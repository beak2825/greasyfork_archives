// ==UserScript==
// @name         Symfony 翻译文档 routing.html
// @namespace    fireloong
// @version      0.1.5
// @description  翻译文档 routing.html
// @author       Itsky71
// @match        https://symfony.com/doc/5.x/routing.html
// @match        https://symfony.com/doc/6.4/routing.html
// @match        https://symfony.com/doc/7.1/routing.html
// @match        https://symfony.com/doc/7.2/routing.html
// @match        https://symfony.com/doc/current/routing.html
// @icon         https://www.google.com/s2/favicons?sz=64&domain=symfony.com
// @require      https://unpkg.com/jquery@3.7.1/dist/jquery.min.js
// @require      https://update.greasyfork.org/scripts/503008/fanyi.js
// @grant        none
// @license      MIT
// @downloadURL https://update.greasyfork.org/scripts/494559/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20routinghtml.user.js
// @updateURL https://update.greasyfork.org/scripts/494559/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20routinghtml.meta.js
// ==/UserScript==

(function($) {
    'use strict';

    const translates = {
        '\n        \n                    Routing\n        \n            ': '路由',
        'Creating Routes': '创建路由',
        'Creating Routes as Attributes': '将路由创建为注解',
        'Creating Routes in YAML, XML or PHP Files': '在 YAML、XML 或 PHP 文件中创建路由',
        'Matching HTTP Methods': 'HTTP 方法匹配',
        'Matching Expressions': '匹配的表达式',
        'Debugging Routes': '调试路由',
        'Route Parameters': '路由参数',
        'Parameters Validation': '参数验证',
        'Optional Parameters': '可选参数',
        'Priority Parameter': '优先级参数',
        'Parameter Conversion': '参数转换',
        'Backed Enum Parameters': '参数说明',
        'Special Parameters': '特殊参数',
        'Extra Parameters': '额外参数',
        'Slash Characters in Route Parameters': '路由参数中的斜杠字符',
        'Route Aliasing': '路由别名',
        'Deprecating Route Aliases': '弃用路由别名',
        'Route Groups and Prefixes': '路由组和前缀',
        'Getting the Route Name and Parameters': '获取路由名称和参数',
        'Special Routes': '特殊路由',
        'Rendering a Template Directly from a Route': '直接从路由中渲染模板',
        'Redirecting to URLs and Routes Directly from a Route': '直接从路由重定向到 URL 和路由',
        'Sub-Domain Routing': '子域路由',
        'Localized Routes (i18n)': '本地化路由(i18n)',
        'Stateless Routes': '无状态的路由',
        'Generating URLs': '生成 URL',
        'Generating URLs in Controllers': '在控制器中生成 URL',
        'Generating URLs in Services': '在服务中生成 URL',
        'Generating URLs in Templates': '在模板中生成 URL',
        'Generating URLs in JavaScript': '用 JavaScript 生成 URL',
        'Generating URLs in Commands': '在命令中生成 URL',
        'Checking if a Route Exists': '检查路由是否存在',
        'Forcing HTTPS on Generated URLs': '对生成的 URL 强制使用 HTTPS',
        'Signing URIs': '签署 URI',
        'Troubleshooting': '故障排除',
        'When your application receives a request, it calls a\ncontroller action to generate the response. The routing\nconfiguration defines which action to run for each incoming URL. It also\nprovides other useful features, like generating SEO-friendly URLs (e.g.\n/read/intro-to-symfony instead of index.php?article_id=57).': '当应用程序接收到请求时，它调用<a href="controller.html" class="reference internal">控制器动作</a>来生成响应。路由配置定义了对每个传入 URL 运行哪个操作。它还提供了其它有用的功能，如生成 SEO 友好的 URL(例如 <code translate="no" class="notranslate">/read/intro-to-symfony</code> 而不是 <code translate="no" class="notranslate">index.php?article_id=57</code>)。',
        "Routes can be configured in YAML, XML, PHP or using attributes.\nAll formats provide the same features and performance, so choose\nyour favorite.\nSymfony recommends attributes\nbecause it's convenient to put the route and controller in the same place.": '路由可以用 YAML、XML、PHP 或使用注解来配置。所有格式提供相同的功能和性能，因此选择您最喜欢的。<a href="best_practices.html#best-practice-controller-attributes" class="reference internal">Symfony 推荐使用注解</a>，因为将路由和控制器放在同一个地方很方便。',
        'PHP attributes allow to define routes next to the code of the\ncontrollers associated to those routes. Attributes are\nnative in PHP 8 and higher versions, so you can use them right away.': 'PHP 注解允许在与这些路由关联的<a href="controller.html" class="reference internal">控制器</a>代码旁边定义路由。注解在 PHP 8 及更高版本中是原生的，因此您可以立即使用它们。',
        'You need to add a bit of configuration to your project before using them. If your\nproject uses Symfony Flex, this file is already created for you.\nOtherwise, create the following file manually:': '在使用它们之前，您需要向您的项目添加一些配置。如果您的项目使用 <a href="setup.html#symfony-flex" class="reference internal">Symfony Flex</a>，则已经为您创建了该文件。否则，请手动创建如下文件：',
        'This configuration tells Symfony to look for routes defined as attributes on\nclasses declared in the App\\Controller namespace and stored in the\nsrc/Controller/ directory which follows the PSR-4 standard. The kernel can\nact as a controller too, which is especially useful for small applications that\nuse Symfony as a microframework.': '这个配置告诉 Symfony 查找在 <code translate="no" class="notranslate">App\\Controller</code> 命名空间中声明的类中定义为属性的路由，并存储在遵循 PSR-4 标准的 <code translate="no" class="notranslate">src/Controller/</code> 目录中。内核也可以充当控制器，这对于使用 Symfony 作为微框架的小型应用程序尤其有用。',
        'The feature to import routes from a PSR-4 namespace root was introduced in Symfony 6.2.': '从 PSR-4 命名空间根目录导入路由的特性是在 Symfony 6.2 中引入的。',
        'Suppose you want to define a route for the /blog URL in your application. To\ndo so, create a controller class like the following:': '假设您想在应用程序中为 <code translate="no" class="notranslate">/blog</code> URL 定义一条路由。为此，创建一个如下所示的<a href="controller.html" class="reference internal">控制器类</a>：',
        'This configuration defines a route called blog_list that matches when the\nuser requests the /blog URL. When the match occurs, the application runs\nthe list() method of the BlogController class.': '这个配置定义了一个名为 <code translate="no" class="notranslate">blog_list</code> 的路由，它匹配用户请求 <code translate="no" class="notranslate">/blog</code> 的 URL。当匹配发生时，应用程序运行 <code translate="no" class="notranslate">BlogController</code> 类的 <code translate="no" class="notranslate">list()</code> 方法。',
        'The query string of a URL is not considered when matching routes. In this\nexample, URLs like /blog?foo=bar and /blog?foo=bar&bar=foo will\nalso match the blog_list route.': '匹配路由时不考虑 URL 的查询字符串。在本例中，像 <code translate="no" class="notranslate">/blog?foo=bar</code> 和 <code translate="no" class="notranslate">/blog?foo=bar&amp;bar=foo</code> 也将匹配 <code translate="no" class="notranslate">blog_list</code> 路由。',
        'If you define multiple PHP classes in the same file, Symfony only loads the\nroutes of the first class, ignoring all the other routes.': '如果在同一个文件中定义多个 PHP 类，Symfony 只加载第一个类的路由，而忽略其它所有的路由。',
        'The route name (blog_list) is not important for now, but it will be\nessential later when generating URLs. You only\nhave to keep in mind that each route name must be unique in the application.': '路由名(<code translate="no" class="notranslate">blog_list</code>)现在并不重要，但是在以后<a href="routing.html#routing-generating-urls" class="reference internal">生成 URL</a> 时它将是必不可少的。你只需要记住，每个路由名在应用程序中必须是唯一的。',
        "Instead of defining routes in the controller classes, you can define them in a\nseparate YAML, XML or PHP file. The main advantage is that they don't require\nany extra dependency. The main drawback is that you have to work with multiple\nfiles when checking the routing of some controller action.": '你可以在单独的 YAML、XML 或 PHP 文件中定义路由，而不是在控制器类中定义路由。主要优点是它们不需要任何额外的依赖项。主要缺点是，在检查某些控制器动作的路由时，必须处理多个文件。',
        'The following example shows how to define in YAML/XML/PHP a route called\nblog_list that associates the /blog URL with the list() action of\nthe BlogController:': '下面的例子展示了如何在 YAML/XML/PHP 中定义一个名为 <code translate="no" class="notranslate">blog_list</code> 的路由，该路由将 <code translate="no" class="notranslate">/blog</code> URL 与 <code translate="no" class="notranslate">BlogController</code> 的 <code translate="no" class="notranslate">list()</code> 动作关联起来：',
        'By default Symfony only loads the routes defined in YAML format. If you\ndefine routes in XML and/or PHP formats, you need to\nupdate the src/Kernel.php file.': '默认情况下，Symfony 只加载以 YAML 格式定义的路由。如果你用 XML 和/或 PHP 格式定义路由，你需要更新 <a href="configuration.html#configuration-formats" class="reference internal">update the src/Kernel.php 文件</a>。',
        'By default, routes match any HTTP verb (GET, POST, PUT, etc.)\nUse the methods option to restrict the verbs each route should respond to:': '默认情况下，路由匹配任何 HTTP 动词(<code translate="no" class="notranslate">GET</code>、<code translate="no" class="notranslate">POST</code>、<code translate="no" class="notranslate">PUT</code> 等)。使用 <code translate="no" class="notranslate">methods</code> 选项来限制每个路由应该响应的动词：',
        'HTML forms only support GET and POST methods. If you\'re calling a\nroute with a different method from an HTML form, add a hidden field called\n_method with the method to use (e.g. <input type="hidden" name="_method" value="PUT">).\nIf you create your forms with Symfony Forms this is done\nautomatically for you when the framework.http_method_override\noption is true.': 'HTML 表单只支持 <code translate="no" class="notranslate">GET</code> 和 <code translate="no" class="notranslate">POST</code> 方法。如果你在 HTML 表单中使用不同的方法调用路由，添加一个名为 <code translate="no" class="notranslate">_method</code> 的隐藏字段，其中包含要使用的方法(例如 <code translate="no" class="notranslate">&lt;input type="hidden" name="_method" value="PUT"&gt;</code>)。如果你用 <a href="forms.html" class="reference internal">Symfony Forms</a> 创建表单，当 <a href="reference/configuration/framework.html#configuration-framework-http_method_override" class="reference internal">framework.http_method_override</a> 选项为 <code translate="no" class="notranslate">true</code> 时，它会自动为你完成。',
        'Use the condition option if you need some route to match based on some\narbitrary matching logic:': '如果你需要一些基于任意匹配逻辑的路由匹配，可以使用 <code translate="no" class="notranslate">condition</code> 选项：',
        'The value of the condition option is an expression using any valid\nexpression language syntax and\ncan use any of these variables created by Symfony:': '<code translate="no" class="notranslate">condition</code> 选项的值是一个使用任何有效<a href="reference/formats/expression_language.html" class="reference internal">表达式语言语法</a>的表达式，并且可以使用 Symfony 创建的以下任何变量：',
        '\n                            An instance of RequestContext,\nwhich holds the most fundamental information about the route being matched.\n                    ': '<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Routing/RequestContext.php" class="reference external" title="Symfony\Component\Routing\RequestContext" rel="external noopener noreferrer" target="_blank">RequestContext</a> 的一个实例，它保存了关于正在匹配的路由的最基本的信息。',
        '\n                            The Symfony Request object that\nrepresents the current request.\n                    ': '表示当前请求的 <a href="components/http_foundation.html#component-http-foundation-request" class="reference internal">Symfony Request</a> 对象。',
        '\n                            An array of matched route parameters for\nthe current route.\n                    ': '与当前路由匹配的<a href="routing.html#routing-route-parameters" class="reference internal">路由参数</a>数组。',
        'The params variable was introduced in Symfony 6.1.': '<code translate="no" class="notranslate">params</code> 变量是在 Symfony 6.1 中引入的。',
        'You can also use these functions:': '你也可以使用这些函数：',
        '\n                            Returns the value of a variable using Environment Variable Processors\n                    ': '使用<a href="configuration/env_var_processors.html" class="reference internal">环境变量处理器</a>返回变量的值',
        'Returns a routing condition service.': '返回路由条件服务。',
        'First, add the #[AsRoutingConditionService] attribute or routing.condition_service\ntag to the services that you want to use in route conditions:': '首先，将 <code translate="no" class="notranslate">#[AsRoutingConditionService]</code> 注解或 <code translate="no" class="notranslate">routing.condition_service</code> 标签添加到你想在路由条件中使用的服务中：',
        'Then, use the service() function to refer to that service inside conditions:': '然后，使用 <code translate="no" class="notranslate">service()</code> 函数在条件中引用该服务：',
        'The service(string $alias) function and #[AsRoutingConditionService]\nattribute were introduced in Symfony 6.1.': '<code translate="no" class="notranslate">service(string $alias)</code> 函数和 <code translate="no" class="notranslate">#[AsRoutingConditionService]</code> 注解是在 Symfony 6.1 中引入的。',
        'Behind the scenes, expressions are compiled down to raw PHP. Because of this,\nusing the condition key causes no extra overhead beyond the time it takes\nfor the underlying PHP to execute.': '在后台，表达式被编译为原始 PHP。因此，除了底层 PHP 执行所需的时间外，使用 <code translate="no" class="notranslate">condition</code> 键不会造成额外的开销。',
        'Conditions are not taken into account when generating URLs (which is\nexplained later in this article).': '在生成 URL 时不考虑条件(本文稍后将对此进行解释)。',
        "As your application grows, you'll eventually have a lot of routes. Symfony\nincludes some commands to help you debug routing issues. First, the debug:router\ncommand lists all your application routes in the same order in which Symfony\nevaluates them:": '随着应用程序的增长，最终会有很多路由。Symfony 包含一些命令来帮助您调试路由问题。首先，<code translate="no" class="notranslate">debug:router</code> 命令以 Symfony 计算它们的顺序列出所有应用程序路由：',
        'Pass the name (or part of the name) of some route to this argument to print the\nroute details:': '将某个路由的名称(或名称的一部分)传递给这个参数，以打印路由的详细信息：',
        'Use the --show-aliases option to show all available aliases for a given\nroute.': '使用 <code translate="no" class="notranslate">--show-aliases</code> 选项显示给定路由的所有可用别名。',
        'The --show-aliases option was introduced in Symfony 6.4.': '<code translate="no" class="notranslate">--show-aliases</code> 选项是在 Symfony 6.4 中引入的。',
        "The other command is called router:match and it shows which route will match\nthe given URL. It's useful to find out why some URL is not executing the\ncontroller action that you expect:": '另一个命令叫做 <code translate="no" class="notranslate">router:match</code>，它显示哪个路由将匹配给定的URL。找出为什么一些URL没有执行你期望的控制器动作是有用的：',
        "The previous examples defined routes where the URL never changes (e.g. /blog).\nHowever, it's common to define routes where some parts are variable. For example,\nthe URL to display some blog post will probably include the title or slug\n(e.g. /blog/my-first-post or /blog/all-about-symfony).": '前面的例子定义了 URL 永远不变的路由(例如 <code translate="no" class="notranslate">/blog</code>)。然而，在定义路由时，某些部分是可变的，这是很常见的。例如，显示某些博客文章的 URL 可能包含标题或标记(例如 <code translate="no" class="notranslate">/blog/my-first-post</code> 或 <code translate="no" class="notranslate">/blog/all-about-symfony</code>)。',
        'In Symfony routes, variable parts are wrapped in { }.\nFor example, the route to display the blog post contents is defined as /blog/{slug}:': '在 Symfony 路由中，变量部分被包装在 <code translate="no" class="notranslate">{ }</code> 中。例如，显示博客文章内容的路由定义为 <code translate="no" class="notranslate">/blog/{slug}</code>：',
        "The name of the variable part ({slug} in this example) is used to create a\nPHP variable where that route content is stored and passed to the controller.\nIf a user visits the /blog/my-first-post URL, Symfony executes the show()\nmethod in the BlogController class and passes a $slug = 'my-first-post'\nargument to the show() method.": '变量部分的名称（本例中的 <code translate="no" class="notranslate">{slug}</code>）用于创建一个 PHP 变量，用于存储该路由的内容并传递给控制器。如果用户访问 <code translate="no" class="notranslate">/blog/my-first-post</code> URL，Symfony 就会执行 <code translate="no" class="notranslate">BlogController</code> 类中的 <code translate="no" class="notranslate">show()</code> 方法，并将 <code translate="no" class="notranslate">$slug = \'my-first-post\'</code> 的参数传递给 <code translate="no" class="notranslate">show()</code> 方法。',
        'Routes can define any number of parameters, but each of them can only be used\nonce on each route (e.g. /blog/posts-about-{category}/page/{pageNumber}).': '路由可以定义任意数量的参数，但每个参数只能在每条路由上使用一次(例如 <code translate="no" class="notranslate">/blog/posts-about-{category}/page/{pageNumber}</code>)。',
        "Imagine that your application has a blog_show route (URL: /blog/{slug})\nand a blog_list route (URL: /blog/{page}). Given that route parameters\naccept any value, there's no way to differentiate both routes.": '假设您的应用程序有一个 <code translate="no" class="notranslate">blog_show</code> 路由(URL：<code translate="no" class="notranslate">/blog/{slug}</code>)和一个 <code translate="no" class="notranslate">blog_list</code> 路由(URL：<code translate="no" class="notranslate">/blog/{page}</code>)。由于路由参数接受任意值，因此无法区分这两种路由。',
        'If the user requests /blog/my-first-post, both routes will match and Symfony\nwill use the route which was defined first. To fix this, add some validation to\nthe {page} parameter using the requirements option:': '如果用户请求 <code translate="no" class="notranslate">/blog/my-first-post</code>，两个路由都将匹配，Symfony 将使用先定义的路由。要解决这个问题，可以使用  <code translate="no" class="notranslate">requirements</code> 选项向 <code translate="no" class="notranslate">{page}</code> 参数添加一些验证：',
        'The requirements option defines the PHP regular expressions that route\nparameters must match for the entire route to match. In this example, \\d+ is\na regular expression that matches a digit of any length. Now:': '<code translate="no" class="notranslate">requirements</code> 选项定义了要匹配整个路由，路由参数必须匹配的 <a href="https://www.php.net/manual/zh/book.pcre.php" class="reference external" rel="external noopener noreferrer" target="_blank">PHP 正则表达式</a>。在本例中，<code translate="no" class="notranslate">\\d+</code> 是一个正则表达式，它匹配任意长度的数字。现在：',
        'The Requirement enum\ncontains a collection of commonly used regular-expression constants such as\ndigits, dates and UUIDs which can be used as route parameter requirements.': '<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Routing/Requirement/Requirement.php" class="reference external" title="Symfony\Component\Routing\Requirement\Requirement" rel="external noopener noreferrer" target="_blank">Requirement</a> 枚举包含一组常用的正则表达式常量，如数字、日期和 uuid，这些常量可以用作路由参数要求。',
        'The Requirement enum was introduced in Symfony 6.1.': '<code translate="no" class="notranslate">Requirement</code> 枚举是在 Symfony 6.1 中引入的。',
        'Route requirements (and route paths too) can include\nconfiguration parameters, which is useful to\ndefine complex regular expressions once and reuse them in multiple routes.': '路由需求(以及路由路径)可以包含<a href="configuration.html#configuration-parameters" class="reference internal">配置参数</a>，这对于一次性定义复杂的正则表达式并在多个路由中重用它们非常有用。',
        'Parameters also support PCRE Unicode properties, which are escape\nsequences that match generic character types. For example, \\p{Lu}\nmatches any uppercase character in any language, \\p{Greek} matches any\nGreek characters, etc.': '参数还支持 <a href="https://www.php.net/manual/zh/regexp.reference.unicode.php" class="reference external" rel="external noopener noreferrer" target="_blank">PCRE Unicode 字符属性</a>，这些属性是匹配通用字符类型的转义序列。例如，<code translate="no" class="notranslate">\\p{Lu}</code> 匹配任何语言中的任何大写字符，<code translate="no" class="notranslate">\p{Greek}</code>匹配任何希腊字符，等等。',
        'When using regular expressions in route parameters, you can set the utf8\nroute option to true to make any . character match any UTF-8\ncharacters instead of just a single byte.': '当在路由参数中使用正则表达式时，您可以将 <code translate="no" class="notranslate">utf8</code> 路由选项设置为 <code translate="no" class="notranslate">true</code>，以使任何 <code translate="no" class="notranslate">.</code> 字符匹配任何 UTF-8 字符，而不仅仅是单个字节。',
        'If you prefer, requirements can be inlined in each parameter using the syntax\n{parameter_name<requirements>}. This feature makes configuration more\nconcise, but it can decrease route readability when requirements are complex:': '如果您愿意，可以使用语法 <code translate="no" class="notranslate">{parameter_name&lt;requirements&gt;}</code> 将需求内联到每个参数中。该特性使配置更简洁，但当需求复杂时，它会降低路由的可读性：',
        'In the previous example, the URL of blog_list is /blog/{page}. If users\nvisit /blog/1, it will match. But if they visit /blog, it will not\nmatch. As soon as you add a parameter to a route, it must have a value.': '在前面的例子中，<code translate="no" class="notranslate">blog_list</code> 的 URL 是 <code translate="no" class="notranslate">/blog/{page}</code>。如果用户访问 <code translate="no" class="notranslate">/blog/1</code>，它将匹配。但如果访问 <code translate="no" class="notranslate">/blog</code>，它将不匹配。一旦你给路由添加了一个参数，它就必须有一个值。',
        'You can make blog_list once again match when the user visits /blog by\nadding a default value for the {page} parameter. When using attributes,\ndefault values are defined in the arguments of the controller action. In the\nother configuration formats they are defined with the defaults option:': '当用户访问 <code translate="no" class="notranslate">/blog</code> 时，您可以通过为 <code translate="no" class="notranslate">{page}</code> 参数添加默认值来使 <code translate="no" class="notranslate">blog_list</code> 再次匹配。使用属性时，默认值是在控制器动作的参数中定义的。在其它配置格式中，它们被定义为 <code translate="no" class="notranslate">defaults</code> 选项：',
        'Now, when the user visits /blog, the blog_list route will match and\n$page will default to a value of 1.': '现在，当用户访问 <code translate="no" class="notranslate">/blog</code> 时，将匹配 <code translate="no" class="notranslate">blog_list</code> 路由，并且 <code translate="no" class="notranslate">$page</code> 将默认为 <code translate="no" class="notranslate">1</code>。',
        'You can have more than one optional parameter (e.g. /blog/{slug}/{page}),\nbut everything after an optional parameter must be optional. For example,\n/{page}/blog is a valid path, but page will always be required\n(i.e. /blog will not match this route).': '可以有多个可选参数(例如 <code translate="no" class="notranslate">/blog/{slug}/{page}</code>)，但可选参数之后的所有内容都必须是可选的。例如，<code translate="no" class="notranslate">/{page}/blog</code> 是一个有效的路径，但是 <code translate="no" class="notranslate">page</code> 总是必需的(即 <code translate="no" class="notranslate">/blog</code> 将不匹配此路由)。',
        'If you want to always include some default value in the generated URL (for\nexample to force the generation of /blog/1 instead of /blog in the\nprevious example) add the ! character before the parameter name: /blog/{!page}': '如果您希望在生成的 URL 中始终包含一些默认值(例如，在前面的示例中强制生成 <code translate="no" class="notranslate">/blog/1</code> 而不是 <code translate="no" class="notranslate">/blog</code>)，参数名称前请添加 <code translate="no" class="notranslate">!</code> 字符：<code translate="no" class="notranslate">/blog/{!page}</code>',
        'As it happens with requirements, default values can also be inlined in each\nparameter using the syntax {parameter_name?default_value}. This feature\nis compatible with inlined requirements, so you can inline both in a single\nparameter:': '与需求一样，也可以使用语法 <code translate="no" class="notranslate">{parameter_name?default_value}</code> 将默认值内联到每个参数中。此功能与内联需求兼容，因此您可以在单个参数中内联两者：',
        "To give a null default value to any parameter, add nothing after the\n? character (e.g. /blog/{page?}). If you do this, don't forget to\nupdate the types of the related controller arguments to allow passing\nnull values (e.g. replace int $page by ?int $page).": '要给任何参数一个 <code translate="no" class="notranslate">null</code> 的默认值，在 <code translate="no" class="notranslate">?</code> 字符后不添加任何东西(例如 <code translate="no" class="notranslate">/blog/{page?}</code>)。如果你这样做，不要忘记更新相关控制器参数的类型以允许传递 <code translate="no" class="notranslate">null</code> 值(例如用 <code translate="no" class="notranslate">?int $page</code> 替换 <code translate="no" class="notranslate">int $page</code>)。',
        'Symfony evaluates routes in the order they are defined. If the path of a route\nmatches many different patterns, it might prevent other routes from being\nmatched. In YAML and XML you can move the route definitions up or down in the\nconfiguration file to control their priority. In routes defined as PHP\nattributes this is much harder to do, so you can set the\noptional priority parameter in those routes to control their priority:': 'Symfony 按照定义路由的顺序计算路由。如果一条路由的路径匹配许多不同的模式，它可能会阻止其它路由被匹配。在 YAML 和 XML 中，您可以在配置文件中上下移动路由定义，以控制它们的优先级。在定义为 PHP 注解的路由中，这很难做到，所以你可以在这些路由中设置可选的 <code translate="no" class="notranslate">priority</code> 参数来控制它们的优先级：',
        'The priority parameter expects an integer value. Routes with higher priority\nare sorted before routes with lower priority. The default value when it is not\ndefined is 0.': '优先级参数需要一个整数值。优先级高的路由排在优先级低的路由之前。未定义时的默认值为 <code translate="no" class="notranslate">0</code>。',
        'A common routing need is to convert the value stored in some parameter (e.g. an\ninteger acting as the user ID) into another value (e.g. the object that\nrepresents the user). This feature is called a "param converter".': '一个常见的路由需求是将存储在某些参数中的值(例如，作为用户 ID 的整数)转换为另一个值(例如，代表用户的对象)。这个特性被称为“参数转换器”。',
        'Starting from Symfony 6.2, route param conversion is a built-in feature.\nIn previous Symfony versions you had to install the package\nsensio/framework-extra-bundle before using this feature.': '从Symfony 6.2 开始，路由参数转换是一个内置特性。在以前的 Symfony 版本中，您必须在使用此特性之前安装软件包 <code translate="no" class="notranslate">sensio/framework-extra-bundle</code>。',
        'Now, keep the previous route configuration, but change the arguments of the\ncontroller action. Instead of string $slug, add BlogPost $post:': '现在，保持前面的路由配置，但是改变控制器动作的参数。代替 <code translate="no" class="notranslate">string $slug</code>，添加 <code translate="no" class="notranslate">BlogPost $post</code>：',
        'If your controller arguments include type-hints for objects (BlogPost in\nthis case), the "param converter" makes a database request to find the object\nusing the request parameters (slug in this case). If no object is found,\nSymfony generates a 404 response automatically.': '如果您的控制器参数包含对象的类型提示(在本例中为 <code translate="no" class="notranslate">BlogPost</code>)，“参数转换器”将使用请求参数(在本例中为 <code translate="no" class="notranslate">slug</code>)发出数据库请求以查找对象。如果没有找到对象，Symfony 将自动生成 404 响应。',
        'Check out the Doctrine param conversion documentation\nto learn about the #[MapEntity] attribute that can be used to customize the\ndatabase queries used to fetch the object from the route parameter.': '查看 <a href="doctrine.html#doctrine-entity-value-resolver" class="reference internal">Doctrine 参数转换文档</a>，了解 <code translate="no" class="notranslate">#[MapEntity]</code> 注解，该属性可用于定制用于从路由参数中获取对象的数据库查询。',
        'You can use PHP backed enumerations as route parameters because Symfony will\nconvert them automatically to their scalar values.': '您可以使用 PHP <a href="https://www.php.net/manual/zh/language.enumerations.backed.php" class="reference external" rel="external noopener noreferrer" target="_blank">回退（Backed）枚举</a>作为路由参数，因为 Symfony 会自动将它们转换为标量值。',
        'In addition to your own parameters, routes can include any of the following\nspecial parameters created by Symfony:': '除了你自己的参数外，路由还可以包含以下任何由 Symfony 创建的特殊参数：',
        '\n                            This parameter is used to determine which controller and action is executed\nwhen the route is matched.\n                    ': '该参数用于确定匹配路由时执行哪个控制器和动作。',
        '\n                            The matched value is used to set the "request format" of the Request object.\nThis is used for such things as setting the Content-Type of the response\n(e.g. a json format translates into a Content-Type of application/json).\n                    ': '匹配的值用于设置 <code translate="no" class="notranslate">Request</code> 对象的“请求格式”。这用于设置响应的 <code translate="no" class="notranslate">Content-Type</code> (例如 <code translate="no" class="notranslate">json</code> 格式转换为 <code translate="no" class="notranslate">application/json</code> 的 <code translate="no" class="notranslate">Content-Type</code>)。',
        '\n                            Used to set the fragment identifier, which is the optional last part of a URL that\nstarts with a # character and is used to identify a portion of a document.\n                    ': '用于设置片段标识符，片段标识符是以 <code translate="no" class="notranslate">#</code> 字符开头的 URL 的可选最后部分，用于标识文档的一部分。',
        '\n                            Used to set the locale on the request.\n                    ': '用于设置请求上的<a href="translation.html#translation-locale-url" class="reference internal">区域</a>设置。',
        'You can include these attributes (except _fragment) both in individual routes\nand in route imports. Symfony defines some special attributes with the same name\n(except for the leading underscore) so you can define them easier:': '你可以在单独的路由和路由导入中包含这些属性(除了 <code translate="no" class="notranslate">_fragment</code>)。Symfony 定义了一些具有相同名称的特殊属性(除了前导下划线)，以便您可以更轻松地定义它们：',
        'In the defaults option of a route you can optionally define parameters not\nincluded in the route configuration. This is useful to pass extra arguments to\nthe controllers of the routes:': '在路由的 <code translate="no" class="notranslate">defaults</code> 选项中，您可以选择定义路由配置中不包含的参数。这对于向路由的控制器传递额外的参数很有用：',
        "Route parameters can contain any values except the / slash character,\nbecause that's the character used to separate the different parts of the URLs.\nFor example, if the token value in the /share/{token} route contains a\n/ character, this route won't match.": '路由参数可以包含除 <code translate="no" class="notranslate">/</code> 斜杠字符之外的任何值，因为这个字符用于分隔 URL 的不同部分。例如，如果 <code translate="no" class="notranslate">/share/{token}</code> 路由中的 <code translate="no" class="notranslate">token</code> 值包含一个 <code translate="no" class="notranslate">/</code> 字符，则该路由将不匹配。',
        'A possible solution is to change the parameter requirements to be more permissive:': '一个可能的解决方案是将参数要求更改为更宽松的：',
        'If the route defines several parameters and you apply this permissive\nregular expression to all of them, you might get unexpected results. For\nexample, if the route definition is /share/{path}/{token} and both\npath and token accept /, then token will only get the last part\nand the rest is matched by path.': '如果路由定义了几个参数，并且您将这个允许的正则表达式应用于所有参数，那么您可能会得到意想不到的结果。例如，如果路由定义是 <code translate="no" class="notranslate">/share/{path}/{token}</code>，并且 <code translate="no" class="notranslate">path</code> 和 <code translate="no" class="notranslate">token</code> 都接受 <code translate="no" class="notranslate">/</code>，那么 <code translate="no" class="notranslate">token</code> 将只获取最后一部分，其余部分由 <code translate="no" class="notranslate">path</code> 匹配。',
        "If the route includes the special {_format} parameter, you shouldn't\nuse the .+ requirement for the parameters that allow slashes. For example,\nif the pattern is /share/{token}.{_format} and {token} allows any\ncharacter, the /share/foo/bar.json URL will consider foo/bar.json\nas the token and the format will be empty. This can be solved by replacing\nthe .+ requirement by [^.]+ to allow any character except dots.": '如果路由包含特殊的 <code translate="no" class="notranslate">{_format}</code> 参数，则不应该对允许斜杠的参数使用 <code translate="no" class="notranslate">.+</code> 要求。例如，如果模式是 <code translate="no" class="notranslate">/share/{token}.{_format}</code> 并且 <code translate="no" class="notranslate">{token}</code> 允许任何字符，则 <code translate="no" class="notranslate">/share/foo/bar.json</code> URL 将考虑 <code translate="no" class="notranslate">foo/bar.json</code> 作为令牌，格式将为空。这可以通过用 <code translate="no" class="notranslate">[^.]+</code> 替换 <code translate="no" class="notranslate">.+</code> 要求来解决，以允许除点以外的任何字符。',
        'Route alias allow you to have multiple name for the same route:': '路由别名允许你为同一条路由设置多个名称：',
        'In this example, both original_route_name and new_route_name routes can\nbe used in the application and will produce the same result.': '在这个例子中，<code translate="no" class="notranslate">original_route_name</code> 和 <code translate="no" class="notranslate">new_route_name</code> 路由都可以在应用程序中使用，并且会产生相同的结果。',
        'If some route alias should no longer be used (because it is outdated or\nyou decided not to maintain it anymore), you can deprecate its definition:': '如果某些路由别名不应该再被使用(因为它过时了或者你决定不再维护它)，你可以弃用它的定义：',
        'In this example, every time the new_route_name alias is used, a deprecation\nwarning is triggered, advising you to stop using that alias.': '在本例中，每次使用 <code translate="no" class="notranslate">new_route_name</code> 别名时，都会触发一个弃用警告，建议您停止使用该别名。',
        'The message is actually a message template, which replaces occurrences of the\n%alias_id% placeholder by the route alias name. You must have\nat least one occurrence of the %alias_id% placeholder in your template.': '该消息实际上是一个消息模板，它用路由别名替换 <code translate="no" class="notranslate">%alias_id%</code> 占位符的出现。在模板中<strong>必须</strong>至少出现一个 <code translate="no" class="notranslate">%alias_id%</code> 占位符。',
         "It's common for a group of routes to share some options (e.g. all routes related\nto the blog start with /blog) That's why Symfony includes a feature to share\nroute configuration.": '一组路由共享一些选项是很常见的(例如，所有与博客相关的路由都以 <code translate="no" class="notranslate">/blog</code> 开头)，这就是为什么 Symfony 包含了共享路由配置的特性。',
        'When defining routes as attributes, put the common configuration\nin the #[Route] attribute of the controller class.\nIn other routing formats, define the common configuration using options\nwhen importing the routes.': '当将路由定义为注解时，将通用配置放在控制器类的 <code translate="no" class="notranslate">#[Route]</code> 注解中。对于其它路由格式，在引入路由时使用选项定义通用配置。',
        'In this example, the route of the index() action will be called blog_index\nand its URL will be /blog/{_locale}. The route of the show() action will be called\nblog_show and its URL will be /blog/{_locale}/posts/{slug}. Both routes\nwill also validate that the _locale parameter matches the regular expression\ndefined in the class attribute.': '在这个例子中，<code translate="no" class="notranslate">index()</code> 动作的路由将被称为 <code translate="no" class="notranslate">blog_index</code>，它的 URL 将是 <code translate="no" class="notranslate">/blog/{_locale}</code>。<code translate="no" class="notranslate">show()</code> 动作的路由将被称为 <code translate="no" class="notranslate">blog_show</code>，它的 URL 将是 <code translate="no" class="notranslate">/blog/{_locale}/posts/{slug}</code>。这两个路由还将验证 <code translate="no" class="notranslate">_locale</code> 参数是否与类属性中定义的正则表达式匹配。',
        'If any of the prefixed routes defines an empty path, Symfony adds a trailing\nslash to it. In the previous example, an empty path prefixed with /blog\nwill result in the /blog/ URL. If you want to avoid this behavior, set\nthe trailing_slash_on_root option to false (this option is not\navailable when using PHP attributes):': '如果任何带前缀的路由定义了一个空路径，Symfony 将在其后面添加一个斜杠。在前面的示例中，以 <code translate="no" class="notranslate">/blog</code> 为前缀的空路径将产生 <code translate="no" class="notranslate">/blog/</code> URL。如果你想避免这种行为，将 <code translate="no" class="notranslate">trailing_slash_on_root</code> 选项设置为 <code translate="no" class="notranslate">false</code> (该选项在使用 PHP 注解时不可用)：',
        'Symfony can import routes from different sources\nand you can even create your own route loader.': 'Symfony 可以<a href="routing/custom_route_loader.html" class="reference internal">从不同的来源导入路由</a>，你甚至可以创建自己的路由加载器。',
        'The Request object created by Symfony stores all the route configuration\n(such as the name and parameters) in the "request attributes". You can get this\ninformation in a controller via the Request object:': '由 Symfony 创建的 <code translate="no" class="notranslate">Request</code> 对象将所有的路由配置(如名称和参数)存储在“请求属性”中。你可以通过 <code translate="no" class="notranslate">Request</code> 对象在控制器中获取这些信息：',
        'In services, you can get this information by\ninjecting the RequestStack service.\nIn templates, use the Twig global app variable\nto get the current route name (app.current_route) and its parameters\n(app.current_route_parameters).': '在服务中，可以通过<a href="service_container/request.html" class="reference internal">注入 RequestStack 服务</a>来获取此信息。在模板中，使用 <a href="templates.html#twig-app-variable" class="reference internal">Twig 全局 app 变量</a>来获取当前路由名(<code translate="no" class="notranslate">app.current_route</code>)及其参数(<code translate="no" class="notranslate">app.current_route_parameters</code>)。',
        'The app.current_route and app.current_route_parameters variables\nwere introduced in Symfony 6.2.\nBefore you had to access _route and _route_params request\nattributes using app.request.attributes.get().': '<code translate="no" class="notranslate">app.current_route</code> 和 <code translate="no" class="notranslate">app.current_route_parameters</code> 变量是在 Symfony 6.2 中引入的。以前，你必须使用 <code translate="no" class="notranslate">app.request.attributes.get()</code> 来访问 <code translate="no" class="notranslate">_route</code> 和 <code translate="no" class="notranslate">_route_params</code> 请求属性。',
        "Symfony defines some special controllers to render templates and redirect to\nother routes from the route configuration so you don't have to create a\ncontroller action.": 'Symfony 定义了一些特殊的控制器来渲染模板，并从路由配置中重定向到其它路由，这样你就不必创建控制器动作了。',
        'Read the section about rendering a template from a route\nin the main article about Symfony templates.': '阅读关于 Symfony 模板的主文章中关于<a href="templates.html#templates-render-from-route" class="reference internal">从路由中渲染模板</a>的部分。',
        'Use the RedirectController to redirect to other routes and URLs:': '使用 <code translate="no" class="notranslate">RedirectController</code> 重定向到其它路由和 URL ：',
        'Symfony also provides some utilities to\nredirect inside controllers': 'Symfony 还提供了一些<a href="controller.html#controller-redirect" class="reference internal">重定向控制器内部</a>的实用程序',
        'Redirecting URLs with Trailing Slashes': '用尾斜杠重定向 URL',
        "Historically, URLs have followed the UNIX convention of adding trailing slashes\nfor directories (e.g. https://example.com/foo/) and removing them to refer\nto files (https://example.com/foo). Although serving different contents for\nboth URLs is OK, nowadays it's common to treat both URLs as the same URL and\nredirect between them.": '历史上，URL 遵循 UNIX 惯例，为目录添加尾部斜杠（例如：<code translate="no" class="notranslate">https://example.com/foo/</code>），并从文件名中删除它们（例如：<code translate="no" class="notranslate">https://example.com/foo</code>）。虽然为这两种 URL 提供不同的内容是可以的，但现在通常将这两种 URL 视为相同的 URL，并在它们之间进行重定向。',
        'Symfony follows this logic to redirect between URLs with and without trailing\nslashes (but only for GET and HEAD requests):': 'Symfony 遵循以下逻辑在带有和不带有尾随斜杠的 URL 之间进行重定向（仅适用于 <code translate="no" class="notranslate">GET</code> 和 <code translate="no" class="notranslate">HEAD</code> 请求）：',
        'Routes can configure a host option to require that the HTTP host of the\nincoming requests matches some specific value. In the following example, both\nroutes match the same path (/) but one of them only responds to a specific\nhost name:': '路由可以配置一个 <code translate="no" class="notranslate">host</code> 选项，要求传入请求的 HTTP 主机匹配某个特定的值。在下面的例子中，两个路由都匹配相同的路径(<code translate="no" class="notranslate">/</code>)，但其中一个只响应特定的主机名：',
        'The value of the host option can include parameters (which is useful in\nmulti-tenant applications) and these parameters can be validated too with\nrequirements:': '<code translate="no" class="notranslate">host</code> 选项的值可以包含参数(这在多租户应用程序中很有用)，这些参数也可以根据 <code translate="no" class="notranslate">requirements</code> 进行验证：',
        'In the above example, the subdomain parameter defines a default value because\notherwise you need to include a subdomain value each time you generate a URL using\nthese routes.': '在上面的例子中，<code translate="no" class="notranslate">subdomain</code> 参数定义了一个默认值，否则每次使用这些路由生成 URL 时都需要包含一个子域值。',
        'You can also set the host option when importing routes\nto make all of them require that host name.': '您还可以在<a href="routing.html#routing-route-groups" class="reference internal">导入路由</a>时设置 <code translate="no" class="notranslate">host</code> 选项，使所有路由都需要该主机名。',
        "When using sub-domain routing, you must set the Host HTTP headers in\nfunctional tests or routes won't match:": '使用子域路由时，必须在<a href="testing.html" class="reference internal">功能测试</a>中设置 <code translate="no" class="notranslate">Host</code> HTTP 标头，否则路由将不匹配：',
        'You can also use the inline defaults and requirements format in the\nhost option: {subdomain<m|mobile>?m}.example.com': '你也可以在 <code translate="no" class="notranslate">host</code> 选项中使用内联默认值和需求格式：<br/><code translate="no" class="notranslate">{subdomain&lt;m|mobile&gt;?m}.example.com</code>',
        'If your application is translated into multiple languages, each route can define\na different URL per each translation locale. This\navoids the need for duplicating routes, which also reduces the potential bugs:': '如果您的应用程序被翻译成多种语言，每个路由可以为每个<a href="translation.html#translation-locale" class="reference internal">翻译语言</a>环境定义不同的 URL。这避免了复制路由的需要，这也减少了潜在的 bug：',
        'When using PHP attributes for localized routes, you have to use the path\nnamed parameter to specify the array of paths.': '将 PHP 注解用于本地化路由时，必须使用 <code translate="no" class="notranslate">path</code> 命名参数来指定路径数组。',
        'When a localized route is matched, Symfony uses the same locale automatically\nduring the entire request.': '当匹配本地化路由时，Symfony 在整个请求过程中自动使用相同的区域设置。',
        'When the application uses full "language + territory" locales (e.g. fr_FR,\nfr_BE), if the URLs are the same in all related locales, routes can use\nonly the language part (e.g. fr) to avoid repeating the same URLs.': '当应用程序使用完整的“语言+区域”区域设置(例如 <code translate="no" class="notranslate">fr_FR</code>，<code translate="no" class="notranslate">fr_BE</code>)时，如果 URL 在所有相关的区域设置中是相同的，路由可以只使用语言部分(例如 <code translate="no" class="notranslate">fr</code>)来避免重复相同的 URL。',
        'A common requirement for internationalized applications is to prefix all routes\nwith a locale. This can be done by defining a different prefix for each locale\n(and setting an empty prefix for your default locale if you prefer it):': '国际化应用程序的一个常见需求是在所有路由前加上区域设置前缀。这可以通过为每个语言环境定义不同的前缀来实现(如果你喜欢，也可以为默认语言环境设置一个空前缀)：',
        'Another common requirement is to host the website on a different domain\naccording to the locale. This can be done by defining a different host for each\nlocale.': '另一个常见的要求是根据区域设置将网站托管在不同的域中。这可以通过为每个区域设置定义不同的 host 来实现。',
        'Sometimes, when an HTTP response should be cached, it is important to ensure\nthat can happen. However, whenever a session is started during a request,\nSymfony turns the response into a private non-cacheable response.': '有时，当应该缓存 HTTP 响应时，重要的是要确保可以缓存。但是，每当在请求期间启动会话时，Symfony 都会将响应转换为私有的不可缓存响应。',
        'For details, see HTTP Cache.': '详细信息请参见 <a href="http_cache.html" class="reference internal">HTTP 缓存</a>。',
        "Routes can configure a stateless boolean option in order to declare that the\nsession shouldn't be used when matching a request:": '路由可以配置一个 <code translate="no" class="notranslate">stateless</code> 布尔选项，以声明在匹配请求时不应该使用会话：',
        'Now, if the session is used, the application will report it based on your\nkernel.debug parameter:': '现在，如果会话被使用，应用程序将根据 <code translate="no" class="notranslate">kernel.debug</code> 参数报告它：',
        'enabled: will throw an UnexpectedSessionUsageException exception': '<code translate="no" class="notranslate">enabled</code>：会抛出一个 <a href="https://github.com/symfony/symfony/blob/6.4/src/Symfony/Component/HttpKernel/Exception/UnexpectedSessionUsageException.php" class="reference external" title="Symfony\Component\HttpKernel\Exception\UnexpectedSessionUsageException" rel="external noopener noreferrer" target="_blank">UnexpectedSessionUsageException</a> 异常',
        'disabled: will log a warning': '<code translate="no" class="notranslate">disabled</code>：将记录一个警告',
        'It will help you understand and hopefully fixing unexpected behavior in your application.': '它将帮助您理解并修复应用程序中的意外行为。',
        'Routing systems are bidirectional:': '路由系统是双向的：',
        'they associate URLs with controllers (as explained in the previous sections);': '它们将 URL 与控制器关联起来(如前几节所述)；',
        'they generate URLs for a given route.': '它们为给定的路由生成 URL。',
        'Generating URLs from routes allows you to not write the <a href="...">\nvalues manually in your HTML templates. Also, if the URL of some route changes,\nyou only have to update the route configuration and all links will be updated.': '通过路由生成 URL，可以不在 HTML 模板中手动写入 <code translate="no" class="notranslate">&lt;a href="..."&gt;</code> 值。此外，如果某些路由的 URL 发生更改，只需更新路由配置，所有链接都将更新。',
        'To generate a URL, you need to specify the name of the route (e.g.\nblog_show) and the values of the parameters defined by the route (e.g.\nslug = my-blog-post).': '要生成 URL，需要指定路由的名称(例如 <code translate="no" class="notranslate">blog_show</code>)和路由定义的参数值(例如 <code translate="no" class="notranslate">slug = my-blog-post</code>)。',
        "For that reason each route has an internal name that must be unique in the\napplication. If you don't set the route name explicitly with the name\noption, Symfony generates an automatic name based on the controller and action.": '因此，每个路由都有一个内部名称，在应用程序中必须是唯一的。如果你没有使用 <code translate="no" class="notranslate">name</code> 选项显式地设置路由名，Symfony 会根据控制器和动作自动生成一个名称。',
        'Symfony declares route aliases based on the FQCN if the target class has an\n__invoke() method that adds a route and if the target class added\none route exactly. Symfony also automatically adds an alias for every method\nthat defines only one route. Consider the following class:': '如果目标类有 <code translate="no" class="notranslate">__invoke()</code> 方法来添加路由，并且目标类恰好添加了一条路由，那么 Symfony 就会基于 FQCN 声明路由别名。Symfony 还会自动为每个只定义一条路由的方法添加别名。考虑下面的类：',
        'Symfony will add a route alias named App\\Controller\\MainController::homepage.': 'Symfony 将添加一个名为 <code translate="no" class="notranslate">App\\Controller\\MainController::homepage</code> 的路由别名',
        'The automatic declaration of route aliases based on FQCNs was introduced in\nSymfony 6.4.': '在 Symfony 6.4 中引入了基于 FQCN 的路由别名自动声明。',
        'If your controller extends from the AbstractController,\nuse the generateUrl() helper:': '如果您的控制器从 <a href="controller.html#the-base-controller-class-services" class="reference internal">AbstractController</a> 扩展，请使用 <code translate="no" class="notranslate">generateUrl()</code> 助手：',
        'If you pass to the generateUrl() method some parameters that are not\npart of the route definition, they are included in the generated URL as a\nquery string:': '如果你传递给 <code translate="no" class="notranslate">generateUrl()</code> 方法一些不属于路由定义的参数，它们会作为查询字符串包含在生成的 URL 中：',
        "While objects are converted to string when used as placeholders, they are not\nconverted when used as extra parameters. So, if you're passing an object (e.g. an Uuid)\nas value of an extra parameter, you need to explicitly convert it to a string:": '当对象用作占位符时会转换为字符串，但当它们用作额外参数时不会转换。所以，如果你传递一个对象(例如 Uuid)作为额外参数的值，你需要显式地将其转换为字符串：',
        "If your controller does not extend from AbstractController, you'll need to\nfetch services in your controller and\nfollow the instructions of the next section.": '如果您的控制器没有从 <code translate="no" class="notranslate">AbstractController</code> 扩展，则需要<a href="controller.html#controller-accessing-services" class="reference internal">在您的控制器中获取服务</a>，并按照下一节的说明操作。',
        'Inject the router Symfony service into your own services and use its\ngenerate() method. When using service autowiring\nyou only need to add an argument in the service constructor and type-hint it with\nthe UrlGeneratorInterface class:': '将 Symfony 服务 <code translate="no" class="notranslate">router</code> 注入到您自己的服务中，并使用其 <code translate="no" class="notranslate">generate()</code> 方法。当使用<a href="service_container/autowiring.html" class="reference internal">服务自动连接</a>时，您只需要在服务构造函数中添加一个参数，并使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Routing/Generator/UrlGeneratorInterface.php" class="reference external" title="Symfony\Component\Routing\Generator\UrlGeneratorInterface" rel="external noopener noreferrer" target="_blank">UrlGeneratorInterface</a> 类键入类型提示：',
        'Read the section about creating links between pages\nin the main article about Symfony templates.': '请阅读关于 Symfony 模板的主要文章中关于<a href="templates.html#templates-link-to-pages" class="reference internal">在页面之间创建链接</a>的部分。',
        'If your JavaScript code is included in a Twig template, you can use the\npath() and url() Twig functions to generate the URLs and store them in\nJavaScript variables. The escape() filter is needed to escape any\nnon-JavaScript-safe values:': '如果 JavaScript 代码包含在 Twig 模板中，则可以使用 <code translate="no" class="notranslate">path()</code> 和 <code translate="no" class="notranslate">url()</code> Twig 函数生成 URL 并将其存储在 JavaScript 变量中。<code translate="no" class="notranslate">escape()</code> 过滤器用于转义任何非 JavaScript 安全的值：',
        "If you need to generate URLs dynamically or if you are using pure JavaScript\ncode, this solution doesn't work. In those cases, consider using the\nFOSJsRoutingBundle.": '如果需要动态生成 URL，或者使用纯 JavaScript 代码，则此解决方案不起作用。在这些情况下，请考虑使用 <a href="https://github.com/FriendsOfSymfony/FOSJsRoutingBundle" class="reference external" rel="external noopener noreferrer" target="_blank">FOSJsRoutingBundle</a>。',
        "Generating URLs in commands works the same as\ngenerating URLs in services. The\nonly difference is that commands are not executed in the HTTP context. Therefore,\nif you generate absolute URLs, you'll get http://localhost/ as the host name\ninstead of your real host name.": '在命令中生成 URL 与<a href="routing.html#routing-generating-urls-in-services" class="reference internal">在服务中生成 URL</a> 的工作原理相同。唯一的区别是命令不在 HTTP 上下文中执行。因此，如果生成绝对 URL，您将得到 <code translate="no" class="notranslate">http://localhost/</code> 作为主机名，而不是您的真实主机名。',
        'The solution is to configure the default_uri option to define the\n"request context" used by commands when they generate URLs:': '解决方案是配置 <code translate="no" class="notranslate">default_uri</code> 选项来定义命令在生成 URL 时使用的“请求上下文”：',
        "Now you'll get the expected results when generating URLs in your commands:": '现在，当你在命令中生成 URL 时，你会得到预期的结果：',
        'By default, the URLs generated for web assets use the same default_uri\nvalue, but you can change it with the asset.request_context.base_path\nand asset.request_context.secure container parameters.': '默认情况下，为 web 资产生成的 URL 使用相同的 <code translate="no" class="notranslate">default_uri</code> 值，但您可以使用 <code translate="no" class="notranslate">asset.request_context.base_path</code> 和 <code translate="no" class="notranslate">asset.request_context.secure</code> 容器参数更改它。',
        "In highly dynamic applications, it may be necessary to check whether a route\nexists before using it to generate a URL. In those cases, don't use the\ngetRouteCollection() method because\nthat regenerates the routing cache and slows down the application.": '在高度动态的应用程序中，在使用路由生成 URL 之前，可能需要检查路由是否存在。在这些情况下，不要使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Routing/Router.php#:~:text=function%20getRouteCollection" class="reference external" title="Symfony\Component\Routing\Router::getRouteCollection()" rel="external noopener noreferrer" target="_blank">getRouteCollection()</a> 方法，因为这会重新生成路由缓存并降低应用程序的速度。',
        "Instead, try to generate the URL and catch the\nRouteNotFoundException thrown\nwhen the route doesn't exist:": '相反，当路由不存在时，请尝试生成 URL 并捕获引发的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Routing/Exception/RouteNotFoundException.php" class="reference external" title="Symfony\Component\Routing\Exception\RouteNotFoundException" rel="external noopener noreferrer" target="_blank">RouteNotFoundException</a>：',
        'If your server runs behind a proxy that terminates SSL, make sure to\nconfigure Symfony to work behind a proxy': '如果您的服务器运行在终止 SSL 的代理之后，请确保<a href="deployment/proxies.html" class="reference internal">将 Symfony 配置为在代理之后工作</a>',
        'The configuration for the scheme is only used for non-HTTP requests.\nThe schemes option together with incorrect proxy configuration will\nlead to a redirect loop.': '该方案的配置仅用于非 http 请求。<code translate="no" class="notranslate">schemes</code> 选项与不正确的代理配置一起将导致重定向循环。',
        "By default, generated URLs use the same HTTP scheme as the current request.\nIn console commands, where there is no HTTP request, URLs use http by\ndefault. You can change this per command (via the router's getContext()\nmethod) or globally with these configuration parameters:": '默认情况下，生成的 URL 使用与当前请求相同的 HTTP 方案。在没有 HTTP 请求的控制台命令中，URL 默认使用 <code translate="no" class="notranslate">http</code>。您可以根据命令（通过路由器的 <code translate="no" class="notranslate">getContext()</code> 方法）或使用以下配置参数进行全局更改：',
        'Outside of console commands, use the schemes option to define the scheme of\neach route explicitly:': '在控制台命令之外，使用 <code translate="no" class="notranslate">schemes</code> 选项显式定义每条路由的方案：',
        'The URL generated for the login route will always use HTTPS. This means that\nwhen using the path() Twig function to generate URLs, you may get an\nabsolute URL instead of a relative URL if the HTTP scheme of the original\nrequest is different from the scheme used by the route:': '为 <code translate="no" class="notranslate">login</code> 路由生成的 URL 将始终使用 HTTPS。这意味着当使用 <code translate="no" class="notranslate">path()</code> Twig 函数生成 URL 时，如果原始请求的 HTTP 方案与路由使用的方案不同，你可能会得到一个绝对 URL 而不是相对 URL：',
        'The scheme requirement is also enforced for incoming requests. If you try to\naccess the /login URL with HTTP, you will automatically be redirected to the\nsame URL, but with the HTTPS scheme.': '对传入请求也强制执行 scheme 要求。如果您尝试使用 HTTP 访问 <code translate="no" class="notranslate">/login</code> URL，您将自动被重定向到相同的 URL，但使用HTTPS方案。',
        'If you want to force a group of routes to use HTTPS, you can define the default\nscheme when importing them. The following example forces HTTPS on all routes\ndefined as annotations:': '如果您想强制一组路由使用 HTTPS，可以在导入它们时定义默认 scheme。下面的例子强制在所有定义为注解的路由上使用 HTTPS：',
        'The Security component provides\nanother way to enforce HTTP or HTTPS\nvia the requires_channel setting.': 'Security 组件通过 <code translate="no" class="notranslate">requires_channel</code> 设置提供了<a href="security/force_https.html" class="reference internal">另一种强制 HTTP 或 HTTPS 的方法</a>。',
        'A signed URI is an URI that includes a hash value that depends on the contents of\nthe URI. This way, you can later check the integrity of the signed URI by\nrecomputing its hash value and comparing it with the hash included in the URI.': '带签名的 URI 是一个包含哈希值的 URI，哈希值取决于 URI 的内容。通过这种方式，您可以稍后通过重新计算其哈希值并将其与 URI 中包含的哈希值进行比较来检查签名 URI 的完整性。',
        'Symfony provides a utility to sign URIs via the UriSigner\nservice, which you can inject in your services or controllers:': 'Symfony 提供了一个通过 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpFoundation/UriSigner.php" class="reference external" title="Symfony\Component\HttpFoundation\UriSigner" rel="external noopener noreferrer" target="_blank">UriSigner</a> 服务签名 URI 的工具，你可以把它注入到你的服务或控制器中：',
        'The namespace of the UriSigner class changed in Symfony 6.4 from\nSymfony\\Component\\HttpKernel\\UriSigner to\nSymfony\\Component\\HttpFoundation\\UriSigner.': '在Symfony 6.4 中，<code translate="no" class="notranslate">UriSigner</code> 类的命名空间从 <code translate="no" class="notranslate">Symfony\\Component\\HttpKernel\\UriSigner</code> 更改为 <code translate="no" class="notranslate">Symfony\\Component\\HttpFoundation\\UriSigner</code>。',
        'Here are some common errors you might see while working with routing:': '下面是一些你在使用路由时可能会看到的常见错误：',
        'This happens when your controller method has an argument (e.g. $slug):': '当你的控制器方法有一个参数(例如 <code translate="no" class="notranslate">$slug</code>)时，就会发生这种情况：',
        'But your route path does not have a {slug} parameter (e.g. it is\n/blog/show). Add a {slug} to your route path: /blog/show/{slug} or\ngive the argument a default value (i.e. $slug = null).': '但是你的路由路径没有 <code translate="no" class="notranslate">{slug}</code> 参数(例如它是 <code translate="no" class="notranslate">/blog/show</code>)。添加一个 <code translate="no" class="notranslate">{slug}</code> 到你的路由路径：<code translate="no" class="notranslate">/blog/show/{slug}</code> 或给参数一个默认值(即 <code translate="no" class="notranslate">$slug = null</code>)。',
        "This means that you're trying to generate a URL to the blog_show route but\nyou are not passing a slug value (which is required, because it has a\n{slug} parameter in the route path). To fix this, pass a slug value when\ngenerating the route:": '这意味着您正在尝试为 <code translate="no" class="notranslate">blog_show</code> 路由生成一个 URL，但您没有传递一个 <code translate="no" class="notranslate">slug</code> 值(这是必需的，因为它在路由路径中有一个 <code translate="no" class="notranslate">{slug}</code> 参数)。要解决这个问题，在生成路由时传递一个 <code translate="no" class="notranslate">slug</code> 值：',
        'or, in Twig:': '或者，在 Twig 中：',
        'Learn more about Routing': '了解更多关于路由的知识',
        'How to Create a custom Route Loader': '<a href="routing/custom_route_loader.html">如何创建自定义路由加载器</a>',
        'Looking up Routes from a Database: Symfony CMF DynamicRouter': '<a href="routing/routing_from_database.html">从数据库查找路由：Symfony CMF DynamicRouter</a>',
        'By default, Symfony loads the routes defined in both YAML and PHP formats.\nIf you define routes in XML format, you need to\nupdate the src/Kernel.php file.': '默认情况下，Symfony 会加载以 YAML 和 PHP 格式定义的路由。如果你使用 XML 格式定义路由，则需要<a href="configuration.html#configuration-formats" class="reference internal">更新 <code translate="no" class="notranslate">src/Kernel.php</code> 文件</a>。',
        'The support of \\BackedEnum as route parameters was introduced Symfony 6.3.': '对 <code translate="no" class="notranslate">\\BackedEnum</code> 作为路由参数的支持是在 Symfony 6.3 中引入的。'
    };

    fanyi(translates, 1);
})($);
