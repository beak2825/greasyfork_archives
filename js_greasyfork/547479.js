// ==UserScript==
// @name         jd-product-crawler
// @namespace    vruses
// @version      1.0.0
// @description  采集京东表格数据
// @match        *://vcpps.jd.com/sub_itemleft/price/initPriceListPage
// @grant        none
// @run-at       document-start
// @downloadURL https://update.greasyfork.org/scripts/547479/jd-product-crawler.user.js
// @updateURL https://update.greasyfork.org/scripts/547479/jd-product-crawler.meta.js
// ==/UserScript==

(function () {
  'use strict';

  const d=new Set;const importCSS = async e=>{d.has(e)||(d.add(e),(t=>{typeof GM_addStyle=="function"?GM_addStyle(t):document.head.appendChild(document.createElement("style")).append(t);})(e));};

  /**
  * @vue/shared v3.5.20
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/

function makeMap(str) {
    const map = Object.create(null);
    for (const key of str.split(",")) map[key] = 1;
    return (val2) => val2 in map;
  }
  const EMPTY_OBJ = {};
  const EMPTY_ARR = [];
  const NOOP = () => {
  };
  const NO = () => false;
  const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 &&
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  const isModelListener = (key) => key.startsWith("onUpdate:");
  const extend = Object.assign;
  const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  const hasOwn = (val2, key) => hasOwnProperty$1.call(val2, key);
  const isArray = Array.isArray;
  const isMap = (val2) => toTypeString(val2) === "[object Map]";
  const isSet = (val2) => toTypeString(val2) === "[object Set]";
  const isFunction = (val2) => typeof val2 === "function";
  const isString = (val2) => typeof val2 === "string";
  const isSymbol = (val2) => typeof val2 === "symbol";
  const isObject = (val2) => val2 !== null && typeof val2 === "object";
  const isPromise = (val2) => {
    return (isObject(val2) || isFunction(val2)) && isFunction(val2.then) && isFunction(val2.catch);
  };
  const objectToString = Object.prototype.toString;
  const toTypeString = (value) => objectToString.call(value);
  const toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  const isPlainObject = (val2) => toTypeString(val2) === "[object Object]";
  const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  const isReservedProp = makeMap(
",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    });
  };
  const camelizeRE = /-(\w)/g;
  const camelize = cacheStringFunction(
    (str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    }
  );
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction(
    (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
  );
  const capitalize = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  const toHandlerKey = cacheStringFunction(
    (str) => {
      const s = str ? `on${capitalize(str)}` : ``;
      return s;
    }
  );
  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  const invokeArrayFns = (fns, ...arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](...arg);
    }
  };
  const def = (obj, key, value, writable = false) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      writable,
      value
    });
  };
  const looseToNumber = (val2) => {
    const n = parseFloat(val2);
    return isNaN(n) ? val2 : n;
  };
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function normalizeStyle(value) {
    if (isArray(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString(value) || isObject(value)) {
      return value;
    }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString(value)) {
      res = value;
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = makeMap(specialBooleanAttrs);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  /**
  * @vue/reactivity v3.5.20
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  let activeEffectScope;
  class EffectScope {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this._on = 0;
      this.effects = [];
      this.cleanups = [];
      this._isPaused = false;
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
      }
    }
    get active() {
      return this._active;
    }
    pause() {
      if (this._active) {
        this._isPaused = true;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].pause();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].pause();
        }
      }
    }
resume() {
      if (this._active) {
        if (this._isPaused) {
          this._isPaused = false;
          let i, l;
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].resume();
            }
          }
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].resume();
          }
        }
      }
    }
    run(fn) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      }
    }
on() {
      if (++this._on === 1) {
        this.prevScope = activeEffectScope;
        activeEffectScope = this;
      }
    }
off() {
      if (this._on > 0 && --this._on === 0) {
        activeEffectScope = this.prevScope;
        this.prevScope = void 0;
      }
    }
    stop(fromParent) {
      if (this._active) {
        this._active = false;
        let i, l;
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].stop();
        }
        this.effects.length = 0;
        for (i = 0, l = this.cleanups.length; i < l; i++) {
          this.cleanups[i]();
        }
        this.cleanups.length = 0;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].stop(true);
          }
          this.scopes.length = 0;
        }
        if (!this.detached && this.parent && !fromParent) {
          const last = this.parent.scopes.pop();
          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }
        this.parent = void 0;
      }
    }
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  let activeSub;
  const pausedQueueEffects = new WeakSet();
  class ReactiveEffect {
    constructor(fn) {
      this.fn = fn;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 1 | 4;
      this.next = void 0;
      this.cleanup = void 0;
      this.scheduler = void 0;
      if (activeEffectScope && activeEffectScope.active) {
        activeEffectScope.effects.push(this);
      }
    }
    pause() {
      this.flags |= 64;
    }
    resume() {
      if (this.flags & 64) {
        this.flags &= -65;
        if (pausedQueueEffects.has(this)) {
          pausedQueueEffects.delete(this);
          this.trigger();
        }
      }
    }
notify() {
      if (this.flags & 2 && !(this.flags & 32)) {
        return;
      }
      if (!(this.flags & 8)) {
        batch(this);
      }
    }
    run() {
      if (!(this.flags & 1)) {
        return this.fn();
      }
      this.flags |= 2;
      cleanupEffect(this);
      prepareDeps(this);
      const prevEffect = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = this;
      shouldTrack = true;
      try {
        return this.fn();
      } finally {
        cleanupDeps(this);
        activeSub = prevEffect;
        shouldTrack = prevShouldTrack;
        this.flags &= -3;
      }
    }
    stop() {
      if (this.flags & 1) {
        for (let link = this.deps; link; link = link.nextDep) {
          removeSub(link);
        }
        this.deps = this.depsTail = void 0;
        cleanupEffect(this);
        this.onStop && this.onStop();
        this.flags &= -2;
      }
    }
    trigger() {
      if (this.flags & 64) {
        pausedQueueEffects.add(this);
      } else if (this.scheduler) {
        this.scheduler();
      } else {
        this.runIfDirty();
      }
    }
runIfDirty() {
      if (isDirty(this)) {
        this.run();
      }
    }
    get dirty() {
      return isDirty(this);
    }
  }
  let batchDepth = 0;
  let batchedSub;
  let batchedComputed;
  function batch(sub, isComputed = false) {
    sub.flags |= 8;
    if (isComputed) {
      sub.next = batchedComputed;
      batchedComputed = sub;
      return;
    }
    sub.next = batchedSub;
    batchedSub = sub;
  }
  function startBatch() {
    batchDepth++;
  }
  function endBatch() {
    if (--batchDepth > 0) {
      return;
    }
    if (batchedComputed) {
      let e = batchedComputed;
      batchedComputed = void 0;
      while (e) {
        const next = e.next;
        e.next = void 0;
        e.flags &= -9;
        e = next;
      }
    }
    let error;
    while (batchedSub) {
      let e = batchedSub;
      batchedSub = void 0;
      while (e) {
        const next = e.next;
        e.next = void 0;
        e.flags &= -9;
        if (e.flags & 1) {
          try {
            ;
            e.trigger();
          } catch (err) {
            if (!error) error = err;
          }
        }
        e = next;
      }
    }
    if (error) throw error;
  }
  function prepareDeps(sub) {
    for (let link = sub.deps; link; link = link.nextDep) {
      link.version = -1;
      link.prevActiveLink = link.dep.activeLink;
      link.dep.activeLink = link;
    }
  }
  function cleanupDeps(sub) {
    let head;
    let tail = sub.depsTail;
    let link = tail;
    while (link) {
      const prev = link.prevDep;
      if (link.version === -1) {
        if (link === tail) tail = prev;
        removeSub(link);
        removeDep(link);
      } else {
        head = link;
      }
      link.dep.activeLink = link.prevActiveLink;
      link.prevActiveLink = void 0;
      link = prev;
    }
    sub.deps = head;
    sub.depsTail = tail;
  }
  function isDirty(sub) {
    for (let link = sub.deps; link; link = link.nextDep) {
      if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
        return true;
      }
    }
    if (sub._dirty) {
      return true;
    }
    return false;
  }
  function refreshComputed(computed2) {
    if (computed2.flags & 4 && !(computed2.flags & 16)) {
      return;
    }
    computed2.flags &= -17;
    if (computed2.globalVersion === globalVersion) {
      return;
    }
    computed2.globalVersion = globalVersion;
    if (!computed2.isSSR && computed2.flags & 128 && (!computed2.deps && !computed2._dirty || !isDirty(computed2))) {
      return;
    }
    computed2.flags |= 2;
    const dep = computed2.dep;
    const prevSub = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = computed2;
    shouldTrack = true;
    try {
      prepareDeps(computed2);
      const value = computed2.fn(computed2._value);
      if (dep.version === 0 || hasChanged(value, computed2._value)) {
        computed2.flags |= 128;
        computed2._value = value;
        dep.version++;
      }
    } catch (err) {
      dep.version++;
      throw err;
    } finally {
      activeSub = prevSub;
      shouldTrack = prevShouldTrack;
      cleanupDeps(computed2);
      computed2.flags &= -3;
    }
  }
  function removeSub(link, soft = false) {
    const { dep, prevSub, nextSub } = link;
    if (prevSub) {
      prevSub.nextSub = nextSub;
      link.prevSub = void 0;
    }
    if (nextSub) {
      nextSub.prevSub = prevSub;
      link.nextSub = void 0;
    }
    if (dep.subs === link) {
      dep.subs = prevSub;
      if (!prevSub && dep.computed) {
        dep.computed.flags &= -5;
        for (let l = dep.computed.deps; l; l = l.nextDep) {
          removeSub(l, true);
        }
      }
    }
    if (!soft && !--dep.sc && dep.map) {
      dep.map.delete(dep.key);
    }
  }
  function removeDep(link) {
    const { prevDep, nextDep } = link;
    if (prevDep) {
      prevDep.nextDep = nextDep;
      link.prevDep = void 0;
    }
    if (nextDep) {
      nextDep.prevDep = prevDep;
      link.nextDep = void 0;
    }
  }
  let shouldTrack = true;
  const trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function cleanupEffect(e) {
    const { cleanup } = e;
    e.cleanup = void 0;
    if (cleanup) {
      const prevSub = activeSub;
      activeSub = void 0;
      try {
        cleanup();
      } finally {
        activeSub = prevSub;
      }
    }
  }
  let globalVersion = 0;
  class Link {
    constructor(sub, dep) {
      this.sub = sub;
      this.dep = dep;
      this.version = dep.version;
      this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
    }
  }
  class Dep {
constructor(computed2) {
      this.computed = computed2;
      this.version = 0;
      this.activeLink = void 0;
      this.subs = void 0;
      this.map = void 0;
      this.key = void 0;
      this.sc = 0;
      this.__v_skip = true;
    }
    track(debugInfo) {
      if (!activeSub || !shouldTrack || activeSub === this.computed) {
        return;
      }
      let link = this.activeLink;
      if (link === void 0 || link.sub !== activeSub) {
        link = this.activeLink = new Link(activeSub, this);
        if (!activeSub.deps) {
          activeSub.deps = activeSub.depsTail = link;
        } else {
          link.prevDep = activeSub.depsTail;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
        }
        addSub(link);
      } else if (link.version === -1) {
        link.version = this.version;
        if (link.nextDep) {
          const next = link.nextDep;
          next.prevDep = link.prevDep;
          if (link.prevDep) {
            link.prevDep.nextDep = next;
          }
          link.prevDep = activeSub.depsTail;
          link.nextDep = void 0;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
          if (activeSub.deps === link) {
            activeSub.deps = next;
          }
        }
      }
      return link;
    }
    trigger(debugInfo) {
      this.version++;
      globalVersion++;
      this.notify(debugInfo);
    }
    notify(debugInfo) {
      startBatch();
      try {
        if (false) ;
        for (let link = this.subs; link; link = link.prevSub) {
          if (link.sub.notify()) {
            ;
            link.sub.dep.notify();
          }
        }
      } finally {
        endBatch();
      }
    }
  }
  function addSub(link) {
    link.dep.sc++;
    if (link.sub.flags & 4) {
      const computed2 = link.dep.computed;
      if (computed2 && !link.dep.subs) {
        computed2.flags |= 4 | 16;
        for (let l = computed2.deps; l; l = l.nextDep) {
          addSub(l);
        }
      }
      const currentTail = link.dep.subs;
      if (currentTail !== link) {
        link.prevSub = currentTail;
        if (currentTail) currentTail.nextSub = link;
      }
      link.dep.subs = link;
    }
  }
  const targetMap = new WeakMap();
  const ITERATE_KEY = Symbol(
    ""
  );
  const MAP_KEY_ITERATE_KEY = Symbol(
    ""
  );
  const ARRAY_ITERATE_KEY = Symbol(
    ""
  );
  function track(target, type, key) {
    if (shouldTrack && activeSub) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = new Dep());
        dep.map = depsMap;
        dep.key = key;
      }
      {
        dep.track();
      }
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      globalVersion++;
      return;
    }
    const run = (dep) => {
      if (dep) {
        {
          dep.trigger();
        }
      }
    };
    startBatch();
    if (type === "clear") {
      depsMap.forEach(run);
    } else {
      const targetIsArray = isArray(target);
      const isArrayIndex = targetIsArray && isIntegerKey(key);
      if (targetIsArray && key === "length") {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
            run(dep);
          }
        });
      } else {
        if (key !== void 0 || depsMap.has(void 0)) {
          run(depsMap.get(key));
        }
        if (isArrayIndex) {
          run(depsMap.get(ARRAY_ITERATE_KEY));
        }
        switch (type) {
          case "add":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isArrayIndex) {
              run(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap(target)) {
              run(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
    }
    endBatch();
  }
  function reactiveReadArray(array) {
    const raw = toRaw(array);
    if (raw === array) return raw;
    track(raw, "iterate", ARRAY_ITERATE_KEY);
    return isShallow(array) ? raw : raw.map(toReactive);
  }
  function shallowReadArray(arr) {
    track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
    return arr;
  }
  const arrayInstrumentations = {
    __proto__: null,
    [Symbol.iterator]() {
      return iterator(this, Symbol.iterator, toReactive);
    },
    concat(...args) {
      return reactiveReadArray(this).concat(
        ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)
      );
    },
    entries() {
      return iterator(this, "entries", (value) => {
        value[1] = toReactive(value[1]);
        return value;
      });
    },
    every(fn, thisArg) {
      return apply(this, "every", fn, thisArg, void 0, arguments);
    },
    filter(fn, thisArg) {
      return apply(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
    },
    find(fn, thisArg) {
      return apply(this, "find", fn, thisArg, toReactive, arguments);
    },
    findIndex(fn, thisArg) {
      return apply(this, "findIndex", fn, thisArg, void 0, arguments);
    },
    findLast(fn, thisArg) {
      return apply(this, "findLast", fn, thisArg, toReactive, arguments);
    },
    findLastIndex(fn, thisArg) {
      return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
    },
forEach(fn, thisArg) {
      return apply(this, "forEach", fn, thisArg, void 0, arguments);
    },
    includes(...args) {
      return searchProxy(this, "includes", args);
    },
    indexOf(...args) {
      return searchProxy(this, "indexOf", args);
    },
    join(separator) {
      return reactiveReadArray(this).join(separator);
    },
lastIndexOf(...args) {
      return searchProxy(this, "lastIndexOf", args);
    },
    map(fn, thisArg) {
      return apply(this, "map", fn, thisArg, void 0, arguments);
    },
    pop() {
      return noTracking(this, "pop");
    },
    push(...args) {
      return noTracking(this, "push", args);
    },
    reduce(fn, ...args) {
      return reduce(this, "reduce", fn, args);
    },
    reduceRight(fn, ...args) {
      return reduce(this, "reduceRight", fn, args);
    },
    shift() {
      return noTracking(this, "shift");
    },
some(fn, thisArg) {
      return apply(this, "some", fn, thisArg, void 0, arguments);
    },
    splice(...args) {
      return noTracking(this, "splice", args);
    },
    toReversed() {
      return reactiveReadArray(this).toReversed();
    },
    toSorted(comparer) {
      return reactiveReadArray(this).toSorted(comparer);
    },
    toSpliced(...args) {
      return reactiveReadArray(this).toSpliced(...args);
    },
    unshift(...args) {
      return noTracking(this, "unshift", args);
    },
    values() {
      return iterator(this, "values", toReactive);
    }
  };
  function iterator(self2, method, wrapValue) {
    const arr = shallowReadArray(self2);
    const iter = arr[method]();
    if (arr !== self2 && !isShallow(self2)) {
      iter._next = iter.next;
      iter.next = () => {
        const result = iter._next();
        if (result.value) {
          result.value = wrapValue(result.value);
        }
        return result;
      };
    }
    return iter;
  }
  const arrayProto = Array.prototype;
  function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
    const arr = shallowReadArray(self2);
    const needsWrap = arr !== self2 && !isShallow(self2);
    const methodFn = arr[method];
    if (methodFn !== arrayProto[method]) {
      const result2 = methodFn.apply(self2, args);
      return needsWrap ? toReactive(result2) : result2;
    }
    let wrappedFn = fn;
    if (arr !== self2) {
      if (needsWrap) {
        wrappedFn = function(item, index) {
          return fn.call(this, toReactive(item), index, self2);
        };
      } else if (fn.length > 2) {
        wrappedFn = function(item, index) {
          return fn.call(this, item, index, self2);
        };
      }
    }
    const result = methodFn.call(arr, wrappedFn, thisArg);
    return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
  }
  function reduce(self2, method, fn, args) {
    const arr = shallowReadArray(self2);
    let wrappedFn = fn;
    if (arr !== self2) {
      if (!isShallow(self2)) {
        wrappedFn = function(acc, item, index) {
          return fn.call(this, acc, toReactive(item), index, self2);
        };
      } else if (fn.length > 3) {
        wrappedFn = function(acc, item, index) {
          return fn.call(this, acc, item, index, self2);
        };
      }
    }
    return arr[method](wrappedFn, ...args);
  }
  function searchProxy(self2, method, args) {
    const arr = toRaw(self2);
    track(arr, "iterate", ARRAY_ITERATE_KEY);
    const res = arr[method](...args);
    if ((res === -1 || res === false) && isProxy(args[0])) {
      args[0] = toRaw(args[0]);
      return arr[method](...args);
    }
    return res;
  }
  function noTracking(self2, method, args = []) {
    pauseTracking();
    startBatch();
    const res = toRaw(self2)[method].apply(self2, args);
    endBatch();
    resetTracking();
    return res;
  }
  const isNonTrackableKeys = makeMap(`__proto__,__v_isRef,__isVue`);
  const builtInSymbols = new Set(
Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
  );
  function hasOwnProperty(key) {
    if (!isSymbol(key)) key = String(key);
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  class BaseReactiveHandler {
    constructor(_isReadonly = false, _isShallow = false) {
      this._isReadonly = _isReadonly;
      this._isShallow = _isShallow;
    }
    get(target, key, receiver) {
      if (key === "__v_skip") return target["__v_skip"];
      const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return isShallow2;
      } else if (key === "__v_raw") {
        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) ||

Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
          return target;
        }
        return;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly2) {
        let fn;
        if (targetIsArray && (fn = arrayInstrumentations[key])) {
          return fn;
        }
        if (key === "hasOwnProperty") {
          return hasOwnProperty;
        }
      }
      const res = Reflect.get(
        target,
        key,


isRef(target) ? target : receiver
      );
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (isShallow2) {
        return res;
      }
      if (isRef(res)) {
        return targetIsArray && isIntegerKey(key) ? res : res.value;
      }
      if (isObject(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    }
  }
  class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(false, isShallow2);
    }
    set(target, key, value, receiver) {
      let oldValue = target[key];
      if (!this._isShallow) {
        const isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          if (isOldValueReadonly) {
            return true;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(
        target,
        key,
        value,
        isRef(target) ? target : receiver
      );
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
      }
      return result;
    }
    deleteProperty(target, key) {
      const hadKey = hasOwn(target, key);
      target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    has(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    ownKeys(target) {
      track(
        target,
        "iterate",
        isArray(target) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target);
    }
  }
  class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(true, isShallow2);
    }
    set(target, key) {
      return true;
    }
    deleteProperty(target, key) {
      return true;
    }
  }
  const mutableHandlers = new MutableReactiveHandler();
  const readonlyHandlers = new ReadonlyReactiveHandler();
  const shallowReactiveHandlers = new MutableReactiveHandler(true);
  const shallowReadonlyHandlers = new ReadonlyReactiveHandler(true);
  const toShallow = (value) => value;
  const getProto = (v) => Reflect.getPrototypeOf(v);
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
[Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      return type === "delete" ? false : type === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations(readonly2, shallow) {
    const instrumentations = {
      get(key) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "get", key);
          }
          track(rawTarget, "get", rawKey);
        }
        const { has } = getProto(rawTarget);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        if (has.call(rawTarget, key)) {
          return wrap(target.get(key));
        } else if (has.call(rawTarget, rawKey)) {
          return wrap(target.get(rawKey));
        } else if (target !== rawTarget) {
          target.get(key);
        }
      },
      get size() {
        const target = this["__v_raw"];
        !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
        return target.size;
      },
      has(key) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "has", key);
          }
          track(rawTarget, "has", rawKey);
        }
        return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
      },
      forEach(callback2, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback2.call(thisArg, wrap(value), wrap(key), observed);
        });
      }
    };
    extend(
      instrumentations,
      readonly2 ? {
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear")
      } : {
        add(value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const proto = getProto(target);
          const hadKey = proto.has.call(target, value);
          if (!hadKey) {
            target.add(value);
            trigger(target, "add", value, value);
          }
          return this;
        },
        set(key, value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const { has, get } = getProto(target);
          let hadKey = has.call(target, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has.call(target, key);
          }
          const oldValue = get.call(target, key);
          target.set(key, value);
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key, value);
          }
          return this;
        },
        delete(key) {
          const target = toRaw(this);
          const { has, get } = getProto(target);
          let hadKey = has.call(target, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has.call(target, key);
          }
          get ? get.call(target, key) : void 0;
          const result = target.delete(key);
          if (hadKey) {
            trigger(target, "delete", key, void 0);
          }
          return result;
        },
        clear() {
          const target = toRaw(this);
          const hadItems = target.size !== 0;
          const result = target.clear();
          if (hadItems) {
            trigger(
              target,
              "clear",
              void 0,
              void 0
            );
          }
          return result;
        }
      }
    );
    const iteratorMethods = [
      "keys",
      "values",
      "entries",
      Symbol.iterator
    ];
    iteratorMethods.forEach((method) => {
      instrumentations[method] = createIterableMethod(method, readonly2, shallow);
    });
    return instrumentations;
  }
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = createInstrumentations(isReadonly2, shallow);
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(
        hasOwn(instrumentations, key) && key in target ? instrumentations : target,
        key,
        receiver
      );
    };
  }
  const mutableCollectionHandlers = {
    get: createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
    get: createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
    get: createInstrumentationGetter(true, false)
  };
  const shallowReadonlyCollectionHandlers = {
    get: createInstrumentationGetter(true, true)
  };
  const reactiveMap = new WeakMap();
  const shallowReactiveMap = new WeakMap();
  const readonlyMap = new WeakMap();
  const shallowReadonlyMap = new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function shallowReactive(target) {
    return createReactiveObject(
      target,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
    );
  }
  function readonly(target) {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function shallowReadonly(target) {
    return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    );
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const proxy = new Proxy(
      target,
      targetType === 2 ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
      def(value, "__v_skip", true);
    }
    return value;
  }
  const toReactive = (value) => isObject(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject(value) ? readonly(value) : value;
  function isRef(r2) {
    return r2 ? r2["__v_isRef"] === true : false;
  }
  function ref(value) {
    return createRef(value, false);
  }
  function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  class RefImpl {
    constructor(value, isShallow2) {
      this.dep = new Dep();
      this["__v_isRef"] = true;
      this["__v_isShallow"] = false;
      this._rawValue = isShallow2 ? value : toRaw(value);
      this._value = isShallow2 ? value : toReactive(value);
      this["__v_isShallow"] = isShallow2;
    }
    get value() {
      {
        this.dep.track();
      }
      return this._value;
    }
    set value(newValue) {
      const oldValue = this._rawValue;
      const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
      newValue = useDirectValue ? newValue : toRaw(newValue);
      if (hasChanged(newValue, oldValue)) {
        this._rawValue = newValue;
        this._value = useDirectValue ? newValue : toReactive(newValue);
        {
          this.dep.trigger();
        }
      }
    }
  }
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  const shallowUnwrapHandlers = {
    get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  class ComputedRefImpl {
    constructor(fn, setter, isSSR) {
      this.fn = fn;
      this.setter = setter;
      this._value = void 0;
      this.dep = new Dep(this);
      this.__v_isRef = true;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 16;
      this.globalVersion = globalVersion - 1;
      this.next = void 0;
      this.effect = this;
      this["__v_isReadonly"] = !setter;
      this.isSSR = isSSR;
    }
notify() {
      this.flags |= 16;
      if (!(this.flags & 8) &&
activeSub !== this) {
        batch(this, true);
        return true;
      }
    }
    get value() {
      const link = this.dep.track();
      refreshComputed(this);
      if (link) {
        link.version = this.dep.version;
      }
      return this._value;
    }
    set value(newValue) {
      if (this.setter) {
        this.setter(newValue);
      }
    }
  }
  function computed$1(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    if (isFunction(getterOrOptions)) {
      getter = getterOrOptions;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, isSSR);
    return cRef;
  }
  const INITIAL_WATCHER_VALUE = {};
  const cleanupMap = new WeakMap();
  let activeWatcher = void 0;
  function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
    if (owner) {
      let cleanups = cleanupMap.get(owner);
      if (!cleanups) cleanupMap.set(owner, cleanups = []);
      cleanups.push(cleanupFn);
    }
  }
  function watch$1(source, cb, options = EMPTY_OBJ) {
    const { immediate, deep, once, scheduler, augmentJob, call } = options;
    const reactiveGetter = (source2) => {
      if (deep) return source2;
      if (isShallow(source2) || deep === false || deep === 0)
        return traverse(source2, 1);
      return traverse(source2);
    };
    let effect2;
    let getter;
    let cleanup;
    let boundCleanup;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => reactiveGetter(source);
      forceTrigger = true;
    } else if (isArray(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
      getter = () => source.map((s) => {
        if (isRef(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return reactiveGetter(s);
        } else if (isFunction(s)) {
          return call ? call(s, 2) : s();
        } else ;
      });
    } else if (isFunction(source)) {
      if (cb) {
        getter = call ? () => call(source, 2) : source;
      } else {
        getter = () => {
          if (cleanup) {
            pauseTracking();
            try {
              cleanup();
            } finally {
              resetTracking();
            }
          }
          const currentEffect = activeWatcher;
          activeWatcher = effect2;
          try {
            return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
          } finally {
            activeWatcher = currentEffect;
          }
        };
      }
    } else {
      getter = NOOP;
    }
    if (cb && deep) {
      const baseGetter = getter;
      const depth = deep === true ? Infinity : deep;
      getter = () => traverse(baseGetter(), depth);
    }
    const scope = getCurrentScope();
    const watchHandle = () => {
      effect2.stop();
      if (scope && scope.active) {
        remove(scope.effects, effect2);
      }
    };
    if (once && cb) {
      const _cb = cb;
      cb = (...args) => {
        _cb(...args);
        watchHandle();
      };
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = (immediateFirstRun) => {
      if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
          if (cleanup) {
            cleanup();
          }
          const currentWatcher = activeWatcher;
          activeWatcher = effect2;
          try {
            const args = [
              newValue,
oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              boundCleanup
            ];
            oldValue = newValue;
            call ? call(cb, 3, args) : (
cb(...args)
            );
          } finally {
            activeWatcher = currentWatcher;
          }
        }
      } else {
        effect2.run();
      }
    };
    if (augmentJob) {
      augmentJob(job);
    }
    effect2 = new ReactiveEffect(getter);
    effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
    boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
    cleanup = effect2.onStop = () => {
      const cleanups = cleanupMap.get(effect2);
      if (cleanups) {
        if (call) {
          call(cleanups, 4);
        } else {
          for (const cleanup2 of cleanups) cleanup2();
        }
        cleanupMap.delete(effect2);
      }
    };
    if (cb) {
      if (immediate) {
        job(true);
      } else {
        oldValue = effect2.run();
      }
    } else if (scheduler) {
      scheduler(job.bind(null, true), true);
    } else {
      effect2.run();
    }
    watchHandle.pause = effect2.pause.bind(effect2);
    watchHandle.resume = effect2.resume.bind(effect2);
    watchHandle.stop = watchHandle;
    return watchHandle;
  }
  function traverse(value, depth = Infinity, seen) {
    if (depth <= 0 || !isObject(value) || value["__v_skip"]) {
      return value;
    }
    seen = seen || new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    depth--;
    if (isRef(value)) {
      traverse(value.value, depth, seen);
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        traverse(value[i], depth, seen);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach((v) => {
        traverse(v, depth, seen);
      });
    } else if (isPlainObject(value)) {
      for (const key in value) {
        traverse(value[key], depth, seen);
      }
      for (const key of Object.getOwnPropertySymbols(value)) {
        if (Object.prototype.propertyIsEnumerable.call(value, key)) {
          traverse(value[key], depth, seen);
        }
      }
    }
    return value;
  }
  /**
  * @vue/runtime-core v3.5.20
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const stack = [];
  let isWarning = false;
  function warn$1(msg, ...args) {
    if (isWarning) return;
    isWarning = true;
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
msg + args.map((a) => {
            var _a, _b;
            return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
          }).join(""),
          instance && instance.proxy,
          trace.map(
            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
          ).join("\n"),
          trace
        ]
      );
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length &&
true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
    isWarning = false;
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last = normalizedStack[0];
      if (last && last.vnode === currentVNode) {
        last.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
      logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
    const close = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
  }
  function formatProps(props) {
    const res = [];
    const keys2 = Object.keys(props);
    keys2.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys2.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key}=${value}`];
    } else if (isRef(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key}=`, value];
    }
  }
  function callWithErrorHandling(fn, instance, type, args) {
    try {
      return args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type);
    }
  }
  function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (isFunction(fn)) {
      const res = callWithErrorHandling(fn, instance, type, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type);
        });
      }
      return res;
    }
    if (isArray(fn)) {
      const values = [];
      for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
      }
      return values;
    }
  }
  function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i = 0; i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      if (errorHandler) {
        pauseTracking();
        callWithErrorHandling(errorHandler, null, 10, [
          err,
          exposedInstance,
          errorInfo
        ]);
        resetTracking();
        return;
      }
    }
    logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
  }
  function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
    if (throwInProd) {
      throw err;
    } else {
      console.error(err);
    }
  }
  const queue = [];
  let flushIndex = -1;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = Promise.resolve();
  let currentFlushPromise = null;
  function nextTick(fn) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
  }
  function findInsertionIndex(id) {
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJob = queue[middle];
      const middleJobId = getId(middleJob);
      if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
        start = middle + 1;
      } else {
        end = middle;
      }
    }
    return start;
  }
  function queueJob(job) {
    if (!(job.flags & 1)) {
      const jobId = getId(job);
      const lastJob = queue[queue.length - 1];
      if (!lastJob ||
!(job.flags & 2) && jobId >= getId(lastJob)) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(jobId), 0, job);
      }
      job.flags |= 1;
      queueFlush();
    }
  }
  function queueFlush() {
    if (!currentFlushPromise) {
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray(cb)) {
      if (activePostFlushCbs && cb.id === -1) {
        activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
      } else if (!(cb.flags & 1)) {
        pendingPostFlushCbs.push(cb);
        cb.flags |= 1;
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
    for (; i < queue.length; i++) {
      const cb = queue[i];
      if (cb && cb.flags & 2) {
        if (instance && cb.id !== instance.uid) {
          continue;
        }
        queue.splice(i, 1);
        i--;
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        cb();
        if (!(cb.flags & 4)) {
          cb.flags &= -2;
        }
      }
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)].sort(
        (a, b) => getId(a) - getId(b)
      );
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        const cb = activePostFlushCbs[postFlushIndex];
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        if (!(cb.flags & 8)) cb();
        cb.flags &= -2;
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
  function flushJobs(seen) {
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && !(job.flags & 8)) {
          if (false) ;
          if (job.flags & 4) {
            job.flags &= ~1;
          }
          callWithErrorHandling(
            job,
            job.i,
            job.i ? 15 : 14
          );
          if (!(job.flags & 4)) {
            job.flags &= ~1;
          }
        }
      }
    } finally {
      for (; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job) {
          job.flags &= -2;
        }
      }
      flushIndex = -1;
      queue.length = 0;
      flushPostFlushCbs();
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs();
      }
    }
  }
  let currentRenderingInstance = null;
  let currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
      const binding = bindings[i];
      if (oldBindings) {
        binding.oldValue = oldBindings[i].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  const TeleportEndKey = Symbol("_vte");
  const isTeleport = (type) => type.__isTeleport;
  const leaveCbKey = Symbol("_leaveCb");
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      vnode.transition = hooks;
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }

function defineComponent(options, extraOptions) {
    return isFunction(options) ? (


(() => extend({ name: options.name }, extraOptions, { setup: options }))()
    ) : options;
  }
  function markAsyncBoundary(instance) {
    instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
  }
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray(rawRef)) {
      rawRef.forEach(
        (r2, i) => setRef(
          r2,
          oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
          parentSuspense,
          vnode,
          isUnmount
        )
      );
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
        setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
      }
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref3 } = rawRef;
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    const rawSetupState = toRaw(setupState);
    const canSetSetupRef = setupState === EMPTY_OBJ ? NO : (key) => {
      return hasOwn(rawSetupState, key);
    };
    if (oldRef != null && oldRef !== ref3) {
      if (isString(oldRef)) {
        refs[oldRef] = null;
        if (canSetSetupRef(oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        {
          oldRef.value = null;
        }
        const oldRawRefAtom = oldRawRef;
        if (oldRawRefAtom.k) refs[oldRawRefAtom.k] = null;
      }
    }
    if (isFunction(ref3)) {
      callWithErrorHandling(ref3, owner, 12, [value, refs]);
    } else {
      const _isString = isString(ref3);
      const _isRef = isRef(ref3);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
            if (isUnmount) {
              isArray(existing) && remove(existing, refValue);
            } else {
              if (!isArray(existing)) {
                if (_isString) {
                  refs[ref3] = [refValue];
                  if (canSetSetupRef(ref3)) {
                    setupState[ref3] = refs[ref3];
                  }
                } else {
                  const newVal = [refValue];
                  {
                    ref3.value = newVal;
                  }
                  if (rawRef.k) refs[rawRef.k] = newVal;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref3] = value;
            if (canSetSetupRef(ref3)) {
              setupState[ref3] = value;
            }
          } else if (_isRef) {
            {
              ref3.value = value;
            }
            if (rawRef.k) refs[rawRef.k] = value;
          } else ;
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      }
    }
  }
  getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
  getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
  const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(
      type,
      hook,
      keepAliveRoot,
      true
);
    onUnmounted(() => {
      remove(keepAliveRoot[type], injected);
    }, target);
  }
  function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type] || (target[type] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        pauseTracking();
        const reset = setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type, args);
        reset();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    }
  }
  const createHook = (lifecycle) => (hook, target = currentInstance) => {
    if (!isInSSRComponentSetup || lifecycle === "sp") {
      injectHook(lifecycle, (...args) => hook(...args), target);
    }
  };
  const onBeforeMount = createHook("bm");
  const onMounted = createHook("m");
  const onBeforeUpdate = createHook(
    "bu"
  );
  const onUpdated = createHook("u");
  const onBeforeUnmount = createHook(
    "bum"
  );
  const onUnmounted = createHook("um");
  const onServerPrefetch = createHook(
    "sp"
  );
  const onRenderTriggered = createHook("rtg");
  const onRenderTracked = createHook("rtc");
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function renderSlot(slots, name, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
      return openBlock(), createBlock(
        Fragment,
        null,
        [createVNode("slot", props, fallback)],
        64
      );
    }
    let slot = slots[name];
    if (slot && slot._c) {
      slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const slotKey = props.key ||

validSlotContent && validSlotContent.key;
    const rendered = createBlock(
      Fragment,
      {
        key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) +
(!validSlotContent && fallback ? "_fb" : "")
      },
      validSlotContent || [],
      validSlotContent && slots._ === 1 ? 64 : -2
    );
    if (rendered.scopeId) {
      rendered.slotScopeIds = [rendered.scopeId + "-s"];
    }
    if (slot && slot._c) {
      slot._d = true;
    }
    return rendered;
  }
  function ensureValidVNode(vnodes) {
    return vnodes.some((child) => {
      if (!isVNode(child)) return true;
      if (child.type === Comment) return false;
      if (child.type === Fragment && !ensureValidVNode(child.children))
        return false;
      return true;
    }) ? vnodes : null;
  }
  const getPublicInstance = (i) => {
    if (!i) return null;
    if (isStatefulComponent(i)) return getComponentPublicInstance(i);
    return getPublicInstance(i.parent);
  };
  const publicPropertiesMap = (


extend( Object.create(null), {
      $: (i) => i,
      $el: (i) => i.vnode.el,
      $data: (i) => i.data,
      $props: (i) => i.props,
      $attrs: (i) => i.attrs,
      $slots: (i) => i.slots,
      $refs: (i) => i.refs,
      $parent: (i) => getPublicInstance(i.parent),
      $root: (i) => getPublicInstance(i.root),
      $host: (i) => i.ce,
      $emit: (i) => i.emit,
      $options: (i) => resolveMergedOptions(i),
      $forceUpdate: (i) => i.f || (i.f = () => {
        queueJob(i.update);
      }),
      $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
      $watch: (i) => instanceWatch.bind(i)
    })
  );
  const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
  const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      if (key === "__v_skip") {
        return true;
      }
      const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
      let normalizedProps;
      if (key[0] !== "$") {
        const n = accessCache[key];
        if (n !== void 0) {
          switch (n) {
            case 1:
              return setupState[key];
            case 2:
              return data[key];
            case 4:
              return ctx[key];
            case 3:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          accessCache[key] = 2;
          return data[key];
        } else if (

(normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
        ) {
          accessCache[key] = 3;
          return props[key];
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (shouldCacheAccess) {
          accessCache[key] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance.attrs, "get", "");
        }
        return publicGetter(instance);
      } else if (
(cssModule = type.__cssModules) && (cssModule = cssModule[key])
      ) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (
globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
      ) {
        {
          return globalProperties[key];
        }
      } else ;
    },
    set({ _: instance }, key, value) {
      const { data, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        data[key] = value;
        return true;
      } else if (hasOwn(instance.props, key)) {
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        return false;
      } else {
        {
          ctx[key] = value;
        }
      }
      return true;
    },
    has({
      _: { data, setupState, accessCache, ctx, appContext, propsOptions, type }
    }, key) {
      let normalizedProps, cssModules;
      return !!(accessCache[key] || data !== EMPTY_OBJ && key[0] !== "$" && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key) || (cssModules = type.__cssModules) && cssModules[key]);
    },
    defineProperty(target, key, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key] = 0;
      } else if (hasOwn(descriptor, "value")) {
        this.set(target, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key, descriptor);
    }
  };
  function normalizePropsOrEmits(props) {
    return isArray(props) ? props.reduce(
      (normalized, p2) => (normalized[p2] = null, normalized),
      {}
    ) : props;
  }
  let shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook(options.beforeCreate, instance, "bc");
    }
    const {
data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
expose,
      inheritAttrs,
components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = null;
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction(methodHandler)) {
          {
            ctx[key] = methodHandler.bind(publicThis);
          }
        }
      }
    }
    if (dataOptions) {
      const data = dataOptions.call(publicThis, publicThis);
      if (!isObject(data)) ;
      else {
        instance.data = reactive(data);
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        const set = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : NOOP;
        const c = computed({
          get,
          set
        });
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => c.value,
          set: (v) => c.value = v
        });
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val2) => publicThis[key] = val2,
            enumerable: true
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render && instance.render === NOOP) {
      instance.render = render;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
    if (serverPrefetch) {
      markAsyncBoundary(instance);
    }
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject(opt)) {
        if ("default" in opt) {
          injected = inject(
            opt.from || key,
            opt.default,
            true
          );
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
    }
  }
  function callHook(hook, instance, type) {
    callWithAsyncErrorHandling(
      isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
      instance,
      type
    );
  }
  function createWatcher(raw, ctx, publicThis, key) {
    let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString(raw)) {
      const handler = ctx[raw];
      if (isFunction(handler)) {
        {
          watch(getter, handler);
        }
      }
    } else if (isFunction(raw)) {
      {
        watch(getter, raw.bind(publicThis));
      }
    } else if (isObject(raw)) {
      if (isArray(raw)) {
        raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
      } else {
        const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction(handler)) {
          watch(getter, handler, raw);
        }
      }
    } else ;
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const {
      mixins: globalMixins,
      optionsCache: cache,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
        );
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    if (isObject(base)) {
      cache.set(base, resolved);
    }
    return resolved;
  }
  function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        (m) => mergeOptions(to, m, strats, true)
      );
    }
    for (const key in from) {
      if (asMixin && key === "expose") ;
      else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
      }
    }
    return to;
  }
  const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
methods: mergeObjectOptions,
    computed: mergeObjectOptions,
beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
components: mergeObjectOptions,
    directives: mergeObjectOptions,
watch: mergeWatchOptions,
provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return extend(
        isFunction(to) ? to.call(this, this) : to,
        isFunction(from) ? from.call(this, this) : from
      );
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray(raw)) {
      const res = {};
      for (let i = 0; i < raw.length; i++) {
        res[raw[i]] = raw[i];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend( Object.create(null), to, from) : from;
  }
  function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
      if (isArray(to) && isArray(from)) {
        return [... new Set([...to, ...from])];
      }
      return extend(
Object.create(null),
        normalizePropsOrEmits(to),
        normalizePropsOrEmits(from != null ? from : {})
      );
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to, from) {
    if (!to) return from;
    if (!from) return to;
    const merged = extend( Object.create(null), to);
    for (const key in from) {
      merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: Object.create(null),
      optionsCache: new WeakMap(),
      propsCache: new WeakMap(),
      emitsCache: new WeakMap()
    };
  }
  let uid$1 = 0;
  function createAppAPI(render, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction(rootComponent)) {
        rootComponent = extend({}, rootComponent);
      }
      if (rootProps != null && !isObject(rootProps)) {
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = new WeakSet();
      const pluginCleanupFns = [];
      let isMounted = false;
      const app = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version,
        get config() {
          return context.config;
        },
        set config(v) {
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin)) ;
          else if (plugin && isFunction(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app, ...options);
          } else if (isFunction(plugin)) {
            installedPlugins.add(plugin);
            plugin(app, ...options);
          } else ;
          return app;
        },
        mixin(mixin) {
          {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            }
          }
          return app;
        },
        component(name, component) {
          if (!component) {
            return context.components[name];
          }
          context.components[name] = component;
          return app;
        },
        directive(name, directive) {
          if (!directive) {
            return context.directives[name];
          }
          context.directives[name] = directive;
          return app;
        },
        mount(rootContainer, isHydrate, namespace) {
          if (!isMounted) {
            const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (namespace === true) {
              namespace = "svg";
            } else if (namespace === false) {
              namespace = void 0;
            }
            {
              render(vnode, rootContainer, namespace);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            return getComponentPublicInstance(vnode.component);
          }
        },
        onUnmount(cleanupFn) {
          pluginCleanupFns.push(cleanupFn);
        },
        unmount() {
          if (isMounted) {
            callWithAsyncErrorHandling(
              pluginCleanupFns,
              app._instance,
              16
            );
            render(null, app._container);
            delete app._container.__vue_app__;
          }
        },
        provide(key, value) {
          context.provides[key] = value;
          return app;
        },
        runWithContext(fn) {
          const lastApp = currentApp;
          currentApp = app;
          try {
            return fn();
          } finally {
            currentApp = lastApp;
          }
        }
      };
      return app;
    };
  }
  let currentApp = null;
  function provide(key, value) {
    if (!currentInstance) ;
    else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = getCurrentInstance();
    if (instance || currentApp) {
      let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else ;
    }
  }
  const internalObjectProto = {};
  const createInternalObject = () => Object.create(internalObjectProto);
  const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = createInternalObject();
    instance.propsDefaults = Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (


(optimized || patchFlag > 0) && !(patchFlag & 16)
    ) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i = 0; i < propsToUpdate.length; i++) {
          let key = propsToUpdate[i];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          const value = rawProps[key];
          if (options) {
            if (hasOwn(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key);
              props[camelizedKey] = resolvePropValue(
                options,
                rawCurrentProps,
                camelizedKey,
                value,
                instance,
                false
              );
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps ||
!hasOwn(rawProps, key) &&

((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps &&
(rawPrevProps[key] !== void 0 ||
rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(
                options,
                rawCurrentProps,
                key,
                void 0,
                instance,
                true
              );
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn(rawProps, key) && true) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance.attrs, "set", "");
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options && hasOwn(options, camelKey = camelize(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs) || value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i = 0; i < needCastKeys.length; i++) {
        const key = needCastKeys[i];
        props[key] = resolvePropValue(
          options,
          rawCurrentProps,
          key,
          castValues[key],
          instance,
          !hasOwn(castValues, key)
        );
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
      const hasDefault = hasOwn(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            const reset = setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(
              null,
              props
            );
            reset();
          }
        } else {
          value = defaultValue;
        }
        if (instance.ce) {
          instance.ce._setProp(key, value);
        }
      }
      if (opt[
        0
]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[
          1
] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  const mixinPropsCache = new WeakMap();
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = asMixin ? mixinPropsCache : appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
        extend(normalized, props);
        if (keys2) needCastKeys.push(...keys2);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject(comp)) {
        cache.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray(raw)) {
      for (let i = 0; i < raw.length; i++) {
        const normalizedKey = camelize(raw[i]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      for (const key in raw) {
        const normalizedKey = camelize(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
          const propType = prop.type;
          let shouldCast = false;
          let shouldCastTrue = true;
          if (isArray(propType)) {
            for (let index = 0; index < propType.length; ++index) {
              const type = propType[index];
              const typeName = isFunction(type) && type.name;
              if (typeName === "Boolean") {
                shouldCast = true;
                break;
              } else if (typeName === "String") {
                shouldCastTrue = false;
              }
            }
          } else {
            shouldCast = isFunction(propType) && propType.name === "Boolean";
          }
          prop[
            0
] = shouldCast;
          prop[
            1
] = shouldCastTrue;
          if (shouldCast || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject(comp)) {
      cache.set(comp, res);
    }
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$" && !isReservedProp(key)) {
      return true;
    }
    return false;
  }
  const isInternalKey = (key) => key === "_" || key === "_ctx" || key === "$stable";
  const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  const normalizeSlot = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (false) ;
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key)) continue;
      const value = rawSlots[key];
      if (isFunction(value)) {
        slots[key] = normalizeSlot(key, value, ctx);
      } else if (value != null) {
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  const normalizeVNodeSlots = (instance, children) => {
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  const assignSlots = (slots, children, optimized) => {
    for (const key in children) {
      if (optimized || !isInternalKey(key)) {
        slots[key] = children[key];
      }
    }
  };
  const initSlots = (instance, children, optimized) => {
    const slots = instance.slots = createInternalObject();
    if (instance.vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        assignSlots(slots, children, optimized);
        if (optimized) {
          def(slots, "_", type, true);
        }
      } else {
        normalizeObjectSlots(children, slots);
      }
    } else if (children) {
      normalizeVNodeSlots(instance, children);
    }
  };
  const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        if (optimized && type === 1) {
          needDeletionCheck = false;
        } else {
          assignSlots(slots, children, optimized);
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
          delete slots[key];
        }
      }
    }
  };
  const queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    const target = getGlobalThis();
    target.__VUE__ = true;
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type, ref: ref3, shapeFlag } = n2;
      switch (type) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, namespace);
          }
          break;
        case Fragment:
          processFragment(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          break;
        default:
          if (shapeFlag & 1) {
            processElement(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 6) {
            processComponent(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 64) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (shapeFlag & 128) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else ;
      }
      if (ref3 != null && parentComponent) {
        setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      } else if (ref3 == null && n1 && n1.ref != null) {
        setRef(n1.ref, null, parentSuspense, n1, true);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateText(n2.children),
          container,
          anchor
        );
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateComment(n2.children || ""),
          container,
          anchor
        );
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, namespace) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace,
        n2.el,
        n2.anchor
      );
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      if (n2.type === "svg") {
        namespace = "svg";
      } else if (n2.type === "math") {
        namespace = "mathml";
      }
      if (n1 == null) {
        mountElement(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { props, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(
        vnode.type,
        namespace,
        props && props.is,
        props
      );
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(vnode, namespace),
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], namespace, parentComponent);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value, namespace);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i = 0; i < slotScopeIds.length; i++) {
          hostSetScopeId(el, slotScopeIds[i]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
          const parentVNode = parentComponent.vnode;
          setScopeId(
            el,
            parentVNode,
            parentVNode.scopeId,
            parentVNode.slotScopeIds,
            parentComponent.parent
          );
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
      for (let i = start; i < children.length; i++) {
        const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
        patch(
          null,
          child,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
        hostSetElementText(el, "");
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          el,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds
        );
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds,
          false
        );
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, oldProps, newProps, parentComponent, namespace);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, namespace);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              const key = propsToUpdate[i];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(el, key, prev, next, namespace, parentComponent);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
      for (let i = 0; i < newChildren.length; i++) {
        const oldVNode = oldChildren[i];
        const newVNode = newChildren[i];
        const container = (

oldVNode.el &&

(oldVNode.type === Fragment ||

!isSameVNodeType(oldVNode, newVNode) ||
oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (

fallbackContainer
          )
        );
        patch(
          oldVNode,
          newVNode,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          true
        );
      }
    };
    const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(
                el,
                key,
                oldProps[key],
                null,
                namespace,
                parentComponent
              );
            }
          }
        }
        for (const key in newProps) {
          if (isReservedProp(key)) continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(el, key, prev, next, namespace, parentComponent);
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(



n2.children || [],
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren &&

n1.dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            container,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          if (



n2.key != null || parentComponent && n2 === parentComponent.subTree
          ) {
            traverseStaticChildren(
              n1,
              n2,
              true
);
          }
        } else {
          patchChildren(
            n1,
            n2,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(
            n2,
            container,
            anchor,
            namespace,
            optimized
          );
        } else {
          mountComponent(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            optimized
          );
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
      const instance = initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      );
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        setupComponent(instance, false, optimized);
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
          initialVNode.placeholder = placeholder.el;
        }
      } else {
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          namespace,
          optimized
        );
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          updateComponentPreRender(instance, n2, optimized);
          return;
        } else {
          instance.next = n2;
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m, parent, root, type } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          toggleRecurse(instance, true);
          {
            if (root.ce &&
root.ce._def.shadowRoot !== false) {
              root.ce._injectChildStyle(type);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            patch(
              null,
              subTree,
              container,
              anchor,
              instance,
              parentSuspense,
              namespace
            );
            initialVNode.el = subTree.el;
          }
          if (m) {
            queuePostRenderEffect(m, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
              parentSuspense
            );
          }
          if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u, parent, vnode } = instance;
          {
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(() => {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          let originNext = next;
          let vnodeHook;
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          toggleRecurse(instance, true);
          const nextTree = renderComponentRoot(instance);
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          patch(
            prevTree,
            nextTree,
hostParentNode(prevTree.el),
getNextHostNode(prevTree),
            instance,
            parentSuspense,
            namespace
          );
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, next, vnode),
              parentSuspense
            );
          }
        }
      };
      instance.scope.on();
      const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
      instance.scope.off();
      const update = instance.update = effect2.run.bind(effect2);
      const job = instance.job = effect2.runIfDirty.bind(effect2);
      job.i = instance;
      job.id = instance.uid;
      effect2.scheduler = () => queueJob(job);
      toggleRecurse(instance, true);
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i;
      for (i = 0; i < commonLength; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        patch(
          c1[i],
          nextChild,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
      if (oldLength > newLength) {
        unmountChildren(
          c1,
          parentComponent,
          parentSuspense,
          true,
          false,
          commonLength
        );
      } else {
        mountChildren(
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized,
          commonLength
        );
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let i = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i <= e1 && i <= e2) {
        const n1 = c1[i];
        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        i++;
      }
      while (i <= e1 && i <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i > e1) {
        if (i <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i <= e2) {
            patch(
              null,
              c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            i++;
          }
        }
      } else if (i > e2) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } else {
        const s1 = i;
        const s2 = i;
        const keyToNewIndexMap = new Map();
        for (i = s2; i <= e2; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (nextChild.key != null) {
            keyToNewIndexMap.set(nextChild.key, i);
          }
        }
        let j;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
        for (i = s1; i <= e1; i++) {
          const prevChild = c1[i];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j = s2; j <= e2; j++) {
              if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                newIndex = j;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(
              prevChild,
              c2[newIndex],
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j = increasingNewIndexSequence.length - 1;
        for (i = toBePatched - 1; i >= 0; i--) {
          const nextIndex = s2 + i;
          const nextChild = c2[nextIndex];
          const anchorVNode = c2[nextIndex + 1];
          const anchor = nextIndex + 1 < l2 ? (
anchorVNode.el || anchorVNode.placeholder
          ) : parentAnchor;
          if (newIndexToOldIndexMap[i] === 0) {
            patch(
              null,
              nextChild,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (moved) {
            if (j < 0 || i !== increasingNewIndexSequence[j]) {
              move(nextChild, container, anchor, 2);
            } else {
              j--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type.move(vnode, container, anchor, internals);
        return;
      }
      if (type === Fragment) {
        hostInsert(el, container, anchor);
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => {
            if (vnode.ctx.isUnmounted) {
              hostRemove(el);
            } else {
              hostInsert(el, container, anchor);
            }
          };
          const performLeave = () => {
            if (el._isLeaving) {
              el[leaveCbKey](
                true
);
            }
            leave(el, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type,
        props,
        ref: ref3,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs,
        cacheIndex
      } = vnode;
      if (patchFlag === -2) {
        optimized = false;
      }
      if (ref3 != null) {
        pauseTracking();
        setRef(ref3, null, parentSuspense, vnode, true);
        resetTracking();
      }
      if (cacheIndex != null) {
        parentComponent.renderCache[cacheIndex] = void 0;
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(
            vnode,
            parentComponent,
            parentSuspense,
            internals,
            doRemove
          );
        } else if (dynamicChildren &&




!dynamicChildren.hasOnce &&
(type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(
            dynamicChildren,
            parentComponent,
            parentSuspense,
            false,
            true
          );
        } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type, el, anchor, transition } = vnode;
      if (type === Fragment) {
        {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      const { bum, scope, job, subTree, um, m, a } = instance;
      invalidateMount(m);
      invalidateMount(a);
      if (bum) {
        invokeArrayFns(bum);
      }
      scope.stop();
      if (job) {
        job.flags |= 8;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i = start; i < children.length; i++) {
        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      const el = hostNextSibling(vnode.anchor || vnode.el);
      const teleportEnd = el && el[TeleportEndKey];
      return teleportEnd ? hostNextSibling(teleportEnd) : el;
    };
    let isFlushing = false;
    const render = (vnode, container, namespace) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(
          container._vnode || null,
          vnode,
          container,
          null,
          null,
          null,
          namespace
        );
      }
      container._vnode = vnode;
      if (!isFlushing) {
        isFlushing = true;
        flushPreFlushCbs();
        flushPostFlushCbs();
        isFlushing = false;
      }
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate;
    return {
      render,
      hydrate,
      createApp: createAppAPI(render)
    };
  }
  function resolveChildrenNamespace({ type, props }, currentNamespace) {
    return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse({ effect: effect2, job }, allowed) {
    if (allowed) {
      effect2.flags |= 32;
      job.flags |= 4;
    } else {
      effect2.flags &= -33;
      job.flags &= -5;
    }
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray(ch1) && isArray(ch2)) {
      for (let i = 0; i < ch1.length; i++) {
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }
          if (!shallow && c2.patchFlag !== -2)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text &&
c2.patchFlag !== -1) {
          c2.el = c1.el;
        }
        if (c2.type === Comment && !c2.el) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
      const arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p2[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = u + v >> 1;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p2[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p2[v];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }
  function invalidateMount(hooks) {
    if (hooks) {
      for (let i = 0; i < hooks.length; i++)
        hooks[i].flags |= 8;
    }
  }
  const ssrContextKey = Symbol.for("v-scx");
  const useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey);
      return ctx;
    }
  };
  function watch(source, cb, options) {
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb, options = EMPTY_OBJ) {
    const { immediate, deep, flush, once } = options;
    const baseWatchOptions = extend({}, options);
    const runsImmediately = cb && immediate || !cb && flush !== "post";
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else if (!runsImmediately) {
        const watchStopHandle = () => {
        };
        watchStopHandle.stop = NOOP;
        watchStopHandle.resume = NOOP;
        watchStopHandle.pause = NOOP;
        return watchStopHandle;
      }
    }
    const instance = currentInstance;
    baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
    let isPre = false;
    if (flush === "post") {
      baseWatchOptions.scheduler = (job) => {
        queuePostRenderEffect(job, instance && instance.suspense);
      };
    } else if (flush !== "sync") {
      isPre = true;
      baseWatchOptions.scheduler = (job, isFirstRun) => {
        if (isFirstRun) {
          job();
        } else {
          queueJob(job);
        }
      };
    }
    baseWatchOptions.augmentJob = (job) => {
      if (cb) {
        job.flags |= 4;
      }
      if (isPre) {
        job.flags |= 2;
        if (instance) {
          job.id = instance.uid;
          job.i = instance;
        }
      }
    };
    const watchHandle = watch$1(source, cb, baseWatchOptions);
    if (isInSSRComponentSetup) {
      if (ssrCleanup) {
        ssrCleanup.push(watchHandle);
      } else if (runsImmediately) {
        watchHandle();
      }
    }
    return watchHandle;
  }
  function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const reset = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    reset();
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i = 0; i < segments.length && cur; i++) {
        cur = cur[segments[i]];
      }
      return cur;
    };
  }
  const getModelModifiers = (props, modelName) => {
    return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
  };
  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props = instance.vnode.props || EMPTY_OBJ;
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
    if (modifiers) {
      if (modifiers.trim) {
        args = rawArgs.map((a) => isString(a) ? a.trim() : a);
      }
      if (modifiers.number) {
        args = rawArgs.map(looseToNumber);
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] ||
props[handlerName = toHandlerKey(camelize(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(
        handler,
        instance,
        6,
        args
      );
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(
        onceHandler,
        instance,
        6,
        args
      );
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject(comp)) {
        cache.set(comp, null);
      }
      return null;
    }
    if (isArray(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend(normalized, raw);
    }
    if (isObject(comp)) {
      cache.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
  }
  function markAttrsAccessed() {
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit: emit2,
      render,
      renderCache,
      props,
      data,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    const prev = setCurrentRenderingInstance(instance);
    let result;
    let fallthroughAttrs;
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        const thisProxy = false ? new Proxy(proxyToUse, {
          get(target, key, receiver) {
            warn$1(
              `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
            );
            return Reflect.get(target, key, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(
          render.call(
            thisProxy,
            proxyToUse,
            renderCache,
            false ? shallowReadonly(props) : props,
            setupState,
            data,
            ctx
          )
        );
        fallthroughAttrs = attrs;
      } else {
        const render2 = Component;
        if (false) ;
        result = normalizeVNode(
          render2.length > 1 ? render2(
            false ? shallowReadonly(props) : props,
            false ? {
              get attrs() {
                markAttrsAccessed();
                return shallowReadonly(attrs);
              },
              slots,
              emit: emit2
            } : { attrs, slots, emit: emit2 }
          ) : render2(
            false ? shallowReadonly(props) : props,
            null
          )
        );
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root = result;
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys2 = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root;
      if (keys2.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys2.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(
              fallthroughAttrs,
              propsOptions
            );
          }
          root = cloneVNode(root, fallthroughAttrs, false, true);
        }
      }
    }
    if (vnode.dirs) {
      root = cloneVNode(root, null, false, true);
      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      setTransitionHooks(root, vnode.transition);
    }
    {
      result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
      if (key === "class" || key === "style" || isOn(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
      if (!isModelListener(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i = 0; i < dynamicProps.length; i++) {
          const key = dynamicProps[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
      const key = nextKeys[i];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    while (parent) {
      const root = parent.subTree;
      if (root.suspense && root.suspense.activeBranch === vnode) {
        root.el = vnode.el;
      }
      if (root === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
      } else {
        break;
      }
    }
  }
  const isSuspense = (type) => type.__isSuspense;
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  const Fragment = Symbol.for("v-fgt");
  const Text = Symbol.for("v-txt");
  const Comment = Symbol.for("v-cmt");
  const Static = Symbol.for("v-stc");
  const blockStack = [];
  let currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  let isBlockTreeEnabled = 1;
  function setBlockTracking(value, inVOnce = false) {
    isBlockTreeEnabled += value;
    if (value < 0 && currentBlock && inVOnce) {
      currentBlock.hasOnce = true;
    }
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
      createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        true
      )
    );
  }
  function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    return n1.type === n2.type && n1.key === n2.key;
  }
  const normalizeKey = ({ key }) => key != null ? key : null;
  const normalizeRef = ({
    ref: ref3,
    ref_key,
    ref_for
  }) => {
    if (typeof ref3 === "number") {
      ref3 = "" + ref3;
    }
    return ref3 != null ? isString(ref3) || isRef(ref3) || isFunction(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
  };
  function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString(children) ? 8 : 16;
    }
    if (isBlockTreeEnabled > 0 &&
!isBlockNode &&
currentBlock &&



(vnode.patchFlag > 0 || shapeFlag & 6) &&

vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  const createVNode = _createVNode;
  function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
      type = Comment;
    }
    if (isVNode(type)) {
      const cloned = cloneVNode(
        type,
        props,
        true
);
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag = -2;
      return cloned;
    }
    if (isClassComponent(type)) {
      type = type.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject(style)) {
        if (isProxy(style) && !isArray(style)) {
          style = extend({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
    return createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props) {
    if (!props) return null;
    return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
    const { props, ref: ref3, patchFlag, children, transition } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? (


mergeRef && ref3 ? isArray(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
      ) : ref3,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children,
      target: vnode.target,
      targetStart: vnode.targetStart,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,



patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition,



component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      placeholder: vnode.placeholder,
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    if (transition && cloneTransition) {
      setTransitionHooks(
        cloned,
        transition.clone(cloned)
      );
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray(child)) {
      return createVNode(
        Fragment,
        null,
child.slice()
      );
    } else if (isVNode(child)) {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray(children)) {
      type = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type = 32;
        const slotFlag = children._;
        if (!slotFlag && !isInternalObject(children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type = 16;
        children = [createTextVNode(children)];
      } else {
        type = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
      const toMerge = args[i];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  const emptyAppContext = createAppContext();
  let uid = 0;
  function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type,
      parent,
      appContext,
      root: null,
next: null,
      subTree: null,
effect: null,
      update: null,
job: null,
      scope: new EffectScope(
        true
),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      ids: parent ? parent.ids : ["", 0, 0],
      accessCache: null,
      renderCache: [],
components: null,
      directives: null,
propsOptions: normalizePropsOptions(type, appContext),
      emitsOptions: normalizeEmitsOptions(type, appContext),
emit: null,
emitted: null,
propsDefaults: EMPTY_OBJ,
inheritAttrs: type.inheritAttrs,
ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,

isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    {
      instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  let currentInstance = null;
  const getCurrentInstance = () => currentInstance || currentRenderingInstance;
  let internalSetCurrentInstance;
  let setInSSRSetupState;
  {
    const g = getGlobalThis();
    const registerGlobalSetter = (key, setter) => {
      let setters;
      if (!(setters = g[key])) setters = g[key] = [];
      setters.push(setter);
      return (v) => {
        if (setters.length > 1) setters.forEach((set) => set(v));
        else setters[0](v);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      `__VUE_INSTANCE_SETTERS__`,
      (v) => currentInstance = v
    );
    setInSSRSetupState = registerGlobalSetter(
      `__VUE_SSR_SETTERS__`,
      (v) => isInSSRComponentSetup = v
    );
  }
  const setCurrentInstance = (instance) => {
    const prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return () => {
      instance.scope.off();
      internalSetCurrentInstance(prev);
    };
  };
  const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false, optimized = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children, optimized || isSSR);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    instance.accessCache = Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    const { setup } = Component;
    if (setup) {
      pauseTracking();
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      const reset = setCurrentInstance(instance);
      const setupResult = callWithErrorHandling(
        setup,
        instance,
        0,
        [
          instance.props,
          setupContext
        ]
      );
      const isAsyncSetup = isPromise(setupResult);
      resetTracking();
      reset();
      if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
        markAsyncBoundary(instance);
      }
      if (isAsyncSetup) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
        }
      } else {
        handleSetupResult(instance, setupResult);
      }
    } else {
      finishComponentSetup(instance);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject(setupResult)) {
      instance.setupState = proxyRefs(setupResult);
    } else ;
    finishComponentSetup(instance);
  }
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      instance.render = Component.render || NOOP;
    }
    {
      const reset = setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        reset();
      }
    }
  }
  const attrsProxyHandlers = {
    get(target, key) {
      track(target, "get", "");
      return target[key];
    }
  };
  function createSetupContext(instance) {
    const expose = (exposed) => {
      instance.exposed = exposed || {};
    };
    {
      return {
        attrs: new Proxy(instance.attrs, attrsProxyHandlers),
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getComponentPublicInstance(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has(target, key) {
          return key in target || key in publicPropertiesMap;
        }
      }));
    } else {
      return instance.proxy;
    }
  }
  const classifyRE = /(?:^|[-_])(\w)/g;
  const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component, includeInferred = true) {
    return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
      const match = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component) {
            return key;
          }
        }
      };
      name = inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction(value) && "__vccOpts" in value;
  }
  const computed = (getterOrOptions, debugOptions) => {
    const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    return c;
  };
  function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
      if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  }
  const version = "3.5.20";
  /**
  * @vue/runtime-dom v3.5.20
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  let policy = void 0;
  const tt = typeof window !== "undefined" && window.trustedTypes;
  if (tt) {
    try {
      policy = tt.createPolicy("vue", {
        createHTML: (val2) => val2
      });
    } catch (e) {
    }
  }
  const unsafeToTrustedHTML = policy ? (val2) => policy.createHTML(val2) : (val2) => val2;
  const svgNS = "http://www.w3.org/2000/svg";
  const mathmlNS = "http://www.w3.org/1998/Math/MathML";
  const doc = typeof document !== "undefined" ? document : null;
  const templateContainer = doc && doc.createElement("template");
  const nodeOps = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, namespace, is, props) => {
      const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
      if (tag === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
      node.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id) {
      el.setAttribute(id, "");
    },



insertStaticContent(content, parent, anchor, namespace, start, end) {
      const before = anchor ? anchor.previousSibling : parent.lastChild;
      if (start && (start === end || start.nextSibling)) {
        while (true) {
          parent.insertBefore(start.cloneNode(true), anchor);
          if (start === end || !(start = start.nextSibling)) break;
        }
      } else {
        templateContainer.innerHTML = unsafeToTrustedHTML(
          namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
        );
        const template = templateContainer.content;
        if (namespace === "svg" || namespace === "mathml") {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent.insertBefore(template, anchor);
      }
      return [
before ? before.nextSibling : parent.firstChild,
anchor ? anchor.previousSibling : parent.lastChild
      ];
    }
  };
  const vtcKey = Symbol("_vtc");
  function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  const vShowOriginalDisplay = Symbol("_vod");
  const vShowHidden = Symbol("_vsh");
  const CSS_VAR_TEXT = Symbol("");
  const displayRE = /(^|;)\s*display\s*:/;
  function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString(next);
    let hasControlledDisplay = false;
    if (next && !isCssString) {
      if (prev) {
        if (!isString(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        } else {
          for (const prevStyle of prev.split(";")) {
            const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
      }
      for (const key in next) {
        if (key === "display") {
          hasControlledDisplay = true;
        }
        setStyle(style, key, next[key]);
      }
    } else {
      if (isCssString) {
        if (prev !== next) {
          const cssVarText = style[CSS_VAR_TEXT];
          if (cssVarText) {
            next += ";" + cssVarText;
          }
          style.cssText = next;
          hasControlledDisplay = displayRE.test(next);
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
    }
    if (vShowOriginalDisplay in el) {
      el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
      if (el[vShowHidden]) {
        style.display = "none";
      }
    }
  }
  const importantRE = /\s*!important$/;
  function setStyle(style, name, val2) {
    if (isArray(val2)) {
      val2.forEach((v) => setStyle(style, name, v));
    } else {
      if (val2 == null) val2 = "";
      if (name.startsWith("--")) {
        style.setProperty(name, val2);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val2)) {
          style.setProperty(
            hyphenate(prefixed),
            val2.replace(importantRE, ""),
            "important"
          );
        } else {
          style[prefixed] = val2;
        }
      }
    }
  }
  const prefixes = ["Webkit", "Moz", "ms"];
  const prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize(name);
    for (let i = 0; i < prefixes.length; i++) {
      const prefixed = prefixes[i] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  const xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance, isBoolean = isSpecialBooleanAttr(key)) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      if (value == null || isBoolean && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(
          key,
          isBoolean ? "" : isSymbol(value) ? String(value) : value
        );
      }
    }
  }
  function patchDOMProp(el, key, value, parentComponent, attrName) {
    if (key === "innerHTML" || key === "textContent") {
      if (value != null) {
        el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
      }
      return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" &&
!tag.includes("-")) {
      const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
      const newValue = value == null ? (

el.type === "checkbox" ? "on" : ""
      ) : String(value);
      if (oldValue !== newValue || !("_value" in el)) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      el._value = value;
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type = typeof el[key];
      if (type === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type === "string") {
        value = "";
        needRemove = true;
      } else if (type === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key] = value;
    } catch (e) {
    }
    needRemove && el.removeAttribute(attrName || key);
  }
  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  const veiKey = Symbol("_vei");
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = nextValue;
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(
          nextValue,
          instance
        );
        addEventListener(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m;
      while (m = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m[0].length);
        options[m[0].toLowerCase()] = true;
      }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options];
  }
  let cachedNow = 0;
  const p = Promise.resolve();
  const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      if (!e._vts) {
        e._vts = Date.now();
      } else if (e._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e, invoker.value),
        instance,
        5,
        [e]
      );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray(value)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map(
        (fn) => (e2) => !e2._stopped && fn && fn(e2)
      );
    } else {
      return value;
    }
  }
  const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 &&
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
  const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
    const isSVG = namespace === "svg";
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(el, key, nextValue);
      if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
        patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
      }
    } else if (
el._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))
    ) {
      patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && isNativeOn(key) && isFunction(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (key === "width" || key === "height") {
      const tag = el.tagName;
      if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key) && isString(value)) {
      return false;
    }
    return key in el;
  }
  const rendererOptions = extend({ patchProp }, nodeOps);
  let renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  const createApp = ((...args) => {
    const app = ensureRenderer().createApp(...args);
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container) return;
      const component = app._component;
      if (!isFunction(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      if (container.nodeType === 1) {
        container.textContent = "";
      }
      const proxy = mount(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  });
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function normalizeContainer(container) {
    if (isString(container)) {
      const res = document.querySelector(container);
      return res;
    }
    return container;
  }
  const _sfc_main$4 = defineComponent({
    __name: "Float",
    props: {
      initialTop: { default: 200 },
      initialRight: { default: 20 },
      dragThreshold: { default: 5 }
    },
    emits: ["click"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit2 = __emit;
      const floatingWrapper = ref(null);
      const top = ref(props.initialTop);
      const right = ref(props.initialRight);
      let isDragging = false;
      let moved = false;
      let startY = 0;
      let startTop = 0;
      function startDrag(event) {
        isDragging = true;
        moved = false;
        startY = event.clientY;
        startTop = top.value;
        document.body.style.userSelect = "none";
      }
      function onDrag(event) {
        if (!isDragging) return;
        const deltaY = event.clientY - startY;
        if (Math.abs(deltaY) > props.dragThreshold) {
          moved = true;
        }
        let newTop = startTop + deltaY;
        const windowHeight = window.innerHeight;
        const btnHeight = floatingWrapper.value?.offsetHeight || 0;
        newTop = Math.max(0, Math.min(newTop, windowHeight - btnHeight));
        top.value = newTop;
      }
      function stopDrag() {
        isDragging = false;
        document.body.style.userSelect = "";
      }
      function handleClick(event) {
        emit2("click", event, moved);
      }
      onMounted(() => {
        document.addEventListener("mousemove", onDrag);
        document.addEventListener("mouseup", stopDrag);
      });
      onBeforeUnmount(() => {
        document.removeEventListener("mousemove", onDrag);
        document.removeEventListener("mouseup", stopDrag);
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", {
          ref_key: "floatingWrapper",
          ref: floatingWrapper,
          class: "fixed z-50 cursor-grab",
          style: normalizeStyle({ top: top.value + "px", right: right.value + "px" }),
          onMousedown: startDrag,
          onClick: handleClick
        }, [
          renderSlot(_ctx.$slots, "default", {
            isDragging: unref(isDragging),
            moved: unref(moved)
          })
        ], 36);
      };
    }
  });
  function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for (f in e) e[f] && (n && (n += " "), n += f);
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
  }
  const falsyToString = (value) => typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
  const cx = clsx;
  const cva = (base, config) => (props) => {
    var _config_compoundVariants;
    if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
    const { variants, defaultVariants } = config;
    const getVariantClassNames = Object.keys(variants).map((variant) => {
      const variantProp = props === null || props === void 0 ? void 0 : props[variant];
      const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
      if (variantProp === null) return null;
      const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
      return variants[variant][variantKey];
    });
    const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
      let [key, value] = param;
      if (value === void 0) {
        return acc;
      }
      acc[key] = value;
      return acc;
    }, {});
    const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param) => {
      let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
      return Object.entries(compoundVariantOptions).every((param2) => {
        let [key, value] = param2;
        return Array.isArray(value) ? value.includes({
          ...defaultVariants,
          ...propsWithoutUndefined
        }[key]) : {
          ...defaultVariants,
          ...propsWithoutUndefined
        }[key] === value;
      }) ? [
        ...acc,
        cvClass,
        cvClassName
      ] : acc;
    }, []);
    return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
  };
  function renderSlotFragments(children) {
    if (!children) return [];
    return children.flatMap((child) => {
      if (child.type === Fragment) return renderSlotFragments(child.children);
      return [child];
    });
  }
  const Slot = defineComponent({
    name: "PrimitiveSlot",
    inheritAttrs: false,
    setup(_, { attrs, slots }) {
      return () => {
        if (!slots.default) return null;
        const children = renderSlotFragments(slots.default());
        const firstNonCommentChildrenIndex = children.findIndex((child) => child.type !== Comment);
        if (firstNonCommentChildrenIndex === -1) return children;
        const firstNonCommentChildren = children[firstNonCommentChildrenIndex];
        delete firstNonCommentChildren.props?.ref;
        const mergedProps = firstNonCommentChildren.props ? mergeProps(attrs, firstNonCommentChildren.props) : attrs;
        const cloned = cloneVNode({
          ...firstNonCommentChildren,
          props: {}
        }, mergedProps);
        if (children.length === 1) return cloned;
        children[firstNonCommentChildrenIndex] = cloned;
        return children;
      };
    }
  });
  const SELF_CLOSING_TAGS = [
    "area",
    "img",
    "input"
  ];
  const Primitive = defineComponent({
    name: "Primitive",
    inheritAttrs: false,
    props: {
      asChild: {
        type: Boolean,
        default: false
      },
      as: {
        type: [String, Object],
        default: "div"
      }
    },
    setup(props, { attrs, slots }) {
      const asTag = props.asChild ? "template" : props.as;
      if (typeof asTag === "string" && SELF_CLOSING_TAGS.includes(asTag)) return () => h(asTag, attrs);
      if (asTag !== "template") return () => h(props.as, attrs, { default: slots.default });
      return () => h(Slot, attrs, { default: slots.default });
    }
  });
  const CLASS_PART_SEPARATOR = "-";
  const createClassGroupUtils = (config) => {
    const classMap = createClassMap(config);
    const {
      conflictingClassGroups,
      conflictingClassGroupModifiers
    } = config;
    const getClassGroupId = (className) => {
      const classParts = className.split(CLASS_PART_SEPARATOR);
      if (classParts[0] === "" && classParts.length !== 1) {
        classParts.shift();
      }
      return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
    };
    const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
      const conflicts = conflictingClassGroups[classGroupId] || [];
      if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
        return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
      }
      return conflicts;
    };
    return {
      getClassGroupId,
      getConflictingClassGroupIds
    };
  };
  const getGroupRecursive = (classParts, classPartObject) => {
    if (classParts.length === 0) {
      return classPartObject.classGroupId;
    }
    const currentClassPart = classParts[0];
    const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
    const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
    if (classGroupFromNextClassPart) {
      return classGroupFromNextClassPart;
    }
    if (classPartObject.validators.length === 0) {
      return void 0;
    }
    const classRest = classParts.join(CLASS_PART_SEPARATOR);
    return classPartObject.validators.find(({
      validator
    }) => validator(classRest))?.classGroupId;
  };
  const arbitraryPropertyRegex = /^\[(.+)\]$/;
  const getGroupIdForArbitraryProperty = (className) => {
    if (arbitraryPropertyRegex.test(className)) {
      const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
      const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
      if (property) {
        return "arbitrary.." + property;
      }
    }
  };
  const createClassMap = (config) => {
    const {
      theme,
      classGroups
    } = config;
    const classMap = {
      nextPart: new Map(),
      validators: []
    };
    for (const classGroupId in classGroups) {
      processClassesRecursively(classGroups[classGroupId], classMap, classGroupId, theme);
    }
    return classMap;
  };
  const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
    classGroup.forEach((classDefinition) => {
      if (typeof classDefinition === "string") {
        const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
        classPartObjectToEdit.classGroupId = classGroupId;
        return;
      }
      if (typeof classDefinition === "function") {
        if (isThemeGetter(classDefinition)) {
          processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
          return;
        }
        classPartObject.validators.push({
          validator: classDefinition,
          classGroupId
        });
        return;
      }
      Object.entries(classDefinition).forEach(([key, classGroup2]) => {
        processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
      });
    });
  };
  const getPart = (classPartObject, path) => {
    let currentClassPartObject = classPartObject;
    path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
      if (!currentClassPartObject.nextPart.has(pathPart)) {
        currentClassPartObject.nextPart.set(pathPart, {
          nextPart: new Map(),
          validators: []
        });
      }
      currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
    });
    return currentClassPartObject;
  };
  const isThemeGetter = (func) => func.isThemeGetter;
  const createLruCache = (maxCacheSize) => {
    if (maxCacheSize < 1) {
      return {
        get: () => void 0,
        set: () => {
        }
      };
    }
    let cacheSize = 0;
    let cache = new Map();
    let previousCache = new Map();
    const update = (key, value) => {
      cache.set(key, value);
      cacheSize++;
      if (cacheSize > maxCacheSize) {
        cacheSize = 0;
        previousCache = cache;
        cache = new Map();
      }
    };
    return {
      get(key) {
        let value = cache.get(key);
        if (value !== void 0) {
          return value;
        }
        if ((value = previousCache.get(key)) !== void 0) {
          update(key, value);
          return value;
        }
      },
      set(key, value) {
        if (cache.has(key)) {
          cache.set(key, value);
        } else {
          update(key, value);
        }
      }
    };
  };
  const IMPORTANT_MODIFIER = "!";
  const MODIFIER_SEPARATOR = ":";
  const MODIFIER_SEPARATOR_LENGTH = MODIFIER_SEPARATOR.length;
  const createParseClassName = (config) => {
    const {
      prefix,
      experimentalParseClassName
    } = config;
    let parseClassName = (className) => {
      const modifiers = [];
      let bracketDepth = 0;
      let parenDepth = 0;
      let modifierStart = 0;
      let postfixModifierPosition;
      for (let index = 0; index < className.length; index++) {
        let currentCharacter = className[index];
        if (bracketDepth === 0 && parenDepth === 0) {
          if (currentCharacter === MODIFIER_SEPARATOR) {
            modifiers.push(className.slice(modifierStart, index));
            modifierStart = index + MODIFIER_SEPARATOR_LENGTH;
            continue;
          }
          if (currentCharacter === "/") {
            postfixModifierPosition = index;
            continue;
          }
        }
        if (currentCharacter === "[") {
          bracketDepth++;
        } else if (currentCharacter === "]") {
          bracketDepth--;
        } else if (currentCharacter === "(") {
          parenDepth++;
        } else if (currentCharacter === ")") {
          parenDepth--;
        }
      }
      const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
      const baseClassName = stripImportantModifier(baseClassNameWithImportantModifier);
      const hasImportantModifier = baseClassName !== baseClassNameWithImportantModifier;
      const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
      return {
        modifiers,
        hasImportantModifier,
        baseClassName,
        maybePostfixModifierPosition
      };
    };
    if (prefix) {
      const fullPrefix = prefix + MODIFIER_SEPARATOR;
      const parseClassNameOriginal = parseClassName;
      parseClassName = (className) => className.startsWith(fullPrefix) ? parseClassNameOriginal(className.substring(fullPrefix.length)) : {
        isExternal: true,
        modifiers: [],
        hasImportantModifier: false,
        baseClassName: className,
        maybePostfixModifierPosition: void 0
      };
    }
    if (experimentalParseClassName) {
      const parseClassNameOriginal = parseClassName;
      parseClassName = (className) => experimentalParseClassName({
        className,
        parseClassName: parseClassNameOriginal
      });
    }
    return parseClassName;
  };
  const stripImportantModifier = (baseClassName) => {
    if (baseClassName.endsWith(IMPORTANT_MODIFIER)) {
      return baseClassName.substring(0, baseClassName.length - 1);
    }
    if (baseClassName.startsWith(IMPORTANT_MODIFIER)) {
      return baseClassName.substring(1);
    }
    return baseClassName;
  };
  const createSortModifiers = (config) => {
    const orderSensitiveModifiers = Object.fromEntries(config.orderSensitiveModifiers.map((modifier) => [modifier, true]));
    const sortModifiers = (modifiers) => {
      if (modifiers.length <= 1) {
        return modifiers;
      }
      const sortedModifiers = [];
      let unsortedModifiers = [];
      modifiers.forEach((modifier) => {
        const isPositionSensitive = modifier[0] === "[" || orderSensitiveModifiers[modifier];
        if (isPositionSensitive) {
          sortedModifiers.push(...unsortedModifiers.sort(), modifier);
          unsortedModifiers = [];
        } else {
          unsortedModifiers.push(modifier);
        }
      });
      sortedModifiers.push(...unsortedModifiers.sort());
      return sortedModifiers;
    };
    return sortModifiers;
  };
  const createConfigUtils = (config) => ({
    cache: createLruCache(config.cacheSize),
    parseClassName: createParseClassName(config),
    sortModifiers: createSortModifiers(config),
    ...createClassGroupUtils(config)
  });
  const SPLIT_CLASSES_REGEX = /\s+/;
  const mergeClassList = (classList, configUtils) => {
    const {
      parseClassName,
      getClassGroupId,
      getConflictingClassGroupIds,
      sortModifiers
    } = configUtils;
    const classGroupsInConflict = [];
    const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
    let result = "";
    for (let index = classNames.length - 1; index >= 0; index -= 1) {
      const originalClassName = classNames[index];
      const {
        isExternal,
        modifiers,
        hasImportantModifier,
        baseClassName,
        maybePostfixModifierPosition
      } = parseClassName(originalClassName);
      if (isExternal) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      let hasPostfixModifier = !!maybePostfixModifierPosition;
      let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
      if (!classGroupId) {
        if (!hasPostfixModifier) {
          result = originalClassName + (result.length > 0 ? " " + result : result);
          continue;
        }
        classGroupId = getClassGroupId(baseClassName);
        if (!classGroupId) {
          result = originalClassName + (result.length > 0 ? " " + result : result);
          continue;
        }
        hasPostfixModifier = false;
      }
      const variantModifier = sortModifiers(modifiers).join(":");
      const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
      const classId = modifierId + classGroupId;
      if (classGroupsInConflict.includes(classId)) {
        continue;
      }
      classGroupsInConflict.push(classId);
      const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
      for (let i = 0; i < conflictGroups.length; ++i) {
        const group = conflictGroups[i];
        classGroupsInConflict.push(modifierId + group);
      }
      result = originalClassName + (result.length > 0 ? " " + result : result);
    }
    return result;
  };
  function twJoin() {
    let index = 0;
    let argument;
    let resolvedValue;
    let string = "";
    while (index < arguments.length) {
      if (argument = arguments[index++]) {
        if (resolvedValue = toValue(argument)) {
          string && (string += " ");
          string += resolvedValue;
        }
      }
    }
    return string;
  }
  const toValue = (mix) => {
    if (typeof mix === "string") {
      return mix;
    }
    let resolvedValue;
    let string = "";
    for (let k = 0; k < mix.length; k++) {
      if (mix[k]) {
        if (resolvedValue = toValue(mix[k])) {
          string && (string += " ");
          string += resolvedValue;
        }
      }
    }
    return string;
  };
  function createTailwindMerge(createConfigFirst, ...createConfigRest) {
    let configUtils;
    let cacheGet;
    let cacheSet;
    let functionToCall = initTailwindMerge;
    function initTailwindMerge(classList) {
      const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
      configUtils = createConfigUtils(config);
      cacheGet = configUtils.cache.get;
      cacheSet = configUtils.cache.set;
      functionToCall = tailwindMerge;
      return tailwindMerge(classList);
    }
    function tailwindMerge(classList) {
      const cachedResult = cacheGet(classList);
      if (cachedResult) {
        return cachedResult;
      }
      const result = mergeClassList(classList, configUtils);
      cacheSet(classList, result);
      return result;
    }
    return function callTailwindMerge() {
      return functionToCall(twJoin.apply(null, arguments));
    };
  }
  const fromTheme = (key) => {
    const themeGetter = (theme) => theme[key] || [];
    themeGetter.isThemeGetter = true;
    return themeGetter;
  };
  const arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i;
  const arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i;
  const fractionRegex = /^\d+\/\d+$/;
  const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
  const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
  const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/;
  const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
  const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
  const isFraction = (value) => fractionRegex.test(value);
  const isNumber = (value) => !!value && !Number.isNaN(Number(value));
  const isInteger = (value) => !!value && Number.isInteger(Number(value));
  const isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
  const isTshirtSize = (value) => tshirtUnitRegex.test(value);
  const isAny = () => true;
  const isLengthOnly = (value) => (


lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
  );
  const isNever = () => false;
  const isShadow = (value) => shadowRegex.test(value);
  const isImage = (value) => imageRegex.test(value);
  const isAnyNonArbitrary = (value) => !isArbitraryValue(value) && !isArbitraryVariable(value);
  const isArbitrarySize = (value) => getIsArbitraryValue(value, isLabelSize, isNever);
  const isArbitraryValue = (value) => arbitraryValueRegex.test(value);
  const isArbitraryLength = (value) => getIsArbitraryValue(value, isLabelLength, isLengthOnly);
  const isArbitraryNumber = (value) => getIsArbitraryValue(value, isLabelNumber, isNumber);
  const isArbitraryPosition = (value) => getIsArbitraryValue(value, isLabelPosition, isNever);
  const isArbitraryImage = (value) => getIsArbitraryValue(value, isLabelImage, isImage);
  const isArbitraryShadow = (value) => getIsArbitraryValue(value, isLabelShadow, isShadow);
  const isArbitraryVariable = (value) => arbitraryVariableRegex.test(value);
  const isArbitraryVariableLength = (value) => getIsArbitraryVariable(value, isLabelLength);
  const isArbitraryVariableFamilyName = (value) => getIsArbitraryVariable(value, isLabelFamilyName);
  const isArbitraryVariablePosition = (value) => getIsArbitraryVariable(value, isLabelPosition);
  const isArbitraryVariableSize = (value) => getIsArbitraryVariable(value, isLabelSize);
  const isArbitraryVariableImage = (value) => getIsArbitraryVariable(value, isLabelImage);
  const isArbitraryVariableShadow = (value) => getIsArbitraryVariable(value, isLabelShadow, true);
  const getIsArbitraryValue = (value, testLabel, testValue) => {
    const result = arbitraryValueRegex.exec(value);
    if (result) {
      if (result[1]) {
        return testLabel(result[1]);
      }
      return testValue(result[2]);
    }
    return false;
  };
  const getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false) => {
    const result = arbitraryVariableRegex.exec(value);
    if (result) {
      if (result[1]) {
        return testLabel(result[1]);
      }
      return shouldMatchNoLabel;
    }
    return false;
  };
  const isLabelPosition = (label) => label === "position" || label === "percentage";
  const isLabelImage = (label) => label === "image" || label === "url";
  const isLabelSize = (label) => label === "length" || label === "size" || label === "bg-size";
  const isLabelLength = (label) => label === "length";
  const isLabelNumber = (label) => label === "number";
  const isLabelFamilyName = (label) => label === "family-name";
  const isLabelShadow = (label) => label === "shadow";
  const getDefaultConfig = () => {
    const themeColor = fromTheme("color");
    const themeFont = fromTheme("font");
    const themeText = fromTheme("text");
    const themeFontWeight = fromTheme("font-weight");
    const themeTracking = fromTheme("tracking");
    const themeLeading = fromTheme("leading");
    const themeBreakpoint = fromTheme("breakpoint");
    const themeContainer = fromTheme("container");
    const themeSpacing = fromTheme("spacing");
    const themeRadius = fromTheme("radius");
    const themeShadow = fromTheme("shadow");
    const themeInsetShadow = fromTheme("inset-shadow");
    const themeTextShadow = fromTheme("text-shadow");
    const themeDropShadow = fromTheme("drop-shadow");
    const themeBlur = fromTheme("blur");
    const themePerspective = fromTheme("perspective");
    const themeAspect = fromTheme("aspect");
    const themeEase = fromTheme("ease");
    const themeAnimate = fromTheme("animate");
    const scaleBreak = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
    const scalePosition = () => [
      "center",
      "top",
      "bottom",
      "left",
      "right",
      "top-left",
"left-top",
      "top-right",
"right-top",
      "bottom-right",
"right-bottom",
      "bottom-left",
"left-bottom"
    ];
    const scalePositionWithArbitrary = () => [...scalePosition(), isArbitraryVariable, isArbitraryValue];
    const scaleOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
    const scaleOverscroll = () => ["auto", "contain", "none"];
    const scaleUnambiguousSpacing = () => [isArbitraryVariable, isArbitraryValue, themeSpacing];
    const scaleInset = () => [isFraction, "full", "auto", ...scaleUnambiguousSpacing()];
    const scaleGridTemplateColsRows = () => [isInteger, "none", "subgrid", isArbitraryVariable, isArbitraryValue];
    const scaleGridColRowStartAndEnd = () => ["auto", {
      span: ["full", isInteger, isArbitraryVariable, isArbitraryValue]
    }, isInteger, isArbitraryVariable, isArbitraryValue];
    const scaleGridColRowStartOrEnd = () => [isInteger, "auto", isArbitraryVariable, isArbitraryValue];
    const scaleGridAutoColsRows = () => ["auto", "min", "max", "fr", isArbitraryVariable, isArbitraryValue];
    const scaleAlignPrimaryAxis = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"];
    const scaleAlignSecondaryAxis = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"];
    const scaleMargin = () => ["auto", ...scaleUnambiguousSpacing()];
    const scaleSizing = () => [isFraction, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...scaleUnambiguousSpacing()];
    const scaleColor = () => [themeColor, isArbitraryVariable, isArbitraryValue];
    const scaleBgPosition = () => [...scalePosition(), isArbitraryVariablePosition, isArbitraryPosition, {
      position: [isArbitraryVariable, isArbitraryValue]
    }];
    const scaleBgRepeat = () => ["no-repeat", {
      repeat: ["", "x", "y", "space", "round"]
    }];
    const scaleBgSize = () => ["auto", "cover", "contain", isArbitraryVariableSize, isArbitrarySize, {
      size: [isArbitraryVariable, isArbitraryValue]
    }];
    const scaleGradientStopPosition = () => [isPercent, isArbitraryVariableLength, isArbitraryLength];
    const scaleRadius = () => [
"",
      "none",
      "full",
      themeRadius,
      isArbitraryVariable,
      isArbitraryValue
    ];
    const scaleBorderWidth = () => ["", isNumber, isArbitraryVariableLength, isArbitraryLength];
    const scaleLineStyle = () => ["solid", "dashed", "dotted", "double"];
    const scaleBlendMode = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
    const scaleMaskImagePosition = () => [isNumber, isPercent, isArbitraryVariablePosition, isArbitraryPosition];
    const scaleBlur = () => [
"",
      "none",
      themeBlur,
      isArbitraryVariable,
      isArbitraryValue
    ];
    const scaleRotate = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
    const scaleScale = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
    const scaleSkew = () => [isNumber, isArbitraryVariable, isArbitraryValue];
    const scaleTranslate = () => [isFraction, "full", ...scaleUnambiguousSpacing()];
    return {
      cacheSize: 500,
      theme: {
        animate: ["spin", "ping", "pulse", "bounce"],
        aspect: ["video"],
        blur: [isTshirtSize],
        breakpoint: [isTshirtSize],
        color: [isAny],
        container: [isTshirtSize],
        "drop-shadow": [isTshirtSize],
        ease: ["in", "out", "in-out"],
        font: [isAnyNonArbitrary],
        "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
        "inset-shadow": [isTshirtSize],
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
        perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
        radius: [isTshirtSize],
        shadow: [isTshirtSize],
        spacing: ["px", isNumber],
        text: [isTshirtSize],
        "text-shadow": [isTshirtSize],
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
      },
      classGroups: {



aspect: [{
          aspect: ["auto", "square", isFraction, isArbitraryValue, isArbitraryVariable, themeAspect]
        }],
container: ["container"],
columns: [{
          columns: [isNumber, isArbitraryValue, isArbitraryVariable, themeContainer]
        }],
"break-after": [{
          "break-after": scaleBreak()
        }],
"break-before": [{
          "break-before": scaleBreak()
        }],
"break-inside": [{
          "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
        }],
"box-decoration": [{
          "box-decoration": ["slice", "clone"]
        }],
box: [{
          box: ["border", "content"]
        }],
display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
sr: ["sr-only", "not-sr-only"],
float: [{
          float: ["right", "left", "none", "start", "end"]
        }],
clear: [{
          clear: ["left", "right", "both", "none", "start", "end"]
        }],
isolation: ["isolate", "isolation-auto"],
"object-fit": [{
          object: ["contain", "cover", "fill", "none", "scale-down"]
        }],
"object-position": [{
          object: scalePositionWithArbitrary()
        }],
overflow: [{
          overflow: scaleOverflow()
        }],
"overflow-x": [{
          "overflow-x": scaleOverflow()
        }],
"overflow-y": [{
          "overflow-y": scaleOverflow()
        }],
overscroll: [{
          overscroll: scaleOverscroll()
        }],
"overscroll-x": [{
          "overscroll-x": scaleOverscroll()
        }],
"overscroll-y": [{
          "overscroll-y": scaleOverscroll()
        }],
position: ["static", "fixed", "absolute", "relative", "sticky"],
inset: [{
          inset: scaleInset()
        }],
"inset-x": [{
          "inset-x": scaleInset()
        }],
"inset-y": [{
          "inset-y": scaleInset()
        }],
start: [{
          start: scaleInset()
        }],
end: [{
          end: scaleInset()
        }],
top: [{
          top: scaleInset()
        }],
right: [{
          right: scaleInset()
        }],
bottom: [{
          bottom: scaleInset()
        }],
left: [{
          left: scaleInset()
        }],
visibility: ["visible", "invisible", "collapse"],
z: [{
          z: [isInteger, "auto", isArbitraryVariable, isArbitraryValue]
        }],



basis: [{
          basis: [isFraction, "full", "auto", themeContainer, ...scaleUnambiguousSpacing()]
        }],
"flex-direction": [{
          flex: ["row", "row-reverse", "col", "col-reverse"]
        }],
"flex-wrap": [{
          flex: ["nowrap", "wrap", "wrap-reverse"]
        }],
flex: [{
          flex: [isNumber, isFraction, "auto", "initial", "none", isArbitraryValue]
        }],
grow: [{
          grow: ["", isNumber, isArbitraryVariable, isArbitraryValue]
        }],
shrink: [{
          shrink: ["", isNumber, isArbitraryVariable, isArbitraryValue]
        }],
order: [{
          order: [isInteger, "first", "last", "none", isArbitraryVariable, isArbitraryValue]
        }],
"grid-cols": [{
          "grid-cols": scaleGridTemplateColsRows()
        }],
"col-start-end": [{
          col: scaleGridColRowStartAndEnd()
        }],
"col-start": [{
          "col-start": scaleGridColRowStartOrEnd()
        }],
"col-end": [{
          "col-end": scaleGridColRowStartOrEnd()
        }],
"grid-rows": [{
          "grid-rows": scaleGridTemplateColsRows()
        }],
"row-start-end": [{
          row: scaleGridColRowStartAndEnd()
        }],
"row-start": [{
          "row-start": scaleGridColRowStartOrEnd()
        }],
"row-end": [{
          "row-end": scaleGridColRowStartOrEnd()
        }],
"grid-flow": [{
          "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
        }],
"auto-cols": [{
          "auto-cols": scaleGridAutoColsRows()
        }],
"auto-rows": [{
          "auto-rows": scaleGridAutoColsRows()
        }],
gap: [{
          gap: scaleUnambiguousSpacing()
        }],
"gap-x": [{
          "gap-x": scaleUnambiguousSpacing()
        }],
"gap-y": [{
          "gap-y": scaleUnambiguousSpacing()
        }],
"justify-content": [{
          justify: [...scaleAlignPrimaryAxis(), "normal"]
        }],
"justify-items": [{
          "justify-items": [...scaleAlignSecondaryAxis(), "normal"]
        }],
"justify-self": [{
          "justify-self": ["auto", ...scaleAlignSecondaryAxis()]
        }],
"align-content": [{
          content: ["normal", ...scaleAlignPrimaryAxis()]
        }],
"align-items": [{
          items: [...scaleAlignSecondaryAxis(), {
            baseline: ["", "last"]
          }]
        }],
"align-self": [{
          self: ["auto", ...scaleAlignSecondaryAxis(), {
            baseline: ["", "last"]
          }]
        }],
"place-content": [{
          "place-content": scaleAlignPrimaryAxis()
        }],
"place-items": [{
          "place-items": [...scaleAlignSecondaryAxis(), "baseline"]
        }],
"place-self": [{
          "place-self": ["auto", ...scaleAlignSecondaryAxis()]
        }],

p: [{
          p: scaleUnambiguousSpacing()
        }],
px: [{
          px: scaleUnambiguousSpacing()
        }],
py: [{
          py: scaleUnambiguousSpacing()
        }],
ps: [{
          ps: scaleUnambiguousSpacing()
        }],
pe: [{
          pe: scaleUnambiguousSpacing()
        }],
pt: [{
          pt: scaleUnambiguousSpacing()
        }],
pr: [{
          pr: scaleUnambiguousSpacing()
        }],
pb: [{
          pb: scaleUnambiguousSpacing()
        }],
pl: [{
          pl: scaleUnambiguousSpacing()
        }],
m: [{
          m: scaleMargin()
        }],
mx: [{
          mx: scaleMargin()
        }],
my: [{
          my: scaleMargin()
        }],
ms: [{
          ms: scaleMargin()
        }],
me: [{
          me: scaleMargin()
        }],
mt: [{
          mt: scaleMargin()
        }],
mr: [{
          mr: scaleMargin()
        }],
mb: [{
          mb: scaleMargin()
        }],
ml: [{
          ml: scaleMargin()
        }],
"space-x": [{
          "space-x": scaleUnambiguousSpacing()
        }],
"space-x-reverse": ["space-x-reverse"],
"space-y": [{
          "space-y": scaleUnambiguousSpacing()
        }],
"space-y-reverse": ["space-y-reverse"],



size: [{
          size: scaleSizing()
        }],
w: [{
          w: [themeContainer, "screen", ...scaleSizing()]
        }],
"min-w": [{
          "min-w": [
            themeContainer,
            "screen",
"none",
            ...scaleSizing()
          ]
        }],
"max-w": [{
          "max-w": [
            themeContainer,
            "screen",
            "none",
"prose",
{
              screen: [themeBreakpoint]
            },
            ...scaleSizing()
          ]
        }],
h: [{
          h: ["screen", "lh", ...scaleSizing()]
        }],
"min-h": [{
          "min-h": ["screen", "lh", "none", ...scaleSizing()]
        }],
"max-h": [{
          "max-h": ["screen", "lh", ...scaleSizing()]
        }],



"font-size": [{
          text: ["base", themeText, isArbitraryVariableLength, isArbitraryLength]
        }],
"font-smoothing": ["antialiased", "subpixel-antialiased"],
"font-style": ["italic", "not-italic"],
"font-weight": [{
          font: [themeFontWeight, isArbitraryVariable, isArbitraryNumber]
        }],
"font-stretch": [{
          "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", isPercent, isArbitraryValue]
        }],
"font-family": [{
          font: [isArbitraryVariableFamilyName, isArbitraryValue, themeFont]
        }],
"fvn-normal": ["normal-nums"],
"fvn-ordinal": ["ordinal"],
"fvn-slashed-zero": ["slashed-zero"],
"fvn-figure": ["lining-nums", "oldstyle-nums"],
"fvn-spacing": ["proportional-nums", "tabular-nums"],
"fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
tracking: [{
          tracking: [themeTracking, isArbitraryVariable, isArbitraryValue]
        }],
"line-clamp": [{
          "line-clamp": [isNumber, "none", isArbitraryVariable, isArbitraryNumber]
        }],
leading: [{
          leading: [
themeLeading,
            ...scaleUnambiguousSpacing()
          ]
        }],
"list-image": [{
          "list-image": ["none", isArbitraryVariable, isArbitraryValue]
        }],
"list-style-position": [{
          list: ["inside", "outside"]
        }],
"list-style-type": [{
          list: ["disc", "decimal", "none", isArbitraryVariable, isArbitraryValue]
        }],
"text-alignment": [{
          text: ["left", "center", "right", "justify", "start", "end"]
        }],
"placeholder-color": [{
          placeholder: scaleColor()
        }],
"text-color": [{
          text: scaleColor()
        }],
"text-decoration": ["underline", "overline", "line-through", "no-underline"],
"text-decoration-style": [{
          decoration: [...scaleLineStyle(), "wavy"]
        }],
"text-decoration-thickness": [{
          decoration: [isNumber, "from-font", "auto", isArbitraryVariable, isArbitraryLength]
        }],
"text-decoration-color": [{
          decoration: scaleColor()
        }],
"underline-offset": [{
          "underline-offset": [isNumber, "auto", isArbitraryVariable, isArbitraryValue]
        }],
"text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
"text-overflow": ["truncate", "text-ellipsis", "text-clip"],
"text-wrap": [{
          text: ["wrap", "nowrap", "balance", "pretty"]
        }],
indent: [{
          indent: scaleUnambiguousSpacing()
        }],
"vertical-align": [{
          align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryVariable, isArbitraryValue]
        }],
whitespace: [{
          whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
        }],
break: [{
          break: ["normal", "words", "all", "keep"]
        }],
wrap: [{
          wrap: ["break-word", "anywhere", "normal"]
        }],
hyphens: [{
          hyphens: ["none", "manual", "auto"]
        }],
content: [{
          content: ["none", isArbitraryVariable, isArbitraryValue]
        }],



"bg-attachment": [{
          bg: ["fixed", "local", "scroll"]
        }],
"bg-clip": [{
          "bg-clip": ["border", "padding", "content", "text"]
        }],
"bg-origin": [{
          "bg-origin": ["border", "padding", "content"]
        }],
"bg-position": [{
          bg: scaleBgPosition()
        }],
"bg-repeat": [{
          bg: scaleBgRepeat()
        }],
"bg-size": [{
          bg: scaleBgSize()
        }],
"bg-image": [{
          bg: ["none", {
            linear: [{
              to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
            }, isInteger, isArbitraryVariable, isArbitraryValue],
            radial: ["", isArbitraryVariable, isArbitraryValue],
            conic: [isInteger, isArbitraryVariable, isArbitraryValue]
          }, isArbitraryVariableImage, isArbitraryImage]
        }],
"bg-color": [{
          bg: scaleColor()
        }],
"gradient-from-pos": [{
          from: scaleGradientStopPosition()
        }],
"gradient-via-pos": [{
          via: scaleGradientStopPosition()
        }],
"gradient-to-pos": [{
          to: scaleGradientStopPosition()
        }],
"gradient-from": [{
          from: scaleColor()
        }],
"gradient-via": [{
          via: scaleColor()
        }],
"gradient-to": [{
          to: scaleColor()
        }],



rounded: [{
          rounded: scaleRadius()
        }],
"rounded-s": [{
          "rounded-s": scaleRadius()
        }],
"rounded-e": [{
          "rounded-e": scaleRadius()
        }],
"rounded-t": [{
          "rounded-t": scaleRadius()
        }],
"rounded-r": [{
          "rounded-r": scaleRadius()
        }],
"rounded-b": [{
          "rounded-b": scaleRadius()
        }],
"rounded-l": [{
          "rounded-l": scaleRadius()
        }],
"rounded-ss": [{
          "rounded-ss": scaleRadius()
        }],
"rounded-se": [{
          "rounded-se": scaleRadius()
        }],
"rounded-ee": [{
          "rounded-ee": scaleRadius()
        }],
"rounded-es": [{
          "rounded-es": scaleRadius()
        }],
"rounded-tl": [{
          "rounded-tl": scaleRadius()
        }],
"rounded-tr": [{
          "rounded-tr": scaleRadius()
        }],
"rounded-br": [{
          "rounded-br": scaleRadius()
        }],
"rounded-bl": [{
          "rounded-bl": scaleRadius()
        }],
"border-w": [{
          border: scaleBorderWidth()
        }],
"border-w-x": [{
          "border-x": scaleBorderWidth()
        }],
"border-w-y": [{
          "border-y": scaleBorderWidth()
        }],
"border-w-s": [{
          "border-s": scaleBorderWidth()
        }],
"border-w-e": [{
          "border-e": scaleBorderWidth()
        }],
"border-w-t": [{
          "border-t": scaleBorderWidth()
        }],
"border-w-r": [{
          "border-r": scaleBorderWidth()
        }],
"border-w-b": [{
          "border-b": scaleBorderWidth()
        }],
"border-w-l": [{
          "border-l": scaleBorderWidth()
        }],
"divide-x": [{
          "divide-x": scaleBorderWidth()
        }],
"divide-x-reverse": ["divide-x-reverse"],
"divide-y": [{
          "divide-y": scaleBorderWidth()
        }],
"divide-y-reverse": ["divide-y-reverse"],
"border-style": [{
          border: [...scaleLineStyle(), "hidden", "none"]
        }],
"divide-style": [{
          divide: [...scaleLineStyle(), "hidden", "none"]
        }],
"border-color": [{
          border: scaleColor()
        }],
"border-color-x": [{
          "border-x": scaleColor()
        }],
"border-color-y": [{
          "border-y": scaleColor()
        }],
"border-color-s": [{
          "border-s": scaleColor()
        }],
"border-color-e": [{
          "border-e": scaleColor()
        }],
"border-color-t": [{
          "border-t": scaleColor()
        }],
"border-color-r": [{
          "border-r": scaleColor()
        }],
"border-color-b": [{
          "border-b": scaleColor()
        }],
"border-color-l": [{
          "border-l": scaleColor()
        }],
"divide-color": [{
          divide: scaleColor()
        }],
"outline-style": [{
          outline: [...scaleLineStyle(), "none", "hidden"]
        }],
"outline-offset": [{
          "outline-offset": [isNumber, isArbitraryVariable, isArbitraryValue]
        }],
"outline-w": [{
          outline: ["", isNumber, isArbitraryVariableLength, isArbitraryLength]
        }],
"outline-color": [{
          outline: scaleColor()
        }],



shadow: [{
          shadow: [
"",
            "none",
            themeShadow,
            isArbitraryVariableShadow,
            isArbitraryShadow
          ]
        }],
"shadow-color": [{
          shadow: scaleColor()
        }],
"inset-shadow": [{
          "inset-shadow": ["none", themeInsetShadow, isArbitraryVariableShadow, isArbitraryShadow]
        }],
"inset-shadow-color": [{
          "inset-shadow": scaleColor()
        }],
"ring-w": [{
          ring: scaleBorderWidth()
        }],
"ring-w-inset": ["ring-inset"],
"ring-color": [{
          ring: scaleColor()
        }],
"ring-offset-w": [{
          "ring-offset": [isNumber, isArbitraryLength]
        }],
"ring-offset-color": [{
          "ring-offset": scaleColor()
        }],
"inset-ring-w": [{
          "inset-ring": scaleBorderWidth()
        }],
"inset-ring-color": [{
          "inset-ring": scaleColor()
        }],
"text-shadow": [{
          "text-shadow": ["none", themeTextShadow, isArbitraryVariableShadow, isArbitraryShadow]
        }],
"text-shadow-color": [{
          "text-shadow": scaleColor()
        }],
opacity: [{
          opacity: [isNumber, isArbitraryVariable, isArbitraryValue]
        }],
"mix-blend": [{
          "mix-blend": [...scaleBlendMode(), "plus-darker", "plus-lighter"]
        }],
"bg-blend": [{
          "bg-blend": scaleBlendMode()
        }],
"mask-clip": [{
          "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
        }, "mask-no-clip"],
"mask-composite": [{
          mask: ["add", "subtract", "intersect", "exclude"]
        }],
"mask-image-linear-pos": [{
          "mask-linear": [isNumber]
        }],
        "mask-image-linear-from-pos": [{
          "mask-linear-from": scaleMaskImagePosition()
        }],
        "mask-image-linear-to-pos": [{
          "mask-linear-to": scaleMaskImagePosition()
        }],
        "mask-image-linear-from-color": [{
          "mask-linear-from": scaleColor()
        }],
        "mask-image-linear-to-color": [{
          "mask-linear-to": scaleColor()
        }],
        "mask-image-t-from-pos": [{
          "mask-t-from": scaleMaskImagePosition()
        }],
        "mask-image-t-to-pos": [{
          "mask-t-to": scaleMaskImagePosition()
        }],
        "mask-image-t-from-color": [{
          "mask-t-from": scaleColor()
        }],
        "mask-image-t-to-color": [{
          "mask-t-to": scaleColor()
        }],
        "mask-image-r-from-pos": [{
          "mask-r-from": scaleMaskImagePosition()
        }],
        "mask-image-r-to-pos": [{
          "mask-r-to": scaleMaskImagePosition()
        }],
        "mask-image-r-from-color": [{
          "mask-r-from": scaleColor()
        }],
        "mask-image-r-to-color": [{
          "mask-r-to": scaleColor()
        }],
        "mask-image-b-from-pos": [{
          "mask-b-from": scaleMaskImagePosition()
        }],
        "mask-image-b-to-pos": [{
          "mask-b-to": scaleMaskImagePosition()
        }],
        "mask-image-b-from-color": [{
          "mask-b-from": scaleColor()
        }],
        "mask-image-b-to-color": [{
          "mask-b-to": scaleColor()
        }],
        "mask-image-l-from-pos": [{
          "mask-l-from": scaleMaskImagePosition()
        }],
        "mask-image-l-to-pos": [{
          "mask-l-to": scaleMaskImagePosition()
        }],
        "mask-image-l-from-color": [{
          "mask-l-from": scaleColor()
        }],
        "mask-image-l-to-color": [{
          "mask-l-to": scaleColor()
        }],
        "mask-image-x-from-pos": [{
          "mask-x-from": scaleMaskImagePosition()
        }],
        "mask-image-x-to-pos": [{
          "mask-x-to": scaleMaskImagePosition()
        }],
        "mask-image-x-from-color": [{
          "mask-x-from": scaleColor()
        }],
        "mask-image-x-to-color": [{
          "mask-x-to": scaleColor()
        }],
        "mask-image-y-from-pos": [{
          "mask-y-from": scaleMaskImagePosition()
        }],
        "mask-image-y-to-pos": [{
          "mask-y-to": scaleMaskImagePosition()
        }],
        "mask-image-y-from-color": [{
          "mask-y-from": scaleColor()
        }],
        "mask-image-y-to-color": [{
          "mask-y-to": scaleColor()
        }],
        "mask-image-radial": [{
          "mask-radial": [isArbitraryVariable, isArbitraryValue]
        }],
        "mask-image-radial-from-pos": [{
          "mask-radial-from": scaleMaskImagePosition()
        }],
        "mask-image-radial-to-pos": [{
          "mask-radial-to": scaleMaskImagePosition()
        }],
        "mask-image-radial-from-color": [{
          "mask-radial-from": scaleColor()
        }],
        "mask-image-radial-to-color": [{
          "mask-radial-to": scaleColor()
        }],
        "mask-image-radial-shape": [{
          "mask-radial": ["circle", "ellipse"]
        }],
        "mask-image-radial-size": [{
          "mask-radial": [{
            closest: ["side", "corner"],
            farthest: ["side", "corner"]
          }]
        }],
        "mask-image-radial-pos": [{
          "mask-radial-at": scalePosition()
        }],
        "mask-image-conic-pos": [{
          "mask-conic": [isNumber]
        }],
        "mask-image-conic-from-pos": [{
          "mask-conic-from": scaleMaskImagePosition()
        }],
        "mask-image-conic-to-pos": [{
          "mask-conic-to": scaleMaskImagePosition()
        }],
        "mask-image-conic-from-color": [{
          "mask-conic-from": scaleColor()
        }],
        "mask-image-conic-to-color": [{
          "mask-conic-to": scaleColor()
        }],
"mask-mode": [{
          mask: ["alpha", "luminance", "match"]
        }],
"mask-origin": [{
          "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
        }],
"mask-position": [{
          mask: scaleBgPosition()
        }],
"mask-repeat": [{
          mask: scaleBgRepeat()
        }],
"mask-size": [{
          mask: scaleBgSize()
        }],
"mask-type": [{
          "mask-type": ["alpha", "luminance"]
        }],
"mask-image": [{
          mask: ["none", isArbitraryVariable, isArbitraryValue]
        }],



filter: [{
          filter: [
"",
            "none",
            isArbitraryVariable,
            isArbitraryValue
          ]
        }],
blur: [{
          blur: scaleBlur()
        }],
brightness: [{
          brightness: [isNumber, isArbitraryVariable, isArbitraryValue]
        }],
contrast: [{
          contrast: [isNumber, isArbitraryVariable, isArbitraryValue]
        }],
"drop-shadow": [{
          "drop-shadow": [
"",
            "none",
            themeDropShadow,
            isArbitraryVariableShadow,
            isArbitraryShadow
          ]
        }],
"drop-shadow-color": [{
          "drop-shadow": scaleColor()
        }],
grayscale: [{
          grayscale: ["", isNumber, isArbitraryVariable, isArbitraryValue]
        }],
"hue-rotate": [{
          "hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue]
        }],
invert: [{
          invert: ["", isNumber, isArbitraryVariable, isArbitraryValue]
        }],
saturate: [{
          saturate: [isNumber, isArbitraryVariable, isArbitraryValue]
        }],
sepia: [{
          sepia: ["", isNumber, isArbitraryVariable, isArbitraryValue]
        }],
"backdrop-filter": [{
          "backdrop-filter": [
"",
            "none",
            isArbitraryVariable,
            isArbitraryValue
          ]
        }],
"backdrop-blur": [{
          "backdrop-blur": scaleBlur()
        }],
"backdrop-brightness": [{
          "backdrop-brightness": [isNumber, isArbitraryVariable, isArbitraryValue]
        }],
"backdrop-contrast": [{
          "backdrop-contrast": [isNumber, isArbitraryVariable, isArbitraryValue]
        }],
"backdrop-grayscale": [{
          "backdrop-grayscale": ["", isNumber, isArbitraryVariable, isArbitraryValue]
        }],
"backdrop-hue-rotate": [{
          "backdrop-hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue]
        }],
"backdrop-invert": [{
          "backdrop-invert": ["", isNumber, isArbitraryVariable, isArbitraryValue]
        }],
"backdrop-opacity": [{
          "backdrop-opacity": [isNumber, isArbitraryVariable, isArbitraryValue]
        }],
"backdrop-saturate": [{
          "backdrop-saturate": [isNumber, isArbitraryVariable, isArbitraryValue]
        }],
"backdrop-sepia": [{
          "backdrop-sepia": ["", isNumber, isArbitraryVariable, isArbitraryValue]
        }],



"border-collapse": [{
          border: ["collapse", "separate"]
        }],
"border-spacing": [{
          "border-spacing": scaleUnambiguousSpacing()
        }],
"border-spacing-x": [{
          "border-spacing-x": scaleUnambiguousSpacing()
        }],
"border-spacing-y": [{
          "border-spacing-y": scaleUnambiguousSpacing()
        }],
"table-layout": [{
          table: ["auto", "fixed"]
        }],
caption: [{
          caption: ["top", "bottom"]
        }],



transition: [{
          transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", isArbitraryVariable, isArbitraryValue]
        }],
"transition-behavior": [{
          transition: ["normal", "discrete"]
        }],
duration: [{
          duration: [isNumber, "initial", isArbitraryVariable, isArbitraryValue]
        }],
ease: [{
          ease: ["linear", "initial", themeEase, isArbitraryVariable, isArbitraryValue]
        }],
delay: [{
          delay: [isNumber, isArbitraryVariable, isArbitraryValue]
        }],
animate: [{
          animate: ["none", themeAnimate, isArbitraryVariable, isArbitraryValue]
        }],



backface: [{
          backface: ["hidden", "visible"]
        }],
perspective: [{
          perspective: [themePerspective, isArbitraryVariable, isArbitraryValue]
        }],
"perspective-origin": [{
          "perspective-origin": scalePositionWithArbitrary()
        }],
rotate: [{
          rotate: scaleRotate()
        }],
"rotate-x": [{
          "rotate-x": scaleRotate()
        }],
"rotate-y": [{
          "rotate-y": scaleRotate()
        }],
"rotate-z": [{
          "rotate-z": scaleRotate()
        }],
scale: [{
          scale: scaleScale()
        }],
"scale-x": [{
          "scale-x": scaleScale()
        }],
"scale-y": [{
          "scale-y": scaleScale()
        }],
"scale-z": [{
          "scale-z": scaleScale()
        }],
"scale-3d": ["scale-3d"],
skew: [{
          skew: scaleSkew()
        }],
"skew-x": [{
          "skew-x": scaleSkew()
        }],
"skew-y": [{
          "skew-y": scaleSkew()
        }],
transform: [{
          transform: [isArbitraryVariable, isArbitraryValue, "", "none", "gpu", "cpu"]
        }],
"transform-origin": [{
          origin: scalePositionWithArbitrary()
        }],
"transform-style": [{
          transform: ["3d", "flat"]
        }],
translate: [{
          translate: scaleTranslate()
        }],
"translate-x": [{
          "translate-x": scaleTranslate()
        }],
"translate-y": [{
          "translate-y": scaleTranslate()
        }],
"translate-z": [{
          "translate-z": scaleTranslate()
        }],
"translate-none": ["translate-none"],



accent: [{
          accent: scaleColor()
        }],
appearance: [{
          appearance: ["none", "auto"]
        }],
"caret-color": [{
          caret: scaleColor()
        }],
"color-scheme": [{
          scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
        }],
cursor: [{
          cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryVariable, isArbitraryValue]
        }],
"field-sizing": [{
          "field-sizing": ["fixed", "content"]
        }],
"pointer-events": [{
          "pointer-events": ["auto", "none"]
        }],
resize: [{
          resize: ["none", "", "y", "x"]
        }],
"scroll-behavior": [{
          scroll: ["auto", "smooth"]
        }],
"scroll-m": [{
          "scroll-m": scaleUnambiguousSpacing()
        }],
"scroll-mx": [{
          "scroll-mx": scaleUnambiguousSpacing()
        }],
"scroll-my": [{
          "scroll-my": scaleUnambiguousSpacing()
        }],
"scroll-ms": [{
          "scroll-ms": scaleUnambiguousSpacing()
        }],
"scroll-me": [{
          "scroll-me": scaleUnambiguousSpacing()
        }],
"scroll-mt": [{
          "scroll-mt": scaleUnambiguousSpacing()
        }],
"scroll-mr": [{
          "scroll-mr": scaleUnambiguousSpacing()
        }],
"scroll-mb": [{
          "scroll-mb": scaleUnambiguousSpacing()
        }],
"scroll-ml": [{
          "scroll-ml": scaleUnambiguousSpacing()
        }],
"scroll-p": [{
          "scroll-p": scaleUnambiguousSpacing()
        }],
"scroll-px": [{
          "scroll-px": scaleUnambiguousSpacing()
        }],
"scroll-py": [{
          "scroll-py": scaleUnambiguousSpacing()
        }],
"scroll-ps": [{
          "scroll-ps": scaleUnambiguousSpacing()
        }],
"scroll-pe": [{
          "scroll-pe": scaleUnambiguousSpacing()
        }],
"scroll-pt": [{
          "scroll-pt": scaleUnambiguousSpacing()
        }],
"scroll-pr": [{
          "scroll-pr": scaleUnambiguousSpacing()
        }],
"scroll-pb": [{
          "scroll-pb": scaleUnambiguousSpacing()
        }],
"scroll-pl": [{
          "scroll-pl": scaleUnambiguousSpacing()
        }],
"snap-align": [{
          snap: ["start", "end", "center", "align-none"]
        }],
"snap-stop": [{
          snap: ["normal", "always"]
        }],
"snap-type": [{
          snap: ["none", "x", "y", "both"]
        }],
"snap-strictness": [{
          snap: ["mandatory", "proximity"]
        }],
touch: [{
          touch: ["auto", "none", "manipulation"]
        }],
"touch-x": [{
          "touch-pan": ["x", "left", "right"]
        }],
"touch-y": [{
          "touch-pan": ["y", "up", "down"]
        }],
"touch-pz": ["touch-pinch-zoom"],
select: [{
          select: ["none", "text", "all", "auto"]
        }],
"will-change": [{
          "will-change": ["auto", "scroll", "contents", "transform", isArbitraryVariable, isArbitraryValue]
        }],



fill: [{
          fill: ["none", ...scaleColor()]
        }],
"stroke-w": [{
          stroke: [isNumber, isArbitraryVariableLength, isArbitraryLength, isArbitraryNumber]
        }],
stroke: [{
          stroke: ["none", ...scaleColor()]
        }],



"forced-color-adjust": [{
          "forced-color-adjust": ["auto", "none"]
        }]
      },
      conflictingClassGroups: {
        overflow: ["overflow-x", "overflow-y"],
        overscroll: ["overscroll-x", "overscroll-y"],
        inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
        "inset-x": ["right", "left"],
        "inset-y": ["top", "bottom"],
        flex: ["basis", "grow", "shrink"],
        gap: ["gap-x", "gap-y"],
        p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
        px: ["pr", "pl"],
        py: ["pt", "pb"],
        m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
        mx: ["mr", "ml"],
        my: ["mt", "mb"],
        size: ["w", "h"],
        "font-size": ["leading"],
        "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
        "fvn-ordinal": ["fvn-normal"],
        "fvn-slashed-zero": ["fvn-normal"],
        "fvn-figure": ["fvn-normal"],
        "fvn-spacing": ["fvn-normal"],
        "fvn-fraction": ["fvn-normal"],
        "line-clamp": ["display", "overflow"],
        rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
        "rounded-s": ["rounded-ss", "rounded-es"],
        "rounded-e": ["rounded-se", "rounded-ee"],
        "rounded-t": ["rounded-tl", "rounded-tr"],
        "rounded-r": ["rounded-tr", "rounded-br"],
        "rounded-b": ["rounded-br", "rounded-bl"],
        "rounded-l": ["rounded-tl", "rounded-bl"],
        "border-spacing": ["border-spacing-x", "border-spacing-y"],
        "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
        "border-w-x": ["border-w-r", "border-w-l"],
        "border-w-y": ["border-w-t", "border-w-b"],
        "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
        "border-color-x": ["border-color-r", "border-color-l"],
        "border-color-y": ["border-color-t", "border-color-b"],
        translate: ["translate-x", "translate-y", "translate-none"],
        "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
        "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
        "scroll-mx": ["scroll-mr", "scroll-ml"],
        "scroll-my": ["scroll-mt", "scroll-mb"],
        "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
        "scroll-px": ["scroll-pr", "scroll-pl"],
        "scroll-py": ["scroll-pt", "scroll-pb"],
        touch: ["touch-x", "touch-y", "touch-pz"],
        "touch-x": ["touch"],
        "touch-y": ["touch"],
        "touch-pz": ["touch"]
      },
      conflictingClassGroupModifiers: {
        "font-size": ["leading"]
      },
      orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
    };
  };
  const twMerge = createTailwindMerge(getDefaultConfig);
  function cn(...inputs) {
    return twMerge(clsx(inputs));
  }
  const _sfc_main$3 = defineComponent({
    __name: "Button",
    props: {
      variant: {},
      size: {},
      class: {},
      asChild: { type: Boolean },
      as: { default: "button" }
    },
    setup(__props) {
      const props = __props;
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(Primitive), {
          "data-slot": "button",
          as: _ctx.as,
          "as-child": _ctx.asChild,
          class: normalizeClass(unref(cn)(unref(buttonVariants)({ variant: _ctx.variant, size: _ctx.size }), props.class))
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["as", "as-child", "class"]);
      };
    }
  });
  const buttonVariants = cva(
    "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
    {
      variants: {
        variant: {
          default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
          destructive: "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
          outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
          secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
          ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
          link: "text-primary underline-offset-4 hover:underline"
        },
        size: {
          default: "h-9 px-4 py-2 has-[>svg]:px-3",
          sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
          lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
          icon: "size-9"
        }
      },
      defaultVariants: {
        variant: "default",
        size: "default"
      }
    }
  );
  /**
   * @license lucide-vue-next v0.542.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
  const toCamelCase = (string) => string.replace(
    /^([A-Z])|[\s-_]+(\w)/g,
    (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()
  );
  const toPascalCase = (string) => {
    const camelCase = toCamelCase(string);
    return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
  };
  const mergeClasses = (...classes) => classes.filter((className, index, array) => {
    return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
  }).join(" ").trim();
  const isEmptyString = (value) => value === "";
  /**
   * @license lucide-vue-next v0.542.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  var defaultAttributes = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    "stroke-width": 2,
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  };
  /**
   * @license lucide-vue-next v0.542.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Icon = ({
    name,
    iconNode,
    absoluteStrokeWidth,
    "absolute-stroke-width": absoluteStrokeWidthKebabCase,
    strokeWidth,
    "stroke-width": strokeWidthKebabCase,
    size = defaultAttributes.width,
    color = defaultAttributes.stroke,
    ...props
  }, { slots }) => {
    return h(
      "svg",
      {
        ...defaultAttributes,
        ...props,
        width: size,
        height: size,
        stroke: color,
        "stroke-width": isEmptyString(absoluteStrokeWidth) || isEmptyString(absoluteStrokeWidthKebabCase) || absoluteStrokeWidth === true || absoluteStrokeWidthKebabCase === true ? Number(strokeWidth || strokeWidthKebabCase || defaultAttributes["stroke-width"]) * 24 / Number(size) : strokeWidth || strokeWidthKebabCase || defaultAttributes["stroke-width"],
        class: mergeClasses(
          "lucide",
          props.class,
          ...name ? [`lucide-${toKebabCase(toPascalCase(name))}-icon`, `lucide-${toKebabCase(name)}`] : ["lucide-icon"]
        )
      },
      [...iconNode.map((child) => h(...child)), ...slots.default ? [slots.default()] : []]
    );
  };
  /**
   * @license lucide-vue-next v0.542.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const createLucideIcon = (iconName, iconNode) => (props, { slots, attrs }) => h(
    Icon,
    {
      ...attrs,
      ...props,
      iconNode,
      name: iconName
    },
    slots
  );
  /**
   * @license lucide-vue-next v0.542.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const PowerOff = createLucideIcon("power-off", [
    ["path", { d: "M18.36 6.64A9 9 0 0 1 20.77 15", key: "dxknvb" }],
    ["path", { d: "M6.16 6.16a9 9 0 1 0 12.68 12.68", key: "1x7qb5" }],
    ["path", { d: "M12 2v4", key: "3427ic" }],
    ["path", { d: "m2 2 20 20", key: "1ooewy" }]
  ]);
  /**
   * @license lucide-vue-next v0.542.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */
  const Power = createLucideIcon("power", [
    ["path", { d: "M12 2v10", key: "mnfbl" }],
    ["path", { d: "M18.4 6.6a9 9 0 1 1-12.77.04", key: "obofu9" }]
  ]);
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var dayjs_min$1 = { exports: {} };
  var dayjs_min = dayjs_min$1.exports;
  var hasRequiredDayjs_min;
  function requireDayjs_min() {
    if (hasRequiredDayjs_min) return dayjs_min$1.exports;
    hasRequiredDayjs_min = 1;
    (function(module, exports) {
      !(function(t, e) {
        module.exports = e();
      })(dayjs_min, (function() {
        var t = 1e3, e = 6e4, n = 36e5, r2 = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h2 = "year", d = "date", l = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
          var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
          return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
        } }, m = function(t2, e2, n2) {
          var r3 = String(t2);
          return !r3 || r3.length >= e2 ? t2 : "" + Array(e2 + 1 - r3.length).join(n2) + t2;
        }, v = { s: m, z: function(t2) {
          var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r3 = Math.floor(n2 / 60), i2 = n2 % 60;
          return (e2 <= 0 ? "+" : "-") + m(r3, 2, "0") + ":" + m(i2, 2, "0");
        }, m: function t2(e2, n2) {
          if (e2.date() < n2.date()) return -t2(n2, e2);
          var r3 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r3, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r3 + (s2 ? -1 : 1), c);
          return +(-(r3 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
        }, a: function(t2) {
          return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
        }, p: function(t2) {
          return { M: c, y: h2, w: o, d: a, D: d, h: u, m: s, s: i, ms: r2, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t2) {
          return void 0 === t2;
        } }, g = "en", D = {};
        D[g] = M;
        var p2 = "$isDayjsObject", S = function(t2) {
          return t2 instanceof _ || !(!t2 || !t2[p2]);
        }, w = function t2(e2, n2, r3) {
          var i2;
          if (!e2) return g;
          if ("string" == typeof e2) {
            var s2 = e2.toLowerCase();
            D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
            var u2 = e2.split("-");
            if (!i2 && u2.length > 1) return t2(u2[0]);
          } else {
            var a2 = e2.name;
            D[a2] = e2, i2 = a2;
          }
          return !r3 && i2 && (g = i2), i2 || !r3 && g;
        }, O = function(t2, e2) {
          if (S(t2)) return t2.clone();
          var n2 = "object" == typeof e2 ? e2 : {};
          return n2.date = t2, n2.args = arguments, new _(n2);
        }, b = v;
        b.l = w, b.i = S, b.w = function(t2, e2) {
          return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
        };
        var _ = (function() {
          function M2(t2) {
            this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p2] = true;
          }
          var m2 = M2.prototype;
          return m2.parse = function(t2) {
            this.$d = (function(t3) {
              var e2 = t3.date, n2 = t3.utc;
              if (null === e2) return new Date(NaN);
              if (b.u(e2)) return new Date();
              if (e2 instanceof Date) return new Date(e2);
              if ("string" == typeof e2 && !/Z$/i.test(e2)) {
                var r3 = e2.match($2);
                if (r3) {
                  var i2 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
                  return n2 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
                }
              }
              return new Date(e2);
            })(t2), this.init();
          }, m2.init = function() {
            var t2 = this.$d;
            this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
          }, m2.$utils = function() {
            return b;
          }, m2.isValid = function() {
            return !(this.$d.toString() === l);
          }, m2.isSame = function(t2, e2) {
            var n2 = O(t2);
            return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
          }, m2.isAfter = function(t2, e2) {
            return O(t2) < this.startOf(e2);
          }, m2.isBefore = function(t2, e2) {
            return this.endOf(e2) < O(t2);
          }, m2.$g = function(t2, e2, n2) {
            return b.u(t2) ? this[e2] : this.set(n2, t2);
          }, m2.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m2.valueOf = function() {
            return this.$d.getTime();
          }, m2.startOf = function(t2, e2) {
            var n2 = this, r3 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
              var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
              return r3 ? i2 : i2.endOf(a);
            }, $3 = function(t3, e3) {
              return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
            }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
            switch (f2) {
              case h2:
                return r3 ? l2(1, 0) : l2(31, 11);
              case c:
                return r3 ? l2(1, M3) : l2(0, M3 + 1);
              case o:
                var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
                return l2(r3 ? m3 - D2 : m3 + (6 - D2), M3);
              case a:
              case d:
                return $3(v2 + "Hours", 0);
              case u:
                return $3(v2 + "Minutes", 1);
              case s:
                return $3(v2 + "Seconds", 2);
              case i:
                return $3(v2 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m2.endOf = function(t2) {
            return this.startOf(t2, false);
          }, m2.$set = function(t2, e2) {
            var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h2] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r2] = f2 + "Milliseconds", n2)[o2], $3 = o2 === a ? this.$D + (e2 - this.$W) : e2;
            if (o2 === c || o2 === h2) {
              var y2 = this.clone().set(d, 1);
              y2.$d[l2]($3), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
            } else l2 && this.$d[l2]($3);
            return this.init(), this;
          }, m2.set = function(t2, e2) {
            return this.clone().$set(t2, e2);
          }, m2.get = function(t2) {
            return this[b.p(t2)]();
          }, m2.add = function(r3, f2) {
            var d2, l2 = this;
            r3 = Number(r3);
            var $3 = b.p(f2), y2 = function(t2) {
              var e2 = O(l2);
              return b.w(e2.date(e2.date() + Math.round(t2 * r3)), l2);
            };
            if ($3 === c) return this.set(c, this.$M + r3);
            if ($3 === h2) return this.set(h2, this.$y + r3);
            if ($3 === a) return y2(1);
            if ($3 === o) return y2(7);
            var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$3] || 1, m3 = this.$d.getTime() + r3 * M3;
            return b.w(m3, this);
          }, m2.subtract = function(t2, e2) {
            return this.add(-1 * t2, e2);
          }, m2.format = function(t2) {
            var e2 = this, n2 = this.$locale();
            if (!this.isValid()) return n2.invalidDate || l;
            var r3 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h3 = function(t3, n3, i3, s3) {
              return t3 && (t3[n3] || t3(e2, r3)) || i3[n3].slice(0, s3);
            }, d2 = function(t3) {
              return b.s(s2 % 12 || 12, t3, "0");
            }, $3 = f2 || function(t3, e3, n3) {
              var r4 = t3 < 12 ? "AM" : "PM";
              return n3 ? r4.toLowerCase() : r4;
            };
            return r3.replace(y, (function(t3, r4) {
              return r4 || (function(t4) {
                switch (t4) {
                  case "YY":
                    return String(e2.$y).slice(-2);
                  case "YYYY":
                    return b.s(e2.$y, 4, "0");
                  case "M":
                    return a2 + 1;
                  case "MM":
                    return b.s(a2 + 1, 2, "0");
                  case "MMM":
                    return h3(n2.monthsShort, a2, c2, 3);
                  case "MMMM":
                    return h3(c2, a2);
                  case "D":
                    return e2.$D;
                  case "DD":
                    return b.s(e2.$D, 2, "0");
                  case "d":
                    return String(e2.$W);
                  case "dd":
                    return h3(n2.weekdaysMin, e2.$W, o2, 2);
                  case "ddd":
                    return h3(n2.weekdaysShort, e2.$W, o2, 3);
                  case "dddd":
                    return o2[e2.$W];
                  case "H":
                    return String(s2);
                  case "HH":
                    return b.s(s2, 2, "0");
                  case "h":
                    return d2(1);
                  case "hh":
                    return d2(2);
                  case "a":
                    return $3(s2, u2, true);
                  case "A":
                    return $3(s2, u2, false);
                  case "m":
                    return String(u2);
                  case "mm":
                    return b.s(u2, 2, "0");
                  case "s":
                    return String(e2.$s);
                  case "ss":
                    return b.s(e2.$s, 2, "0");
                  case "SSS":
                    return b.s(e2.$ms, 3, "0");
                  case "Z":
                    return i2;
                }
                return null;
              })(t3) || i2.replace(":", "");
            }));
          }, m2.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m2.diff = function(r3, d2, l2) {
            var $3, y2 = this, M3 = b.p(d2), m3 = O(r3), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
              return b.m(y2, m3);
            };
            switch (M3) {
              case h2:
                $3 = D2() / 12;
                break;
              case c:
                $3 = D2();
                break;
              case f:
                $3 = D2() / 3;
                break;
              case o:
                $3 = (g2 - v2) / 6048e5;
                break;
              case a:
                $3 = (g2 - v2) / 864e5;
                break;
              case u:
                $3 = g2 / n;
                break;
              case s:
                $3 = g2 / e;
                break;
              case i:
                $3 = g2 / t;
                break;
              default:
                $3 = g2;
            }
            return l2 ? $3 : b.a($3);
          }, m2.daysInMonth = function() {
            return this.endOf(c).$D;
          }, m2.$locale = function() {
            return D[this.$L];
          }, m2.locale = function(t2, e2) {
            if (!t2) return this.$L;
            var n2 = this.clone(), r3 = w(t2, e2, true);
            return r3 && (n2.$L = r3), n2;
          }, m2.clone = function() {
            return b.w(this.$d, this);
          }, m2.toDate = function() {
            return new Date(this.valueOf());
          }, m2.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m2.toISOString = function() {
            return this.$d.toISOString();
          }, m2.toString = function() {
            return this.$d.toUTCString();
          }, M2;
        })(), k = _.prototype;
        return O.prototype = k, [["$ms", r2], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h2], ["$D", d]].forEach((function(t2) {
          k[t2[1]] = function(e2) {
            return this.$g(e2, t2[0], t2[1]);
          };
        })), O.extend = function(t2, e2) {
          return t2.$i || (t2(e2, _, O), t2.$i = true), O;
        }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
          return O(1e3 * t2);
        }, O.en = D[g], O.Ls = D, O.p = {}, O;
      }));
    })(dayjs_min$1);
    return dayjs_min$1.exports;
  }
  var dayjs_minExports = requireDayjs_min();
  const dayjs = getDefaultExportFromCjs(dayjs_minExports);
var XLSX = {};
  XLSX.version = "0.20.3";
  var current_codepage = 1200, current_ansi = 1252;
  var $cptable;
  var VALID_ANSI = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4];
  var CS2CP = {
    0: 1252,
1: 65001,
2: 65001,
77: 1e4,
128: 932,
129: 949,
130: 1361,
134: 936,
136: 950,
161: 1253,
162: 1254,
163: 1258,
177: 1255,
178: 1256,
186: 1257,
204: 1251,
222: 874,
238: 1250,
255: 1252,
69: 6969
};
  var set_ansi = function(cp) {
    if (VALID_ANSI.indexOf(cp) == -1) return;
    current_ansi = CS2CP[0] = cp;
  };
  function reset_ansi() {
    set_ansi(1252);
  }
  var set_cp = function(cp) {
    current_codepage = cp;
    set_ansi(cp);
  };
  function reset_cp() {
    set_cp(1200);
    reset_ansi();
  }
  function char_codes(data) {
    var o = [];
    for (var i = 0, len = data.length; i < len; ++i) o[i] = data.charCodeAt(i);
    return o;
  }
  function utf16leread(data) {
    var o = [];
    for (var i = 0; i < data.length >> 1; ++i) o[i] = String.fromCharCode(data.charCodeAt(2 * i) + (data.charCodeAt(2 * i + 1) << 8));
    return o.join("");
  }
  function utf16lereadu(data) {
    var o = [];
    for (var i = 0; i < data.length >> 1; ++i) o[i] = String.fromCharCode(data[2 * i] + (data[2 * i + 1] << 8));
    return o.join("");
  }
  function utf16beread(data) {
    var o = [];
    for (var i = 0; i < data.length >> 1; ++i) o[i] = String.fromCharCode(data.charCodeAt(2 * i + 1) + (data.charCodeAt(2 * i) << 8));
    return o.join("");
  }
  var debom = function(data) {
    var c1 = data.charCodeAt(0), c2 = data.charCodeAt(1);
    if (c1 == 255 && c2 == 254) return utf16leread(data.slice(2));
    if (c1 == 254 && c2 == 255) return utf16beread(data.slice(2));
    if (c1 == 65279) return data.slice(1);
    return data;
  };
  var _getchar = function _gc1(x) {
    return String.fromCharCode(x);
  };
  var _getansi = function _ga1(x) {
    return String.fromCharCode(x);
  };
  function set_cptable(cptable) {
    $cptable = cptable;
    set_cp = function(cp) {
      current_codepage = cp;
      set_ansi(cp);
    };
    debom = function(data) {
      if (data.charCodeAt(0) === 255 && data.charCodeAt(1) === 254) {
        return $cptable.utils.decode(1200, char_codes(data.slice(2)));
      }
      return data;
    };
    _getchar = function _gc2(x) {
      if (current_codepage === 1200) return String.fromCharCode(x);
      return $cptable.utils.decode(current_codepage, [x & 255, x >> 8])[0];
    };
    _getansi = function _ga2(x) {
      return $cptable.utils.decode(current_ansi, [x])[0];
    };
    cpdoit();
  }
  var DENSE = null;
  var Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  function Base64_encode(input) {
    var o = "";
    var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
    for (var i = 0; i < input.length; ) {
      c1 = input.charCodeAt(i++);
      e1 = c1 >> 2;
      c2 = input.charCodeAt(i++);
      e2 = (c1 & 3) << 4 | c2 >> 4;
      c3 = input.charCodeAt(i++);
      e3 = (c2 & 15) << 2 | c3 >> 6;
      e4 = c3 & 63;
      if (isNaN(c2)) {
        e3 = e4 = 64;
      } else if (isNaN(c3)) {
        e4 = 64;
      }
      o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);
    }
    return o;
  }
  function Base64_encode_pass(input) {
    var o = "";
    var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
    for (var i = 0; i < input.length; ) {
      c1 = input.charCodeAt(i++);
      if (c1 > 255)
        c1 = 95;
      e1 = c1 >> 2;
      c2 = input.charCodeAt(i++);
      if (c2 > 255)
        c2 = 95;
      e2 = (c1 & 3) << 4 | c2 >> 4;
      c3 = input.charCodeAt(i++);
      if (c3 > 255)
        c3 = 95;
      e3 = (c2 & 15) << 2 | c3 >> 6;
      e4 = c3 & 63;
      if (isNaN(c2)) {
        e3 = e4 = 64;
      } else if (isNaN(c3)) {
        e4 = 64;
      }
      o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);
    }
    return o;
  }
  function Base64_encode_arr(input) {
    var o = "";
    var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
    for (var i = 0; i < input.length; ) {
      c1 = input[i++];
      e1 = c1 >> 2;
      c2 = input[i++];
      e2 = (c1 & 3) << 4 | c2 >> 4;
      c3 = input[i++];
      e3 = (c2 & 15) << 2 | c3 >> 6;
      e4 = c3 & 63;
      if (isNaN(c2)) {
        e3 = e4 = 64;
      } else if (isNaN(c3)) {
        e4 = 64;
      }
      o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);
    }
    return o;
  }
  function Base64_decode(input) {
    var o = "";
    var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
    if (input.slice(0, 5) == "data:") {
      var i = input.slice(0, 1024).indexOf(";base64,");
      if (i > -1)
        input = input.slice(i + 8);
    }
    input = input.replace(/[^\w\+\/\=]/g, "");
    for (var i = 0; i < input.length; ) {
      e1 = Base64_map.indexOf(input.charAt(i++));
      e2 = Base64_map.indexOf(input.charAt(i++));
      c1 = e1 << 2 | e2 >> 4;
      o += String.fromCharCode(c1);
      e3 = Base64_map.indexOf(input.charAt(i++));
      c2 = (e2 & 15) << 4 | e3 >> 2;
      if (e3 !== 64) {
        o += String.fromCharCode(c2);
      }
      e4 = Base64_map.indexOf(input.charAt(i++));
      c3 = (e3 & 3) << 6 | e4;
      if (e4 !== 64) {
        o += String.fromCharCode(c3);
      }
    }
    return o;
  }
  var has_buf = (function() {
    return typeof Buffer !== "undefined" && typeof process !== "undefined" && typeof process.versions !== "undefined" && !!process.versions.node;
  })();
  var Buffer_from = (function() {
    if (typeof Buffer !== "undefined") {
      var nbfs = !Buffer.from;
      if (!nbfs) try {
        Buffer.from("foo", "utf8");
      } catch (e) {
        nbfs = true;
      }
      return nbfs ? function(buf, enc) {
        return enc ? new Buffer(buf, enc) : new Buffer(buf);
      } : Buffer.from.bind(Buffer);
    }
    return function() {
    };
  })();
  var buf_utf16le = (function() {
    if (typeof Buffer === "undefined") return false;
    var x = Buffer_from([65, 0]);
    if (!x) return false;
    var o = x.toString("utf16le");
    return o.length == 1;
  })();
  function new_raw_buf(len) {
    if (has_buf) return Buffer.alloc ? Buffer.alloc(len) : new Buffer(len);
    return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
  }
  function new_unsafe_buf(len) {
    if (has_buf) return Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : new Buffer(len);
    return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
  }
  var s2a = function s2a2(s) {
    if (has_buf) return Buffer_from(s, "binary");
    return s.split("").map(function(x) {
      return x.charCodeAt(0) & 255;
    });
  };
  function s2ab(s) {
    if (typeof ArrayBuffer === "undefined") return s2a(s);
    var buf = new ArrayBuffer(s.length), view = new Uint8Array(buf);
    for (var i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) & 255;
    return buf;
  }
  function a2s(data) {
    if (Array.isArray(data)) return data.map(function(c) {
      return String.fromCharCode(c);
    }).join("");
    var o = [];
    for (var i = 0; i < data.length; ++i) o[i] = String.fromCharCode(data[i]);
    return o.join("");
  }
  function a2u(data) {
    if (typeof Uint8Array === "undefined") throw new Error("Unsupported");
    return new Uint8Array(data);
  }
  function ab2a(data) {
    if (typeof ArrayBuffer == "undefined") throw new Error("Unsupported");
    if (data instanceof ArrayBuffer) return ab2a(new Uint8Array(data));
    var o = new Array(data.length);
    for (var i = 0; i < data.length; ++i) o[i] = data[i];
    return o;
  }
  var bconcat = has_buf ? function(bufs) {
    return Buffer.concat(bufs.map(function(buf) {
      return Buffer.isBuffer(buf) ? buf : Buffer_from(buf);
    }));
  } : function(bufs) {
    if (typeof Uint8Array !== "undefined") {
      var i = 0, maxlen = 0;
      for (i = 0; i < bufs.length; ++i) maxlen += bufs[i].length;
      var o = new Uint8Array(maxlen);
      var len = 0;
      for (i = 0, maxlen = 0; i < bufs.length; maxlen += len, ++i) {
        len = bufs[i].length;
        if (bufs[i] instanceof Uint8Array) o.set(bufs[i], maxlen);
        else if (typeof bufs[i] == "string") o.set(new Uint8Array(s2a(bufs[i])), maxlen);
        else o.set(new Uint8Array(bufs[i]), maxlen);
      }
      return o;
    }
    return [].concat.apply([], bufs.map(function(buf) {
      return Array.isArray(buf) ? buf : [].slice.call(buf);
    }));
  };
  function utf8decode(content) {
    var out = [], widx = 0, L = content.length + 250;
    var o = new_raw_buf(content.length + 255);
    for (var ridx = 0; ridx < content.length; ++ridx) {
      var c = content.charCodeAt(ridx);
      if (c < 128) o[widx++] = c;
      else if (c < 2048) {
        o[widx++] = 192 | c >> 6 & 31;
        o[widx++] = 128 | c & 63;
      } else if (c >= 55296 && c < 57344) {
        c = (c & 1023) + 64;
        var d = content.charCodeAt(++ridx) & 1023;
        o[widx++] = 240 | c >> 8 & 7;
        o[widx++] = 128 | c >> 2 & 63;
        o[widx++] = 128 | d >> 6 & 15 | (c & 3) << 4;
        o[widx++] = 128 | d & 63;
      } else {
        o[widx++] = 224 | c >> 12 & 15;
        o[widx++] = 128 | c >> 6 & 63;
        o[widx++] = 128 | c & 63;
      }
      if (widx > L) {
        out.push(o.slice(0, widx));
        widx = 0;
        o = new_raw_buf(65535);
        L = 65530;
      }
    }
    out.push(o.slice(0, widx));
    return bconcat(out);
  }
  var chr0 = /\u0000/g, chr1 = /[\u0001-\u0006]/g;
  function _strrev(x) {
    var o = "", i = x.length - 1;
    while (i >= 0) o += x.charAt(i--);
    return o;
  }
  function pad0(v, d) {
    var t = "" + v;
    return t.length >= d ? t : fill("0", d - t.length) + t;
  }
  function pad_(v, d) {
    var t = "" + v;
    return t.length >= d ? t : fill(" ", d - t.length) + t;
  }
  function rpad_(v, d) {
    var t = "" + v;
    return t.length >= d ? t : t + fill(" ", d - t.length);
  }
  function pad0r1(v, d) {
    var t = "" + Math.round(v);
    return t.length >= d ? t : fill("0", d - t.length) + t;
  }
  function pad0r2(v, d) {
    var t = "" + v;
    return t.length >= d ? t : fill("0", d - t.length) + t;
  }
  var p2_32 = Math.pow(2, 32);
  function pad0r(v, d) {
    if (v > p2_32 || v < -p2_32) return pad0r1(v, d);
    var i = Math.round(v);
    return pad0r2(i, d);
  }
  function SSF_isgeneral(s, i) {
    i = i || 0;
    return s.length >= 7 + i && (s.charCodeAt(i) | 32) === 103 && (s.charCodeAt(i + 1) | 32) === 101 && (s.charCodeAt(i + 2) | 32) === 110 && (s.charCodeAt(i + 3) | 32) === 101 && (s.charCodeAt(i + 4) | 32) === 114 && (s.charCodeAt(i + 5) | 32) === 97 && (s.charCodeAt(i + 6) | 32) === 108;
  }
  var days = [
    ["Sun", "Sunday"],
    ["Mon", "Monday"],
    ["Tue", "Tuesday"],
    ["Wed", "Wednesday"],
    ["Thu", "Thursday"],
    ["Fri", "Friday"],
    ["Sat", "Saturday"]
  ];
  var months = [
    ["J", "Jan", "January"],
    ["F", "Feb", "February"],
    ["M", "Mar", "March"],
    ["A", "Apr", "April"],
    ["M", "May", "May"],
    ["J", "Jun", "June"],
    ["J", "Jul", "July"],
    ["A", "Aug", "August"],
    ["S", "Sep", "September"],
    ["O", "Oct", "October"],
    ["N", "Nov", "November"],
    ["D", "Dec", "December"]
  ];
  function SSF_init_table(t) {
    if (!t) t = {};
    t[0] = "General";
    t[1] = "0";
    t[2] = "0.00";
    t[3] = "#,##0";
    t[4] = "#,##0.00";
    t[9] = "0%";
    t[10] = "0.00%";
    t[11] = "0.00E+00";
    t[12] = "# ?/?";
    t[13] = "# ??/??";
    t[14] = "m/d/yy";
    t[15] = "d-mmm-yy";
    t[16] = "d-mmm";
    t[17] = "mmm-yy";
    t[18] = "h:mm AM/PM";
    t[19] = "h:mm:ss AM/PM";
    t[20] = "h:mm";
    t[21] = "h:mm:ss";
    t[22] = "m/d/yy h:mm";
    t[37] = "#,##0 ;(#,##0)";
    t[38] = "#,##0 ;[Red](#,##0)";
    t[39] = "#,##0.00;(#,##0.00)";
    t[40] = "#,##0.00;[Red](#,##0.00)";
    t[45] = "mm:ss";
    t[46] = "[h]:mm:ss";
    t[47] = "mmss.0";
    t[48] = "##0.0E+0";
    t[49] = "@";
    t[56] = '"上午/下午 "hh"時"mm"分"ss"秒 "';
    return t;
  }
  var table_fmt = {
    0: "General",
    1: "0",
    2: "0.00",
    3: "#,##0",
    4: "#,##0.00",
    9: "0%",
    10: "0.00%",
    11: "0.00E+00",
    12: "# ?/?",
    13: "# ??/??",
    14: "m/d/yy",
    15: "d-mmm-yy",
    16: "d-mmm",
    17: "mmm-yy",
    18: "h:mm AM/PM",
    19: "h:mm:ss AM/PM",
    20: "h:mm",
    21: "h:mm:ss",
    22: "m/d/yy h:mm",
    37: "#,##0 ;(#,##0)",
    38: "#,##0 ;[Red](#,##0)",
    39: "#,##0.00;(#,##0.00)",
    40: "#,##0.00;[Red](#,##0.00)",
    45: "mm:ss",
    46: "[h]:mm:ss",
    47: "mmss.0",
    48: "##0.0E+0",
    49: "@",
    56: '"上午/下午 "hh"時"mm"分"ss"秒 "'
  };
  var SSF_default_map = {
    5: 37,
    6: 38,
    7: 39,
    8: 40,
23: 0,
    24: 0,
    25: 0,
    26: 0,
27: 14,
    28: 14,
    29: 14,
    30: 14,
    31: 14,
50: 14,
    51: 14,
    52: 14,
    53: 14,
    54: 14,
55: 14,
    56: 14,
    57: 14,
    58: 14,
    59: 1,
    60: 2,
    61: 3,
    62: 4,
67: 9,
    68: 10,
69: 12,
    70: 13,
    71: 14,
72: 14,
    73: 15,
    74: 16,
    75: 17,
76: 20,
    77: 21,
    78: 22,
79: 45,
    80: 46,
    81: 47,
82: 0
};
  var SSF_default_str = {
5: '"$"#,##0_);\\("$"#,##0\\)',
    63: '"$"#,##0_);\\("$"#,##0\\)',
6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
    64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
    65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
  };
  function SSF_frac(x, D, mixed) {
    var sgn = x < 0 ? -1 : 1;
    var B = x * sgn;
    var P_2 = 0, P_1 = 1, P = 0;
    var Q_2 = 1, Q_1 = 0, Q = 0;
    var A = Math.floor(B);
    while (Q_1 < D) {
      A = Math.floor(B);
      P = A * P_1 + P_2;
      Q = A * Q_1 + Q_2;
      if (B - A < 5e-8) break;
      B = 1 / (B - A);
      P_2 = P_1;
      P_1 = P;
      Q_2 = Q_1;
      Q_1 = Q;
    }
    if (Q > D) {
      if (Q_1 > D) {
        Q = Q_2;
        P = P_2;
      } else {
        Q = Q_1;
        P = P_1;
      }
    }
    if (!mixed) return [0, sgn * P, Q];
    var q = Math.floor(sgn * P / Q);
    return [q, sgn * P - q * Q, Q];
  }
  function SSF_normalize_xl_unsafe(v) {
    var s = v.toPrecision(16);
    if (s.indexOf("e") > -1) {
      var m = s.slice(0, s.indexOf("e"));
      m = m.indexOf(".") > -1 ? m.slice(0, m.slice(0, 2) == "0." ? 17 : 16) : m.slice(0, 15) + fill("0", m.length - 15);
      return m + s.slice(s.indexOf("e"));
    }
    var n = s.indexOf(".") > -1 ? s.slice(0, s.slice(0, 2) == "0." ? 17 : 16) : s.slice(0, 15) + fill("0", s.length - 15);
    return Number(n);
  }
  function SSF_parse_date_code(v, opts, b2) {
    if (v > 2958465 || v < 0) return null;
    v = SSF_normalize_xl_unsafe(v);
    var date = v | 0, time = Math.floor(86400 * (v - date)), dow = 0;
    var dout = [];
    var out = { D: date, T: time, u: 86400 * (v - date) - time, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 };
    if (Math.abs(out.u) < 1e-6) out.u = 0;
    if (opts && opts.date1904) date += 1462;
    if (out.u > 0.9999) {
      out.u = 0;
      if (++time == 86400) {
        out.T = time = 0;
        ++date;
        ++out.D;
      }
    }
    if (date === 60) {
      dout = b2 ? [1317, 10, 29] : [1900, 2, 29];
      dow = 3;
    } else if (date === 0) {
      dout = b2 ? [1317, 8, 29] : [1900, 1, 0];
      dow = 6;
    } else {
      if (date > 60) --date;
      var d = new Date(1900, 0, 1);
      d.setDate(d.getDate() + date - 1);
      dout = [d.getFullYear(), d.getMonth() + 1, d.getDate()];
      dow = d.getDay();
      if (date < 60) dow = (dow + 6) % 7;
      if (b2) dow = SSF_fix_hijri(d, dout);
    }
    out.y = dout[0];
    out.m = dout[1];
    out.d = dout[2];
    out.S = time % 60;
    time = Math.floor(time / 60);
    out.M = time % 60;
    time = Math.floor(time / 60);
    out.H = time;
    out.q = dow;
    return out;
  }
  function SSF_strip_decimal(o) {
    return o.indexOf(".") == -1 ? o : o.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");
  }
  function SSF_normalize_exp(o) {
    if (o.indexOf("E") == -1) return o;
    return o.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2");
  }
  function SSF_small_exp(v) {
    var w = v < 0 ? 12 : 11;
    var o = SSF_strip_decimal(v.toFixed(12));
    if (o.length <= w) return o;
    o = v.toPrecision(10);
    if (o.length <= w) return o;
    return v.toExponential(5);
  }
  function SSF_large_exp(v) {
    var o = SSF_strip_decimal(v.toFixed(11));
    return o.length > (v < 0 ? 12 : 11) || o === "0" || o === "-0" ? v.toPrecision(6) : o;
  }
  function SSF_general_num(v) {
    if (!isFinite(v)) return isNaN(v) ? "#NUM!" : "#DIV/0!";
    var V = Math.floor(Math.log(Math.abs(v)) * Math.LOG10E), o;
    if (V >= -4 && V <= -1) o = v.toPrecision(10 + V);
    else if (Math.abs(V) <= 9) o = SSF_small_exp(v);
    else if (V === 10) o = v.toFixed(10).substr(0, 12);
    else o = SSF_large_exp(v);
    return SSF_strip_decimal(SSF_normalize_exp(o.toUpperCase()));
  }
  function SSF_general(v, opts) {
    switch (typeof v) {
      case "string":
        return v;
      case "boolean":
        return v ? "TRUE" : "FALSE";
      case "number":
        return (v | 0) === v ? v.toString(10) : SSF_general_num(v);
      case "undefined":
        return "";
      case "object":
        if (v == null) return "";
        if (v instanceof Date) return SSF_format(14, datenum(v, opts && opts.date1904), opts);
    }
    throw new Error("unsupported value in General format: " + v);
  }
  function SSF_fix_hijri(date, o) {
    o[0] -= 581;
    var dow = date.getDay();
    if (date < 60) dow = (dow + 6) % 7;
    return dow;
  }
  function SSF_write_date(type, fmt, val2, ss0) {
    var o = "", ss = 0, tt2 = 0, y = val2.y, out, outl = 0;
    switch (type) {
      case 98:
        y = val2.y + 543;
case 121:
        switch (fmt.length) {
          case 1:
          case 2:
            out = y % 100;
            outl = 2;
            break;
          default:
            out = y % 1e4;
            outl = 4;
            break;
        }
        break;
      case 109:
        switch (fmt.length) {
          case 1:
          case 2:
            out = val2.m;
            outl = fmt.length;
            break;
          case 3:
            return months[val2.m - 1][1];
          case 5:
            return months[val2.m - 1][0];
          default:
            return months[val2.m - 1][2];
        }
        break;
      case 100:
        switch (fmt.length) {
          case 1:
          case 2:
            out = val2.d;
            outl = fmt.length;
            break;
          case 3:
            return days[val2.q][0];
          default:
            return days[val2.q][1];
        }
        break;
      case 104:
        switch (fmt.length) {
          case 1:
          case 2:
            out = 1 + (val2.H + 11) % 12;
            outl = fmt.length;
            break;
          default:
            throw "bad hour format: " + fmt;
        }
        break;
      case 72:
        switch (fmt.length) {
          case 1:
          case 2:
            out = val2.H;
            outl = fmt.length;
            break;
          default:
            throw "bad hour format: " + fmt;
        }
        break;
      case 77:
        switch (fmt.length) {
          case 1:
          case 2:
            out = val2.M;
            outl = fmt.length;
            break;
          default:
            throw "bad minute format: " + fmt;
        }
        break;
      case 115:
        if (fmt != "s" && fmt != "ss" && fmt != ".0" && fmt != ".00" && fmt != ".000") throw "bad second format: " + fmt;
        if (val2.u === 0 && (fmt == "s" || fmt == "ss")) return pad0(val2.S, fmt.length);
        if (ss0 >= 2) tt2 = ss0 === 3 ? 1e3 : 100;
        else tt2 = ss0 === 1 ? 10 : 1;
        ss = Math.round(tt2 * (val2.S + val2.u));
        if (ss >= 60 * tt2) ss = 0;
        if (fmt === "s") return ss === 0 ? "0" : "" + ss / tt2;
        o = pad0(ss, 2 + ss0);
        if (fmt === "ss") return o.substr(0, 2);
        return "." + o.substr(2, fmt.length - 1);
      case 90:
        switch (fmt) {
          case "[h]":
          case "[hh]":
            out = val2.D * 24 + val2.H;
            break;
          case "[m]":
          case "[mm]":
            out = (val2.D * 24 + val2.H) * 60 + val2.M;
            break;
          case "[s]":
          case "[ss]":
            out = ((val2.D * 24 + val2.H) * 60 + val2.M) * 60 + (ss0 == 0 ? Math.round(val2.S + val2.u) : val2.S);
            break;
          default:
            throw "bad abstime format: " + fmt;
        }
        outl = fmt.length === 3 ? 1 : 2;
        break;
      case 101:
        out = y;
        outl = 1;
        break;
    }
    var outstr = outl > 0 ? pad0(out, outl) : "";
    return outstr;
  }
  function commaify(s) {
    var w = 3;
    if (s.length <= w) return s;
    var j = s.length % w, o = s.substr(0, j);
    for (; j != s.length; j += w) o += (o.length > 0 ? "," : "") + s.substr(j, w);
    return o;
  }
  var pct1 = /%/g;
  function write_num_pct(type, fmt, val2) {
    var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
    return write_num(type, sfmt, val2 * Math.pow(10, 2 * mul)) + fill("%", mul);
  }
  function write_num_cm(type, fmt, val2) {
    var idx = fmt.length - 1;
    while (fmt.charCodeAt(idx - 1) === 44) --idx;
    return write_num(type, fmt.substr(0, idx), val2 / Math.pow(10, 3 * (fmt.length - idx)));
  }
  function write_num_exp(fmt, val2) {
    var o;
    var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
    if (fmt.match(/^#+0.0E\+0$/)) {
      if (val2 == 0) return "0.0E+0";
      else if (val2 < 0) return "-" + write_num_exp(fmt, -val2);
      var period = fmt.indexOf(".");
      if (period === -1) period = fmt.indexOf("E");
      var ee = Math.floor(Math.log(val2) * Math.LOG10E) % period;
      if (ee < 0) ee += period;
      o = (val2 / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
      if (o.indexOf("e") === -1) {
        var fakee = Math.floor(Math.log(val2) * Math.LOG10E);
        if (o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
        else o += "E+" + (fakee - ee);
        while (o.substr(0, 2) === "0.") {
          o = o.charAt(0) + o.substr(2, period) + "." + o.substr(2 + period);
          o = o.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
        }
        o = o.replace(/\+-/, "-");
      }
      o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
        return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
      });
    } else o = val2.toExponential(idx);
    if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/)) o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
    if (fmt.match(/E\-/) && o.match(/e\+/)) o = o.replace(/e\+/, "e");
    return o.replace("e", "E");
  }
  var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
  function write_num_f1(r2, aval, sign) {
    var den = parseInt(r2[4], 10), rr = Math.round(aval * den), base = Math.floor(rr / den);
    var myn = rr - base * den, myd = den;
    return sign + (base === 0 ? "" : "" + base) + " " + (myn === 0 ? fill(" ", r2[1].length + 1 + r2[4].length) : pad_(myn, r2[1].length) + r2[2] + "/" + r2[3] + pad0(myd, r2[4].length));
  }
  function write_num_f2(r2, aval, sign) {
    return sign + (aval === 0 ? "" : "" + aval) + fill(" ", r2[1].length + 2 + r2[4].length);
  }
  var dec1 = /^#*0*\.([0#]+)/;
  var closeparen = /\)[^)]*[0#]/;
  var phone = /\(###\) ###\\?-####/;
  function hashq(str) {
    var o = "", cc;
    for (var i = 0; i != str.length; ++i) switch (cc = str.charCodeAt(i)) {
      case 35:
        break;
      case 63:
        o += " ";
        break;
      case 48:
        o += "0";
        break;
      default:
        o += String.fromCharCode(cc);
    }
    return o;
  }
  function rnd(val2, d) {
    var dd = Math.pow(10, d);
    return "" + Math.round(val2 * dd) / dd;
  }
  function dec(val2, d) {
    var _frac = val2 - Math.floor(val2), dd = Math.pow(10, d);
    if (d < ("" + Math.round(_frac * dd)).length) return 0;
    return Math.round(_frac * dd);
  }
  function carry(val2, d) {
    if (d < ("" + Math.round((val2 - Math.floor(val2)) * Math.pow(10, d))).length) {
      return 1;
    }
    return 0;
  }
  function flr(val2) {
    if (val2 < 2147483647 && val2 > -2147483648) return "" + (val2 >= 0 ? val2 | 0 : val2 - 1 | 0);
    return "" + Math.floor(val2);
  }
  function write_num_flt(type, fmt, val2) {
    if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
      var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
      if (val2 >= 0) return write_num_flt("n", ffmt, val2);
      return "(" + write_num_flt("n", ffmt, -val2) + ")";
    }
    if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm(type, fmt, val2);
    if (fmt.indexOf("%") !== -1) return write_num_pct(type, fmt, val2);
    if (fmt.indexOf("E") !== -1) return write_num_exp(fmt, val2);
    if (fmt.charCodeAt(0) === 36) return "$" + write_num_flt(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val2);
    var o;
    var r2, ri, ff, aval = Math.abs(val2), sign = val2 < 0 ? "-" : "";
    if (fmt.match(/^00+$/)) return sign + pad0r(aval, fmt.length);
    if (fmt.match(/^[#?]+$/)) {
      o = pad0r(val2, 0);
      if (o === "0") o = "";
      return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
    }
    if (r2 = fmt.match(frac1)) return write_num_f1(r2, aval, sign);
    if (fmt.match(/^#+0+$/)) return sign + pad0r(aval, fmt.length - fmt.indexOf("0"));
    if (r2 = fmt.match(dec1)) {
      o = rnd(val2, r2[1].length).replace(/^([^\.]+)$/, "$1." + hashq(r2[1])).replace(/\.$/, "." + hashq(r2[1])).replace(/\.(\d*)$/, function($$, $1) {
        return "." + $1 + fill("0", hashq(
r2[1]
        ).length - $1.length);
      });
      return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
    }
    fmt = fmt.replace(/^#+([0.])/, "$1");
    if (r2 = fmt.match(/^(0*)\.(#*)$/)) {
      return sign + rnd(aval, r2[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r2[1].length ? "0." : ".");
    }
    if (r2 = fmt.match(/^#{1,3},##0(\.?)$/)) return sign + commaify(pad0r(aval, 0));
    if (r2 = fmt.match(/^#,##0\.([#0]*0)$/)) {
      return val2 < 0 ? "-" + write_num_flt(type, fmt, -val2) : commaify("" + (Math.floor(val2) + carry(val2, r2[1].length))) + "." + pad0(dec(val2, r2[1].length), r2[1].length);
    }
    if (r2 = fmt.match(/^#,#*,#0/)) return write_num_flt(type, fmt.replace(/^#,#*,/, ""), val2);
    if (r2 = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
      o = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g, ""), val2));
      ri = 0;
      return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x2) {
        return ri < o.length ? o.charAt(ri++) : x2 === "0" ? "0" : "";
      }));
    }
    if (fmt.match(phone)) {
      o = write_num_flt(type, "##########", val2);
      return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
    }
    var oa = "";
    if (r2 = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
      ri = Math.min(
r2[4].length,
        7
      );
      ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
      o = "" + sign;
      oa = write_num(
        "n",
r2[1],
        ff[1]
      );
      if (oa.charAt(oa.length - 1) == " ") oa = oa.substr(0, oa.length - 1) + "0";
      o += oa +
r2[2] + "/" +
r2[3];
      oa = rpad_(ff[2], ri);
      if (oa.length < r2[4].length) oa = hashq(r2[4].substr(r2[4].length - oa.length)) + oa;
      o += oa;
      return o;
    }
    if (r2 = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
      ri = Math.min(Math.max(r2[1].length, r2[4].length), 7);
      ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
      return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r2[2] + "/" + r2[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r2[2].length + r2[3].length));
    }
    if (r2 = fmt.match(/^[#0?]+$/)) {
      o = pad0r(val2, 0);
      if (fmt.length <= o.length) return o;
      return hashq(fmt.substr(0, fmt.length - o.length)) + o;
    }
    if (r2 = fmt.match(/^([#0?]+)\.([#0]+)$/)) {
      o = "" + val2.toFixed(Math.min(r2[2].length, 10)).replace(/([^0])0+$/, "$1");
      ri = o.indexOf(".");
      var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
      return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
    }
    if (r2 = fmt.match(/^00,000\.([#0]*0)$/)) {
      ri = dec(val2, r2[1].length);
      return val2 < 0 ? "-" + write_num_flt(type, fmt, -val2) : commaify(flr(val2)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
        return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
      }) + "." + pad0(ri, r2[1].length);
    }
    switch (fmt) {
      case "###,##0.00":
        return write_num_flt(type, "#,##0.00", val2);
      case "###,###":
      case "##,###":
      case "#,###":
        var x = commaify(pad0r(aval, 0));
        return x !== "0" ? sign + x : "";
      case "###,###.00":
        return write_num_flt(type, "###,##0.00", val2).replace(/^0\./, ".");
      case "#,###.00":
        return write_num_flt(type, "#,##0.00", val2).replace(/^0\./, ".");
    }
    throw new Error("unsupported format |" + fmt + "|");
  }
  function write_num_cm2(type, fmt, val2) {
    var idx = fmt.length - 1;
    while (fmt.charCodeAt(idx - 1) === 44) --idx;
    return write_num(type, fmt.substr(0, idx), val2 / Math.pow(10, 3 * (fmt.length - idx)));
  }
  function write_num_pct2(type, fmt, val2) {
    var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
    return write_num(type, sfmt, val2 * Math.pow(10, 2 * mul)) + fill("%", mul);
  }
  function write_num_exp2(fmt, val2) {
    var o;
    var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
    if (fmt.match(/^#+0.0E\+0$/)) {
      if (val2 == 0) return "0.0E+0";
      else if (val2 < 0) return "-" + write_num_exp2(fmt, -val2);
      var period = fmt.indexOf(".");
      if (period === -1) period = fmt.indexOf("E");
      var ee = Math.floor(Math.log(val2) * Math.LOG10E) % period;
      if (ee < 0) ee += period;
      o = (val2 / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
      if (!o.match(/[Ee]/)) {
        var fakee = Math.floor(Math.log(val2) * Math.LOG10E);
        if (o.indexOf(".") === -1) o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
        else o += "E+" + (fakee - ee);
        o = o.replace(/\+-/, "-");
      }
      o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
        return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
      });
    } else o = val2.toExponential(idx);
    if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/)) o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
    if (fmt.match(/E\-/) && o.match(/e\+/)) o = o.replace(/e\+/, "e");
    return o.replace("e", "E");
  }
  function write_num_int(type, fmt, val2) {
    if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
      var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
      if (val2 >= 0) return write_num_int("n", ffmt, val2);
      return "(" + write_num_int("n", ffmt, -val2) + ")";
    }
    if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm2(type, fmt, val2);
    if (fmt.indexOf("%") !== -1) return write_num_pct2(type, fmt, val2);
    if (fmt.indexOf("E") !== -1) return write_num_exp2(fmt, val2);
    if (fmt.charCodeAt(0) === 36) return "$" + write_num_int(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val2);
    var o;
    var r2, ri, ff, aval = Math.abs(val2), sign = val2 < 0 ? "-" : "";
    if (fmt.match(/^00+$/)) return sign + pad0(aval, fmt.length);
    if (fmt.match(/^[#?]+$/)) {
      o = "" + val2;
      if (val2 === 0) o = "";
      return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
    }
    if (r2 = fmt.match(frac1)) return write_num_f2(r2, aval, sign);
    if (fmt.match(/^#+0+$/)) return sign + pad0(aval, fmt.length - fmt.indexOf("0"));
    if (r2 = fmt.match(dec1)) {
      o = ("" + val2).replace(/^([^\.]+)$/, "$1." + hashq(r2[1])).replace(/\.$/, "." + hashq(r2[1]));
      o = o.replace(/\.(\d*)$/, function($$, $1) {
        return "." + $1 + fill("0", hashq(r2[1]).length - $1.length);
      });
      return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
    }
    fmt = fmt.replace(/^#+([0.])/, "$1");
    if (r2 = fmt.match(/^(0*)\.(#*)$/)) {
      return sign + ("" + aval).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r2[1].length ? "0." : ".");
    }
    if (r2 = fmt.match(/^#{1,3},##0(\.?)$/)) return sign + commaify("" + aval);
    if (r2 = fmt.match(/^#,##0\.([#0]*0)$/)) {
      return val2 < 0 ? "-" + write_num_int(type, fmt, -val2) : commaify("" + val2) + "." + fill("0", r2[1].length);
    }
    if (r2 = fmt.match(/^#,#*,#0/)) return write_num_int(type, fmt.replace(/^#,#*,/, ""), val2);
    if (r2 = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
      o = _strrev(write_num_int(type, fmt.replace(/[\\-]/g, ""), val2));
      ri = 0;
      return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x2) {
        return ri < o.length ? o.charAt(ri++) : x2 === "0" ? "0" : "";
      }));
    }
    if (fmt.match(phone)) {
      o = write_num_int(type, "##########", val2);
      return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
    }
    var oa = "";
    if (r2 = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
      ri = Math.min(
r2[4].length,
        7
      );
      ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
      o = "" + sign;
      oa = write_num(
        "n",
r2[1],
        ff[1]
      );
      if (oa.charAt(oa.length - 1) == " ") oa = oa.substr(0, oa.length - 1) + "0";
      o += oa +
r2[2] + "/" +
r2[3];
      oa = rpad_(ff[2], ri);
      if (oa.length < r2[4].length) oa = hashq(r2[4].substr(r2[4].length - oa.length)) + oa;
      o += oa;
      return o;
    }
    if (r2 = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
      ri = Math.min(Math.max(r2[1].length, r2[4].length), 7);
      ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
      return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r2[2] + "/" + r2[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r2[2].length + r2[3].length));
    }
    if (r2 = fmt.match(/^[#0?]+$/)) {
      o = "" + val2;
      if (fmt.length <= o.length) return o;
      return hashq(fmt.substr(0, fmt.length - o.length)) + o;
    }
    if (r2 = fmt.match(/^([#0]+)\.([#0]+)$/)) {
      o = "" + val2.toFixed(Math.min(r2[2].length, 10)).replace(/([^0])0+$/, "$1");
      ri = o.indexOf(".");
      var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
      return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
    }
    if (r2 = fmt.match(/^00,000\.([#0]*0)$/)) {
      return val2 < 0 ? "-" + write_num_int(type, fmt, -val2) : commaify("" + val2).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
        return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
      }) + "." + pad0(0, r2[1].length);
    }
    switch (fmt) {
      case "###,###":
      case "##,###":
      case "#,###":
        var x = commaify("" + aval);
        return x !== "0" ? sign + x : "";
      default:
        if (fmt.match(/\.[0#?]*$/)) return write_num_int(type, fmt.slice(0, fmt.lastIndexOf(".")), val2) + hashq(fmt.slice(fmt.lastIndexOf(".")));
    }
    throw new Error("unsupported format |" + fmt + "|");
  }
  function write_num(type, fmt, val2) {
    return (val2 | 0) === val2 ? write_num_int(type, fmt, val2) : write_num_flt(type, fmt, val2);
  }
  function SSF_split_fmt(fmt) {
    var out = [];
    var in_str = false;
    for (var i = 0, j = 0; i < fmt.length; ++i) switch (
fmt.charCodeAt(i)
    ) {
      case 34:
        in_str = !in_str;
        break;
      case 95:
      case 42:
      case 92:
        ++i;
        break;
      case 59:
        out[out.length] = fmt.substr(j, i - j);
        j = i + 1;
    }
    out[out.length] = fmt.substr(j);
    if (in_str === true) throw new Error("Format |" + fmt + "| unterminated string ");
    return out;
  }
  var SSF_abstime = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
  function fmt_is_date(fmt) {
    var i = 0, c = "", o = "";
    while (i < fmt.length) {
      switch (c = fmt.charAt(i)) {
        case "G":
          if (SSF_isgeneral(fmt, i)) i += 6;
          i++;
          break;
        case '"':
          for (
            ;
fmt.charCodeAt(++i) !== 34 && i < fmt.length;
          ) {
          }
          ++i;
          break;
        case "\\":
          i += 2;
          break;
        case "_":
          i += 2;
          break;
        case "@":
          ++i;
          break;
        case "B":
        case "b":
          if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2") return true;
case "M":
        case "D":
        case "Y":
        case "H":
        case "S":
        case "E":
case "m":
        case "d":
        case "y":
        case "h":
        case "s":
        case "e":
        case "g":
          return true;
        case "A":
        case "a":
        case "上":
          if (fmt.substr(i, 3).toUpperCase() === "A/P") return true;
          if (fmt.substr(i, 5).toUpperCase() === "AM/PM") return true;
          if (fmt.substr(i, 5).toUpperCase() === "上午/下午") return true;
          ++i;
          break;
        case "[":
          o = c;
          while (fmt.charAt(i++) !== "]" && i < fmt.length) o += fmt.charAt(i);
          if (o.match(SSF_abstime)) return true;
          break;
        case ".":
case "0":
        case "#":
          while (i < fmt.length && ("0#?.,E+-%".indexOf(c = fmt.charAt(++i)) > -1 || c == "\\" && fmt.charAt(i + 1) == "-" && "0#".indexOf(fmt.charAt(i + 2)) > -1)) {
          }
          break;
        case "?":
          while (fmt.charAt(++i) === c) {
          }
          break;
        case "*":
          ++i;
          if (fmt.charAt(i) == " " || fmt.charAt(i) == "*") ++i;
          break;
        case "(":
        case ")":
          ++i;
          break;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1) {
          }
          break;
        case " ":
          ++i;
          break;
        default:
          ++i;
          break;
      }
    }
    return false;
  }
  function eval_fmt(fmt, v, opts, flen) {
    var out = [], o = "", i = 0, c = "", lst = "t", dt, j, cc;
    var hr = "H";
    while (i < fmt.length) {
      switch (c = fmt.charAt(i)) {
        case "G":
          if (!SSF_isgeneral(fmt, i)) throw new Error("unrecognized character " + c + " in " + fmt);
          out[out.length] = { t: "G", v: "General" };
          i += 7;
          break;
        case '"':
          for (o = ""; (cc = fmt.charCodeAt(++i)) !== 34 && i < fmt.length; ) o += String.fromCharCode(cc);
          out[out.length] = { t: "t", v: o };
          ++i;
          break;
        case "\\":
          var w = fmt.charAt(++i), t = w === "(" || w === ")" ? w : "t";
          out[out.length] = { t, v: w };
          ++i;
          break;
        case "_":
          out[out.length] = { t: "t", v: " " };
          i += 2;
          break;
        case "@":
          out[out.length] = { t: "T", v };
          ++i;
          break;
        case "B":
        case "b":
          if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2") {
            if (dt == null) {
              dt = SSF_parse_date_code(v, opts, fmt.charAt(i + 1) === "2");
              if (dt == null) return "";
            }
            out[out.length] = { t: "X", v: fmt.substr(i, 2) };
            lst = c;
            i += 2;
            break;
          }
case "M":
        case "D":
        case "Y":
        case "H":
        case "S":
        case "E":
          c = c.toLowerCase();
case "m":
        case "d":
        case "y":
        case "h":
        case "s":
        case "e":
        case "g":
          if (v < 0) return "";
          if (dt == null) {
            dt = SSF_parse_date_code(v, opts);
            if (dt == null) return "";
          }
          o = c;
          while (++i < fmt.length && fmt.charAt(i).toLowerCase() === c) o += c;
          if (c === "m" && lst.toLowerCase() === "h") c = "M";
          if (c === "h") c = hr;
          out[out.length] = { t: c, v: o };
          lst = c;
          break;
        case "A":
        case "a":
        case "上":
          var q = { t: c, v: c };
          if (dt == null) dt = SSF_parse_date_code(v, opts);
          if (fmt.substr(i, 3).toUpperCase() === "A/P") {
            if (dt != null) q.v = dt.H >= 12 ? fmt.charAt(i + 2) : c;
            q.t = "T";
            hr = "h";
            i += 3;
          } else if (fmt.substr(i, 5).toUpperCase() === "AM/PM") {
            if (dt != null) q.v = dt.H >= 12 ? "PM" : "AM";
            q.t = "T";
            i += 5;
            hr = "h";
          } else if (fmt.substr(i, 5).toUpperCase() === "上午/下午") {
            if (dt != null) q.v = dt.H >= 12 ? "下午" : "上午";
            q.t = "T";
            i += 5;
            hr = "h";
          } else {
            q.t = "t";
            ++i;
          }
          if (dt == null && q.t === "T") return "";
          out[out.length] = q;
          lst = c;
          break;
        case "[":
          o = c;
          while (fmt.charAt(i++) !== "]" && i < fmt.length) o += fmt.charAt(i);
          if (o.slice(-1) !== "]") throw 'unterminated "[" block: |' + o + "|";
          if (o.match(SSF_abstime)) {
            if (dt == null) {
              dt = SSF_parse_date_code(v, opts);
              if (dt == null) return "";
            }
            out[out.length] = { t: "Z", v: o.toLowerCase() };
            lst = o.charAt(1);
          } else if (o.indexOf("$") > -1) {
            o = (o.match(/\$([^-\[\]]*)/) || [])[1] || "$";
            if (!fmt_is_date(fmt)) out[out.length] = { t: "t", v: o };
          }
          break;
case ".":
          if (dt != null) {
            o = c;
            while (++i < fmt.length && (c = fmt.charAt(i)) === "0") o += c;
            out[out.length] = { t: "s", v: o };
            break;
          }
case "0":
        case "#":
          o = c;
          while (++i < fmt.length && "0#?.,E+-%".indexOf(c = fmt.charAt(i)) > -1) o += c;
          out[out.length] = { t: "n", v: o };
          break;
        case "?":
          o = c;
          while (fmt.charAt(++i) === c) o += c;
          out[out.length] = { t: c, v: o };
          lst = c;
          break;
        case "*":
          ++i;
          if (fmt.charAt(i) == " " || fmt.charAt(i) == "*") ++i;
          break;
case "(":
        case ")":
          out[out.length] = { t: flen === 1 ? "t" : c, v: c };
          ++i;
          break;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          o = c;
          while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1) o += fmt.charAt(i);
          out[out.length] = { t: "D", v: o };
          break;
        case " ":
          out[out.length] = { t: c, v: c };
          ++i;
          break;
        case "$":
          out[out.length] = { t: "t", v: "$" };
          ++i;
          break;
        default:
          if (",$-+/():!^&'~{}<>=€acfijklopqrtuvwxzP".indexOf(c) === -1) throw new Error("unrecognized character " + c + " in " + fmt);
          out[out.length] = { t: "t", v: c };
          ++i;
          break;
      }
    }
    var bt = 0, ss0 = 0, ssm;
    for (i = out.length - 1, lst = "t"; i >= 0; --i) {
      switch (out[i].t) {
        case "h":
        case "H":
          out[i].t = hr;
          lst = "h";
          if (bt < 1) bt = 1;
          break;
        case "s":
          if (ssm = out[i].v.match(/\.0+$/)) {
            ss0 = Math.max(ss0, ssm[0].length - 1);
            bt = 4;
          }
          if (bt < 3) bt = 3;
case "d":
        case "y":
        case "e":
          lst = out[i].t;
          break;
        case "M":
          lst = out[i].t;
          if (bt < 2) bt = 2;
          break;
        case "m":
          if (lst === "s") {
            out[i].t = "M";
            if (bt < 2) bt = 2;
          }
          break;
        case "X":
          break;
        case "Z":
          if (bt < 1 && out[i].v.match(/[Hh]/)) bt = 1;
          if (bt < 2 && out[i].v.match(/[Mm]/)) bt = 2;
          if (bt < 3 && out[i].v.match(/[Ss]/)) bt = 3;
      }
    }
    var _dt;
    switch (bt) {
      case 0:
        break;
      case 1:
      case 2:
      case 3:
        if (dt.u >= 0.5) {
          dt.u = 0;
          ++dt.S;
        }
        if (dt.S >= 60) {
          dt.S = 0;
          ++dt.M;
        }
        if (dt.M >= 60) {
          dt.M = 0;
          ++dt.H;
        }
        if (dt.H >= 24) {
          dt.H = 0;
          ++dt.D;
          _dt = SSF_parse_date_code(dt.D);
          _dt.u = dt.u;
          _dt.S = dt.S;
          _dt.M = dt.M;
          _dt.H = dt.H;
          dt = _dt;
        }
        break;
      case 4:
        switch (ss0) {
          case 1:
            dt.u = Math.round(dt.u * 10) / 10;
            break;
          case 2:
            dt.u = Math.round(dt.u * 100) / 100;
            break;
          case 3:
            dt.u = Math.round(dt.u * 1e3) / 1e3;
            break;
        }
        if (dt.u >= 1) {
          dt.u = 0;
          ++dt.S;
        }
        if (dt.S >= 60) {
          dt.S = 0;
          ++dt.M;
        }
        if (dt.M >= 60) {
          dt.M = 0;
          ++dt.H;
        }
        if (dt.H >= 24) {
          dt.H = 0;
          ++dt.D;
          _dt = SSF_parse_date_code(dt.D);
          _dt.u = dt.u;
          _dt.S = dt.S;
          _dt.M = dt.M;
          _dt.H = dt.H;
          dt = _dt;
        }
        break;
    }
    var nstr = "", jj;
    for (i = 0; i < out.length; ++i) {
      switch (out[i].t) {
        case "t":
        case "T":
        case " ":
        case "D":
          break;
        case "X":
          out[i].v = "";
          out[i].t = ";";
          break;
        case "d":
        case "m":
        case "y":
        case "h":
        case "H":
        case "M":
        case "s":
        case "e":
        case "b":
        case "Z":
          out[i].v = SSF_write_date(out[i].t.charCodeAt(0), out[i].v, dt, ss0);
          out[i].t = "t";
          break;
        case "n":
        case "?":
          jj = i + 1;
          while (out[jj] != null && ((c = out[jj].t) === "?" || c === "D" || (c === " " || c === "t") && out[jj + 1] != null && (out[jj + 1].t === "?" || out[jj + 1].t === "t" && out[jj + 1].v === "/") || out[i].t === "(" && (c === " " || c === "n" || c === ")") || c === "t" && (out[jj].v === "/" || out[jj].v === " " && out[jj + 1] != null && out[jj + 1].t == "?"))) {
            out[i].v += out[jj].v;
            out[jj] = { v: "", t: ";" };
            ++jj;
          }
          nstr += out[i].v;
          i = jj - 1;
          break;
        case "G":
          out[i].t = "t";
          out[i].v = SSF_general(v, opts);
          break;
      }
    }
    var vv = "", myv, ostr;
    if (nstr.length > 0) {
      if (nstr.charCodeAt(0) == 40) {
        myv = v < 0 && nstr.charCodeAt(0) === 45 ? -v : v;
        ostr = write_num("n", nstr, myv);
      } else {
        myv = v < 0 && flen > 1 ? -v : v;
        ostr = write_num("n", nstr, myv);
        if (myv < 0 && out[0] && out[0].t == "t") {
          ostr = ostr.substr(1);
          out[0].v = "-" + out[0].v;
        }
      }
      jj = ostr.length - 1;
      var decpt = out.length;
      for (i = 0; i < out.length; ++i) if (out[i] != null && out[i].t != "t" && out[i].v.indexOf(".") > -1) {
        decpt = i;
        break;
      }
      var lasti = out.length;
      if (decpt === out.length && ostr.indexOf("E") === -1) {
        for (i = out.length - 1; i >= 0; --i) {
          if (out[i] == null || "n?".indexOf(out[i].t) === -1) continue;
          if (jj >= out[i].v.length - 1) {
            jj -= out[i].v.length;
            out[i].v = ostr.substr(jj + 1, out[i].v.length);
          } else if (jj < 0) out[i].v = "";
          else {
            out[i].v = ostr.substr(0, jj + 1);
            jj = -1;
          }
          out[i].t = "t";
          lasti = i;
        }
        if (jj >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
      } else if (decpt !== out.length && ostr.indexOf("E") === -1) {
        jj = ostr.indexOf(".") - 1;
        for (i = decpt; i >= 0; --i) {
          if (out[i] == null || "n?".indexOf(out[i].t) === -1) continue;
          j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") - 1 : out[i].v.length - 1;
          vv = out[i].v.substr(j + 1);
          for (; j >= 0; --j) {
            if (jj >= 0 && (out[i].v.charAt(j) === "0" || out[i].v.charAt(j) === "#")) vv = ostr.charAt(jj--) + vv;
          }
          out[i].v = vv;
          out[i].t = "t";
          lasti = i;
        }
        if (jj >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
        jj = ostr.indexOf(".") + 1;
        for (i = decpt; i < out.length; ++i) {
          if (out[i] == null || "n?(".indexOf(out[i].t) === -1 && i !== decpt) continue;
          j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") + 1 : 0;
          vv = out[i].v.substr(0, j);
          for (; j < out[i].v.length; ++j) {
            if (jj < ostr.length) vv += ostr.charAt(jj++);
          }
          out[i].v = vv;
          out[i].t = "t";
          lasti = i;
        }
      }
    }
    for (i = 0; i < out.length; ++i) if (out[i] != null && "n?".indexOf(out[i].t) > -1) {
      myv = flen > 1 && v < 0 && i > 0 && out[i - 1].v === "-" ? -v : v;
      out[i].v = write_num(out[i].t, out[i].v, myv);
      out[i].t = "t";
    }
    var retval = "";
    for (i = 0; i !== out.length; ++i) if (out[i] != null) retval += out[i].v;
    return retval;
  }
  var cfregex2 = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
  function chkcond(v, rr) {
    if (rr == null) return false;
    var thresh = parseFloat(rr[2]);
    switch (rr[1]) {
      case "=":
        if (v == thresh) return true;
        break;
      case ">":
        if (v > thresh) return true;
        break;
      case "<":
        if (v < thresh) return true;
        break;
      case "<>":
        if (v != thresh) return true;
        break;
      case ">=":
        if (v >= thresh) return true;
        break;
      case "<=":
        if (v <= thresh) return true;
        break;
    }
    return false;
  }
  function choose_fmt(f, v) {
    var fmt = SSF_split_fmt(f);
    var l = fmt.length, lat = fmt[l - 1].indexOf("@");
    if (l < 4 && lat > -1) --l;
    if (fmt.length > 4) throw new Error("cannot find right format for |" + fmt.join("|") + "|");
    if (typeof v !== "number") return [4, fmt.length === 4 || lat > -1 ? fmt[fmt.length - 1] : "@"];
    if (typeof v === "number" && !isFinite(v)) v = 0;
    switch (fmt.length) {
      case 1:
        fmt = lat > -1 ? ["General", "General", "General", fmt[0]] : [fmt[0], fmt[0], fmt[0], "@"];
        break;
      case 2:
        fmt = lat > -1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], "@"];
        break;
      case 3:
        fmt = lat > -1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], "@"];
        break;
    }
    var ff = v > 0 ? fmt[0] : v < 0 ? fmt[1] : fmt[2];
    if (fmt[0].indexOf("[") === -1 && fmt[1].indexOf("[") === -1) return [l, ff];
    if (fmt[0].match(/\[[=<>]/) != null || fmt[1].match(/\[[=<>]/) != null) {
      var m1 = fmt[0].match(cfregex2);
      var m2 = fmt[1].match(cfregex2);
      return chkcond(v, m1) ? [l, fmt[0]] : chkcond(v, m2) ? [l, fmt[1]] : [l, fmt[m1 != null && m2 != null ? 2 : 1]];
    }
    return [l, ff];
  }
  function SSF_format(fmt, v, o) {
    if (o == null) o = {};
    var sfmt = "";
    switch (typeof fmt) {
      case "string":
        if (fmt == "m/d/yy" && o.dateNF) sfmt = o.dateNF;
        else sfmt = fmt;
        break;
      case "number":
        if (fmt == 14 && o.dateNF) sfmt = o.dateNF;
        else sfmt = (o.table != null ? o.table : table_fmt)[fmt];
        if (sfmt == null) sfmt = o.table && o.table[SSF_default_map[fmt]] || table_fmt[SSF_default_map[fmt]];
        if (sfmt == null) sfmt = SSF_default_str[fmt] || "General";
        break;
    }
    if (SSF_isgeneral(sfmt, 0)) return SSF_general(v, o);
    if (v instanceof Date) v = datenum(v, o.date1904);
    var f = choose_fmt(sfmt, v);
    if (SSF_isgeneral(f[1])) return SSF_general(v, o);
    if (v === true) v = "TRUE";
    else if (v === false) v = "FALSE";
    else if (v === "" || v == null) return "";
    else if (isNaN(v) && f[1].indexOf("0") > -1) return "#NUM!";
    else if (!isFinite(v) && f[1].indexOf("0") > -1) return "#DIV/0!";
    return eval_fmt(f[1], v, o, f[0]);
  }
  function SSF_load(fmt, idx) {
    if (typeof idx != "number") {
      idx = +idx || -1;
      for (var i = 0; i < 392; ++i) {
        if (table_fmt[i] == void 0) {
          if (idx < 0) idx = i;
          continue;
        }
        if (table_fmt[i] == fmt) {
          idx = i;
          break;
        }
      }
      if (idx < 0) idx = 391;
    }
    table_fmt[idx] = fmt;
    return idx;
  }
  function SSF_load_table(tbl) {
    for (var i = 0; i != 392; ++i)
      if (tbl[i] !== void 0) SSF_load(tbl[i], i);
  }
  function make_ssf() {
    table_fmt = SSF_init_table();
  }
  var SSF = {
    format: SSF_format,
    load: SSF_load,
    _table: table_fmt,
    load_table: SSF_load_table,
    parse_date_code: SSF_parse_date_code,
    is_date: fmt_is_date,
    get_table: function get_table() {
      return SSF._table = table_fmt;
    }
  };
  var SSFImplicit = {
    "5": '"$"#,##0_);\\("$"#,##0\\)',
    "6": '"$"#,##0_);[Red]\\("$"#,##0\\)',
    "7": '"$"#,##0.00_);\\("$"#,##0.00\\)',
    "8": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    "23": "General",
    "24": "General",
    "25": "General",
    "26": "General",
    "27": "m/d/yy",
    "28": "m/d/yy",
    "29": "m/d/yy",
    "30": "m/d/yy",
    "31": "m/d/yy",
    "32": "h:mm:ss",
    "33": "h:mm:ss",
    "34": "h:mm:ss",
    "35": "h:mm:ss",
    "36": "m/d/yy",
    "41": '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
    "42": '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',
    "43": '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',
    "44": '_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',
    "50": "m/d/yy",
    "51": "m/d/yy",
    "52": "m/d/yy",
    "53": "m/d/yy",
    "54": "m/d/yy",
    "55": "m/d/yy",
    "56": "m/d/yy",
    "57": "m/d/yy",
    "58": "m/d/yy",
    "59": "0",
    "60": "0.00",
    "61": "#,##0",
    "62": "#,##0.00",
    "63": '"$"#,##0_);\\("$"#,##0\\)',
    "64": '"$"#,##0_);[Red]\\("$"#,##0\\)',
    "65": '"$"#,##0.00_);\\("$"#,##0.00\\)',
    "66": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    "67": "0%",
    "68": "0.00%",
    "69": "# ?/?",
    "70": "# ??/??",
    "71": "m/d/yy",
    "72": "m/d/yy",
    "73": "d-mmm-yy",
    "74": "d-mmm",
    "75": "mmm-yy",
    "76": "h:mm",
    "77": "h:mm:ss",
    "78": "m/d/yy h:mm",
    "79": "mm:ss",
    "80": "[h]:mm:ss",
    "81": "mmss.0"
  };
  var dateNFregex = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
  function dateNF_regex(dateNF) {
    var fmt = typeof dateNF == "number" ? table_fmt[dateNF] : dateNF;
    fmt = fmt.replace(dateNFregex, "(\\d+)");
    dateNFregex.lastIndex = 0;
    return new RegExp("^" + fmt + "$");
  }
  function dateNF_fix(str, dateNF, match) {
    var Y = -1, m = -1, d = -1, H = -1, M = -1, S = -1;
    (dateNF.match(dateNFregex) || []).forEach(function(n, i) {
      var v = parseInt(match[i + 1], 10);
      switch (n.toLowerCase().charAt(0)) {
        case "y":
          Y = v;
          break;
        case "d":
          d = v;
          break;
        case "h":
          H = v;
          break;
        case "s":
          S = v;
          break;
        case "m":
          if (H >= 0) M = v;
          else m = v;
          break;
      }
    });
    dateNFregex.lastIndex = 0;
    if (S >= 0 && M == -1 && m >= 0) {
      M = m;
      m = -1;
    }
    var datestr = ("" + (Y >= 0 ? Y : ( new Date()).getFullYear())).slice(-4) + "-" + ("00" + (m >= 1 ? m : 1)).slice(-2) + "-" + ("00" + (d >= 1 ? d : 1)).slice(-2);
    if (datestr.length == 7) datestr = "0" + datestr;
    if (datestr.length == 8) datestr = "20" + datestr;
    var timestr = ("00" + (H >= 0 ? H : 0)).slice(-2) + ":" + ("00" + (M >= 0 ? M : 0)).slice(-2) + ":" + ("00" + (S >= 0 ? S : 0)).slice(-2);
    if (H == -1 && M == -1 && S == -1) return datestr;
    if (Y == -1 && m == -1 && d == -1) return timestr;
    return datestr + "T" + timestr;
  }
  var bad_formats = {
    "d.m": "d\\.m"
};
  function SSF__load(fmt, idx) {
    return SSF_load(bad_formats[fmt] || fmt, idx);
  }
  var CRC32 = (function() {
    var CRC322 = {};
    CRC322.version = "1.2.0";
    function signed_crc_table() {
      var c = 0, table = new Array(256);
      for (var n = 0; n != 256; ++n) {
        c = n;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        table[n] = c;
      }
      return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
    }
    var T0 = signed_crc_table();
    function slice_by_16_tables(T) {
      var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
      for (n = 0; n != 256; ++n) table[n] = T[n];
      for (n = 0; n != 256; ++n) {
        v = T[n];
        for (c = 256 + n; c < 4096; c += 256) v = table[c] = v >>> 8 ^ T[v & 255];
      }
      var out = [];
      for (n = 1; n != 16; ++n) out[n - 1] = typeof Int32Array !== "undefined" && typeof table.subarray == "function" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
      return out;
    }
    var TT = slice_by_16_tables(T0);
    var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
    var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
    var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
    function crc32_bstr(bstr, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = bstr.length; i < L; ) C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
      return ~C;
    }
    function crc32_buf(B, seed) {
      var C = seed ^ -1, L = B.length - 15, i = 0;
      for (; i < L; ) C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
      L += 15;
      while (i < L) C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
      return ~C;
    }
    function crc32_str(str, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = str.length, c = 0, d = 0; i < L; ) {
        c = str.charCodeAt(i++);
        if (c < 128) {
          C = C >>> 8 ^ T0[(C ^ c) & 255];
        } else if (c < 2048) {
          C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
        } else if (c >= 55296 && c < 57344) {
          c = (c & 1023) + 64;
          d = str.charCodeAt(i++) & 1023;
          C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
        } else {
          C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
        }
      }
      return ~C;
    }
    CRC322.table = T0;
    CRC322.bstr = crc32_bstr;
    CRC322.buf = crc32_buf;
    CRC322.str = crc32_str;
    return CRC322;
  })();
  var CFB = (function _CFB() {
    var exports = (
{}
    );
    exports.version = "1.2.2";
    function namecmp(l, r2) {
      var L = l.split("/"), R = r2.split("/");
      for (var i2 = 0, c = 0, Z = Math.min(L.length, R.length); i2 < Z; ++i2) {
        if (c = L[i2].length - R[i2].length) return c;
        if (L[i2] != R[i2]) return L[i2] < R[i2] ? -1 : 1;
      }
      return L.length - R.length;
    }
    function dirname(p2) {
      if (p2.charAt(p2.length - 1) == "/") return p2.slice(0, -1).indexOf("/") === -1 ? p2 : dirname(p2.slice(0, -1));
      var c = p2.lastIndexOf("/");
      return c === -1 ? p2 : p2.slice(0, c + 1);
    }
    function filename(p2) {
      if (p2.charAt(p2.length - 1) == "/") return filename(p2.slice(0, -1));
      var c = p2.lastIndexOf("/");
      return c === -1 ? p2 : p2.slice(c + 1);
    }
    function write_dos_date(buf, date) {
      if (typeof date === "string") date = new Date(date);
      var hms = date.getHours();
      hms = hms << 6 | date.getMinutes();
      hms = hms << 5 | date.getSeconds() >>> 1;
      buf.write_shift(2, hms);
      var ymd = date.getFullYear() - 1980;
      ymd = ymd << 4 | date.getMonth() + 1;
      ymd = ymd << 5 | date.getDate();
      buf.write_shift(2, ymd);
    }
    function parse_dos_date(buf) {
      var hms = buf.read_shift(2) & 65535;
      var ymd = buf.read_shift(2) & 65535;
      var val2 = new Date();
      var d = ymd & 31;
      ymd >>>= 5;
      var m = ymd & 15;
      ymd >>>= 4;
      val2.setMilliseconds(0);
      val2.setFullYear(ymd + 1980);
      val2.setMonth(m - 1);
      val2.setDate(d);
      var S = hms & 31;
      hms >>>= 5;
      var M = hms & 63;
      hms >>>= 6;
      val2.setHours(hms);
      val2.setMinutes(M);
      val2.setSeconds(S << 1);
      return val2;
    }
    function parse_extra_field(blob) {
      prep_blob(blob, 0);
      var o = (
{}
      );
      var flags = 0;
      while (blob.l <= blob.length - 4) {
        var type = blob.read_shift(2);
        var sz = blob.read_shift(2), tgt = blob.l + sz;
        var p2 = {};
        switch (type) {
case 21589:
            {
              flags = blob.read_shift(1);
              if (flags & 1) p2.mtime = blob.read_shift(4);
              if (sz > 5) {
                if (flags & 2) p2.atime = blob.read_shift(4);
                if (flags & 4) p2.ctime = blob.read_shift(4);
              }
              if (p2.mtime) p2.mt = new Date(p2.mtime * 1e3);
            }
            break;
case 1:
            {
              var sz1 = blob.read_shift(4), sz2 = blob.read_shift(4);
              p2.usz = sz2 * Math.pow(2, 32) + sz1;
              sz1 = blob.read_shift(4);
              sz2 = blob.read_shift(4);
              p2.csz = sz2 * Math.pow(2, 32) + sz1;
            }
            break;
        }
        blob.l = tgt;
        o[type] = p2;
      }
      return o;
    }
    var fs;
    function get_fs() {
      return fs || (fs = _fs);
    }
    function parse(file, options) {
      if (file[0] == 80 && file[1] == 75) return parse_zip2(file, options);
      if ((file[0] | 32) == 109 && (file[1] | 32) == 105) return parse_mad(file, options);
      if (file.length < 512) throw new Error("CFB file size " + file.length + " < 512");
      var mver = 3;
      var ssz = 512;
      var nmfs = 0;
      var difat_sec_cnt = 0;
      var dir_start = 0;
      var minifat_start = 0;
      var difat_start = 0;
      var fat_addrs = [];
      var blob = (
file.slice(0, 512)
      );
      prep_blob(blob, 0);
      var mv = check_get_mver(blob);
      mver = mv[0];
      switch (mver) {
        case 3:
          ssz = 512;
          break;
        case 4:
          ssz = 4096;
          break;
        case 0:
          if (mv[1] == 0) return parse_zip2(file, options);
default:
          throw new Error("Major Version: Expected 3 or 4 saw " + mver);
      }
      if (ssz !== 512) {
        blob =
file.slice(0, ssz);
        prep_blob(
          blob,
          28
);
      }
      var header = file.slice(0, ssz);
      check_shifts(blob, mver);
      var dir_cnt = blob.read_shift(4, "i");
      if (mver === 3 && dir_cnt !== 0) throw new Error("# Directory Sectors: Expected 0 saw " + dir_cnt);
      blob.l += 4;
      dir_start = blob.read_shift(4, "i");
      blob.l += 4;
      blob.chk("00100000", "Mini Stream Cutoff Size: ");
      minifat_start = blob.read_shift(4, "i");
      nmfs = blob.read_shift(4, "i");
      difat_start = blob.read_shift(4, "i");
      difat_sec_cnt = blob.read_shift(4, "i");
      for (var q2 = -1, j = 0; j < 109; ++j) {
        q2 = blob.read_shift(4, "i");
        if (q2 < 0) break;
        fat_addrs[j] = q2;
      }
      var sectors = sectorify(file, ssz);
      sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);
      var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);
      if (dir_start < sector_list.length) sector_list[dir_start].name = "!Directory";
      if (nmfs > 0 && minifat_start !== ENDOFCHAIN) sector_list[minifat_start].name = "!MiniFAT";
      sector_list[fat_addrs[0]].name = "!FAT";
      sector_list.fat_addrs = fat_addrs;
      sector_list.ssz = ssz;
      var files = {}, Paths = [], FileIndex = [], FullPaths = [];
      read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);
      build_full_paths(FileIndex, FullPaths, Paths);
      Paths.shift();
      var o = {
        FileIndex,
        FullPaths
      };
      if (options && options.raw) o.raw = { header, sectors };
      return o;
    }
    function check_get_mver(blob) {
      if (blob[blob.l] == 80 && blob[blob.l + 1] == 75) return [0, 0];
      blob.chk(HEADER_SIGNATURE, "Header Signature: ");
      blob.l += 16;
      var mver = blob.read_shift(2, "u");
      return [blob.read_shift(2, "u"), mver];
    }
    function check_shifts(blob, mver) {
      var shift = 9;
      blob.l += 2;
      switch (shift = blob.read_shift(2)) {
        case 9:
          if (mver != 3) throw new Error("Sector Shift: Expected 9 saw " + shift);
          break;
        case 12:
          if (mver != 4) throw new Error("Sector Shift: Expected 12 saw " + shift);
          break;
        default:
          throw new Error("Sector Shift: Expected 9 or 12 saw " + shift);
      }
      blob.chk("0600", "Mini Sector Shift: ");
      blob.chk("000000000000", "Reserved: ");
    }
    function sectorify(file, ssz) {
      var nsectors = Math.ceil(file.length / ssz) - 1;
      var sectors = [];
      for (var i2 = 1; i2 < nsectors; ++i2) sectors[i2 - 1] = file.slice(i2 * ssz, (i2 + 1) * ssz);
      sectors[nsectors - 1] = file.slice(nsectors * ssz);
      return sectors;
    }
    function build_full_paths(FI, FP, Paths) {
      var i2 = 0, L = 0, R = 0, C = 0, j = 0, pl = Paths.length;
      var dad = [], q2 = [];
      for (; i2 < pl; ++i2) {
        dad[i2] = q2[i2] = i2;
        FP[i2] = Paths[i2];
      }
      for (; j < q2.length; ++j) {
        i2 = q2[j];
        L = FI[i2].L;
        R = FI[i2].R;
        C = FI[i2].C;
        if (dad[i2] === i2) {
          if (L !== -1 && dad[L] !== L) dad[i2] = dad[L];
          if (R !== -1 && dad[R] !== R) dad[i2] = dad[R];
        }
        if (C !== -1) dad[C] = i2;
        if (L !== -1 && i2 != dad[i2]) {
          dad[L] = dad[i2];
          if (q2.lastIndexOf(L) < j) q2.push(L);
        }
        if (R !== -1 && i2 != dad[i2]) {
          dad[R] = dad[i2];
          if (q2.lastIndexOf(R) < j) q2.push(R);
        }
      }
      for (i2 = 1; i2 < pl; ++i2) if (dad[i2] === i2) {
        if (R !== -1 && dad[R] !== R) dad[i2] = dad[R];
        else if (L !== -1 && dad[L] !== L) dad[i2] = dad[L];
      }
      for (i2 = 1; i2 < pl; ++i2) {
        if (FI[i2].type === 0) continue;
        j = i2;
        if (j != dad[j]) do {
          j = dad[j];
          FP[i2] = FP[j] + "/" + FP[i2];
        } while (j !== 0 && -1 !== dad[j] && j != dad[j]);
        dad[i2] = -1;
      }
      FP[0] += "/";
      for (i2 = 1; i2 < pl; ++i2) {
        if (FI[i2].type !== 2) FP[i2] += "/";
      }
    }
    function get_mfat_entry(entry, payload, mini) {
      var start = entry.start, size = entry.size;
      var o = [];
      var idx = start;
      while (mini && size > 0 && idx >= 0) {
        o.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));
        size -= MSSZ;
        idx = __readInt32LE(mini, idx * 4);
      }
      if (o.length === 0) return new_buf(0);
      return bconcat(o).slice(0, entry.size);
    }
    function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {
      var q2 = ENDOFCHAIN;
      if (idx === ENDOFCHAIN) {
        if (cnt !== 0) throw new Error("DIFAT chain shorter than expected");
      } else if (idx !== -1) {
        var sector = sectors[idx], m = (ssz >>> 2) - 1;
        if (!sector) return;
        for (var i2 = 0; i2 < m; ++i2) {
          if ((q2 = __readInt32LE(sector, i2 * 4)) === ENDOFCHAIN) break;
          fat_addrs.push(q2);
        }
        if (cnt >= 1) sleuth_fat(__readInt32LE(sector, ssz - 4), cnt - 1, sectors, ssz, fat_addrs);
      }
    }
    function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {
      var buf = [], buf_chain = [];
      if (!chkd) chkd = [];
      var modulus = ssz - 1, j = 0, jj = 0;
      for (j = start; j >= 0; ) {
        chkd[j] = true;
        buf[buf.length] = j;
        buf_chain.push(sectors[j]);
        var addr = fat_addrs[Math.floor(j * 4 / ssz)];
        jj = j * 4 & modulus;
        if (ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
        if (!sectors[addr]) break;
        j = __readInt32LE(sectors[addr], jj);
      }
      return { nodes: buf, data: __toBuffer([buf_chain]) };
    }
    function make_sector_list(sectors, dir_start, fat_addrs, ssz) {
      var sl = sectors.length, sector_list = [];
      var chkd = [], buf = [], buf_chain = [];
      var modulus = ssz - 1, i2 = 0, j = 0, k = 0, jj = 0;
      for (i2 = 0; i2 < sl; ++i2) {
        buf = [];
        k = i2 + dir_start;
        if (k >= sl) k -= sl;
        if (chkd[k]) continue;
        buf_chain = [];
        var seen = [];
        for (j = k; j >= 0; ) {
          seen[j] = true;
          chkd[j] = true;
          buf[buf.length] = j;
          buf_chain.push(sectors[j]);
          var addr = fat_addrs[Math.floor(j * 4 / ssz)];
          jj = j * 4 & modulus;
          if (ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
          if (!sectors[addr]) break;
          j = __readInt32LE(sectors[addr], jj);
          if (seen[j]) break;
        }
        sector_list[k] = { nodes: buf, data: __toBuffer([buf_chain]) };
      }
      return sector_list;
    }
    function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {
      var minifat_store = 0, pl = Paths.length ? 2 : 0;
      var sector = sector_list[dir_start].data;
      var i2 = 0, namelen = 0, name;
      for (; i2 < sector.length; i2 += 128) {
        var blob = (
sector.slice(i2, i2 + 128)
        );
        prep_blob(blob, 64);
        namelen = blob.read_shift(2);
        name = __utf16le(blob, 0, namelen - pl);
        Paths.push(name);
        var o = {
          name,
          type: blob.read_shift(1),
          color: blob.read_shift(1),
          L: blob.read_shift(4, "i"),
          R: blob.read_shift(4, "i"),
          C: blob.read_shift(4, "i"),
          clsid: blob.read_shift(16),
          state: blob.read_shift(4, "i"),
          start: 0,
          size: 0
        };
        var ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
        if (ctime !== 0) o.ct = read_date(blob, blob.l - 8);
        var mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
        if (mtime !== 0) o.mt = read_date(blob, blob.l - 8);
        o.start = blob.read_shift(4, "i");
        o.size = blob.read_shift(4, "i");
        if (o.size < 0 && o.start < 0) {
          o.size = o.type = 0;
          o.start = ENDOFCHAIN;
          o.name = "";
        }
        if (o.type === 5) {
          minifat_store = o.start;
          if (nmfs > 0 && minifat_store !== ENDOFCHAIN) sector_list[minifat_store].name = "!StreamData";
        } else if (o.size >= 4096) {
          o.storage = "fat";
          if (sector_list[o.start] === void 0) sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);
          sector_list[o.start].name = o.name;
          o.content = sector_list[o.start].data.slice(0, o.size);
        } else {
          o.storage = "minifat";
          if (o.size < 0) o.size = 0;
          else if (minifat_store !== ENDOFCHAIN && o.start !== ENDOFCHAIN && sector_list[minifat_store]) {
            o.content = get_mfat_entry(o, sector_list[minifat_store].data, (sector_list[mini] || {}).data);
          }
        }
        if (o.content) prep_blob(o.content, 0);
        files[name] = o;
        FileIndex.push(o);
      }
    }
    function read_date(blob, offset) {
      return new Date((__readUInt32LE(blob, offset + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(blob, offset) / 1e7 - 11644473600) * 1e3);
    }
    function read_file(filename2, options) {
      get_fs();
      return parse(fs.readFileSync(filename2), options);
    }
    function read(blob, options) {
      var type = options && options.type;
      if (!type) {
        if (has_buf && Buffer.isBuffer(blob)) type = "buffer";
      }
      switch (type || "base64") {
        case "file":
          return read_file(blob, options);
        case "base64":
          return parse(s2a(Base64_decode(blob)), options);
        case "binary":
          return parse(s2a(blob), options);
      }
      return parse(
blob,
        options
      );
    }
    function init_cfb(cfb, opts) {
      var o = opts || {}, root = o.root || "Root Entry";
      if (!cfb.FullPaths) cfb.FullPaths = [];
      if (!cfb.FileIndex) cfb.FileIndex = [];
      if (cfb.FullPaths.length !== cfb.FileIndex.length) throw new Error("inconsistent CFB structure");
      if (cfb.FullPaths.length === 0) {
        cfb.FullPaths[0] = root + "/";
        cfb.FileIndex[0] = { name: root, type: 5 };
      }
      if (o.CLSID) cfb.FileIndex[0].clsid = o.CLSID;
      seed_cfb(cfb);
    }
    function seed_cfb(cfb) {
      var nm = "Sh33tJ5";
      if (CFB.find(cfb, "/" + nm)) return;
      var p2 = new_buf(4);
      p2[0] = 55;
      p2[1] = p2[3] = 50;
      p2[2] = 54;
      cfb.FileIndex.push({ name: nm, type: 2, content: p2, size: 4, L: 69, R: 69, C: 69 });
      cfb.FullPaths.push(cfb.FullPaths[0] + nm);
      rebuild_cfb(cfb);
    }
    function rebuild_cfb(cfb, f) {
      init_cfb(cfb);
      var gc = false, s = false;
      for (var i2 = cfb.FullPaths.length - 1; i2 >= 0; --i2) {
        var _file = cfb.FileIndex[i2];
        switch (_file.type) {
          case 0:
            if (s) gc = true;
            else {
              cfb.FileIndex.pop();
              cfb.FullPaths.pop();
            }
            break;
          case 1:
          case 2:
          case 5:
            s = true;
            if (isNaN(_file.R * _file.L * _file.C)) gc = true;
            if (_file.R > -1 && _file.L > -1 && _file.R == _file.L) gc = true;
            break;
          default:
            gc = true;
            break;
        }
      }
      if (!gc && !f) return;
      var now = new Date(1987, 1, 19), j = 0;
      var fullPaths = Object.create ? Object.create(null) : {};
      var data = [];
      for (i2 = 0; i2 < cfb.FullPaths.length; ++i2) {
        fullPaths[cfb.FullPaths[i2]] = true;
        if (cfb.FileIndex[i2].type === 0) continue;
        data.push([cfb.FullPaths[i2], cfb.FileIndex[i2]]);
      }
      for (i2 = 0; i2 < data.length; ++i2) {
        var dad = dirname(data[i2][0]);
        s = fullPaths[dad];
        while (!s) {
          while (dirname(dad) && !fullPaths[dirname(dad)]) dad = dirname(dad);
          data.push([dad, {
            name: filename(dad).replace("/", ""),
            type: 1,
            clsid: HEADER_CLSID,
            ct: now,
            mt: now,
            content: null
          }]);
          fullPaths[dad] = true;
          dad = dirname(data[i2][0]);
          s = fullPaths[dad];
        }
      }
      data.sort(function(x, y) {
        return namecmp(x[0], y[0]);
      });
      cfb.FullPaths = [];
      cfb.FileIndex = [];
      for (i2 = 0; i2 < data.length; ++i2) {
        cfb.FullPaths[i2] = data[i2][0];
        cfb.FileIndex[i2] = data[i2][1];
      }
      for (i2 = 0; i2 < data.length; ++i2) {
        var elt = cfb.FileIndex[i2];
        var nm = cfb.FullPaths[i2];
        elt.name = filename(nm).replace("/", "");
        elt.L = elt.R = elt.C = -(elt.color = 1);
        elt.size = elt.content ? elt.content.length : 0;
        elt.start = 0;
        elt.clsid = elt.clsid || HEADER_CLSID;
        if (i2 === 0) {
          elt.C = data.length > 1 ? 1 : -1;
          elt.size = 0;
          elt.type = 5;
        } else if (nm.slice(-1) == "/") {
          for (j = i2 + 1; j < data.length; ++j) if (dirname(cfb.FullPaths[j]) == nm) break;
          elt.C = j >= data.length ? -1 : j;
          for (j = i2 + 1; j < data.length; ++j) if (dirname(cfb.FullPaths[j]) == dirname(nm)) break;
          elt.R = j >= data.length ? -1 : j;
          elt.type = 1;
        } else {
          if (dirname(cfb.FullPaths[i2 + 1] || "") == dirname(nm)) elt.R = i2 + 1;
          elt.type = 2;
        }
      }
    }
    function _write(cfb, options) {
      var _opts = options || {};
      if (_opts.fileType == "mad") return write_mad(cfb, _opts);
      rebuild_cfb(cfb);
      switch (_opts.fileType) {
        case "zip":
          return write_zip2(cfb, _opts);
      }
      var L = (function(cfb2) {
        var mini_size = 0, fat_size = 0;
        for (var i3 = 0; i3 < cfb2.FileIndex.length; ++i3) {
          var file2 = cfb2.FileIndex[i3];
          if (!file2.content) continue;
          var flen2 = file2.content.length;
          if (flen2 > 0) {
            if (flen2 < 4096) mini_size += flen2 + 63 >> 6;
            else fat_size += flen2 + 511 >> 9;
          }
        }
        var dir_cnt = cfb2.FullPaths.length + 3 >> 2;
        var mini_cnt = mini_size + 7 >> 3;
        var mfat_cnt = mini_size + 127 >> 7;
        var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;
        var fat_cnt = fat_base + 127 >> 7;
        var difat_cnt = fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
        while (fat_base + fat_cnt + difat_cnt + 127 >> 7 > fat_cnt) difat_cnt = ++fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
        var L2 = [1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0];
        cfb2.FileIndex[0].size = mini_size << 6;
        L2[7] = (cfb2.FileIndex[0].start = L2[0] + L2[1] + L2[2] + L2[3] + L2[4] + L2[5]) + (L2[6] + 7 >> 3);
        return L2;
      })(cfb);
      var o = new_buf(L[7] << 9);
      var i2 = 0, T = 0;
      {
        for (i2 = 0; i2 < 8; ++i2) o.write_shift(1, HEADER_SIG[i2]);
        for (i2 = 0; i2 < 8; ++i2) o.write_shift(2, 0);
        o.write_shift(2, 62);
        o.write_shift(2, 3);
        o.write_shift(2, 65534);
        o.write_shift(2, 9);
        o.write_shift(2, 6);
        for (i2 = 0; i2 < 3; ++i2) o.write_shift(2, 0);
        o.write_shift(4, 0);
        o.write_shift(4, L[2]);
        o.write_shift(4, L[0] + L[1] + L[2] + L[3] - 1);
        o.write_shift(4, 0);
        o.write_shift(4, 1 << 12);
        o.write_shift(4, L[3] ? L[0] + L[1] + L[2] - 1 : ENDOFCHAIN);
        o.write_shift(4, L[3]);
        o.write_shift(-4, L[1] ? L[0] - 1 : ENDOFCHAIN);
        o.write_shift(4, L[1]);
        for (i2 = 0; i2 < 109; ++i2) o.write_shift(-4, i2 < L[2] ? L[1] + i2 : -1);
      }
      if (L[1]) {
        for (T = 0; T < L[1]; ++T) {
          for (; i2 < 236 + T * 127; ++i2) o.write_shift(-4, i2 < L[2] ? L[1] + i2 : -1);
          o.write_shift(-4, T === L[1] - 1 ? ENDOFCHAIN : T + 1);
        }
      }
      var chainit = function(w) {
        for (T += w; i2 < T - 1; ++i2) o.write_shift(-4, i2 + 1);
        if (w) {
          ++i2;
          o.write_shift(-4, ENDOFCHAIN);
        }
      };
      T = i2 = 0;
      for (T += L[1]; i2 < T; ++i2) o.write_shift(-4, consts.DIFSECT);
      for (T += L[2]; i2 < T; ++i2) o.write_shift(-4, consts.FATSECT);
      chainit(L[3]);
      chainit(L[4]);
      var j = 0, flen = 0;
      var file = cfb.FileIndex[0];
      for (; j < cfb.FileIndex.length; ++j) {
        file = cfb.FileIndex[j];
        if (!file.content) continue;
        flen = file.content.length;
        if (flen < 4096) continue;
        file.start = T;
        chainit(flen + 511 >> 9);
      }
      chainit(L[6] + 7 >> 3);
      while (o.l & 511) o.write_shift(-4, consts.ENDOFCHAIN);
      T = i2 = 0;
      for (j = 0; j < cfb.FileIndex.length; ++j) {
        file = cfb.FileIndex[j];
        if (!file.content) continue;
        flen = file.content.length;
        if (!flen || flen >= 4096) continue;
        file.start = T;
        chainit(flen + 63 >> 6);
      }
      while (o.l & 511) o.write_shift(-4, consts.ENDOFCHAIN);
      for (i2 = 0; i2 < L[4] << 2; ++i2) {
        var nm = cfb.FullPaths[i2];
        if (!nm || nm.length === 0) {
          for (j = 0; j < 17; ++j) o.write_shift(4, 0);
          for (j = 0; j < 3; ++j) o.write_shift(4, -1);
          for (j = 0; j < 12; ++j) o.write_shift(4, 0);
          continue;
        }
        file = cfb.FileIndex[i2];
        if (i2 === 0) file.start = file.size ? file.start - 1 : ENDOFCHAIN;
        var _nm = i2 === 0 && _opts.root || file.name;
        if (_nm.length > 31) {
          console.error("Name " + _nm + " will be truncated to " + _nm.slice(0, 31));
          _nm = _nm.slice(0, 31);
        }
        flen = 2 * (_nm.length + 1);
        o.write_shift(64, _nm, "utf16le");
        o.write_shift(2, flen);
        o.write_shift(1, file.type);
        o.write_shift(1, file.color);
        o.write_shift(-4, file.L);
        o.write_shift(-4, file.R);
        o.write_shift(-4, file.C);
        if (!file.clsid) for (j = 0; j < 4; ++j) o.write_shift(4, 0);
        else o.write_shift(16, file.clsid, "hex");
        o.write_shift(4, file.state || 0);
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        o.write_shift(4, file.start);
        o.write_shift(4, file.size);
        o.write_shift(4, 0);
      }
      for (i2 = 1; i2 < cfb.FileIndex.length; ++i2) {
        file = cfb.FileIndex[i2];
        if (file.size >= 4096) {
          o.l = file.start + 1 << 9;
          if (has_buf && Buffer.isBuffer(file.content)) {
            file.content.copy(o, o.l, 0, file.size);
            o.l += file.size + 511 & -512;
          } else {
            for (j = 0; j < file.size; ++j) o.write_shift(1, file.content[j]);
            for (; j & 511; ++j) o.write_shift(1, 0);
          }
        }
      }
      for (i2 = 1; i2 < cfb.FileIndex.length; ++i2) {
        file = cfb.FileIndex[i2];
        if (file.size > 0 && file.size < 4096) {
          if (has_buf && Buffer.isBuffer(file.content)) {
            file.content.copy(o, o.l, 0, file.size);
            o.l += file.size + 63 & -64;
          } else {
            for (j = 0; j < file.size; ++j) o.write_shift(1, file.content[j]);
            for (; j & 63; ++j) o.write_shift(1, 0);
          }
        }
      }
      if (has_buf) {
        o.l = o.length;
      } else {
        while (o.l < o.length) o.write_shift(1, 0);
      }
      return o;
    }
    function find(cfb, path) {
      var UCFullPaths = cfb.FullPaths.map(function(x) {
        return x.toUpperCase();
      });
      var UCPaths = UCFullPaths.map(function(x) {
        var y = x.split("/");
        return y[y.length - (x.slice(-1) == "/" ? 2 : 1)];
      });
      var k = false;
      if (path.charCodeAt(0) === 47) {
        k = true;
        path = UCFullPaths[0].slice(0, -1) + path;
      } else k = path.indexOf("/") !== -1;
      var UCPath = path.toUpperCase();
      var w = k === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
      if (w !== -1) return cfb.FileIndex[w];
      var m = !UCPath.match(chr1);
      UCPath = UCPath.replace(chr0, "");
      if (m) UCPath = UCPath.replace(chr1, "!");
      for (w = 0; w < UCFullPaths.length; ++w) {
        if ((m ? UCFullPaths[w].replace(chr1, "!") : UCFullPaths[w]).replace(chr0, "") == UCPath) return cfb.FileIndex[w];
        if ((m ? UCPaths[w].replace(chr1, "!") : UCPaths[w]).replace(chr0, "") == UCPath) return cfb.FileIndex[w];
      }
      return null;
    }
    var MSSZ = 64;
    var ENDOFCHAIN = -2;
    var HEADER_SIGNATURE = "d0cf11e0a1b11ae1";
    var HEADER_SIG = [208, 207, 17, 224, 161, 177, 26, 225];
    var HEADER_CLSID = "00000000000000000000000000000000";
    var consts = {
MAXREGSECT: -6,
      DIFSECT: -4,
      FATSECT: -3,
      ENDOFCHAIN,
      FREESECT: -1,
HEADER_SIGNATURE,
      HEADER_MINOR_VERSION: "3e00",
      MAXREGSID: -6,
      NOSTREAM: -1,
      HEADER_CLSID,
EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
    };
    function write_file(cfb, filename2, options) {
      get_fs();
      var o = _write(cfb, options);
      fs.writeFileSync(filename2, o);
    }
    function a2s2(o) {
      var out = new Array(o.length);
      for (var i2 = 0; i2 < o.length; ++i2) out[i2] = String.fromCharCode(o[i2]);
      return out.join("");
    }
    function write(cfb, options) {
      var o = _write(cfb, options);
      switch (options && options.type || "buffer") {
        case "file":
          get_fs();
          fs.writeFileSync(options.filename, o);
          return o;
        case "binary":
          return typeof o == "string" ? o : a2s2(o);
        case "base64":
          return Base64_encode(typeof o == "string" ? o : a2s2(o));
        case "buffer":
          if (has_buf) return Buffer.isBuffer(o) ? o : Buffer_from(o);
case "array":
          return typeof o == "string" ? s2a(o) : o;
      }
      return o;
    }
    var _zlib;
    function use_zlib(zlib) {
      try {
        var InflateRaw = zlib.InflateRaw;
        var InflRaw = new InflateRaw();
        InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);
        if (InflRaw.bytesRead) _zlib = zlib;
        else throw new Error("zlib does not expose bytesRead");
      } catch (e) {
        console.error("cannot use native zlib: " + (e.message || e));
      }
    }
    function _inflateRawSync(payload, usz) {
      if (!_zlib) return _inflate(payload, usz);
      var InflateRaw = _zlib.InflateRaw;
      var InflRaw = new InflateRaw();
      var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);
      payload.l += InflRaw.bytesRead;
      return out;
    }
    function _deflateRawSync(payload) {
      return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);
    }
    var CLEN_ORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var LEN_LN = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258];
    var DST_LN = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    function bit_swap_8(n) {
      var t = (n << 1 | n << 11) & 139536 | (n << 5 | n << 15) & 558144;
      return (t >> 16 | t >> 8 | t) & 255;
    }
    var use_typed_arrays = typeof Uint8Array !== "undefined";
    var bitswap8 = use_typed_arrays ? new Uint8Array(1 << 8) : [];
    for (var q = 0; q < 1 << 8; ++q) bitswap8[q] = bit_swap_8(q);
    function bit_swap_n(n, b) {
      var rev = bitswap8[n & 255];
      if (b <= 8) return rev >>> 8 - b;
      rev = rev << 8 | bitswap8[n >> 8 & 255];
      if (b <= 16) return rev >>> 16 - b;
      rev = rev << 8 | bitswap8[n >> 16 & 255];
      return rev >>> 24 - b;
    }
    function read_bits_2(buf, bl) {
      var w = bl & 7, h2 = bl >>> 3;
      return (buf[h2] | (w <= 6 ? 0 : buf[h2 + 1] << 8)) >>> w & 3;
    }
    function read_bits_3(buf, bl) {
      var w = bl & 7, h2 = bl >>> 3;
      return (buf[h2] | (w <= 5 ? 0 : buf[h2 + 1] << 8)) >>> w & 7;
    }
    function read_bits_4(buf, bl) {
      var w = bl & 7, h2 = bl >>> 3;
      return (buf[h2] | (w <= 4 ? 0 : buf[h2 + 1] << 8)) >>> w & 15;
    }
    function read_bits_5(buf, bl) {
      var w = bl & 7, h2 = bl >>> 3;
      return (buf[h2] | (w <= 3 ? 0 : buf[h2 + 1] << 8)) >>> w & 31;
    }
    function read_bits_7(buf, bl) {
      var w = bl & 7, h2 = bl >>> 3;
      return (buf[h2] | (w <= 1 ? 0 : buf[h2 + 1] << 8)) >>> w & 127;
    }
    function read_bits_n(buf, bl, n) {
      var w = bl & 7, h2 = bl >>> 3, f = (1 << n) - 1;
      var v = buf[h2] >>> w;
      if (n < 8 - w) return v & f;
      v |= buf[h2 + 1] << 8 - w;
      if (n < 16 - w) return v & f;
      v |= buf[h2 + 2] << 16 - w;
      if (n < 24 - w) return v & f;
      v |= buf[h2 + 3] << 24 - w;
      return v & f;
    }
    function write_bits_3(buf, bl, v) {
      var w = bl & 7, h2 = bl >>> 3;
      if (w <= 5) buf[h2] |= (v & 7) << w;
      else {
        buf[h2] |= v << w & 255;
        buf[h2 + 1] = (v & 7) >> 8 - w;
      }
      return bl + 3;
    }
    function write_bits_1(buf, bl, v) {
      var w = bl & 7, h2 = bl >>> 3;
      v = (v & 1) << w;
      buf[h2] |= v;
      return bl + 1;
    }
    function write_bits_8(buf, bl, v) {
      var w = bl & 7, h2 = bl >>> 3;
      v <<= w;
      buf[h2] |= v & 255;
      v >>>= 8;
      buf[h2 + 1] = v;
      return bl + 8;
    }
    function write_bits_16(buf, bl, v) {
      var w = bl & 7, h2 = bl >>> 3;
      v <<= w;
      buf[h2] |= v & 255;
      v >>>= 8;
      buf[h2 + 1] = v & 255;
      buf[h2 + 2] = v >>> 8;
      return bl + 16;
    }
    function realloc(b, sz) {
      var L = b.length, M = 2 * L > sz ? 2 * L : sz + 5, i2 = 0;
      if (L >= sz) return b;
      if (has_buf) {
        var o = new_unsafe_buf(M);
        if (b.copy) b.copy(o);
        else for (; i2 < b.length; ++i2) o[i2] = b[i2];
        return o;
      } else if (use_typed_arrays) {
        var a = new Uint8Array(M);
        if (a.set) a.set(b);
        else for (; i2 < L; ++i2) a[i2] = b[i2];
        return a;
      }
      b.length = M;
      return b;
    }
    function zero_fill_array(n) {
      var o = new Array(n);
      for (var i2 = 0; i2 < n; ++i2) o[i2] = 0;
      return o;
    }
    function build_tree(clens, cmap, MAX) {
      var maxlen = 1, w = 0, i2 = 0, j = 0, ccode = 0, L = clens.length;
      var bl_count = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
      for (i2 = 0; i2 < 32; ++i2) bl_count[i2] = 0;
      for (i2 = L; i2 < MAX; ++i2) clens[i2] = 0;
      L = clens.length;
      var ctree = use_typed_arrays ? new Uint16Array(L) : zero_fill_array(L);
      for (i2 = 0; i2 < L; ++i2) {
        bl_count[w = clens[i2]]++;
        if (maxlen < w) maxlen = w;
        ctree[i2] = 0;
      }
      bl_count[0] = 0;
      for (i2 = 1; i2 <= maxlen; ++i2) bl_count[i2 + 16] = ccode = ccode + bl_count[i2 - 1] << 1;
      for (i2 = 0; i2 < L; ++i2) {
        ccode = clens[i2];
        if (ccode != 0) ctree[i2] = bl_count[ccode + 16]++;
      }
      var cleni = 0;
      for (i2 = 0; i2 < L; ++i2) {
        cleni = clens[i2];
        if (cleni != 0) {
          ccode = bit_swap_n(ctree[i2], maxlen) >> maxlen - cleni;
          for (j = (1 << maxlen + 4 - cleni) - 1; j >= 0; --j)
            cmap[ccode | j << cleni] = cleni & 15 | i2 << 4;
        }
      }
      return maxlen;
    }
    var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);
    var fix_dmap = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
    if (!use_typed_arrays) {
      for (var i = 0; i < 512; ++i) fix_lmap[i] = 0;
      for (i = 0; i < 32; ++i) fix_dmap[i] = 0;
    }
    (function() {
      var dlens = [];
      var i2 = 0;
      for (; i2 < 32; i2++) dlens.push(5);
      build_tree(dlens, fix_dmap, 32);
      var clens = [];
      i2 = 0;
      for (; i2 <= 143; i2++) clens.push(8);
      for (; i2 <= 255; i2++) clens.push(9);
      for (; i2 <= 279; i2++) clens.push(7);
      for (; i2 <= 287; i2++) clens.push(8);
      build_tree(clens, fix_lmap, 288);
    })();
    var _deflateRaw = (function _deflateRawIIFE() {
      var DST_LN_RE = use_typed_arrays ? new Uint8Array(32768) : [];
      var j = 0, k = 0;
      for (; j < DST_LN.length - 1; ++j) {
        for (; k < DST_LN[j + 1]; ++k) DST_LN_RE[k] = j;
      }
      for (; k < 32768; ++k) DST_LN_RE[k] = 29;
      var LEN_LN_RE = use_typed_arrays ? new Uint8Array(259) : [];
      for (j = 0, k = 0; j < LEN_LN.length - 1; ++j) {
        for (; k < LEN_LN[j + 1]; ++k) LEN_LN_RE[k] = j;
      }
      function write_stored(data, out) {
        var boff = 0;
        while (boff < data.length) {
          var L = Math.min(65535, data.length - boff);
          var h2 = boff + L == data.length;
          out.write_shift(1, +h2);
          out.write_shift(2, L);
          out.write_shift(2, ~L & 65535);
          while (L-- > 0) out[out.l++] = data[boff++];
        }
        return out.l;
      }
      function write_huff_fixed(data, out) {
        var bl = 0;
        var boff = 0;
        var addrs = use_typed_arrays ? new Uint16Array(32768) : [];
        while (boff < data.length) {
          var L = (
Math.min(65535, data.length - boff)
          );
          if (L < 10) {
            bl = write_bits_3(out, bl, +!!(boff + L == data.length));
            if (bl & 7) bl += 8 - (bl & 7);
            out.l = bl / 8 | 0;
            out.write_shift(2, L);
            out.write_shift(2, ~L & 65535);
            while (L-- > 0) out[out.l++] = data[boff++];
            bl = out.l * 8;
            continue;
          }
          bl = write_bits_3(out, bl, +!!(boff + L == data.length) + 2);
          var hash = 0;
          while (L-- > 0) {
            var d = data[boff];
            hash = (hash << 5 ^ d) & 32767;
            var match = -1, mlen = 0;
            if (match = addrs[hash]) {
              match |= boff & -32768;
              if (match > boff) match -= 32768;
              if (match < boff) while (data[match + mlen] == data[boff + mlen] && mlen < 250) ++mlen;
            }
            if (mlen > 2) {
              d = LEN_LN_RE[mlen];
              if (d <= 22) bl = write_bits_8(out, bl, bitswap8[d + 1] >> 1) - 1;
              else {
                write_bits_8(out, bl, 3);
                bl += 5;
                write_bits_8(out, bl, bitswap8[d - 23] >> 5);
                bl += 3;
              }
              var len_eb = d < 8 ? 0 : d - 4 >> 2;
              if (len_eb > 0) {
                write_bits_16(out, bl, mlen - LEN_LN[d]);
                bl += len_eb;
              }
              d = DST_LN_RE[boff - match];
              bl = write_bits_8(out, bl, bitswap8[d] >> 3);
              bl -= 3;
              var dst_eb = d < 4 ? 0 : d - 2 >> 1;
              if (dst_eb > 0) {
                write_bits_16(out, bl, boff - match - DST_LN[d]);
                bl += dst_eb;
              }
              for (var q2 = 0; q2 < mlen; ++q2) {
                addrs[hash] = boff & 32767;
                hash = (hash << 5 ^ data[boff]) & 32767;
                ++boff;
              }
              L -= mlen - 1;
            } else {
              if (d <= 143) d = d + 48;
              else bl = write_bits_1(out, bl, 1);
              bl = write_bits_8(out, bl, bitswap8[d]);
              addrs[hash] = boff & 32767;
              ++boff;
            }
          }
          bl = write_bits_8(out, bl, 0) - 1;
        }
        out.l = (bl + 7) / 8 | 0;
        return out.l;
      }
      return function _deflateRaw2(data, out) {
        if (data.length < 8) return write_stored(data, out);
        return write_huff_fixed(data, out);
      };
    })();
    function _deflate(data) {
      var buf = new_buf(50 + Math.floor(data.length * 1.1));
      var off = _deflateRaw(data, buf);
      return buf.slice(0, off);
    }
    var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
    var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
    var dyn_cmap = use_typed_arrays ? new Uint16Array(128) : zero_fill_array(128);
    var dyn_len_1 = 1, dyn_len_2 = 1;
    function dyn(data, boff) {
      var _HLIT = read_bits_5(data, boff) + 257;
      boff += 5;
      var _HDIST = read_bits_5(data, boff) + 1;
      boff += 5;
      var _HCLEN = read_bits_4(data, boff) + 4;
      boff += 4;
      var w = 0;
      var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);
      var ctree = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      var maxlen = 1;
      var bl_count = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
      var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
      var L = clens.length;
      for (var i2 = 0; i2 < _HCLEN; ++i2) {
        clens[CLEN_ORDER[i2]] = w = read_bits_3(data, boff);
        if (maxlen < w) maxlen = w;
        bl_count[w]++;
        boff += 3;
      }
      var ccode = 0;
      bl_count[0] = 0;
      for (i2 = 1; i2 <= maxlen; ++i2) next_code[i2] = ccode = ccode + bl_count[i2 - 1] << 1;
      for (i2 = 0; i2 < L; ++i2) if ((ccode = clens[i2]) != 0) ctree[i2] = next_code[ccode]++;
      var cleni = 0;
      for (i2 = 0; i2 < L; ++i2) {
        cleni = clens[i2];
        if (cleni != 0) {
          ccode = bitswap8[ctree[i2]] >> 8 - cleni;
          for (var j = (1 << 7 - cleni) - 1; j >= 0; --j) dyn_cmap[ccode | j << cleni] = cleni & 7 | i2 << 3;
        }
      }
      var hcodes = [];
      maxlen = 1;
      for (; hcodes.length < _HLIT + _HDIST; ) {
        ccode = dyn_cmap[read_bits_7(data, boff)];
        boff += ccode & 7;
        switch (ccode >>>= 3) {
          case 16:
            w = 3 + read_bits_2(data, boff);
            boff += 2;
            ccode = hcodes[hcodes.length - 1];
            while (w-- > 0) hcodes.push(ccode);
            break;
          case 17:
            w = 3 + read_bits_3(data, boff);
            boff += 3;
            while (w-- > 0) hcodes.push(0);
            break;
          case 18:
            w = 11 + read_bits_7(data, boff);
            boff += 7;
            while (w-- > 0) hcodes.push(0);
            break;
          default:
            hcodes.push(ccode);
            if (maxlen < ccode) maxlen = ccode;
            break;
        }
      }
      var h1 = hcodes.slice(0, _HLIT), h2 = hcodes.slice(_HLIT);
      for (i2 = _HLIT; i2 < 286; ++i2) h1[i2] = 0;
      for (i2 = _HDIST; i2 < 30; ++i2) h2[i2] = 0;
      dyn_len_1 = build_tree(h1, dyn_lmap, 286);
      dyn_len_2 = build_tree(h2, dyn_dmap, 30);
      return boff;
    }
    function inflate(data, usz) {
      if (data[0] == 3 && !(data[1] & 3)) {
        return [new_raw_buf(usz), 2];
      }
      var boff = 0;
      var header = 0;
      var outbuf = new_unsafe_buf(usz ? usz : 1 << 18);
      var woff = 0;
      var OL = outbuf.length >>> 0;
      var max_len_1 = 0, max_len_2 = 0;
      while ((header & 1) == 0) {
        header = read_bits_3(data, boff);
        boff += 3;
        if (header >>> 1 == 0) {
          if (boff & 7) boff += 8 - (boff & 7);
          var sz = data[boff >>> 3] | data[(boff >>> 3) + 1] << 8;
          boff += 32;
          if (sz > 0) {
            if (!usz && OL < woff + sz) {
              outbuf = realloc(outbuf, woff + sz);
              OL = outbuf.length;
            }
            while (sz-- > 0) {
              outbuf[woff++] = data[boff >>> 3];
              boff += 8;
            }
          }
          continue;
        } else if (header >> 1 == 1) {
          max_len_1 = 9;
          max_len_2 = 5;
        } else {
          boff = dyn(data, boff);
          max_len_1 = dyn_len_1;
          max_len_2 = dyn_len_2;
        }
        for (; ; ) {
          if (!usz && OL < woff + 32767) {
            outbuf = realloc(outbuf, woff + 32767);
            OL = outbuf.length;
          }
          var bits = read_bits_n(data, boff, max_len_1);
          var code = header >>> 1 == 1 ? fix_lmap[bits] : dyn_lmap[bits];
          boff += code & 15;
          code >>>= 4;
          if ((code >>> 8 & 255) === 0) outbuf[woff++] = code;
          else if (code == 256) break;
          else {
            code -= 257;
            var len_eb = code < 8 ? 0 : code - 4 >> 2;
            if (len_eb > 5) len_eb = 0;
            var tgt = woff + LEN_LN[code];
            if (len_eb > 0) {
              tgt += read_bits_n(data, boff, len_eb);
              boff += len_eb;
            }
            bits = read_bits_n(data, boff, max_len_2);
            code = header >>> 1 == 1 ? fix_dmap[bits] : dyn_dmap[bits];
            boff += code & 15;
            code >>>= 4;
            var dst_eb = code < 4 ? 0 : code - 2 >> 1;
            var dst = DST_LN[code];
            if (dst_eb > 0) {
              dst += read_bits_n(data, boff, dst_eb);
              boff += dst_eb;
            }
            if (!usz && OL < tgt) {
              outbuf = realloc(outbuf, tgt + 100);
              OL = outbuf.length;
            }
            while (woff < tgt) {
              outbuf[woff] = outbuf[woff - dst];
              ++woff;
            }
          }
        }
      }
      if (usz) return [outbuf, boff + 7 >>> 3];
      return [outbuf.slice(0, woff), boff + 7 >>> 3];
    }
    function _inflate(payload, usz) {
      var data = payload.slice(payload.l || 0);
      var out = inflate(data, usz);
      payload.l += out[1];
      return out[0];
    }
    function warn_or_throw(wrn, msg) {
      if (wrn) {
        if (typeof console !== "undefined") console.error(msg);
      } else throw new Error(msg);
    }
    function parse_zip2(file, options) {
      var blob = (
file
      );
      prep_blob(blob, 0);
      var FileIndex = [], FullPaths = [];
      var o = {
        FileIndex,
        FullPaths
      };
      init_cfb(o, { root: options.root });
      var i2 = blob.length - 4;
      while ((blob[i2] != 80 || blob[i2 + 1] != 75 || blob[i2 + 2] != 5 || blob[i2 + 3] != 6) && i2 >= 0) --i2;
      blob.l = i2 + 4;
      blob.l += 4;
      var fcnt = blob.read_shift(2);
      blob.l += 6;
      var start_cd = blob.read_shift(4);
      blob.l = start_cd;
      for (i2 = 0; i2 < fcnt; ++i2) {
        blob.l += 20;
        var csz = blob.read_shift(4);
        var usz = blob.read_shift(4);
        var namelen = blob.read_shift(2);
        var efsz = blob.read_shift(2);
        var fcsz = blob.read_shift(2);
        blob.l += 8;
        var offset = blob.read_shift(4);
        var EF = parse_extra_field(
blob.slice(blob.l + namelen, blob.l + namelen + efsz)
);
        blob.l += namelen + efsz + fcsz;
        var L = blob.l;
        blob.l = offset + 4;
        if (EF && EF[1]) {
          if ((EF[1] || {}).usz) usz = EF[1].usz;
          if ((EF[1] || {}).csz) csz = EF[1].csz;
        }
        parse_local_file(blob, csz, usz, o, EF);
        blob.l = L;
      }
      return o;
    }
    function parse_local_file(blob, csz, usz, o, EF) {
      blob.l += 2;
      var flags = blob.read_shift(2);
      var meth = blob.read_shift(2);
      var date = parse_dos_date(blob);
      if (flags & 8257) throw new Error("Unsupported ZIP encryption");
      var crc32 = blob.read_shift(4);
      var _csz = blob.read_shift(4);
      var _usz = blob.read_shift(4);
      var namelen = blob.read_shift(2);
      var efsz = blob.read_shift(2);
      var name = "";
      for (var i2 = 0; i2 < namelen; ++i2) name += String.fromCharCode(blob[blob.l++]);
      if (efsz) {
        var ef = parse_extra_field(
blob.slice(blob.l, blob.l + efsz)
);
        if ((ef[21589] || {}).mt) date = ef[21589].mt;
        if ((ef[1] || {}).usz) _usz = ef[1].usz;
        if ((ef[1] || {}).csz) _csz = ef[1].csz;
        if (EF) {
          if ((EF[21589] || {}).mt) date = EF[21589].mt;
          if ((EF[1] || {}).usz) _usz = EF[1].usz;
          if ((EF[1] || {}).csz) _csz = EF[1].csz;
        }
      }
      blob.l += efsz;
      var data = blob.slice(blob.l, blob.l + _csz);
      switch (meth) {
        case 8:
          data = _inflateRawSync(blob, _usz);
          break;
        case 0:
          blob.l += _csz;
          break;
default:
          throw new Error("Unsupported ZIP Compression method " + meth);
      }
      var wrn = false;
      if (flags & 8) {
        crc32 = blob.read_shift(4);
        if (crc32 == 134695760) {
          crc32 = blob.read_shift(4);
          wrn = true;
        }
        _csz = blob.read_shift(4);
        _usz = blob.read_shift(4);
      }
      if (_csz != csz) warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);
      if (_usz != usz) warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);
      cfb_add(o, name, data, { unsafe: true, mt: date });
    }
    function write_zip2(cfb, options) {
      var _opts = options || {};
      var out = [], cdirs = [];
      var o = new_buf(1);
      var method = _opts.compression ? 8 : 0, flags = 0;
      var i2 = 0, j = 0;
      var start_cd = 0, fcnt = 0;
      var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];
      var crcs = [];
      var sz_cd = 0;
      for (i2 = 1; i2 < cfb.FullPaths.length; ++i2) {
        fp = cfb.FullPaths[i2].slice(root.length);
        fi = cfb.FileIndex[i2];
        if (!fi.size || !fi.content || Array.isArray(fi.content) && fi.content.length == 0 || fp == "Sh33tJ5") continue;
        var start = start_cd;
        var namebuf = new_buf(fp.length);
        for (j = 0; j < fp.length; ++j) namebuf.write_shift(1, fp.charCodeAt(j) & 127);
        namebuf = namebuf.slice(0, namebuf.l);
        crcs[fcnt] = typeof fi.content == "string" ? CRC32.bstr(fi.content, 0) : CRC32.buf(
fi.content,
          0
        );
        var outbuf = typeof fi.content == "string" ? s2a(fi.content) : fi.content;
        if (method == 8) outbuf = _deflateRawSync(outbuf);
        o = new_buf(30);
        o.write_shift(4, 67324752);
        o.write_shift(2, 20);
        o.write_shift(2, flags);
        o.write_shift(2, method);
        if (fi.mt) write_dos_date(o, fi.mt);
        else o.write_shift(4, 0);
        o.write_shift(-4, crcs[fcnt]);
        o.write_shift(4, outbuf.length);
        o.write_shift(
          4,
fi.content.length
        );
        o.write_shift(2, namebuf.length);
        o.write_shift(2, 0);
        start_cd += o.length;
        out.push(o);
        start_cd += namebuf.length;
        out.push(namebuf);
        start_cd += outbuf.length;
        out.push(outbuf);
        o = new_buf(46);
        o.write_shift(4, 33639248);
        o.write_shift(2, 0);
        o.write_shift(2, 20);
        o.write_shift(2, flags);
        o.write_shift(2, method);
        o.write_shift(4, 0);
        o.write_shift(-4, crcs[fcnt]);
        o.write_shift(4, outbuf.length);
        o.write_shift(
          4,
fi.content.length
        );
        o.write_shift(2, namebuf.length);
        o.write_shift(2, 0);
        o.write_shift(2, 0);
        o.write_shift(2, 0);
        o.write_shift(2, 0);
        o.write_shift(4, 0);
        o.write_shift(4, start);
        sz_cd += o.l;
        cdirs.push(o);
        sz_cd += namebuf.length;
        cdirs.push(namebuf);
        ++fcnt;
      }
      o = new_buf(22);
      o.write_shift(4, 101010256);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(2, fcnt);
      o.write_shift(2, fcnt);
      o.write_shift(4, sz_cd);
      o.write_shift(4, start_cd);
      o.write_shift(2, 0);
      return bconcat([bconcat(out), bconcat(cdirs), o]);
    }
    var ContentTypeMap = {
      "htm": "text/html",
      "xml": "text/xml",
      "gif": "image/gif",
      "jpg": "image/jpeg",
      "png": "image/png",
      "mso": "application/x-mso",
      "thmx": "application/vnd.ms-officetheme",
      "sh33tj5": "application/octet-stream"
    };
    function get_content_type(fi, fp) {
      if (fi.ctype) return fi.ctype;
      var ext = fi.name || "", m = ext.match(/\.([^\.]+)$/);
      if (m && ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];
      if (fp) {
        m = (ext = fp).match(/[\.\\]([^\.\\])+$/);
        if (m && ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];
      }
      return "application/octet-stream";
    }
    function write_base64_76(bstr) {
      var data = Base64_encode(bstr);
      var o = [];
      for (var i2 = 0; i2 < data.length; i2 += 76) o.push(data.slice(i2, i2 + 76));
      return o.join("\r\n") + "\r\n";
    }
    function write_quoted_printable(text) {
      var encoded = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(c) {
        var w = c.charCodeAt(0).toString(16).toUpperCase();
        return "=" + (w.length == 1 ? "0" + w : w);
      });
      encoded = encoded.replace(/ $/mg, "=20").replace(/\t$/mg, "=09");
      if (encoded.charAt(0) == "\n") encoded = "=0D" + encoded.slice(1);
      encoded = encoded.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, "\n=0A").replace(/([^\r\n])\n/mg, "$1=0A");
      var o = [], split = encoded.split("\r\n");
      for (var si = 0; si < split.length; ++si) {
        var str = split[si];
        if (str.length == 0) {
          o.push("");
          continue;
        }
        for (var i2 = 0; i2 < str.length; ) {
          var end = 76;
          var tmp = str.slice(i2, i2 + end);
          if (tmp.charAt(end - 1) == "=") end--;
          else if (tmp.charAt(end - 2) == "=") end -= 2;
          else if (tmp.charAt(end - 3) == "=") end -= 3;
          tmp = str.slice(i2, i2 + end);
          i2 += end;
          if (i2 < str.length) tmp += "=";
          o.push(tmp);
        }
      }
      return o.join("\r\n");
    }
    function parse_quoted_printable(data) {
      var o = [];
      for (var di = 0; di < data.length; ++di) {
        var line = data[di];
        while (di <= data.length && line.charAt(line.length - 1) == "=") line = line.slice(0, line.length - 1) + data[++di];
        o.push(line);
      }
      for (var oi = 0; oi < o.length; ++oi) o[oi] = o[oi].replace(/[=][0-9A-Fa-f]{2}/g, function($$) {
        return String.fromCharCode(parseInt($$.slice(1), 16));
      });
      return s2a(o.join("\r\n"));
    }
    function parse_mime(cfb, data, root) {
      var fname = "", cte = "", ctype = "", fdata;
      var di = 0;
      for (; di < 10; ++di) {
        var line = data[di];
        if (!line || line.match(/^\s*$/)) break;
        var m = line.match(/^([^:]*?):\s*([^\s].*)$/);
        if (m) switch (m[1].toLowerCase()) {
          case "content-location":
            fname = m[2].trim();
            break;
          case "content-type":
            ctype = m[2].trim();
            break;
          case "content-transfer-encoding":
            cte = m[2].trim();
            break;
        }
      }
      ++di;
      switch (cte.toLowerCase()) {
        case "base64":
          fdata = s2a(Base64_decode(data.slice(di).join("")));
          break;
        case "quoted-printable":
          fdata = parse_quoted_printable(data.slice(di));
          break;
        default:
          throw new Error("Unsupported Content-Transfer-Encoding " + cte);
      }
      var file = cfb_add(cfb, fname.slice(root.length), fdata, { unsafe: true });
      if (ctype) file.ctype = ctype;
    }
    function parse_mad(file, options) {
      if (a2s2(file.slice(0, 13)).toLowerCase() != "mime-version:") throw new Error("Unsupported MAD header");
      var root = options && options.root || "";
      var data = (has_buf && Buffer.isBuffer(file) ? file.toString("binary") : a2s2(file)).split("\r\n");
      var di = 0, row = "";
      for (di = 0; di < data.length; ++di) {
        row = data[di];
        if (!/^Content-Location:/i.test(row)) continue;
        row = row.slice(row.indexOf("file"));
        if (!root) root = row.slice(0, row.lastIndexOf("/") + 1);
        if (row.slice(0, root.length) == root) continue;
        while (root.length > 0) {
          root = root.slice(0, root.length - 1);
          root = root.slice(0, root.lastIndexOf("/") + 1);
          if (row.slice(0, root.length) == root) break;
        }
      }
      var mboundary = (data[1] || "").match(/boundary="(.*?)"/);
      if (!mboundary) throw new Error("MAD cannot find boundary");
      var boundary = "--" + (mboundary[1] || "");
      var FileIndex = [], FullPaths = [];
      var o = {
        FileIndex,
        FullPaths
      };
      init_cfb(o);
      var start_di, fcnt = 0;
      for (di = 0; di < data.length; ++di) {
        var line = data[di];
        if (line !== boundary && line !== boundary + "--") continue;
        if (fcnt++) parse_mime(o, data.slice(start_di, di), root);
        start_di = di;
      }
      return o;
    }
    function write_mad(cfb, options) {
      var opts = options || {};
      var boundary = opts.boundary || "SheetJS";
      boundary = "------=" + boundary;
      var out = [
        "MIME-Version: 1.0",
        'Content-Type: multipart/related; boundary="' + boundary.slice(2) + '"',
        "",
        "",
        ""
      ];
      var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];
      for (var i2 = 1; i2 < cfb.FullPaths.length; ++i2) {
        fp = cfb.FullPaths[i2].slice(root.length);
        fi = cfb.FileIndex[i2];
        if (!fi.size || !fi.content || fp == "Sh33tJ5") continue;
        fp = fp.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(c) {
          return "_x" + c.charCodeAt(0).toString(16) + "_";
        }).replace(/[\u0080-\uFFFF]/g, function(u) {
          return "_u" + u.charCodeAt(0).toString(16) + "_";
        });
        var ca = fi.content;
        var cstr = has_buf && Buffer.isBuffer(ca) ? ca.toString("binary") : a2s2(ca);
        var dispcnt = 0, L = Math.min(1024, cstr.length), cc = 0;
        for (var csl = 0; csl <= L; ++csl) if ((cc = cstr.charCodeAt(csl)) >= 32 && cc < 128) ++dispcnt;
        var qp = dispcnt >= L * 4 / 5;
        out.push(boundary);
        out.push("Content-Location: " + (opts.root || "file:///C:/SheetJS/") + fp);
        out.push("Content-Transfer-Encoding: " + (qp ? "quoted-printable" : "base64"));
        out.push("Content-Type: " + get_content_type(fi, fp));
        out.push("");
        out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));
      }
      out.push(boundary + "--\r\n");
      return out.join("\r\n");
    }
    function cfb_new(opts) {
      var o = {};
      init_cfb(o, opts);
      return o;
    }
    function cfb_add(cfb, name, content, opts) {
      var unsafe = opts && opts.unsafe;
      if (!unsafe) init_cfb(cfb);
      var file = !unsafe && CFB.find(cfb, name);
      if (!file) {
        var fpath = cfb.FullPaths[0];
        if (name.slice(0, fpath.length) == fpath) fpath = name;
        else {
          if (fpath.slice(-1) != "/") fpath += "/";
          fpath = (fpath + name).replace("//", "/");
        }
        file = { name: filename(name), type: 2 };
        cfb.FileIndex.push(file);
        cfb.FullPaths.push(fpath);
        if (!unsafe) CFB.utils.cfb_gc(cfb);
      }
      file.content = content;
      file.size = content ? content.length : 0;
      if (opts) {
        if (opts.CLSID) file.clsid = opts.CLSID;
        if (opts.mt) file.mt = opts.mt;
        if (opts.ct) file.ct = opts.ct;
      }
      return file;
    }
    function cfb_del(cfb, name) {
      init_cfb(cfb);
      var file = CFB.find(cfb, name);
      if (file) {
        for (var j = 0; j < cfb.FileIndex.length; ++j) if (cfb.FileIndex[j] == file) {
          cfb.FileIndex.splice(j, 1);
          cfb.FullPaths.splice(j, 1);
          return true;
        }
      }
      return false;
    }
    function cfb_mov(cfb, old_name, new_name) {
      init_cfb(cfb);
      var file = CFB.find(cfb, old_name);
      if (file) {
        for (var j = 0; j < cfb.FileIndex.length; ++j) if (cfb.FileIndex[j] == file) {
          cfb.FileIndex[j].name = filename(new_name);
          cfb.FullPaths[j] = new_name;
          return true;
        }
      }
      return false;
    }
    function cfb_gc(cfb) {
      rebuild_cfb(cfb, true);
    }
    exports.find = find;
    exports.read = read;
    exports.parse = parse;
    exports.write = write;
    exports.writeFile = write_file;
    exports.utils = {
      cfb_new,
      cfb_add,
      cfb_del,
      cfb_mov,
      cfb_gc,
      ReadShift,
      CheckField,
      prep_blob,
      bconcat,
      use_zlib,
      _deflateRaw: _deflate,
      _inflateRaw: _inflate,
      consts
    };
    return exports;
  })();
  var _fs;
  function set_fs(fs) {
    _fs = fs;
  }
  function blobify(data) {
    if (typeof data === "string") return s2ab(data);
    if (Array.isArray(data)) return a2u(data);
    return data;
  }
  function write_dl(fname, payload, enc) {
    if (typeof _fs !== "undefined" && _fs.writeFileSync) return enc ? _fs.writeFileSync(fname, payload, enc) : _fs.writeFileSync(fname, payload);
    if (typeof Deno !== "undefined") {
      if (enc && typeof payload == "string") switch (enc) {
        case "utf8":
          payload = new TextEncoder(enc).encode(payload);
          break;
        case "binary":
          payload = s2ab(payload);
          break;
default:
          throw new Error("Unsupported encoding " + enc);
      }
      return Deno.writeFileSync(fname, payload);
    }
    var data = enc == "utf8" ? utf8write(payload) : payload;
    if (typeof IE_SaveFile !== "undefined") return IE_SaveFile(data, fname);
    if (typeof Blob !== "undefined") {
      var blob = new Blob([blobify(data)], { type: "application/octet-stream" });
      if (typeof navigator !== "undefined" && navigator.msSaveBlob) return navigator.msSaveBlob(blob, fname);
      if (typeof saveAs !== "undefined") return saveAs(blob, fname);
      if (typeof URL !== "undefined" && typeof document !== "undefined" && document.createElement && URL.createObjectURL) {
        var url = URL.createObjectURL(blob);
        if (typeof chrome === "object" && typeof (chrome.downloads || {}).download == "function") {
          if (URL.revokeObjectURL && typeof setTimeout !== "undefined") setTimeout(function() {
            URL.revokeObjectURL(url);
          }, 6e4);
          return chrome.downloads.download({ url, filename: fname, saveAs: true });
        }
        var a = document.createElement("a");
        if (a.download != null) {
          a.download = fname;
          a.href = url;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          if (URL.revokeObjectURL && typeof setTimeout !== "undefined") setTimeout(function() {
            URL.revokeObjectURL(url);
          }, 6e4);
          return url;
        }
      } else if (typeof URL !== "undefined" && !URL.createObjectURL && typeof chrome === "object") {
        var b64 = "data:application/octet-stream;base64," + Base64_encode_arr(new Uint8Array(blobify(data)));
        return chrome.downloads.download({ url: b64, filename: fname, saveAs: true });
      }
    }
    if (typeof $ !== "undefined" && typeof File !== "undefined" && typeof Folder !== "undefined") try {
      var out = File(fname);
      out.open("w");
      out.encoding = "binary";
      if (Array.isArray(payload)) payload = a2s(payload);
      out.write(payload);
      out.close();
      return payload;
    } catch (e) {
      if (!e.message || e.message.indexOf("onstruct") == -1) throw e;
    }
    throw new Error("cannot save file " + fname);
  }
  function read_binary(path) {
    if (typeof _fs !== "undefined") return _fs.readFileSync(path);
    if (typeof Deno !== "undefined") return Deno.readFileSync(path);
    if (typeof $ !== "undefined" && typeof File !== "undefined" && typeof Folder !== "undefined") try {
      var infile = File(path);
      infile.open("r");
      infile.encoding = "binary";
      var data = infile.read();
      infile.close();
      return data;
    } catch (e) {
      if (!e.message || e.message.indexOf("onstruct") == -1) throw e;
    }
    throw new Error("Cannot access file " + path);
  }
  function keys(o) {
    var ks = Object.keys(o), o2 = [];
    for (var i = 0; i < ks.length; ++i) if (Object.prototype.hasOwnProperty.call(o, ks[i])) o2.push(ks[i]);
    return o2;
  }
  function evert_key(obj, key) {
    var o = [], K = keys(obj);
    for (var i = 0; i !== K.length; ++i) if (o[obj[K[i]][key]] == null) o[obj[K[i]][key]] = K[i];
    return o;
  }
  function evert(obj) {
    var o = [], K = keys(obj);
    for (var i = 0; i !== K.length; ++i) o[obj[K[i]]] = K[i];
    return o;
  }
  function evert_num(obj) {
    var o = [], K = keys(obj);
    for (var i = 0; i !== K.length; ++i) o[obj[K[i]]] = parseInt(K[i], 10);
    return o;
  }
  function evert_arr(obj) {
    var o = [], K = keys(obj);
    for (var i = 0; i !== K.length; ++i) {
      if (o[obj[K[i]]] == null) o[obj[K[i]]] = [];
      o[obj[K[i]]].push(K[i]);
    }
    return o;
  }
  var dnthresh = Date.UTC(1899, 11, 30, 0, 0, 0);
  var dnthresh1 = Date.UTC(1899, 11, 31, 0, 0, 0);
  var dnthresh2 = Date.UTC(1904, 0, 1, 0, 0, 0);
  function datenum(v, date1904) {
    var epoch = v.getTime();
    var res = (epoch - dnthresh) / (24 * 60 * 60 * 1e3);
    if (date1904) {
      res -= 1462;
      return res < -1402 ? res - 1 : res;
    }
    return res < 60 ? res - 1 : res;
  }
  function numdate(v) {
    if (v >= 60 && v < 61) return v;
    var out = new Date();
    out.setTime((v > 60 ? v : v + 1) * 24 * 60 * 60 * 1e3 + dnthresh);
    return out;
  }
  function parse_isodur(s) {
    var sec = 0, mt = 0, time = false;
    var m = s.match(/P([0-9\.]+Y)?([0-9\.]+M)?([0-9\.]+D)?T([0-9\.]+H)?([0-9\.]+M)?([0-9\.]+S)?/);
    if (!m) throw new Error("|" + s + "| is not an ISO8601 Duration");
    for (var i = 1; i != m.length; ++i) {
      if (!m[i]) continue;
      mt = 1;
      if (i > 3) time = true;
      switch (m[i].slice(m[i].length - 1)) {
        case "Y":
          throw new Error("Unsupported ISO Duration Field: " + m[i].slice(m[i].length - 1));
        case "D":
          mt *= 24;
case "H":
          mt *= 60;
case "M":
          if (!time) throw new Error("Unsupported ISO Duration Field: M");
          else mt *= 60;
      }
      sec += mt * parseInt(m[i], 10);
    }
    return sec;
  }
  var pdre1 = /^(\d+):(\d+)(:\d+)?(\.\d+)?$/;
  var pdre2 = /^(\d+)-(\d+)-(\d+)$/;
  var pdre3 = /^(\d+)-(\d+)-(\d+)[T ](\d+):(\d+)(:\d+)?(\.\d+)?$/;
  function parseDate(str, date1904) {
    if (str instanceof Date) return str;
    var m = str.match(pdre1);
    if (m) return new Date((date1904 ? dnthresh2 : dnthresh1) + ((parseInt(m[1], 10) * 60 + parseInt(m[2], 10)) * 60 + (m[3] ? parseInt(m[3].slice(1), 10) : 0)) * 1e3 + (m[4] ? parseInt((m[4] + "000").slice(1, 4), 10) : 0));
    m = str.match(pdre2);
    if (m) return new Date(Date.UTC(+m[1], +m[2] - 1, +m[3], 0, 0, 0, 0));
    m = str.match(pdre3);
    if (m) return new Date(Date.UTC(+m[1], +m[2] - 1, +m[3], +m[4], +m[5], m[6] && parseInt(m[6].slice(1), 10) || 0, m[7] && parseInt((m[7] + "0000").slice(1, 4), 10) || 0));
    var d = new Date(str);
    return d;
  }
  function cc2str(arr, debomit) {
    if (has_buf && Buffer.isBuffer(arr)) {
      if (debomit && buf_utf16le) {
        if (arr[0] == 255 && arr[1] == 254) return utf8write(arr.slice(2).toString("utf16le"));
        if (arr[1] == 254 && arr[2] == 255) return utf8write(utf16beread(arr.slice(2).toString("binary")));
      }
      return arr.toString("binary");
    }
    if (typeof TextDecoder !== "undefined") try {
      if (debomit) {
        if (arr[0] == 255 && arr[1] == 254) return utf8write(new TextDecoder("utf-16le").decode(arr.slice(2)));
        if (arr[0] == 254 && arr[1] == 255) return utf8write(new TextDecoder("utf-16be").decode(arr.slice(2)));
      }
      var rev = {
        "€": "",
        "‚": "",
        "ƒ": "",
        "„": "",
        "…": "",
        "†": "",
        "‡": "",
        "ˆ": "",
        "‰": "",
        "Š": "",
        "‹": "",
        "Œ": "",
        "Ž": "",
        "‘": "",
        "’": "",
        "“": "",
        "”": "",
        "•": "",
        "–": "",
        "—": "",
        "˜": "",
        "™": "",
        "š": "",
        "›": "",
        "œ": "",
        "ž": "",
        "Ÿ": ""
      };
      if (Array.isArray(arr)) arr = new Uint8Array(arr);
      return new TextDecoder("latin1").decode(arr).replace(/[€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ]/g, function(c) {
        return rev[c] || c;
      });
    } catch (e) {
    }
    var o = [], i = 0;
    try {
      for (i = 0; i < arr.length - 65536; i += 65536) o.push(String.fromCharCode.apply(0, arr.slice(i, i + 65536)));
      o.push(String.fromCharCode.apply(0, arr.slice(i)));
    } catch (e) {
      try {
        for (; i < arr.length - 16384; i += 16384) o.push(String.fromCharCode.apply(0, arr.slice(i, i + 16384)));
        o.push(String.fromCharCode.apply(0, arr.slice(i)));
      } catch (e2) {
        for (; i != arr.length; ++i) o.push(String.fromCharCode(arr[i]));
      }
    }
    return o.join("");
  }
  function dup(o) {
    if (typeof JSON != "undefined" && !Array.isArray(o)) return JSON.parse(JSON.stringify(o));
    if (typeof o != "object" || o == null) return o;
    if (o instanceof Date) return new Date(o.getTime());
    var out = {};
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) out[k] = dup(o[k]);
    return out;
  }
  function fill(c, l) {
    var o = "";
    while (o.length < l) o += c;
    return o;
  }
  function fuzzynum(s) {
    var v = Number(s);
    if (!isNaN(v)) return isFinite(v) ? v : NaN;
    if (!/\d/.test(s)) return v;
    var wt = 1;
    var ss = s.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
      wt *= 100;
      return "";
    });
    if (!isNaN(v = Number(ss))) return v / wt;
    ss = ss.replace(/[(]([^()]*)[)]/, function($$, $1) {
      wt = -wt;
      return $1;
    });
    if (!isNaN(v = Number(ss))) return v / wt;
    return v;
  }
  var FDRE1 = /^(0?\d|1[0-2])(?:|:([0-5]?\d)(?:|(\.\d+)(?:|:([0-5]?\d))|:([0-5]?\d)(|\.\d+)))\s+([ap])m?$/;
  var FDRE2 = /^([01]?\d|2[0-3])(?:|:([0-5]?\d)(?:|(\.\d+)(?:|:([0-5]?\d))|:([0-5]?\d)(|\.\d+)))$/;
  var FDISO = /^(\d+)-(\d+)-(\d+)[T ](\d+):(\d+)(:\d+)(\.\d+)?[Z]?$/;
  var utc_append_works = ( new Date("6/9/69 00:00 UTC")).valueOf() == -177984e5;
  function fuzzytime1(M) {
    if (!M[2]) return new Date(Date.UTC(1899, 11, 31, +M[1] % 12 + (M[7] == "p" ? 12 : 0), 0, 0, 0));
    if (M[3]) {
      if (M[4]) return new Date(Date.UTC(1899, 11, 31, +M[1] % 12 + (M[7] == "p" ? 12 : 0), +M[2], +M[4], parseFloat(M[3]) * 1e3));
      else return new Date(Date.UTC(1899, 11, 31, M[7] == "p" ? 12 : 0, +M[1], +M[2], parseFloat(M[3]) * 1e3));
    } else if (M[5]) return new Date(Date.UTC(1899, 11, 31, +M[1] % 12 + (M[7] == "p" ? 12 : 0), +M[2], +M[5], M[6] ? parseFloat(M[6]) * 1e3 : 0));
    else return new Date(Date.UTC(1899, 11, 31, +M[1] % 12 + (M[7] == "p" ? 12 : 0), +M[2], 0, 0));
  }
  function fuzzytime2(M) {
    if (!M[2]) return new Date(Date.UTC(1899, 11, 31, +M[1], 0, 0, 0));
    if (M[3]) {
      if (M[4]) return new Date(Date.UTC(1899, 11, 31, +M[1], +M[2], +M[4], parseFloat(M[3]) * 1e3));
      else return new Date(Date.UTC(1899, 11, 31, 0, +M[1], +M[2], parseFloat(M[3]) * 1e3));
    } else if (M[5]) return new Date(Date.UTC(1899, 11, 31, +M[1], +M[2], +M[5], M[6] ? parseFloat(M[6]) * 1e3 : 0));
    else return new Date(Date.UTC(1899, 11, 31, +M[1], +M[2], 0, 0));
  }
  var lower_months = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
  function fuzzydate(s) {
    if (FDISO.test(s)) return s.indexOf("Z") == -1 ? local_to_utc(new Date(s)) : new Date(s);
    var lower = s.toLowerCase();
    var lnos = lower.replace(/\s+/g, " ").trim();
    var M = lnos.match(FDRE1);
    if (M) return fuzzytime1(M);
    M = lnos.match(FDRE2);
    if (M) return fuzzytime2(M);
    M = lnos.match(pdre3);
    if (M) return new Date(Date.UTC(+M[1], +M[2] - 1, +M[3], +M[4], +M[5], M[6] && parseInt(M[6].slice(1), 10) || 0, M[7] && parseInt((M[7] + "0000").slice(1, 4), 10) || 0));
    var o = new Date(utc_append_works && s.indexOf("UTC") == -1 ? s + " UTC" : s), n = new Date(NaN);
    var y = o.getYear();
    o.getMonth();
    var d = o.getDate();
    if (isNaN(d)) return n;
    if (lower.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
      lower = lower.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, "");
      if (lower.length > 3 && lower_months.indexOf(lower) == -1) return n;
    } else if (lower.replace(/[ap]m?/, "").match(/[a-z]/)) return n;
    if (y < 0 || y > 8099 || s.match(/[^-0-9:,\/\\\ ]/)) return n;
    return o;
  }
  var split_regex = (function() {
    var safe_split_regex = "abacaba".split(/(:?b)/i).length == 5;
    return function split_regex2(str, re, def2) {
      if (safe_split_regex || typeof re == "string") return str.split(re);
      var p2 = str.split(re), o = [p2[0]];
      for (var i = 1; i < p2.length; ++i) {
        o.push(def2);
        o.push(p2[i]);
      }
      return o;
    };
  })();
  function utc_to_local(utc) {
    return new Date(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate(), utc.getUTCHours(), utc.getUTCMinutes(), utc.getUTCSeconds(), utc.getUTCMilliseconds());
  }
  function local_to_utc(local) {
    return new Date(Date.UTC(local.getFullYear(), local.getMonth(), local.getDate(), local.getHours(), local.getMinutes(), local.getSeconds(), local.getMilliseconds()));
  }
  function remove_doctype(str) {
    var preamble = str.slice(0, 1024);
    var si = preamble.indexOf("<!DOCTYPE");
    if (si == -1) return str;
    var m = str.match(/<[\w]/);
    if (!m) return str;
    return str.slice(0, si) + str.slice(m.index);
  }
  function str_match_ng(str, s, e) {
    var out = [];
    var si = str.indexOf(s);
    while (si > -1) {
      var ei = str.indexOf(e, si + s.length);
      if (ei == -1) break;
      out.push(str.slice(si, ei + e.length));
      si = str.indexOf(s, ei + e.length);
    }
    return out.length > 0 ? out : null;
  }
  function str_remove_ng(str, s, e) {
    var out = [], last = 0;
    var si = str.indexOf(s);
    if (si == -1) return str;
    while (si > -1) {
      out.push(str.slice(last, si));
      var ei = str.indexOf(e, si + s.length);
      if (ei == -1) break;
      if ((si = str.indexOf(s, last = ei + e.length)) == -1) out.push(str.slice(last));
    }
    return out.join("");
  }
  var xml_boundary = { " ": 1, "	": 1, "\r": 1, "\n": 1, ">": 1 };
  function str_match_xml(str, tag) {
    var si = str.indexOf("<" + tag), w = tag.length + 1, L = str.length;
    while (si >= 0 && si <= L - w && !xml_boundary[str.charAt(si + w)]) si = str.indexOf("<" + tag, si + 1);
    if (si === -1) return null;
    var sf = str.indexOf(">", si + tag.length);
    if (sf === -1) return null;
    var et = "</" + tag + ">";
    var ei = str.indexOf(et, sf);
    if (ei == -1) return null;
    return [str.slice(si, ei + et.length), str.slice(sf + 1, ei)];
  }
  var str_match_xml_ns = (function() {
    var str_match_xml_ns_cache = {};
    return function str_match_xml_ns2(str, tag) {
      var res = str_match_xml_ns_cache[tag];
      if (!res) str_match_xml_ns_cache[tag] = res = [
        new RegExp("<(?:\\w+:)?" + tag + "\\b[^<>]*>", "g"),
        new RegExp("</(?:\\w+:)?" + tag + ">", "g")
      ];
      res[0].lastIndex = res[1].lastIndex = 0;
      var m = res[0].exec(str);
      if (!m) return null;
      var si = m.index;
      var sf = res[0].lastIndex;
      res[1].lastIndex = res[0].lastIndex;
      m = res[1].exec(str);
      if (!m) return null;
      var ei = m.index;
      var ef = res[1].lastIndex;
      return [str.slice(si, ef), str.slice(sf, ei)];
    };
  })();
  var str_match_xml_ns_g = (function() {
    var str_match_xml_ns_cache = {};
    return function str_match_xml_ns2(str, tag) {
      var out = [];
      var res = str_match_xml_ns_cache[tag];
      if (!res) str_match_xml_ns_cache[tag] = res = [
        new RegExp("<(?:\\w+:)?" + tag + "\\b[^<>]*>", "g"),
        new RegExp("</(?:\\w+:)?" + tag + ">", "g")
      ];
      res[0].lastIndex = res[1].lastIndex = 0;
      var m;
      while (m = res[0].exec(str)) {
        var si = m.index;
        res[1].lastIndex = res[0].lastIndex;
        m = res[1].exec(str);
        if (!m) return null;
        var ef = res[1].lastIndex;
        out.push(str.slice(si, ef));
        res[0].lastIndex = res[1].lastIndex;
      }
      return out.length == 0 ? null : out;
    };
  })();
  var str_remove_xml_ns_g = (function() {
    var str_remove_xml_ns_cache = {};
    return function str_remove_xml_ns_g2(str, tag) {
      var out = [];
      var res = str_remove_xml_ns_cache[tag];
      if (!res) str_remove_xml_ns_cache[tag] = res = [
        new RegExp("<(?:\\w+:)?" + tag + "\\b[^<>]*>", "g"),
        new RegExp("</(?:\\w+:)?" + tag + ">", "g")
      ];
      res[0].lastIndex = res[1].lastIndex = 0;
      var m;
      var si = 0, ef = 0;
      while (m = res[0].exec(str)) {
        si = m.index;
        out.push(str.slice(ef, si));
        ef = si;
        res[1].lastIndex = res[0].lastIndex;
        m = res[1].exec(str);
        if (!m) return null;
        ef = res[1].lastIndex;
        res[0].lastIndex = res[1].lastIndex;
      }
      out.push(str.slice(ef));
      return out.length == 0 ? "" : out.join("");
    };
  })();
  var str_match_xml_ig = (function() {
    var str_match_xml_ns_cache = {};
    return function str_match_xml_ns2(str, tag) {
      var out = [];
      var res = str_match_xml_ns_cache[tag];
      if (!res) str_match_xml_ns_cache[tag] = res = [
        new RegExp("<" + tag + "\\b[^<>]*>", "ig"),
        new RegExp("</" + tag + ">", "ig")
      ];
      res[0].lastIndex = res[1].lastIndex = 0;
      var m;
      while (m = res[0].exec(str)) {
        var si = m.index;
        res[1].lastIndex = res[0].lastIndex;
        m = res[1].exec(str);
        if (!m) return null;
        var ef = res[1].lastIndex;
        out.push(str.slice(si, ef));
        res[0].lastIndex = res[1].lastIndex;
      }
      return out.length == 0 ? null : out;
    };
  })();
  function getdatastr(data) {
    if (!data) return null;
    if (data.content && data.type) return cc2str(data.content, true);
    if (data.data) return debom(data.data);
    if (data.asNodeBuffer && has_buf) return debom(data.asNodeBuffer().toString("binary"));
    if (data.asBinary) return debom(data.asBinary());
    if (data._data && data._data.getContent) return debom(cc2str(Array.prototype.slice.call(data._data.getContent(), 0)));
    return null;
  }
  function getdatabin(data) {
    if (!data) return null;
    if (data.data) return char_codes(data.data);
    if (data.asNodeBuffer && has_buf) return data.asNodeBuffer();
    if (data._data && data._data.getContent) {
      var o = data._data.getContent();
      if (typeof o == "string") return char_codes(o);
      return Array.prototype.slice.call(o);
    }
    if (data.content && data.type) return data.content;
    return null;
  }
  function getdata(data) {
    return data && data.name.slice(-4) === ".bin" ? getdatabin(data) : getdatastr(data);
  }
  function safegetzipfile(zip, file) {
    var k = zip.FullPaths || keys(zip.files);
    var f = file.toLowerCase().replace(/[\/]/g, "\\"), g = f.replace(/\\/g, "/");
    for (var i = 0; i < k.length; ++i) {
      var n = k[i].replace(/^Root Entry[\/]/, "").toLowerCase();
      if (f == n || g == n) return zip.files ? zip.files[k[i]] : zip.FileIndex[i];
    }
    return null;
  }
  function getzipfile(zip, file) {
    var o = safegetzipfile(zip, file);
    if (o == null) throw new Error("Cannot find file " + file + " in zip");
    return o;
  }
  function getzipdata(zip, file, safe) {
    if (!safe) return getdata(getzipfile(zip, file));
    if (!file) return null;
    try {
      return getzipdata(zip, file);
    } catch (e) {
      return null;
    }
  }
  function getzipstr(zip, file, safe) {
    if (!safe) return getdatastr(getzipfile(zip, file));
    if (!file) return null;
    try {
      return getzipstr(zip, file);
    } catch (e) {
      return null;
    }
  }
  function getzipbin(zip, file, safe) {
    return getdatabin(getzipfile(zip, file));
  }
  function zipentries(zip) {
    var k = zip.FullPaths || keys(zip.files), o = [];
    for (var i = 0; i < k.length; ++i) if (k[i].slice(-1) != "/") o.push(k[i].replace(/^Root Entry[\/]/, ""));
    return o.sort();
  }
  function zip_add_file(zip, path, content) {
    if (zip.FullPaths) {
      if (Array.isArray(content) && typeof content[0] == "string") {
        content = content.join("");
      }
      if (typeof content == "string") {
        var res;
        if (has_buf) res = Buffer_from(content);
        else res = utf8decode(content);
        return CFB.utils.cfb_add(zip, path, res);
      }
      CFB.utils.cfb_add(zip, path, content);
    } else zip.file(path, content);
  }
  function zip_new() {
    return CFB.utils.cfb_new();
  }
  function zip_read(d, o) {
    switch (o.type) {
      case "base64":
        return CFB.read(d, { type: "base64" });
      case "binary":
        return CFB.read(d, { type: "binary" });
      case "buffer":
      case "array":
        return CFB.read(d, { type: "buffer" });
    }
    throw new Error("Unrecognized type " + o.type);
  }
  function resolve_path(path, base) {
    if (path.charAt(0) == "/") return path.slice(1);
    var result = base.split("/");
    if (base.slice(-1) != "/") result.pop();
    var target = path.split("/");
    while (target.length !== 0) {
      var step = target.shift();
      if (step === "..") result.pop();
      else if (step !== ".") result.push(step);
    }
    return result.join("/");
  }
  var XML_HEADER = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n';
  var attregexg = /\s([^"\s?>\/]+)\s*=\s*((?:")([^"]*)(?:")|(?:')([^']*)(?:')|([^'">\s]+))/g;
  var tagregex1 = /<[\/\?]?[a-zA-Z0-9:_-]+(?:\s+[^"\s?<>\/]+\s*=\s*(?:"[^"]*"|'[^']*'|[^'"<>\s=]+))*\s*[\/\?]?>/mg, tagregex2 = /<[^<>]*>/g;
  var tagregex = XML_HEADER.match(tagregex1) ? tagregex1 : tagregex2;
  var nsregex = /<\w*:/, nsregex2 = /<(\/?)\w+:/;
  function parsexmltag(tag, skip_root, skip_LC) {
    var z = {};
    var eq = 0, c = 0;
    for (; eq !== tag.length; ++eq) if ((c = tag.charCodeAt(eq)) === 32 || c === 10 || c === 13) break;
    if (!skip_root) z[0] = tag.slice(0, eq);
    if (eq === tag.length) return z;
    var m = tag.match(attregexg), j = 0, v = "", i = 0, q = "", cc = "", quot = 1;
    if (m) for (i = 0; i != m.length; ++i) {
      cc = m[i].slice(1);
      for (c = 0; c != cc.length; ++c) if (cc.charCodeAt(c) === 61) break;
      q = cc.slice(0, c).trim();
      while (cc.charCodeAt(c + 1) == 32) ++c;
      quot = (eq = cc.charCodeAt(c + 1)) == 34 || eq == 39 ? 1 : 0;
      v = cc.slice(c + 1 + quot, cc.length - quot);
      for (j = 0; j != q.length; ++j) if (q.charCodeAt(j) === 58) break;
      if (j === q.length) {
        if (q.indexOf("_") > 0) q = q.slice(0, q.indexOf("_"));
        z[q] = v;
        z[q.toLowerCase()] = v;
      } else {
        var k = (j === 5 && q.slice(0, 5) === "xmlns" ? "xmlns" : "") + q.slice(j + 1);
        if (z[k] && q.slice(j - 3, j) == "ext") continue;
        z[k] = v;
        z[k.toLowerCase()] = v;
      }
    }
    return z;
  }
  function parsexmltagraw(tag, skip_root, skip_LC) {
    var z = {};
    var eq = 0, c = 0;
    for (; eq !== tag.length; ++eq) if ((c = tag.charCodeAt(eq)) === 32 || c === 10 || c === 13) break;
    if (eq === tag.length) return z;
    var m = tag.match(attregexg), v = "", i = 0, q = "", cc = "", quot = 1;
    if (m) for (i = 0; i != m.length; ++i) {
      cc = m[i].slice(1);
      for (c = 0; c != cc.length; ++c) if (cc.charCodeAt(c) === 61) break;
      q = cc.slice(0, c).trim();
      while (cc.charCodeAt(c + 1) == 32) ++c;
      quot = (eq = cc.charCodeAt(c + 1)) == 34 || eq == 39 ? 1 : 0;
      v = cc.slice(c + 1 + quot, cc.length - quot);
      if (q.indexOf("_") > 0) q = q.slice(0, q.indexOf("_"));
      z[q] = v;
      z[q.toLowerCase()] = v;
    }
    return z;
  }
  function strip_ns(x) {
    return x.replace(nsregex2, "<$1");
  }
  var encodings = {
    "&quot;": '"',
    "&apos;": "'",
    "&gt;": ">",
    "&lt;": "<",
    "&amp;": "&"
  };
  var rencoding = evert(encodings);
  var unescapexml = (function() {
    var encregex = /&(?:quot|apos|gt|lt|amp|#x?([\da-fA-F]+));/ig, coderegex = /_x([\da-fA-F]{4})_/ig;
    function raw_unescapexml(text) {
      var s = text + "", i = s.indexOf("<![CDATA[");
      if (i == -1) return s.replace(encregex, function($$, $1) {
        return encodings[$$] || String.fromCharCode(parseInt($1, $$.indexOf("x") > -1 ? 16 : 10)) || $$;
      }).replace(coderegex, function(m, c) {
        return String.fromCharCode(parseInt(c, 16));
      });
      var j = s.indexOf("]]>");
      return raw_unescapexml(s.slice(0, i)) + s.slice(i + 9, j) + raw_unescapexml(s.slice(j + 3));
    }
    return function unescapexml2(text, xlsx) {
      var out = raw_unescapexml(text);
      return xlsx ? out.replace(/\r\n/g, "\n") : out;
    };
  })();
  var decregex = /[&<>'"]/g, charegex = /[\u0000-\u0008\u000b-\u001f\uFFFE-\uFFFF]/g;
  function escapexml(text) {
    var s = text + "";
    return s.replace(decregex, function(y) {
      return rencoding[y];
    }).replace(charegex, function(s2) {
      return "_x" + ("000" + s2.charCodeAt(0).toString(16)).slice(-4) + "_";
    });
  }
  function escapexmltag(text) {
    return escapexml(text).replace(/ /g, "_x0020_");
  }
  var htmlcharegex = /[\u0000-\u001f]/g;
  function escapehtml(text) {
    var s = text + "";
    return s.replace(decregex, function(y) {
      return rencoding[y];
    }).replace(/\n/g, "<br/>").replace(htmlcharegex, function(s2) {
      return "&#x" + ("000" + s2.charCodeAt(0).toString(16)).slice(-4) + ";";
    });
  }
  function escapexlml(text) {
    var s = text + "";
    return s.replace(decregex, function(y) {
      return rencoding[y];
    }).replace(htmlcharegex, function(s2) {
      return "&#x" + s2.charCodeAt(0).toString(16).toUpperCase() + ";";
    });
  }
  var xlml_fixstr = (function() {
    var entregex = /&#(\d+);/g;
    function entrepl($$, $1) {
      return String.fromCharCode(parseInt($1, 10));
    }
    return function xlml_fixstr2(str) {
      return str.replace(entregex, entrepl);
    };
  })();
  function xlml_unfixstr(str) {
    return str.replace(/(\r\n|[\r\n])/g, "&#10;");
  }
  function parsexmlbool(value) {
    switch (value) {
      case 1:
      case true:
      case "1":
      case "true":
        return true;
      case 0:
      case false:
      case "0":
      case "false":
        return false;
    }
    return false;
  }
  function utf8reada(orig) {
    var out = "", i = 0, c = 0, d = 0, e = 0, f = 0, w = 0;
    while (i < orig.length) {
      c = orig.charCodeAt(i++);
      if (c < 128) {
        out += String.fromCharCode(c);
        continue;
      }
      d = orig.charCodeAt(i++);
      if (c > 191 && c < 224) {
        f = (c & 31) << 6;
        f |= d & 63;
        out += String.fromCharCode(f);
        continue;
      }
      e = orig.charCodeAt(i++);
      if (c < 240) {
        out += String.fromCharCode((c & 15) << 12 | (d & 63) << 6 | e & 63);
        continue;
      }
      f = orig.charCodeAt(i++);
      w = ((c & 7) << 18 | (d & 63) << 12 | (e & 63) << 6 | f & 63) - 65536;
      out += String.fromCharCode(55296 + (w >>> 10 & 1023));
      out += String.fromCharCode(56320 + (w & 1023));
    }
    return out;
  }
  function utf8readb(data) {
    var out = new_raw_buf(2 * data.length), w, i, j = 1, k = 0, ww = 0, c;
    for (i = 0; i < data.length; i += j) {
      j = 1;
      if ((c = data.charCodeAt(i)) < 128) w = c;
      else if (c < 224) {
        w = (c & 31) * 64 + (data.charCodeAt(i + 1) & 63);
        j = 2;
      } else if (c < 240) {
        w = (c & 15) * 4096 + (data.charCodeAt(i + 1) & 63) * 64 + (data.charCodeAt(i + 2) & 63);
        j = 3;
      } else {
        j = 4;
        w = (c & 7) * 262144 + (data.charCodeAt(i + 1) & 63) * 4096 + (data.charCodeAt(i + 2) & 63) * 64 + (data.charCodeAt(i + 3) & 63);
        w -= 65536;
        ww = 55296 + (w >>> 10 & 1023);
        w = 56320 + (w & 1023);
      }
      if (ww !== 0) {
        out[k++] = ww & 255;
        out[k++] = ww >>> 8;
        ww = 0;
      }
      out[k++] = w % 256;
      out[k++] = w >>> 8;
    }
    return out.slice(0, k).toString("ucs2");
  }
  function utf8readc(data) {
    return Buffer_from(data, "binary").toString("utf8");
  }
  var utf8corpus = "foo bar bazâð£";
  var utf8read = has_buf && ( utf8readc(utf8corpus) == utf8reada(utf8corpus) && utf8readc || utf8readb(utf8corpus) == utf8reada(utf8corpus) && utf8readb) || utf8reada;
  var utf8write = has_buf ? function(data) {
    return Buffer_from(data, "utf8").toString("binary");
  } : function(orig) {
    var out = [], i = 0, c = 0, d = 0;
    while (i < orig.length) {
      c = orig.charCodeAt(i++);
      switch (true) {
        case c < 128:
          out.push(String.fromCharCode(c));
          break;
        case c < 2048:
          out.push(String.fromCharCode(192 + (c >> 6)));
          out.push(String.fromCharCode(128 + (c & 63)));
          break;
        case (c >= 55296 && c < 57344):
          c -= 55296;
          d = orig.charCodeAt(i++) - 56320 + (c << 10);
          out.push(String.fromCharCode(240 + (d >> 18 & 7)));
          out.push(String.fromCharCode(144 + (d >> 12 & 63)));
          out.push(String.fromCharCode(128 + (d >> 6 & 63)));
          out.push(String.fromCharCode(128 + (d & 63)));
          break;
        default:
          out.push(String.fromCharCode(224 + (c >> 12)));
          out.push(String.fromCharCode(128 + (c >> 6 & 63)));
          out.push(String.fromCharCode(128 + (c & 63)));
      }
    }
    return out.join("");
  };
  var htmldecode = (function() {
    var entities = [
      ["nbsp", " "],
      ["middot", "·"],
      ["quot", '"'],
      ["apos", "'"],
      ["gt", ">"],
      ["lt", "<"],
      ["amp", "&"]
    ].map(function(x) {
      return [new RegExp("&" + x[0] + ";", "ig"), x[1]];
    });
    return function htmldecode2(str) {
      var o = str.replace(/^[\t\n\r ]+/, "").replace(/(^|[^\t\n\r ])[\t\n\r ]+$/, "$1").replace(/>\s+/g, ">").replace(/\b\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, "\n").replace(/<[^<>]*>/g, "");
      for (var i = 0; i < entities.length; ++i) o = o.replace(entities[i][0], entities[i][1]);
      return o;
    };
  })();
  var vtvregex = /<\/?(?:vt:)?variant>/g, vtmregex = /<(?:vt:)([^<"'>]*)>([\s\S]*)</;
  function parseVector(data, opts) {
    var h2 = parsexmltag(data);
    var matches = str_match_xml_ns_g(data, h2.baseType) || [];
    var res = [];
    if (matches.length != h2.size) {
      if (opts.WTF) throw new Error("unexpected vector length " + matches.length + " != " + h2.size);
      return res;
    }
    matches.forEach(function(x) {
      var v = x.replace(vtvregex, "").match(vtmregex);
      if (v) res.push({ v: utf8read(v[2]), t: v[1] });
    });
    return res;
  }
  var wtregex = /(^\s|\s$|\n)/;
  function writetag(f, g) {
    return "<" + f + (g.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g + "</" + f + ">";
  }
  function wxt_helper(h2) {
    return keys(h2).map(function(k) {
      return " " + k + '="' + h2[k] + '"';
    }).join("");
  }
  function writextag(f, g, h2) {
    return "<" + f + (h2 != null ? wxt_helper(h2) : "") + (g != null ? (g.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g + "</" + f : "/") + ">";
  }
  function write_w3cdtf(d, t) {
    try {
      return d.toISOString().replace(/\.\d*/, "");
    } catch (e) {
      if (t) throw e;
    }
    return "";
  }
  function write_vt(s, xlsx) {
    switch (typeof s) {
      case "string":
        var o = writextag("vt:lpwstr", escapexml(s));
        o = o.replace(/&quot;/g, "_x0022_");
        return o;
      case "number":
        return writextag((s | 0) == s ? "vt:i4" : "vt:r8", escapexml(String(s)));
      case "boolean":
        return writextag("vt:bool", s ? "true" : "false");
    }
    if (s instanceof Date) return writextag("vt:filetime", write_w3cdtf(s));
    throw new Error("Unable to serialize " + s);
  }
  function xlml_normalize(d) {
    if (has_buf &&
Buffer.isBuffer(d)) return d.toString("utf8");
    if (typeof d === "string") return d;
    if (typeof Uint8Array !== "undefined" && d instanceof Uint8Array) return utf8read(a2s(ab2a(d)));
    throw new Error("Bad input format: expected Buffer or string");
  }
  var xlmlregex = /<([\/]?)([^\s?><!\/:"]*:|)([^\s?<>:\/"]+)(?:\s+[^<>=?"'\s]+="[^"]*?")*\s*[\/]?>/mg;
  var XMLNS = {
    CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
    CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
    EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
    CT: "http://schemas.openxmlformats.org/package/2006/content-types",
    RELS: "http://schemas.openxmlformats.org/package/2006/relationships",
    TCMNT: "http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments",
    "dc": "http://purl.org/dc/elements/1.1/",
    "dcterms": "http://purl.org/dc/terms/",
    "dcmitype": "http://purl.org/dc/dcmitype/",
    "r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
    "vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
    "xsi": "http://www.w3.org/2001/XMLSchema-instance",
    "xsd": "http://www.w3.org/2001/XMLSchema"
  };
  var XMLNS_main = [
    "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
    "http://purl.oclc.org/ooxml/spreadsheetml/main",
    "http://schemas.microsoft.com/office/excel/2006/main",
    "http://schemas.microsoft.com/office/excel/2006/2"
  ];
  var XLMLNS = {
    "o": "urn:schemas-microsoft-com:office:office",
    "x": "urn:schemas-microsoft-com:office:excel",
    "ss": "urn:schemas-microsoft-com:office:spreadsheet",
    "dt": "uuid:C2F41010-65B3-11d1-A29F-00AA00C14882",
    "mv": "http://macVmlSchemaUri",
    "v": "urn:schemas-microsoft-com:vml",
    "html": "http://www.w3.org/TR/REC-html40"
  };
  function read_double_le(b, idx) {
    var s = 1 - 2 * (b[idx + 7] >>> 7);
    var e = ((b[idx + 7] & 127) << 4) + (b[idx + 6] >>> 4 & 15);
    var m = b[idx + 6] & 15;
    for (var i = 5; i >= 0; --i) m = m * 256 + b[idx + i];
    if (e == 2047) return m == 0 ? s * Infinity : NaN;
    if (e == 0) e = -1022;
    else {
      e -= 1023;
      m += Math.pow(2, 52);
    }
    return s * Math.pow(2, e - 52) * m;
  }
  function write_double_le(b, v, idx) {
    var bs = (v < 0 || 1 / v == -Infinity ? 1 : 0) << 7, e = 0, m = 0;
    var av = bs ? -v : v;
    if (!isFinite(av)) {
      e = 2047;
      m = isNaN(v) ? 26985 : 0;
    } else if (av == 0) e = m = 0;
    else {
      e = Math.floor(Math.log(av) / Math.LN2);
      m = av * Math.pow(2, 52 - e);
      if (e <= -1023 && (!isFinite(m) || m < Math.pow(2, 52))) {
        e = -1022;
      } else {
        m -= Math.pow(2, 52);
        e += 1023;
      }
    }
    for (var i = 0; i <= 5; ++i, m /= 256) b[idx + i] = m & 255;
    b[idx + 6] = (e & 15) << 4 | m & 15;
    b[idx + 7] = e >> 4 | bs;
  }
  var ___toBuffer = function(bufs) {
    var x = [], w = 10240;
    for (var i = 0; i < bufs[0].length; ++i) if (bufs[0][i]) for (var j = 0, L = bufs[0][i].length; j < L; j += w) x.push.apply(x, bufs[0][i].slice(j, j + w));
    return x;
  };
  var __toBuffer = has_buf ? function(bufs) {
    return bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0]) ? Buffer.concat(bufs[0].map(function(x) {
      return Buffer.isBuffer(x) ? x : Buffer_from(x);
    })) : ___toBuffer(bufs);
  } : ___toBuffer;
  var ___utf16le = function(b, s, e) {
    var ss = [];
    for (var i = s; i < e; i += 2) ss.push(String.fromCharCode(__readUInt16LE(b, i)));
    return ss.join("").replace(chr0, "");
  };
  var __utf16le = has_buf ? function(b, s, e) {
    if (!Buffer.isBuffer(b) || !buf_utf16le) return ___utf16le(b, s, e);
    return b.toString("utf16le", s, e).replace(chr0, "");
  } : ___utf16le;
  var ___hexlify = function(b, s, l) {
    var ss = [];
    for (var i = s; i < s + l; ++i) ss.push(("0" + b[i].toString(16)).slice(-2));
    return ss.join("");
  };
  var __hexlify = has_buf ? function(b, s, l) {
    return Buffer.isBuffer(b) ? b.toString("hex", s, s + l) : ___hexlify(b, s, l);
  } : ___hexlify;
  var ___utf8 = function(b, s, e) {
    var ss = [];
    for (var i = s; i < e; i++) ss.push(String.fromCharCode(__readUInt8(b, i)));
    return ss.join("");
  };
  var __utf8 = has_buf ? function utf8_b(b, s, e) {
    return Buffer.isBuffer(b) ? b.toString("utf8", s, e) : ___utf8(b, s, e);
  } : ___utf8;
  var ___lpstr = function(b, i) {
    var len = __readUInt32LE(b, i);
    return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
  };
  var __lpstr = ___lpstr;
  var ___cpstr = function(b, i) {
    var len = __readUInt32LE(b, i);
    return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
  };
  var __cpstr = ___cpstr;
  var ___lpwstr = function(b, i) {
    var len = 2 * __readUInt32LE(b, i);
    return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
  };
  var __lpwstr = ___lpwstr;
  var ___lpp4 = function lpp4_(b, i) {
    var len = __readUInt32LE(b, i);
    return len > 0 ? __utf16le(b, i + 4, i + 4 + len) : "";
  };
  var __lpp4 = ___lpp4;
  var ___8lpp4 = function(b, i) {
    var len = __readUInt32LE(b, i);
    return len > 0 ? __utf8(b, i + 4, i + 4 + len) : "";
  };
  var __8lpp4 = ___8lpp4;
  var ___double = function(b, idx) {
    return read_double_le(b, idx);
  };
  var __double = ___double;
  var is_buf = function is_buf_a(a) {
    return Array.isArray(a) || typeof Uint8Array !== "undefined" && a instanceof Uint8Array;
  };
  if (has_buf) {
    __lpstr = function lpstr_b(b, i) {
      if (!Buffer.isBuffer(b)) return ___lpstr(b, i);
      var len = b.readUInt32LE(i);
      return len > 0 ? b.toString("utf8", i + 4, i + 4 + len - 1) : "";
    };
    __cpstr = function cpstr_b(b, i) {
      if (!Buffer.isBuffer(b)) return ___cpstr(b, i);
      var len = b.readUInt32LE(i);
      return len > 0 ? b.toString("utf8", i + 4, i + 4 + len - 1) : "";
    };
    __lpwstr = function lpwstr_b(b, i) {
      if (!Buffer.isBuffer(b) || !buf_utf16le) return ___lpwstr(b, i);
      var len = 2 * b.readUInt32LE(i);
      return b.toString("utf16le", i + 4, i + 4 + len - 1);
    };
    __lpp4 = function lpp4_b(b, i) {
      if (!Buffer.isBuffer(b) || !buf_utf16le) return ___lpp4(b, i);
      var len = b.readUInt32LE(i);
      return b.toString("utf16le", i + 4, i + 4 + len);
    };
    __8lpp4 = function lpp4_8b(b, i) {
      if (!Buffer.isBuffer(b)) return ___8lpp4(b, i);
      var len = b.readUInt32LE(i);
      return b.toString("utf8", i + 4, i + 4 + len);
    };
    __double = function double_(b, i) {
      if (Buffer.isBuffer(b)) return b.readDoubleLE(i);
      return ___double(b, i);
    };
    is_buf = function is_buf_b(a) {
      return Buffer.isBuffer(a) || Array.isArray(a) || typeof Uint8Array !== "undefined" && a instanceof Uint8Array;
    };
  }
  function cpdoit() {
    __utf16le = function(b, s, e) {
      return $cptable.utils.decode(1200, b.slice(s, e)).replace(chr0, "");
    };
    __utf8 = function(b, s, e) {
      return $cptable.utils.decode(65001, b.slice(s, e));
    };
    __lpstr = function(b, i) {
      var len = __readUInt32LE(b, i);
      return len > 0 ? $cptable.utils.decode(current_ansi, b.slice(i + 4, i + 4 + len - 1)) : "";
    };
    __cpstr = function(b, i) {
      var len = __readUInt32LE(b, i);
      return len > 0 ? $cptable.utils.decode(current_codepage, b.slice(i + 4, i + 4 + len - 1)) : "";
    };
    __lpwstr = function(b, i) {
      var len = 2 * __readUInt32LE(b, i);
      return len > 0 ? $cptable.utils.decode(1200, b.slice(i + 4, i + 4 + len - 1)) : "";
    };
    __lpp4 = function(b, i) {
      var len = __readUInt32LE(b, i);
      return len > 0 ? $cptable.utils.decode(1200, b.slice(i + 4, i + 4 + len)) : "";
    };
    __8lpp4 = function(b, i) {
      var len = __readUInt32LE(b, i);
      return len > 0 ? $cptable.utils.decode(65001, b.slice(i + 4, i + 4 + len)) : "";
    };
  }
  if (typeof $cptable !== "undefined") cpdoit();
  var __readUInt8 = function(b, idx) {
    return b[idx];
  };
  var __readUInt16LE = function(b, idx) {
    return b[idx + 1] * (1 << 8) + b[idx];
  };
  var __readInt16LE = function(b, idx) {
    var u = b[idx + 1] * (1 << 8) + b[idx];
    return u < 32768 ? u : (65535 - u + 1) * -1;
  };
  var __readUInt32LE = function(b, idx) {
    return b[idx + 3] * (1 << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];
  };
  var __readInt32LE = function(b, idx) {
    return b[idx + 3] << 24 | b[idx + 2] << 16 | b[idx + 1] << 8 | b[idx];
  };
  var __readInt32BE = function(b, idx) {
    return b[idx] << 24 | b[idx + 1] << 16 | b[idx + 2] << 8 | b[idx + 3];
  };
  function ReadShift(size, t) {
    var o = "", oI, oR, oo = [], w, vv, i, loc;
    switch (t) {
      case "dbcs":
        loc = this.l;
        if (has_buf && Buffer.isBuffer(this) && buf_utf16le) o = this.slice(this.l, this.l + 2 * size).toString("utf16le");
        else for (i = 0; i < size; ++i) {
          o += String.fromCharCode(__readUInt16LE(this, loc));
          loc += 2;
        }
        size *= 2;
        break;
      case "utf8":
        o = __utf8(this, this.l, this.l + size);
        break;
      case "utf16le":
        size *= 2;
        o = __utf16le(this, this.l, this.l + size);
        break;
      case "wstr":
        if (typeof $cptable !== "undefined") o = $cptable.utils.decode(current_codepage, this.slice(this.l, this.l + 2 * size));
        else return ReadShift.call(this, size, "dbcs");
        size = 2 * size;
        break;
case "lpstr-ansi":
        o = __lpstr(this, this.l);
        size = 4 + __readUInt32LE(this, this.l);
        break;
      case "lpstr-cp":
        o = __cpstr(this, this.l);
        size = 4 + __readUInt32LE(this, this.l);
        break;
case "lpwstr":
        o = __lpwstr(this, this.l);
        size = 4 + 2 * __readUInt32LE(this, this.l);
        break;
case "lpp4":
        size = 4 + __readUInt32LE(this, this.l);
        o = __lpp4(this, this.l);
        if (size & 2) size += 2;
        break;
case "8lpp4":
        size = 4 + __readUInt32LE(this, this.l);
        o = __8lpp4(this, this.l);
        if (size & 3) size += 4 - (size & 3);
        break;
      case "cstr":
        size = 0;
        o = "";
        while ((w = __readUInt8(this, this.l + size++)) !== 0) oo.push(_getchar(w));
        o = oo.join("");
        break;
      case "_wstr":
        size = 0;
        o = "";
        while ((w = __readUInt16LE(this, this.l + size)) !== 0) {
          oo.push(_getchar(w));
          size += 2;
        }
        size += 2;
        o = oo.join("");
        break;
case "dbcs-cont":
        o = "";
        loc = this.l;
        for (i = 0; i < size; ++i) {
          if (this.lens && this.lens.indexOf(loc) !== -1) {
            w = __readUInt8(this, loc);
            this.l = loc + 1;
            vv = ReadShift.call(this, size - i, w ? "dbcs-cont" : "sbcs-cont");
            return oo.join("") + vv;
          }
          oo.push(_getchar(__readUInt16LE(this, loc)));
          loc += 2;
        }
        o = oo.join("");
        size *= 2;
        break;
      case "cpstr":
        if (typeof $cptable !== "undefined") {
          o = $cptable.utils.decode(current_codepage, this.slice(this.l, this.l + size));
          break;
        }
case "sbcs-cont":
        o = "";
        loc = this.l;
        for (i = 0; i != size; ++i) {
          if (this.lens && this.lens.indexOf(loc) !== -1) {
            w = __readUInt8(this, loc);
            this.l = loc + 1;
            vv = ReadShift.call(this, size - i, w ? "dbcs-cont" : "sbcs-cont");
            return oo.join("") + vv;
          }
          oo.push(_getchar(__readUInt8(this, loc)));
          loc += 1;
        }
        o = oo.join("");
        break;
      default:
        switch (size) {
          case 1:
            oI = __readUInt8(this, this.l);
            this.l++;
            return oI;
          case 2:
            oI = (t === "i" ? __readInt16LE : __readUInt16LE)(this, this.l);
            this.l += 2;
            return oI;
          case 4:
          case -4:
            if (t === "i" || (this[this.l + 3] & 128) === 0) {
              oI = (size > 0 ? __readInt32LE : __readInt32BE)(this, this.l);
              this.l += 4;
              return oI;
            } else {
              oR = __readUInt32LE(this, this.l);
              this.l += 4;
            }
            return oR;
          case 8:
          case -8:
            if (t === "f") {
              if (size == 8) oR = __double(this, this.l);
              else oR = __double([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0);
              this.l += 8;
              return oR;
            } else size = 8;
case 16:
            o = __hexlify(this, this.l, size);
            break;
        }
    }
    this.l += size;
    return o;
  }
  var __writeUInt32LE = function(b, val2, idx) {
    b[idx] = val2 & 255;
    b[idx + 1] = val2 >>> 8 & 255;
    b[idx + 2] = val2 >>> 16 & 255;
    b[idx + 3] = val2 >>> 24 & 255;
  };
  var __writeInt32LE = function(b, val2, idx) {
    b[idx] = val2 & 255;
    b[idx + 1] = val2 >> 8 & 255;
    b[idx + 2] = val2 >> 16 & 255;
    b[idx + 3] = val2 >> 24 & 255;
  };
  var __writeUInt16LE = function(b, val2, idx) {
    b[idx] = val2 & 255;
    b[idx + 1] = val2 >>> 8 & 255;
  };
  function WriteShift(t, val2, f) {
    var size = 0, i = 0;
    if (f === "dbcs") {
      for (i = 0; i != val2.length; ++i) __writeUInt16LE(this, val2.charCodeAt(i), this.l + 2 * i);
      size = 2 * val2.length;
    } else if (f === "sbcs" || f == "cpstr") {
      if (typeof $cptable !== "undefined" && current_ansi == 874) {
        for (i = 0; i != val2.length; ++i) {
          var cpp = $cptable.utils.encode(current_ansi, val2.charAt(i));
          this[this.l + i] = cpp[0];
        }
        size = val2.length;
      } else if (typeof $cptable !== "undefined" && f == "cpstr") {
        cpp = $cptable.utils.encode(current_codepage, val2);
        if (cpp.length == val2.length) {
          for (i = 0; i < val2.length; ++i) if (cpp[i] == 0 && val2.charCodeAt(i) != 0) cpp[i] = 95;
        }
        if (cpp.length == 2 * val2.length) {
          for (i = 0; i < val2.length; ++i) if (cpp[2 * i] == 0 && cpp[2 * i + 1] == 0 && val2.charCodeAt(i) != 0) cpp[2 * i] = 95;
        }
        for (i = 0; i < cpp.length; ++i) this[this.l + i] = cpp[i];
        size = cpp.length;
      } else {
        val2 = val2.replace(/[^\x00-\x7F]/g, "_");
        for (i = 0; i != val2.length; ++i) this[this.l + i] = val2.charCodeAt(i) & 255;
        size = val2.length;
      }
    } else if (f === "hex") {
      for (; i < t; ++i) {
        this[this.l++] = parseInt(val2.slice(2 * i, 2 * i + 2), 16) || 0;
      }
      return this;
    } else if (f === "utf16le") {
      var end = Math.min(this.l + t, this.length);
      for (i = 0; i < Math.min(val2.length, t); ++i) {
        var cc = val2.charCodeAt(i);
        this[this.l++] = cc & 255;
        this[this.l++] = cc >> 8;
      }
      while (this.l < end) this[this.l++] = 0;
      return this;
    } else switch (t) {
      case 1:
        size = 1;
        this[this.l] = val2 & 255;
        break;
      case 2:
        size = 2;
        this[this.l] = val2 & 255;
        val2 >>>= 8;
        this[this.l + 1] = val2 & 255;
        break;
      case 3:
        size = 3;
        this[this.l] = val2 & 255;
        val2 >>>= 8;
        this[this.l + 1] = val2 & 255;
        val2 >>>= 8;
        this[this.l + 2] = val2 & 255;
        break;
      case 4:
        size = 4;
        __writeUInt32LE(this, val2, this.l);
        break;
      case 8:
        size = 8;
        if (f === "f") {
          write_double_le(this, val2, this.l);
          break;
        }
case 16:
        break;
      case -4:
        size = 4;
        __writeInt32LE(this, val2, this.l);
        break;
    }
    this.l += size;
    return this;
  }
  function CheckField(hexstr, fld) {
    var m = __hexlify(this, this.l, hexstr.length >> 1);
    if (m !== hexstr) throw new Error(fld + "Expected " + hexstr + " saw " + m);
    this.l += hexstr.length >> 1;
  }
  function prep_blob(blob, pos) {
    blob.l = pos;
    blob.read_shift =
ReadShift;
    blob.chk = CheckField;
    blob.write_shift = WriteShift;
  }
  function parsenoop(blob, length) {
    blob.l += length;
  }
  function new_buf(sz) {
    var o = new_raw_buf(sz);
    prep_blob(o, 0);
    return o;
  }
  function recordhopper(data, cb, opts) {
    if (!data) return;
    var tmpbyte, cntbyte, length;
    prep_blob(data, data.l || 0);
    var L = data.length, RT = 0, tgt = 0;
    while (data.l < L) {
      RT = data.read_shift(1);
      if (RT & 128) RT = (RT & 127) + ((data.read_shift(1) & 127) << 7);
      var R = XLSBRecordEnum[RT] || XLSBRecordEnum[65535];
      tmpbyte = data.read_shift(1);
      length = tmpbyte & 127;
      for (cntbyte = 1; cntbyte < 4 && tmpbyte & 128; ++cntbyte) length += ((tmpbyte = data.read_shift(1)) & 127) << 7 * cntbyte;
      tgt = data.l + length;
      var d = R.f && R.f(data, length, opts);
      data.l = tgt;
      if (cb(d, R, RT)) return;
    }
  }
  function buf_array() {
    var bufs = [], blksz = has_buf ? 16384 : 2048;
    has_buf && typeof new_buf(blksz).copy == "function";
    var newblk = function ba_newblk(sz) {
      var o = new_buf(sz);
      prep_blob(o, 0);
      return o;
    };
    var curbuf = newblk(blksz);
    var endbuf = function ba_endbuf() {
      if (!curbuf) return;
      if (curbuf.l) {
        if (curbuf.length > curbuf.l) {
          curbuf = curbuf.slice(0, curbuf.l);
          curbuf.l = curbuf.length;
        }
        if (curbuf.length > 0) bufs.push(curbuf);
      }
      curbuf = null;
    };
    var next = function ba_next(sz) {
      if (curbuf && sz < curbuf.length - curbuf.l) return curbuf;
      endbuf();
      return curbuf = newblk(Math.max(sz + 1, blksz));
    };
    var end = function ba_end() {
      endbuf();
      return bconcat(bufs);
    };
    var end2 = function() {
      endbuf();
      return bufs;
    };
    var push = function ba_push(buf) {
      endbuf();
      curbuf = buf;
      if (curbuf.l == null) curbuf.l = curbuf.length;
      next(blksz);
    };
    return { next, push, end, _bufs: bufs, end2 };
  }
  function write_record(ba, type, payload, length) {
    var t = +type, l;
    if (isNaN(t)) return;
    if (!length) length = XLSBRecordEnum[t].p || (payload || []).length || 0;
    l = 1 + (t >= 128 ? 1 : 0) + 1;
    if (length >= 128) ++l;
    if (length >= 16384) ++l;
    if (length >= 2097152) ++l;
    var o = ba.next(l);
    if (t <= 127) o.write_shift(1, t);
    else {
      o.write_shift(1, (t & 127) + 128);
      o.write_shift(1, t >> 7);
    }
    for (var i = 0; i != 4; ++i) {
      if (length >= 128) {
        o.write_shift(1, (length & 127) + 128);
        length >>= 7;
      } else {
        o.write_shift(1, length);
        break;
      }
    }
    if (
length > 0 && is_buf(payload)
    ) ba.push(payload);
  }
  function shift_cell_xls(cell, tgt, opts) {
    var out = dup(cell);
    if (tgt.s) {
      if (out.cRel) out.c += tgt.s.c;
      if (out.rRel) out.r += tgt.s.r;
    } else {
      if (out.cRel) out.c += tgt.c;
      if (out.rRel) out.r += tgt.r;
    }
    if (!opts || opts.biff < 12) {
      while (out.c >= 256) out.c -= 256;
      while (out.r >= 65536) out.r -= 65536;
    }
    return out;
  }
  function shift_range_xls(cell, range, opts) {
    var out = dup(cell);
    out.s = shift_cell_xls(out.s, range.s, opts);
    out.e = shift_cell_xls(out.e, range.s, opts);
    return out;
  }
  function encode_cell_xls(c, biff) {
    if (c.cRel && c.c < 0) {
      c = dup(c);
      while (c.c < 0) c.c += biff > 8 ? 16384 : 256;
    }
    if (c.rRel && c.r < 0) {
      c = dup(c);
      while (c.r < 0) c.r += biff > 8 ? 1048576 : biff > 5 ? 65536 : 16384;
    }
    var s = encode_cell(c);
    if (!c.cRel && c.cRel != null) s = fix_col(s);
    if (!c.rRel && c.rRel != null) s = fix_row(s);
    return s;
  }
  function encode_range_xls(r2, opts) {
    if (r2.s.r == 0 && !r2.s.rRel) {
      if (r2.e.r == (opts.biff >= 12 ? 1048575 : opts.biff >= 8 ? 65536 : 16384) && !r2.e.rRel) {
        return (r2.s.cRel ? "" : "$") + encode_col(r2.s.c) + ":" + (r2.e.cRel ? "" : "$") + encode_col(r2.e.c);
      }
    }
    if (r2.s.c == 0 && !r2.s.cRel) {
      if (r2.e.c == (opts.biff >= 12 ? 16383 : 255) && !r2.e.cRel) {
        return (r2.s.rRel ? "" : "$") + encode_row(r2.s.r) + ":" + (r2.e.rRel ? "" : "$") + encode_row(r2.e.r);
      }
    }
    return encode_cell_xls(r2.s, opts.biff) + ":" + encode_cell_xls(r2.e, opts.biff);
  }
  function decode_row(rowstr) {
    return parseInt(unfix_row(rowstr), 10) - 1;
  }
  function encode_row(row) {
    return "" + (row + 1);
  }
  function fix_row(cstr) {
    return cstr.replace(/([A-Z]|^)(\d+)$/, "$1$$$2");
  }
  function unfix_row(cstr) {
    return cstr.replace(/\$(\d+)$/, "$1");
  }
  function decode_col(colstr) {
    var c = unfix_col(colstr), d = 0, i = 0;
    for (; i !== c.length; ++i) d = 26 * d + c.charCodeAt(i) - 64;
    return d - 1;
  }
  function encode_col(col) {
    if (col < 0) throw new Error("invalid column " + col);
    var s = "";
    for (++col; col; col = Math.floor((col - 1) / 26)) s = String.fromCharCode((col - 1) % 26 + 65) + s;
    return s;
  }
  function fix_col(cstr) {
    return cstr.replace(/^([A-Z])/, "$$$1");
  }
  function unfix_col(cstr) {
    return cstr.replace(/^\$([A-Z])/, "$1");
  }
  function split_cell(cstr) {
    return cstr.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",");
  }
  function decode_cell(cstr) {
    var R = 0, C = 0;
    for (var i = 0; i < cstr.length; ++i) {
      var cc = cstr.charCodeAt(i);
      if (cc >= 48 && cc <= 57) R = 10 * R + (cc - 48);
      else if (cc >= 65 && cc <= 90) C = 26 * C + (cc - 64);
    }
    return { c: C - 1, r: R - 1 };
  }
  function encode_cell(cell) {
    var col = cell.c + 1;
    var s = "";
    for (; col; col = (col - 1) / 26 | 0) s = String.fromCharCode((col - 1) % 26 + 65) + s;
    return s + (cell.r + 1);
  }
  function decode_range(range) {
    var idx = range.indexOf(":");
    if (idx == -1) return { s: decode_cell(range), e: decode_cell(range) };
    return { s: decode_cell(range.slice(0, idx)), e: decode_cell(range.slice(idx + 1)) };
  }
  function encode_range(cs, ce) {
    if (typeof ce === "undefined" || typeof ce === "number") {
      return encode_range(cs.s, cs.e);
    }
    if (typeof cs !== "string") cs = encode_cell(cs);
    if (typeof ce !== "string") ce = encode_cell(ce);
    return cs == ce ? cs : cs + ":" + ce;
  }
  function fix_range(a1) {
    var s = decode_range(a1);
    return "$" + encode_col(s.s.c) + "$" + encode_row(s.s.r) + ":$" + encode_col(s.e.c) + "$" + encode_row(s.e.r);
  }
  function formula_quote_sheet_name(sname, opts) {
    if (!sname && !(opts && opts.biff <= 5 && opts.biff >= 2)) throw new Error("empty sheet name");
    if (/[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(sname)) return "'" + sname.replace(/'/g, "''") + "'";
    return sname;
  }
  function safe_decode_range(range) {
    var o = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    var idx = 0, i = 0, cc = 0;
    var len = range.length;
    for (idx = 0; i < len; ++i) {
      if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26) break;
      idx = 26 * idx + cc;
    }
    o.s.c = --idx;
    for (idx = 0; i < len; ++i) {
      if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9) break;
      idx = 10 * idx + cc;
    }
    o.s.r = --idx;
    if (i === len || cc != 10) {
      o.e.c = o.s.c;
      o.e.r = o.s.r;
      return o;
    }
    ++i;
    for (idx = 0; i != len; ++i) {
      if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26) break;
      idx = 26 * idx + cc;
    }
    o.e.c = --idx;
    for (idx = 0; i != len; ++i) {
      if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9) break;
      idx = 10 * idx + cc;
    }
    o.e.r = --idx;
    return o;
  }
  function safe_format_cell(cell, v) {
    var q = cell.t == "d" && v instanceof Date;
    if (cell.z != null) try {
      return cell.w = SSF_format(cell.z, q ? datenum(v) : v);
    } catch (e) {
    }
    try {
      return cell.w = SSF_format((cell.XF || {}).numFmtId || (q ? 14 : 0), q ? datenum(v) : v);
    } catch (e) {
      return "" + v;
    }
  }
  function format_cell(cell, v, o) {
    if (cell == null || cell.t == null || cell.t == "z") return "";
    if (cell.w !== void 0) return cell.w;
    if (cell.t == "d" && !cell.z && o && o.dateNF) cell.z = o.dateNF;
    if (cell.t == "e") return BErr[cell.v] || cell.v;
    if (v == void 0) return safe_format_cell(cell, cell.v);
    return safe_format_cell(cell, v);
  }
  function sheet_to_workbook(sheet, opts) {
    var n = opts && opts.sheet ? opts.sheet : "Sheet1";
    var sheets = {};
    sheets[n] = sheet;
    return { SheetNames: [n], Sheets: sheets };
  }
  function sheet_new(opts) {
    var out = {};
    var o = opts || {};
    if (o.dense) out["!data"] = [];
    return out;
  }
  function sheet_add_aoa(_ws, data, opts) {
    var o = opts || {};
    var dense = _ws ? _ws["!data"] != null : o.dense;
    var ws = _ws || (dense ? { "!data": [] } : {});
    if (dense && !ws["!data"]) ws["!data"] = [];
    var _R = 0, _C = 0;
    if (ws && o.origin != null) {
      if (typeof o.origin == "number") _R = o.origin;
      else {
        var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;
        _R = _origin.r;
        _C = _origin.c;
      }
    }
    var range = { s: { c: 1e7, r: 1e7 }, e: { c: 0, r: 0 } };
    if (ws["!ref"]) {
      var _range = safe_decode_range(ws["!ref"]);
      range.s.c = _range.s.c;
      range.s.r = _range.s.r;
      range.e.c = Math.max(range.e.c, _range.e.c);
      range.e.r = Math.max(range.e.r, _range.e.r);
      if (_R == -1) range.e.r = _R = ws["!ref"] ? _range.e.r + 1 : 0;
    } else {
      range.s.c = range.e.c = range.s.r = range.e.r = 0;
    }
    var row = [], seen = false;
    for (var R = 0; R != data.length; ++R) {
      if (!data[R]) continue;
      if (!Array.isArray(data[R])) throw new Error("aoa_to_sheet expects an array of arrays");
      var __R = _R + R;
      if (dense) {
        if (!ws["!data"][__R]) ws["!data"][__R] = [];
        row = ws["!data"][__R];
      }
      var data_R = data[R];
      for (var C = 0; C != data_R.length; ++C) {
        if (typeof data_R[C] === "undefined") continue;
        var cell = { v: data_R[C], t: "" };
        var __C = _C + C;
        if (range.s.r > __R) range.s.r = __R;
        if (range.s.c > __C) range.s.c = __C;
        if (range.e.r < __R) range.e.r = __R;
        if (range.e.c < __C) range.e.c = __C;
        seen = true;
        if (data_R[C] && typeof data_R[C] === "object" && !Array.isArray(data_R[C]) && !(data_R[C] instanceof Date)) cell = data_R[C];
        else {
          if (Array.isArray(cell.v)) {
            cell.f = data_R[C][1];
            cell.v = cell.v[0];
          }
          if (cell.v === null) {
            if (cell.f) cell.t = "n";
            else if (o.nullError) {
              cell.t = "e";
              cell.v = 0;
            } else if (!o.sheetStubs) continue;
            else cell.t = "z";
          } else if (typeof cell.v === "number") {
            if (isFinite(cell.v)) cell.t = "n";
            else if (isNaN(cell.v)) {
              cell.t = "e";
              cell.v = 15;
            } else {
              cell.t = "e";
              cell.v = 7;
            }
          } else if (typeof cell.v === "boolean") cell.t = "b";
          else if (cell.v instanceof Date) {
            cell.z = o.dateNF || table_fmt[14];
            if (!o.UTC) cell.v = local_to_utc(cell.v);
            if (o.cellDates) {
              cell.t = "d";
              cell.w = SSF_format(cell.z, datenum(cell.v, o.date1904));
            } else {
              cell.t = "n";
              cell.v = datenum(cell.v, o.date1904);
              cell.w = SSF_format(cell.z, cell.v);
            }
          } else cell.t = "s";
        }
        if (dense) {
          if (row[__C] && row[__C].z) cell.z = row[__C].z;
          row[__C] = cell;
        } else {
          var cell_ref = encode_col(__C) + (__R + 1);
          if (ws[cell_ref] && ws[cell_ref].z) cell.z = ws[cell_ref].z;
          ws[cell_ref] = cell;
        }
      }
    }
    if (seen && range.s.c < 104e5) ws["!ref"] = encode_range(range);
    return ws;
  }
  function aoa_to_sheet(data, opts) {
    return sheet_add_aoa(null, data, opts);
  }
  function parse_Int32LE(data) {
    return data.read_shift(4, "i");
  }
  function write_UInt32LE(x, o) {
    if (!o) o = new_buf(4);
    o.write_shift(4, x);
    return o;
  }
  function parse_XLWideString(data) {
    var cchCharacters = data.read_shift(4);
    return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, "dbcs");
  }
  function write_XLWideString(data, o) {
    var _null = false;
    if (o == null) {
      _null = true;
      o = new_buf(4 + 2 * data.length);
    }
    o.write_shift(4, data.length);
    if (data.length > 0) o.write_shift(0, data, "dbcs");
    return _null ? o.slice(0, o.l) : o;
  }
  function parse_StrRun(data) {
    return { ich: data.read_shift(2), ifnt: data.read_shift(2) };
  }
  function write_StrRun(run, o) {
    if (!o) o = new_buf(4);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    return o;
  }
  function parse_RichStr(data, length) {
    var start = data.l;
    var flags = data.read_shift(1);
    var str = parse_XLWideString(data);
    var rgsStrRun = [];
    var z = { t: str, h: str };
    if ((flags & 1) !== 0) {
      var dwSizeStrRun = data.read_shift(4);
      for (var i = 0; i != dwSizeStrRun; ++i) rgsStrRun.push(parse_StrRun(data));
      z.r = rgsStrRun;
    } else z.r = [{ ich: 0, ifnt: 0 }];
    data.l = start + length;
    return z;
  }
  function write_RichStr(str, o) {
    var _null = false;
    if (o == null) {
      _null = true;
      o = new_buf(15 + 4 * str.t.length);
    }
    o.write_shift(1, 0);
    write_XLWideString(str.t, o);
    return _null ? o.slice(0, o.l) : o;
  }
  var parse_BrtCommentText = parse_RichStr;
  function write_BrtCommentText(str, o) {
    var _null = false;
    if (o == null) {
      _null = true;
      o = new_buf(23 + 4 * str.t.length);
    }
    o.write_shift(1, 1);
    write_XLWideString(str.t, o);
    o.write_shift(4, 1);
    write_StrRun({}, o);
    return _null ? o.slice(0, o.l) : o;
  }
  function parse_XLSBCell(data) {
    var col = data.read_shift(4);
    var iStyleRef = data.read_shift(2);
    iStyleRef += data.read_shift(1) << 16;
    data.l++;
    return { c: col, iStyleRef };
  }
  function write_XLSBCell(cell, o) {
    if (o == null) o = new_buf(8);
    o.write_shift(-4, cell.c);
    o.write_shift(3, cell.iStyleRef || cell.s);
    o.write_shift(1, 0);
    return o;
  }
  function parse_XLSBShortCell(data) {
    var iStyleRef = data.read_shift(2);
    iStyleRef += data.read_shift(1) << 16;
    data.l++;
    return { c: -1, iStyleRef };
  }
  function write_XLSBShortCell(cell, o) {
    if (o == null) o = new_buf(4);
    o.write_shift(3, cell.iStyleRef || cell.s);
    o.write_shift(1, 0);
    return o;
  }
  var parse_XLSBCodeName = parse_XLWideString;
  var write_XLSBCodeName = write_XLWideString;
  function parse_XLNullableWideString(data) {
    var cchCharacters = data.read_shift(4);
    return cchCharacters === 0 || cchCharacters === 4294967295 ? "" : data.read_shift(cchCharacters, "dbcs");
  }
  function write_XLNullableWideString(data, o) {
    var _null = false;
    if (o == null) {
      _null = true;
      o = new_buf(127);
    }
    o.write_shift(4, data.length > 0 ? data.length : 4294967295);
    if (data.length > 0) o.write_shift(0, data, "dbcs");
    return _null ? o.slice(0, o.l) : o;
  }
  var parse_XLNameWideString = parse_XLWideString;
  var parse_RelID = parse_XLNullableWideString;
  var write_RelID = write_XLNullableWideString;
  function parse_RkNumber(data) {
    var b = data.slice(data.l, data.l + 4);
    var fX100 = b[0] & 1, fInt = b[0] & 2;
    data.l += 4;
    var RK = fInt === 0 ? __double([0, 0, 0, 0, b[0] & 252, b[1], b[2], b[3]], 0) : __readInt32LE(b, 0) >> 2;
    return fX100 ? RK / 100 : RK;
  }
  function write_RkNumber(data, o) {
    if (o == null) o = new_buf(4);
    var fX100 = 0, fInt = 0, d100 = data * 100;
    if (data == (data | 0) && data >= -536870912 && data < 1 << 29) {
      fInt = 1;
    } else if (d100 == (d100 | 0) && d100 >= -536870912 && d100 < 1 << 29) {
      fInt = 1;
      fX100 = 1;
    }
    if (fInt) o.write_shift(-4, ((fX100 ? d100 : data) << 2) + (fX100 + 2));
    else throw new Error("unsupported RkNumber " + data);
  }
  function parse_RfX(data) {
    var cell = { s: {}, e: {} };
    cell.s.r = data.read_shift(4);
    cell.e.r = data.read_shift(4);
    cell.s.c = data.read_shift(4);
    cell.e.c = data.read_shift(4);
    return cell;
  }
  function write_RfX(r2, o) {
    if (!o) o = new_buf(16);
    o.write_shift(4, r2.s.r);
    o.write_shift(4, r2.e.r);
    o.write_shift(4, r2.s.c);
    o.write_shift(4, r2.e.c);
    return o;
  }
  var parse_UncheckedRfX = parse_RfX;
  var write_UncheckedRfX = write_RfX;
  function parse_Xnum(data) {
    if (data.length - data.l < 8) throw "XLS Xnum Buffer underflow";
    return data.read_shift(8, "f");
  }
  function write_Xnum(data, o) {
    return (o || new_buf(8)).write_shift(8, data, "f");
  }
  function parse_BrtColor(data) {
    var out = {};
    var d = data.read_shift(1);
    var xColorType = d >>> 1;
    var index = data.read_shift(1);
    var nTS = data.read_shift(2, "i");
    var bR = data.read_shift(1);
    var bG = data.read_shift(1);
    var bB = data.read_shift(1);
    data.l++;
    switch (xColorType) {
      case 0:
        out.auto = 1;
        break;
      case 1:
        out.index = index;
        var icv = XLSIcv[index];
        if (icv) out.rgb = rgb2Hex(icv);
        break;
      case 2:
        out.rgb = rgb2Hex([bR, bG, bB]);
        break;
      case 3:
        out.theme = index;
        break;
    }
    if (nTS != 0) out.tint = nTS > 0 ? nTS / 32767 : nTS / 32768;
    return out;
  }
  function write_BrtColor(color, o) {
    if (!o) o = new_buf(8);
    if (!color || color.auto) {
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      return o;
    }
    if (color.index != null) {
      o.write_shift(1, 2);
      o.write_shift(1, color.index);
    } else if (color.theme != null) {
      o.write_shift(1, 6);
      o.write_shift(1, color.theme);
    } else {
      o.write_shift(1, 5);
      o.write_shift(1, 0);
    }
    var nTS = color.tint || 0;
    if (nTS > 0) nTS *= 32767;
    else if (nTS < 0) nTS *= 32768;
    o.write_shift(2, nTS);
    if (!color.rgb || color.theme != null) {
      o.write_shift(2, 0);
      o.write_shift(1, 0);
      o.write_shift(1, 0);
    } else {
      var rgb = color.rgb || "FFFFFF";
      if (typeof rgb == "number") rgb = ("000000" + rgb.toString(16)).slice(-6);
      o.write_shift(1, parseInt(rgb.slice(0, 2), 16));
      o.write_shift(1, parseInt(rgb.slice(2, 4), 16));
      o.write_shift(1, parseInt(rgb.slice(4, 6), 16));
      o.write_shift(1, 255);
    }
    return o;
  }
  function parse_FontFlags(data) {
    var d = data.read_shift(1);
    data.l++;
    var out = {
      fBold: d & 1,
      fItalic: d & 2,
      fUnderline: d & 4,
      fStrikeout: d & 8,
      fOutline: d & 16,
      fShadow: d & 32,
      fCondense: d & 64,
      fExtend: d & 128
    };
    return out;
  }
  function write_FontFlags(font, o) {
    if (!o) o = new_buf(2);
    var grbit = (font.italic ? 2 : 0) | (font.strike ? 8 : 0) | (font.outline ? 16 : 0) | (font.shadow ? 32 : 0) | (font.condense ? 64 : 0) | (font.extend ? 128 : 0);
    o.write_shift(1, grbit);
    o.write_shift(1, 0);
    return o;
  }
  function parse_ClipboardFormatOrString(o, w) {
    var ClipFmt = { 2: "BITMAP", 3: "METAFILEPICT", 8: "DIB", 14: "ENHMETAFILE" };
    var m = o.read_shift(4);
    switch (m) {
      case 0:
        return "";
      case 4294967295:
      case 4294967294:
        return ClipFmt[o.read_shift(4)] || "";
    }
    if (m > 400) throw new Error("Unsupported Clipboard: " + m.toString(16));
    o.l -= 4;
    return o.read_shift(0, w == 1 ? "lpstr" : "lpwstr");
  }
  function parse_ClipboardFormatOrAnsiString(o) {
    return parse_ClipboardFormatOrString(o, 1);
  }
  function parse_ClipboardFormatOrUnicodeString(o) {
    return parse_ClipboardFormatOrString(o, 2);
  }
  var VT_I2 = 2;
  var VT_I4 = 3;
  var VT_BOOL = 11;
  var VT_VARIANT = 12;
  var VT_UI4 = 19;
  var VT_FILETIME = 64;
  var VT_BLOB = 65;
  var VT_CF = 71;
  var VT_VECTOR_VARIANT = 4108;
  var VT_VECTOR_LPSTR = 4126;
  var VT_STRING = 80;
  var VT_USTR = 81;
  var VT_CUSTOM = [VT_STRING, VT_USTR];
  var DocSummaryPIDDSI = {
    1: { n: "CodePage", t: VT_I2 },
    2: { n: "Category", t: VT_STRING },
    3: { n: "PresentationFormat", t: VT_STRING },
    4: { n: "ByteCount", t: VT_I4 },
    5: { n: "LineCount", t: VT_I4 },
    6: { n: "ParagraphCount", t: VT_I4 },
    7: { n: "SlideCount", t: VT_I4 },
    8: { n: "NoteCount", t: VT_I4 },
    9: { n: "HiddenCount", t: VT_I4 },
    10: { n: "MultimediaClipCount", t: VT_I4 },
    11: { n: "ScaleCrop", t: VT_BOOL },
    12: {
      n: "HeadingPairs",
      t: VT_VECTOR_VARIANT
},
    13: {
      n: "TitlesOfParts",
      t: VT_VECTOR_LPSTR
},
    14: { n: "Manager", t: VT_STRING },
    15: { n: "Company", t: VT_STRING },
    16: { n: "LinksUpToDate", t: VT_BOOL },
    17: { n: "CharacterCount", t: VT_I4 },
    19: { n: "SharedDoc", t: VT_BOOL },
    22: { n: "HyperlinksChanged", t: VT_BOOL },
    23: { n: "AppVersion", t: VT_I4, p: "version" },
    24: { n: "DigSig", t: VT_BLOB },
    26: { n: "ContentType", t: VT_STRING },
    27: { n: "ContentStatus", t: VT_STRING },
    28: { n: "Language", t: VT_STRING },
    29: { n: "Version", t: VT_STRING },
    255: {},
2147483648: { n: "Locale", t: VT_UI4 },
    2147483651: { n: "Behavior", t: VT_UI4 },
    1919054434: {}
  };
  var SummaryPIDSI = {
    1: { n: "CodePage", t: VT_I2 },
    2: { n: "Title", t: VT_STRING },
    3: { n: "Subject", t: VT_STRING },
    4: { n: "Author", t: VT_STRING },
    5: { n: "Keywords", t: VT_STRING },
    6: { n: "Comments", t: VT_STRING },
    7: { n: "Template", t: VT_STRING },
    8: { n: "LastAuthor", t: VT_STRING },
    9: { n: "RevNumber", t: VT_STRING },
    10: { n: "EditTime", t: VT_FILETIME },
    11: { n: "LastPrinted", t: VT_FILETIME },
    12: { n: "CreatedDate", t: VT_FILETIME },
    13: { n: "ModifiedDate", t: VT_FILETIME },
    14: { n: "PageCount", t: VT_I4 },
    15: { n: "WordCount", t: VT_I4 },
    16: { n: "CharCount", t: VT_I4 },
    17: { n: "Thumbnail", t: VT_CF },
    18: { n: "Application", t: VT_STRING },
    19: { n: "DocSecurity", t: VT_I4 },
    255: {},
2147483648: { n: "Locale", t: VT_UI4 },
    2147483651: { n: "Behavior", t: VT_UI4 },
    1919054434: {}
  };
  var CountryEnum = {
    1: "US",
2: "CA",
3: "",
7: "RU",
20: "EG",
30: "GR",
31: "NL",
32: "BE",
33: "FR",
34: "ES",
36: "HU",
39: "IT",
41: "CH",
43: "AT",
44: "GB",
45: "DK",
46: "SE",
47: "NO",
48: "PL",
49: "DE",
52: "MX",
55: "BR",
61: "AU",
64: "NZ",
66: "TH",
81: "JP",
82: "KR",
84: "VN",
86: "CN",
90: "TR",
105: "JS",
213: "DZ",
216: "MA",
218: "LY",
351: "PT",
354: "IS",
358: "FI",
420: "CZ",
886: "TW",
961: "LB",
962: "JO",
963: "SY",
964: "IQ",
965: "KW",
966: "SA",
971: "AE",
972: "IL",
974: "QA",
981: "IR",
65535: "US"
};
  var XLSFillPattern = [
    null,
    "solid",
    "mediumGray",
    "darkGray",
    "lightGray",
    "darkHorizontal",
    "darkVertical",
    "darkDown",
    "darkUp",
    "darkGrid",
    "darkTrellis",
    "lightHorizontal",
    "lightVertical",
    "lightDown",
    "lightUp",
    "lightGrid",
    "lightTrellis",
    "gray125",
    "gray0625"
  ];
  function rgbify(arr) {
    return arr.map(function(x) {
      return [x >> 16 & 255, x >> 8 & 255, x & 255];
    });
  }
  var _XLSIcv = rgbify([
0,
    16777215,
    16711680,
    65280,
    255,
    16776960,
    16711935,
    65535,
0,
    16777215,
    16711680,
    65280,
    255,
    16776960,
    16711935,
    65535,
    8388608,
    32768,
    128,
    8421376,
    8388736,
    32896,
    12632256,
    8421504,
    10066431,
    10040166,
    16777164,
    13434879,
    6684774,
    16744576,
    26316,
    13421823,
    128,
    16711935,
    16776960,
    65535,
    8388736,
    8388608,
    32896,
    255,
    52479,
    13434879,
    13434828,
    16777113,
    10079487,
    16751052,
    13408767,
    16764057,
    3368703,
    3394764,
    10079232,
    16763904,
    16750848,
    16737792,
    6710937,
    9868950,
    13158,
    3381606,
    13056,
    3355392,
    10040064,
    10040166,
    3355545,
    3355443,
0,
16777215,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0
]);
  var XLSIcv = dup(_XLSIcv);
  var BErr = {
    0: "#NULL!",
    7: "#DIV/0!",
    15: "#VALUE!",
    23: "#REF!",
    29: "#NAME?",
    36: "#NUM!",
    42: "#N/A",
    43: "#GETTING_DATA",
    255: "#WTF?"
  };
  var RBErr = {
    "#NULL!": 0,
    "#DIV/0!": 7,
    "#VALUE!": 15,
    "#REF!": 23,
    "#NAME?": 29,
    "#NUM!": 36,
    "#N/A": 42,
    "#GETTING_DATA": 43,
    "#WTF?": 255
  };
  var XLSLblBuiltIn = [
    "_xlnm.Consolidate_Area",
    "_xlnm.Auto_Open",
    "_xlnm.Auto_Close",
    "_xlnm.Extract",
    "_xlnm.Database",
    "_xlnm.Criteria",
    "_xlnm.Print_Area",
    "_xlnm.Print_Titles",
    "_xlnm.Recorder",
    "_xlnm.Data_Form",
    "_xlnm.Auto_Activate",
    "_xlnm.Auto_Deactivate",
    "_xlnm.Sheet_Title",
    "_xlnm._FilterDatabase"
  ];
  var ct2type = {
"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
    "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
    "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
    "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
    "application/vnd.ms-excel.worksheet": "sheets",
    "application/vnd.ms-excel.binIndexWs": "TODO",

"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
    "application/vnd.ms-excel.chartsheet": "charts",
"application/vnd.ms-excel.macrosheet+xml": "macros",
    "application/vnd.ms-excel.macrosheet": "macros",
    "application/vnd.ms-excel.intlmacrosheet": "TODO",
    "application/vnd.ms-excel.binIndexMs": "TODO",

"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
    "application/vnd.ms-excel.dialogsheet": "dialogs",
"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
    "application/vnd.ms-excel.sharedStrings": "strs",
"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
    "application/vnd.ms-excel.styles": "styles",
"application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
"application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
    "application/vnd.ms-excel.comments": "comments",
    "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
    "application/vnd.ms-excel.person+xml": "people",
"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
    "application/vnd.ms-excel.sheetMetadata": "metadata",
"application/vnd.ms-excel.pivotTable": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
"application/vnd.ms-office.chartcolorstyle+xml": "TODO",
"application/vnd.ms-office.chartstyle+xml": "TODO",
"application/vnd.ms-office.chartex+xml": "TODO",
"application/vnd.ms-excel.calcChain": "calcchains",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
"application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
"application/vnd.ms-office.activeX": "TODO",
    "application/vnd.ms-office.activeX+xml": "TODO",
"application/vnd.ms-excel.attachedToolbars": "TODO",
"application/vnd.ms-excel.connections": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
"application/vnd.ms-excel.externalLink": "links",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
"application/vnd.ms-excel.pivotCacheDefinition": "TODO",
    "application/vnd.ms-excel.pivotCacheRecords": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
"application/vnd.ms-excel.queryTable": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
"application/vnd.ms-excel.userNames": "TODO",
    "application/vnd.ms-excel.revisionHeaders": "TODO",
    "application/vnd.ms-excel.revisionLog": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
"application/vnd.ms-excel.tableSingleCells": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
"application/vnd.ms-excel.slicer": "TODO",
    "application/vnd.ms-excel.slicerCache": "TODO",
    "application/vnd.ms-excel.slicer+xml": "TODO",
    "application/vnd.ms-excel.slicerCache+xml": "TODO",
"application/vnd.ms-excel.wsSortMap": "TODO",
"application/vnd.ms-excel.table": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
"application/vnd.openxmlformats-officedocument.theme+xml": "themes",
"application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
"application/vnd.ms-excel.Timeline+xml": "TODO",
"application/vnd.ms-excel.TimelineCache+xml": "TODO",

"application/vnd.ms-office.vbaProject": "vba",
    "application/vnd.ms-office.vbaProjectSignature": "TODO",
"application/vnd.ms-office.volatileDependencies": "TODO",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
"application/vnd.ms-excel.controlproperties+xml": "TODO",
"application/vnd.openxmlformats-officedocument.model+data": "TODO",
"application/vnd.ms-excel.Survey+xml": "TODO",
"application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
    "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
"application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
    "application/vnd.openxmlformats-package.relationships+xml": "rels",
    "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
"image/png": "TODO",
    "sheet": "js"
  };
  var CT_LIST = {
    workbooks: {
      xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
      xlsm: "application/vnd.ms-excel.sheet.macroEnabled.main+xml",
      xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.main",
      xlam: "application/vnd.ms-excel.addin.macroEnabled.main+xml",
      xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"
    },
    strs: {
xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
      xlsb: "application/vnd.ms-excel.sharedStrings"
    },
    comments: {
xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",
      xlsb: "application/vnd.ms-excel.comments"
    },
    sheets: {
xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
      xlsb: "application/vnd.ms-excel.worksheet"
    },
    charts: {
xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",
      xlsb: "application/vnd.ms-excel.chartsheet"
    },
    dialogs: {
xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",
      xlsb: "application/vnd.ms-excel.dialogsheet"
    },
    macros: {
xlsx: "application/vnd.ms-excel.macrosheet+xml",
      xlsb: "application/vnd.ms-excel.macrosheet"
    },
    metadata: {
xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml",
      xlsb: "application/vnd.ms-excel.sheetMetadata"
    },
    styles: {
xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
      xlsb: "application/vnd.ms-excel.styles"
    }
  };
  function new_ct() {
    return {
      workbooks: [],
      sheets: [],
      charts: [],
      dialogs: [],
      macros: [],
      rels: [],
      strs: [],
      comments: [],
      threadedcomments: [],
      links: [],
      coreprops: [],
      extprops: [],
      custprops: [],
      themes: [],
      styles: [],
      calcchains: [],
      vba: [],
      drawings: [],
      metadata: [],
      people: [],
      TODO: [],
      xmlns: ""
    };
  }
  function parse_ct(data) {
    var ct = new_ct();
    if (!data || !data.match) return ct;
    var ctext = {};
    (data.match(tagregex) || []).forEach(function(x) {
      var y = parsexmltag(x);
      switch (y[0].replace(nsregex, "<")) {
        case "<?xml":
          break;
        case "<Types":
          ct.xmlns = y["xmlns" + (y[0].match(/<(\w+):/) || ["", ""])[1]];
          break;
        case "<Default":
          ctext[y.Extension.toLowerCase()] = y.ContentType;
          break;
        case "<Override":
          if (ct[ct2type[y.ContentType]] !== void 0) ct[ct2type[y.ContentType]].push(y.PartName);
          break;
      }
    });
    if (ct.xmlns !== XMLNS.CT) throw new Error("Unknown Namespace: " + ct.xmlns);
    ct.calcchain = ct.calcchains.length > 0 ? ct.calcchains[0] : "";
    ct.sst = ct.strs.length > 0 ? ct.strs[0] : "";
    ct.style = ct.styles.length > 0 ? ct.styles[0] : "";
    ct.defaults = ctext;
    delete ct.calcchains;
    return ct;
  }
  function write_ct(ct, opts, raw) {
    var type2ct = evert_arr(ct2type);
    var o = [], v;
    {
      o[o.length] = XML_HEADER;
      o[o.length] = writextag("Types", null, {
        "xmlns": XMLNS.CT,
        "xmlns:xsd": XMLNS.xsd,
        "xmlns:xsi": XMLNS.xsi
      });
      o = o.concat([
        ["xml", "application/xml"],
        ["bin", "application/vnd.ms-excel.sheet.binary.macroEnabled.main"],
        ["vml", "application/vnd.openxmlformats-officedocument.vmlDrawing"],
        ["data", "application/vnd.openxmlformats-officedocument.model+data"],
["bmp", "image/bmp"],
        ["png", "image/png"],
        ["gif", "image/gif"],
        ["emf", "image/x-emf"],
        ["wmf", "image/x-wmf"],
        ["jpg", "image/jpeg"],
        ["jpeg", "image/jpeg"],
        ["tif", "image/tiff"],
        ["tiff", "image/tiff"],
        ["pdf", "application/pdf"],
        ["rels", "application/vnd.openxmlformats-package.relationships+xml"]
      ].map(function(x) {
        return writextag("Default", null, { "Extension": x[0], "ContentType": x[1] });
      }));
    }
    var f1 = function(w) {
      if (ct[w] && ct[w].length > 0) {
        v = ct[w][0];
        o[o.length] = writextag("Override", null, {
          "PartName": (v[0] == "/" ? "" : "/") + v,
          "ContentType": CT_LIST[w][opts.bookType] || CT_LIST[w]["xlsx"]
        });
      }
    };
    var f2 = function(w) {
      (ct[w] || []).forEach(function(v2) {
        o[o.length] = writextag("Override", null, {
          "PartName": (v2[0] == "/" ? "" : "/") + v2,
          "ContentType": CT_LIST[w][opts.bookType] || CT_LIST[w]["xlsx"]
        });
      });
    };
    var f3 = function(t) {
      (ct[t] || []).forEach(function(v2) {
        o[o.length] = writextag("Override", null, {
          "PartName": (v2[0] == "/" ? "" : "/") + v2,
          "ContentType": type2ct[t][0]
        });
      });
    };
    f1("workbooks");
    f2("sheets");
    f2("charts");
    f3("themes");
    ["strs", "styles"].forEach(f1);
    ["coreprops", "extprops", "custprops"].forEach(f3);
    f3("vba");
    f3("comments");
    f3("threadedcomments");
    f3("drawings");
    f2("metadata");
    f3("people");
    if (o.length > 2) {
      o[o.length] = "</Types>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  var RELS = {
    WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
    SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
    HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
    VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
    XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
    XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
    XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",
    CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
    CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",
    CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
    CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
    EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
    CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
    SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
    STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
    THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
    CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
    CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",
    CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",
    WS: [
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
      "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"
    ],
    DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",
    MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",
    IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
    DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
    XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
    TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
    PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
    CONN: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/connections",
    VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
  };
  function get_rels_path(file) {
    var n = file.lastIndexOf("/");
    return file.slice(0, n + 1) + "_rels/" + file.slice(n + 1) + ".rels";
  }
  function parse_rels(data, currentFilePath) {
    var rels = { "!id": {} };
    if (!data) return rels;
    if (currentFilePath.charAt(0) !== "/") {
      currentFilePath = "/" + currentFilePath;
    }
    var hash = {};
    (data.match(tagregex) || []).forEach(function(x) {
      var y = parsexmltag(x);
      if (y[0] === "<Relationship") {
        var rel = {};
        rel.Type = y.Type;
        rel.Target = unescapexml(y.Target);
        rel.Id = y.Id;
        if (y.TargetMode) rel.TargetMode = y.TargetMode;
        var canonictarget = y.TargetMode === "External" ? y.Target : resolve_path(y.Target, currentFilePath);
        rels[canonictarget] = rel;
        hash[y.Id] = rel;
      }
    });
    rels["!id"] = hash;
    return rels;
  }
  function write_rels(rels) {
    var o = [XML_HEADER, writextag("Relationships", null, {
"xmlns": XMLNS.RELS
    })];
    keys(rels["!id"]).forEach(function(rid) {
      o[o.length] = writextag("Relationship", null, rels["!id"][rid]);
    });
    if (o.length > 2) {
      o[o.length] = "</Relationships>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  function add_rels(rels, rId, f, type, relobj, targetmode) {
    if (!relobj) relobj = {};
    if (!rels["!id"]) rels["!id"] = {};
    if (!rels["!idx"]) rels["!idx"] = 1;
    if (rId < 0) for (rId = rels["!idx"]; rels["!id"]["rId" + rId]; ++rId) {
    }
    rels["!idx"] = rId + 1;
    relobj.Id = "rId" + rId;
    relobj.Type = type;
    relobj.Target = f;
    if ([RELS.HLINK, RELS.XPATH, RELS.XMISS].indexOf(relobj.Type) > -1) relobj.TargetMode = "External";
    if (rels["!id"][relobj.Id]) throw new Error("Cannot rewrite rId " + rId);
    rels["!id"][relobj.Id] = relobj;
    rels[("/" + relobj.Target).replace("//", "/")] = relobj;
    return rId;
  }
  var CT_ODS = "application/vnd.oasis.opendocument.spreadsheet";
  function parse_manifest(d, opts) {
    var str = xlml_normalize(d);
    var Rn;
    var FEtag;
    while (Rn = xlmlregex.exec(str))
      switch (Rn[3]) {
        case "manifest":
          break;
        case "file-entry":
          FEtag = parsexmltag(Rn[0], false);
          if (FEtag.path == "/" && FEtag.type !== CT_ODS)
            throw new Error("This OpenDocument is not a spreadsheet");
          break;
        case "encryption-data":
        case "algorithm":
        case "start-key-generation":
        case "key-derivation":
          throw new Error("Unsupported ODS Encryption");
        default:
          if (opts && opts.WTF)
            throw Rn;
      }
  }
  function write_manifest(manifest) {
    var o = [XML_HEADER];
    o.push('<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">\n');
    o.push('  <manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/>\n');
    for (var i = 0; i < manifest.length; ++i)
      o.push('  <manifest:file-entry manifest:full-path="' + manifest[i][0] + '" manifest:media-type="' + manifest[i][1] + '"/>\n');
    o.push("</manifest:manifest>");
    return o.join("");
  }
  function write_rdf_type(file, res, tag) {
    return [
      '  <rdf:Description rdf:about="' + file + '">\n',
      '    <rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/' + (tag || "odf") + "#" + res + '"/>\n',
      "  </rdf:Description>\n"
    ].join("");
  }
  function write_rdf_has(base, file) {
    return [
      '  <rdf:Description rdf:about="' + base + '">\n',
      '    <ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="' + file + '"/>\n',
      "  </rdf:Description>\n"
    ].join("");
  }
  function write_rdf(rdf) {
    var o = [XML_HEADER];
    o.push('<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">\n');
    for (var i = 0; i != rdf.length; ++i) {
      o.push(write_rdf_type(rdf[i][0], rdf[i][1]));
      o.push(write_rdf_has("", rdf[i][0]));
    }
    o.push(write_rdf_type("", "Document", "pkg"));
    o.push("</rdf:RDF>");
    return o.join("");
  }
  function write_meta_ods(wb, opts) {
    return '<office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"><office:meta><meta:generator>SheetJS ' + XLSX.version + "</meta:generator></office:meta></office:document-meta>";
  }
  var CORE_PROPS = [
    ["cp:category", "Category"],
    ["cp:contentStatus", "ContentStatus"],
    ["cp:keywords", "Keywords"],
    ["cp:lastModifiedBy", "LastAuthor"],
    ["cp:lastPrinted", "LastPrinted"],
    ["cp:revision", "RevNumber"],
    ["cp:version", "Version"],
    ["dc:creator", "Author"],
    ["dc:description", "Comments"],
    ["dc:identifier", "Identifier"],
    ["dc:language", "Language"],
    ["dc:subject", "Subject"],
    ["dc:title", "Title"],
    ["dcterms:created", "CreatedDate", "date"],
    ["dcterms:modified", "ModifiedDate", "date"]
  ];
  function parse_core_props(data) {
    var p2 = {};
    data = utf8read(data);
    for (var i = 0; i < CORE_PROPS.length; ++i) {
      var f = CORE_PROPS[i], cur = str_match_xml(data, f[0]);
      if (cur != null && cur.length > 0) p2[f[1]] = unescapexml(cur[1]);
      if (f[2] === "date" && p2[f[1]]) p2[f[1]] = parseDate(p2[f[1]]);
    }
    return p2;
  }
  function cp_doit(f, g, h2, o, p2) {
    if (p2[f] != null || g == null || g === "") return;
    p2[f] = g;
    g = escapexml(g);
    o[o.length] = h2 ? writextag(f, g, h2) : writetag(f, g);
  }
  function write_core_props(cp, _opts) {
    var opts = _opts || {};
    var o = [XML_HEADER, writextag("cp:coreProperties", null, {
"xmlns:cp": XMLNS.CORE_PROPS,
      "xmlns:dc": XMLNS.dc,
      "xmlns:dcterms": XMLNS.dcterms,
      "xmlns:dcmitype": XMLNS.dcmitype,
      "xmlns:xsi": XMLNS.xsi
    })], p2 = {};
    if (!cp && !opts.Props) return o.join("");
    if (cp) {
      if (cp.CreatedDate != null) cp_doit("dcterms:created", typeof cp.CreatedDate === "string" ? cp.CreatedDate : write_w3cdtf(cp.CreatedDate, opts.WTF), { "xsi:type": "dcterms:W3CDTF" }, o, p2);
      if (cp.ModifiedDate != null) cp_doit("dcterms:modified", typeof cp.ModifiedDate === "string" ? cp.ModifiedDate : write_w3cdtf(cp.ModifiedDate, opts.WTF), { "xsi:type": "dcterms:W3CDTF" }, o, p2);
    }
    for (var i = 0; i != CORE_PROPS.length; ++i) {
      var f = CORE_PROPS[i];
      var v = opts.Props && opts.Props[f[1]] != null ? opts.Props[f[1]] : cp ? cp[f[1]] : null;
      if (v === true) v = "1";
      else if (v === false) v = "0";
      else if (typeof v == "number") v = String(v);
      if (v != null) cp_doit(f[0], v, null, o, p2);
    }
    if (o.length > 2) {
      o[o.length] = "</cp:coreProperties>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  var EXT_PROPS = [
    ["Application", "Application", "string"],
    ["AppVersion", "AppVersion", "string"],
    ["Company", "Company", "string"],
    ["DocSecurity", "DocSecurity", "string"],
    ["Manager", "Manager", "string"],
    ["HyperlinksChanged", "HyperlinksChanged", "bool"],
    ["SharedDoc", "SharedDoc", "bool"],
    ["LinksUpToDate", "LinksUpToDate", "bool"],
    ["ScaleCrop", "ScaleCrop", "bool"],
    ["HeadingPairs", "HeadingPairs", "raw"],
    ["TitlesOfParts", "TitlesOfParts", "raw"]
  ];
  var PseudoPropsPairs = [
    "Worksheets",
    "SheetNames",
    "NamedRanges",
    "DefinedNames",
    "Chartsheets",
    "ChartNames"
  ];
  function load_props_pairs(HP, TOP, props, opts) {
    var v = [];
    if (typeof HP == "string") v = parseVector(HP, opts);
    else for (var j = 0; j < HP.length; ++j) v = v.concat(HP[j].map(function(hp) {
      return { v: hp };
    }));
    var parts = typeof TOP == "string" ? parseVector(TOP, opts).map(function(x) {
      return x.v;
    }) : TOP;
    var idx = 0, len = 0;
    if (parts.length > 0) for (var i = 0; i !== v.length; i += 2) {
      len = +v[i + 1].v;
      switch (v[i].v) {
        case "Worksheets":
        case "工作表":
        case "Листы":
        case "أوراق العمل":
        case "ワークシート":
        case "גליונות עבודה":
        case "Arbeitsblätter":
        case "Çalışma Sayfaları":
        case "Feuilles de calcul":
        case "Fogli di lavoro":
        case "Folhas de cálculo":
        case "Planilhas":
        case "Regneark":
        case "Hojas de cálculo":
        case "Werkbladen":
          props.Worksheets = len;
          props.SheetNames = parts.slice(idx, idx + len);
          break;
        case "Named Ranges":
        case "Rangos con nombre":
        case "名前付き一覧":
        case "Benannte Bereiche":
        case "Navngivne områder":
          props.NamedRanges = len;
          props.DefinedNames = parts.slice(idx, idx + len);
          break;
        case "Charts":
        case "Diagramme":
          props.Chartsheets = len;
          props.ChartNames = parts.slice(idx, idx + len);
          break;
      }
      idx += len;
    }
  }
  function parse_ext_props(data, p2, opts) {
    var q = {};
    if (!p2) p2 = {};
    data = utf8read(data);
    EXT_PROPS.forEach(function(f) {
      var xml = (str_match_xml_ns(data, f[0]) || [])[1];
      switch (f[2]) {
        case "string":
          if (xml) p2[f[1]] = unescapexml(xml);
          break;
        case "bool":
          p2[f[1]] = xml === "true";
          break;
        case "raw":
          var cur = str_match_xml(data, f[0]);
          if (cur && cur.length > 0) q[f[1]] = cur[1];
          break;
      }
    });
    if (q.HeadingPairs && q.TitlesOfParts) load_props_pairs(q.HeadingPairs, q.TitlesOfParts, p2, opts);
    return p2;
  }
  function write_ext_props(cp) {
    var o = [], W = writextag;
    if (!cp) cp = {};
    cp.Application = "SheetJS";
    o[o.length] = XML_HEADER;
    o[o.length] = writextag("Properties", null, {
      "xmlns": XMLNS.EXT_PROPS,
      "xmlns:vt": XMLNS.vt
    });
    EXT_PROPS.forEach(function(f) {
      if (cp[f[1]] === void 0) return;
      var v;
      switch (f[2]) {
        case "string":
          v = escapexml(String(cp[f[1]]));
          break;
        case "bool":
          v = cp[f[1]] ? "true" : "false";
          break;
      }
      if (v !== void 0) o[o.length] = W(f[0], v);
    });
    o[o.length] = W("HeadingPairs", W("vt:vector", W("vt:variant", "<vt:lpstr>Worksheets</vt:lpstr>") + W("vt:variant", W("vt:i4", String(cp.Worksheets))), { size: 2, baseType: "variant" }));
    o[o.length] = W("TitlesOfParts", W("vt:vector", cp.SheetNames.map(function(s) {
      return "<vt:lpstr>" + escapexml(s) + "</vt:lpstr>";
    }).join(""), { size: cp.Worksheets, baseType: "lpstr" }));
    if (o.length > 2) {
      o[o.length] = "</Properties>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  var custregex = /<[^<>]+>[^<]*/g;
  function parse_cust_props(data, opts) {
    var p2 = {}, name = "";
    var m = data.match(custregex);
    if (m) for (var i = 0; i != m.length; ++i) {
      var x = m[i], y = parsexmltag(x);
      switch (strip_ns(y[0])) {
        case "<?xml":
          break;
        case "<Properties":
          break;
        case "<property":
          name = unescapexml(y.name);
          break;
        case "</property>":
          name = null;
          break;
        default:
          if (x.indexOf("<vt:") === 0) {
            var toks = x.split(">");
            var type = toks[0].slice(4), text = toks[1];
            switch (type) {
              case "lpstr":
              case "bstr":
              case "lpwstr":
                p2[name] = unescapexml(text);
                break;
              case "bool":
                p2[name] = parsexmlbool(text);
                break;
              case "i1":
              case "i2":
              case "i4":
              case "i8":
              case "int":
              case "uint":
                p2[name] = parseInt(text, 10);
                break;
              case "r4":
              case "r8":
              case "decimal":
                p2[name] = parseFloat(text);
                break;
              case "filetime":
              case "date":
                p2[name] = parseDate(text);
                break;
              case "cy":
              case "error":
                p2[name] = unescapexml(text);
                break;
              default:
                if (type.slice(-1) == "/") break;
                if (opts.WTF && typeof console !== "undefined") console.warn("Unexpected", x, type, toks);
            }
          } else if (x.slice(0, 2) === "</") ;
          else if (opts.WTF) throw new Error(x);
      }
    }
    return p2;
  }
  function write_cust_props(cp) {
    var o = [XML_HEADER, writextag("Properties", null, {
      "xmlns": XMLNS.CUST_PROPS,
      "xmlns:vt": XMLNS.vt
    })];
    if (!cp) return o.join("");
    var pid = 1;
    keys(cp).forEach(function custprop(k) {
      ++pid;
      o[o.length] = writextag("property", write_vt(cp[k]), {
        "fmtid": "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
        "pid": pid,
        "name": escapexml(k)
      });
    });
    if (o.length > 2) {
      o[o.length] = "</Properties>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  var XLMLDocPropsMap = {
    Title: "Title",
    Subject: "Subject",
    Author: "Author",
    Keywords: "Keywords",
    Comments: "Description",
    LastAuthor: "LastAuthor",
    RevNumber: "Revision",
    Application: "AppName",
LastPrinted: "LastPrinted",
    CreatedDate: "Created",
    ModifiedDate: "LastSaved",


Category: "Category",
Manager: "Manager",
    Company: "Company",





AppVersion: "Version",
    ContentStatus: "ContentStatus",
Identifier: "Identifier",
Language: "Language"
};
  var evert_XLMLDPM;
  function xlml_set_prop(Props, tag, val2) {
    if (!evert_XLMLDPM) evert_XLMLDPM = evert(XLMLDocPropsMap);
    tag = evert_XLMLDPM[tag] || tag;
    Props[tag] = val2;
  }
  function xlml_write_docprops(Props, opts) {
    var o = [];
    keys(XLMLDocPropsMap).map(function(m) {
      for (var i = 0; i < CORE_PROPS.length; ++i) if (CORE_PROPS[i][1] == m) return CORE_PROPS[i];
      for (i = 0; i < EXT_PROPS.length; ++i) if (EXT_PROPS[i][1] == m) return EXT_PROPS[i];
      throw m;
    }).forEach(function(p2) {
      if (Props[p2[1]] == null) return;
      var m = opts && opts.Props && opts.Props[p2[1]] != null ? opts.Props[p2[1]] : Props[p2[1]];
      switch (p2[2]) {
        case "date":
          m = new Date(m).toISOString().replace(/\.\d*Z/, "Z");
          break;
      }
      if (typeof m == "number") m = String(m);
      else if (m === true || m === false) {
        m = m ? "1" : "0";
      } else if (m instanceof Date) m = new Date(m).toISOString().replace(/\.\d*Z/, "");
      o.push(writetag(XLMLDocPropsMap[p2[1]] || p2[1], m));
    });
    return writextag("DocumentProperties", o.join(""), { xmlns: XLMLNS.o });
  }
  function xlml_write_custprops(Props, Custprops) {
    var BLACKLIST = ["Worksheets", "SheetNames"];
    var T = "CustomDocumentProperties";
    var o = [];
    if (Props) keys(Props).forEach(function(k) {
      if (!Object.prototype.hasOwnProperty.call(Props, k)) return;
      for (var i = 0; i < CORE_PROPS.length; ++i) if (k == CORE_PROPS[i][1]) return;
      for (i = 0; i < EXT_PROPS.length; ++i) if (k == EXT_PROPS[i][1]) return;
      for (i = 0; i < BLACKLIST.length; ++i) if (k == BLACKLIST[i]) return;
      var m = Props[k];
      var t = "string";
      if (typeof m == "number") {
        t = "float";
        m = String(m);
      } else if (m === true || m === false) {
        t = "boolean";
        m = m ? "1" : "0";
      } else m = String(m);
      o.push(writextag(escapexmltag(k), m, { "dt:dt": t }));
    });
    if (Custprops) keys(Custprops).forEach(function(k) {
      if (!Object.prototype.hasOwnProperty.call(Custprops, k)) return;
      if (Props && Object.prototype.hasOwnProperty.call(Props, k)) return;
      var m = Custprops[k];
      var t = "string";
      if (typeof m == "number") {
        t = "float";
        m = String(m);
      } else if (m === true || m === false) {
        t = "boolean";
        m = m ? "1" : "0";
      } else if (m instanceof Date) {
        t = "dateTime.tz";
        m = m.toISOString();
      } else m = String(m);
      o.push(writextag(escapexmltag(k), m, { "dt:dt": t }));
    });
    return "<" + T + ' xmlns="' + XLMLNS.o + '">' + o.join("") + "</" + T + ">";
  }
  function parse_FILETIME(blob) {
    var dwLowDateTime = blob.read_shift(4), dwHighDateTime = blob.read_shift(4);
    return new Date((dwHighDateTime / 1e7 * Math.pow(2, 32) + dwLowDateTime / 1e7 - 11644473600) * 1e3).toISOString().replace(/\.000/, "");
  }
  function write_FILETIME(time) {
    var date = typeof time == "string" ? new Date(Date.parse(time)) : time;
    var t = date.getTime() / 1e3 + 11644473600;
    var l = t % Math.pow(2, 32), h2 = (t - l) / Math.pow(2, 32);
    l *= 1e7;
    h2 *= 1e7;
    var w = l / Math.pow(2, 32) | 0;
    if (w > 0) {
      l = l % Math.pow(2, 32);
      h2 += w;
    }
    var o = new_buf(8);
    o.write_shift(4, l);
    o.write_shift(4, h2);
    return o;
  }
  function parse_lpstr(blob, type, pad) {
    var start = blob.l;
    var str = blob.read_shift(0, "lpstr-cp");
    if (pad) while (blob.l - start & 3) ++blob.l;
    return str;
  }
  function parse_lpwstr(blob, type, pad) {
    var str = blob.read_shift(0, "lpwstr");
    return str;
  }
  function parse_VtStringBase(blob, stringType, pad) {
    if (stringType === 31) return parse_lpwstr(blob);
    return parse_lpstr(blob, stringType, pad);
  }
  function parse_VtString(blob, t, pad) {
    return parse_VtStringBase(blob, t, pad === false ? 0 : 4);
  }
  function parse_VtUnalignedString(blob, t) {
    if (!t) throw new Error("VtUnalignedString must have positive length");
    return parse_VtStringBase(blob, t, 0);
  }
  function parse_VtVecLpwstrValue(blob) {
    var length = blob.read_shift(4);
    var ret = [];
    for (var i = 0; i != length; ++i) {
      var start = blob.l;
      ret[i] = blob.read_shift(0, "lpwstr").replace(chr0, "");
      if (blob.l - start & 2) blob.l += 2;
    }
    return ret;
  }
  function parse_VtVecUnalignedLpstrValue(blob) {
    var length = blob.read_shift(4);
    var ret = [];
    for (var i = 0; i != length; ++i) ret[i] = blob.read_shift(0, "lpstr-cp").replace(chr0, "");
    return ret;
  }
  function parse_VtHeadingPair(blob) {
    var start = blob.l;
    var headingString = parse_TypedPropertyValue(blob, VT_USTR);
    if (blob[blob.l] == 0 && blob[blob.l + 1] == 0 && blob.l - start & 2) blob.l += 2;
    var headerParts = parse_TypedPropertyValue(blob, VT_I4);
    return [headingString, headerParts];
  }
  function parse_VtVecHeadingPairValue(blob) {
    var cElements = blob.read_shift(4);
    var out = [];
    for (var i = 0; i < cElements / 2; ++i) out.push(parse_VtHeadingPair(blob));
    return out;
  }
  function parse_dictionary(blob, CodePage) {
    var cnt = blob.read_shift(4);
    var dict = {};
    for (var j = 0; j != cnt; ++j) {
      var pid = blob.read_shift(4);
      var len = blob.read_shift(4);
      dict[pid] = blob.read_shift(len, CodePage === 1200 ? "utf16le" : "utf8").replace(chr0, "").replace(chr1, "!");
      if (CodePage === 1200 && len % 2) blob.l += 2;
    }
    if (blob.l & 3) blob.l = blob.l >> 2 + 1 << 2;
    return dict;
  }
  function parse_BLOB(blob) {
    var size = blob.read_shift(4);
    var bytes = blob.slice(blob.l, blob.l + size);
    blob.l += size;
    if ((size & 3) > 0) blob.l += 4 - (size & 3) & 3;
    return bytes;
  }
  function parse_ClipboardData(blob) {
    var o = {};
    o.Size = blob.read_shift(4);
    blob.l += o.Size + 3 - (o.Size - 1) % 4;
    return o;
  }
  function parse_TypedPropertyValue(blob, type, _opts) {
    var t = blob.read_shift(2), ret, opts = _opts || {};
    blob.l += 2;
    if (type !== VT_VARIANT) {
      if (t !== type && VT_CUSTOM.indexOf(type) === -1 && !((type & 65534) == 4126 && (t & 65534) == 4126)) throw new Error("Expected type " + type + " saw " + t);
    }
    switch (type === VT_VARIANT ? t : type) {
      case 2:
        ret = blob.read_shift(2, "i");
        if (!opts.raw) blob.l += 2;
        return ret;
      case 3:
        ret = blob.read_shift(4, "i");
        return ret;
      case 11:
        return blob.read_shift(4) !== 0;
      case 19:
        ret = blob.read_shift(4);
        return ret;
      case 30:
        blob.l += 4;
        val = parse_VtString(blob, blob[blob.l - 4]).replace(/(^|[^\u0000])\u0000+$/, "$1");
        break;
      case 31:
        blob.l += 4;
        val = parse_VtString(blob, blob[blob.l - 4]).replace(/(^|[^\u0000])\u0000+$/, "$1");
        break;
      case 64:
        return parse_FILETIME(blob);
      case 65:
        return parse_BLOB(blob);
      case 71:
        return parse_ClipboardData(blob);
      case 80:
        return parse_VtString(blob, t, !opts.raw).replace(chr0, "");
      case 81:
        return parse_VtUnalignedString(
          blob,
          t
).replace(chr0, "");
      case 4108:
        return parse_VtVecHeadingPairValue(blob);
      case 4126:
      case 4127:
        return t == 4127 ? parse_VtVecLpwstrValue(blob) : parse_VtVecUnalignedLpstrValue(blob);
      default:
        throw new Error("TypedPropertyValue unrecognized type " + type + " " + t);
    }
  }
  function write_TypedPropertyValue(type, value) {
    var o = new_buf(4), p2 = new_buf(4);
    o.write_shift(4, type == 80 ? 31 : type);
    switch (type) {
      case 3:
        p2.write_shift(-4, value);
        break;
      case 5:
        p2 = new_buf(8);
        p2.write_shift(8, value, "f");
        break;
      case 11:
        p2.write_shift(4, value ? 1 : 0);
        break;
      case 64:
        p2 = write_FILETIME(value);
        break;
      case 31:
      case 80:
        p2 = new_buf(4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
        p2.write_shift(4, value.length + 1);
        p2.write_shift(0, value, "dbcs");
        while (p2.l != p2.length) p2.write_shift(1, 0);
        break;
      default:
        throw new Error("TypedPropertyValue unrecognized type " + type + " " + value);
    }
    return bconcat([o, p2]);
  }
  function parse_PropertySet(blob, PIDSI) {
    var start_addr = blob.l;
    var size = blob.read_shift(4);
    var NumProps = blob.read_shift(4);
    var Props = [], i = 0;
    var CodePage = 0;
    var Dictionary = -1, DictObj = {};
    for (i = 0; i != NumProps; ++i) {
      var PropID = blob.read_shift(4);
      var Offset = blob.read_shift(4);
      Props[i] = [PropID, Offset + start_addr];
    }
    Props.sort(function(x, y) {
      return x[1] - y[1];
    });
    var PropH = {};
    for (i = 0; i != NumProps; ++i) {
      if (blob.l !== Props[i][1]) {
        var fail = true;
        if (i > 0 && PIDSI) switch (PIDSI[Props[i - 1][0]].t) {
          case 2:
            if (blob.l + 2 === Props[i][1]) {
              blob.l += 2;
              fail = false;
            }
            break;
          case 80:
            if (blob.l <= Props[i][1]) {
              blob.l = Props[i][1];
              fail = false;
            }
            break;
          case 4108:
            if (blob.l <= Props[i][1]) {
              blob.l = Props[i][1];
              fail = false;
            }
            break;
        }
        if ((!PIDSI || i == 0) && blob.l <= Props[i][1]) {
          fail = false;
          blob.l = Props[i][1];
        }
        if (fail) throw new Error("Read Error: Expected address " + Props[i][1] + " at " + blob.l + " :" + i);
      }
      if (PIDSI) {
        if (Props[i][0] == 0 && Props.length > i + 1 && Props[i][1] == Props[i + 1][1]) continue;
        var piddsi = PIDSI[Props[i][0]];
        PropH[piddsi.n] = parse_TypedPropertyValue(blob, piddsi.t, { raw: true });
        if (piddsi.p === "version") PropH[piddsi.n] = String(PropH[piddsi.n] >> 16) + "." + ("0000" + String(PropH[piddsi.n] & 65535)).slice(-4);
        if (piddsi.n == "CodePage") switch (PropH[piddsi.n]) {
          case 0:
            PropH[piddsi.n] = 1252;
case 874:
          case 932:
          case 936:
          case 949:
          case 950:
          case 1250:
          case 1251:
          case 1253:
          case 1254:
          case 1255:
          case 1256:
          case 1257:
          case 1258:
          case 1e4:
          case 1200:
          case 1201:
          case 1252:
          case 65e3:
          case -536:
          case 65001:
          case -535:
            set_cp(CodePage = PropH[piddsi.n] >>> 0 & 65535);
            break;
          default:
            throw new Error("Unsupported CodePage: " + PropH[piddsi.n]);
        }
      } else {
        if (Props[i][0] === 1) {
          CodePage = PropH.CodePage = parse_TypedPropertyValue(blob, VT_I2);
          set_cp(CodePage);
          if (Dictionary !== -1) {
            var oldpos = blob.l;
            blob.l = Props[Dictionary][1];
            DictObj = parse_dictionary(blob, CodePage);
            blob.l = oldpos;
          }
        } else if (Props[i][0] === 0) {
          if (CodePage === 0) {
            Dictionary = i;
            blob.l = Props[i + 1][1];
            continue;
          }
          DictObj = parse_dictionary(blob, CodePage);
        } else {
          var name = DictObj[Props[i][0]];
          var val2;
          switch (blob[blob.l]) {
            case 65:
              blob.l += 4;
              val2 = parse_BLOB(blob);
              break;
            case 30:
              blob.l += 4;
              val2 = parse_VtString(blob, blob[blob.l - 4]).replace(/(^|[^\u0000])\u0000+$/, "$1");
              break;
            case 31:
              blob.l += 4;
              val2 = parse_VtString(blob, blob[blob.l - 4]).replace(/(^|[^\u0000])\u0000+$/, "$1");
              break;
            case 3:
              blob.l += 4;
              val2 = blob.read_shift(4, "i");
              break;
            case 19:
              blob.l += 4;
              val2 = blob.read_shift(4);
              break;
            case 5:
              blob.l += 4;
              val2 = blob.read_shift(8, "f");
              break;
            case 11:
              blob.l += 4;
              val2 = parsebool(blob, 4);
              break;
            case 64:
              blob.l += 4;
              val2 = parseDate(parse_FILETIME(blob));
              break;
            default:
              throw new Error("unparsed value: " + blob[blob.l]);
          }
          PropH[name] = val2;
        }
      }
    }
    blob.l = start_addr + size;
    return PropH;
  }
  var XLSPSSkip = ["CodePage", "Thumbnail", "_PID_LINKBASE", "_PID_HLINKS", "SystemIdentifier", "FMTID"];
  function guess_property_type(val2) {
    switch (typeof val2) {
      case "boolean":
        return 11;
      case "number":
        return (val2 | 0) == val2 ? 3 : 5;
      case "string":
        return 31;
      case "object":
        if (val2 instanceof Date) return 64;
        break;
    }
    return -1;
  }
  function write_PropertySet(entries, RE, PIDSI) {
    var hdr = new_buf(8), piao = [], prop = [];
    var sz = 8, i = 0;
    var pr = new_buf(8), pio = new_buf(8);
    pr.write_shift(4, 2);
    pr.write_shift(4, 1200);
    pio.write_shift(4, 1);
    prop.push(pr);
    piao.push(pio);
    sz += 8 + pr.length;
    if (!RE) {
      pio = new_buf(8);
      pio.write_shift(4, 0);
      piao.unshift(pio);
      var bufs = [new_buf(4)];
      bufs[0].write_shift(4, entries.length);
      for (i = 0; i < entries.length; ++i) {
        var value = entries[i][0];
        pr = new_buf(4 + 4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
        pr.write_shift(4, i + 2);
        pr.write_shift(4, value.length + 1);
        pr.write_shift(0, value, "dbcs");
        while (pr.l != pr.length) pr.write_shift(1, 0);
        bufs.push(pr);
      }
      pr = bconcat(bufs);
      prop.unshift(pr);
      sz += 8 + pr.length;
    }
    for (i = 0; i < entries.length; ++i) {
      if (RE && !RE[entries[i][0]]) continue;
      if (XLSPSSkip.indexOf(entries[i][0]) > -1 || PseudoPropsPairs.indexOf(entries[i][0]) > -1) continue;
      if (entries[i][1] == null) continue;
      var val2 = entries[i][1], idx = 0;
      if (RE) {
        idx = +RE[entries[i][0]];
        var pinfo = PIDSI[idx];
        if (pinfo.p == "version" && typeof val2 == "string") {
          var arr = val2.split(".");
          val2 = (+arr[0] << 16) + (+arr[1] || 0);
        }
        pr = write_TypedPropertyValue(pinfo.t, val2);
      } else {
        var T = guess_property_type(val2);
        if (T == -1) {
          T = 31;
          val2 = String(val2);
        }
        pr = write_TypedPropertyValue(T, val2);
      }
      prop.push(pr);
      pio = new_buf(8);
      pio.write_shift(4, !RE ? 2 + i : idx);
      piao.push(pio);
      sz += 8 + pr.length;
    }
    var w = 8 * (prop.length + 1);
    for (i = 0; i < prop.length; ++i) {
      piao[i].write_shift(4, w);
      w += prop[i].length;
    }
    hdr.write_shift(4, sz);
    hdr.write_shift(4, prop.length);
    return bconcat([hdr].concat(piao).concat(prop));
  }
  function parse_PropertySetStream(file, PIDSI, clsid) {
    var blob = file.content;
    if (!blob) return {};
    prep_blob(blob, 0);
    var NumSets, FMTID0, FMTID1, Offset0, Offset1 = 0;
    blob.chk("feff", "Byte Order: ");
    blob.read_shift(2);
    var SystemIdentifier = blob.read_shift(4);
    var CLSID = blob.read_shift(16);
    if (CLSID !== CFB.utils.consts.HEADER_CLSID && CLSID !== clsid) throw new Error("Bad PropertySet CLSID " + CLSID);
    NumSets = blob.read_shift(4);
    if (NumSets !== 1 && NumSets !== 2) throw new Error("Unrecognized #Sets: " + NumSets);
    FMTID0 = blob.read_shift(16);
    Offset0 = blob.read_shift(4);
    if (NumSets === 1 && Offset0 !== blob.l) throw new Error("Length mismatch: " + Offset0 + " !== " + blob.l);
    else if (NumSets === 2) {
      FMTID1 = blob.read_shift(16);
      Offset1 = blob.read_shift(4);
    }
    var PSet0 = parse_PropertySet(blob, PIDSI);
    var rval = { SystemIdentifier };
    for (var y in PSet0) rval[y] = PSet0[y];
    rval.FMTID = FMTID0;
    if (NumSets === 1) return rval;
    if (Offset1 - blob.l == 2) blob.l += 2;
    if (blob.l !== Offset1) throw new Error("Length mismatch 2: " + blob.l + " !== " + Offset1);
    var PSet1;
    try {
      PSet1 = parse_PropertySet(blob, null);
    } catch (e) {
    }
    for (y in PSet1) rval[y] = PSet1[y];
    rval.FMTID = [FMTID0, FMTID1];
    return rval;
  }
  function write_PropertySetStream(entries, clsid, RE, PIDSI, entries2, clsid2) {
    var hdr = new_buf(entries2 ? 68 : 48);
    var bufs = [hdr];
    hdr.write_shift(2, 65534);
    hdr.write_shift(2, 0);
    hdr.write_shift(4, 842412599);
    hdr.write_shift(16, CFB.utils.consts.HEADER_CLSID, "hex");
    hdr.write_shift(4, entries2 ? 2 : 1);
    hdr.write_shift(16, clsid, "hex");
    hdr.write_shift(4, entries2 ? 68 : 48);
    var ps0 = write_PropertySet(entries, RE, PIDSI);
    bufs.push(ps0);
    if (entries2) {
      var ps1 = write_PropertySet(entries2, null, null);
      hdr.write_shift(16, clsid2, "hex");
      hdr.write_shift(4, 68 + ps0.length);
      bufs.push(ps1);
    }
    return bconcat(bufs);
  }
  function parsenoop2(blob, length) {
    blob.read_shift(length);
    return null;
  }
  function writezeroes(n, o) {
    if (!o) o = new_buf(n);
    for (var j = 0; j < n; ++j) o.write_shift(1, 0);
    return o;
  }
  function parslurp(blob, length, cb) {
    var arr = [], target = blob.l + length;
    while (blob.l < target) arr.push(cb(blob, target - blob.l));
    if (target !== blob.l) throw new Error("Slurp error");
    return arr;
  }
  function parsebool(blob, length) {
    return blob.read_shift(length) === 1;
  }
  function writebool(v, o) {
    if (!o) o = new_buf(2);
    o.write_shift(2, +!!v);
    return o;
  }
  function parseuint16(blob) {
    return blob.read_shift(2, "u");
  }
  function writeuint16(v, o) {
    if (!o) o = new_buf(2);
    o.write_shift(2, v);
    return o;
  }
  function parseuint16a(blob, length) {
    return parslurp(blob, length, parseuint16);
  }
  function parse_Bes(blob) {
    var v = blob.read_shift(1), t = blob.read_shift(1);
    return t === 1 ? v : v === 1;
  }
  function write_Bes(v, t, o) {
    if (!o) o = new_buf(2);
    o.write_shift(1, t == "e" ? +v : +!!v);
    o.write_shift(1, t == "e" ? 1 : 0);
    return o;
  }
  function parse_ShortXLUnicodeString(blob, length, opts) {
    var cch = blob.read_shift(opts && opts.biff >= 12 ? 2 : 1);
    var encoding = "sbcs-cont";
    var cp = current_codepage;
    if (opts && opts.biff >= 8) current_codepage = 1200;
    if (!opts || opts.biff == 8) {
      var fHighByte = blob.read_shift(1);
      if (fHighByte) {
        encoding = "dbcs-cont";
      }
    } else if (opts.biff == 12) {
      encoding = "wstr";
    }
    if (opts.biff >= 2 && opts.biff <= 5) encoding = "cpstr";
    var o = cch ? blob.read_shift(cch, encoding) : "";
    current_codepage = cp;
    return o;
  }
  function parse_XLUnicodeRichExtendedString(blob) {
    var cp = current_codepage;
    current_codepage = 1200;
    var cch = blob.read_shift(2), flags = blob.read_shift(1);
    var fExtSt = flags & 4, fRichSt = flags & 8;
    var width = 1 + (flags & 1);
    var cRun = 0, cbExtRst;
    var z = {};
    if (fRichSt) cRun = blob.read_shift(2);
    if (fExtSt) cbExtRst = blob.read_shift(4);
    var encoding = width == 2 ? "dbcs-cont" : "sbcs-cont";
    var msg = cch === 0 ? "" : blob.read_shift(cch, encoding);
    if (fRichSt) blob.l += 4 * cRun;
    if (fExtSt) blob.l += cbExtRst;
    z.t = msg;
    if (!fRichSt) {
      z.raw = "<t>" + z.t + "</t>";
      z.r = z.t;
    }
    current_codepage = cp;
    return z;
  }
  function write_XLUnicodeRichExtendedString(xlstr) {
    var str = xlstr.t || "";
    var hdr = new_buf(3 + 0);
    hdr.write_shift(2, str.length);
    hdr.write_shift(1, 0 | 1);
    var otext = new_buf(2 * str.length);
    otext.write_shift(2 * str.length, str, "utf16le");
    var out = [hdr, otext];
    return bconcat(out);
  }
  function parse_XLUnicodeStringNoCch(blob, cch, opts) {
    var retval;
    if (opts) {
      if (opts.biff >= 2 && opts.biff <= 5) return blob.read_shift(cch, "cpstr");
      if (opts.biff >= 12) return blob.read_shift(cch, "dbcs-cont");
    }
    var fHighByte = blob.read_shift(1);
    if (fHighByte === 0) {
      retval = blob.read_shift(cch, "sbcs-cont");
    } else {
      retval = blob.read_shift(cch, "dbcs-cont");
    }
    return retval;
  }
  function parse_XLUnicodeString(blob, length, opts) {
    var cch = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
    if (cch === 0) {
      blob.l++;
      return "";
    }
    return parse_XLUnicodeStringNoCch(blob, cch, opts);
  }
  function parse_XLUnicodeString2(blob, length, opts) {
    if (opts.biff > 5) return parse_XLUnicodeString(blob, length, opts);
    var cch = blob.read_shift(1);
    if (cch === 0) {
      blob.l++;
      return "";
    }
    return blob.read_shift(cch, opts.biff <= 4 || !blob.lens ? "cpstr" : "sbcs-cont");
  }
  function write_XLUnicodeString(str, opts, o) {
    if (!o) o = new_buf(3 + 2 * str.length);
    o.write_shift(2, str.length);
    o.write_shift(1, 1);
    o.write_shift(31, str, "utf16le");
    return o;
  }
  function parse_ControlInfo(blob) {
    var flags = blob.read_shift(1);
    blob.l++;
    var accel = blob.read_shift(2);
    blob.l += 2;
    return [flags, accel];
  }
  function parse_URLMoniker(blob) {
    var len = blob.read_shift(4), start = blob.l;
    var extra = false;
    if (len > 24) {
      blob.l += len - 24;
      if (blob.read_shift(16) === "795881f43b1d7f48af2c825dc4852763") extra = true;
      blob.l = start;
    }
    var url = blob.read_shift((extra ? len - 24 : len) >> 1, "utf16le").replace(chr0, "");
    if (extra) blob.l += 24;
    return url;
  }
  function parse_FileMoniker(blob) {
    var cAnti = blob.read_shift(2);
    var preamble = "";
    while (cAnti-- > 0) preamble += "../";
    var ansiPath = blob.read_shift(0, "lpstr-ansi");
    blob.l += 2;
    if (blob.read_shift(2) != 57005) throw new Error("Bad FileMoniker");
    var sz = blob.read_shift(4);
    if (sz === 0) return preamble + ansiPath.replace(/\\/g, "/");
    var bytes = blob.read_shift(4);
    if (blob.read_shift(2) != 3) throw new Error("Bad FileMoniker");
    var unicodePath = blob.read_shift(bytes >> 1, "utf16le").replace(chr0, "");
    return preamble + unicodePath;
  }
  function parse_HyperlinkMoniker(blob, length) {
    var clsid = blob.read_shift(16);
    switch (clsid) {
      case "e0c9ea79f9bace118c8200aa004ba90b":
        return parse_URLMoniker(blob);
      case "0303000000000000c000000000000046":
        return parse_FileMoniker(blob);
      default:
        throw new Error("Unsupported Moniker " + clsid);
    }
  }
  function parse_HyperlinkString(blob) {
    var len = blob.read_shift(4);
    var o = len > 0 ? blob.read_shift(len, "utf16le").replace(chr0, "") : "";
    return o;
  }
  function write_HyperlinkString(str, o) {
    if (!o) o = new_buf(6 + str.length * 2);
    o.write_shift(4, 1 + str.length);
    for (var i = 0; i < str.length; ++i) o.write_shift(2, str.charCodeAt(i));
    o.write_shift(2, 0);
    return o;
  }
  function parse_Hyperlink(blob, length) {
    var end = blob.l + length;
    var sVer = blob.read_shift(4);
    if (sVer !== 2) throw new Error("Unrecognized streamVersion: " + sVer);
    var flags = blob.read_shift(2);
    blob.l += 2;
    var displayName, targetFrameName, moniker, oleMoniker, Loc = "", guid, fileTime;
    if (flags & 16) displayName = parse_HyperlinkString(blob, end - blob.l);
    if (flags & 128) targetFrameName = parse_HyperlinkString(blob, end - blob.l);
    if ((flags & 257) === 257) moniker = parse_HyperlinkString(blob, end - blob.l);
    if ((flags & 257) === 1) oleMoniker = parse_HyperlinkMoniker(blob, end - blob.l);
    if (flags & 8) Loc = parse_HyperlinkString(blob, end - blob.l);
    if (flags & 32) guid = blob.read_shift(16);
    if (flags & 64) fileTime = parse_FILETIME(
      blob
);
    blob.l = end;
    var target = targetFrameName || moniker || oleMoniker || "";
    if (target && Loc) target += "#" + Loc;
    if (!target) target = "#" + Loc;
    if (flags & 2 && target.charAt(0) == "/" && target.charAt(1) != "/") target = "file://" + target;
    var out = { Target: target };
    if (guid) out.guid = guid;
    if (fileTime) out.time = fileTime;
    if (displayName) out.Tooltip = displayName;
    return out;
  }
  function write_Hyperlink(hl) {
    var out = new_buf(512), i = 0;
    var Target = hl.Target;
    if (Target.slice(0, 7) == "file://") Target = Target.slice(7);
    var hashidx = Target.indexOf("#");
    var F = hashidx > -1 ? 31 : 23;
    switch (Target.charAt(0)) {
      case "#":
        F = 28;
        break;
      case ".":
        F &= -3;
        break;
    }
    out.write_shift(4, 2);
    out.write_shift(4, F);
    var data = [8, 6815827, 6619237, 4849780, 83];
    for (i = 0; i < data.length; ++i) out.write_shift(4, data[i]);
    if (F == 28) {
      Target = Target.slice(1);
      write_HyperlinkString(Target, out);
    } else if (F & 2) {
      data = "e0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
      for (i = 0; i < data.length; ++i) out.write_shift(1, parseInt(data[i], 16));
      var Pretarget = hashidx > -1 ? Target.slice(0, hashidx) : Target;
      out.write_shift(4, 2 * (Pretarget.length + 1));
      for (i = 0; i < Pretarget.length; ++i) out.write_shift(2, Pretarget.charCodeAt(i));
      out.write_shift(2, 0);
      if (F & 8) write_HyperlinkString(hashidx > -1 ? Target.slice(hashidx + 1) : "", out);
    } else {
      data = "03 03 00 00 00 00 00 00 c0 00 00 00 00 00 00 46".split(" ");
      for (i = 0; i < data.length; ++i) out.write_shift(1, parseInt(data[i], 16));
      var P = 0;
      while (Target.slice(P * 3, P * 3 + 3) == "../" || Target.slice(P * 3, P * 3 + 3) == "..\\") ++P;
      out.write_shift(2, P);
      out.write_shift(4, Target.length - 3 * P + 1);
      for (i = 0; i < Target.length - 3 * P; ++i) out.write_shift(1, Target.charCodeAt(i + 3 * P) & 255);
      out.write_shift(1, 0);
      out.write_shift(2, 65535);
      out.write_shift(2, 57005);
      for (i = 0; i < 6; ++i) out.write_shift(4, 0);
    }
    return out.slice(0, out.l);
  }
  function parse_LongRGBA(blob) {
    var r2 = blob.read_shift(1), g = blob.read_shift(1), b = blob.read_shift(1), a = blob.read_shift(1);
    return [r2, g, b, a];
  }
  function parse_LongRGB(blob, length) {
    var x = parse_LongRGBA(blob);
    x[3] = 0;
    return x;
  }
  function parse_XLSCell(blob, length, opts) {
    var rw = blob.read_shift(2);
    var col = blob.read_shift(2);
    var ret = { r: rw, c: col, ixfe: 0 };
    if (opts && opts.biff == 2 || length == 7) {
      var flags = blob.read_shift(1);
      ret.ixfe = flags & 63;
      blob.l += 2;
    } else ret.ixfe = blob.read_shift(2);
    return ret;
  }
  function write_XLSCell(R, C, ixfe, o) {
    if (!o) o = new_buf(6);
    o.write_shift(2, R);
    o.write_shift(2, C);
    o.write_shift(2, ixfe || 0);
    return o;
  }
  function parse_frtHeader(blob) {
    var rt = blob.read_shift(2);
    var flags = blob.read_shift(2);
    blob.l += 8;
    return { type: rt, flags };
  }
  function parse_OptXLUnicodeString(blob, length, opts) {
    return length === 0 ? "" : parse_XLUnicodeString2(blob, length, opts);
  }
  function parse_XTI(blob, length, opts) {
    var w = opts.biff > 8 ? 4 : 2;
    var iSupBook = blob.read_shift(w), itabFirst = blob.read_shift(w, "i"), itabLast = blob.read_shift(w, "i");
    return [iSupBook, itabFirst, itabLast];
  }
  function parse_RkRec(blob) {
    var ixfe = blob.read_shift(2);
    var RK = parse_RkNumber(blob);
    return [ixfe, RK];
  }
  function parse_AddinUdf(blob, length, opts) {
    blob.l += 4;
    length -= 4;
    var l = blob.l + length;
    var udfName = parse_ShortXLUnicodeString(blob, length, opts);
    var cb = blob.read_shift(2);
    l -= blob.l;
    if (cb !== l) throw new Error("Malformed AddinUdf: padding = " + l + " != " + cb);
    blob.l += cb;
    return udfName;
  }
  function parse_Ref8U(blob) {
    var rwFirst = blob.read_shift(2);
    var rwLast = blob.read_shift(2);
    var colFirst = blob.read_shift(2);
    var colLast = blob.read_shift(2);
    return { s: { c: colFirst, r: rwFirst }, e: { c: colLast, r: rwLast } };
  }
  function write_Ref8U(r2, o) {
    if (!o) o = new_buf(8);
    o.write_shift(2, r2.s.r);
    o.write_shift(2, r2.e.r);
    o.write_shift(2, r2.s.c);
    o.write_shift(2, r2.e.c);
    return o;
  }
  function parse_RefU(blob) {
    var rwFirst = blob.read_shift(2);
    var rwLast = blob.read_shift(2);
    var colFirst = blob.read_shift(1);
    var colLast = blob.read_shift(1);
    return { s: { c: colFirst, r: rwFirst }, e: { c: colLast, r: rwLast } };
  }
  var parse_Ref = parse_RefU;
  function parse_FtCmo(blob) {
    blob.l += 4;
    var ot = blob.read_shift(2);
    var id = blob.read_shift(2);
    var flags = blob.read_shift(2);
    blob.l += 12;
    return [id, ot, flags];
  }
  function parse_FtNts(blob) {
    var out = {};
    blob.l += 4;
    blob.l += 16;
    out.fSharedNote = blob.read_shift(2);
    blob.l += 4;
    return out;
  }
  function parse_FtCf(blob) {
    var out = {};
    blob.l += 4;
    blob.cf = blob.read_shift(2);
    return out;
  }
  function parse_FtSkip(blob) {
    blob.l += 2;
    blob.l += blob.read_shift(2);
  }
  var FtTab = {
    0: parse_FtSkip,
4: parse_FtSkip,
5: parse_FtSkip,
6: parse_FtSkip,
7: parse_FtCf,
8: parse_FtSkip,
9: parse_FtSkip,
10: parse_FtSkip,
11: parse_FtSkip,
12: parse_FtSkip,
13: parse_FtNts,
14: parse_FtSkip,
15: parse_FtSkip,
16: parse_FtSkip,
17: parse_FtSkip,
18: parse_FtSkip,
19: parse_FtSkip,
20: parse_FtSkip,
21: parse_FtCmo
  };
  function parse_FtArray(blob, length) {
    var tgt = blob.l + length;
    var fts = [];
    while (blob.l < tgt) {
      var ft = blob.read_shift(2);
      blob.l -= 2;
      try {
        fts[ft] = FtTab[ft](blob, tgt - blob.l);
      } catch (e) {
        blob.l = tgt;
        return fts;
      }
    }
    if (blob.l != tgt) blob.l = tgt;
    return fts;
  }
  function parse_BOF(blob, length) {
    var o = { BIFFVer: 0, dt: 0 };
    o.BIFFVer = blob.read_shift(2);
    length -= 2;
    if (length >= 2) {
      o.dt = blob.read_shift(2);
      blob.l -= 2;
    }
    switch (o.BIFFVer) {
      case 1536:
case 1280:
case 1024:
case 768:
case 512:
case 2:
      case 7:
        break;
      default:
        if (length > 6) throw new Error("Unexpected BIFF Ver " + o.BIFFVer);
    }
    blob.read_shift(length);
    return o;
  }
  function write_BOF(wb, t, o) {
    var h2 = 1536, w = 16;
    switch (o.bookType) {
      case "biff8":
        break;
      case "biff5":
        h2 = 1280;
        w = 8;
        break;
      case "biff4":
        h2 = 4;
        w = 6;
        break;
      case "biff3":
        h2 = 3;
        w = 6;
        break;
      case "biff2":
        h2 = 2;
        w = 4;
        break;
      case "xla":
        break;
      default:
        throw new Error("unsupported BIFF version");
    }
    var out = new_buf(w);
    out.write_shift(2, h2);
    out.write_shift(2, t);
    if (w > 4) out.write_shift(2, 29282);
    if (w > 6) out.write_shift(2, 1997);
    if (w > 8) {
      out.write_shift(2, 49161);
      out.write_shift(2, 1);
      out.write_shift(2, 1798);
      out.write_shift(2, 0);
    }
    return out;
  }
  function parse_InterfaceHdr(blob, length) {
    if (length === 0) return 1200;
    if (blob.read_shift(2) !== 1200) ;
    return 1200;
  }
  function parse_WriteAccess(blob, length, opts) {
    if (opts.enc) {
      blob.l += length;
      return "";
    }
    var l = blob.l;
    var UserName = parse_XLUnicodeString2(blob, 0, opts);
    blob.read_shift(length + l - blob.l);
    return UserName;
  }
  function write_WriteAccess(s, opts) {
    var b8 = !opts || opts.biff == 8;
    var o = new_buf(b8 ? 112 : 54);
    o.write_shift(opts.biff == 8 ? 2 : 1, 7);
    if (b8) o.write_shift(1, 0);
    o.write_shift(4, 859007059);
    o.write_shift(4, 5458548 | (b8 ? 0 : 536870912));
    while (o.l < o.length) o.write_shift(1, b8 ? 0 : 32);
    return o;
  }
  function parse_WsBool(blob, length, opts) {
    var flags = opts && opts.biff == 8 || length == 2 ? blob.read_shift(2) : (blob.l += length, 0);
    return { fDialog: flags & 16, fBelow: flags & 64, fRight: flags & 128 };
  }
  function parse_BoundSheet8(blob, length, opts) {
    var name = "";
    if (opts.biff == 4) {
      name = parse_ShortXLUnicodeString(blob, 0, opts);
      if (name.length === 0) name = "Sheet1";
      return { name };
    }
    var pos = blob.read_shift(4);
    var hidden = blob.read_shift(1) & 3;
    var dt = blob.read_shift(1);
    switch (dt) {
      case 0:
        dt = "Worksheet";
        break;
      case 1:
        dt = "Macrosheet";
        break;
      case 2:
        dt = "Chartsheet";
        break;
      case 6:
        dt = "VBAModule";
        break;
    }
    name = parse_ShortXLUnicodeString(blob, 0, opts);
    if (name.length === 0) name = "Sheet1";
    return { pos, hs: hidden, dt, name };
  }
  function write_BoundSheet8(data, opts) {
    var w = !opts || opts.biff >= 8 ? 2 : 1;
    var o = new_buf(8 + w * data.name.length);
    o.write_shift(4, data.pos);
    o.write_shift(1, data.hs || 0);
    o.write_shift(1, data.dt);
    o.write_shift(1, data.name.length);
    if (opts.biff >= 8) o.write_shift(1, 1);
    o.write_shift(w * data.name.length, data.name, opts.biff < 8 ? "sbcs" : "utf16le");
    var out = o.slice(0, o.l);
    out.l = o.l;
    return out;
  }
  function parse_SST(blob, length) {
    var end = blob.l + length;
    var cnt = blob.read_shift(4);
    var ucnt = blob.read_shift(4);
    var strs2 = [];
    for (var i = 0; i != ucnt && blob.l < end; ++i) {
      strs2.push(parse_XLUnicodeRichExtendedString(blob));
    }
    strs2.Count = cnt;
    strs2.Unique = ucnt;
    return strs2;
  }
  function write_SST(sst, opts) {
    var header = new_buf(8);
    header.write_shift(4, sst.Count);
    header.write_shift(4, sst.Unique);
    var strs2 = [];
    for (var j = 0; j < sst.length; ++j) strs2[j] = write_XLUnicodeRichExtendedString(sst[j]);
    var o = bconcat([header].concat(strs2));
    o.parts = [header.length].concat(strs2.map(function(str) {
      return str.length;
    }));
    return o;
  }
  function parse_ExtSST(blob, length) {
    var extsst = {};
    extsst.dsst = blob.read_shift(2);
    blob.l += length - 2;
    return extsst;
  }
  function parse_Row(blob) {
    var z = {};
    z.r = blob.read_shift(2);
    z.c = blob.read_shift(2);
    z.cnt = blob.read_shift(2) - z.c;
    var miyRw = blob.read_shift(2);
    blob.l += 4;
    var flags = blob.read_shift(1);
    blob.l += 3;
    if (flags & 7) z.level = flags & 7;
    if (flags & 32) z.hidden = true;
    if (flags & 64) z.hpt = miyRw / 20;
    return z;
  }
  function parse_ForceFullCalculation(blob) {
    var header = parse_frtHeader(blob);
    if (header.type != 2211) throw new Error("Invalid Future Record " + header.type);
    var fullcalc = blob.read_shift(4);
    return fullcalc !== 0;
  }
  function parse_RecalcId(blob) {
    blob.read_shift(2);
    return blob.read_shift(4);
  }
  function parse_DefaultRowHeight(blob, length, opts) {
    var f = 0;
    if (!(opts && opts.biff == 2)) {
      f = blob.read_shift(2);
    }
    var miyRw = blob.read_shift(2);
    if (opts && opts.biff == 2) {
      f = 1 - (miyRw >> 15);
      miyRw &= 32767;
    }
    var fl = { Unsynced: f & 1, DyZero: (f & 2) >> 1, ExAsc: (f & 4) >> 2, ExDsc: (f & 8) >> 3 };
    return [fl, miyRw];
  }
  function parse_Window1(blob) {
    var xWn = blob.read_shift(2), yWn = blob.read_shift(2), dxWn = blob.read_shift(2), dyWn = blob.read_shift(2);
    var flags = blob.read_shift(2), iTabCur = blob.read_shift(2), iTabFirst = blob.read_shift(2);
    var ctabSel = blob.read_shift(2), wTabRatio = blob.read_shift(2);
    return {
      Pos: [xWn, yWn],
      Dim: [dxWn, dyWn],
      Flags: flags,
      CurTab: iTabCur,
      FirstTab: iTabFirst,
      Selected: ctabSel,
      TabRatio: wTabRatio
    };
  }
  function write_Window1() {
    var o = new_buf(18);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    o.write_shift(2, 29280);
    o.write_shift(2, 17600);
    o.write_shift(2, 56);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    o.write_shift(2, 1);
    o.write_shift(2, 500);
    return o;
  }
  function parse_Window2(blob, length, opts) {
    if (opts && opts.biff >= 2 && opts.biff < 5) return {};
    var f = blob.read_shift(2);
    return { RTL: f & 64 };
  }
  function write_Window2(view) {
    var o = new_buf(18), f = 1718;
    if (view && view.RTL) f |= 64;
    o.write_shift(2, f);
    o.write_shift(4, 0);
    o.write_shift(4, 64);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    return o;
  }
  function parse_Pane() {
  }
  function parse_Font(blob, length, opts) {
    var o = {
      dyHeight: blob.read_shift(2),
      fl: blob.read_shift(2)
    };
    switch (opts && opts.biff || 8) {
      case 2:
        break;
      case 3:
      case 4:
        blob.l += 2;
        break;
      default:
        blob.l += 10;
        break;
    }
    o.name = parse_ShortXLUnicodeString(blob, 0, opts);
    return o;
  }
  function write_Font(data, opts) {
    var name = data.name || "Arial";
    var b5 = opts && opts.biff == 5, w = b5 ? 15 + name.length : 16 + 2 * name.length;
    var o = new_buf(w);
    o.write_shift(2, data.sz * 20);
    o.write_shift(4, 0);
    o.write_shift(2, 400);
    o.write_shift(4, 0);
    o.write_shift(2, 0);
    o.write_shift(1, name.length);
    if (!b5) o.write_shift(1, 1);
    o.write_shift((b5 ? 1 : 2) * name.length, name, b5 ? "sbcs" : "utf16le");
    return o;
  }
  function parse_LabelSst(blob, length, opts) {
    var cell = parse_XLSCell(blob, length, opts);
    cell.isst = blob.read_shift(4);
    return cell;
  }
  function write_LabelSst(R, C, v, os) {
    var o = new_buf(10);
    write_XLSCell(R, C, os, o);
    o.write_shift(4, v);
    return o;
  }
  function parse_Label(blob, length, opts) {
    if (opts.biffguess && opts.biff == 2) opts.biff = 5;
    var target = blob.l + length;
    var cell = parse_XLSCell(blob, length, opts);
    var str = parse_XLUnicodeString(blob, target - blob.l, opts);
    cell.val = str;
    return cell;
  }
  function write_Label(R, C, v, os, opts) {
    var b8 = !opts || opts.biff == 8;
    var o = new_buf(6 + 2 + +b8 + (1 + b8) * v.length);
    write_XLSCell(R, C, os, o);
    o.write_shift(2, v.length);
    if (b8) o.write_shift(1, 1);
    o.write_shift((1 + b8) * v.length, v, b8 ? "utf16le" : "sbcs");
    return o;
  }
  function parse_Format(blob, length, opts) {
    var numFmtId = blob.read_shift(2);
    var fmtstr = parse_XLUnicodeString2(blob, 0, opts);
    return [numFmtId, fmtstr];
  }
  function write_Format(i, f, opts, o) {
    var b5 = opts && opts.biff == 5;
    if (!o) o = new_buf(b5 ? 3 + f.length : 5 + 2 * f.length);
    o.write_shift(2, i);
    o.write_shift(b5 ? 1 : 2, f.length);
    if (!b5) o.write_shift(1, 1);
    o.write_shift((b5 ? 1 : 2) * f.length, f, b5 ? "sbcs" : "utf16le");
    var out = o.length > o.l ? o.slice(0, o.l) : o;
    if (out.l == null) out.l = out.length;
    return out;
  }
  var parse_BIFF2Format = parse_XLUnicodeString2;
  function write_BIFF2Format(f) {
    var o = new_buf(1 + f.length);
    o.write_shift(1, f.length);
    o.write_shift(f.length, f, "sbcs");
    return o;
  }
  function write_BIFF4Format(f) {
    var o = new_buf(3 + f.length);
    o.l += 2;
    o.write_shift(1, f.length);
    o.write_shift(f.length, f, "sbcs");
    return o;
  }
  function parse_Dimensions(blob, length, opts) {
    var end = blob.l + length;
    var w = opts.biff == 8 || !opts.biff ? 4 : 2;
    var r2 = blob.read_shift(w), R = blob.read_shift(w);
    var c = blob.read_shift(2), C = blob.read_shift(2);
    blob.l = end;
    return { s: { r: r2, c }, e: { r: R, c: C } };
  }
  function write_Dimensions(range, opts) {
    var w = opts.biff == 8 || !opts.biff ? 4 : 2;
    var o = new_buf(2 * w + 6);
    o.write_shift(w, range.s.r);
    o.write_shift(w, range.e.r + 1);
    o.write_shift(2, range.s.c);
    o.write_shift(2, range.e.c + 1);
    o.write_shift(2, 0);
    return o;
  }
  function parse_RK(blob) {
    var rw = blob.read_shift(2), col = blob.read_shift(2);
    var rkrec = parse_RkRec(blob);
    return { r: rw, c: col, ixfe: rkrec[0], rknum: rkrec[1] };
  }
  function parse_MulRk(blob, length) {
    var target = blob.l + length - 2;
    var rw = blob.read_shift(2), col = blob.read_shift(2);
    var rkrecs = [];
    while (blob.l < target) rkrecs.push(parse_RkRec(blob));
    if (blob.l !== target) throw new Error("MulRK read error");
    var lastcol = blob.read_shift(2);
    if (rkrecs.length != lastcol - col + 1) throw new Error("MulRK length mismatch");
    return { r: rw, c: col, C: lastcol, rkrec: rkrecs };
  }
  function parse_MulBlank(blob, length) {
    var target = blob.l + length - 2;
    var rw = blob.read_shift(2), col = blob.read_shift(2);
    var ixfes = [];
    while (blob.l < target) ixfes.push(blob.read_shift(2));
    if (blob.l !== target) throw new Error("MulBlank read error");
    var lastcol = blob.read_shift(2);
    if (ixfes.length != lastcol - col + 1) throw new Error("MulBlank length mismatch");
    return { r: rw, c: col, C: lastcol, ixfe: ixfes };
  }
  function parse_CellStyleXF(blob, length, style, opts) {
    var o = {};
    var a = blob.read_shift(4), b = blob.read_shift(4);
    var c = blob.read_shift(4), d = blob.read_shift(2);
    o.patternType = XLSFillPattern[c >> 26];
    if (!opts.cellStyles) return o;
    o.alc = a & 7;
    o.fWrap = a >> 3 & 1;
    o.alcV = a >> 4 & 7;
    o.fJustLast = a >> 7 & 1;
    o.trot = a >> 8 & 255;
    o.cIndent = a >> 16 & 15;
    o.fShrinkToFit = a >> 20 & 1;
    o.iReadOrder = a >> 22 & 2;
    o.fAtrNum = a >> 26 & 1;
    o.fAtrFnt = a >> 27 & 1;
    o.fAtrAlc = a >> 28 & 1;
    o.fAtrBdr = a >> 29 & 1;
    o.fAtrPat = a >> 30 & 1;
    o.fAtrProt = a >> 31 & 1;
    o.dgLeft = b & 15;
    o.dgRight = b >> 4 & 15;
    o.dgTop = b >> 8 & 15;
    o.dgBottom = b >> 12 & 15;
    o.icvLeft = b >> 16 & 127;
    o.icvRight = b >> 23 & 127;
    o.grbitDiag = b >> 30 & 3;
    o.icvTop = c & 127;
    o.icvBottom = c >> 7 & 127;
    o.icvDiag = c >> 14 & 127;
    o.dgDiag = c >> 21 & 15;
    o.icvFore = d & 127;
    o.icvBack = d >> 7 & 127;
    o.fsxButton = d >> 14 & 1;
    return o;
  }
  function parse_XF(blob, length, opts) {
    var o = {};
    o.ifnt = blob.read_shift(2);
    o.numFmtId = blob.read_shift(2);
    o.flags = blob.read_shift(2);
    o.fStyle = o.flags >> 2 & 1;
    length -= 6;
    o.data = parse_CellStyleXF(blob, length, o.fStyle, opts);
    return o;
  }
  function write_XF(data, ixfeP, opts, o) {
    var b5 = opts && opts.biff == 5;
    if (!o) o = new_buf(b5 ? 16 : 20);
    o.write_shift(2, 0);
    if (data.style) {
      o.write_shift(2, data.numFmtId || 0);
      o.write_shift(2, 65524);
    } else {
      o.write_shift(2, data.numFmtId || 0);
      o.write_shift(2, ixfeP << 4);
    }
    var f = 0;
    if (data.numFmtId > 0 && b5) f |= 1024;
    o.write_shift(4, f);
    o.write_shift(4, 0);
    if (!b5) o.write_shift(4, 0);
    o.write_shift(2, 0);
    return o;
  }
  function parse_BIFF2XF(blob) {
    var o = {};
    o.ifnt = blob.read_shift(1);
    blob.l++;
    o.flags = blob.read_shift(1);
    o.numFmtId = o.flags & 63;
    o.flags >>= 6;
    o.fStyle = 0;
    o.data = {};
    return o;
  }
  function write_BIFF2XF(xf) {
    var o = new_buf(4);
    o.l += 2;
    o.write_shift(1, xf.numFmtId);
    o.l++;
    return o;
  }
  function write_BIFF3XF(xf) {
    var o = new_buf(12);
    o.l++;
    o.write_shift(1, xf.numFmtId);
    o.l += 10;
    return o;
  }
  var write_BIFF4XF = write_BIFF3XF;
  function parse_BIFF3XF(blob) {
    var o = {};
    o.ifnt = blob.read_shift(1);
    o.numFmtId = blob.read_shift(1);
    o.flags = blob.read_shift(2);
    o.fStyle = o.flags >> 2 & 1;
    o.data = {};
    return o;
  }
  function parse_BIFF4XF(blob) {
    var o = {};
    o.ifnt = blob.read_shift(1);
    o.numFmtId = blob.read_shift(1);
    o.flags = blob.read_shift(2);
    o.fStyle = o.flags >> 2 & 1;
    o.data = {};
    return o;
  }
  function parse_Guts(blob) {
    blob.l += 4;
    var out = [blob.read_shift(2), blob.read_shift(2)];
    if (out[0] !== 0) out[0]--;
    if (out[1] !== 0) out[1]--;
    if (out[0] > 7 || out[1] > 7) throw new Error("Bad Gutters: " + out.join("|"));
    return out;
  }
  function write_Guts(guts) {
    var o = new_buf(8);
    o.write_shift(4, 0);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    return o;
  }
  function parse_BoolErr(blob, length, opts) {
    var cell = parse_XLSCell(blob, 6, opts);
    var val2 = parse_Bes(blob);
    cell.val = val2;
    cell.t = val2 === true || val2 === false ? "b" : "e";
    return cell;
  }
  function write_BoolErr(R, C, v, os, opts, t) {
    var o = new_buf(8);
    write_XLSCell(R, C, os, o);
    write_Bes(v, t, o);
    return o;
  }
  function parse_Number(blob, length, opts) {
    if (opts.biffguess && opts.biff == 2) opts.biff = 5;
    var cell = parse_XLSCell(blob, 6, opts);
    var xnum = parse_Xnum(blob);
    cell.val = xnum;
    return cell;
  }
  function write_Number(R, C, v, os) {
    var o = new_buf(14);
    write_XLSCell(R, C, os, o);
    write_Xnum(v, o);
    return o;
  }
  var parse_XLHeaderFooter = parse_OptXLUnicodeString;
  function parse_SupBook(blob, length, opts) {
    var end = blob.l + length;
    var ctab = blob.read_shift(2);
    var cch = blob.read_shift(2);
    opts.sbcch = cch;
    if (cch == 1025 || cch == 14849) return [cch, ctab];
    if (cch < 1 || cch > 255) throw new Error("Unexpected SupBook type: " + cch);
    var virtPath = parse_XLUnicodeStringNoCch(blob, cch);
    var rgst = [];
    while (end > blob.l) rgst.push(parse_XLUnicodeString(blob));
    return [cch, ctab, virtPath, rgst];
  }
  function parse_ExternName(blob, length, opts) {
    var flags = blob.read_shift(2);
    var body;
    var o = {
      fBuiltIn: flags & 1,
      fWantAdvise: flags >>> 1 & 1,
      fWantPict: flags >>> 2 & 1,
      fOle: flags >>> 3 & 1,
      fOleLink: flags >>> 4 & 1,
      cf: flags >>> 5 & 1023,
      fIcon: flags >>> 15 & 1
    };
    if (opts.sbcch === 14849) body = parse_AddinUdf(blob, length - 2, opts);
    o.body = body || blob.read_shift(length - 2);
    if (typeof body === "string") o.Name = body;
    return o;
  }
  function parse_Lbl(blob, length, opts) {
    var target = blob.l + length;
    var flags = blob.read_shift(2);
    var chKey = blob.read_shift(1);
    var cch = blob.read_shift(1);
    var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
    var itab = 0;
    if (!opts || opts.biff >= 5) {
      if (opts.biff != 5) blob.l += 2;
      itab = blob.read_shift(2);
      if (opts.biff == 5) blob.l += 2;
      blob.l += 4;
    }
    var name = parse_XLUnicodeStringNoCch(blob, cch, opts);
    if (flags & 32) name = XLSLblBuiltIn[name.charCodeAt(0)];
    var npflen = target - blob.l;
    if (opts && opts.biff == 2) --npflen;
    var rgce = target == blob.l || cce === 0 || !(npflen > 0) ? [] : parse_NameParsedFormula(blob, npflen, opts, cce);
    return {
      chKey,
      Name: name,
      itab,
      rgce
    };
  }
  function parse_ExternSheet(blob, length, opts) {
    if (opts.biff < 8) return parse_BIFF5ExternSheet(blob, length, opts);
    if (!(opts.biff > 8) && length == blob[blob.l] + (blob[blob.l + 1] == 3 ? 1 : 0) + 1) return parse_BIFF5ExternSheet(blob, length, opts);
    var o = [], target = blob.l + length, len = blob.read_shift(opts.biff > 8 ? 4 : 2);
    while (len-- !== 0) o.push(parse_XTI(blob, opts.biff > 8 ? 12 : 6, opts));
    if (blob.l != target) throw new Error("Bad ExternSheet: " + blob.l + " != " + target);
    return o;
  }
  function parse_BIFF5ExternSheet(blob, length, opts) {
    if (blob[blob.l + 1] == 3) blob[blob.l]++;
    var o = parse_ShortXLUnicodeString(blob, length, opts);
    return o.charCodeAt(0) == 3 ? o.slice(1) : o;
  }
  function parse_NameCmt(blob, length, opts) {
    if (opts.biff < 8) {
      blob.l += length;
      return;
    }
    var cchName = blob.read_shift(2);
    var cchComment = blob.read_shift(2);
    var name = parse_XLUnicodeStringNoCch(blob, cchName, opts);
    var comment = parse_XLUnicodeStringNoCch(blob, cchComment, opts);
    return [name, comment];
  }
  function parse_ShrFmla(blob, length, opts) {
    var ref2 = parse_RefU(blob);
    blob.l++;
    var cUse = blob.read_shift(1);
    length -= 8;
    return [parse_SharedParsedFormula(blob, length, opts), cUse, ref2];
  }
  function parse_Array(blob, length, opts) {
    var ref2 = parse_Ref(blob);
    switch (opts.biff) {
      case 2:
        blob.l++;
        length -= 7;
        break;
      case 3:
      case 4:
        blob.l += 2;
        length -= 8;
        break;
      default:
        blob.l += 6;
        length -= 12;
    }
    return [ref2, parse_ArrayParsedFormula(blob, length, opts)];
  }
  function parse_MTRSettings(blob) {
    var fMTREnabled = blob.read_shift(4) !== 0;
    var fUserSetThreadCount = blob.read_shift(4) !== 0;
    var cUserThreadCount = blob.read_shift(4);
    return [fMTREnabled, fUserSetThreadCount, cUserThreadCount];
  }
  function parse_NoteSh(blob, length, opts) {
    var row = blob.read_shift(2), col = blob.read_shift(2);
    var flags = blob.read_shift(2), idObj = blob.read_shift(2);
    var stAuthor = parse_XLUnicodeString2(blob, 0, opts);
    return [{ r: row, c: col }, stAuthor, idObj, flags];
  }
  function parse_Note(blob, length, opts) {
    if (opts && opts.biff < 8) {
      var row = blob.read_shift(2), col = blob.read_shift(2);
      if (row == 65535 || row == -1) return;
      var cch = blob.read_shift(2);
      var cmnt = blob.read_shift(Math.min(cch, 2048), "cpstr");
      return [{ r: row, c: col }, cmnt];
    }
    return parse_NoteSh(blob, length, opts);
  }
  function write_NOTE_BIFF2(text, R, C, len) {
    var o = new_buf(6 + (len || text.length));
    o.write_shift(2, R);
    o.write_shift(2, C);
    o.write_shift(2, len || text.length);
    o.write_shift(text.length, text, "sbcs");
    return o;
  }
  function parse_MergeCells(blob, length) {
    var merges = [];
    var cmcs = blob.read_shift(2);
    while (cmcs--) merges.push(parse_Ref8U(blob));
    return merges;
  }
  function write_MergeCells(merges) {
    var o = new_buf(2 + merges.length * 8);
    o.write_shift(2, merges.length);
    for (var i = 0; i < merges.length; ++i) write_Ref8U(merges[i], o);
    return o;
  }
  function parse_Obj(blob, length, opts) {
    if (opts && opts.biff < 8) return parse_BIFF5Obj(blob, length, opts);
    var cmo = parse_FtCmo(blob);
    var fts = parse_FtArray(blob, length - 22, cmo[1]);
    return { cmo, ft: fts };
  }
  var parse_BIFF5OT = {
    8: function(blob, length) {
      var tgt = blob.l + length;
      blob.l += 10;
      var cf = blob.read_shift(2);
      blob.l += 4;
      blob.l += 2;
      blob.l += 2;
      blob.l += 2;
      blob.l += 4;
      var cchName = blob.read_shift(1);
      blob.l += cchName;
      blob.l = tgt;
      return { fmt: cf };
    }
  };
  function parse_BIFF5Obj(blob, length, opts) {
    blob.l += 4;
    var ot = blob.read_shift(2);
    var id = blob.read_shift(2);
    var grbit = blob.read_shift(2);
    blob.l += 2;
    blob.l += 2;
    blob.l += 2;
    blob.l += 2;
    blob.l += 2;
    blob.l += 2;
    blob.l += 2;
    blob.l += 2;
    blob.l += 2;
    blob.l += 6;
    length -= 36;
    var fts = [];
    fts.push((parse_BIFF5OT[ot] || parsenoop)(blob, length, opts));
    return { cmo: [id, ot, grbit], ft: fts };
  }
  function parse_TxO(blob, length, opts) {
    var s = blob.l;
    var texts = "";
    try {
      blob.l += 4;
      var ot = (opts.lastobj || { cmo: [0, 0] }).cmo[1];
      var controlInfo;
      if ([0, 5, 7, 11, 12, 14].indexOf(ot) == -1) blob.l += 6;
      else controlInfo = parse_ControlInfo(blob, 6, opts);
      var cchText = blob.read_shift(2);
      blob.read_shift(2);
      parseuint16(blob, 2);
      var len = blob.read_shift(2);
      blob.l += len;
      for (var i = 1; i < blob.lens.length - 1; ++i) {
        if (blob.l - s != blob.lens[i]) throw new Error("TxO: bad continue record");
        var hdr = blob[blob.l];
        var t = parse_XLUnicodeStringNoCch(blob, blob.lens[i + 1] - blob.lens[i] - 1);
        texts += t;
        if (texts.length >= (hdr ? cchText : 2 * cchText)) break;
      }
      if (texts.length !== cchText && texts.length !== cchText * 2) {
        throw new Error("cchText: " + cchText + " != " + texts.length);
      }
      blob.l = s + length;
      return { t: texts };
    } catch (e) {
      blob.l = s + length;
      return { t: texts };
    }
  }
  function parse_HLink(blob, length) {
    var ref2 = parse_Ref8U(blob);
    blob.l += 16;
    var hlink = parse_Hyperlink(blob, length - 24);
    return [ref2, hlink];
  }
  function write_HLink(hl) {
    var O = new_buf(24);
    var ref2 = decode_cell(hl[0]);
    O.write_shift(2, ref2.r);
    O.write_shift(2, ref2.r);
    O.write_shift(2, ref2.c);
    O.write_shift(2, ref2.c);
    var clsid = "d0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
    for (var i = 0; i < 16; ++i) O.write_shift(1, parseInt(clsid[i], 16));
    return bconcat([O, write_Hyperlink(hl[1])]);
  }
  function parse_HLinkTooltip(blob, length) {
    blob.read_shift(2);
    var ref2 = parse_Ref8U(blob);
    var wzTooltip = blob.read_shift((length - 10) / 2, "dbcs-cont");
    wzTooltip = wzTooltip.replace(chr0, "");
    return [ref2, wzTooltip];
  }
  function write_HLinkTooltip(hl) {
    var TT = hl[1].Tooltip;
    var O = new_buf(10 + 2 * (TT.length + 1));
    O.write_shift(2, 2048);
    var ref2 = decode_cell(hl[0]);
    O.write_shift(2, ref2.r);
    O.write_shift(2, ref2.r);
    O.write_shift(2, ref2.c);
    O.write_shift(2, ref2.c);
    for (var i = 0; i < TT.length; ++i) O.write_shift(2, TT.charCodeAt(i));
    O.write_shift(2, 0);
    return O;
  }
  function parse_Country(blob) {
    var o = [0, 0], d;
    d = blob.read_shift(2);
    o[0] = CountryEnum[d] || d;
    d = blob.read_shift(2);
    o[1] = CountryEnum[d] || d;
    return o;
  }
  function write_Country(o) {
    if (!o) o = new_buf(4);
    o.write_shift(2, 1);
    o.write_shift(2, 1);
    return o;
  }
  function parse_ClrtClient(blob) {
    var ccv = blob.read_shift(2);
    var o = [];
    while (ccv-- > 0) o.push(parse_LongRGB(blob));
    return o;
  }
  function parse_Palette(blob) {
    var ccv = blob.read_shift(2);
    var o = [];
    while (ccv-- > 0) o.push(parse_LongRGB(blob));
    return o;
  }
  function parse_XFCRC(blob) {
    blob.l += 2;
    var o = { cxfs: 0, crc: 0 };
    o.cxfs = blob.read_shift(2);
    o.crc = blob.read_shift(4);
    return o;
  }
  function parse_ColInfo(blob, length, opts) {
    if (!opts.cellStyles) return parsenoop(blob, length);
    var w = opts && opts.biff >= 12 ? 4 : 2;
    var colFirst = blob.read_shift(w);
    var colLast = blob.read_shift(w);
    var coldx = blob.read_shift(w);
    var ixfe = blob.read_shift(w);
    var flags = blob.read_shift(2);
    if (w == 2) blob.l += 2;
    var o = { s: colFirst, e: colLast, w: coldx, ixfe, flags };
    if (opts.biff >= 5 || !opts.biff) o.level = flags >> 8 & 7;
    return o;
  }
  function write_ColInfo(col, idx) {
    var o = new_buf(12);
    o.write_shift(2, idx);
    o.write_shift(2, idx);
    o.write_shift(2, col.width * 256);
    o.write_shift(2, 0);
    var f = 0;
    if (col.hidden) f |= 1;
    o.write_shift(1, f);
    f = col.level || 0;
    o.write_shift(1, f);
    o.write_shift(2, 0);
    return o;
  }
  function parse_Setup(blob, length) {
    var o = {};
    if (length < 32) return o;
    blob.l += 16;
    o.header = parse_Xnum(blob);
    o.footer = parse_Xnum(blob);
    blob.l += 2;
    return o;
  }
  function parse_ShtProps(blob, length, opts) {
    var def2 = { area: false };
    if (opts.biff != 5) {
      blob.l += length;
      return def2;
    }
    var d = blob.read_shift(1);
    blob.l += 3;
    if (d & 16) def2.area = true;
    return def2;
  }
  function write_RRTabId(n) {
    var out = new_buf(2 * n);
    for (var i = 0; i < n; ++i) out.write_shift(2, i + 1);
    return out;
  }
  var parse_Blank = parse_XLSCell;
  var parse_Scl = parseuint16a;
  var parse_String = parse_XLUnicodeString;
  function parse_ImData(blob) {
    var cf = blob.read_shift(2);
    var env = blob.read_shift(2);
    var lcb = blob.read_shift(4);
    var o = { fmt: cf, env, len: lcb, data: blob.slice(blob.l, blob.l + lcb) };
    blob.l += lcb;
    return o;
  }
  function write_BIFF2Cell(out, r2, c, ixfe, ifmt) {
    if (!out) out = new_buf(7);
    out.write_shift(2, r2);
    out.write_shift(2, c);
    out.write_shift(
      1,
      ixfe || 0
);
    out.write_shift(
      1,
      ifmt || 0
);
    out.write_shift(1, 0);
    return out;
  }
  function parse_BIFF2STR(blob, length, opts) {
    if (opts.biffguess && opts.biff == 5) opts.biff = 2;
    var cell = parse_XLSCell(blob, 7, opts);
    var str = parse_XLUnicodeString2(blob, length - 7, opts);
    cell.t = "str";
    cell.val = str;
    return cell;
  }
  function parse_BIFF2NUM(blob, length, opts) {
    var cell = parse_XLSCell(blob, 7, opts);
    var num = parse_Xnum(blob);
    cell.t = "n";
    cell.val = num;
    return cell;
  }
  function write_BIFF2NUM(r2, c, val2, ixfe, ifmt) {
    var out = new_buf(15);
    write_BIFF2Cell(out, r2, c, ixfe || 0, ifmt || 0);
    out.write_shift(8, val2, "f");
    return out;
  }
  function parse_BIFF2INT(blob, length, opts) {
    var cell = parse_XLSCell(blob, 7, opts);
    var num = blob.read_shift(2);
    cell.t = "n";
    cell.val = num;
    return cell;
  }
  function write_BIFF2INT(r2, c, val2, ixfe, ifmt) {
    var out = new_buf(9);
    write_BIFF2Cell(out, r2, c, ixfe || 0, ifmt || 0);
    out.write_shift(2, val2);
    return out;
  }
  function parse_BIFF2STRING(blob) {
    var cch = blob.read_shift(1);
    if (cch === 0) {
      blob.l++;
      return "";
    }
    return blob.read_shift(cch, "sbcs-cont");
  }
  function parse_BIFF2BOOLERR(blob, length, opts) {
    var bestart = blob.l + 7;
    var cell = parse_XLSCell(blob, 6, opts);
    blob.l = bestart;
    var val2 = parse_Bes(blob);
    cell.val = val2;
    cell.t = val2 === true || val2 === false ? "b" : "e";
    return cell;
  }
  function parse_BIFF2FONTXTRA(blob, length) {
    blob.l += 6;
    blob.l += 2;
    blob.l += 1;
    blob.l += 3;
    blob.l += 1;
    blob.l += length - 13;
  }
  function parse_RString(blob, length, opts) {
    var end = blob.l + length;
    var cell = parse_XLSCell(blob, 6, opts);
    var cch = blob.read_shift(2);
    var str = parse_XLUnicodeStringNoCch(blob, cch, opts);
    blob.l = end;
    cell.t = "str";
    cell.val = str;
    return cell;
  }
  function parse_BIFF4SheetInfo(blob) {
    var flags = blob.read_shift(4);
    var cch = blob.read_shift(1), name = blob.read_shift(cch, "sbcs");
    if (name.length === 0) name = "Sheet1";
    return { flags, name };
  }
  var DBF_SUPPORTED_VERSIONS = [2, 3, 48, 49, 131, 139, 140, 245];
  var DBF = (function() {
    var dbf_codepage_map = {
1: 437,
      2: 850,
      3: 1252,
      4: 1e4,
      100: 852,
      101: 866,
      102: 865,
      103: 861,
      104: 895,
      105: 620,
      106: 737,
      107: 857,
      120: 950,
      121: 949,
      122: 936,
      123: 932,
      124: 874,
      125: 1255,
      126: 1256,
      150: 10007,
      151: 10029,
      152: 10006,
      200: 1250,
      201: 1251,
      202: 1254,
      203: 1253,
0: 20127,
      8: 865,
      9: 437,
      10: 850,
      11: 437,
      13: 437,
      14: 850,
      15: 437,
      16: 850,
      17: 437,
      18: 850,
      19: 932,
      20: 850,
      21: 437,
      22: 850,
      23: 865,
      24: 437,
      25: 437,
      26: 850,
      27: 437,
      28: 863,
      29: 850,
      31: 852,
      34: 852,
      35: 852,
      36: 860,
      37: 850,
      38: 866,
      55: 850,
      64: 852,
      77: 936,
      78: 949,
      79: 950,
      80: 874,
      87: 1252,
      88: 1252,
      89: 1252,
      108: 863,
      134: 737,
      135: 852,
      136: 857,
      204: 1257,
      255: 16969
    };
    var dbf_reverse_map = evert({
      1: 437,
      2: 850,
      3: 1252,
      4: 1e4,
      100: 852,
      101: 866,
      102: 865,
      103: 861,
      104: 895,
      105: 620,
      106: 737,
      107: 857,
      120: 950,
      121: 949,
      122: 936,
      123: 932,
      124: 874,
      125: 1255,
      126: 1256,
      150: 10007,
      151: 10029,
      152: 10006,
      200: 1250,
      201: 1251,
      202: 1254,
      203: 1253,
      0: 20127
    });
    function dbf_to_aoa(buf, opts) {
      var out = [];
      var d = new_raw_buf(1);
      switch (opts.type) {
        case "base64":
          d = s2a(Base64_decode(buf));
          break;
        case "binary":
          d = s2a(buf);
          break;
        case "buffer":
        case "array":
          d = buf;
          break;
      }
      prep_blob(d, 0);
      var ft = d.read_shift(1);
      var memo = !!(ft & 136);
      var vfp = false, l7 = false;
      switch (ft) {
        case 2:
          break;
case 3:
          break;
case 48:
          vfp = true;
          memo = true;
          break;
case 49:
          vfp = true;
          memo = true;
          break;


case 131:
          break;
case 139:
          break;
case 140:
          l7 = true;
          break;

case 245:
          break;

default:
          throw new Error("DBF Unsupported Version: " + ft.toString(16));
      }
      var nrow = 0, fpos = 521;
      if (ft == 2) nrow = d.read_shift(2);
      d.l += 3;
      if (ft != 2) nrow = d.read_shift(4);
      if (nrow > 1048576) nrow = 1e6;
      if (ft != 2) fpos = d.read_shift(2);
      var rlen = d.read_shift(2);
      var current_cp = opts.codepage || 1252;
      if (ft != 2) {
        d.l += 16;
        d.read_shift(1);
        if (d[d.l] !== 0) current_cp = dbf_codepage_map[d[d.l]];
        d.l += 1;
        d.l += 2;
      }
      if (l7) d.l += 36;
      var fields = [], field = {};
      var hend = Math.min(d.length, ft == 2 ? 521 : fpos - 10 - (vfp ? 264 : 0));
      var ww = l7 ? 32 : 11;
      while (d.l < hend && d[d.l] != 13) {
        field = {};
        field.name = (typeof $cptable !== "undefined" ? $cptable.utils.decode(current_cp, d.slice(d.l, d.l + ww)) : a2s(d.slice(d.l, d.l + ww))).replace(/[\u0000\r\n][\S\s]*$/g, "");
        d.l += ww;
        field.type = String.fromCharCode(d.read_shift(1));
        if (ft != 2 && !l7) field.offset = d.read_shift(4);
        field.len = d.read_shift(1);
        if (ft == 2) field.offset = d.read_shift(2);
        field.dec = d.read_shift(1);
        if (field.name.length) fields.push(field);
        if (ft != 2) d.l += l7 ? 13 : 14;
        switch (field.type) {
          case "B":
            if ((!vfp || field.len != 8) && opts.WTF) console.log("Skipping " + field.name + ":" + field.type);
            break;
          case "G":
case "P":
            if (opts.WTF) console.log("Skipping " + field.name + ":" + field.type);
            break;
          case "+":
case "0":
case "@":
case "C":
case "D":
case "F":
case "I":
case "L":
case "M":
case "N":
case "O":
case "T":
case "Y":
            break;
          default:
            throw new Error("Unknown Field Type: " + field.type);
        }
      }
      if (d[d.l] !== 13) d.l = fpos - 1;
      if (d.read_shift(1) !== 13) throw new Error("DBF Terminator not found " + d.l + " " + d[d.l]);
      d.l = fpos;
      var R = 0, C = 0;
      out[0] = [];
      for (C = 0; C != fields.length; ++C) out[0][C] = fields[C].name;
      while (nrow-- > 0) {
        if (d[d.l] === 42) {
          d.l += rlen;
          continue;
        }
        ++d.l;
        out[++R] = [];
        C = 0;
        for (C = 0; C != fields.length; ++C) {
          var dd = d.slice(d.l, d.l + fields[C].len);
          d.l += fields[C].len;
          prep_blob(dd, 0);
          var s = typeof $cptable !== "undefined" ? $cptable.utils.decode(current_cp, dd) : a2s(dd);
          switch (fields[C].type) {
            case "C":
              if (s.trim().length) out[R][C] = s.replace(/([^\s])\s+$/, "$1");
              break;
            case "D":
              if (s.length === 8) {
                out[R][C] = new Date(Date.UTC(+s.slice(0, 4), +s.slice(4, 6) - 1, +s.slice(6, 8), 0, 0, 0, 0));
                if (!(opts && opts.UTC)) {
                  out[R][C] = utc_to_local(out[R][C]);
                }
              } else out[R][C] = s;
              break;
            case "F":
              out[R][C] = parseFloat(s.trim());
              break;
            case "+":
            case "I":
              out[R][C] = l7 ? dd.read_shift(-4, "i") ^ 2147483648 : dd.read_shift(4, "i");
              break;
            case "L":
              switch (s.trim().toUpperCase()) {
                case "Y":
                case "T":
                  out[R][C] = true;
                  break;
                case "N":
                case "F":
                  out[R][C] = false;
                  break;
                case "":
                case "\0":
                case "?":
                  break;
                default:
                  throw new Error("DBF Unrecognized L:|" + s + "|");
              }
              break;
            case "M":
              if (!memo) throw new Error("DBF Unexpected MEMO for type " + ft.toString(16));
              out[R][C] = "##MEMO##" + (l7 ? parseInt(s.trim(), 10) : dd.read_shift(4));
              break;
            case "N":
              s = s.replace(/\u0000/g, "").trim();
              if (s && s != ".") out[R][C] = +s || 0;
              break;
            case "@":
              out[R][C] = new Date(dd.read_shift(-8, "f") - 621356832e5);
              break;
            case "T":
              {
                var hi = dd.read_shift(4), lo = dd.read_shift(4);
                if (hi == 0 && lo == 0) break;
                out[R][C] = new Date((hi - 2440588) * 864e5 + lo);
                if (!(opts && opts.UTC)) out[R][C] = utc_to_local(out[R][C]);
              }
              break;
            case "Y":
              out[R][C] = dd.read_shift(4, "i") / 1e4 + dd.read_shift(4, "i") / 1e4 * Math.pow(2, 32);
              break;
            case "O":
              out[R][C] = -dd.read_shift(-8, "f");
              break;
            case "B":
              if (vfp && fields[C].len == 8) {
                out[R][C] = dd.read_shift(8, "f");
                break;
              }
case "G":
            case "P":
              dd.l += fields[C].len;
              break;
            case "0":
              if (fields[C].name === "_NullFlags") break;
default:
              throw new Error("DBF Unsupported data type " + fields[C].type);
          }
        }
      }
      if (ft != 2) {
        if (d.l < d.length && d[d.l++] != 26) throw new Error("DBF EOF Marker missing " + (d.l - 1) + " of " + d.length + " " + d[d.l - 1].toString(16));
      }
      if (opts && opts.sheetRows) out = out.slice(0, opts.sheetRows);
      opts.DBF = fields;
      return out;
    }
    function dbf_to_sheet(buf, opts) {
      var o = opts || {};
      if (!o.dateNF) o.dateNF = "yyyymmdd";
      var ws = aoa_to_sheet(dbf_to_aoa(buf, o), o);
      ws["!cols"] = o.DBF.map(function(field) {
        return {
          wch: field.len,
          DBF: field
        };
      });
      delete o.DBF;
      return ws;
    }
    function dbf_to_workbook(buf, opts) {
      try {
        var o = sheet_to_workbook(dbf_to_sheet(buf, opts), opts);
        o.bookType = "dbf";
        return o;
      } catch (e) {
        if (opts && opts.WTF) throw e;
      }
      return { SheetNames: [], Sheets: {} };
    }
    var _RLEN = { "B": 8, "C": 250, "L": 1, "D": 8, "?": 0, "": 0 };
    function sheet_to_dbf(ws, opts) {
      if (!ws["!ref"]) throw new Error("Cannot export empty sheet to DBF");
      var o = opts || {};
      var old_cp = current_codepage;
      if (+o.codepage >= 0) set_cp(+o.codepage);
      if (o.type == "string") throw new Error("Cannot write DBF to JS string");
      var ba = buf_array();
      var aoa = sheet_to_json(ws, { header: 1, raw: true, cellDates: true });
      var headers = aoa[0], data = aoa.slice(1), cols = ws["!cols"] || [];
      var i = 0, j = 0, hcnt = 0, rlen = 1;
      for (i = 0; i < headers.length; ++i) {
        if (((cols[i] || {}).DBF || {}).name) {
          headers[i] = cols[i].DBF.name;
          ++hcnt;
          continue;
        }
        if (headers[i] == null) continue;
        ++hcnt;
        if (typeof headers[i] === "number") headers[i] = headers[i].toString(10);
        if (typeof headers[i] !== "string") throw new Error("DBF Invalid column name " + headers[i] + " |" + typeof headers[i] + "|");
        if (headers.indexOf(headers[i]) !== i) {
          for (j = 0; j < 1024; ++j)
            if (headers.indexOf(headers[i] + "_" + j) == -1) {
              headers[i] += "_" + j;
              break;
            }
        }
      }
      var range = safe_decode_range(ws["!ref"]);
      var coltypes = [];
      var colwidths = [];
      var coldecimals = [];
      for (i = 0; i <= range.e.c - range.s.c; ++i) {
        var guess = "", _guess = "", maxlen = 0;
        var col = [];
        for (j = 0; j < data.length; ++j) {
          if (data[j][i] != null) col.push(data[j][i]);
        }
        if (col.length == 0 || headers[i] == null) {
          coltypes[i] = "?";
          continue;
        }
        for (j = 0; j < col.length; ++j) {
          switch (typeof col[j]) {
case "number":
              _guess = "B";
              break;
            case "string":
              _guess = "C";
              break;
            case "boolean":
              _guess = "L";
              break;
            case "object":
              _guess = col[j] instanceof Date ? "D" : "C";
              break;
            default:
              _guess = "C";
          }
          maxlen = Math.max(maxlen, (typeof $cptable !== "undefined" && typeof col[j] == "string" ? $cptable.utils.encode(current_ansi, col[j]) : String(col[j])).length);
          guess = guess && guess != _guess ? "C" : _guess;
        }
        if (maxlen > 250) maxlen = 250;
        _guess = ((cols[i] || {}).DBF || {}).type;
        if (_guess == "C") {
          if (cols[i].DBF.len > maxlen) maxlen = cols[i].DBF.len;
        }
        if (guess == "B" && _guess == "N") {
          guess = "N";
          coldecimals[i] = cols[i].DBF.dec;
          maxlen = cols[i].DBF.len;
        }
        colwidths[i] = guess == "C" || _guess == "N" ? maxlen : _RLEN[guess] || 0;
        rlen += colwidths[i];
        coltypes[i] = guess;
      }
      var h2 = ba.next(32);
      h2.write_shift(4, 318902576);
      h2.write_shift(4, data.length);
      h2.write_shift(2, 296 + 32 * hcnt);
      h2.write_shift(2, rlen);
      for (i = 0; i < 4; ++i) h2.write_shift(4, 0);
      var cp = +dbf_reverse_map[
current_codepage
] || 3;
      h2.write_shift(4, 0 | cp << 8);
      if (dbf_codepage_map[cp] != +o.codepage) {
        if (o.codepage) console.error("DBF Unsupported codepage " + current_codepage + ", using 1252");
        current_codepage = 1252;
      }
      for (i = 0, j = 0; i < headers.length; ++i) {
        if (headers[i] == null) continue;
        var hf = ba.next(32);
        var _f = (headers[i].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
        hf.write_shift(1, _f, "sbcs");
        hf.write_shift(1, coltypes[i] == "?" ? "C" : coltypes[i], "sbcs");
        hf.write_shift(4, j);
        hf.write_shift(1, colwidths[i] || _RLEN[coltypes[i]] || 0);
        hf.write_shift(1, coldecimals[i] || 0);
        hf.write_shift(1, 2);
        hf.write_shift(4, 0);
        hf.write_shift(1, 0);
        hf.write_shift(4, 0);
        hf.write_shift(4, 0);
        j += colwidths[i] || _RLEN[coltypes[i]] || 0;
      }
      var hb = ba.next(264);
      hb.write_shift(4, 13);
      for (i = 0; i < 65; ++i) hb.write_shift(4, 0);
      for (i = 0; i < data.length; ++i) {
        var rout = ba.next(rlen);
        rout.write_shift(1, 0);
        for (j = 0; j < headers.length; ++j) {
          if (headers[j] == null) continue;
          switch (coltypes[j]) {
            case "L":
              rout.write_shift(1, data[i][j] == null ? 63 : data[i][j] ? 84 : 70);
              break;
            case "B":
              rout.write_shift(8, data[i][j] || 0, "f");
              break;
            case "N":
              var _n = "0";
              if (typeof data[i][j] == "number") _n = data[i][j].toFixed(coldecimals[j] || 0);
              if (_n.length > colwidths[j]) _n = _n.slice(0, colwidths[j]);
              for (hcnt = 0; hcnt < colwidths[j] - _n.length; ++hcnt) rout.write_shift(1, 32);
              rout.write_shift(1, _n, "sbcs");
              break;
            case "D":
              if (!data[i][j]) rout.write_shift(8, "00000000", "sbcs");
              else {
                rout.write_shift(4, ("0000" + data[i][j].getFullYear()).slice(-4), "sbcs");
                rout.write_shift(2, ("00" + (data[i][j].getMonth() + 1)).slice(-2), "sbcs");
                rout.write_shift(2, ("00" + data[i][j].getDate()).slice(-2), "sbcs");
              }
              break;
            case "C":
              var _l = rout.l;
              var _s = String(data[i][j] != null ? data[i][j] : "").slice(0, colwidths[j]);
              rout.write_shift(1, _s, "cpstr");
              _l += colwidths[j] - rout.l;
              for (hcnt = 0; hcnt < _l; ++hcnt) rout.write_shift(1, 32);
              break;
          }
        }
      }
      current_codepage = old_cp;
      ba.next(1).write_shift(1, 26);
      return ba.end();
    }
    return {
      to_workbook: dbf_to_workbook,
      to_sheet: dbf_to_sheet,
      from_sheet: sheet_to_dbf
    };
  })();
  var SYLK = (function() {
    var sylk_escapes = {
      AA: "À",
      BA: "Á",
      CA: "Â",
      DA: 195,
      HA: "Ä",
      JA: 197,
      AE: "È",
      BE: "É",
      CE: "Ê",
      HE: "Ë",
      AI: "Ì",
      BI: "Í",
      CI: "Î",
      HI: "Ï",
      AO: "Ò",
      BO: "Ó",
      CO: "Ô",
      DO: 213,
      HO: "Ö",
      AU: "Ù",
      BU: "Ú",
      CU: "Û",
      HU: "Ü",
      Aa: "à",
      Ba: "á",
      Ca: "â",
      Da: 227,
      Ha: "ä",
      Ja: 229,
      Ae: "è",
      Be: "é",
      Ce: "ê",
      He: "ë",
      Ai: "ì",
      Bi: "í",
      Ci: "î",
      Hi: "ï",
      Ao: "ò",
      Bo: "ó",
      Co: "ô",
      Do: 245,
      Ho: "ö",
      Au: "ù",
      Bu: "ú",
      Cu: "û",
      Hu: "ü",
      KC: "Ç",
      Kc: "ç",
      q: "æ",
      z: "œ",
      a: "Æ",
      j: "Œ",
      DN: 209,
      Dn: 241,
      Hy: 255,
      S: 169,
      c: 170,
      R: 174,
      "B ": 180,
      0: 176,
      1: 177,
      2: 178,
      3: 179,
      5: 181,
      6: 182,
      7: 183,
      Q: 185,
      k: 186,
      b: 208,
      i: 216,
      l: 222,
      s: 240,
      y: 248,
      "!": 161,
      '"': 162,
      "#": 163,
      "(": 164,
      "%": 165,
      "'": 167,
      "H ": 168,
      "+": 171,
      ";": 187,
      "<": 188,
      "=": 189,
      ">": 190,
      "?": 191,
      "{": 223
    };
    var sylk_char_regex = new RegExp("\x1BN(" + keys(sylk_escapes).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1").replace("{", "\\{") + "|\\|)", "gm");
    try {
      sylk_char_regex = new RegExp("\x1BN(" + keys(sylk_escapes).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1") + "|\\|)", "gm");
    } catch (e) {
    }
    var sylk_char_fn = function(_, $1) {
      var o = sylk_escapes[$1];
      return typeof o == "number" ? _getansi(o) : o;
    };
    var decode_sylk_char = function($$, $1, $2) {
      var newcc = $1.charCodeAt(0) - 32 << 4 | $2.charCodeAt(0) - 48;
      return newcc == 59 ? $$ : _getansi(newcc);
    };
    sylk_escapes["|"] = 254;
    var encode_sylk_str = function($$) {
      return $$.replace(/\n/g, "\x1B :").replace(/\r/g, "\x1B =");
    };
    function sylk_to_aoa(d, opts) {
      switch (opts.type) {
        case "base64":
          return sylk_to_aoa_str(Base64_decode(d), opts);
        case "binary":
          return sylk_to_aoa_str(d, opts);
        case "buffer":
          return sylk_to_aoa_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
        case "array":
          return sylk_to_aoa_str(cc2str(d), opts);
      }
      throw new Error("Unrecognized type " + opts.type);
    }
    function sylk_to_aoa_str(str, opts) {
      var records = str.split(/[\n\r]+/), R = -1, C = -1, ri = 0, rj = 0, arr = [];
      var formats = [];
      var next_cell_format = null;
      var sht = {}, rowinfo = [], colinfo = [], cw = [];
      var Mval = 0, j;
      var wb = { Workbook: { WBProps: {}, Names: [] } };
      if (+opts.codepage >= 0) set_cp(+opts.codepage);
      for (; ri !== records.length; ++ri) {
        Mval = 0;
        var rstr = records[ri].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, decode_sylk_char).replace(sylk_char_regex, sylk_char_fn);
        var record = rstr.replace(/;;/g, "\0").split(";").map(function(x) {
          return x.replace(/\u0000/g, ";");
        });
        var RT = record[0], val2;
        if (rstr.length > 0) switch (RT) {
          case "ID":
            break;
case "E":
            break;
case "B":
            break;
case "O":
            for (rj = 1; rj < record.length; ++rj) switch (record[rj].charAt(0)) {
              case "V":
                {
                  var d1904 = parseInt(record[rj].slice(1), 10);
                  if (d1904 >= 1 && d1904 <= 4) wb.Workbook.WBProps.date1904 = true;
                }
                break;
            }
            break;
          case "W":
            break;
case "P":
            switch (record[1].charAt(0)) {
              case "P":
                formats.push(rstr.slice(3).replace(/;;/g, ";"));
                break;
            }
            break;
          case "NN":
            {
              var nn = { Sheet: 0 };
              for (rj = 1; rj < record.length; ++rj) switch (record[rj].charAt(0)) {
                case "N":
                  nn.Name = record[rj].slice(1);
                  break;
                case "E":
                  nn.Ref = (opts && opts.sheet || "Sheet1") + "!" + rc_to_a1(record[rj].slice(1));
                  break;
              }
              wb.Workbook.Names.push(nn);
            }
            break;

case "C":
            var C_seen_K = false, C_seen_X = false, C_seen_S = false, C_seen_E = false, _R = -1, _C = -1, formula = "", cell_t = "z";
            var cmnt = "";
            for (rj = 1; rj < record.length; ++rj) switch (record[rj].charAt(0)) {
              case "A":
                cmnt = record[rj].slice(1);
                break;
case "X":
                C = parseInt(record[rj].slice(1), 10) - 1;
                C_seen_X = true;
                break;
              case "Y":
                R = parseInt(record[rj].slice(1), 10) - 1;
                if (!C_seen_X) C = 0;
                for (j = arr.length; j <= R; ++j) arr[j] = [];
                break;
              case "K":
                val2 = record[rj].slice(1);
                if (val2.charAt(0) === '"') {
                  val2 = val2.slice(1, val2.length - 1);
                  cell_t = "s";
                } else if (val2 === "TRUE" || val2 === "FALSE") {
                  val2 = val2 === "TRUE";
                  cell_t = "b";
                } else if (val2.charAt(0) == "#" && RBErr[val2] != null) {
                  cell_t = "e";
                  val2 = RBErr[val2];
                } else if (!isNaN(fuzzynum(val2))) {
                  val2 = fuzzynum(val2);
                  cell_t = "n";
                  if (next_cell_format !== null && fmt_is_date(next_cell_format) && opts.cellDates) {
                    val2 = numdate(wb.Workbook.WBProps.date1904 ? val2 + 1462 : val2);
                    cell_t = typeof val2 == "number" ? "n" : "d";
                  }
                }
                if (typeof $cptable !== "undefined" && typeof val2 == "string" && (opts || {}).type != "string" && (opts || {}).codepage) val2 = $cptable.utils.decode(opts.codepage, val2);
                C_seen_K = true;
                break;
              case "E":
                C_seen_E = true;
                formula = rc_to_a1(record[rj].slice(1), { r: R, c: C });
                break;
              case "S":
                C_seen_S = true;
                break;
              case "G":
                break;
case "R":
                _R = parseInt(record[rj].slice(1), 10) - 1;
                break;
              case "C":
                _C = parseInt(record[rj].slice(1), 10) - 1;
                break;

default:
                if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
            }
            if (C_seen_K) {
              if (!arr[R][C]) arr[R][C] = { t: cell_t, v: val2 };
              else {
                arr[R][C].t = cell_t;
                arr[R][C].v = val2;
              }
              if (next_cell_format) arr[R][C].z = next_cell_format;
              if (opts.cellText !== false && next_cell_format) arr[R][C].w = SSF_format(arr[R][C].z, arr[R][C].v, { date1904: wb.Workbook.WBProps.date1904 });
              next_cell_format = null;
            }
            if (C_seen_S) {
              if (C_seen_E) throw new Error("SYLK shared formula cannot have own formula");
              var shrbase = _R > -1 && arr[_R][_C];
              if (!shrbase || !shrbase[1]) throw new Error("SYLK shared formula cannot find base");
              formula = shift_formula_str(shrbase[1], { r: R - _R, c: C - _C });
            }
            if (formula) {
              if (!arr[R][C]) arr[R][C] = { t: "n", f: formula };
              else arr[R][C].f = formula;
            }
            if (cmnt) {
              if (!arr[R][C]) arr[R][C] = { t: "z" };
              arr[R][C].c = [{ a: "SheetJSYLK", t: cmnt }];
            }
            break;
          case "F":
            var F_seen = 0;
            for (rj = 1; rj < record.length; ++rj) switch (record[rj].charAt(0)) {
              case "X":
                C = parseInt(record[rj].slice(1), 10) - 1;
                ++F_seen;
                break;
              case "Y":
                R = parseInt(record[rj].slice(1), 10) - 1;
                for (j = arr.length; j <= R; ++j) arr[j] = [];
                break;
              case "M":
                Mval = parseInt(record[rj].slice(1), 10) / 20;
                break;
              case "F":
                break;
case "G":
                break;
case "P":
                next_cell_format = formats[parseInt(record[rj].slice(1), 10)];
                break;
              case "S":
                break;
case "D":
                break;
case "N":
                break;
case "W":
                cw = record[rj].slice(1).split(" ");
                for (j = parseInt(cw[0], 10); j <= parseInt(cw[1], 10); ++j) {
                  Mval = parseInt(cw[2], 10);
                  colinfo[j - 1] = Mval === 0 ? { hidden: true } : { wch: Mval };
                }
                break;
              case "C":
                C = parseInt(record[rj].slice(1), 10) - 1;
                if (!colinfo[C]) colinfo[C] = {};
                break;
              case "R":
                R = parseInt(record[rj].slice(1), 10) - 1;
                if (!rowinfo[R]) rowinfo[R] = {};
                if (Mval > 0) {
                  rowinfo[R].hpt = Mval;
                  rowinfo[R].hpx = pt2px(Mval);
                } else if (Mval === 0) rowinfo[R].hidden = true;
                break;

default:
                if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
            }
            if (F_seen < 1) next_cell_format = null;
            break;
          default:
            if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
        }
      }
      if (rowinfo.length > 0) sht["!rows"] = rowinfo;
      if (colinfo.length > 0) sht["!cols"] = colinfo;
      colinfo.forEach(function(col) {
        process_col(col);
      });
      if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
      return [arr, sht, wb];
    }
    function sylk_to_workbook(d, opts) {
      var aoasht = sylk_to_aoa(d, opts);
      var aoa = aoasht[0], ws = aoasht[1], wb = aoasht[2];
      var _opts = dup(opts);
      _opts.date1904 = (((wb || {}).Workbook || {}).WBProps || {}).date1904;
      var o = aoa_to_sheet(aoa, _opts);
      keys(ws).forEach(function(k) {
        o[k] = ws[k];
      });
      var outwb = sheet_to_workbook(o, opts);
      keys(wb).forEach(function(k) {
        outwb[k] = wb[k];
      });
      outwb.bookType = "sylk";
      return outwb;
    }
    function write_ws_cell_sylk(cell, ws, R, C, opts, date1904) {
      var o = "C;Y" + (R + 1) + ";X" + (C + 1) + ";K";
      switch (cell.t) {
        case "n":
          o += isFinite(cell.v) ? cell.v || 0 : BErr[isNaN(cell.v) ? 36 : 7];
          if (cell.f && !cell.F) o += ";E" + a1_to_rc(cell.f, { r: R, c: C });
          break;
        case "b":
          o += cell.v ? "TRUE" : "FALSE";
          break;
        case "e":
          o += cell.w || BErr[cell.v] || cell.v;
          break;
        case "d":
          o += datenum(parseDate(cell.v, date1904), date1904);
          break;
        case "s":
          o += '"' + (cell.v == null ? "" : String(cell.v)).replace(/"/g, "").replace(/;/g, ";;") + '"';
          break;
      }
      return o;
    }
    function write_ws_cmnt_sylk(cmnt, R, C) {
      var o = "C;Y" + (R + 1) + ";X" + (C + 1) + ";A";
      o += encode_sylk_str(cmnt.map(function(c) {
        return c.t;
      }).join(""));
      return o;
    }
    function write_ws_cols_sylk(out, cols) {
      cols.forEach(function(col, i) {
        var rec = "F;W" + (i + 1) + " " + (i + 1) + " ";
        if (col.hidden) rec += "0";
        else {
          if (typeof col.width == "number" && !col.wpx) col.wpx = width2px(col.width);
          if (typeof col.wpx == "number" && !col.wch) col.wch = px2char(col.wpx);
          if (typeof col.wch == "number") rec += Math.round(col.wch);
        }
        if (rec.charAt(rec.length - 1) != " ") out.push(rec);
      });
    }
    function write_ws_rows_sylk(out, rows) {
      rows.forEach(function(row, i) {
        var rec = "F;";
        if (row.hidden) rec += "M0;";
        else if (row.hpt) rec += "M" + 20 * row.hpt + ";";
        else if (row.hpx) rec += "M" + 20 * px2pt(row.hpx) + ";";
        if (rec.length > 2) out.push(rec + "R" + (i + 1));
      });
    }
    function sheet_to_sylk(ws, opts, wb) {
      if (!opts) opts = {};
      opts._formats = ["General"];
      var preamble = ["ID;PSheetJS;N;E"], o = [];
      var r2 = safe_decode_range(ws["!ref"] || "A1"), cell;
      var dense = ws["!data"] != null;
      var RS = "\r\n";
      var d1904 = (((wb || {}).Workbook || {}).WBProps || {}).date1904;
      var _lastfmt = "General";
      preamble.push("P;PGeneral");
      var R = r2.s.r, C = r2.s.c, p2 = [];
      if (ws["!ref"]) for (R = r2.s.r; R <= r2.e.r; ++R) {
        if (dense && !ws["!data"][R]) continue;
        p2 = [];
        for (C = r2.s.c; C <= r2.e.c; ++C) {
          cell = dense ? ws["!data"][R][C] : ws[encode_col(C) + encode_row(R)];
          if (!cell || !cell.c) continue;
          p2.push(write_ws_cmnt_sylk(cell.c, R, C));
        }
        if (p2.length) o.push(p2.join(RS));
      }
      if (ws["!ref"]) for (R = r2.s.r; R <= r2.e.r; ++R) {
        if (dense && !ws["!data"][R]) continue;
        p2 = [];
        for (C = r2.s.c; C <= r2.e.c; ++C) {
          cell = dense ? ws["!data"][R][C] : ws[encode_col(C) + encode_row(R)];
          if (!cell || cell.v == null && (!cell.f || cell.F)) continue;
          if ((cell.z || (cell.t == "d" ? table_fmt[14] : "General")) != _lastfmt) {
            var ifmt = opts._formats.indexOf(cell.z);
            if (ifmt == -1) {
              opts._formats.push(cell.z);
              ifmt = opts._formats.length - 1;
              preamble.push("P;P" + cell.z.replace(/;/g, ";;"));
            }
            p2.push("F;P" + ifmt + ";Y" + (R + 1) + ";X" + (C + 1));
          }
          p2.push(write_ws_cell_sylk(cell, ws, R, C, opts, d1904));
        }
        o.push(p2.join(RS));
      }
      preamble.push("F;P0;DG0G8;M255");
      if (ws["!cols"]) write_ws_cols_sylk(preamble, ws["!cols"]);
      if (ws["!rows"]) write_ws_rows_sylk(preamble, ws["!rows"]);
      if (ws["!ref"]) preamble.push("B;Y" + (r2.e.r - r2.s.r + 1) + ";X" + (r2.e.c - r2.s.c + 1) + ";D" + [r2.s.c, r2.s.r, r2.e.c, r2.e.r].join(" "));
      preamble.push("O;L;D;B" + (d1904 ? ";V4" : "") + ";K47;G100 0.001");
      delete opts._formats;
      return preamble.join(RS) + RS + o.join(RS) + RS + "E" + RS;
    }
    return {
      to_workbook: sylk_to_workbook,
      from_sheet: sheet_to_sylk
    };
  })();
  var DIF = (function() {
    function dif_to_aoa(d, opts) {
      switch (opts.type) {
        case "base64":
          return dif_to_aoa_str(Base64_decode(d), opts);
        case "binary":
          return dif_to_aoa_str(d, opts);
        case "buffer":
          return dif_to_aoa_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
        case "array":
          return dif_to_aoa_str(cc2str(d), opts);
      }
      throw new Error("Unrecognized type " + opts.type);
    }
    function dif_to_aoa_str(str, opts) {
      var records = str.split("\n"), R = -1, C = -1, ri = 0, arr = [];
      for (; ri !== records.length; ++ri) {
        if (records[ri].trim() === "BOT") {
          arr[++R] = [];
          C = 0;
          continue;
        }
        if (R < 0) continue;
        var metadata = records[ri].trim().split(",");
        var type = metadata[0], value = metadata[1];
        ++ri;
        var data = records[ri] || "";
        while ((data.match(/["]/g) || []).length & 1 && ri < records.length - 1) data += "\n" + records[++ri];
        data = data.trim();
        switch (+type) {
          case -1:
            if (data === "BOT") {
              arr[++R] = [];
              C = 0;
              continue;
            } else if (data !== "EOD") throw new Error("Unrecognized DIF special command " + data);
            break;
          case 0:
            if (data === "TRUE") arr[R][C] = true;
            else if (data === "FALSE") arr[R][C] = false;
            else if (!isNaN(fuzzynum(value))) arr[R][C] = fuzzynum(value);
            else if (!isNaN(fuzzydate(value).getDate())) {
              arr[R][C] = parseDate(value);
              if (!(opts && opts.UTC)) {
                arr[R][C] = utc_to_local(arr[R][C]);
              }
            } else arr[R][C] = value;
            ++C;
            break;
          case 1:
            data = data.slice(1, data.length - 1);
            data = data.replace(/""/g, '"');
            if (data && data.match(/^=".*"$/)) data = data.slice(2, -1);
            arr[R][C++] = data !== "" ? data : null;
            break;
        }
        if (data === "EOD") break;
      }
      if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
      return arr;
    }
    function dif_to_sheet(str, opts) {
      return aoa_to_sheet(dif_to_aoa(str, opts), opts);
    }
    function dif_to_workbook(str, opts) {
      var o = sheet_to_workbook(dif_to_sheet(str, opts), opts);
      o.bookType = "dif";
      return o;
    }
    function make_value(v, s) {
      return "0," + String(v) + "\r\n" + s;
    }
    function make_value_str(s) {
      return '1,0\r\n"' + s.replace(/"/g, '""') + '"';
    }
    function sheet_to_dif(ws) {
      if (!ws["!ref"]) throw new Error("Cannot export empty sheet to DIF");
      var r2 = safe_decode_range(ws["!ref"]);
      var dense = ws["!data"] != null;
      var o = [
        'TABLE\r\n0,1\r\n"sheetjs"\r\n',
        "VECTORS\r\n0," + (r2.e.r - r2.s.r + 1) + '\r\n""\r\n',
        "TUPLES\r\n0," + (r2.e.c - r2.s.c + 1) + '\r\n""\r\n',
        'DATA\r\n0,0\r\n""\r\n'
      ];
      for (var R = r2.s.r; R <= r2.e.r; ++R) {
        var row = dense ? ws["!data"][R] : [];
        var p2 = "-1,0\r\nBOT\r\n";
        for (var C = r2.s.c; C <= r2.e.c; ++C) {
          var cell = dense ? row && row[C] : ws[encode_cell({ r: R, c: C })];
          if (cell == null) {
            p2 += '1,0\r\n""\r\n';
            continue;
          }
          switch (cell.t) {
            case "n":
              {
                if (cell.w != null) p2 += "0," + cell.w + "\r\nV";
                else if (cell.v != null) p2 += make_value(cell.v, "V");
                else if (cell.f != null && !cell.F) p2 += make_value_str("=" + cell.f);
                else p2 += '1,0\r\n""';
              }
              break;
            case "b":
              p2 += cell.v ? make_value(1, "TRUE") : make_value(0, "FALSE");
              break;
            case "s":
              p2 += make_value_str(isNaN(+cell.v) ? cell.v : '="' + cell.v + '"');
              break;
            case "d":
              if (!cell.w) cell.w = SSF_format(cell.z || table_fmt[14], datenum(parseDate(cell.v)));
              p2 += make_value(cell.w, "V");
              break;
            default:
              p2 += '1,0\r\n""';
          }
          p2 += "\r\n";
        }
        o.push(p2);
      }
      return o.join("") + "-1,0\r\nEOD";
    }
    return {
      to_workbook: dif_to_workbook,
      to_sheet: dif_to_sheet,
      from_sheet: sheet_to_dif
    };
  })();
  var ETH = (function() {
    function decode(s) {
      return s.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, "\n");
    }
    function encode(s) {
      return s.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n");
    }
    function eth_to_aoa(str, opts) {
      var records = str.split("\n"), R = -1, C = -1, ri = 0, arr = [];
      for (; ri !== records.length; ++ri) {
        var record = records[ri].trim().split(":");
        if (record[0] !== "cell") continue;
        var addr = decode_cell(record[1]);
        if (arr.length <= addr.r) {
          for (R = arr.length; R <= addr.r; ++R) if (!arr[R]) arr[R] = [];
        }
        R = addr.r;
        C = addr.c;
        switch (record[2]) {
          case "t":
            arr[R][C] = decode(record[3]);
            break;
          case "v":
            arr[R][C] = +record[3];
            break;
          case "vtf":
            var _f = record[record.length - 1];
case "vtc":
            switch (record[3]) {
              case "nl":
                arr[R][C] = +record[4] ? true : false;
                break;
              default:
                arr[R][C] = record[record.length - 1].charAt(0) == "#" ? { t: "e", v: RBErr[record[record.length - 1]] } : +record[4];
                break;
            }
            if (record[2] == "vtf") arr[R][C] = [arr[R][C], _f];
        }
      }
      if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
      return arr;
    }
    function eth_to_sheet(d, opts) {
      return aoa_to_sheet(eth_to_aoa(d, opts), opts);
    }
    function eth_to_workbook(d, opts) {
      return sheet_to_workbook(eth_to_sheet(d, opts), opts);
    }
    var header = [
      "socialcalc:version:1.5",
      "MIME-Version: 1.0",
      "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"
    ].join("\n");
    var sep = [
      "--SocialCalcSpreadsheetControlSave",
      "Content-type: text/plain; charset=UTF-8"
    ].join("\n") + "\n";
    var meta = [
      "# SocialCalc Spreadsheet Control Save",
      "part:sheet"
    ].join("\n");
    var end = "--SocialCalcSpreadsheetControlSave--";
    function sheet_to_eth_data(ws) {
      if (!ws || !ws["!ref"]) return "";
      var o = [], oo = [], cell, coord = "";
      var r2 = decode_range(ws["!ref"]);
      var dense = ws["!data"] != null;
      for (var R = r2.s.r; R <= r2.e.r; ++R) {
        for (var C = r2.s.c; C <= r2.e.c; ++C) {
          coord = encode_cell({ r: R, c: C });
          cell = dense ? (ws["!data"][R] || [])[C] : ws[coord];
          if (!cell || cell.v == null || cell.t === "z") continue;
          oo = ["cell", coord, "t"];
          switch (cell.t) {
            case "s":
              oo.push(encode(cell.v));
              break;
            case "b":
              oo[2] = "vt" + (cell.f ? "f" : "c");
              oo[3] = "nl";
              oo[4] = cell.v ? "1" : "0";
              oo[5] = encode(cell.f || (cell.v ? "TRUE" : "FALSE"));
              break;
            case "d":
              var t = datenum(parseDate(cell.v));
              oo[2] = "vtc";
              oo[3] = "nd";
              oo[4] = "" + t;
              oo[5] = cell.w || SSF_format(cell.z || table_fmt[14], t);
              break;
            case "n":
              if (isFinite(cell.v)) {
                if (!cell.f) {
                  oo[2] = "v";
                  oo[3] = cell.v;
                } else {
                  oo[2] = "vtf";
                  oo[3] = "n";
                  oo[4] = cell.v;
                  oo[5] = encode(cell.f);
                }
              } else {
                oo[2] = "vt" + (cell.f ? "f" : "c");
                oo[3] = "e" + BErr[isNaN(cell.v) ? 36 : 7];
                oo[4] = "0";
                oo[5] = cell.f || oo[3].slice(1);
                oo[6] = "e";
                oo[7] = oo[3].slice(1);
              }
              break;
            case "e":
              continue;
          }
          o.push(oo.join(":"));
        }
      }
      o.push("sheet:c:" + (r2.e.c - r2.s.c + 1) + ":r:" + (r2.e.r - r2.s.r + 1) + ":tvf:1");
      o.push("valueformat:1:text-wiki");
      return o.join("\n");
    }
    function sheet_to_eth(ws) {
      return [header, sep, meta, sep, sheet_to_eth_data(ws), end].join("\n");
    }
    return {
      to_workbook: eth_to_workbook,
      to_sheet: eth_to_sheet,
      from_sheet: sheet_to_eth
    };
  })();
  var PRN = (function() {
    function set_text_arr(data, arr, R, C, o) {
      if (o.raw) arr[R][C] = data;
      else if (data === "") ;
      else if (data === "TRUE") arr[R][C] = true;
      else if (data === "FALSE") arr[R][C] = false;
      else if (!isNaN(fuzzynum(data))) arr[R][C] = fuzzynum(data);
      else if (!isNaN(fuzzydate(data).getDate())) arr[R][C] = parseDate(data);
      else if (data.charCodeAt(0) == 35 && RBErr[data] != null) arr[R][C] = { t: "e", v: RBErr[data], w: data };
      else arr[R][C] = data;
    }
    function prn_to_aoa_str(f, opts) {
      var o = opts || {};
      var arr = [];
      if (!f || f.length === 0) return arr;
      var lines = f.split(/[\r\n]/);
      var L = lines.length - 1;
      while (L >= 0 && lines[L].length === 0) --L;
      var start = 10, idx = 0;
      var R = 0;
      for (; R <= L; ++R) {
        idx = lines[R].indexOf(" ");
        if (idx == -1) idx = lines[R].length;
        else idx++;
        start = Math.max(start, idx);
      }
      for (R = 0; R <= L; ++R) {
        arr[R] = [];
        var C = 0;
        set_text_arr(lines[R].slice(0, start).trim(), arr, R, C, o);
        for (C = 1; C <= (lines[R].length - start) / 10 + 1; ++C)
          set_text_arr(lines[R].slice(start + (C - 1) * 10, start + C * 10).trim(), arr, R, C, o);
      }
      if (o.sheetRows) arr = arr.slice(0, o.sheetRows);
      return arr;
    }
    var guess_seps = {
      44: ",",
      9: "	",
      59: ";",
      124: "|"
    };
    var guess_sep_weights = {
      44: 3,
      9: 2,
      59: 1,
      124: 0
    };
    function guess_sep(str) {
      var cnt = {}, instr = false, end = 0, cc = 0;
      for (; end < str.length; ++end) {
        if ((cc = str.charCodeAt(end)) == 34) instr = !instr;
        else if (!instr && cc in guess_seps) cnt[cc] = (cnt[cc] || 0) + 1;
      }
      cc = [];
      for (end in cnt) if (Object.prototype.hasOwnProperty.call(cnt, end)) {
        cc.push([cnt[end], end]);
      }
      if (!cc.length) {
        cnt = guess_sep_weights;
        for (end in cnt) if (Object.prototype.hasOwnProperty.call(cnt, end)) {
          cc.push([cnt[end], end]);
        }
      }
      cc.sort(function(a, b) {
        return a[0] - b[0] || guess_sep_weights[a[1]] - guess_sep_weights[b[1]];
      });
      return guess_seps[cc.pop()[1]] || 44;
    }
    function dsv_to_sheet_str(str, opts) {
      var o = opts || {};
      var sep = "";
      var ws = {};
      if (o.dense) ws["!data"] = [];
      var range = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
      if (str.slice(0, 4) == "sep=") {
        if (str.charCodeAt(5) == 13 && str.charCodeAt(6) == 10) {
          sep = str.charAt(4);
          str = str.slice(7);
        } else if (str.charCodeAt(5) == 13 || str.charCodeAt(5) == 10) {
          sep = str.charAt(4);
          str = str.slice(6);
        } else sep = guess_sep(str.slice(0, 1024));
      } else if (o && o.FS) sep = o.FS;
      else sep = guess_sep(str.slice(0, 1024));
      var R = 0, C = 0, v = 0;
      var start = 0, end = 0, sepcc = sep.charCodeAt(0), instr = false, cc = 0, startcc = str.charCodeAt(0);
      var _re = o.dateNF != null ? dateNF_regex(o.dateNF) : null;
      function finish_cell() {
        var s = str.slice(start, end);
        if (s.slice(-1) == "\r") s = s.slice(0, -1);
        var cell = {};
        if (s.charAt(0) == '"' && s.charAt(s.length - 1) == '"') s = s.slice(1, -1).replace(/""/g, '"');
        if (o.cellText !== false) cell.w = s;
        if (s.length === 0) cell.t = "z";
        else if (o.raw) {
          cell.t = "s";
          cell.v = s;
        } else if (s.trim().length === 0) {
          cell.t = "s";
          cell.v = s;
        } else if (s.charCodeAt(0) == 61) {
          if (s.charCodeAt(1) == 34 && s.charCodeAt(s.length - 1) == 34) {
            cell.t = "s";
            cell.v = s.slice(2, -1).replace(/""/g, '"');
          } else if (fuzzyfmla(s)) {
            cell.t = "s";
            cell.f = s.slice(1);
            cell.v = s;
          } else {
            cell.t = "s";
            cell.v = s;
          }
        } else if (s == "TRUE") {
          cell.t = "b";
          cell.v = true;
        } else if (s == "FALSE") {
          cell.t = "b";
          cell.v = false;
        } else if (!isNaN(v = fuzzynum(s))) {
          cell.t = "n";
          cell.v = v;
        } else if (!isNaN((v = fuzzydate(s)).getDate()) || _re && s.match(_re)) {
          cell.z = o.dateNF || table_fmt[14];
          if (_re && s.match(_re)) {
            var news = dateNF_fix(s, o.dateNF, s.match(_re) || []);
            v = parseDate(news);
            if (o && o.UTC === false) v = utc_to_local(v);
          } else if (o && o.UTC === false) v = utc_to_local(v);
          else if (o.cellText !== false && o.dateNF) cell.w = SSF_format(cell.z, v);
          if (o.cellDates) {
            cell.t = "d";
            cell.v = v;
          } else {
            cell.t = "n";
            cell.v = datenum(v);
          }
          if (!o.cellNF) delete cell.z;
        } else if (s.charCodeAt(0) == 35 && RBErr[s] != null) {
          cell.t = "e";
          cell.w = s;
          cell.v = RBErr[s];
        } else {
          cell.t = "s";
          cell.v = s;
        }
        if (cell.t == "z") ;
        else if (o.dense) {
          if (!ws["!data"][R]) ws["!data"][R] = [];
          ws["!data"][R][C] = cell;
        } else ws[encode_cell({ c: C, r: R })] = cell;
        start = end + 1;
        startcc = str.charCodeAt(start);
        if (range.e.c < C) range.e.c = C;
        if (range.e.r < R) range.e.r = R;
        if (cc == sepcc) ++C;
        else {
          C = 0;
          ++R;
          if (o.sheetRows && o.sheetRows <= R) return true;
        }
      }
      outer: for (; end < str.length; ++end) switch (cc = str.charCodeAt(end)) {
        case 34:
          if (startcc === 34) instr = !instr;
          break;
        case 13:
          if (instr) break;
          if (str.charCodeAt(end + 1) == 10) ++end;
case sepcc:
        case 10:
          if (!instr && finish_cell()) break outer;
          break;
      }
      if (end - start > 0) finish_cell();
      ws["!ref"] = encode_range(range);
      return ws;
    }
    function prn_to_sheet_str(str, opts) {
      if (!(opts && opts.PRN)) return dsv_to_sheet_str(str, opts);
      if (opts.FS) return dsv_to_sheet_str(str, opts);
      if (str.slice(0, 4) == "sep=") return dsv_to_sheet_str(str, opts);
      if (str.indexOf("	") >= 0 || str.indexOf(",") >= 0 || str.indexOf(";") >= 0) return dsv_to_sheet_str(str, opts);
      return aoa_to_sheet(prn_to_aoa_str(str, opts), opts);
    }
    function prn_to_sheet(d, opts) {
      var str = "", bytes = opts.type == "string" ? [0, 0, 0, 0] : firstbyte(d, opts);
      switch (opts.type) {
        case "base64":
          str = Base64_decode(d);
          break;
        case "binary":
          str = d;
          break;
        case "buffer":
          if (opts.codepage == 65001) str = d.toString("utf8");
          else if (opts.codepage && typeof $cptable !== "undefined") str = $cptable.utils.decode(opts.codepage, d);
          else str = has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d);
          break;
        case "array":
          str = cc2str(d);
          break;
        case "string":
          str = d;
          break;
        default:
          throw new Error("Unrecognized type " + opts.type);
      }
      if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191) str = utf8read(str.slice(3));
      else if (opts.type != "string" && opts.type != "buffer" && opts.codepage == 65001) str = utf8read(str);
      else if (opts.type == "binary" && typeof $cptable !== "undefined" && opts.codepage) str = $cptable.utils.decode(opts.codepage, $cptable.utils.encode(28591, str));
      if (str.slice(0, 19) == "socialcalc:version:") return ETH.to_sheet(opts.type == "string" ? str : utf8read(str), opts);
      return prn_to_sheet_str(str, opts);
    }
    function prn_to_workbook(d, opts) {
      return sheet_to_workbook(prn_to_sheet(d, opts), opts);
    }
    function sheet_to_prn(ws) {
      var o = [];
      if (!ws["!ref"]) return "";
      var r2 = safe_decode_range(ws["!ref"]), cell;
      var dense = ws["!data"] != null;
      for (var R = r2.s.r; R <= r2.e.r; ++R) {
        var oo = [];
        for (var C = r2.s.c; C <= r2.e.c; ++C) {
          var coord = encode_cell({ r: R, c: C });
          cell = dense ? (ws["!data"][R] || [])[C] : ws[coord];
          if (!cell || cell.v == null) {
            oo.push("          ");
            continue;
          }
          var w = (cell.w || (format_cell(cell), cell.w) || "").slice(0, 10);
          while (w.length < 10) w += " ";
          oo.push(w + (C === 0 ? " " : ""));
        }
        o.push(oo.join(""));
      }
      return o.join("\n");
    }
    return {
      to_workbook: prn_to_workbook,
      to_sheet: prn_to_sheet,
      from_sheet: sheet_to_prn
    };
  })();
  function read_wb_ID(d, opts) {
    var o = opts || {}, OLD_WTF = !!o.WTF;
    o.WTF = true;
    try {
      var out = SYLK.to_workbook(d, o);
      o.WTF = OLD_WTF;
      return out;
    } catch (e) {
      o.WTF = OLD_WTF;
      if (e.message.indexOf("SYLK bad record ID") == -1 && OLD_WTF) throw e;
      return PRN.to_workbook(d, opts);
    }
  }
  var WK_ = (function() {
    function lotushopper(data, cb, opts) {
      if (!data) return;
      prep_blob(data, data.l || 0);
      var Enum = opts.Enum || WK1Enum;
      while (data.l < data.length) {
        var RT = data.read_shift(2);
        var R = Enum[RT] || Enum[65535];
        var length = data.read_shift(2);
        var tgt = data.l + length;
        var d = R.f && R.f(data, length, opts);
        data.l = tgt;
        if (cb(d, R, RT)) return;
      }
    }
    function lotus_to_workbook(d, opts) {
      switch (opts.type) {
        case "base64":
          return lotus_to_workbook_buf(s2a(Base64_decode(d)), opts);
        case "binary":
          return lotus_to_workbook_buf(s2a(d), opts);
        case "buffer":
        case "array":
          return lotus_to_workbook_buf(d, opts);
      }
      throw "Unsupported type " + opts.type;
    }
    var LOTUS_DATE_FMTS = [
      "mmmm",
      "dd-mmm-yyyy",
      "dd-mmm",
      "mmm-yyyy",
      "@",
"mm/dd",
      "hh:mm:ss AM/PM",
"hh:mm AM/PM",
      "mm/dd/yyyy",
      "mm/dd",
      "hh:mm:ss",
      "hh:mm"
];
    function lotus_to_workbook_buf(d, opts) {
      if (!d) return d;
      var o = opts || {};
      var s = {}, n = "Sheet1", next_n = "", sidx = 0;
      var sheets = {}, snames = [], realnames = [], sdata = [];
      if (o.dense) sdata = s["!data"] = [];
      var refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
      var sheetRows = o.sheetRows || 0;
      var lastcell = {};
      if (d[4] == 81 && d[5] == 80 && d[6] == 87) return qpw_to_workbook_buf(d, opts);
      if (d[2] == 0) {
        if (d[3] == 8 || d[3] == 9) {
          if (d.length >= 16 && d[14] == 5 && d[15] === 108) throw new Error("Unsupported Works 3 for Mac file");
        }
      }
      if (d[2] == 2) {
        o.Enum = WK1Enum;
        lotushopper(d, function(val2, R, RT) {
          switch (RT) {
            case 0:
              o.vers = val2;
              if (val2 >= 4096) o.qpro = true;
              break;
            case 255:
              o.vers = val2;
              o.works = true;
              break;
            case 6:
              refguess = val2;
              break;
case 204:
              if (val2) next_n = val2;
              break;
case 222:
              next_n = val2;
              break;
case 15:
case 51:
              if ((!o.qpro && !o.works || RT == 51) && val2[1].v.charCodeAt(0) < 48) val2[1].v = val2[1].v.slice(1);
              if (o.works || o.works2) val2[1].v = val2[1].v.replace(/\r\n/g, "\n");
case 13:
case 14:
case 16:
              if ((val2[2] & 112) == 112 && (val2[2] & 15) > 1 && (val2[2] & 15) < 15) {
                val2[1].z = o.dateNF || LOTUS_DATE_FMTS[(val2[2] & 15) - 1] || table_fmt[14];
                if (o.cellDates) {
                  val2[1].v = numdate(val2[1].v);
                  val2[1].t = typeof val2[1].v == "number" ? "n" : "d";
                }
              }
              if (o.qpro) {
                if (val2[3] > sidx) {
                  s["!ref"] = encode_range(refguess);
                  sheets[n] = s;
                  snames.push(n);
                  s = {};
                  if (o.dense) sdata = s["!data"] = [];
                  refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
                  sidx = val2[3];
                  n = next_n || "Sheet" + (sidx + 1);
                  next_n = "";
                }
              }
              var tmpcell = o.dense ? (sdata[val2[0].r] || [])[val2[0].c] : s[encode_cell(val2[0])];
              if (tmpcell) {
                tmpcell.t = val2[1].t;
                tmpcell.v = val2[1].v;
                if (val2[1].z != null) tmpcell.z = val2[1].z;
                if (val2[1].f != null) tmpcell.f = val2[1].f;
                lastcell = tmpcell;
                break;
              }
              if (o.dense) {
                if (!sdata[val2[0].r]) sdata[val2[0].r] = [];
                sdata[val2[0].r][val2[0].c] = val2[1];
              } else s[encode_cell(val2[0])] = val2[1];
              lastcell = val2[1];
              break;
            case 21509:
              o.works2 = true;
              break;
            case 21506:
              {
                if (val2 == 5281) {
                  lastcell.z = "hh:mm:ss";
                  if (o.cellDates && lastcell.t == "n") {
                    lastcell.v = numdate(lastcell.v);
                    lastcell.t = typeof lastcell.v == "number" ? "n" : "d";
                  }
                }
              }
              break;
          }
        }, o);
      } else if (d[2] == 26 || d[2] == 14) {
        o.Enum = WK3Enum;
        if (d[2] == 14) {
          o.qpro = true;
          d.l = 0;
        }
        lotushopper(d, function(val2, R, RT) {
          switch (RT) {
            case 204:
              n = val2;
              break;
case 22:
              if (val2[1].v.charCodeAt(0) < 48) val2[1].v = val2[1].v.slice(1);
              val2[1].v = val2[1].v.replace(/\x0F./g, function($$) {
                return String.fromCharCode($$.charCodeAt(1) - 32);
              }).replace(/\r\n/g, "\n");
case 23:
case 24:
case 25:
case 37:
case 39:
case 40:
              if (val2[3] > sidx) {
                s["!ref"] = encode_range(refguess);
                sheets[n] = s;
                snames.push(n);
                s = {};
                if (o.dense) sdata = s["!data"] = [];
                refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
                sidx = val2[3];
                n = "Sheet" + (sidx + 1);
              }
              if (sheetRows > 0 && val2[0].r >= sheetRows) break;
              if (o.dense) {
                if (!sdata[val2[0].r]) sdata[val2[0].r] = [];
                sdata[val2[0].r][val2[0].c] = val2[1];
              } else s[encode_cell(val2[0])] = val2[1];
              if (refguess.e.c < val2[0].c) refguess.e.c = val2[0].c;
              if (refguess.e.r < val2[0].r) refguess.e.r = val2[0].r;
              break;
            case 27:
              if (val2[14e3]) realnames[val2[14e3][0]] = val2[14e3][1];
              break;
            case 1537:
              realnames[val2[0]] = val2[1];
              if (val2[0] == sidx) n = val2[1];
              break;
          }
        }, o);
      } else throw new Error("Unrecognized LOTUS BOF " + d[2]);
      s["!ref"] = encode_range(refguess);
      sheets[next_n || n] = s;
      snames.push(next_n || n);
      if (!realnames.length) return { SheetNames: snames, Sheets: sheets };
      var osheets = {}, rnames = [];
      for (var i = 0; i < realnames.length; ++i) if (sheets[snames[i]]) {
        rnames.push(realnames[i] || snames[i]);
        osheets[realnames[i]] = sheets[realnames[i]] || sheets[snames[i]];
      } else {
        rnames.push(realnames[i]);
        osheets[realnames[i]] = { "!ref": "A1" };
      }
      return { SheetNames: rnames, Sheets: osheets };
    }
    function sheet_to_wk1(ws, opts) {
      var o = opts || {};
      if (+o.codepage >= 0) set_cp(+o.codepage);
      if (o.type == "string") throw new Error("Cannot write WK1 to JS string");
      var ba = buf_array();
      if (!ws["!ref"]) throw new Error("Cannot export empty sheet to WK1");
      var range = safe_decode_range(ws["!ref"]);
      var dense = ws["!data"] != null;
      var cols = [];
      write_biff_rec(ba, 0, write_BOF_WK1(1030));
      write_biff_rec(ba, 6, write_RANGE(range));
      var max_R = Math.min(range.e.r, 8191);
      for (var C = range.s.c; C <= range.e.c; ++C) cols[C] = encode_col(C);
      for (var R = range.s.r; R <= max_R; ++R) {
        var rr = encode_row(R);
        for (C = range.s.c; C <= range.e.c; ++C) {
          var cell = dense ? (ws["!data"][R] || [])[C] : ws[cols[C] + rr];
          if (!cell || cell.t == "z") continue;
          switch (cell.t) {
            case "n":
              if ((cell.v | 0) == cell.v && cell.v >= -32768 && cell.v <= 32767) write_biff_rec(ba, 13, write_INTEGER(R, C, cell));
              else write_biff_rec(ba, 14, write_NUMBER(R, C, cell));
              break;
            case "d":
              var dc = datenum(cell.v);
              if ((dc | 0) == dc && dc >= -32768 && dc <= 32767) write_biff_rec(ba, 13, write_INTEGER(R, C, { v: dc, z: cell.z || table_fmt[14] }));
              else write_biff_rec(ba, 14, write_NUMBER(R, C, { v: dc, z: cell.z || table_fmt[14] }));
              break;
            default:
              var str = format_cell(cell);
              write_biff_rec(ba, 15, write_LABEL(R, C, str.slice(0, 239)));
          }
        }
      }
      write_biff_rec(ba, 1);
      return ba.end();
    }
    function book_to_wk3(wb, opts) {
      var o = opts || {};
      if (+o.codepage >= 0) set_cp(+o.codepage);
      if (o.type == "string") throw new Error("Cannot write WK3 to JS string");
      var ba = buf_array();
      write_biff_rec(ba, 0, write_BOF_WK3(wb));
      for (var i = 0, cnt = 0; i < wb.SheetNames.length; ++i) if ((wb.Sheets[wb.SheetNames[i]] || {})["!ref"]) write_biff_rec(ba, 27, write_XFORMAT_SHEETNAME(wb.SheetNames[i], cnt++));
      var wsidx = 0;
      for (i = 0; i < wb.SheetNames.length; ++i) {
        var ws = wb.Sheets[wb.SheetNames[i]];
        if (!ws || !ws["!ref"]) continue;
        var range = safe_decode_range(ws["!ref"]);
        var dense = ws["!data"] != null;
        var cols = [];
        var max_R = Math.min(range.e.r, 8191);
        for (var R = range.s.r; R <= max_R; ++R) {
          var rr = encode_row(R);
          for (var C = range.s.c; C <= range.e.c; ++C) {
            if (R === range.s.r) cols[C] = encode_col(C);
            var ref2 = cols[C] + rr;
            var cell = dense ? (ws["!data"][R] || [])[C] : ws[ref2];
            if (!cell || cell.t == "z") continue;
            if (cell.t == "n") {
              write_biff_rec(ba, 23, write_NUMBER_17(R, C, wsidx, cell.v));
            } else {
              var str = format_cell(cell);
              write_biff_rec(ba, 22, write_LABEL_16(R, C, wsidx, str.slice(0, 239)));
            }
          }
        }
        ++wsidx;
      }
      write_biff_rec(ba, 1);
      return ba.end();
    }
    function write_BOF_WK1(v) {
      var out = new_buf(2);
      out.write_shift(2, v);
      return out;
    }
    function write_BOF_WK3(wb) {
      var out = new_buf(26);
      out.write_shift(2, 4096);
      out.write_shift(2, 4);
      out.write_shift(4, 0);
      var rows = 0, cols = 0, wscnt = 0;
      for (var i = 0; i < wb.SheetNames.length; ++i) {
        var name = wb.SheetNames[i];
        var ws = wb.Sheets[name];
        if (!ws || !ws["!ref"]) continue;
        ++wscnt;
        var range = decode_range(ws["!ref"]);
        if (rows < range.e.r) rows = range.e.r;
        if (cols < range.e.c) cols = range.e.c;
      }
      if (rows > 8191) rows = 8191;
      out.write_shift(2, rows);
      out.write_shift(1, wscnt);
      out.write_shift(1, cols);
      out.write_shift(2, 0);
      out.write_shift(2, 0);
      out.write_shift(1, 1);
      out.write_shift(1, 2);
      out.write_shift(4, 0);
      out.write_shift(4, 0);
      return out;
    }
    function parse_RANGE(blob, length, opts) {
      var o = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
      if (length == 8 && opts.qpro) {
        o.s.c = blob.read_shift(1);
        blob.l++;
        o.s.r = blob.read_shift(2);
        o.e.c = blob.read_shift(1);
        blob.l++;
        o.e.r = blob.read_shift(2);
        return o;
      }
      o.s.c = blob.read_shift(2);
      o.s.r = blob.read_shift(2);
      if (length == 12 && opts.qpro) blob.l += 2;
      o.e.c = blob.read_shift(2);
      o.e.r = blob.read_shift(2);
      if (length == 12 && opts.qpro) blob.l += 2;
      if (o.s.c == 65535) o.s.c = o.e.c = o.s.r = o.e.r = 0;
      return o;
    }
    function write_RANGE(range) {
      var out = new_buf(8);
      out.write_shift(2, range.s.c);
      out.write_shift(2, range.s.r);
      out.write_shift(2, range.e.c);
      out.write_shift(2, range.e.r);
      return out;
    }
    function parse_cell(blob, length, opts) {
      var o = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0, 0];
      if (opts.qpro && opts.vers != 20768) {
        o[0].c = blob.read_shift(1);
        o[3] = blob.read_shift(1);
        o[0].r = blob.read_shift(2);
        blob.l += 2;
      } else if (opts.works) {
        o[0].c = blob.read_shift(2);
        o[0].r = blob.read_shift(2);
        o[2] = blob.read_shift(2);
      } else {
        o[2] = blob.read_shift(1);
        o[0].c = blob.read_shift(2);
        o[0].r = blob.read_shift(2);
      }
      return o;
    }
    function get_wk1_fmt(cell) {
      if (cell.z && fmt_is_date(cell.z)) {
        return 240 | (LOTUS_DATE_FMTS.indexOf(cell.z) + 1 || 2);
      }
      return 255;
    }
    function parse_LABEL(blob, length, opts) {
      var tgt = blob.l + length;
      var o = parse_cell(blob, length, opts);
      o[1].t = "s";
      if ((opts.vers & 65534) == 20768) {
        blob.l++;
        var len = blob.read_shift(1);
        o[1].v = blob.read_shift(len, "utf8");
        return o;
      }
      if (opts.qpro) blob.l++;
      o[1].v = blob.read_shift(tgt - blob.l, "cstr");
      return o;
    }
    function write_LABEL(R, C, s) {
      var o = new_buf(7 + s.length);
      o.write_shift(1, 255);
      o.write_shift(2, C);
      o.write_shift(2, R);
      o.write_shift(1, 39);
      for (var i = 0; i < o.length; ++i) {
        var cc = s.charCodeAt(i);
        o.write_shift(1, cc >= 128 ? 95 : cc);
      }
      o.write_shift(1, 0);
      return o;
    }
    function parse_STRING(blob, length, opts) {
      var tgt = blob.l + length;
      var o = parse_cell(blob, length, opts);
      o[1].t = "s";
      if (opts.vers == 20768) {
        var len = blob.read_shift(1);
        o[1].v = blob.read_shift(len, "utf8");
        return o;
      }
      o[1].v = blob.read_shift(tgt - blob.l, "cstr");
      return o;
    }
    function parse_INTEGER(blob, length, opts) {
      var o = parse_cell(blob, length, opts);
      o[1].v = blob.read_shift(2, "i");
      return o;
    }
    function write_INTEGER(R, C, cell) {
      var o = new_buf(7);
      o.write_shift(1, get_wk1_fmt(cell));
      o.write_shift(2, C);
      o.write_shift(2, R);
      o.write_shift(2, cell.v, "i");
      return o;
    }
    function parse_NUMBER(blob, length, opts) {
      var o = parse_cell(blob, length, opts);
      o[1].v = blob.read_shift(8, "f");
      return o;
    }
    function write_NUMBER(R, C, cell) {
      var o = new_buf(13);
      o.write_shift(1, get_wk1_fmt(cell));
      o.write_shift(2, C);
      o.write_shift(2, R);
      o.write_shift(8, cell.v, "f");
      return o;
    }
    function parse_FORMULA(blob, length, opts) {
      var tgt = blob.l + length;
      var o = parse_cell(blob, length, opts);
      o[1].v = blob.read_shift(8, "f");
      if (opts.qpro) blob.l = tgt;
      else {
        var flen = blob.read_shift(2);
        wk1_fmla_to_csf(blob.slice(blob.l, blob.l + flen), o);
        blob.l += flen;
      }
      return o;
    }
    function wk1_parse_rc(B, V, col) {
      var rel = V & 32768;
      V &= -32769;
      V = (rel ? B : 0) + (V >= 8192 ? V - 16384 : V);
      return (rel ? "" : "$") + (col ? encode_col(V) : encode_row(V));
    }
    var FuncTab = {
      31: ["NA", 0],
33: ["ABS", 1],
      34: ["TRUNC", 1],
      35: ["SQRT", 1],
      36: ["LOG", 1],
      37: ["LN", 1],
      38: ["PI", 0],
      39: ["SIN", 1],
      40: ["COS", 1],
      41: ["TAN", 1],
      42: ["ATAN2", 2],
      43: ["ATAN", 1],
      44: ["ASIN", 1],
      45: ["ACOS", 1],
      46: ["EXP", 1],
      47: ["MOD", 2],
49: ["ISNA", 1],
      50: ["ISERR", 1],
      51: ["FALSE", 0],
      52: ["TRUE", 0],
      53: ["RAND", 0],
      54: ["DATE", 3],







63: ["ROUND", 2],
      64: ["TIME", 3],


68: ["ISNUMBER", 1],
      69: ["ISTEXT", 1],
      70: ["LEN", 1],
      71: ["VALUE", 1],
73: ["MID", 3],
      74: ["CHAR", 1],




80: ["SUM", 69],
      81: ["AVERAGEA", 69],
      82: ["COUNTA", 69],
      83: ["MINA", 69],
      84: ["MAXA", 69],
















102: ["UPPER", 1],
      103: ["LOWER", 1],


107: ["PROPER", 1],
109: ["TRIM", 1],
111: ["T", 1]
};
    var BinOpTab = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
"",
      "+",
      "-",
      "*",
      "/",
      "^",
      "=",
      "<>",
"<=",
      ">=",
      "<",
      ">",
      "",
      "",
      "",
      "",
"&",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
];
    function wk1_fmla_to_csf(blob, o) {
      prep_blob(blob, 0);
      var out = [], argc = 0, R = "", C = "", argL = "", argR = "";
      while (blob.l < blob.length) {
        var cc = blob[blob.l++];
        switch (cc) {
          case 0:
            out.push(blob.read_shift(8, "f"));
            break;
          case 1:
            {
              C = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
              R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
              out.push(C + R);
            }
            break;
          case 2:
            {
              var c = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
              var r2 = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
              C = wk1_parse_rc(o[0].c, blob.read_shift(2), true);
              R = wk1_parse_rc(o[0].r, blob.read_shift(2), false);
              out.push(c + r2 + ":" + C + R);
            }
            break;
          case 3:
            if (blob.l < blob.length) {
              console.error("WK1 premature formula end");
              return;
            }
            break;
          case 4:
            out.push("(" + out.pop() + ")");
            break;
          case 5:
            out.push(blob.read_shift(2));
            break;
          case 6:
            {
              var Z = "";
              while (cc = blob[blob.l++]) Z += String.fromCharCode(cc);
              out.push('"' + Z.replace(/"/g, '""') + '"');
            }
            break;
          case 8:
            out.push("-" + out.pop());
            break;
          case 23:
            out.push("+" + out.pop());
            break;
          case 22:
            out.push("NOT(" + out.pop() + ")");
            break;
          case 20:
          case 21:
            {
              argR = out.pop();
              argL = out.pop();
              out.push(["AND", "OR"][cc - 20] + "(" + argL + "," + argR + ")");
            }
            break;
          default:
            if (cc < 32 && BinOpTab[cc]) {
              argR = out.pop();
              argL = out.pop();
              out.push(argL + BinOpTab[cc] + argR);
            } else if (FuncTab[cc]) {
              argc = FuncTab[cc][1];
              if (argc == 69) argc = blob[blob.l++];
              if (argc > out.length) {
                console.error("WK1 bad formula parse 0x" + cc.toString(16) + ":|" + out.join("|") + "|");
                return;
              }
              var args = out.slice(-argc);
              out.length -= argc;
              out.push(FuncTab[cc][0] + "(" + args.join(",") + ")");
            } else if (cc <= 7) return console.error("WK1 invalid opcode " + cc.toString(16));
            else if (cc <= 24) return console.error("WK1 unsupported op " + cc.toString(16));
            else if (cc <= 30) return console.error("WK1 invalid opcode " + cc.toString(16));
            else if (cc <= 115) return console.error("WK1 unsupported function opcode " + cc.toString(16));
            else return console.error("WK1 unrecognized opcode " + cc.toString(16));
        }
      }
      if (out.length == 1) o[1].f = "" + out[0];
      else console.error("WK1 bad formula parse |" + out.join("|") + "|");
    }
    function parse_cell_3(blob) {
      var o = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0];
      o[0].r = blob.read_shift(2);
      o[3] = blob[blob.l++];
      o[0].c = blob[blob.l++];
      return o;
    }
    function parse_LABEL_16(blob, length) {
      var o = parse_cell_3(blob);
      o[1].t = "s";
      o[1].v = blob.read_shift(length - 4, "cstr");
      return o;
    }
    function write_LABEL_16(R, C, wsidx, s) {
      var o = new_buf(6 + s.length);
      o.write_shift(2, R);
      o.write_shift(1, wsidx);
      o.write_shift(1, C);
      o.write_shift(1, 39);
      for (var i = 0; i < s.length; ++i) {
        var cc = s.charCodeAt(i);
        o.write_shift(1, cc >= 128 ? 95 : cc);
      }
      o.write_shift(1, 0);
      return o;
    }
    function parse_NUMBER_18(blob, length) {
      var o = parse_cell_3(blob);
      o[1].v = blob.read_shift(2);
      var v = o[1].v >> 1;
      if (o[1].v & 1) {
        switch (v & 7) {
          case 0:
            v = (v >> 3) * 5e3;
            break;
          case 1:
            v = (v >> 3) * 500;
            break;
          case 2:
            v = (v >> 3) / 20;
            break;
          case 3:
            v = (v >> 3) / 200;
            break;
          case 4:
            v = (v >> 3) / 2e3;
            break;
          case 5:
            v = (v >> 3) / 2e4;
            break;
          case 6:
            v = (v >> 3) / 16;
            break;
          case 7:
            v = (v >> 3) / 64;
            break;
        }
      }
      o[1].v = v;
      return o;
    }
    function parse_NUMBER_17(blob, length) {
      var o = parse_cell_3(blob);
      var v1 = blob.read_shift(4);
      var v2 = blob.read_shift(4);
      var e = blob.read_shift(2);
      if (e == 65535) {
        if (v1 === 0 && v2 === 3221225472) {
          o[1].t = "e";
          o[1].v = 15;
        } else if (v1 === 0 && v2 === 3489660928) {
          o[1].t = "e";
          o[1].v = 42;
        } else o[1].v = 0;
        return o;
      }
      var s = e & 32768;
      e = (e & 32767) - 16446;
      o[1].v = (1 - s * 2) * (v2 * Math.pow(2, e + 32) + v1 * Math.pow(2, e));
      return o;
    }
    function write_NUMBER_17(R, C, wsidx, v) {
      var o = new_buf(14);
      o.write_shift(2, R);
      o.write_shift(1, wsidx);
      o.write_shift(1, C);
      if (v == 0) {
        o.write_shift(4, 0);
        o.write_shift(4, 0);
        o.write_shift(2, 65535);
        return o;
      }
      var s = 0, e = 0, v1 = 0, v2 = 0;
      if (v < 0) {
        s = 1;
        v = -v;
      }
      e = Math.log2(v) | 0;
      v /= Math.pow(2, e - 31);
      v2 = v >>> 0;
      if ((v2 & 2147483648) == 0) {
        v /= 2;
        ++e;
        v2 = v >>> 0;
      }
      v -= v2;
      v2 |= 2147483648;
      v2 >>>= 0;
      v *= Math.pow(2, 32);
      v1 = v >>> 0;
      o.write_shift(4, v1);
      o.write_shift(4, v2);
      e += 16383 + (s ? 32768 : 0);
      o.write_shift(2, e);
      return o;
    }
    function parse_FORMULA_19(blob, length) {
      var o = parse_NUMBER_17(blob);
      blob.l += length - 14;
      return o;
    }
    function parse_NUMBER_25(blob, length) {
      var o = parse_cell_3(blob);
      var v1 = blob.read_shift(4);
      o[1].v = v1 >> 6;
      return o;
    }
    function parse_NUMBER_27(blob, length) {
      var o = parse_cell_3(blob);
      var v1 = blob.read_shift(8, "f");
      o[1].v = v1;
      return o;
    }
    function parse_FORMULA_28(blob, length) {
      var o = parse_NUMBER_27(blob);
      blob.l += length - 12;
      return o;
    }
    function parse_SHEETNAMECS(blob, length) {
      return blob[blob.l + length - 1] == 0 ? blob.read_shift(length, "cstr") : "";
    }
    function parse_SHEETNAMELP(blob, length) {
      var len = blob[blob.l++];
      if (len > length - 1) len = length - 1;
      var o = "";
      while (o.length < len) o += String.fromCharCode(blob[blob.l++]);
      return o;
    }
    function parse_SHEETINFOQP(blob, length, opts) {
      if (!opts.qpro || length < 21) return;
      var id = blob.read_shift(1);
      blob.l += 17;
      blob.l += 1;
      blob.l += 2;
      var nm = blob.read_shift(length - 21, "cstr");
      return [id, nm];
    }
    function parse_XFORMAT(blob, length) {
      var o = {}, tgt = blob.l + length;
      while (blob.l < tgt) {
        var dt = blob.read_shift(2);
        if (dt == 14e3) {
          o[dt] = [0, ""];
          o[dt][0] = blob.read_shift(2);
          while (blob[blob.l]) {
            o[dt][1] += String.fromCharCode(blob[blob.l]);
            blob.l++;
          }
          blob.l++;
        }
      }
      return o;
    }
    function write_XFORMAT_SHEETNAME(name, wsidx) {
      var out = new_buf(5 + name.length);
      out.write_shift(2, 14e3);
      out.write_shift(2, wsidx);
      for (var i = 0; i < name.length; ++i) {
        var cc = name.charCodeAt(i);
        out[out.l++] = cc > 127 ? 95 : cc;
      }
      out[out.l++] = 0;
      return out;
    }
    var WK1Enum = {
      0: { n: "BOF", f: parseuint16 },
      1: { n: "EOF" },
      2: { n: "CALCMODE" },
      3: { n: "CALCORDER" },
      4: { n: "SPLIT" },
      5: { n: "SYNC" },
      6: { n: "RANGE", f: parse_RANGE },
      7: { n: "WINDOW1" },
      8: { n: "COLW1" },
      9: { n: "WINTWO" },
      10: { n: "COLW2" },
      11: { n: "NAME" },
      12: { n: "BLANK" },
      13: { n: "INTEGER", f: parse_INTEGER },
      14: { n: "NUMBER", f: parse_NUMBER },
      15: { n: "LABEL", f: parse_LABEL },
      16: { n: "FORMULA", f: parse_FORMULA },
      24: { n: "TABLE" },
      25: { n: "ORANGE" },
      26: { n: "PRANGE" },
      27: { n: "SRANGE" },
      28: { n: "FRANGE" },
      29: { n: "KRANGE1" },
      32: { n: "HRANGE" },
      35: { n: "KRANGE2" },
      36: { n: "PROTEC" },
      37: { n: "FOOTER" },
      38: { n: "HEADER" },
      39: { n: "SETUP" },
      40: { n: "MARGINS" },
      41: { n: "LABELFMT" },
      42: { n: "TITLES" },
      43: { n: "SHEETJS" },
      45: { n: "GRAPH" },
      46: { n: "NGRAPH" },
      47: { n: "CALCCOUNT" },
      48: { n: "UNFORMATTED" },
      49: { n: "CURSORW12" },
      50: { n: "WINDOW" },
      51: { n: "STRING", f: parse_STRING },
      55: { n: "PASSWORD" },
      56: { n: "LOCKED" },
      60: { n: "QUERY" },
      61: { n: "QUERYNAME" },
      62: { n: "PRINT" },
      63: { n: "PRINTNAME" },
      64: { n: "GRAPH2" },
      65: { n: "GRAPHNAME" },
      66: { n: "ZOOM" },
      67: { n: "SYMSPLIT" },
      68: { n: "NSROWS" },
      69: { n: "NSCOLS" },
      70: { n: "RULER" },
      71: { n: "NNAME" },
      72: { n: "ACOMM" },
      73: { n: "AMACRO" },
      74: { n: "PARSE" },
102: { n: "PRANGES??" },
      103: { n: "RRANGES??" },
      104: { n: "FNAME??" },
      105: { n: "MRANGES??" },







204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
222: { n: "SHEETNAMELP", f: parse_SHEETNAMELP },
      255: { n: "BOF", f: parseuint16 },
      21506: { n: "WKSNF", f: parseuint16 },
      65535: { n: "" }
    };
    var WK3Enum = {
      0: { n: "BOF" },
      1: { n: "EOF" },
      2: { n: "PASSWORD" },
      3: { n: "CALCSET" },
      4: { n: "WINDOWSET" },
      5: { n: "SHEETCELLPTR" },
      6: { n: "SHEETLAYOUT" },
      7: { n: "COLUMNWIDTH" },
      8: { n: "HIDDENCOLUMN" },
      9: { n: "USERRANGE" },
      10: { n: "SYSTEMRANGE" },
      11: { n: "ZEROFORCE" },
      12: { n: "SORTKEYDIR" },
      13: { n: "FILESEAL" },
      14: { n: "DATAFILLNUMS" },
      15: { n: "PRINTMAIN" },
      16: { n: "PRINTSTRING" },
      17: { n: "GRAPHMAIN" },
      18: { n: "GRAPHSTRING" },
      19: { n: "??" },
      20: { n: "ERRCELL" },
      21: { n: "NACELL" },
      22: { n: "LABEL16", f: parse_LABEL_16 },
      23: { n: "NUMBER17", f: parse_NUMBER_17 },
      24: { n: "NUMBER18", f: parse_NUMBER_18 },
      25: { n: "FORMULA19", f: parse_FORMULA_19 },
      26: { n: "FORMULA1A" },
      27: { n: "XFORMAT", f: parse_XFORMAT },
      28: { n: "DTLABELMISC" },
      29: { n: "DTLABELCELL" },
      30: { n: "GRAPHWINDOW" },
      31: { n: "CPA" },
      32: { n: "LPLAUTO" },
      33: { n: "QUERY" },
      34: { n: "HIDDENSHEET" },
      35: { n: "??" },
      37: { n: "NUMBER25", f: parse_NUMBER_25 },
      38: { n: "??" },
      39: { n: "NUMBER27", f: parse_NUMBER_27 },
      40: { n: "FORMULA28", f: parse_FORMULA_28 },
      142: { n: "??" },
      147: { n: "??" },
      150: { n: "??" },
      151: { n: "??" },
      152: { n: "??" },
      153: { n: "??" },
      154: { n: "??" },
      155: { n: "??" },
      156: { n: "??" },
      163: { n: "??" },
      174: { n: "??" },
      175: { n: "??" },
      176: { n: "??" },
      177: { n: "??" },
      184: { n: "??" },
      185: { n: "??" },
      186: { n: "??" },
      187: { n: "??" },
      188: { n: "??" },
      195: { n: "??" },
      201: { n: "??" },
      204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
      205: { n: "??" },
      206: { n: "??" },
      207: { n: "??" },
      208: { n: "??" },
      256: { n: "??" },
      259: { n: "??" },
      260: { n: "??" },
      261: { n: "??" },
      262: { n: "??" },
      263: { n: "??" },
      265: { n: "??" },
      266: { n: "??" },
      267: { n: "??" },
      268: { n: "??" },
      270: { n: "??" },
      271: { n: "??" },
      384: { n: "??" },
      389: { n: "??" },
      390: { n: "??" },
      393: { n: "??" },
      396: { n: "??" },
      512: { n: "??" },
      514: { n: "??" },
      513: { n: "??" },
      516: { n: "??" },
      517: { n: "??" },
      640: { n: "??" },
      641: { n: "??" },
      642: { n: "??" },
      643: { n: "??" },
      644: { n: "??" },
      645: { n: "??" },
      646: { n: "??" },
      647: { n: "??" },
      648: { n: "??" },
      658: { n: "??" },
      659: { n: "??" },
      660: { n: "??" },
      661: { n: "??" },
      662: { n: "??" },
      665: { n: "??" },
      666: { n: "??" },
      768: { n: "??" },
      772: { n: "??" },
      1537: { n: "SHEETINFOQP", f: parse_SHEETINFOQP },
      1600: { n: "??" },
      1602: { n: "??" },
      1793: { n: "??" },
      1794: { n: "??" },
      1795: { n: "??" },
      1796: { n: "??" },
      1920: { n: "??" },
      2048: { n: "??" },
      2049: { n: "??" },
      2052: { n: "??" },
      2688: { n: "??" },
      10998: { n: "??" },
      12849: { n: "??" },
      28233: { n: "??" },
      28484: { n: "??" },
      65535: { n: "" }
    };
    var QPWNFTable = {
      5: "dd-mmm-yy",
      6: "dd-mmm",
      7: "mmm-yy",
      8: "mm/dd/yy",
10: "hh:mm:ss AM/PM",
      11: "hh:mm AM/PM",
      14: "dd-mmm-yyyy",
      15: "mmm-yyyy",
34: "0.00",
      50: "0.00;[Red]0.00",
      66: "0.00;(0.00)",
      82: "0.00;[Red](0.00)",
      162: '"$"#,##0.00;\\("$"#,##0.00\\)',
      288: "0%",
      304: "0E+00",
      320: "# ?/?"
    };
    function parse_qpw_str(p2) {
      var cch = p2.read_shift(2);
      var flags = p2.read_shift(1);
      if (flags != 0) throw "unsupported QPW string type " + flags.toString(16);
      return p2.read_shift(cch, "sbcs-cont");
    }
    function qpw_to_workbook_buf(d, opts) {
      prep_blob(d, 0);
      var o = opts || {};
      var s = {};
      if (o.dense) s["!data"] = [];
      var SST = [], sname = "";
      var range = { s: { r: -1, c: -1 }, e: { r: -1, c: -1 } };
      var cnt = 0, type = 0, C = 0, R = 0;
      var wb = { SheetNames: [], Sheets: {} };
      var FMTS = [];
      outer: while (d.l < d.length) {
        var RT = d.read_shift(2), length = d.read_shift(2);
        var p2 = d.slice(d.l, d.l + length);
        prep_blob(p2, 0);
        switch (RT) {
          case 1:
            if (p2.read_shift(4) != 962023505) throw "Bad QPW9 BOF!";
            break;
          case 2:
            break outer;
          case 8:
            break;
case 10:
            {
              var fcnt = p2.read_shift(4);
              var step = (p2.length - p2.l) / fcnt | 0;
              for (var ifmt = 0; ifmt < fcnt; ++ifmt) {
                var end = p2.l + step;
                var fmt = {};
                p2.l += 2;
                fmt.numFmtId = p2.read_shift(2);
                if (QPWNFTable[fmt.numFmtId]) fmt.z = QPWNFTable[fmt.numFmtId];
                p2.l = end;
                FMTS.push(fmt);
              }
            }
            break;
case 1025:
            break;
          case 1026:
            break;
          case 1031:
            {
              p2.l += 12;
              while (p2.l < p2.length) {
                cnt = p2.read_shift(2);
                type = p2.read_shift(1);
                SST.push(p2.read_shift(cnt, "cstr"));
              }
            }
            break;
          case 1032:
            break;
          case 1537:
            {
              var sidx = p2.read_shift(2);
              s = {};
              if (o.dense) s["!data"] = [];
              range.s.c = p2.read_shift(2);
              range.e.c = p2.read_shift(2);
              range.s.r = p2.read_shift(4);
              range.e.r = p2.read_shift(4);
              p2.l += 4;
              if (p2.l + 2 < p2.length) {
                cnt = p2.read_shift(2);
                type = p2.read_shift(1);
                sname = cnt == 0 ? "" : p2.read_shift(cnt, "cstr");
              }
              if (!sname) sname = encode_col(sidx);
            }
            break;
          case 1538:
            {
              if (range.s.c > 255 || range.s.r > 999999) break;
              if (range.e.c < range.s.c) range.e.c = range.s.c;
              if (range.e.r < range.s.r) range.e.r = range.s.r;
              s["!ref"] = encode_range(range);
              book_append_sheet(wb, s, sname);
            }
            break;
          case 2561:
            {
              C = p2.read_shift(2);
              if (range.e.c < C) range.e.c = C;
              if (range.s.c > C) range.s.c = C;
              R = p2.read_shift(4);
              if (range.s.r > R) range.s.r = R;
              R = p2.read_shift(4);
              if (range.e.r < R) range.e.r = R;
            }
            break;
          case 3073:
            {
              R = p2.read_shift(4), cnt = p2.read_shift(4);
              if (range.s.r > R) range.s.r = R;
              if (range.e.r < R + cnt - 1) range.e.r = R + cnt - 1;
              var CC = encode_col(C);
              while (p2.l < p2.length) {
                var cell = { t: "z" };
                var flags = p2.read_shift(1), fmtidx = -1;
                if (flags & 128) fmtidx = p2.read_shift(2);
                var mul = flags & 64 ? p2.read_shift(2) - 1 : 0;
                switch (flags & 31) {
                  case 0:
                    break;
                  case 1:
                    break;
                  case 2:
                    cell = { t: "n", v: p2.read_shift(2) };
                    break;
                  case 3:
                    cell = { t: "n", v: p2.read_shift(2, "i") };
                    break;
                  case 4:
                    cell = { t: "n", v: parse_RkNumber(p2) };
                    break;
                  case 5:
                    cell = { t: "n", v: p2.read_shift(8, "f") };
                    break;
                  case 7:
                    cell = { t: "s", v: SST[type = p2.read_shift(4) - 1] };
                    break;
                  case 8:
                    cell = { t: "n", v: p2.read_shift(8, "f") };
                    p2.l += 2;
                    p2.l += 4;
                    if (isNaN(cell.v)) cell = { t: "e", v: 15 };
                    break;
                  default:
                    throw "Unrecognized QPW cell type " + (flags & 31);
                }
                if (fmtidx != -1 && (FMTS[fmtidx - 1] || {}).z) cell.z = FMTS[fmtidx - 1].z;
                var delta = 0;
                if (flags & 32) switch (flags & 31) {
                  case 2:
                    delta = p2.read_shift(2);
                    break;
                  case 3:
                    delta = p2.read_shift(2, "i");
                    break;
                  case 7:
                    delta = p2.read_shift(2);
                    break;
                  default:
                    throw "Unsupported delta for QPW cell type " + (flags & 31);
                }
                if (!(!o.sheetStubs && cell.t == "z")) {
                  var newcell = dup(cell);
                  if (cell.t == "n" && cell.z && fmt_is_date(cell.z) && o.cellDates) {
                    newcell.v = numdate(cell.v);
                    newcell.t = typeof newcell.v == "number" ? "n" : "d";
                  }
                  if (s["!data"] != null) {
                    if (!s["!data"][R]) s["!data"][R] = [];
                    s["!data"][R][C] = newcell;
                  } else s[CC + encode_row(R)] = newcell;
                }
                ++R;
                --cnt;
                while (mul-- > 0 && cnt >= 0) {
                  if (flags & 32) switch (flags & 31) {
                    case 2:
                      cell = { t: "n", v: cell.v + delta & 65535 };
                      break;
                    case 3:
                      cell = { t: "n", v: cell.v + delta & 65535 };
                      if (cell.v > 32767) cell.v -= 65536;
                      break;
                    case 7:
                      cell = { t: "s", v: SST[type = type + delta >>> 0] };
                      break;
                    default:
                      throw "Cannot apply delta for QPW cell type " + (flags & 31);
                  }
                  else switch (flags & 31) {
                    case 1:
                      cell = { t: "z" };
                      break;
                    case 2:
                      cell = { t: "n", v: p2.read_shift(2) };
                      break;
                    case 7:
                      cell = { t: "s", v: SST[type = p2.read_shift(4) - 1] };
                      break;
                    default:
                      throw "Cannot apply repeat for QPW cell type " + (flags & 31);
                  }
                  if (!(!o.sheetStubs && cell.t == "z")) {
                    if (s["!data"] != null) {
                      if (!s["!data"][R]) s["!data"][R] = [];
                      s["!data"][R][C] = cell;
                    } else s[CC + encode_row(R)] = cell;
                  }
                  ++R;
                  --cnt;
                }
              }
            }
            break;
          case 3074:
            {
              C = p2.read_shift(2);
              R = p2.read_shift(4);
              var str = parse_qpw_str(p2);
              if (s["!data"] != null) {
                if (!s["!data"][R]) s["!data"][R] = [];
                s["!data"][R][C] = { t: "s", v: str };
              } else s[encode_col(C) + encode_row(R)] = { t: "s", v: str };
            }
            break;
        }
        d.l += length;
      }
      return wb;
    }
    return {
      sheet_to_wk1,
      book_to_wk3,
      to_workbook: lotus_to_workbook
    };
  })();
  function parse_rpr(rpr) {
    var font = {}, m = rpr.match(tagregex), i = 0;
    var pass = false;
    if (m) for (; i != m.length; ++i) {
      var y = parsexmltag(m[i]);
      switch (y[0].replace(/<\w*:/g, "<")) {

case "<condense":
          break;

case "<extend":
          break;

case "<shadow":
          if (!y.val) break;
case "<shadow>":
        case "<shadow/>":
          font.shadow = 1;
          break;
        case "</shadow>":
          break;
case "<charset":
          if (y.val == "1") break;
          font.cp = CS2CP[parseInt(y.val, 10)];
          break;
case "<outline":
          if (!y.val) break;
case "<outline>":
        case "<outline/>":
          font.outline = 1;
          break;
        case "</outline>":
          break;
case "<rFont":
          font.name = y.val;
          break;
case "<sz":
          font.sz = y.val;
          break;
case "<strike":
          if (!y.val) break;
case "<strike>":
        case "<strike/>":
          font.strike = 1;
          break;
        case "</strike>":
          break;
case "<u":
          if (!y.val) break;
          switch (y.val) {
            case "double":
              font.uval = "double";
              break;
            case "singleAccounting":
              font.uval = "single-accounting";
              break;
            case "doubleAccounting":
              font.uval = "double-accounting";
              break;
          }
case "<u>":
        case "<u/>":
          font.u = 1;
          break;
        case "</u>":
          break;
case "<b":
          if (y.val == "0") break;
case "<b>":
        case "<b/>":
          font.b = 1;
          break;
        case "</b>":
          break;
case "<i":
          if (y.val == "0") break;
case "<i>":
        case "<i/>":
          font.i = 1;
          break;
        case "</i>":
          break;
case "<color":
          if (y.rgb) font.color = y.rgb.slice(2, 8);
          break;
        case "<color>":
        case "<color/>":
        case "</color>":
          break;
case "<family":
          font.family = y.val;
          break;
        case "<family>":
        case "<family/>":
        case "</family>":
          break;
case "<vertAlign":
          font.valign = y.val;
          break;
        case "<vertAlign>":
        case "<vertAlign/>":
        case "</vertAlign>":
          break;
case "<scheme":
          break;
        case "<scheme>":
        case "<scheme/>":
        case "</scheme>":
          break;
case "<extLst":
        case "<extLst>":
        case "</extLst>":
          break;
        case "<ext":
          pass = true;
          break;
        case "</ext>":
          pass = false;
          break;
        default:
          if (y[0].charCodeAt(1) !== 47 && !pass) throw new Error("Unrecognized rich format " + y[0]);
      }
    }
    return font;
  }
  var parse_rs = (function() {
    function parse_r(r2) {
      var t = str_match_xml_ns(r2, "t");
      if (!t) return { t: "s", v: "" };
      var o = { t: "s", v: unescapexml(t[1]) };
      var rpr = str_match_xml_ns(r2, "rPr");
      if (rpr) o.s = parse_rpr(rpr[1]);
      return o;
    }
    var rregex = /<(?:\w+:)?r>/g, rend = /<\/(?:\w+:)?r>/;
    return function parse_rs2(rs) {
      return rs.replace(rregex, "").split(rend).map(parse_r).filter(function(r2) {
        return r2.v;
      });
    };
  })();
  var rs_to_html = (function parse_rs_factory() {
    var nlregex = /(\r\n|\n)/g;
    function parse_rpr2(font, intro, outro) {
      var style = [];
      if (font.u) style.push("text-decoration: underline;");
      if (font.uval) style.push("text-underline-style:" + font.uval + ";");
      if (font.sz) style.push("font-size:" + font.sz + "pt;");
      if (font.outline) style.push("text-effect: outline;");
      if (font.shadow) style.push("text-shadow: auto;");
      intro.push('<span style="' + style.join("") + '">');
      if (font.b) {
        intro.push("<b>");
        outro.push("</b>");
      }
      if (font.i) {
        intro.push("<i>");
        outro.push("</i>");
      }
      if (font.strike) {
        intro.push("<s>");
        outro.push("</s>");
      }
      var align = font.valign || "";
      if (align == "superscript" || align == "super") align = "sup";
      else if (align == "subscript") align = "sub";
      if (align != "") {
        intro.push("<" + align + ">");
        outro.push("</" + align + ">");
      }
      outro.push("</span>");
      return font;
    }
    function r_to_html(r2) {
      var terms = [[], r2.v, []];
      if (!r2.v) return "";
      if (r2.s) parse_rpr2(r2.s, terms[0], terms[2]);
      return terms[0].join("") + terms[1].replace(nlregex, "<br/>") + terms[2].join("");
    }
    return function parse_rs2(rs) {
      return rs.map(r_to_html).join("");
    };
  })();
  var sitregex = /<(?:\w+:)?t\b[^<>]*>([^<]*)<\/(?:\w+:)?t>/g, sirregex = /<(?:\w+:)?r\b[^<>]*>/;
  function parse_si(x, opts) {
    var html = opts ? opts.cellHTML : true;
    var z = {};
    if (!x) return { t: "" };
    if (x.match(/^\s*<(?:\w+:)?t[^>]*>/)) {
      z.t = unescapexml(utf8read(x.slice(x.indexOf(">") + 1).split(/<\/(?:\w+:)?t>/)[0] || ""), true);
      z.r = utf8read(x);
      if (html) z.h = escapehtml(z.t);
    } else if (
x.match(sirregex)
    ) {
      z.r = utf8read(x);
      z.t = unescapexml(utf8read((str_remove_xml_ns_g(x, "rPh").match(sitregex) || []).join("").replace(tagregex, "")), true);
      if (html) z.h = rs_to_html(parse_rs(z.r));
    }
    return z;
  }
  var sstr1 = /<(?:\w+:)?(?:si|sstItem)>/g;
  var sstr2 = /<\/(?:\w+:)?(?:si|sstItem)>/;
  function parse_sst_xml(data, opts) {
    var s = [], ss = "";
    if (!data) return s;
    var sst = str_match_xml_ns(data, "sst");
    if (sst) {
      ss = sst[1].replace(sstr1, "").split(sstr2);
      for (var i = 0; i != ss.length; ++i) {
        var o = parse_si(ss[i].trim(), opts);
        if (o != null) s[s.length] = o;
      }
      sst = parsexmltag(sst[0].slice(0, sst[0].indexOf(">")));
      s.Count = sst.count;
      s.Unique = sst.uniqueCount;
    }
    return s;
  }
  var straywsregex = /^\s|\s$|[\t\n\r]/;
  function write_sst_xml(sst, opts) {
    if (!opts.bookSST) return "";
    var o = [XML_HEADER];
    o[o.length] = writextag("sst", null, {
      xmlns: XMLNS_main[0],
      count: sst.Count,
      uniqueCount: sst.Unique
    });
    for (var i = 0; i != sst.length; ++i) {
      if (sst[i] == null) continue;
      var s = sst[i];
      var sitag = "<si>";
      if (s.r) sitag += s.r;
      else {
        sitag += "<t";
        if (!s.t) s.t = "";
        if (typeof s.t !== "string") s.t = String(s.t);
        if (s.t.match(straywsregex)) sitag += ' xml:space="preserve"';
        sitag += ">" + escapexml(s.t) + "</t>";
      }
      sitag += "</si>";
      o[o.length] = sitag;
    }
    if (o.length > 2) {
      o[o.length] = "</sst>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  function parse_BrtBeginSst(data) {
    return [data.read_shift(4), data.read_shift(4)];
  }
  function parse_sst_bin(data, opts) {
    var s = [];
    var pass = false;
    recordhopper(data, function hopper_sst(val2, R, RT) {
      switch (RT) {
        case 159:
          s.Count = val2[0];
          s.Unique = val2[1];
          break;
        case 19:
          s.push(val2);
          break;
        case 160:
          return true;
        case 35:
          pass = true;
          break;
        case 36:
          pass = false;
          break;
        default:
          if (R.T) ;
          if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
      }
    });
    return s;
  }
  function write_BrtBeginSst(sst, o) {
    if (!o) o = new_buf(8);
    o.write_shift(4, sst.Count);
    o.write_shift(4, sst.Unique);
    return o;
  }
  var write_BrtSSTItem = write_RichStr;
  function write_sst_bin(sst) {
    var ba = buf_array();
    write_record(ba, 159, write_BrtBeginSst(sst));
    for (var i = 0; i < sst.length; ++i) write_record(ba, 19, write_BrtSSTItem(sst[i]));
    write_record(
      ba,
      160
);
    return ba.end();
  }
  function _JS2ANSI(str) {
    if (typeof $cptable !== "undefined") return $cptable.utils.encode(current_ansi, str);
    var o = [], oo = str.split("");
    for (var i = 0; i < oo.length; ++i) o[i] = oo[i].charCodeAt(0);
    return o;
  }
  function parse_CRYPTOVersion(blob, length) {
    var o = {};
    o.Major = blob.read_shift(2);
    o.Minor = blob.read_shift(2);
    if (length >= 4) blob.l += length - 4;
    return o;
  }
  function parse_DataSpaceVersionInfo(blob) {
    var o = {};
    o.id = blob.read_shift(0, "lpp4");
    o.R = parse_CRYPTOVersion(blob, 4);
    o.U = parse_CRYPTOVersion(blob, 4);
    o.W = parse_CRYPTOVersion(blob, 4);
    return o;
  }
  function parse_DataSpaceMapEntry(blob) {
    var len = blob.read_shift(4);
    var end = blob.l + len - 4;
    var o = {};
    var cnt = blob.read_shift(4);
    var comps = [];
    while (cnt-- > 0) comps.push({ t: blob.read_shift(4), v: blob.read_shift(0, "lpp4") });
    o.name = blob.read_shift(0, "lpp4");
    o.comps = comps;
    if (blob.l != end) throw new Error("Bad DataSpaceMapEntry: " + blob.l + " != " + end);
    return o;
  }
  function parse_DataSpaceMap(blob) {
    var o = [];
    blob.l += 4;
    var cnt = blob.read_shift(4);
    while (cnt-- > 0) o.push(parse_DataSpaceMapEntry(blob));
    return o;
  }
  function parse_DataSpaceDefinition(blob) {
    var o = [];
    blob.l += 4;
    var cnt = blob.read_shift(4);
    while (cnt-- > 0) o.push(blob.read_shift(0, "lpp4"));
    return o;
  }
  function parse_TransformInfoHeader(blob) {
    var o = {};
    blob.read_shift(4);
    blob.l += 4;
    o.id = blob.read_shift(0, "lpp4");
    o.name = blob.read_shift(0, "lpp4");
    o.R = parse_CRYPTOVersion(blob, 4);
    o.U = parse_CRYPTOVersion(blob, 4);
    o.W = parse_CRYPTOVersion(blob, 4);
    return o;
  }
  function parse_Primary(blob) {
    var hdr = parse_TransformInfoHeader(blob);
    hdr.ename = blob.read_shift(0, "8lpp4");
    hdr.blksz = blob.read_shift(4);
    hdr.cmode = blob.read_shift(4);
    if (blob.read_shift(4) != 4) throw new Error("Bad !Primary record");
    return hdr;
  }
  function parse_EncryptionHeader(blob, length) {
    var tgt = blob.l + length;
    var o = {};
    o.Flags = blob.read_shift(4) & 63;
    blob.l += 4;
    o.AlgID = blob.read_shift(4);
    var valid = false;
    switch (o.AlgID) {
      case 26126:
      case 26127:
      case 26128:
        valid = o.Flags == 36;
        break;
      case 26625:
        valid = o.Flags == 4;
        break;
      case 0:
        valid = o.Flags == 16 || o.Flags == 4 || o.Flags == 36;
        break;
      default:
        throw "Unrecognized encryption algorithm: " + o.AlgID;
    }
    if (!valid) throw new Error("Encryption Flags/AlgID mismatch");
    o.AlgIDHash = blob.read_shift(4);
    o.KeySize = blob.read_shift(4);
    o.ProviderType = blob.read_shift(4);
    blob.l += 8;
    o.CSPName = blob.read_shift(tgt - blob.l >> 1, "utf16le");
    blob.l = tgt;
    return o;
  }
  function parse_EncryptionVerifier(blob, length) {
    var o = {}, tgt = blob.l + length;
    blob.l += 4;
    o.Salt = blob.slice(blob.l, blob.l + 16);
    blob.l += 16;
    o.Verifier = blob.slice(blob.l, blob.l + 16);
    blob.l += 16;
    blob.read_shift(4);
    o.VerifierHash = blob.slice(blob.l, tgt);
    blob.l = tgt;
    return o;
  }
  function parse_EncryptionInfo(blob) {
    var vers = parse_CRYPTOVersion(blob);
    switch (vers.Minor) {
      case 2:
        return [vers.Minor, parse_EncInfoStd(blob)];
      case 3:
        return [vers.Minor, parse_EncInfoExt()];
      case 4:
        return [vers.Minor, parse_EncInfoAgl(blob)];
    }
    throw new Error("ECMA-376 Encrypted file unrecognized Version: " + vers.Minor);
  }
  function parse_EncInfoStd(blob) {
    var flags = blob.read_shift(4);
    if ((flags & 63) != 36) throw new Error("EncryptionInfo mismatch");
    var sz = blob.read_shift(4);
    var hdr = parse_EncryptionHeader(blob, sz);
    var verifier = parse_EncryptionVerifier(blob, blob.length - blob.l);
    return { t: "Std", h: hdr, v: verifier };
  }
  function parse_EncInfoExt() {
    throw new Error("File is password-protected: ECMA-376 Extensible");
  }
  function parse_EncInfoAgl(blob) {
    var KeyData = ["saltSize", "blockSize", "keyBits", "hashSize", "cipherAlgorithm", "cipherChaining", "hashAlgorithm", "saltValue"];
    blob.l += 4;
    var xml = blob.read_shift(blob.length - blob.l, "utf8");
    var o = {};
    xml.replace(tagregex, function xml_agile(x) {
      var y = parsexmltag(x);
      switch (strip_ns(y[0])) {
        case "<?xml":
          break;
        case "<encryption":
        case "</encryption>":
          break;
        case "<keyData":
          KeyData.forEach(function(k) {
            o[k] = y[k];
          });
          break;
        case "<dataIntegrity":
          o.encryptedHmacKey = y.encryptedHmacKey;
          o.encryptedHmacValue = y.encryptedHmacValue;
          break;
        case "<keyEncryptors>":
        case "<keyEncryptors":
          o.encs = [];
          break;
        case "</keyEncryptors>":
          break;
        case "<keyEncryptor":
          o.uri = y.uri;
          break;
        case "</keyEncryptor>":
          break;
        case "<encryptedKey":
          o.encs.push(y);
          break;
        default:
          throw y[0];
      }
    });
    return o;
  }
  function parse_RC4CryptoHeader(blob, length) {
    var o = {};
    var vers = o.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4);
    length -= 4;
    if (vers.Minor != 2) throw new Error("unrecognized minor version code: " + vers.Minor);
    if (vers.Major > 4 || vers.Major < 2) throw new Error("unrecognized major version code: " + vers.Major);
    o.Flags = blob.read_shift(4);
    length -= 4;
    var sz = blob.read_shift(4);
    length -= 4;
    o.EncryptionHeader = parse_EncryptionHeader(blob, sz);
    length -= sz;
    o.EncryptionVerifier = parse_EncryptionVerifier(blob, length);
    return o;
  }
  function parse_RC4Header(blob) {
    var o = {};
    var vers = o.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4);
    if (vers.Major != 1 || vers.Minor != 1) throw "unrecognized version code " + vers.Major + " : " + vers.Minor;
    o.Salt = blob.read_shift(16);
    o.EncryptedVerifier = blob.read_shift(16);
    o.EncryptedVerifierHash = blob.read_shift(16);
    return o;
  }
  function crypto_CreatePasswordVerifier_Method1(Password) {
    var Verifier = 0, PasswordArray;
    var PasswordDecoded = _JS2ANSI(Password);
    var len = PasswordDecoded.length + 1, i, PasswordByte;
    var Intermediate1, Intermediate2, Intermediate3;
    PasswordArray = new_raw_buf(len);
    PasswordArray[0] = PasswordDecoded.length;
    for (i = 1; i != len; ++i) PasswordArray[i] = PasswordDecoded[i - 1];
    for (i = len - 1; i >= 0; --i) {
      PasswordByte = PasswordArray[i];
      Intermediate1 = (Verifier & 16384) === 0 ? 0 : 1;
      Intermediate2 = Verifier << 1 & 32767;
      Intermediate3 = Intermediate1 | Intermediate2;
      Verifier = Intermediate3 ^ PasswordByte;
    }
    return Verifier ^ 52811;
  }
  var crypto_CreateXorArray_Method1 = (function() {
    var PadArray = [187, 255, 255, 186, 255, 255, 185, 128, 0, 190, 15, 0, 191, 15, 0];
    var InitialCode = [57840, 7439, 52380, 33984, 4364, 3600, 61902, 12606, 6258, 57657, 54287, 34041, 10252, 43370, 20163];
    var XorMatrix = [44796, 19929, 39858, 10053, 20106, 40212, 10761, 31585, 63170, 64933, 60267, 50935, 40399, 11199, 17763, 35526, 1453, 2906, 5812, 11624, 23248, 885, 1770, 3540, 7080, 14160, 28320, 56640, 55369, 41139, 20807, 41614, 21821, 43642, 17621, 28485, 56970, 44341, 19019, 38038, 14605, 29210, 60195, 50791, 40175, 10751, 21502, 43004, 24537, 18387, 36774, 3949, 7898, 15796, 31592, 63184, 47201, 24803, 49606, 37805, 14203, 28406, 56812, 17824, 35648, 1697, 3394, 6788, 13576, 27152, 43601, 17539, 35078, 557, 1114, 2228, 4456, 30388, 60776, 51953, 34243, 7079, 14158, 28316, 14128, 28256, 56512, 43425, 17251, 34502, 7597, 13105, 26210, 52420, 35241, 883, 1766, 3532, 4129, 8258, 16516, 33032, 4657, 9314, 18628];
    var Ror = function(Byte) {
      return (Byte / 2 | Byte * 128) & 255;
    };
    var XorRor = function(byte1, byte2) {
      return Ror(byte1 ^ byte2);
    };
    var CreateXorKey_Method1 = function(Password) {
      var XorKey = InitialCode[Password.length - 1];
      var CurrentElement = 104;
      for (var i = Password.length - 1; i >= 0; --i) {
        var Char = Password[i];
        for (var j = 0; j != 7; ++j) {
          if (Char & 64) XorKey ^= XorMatrix[CurrentElement];
          Char *= 2;
          --CurrentElement;
        }
      }
      return XorKey;
    };
    return function(password) {
      var Password = _JS2ANSI(password);
      var XorKey = CreateXorKey_Method1(Password);
      var Index = Password.length;
      var ObfuscationArray = new_raw_buf(16);
      for (var i = 0; i != 16; ++i) ObfuscationArray[i] = 0;
      var Temp, PasswordLastChar, PadIndex;
      if ((Index & 1) === 1) {
        Temp = XorKey >> 8;
        ObfuscationArray[Index] = XorRor(PadArray[0], Temp);
        --Index;
        Temp = XorKey & 255;
        PasswordLastChar = Password[Password.length - 1];
        ObfuscationArray[Index] = XorRor(PasswordLastChar, Temp);
      }
      while (Index > 0) {
        --Index;
        Temp = XorKey >> 8;
        ObfuscationArray[Index] = XorRor(Password[Index], Temp);
        --Index;
        Temp = XorKey & 255;
        ObfuscationArray[Index] = XorRor(Password[Index], Temp);
      }
      Index = 15;
      PadIndex = 15 - Password.length;
      while (PadIndex > 0) {
        Temp = XorKey >> 8;
        ObfuscationArray[Index] = XorRor(PadArray[PadIndex], Temp);
        --Index;
        --PadIndex;
        Temp = XorKey & 255;
        ObfuscationArray[Index] = XorRor(Password[Index], Temp);
        --Index;
        --PadIndex;
      }
      return ObfuscationArray;
    };
  })();
  var crypto_DecryptData_Method1 = function(password, Data, XorArrayIndex, XorArray, O) {
    if (!O) O = Data;
    if (!XorArray) XorArray = crypto_CreateXorArray_Method1(password);
    var Index, Value;
    for (Index = 0; Index != Data.length; ++Index) {
      Value = Data[Index];
      Value ^= XorArray[XorArrayIndex];
      Value = (Value >> 5 | Value << 3) & 255;
      O[Index] = Value;
      ++XorArrayIndex;
    }
    return [O, XorArrayIndex, XorArray];
  };
  var crypto_MakeXorDecryptor = function(password) {
    var XorArrayIndex = 0, XorArray = crypto_CreateXorArray_Method1(password);
    return function(Data) {
      var O = crypto_DecryptData_Method1("", Data, XorArrayIndex, XorArray);
      XorArrayIndex = O[1];
      return O[0];
    };
  };
  function parse_XORObfuscation(blob, length, opts, out) {
    var o = { key: parseuint16(blob), verificationBytes: parseuint16(blob) };
    if (opts.password) o.verifier = crypto_CreatePasswordVerifier_Method1(opts.password);
    out.valid = o.verificationBytes === o.verifier;
    if (out.valid) out.insitu = crypto_MakeXorDecryptor(opts.password);
    return o;
  }
  function parse_FilePassHeader(blob, length, oo) {
    var o = oo || {};
    o.Info = blob.read_shift(2);
    blob.l -= 2;
    if (o.Info === 1) o.Data = parse_RC4Header(blob);
    else o.Data = parse_RC4CryptoHeader(blob, length);
    return o;
  }
  function parse_FilePass(blob, length, opts) {
    var o = { Type: opts.biff >= 8 ? blob.read_shift(2) : 0 };
    if (o.Type) parse_FilePassHeader(blob, length - 2, o);
    else parse_XORObfuscation(blob, opts.biff >= 8 ? length : length - 2, opts, o);
    return o;
  }
  function rtf_to_sheet(d, opts) {
    switch (opts.type) {
      case "base64":
        return rtf_to_sheet_str(Base64_decode(d), opts);
      case "binary":
        return rtf_to_sheet_str(d, opts);
      case "buffer":
        return rtf_to_sheet_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
      case "array":
        return rtf_to_sheet_str(cc2str(d), opts);
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function rtf_to_sheet_str(str, opts) {
    var o = opts || {};
    var ws = {};
    var dense = o.dense;
    if (dense)
      ws["!data"] = [];
    var rows = str_match_ng(str, "\\trowd", "\\row");
    if (!rows)
      throw new Error("RTF missing table");
    var range = { s: { c: 0, r: 0 }, e: { c: 0, r: rows.length - 1 } };
    var row = [];
    rows.forEach(function(rowtf, R) {
      if (dense)
        row = ws["!data"][R] = [];
      var rtfre = /\\[\w\-]+\b/g;
      var last_index = 0;
      var res;
      var C = -1;
      var payload = [];
      while ((res = rtfre.exec(rowtf)) != null) {
        var data = rowtf.slice(last_index, rtfre.lastIndex - res[0].length);
        if (data.charCodeAt(0) == 32)
          data = data.slice(1);
        if (data.length)
          payload.push(data);
        switch (res[0]) {
          case "\\cell":
            ++C;
            if (payload.length) {
              var cell = { v: payload.join(""), t: "s" };
              if (cell.v == "TRUE" || cell.v == "FALSE") {
                cell.v = cell.v == "TRUE";
                cell.t = "b";
              } else if (!isNaN(fuzzynum(cell.v))) {
                cell.t = "n";
                if (o.cellText !== false)
                  cell.w = cell.v;
                cell.v = fuzzynum(cell.v);
              } else if (RBErr[cell.v] != null) {
                cell.t = "e";
                cell.w = cell.v;
                cell.v = RBErr[cell.v];
              }
              if (dense)
                row[C] = cell;
              else
                ws[encode_cell({ r: R, c: C })] = cell;
            }
            payload = [];
            break;
          case "\\par":
            payload.push("\n");
            break;
        }
        last_index = rtfre.lastIndex;
      }
      if (C > range.e.c)
        range.e.c = C;
    });
    ws["!ref"] = encode_range(range);
    return ws;
  }
  function rtf_to_workbook(d, opts) {
    var wb = sheet_to_workbook(rtf_to_sheet(d, opts), opts);
    wb.bookType = "rtf";
    return wb;
  }
  function sheet_to_rtf(ws, opts) {
    var o = ["{\\rtf1\\ansi"];
    if (!ws["!ref"])
      return o[0] + "}";
    var r2 = safe_decode_range(ws["!ref"]), cell;
    var dense = ws["!data"] != null, row = [];
    for (var R = r2.s.r; R <= r2.e.r; ++R) {
      o.push("\\trowd\\trautofit1");
      for (var C = r2.s.c; C <= r2.e.c; ++C)
        o.push("\\cellx" + (C + 1));
      o.push("\\pard\\intbl");
      if (dense)
        row = ws["!data"][R] || [];
      for (C = r2.s.c; C <= r2.e.c; ++C) {
        var coord = encode_cell({ r: R, c: C });
        cell = dense ? row[C] : ws[coord];
        if (!cell || cell.v == null && (!cell.f || cell.F)) {
          o.push(" \\cell");
          continue;
        }
        o.push(" " + (cell.w || (format_cell(cell), cell.w) || "").replace(/[\r\n]/g, "\\par "));
        o.push("\\cell");
      }
      o.push("\\pard\\intbl\\row");
    }
    return o.join("") + "}";
  }
  function hex2RGB(h2) {
    var o = h2.slice(h2[0] === "#" ? 1 : 0).slice(0, 6);
    return [parseInt(o.slice(0, 2), 16), parseInt(o.slice(2, 4), 16), parseInt(o.slice(4, 6), 16)];
  }
  function rgb2Hex(rgb) {
    for (var i = 0, o = 1; i != 3; ++i) o = o * 256 + (rgb[i] > 255 ? 255 : rgb[i] < 0 ? 0 : rgb[i]);
    return o.toString(16).toUpperCase().slice(1);
  }
  function rgb2HSL(rgb) {
    var R = rgb[0] / 255, G = rgb[1] / 255, B = rgb[2] / 255;
    var M = Math.max(R, G, B), m = Math.min(R, G, B), C = M - m;
    if (C === 0) return [0, 0, R];
    var H6 = 0, S = 0, L2 = M + m;
    S = C / (L2 > 1 ? 2 - L2 : L2);
    switch (M) {
      case R:
        H6 = ((G - B) / C + 6) % 6;
        break;
      case G:
        H6 = (B - R) / C + 2;
        break;
      case B:
        H6 = (R - G) / C + 4;
        break;
    }
    return [H6 / 6, S, L2 / 2];
  }
  function hsl2RGB(hsl) {
    var H = hsl[0], S = hsl[1], L = hsl[2];
    var C = S * 2 * (L < 0.5 ? L : 1 - L), m = L - C / 2;
    var rgb = [m, m, m], h6 = 6 * H;
    var X;
    if (S !== 0) switch (h6 | 0) {
      case 0:
      case 6:
        X = C * h6;
        rgb[0] += C;
        rgb[1] += X;
        break;
      case 1:
        X = C * (2 - h6);
        rgb[0] += X;
        rgb[1] += C;
        break;
      case 2:
        X = C * (h6 - 2);
        rgb[1] += C;
        rgb[2] += X;
        break;
      case 3:
        X = C * (4 - h6);
        rgb[1] += X;
        rgb[2] += C;
        break;
      case 4:
        X = C * (h6 - 4);
        rgb[2] += C;
        rgb[0] += X;
        break;
      case 5:
        X = C * (6 - h6);
        rgb[2] += X;
        rgb[0] += C;
        break;
    }
    for (var i = 0; i != 3; ++i) rgb[i] = Math.round(rgb[i] * 255);
    return rgb;
  }
  function rgb_tint(hex, tint) {
    if (tint === 0) return hex;
    var hsl = rgb2HSL(hex2RGB(hex));
    if (tint < 0) hsl[2] = hsl[2] * (1 + tint);
    else hsl[2] = 1 - (1 - hsl[2]) * (1 - tint);
    return rgb2Hex(hsl2RGB(hsl));
  }
  var DEF_MDW = 6, MAX_MDW = 15, MIN_MDW = 1, MDW = DEF_MDW;
  function width2px(width) {
    return Math.floor((width + Math.round(128 / MDW) / 256) * MDW);
  }
  function px2char(px) {
    return Math.floor((px - 5) / MDW * 100 + 0.5) / 100;
  }
  function char2width(chr) {
    return Math.round((chr * MDW + 5) / MDW * 256) / 256;
  }
  function cycle_width(collw) {
    return char2width(px2char(width2px(collw)));
  }
  function find_mdw_colw(collw) {
    var delta = Math.abs(collw - cycle_width(collw)), _MDW = MDW;
    if (delta > 5e-3) {
      for (MDW = MIN_MDW; MDW < MAX_MDW; ++MDW) if (Math.abs(collw - cycle_width(collw)) <= delta) {
        delta = Math.abs(collw - cycle_width(collw));
        _MDW = MDW;
      }
    }
    MDW = _MDW;
  }
  function process_col(coll) {
    if (coll.width) {
      coll.wpx = width2px(coll.width);
      coll.wch = px2char(coll.wpx);
      coll.MDW = MDW;
    } else if (coll.wpx) {
      coll.wch = px2char(coll.wpx);
      coll.width = char2width(coll.wch);
      coll.MDW = MDW;
    } else if (typeof coll.wch == "number") {
      coll.width = char2width(coll.wch);
      coll.wpx = width2px(coll.width);
      coll.MDW = MDW;
    }
    if (coll.customWidth) delete coll.customWidth;
  }
  var DEF_PPI = 96, PPI = DEF_PPI;
  function px2pt(px) {
    return px * 96 / PPI;
  }
  function pt2px(pt) {
    return pt * PPI / 96;
  }
  var XLMLPatternTypeMap = {
    "None": "none",
    "Solid": "solid",
    "Gray50": "mediumGray",
    "Gray75": "darkGray",
    "Gray25": "lightGray",
    "HorzStripe": "darkHorizontal",
    "VertStripe": "darkVertical",
    "ReverseDiagStripe": "darkDown",
    "DiagStripe": "darkUp",
    "DiagCross": "darkGrid",
    "ThickDiagCross": "darkTrellis",
    "ThinHorzStripe": "lightHorizontal",
    "ThinVertStripe": "lightVertical",
    "ThinReverseDiagStripe": "lightDown",
    "ThinHorzCross": "lightGrid"
  };
  function parse_borders(t, styles, themes, opts) {
    styles.Borders = [];
    var border = {};
    var pass = false;
    (t.match(tagregex) || []).forEach(function(x) {
      var y = parsexmltag(x);
      switch (strip_ns(y[0])) {
        case "<borders":
        case "<borders>":
        case "</borders>":
          break;
case "<border":
        case "<border>":
        case "<border/>":
          border =
{};
          if (y.diagonalUp) border.diagonalUp = parsexmlbool(y.diagonalUp);
          if (y.diagonalDown) border.diagonalDown = parsexmlbool(y.diagonalDown);
          styles.Borders.push(border);
          break;
        case "</border>":
          break;
case "<left/>":
          break;
        case "<left":
        case "<left>":
          break;
        case "</left>":
          break;
case "<right/>":
          break;
        case "<right":
        case "<right>":
          break;
        case "</right>":
          break;
case "<top/>":
          break;
        case "<top":
        case "<top>":
          break;
        case "</top>":
          break;
case "<bottom/>":
          break;
        case "<bottom":
        case "<bottom>":
          break;
        case "</bottom>":
          break;
case "<diagonal":
        case "<diagonal>":
        case "<diagonal/>":
          break;
        case "</diagonal>":
          break;
case "<horizontal":
        case "<horizontal>":
        case "<horizontal/>":
          break;
        case "</horizontal>":
          break;
case "<vertical":
        case "<vertical>":
        case "<vertical/>":
          break;
        case "</vertical>":
          break;
case "<start":
        case "<start>":
        case "<start/>":
          break;
        case "</start>":
          break;
case "<end":
        case "<end>":
        case "<end/>":
          break;
        case "</end>":
          break;
case "<color":
        case "<color>":
          break;
        case "<color/>":
        case "</color>":
          break;
case "<extLst":
        case "<extLst>":
        case "</extLst>":
          break;
        case "<ext":
          pass = true;
          break;
        case "</ext>":
          pass = false;
          break;
        default:
          if (opts && opts.WTF) {
            if (!pass) throw new Error("unrecognized " + y[0] + " in borders");
          }
      }
    });
  }
  function parse_fills(t, styles, themes, opts) {
    styles.Fills = [];
    var fill2 = {};
    var pass = false;
    (t.match(tagregex) || []).forEach(function(x) {
      var y = parsexmltag(x);
      switch (strip_ns(y[0])) {
        case "<fills":
        case "<fills>":
        case "</fills>":
          break;
case "<fill>":
        case "<fill":
        case "<fill/>":
          fill2 = {};
          styles.Fills.push(fill2);
          break;
        case "</fill>":
          break;
case "<gradientFill>":
          break;
        case "<gradientFill":
        case "</gradientFill>":
          styles.Fills.push(fill2);
          fill2 = {};
          break;
case "<patternFill":
        case "<patternFill>":
          if (y.patternType) fill2.patternType = y.patternType;
          break;
        case "<patternFill/>":
        case "</patternFill>":
          break;
case "<bgColor":
          if (!fill2.bgColor) fill2.bgColor = {};
          if (y.indexed) fill2.bgColor.indexed = parseInt(y.indexed, 10);
          if (y.theme) fill2.bgColor.theme = parseInt(y.theme, 10);
          if (y.tint) fill2.bgColor.tint = parseFloat(y.tint);
          if (y.rgb) fill2.bgColor.rgb = y.rgb.slice(-6);
          break;
        case "<bgColor/>":
        case "</bgColor>":
          break;
case "<fgColor":
          if (!fill2.fgColor) fill2.fgColor = {};
          if (y.theme) fill2.fgColor.theme = parseInt(y.theme, 10);
          if (y.tint) fill2.fgColor.tint = parseFloat(y.tint);
          if (y.rgb != null) fill2.fgColor.rgb = y.rgb.slice(-6);
          break;
        case "<fgColor/>":
        case "</fgColor>":
          break;
case "<stop":
        case "<stop/>":
          break;
        case "</stop>":
          break;
case "<color":
        case "<color/>":
          break;
        case "</color>":
          break;
case "<extLst":
        case "<extLst>":
        case "</extLst>":
          break;
        case "<ext":
          pass = true;
          break;
        case "</ext>":
          pass = false;
          break;
        default:
          if (opts && opts.WTF) {
            if (!pass) throw new Error("unrecognized " + y[0] + " in fills");
          }
      }
    });
  }
  function parse_fonts(t, styles, themes, opts) {
    styles.Fonts = [];
    var font = {};
    var pass = false;
    (t.match(tagregex) || []).forEach(function(x) {
      var y = parsexmltag(x);
      switch (strip_ns(y[0])) {
        case "<fonts":
        case "<fonts>":
        case "</fonts>":
          break;
case "<font":
        case "<font>":
          break;
        case "</font>":
        case "<font/>":
          styles.Fonts.push(font);
          font = {};
          break;
case "<name":
          if (y.val) font.name = utf8read(y.val);
          break;
        case "<name/>":
        case "</name>":
          break;
case "<b":
          font.bold = y.val ? parsexmlbool(y.val) : 1;
          break;
        case "<b/>":
          font.bold = 1;
          break;
        case "</b>":
        case "</b":
          break;
case "<i":
          font.italic = y.val ? parsexmlbool(y.val) : 1;
          break;
        case "<i/>":
          font.italic = 1;
          break;
        case "</i>":
        case "</i":
          break;
case "<u":
          switch (y.val) {
            case "none":
              font.underline = 0;
              break;
            case "single":
              font.underline = 1;
              break;
            case "double":
              font.underline = 2;
              break;
            case "singleAccounting":
              font.underline = 33;
              break;
            case "doubleAccounting":
              font.underline = 34;
              break;
          }
          break;
        case "<u/>":
          font.underline = 1;
          break;
        case "</u>":
        case "</u":
          break;
case "<strike":
          font.strike = y.val ? parsexmlbool(y.val) : 1;
          break;
        case "<strike/>":
          font.strike = 1;
          break;
        case "</strike>":
        case "</strike":
          break;
case "<outline":
          font.outline = y.val ? parsexmlbool(y.val) : 1;
          break;
        case "<outline/>":
          font.outline = 1;
          break;
        case "</outline>":
        case "</outline":
          break;
case "<shadow":
          font.shadow = y.val ? parsexmlbool(y.val) : 1;
          break;
        case "<shadow/>":
          font.shadow = 1;
          break;
        case "</shadow>":
        case "</shadow":
          break;
case "<condense":
          font.condense = y.val ? parsexmlbool(y.val) : 1;
          break;
        case "<condense/>":
          font.condense = 1;
          break;
        case "</condense>":
        case "</condense":
          break;
case "<extend":
          font.extend = y.val ? parsexmlbool(y.val) : 1;
          break;
        case "<extend/>":
          font.extend = 1;
          break;
        case "</extend>":
        case "</extend":
          break;
case "<sz":
          if (y.val) font.sz = +y.val;
          break;
        case "<sz/>":
        case "</sz>":
        case "</sz":
          break;
case "<vertAlign":
          if (y.val) font.vertAlign = y.val;
          break;
        case "<vertAlign/>":
        case "</vertAlign>":
        case "</vertAlign":
          break;
case "<family":
          if (y.val) font.family = parseInt(y.val, 10);
          break;
        case "<family/>":
        case "</family>":
        case "</family":
          break;
case "<scheme":
          if (y.val) font.scheme = y.val;
          break;
        case "<scheme/>":
        case "</scheme>":
        case "</scheme":
          break;
case "<charset":
          if (y.val == "1") break;
          y.codepage = CS2CP[parseInt(y.val, 10)];
          break;
        case "<charset/>":
        case "</charset>":
        case "</charset":
          break;
case "<color":
          if (!font.color) font.color = {};
          if (y.auto) font.color.auto = parsexmlbool(y.auto);
          if (y.rgb) font.color.rgb = y.rgb.slice(-6);
          else if (y.indexed) {
            font.color.index = parseInt(y.indexed, 10);
            var icv = XLSIcv[font.color.index];
            if (font.color.index == 81) icv = XLSIcv[1];
            if (!icv) icv = XLSIcv[1];
            font.color.rgb = icv[0].toString(16) + icv[1].toString(16) + icv[2].toString(16);
          } else if (y.theme) {
            font.color.theme = parseInt(y.theme, 10);
            if (y.tint) font.color.tint = parseFloat(y.tint);
            if (y.theme && themes.themeElements && themes.themeElements.clrScheme) {
              font.color.rgb = rgb_tint(themes.themeElements.clrScheme[font.color.theme].rgb, font.color.tint || 0);
            }
          }
          break;
        case "<color/>":
        case "</color>":
        case "</color":
          break;
case "<AlternateContent":
          pass = true;
          break;
        case "</AlternateContent>":
        case "</AlternateContent":
          pass = false;
          break;
case "<extLst":
        case "<extLst>":
        case "</extLst>":
          break;
        case "<ext":
          pass = true;
          break;
        case "</ext>":
          pass = false;
          break;
        default:
          if (opts && opts.WTF) {
            if (!pass) throw new Error("unrecognized " + y[0] + " in fonts");
          }
      }
    });
  }
  function parse_numFmts(t, styles, opts) {
    styles.NumberFmt = [];
    var k = keys(table_fmt);
    for (var i = 0; i < k.length; ++i) styles.NumberFmt[k[i]] = table_fmt[k[i]];
    var m = t.match(tagregex);
    if (!m) return;
    for (i = 0; i < m.length; ++i) {
      var y = parsexmltag(m[i]);
      switch (strip_ns(y[0])) {
        case "<numFmts":
        case "</numFmts>":
        case "<numFmts/>":
        case "<numFmts>":
          break;
        case "<numFmt":
          {
            var f = unescapexml(utf8read(y.formatCode)), j = parseInt(y.numFmtId, 10);
            styles.NumberFmt[j] = f;
            if (j > 0) {
              if (j > 392) {
                for (j = 392; j > 60; --j) if (styles.NumberFmt[j] == null) break;
                styles.NumberFmt[j] = f;
              }
              SSF__load(f, j);
            }
          }
          break;
        case "</numFmt>":
          break;
        default:
          if (opts.WTF) throw new Error("unrecognized " + y[0] + " in numFmts");
      }
    }
  }
  function write_numFmts(NF) {
    var o = ["<numFmts>"];
    [[5, 8], [23, 26], [41, 44], [
50,
392
    ]].forEach(function(r2) {
      for (var i = r2[0]; i <= r2[1]; ++i) if (NF[i] != null) o[o.length] = writextag("numFmt", null, { numFmtId: i, formatCode: escapexml(NF[i]) });
    });
    if (o.length === 1) return "";
    o[o.length] = "</numFmts>";
    o[0] = writextag("numFmts", null, { count: o.length - 2 }).replace("/>", ">");
    return o.join("");
  }
  var cellXF_uint = ["numFmtId", "fillId", "fontId", "borderId", "xfId"];
  var cellXF_bool = ["applyAlignment", "applyBorder", "applyFill", "applyFont", "applyNumberFormat", "applyProtection", "pivotButton", "quotePrefix"];
  function parse_cellXfs(t, styles, opts) {
    styles.CellXf = [];
    var xf;
    var pass = false;
    (t.match(tagregex) || []).forEach(function(x) {
      var y = parsexmltag(x), i = 0;
      switch (strip_ns(y[0])) {
        case "<cellXfs":
        case "<cellXfs>":
        case "<cellXfs/>":
        case "</cellXfs>":
          break;
case "<xf":
        case "<xf/>":
        case "<xf>":
          xf = y;
          delete xf[0];
          for (i = 0; i < cellXF_uint.length; ++i) if (xf[cellXF_uint[i]])
            xf[cellXF_uint[i]] = parseInt(xf[cellXF_uint[i]], 10);
          for (i = 0; i < cellXF_bool.length; ++i) if (xf[cellXF_bool[i]])
            xf[cellXF_bool[i]] = parsexmlbool(xf[cellXF_bool[i]]);
          if (styles.NumberFmt && xf.numFmtId > 392) {
            for (i = 392; i > 60; --i) if (styles.NumberFmt[xf.numFmtId] == styles.NumberFmt[i]) {
              xf.numFmtId = i;
              break;
            }
          }
          styles.CellXf.push(xf);
          break;
        case "</xf>":
          break;
case "<alignment":
        case "<alignment/>":
        case "<alignment>":
          var alignment = {};
          if (y.vertical) alignment.vertical = y.vertical;
          if (y.horizontal) alignment.horizontal = y.horizontal;
          if (y.textRotation != null) alignment.textRotation = y.textRotation;
          if (y.indent) alignment.indent = y.indent;
          if (y.wrapText) alignment.wrapText = parsexmlbool(y.wrapText);
          xf.alignment = alignment;
          break;
        case "</alignment>":
          break;
case "<protection":
        case "<protection>":
          break;
        case "</protection>":
        case "<protection/>":
          break;
case "<AlternateContent":
        case "<AlternateContent>":
          pass = true;
          break;
        case "</AlternateContent>":
          pass = false;
          break;
case "<extLst":
        case "<extLst>":
        case "</extLst>":
          break;
        case "<ext":
          pass = true;
          break;
        case "</ext>":
          pass = false;
          break;
        default:
          if (opts && opts.WTF) {
            if (!pass) throw new Error("unrecognized " + y[0] + " in cellXfs");
          }
      }
    });
  }
  function write_cellXfs(cellXfs) {
    var o = [];
    o[o.length] = writextag("cellXfs", null);
    cellXfs.forEach(function(c) {
      o[o.length] = writextag("xf", null, c);
    });
    o[o.length] = "</cellXfs>";
    if (o.length === 2) return "";
    o[0] = writextag("cellXfs", null, { count: o.length - 2 }).replace("/>", ">");
    return o.join("");
  }
  var parse_sty_xml = (function make_pstyx() {
    return function parse_sty_xml2(data, themes, opts) {
      var styles = {};
      if (!data) return styles;
      data = remove_doctype(str_remove_ng(data, "<!--", "-->"));
      var t;
      if (t = str_match_xml_ns(data, "numFmts")) parse_numFmts(t[0], styles, opts);
      if (t = str_match_xml_ns(data, "fonts")) parse_fonts(t[0], styles, themes, opts);
      if (t = str_match_xml_ns(data, "fills")) parse_fills(t[0], styles, themes, opts);
      if (t = str_match_xml_ns(data, "borders")) parse_borders(t[0], styles, themes, opts);
      if (t = str_match_xml_ns(data, "cellXfs")) parse_cellXfs(t[0], styles, opts);
      return styles;
    };
  })();
  function write_sty_xml(wb, opts) {
    var o = [XML_HEADER, writextag("styleSheet", null, {
      "xmlns": XMLNS_main[0],
      "xmlns:vt": XMLNS.vt
    })], w;
    if (wb.SSF && (w = write_numFmts(wb.SSF)) != null) o[o.length] = w;
    o[o.length] = '<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>';
    o[o.length] = '<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>';
    o[o.length] = '<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>';
    o[o.length] = '<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>';
    if (w = write_cellXfs(opts.cellXfs)) o[o.length] = w;
    o[o.length] = '<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>';
    o[o.length] = '<dxfs count="0"/>';
    o[o.length] = '<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>';
    if (o.length > 2) {
      o[o.length] = "</styleSheet>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  function parse_BrtFmt(data, length) {
    var numFmtId = data.read_shift(2);
    var stFmtCode = parse_XLWideString(data);
    return [numFmtId, stFmtCode];
  }
  function write_BrtFmt(i, f, o) {
    if (!o) o = new_buf(6 + 4 * f.length);
    o.write_shift(2, i);
    write_XLWideString(f, o);
    var out = o.length > o.l ? o.slice(0, o.l) : o;
    if (o.l == null) o.l = o.length;
    return out;
  }
  function parse_BrtFont(data, length, opts) {
    var out = {};
    out.sz = data.read_shift(2) / 20;
    var grbit = parse_FontFlags(data);
    if (grbit.fItalic) out.italic = 1;
    if (grbit.fCondense) out.condense = 1;
    if (grbit.fExtend) out.extend = 1;
    if (grbit.fShadow) out.shadow = 1;
    if (grbit.fOutline) out.outline = 1;
    if (grbit.fStrikeout) out.strike = 1;
    var bls = data.read_shift(2);
    if (bls === 700) out.bold = 1;
    switch (data.read_shift(2)) {
case 1:
        out.vertAlign = "superscript";
        break;
      case 2:
        out.vertAlign = "subscript";
        break;
    }
    var underline = data.read_shift(1);
    if (underline != 0) out.underline = underline;
    var family = data.read_shift(1);
    if (family > 0) out.family = family;
    var bCharSet = data.read_shift(1);
    if (bCharSet > 0) out.charset = bCharSet;
    data.l++;
    out.color = parse_BrtColor(data);
    switch (data.read_shift(1)) {
case 1:
        out.scheme = "major";
        break;
      case 2:
        out.scheme = "minor";
        break;
    }
    out.name = parse_XLWideString(data);
    return out;
  }
  function write_BrtFont(font, o) {
    if (!o) o = new_buf(25 + 4 * 32);
    o.write_shift(2, font.sz * 20);
    write_FontFlags(font, o);
    o.write_shift(2, font.bold ? 700 : 400);
    var sss = 0;
    if (font.vertAlign == "superscript") sss = 1;
    else if (font.vertAlign == "subscript") sss = 2;
    o.write_shift(2, sss);
    o.write_shift(1, font.underline || 0);
    o.write_shift(1, font.family || 0);
    o.write_shift(1, font.charset || 0);
    o.write_shift(1, 0);
    write_BrtColor(font.color, o);
    var scheme = 0;
    scheme = 2;
    o.write_shift(1, scheme);
    write_XLWideString(font.name, o);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  var XLSBFillPTNames = [
    "none",
    "solid",
    "mediumGray",
    "darkGray",
    "lightGray",
    "darkHorizontal",
    "darkVertical",
    "darkDown",
    "darkUp",
    "darkGrid",
    "darkTrellis",
    "lightHorizontal",
    "lightVertical",
    "lightDown",
    "lightUp",
    "lightGrid",
    "lightTrellis",
    "gray125",
    "gray0625"
  ];
  var rev_XLSBFillPTNames;
  var parse_BrtFill = parsenoop;
  function write_BrtFill(fill2, o) {
    if (!o) o = new_buf(4 * 3 + 8 * 7 + 16 * 1);
    if (!rev_XLSBFillPTNames) rev_XLSBFillPTNames = evert(XLSBFillPTNames);
    var fls = rev_XLSBFillPTNames[fill2.patternType];
    if (fls == null) fls = 40;
    o.write_shift(4, fls);
    var j = 0;
    if (fls != 40) {
      write_BrtColor({ auto: 1 }, o);
      write_BrtColor({ auto: 1 }, o);
      for (; j < 12; ++j) o.write_shift(4, 0);
    } else {
      for (; j < 4; ++j) o.write_shift(4, 0);
      for (; j < 12; ++j) o.write_shift(4, 0);
    }
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function parse_BrtXF(data, length) {
    var tgt = data.l + length;
    var ixfeParent = data.read_shift(2);
    var ifmt = data.read_shift(2);
    data.l = tgt;
    return { ixfe: ixfeParent, numFmtId: ifmt };
  }
  function write_BrtXF(data, ixfeP, o) {
    if (!o) o = new_buf(16);
    o.write_shift(2, ixfeP || 0);
    o.write_shift(2, data.numFmtId || 0);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    o.write_shift(1, 0);
    o.write_shift(1, 0);
    var flow = 0;
    o.write_shift(1, flow);
    o.write_shift(1, 0);
    o.write_shift(1, 0);
    o.write_shift(1, 0);
    return o;
  }
  function write_Blxf(data, o) {
    if (!o) o = new_buf(10);
    o.write_shift(1, 0);
    o.write_shift(1, 0);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    return o;
  }
  var parse_BrtBorder = parsenoop;
  function write_BrtBorder(border, o) {
    if (!o) o = new_buf(51);
    o.write_shift(1, 0);
    write_Blxf(null, o);
    write_Blxf(null, o);
    write_Blxf(null, o);
    write_Blxf(null, o);
    write_Blxf(null, o);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function write_BrtStyle(style, o) {
    if (!o) o = new_buf(12 + 4 * 10);
    o.write_shift(4, style.xfId);
    o.write_shift(2, 1);
    o.write_shift(1, 0);
    o.write_shift(1, 0);
    write_XLNullableWideString(style.name || "", o);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function write_BrtBeginTableStyles(cnt, defTableStyle, defPivotStyle) {
    var o = new_buf(4 + 256 * 2 * 4);
    o.write_shift(4, cnt);
    write_XLNullableWideString(defTableStyle, o);
    write_XLNullableWideString(defPivotStyle, o);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function parse_sty_bin(data, themes, opts) {
    var styles = {};
    styles.NumberFmt = [];
    for (var y in table_fmt) styles.NumberFmt[y] = table_fmt[y];
    styles.CellXf = [];
    styles.Fonts = [];
    var state = [];
    var pass = false;
    recordhopper(data, function hopper_sty(val2, R, RT) {
      switch (RT) {
        case 44:
          styles.NumberFmt[val2[0]] = val2[1];
          SSF__load(val2[1], val2[0]);
          break;
        case 43:
          styles.Fonts.push(val2);
          if (val2.color.theme != null && themes && themes.themeElements && themes.themeElements.clrScheme) {
            val2.color.rgb = rgb_tint(themes.themeElements.clrScheme[val2.color.theme].rgb, val2.color.tint || 0);
          }
          break;
        case 1025:
          break;
        case 45:
          break;
        case 46:
          break;
        case 47:
          if (state[state.length - 1] == 617) {
            styles.CellXf.push(val2);
          }
          break;
        case 48:
case 507:
case 572:
case 475:
          break;
        case 1171:
case 2102:
case 1130:
case 512:
case 2095:
case 3072:
          break;
        case 35:
          pass = true;
          break;
        case 36:
          pass = false;
          break;
        case 37:
          state.push(RT);
          pass = true;
          break;
        case 38:
          state.pop();
          pass = false;
          break;
        default:
          if (R.T > 0) state.push(RT);
          else if (R.T < 0) state.pop();
          else if (!pass || opts.WTF && state[state.length - 1] != 37) throw new Error("Unexpected record 0x" + RT.toString(16));
      }
    });
    return styles;
  }
  function write_FMTS_bin(ba, NF) {
    if (!NF) return;
    var cnt = 0;
    [[5, 8], [23, 26], [41, 44], [
50,
392
    ]].forEach(function(r2) {
      for (var i = r2[0]; i <= r2[1]; ++i) if (NF[i] != null) ++cnt;
    });
    if (cnt == 0) return;
    write_record(ba, 615, write_UInt32LE(cnt));
    [[5, 8], [23, 26], [41, 44], [
50,
392
    ]].forEach(function(r2) {
      for (var i = r2[0]; i <= r2[1]; ++i) if (NF[i] != null) write_record(ba, 44, write_BrtFmt(i, NF[i]));
    });
    write_record(
      ba,
      616
);
  }
  function write_FONTS_bin(ba) {
    var cnt = 1;
    write_record(ba, 611, write_UInt32LE(cnt));
    write_record(ba, 43, write_BrtFont({
      sz: 12,
      color: { theme: 1 },
      name: "Calibri",
      family: 2
    }));
    write_record(
      ba,
      612
);
  }
  function write_FILLS_bin(ba) {
    var cnt = 2;
    write_record(ba, 603, write_UInt32LE(cnt));
    write_record(ba, 45, write_BrtFill({ patternType: "none" }));
    write_record(ba, 45, write_BrtFill({ patternType: "gray125" }));
    write_record(
      ba,
      604
);
  }
  function write_BORDERS_bin(ba) {
    var cnt = 1;
    write_record(ba, 613, write_UInt32LE(cnt));
    write_record(ba, 46, write_BrtBorder());
    write_record(
      ba,
      614
);
  }
  function write_CELLSTYLEXFS_bin(ba) {
    var cnt = 1;
    write_record(ba, 626, write_UInt32LE(cnt));
    write_record(ba, 47, write_BrtXF({
      numFmtId: 0
    }, 65535));
    write_record(
      ba,
      627
);
  }
  function write_CELLXFS_bin(ba, data) {
    write_record(ba, 617, write_UInt32LE(data.length));
    data.forEach(function(c) {
      write_record(ba, 47, write_BrtXF(c, 0));
    });
    write_record(
      ba,
      618
);
  }
  function write_STYLES_bin(ba) {
    var cnt = 1;
    write_record(ba, 619, write_UInt32LE(cnt));
    write_record(ba, 48, write_BrtStyle({
      xfId: 0,
      name: "Normal"
    }));
    write_record(
      ba,
      620
);
  }
  function write_DXFS_bin(ba) {
    var cnt = 0;
    write_record(ba, 505, write_UInt32LE(cnt));
    write_record(
      ba,
      506
);
  }
  function write_TABLESTYLES_bin(ba) {
    var cnt = 0;
    write_record(ba, 508, write_BrtBeginTableStyles(cnt, "TableStyleMedium9", "PivotStyleMedium4"));
    write_record(
      ba,
      509
);
  }
  function write_sty_bin(wb, opts) {
    var ba = buf_array();
    write_record(
      ba,
      278
);
    write_FMTS_bin(ba, wb.SSF);
    write_FONTS_bin(ba);
    write_FILLS_bin(ba);
    write_BORDERS_bin(ba);
    write_CELLSTYLEXFS_bin(ba);
    write_CELLXFS_bin(ba, opts.cellXfs);
    write_STYLES_bin(ba);
    write_DXFS_bin(ba);
    write_TABLESTYLES_bin(ba);
    write_record(
      ba,
      279
);
    return ba.end();
  }
  var XLSXThemeClrScheme = [
    "</a:lt1>",
    "</a:dk1>",
    "</a:lt2>",
    "</a:dk2>",
    "</a:accent1>",
    "</a:accent2>",
    "</a:accent3>",
    "</a:accent4>",
    "</a:accent5>",
    "</a:accent6>",
    "</a:hlink>",
    "</a:folHlink>"
  ];
  function parse_clrScheme(t, themes, opts) {
    themes.themeElements.clrScheme = [];
    var color = {};
    (t[0].match(tagregex) || []).forEach(function(x) {
      var y = parsexmltag(x);
      switch (y[0]) {
case "<a:clrScheme":
        case "</a:clrScheme>":
          break;
case "<a:srgbClr":
          color.rgb = y.val;
          break;
        case "</a:srgbClr>":
          break;
case "<a:sysClr":
          color.rgb = y.lastClr;
          break;
        case "</a:sysClr>":
          break;











case "</a:dk1>":
        case "</a:lt1>":
        case "<a:dk1>":
        case "<a:lt1>":
        case "<a:dk2>":
        case "</a:dk2>":
        case "<a:lt2>":
        case "</a:lt2>":
        case "<a:accent1>":
        case "</a:accent1>":
        case "<a:accent2>":
        case "</a:accent2>":
        case "<a:accent3>":
        case "</a:accent3>":
        case "<a:accent4>":
        case "</a:accent4>":
        case "<a:accent5>":
        case "</a:accent5>":
        case "<a:accent6>":
        case "</a:accent6>":
        case "<a:hlink>":
        case "</a:hlink>":
        case "<a:folHlink>":
        case "</a:folHlink>":
          if (y[0].charAt(1) === "/") {
            themes.themeElements.clrScheme[XLSXThemeClrScheme.indexOf(y[0])] = color;
            color = {};
          } else {
            color.name = y[0].slice(3, y[0].length - 1);
          }
          break;
        default:
          if (opts && opts.WTF) throw new Error("Unrecognized " + y[0] + " in clrScheme");
      }
    });
  }
  function parse_themeElements(data, themes, opts) {
    themes.themeElements = {};
    var t;
    if (!(t = str_match_xml(data, "a:clrScheme"))) throw new Error("clrScheme not found in themeElements");
    parse_clrScheme(t, themes, opts);
    if (!(t = str_match_xml(data, "a:fontScheme"))) throw new Error("fontScheme not found in themeElements");
    if (!(t = str_match_xml(data, "a:fmtScheme"))) throw new Error("fmtScheme not found in themeElements");
  }
  function parse_theme_xml(data, opts) {
    if (!data || data.length === 0) data = write_theme();
    var t;
    var themes = {};
    if (!(t = str_match_xml(data, "a:themeElements"))) throw new Error("themeElements not found in theme");
    parse_themeElements(t[0], themes, opts);
    themes.raw = data;
    return themes;
  }
  function write_theme(Themes, opts) {
    if (opts && opts.themeXLSX) return opts.themeXLSX;
    if (Themes && typeof Themes.raw == "string") return Themes.raw;
    var o = [XML_HEADER];
    o[o.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">';
    o[o.length] = "<a:themeElements>";
    o[o.length] = '<a:clrScheme name="Office">';
    o[o.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>';
    o[o.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>';
    o[o.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>';
    o[o.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>';
    o[o.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>';
    o[o.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>';
    o[o.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>';
    o[o.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>';
    o[o.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>';
    o[o.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>';
    o[o.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>';
    o[o.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>';
    o[o.length] = "</a:clrScheme>";
    o[o.length] = '<a:fontScheme name="Office">';
    o[o.length] = "<a:majorFont>";
    o[o.length] = '<a:latin typeface="Cambria"/>';
    o[o.length] = '<a:ea typeface=""/>';
    o[o.length] = '<a:cs typeface=""/>';
    o[o.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>';
    o[o.length] = '<a:font script="Hang" typeface="맑은 고딕"/>';
    o[o.length] = '<a:font script="Hans" typeface="宋体"/>';
    o[o.length] = '<a:font script="Hant" typeface="新細明體"/>';
    o[o.length] = '<a:font script="Arab" typeface="Times New Roman"/>';
    o[o.length] = '<a:font script="Hebr" typeface="Times New Roman"/>';
    o[o.length] = '<a:font script="Thai" typeface="Tahoma"/>';
    o[o.length] = '<a:font script="Ethi" typeface="Nyala"/>';
    o[o.length] = '<a:font script="Beng" typeface="Vrinda"/>';
    o[o.length] = '<a:font script="Gujr" typeface="Shruti"/>';
    o[o.length] = '<a:font script="Khmr" typeface="MoolBoran"/>';
    o[o.length] = '<a:font script="Knda" typeface="Tunga"/>';
    o[o.length] = '<a:font script="Guru" typeface="Raavi"/>';
    o[o.length] = '<a:font script="Cans" typeface="Euphemia"/>';
    o[o.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
    o[o.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
    o[o.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
    o[o.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
    o[o.length] = '<a:font script="Deva" typeface="Mangal"/>';
    o[o.length] = '<a:font script="Telu" typeface="Gautami"/>';
    o[o.length] = '<a:font script="Taml" typeface="Latha"/>';
    o[o.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
    o[o.length] = '<a:font script="Orya" typeface="Kalinga"/>';
    o[o.length] = '<a:font script="Mlym" typeface="Kartika"/>';
    o[o.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
    o[o.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
    o[o.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
    o[o.length] = '<a:font script="Viet" typeface="Times New Roman"/>';
    o[o.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
    o[o.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
    o[o.length] = "</a:majorFont>";
    o[o.length] = "<a:minorFont>";
    o[o.length] = '<a:latin typeface="Calibri"/>';
    o[o.length] = '<a:ea typeface=""/>';
    o[o.length] = '<a:cs typeface=""/>';
    o[o.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>';
    o[o.length] = '<a:font script="Hang" typeface="맑은 고딕"/>';
    o[o.length] = '<a:font script="Hans" typeface="宋体"/>';
    o[o.length] = '<a:font script="Hant" typeface="新細明體"/>';
    o[o.length] = '<a:font script="Arab" typeface="Arial"/>';
    o[o.length] = '<a:font script="Hebr" typeface="Arial"/>';
    o[o.length] = '<a:font script="Thai" typeface="Tahoma"/>';
    o[o.length] = '<a:font script="Ethi" typeface="Nyala"/>';
    o[o.length] = '<a:font script="Beng" typeface="Vrinda"/>';
    o[o.length] = '<a:font script="Gujr" typeface="Shruti"/>';
    o[o.length] = '<a:font script="Khmr" typeface="DaunPenh"/>';
    o[o.length] = '<a:font script="Knda" typeface="Tunga"/>';
    o[o.length] = '<a:font script="Guru" typeface="Raavi"/>';
    o[o.length] = '<a:font script="Cans" typeface="Euphemia"/>';
    o[o.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
    o[o.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
    o[o.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
    o[o.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
    o[o.length] = '<a:font script="Deva" typeface="Mangal"/>';
    o[o.length] = '<a:font script="Telu" typeface="Gautami"/>';
    o[o.length] = '<a:font script="Taml" typeface="Latha"/>';
    o[o.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
    o[o.length] = '<a:font script="Orya" typeface="Kalinga"/>';
    o[o.length] = '<a:font script="Mlym" typeface="Kartika"/>';
    o[o.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
    o[o.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
    o[o.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
    o[o.length] = '<a:font script="Viet" typeface="Arial"/>';
    o[o.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
    o[o.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
    o[o.length] = "</a:minorFont>";
    o[o.length] = "</a:fontScheme>";
    o[o.length] = '<a:fmtScheme name="Office">';
    o[o.length] = "<a:fillStyleLst>";
    o[o.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
    o[o.length] = '<a:gradFill rotWithShape="1">';
    o[o.length] = "<a:gsLst>";
    o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
    o[o.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
    o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
    o[o.length] = "</a:gsLst>";
    o[o.length] = '<a:lin ang="16200000" scaled="1"/>';
    o[o.length] = "</a:gradFill>";
    o[o.length] = '<a:gradFill rotWithShape="1">';
    o[o.length] = "<a:gsLst>";
    o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>';
    o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
    o[o.length] = "</a:gsLst>";
    o[o.length] = '<a:lin ang="16200000" scaled="0"/>';
    o[o.length] = "</a:gradFill>";
    o[o.length] = "</a:fillStyleLst>";
    o[o.length] = "<a:lnStyleLst>";
    o[o.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>';
    o[o.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
    o[o.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
    o[o.length] = "</a:lnStyleLst>";
    o[o.length] = "<a:effectStyleLst>";
    o[o.length] = "<a:effectStyle>";
    o[o.length] = "<a:effectLst>";
    o[o.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>';
    o[o.length] = "</a:effectLst>";
    o[o.length] = "</a:effectStyle>";
    o[o.length] = "<a:effectStyle>";
    o[o.length] = "<a:effectLst>";
    o[o.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
    o[o.length] = "</a:effectLst>";
    o[o.length] = "</a:effectStyle>";
    o[o.length] = "<a:effectStyle>";
    o[o.length] = "<a:effectLst>";
    o[o.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
    o[o.length] = "</a:effectLst>";
    o[o.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>';
    o[o.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>';
    o[o.length] = "</a:effectStyle>";
    o[o.length] = "</a:effectStyleLst>";
    o[o.length] = "<a:bgFillStyleLst>";
    o[o.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
    o[o.length] = '<a:gradFill rotWithShape="1">';
    o[o.length] = "<a:gsLst>";
    o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
    o[o.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
    o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>';
    o[o.length] = "</a:gsLst>";
    o[o.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>';
    o[o.length] = "</a:gradFill>";
    o[o.length] = '<a:gradFill rotWithShape="1">';
    o[o.length] = "<a:gsLst>";
    o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
    o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>';
    o[o.length] = "</a:gsLst>";
    o[o.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>';
    o[o.length] = "</a:gradFill>";
    o[o.length] = "</a:bgFillStyleLst>";
    o[o.length] = "</a:fmtScheme>";
    o[o.length] = "</a:themeElements>";
    o[o.length] = "<a:objectDefaults>";
    o[o.length] = "<a:spDef>";
    o[o.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>';
    o[o.length] = "</a:spDef>";
    o[o.length] = "<a:lnDef>";
    o[o.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>';
    o[o.length] = "</a:lnDef>";
    o[o.length] = "</a:objectDefaults>";
    o[o.length] = "<a:extraClrSchemeLst/>";
    o[o.length] = "</a:theme>";
    return o.join("");
  }
  function parse_Theme(blob, length, opts) {
    var end = blob.l + length;
    var dwThemeVersion = blob.read_shift(4);
    if (dwThemeVersion === 124226) return;
    if (!opts.cellStyles) {
      blob.l = end;
      return;
    }
    var data = blob.slice(blob.l);
    blob.l = end;
    var zip;
    try {
      zip = zip_read(data, { type: "array" });
    } catch (e) {
      return;
    }
    var themeXML = getzipstr(zip, "theme/theme/theme1.xml", true);
    if (!themeXML) return;
    return parse_theme_xml(themeXML, opts);
  }
  function parse_ColorTheme(blob) {
    return blob.read_shift(4);
  }
  function parse_FullColorExt(blob) {
    var o = {};
    o.xclrType = blob.read_shift(2);
    o.nTintShade = blob.read_shift(2);
    switch (o.xclrType) {
      case 0:
        blob.l += 4;
        break;
      case 1:
        o.xclrValue = parse_IcvXF(blob, 4);
        break;
      case 2:
        o.xclrValue = parse_LongRGBA(blob);
        break;
      case 3:
        o.xclrValue = parse_ColorTheme(blob);
        break;
      case 4:
        blob.l += 4;
        break;
    }
    blob.l += 8;
    return o;
  }
  function parse_IcvXF(blob, length) {
    return parsenoop(blob, length);
  }
  function parse_XFExtGradient(blob, length) {
    return parsenoop(blob, length);
  }
  function parse_ExtProp(blob) {
    var extType = blob.read_shift(2);
    var cb = blob.read_shift(2) - 4;
    var o = [extType];
    switch (extType) {
      case 4:
      case 5:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 13:
        o[1] = parse_FullColorExt(blob);
        break;
      case 6:
        o[1] = parse_XFExtGradient(blob, cb);
        break;
      case 14:
      case 15:
        o[1] = blob.read_shift(cb === 1 ? 1 : 2);
        break;
      default:
        throw new Error("Unrecognized ExtProp type: " + extType + " " + cb);
    }
    return o;
  }
  function parse_XFExt(blob, length) {
    var end = blob.l + length;
    blob.l += 2;
    var ixfe = blob.read_shift(2);
    blob.l += 2;
    var cexts = blob.read_shift(2);
    var ext = [];
    while (cexts-- > 0) ext.push(parse_ExtProp(blob, end - blob.l));
    return { ixfe, ext };
  }
  function update_xfext(xf, xfext) {
    xfext.forEach(function(xfe) {
      switch (xfe[0]) {
      }
    });
  }
  function parse_BrtMdtinfo(data, length) {
    return {
      flags: data.read_shift(4),
      version: data.read_shift(4),
      name: parse_XLWideString(data)
    };
  }
  function write_BrtMdtinfo(data) {
    var o = new_buf(12 + 2 * data.name.length);
    o.write_shift(4, data.flags);
    o.write_shift(4, data.version);
    write_XLWideString(data.name, o);
    return o.slice(0, o.l);
  }
  function parse_BrtMdb(data) {
    var out = [];
    var cnt = data.read_shift(4);
    while (cnt-- > 0)
      out.push([data.read_shift(4), data.read_shift(4)]);
    return out;
  }
  function write_BrtMdb(mdb) {
    var o = new_buf(4 + 8 * mdb.length);
    o.write_shift(4, mdb.length);
    for (var i = 0; i < mdb.length; ++i) {
      o.write_shift(4, mdb[i][0]);
      o.write_shift(4, mdb[i][1]);
    }
    return o;
  }
  function write_BrtBeginEsfmd(cnt, name) {
    var o = new_buf(8 + 2 * name.length);
    o.write_shift(4, cnt);
    write_XLWideString(name, o);
    return o.slice(0, o.l);
  }
  function parse_BrtBeginEsmdb(data) {
    data.l += 4;
    return data.read_shift(4) != 0;
  }
  function write_BrtBeginEsmdb(cnt, cm) {
    var o = new_buf(8);
    o.write_shift(4, cnt);
    o.write_shift(4, 1);
    return o;
  }
  function parse_xlmeta_bin(data, name, _opts) {
    var out = { Types: [], Cell: [], Value: [] };
    var opts = _opts || {};
    var state = [];
    var pass = false;
    var metatype = 2;
    recordhopper(data, function(val2, R, RT) {
      switch (RT) {
        case 335:
          out.Types.push({ name: val2.name });
          break;
        case 51:
          val2.forEach(function(r2) {
            if (metatype == 1)
              out.Cell.push({ type: out.Types[r2[0] - 1].name, index: r2[1] });
            else if (metatype == 0)
              out.Value.push({ type: out.Types[r2[0] - 1].name, index: r2[1] });
          });
          break;
        case 337:
          metatype = val2 ? 1 : 0;
          break;
        case 338:
          metatype = 2;
          break;
        case 35:
          state.push(RT);
          pass = true;
          break;
        case 36:
          state.pop();
          pass = false;
          break;
        default:
          if (R.T) ;
          else if (!pass || opts.WTF && state[state.length - 1] != 35)
            throw new Error("Unexpected record 0x" + RT.toString(16));
      }
    });
    return out;
  }
  function write_xlmeta_bin() {
    var ba = buf_array();
    write_record(ba, 332);
    write_record(ba, 334, write_UInt32LE(1));
    write_record(ba, 335, write_BrtMdtinfo({
      name: "XLDAPR",
      version: 12e4,
      flags: 3496657072
    }));
    write_record(ba, 336);
    write_record(ba, 339, write_BrtBeginEsfmd(1, "XLDAPR"));
    write_record(ba, 52);
    write_record(ba, 35, write_UInt32LE(514));
    write_record(ba, 4096, write_UInt32LE(0));
    write_record(ba, 4097, writeuint16(1));
    write_record(ba, 36);
    write_record(ba, 53);
    write_record(ba, 340);
    write_record(ba, 337, write_BrtBeginEsmdb(1));
    write_record(ba, 51, write_BrtMdb([[1, 0]]));
    write_record(ba, 338);
    write_record(ba, 333);
    return ba.end();
  }
  function parse_xlmeta_xml(data, name, opts) {
    var out = { Types: [], Cell: [], Value: [] };
    if (!data)
      return out;
    var pass = false;
    var metatype = 2;
    var lastmeta;
    data.replace(tagregex, function(x) {
      var y = parsexmltag(x);
      switch (strip_ns(y[0])) {
        case "<?xml":
          break;
        case "<metadata":
        case "</metadata>":
          break;
        case "<metadataTypes":
        case "</metadataTypes>":
          break;
        case "<metadataType":
          out.Types.push({ name: y.name });
          break;
        case "</metadataType>":
          break;
        case "<futureMetadata":
          for (var j = 0; j < out.Types.length; ++j)
            if (out.Types[j].name == y.name)
              lastmeta = out.Types[j];
          break;
        case "</futureMetadata>":
          break;
        case "<bk>":
          break;
        case "</bk>":
          break;
        case "<rc":
          if (metatype == 1)
            out.Cell.push({ type: out.Types[y.t - 1].name, index: +y.v });
          else if (metatype == 0)
            out.Value.push({ type: out.Types[y.t - 1].name, index: +y.v });
          break;
        case "</rc>":
          break;
        case "<cellMetadata":
          metatype = 1;
          break;
        case "</cellMetadata>":
          metatype = 2;
          break;
        case "<valueMetadata":
          metatype = 0;
          break;
        case "</valueMetadata>":
          metatype = 2;
          break;
        case "<extLst":
        case "<extLst>":
        case "</extLst>":
        case "<extLst/>":
          break;
        case "<ext":
          pass = true;
          break;
        case "</ext>":
          pass = false;
          break;
        case "<rvb":
          if (!lastmeta)
            break;
          if (!lastmeta.offsets)
            lastmeta.offsets = [];
          lastmeta.offsets.push(+y.i);
          break;
        default:
          if (!pass && (opts == null ? void 0 : opts.WTF))
            throw new Error("unrecognized " + y[0] + " in metadata");
      }
      return x;
    });
    return out;
  }
  function write_xlmeta_xml() {
    var o = [XML_HEADER];
    o.push('<metadata xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:xlrd="http://schemas.microsoft.com/office/spreadsheetml/2017/richdata" xmlns:xda="http://schemas.microsoft.com/office/spreadsheetml/2017/dynamicarray">\n  <metadataTypes count="1">\n    <metadataType name="XLDAPR" minSupportedVersion="120000" copy="1" pasteAll="1" pasteValues="1" merge="1" splitFirst="1" rowColShift="1" clearFormats="1" clearComments="1" assign="1" coerce="1" cellMeta="1"/>\n  </metadataTypes>\n  <futureMetadata name="XLDAPR" count="1">\n    <bk>\n      <extLst>\n        <ext uri="{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}">\n          <xda:dynamicArrayProperties fDynamic="1" fCollapsed="0"/>\n        </ext>\n      </extLst>\n    </bk>\n  </futureMetadata>\n  <cellMetadata count="1">\n    <bk>\n      <rc t="1" v="0"/>\n    </bk>\n  </cellMetadata>\n</metadata>');
    return o.join("");
  }
  function parse_cc_xml(data) {
    var d = [];
    if (!data) return d;
    var i = 1;
    (data.match(tagregex) || []).forEach(function(x) {
      var y = parsexmltag(x);
      switch (y[0]) {
        case "<?xml":
          break;
case "<calcChain":
        case "<calcChain>":
        case "</calcChain>":
          break;
case "<c":
          delete y[0];
          if (y.i) i = y.i;
          else y.i = i;
          d.push(y);
          break;
      }
    });
    return d;
  }
  function parse_BrtCalcChainItem$(data) {
    var out = {};
    out.i = data.read_shift(4);
    var cell = {};
    cell.r = data.read_shift(4);
    cell.c = data.read_shift(4);
    out.r = encode_cell(cell);
    var flags = data.read_shift(1);
    if (flags & 2) out.l = "1";
    if (flags & 8) out.a = "1";
    return out;
  }
  function parse_cc_bin(data, name, opts) {
    var out = [];
    recordhopper(data, function hopper_cc(val2, R, RT) {
      switch (RT) {
        case 63:
          out.push(val2);
          break;
        default:
          if (R.T) ;
          else throw new Error("Unexpected record 0x" + RT.toString(16));
      }
    });
    return out;
  }
  function parse_xlink_xml() {
  }
  function parse_xlink_bin(data, rel, name, _opts) {
    if (!data) return data;
    var opts = _opts || {};
    var pass = false;
    recordhopper(data, function xlink_parse(val2, R, RT) {
      switch (RT) {
        case 359:
case 363:
case 364:
case 366:
case 367:
case 368:
case 369:
case 370:
case 371:
case 472:
case 577:
case 578:
case 579:
case 580:
case 581:
case 582:
case 583:
case 584:
case 585:
case 586:
case 587:
          break;
        case 35:
          pass = true;
          break;
        case 36:
          pass = false;
          break;
        default:
          if (R.T) ;
          else if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
      }
    }, opts);
  }
  function parse_drawing(data, rels) {
    if (!data) return "??";
    var id = (data.match(/<c:chart [^<>]*r:id="([^<>"]*)"/) || ["", ""])[1];
    return rels["!id"][id].Target;
  }
  function parse_vml(data, sheet, comments) {
    var cidx = 0;
    (str_match_xml_ns_g(data, "shape") || []).forEach(function(m) {
      var type = "";
      var hidden = true;
      var aidx = -1;
      var R = -1, C = -1;
      m.replace(tagregex, function(x, idx) {
        var y = parsexmltag(x);
        switch (strip_ns(y[0])) {
          case "<ClientData":
            if (y.ObjectType) type = y.ObjectType;
            break;
          case "<Visible":
          case "<Visible/>":
            hidden = false;
            break;
          case "<Row":
          case "<Row>":
            aidx = idx + x.length;
            break;
          case "</Row>":
            R = +m.slice(aidx, idx).trim();
            break;
          case "<Column":
          case "<Column>":
            aidx = idx + x.length;
            break;
          case "</Column>":
            C = +m.slice(aidx, idx).trim();
            break;
        }
        return "";
      });
      switch (type) {
        case "Note":
          var cell = ws_get_cell_stub(sheet, R >= 0 && C >= 0 ? encode_cell({ r: R, c: C }) : comments[cidx].ref);
          if (cell.c) {
            cell.c.hidden = hidden;
          }
          ++cidx;
          break;
      }
    });
  }
  function write_vml(rId, comments, ws) {
    var csize = [21600, 21600];
    var bbox = ["m0,0l0", csize[1], csize[0], csize[1], csize[0], "0xe"].join(",");
    var o = [
      writextag("xml", null, { "xmlns:v": XLMLNS.v, "xmlns:o": XLMLNS.o, "xmlns:x": XLMLNS.x, "xmlns:mv": XLMLNS.mv }).replace(/\/>/, ">"),
      writextag("o:shapelayout", writextag("o:idmap", null, { "v:ext": "edit", "data": rId }), { "v:ext": "edit" })
    ];
    var _shapeid = 65536 * rId;
    var _comments = comments || [];
    if (_comments.length > 0) o.push(writextag("v:shapetype", [
      writextag("v:stroke", null, { joinstyle: "miter" }),
      writextag("v:path", null, { gradientshapeok: "t", "o:connecttype": "rect" })
    ].join(""), { id: "_x0000_t202", coordsize: csize.join(","), "o:spt": 202, path: bbox }));
    _comments.forEach(function(x) {
      ++_shapeid;
      o.push(write_vml_comment(x, _shapeid));
    });
    o.push("</xml>");
    return o.join("");
  }
  function write_vml_comment(x, _shapeid, ws) {
    var c = decode_cell(x[0]);
    var fillopts = (
{ "color2": "#BEFF82", "type": "gradient" }
    );
    if (fillopts.type == "gradient") fillopts.angle = "-180";
    var fillparm = fillopts.type == "gradient" ? writextag("o:fill", null, { type: "gradientUnscaled", "v:ext": "view" }) : null;
    var fillxml = writextag("v:fill", fillparm, fillopts);
    var shadata = { on: "t", "obscured": "t" };
    return [
      "<v:shape" + wxt_helper({
        id: "_x0000_s" + _shapeid,
        type: "#_x0000_t202",
        style: "position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10" + (x[1].hidden ? ";visibility:hidden" : ""),
        fillcolor: "#ECFAD4",
        strokecolor: "#edeaa1"
      }) + ">",
      fillxml,
      writextag("v:shadow", null, shadata),
      writextag("v:path", null, { "o:connecttype": "none" }),
      '<v:textbox><div style="text-align:left"></div></v:textbox>',
      '<x:ClientData ObjectType="Note">',
      "<x:MoveWithCells/>",
      "<x:SizeWithCells/>",
writetag("x:Anchor", [c.c + 1, 0, c.r + 1, 0, c.c + 3, 20, c.r + 5, 20].join(",")),
      writetag("x:AutoFill", "False"),
      writetag("x:Row", String(c.r)),
      writetag("x:Column", String(c.c)),
      x[1].hidden ? "" : "<x:Visible/>",
      "</x:ClientData>",
      "</v:shape>"
    ].join("");
  }
  function sheet_insert_comments(sheet, comments, threaded, people) {
    var dense = sheet["!data"] != null;
    var cell;
    comments.forEach(function(comment) {
      var r2 = decode_cell(comment.ref);
      if (r2.r < 0 || r2.c < 0) return;
      if (dense) {
        if (!sheet["!data"][r2.r]) sheet["!data"][r2.r] = [];
        cell = sheet["!data"][r2.r][r2.c];
      } else cell = sheet[comment.ref];
      if (!cell) {
        cell = { t: "z" };
        if (dense) sheet["!data"][r2.r][r2.c] = cell;
        else sheet[comment.ref] = cell;
        var range = safe_decode_range(sheet["!ref"] || "BDWGO1000001:A1");
        if (range.s.r > r2.r) range.s.r = r2.r;
        if (range.e.r < r2.r) range.e.r = r2.r;
        if (range.s.c > r2.c) range.s.c = r2.c;
        if (range.e.c < r2.c) range.e.c = r2.c;
        var encoded = encode_range(range);
        sheet["!ref"] = encoded;
      }
      if (!cell.c) cell.c = [];
      var o = { a: comment.author, t: comment.t, r: comment.r, T: threaded };
      if (comment.h) o.h = comment.h;
      for (var i = cell.c.length - 1; i >= 0; --i) {
        if (!threaded && cell.c[i].T) return;
        if (threaded && !cell.c[i].T) cell.c.splice(i, 1);
      }
      if (threaded && people) for (i = 0; i < people.length; ++i) {
        if (o.a == people[i].id) {
          o.a = people[i].name || o.a;
          break;
        }
      }
      cell.c.push(o);
    });
  }
  function parse_comments_xml(data, opts) {
    if (data.match(/<(?:\w+:)?comments *\/>/)) return [];
    var authors = [];
    var commentList = [];
    var authtag = str_match_xml_ns(data, "authors");
    if (authtag && authtag[1]) authtag[1].split(/<\/\w*:?author>/).forEach(function(x) {
      if (x === "" || x.trim() === "") return;
      var a = x.match(/<(?:\w+:)?author[^<>]*>(.*)/);
      if (a) authors.push(a[1]);
    });
    var cmnttag = str_match_xml_ns(data, "commentList");
    if (cmnttag && cmnttag[1]) cmnttag[1].split(/<\/\w*:?comment>/).forEach(function(x) {
      if (x === "" || x.trim() === "") return;
      var cm = x.match(/<(?:\w+:)?comment[^<>]*>/);
      if (!cm) return;
      var y = parsexmltag(cm[0]);
      var comment = { author: y.authorId && authors[y.authorId] || "sheetjsghost", ref: y.ref, guid: y.guid };
      var cell = decode_cell(y.ref);
      if (opts.sheetRows && opts.sheetRows <= cell.r) return;
      var textMatch = str_match_xml_ns(x, "text");
      var rt = !!textMatch && !!textMatch[1] && parse_si(textMatch[1]) || { r: "", t: "", h: "" };
      comment.r = rt.r;
      if (rt.r == "<t></t>") rt.t = rt.h = "";
      comment.t = (rt.t || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      if (opts.cellHTML) comment.h = rt.h;
      commentList.push(comment);
    });
    return commentList;
  }
  function write_comments_xml(data) {
    var o = [XML_HEADER, writextag("comments", null, { "xmlns": XMLNS_main[0] })];
    var iauthor = [];
    o.push("<authors>");
    data.forEach(function(x) {
      x[1].forEach(function(w) {
        var a = escapexml(w.a);
        if (iauthor.indexOf(a) == -1) {
          iauthor.push(a);
          o.push("<author>" + a + "</author>");
        }
        if (w.T && w.ID && iauthor.indexOf("tc=" + w.ID) == -1) {
          iauthor.push("tc=" + w.ID);
          o.push("<author>tc=" + w.ID + "</author>");
        }
      });
    });
    if (iauthor.length == 0) {
      iauthor.push("SheetJ5");
      o.push("<author>SheetJ5</author>");
    }
    o.push("</authors>");
    o.push("<commentList>");
    data.forEach(function(d) {
      var lastauthor = 0, ts = [], tcnt = 0;
      if (d[1][0] && d[1][0].T && d[1][0].ID) lastauthor = iauthor.indexOf("tc=" + d[1][0].ID);
      d[1].forEach(function(c) {
        if (c.a) lastauthor = iauthor.indexOf(escapexml(c.a));
        if (c.T) ++tcnt;
        ts.push(c.t == null ? "" : escapexml(c.t));
      });
      if (tcnt === 0) {
        d[1].forEach(function(c) {
          o.push('<comment ref="' + d[0] + '" authorId="' + iauthor.indexOf(escapexml(c.a)) + '"><text>');
          o.push(writetag("t", c.t == null ? "" : escapexml(c.t)));
          o.push("</text></comment>");
        });
      } else {
        if (d[1][0] && d[1][0].T && d[1][0].ID) lastauthor = iauthor.indexOf("tc=" + d[1][0].ID);
        o.push('<comment ref="' + d[0] + '" authorId="' + lastauthor + '"><text>');
        var t = "Comment:\n    " + ts[0] + "\n";
        for (var i = 1; i < ts.length; ++i) t += "Reply:\n    " + ts[i] + "\n";
        o.push(writetag("t", escapexml(t)));
        o.push("</text></comment>");
      }
    });
    o.push("</commentList>");
    if (o.length > 2) {
      o[o.length] = "</comments>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  function parse_tcmnt_xml(data, opts) {
    var out = [];
    var pass = false, comment = {}, tidx = 0;
    data.replace(tagregex, function xml_tcmnt(x, idx) {
      var y = parsexmltag(x);
      switch (strip_ns(y[0])) {
        case "<?xml":
          break;
case "<ThreadedComments":
          break;
        case "</ThreadedComments>":
          break;
case "<threadedComment":
          comment = { author: y.personId, guid: y.id, ref: y.ref, T: 1 };
          break;
        case "</threadedComment>":
          if (comment.t != null) out.push(comment);
          break;
        case "<text>":
        case "<text":
          tidx = idx + x.length;
          break;
        case "</text>":
          comment.t = data.slice(tidx, idx).replace(/\r\n/g, "\n").replace(/\r/g, "\n");
          break;
case "<mentions":
        case "<mentions>":
          pass = true;
          break;
        case "</mentions>":
          pass = false;
          break;

case "<extLst":
        case "<extLst>":
        case "</extLst>":
        case "<extLst/>":
          break;
case "<ext":
          pass = true;
          break;
        case "</ext>":
          pass = false;
          break;
        default:
          if (!pass && opts.WTF) throw new Error("unrecognized " + y[0] + " in threaded comments");
      }
      return x;
    });
    return out;
  }
  function write_tcmnt_xml(comments, people, opts) {
    var o = [XML_HEADER, writextag("ThreadedComments", null, { "xmlns": XMLNS.TCMNT }).replace(/[\/]>/, ">")];
    comments.forEach(function(carr) {
      var rootid = "";
      (carr[1] || []).forEach(function(c, idx) {
        if (!c.T) {
          delete c.ID;
          return;
        }
        if (c.a && people.indexOf(c.a) == -1) people.push(c.a);
        var tcopts = {
          ref: carr[0],
          id: "{54EE7951-7262-4200-6969-" + ("000000000000" + opts.tcid++).slice(-12) + "}"
        };
        if (idx == 0) rootid = tcopts.id;
        else tcopts.parentId = rootid;
        c.ID = tcopts.id;
        if (c.a) tcopts.personId = "{54EE7950-7262-4200-6969-" + ("000000000000" + people.indexOf(c.a)).slice(-12) + "}";
        o.push(writextag("threadedComment", writetag("text", c.t || ""), tcopts));
      });
    });
    o.push("</ThreadedComments>");
    return o.join("");
  }
  function parse_people_xml(data, opts) {
    var out = [];
    var pass = false;
    data.replace(tagregex, function xml_tcmnt(x) {
      var y = parsexmltag(x);
      switch (strip_ns(y[0])) {
        case "<?xml":
          break;
case "<personList":
          break;
        case "</personList>":
          break;
case "<person":
          out.push({ name: y.displayname, id: y.id });
          break;
        case "</person>":
          break;
case "<extLst":
        case "<extLst>":
        case "</extLst>":
        case "<extLst/>":
          break;
case "<ext":
          pass = true;
          break;
        case "</ext>":
          pass = false;
          break;
        default:
          if (!pass && opts.WTF) throw new Error("unrecognized " + y[0] + " in threaded comments");
      }
      return x;
    });
    return out;
  }
  function write_people_xml(people) {
    var o = [XML_HEADER, writextag("personList", null, {
      "xmlns": XMLNS.TCMNT,
      "xmlns:x": XMLNS_main[0]
    }).replace(/[\/]>/, ">")];
    people.forEach(function(person, idx) {
      o.push(writextag("person", null, {
        displayName: person,
        id: "{54EE7950-7262-4200-6969-" + ("000000000000" + idx).slice(-12) + "}",
        userId: person,
        providerId: "None"
      }));
    });
    o.push("</personList>");
    return o.join("");
  }
  function parse_BrtBeginComment(data) {
    var out = {};
    out.iauthor = data.read_shift(4);
    var rfx = parse_UncheckedRfX(data);
    out.rfx = rfx.s;
    out.ref = encode_cell(rfx.s);
    data.l += 16;
    return out;
  }
  function write_BrtBeginComment(data, o) {
    if (o == null) o = new_buf(36);
    o.write_shift(4, data[1].iauthor);
    write_UncheckedRfX(data[0], o);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    return o;
  }
  var parse_BrtCommentAuthor = parse_XLWideString;
  function write_BrtCommentAuthor(data) {
    return write_XLWideString(data.slice(0, 54));
  }
  function parse_comments_bin(data, opts) {
    var out = [];
    var authors = [];
    var c = {};
    var pass = false;
    recordhopper(data, function hopper_cmnt(val2, R, RT) {
      switch (RT) {
        case 632:
          authors.push(val2);
          break;
        case 635:
          c = val2;
          break;
        case 637:
          c.t = val2.t;
          c.h = val2.h;
          c.r = val2.r;
          break;
        case 636:
          c.author = authors[c.iauthor];
          delete c.iauthor;
          if (opts.sheetRows && c.rfx && opts.sheetRows <= c.rfx.r) break;
          if (!c.t) c.t = "";
          delete c.rfx;
          out.push(c);
          break;
        case 3072:
          break;
        case 35:
          pass = true;
          break;
        case 36:
          pass = false;
          break;
        case 37:
          break;
        case 38:
          break;
        default:
          if (R.T) ;
          else if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
      }
    });
    return out;
  }
  function write_comments_bin(data) {
    var ba = buf_array();
    var iauthor = [];
    write_record(
      ba,
      628
);
    write_record(
      ba,
      630
);
    data.forEach(function(comment) {
      comment[1].forEach(function(c) {
        if (iauthor.indexOf(c.a) > -1) return;
        iauthor.push(c.a.slice(0, 54));
        write_record(ba, 632, write_BrtCommentAuthor(c.a));
        if (c.T && c.ID && iauthor.indexOf("tc=" + c.ID) == -1) {
          iauthor.push("tc=" + c.ID);
          write_record(ba, 632, write_BrtCommentAuthor("tc=" + c.ID));
        }
      });
    });
    write_record(
      ba,
      631
);
    write_record(
      ba,
      633
);
    data.forEach(function(comment) {
      comment[1].forEach(function(c) {
        var _ia = -1;
        if (c.ID) _ia = iauthor.indexOf("tc=" + c.ID);
        if (_ia == -1 && comment[1][0].T && comment[1][0].ID) _ia = iauthor.indexOf("tc=" + comment[1][0].ID);
        if (_ia == -1) _ia = iauthor.indexOf(c.a);
        c.iauthor = _ia;
        var range = { s: decode_cell(comment[0]), e: decode_cell(comment[0]) };
        write_record(ba, 635, write_BrtBeginComment([range, c]));
        if (c.t && c.t.length > 0) write_record(ba, 637, write_BrtCommentText(c));
        write_record(
          ba,
          636
);
        delete c.iauthor;
      });
    });
    write_record(
      ba,
      634
);
    write_record(
      ba,
      629
);
    return ba.end();
  }
  var CT_VBA = "application/vnd.ms-office.vbaProject";
  function make_vba_xls(cfb) {
    var newcfb = CFB.utils.cfb_new({ root: "R" });
    cfb.FullPaths.forEach(function(p2, i) {
      if (p2.slice(-1) === "/" || !p2.match(/_VBA_PROJECT_CUR/))
        return;
      var newpath = p2.replace(/^[^\/]*/, "R").replace(/\/_VBA_PROJECT_CUR\u0000*/, "");
      CFB.utils.cfb_add(newcfb, newpath, cfb.FileIndex[i].content);
    });
    return CFB.write(newcfb);
  }
  function fill_vba_xls(cfb, vba) {
    vba.FullPaths.forEach(function(p2, i) {
      if (i == 0)
        return;
      var newpath = p2.replace(/^[\/]*[^\/]*[\/]/, "/_VBA_PROJECT_CUR/");
      if (newpath.slice(-1) !== "/")
        CFB.utils.cfb_add(cfb, newpath, vba.FileIndex[i].content);
    });
  }
  var VBAFMTS = ["xlsb", "xlsm", "xlam", "biff8", "xla"];
  function parse_ds_bin() {
    return { "!type": "dialog" };
  }
  function parse_ds_xml() {
    return { "!type": "dialog" };
  }
  function parse_ms_bin() {
    return { "!type": "macro" };
  }
  function parse_ms_xml() {
    return { "!type": "macro" };
  }
  var rc_to_a1 = (function() {
    var rcregex = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g;
    var rcbase = { r: 0, c: 0 };
    function rcfunc($$, $1, $2, $3) {
      var cRel = false, rRel = false;
      if ($2.length == 0) rRel = true;
      else if ($2.charAt(0) == "[") {
        rRel = true;
        $2 = $2.slice(1, -1);
      }
      if ($3.length == 0) cRel = true;
      else if ($3.charAt(0) == "[") {
        cRel = true;
        $3 = $3.slice(1, -1);
      }
      var R = $2.length > 0 ? parseInt($2, 10) | 0 : 0, C = $3.length > 0 ? parseInt($3, 10) | 0 : 0;
      if (cRel) C += rcbase.c;
      else --C;
      if (rRel) R += rcbase.r;
      else --R;
      return $1 + (cRel ? "" : "$") + encode_col(C) + (rRel ? "" : "$") + encode_row(R);
    }
    return function rc_to_a12(fstr, base) {
      rcbase = base;
      return fstr.replace(rcregex, rcfunc);
    };
  })();
  var crefregex = /(^|[^._A-Z0-9])(\$?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])(\$?)(\d{1,7})(?![_.\(A-Za-z0-9])/g;
  try {
    crefregex = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g;
  } catch (e) {
  }
  var a1_to_rc = (function() {
    return function a1_to_rc2(fstr, base) {
      return fstr.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
        var c = decode_col($3) - ($2 ? 0 : base.c);
        var r2 = decode_row($5) - ($4 ? 0 : base.r);
        var R = $4 == "$" ? r2 + 1 : r2 == 0 ? "" : "[" + r2 + "]";
        var C = $2 == "$" ? c + 1 : c == 0 ? "" : "[" + c + "]";
        return $1 + "R" + R + "C" + C;
      });
    };
  })();
  function shift_formula_str(f, delta) {
    return f.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
      return $1 + ($2 == "$" ? $2 + $3 : encode_col(decode_col($3) + delta.c)) + ($4 == "$" ? $4 + $5 : encode_row(decode_row($5) + delta.r));
    });
  }
  function shift_formula_xlsx(f, range, cell) {
    var r2 = decode_range(range), s = r2.s, c = decode_cell(cell);
    var delta = { r: c.r - s.r, c: c.c - s.c };
    return shift_formula_str(f, delta);
  }
  function fuzzyfmla(f) {
    if (f.length == 1) return false;
    return true;
  }
  function _xlfn(f) {
    return f.replace(/_xlfn\./g, "");
  }
  function parseread1(blob) {
    blob.l += 1;
    return;
  }
  function parse_ColRelU(blob, length) {
    var c = blob.read_shift(2);
    return [c & 16383, c >> 14 & 1, c >> 15 & 1];
  }
  function parse_RgceArea(blob, length, opts) {
    var w = 2;
    if (opts) {
      if (opts.biff >= 2 && opts.biff <= 5) return parse_RgceArea_BIFF2(blob);
      else if (opts.biff == 12) w = 4;
    }
    var r2 = blob.read_shift(w), R = blob.read_shift(w);
    var c = parse_ColRelU(blob);
    var C = parse_ColRelU(blob);
    return { s: { r: r2, c: c[0], cRel: c[1], rRel: c[2] }, e: { r: R, c: C[0], cRel: C[1], rRel: C[2] } };
  }
  function parse_RgceArea_BIFF2(blob) {
    var r2 = parse_ColRelU(blob), R = parse_ColRelU(blob);
    var c = blob.read_shift(1);
    var C = blob.read_shift(1);
    return { s: { r: r2[0], c, cRel: r2[1], rRel: r2[2] }, e: { r: R[0], c: C, cRel: R[1], rRel: R[2] } };
  }
  function parse_RgceAreaRel(blob, length, opts) {
    if (opts.biff < 8) return parse_RgceArea_BIFF2(blob);
    var r2 = blob.read_shift(opts.biff == 12 ? 4 : 2), R = blob.read_shift(opts.biff == 12 ? 4 : 2);
    var c = parse_ColRelU(blob);
    var C = parse_ColRelU(blob);
    return { s: { r: r2, c: c[0], cRel: c[1], rRel: c[2] }, e: { r: R, c: C[0], cRel: C[1], rRel: C[2] } };
  }
  function parse_RgceLoc(blob, length, opts) {
    if (opts && opts.biff >= 2 && opts.biff <= 5) return parse_RgceLoc_BIFF2(blob);
    var r2 = blob.read_shift(opts && opts.biff == 12 ? 4 : 2);
    var c = parse_ColRelU(blob);
    return { r: r2, c: c[0], cRel: c[1], rRel: c[2] };
  }
  function parse_RgceLoc_BIFF2(blob) {
    var r2 = parse_ColRelU(blob);
    var c = blob.read_shift(1);
    return { r: r2[0], c, cRel: r2[1], rRel: r2[2] };
  }
  function parse_RgceElfLoc(blob) {
    var r2 = blob.read_shift(2);
    var c = blob.read_shift(2);
    return { r: r2, c: c & 255, fQuoted: !!(c & 16384), cRel: c >> 15, rRel: c >> 15 };
  }
  function parse_RgceLocRel(blob, length, opts) {
    var biff = opts && opts.biff ? opts.biff : 8;
    if (biff >= 2 && biff <= 5) return parse_RgceLocRel_BIFF2(blob);
    var r2 = blob.read_shift(biff >= 12 ? 4 : 2);
    var cl = blob.read_shift(2);
    var cRel = (cl & 16384) >> 14, rRel = (cl & 32768) >> 15;
    cl &= 16383;
    if (rRel == 1) while (r2 > 524287) r2 -= 1048576;
    if (cRel == 1) while (cl > 8191) cl = cl - 16384;
    return { r: r2, c: cl, cRel, rRel };
  }
  function parse_RgceLocRel_BIFF2(blob) {
    var rl = blob.read_shift(2);
    var c = blob.read_shift(1);
    var rRel = (rl & 32768) >> 15, cRel = (rl & 16384) >> 14;
    rl &= 16383;
    if (rRel == 1 && rl >= 8192) rl = rl - 16384;
    if (cRel == 1 && c >= 128) c = c - 256;
    return { r: rl, c, cRel, rRel };
  }
  function parse_PtgArea(blob, length, opts) {
    var type = (blob[blob.l++] & 96) >> 5;
    var area = parse_RgceArea(blob, opts.biff >= 2 && opts.biff <= 5 ? 6 : 8, opts);
    return [type, area];
  }
  function parse_PtgArea3d(blob, length, opts) {
    var type = (blob[blob.l++] & 96) >> 5;
    var ixti = blob.read_shift(2, "i");
    var w = 8;
    if (opts) switch (opts.biff) {
      case 5:
        blob.l += 12;
        w = 6;
        break;
      case 12:
        w = 12;
        break;
    }
    var area = parse_RgceArea(blob, w, opts);
    return [type, ixti, area];
  }
  function parse_PtgAreaErr(blob, length, opts) {
    var type = (blob[blob.l++] & 96) >> 5;
    blob.l += opts && opts.biff > 8 ? 12 : opts.biff < 8 ? 6 : 8;
    return [type];
  }
  function parse_PtgAreaErr3d(blob, length, opts) {
    var type = (blob[blob.l++] & 96) >> 5;
    var ixti = blob.read_shift(2);
    var w = 8;
    if (opts) switch (opts.biff) {
      case 5:
        blob.l += 12;
        w = 6;
        break;
      case 12:
        w = 12;
        break;
    }
    blob.l += w;
    return [type, ixti];
  }
  function parse_PtgAreaN(blob, length, opts) {
    var type = (blob[blob.l++] & 96) >> 5;
    var area = parse_RgceAreaRel(blob, length - 1, opts);
    return [type, area];
  }
  function parse_PtgArray(blob, length, opts) {
    var type = (blob[blob.l++] & 96) >> 5;
    blob.l += opts.biff == 2 ? 6 : opts.biff == 12 ? 14 : 7;
    return [type];
  }
  function parse_PtgAttrBaxcel(blob) {
    var bitSemi = blob[blob.l + 1] & 1;
    var bitBaxcel = 1;
    blob.l += 4;
    return [bitSemi, bitBaxcel];
  }
  function parse_PtgAttrChoose(blob, length, opts) {
    blob.l += 2;
    var offset = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
    var o = [];
    for (var i = 0; i <= offset; ++i) o.push(blob.read_shift(opts && opts.biff == 2 ? 1 : 2));
    return o;
  }
  function parse_PtgAttrGoto(blob, length, opts) {
    var bitGoto = blob[blob.l + 1] & 255 ? 1 : 0;
    blob.l += 2;
    return [bitGoto, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
  }
  function parse_PtgAttrIf(blob, length, opts) {
    var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
    blob.l += 2;
    return [bitIf, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
  }
  function parse_PtgAttrIfError(blob) {
    var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
    blob.l += 2;
    return [bitIf, blob.read_shift(2)];
  }
  function parse_PtgAttrSemi(blob, length, opts) {
    var bitSemi = blob[blob.l + 1] & 255 ? 1 : 0;
    blob.l += opts && opts.biff == 2 ? 3 : 4;
    return [bitSemi];
  }
  function parse_PtgAttrSpaceType(blob) {
    var type = blob.read_shift(1), cch = blob.read_shift(1);
    return [type, cch];
  }
  function parse_PtgAttrSpace(blob) {
    blob.read_shift(2);
    return parse_PtgAttrSpaceType(blob);
  }
  function parse_PtgAttrSpaceSemi(blob) {
    blob.read_shift(2);
    return parse_PtgAttrSpaceType(blob);
  }
  function parse_PtgRef(blob, length, opts) {
    var type = (blob[blob.l] & 96) >> 5;
    blob.l += 1;
    var loc = parse_RgceLoc(blob, 0, opts);
    return [type, loc];
  }
  function parse_PtgRefN(blob, length, opts) {
    var type = (blob[blob.l] & 96) >> 5;
    blob.l += 1;
    var loc = parse_RgceLocRel(blob, 0, opts);
    return [type, loc];
  }
  function parse_PtgRef3d(blob, length, opts) {
    var type = (blob[blob.l] & 96) >> 5;
    blob.l += 1;
    var ixti = blob.read_shift(2);
    if (opts && opts.biff == 5) blob.l += 12;
    var loc = parse_RgceLoc(blob, 0, opts);
    return [type, ixti, loc];
  }
  function parse_PtgFunc(blob, length, opts) {
    var type = (blob[blob.l] & 96) >> 5;
    blob.l += 1;
    var iftab = blob.read_shift(opts && opts.biff <= 3 ? 1 : 2);
    return [FtabArgc[iftab], Ftab[iftab], type];
  }
  function parse_PtgFuncVar(blob, length, opts) {
    var type = blob[blob.l++];
    var cparams = blob.read_shift(1), tab = opts && opts.biff <= 3 ? [type == 88 ? -1 : 0, blob.read_shift(1)] : parsetab(blob);
    return [cparams, (tab[0] === 0 ? Ftab : Cetab)[tab[1]]];
  }
  function parsetab(blob) {
    return [blob[blob.l + 1] >> 7, blob.read_shift(2) & 32767];
  }
  function parse_PtgAttrSum(blob, length, opts) {
    blob.l += opts && opts.biff == 2 ? 3 : 4;
    return;
  }
  function parse_PtgExp(blob, length, opts) {
    blob.l++;
    if (opts && opts.biff == 12) return [blob.read_shift(4, "i"), 0];
    var row = blob.read_shift(2);
    var col = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
    return [row, col];
  }
  function parse_PtgErr(blob) {
    blob.l++;
    return BErr[blob.read_shift(1)];
  }
  function parse_PtgInt(blob) {
    blob.l++;
    return blob.read_shift(2);
  }
  function parse_PtgBool(blob) {
    blob.l++;
    return blob.read_shift(1) !== 0;
  }
  function parse_PtgNum(blob) {
    blob.l++;
    return parse_Xnum(blob);
  }
  function parse_PtgStr(blob, length, opts) {
    blob.l++;
    return parse_ShortXLUnicodeString(blob, length - 1, opts);
  }
  function parse_SerAr(blob, biff) {
    var val2 = [blob.read_shift(1)];
    if (biff == 12) switch (val2[0]) {
      case 2:
        val2[0] = 4;
        break;
case 4:
        val2[0] = 16;
        break;
case 0:
        val2[0] = 1;
        break;
case 1:
        val2[0] = 2;
        break;
    }
    switch (val2[0]) {
      case 4:
        val2[1] = parsebool(blob, 1) ? "TRUE" : "FALSE";
        if (biff != 12) blob.l += 7;
        break;
      case 37:
case 16:
        val2[1] = BErr[blob[blob.l]];
        blob.l += biff == 12 ? 4 : 8;
        break;
      case 0:
        blob.l += 8;
        break;
      case 1:
        val2[1] = parse_Xnum(blob);
        break;
      case 2:
        val2[1] = parse_XLUnicodeString2(blob, 0, { biff: biff > 0 && biff < 8 ? 2 : biff });
        break;
      default:
        throw new Error("Bad SerAr: " + val2[0]);
    }
    return val2;
  }
  function parse_PtgExtraMem(blob, cce, opts) {
    var count = blob.read_shift(opts.biff == 12 ? 4 : 2);
    var out = [];
    for (var i = 0; i != count; ++i) out.push((opts.biff == 12 ? parse_UncheckedRfX : parse_Ref8U)(blob));
    return out;
  }
  function parse_PtgExtraArray(blob, length, opts) {
    var rows = 0, cols = 0;
    if (opts.biff == 12) {
      rows = blob.read_shift(4);
      cols = blob.read_shift(4);
    } else {
      cols = 1 + blob.read_shift(1);
      rows = 1 + blob.read_shift(2);
    }
    if (opts.biff >= 2 && opts.biff < 8) {
      --rows;
      if (--cols == 0) cols = 256;
    }
    for (var i = 0, o = []; i != rows && (o[i] = []); ++i)
      for (var j = 0; j != cols; ++j) o[i][j] = parse_SerAr(blob, opts.biff);
    return o;
  }
  function parse_PtgName(blob, length, opts) {
    var type = blob.read_shift(1) >>> 5 & 3;
    var w = !opts || opts.biff >= 8 ? 4 : 2;
    var nameindex = blob.read_shift(w);
    switch (opts.biff) {
      case 2:
        blob.l += 5;
        break;
      case 3:
      case 4:
        blob.l += 8;
        break;
      case 5:
        blob.l += 12;
        break;
    }
    return [type, 0, nameindex];
  }
  function parse_PtgNameX(blob, length, opts) {
    if (opts.biff == 5) return parse_PtgNameX_BIFF5(blob);
    var type = blob.read_shift(1) >>> 5 & 3;
    var ixti = blob.read_shift(2);
    var nameindex = blob.read_shift(4);
    return [type, ixti, nameindex];
  }
  function parse_PtgNameX_BIFF5(blob) {
    var type = blob.read_shift(1) >>> 5 & 3;
    var ixti = blob.read_shift(2, "i");
    blob.l += 8;
    var nameindex = blob.read_shift(2);
    blob.l += 12;
    return [type, ixti, nameindex];
  }
  function parse_PtgMemArea(blob, length, opts) {
    var type = blob.read_shift(1) >>> 5 & 3;
    blob.l += opts && opts.biff == 2 ? 3 : 4;
    var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
    return [type, cce];
  }
  function parse_PtgMemFunc(blob, length, opts) {
    var type = blob.read_shift(1) >>> 5 & 3;
    var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
    return [type, cce];
  }
  function parse_PtgRefErr(blob, length, opts) {
    var type = blob.read_shift(1) >>> 5 & 3;
    blob.l += 4;
    if (opts.biff < 8) blob.l--;
    if (opts.biff == 12) blob.l += 2;
    return [type];
  }
  function parse_PtgRefErr3d(blob, length, opts) {
    var type = (blob[blob.l++] & 96) >> 5;
    var ixti = blob.read_shift(2);
    var w = 4;
    if (opts) switch (opts.biff) {
      case 5:
        w = 15;
        break;
      case 12:
        w = 6;
        break;
    }
    blob.l += w;
    return [type, ixti];
  }
  var parse_PtgMemErr = parsenoop;
  var parse_PtgMemNoMem = parsenoop;
  var parse_PtgTbl = parsenoop;
  function parse_PtgElfLoc(blob, length, opts) {
    blob.l += 2;
    return [parse_RgceElfLoc(blob)];
  }
  function parse_PtgElfNoop(blob) {
    blob.l += 6;
    return [];
  }
  var parse_PtgElfCol = parse_PtgElfLoc;
  var parse_PtgElfColS = parse_PtgElfNoop;
  var parse_PtgElfColSV = parse_PtgElfNoop;
  var parse_PtgElfColV = parse_PtgElfLoc;
  function parse_PtgElfLel(blob) {
    blob.l += 2;
    return [parseuint16(blob), blob.read_shift(2) & 1];
  }
  var parse_PtgElfRadical = parse_PtgElfLoc;
  var parse_PtgElfRadicalLel = parse_PtgElfLel;
  var parse_PtgElfRadicalS = parse_PtgElfNoop;
  var parse_PtgElfRw = parse_PtgElfLoc;
  var parse_PtgElfRwV = parse_PtgElfLoc;
  var PtgListRT = [
    "Data",
    "All",
    "Headers",
    "??",
    "?Data2",
    "??",
    "?DataHeaders",
    "??",
    "Totals",
    "??",
    "??",
    "??",
    "?DataTotals",
    "??",
    "??",
    "??",
    "?Current"
  ];
  function parse_PtgList(blob) {
    blob.l += 2;
    var ixti = blob.read_shift(2);
    var flags = blob.read_shift(2);
    var idx = blob.read_shift(4);
    var c = blob.read_shift(2);
    var C = blob.read_shift(2);
    var rt = PtgListRT[flags >> 2 & 31];
    return { ixti, coltype: flags & 3, rt, idx, c, C };
  }
  function parse_PtgSxName(blob) {
    blob.l += 2;
    return [blob.read_shift(4)];
  }
  function parse_PtgSheet(blob, length, opts) {
    blob.l += 5;
    blob.l += 2;
    blob.l += opts.biff == 2 ? 1 : 4;
    return ["PTGSHEET"];
  }
  function parse_PtgEndSheet(blob, length, opts) {
    blob.l += opts.biff == 2 ? 4 : 5;
    return ["PTGENDSHEET"];
  }
  function parse_PtgMemAreaN(blob) {
    var type = blob.read_shift(1) >>> 5 & 3;
    var cce = blob.read_shift(2);
    return [type, cce];
  }
  function parse_PtgMemNoMemN(blob) {
    var type = blob.read_shift(1) >>> 5 & 3;
    var cce = blob.read_shift(2);
    return [type, cce];
  }
  function parse_PtgAttrNoop(blob) {
    blob.l += 4;
    return [0, 0];
  }
  var PtgTypes = {
    1: { n: "PtgExp", f: parse_PtgExp },
    2: { n: "PtgTbl", f: parse_PtgTbl },
    3: { n: "PtgAdd", f: parseread1 },
    4: { n: "PtgSub", f: parseread1 },
    5: { n: "PtgMul", f: parseread1 },
    6: { n: "PtgDiv", f: parseread1 },
    7: { n: "PtgPower", f: parseread1 },
    8: { n: "PtgConcat", f: parseread1 },
    9: { n: "PtgLt", f: parseread1 },
    10: { n: "PtgLe", f: parseread1 },
    11: { n: "PtgEq", f: parseread1 },
    12: { n: "PtgGe", f: parseread1 },
    13: { n: "PtgGt", f: parseread1 },
    14: { n: "PtgNe", f: parseread1 },
    15: { n: "PtgIsect", f: parseread1 },
    16: { n: "PtgUnion", f: parseread1 },
    17: { n: "PtgRange", f: parseread1 },
    18: { n: "PtgUplus", f: parseread1 },
    19: { n: "PtgUminus", f: parseread1 },
    20: { n: "PtgPercent", f: parseread1 },
    21: { n: "PtgParen", f: parseread1 },
    22: { n: "PtgMissArg", f: parseread1 },
    23: { n: "PtgStr", f: parse_PtgStr },
    26: { n: "PtgSheet", f: parse_PtgSheet },
    27: { n: "PtgEndSheet", f: parse_PtgEndSheet },
    28: { n: "PtgErr", f: parse_PtgErr },
    29: { n: "PtgBool", f: parse_PtgBool },
    30: { n: "PtgInt", f: parse_PtgInt },
    31: { n: "PtgNum", f: parse_PtgNum },
    32: { n: "PtgArray", f: parse_PtgArray },
    33: { n: "PtgFunc", f: parse_PtgFunc },
    34: { n: "PtgFuncVar", f: parse_PtgFuncVar },
    35: { n: "PtgName", f: parse_PtgName },
    36: { n: "PtgRef", f: parse_PtgRef },
    37: { n: "PtgArea", f: parse_PtgArea },
    38: { n: "PtgMemArea", f: parse_PtgMemArea },
    39: { n: "PtgMemErr", f: parse_PtgMemErr },
    40: { n: "PtgMemNoMem", f: parse_PtgMemNoMem },
    41: { n: "PtgMemFunc", f: parse_PtgMemFunc },
    42: { n: "PtgRefErr", f: parse_PtgRefErr },
    43: { n: "PtgAreaErr", f: parse_PtgAreaErr },
    44: { n: "PtgRefN", f: parse_PtgRefN },
    45: { n: "PtgAreaN", f: parse_PtgAreaN },
    46: { n: "PtgMemAreaN", f: parse_PtgMemAreaN },
    47: { n: "PtgMemNoMemN", f: parse_PtgMemNoMemN },
    57: { n: "PtgNameX", f: parse_PtgNameX },
    58: { n: "PtgRef3d", f: parse_PtgRef3d },
    59: { n: "PtgArea3d", f: parse_PtgArea3d },
    60: { n: "PtgRefErr3d", f: parse_PtgRefErr3d },
    61: { n: "PtgAreaErr3d", f: parse_PtgAreaErr3d },
    255: {}
  };
  var PtgDupes = {
    64: 32,
    96: 32,
    65: 33,
    97: 33,
    66: 34,
    98: 34,
    67: 35,
    99: 35,
    68: 36,
    100: 36,
    69: 37,
    101: 37,
    70: 38,
    102: 38,
    71: 39,
    103: 39,
    72: 40,
    104: 40,
    73: 41,
    105: 41,
    74: 42,
    106: 42,
    75: 43,
    107: 43,
    76: 44,
    108: 44,
    77: 45,
    109: 45,
    78: 46,
    110: 46,
    79: 47,
    111: 47,
    88: 34,
    120: 34,
    89: 57,
    121: 57,
    90: 58,
    122: 58,
    91: 59,
    123: 59,
    92: 60,
    124: 60,
    93: 61,
    125: 61
  };
  var Ptg18 = {
    1: { n: "PtgElfLel", f: parse_PtgElfLel },
    2: { n: "PtgElfRw", f: parse_PtgElfRw },
    3: { n: "PtgElfCol", f: parse_PtgElfCol },
    6: { n: "PtgElfRwV", f: parse_PtgElfRwV },
    7: { n: "PtgElfColV", f: parse_PtgElfColV },
    10: { n: "PtgElfRadical", f: parse_PtgElfRadical },
    11: { n: "PtgElfRadicalS", f: parse_PtgElfRadicalS },
    13: { n: "PtgElfColS", f: parse_PtgElfColS },
    15: { n: "PtgElfColSV", f: parse_PtgElfColSV },
    16: { n: "PtgElfRadicalLel", f: parse_PtgElfRadicalLel },
    25: { n: "PtgList", f: parse_PtgList },
    29: { n: "PtgSxName", f: parse_PtgSxName },
    255: {}
  };
  var Ptg19 = {
    0: { n: "PtgAttrNoop", f: parse_PtgAttrNoop },
    1: { n: "PtgAttrSemi", f: parse_PtgAttrSemi },
    2: { n: "PtgAttrIf", f: parse_PtgAttrIf },
    4: { n: "PtgAttrChoose", f: parse_PtgAttrChoose },
    8: { n: "PtgAttrGoto", f: parse_PtgAttrGoto },
    16: { n: "PtgAttrSum", f: parse_PtgAttrSum },
    32: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
    33: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
    64: { n: "PtgAttrSpace", f: parse_PtgAttrSpace },
    65: { n: "PtgAttrSpaceSemi", f: parse_PtgAttrSpaceSemi },
    128: { n: "PtgAttrIfError", f: parse_PtgAttrIfError },
    255: {}
  };
  function parse_RgbExtra(blob, length, rgce, opts) {
    if (opts.biff < 8) return parsenoop(blob, length);
    var target = blob.l + length;
    var o = [];
    for (var i = 0; i !== rgce.length; ++i) {
      switch (rgce[i][0]) {
        case "PtgArray":
          rgce[i][1] = parse_PtgExtraArray(blob, 0, opts);
          o.push(rgce[i][1]);
          break;
        case "PtgMemArea":
          rgce[i][2] = parse_PtgExtraMem(blob, rgce[i][1], opts);
          o.push(rgce[i][2]);
          break;
        case "PtgExp":
          if (opts && opts.biff == 12) {
            rgce[i][1][1] = blob.read_shift(4);
            o.push(rgce[i][1]);
          }
          break;
        case "PtgList":
case "PtgElfRadicalS":
case "PtgElfColS":
case "PtgElfColSV":
          throw "Unsupported " + rgce[i][0];
      }
    }
    length = target - blob.l;
    if (length !== 0) o.push(parsenoop(blob, length));
    return o;
  }
  function parse_Rgce(blob, length, opts) {
    var target = blob.l + length;
    var R, id, ptgs = [];
    while (target != blob.l) {
      length = target - blob.l;
      id = blob[blob.l];
      R = PtgTypes[id] || PtgTypes[PtgDupes[id]];
      if (id === 24 || id === 25) R = (id === 24 ? Ptg18 : Ptg19)[blob[blob.l + 1]];
      if (!R || !R.f) {
        parsenoop(blob, length);
      } else {
        ptgs.push([R.n, R.f(blob, length, opts)]);
      }
    }
    return ptgs;
  }
  function stringify_array(f) {
    var o = [];
    for (var i = 0; i < f.length; ++i) {
      var x = f[i], r2 = [];
      for (var j = 0; j < x.length; ++j) {
        var y = x[j];
        if (y) switch (y[0]) {
case 2:
            r2.push('"' + y[1].replace(/"/g, '""') + '"');
            break;
          default:
            r2.push(y[1]);
        }
        else r2.push("");
      }
      o.push(r2.join(","));
    }
    return o.join(";");
  }
  var PtgBinOp = {
    PtgAdd: "+",
    PtgConcat: "&",
    PtgDiv: "/",
    PtgEq: "=",
    PtgGe: ">=",
    PtgGt: ">",
    PtgLe: "<=",
    PtgLt: "<",
    PtgMul: "*",
    PtgNe: "<>",
    PtgPower: "^",
    PtgSub: "-"
  };
  function make_3d_range(start, end) {
    var s = start.lastIndexOf("!"), e = end.lastIndexOf("!");
    if (s == -1 && e == -1) return start + ":" + end;
    if (s > 0 && e > 0 && start.slice(0, s).toLowerCase() == end.slice(0, e).toLowerCase()) return start + ":" + end.slice(e + 1);
    console.error("Cannot hydrate range", start, end);
    return start + ":" + end;
  }
  function get_ixti_raw(supbooks, ixti, opts) {
    if (!supbooks) return "SH33TJSERR0";
    if (opts.biff > 8 && (!supbooks.XTI || !supbooks.XTI[ixti])) return supbooks.SheetNames[ixti];
    if (!supbooks.XTI) return "SH33TJSERR6";
    var XTI = supbooks.XTI[ixti];
    if (opts.biff < 8) {
      if (ixti > 1e4) ixti -= 65536;
      if (ixti < 0) ixti = -ixti;
      return ixti == 0 ? "" : supbooks.XTI[ixti - 1];
    }
    if (!XTI) return "SH33TJSERR1";
    var o = "";
    if (opts.biff > 8) switch (supbooks[XTI[0]][0]) {
      case 357:
        o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]];
        return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];
      case 358:
        if (opts.SID != null) return supbooks.SheetNames[opts.SID];
        return "SH33TJSSAME" + supbooks[XTI[0]][0];
      case 355:

default:
        return "SH33TJSSRC" + supbooks[XTI[0]][0];
    }
    switch (supbooks[XTI[0]][0][0]) {
      case 1025:
        o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]] || "SH33TJSERR3";
        return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];
      case 14849:
        return supbooks[XTI[0]].slice(1).map(function(name) {
          return name.Name;
        }).join(";;");
default:
        if (!supbooks[XTI[0]][0][3]) return "SH33TJSERR2";
        o = XTI[1] == -1 ? "#REF" : supbooks[XTI[0]][0][3][XTI[1]] || "SH33TJSERR4";
        return XTI[1] == XTI[2] ? o : o + ":" + supbooks[XTI[0]][0][3][XTI[2]];
    }
  }
  function get_ixti(supbooks, ixti, opts) {
    var ixtiraw = get_ixti_raw(supbooks, ixti, opts);
    return ixtiraw == "#REF" ? ixtiraw : formula_quote_sheet_name(ixtiraw, opts);
  }
  function stringify_formula(formula, range, cell, supbooks, opts) {
    var biff = opts && opts.biff || 8;
    var _range = (
{ s: { c: 0, r: 0 } }
    );
    var stack2 = [], e1, e2, c, ixti = 0, nameidx = 0, r2, sname = "";
    if (!formula[0] || !formula[0][0]) return "";
    var last_sp = -1, sp = "";
    for (var ff = 0, fflen = formula[0].length; ff < fflen; ++ff) {
      var f = formula[0][ff];
      switch (f[0]) {
        case "PtgUminus":
          stack2.push("-" + stack2.pop());
          break;
        case "PtgUplus":
          stack2.push("+" + stack2.pop());
          break;
        case "PtgPercent":
          stack2.push(stack2.pop() + "%");
          break;
        case "PtgAdd":
case "PtgConcat":
case "PtgDiv":
case "PtgEq":
case "PtgGe":
case "PtgGt":
case "PtgLe":
case "PtgLt":
case "PtgMul":
case "PtgNe":
case "PtgPower":
case "PtgSub":
          e1 = stack2.pop();
          e2 = stack2.pop();
          if (last_sp >= 0) {
            switch (formula[0][last_sp][1][0]) {
              case 0:
                sp = fill(" ", formula[0][last_sp][1][1]);
                break;
              case 1:
                sp = fill("\r", formula[0][last_sp][1][1]);
                break;
              default:
                sp = "";
                if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
            }
            e2 = e2 + sp;
            last_sp = -1;
          }
          stack2.push(e2 + PtgBinOp[f[0]] + e1);
          break;
        case "PtgIsect":
          e1 = stack2.pop();
          e2 = stack2.pop();
          stack2.push(e2 + " " + e1);
          break;
        case "PtgUnion":
          e1 = stack2.pop();
          e2 = stack2.pop();
          stack2.push(e2 + "," + e1);
          break;
        case "PtgRange":
          e1 = stack2.pop();
          e2 = stack2.pop();
          stack2.push(make_3d_range(e2, e1));
          break;
        case "PtgAttrChoose":
          break;
        case "PtgAttrGoto":
          break;
        case "PtgAttrIf":
          break;
        case "PtgAttrIfError":
          break;
        case "PtgRef":
          c = shift_cell_xls(f[1][1], _range, opts);
          stack2.push(encode_cell_xls(c, biff));
          break;
        case "PtgRefN":
          c = cell ? shift_cell_xls(f[1][1], cell, opts) : f[1][1];
          stack2.push(encode_cell_xls(c, biff));
          break;
        case "PtgRef3d":
          ixti =
f[1][1];
          c = shift_cell_xls(f[1][2], _range, opts);
          sname = get_ixti(supbooks, ixti, opts);
          stack2.push(sname + "!" + encode_cell_xls(c, biff));
          break;
        case "PtgFunc":
case "PtgFuncVar":
          var argc = f[1][0], func = f[1][1];
          if (!argc) argc = 0;
          argc &= 127;
          var args = argc == 0 ? [] : stack2.slice(-argc);
          stack2.length -= argc;
          if (func === "User") func = args.shift();
          stack2.push(func + "(" + args.join(",") + ")");
          break;
        case "PtgBool":
          stack2.push(f[1] ? "TRUE" : "FALSE");
          break;
        case "PtgInt":
          stack2.push(
f[1]
);
          break;
        case "PtgNum":
          stack2.push(String(f[1]));
          break;
        case "PtgStr":
          stack2.push('"' + f[1].replace(/"/g, '""') + '"');
          break;
        case "PtgErr":
          stack2.push(
f[1]
);
          break;
        case "PtgAreaN":
          r2 = shift_range_xls(f[1][1], cell ? { s: cell } : _range, opts);
          stack2.push(encode_range_xls(r2, opts));
          break;
        case "PtgArea":
          r2 = shift_range_xls(f[1][1], _range, opts);
          stack2.push(encode_range_xls(r2, opts));
          break;
        case "PtgArea3d":
          ixti =
f[1][1];
          r2 = f[1][2];
          sname = get_ixti(supbooks, ixti, opts);
          stack2.push(sname + "!" + encode_range_xls(r2, opts));
          break;
        case "PtgAttrSum":
          stack2.push("SUM(" + stack2.pop() + ")");
          break;
        case "PtgAttrBaxcel":
case "PtgAttrSemi":
          break;
        case "PtgName":
          nameidx = f[1][2];
          var lbl = (supbooks.names || [])[nameidx - 1] || (supbooks[0] || [])[nameidx];
          var name = lbl ? lbl.Name : "SH33TJSNAME" + String(nameidx);
          if (name && name.slice(0, 6) == "_xlfn." && !opts.xlfn) name = name.slice(6);
          stack2.push(name);
          break;
        case "PtgNameX":
          var bookidx = f[1][1];
          nameidx = f[1][2];
          var externbook;
          if (opts.biff <= 5) {
            if (bookidx < 0) bookidx = -bookidx;
            if (supbooks[bookidx]) externbook = supbooks[bookidx][nameidx];
          } else {
            var o = "";
            if (((supbooks[bookidx] || [])[0] || [])[0] == 14849) ;
            else if (((supbooks[bookidx] || [])[0] || [])[0] == 1025) {
              if (supbooks[bookidx][nameidx] && supbooks[bookidx][nameidx].itab > 0) {
                o = supbooks.SheetNames[supbooks[bookidx][nameidx].itab - 1] + "!";
              }
            } else o = supbooks.SheetNames[nameidx - 1] + "!";
            if (supbooks[bookidx] && supbooks[bookidx][nameidx]) o += supbooks[bookidx][nameidx].Name;
            else if (supbooks[0] && supbooks[0][nameidx]) o += supbooks[0][nameidx].Name;
            else {
              var ixtidata = (get_ixti_raw(supbooks, bookidx, opts) || "").split(";;");
              if (ixtidata[nameidx - 1]) o = ixtidata[nameidx - 1];
              else o += "SH33TJSERRX";
            }
            stack2.push(o);
            break;
          }
          if (!externbook) externbook = { Name: "SH33TJSERRY" };
          stack2.push(externbook.Name);
          break;
        case "PtgParen":
          var lp = "(", rp = ")";
          if (last_sp >= 0) {
            sp = "";
            switch (formula[0][last_sp][1][0]) {
case 2:
                lp = fill(" ", formula[0][last_sp][1][1]) + lp;
                break;
case 3:
                lp = fill("\r", formula[0][last_sp][1][1]) + lp;
                break;
case 4:
                rp = fill(" ", formula[0][last_sp][1][1]) + rp;
                break;
case 5:
                rp = fill("\r", formula[0][last_sp][1][1]) + rp;
                break;
              default:
                if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
            }
            last_sp = -1;
          }
          stack2.push(lp + stack2.pop() + rp);
          break;
        case "PtgRefErr":
          stack2.push("#REF!");
          break;
        case "PtgRefErr3d":
          stack2.push("#REF!");
          break;
        case "PtgExp":
          c = { c: f[1][1], r: f[1][0] };
          var q = { c: cell.c, r: cell.r };
          if (supbooks.sharedf[encode_cell(c)]) {
            var parsedf = supbooks.sharedf[encode_cell(c)];
            stack2.push(stringify_formula(parsedf, _range, q, supbooks, opts));
          } else {
            var fnd = false;
            for (e1 = 0; e1 != supbooks.arrayf.length; ++e1) {
              e2 = supbooks.arrayf[e1];
              if (c.c < e2[0].s.c || c.c > e2[0].e.c) continue;
              if (c.r < e2[0].s.r || c.r > e2[0].e.r) continue;
              stack2.push(stringify_formula(e2[1], _range, q, supbooks, opts));
              fnd = true;
              break;
            }
            if (!fnd) stack2.push(
f[1]
);
          }
          break;
        case "PtgArray":
          stack2.push("{" + stringify_array(
f[1]
) + "}");
          break;
        case "PtgMemArea":
          break;
        case "PtgAttrSpace":
case "PtgAttrSpaceSemi":
          last_sp = ff;
          break;
        case "PtgTbl":
          break;
        case "PtgMemErr":
          break;
        case "PtgMissArg":
          stack2.push("");
          break;
        case "PtgAreaErr":
          stack2.push("#REF!");
          break;
        case "PtgAreaErr3d":
          stack2.push("#REF!");
          break;
        case "PtgList":
          stack2.push("Table" + f[1].idx + "[#" + f[1].rt + "]");
          break;
        case "PtgMemAreaN":
        case "PtgMemNoMemN":
        case "PtgAttrNoop":
        case "PtgSheet":
        case "PtgEndSheet":
          break;
        case "PtgMemFunc":
          break;
        case "PtgMemNoMem":
          break;
        case "PtgElfCol":
case "PtgElfColS":
case "PtgElfColSV":
case "PtgElfColV":
case "PtgElfLel":
case "PtgElfRadical":
case "PtgElfRadicalLel":
case "PtgElfRadicalS":
case "PtgElfRw":
case "PtgElfRwV":
          throw new Error("Unsupported ELFs");
        case "PtgSxName":
          throw new Error("Unrecognized Formula Token: " + String(f));
        default:
          throw new Error("Unrecognized Formula Token: " + String(f));
      }
      var PtgNonDisp = ["PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto"];
      if (opts.biff != 3) {
        if (last_sp >= 0 && PtgNonDisp.indexOf(formula[0][ff][0]) == -1) {
          f = formula[0][last_sp];
          var _left = true;
          switch (f[1][0]) {
case 4:
              _left = false;
case 0:
              sp = fill(" ", f[1][1]);
              break;
            case 5:
              _left = false;
case 1:
              sp = fill("\r", f[1][1]);
              break;
            default:
              sp = "";
              if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + f[1][0]);
          }
          stack2.push((_left ? sp : "") + stack2.pop() + (_left ? "" : sp));
          last_sp = -1;
        }
      }
    }
    if (stack2.length > 1 && opts.WTF) throw new Error("bad formula stack");
    if (stack2[0] == "TRUE") return true;
    if (stack2[0] == "FALSE") return false;
    return stack2[0];
  }
  function parse_ArrayParsedFormula(blob, length, opts) {
    var target = blob.l + length, len = opts.biff == 2 ? 1 : 2;
    var rgcb, cce = blob.read_shift(len);
    if (cce == 65535) return [[], parsenoop(blob, length - 2)];
    var rgce = parse_Rgce(blob, cce, opts);
    if (length !== cce + len) rgcb = parse_RgbExtra(blob, length - cce - len, rgce, opts);
    blob.l = target;
    return [rgce, rgcb];
  }
  function parse_XLSCellParsedFormula(blob, length, opts) {
    var target = blob.l + length, len = opts.biff == 2 ? 1 : 2;
    var rgcb, cce = blob.read_shift(len);
    if (cce == 65535) return [[], parsenoop(blob, length - 2)];
    var rgce = parse_Rgce(blob, cce, opts);
    if (length !== cce + len) rgcb = parse_RgbExtra(blob, length - cce - len, rgce, opts);
    blob.l = target;
    return [rgce, rgcb];
  }
  function parse_NameParsedFormula(blob, length, opts, cce) {
    var target = blob.l + length;
    var rgce = parse_Rgce(blob, cce, opts);
    var rgcb;
    if (target !== blob.l) rgcb = parse_RgbExtra(blob, target - blob.l, rgce, opts);
    return [rgce, rgcb];
  }
  function parse_SharedParsedFormula(blob, length, opts) {
    var target = blob.l + length;
    var rgcb, cce = blob.read_shift(2);
    var rgce = parse_Rgce(blob, cce, opts);
    if (cce == 65535) return [[], parsenoop(blob, length - 2)];
    if (length !== cce + 2) rgcb = parse_RgbExtra(blob, target - cce - 2, rgce, opts);
    return [rgce, rgcb];
  }
  function parse_FormulaValue(blob) {
    var b;
    if (__readUInt16LE(blob, blob.l + 6) !== 65535) return [parse_Xnum(blob), "n"];
    switch (blob[blob.l]) {
      case 0:
        blob.l += 8;
        return ["String", "s"];
      case 1:
        b = blob[blob.l + 2] === 1;
        blob.l += 8;
        return [b, "b"];
      case 2:
        b = blob[blob.l + 2];
        blob.l += 8;
        return [b, "e"];
      case 3:
        blob.l += 8;
        return ["", "s"];
    }
    return [];
  }
  function write_FormulaValue(value) {
    if (value == null) {
      var o = new_buf(8);
      o.write_shift(1, 3);
      o.write_shift(1, 0);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(2, 65535);
      return o;
    } else if (typeof value == "number") return write_Xnum(value);
    return write_Xnum(0);
  }
  function parse_Formula(blob, length, opts) {
    var end = blob.l + length;
    var cell = parse_XLSCell(blob, 6, opts);
    var val2 = parse_FormulaValue(blob);
    var flags = blob.read_shift(1);
    if (opts.biff != 2) {
      blob.read_shift(1);
      if (opts.biff >= 5) {
        blob.read_shift(4);
      }
    }
    var cbf = parse_XLSCellParsedFormula(blob, end - blob.l, opts);
    return { cell, val: val2[0], formula: cbf, shared: flags >> 3 & 1, tt: val2[1] };
  }
  function write_Formula(cell, R, C, opts, os) {
    var o1 = write_XLSCell(R, C, os);
    var o2 = write_FormulaValue(cell.v);
    var o3 = new_buf(6);
    var flags = 1 | 32;
    o3.write_shift(2, flags);
    o3.write_shift(4, 0);
    var bf = new_buf(cell.bf.length);
    for (var i = 0; i < cell.bf.length; ++i) bf[i] = cell.bf[i];
    var out = bconcat([o1, o2, o3, bf]);
    return out;
  }
  function parse_XLSBParsedFormula(data, length, opts) {
    var cce = data.read_shift(4);
    var rgce = parse_Rgce(data, cce, opts);
    var cb = data.read_shift(4);
    var rgcb = cb > 0 ? parse_RgbExtra(data, cb, rgce, opts) : null;
    return [rgce, rgcb];
  }
  var parse_XLSBArrayParsedFormula = parse_XLSBParsedFormula;
  var parse_XLSBCellParsedFormula = parse_XLSBParsedFormula;
  var parse_XLSBNameParsedFormula = parse_XLSBParsedFormula;
  var parse_XLSBSharedParsedFormula = parse_XLSBParsedFormula;
  function write_XLSBFormulaNum(val2) {
    if ((val2 | 0) == val2 && val2 < Math.pow(2, 16) && val2 >= 0) {
      var oint = new_buf(11);
      oint.write_shift(4, 3);
      oint.write_shift(1, 30);
      oint.write_shift(2, val2);
      oint.write_shift(4, 0);
      return oint;
    }
    var num = new_buf(17);
    num.write_shift(4, 11);
    num.write_shift(1, 31);
    num.write_shift(8, val2);
    num.write_shift(4, 0);
    return num;
  }
  function write_XLSBFormulaErr(val2) {
    var oint = new_buf(10);
    oint.write_shift(4, 2);
    oint.write_shift(1, 28);
    oint.write_shift(1, val2);
    oint.write_shift(4, 0);
    return oint;
  }
  function write_XLSBFormulaBool(val2) {
    var oint = new_buf(10);
    oint.write_shift(4, 2);
    oint.write_shift(1, 29);
    oint.write_shift(1, val2 ? 1 : 0);
    oint.write_shift(4, 0);
    return oint;
  }
  function write_XLSBFormulaStr(val2) {
    var preamble = new_buf(7);
    preamble.write_shift(4, 3 + 2 * val2.length);
    preamble.write_shift(1, 23);
    preamble.write_shift(2, val2.length);
    var body = new_buf(2 * val2.length);
    body.write_shift(2 * val2.length, val2, "utf16le");
    var postamble = new_buf(4);
    postamble.write_shift(4, 0);
    return bconcat([preamble, body, postamble]);
  }
  function write_XLSBFormulaRef(str) {
    var cell = decode_cell(str);
    var out = new_buf(15);
    out.write_shift(4, 7);
    out.write_shift(1, 4 | 1 << 5);
    out.write_shift(4, cell.r);
    out.write_shift(2, cell.c | (str.charAt(0) == "$" ? 0 : 1) << 14 | (str.match(/\$\d/) ? 0 : 1) << 15);
    out.write_shift(4, 0);
    return out;
  }
  function write_XLSBFormulaRef3D(str, wb) {
    var lastbang = str.lastIndexOf("!");
    var sname = str.slice(0, lastbang);
    str = str.slice(lastbang + 1);
    var cell = decode_cell(str);
    if (sname.charAt(0) == "'") sname = sname.slice(1, -1).replace(/''/g, "'");
    var out = new_buf(17);
    out.write_shift(4, 9);
    out.write_shift(1, 26 | 1 << 5);
    out.write_shift(2, 2 + wb.SheetNames.map(function(n) {
      return n.toLowerCase();
    }).indexOf(sname.toLowerCase()));
    out.write_shift(4, cell.r);
    out.write_shift(2, cell.c | (str.charAt(0) == "$" ? 0 : 1) << 14 | (str.match(/\$\d/) ? 0 : 1) << 15);
    out.write_shift(4, 0);
    return out;
  }
  function write_XLSBFormulaRefErr3D(str, wb) {
    var lastbang = str.lastIndexOf("!");
    var sname = str.slice(0, lastbang);
    str = str.slice(lastbang + 1);
    if (sname.charAt(0) == "'") sname = sname.slice(1, -1).replace(/''/g, "'");
    var out = new_buf(17);
    out.write_shift(4, 9);
    out.write_shift(1, 28 | 1 << 5);
    out.write_shift(2, 2 + wb.SheetNames.map(function(n) {
      return n.toLowerCase();
    }).indexOf(sname.toLowerCase()));
    out.write_shift(4, 0);
    out.write_shift(2, 0);
    out.write_shift(4, 0);
    return out;
  }
  function write_XLSBFormulaRange(_str) {
    var parts = _str.split(":"), str = parts[0];
    var out = new_buf(23);
    out.write_shift(4, 15);
    str = parts[0];
    var cell = decode_cell(str);
    out.write_shift(1, 4 | 1 << 5);
    out.write_shift(4, cell.r);
    out.write_shift(2, cell.c | (str.charAt(0) == "$" ? 0 : 1) << 14 | (str.match(/\$\d/) ? 0 : 1) << 15);
    out.write_shift(4, 0);
    str = parts[1];
    cell = decode_cell(str);
    out.write_shift(1, 4 | 1 << 5);
    out.write_shift(4, cell.r);
    out.write_shift(2, cell.c | (str.charAt(0) == "$" ? 0 : 1) << 14 | (str.match(/\$\d/) ? 0 : 1) << 15);
    out.write_shift(4, 0);
    out.write_shift(1, 17);
    out.write_shift(4, 0);
    return out;
  }
  function write_XLSBFormulaRangeWS(_str, wb) {
    var lastbang = _str.lastIndexOf("!");
    var sname = _str.slice(0, lastbang);
    _str = _str.slice(lastbang + 1);
    if (sname.charAt(0) == "'") sname = sname.slice(1, -1).replace(/''/g, "'");
    var parts = _str.split(":");
    var out = new_buf(27);
    out.write_shift(4, 19);
    var str = parts[0], cell = decode_cell(str);
    out.write_shift(1, 26 | 1 << 5);
    out.write_shift(2, 2 + wb.SheetNames.map(function(n) {
      return n.toLowerCase();
    }).indexOf(sname.toLowerCase()));
    out.write_shift(4, cell.r);
    out.write_shift(2, cell.c | (str.charAt(0) == "$" ? 0 : 1) << 14 | (str.match(/\$\d/) ? 0 : 1) << 15);
    str = parts[1];
    cell = decode_cell(str);
    out.write_shift(1, 26 | 1 << 5);
    out.write_shift(2, 2 + wb.SheetNames.map(function(n) {
      return n.toLowerCase();
    }).indexOf(sname.toLowerCase()));
    out.write_shift(4, cell.r);
    out.write_shift(2, cell.c | (str.charAt(0) == "$" ? 0 : 1) << 14 | (str.match(/\$\d/) ? 0 : 1) << 15);
    out.write_shift(1, 17);
    out.write_shift(4, 0);
    return out;
  }
  function write_XLSBFormulaArea3D(_str, wb) {
    var lastbang = _str.lastIndexOf("!");
    var sname = _str.slice(0, lastbang);
    _str = _str.slice(lastbang + 1);
    if (sname.charAt(0) == "'") sname = sname.slice(1, -1).replace(/''/g, "'");
    var range = decode_range(_str);
    var out = new_buf(23);
    out.write_shift(4, 15);
    out.write_shift(1, 27 | 1 << 5);
    out.write_shift(2, 2 + wb.SheetNames.map(function(n) {
      return n.toLowerCase();
    }).indexOf(sname.toLowerCase()));
    out.write_shift(4, range.s.r);
    out.write_shift(4, range.e.r);
    out.write_shift(2, range.s.c);
    out.write_shift(2, range.e.c);
    out.write_shift(4, 0);
    return out;
  }
  function write_XLSBFormula(val2, wb) {
    if (typeof val2 == "number") return write_XLSBFormulaNum(val2);
    if (typeof val2 == "boolean") return write_XLSBFormulaBool(val2);
    if (/^#(DIV\/0!|GETTING_DATA|N\/A|NAME\?|NULL!|NUM!|REF!|VALUE!)$/.test(val2)) return write_XLSBFormulaErr(+RBErr[val2]);
    if (val2.match(/^\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRef(val2);
    if (val2.match(/^\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRange(val2);
    if (val2.match(/^#REF!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaArea3D(val2, wb);
    if (val2.match(/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,<.>]*)!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRef3D(val2, wb);
    if (val2.match(/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,<.>]*)!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/)) return write_XLSBFormulaRangeWS(val2, wb);
    if (/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,<.>]*)!#REF!$/.test(val2)) return write_XLSBFormulaRefErr3D(val2, wb);
    if (/^".*"$/.test(val2)) return write_XLSBFormulaStr(val2);
    if (/^[+-]\d+$/.test(val2)) return write_XLSBFormulaNum(parseInt(val2, 10));
    throw "Formula |" + val2 + "| not supported for XLSB";
  }
  var write_XLSBNameParsedFormula = write_XLSBFormula;
  var Cetab = {
    0: "BEEP",
    1: "OPEN",
    2: "OPEN.LINKS",
    3: "CLOSE.ALL",
    4: "SAVE",
    5: "SAVE.AS",
    6: "FILE.DELETE",
    7: "PAGE.SETUP",
    8: "PRINT",
    9: "PRINTER.SETUP",
    10: "QUIT",
    11: "NEW.WINDOW",
    12: "ARRANGE.ALL",
    13: "WINDOW.SIZE",
    14: "WINDOW.MOVE",
    15: "FULL",
    16: "CLOSE",
    17: "RUN",
    22: "SET.PRINT.AREA",
    23: "SET.PRINT.TITLES",
    24: "SET.PAGE.BREAK",
    25: "REMOVE.PAGE.BREAK",
    26: "FONT",
    27: "DISPLAY",
    28: "PROTECT.DOCUMENT",
    29: "PRECISION",
    30: "A1.R1C1",
    31: "CALCULATE.NOW",
    32: "CALCULATION",
    34: "DATA.FIND",
    35: "EXTRACT",
    36: "DATA.DELETE",
    37: "SET.DATABASE",
    38: "SET.CRITERIA",
    39: "SORT",
    40: "DATA.SERIES",
    41: "TABLE",
    42: "FORMAT.NUMBER",
    43: "ALIGNMENT",
    44: "STYLE",
    45: "BORDER",
    46: "CELL.PROTECTION",
    47: "COLUMN.WIDTH",
    48: "UNDO",
    49: "CUT",
    50: "COPY",
    51: "PASTE",
    52: "CLEAR",
    53: "PASTE.SPECIAL",
    54: "EDIT.DELETE",
    55: "INSERT",
    56: "FILL.RIGHT",
    57: "FILL.DOWN",
    61: "DEFINE.NAME",
    62: "CREATE.NAMES",
    63: "FORMULA.GOTO",
    64: "FORMULA.FIND",
    65: "SELECT.LAST.CELL",
    66: "SHOW.ACTIVE.CELL",
    67: "GALLERY.AREA",
    68: "GALLERY.BAR",
    69: "GALLERY.COLUMN",
    70: "GALLERY.LINE",
    71: "GALLERY.PIE",
    72: "GALLERY.SCATTER",
    73: "COMBINATION",
    74: "PREFERRED",
    75: "ADD.OVERLAY",
    76: "GRIDLINES",
    77: "SET.PREFERRED",
    78: "AXES",
    79: "LEGEND",
    80: "ATTACH.TEXT",
    81: "ADD.ARROW",
    82: "SELECT.CHART",
    83: "SELECT.PLOT.AREA",
    84: "PATTERNS",
    85: "MAIN.CHART",
    86: "OVERLAY",
    87: "SCALE",
    88: "FORMAT.LEGEND",
    89: "FORMAT.TEXT",
    90: "EDIT.REPEAT",
    91: "PARSE",
    92: "JUSTIFY",
    93: "HIDE",
    94: "UNHIDE",
    95: "WORKSPACE",
    96: "FORMULA",
    97: "FORMULA.FILL",
    98: "FORMULA.ARRAY",
    99: "DATA.FIND.NEXT",
    100: "DATA.FIND.PREV",
    101: "FORMULA.FIND.NEXT",
    102: "FORMULA.FIND.PREV",
    103: "ACTIVATE",
    104: "ACTIVATE.NEXT",
    105: "ACTIVATE.PREV",
    106: "UNLOCKED.NEXT",
    107: "UNLOCKED.PREV",
    108: "COPY.PICTURE",
    109: "SELECT",
    110: "DELETE.NAME",
    111: "DELETE.FORMAT",
    112: "VLINE",
    113: "HLINE",
    114: "VPAGE",
    115: "HPAGE",
    116: "VSCROLL",
    117: "HSCROLL",
    118: "ALERT",
    119: "NEW",
    120: "CANCEL.COPY",
    121: "SHOW.CLIPBOARD",
    122: "MESSAGE",
    124: "PASTE.LINK",
    125: "APP.ACTIVATE",
    126: "DELETE.ARROW",
    127: "ROW.HEIGHT",
    128: "FORMAT.MOVE",
    129: "FORMAT.SIZE",
    130: "FORMULA.REPLACE",
    131: "SEND.KEYS",
    132: "SELECT.SPECIAL",
    133: "APPLY.NAMES",
    134: "REPLACE.FONT",
    135: "FREEZE.PANES",
    136: "SHOW.INFO",
    137: "SPLIT",
    138: "ON.WINDOW",
    139: "ON.DATA",
    140: "DISABLE.INPUT",
    142: "OUTLINE",
    143: "LIST.NAMES",
    144: "FILE.CLOSE",
    145: "SAVE.WORKBOOK",
    146: "DATA.FORM",
    147: "COPY.CHART",
    148: "ON.TIME",
    149: "WAIT",
    150: "FORMAT.FONT",
    151: "FILL.UP",
    152: "FILL.LEFT",
    153: "DELETE.OVERLAY",
    155: "SHORT.MENUS",
    159: "SET.UPDATE.STATUS",
    161: "COLOR.PALETTE",
    162: "DELETE.STYLE",
    163: "WINDOW.RESTORE",
    164: "WINDOW.MAXIMIZE",
    166: "CHANGE.LINK",
    167: "CALCULATE.DOCUMENT",
    168: "ON.KEY",
    169: "APP.RESTORE",
    170: "APP.MOVE",
    171: "APP.SIZE",
    172: "APP.MINIMIZE",
    173: "APP.MAXIMIZE",
    174: "BRING.TO.FRONT",
    175: "SEND.TO.BACK",
    185: "MAIN.CHART.TYPE",
    186: "OVERLAY.CHART.TYPE",
    187: "SELECT.END",
    188: "OPEN.MAIL",
    189: "SEND.MAIL",
    190: "STANDARD.FONT",
    191: "CONSOLIDATE",
    192: "SORT.SPECIAL",
    193: "GALLERY.3D.AREA",
    194: "GALLERY.3D.COLUMN",
    195: "GALLERY.3D.LINE",
    196: "GALLERY.3D.PIE",
    197: "VIEW.3D",
    198: "GOAL.SEEK",
    199: "WORKGROUP",
    200: "FILL.GROUP",
    201: "UPDATE.LINK",
    202: "PROMOTE",
    203: "DEMOTE",
    204: "SHOW.DETAIL",
    206: "UNGROUP",
    207: "OBJECT.PROPERTIES",
    208: "SAVE.NEW.OBJECT",
    209: "SHARE",
    210: "SHARE.NAME",
    211: "DUPLICATE",
    212: "APPLY.STYLE",
    213: "ASSIGN.TO.OBJECT",
    214: "OBJECT.PROTECTION",
    215: "HIDE.OBJECT",
    216: "SET.EXTRACT",
    217: "CREATE.PUBLISHER",
    218: "SUBSCRIBE.TO",
    219: "ATTRIBUTES",
    220: "SHOW.TOOLBAR",
    222: "PRINT.PREVIEW",
    223: "EDIT.COLOR",
    224: "SHOW.LEVELS",
    225: "FORMAT.MAIN",
    226: "FORMAT.OVERLAY",
    227: "ON.RECALC",
    228: "EDIT.SERIES",
    229: "DEFINE.STYLE",
    240: "LINE.PRINT",
    243: "ENTER.DATA",
    249: "GALLERY.RADAR",
    250: "MERGE.STYLES",
    251: "EDITION.OPTIONS",
    252: "PASTE.PICTURE",
    253: "PASTE.PICTURE.LINK",
    254: "SPELLING",
    256: "ZOOM",
    259: "INSERT.OBJECT",
    260: "WINDOW.MINIMIZE",
    265: "SOUND.NOTE",
    266: "SOUND.PLAY",
    267: "FORMAT.SHAPE",
    268: "EXTEND.POLYGON",
    269: "FORMAT.AUTO",
    272: "GALLERY.3D.BAR",
    273: "GALLERY.3D.SURFACE",
    274: "FILL.AUTO",
    276: "CUSTOMIZE.TOOLBAR",
    277: "ADD.TOOL",
    278: "EDIT.OBJECT",
    279: "ON.DOUBLECLICK",
    280: "ON.ENTRY",
    281: "WORKBOOK.ADD",
    282: "WORKBOOK.MOVE",
    283: "WORKBOOK.COPY",
    284: "WORKBOOK.OPTIONS",
    285: "SAVE.WORKSPACE",
    288: "CHART.WIZARD",
    289: "DELETE.TOOL",
    290: "MOVE.TOOL",
    291: "WORKBOOK.SELECT",
    292: "WORKBOOK.ACTIVATE",
    293: "ASSIGN.TO.TOOL",
    295: "COPY.TOOL",
    296: "RESET.TOOL",
    297: "CONSTRAIN.NUMERIC",
    298: "PASTE.TOOL",
    302: "WORKBOOK.NEW",
    305: "SCENARIO.CELLS",
    306: "SCENARIO.DELETE",
    307: "SCENARIO.ADD",
    308: "SCENARIO.EDIT",
    309: "SCENARIO.SHOW",
    310: "SCENARIO.SHOW.NEXT",
    311: "SCENARIO.SUMMARY",
    312: "PIVOT.TABLE.WIZARD",
    313: "PIVOT.FIELD.PROPERTIES",
    314: "PIVOT.FIELD",
    315: "PIVOT.ITEM",
    316: "PIVOT.ADD.FIELDS",
    318: "OPTIONS.CALCULATION",
    319: "OPTIONS.EDIT",
    320: "OPTIONS.VIEW",
    321: "ADDIN.MANAGER",
    322: "MENU.EDITOR",
    323: "ATTACH.TOOLBARS",
    324: "VBAActivate",
    325: "OPTIONS.CHART",
    328: "VBA.INSERT.FILE",
    330: "VBA.PROCEDURE.DEFINITION",
    336: "ROUTING.SLIP",
    338: "ROUTE.DOCUMENT",
    339: "MAIL.LOGON",
    342: "INSERT.PICTURE",
    343: "EDIT.TOOL",
    344: "GALLERY.DOUGHNUT",
    350: "CHART.TREND",
    352: "PIVOT.ITEM.PROPERTIES",
    354: "WORKBOOK.INSERT",
    355: "OPTIONS.TRANSITION",
    356: "OPTIONS.GENERAL",
    370: "FILTER.ADVANCED",
    373: "MAIL.ADD.MAILER",
    374: "MAIL.DELETE.MAILER",
    375: "MAIL.REPLY",
    376: "MAIL.REPLY.ALL",
    377: "MAIL.FORWARD",
    378: "MAIL.NEXT.LETTER",
    379: "DATA.LABEL",
    380: "INSERT.TITLE",
    381: "FONT.PROPERTIES",
    382: "MACRO.OPTIONS",
    383: "WORKBOOK.HIDE",
    384: "WORKBOOK.UNHIDE",
    385: "WORKBOOK.DELETE",
    386: "WORKBOOK.NAME",
    388: "GALLERY.CUSTOM",
    390: "ADD.CHART.AUTOFORMAT",
    391: "DELETE.CHART.AUTOFORMAT",
    392: "CHART.ADD.DATA",
    393: "AUTO.OUTLINE",
    394: "TAB.ORDER",
    395: "SHOW.DIALOG",
    396: "SELECT.ALL",
    397: "UNGROUP.SHEETS",
    398: "SUBTOTAL.CREATE",
    399: "SUBTOTAL.REMOVE",
    400: "RENAME.OBJECT",
    412: "WORKBOOK.SCROLL",
    413: "WORKBOOK.NEXT",
    414: "WORKBOOK.PREV",
    415: "WORKBOOK.TAB.SPLIT",
    416: "FULL.SCREEN",
    417: "WORKBOOK.PROTECT",
    420: "SCROLLBAR.PROPERTIES",
    421: "PIVOT.SHOW.PAGES",
    422: "TEXT.TO.COLUMNS",
    423: "FORMAT.CHARTTYPE",
    424: "LINK.FORMAT",
    425: "TRACER.DISPLAY",
    430: "TRACER.NAVIGATE",
    431: "TRACER.CLEAR",
    432: "TRACER.ERROR",
    433: "PIVOT.FIELD.GROUP",
    434: "PIVOT.FIELD.UNGROUP",
    435: "CHECKBOX.PROPERTIES",
    436: "LABEL.PROPERTIES",
    437: "LISTBOX.PROPERTIES",
    438: "EDITBOX.PROPERTIES",
    439: "PIVOT.REFRESH",
    440: "LINK.COMBO",
    441: "OPEN.TEXT",
    442: "HIDE.DIALOG",
    443: "SET.DIALOG.FOCUS",
    444: "ENABLE.OBJECT",
    445: "PUSHBUTTON.PROPERTIES",
    446: "SET.DIALOG.DEFAULT",
    447: "FILTER",
    448: "FILTER.SHOW.ALL",
    449: "CLEAR.OUTLINE",
    450: "FUNCTION.WIZARD",
    451: "ADD.LIST.ITEM",
    452: "SET.LIST.ITEM",
    453: "REMOVE.LIST.ITEM",
    454: "SELECT.LIST.ITEM",
    455: "SET.CONTROL.VALUE",
    456: "SAVE.COPY.AS",
    458: "OPTIONS.LISTS.ADD",
    459: "OPTIONS.LISTS.DELETE",
    460: "SERIES.AXES",
    461: "SERIES.X",
    462: "SERIES.Y",
    463: "ERRORBAR.X",
    464: "ERRORBAR.Y",
    465: "FORMAT.CHART",
    466: "SERIES.ORDER",
    467: "MAIL.LOGOFF",
    468: "CLEAR.ROUTING.SLIP",
    469: "APP.ACTIVATE.MICROSOFT",
    470: "MAIL.EDIT.MAILER",
    471: "ON.SHEET",
    472: "STANDARD.WIDTH",
    473: "SCENARIO.MERGE",
    474: "SUMMARY.INFO",
    475: "FIND.FILE",
    476: "ACTIVE.CELL.FONT",
    477: "ENABLE.TIPWIZARD",
    478: "VBA.MAKE.ADDIN",
    480: "INSERTDATATABLE",
    481: "WORKGROUP.OPTIONS",
    482: "MAIL.SEND.MAILER",
    485: "AUTOCORRECT",
    489: "POST.DOCUMENT",
    491: "PICKLIST",
    493: "VIEW.SHOW",
    494: "VIEW.DEFINE",
    495: "VIEW.DELETE",
    509: "SHEET.BACKGROUND",
    510: "INSERT.MAP.OBJECT",
    511: "OPTIONS.MENONO",
    517: "MSOCHECKS",
    518: "NORMAL",
    519: "LAYOUT",
    520: "RM.PRINT.AREA",
    521: "CLEAR.PRINT.AREA",
    522: "ADD.PRINT.AREA",
    523: "MOVE.BRK",
    545: "HIDECURR.NOTE",
    546: "HIDEALL.NOTES",
    547: "DELETE.NOTE",
    548: "TRAVERSE.NOTES",
    549: "ACTIVATE.NOTES",
    620: "PROTECT.REVISIONS",
    621: "UNPROTECT.REVISIONS",
    647: "OPTIONS.ME",
    653: "WEB.PUBLISH",
    667: "NEWWEBQUERY",
    673: "PIVOT.TABLE.CHART",
    753: "OPTIONS.SAVE",
    755: "OPTIONS.SPELL",
    808: "HIDEALL.INKANNOTS"
  };
  var Ftab = {
    0: "COUNT",
    1: "IF",
    2: "ISNA",
    3: "ISERROR",
    4: "SUM",
    5: "AVERAGE",
    6: "MIN",
    7: "MAX",
    8: "ROW",
    9: "COLUMN",
    10: "NA",
    11: "NPV",
    12: "STDEV",
    13: "DOLLAR",
    14: "FIXED",
    15: "SIN",
    16: "COS",
    17: "TAN",
    18: "ATAN",
    19: "PI",
    20: "SQRT",
    21: "EXP",
    22: "LN",
    23: "LOG10",
    24: "ABS",
    25: "INT",
    26: "SIGN",
    27: "ROUND",
    28: "LOOKUP",
    29: "INDEX",
    30: "REPT",
    31: "MID",
    32: "LEN",
    33: "VALUE",
    34: "TRUE",
    35: "FALSE",
    36: "AND",
    37: "OR",
    38: "NOT",
    39: "MOD",
    40: "DCOUNT",
    41: "DSUM",
    42: "DAVERAGE",
    43: "DMIN",
    44: "DMAX",
    45: "DSTDEV",
    46: "VAR",
    47: "DVAR",
    48: "TEXT",
    49: "LINEST",
    50: "TREND",
    51: "LOGEST",
    52: "GROWTH",
    53: "GOTO",
    54: "HALT",
    55: "RETURN",
    56: "PV",
    57: "FV",
    58: "NPER",
    59: "PMT",
    60: "RATE",
    61: "MIRR",
    62: "IRR",
    63: "RAND",
    64: "MATCH",
    65: "DATE",
    66: "TIME",
    67: "DAY",
    68: "MONTH",
    69: "YEAR",
    70: "WEEKDAY",
    71: "HOUR",
    72: "MINUTE",
    73: "SECOND",
    74: "NOW",
    75: "AREAS",
    76: "ROWS",
    77: "COLUMNS",
    78: "OFFSET",
    79: "ABSREF",
    80: "RELREF",
    81: "ARGUMENT",
    82: "SEARCH",
    83: "TRANSPOSE",
    84: "ERROR",
    85: "STEP",
    86: "TYPE",
    87: "ECHO",
    88: "SET.NAME",
    89: "CALLER",
    90: "DEREF",
    91: "WINDOWS",
    92: "SERIES",
    93: "DOCUMENTS",
    94: "ACTIVE.CELL",
    95: "SELECTION",
    96: "RESULT",
    97: "ATAN2",
    98: "ASIN",
    99: "ACOS",
    100: "CHOOSE",
    101: "HLOOKUP",
    102: "VLOOKUP",
    103: "LINKS",
    104: "INPUT",
    105: "ISREF",
    106: "GET.FORMULA",
    107: "GET.NAME",
    108: "SET.VALUE",
    109: "LOG",
    110: "EXEC",
    111: "CHAR",
    112: "LOWER",
    113: "UPPER",
    114: "PROPER",
    115: "LEFT",
    116: "RIGHT",
    117: "EXACT",
    118: "TRIM",
    119: "REPLACE",
    120: "SUBSTITUTE",
    121: "CODE",
    122: "NAMES",
    123: "DIRECTORY",
    124: "FIND",
    125: "CELL",
    126: "ISERR",
    127: "ISTEXT",
    128: "ISNUMBER",
    129: "ISBLANK",
    130: "T",
    131: "N",
    132: "FOPEN",
    133: "FCLOSE",
    134: "FSIZE",
    135: "FREADLN",
    136: "FREAD",
    137: "FWRITELN",
    138: "FWRITE",
    139: "FPOS",
    140: "DATEVALUE",
    141: "TIMEVALUE",
    142: "SLN",
    143: "SYD",
    144: "DDB",
    145: "GET.DEF",
    146: "REFTEXT",
    147: "TEXTREF",
    148: "INDIRECT",
    149: "REGISTER",
    150: "CALL",
    151: "ADD.BAR",
    152: "ADD.MENU",
    153: "ADD.COMMAND",
    154: "ENABLE.COMMAND",
    155: "CHECK.COMMAND",
    156: "RENAME.COMMAND",
    157: "SHOW.BAR",
    158: "DELETE.MENU",
    159: "DELETE.COMMAND",
    160: "GET.CHART.ITEM",
    161: "DIALOG.BOX",
    162: "CLEAN",
    163: "MDETERM",
    164: "MINVERSE",
    165: "MMULT",
    166: "FILES",
    167: "IPMT",
    168: "PPMT",
    169: "COUNTA",
    170: "CANCEL.KEY",
    171: "FOR",
    172: "WHILE",
    173: "BREAK",
    174: "NEXT",
    175: "INITIATE",
    176: "REQUEST",
    177: "POKE",
    178: "EXECUTE",
    179: "TERMINATE",
    180: "RESTART",
    181: "HELP",
    182: "GET.BAR",
    183: "PRODUCT",
    184: "FACT",
    185: "GET.CELL",
    186: "GET.WORKSPACE",
    187: "GET.WINDOW",
    188: "GET.DOCUMENT",
    189: "DPRODUCT",
    190: "ISNONTEXT",
    191: "GET.NOTE",
    192: "NOTE",
    193: "STDEVP",
    194: "VARP",
    195: "DSTDEVP",
    196: "DVARP",
    197: "TRUNC",
    198: "ISLOGICAL",
    199: "DCOUNTA",
    200: "DELETE.BAR",
    201: "UNREGISTER",
    204: "USDOLLAR",
    205: "FINDB",
    206: "SEARCHB",
    207: "REPLACEB",
    208: "LEFTB",
    209: "RIGHTB",
    210: "MIDB",
    211: "LENB",
    212: "ROUNDUP",
    213: "ROUNDDOWN",
    214: "ASC",
    215: "DBCS",
    216: "RANK",
    219: "ADDRESS",
    220: "DAYS360",
    221: "TODAY",
    222: "VDB",
    223: "ELSE",
    224: "ELSE.IF",
    225: "END.IF",
    226: "FOR.CELL",
    227: "MEDIAN",
    228: "SUMPRODUCT",
    229: "SINH",
    230: "COSH",
    231: "TANH",
    232: "ASINH",
    233: "ACOSH",
    234: "ATANH",
    235: "DGET",
    236: "CREATE.OBJECT",
    237: "VOLATILE",
    238: "LAST.ERROR",
    239: "CUSTOM.UNDO",
    240: "CUSTOM.REPEAT",
    241: "FORMULA.CONVERT",
    242: "GET.LINK.INFO",
    243: "TEXT.BOX",
    244: "INFO",
    245: "GROUP",
    246: "GET.OBJECT",
    247: "DB",
    248: "PAUSE",
    251: "RESUME",
    252: "FREQUENCY",
    253: "ADD.TOOLBAR",
    254: "DELETE.TOOLBAR",
    255: "User",
    256: "RESET.TOOLBAR",
    257: "EVALUATE",
    258: "GET.TOOLBAR",
    259: "GET.TOOL",
    260: "SPELLING.CHECK",
    261: "ERROR.TYPE",
    262: "APP.TITLE",
    263: "WINDOW.TITLE",
    264: "SAVE.TOOLBAR",
    265: "ENABLE.TOOL",
    266: "PRESS.TOOL",
    267: "REGISTER.ID",
    268: "GET.WORKBOOK",
    269: "AVEDEV",
    270: "BETADIST",
    271: "GAMMALN",
    272: "BETAINV",
    273: "BINOMDIST",
    274: "CHIDIST",
    275: "CHIINV",
    276: "COMBIN",
    277: "CONFIDENCE",
    278: "CRITBINOM",
    279: "EVEN",
    280: "EXPONDIST",
    281: "FDIST",
    282: "FINV",
    283: "FISHER",
    284: "FISHERINV",
    285: "FLOOR",
    286: "GAMMADIST",
    287: "GAMMAINV",
    288: "CEILING",
    289: "HYPGEOMDIST",
    290: "LOGNORMDIST",
    291: "LOGINV",
    292: "NEGBINOMDIST",
    293: "NORMDIST",
    294: "NORMSDIST",
    295: "NORMINV",
    296: "NORMSINV",
    297: "STANDARDIZE",
    298: "ODD",
    299: "PERMUT",
    300: "POISSON",
    301: "TDIST",
    302: "WEIBULL",
    303: "SUMXMY2",
    304: "SUMX2MY2",
    305: "SUMX2PY2",
    306: "CHITEST",
    307: "CORREL",
    308: "COVAR",
    309: "FORECAST",
    310: "FTEST",
    311: "INTERCEPT",
    312: "PEARSON",
    313: "RSQ",
    314: "STEYX",
    315: "SLOPE",
    316: "TTEST",
    317: "PROB",
    318: "DEVSQ",
    319: "GEOMEAN",
    320: "HARMEAN",
    321: "SUMSQ",
    322: "KURT",
    323: "SKEW",
    324: "ZTEST",
    325: "LARGE",
    326: "SMALL",
    327: "QUARTILE",
    328: "PERCENTILE",
    329: "PERCENTRANK",
    330: "MODE",
    331: "TRIMMEAN",
    332: "TINV",
    334: "MOVIE.COMMAND",
    335: "GET.MOVIE",
    336: "CONCATENATE",
    337: "POWER",
    338: "PIVOT.ADD.DATA",
    339: "GET.PIVOT.TABLE",
    340: "GET.PIVOT.FIELD",
    341: "GET.PIVOT.ITEM",
    342: "RADIANS",
    343: "DEGREES",
    344: "SUBTOTAL",
    345: "SUMIF",
    346: "COUNTIF",
    347: "COUNTBLANK",
    348: "SCENARIO.GET",
    349: "OPTIONS.LISTS.GET",
    350: "ISPMT",
    351: "DATEDIF",
    352: "DATESTRING",
    353: "NUMBERSTRING",
    354: "ROMAN",
    355: "OPEN.DIALOG",
    356: "SAVE.DIALOG",
    357: "VIEW.GET",
    358: "GETPIVOTDATA",
    359: "HYPERLINK",
    360: "PHONETIC",
    361: "AVERAGEA",
    362: "MAXA",
    363: "MINA",
    364: "STDEVPA",
    365: "VARPA",
    366: "STDEVA",
    367: "VARA",
    368: "BAHTTEXT",
    369: "THAIDAYOFWEEK",
    370: "THAIDIGIT",
    371: "THAIMONTHOFYEAR",
    372: "THAINUMSOUND",
    373: "THAINUMSTRING",
    374: "THAISTRINGLENGTH",
    375: "ISTHAIDIGIT",
    376: "ROUNDBAHTDOWN",
    377: "ROUNDBAHTUP",
    378: "THAIYEAR",
    379: "RTD",
    380: "CUBEVALUE",
    381: "CUBEMEMBER",
    382: "CUBEMEMBERPROPERTY",
    383: "CUBERANKEDMEMBER",
    384: "HEX2BIN",
    385: "HEX2DEC",
    386: "HEX2OCT",
    387: "DEC2BIN",
    388: "DEC2HEX",
    389: "DEC2OCT",
    390: "OCT2BIN",
    391: "OCT2HEX",
    392: "OCT2DEC",
    393: "BIN2DEC",
    394: "BIN2OCT",
    395: "BIN2HEX",
    396: "IMSUB",
    397: "IMDIV",
    398: "IMPOWER",
    399: "IMABS",
    400: "IMSQRT",
    401: "IMLN",
    402: "IMLOG2",
    403: "IMLOG10",
    404: "IMSIN",
    405: "IMCOS",
    406: "IMEXP",
    407: "IMARGUMENT",
    408: "IMCONJUGATE",
    409: "IMAGINARY",
    410: "IMREAL",
    411: "COMPLEX",
    412: "IMSUM",
    413: "IMPRODUCT",
    414: "SERIESSUM",
    415: "FACTDOUBLE",
    416: "SQRTPI",
    417: "QUOTIENT",
    418: "DELTA",
    419: "GESTEP",
    420: "ISEVEN",
    421: "ISODD",
    422: "MROUND",
    423: "ERF",
    424: "ERFC",
    425: "BESSELJ",
    426: "BESSELK",
    427: "BESSELY",
    428: "BESSELI",
    429: "XIRR",
    430: "XNPV",
    431: "PRICEMAT",
    432: "YIELDMAT",
    433: "INTRATE",
    434: "RECEIVED",
    435: "DISC",
    436: "PRICEDISC",
    437: "YIELDDISC",
    438: "TBILLEQ",
    439: "TBILLPRICE",
    440: "TBILLYIELD",
    441: "PRICE",
    442: "YIELD",
    443: "DOLLARDE",
    444: "DOLLARFR",
    445: "NOMINAL",
    446: "EFFECT",
    447: "CUMPRINC",
    448: "CUMIPMT",
    449: "EDATE",
    450: "EOMONTH",
    451: "YEARFRAC",
    452: "COUPDAYBS",
    453: "COUPDAYS",
    454: "COUPDAYSNC",
    455: "COUPNCD",
    456: "COUPNUM",
    457: "COUPPCD",
    458: "DURATION",
    459: "MDURATION",
    460: "ODDLPRICE",
    461: "ODDLYIELD",
    462: "ODDFPRICE",
    463: "ODDFYIELD",
    464: "RANDBETWEEN",
    465: "WEEKNUM",
    466: "AMORDEGRC",
    467: "AMORLINC",
    468: "CONVERT",
    724: "SHEETJS",
    469: "ACCRINT",
    470: "ACCRINTM",
    471: "WORKDAY",
    472: "NETWORKDAYS",
    473: "GCD",
    474: "MULTINOMIAL",
    475: "LCM",
    476: "FVSCHEDULE",
    477: "CUBEKPIMEMBER",
    478: "CUBESET",
    479: "CUBESETCOUNT",
    480: "IFERROR",
    481: "COUNTIFS",
    482: "SUMIFS",
    483: "AVERAGEIF",
    484: "AVERAGEIFS"
  };
  var FtabArgc = {
    2: 1,
    3: 1,
    10: 0,
    15: 1,
    16: 1,
    17: 1,
    18: 1,
    19: 0,
    20: 1,
    21: 1,
    22: 1,
    23: 1,
    24: 1,
    25: 1,
    26: 1,
    27: 2,
    30: 2,
    31: 3,
    32: 1,
    33: 1,
    34: 0,
    35: 0,
    38: 1,
    39: 2,
    40: 3,
    41: 3,
    42: 3,
    43: 3,
    44: 3,
    45: 3,
    47: 3,
    48: 2,
    53: 1,
    61: 3,
    63: 0,
    65: 3,
    66: 3,
    67: 1,
    68: 1,
    69: 1,
    70: 1,
    71: 1,
    72: 1,
    73: 1,
    74: 0,
    75: 1,
    76: 1,
    77: 1,
    79: 2,
    80: 2,
    83: 1,
    85: 0,
    86: 1,
    89: 0,
    90: 1,
    94: 0,
    95: 0,
    97: 2,
    98: 1,
    99: 1,
    101: 3,
    102: 3,
    105: 1,
    106: 1,
    108: 2,
    111: 1,
    112: 1,
    113: 1,
    114: 1,
    117: 2,
    118: 1,
    119: 4,
    121: 1,
    126: 1,
    127: 1,
    128: 1,
    129: 1,
    130: 1,
    131: 1,
    133: 1,
    134: 1,
    135: 1,
    136: 2,
    137: 2,
    138: 2,
    140: 1,
    141: 1,
    142: 3,
    143: 4,
    144: 4,
    161: 1,
    162: 1,
    163: 1,
    164: 1,
    165: 2,
    172: 1,
    175: 2,
    176: 2,
    177: 3,
    178: 2,
    179: 1,
    184: 1,
    186: 1,
    189: 3,
    190: 1,
    195: 3,
    196: 3,
    197: 1,
    198: 1,
    199: 3,
    201: 1,
    207: 4,
    210: 3,
    211: 1,
    212: 2,
    213: 2,
    214: 1,
    215: 1,
    225: 0,
    229: 1,
    230: 1,
    231: 1,
    232: 1,
    233: 1,
    234: 1,
    235: 3,
    244: 1,
    247: 4,
    252: 2,
    257: 1,
    261: 1,
    271: 1,
    273: 4,
    274: 2,
    275: 2,
    276: 2,
    277: 3,
    278: 3,
    279: 1,
    280: 3,
    281: 3,
    282: 3,
    283: 1,
    284: 1,
    285: 2,
    286: 4,
    287: 3,
    288: 2,
    289: 4,
    290: 3,
    291: 3,
    292: 3,
    293: 4,
    294: 1,
    295: 3,
    296: 1,
    297: 3,
    298: 1,
    299: 2,
    300: 3,
    301: 3,
    302: 4,
    303: 2,
    304: 2,
    305: 2,
    306: 2,
    307: 2,
    308: 2,
    309: 3,
    310: 2,
    311: 2,
    312: 2,
    313: 2,
    314: 2,
    315: 2,
    316: 4,
    325: 2,
    326: 2,
    327: 2,
    328: 2,
    331: 2,
    332: 2,
    337: 2,
    342: 1,
    343: 1,
    346: 2,
    347: 1,
    350: 4,
    351: 3,
    352: 1,
    353: 2,
    360: 1,
    368: 1,
    369: 1,
    370: 1,
    371: 1,
    372: 1,
    373: 1,
    374: 1,
    375: 1,
    376: 1,
    377: 1,
    378: 1,
    382: 3,
    385: 1,
    392: 1,
    393: 1,
    396: 2,
    397: 2,
    398: 2,
    399: 1,
    400: 1,
    401: 1,
    402: 1,
    403: 1,
    404: 1,
    405: 1,
    406: 1,
    407: 1,
    408: 1,
    409: 1,
    410: 1,
    414: 4,
    415: 1,
    416: 1,
    417: 2,
    420: 1,
    421: 1,
    422: 2,
    424: 1,
    425: 2,
    426: 2,
    427: 2,
    428: 2,
    430: 3,
    438: 3,
    439: 3,
    440: 3,
    443: 2,
    444: 2,
    445: 2,
    446: 2,
    447: 6,
    448: 6,
    449: 2,
    450: 2,
    464: 2,
    468: 3,
    476: 2,
    479: 1,
    480: 2,
    65535: 0
  };
  function ods_to_csf_formula(f) {
    if (f.slice(0, 3) == "of:") f = f.slice(3);
    if (f.charCodeAt(0) == 61) {
      f = f.slice(1);
      if (f.charCodeAt(0) == 61) f = f.slice(1);
    }
    f = f.replace(/COM\.MICROSOFT\./g, "");
    f = f.replace(/\[((?:\.[A-Z]+[0-9]+)(?::\.[A-Z]+[0-9]+)?)\]/g, function($$, $1) {
      return $1.replace(/\./g, "");
    });
    f = f.replace(/\$'([^']|'')+'/g, function($$) {
      return $$.slice(1);
    });
    f = f.replace(/\$([^\]\. #$]+)/g, function($$, $1) {
      return $1.match(/^([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])?(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})?$/) ? $$ : $1;
    });
    f = f.replace(/\[.(#[A-Z]*[?!])\]/g, "$1");
    return f.replace(/[;~]/g, ",").replace(/\|/g, ";");
  }
  function csf_to_ods_formula(f) {
    var o = "of:=" + f.replace(crefregex, "$1[.$2$3$4$5]").replace(/\]:\[/g, ":");
    return o.replace(/;/g, "|").replace(/,/g, ";");
  }
  function ods_to_csf_3D(r2) {
    r2 = r2.replace(/\$'([^']|'')+'/g, function($$) {
      return $$.slice(1);
    });
    r2 = r2.replace(/\$([^\]\. #$]+)/g, function($$, $1) {
      return $1.match(/^([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])?(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})?$/) ? $$ : $1;
    });
    var a = r2.split(":");
    var s = a[0].split(".")[0];
    return [s, a[0].split(".")[1] + (a.length > 1 ? ":" + (a[1].split(".")[1] || a[1].split(".")[0]) : "")];
  }
  function csf_to_ods_3D(r2) {
    return r2.replace(/!/, ".").replace(/:/, ":.");
  }
  var strs = {};
  var _ssfopts = {};
  var browser_has_Map = typeof Map !== "undefined";
  function get_sst_id(sst, str, rev) {
    var i = 0, len = sst.length;
    if (rev) {
      if (browser_has_Map ? rev.has(str) : Object.prototype.hasOwnProperty.call(rev, str)) {
        var revarr = browser_has_Map ? rev.get(str) : rev[str];
        for (; i < revarr.length; ++i) {
          if (sst[revarr[i]].t === str) {
            sst.Count++;
            return revarr[i];
          }
        }
      }
    } else for (; i < len; ++i) {
      if (sst[i].t === str) {
        sst.Count++;
        return i;
      }
    }
    sst[len] = { t: str };
    sst.Count++;
    sst.Unique++;
    if (rev) {
      if (browser_has_Map) {
        if (!rev.has(str)) rev.set(str, []);
        rev.get(str).push(len);
      } else {
        if (!Object.prototype.hasOwnProperty.call(rev, str)) rev[str] = [];
        rev[str].push(len);
      }
    }
    return len;
  }
  function col_obj_w(C, col) {
    var p2 = { min: C + 1, max: C + 1 };
    var wch = -1;
    if (col.MDW) MDW = col.MDW;
    if (col.width != null) p2.customWidth = 1;
    else if (col.wpx != null) wch = px2char(col.wpx);
    else if (col.wch != null) wch = col.wch;
    if (wch > -1) {
      p2.width = char2width(wch);
      p2.customWidth = 1;
    } else if (col.width != null) p2.width = col.width;
    if (col.hidden) p2.hidden = true;
    if (col.level != null) {
      p2.outlineLevel = p2.level = col.level;
    }
    return p2;
  }
  function default_margins(margins, mode) {
    if (!margins) return;
    var defs = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];
    if (mode == "xlml") defs = [1, 1, 1, 1, 0.5, 0.5];
    if (margins.left == null) margins.left = defs[0];
    if (margins.right == null) margins.right = defs[1];
    if (margins.top == null) margins.top = defs[2];
    if (margins.bottom == null) margins.bottom = defs[3];
    if (margins.header == null) margins.header = defs[4];
    if (margins.footer == null) margins.footer = defs[5];
  }
  function get_cell_style(styles, cell, opts) {
    var z = opts.revssf[cell.z != null ? cell.z : "General"];
    var i = 60, len = styles.length;
    if (z == null && opts.ssf) {
      for (; i < 392; ++i) if (opts.ssf[i] == null) {
        SSF__load(cell.z, i);
        opts.ssf[i] = cell.z;
        opts.revssf[cell.z] = z = i;
        break;
      }
    }
    for (i = 0; i != len; ++i) if (styles[i].numFmtId === z) return i;
    styles[len] = {
      numFmtId: z,
      fontId: 0,
      fillId: 0,
      borderId: 0,
      xfId: 0,
      applyNumberFormat: 1
    };
    return len;
  }
  function safe_format(p2, fmtid, fillid, opts, themes, styles, date1904) {
    try {
      if (opts.cellNF) p2.z = table_fmt[fmtid];
    } catch (e) {
      if (opts.WTF) throw e;
    }
    if (p2.t === "z" && !opts.cellStyles) return;
    if (p2.t === "d" && typeof p2.v === "string") p2.v = parseDate(p2.v);
    if ((!opts || opts.cellText !== false) && p2.t !== "z") try {
      if (table_fmt[fmtid] == null) SSF__load(SSFImplicit[fmtid] || "General", fmtid);
      if (p2.t === "e") p2.w = p2.w || BErr[p2.v];
      else if (fmtid === 0) {
        if (p2.t === "n") {
          if ((p2.v | 0) === p2.v) p2.w = p2.v.toString(10);
          else p2.w = SSF_general_num(p2.v);
        } else if (p2.t === "d") {
          var dd = datenum(p2.v, !!date1904);
          if ((dd | 0) === dd) p2.w = dd.toString(10);
          else p2.w = SSF_general_num(dd);
        } else if (p2.v === void 0) return "";
        else p2.w = SSF_general(p2.v, _ssfopts);
      } else if (p2.t === "d") p2.w = SSF_format(fmtid, datenum(p2.v, !!date1904), _ssfopts);
      else p2.w = SSF_format(fmtid, p2.v, _ssfopts);
    } catch (e) {
      if (opts.WTF) throw e;
    }
    if (!opts.cellStyles) return;
    if (fillid != null) try {
      p2.s = styles.Fills[fillid];
      if (p2.s.fgColor && p2.s.fgColor.theme && !p2.s.fgColor.rgb) {
        p2.s.fgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p2.s.fgColor.theme].rgb, p2.s.fgColor.tint || 0);
        if (opts.WTF) p2.s.fgColor.raw_rgb = themes.themeElements.clrScheme[p2.s.fgColor.theme].rgb;
      }
      if (p2.s.bgColor && p2.s.bgColor.theme) {
        p2.s.bgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p2.s.bgColor.theme].rgb, p2.s.bgColor.tint || 0);
        if (opts.WTF) p2.s.bgColor.raw_rgb = themes.themeElements.clrScheme[p2.s.bgColor.theme].rgb;
      }
    } catch (e) {
      if (opts.WTF && styles.Fills) throw e;
    }
  }
  function check_ws(ws, sname, i) {
    if (ws && ws["!ref"]) {
      var range = safe_decode_range(ws["!ref"]);
      if (range.e.c < range.s.c || range.e.r < range.s.r) throw new Error("Bad range (" + i + "): " + ws["!ref"]);
    }
  }
  function parse_ws_xml_dim(ws, s) {
    var d = safe_decode_range(s);
    if (d.s.r <= d.e.r && d.s.c <= d.e.c && d.s.r >= 0 && d.s.c >= 0) ws["!ref"] = encode_range(d);
  }
  var mergecregex = /<(?:\w+:)?mergeCell ref=["'][A-Z0-9:]+['"]\s*[\/]?>/g;
  var hlinkregex = /<(?:\w+:)?hyperlink [^<>]*>/mg;
  var dimregex = /"(\w*:\w*)"/;
  var colregex = /<(?:\w+:)?col\b[^<>]*[\/]?>/g;
  var afregex = /<(?:\w+:)?autoFilter[^>]*/g;
  var marginregex = /<(?:\w+:)?pageMargins[^<>]*\/>/g;
  var sheetprregex = /<(?:\w+:)?sheetPr\b[^<>]*?\/>/;
  function parse_ws_xml(data, opts, idx, rels, wb, themes, styles) {
    if (!data) return data;
    if (!rels) rels = { "!id": {} };
    var s = {};
    if (opts.dense) s["!data"] = [];
    var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
    var data1 = "", data2 = "";
    var mtch = str_match_xml_ns(data, "sheetData");
    if (mtch) {
      data1 = data.slice(0, mtch.index);
      data2 = data.slice(mtch.index + mtch[0].length);
    } else data1 = data2 = data;
    var sheetPr = data1.match(sheetprregex);
    if (sheetPr) parse_ws_xml_sheetpr(sheetPr[0], s, wb, idx);
    else if (sheetPr = str_match_xml_ns(data1, "sheetPr")) parse_ws_xml_sheetpr2(sheetPr[0], sheetPr[1] || "", s, wb, idx);
    var ridx = (data1.match(/<(?:\w*:)?dimension/) || { index: -1 }).index;
    if (ridx > 0) {
      var ref2 = data1.slice(ridx, ridx + 50).match(dimregex);
      if (ref2 && !(opts && opts.nodim)) parse_ws_xml_dim(s, ref2[1]);
    }
    var svs = str_match_xml_ns(data1, "sheetViews");
    if (svs && svs[1]) parse_ws_xml_sheetviews(svs[1], wb);
    var columns = [];
    if (opts.cellStyles) {
      var cols = data1.match(colregex);
      if (cols) parse_ws_xml_cols(columns, cols);
    }
    if (mtch) parse_ws_xml_data(mtch[1], s, opts, refguess, themes, styles, wb);
    var afilter = data2.match(afregex);
    if (afilter) s["!autofilter"] = parse_ws_xml_autofilter(afilter[0]);
    var merges = [];
    var _merge = data2.match(mergecregex);
    if (_merge) for (ridx = 0; ridx != _merge.length; ++ridx)
      merges[ridx] = safe_decode_range(_merge[ridx].slice(_merge[ridx].indexOf("=") + 2));
    var hlink = data2.match(hlinkregex);
    if (hlink) parse_ws_xml_hlinks(s, hlink, rels);
    var margins = data2.match(marginregex);
    if (margins) s["!margins"] = parse_ws_xml_margins(parsexmltag(margins[0]));
    var m;
    if (m = data2.match(/legacyDrawing r:id="(.*?)"/)) s["!legrel"] = m[1];
    if (opts && opts.nodim) refguess.s.c = refguess.s.r = 0;
    if (!s["!ref"] && refguess.e.c >= refguess.s.c && refguess.e.r >= refguess.s.r) s["!ref"] = encode_range(refguess);
    if (opts.sheetRows > 0 && s["!ref"]) {
      var tmpref = safe_decode_range(s["!ref"]);
      if (opts.sheetRows <= +tmpref.e.r) {
        tmpref.e.r = opts.sheetRows - 1;
        if (tmpref.e.r > refguess.e.r) tmpref.e.r = refguess.e.r;
        if (tmpref.e.r < tmpref.s.r) tmpref.s.r = tmpref.e.r;
        if (tmpref.e.c > refguess.e.c) tmpref.e.c = refguess.e.c;
        if (tmpref.e.c < tmpref.s.c) tmpref.s.c = tmpref.e.c;
        s["!fullref"] = s["!ref"];
        s["!ref"] = encode_range(tmpref);
      }
    }
    if (columns.length > 0) s["!cols"] = columns;
    if (merges.length > 0) s["!merges"] = merges;
    if (rels["!id"][s["!legrel"]]) s["!legdrawel"] = rels["!id"][s["!legrel"]];
    return s;
  }
  function write_ws_xml_merges(merges) {
    if (merges.length === 0) return "";
    var o = '<mergeCells count="' + merges.length + '">';
    for (var i = 0; i != merges.length; ++i) o += '<mergeCell ref="' + encode_range(merges[i]) + '"/>';
    return o + "</mergeCells>";
  }
  function parse_ws_xml_sheetpr(sheetPr, s, wb, idx) {
    var data = parsexmltag(sheetPr);
    if (!wb.Sheets[idx]) wb.Sheets[idx] = {};
    if (data.codeName) wb.Sheets[idx].CodeName = unescapexml(utf8read(data.codeName));
  }
  function parse_ws_xml_sheetpr2(sheetPr, body, s, wb, idx) {
    parse_ws_xml_sheetpr(sheetPr.slice(0, sheetPr.indexOf(">")), s, wb, idx);
  }
  function write_ws_xml_sheetpr(ws, wb, idx, opts, o) {
    var needed = false;
    var props = {}, payload = null;
    if (opts.bookType !== "xlsx" && wb.vbaraw) {
      var cname = wb.SheetNames[idx];
      try {
        if (wb.Workbook) cname = wb.Workbook.Sheets[idx].CodeName || cname;
      } catch (e) {
      }
      needed = true;
      props.codeName = utf8write(escapexml(cname));
    }
    if (ws && ws["!outline"]) {
      var outlineprops = { summaryBelow: 1, summaryRight: 1 };
      if (ws["!outline"].above) outlineprops.summaryBelow = 0;
      if (ws["!outline"].left) outlineprops.summaryRight = 0;
      payload = (payload || "") + writextag("outlinePr", null, outlineprops);
    }
    if (!needed && !payload) return;
    o[o.length] = writextag("sheetPr", payload, props);
  }
  var sheetprot_deffalse = ["objects", "scenarios", "selectLockedCells", "selectUnlockedCells"];
  var sheetprot_deftrue = [
    "formatColumns",
    "formatRows",
    "formatCells",
    "insertColumns",
    "insertRows",
    "insertHyperlinks",
    "deleteColumns",
    "deleteRows",
    "sort",
    "autoFilter",
    "pivotTables"
  ];
  function write_ws_xml_protection(sp) {
    var o = { sheet: 1 };
    sheetprot_deffalse.forEach(function(n) {
      if (sp[n] != null && sp[n]) o[n] = "1";
    });
    sheetprot_deftrue.forEach(function(n) {
      if (sp[n] != null && !sp[n]) o[n] = "0";
    });
    if (sp.password) o.password = crypto_CreatePasswordVerifier_Method1(sp.password).toString(16).toUpperCase();
    return writextag("sheetProtection", null, o);
  }
  function parse_ws_xml_hlinks(s, data, rels) {
    var dense = s["!data"] != null;
    for (var i = 0; i != data.length; ++i) {
      var val2 = parsexmltag(utf8read(data[i]), true);
      if (!val2.ref) return;
      var rel = ((rels || {})["!id"] || [])[val2.id];
      if (rel) {
        val2.Target = rel.Target;
        if (val2.location) val2.Target += "#" + unescapexml(val2.location);
      } else {
        val2.Target = "#" + unescapexml(val2.location);
        rel = { Target: val2.Target, TargetMode: "Internal" };
      }
      val2.Rel = rel;
      if (val2.tooltip) {
        val2.Tooltip = val2.tooltip;
        delete val2.tooltip;
      }
      var rng = safe_decode_range(val2.ref);
      for (var R = rng.s.r; R <= rng.e.r; ++R) for (var C = rng.s.c; C <= rng.e.c; ++C) {
        var addr = encode_col(C) + encode_row(R);
        if (dense) {
          if (!s["!data"][R]) s["!data"][R] = [];
          if (!s["!data"][R][C]) s["!data"][R][C] = { t: "z", v: void 0 };
          s["!data"][R][C].l = val2;
        } else {
          if (!s[addr]) s[addr] = { t: "z", v: void 0 };
          s[addr].l = val2;
        }
      }
    }
  }
  function parse_ws_xml_margins(margin) {
    var o = {};
    ["left", "right", "top", "bottom", "header", "footer"].forEach(function(k) {
      if (margin[k]) o[k] = parseFloat(margin[k]);
    });
    return o;
  }
  function write_ws_xml_margins(margin) {
    default_margins(margin);
    return writextag("pageMargins", null, margin);
  }
  function parse_ws_xml_cols(columns, cols) {
    var seencol = false;
    for (var coli = 0; coli != cols.length; ++coli) {
      var coll = parsexmltag(cols[coli], true);
      if (coll.hidden) coll.hidden = parsexmlbool(coll.hidden);
      var colm = parseInt(coll.min, 10) - 1, colM = parseInt(coll.max, 10) - 1;
      if (coll.outlineLevel) coll.level = +coll.outlineLevel || 0;
      delete coll.min;
      delete coll.max;
      coll.width = +coll.width;
      if (!seencol && coll.width) {
        seencol = true;
        find_mdw_colw(coll.width);
      }
      process_col(coll);
      while (colm <= colM) columns[colm++] = dup(coll);
    }
  }
  function write_ws_xml_cols(ws, cols) {
    var o = ["<cols>"], col;
    for (var i = 0; i != cols.length; ++i) {
      if (!(col = cols[i])) continue;
      o[o.length] = writextag("col", null, col_obj_w(i, col));
    }
    o[o.length] = "</cols>";
    return o.join("");
  }
  function parse_ws_xml_autofilter(data) {
    var o = { ref: (data.match(/ref="([^"]*)"/) || [])[1] };
    return o;
  }
  function write_ws_xml_autofilter(data, ws, wb, idx) {
    var ref2 = typeof data.ref == "string" ? data.ref : encode_range(data.ref);
    if (!wb.Workbook) wb.Workbook = { Sheets: [] };
    if (!wb.Workbook.Names) wb.Workbook.Names = [];
    var names = wb.Workbook.Names;
    var range = decode_range(ref2);
    if (range.s.r == range.e.r) {
      range.e.r = decode_range(ws["!ref"]).e.r;
      ref2 = encode_range(range);
    }
    for (var i = 0; i < names.length; ++i) {
      var name = names[i];
      if (name.Name != "_xlnm._FilterDatabase") continue;
      if (name.Sheet != idx) continue;
      name.Ref = formula_quote_sheet_name(wb.SheetNames[idx]) + "!" + fix_range(ref2);
      break;
    }
    if (i == names.length) names.push({ Name: "_xlnm._FilterDatabase", Sheet: idx, Ref: "'" + wb.SheetNames[idx] + "'!" + ref2 });
    return writextag("autoFilter", null, { ref: ref2 });
  }
  var sviewregex = /<(?:\w:)?sheetView(?:[^<>a-z][^<>]*)?\/?>/g;
  function parse_ws_xml_sheetviews(data, wb) {
    if (!wb.Views) wb.Views = [{}];
    (data.match(sviewregex) || []).forEach(function(r2, i) {
      var tag = parsexmltag(r2);
      if (!wb.Views[i]) wb.Views[i] = {};
      if (+tag.zoomScale) wb.Views[i].zoom = +tag.zoomScale;
      if (tag.rightToLeft && parsexmlbool(tag.rightToLeft)) wb.Views[i].RTL = true;
    });
  }
  function write_ws_xml_sheetviews(ws, opts, idx, wb) {
    var sview = { workbookViewId: "0" };
    if ((((wb || {}).Workbook || {}).Views || [])[0]) sview.rightToLeft = wb.Workbook.Views[0].RTL ? "1" : "0";
    return writextag("sheetViews", writextag("sheetView", null, sview), {});
  }
  function write_ws_xml_cell(cell, ref2, ws, opts, idx, wb, date1904) {
    if (cell.c) ws["!comments"].push([ref2, cell.c]);
    if ((cell.v === void 0 || cell.t === "z" && !(opts || {}).sheetStubs) && typeof cell.f !== "string" && typeof cell.z == "undefined") return "";
    var vv = "";
    var oldt = cell.t, oldv = cell.v;
    if (cell.t !== "z") switch (cell.t) {
      case "b":
        vv = cell.v ? "1" : "0";
        break;
      case "n":
        if (isNaN(cell.v)) {
          cell.t = "e";
          vv = BErr[cell.v = 36];
        } else if (!isFinite(cell.v)) {
          cell.t = "e";
          vv = BErr[cell.v = 7];
        } else vv = "" + cell.v;
        break;
      case "e":
        vv = BErr[cell.v];
        break;
      case "d":
        if (opts && opts.cellDates) {
          var _vv = parseDate(cell.v, date1904);
          vv = _vv.toISOString();
          if (_vv.getUTCFullYear() < 1900) vv = vv.slice(vv.indexOf("T") + 1).replace("Z", "");
        } else {
          cell = dup(cell);
          cell.t = "n";
          vv = "" + (cell.v = datenum(parseDate(cell.v, date1904), date1904));
        }
        if (typeof cell.z === "undefined") cell.z = table_fmt[14];
        break;
      default:
        vv = cell.v;
        break;
    }
    var v = cell.t == "z" || cell.v == null ? "" : writetag("v", escapexml(vv)), o = { r: ref2 };
    var os = get_cell_style(opts.cellXfs, cell, opts);
    if (os !== 0) o.s = os;
    switch (cell.t) {
      case "n":
        break;
      case "d":
        o.t = "d";
        break;
      case "b":
        o.t = "b";
        break;
      case "e":
        o.t = "e";
        break;
      case "z":
        break;
      default:
        if (cell.v == null) {
          delete cell.t;
          break;
        }
        if (cell.v.length > 32767) throw new Error("Text length must not exceed 32767 characters");
        if (opts && opts.bookSST) {
          v = writetag("v", "" + get_sst_id(opts.Strings, cell.v, opts.revStrings));
          o.t = "s";
          break;
        } else o.t = "str";
        break;
    }
    if (cell.t != oldt) {
      cell.t = oldt;
      cell.v = oldv;
    }
    if (typeof cell.f == "string" && cell.f) {
      var ff = cell.F && cell.F.slice(0, ref2.length) == ref2 ? { t: "array", ref: cell.F } : null;
      v = writextag("f", escapexml(cell.f), ff) + (cell.v != null ? v : "");
    }
    if (cell.l) {
      cell.l.display = escapexml(vv);
      ws["!links"].push([ref2, cell.l]);
    }
    if (cell.D) o.cm = 1;
    return writextag("c", v, o);
  }
  var parse_ws_xml_data = (function() {
    var cellregex = /<(?:\w+:)?c[ \/>]/, rowregex = /<\/(?:\w+:)?row>/;
    var rregex = /r=["']([^"']*)["']/;
    var refregex = /ref=["']([^"']*)["']/;
    return function parse_ws_xml_data2(sdata, s, opts, guess, themes, styles, wb) {
      var ri = 0, x = "", cells = [], cref = [], idx = 0, i = 0, cc = 0, d = "", p2;
      var tag, tagr = 0, tagc = 0;
      var sstr, ftag;
      var fmtid = 0, fillid = 0;
      var do_format = Array.isArray(styles.CellXf), cf;
      var arrayf = [];
      var sharedf = [];
      var dense = s["!data"] != null;
      var rows = [], rowobj = {}, rowrite = false;
      var sheetStubs = !!opts.sheetStubs;
      var date1904 = !!((wb || {}).WBProps || {}).date1904;
      for (var marr = sdata.split(rowregex), mt = 0, marrlen = marr.length; mt != marrlen; ++mt) {
        x = marr[mt].trim();
        var xlen = x.length;
        if (xlen === 0) continue;
        var rstarti = 0;
        outa: for (ri = 0; ri < xlen; ++ri) switch (
x[ri]
        ) {
          case ">":
            if (
x[ri - 1] != "/"
            ) {
              ++ri;
              break outa;
            }
            if (opts && opts.cellStyles) {
              tag = parsexmltag(x.slice(rstarti, ri), true);
              tagr = tag.r != null ? parseInt(tag.r, 10) : tagr + 1;
              tagc = -1;
              if (opts.sheetRows && opts.sheetRows < tagr) continue;
              rowobj = {};
              rowrite = false;
              if (tag.ht) {
                rowrite = true;
                rowobj.hpt = parseFloat(tag.ht);
                rowobj.hpx = pt2px(rowobj.hpt);
              }
              if (tag.hidden && parsexmlbool(tag.hidden)) {
                rowrite = true;
                rowobj.hidden = true;
              }
              if (tag.outlineLevel != null) {
                rowrite = true;
                rowobj.level = +tag.outlineLevel;
              }
              if (rowrite) rows[tagr - 1] = rowobj;
            }
            break;
          case "<":
            rstarti = ri;
            break;
        }
        if (rstarti >= ri) break;
        tag = parsexmltag(x.slice(rstarti, ri), true);
        tagr = tag.r != null ? parseInt(tag.r, 10) : tagr + 1;
        tagc = -1;
        if (opts.sheetRows && opts.sheetRows < tagr) continue;
        if (!opts.nodim) {
          if (guess.s.r > tagr - 1) guess.s.r = tagr - 1;
          if (guess.e.r < tagr - 1) guess.e.r = tagr - 1;
        }
        if (opts && opts.cellStyles) {
          rowobj = {};
          rowrite = false;
          if (tag.ht) {
            rowrite = true;
            rowobj.hpt = parseFloat(tag.ht);
            rowobj.hpx = pt2px(rowobj.hpt);
          }
          if (tag.hidden && parsexmlbool(tag.hidden)) {
            rowrite = true;
            rowobj.hidden = true;
          }
          if (tag.outlineLevel != null) {
            rowrite = true;
            rowobj.level = +tag.outlineLevel;
          }
          if (rowrite) rows[tagr - 1] = rowobj;
        }
        cells = x.slice(ri).split(cellregex);
        for (var rslice = 0; rslice != cells.length; ++rslice) if (cells[rslice].trim().charAt(0) != "<") break;
        cells = cells.slice(rslice);
        for (ri = 0; ri != cells.length; ++ri) {
          x = cells[ri].trim();
          if (x.length === 0) continue;
          cref = x.match(rregex);
          idx = ri;
          i = 0;
          cc = 0;
          x = "<c " + (x.slice(0, 1) == "<" ? ">" : "") + x;
          if (cref != null && cref.length === 2) {
            idx = 0;
            d = cref[1];
            for (i = 0; i != d.length; ++i) {
              if ((cc = d.charCodeAt(i) - 64) < 1 || cc > 26) break;
              idx = 26 * idx + cc;
            }
            --idx;
            tagc = idx;
          } else ++tagc;
          for (i = 0; i != x.length; ++i) if (x.charCodeAt(i) === 62) break;
          ++i;
          tag = parsexmltag(x.slice(0, i), true);
          if (!tag.r) tag.r = encode_cell({ r: tagr - 1, c: tagc });
          d = x.slice(i);
          p2 = { t: "" };
          if ((cref = str_match_xml_ns(d, "v")) != null &&
cref[1] !== "") p2.v = unescapexml(cref[1]);
          if (opts.cellFormula) {
            if ((cref = str_match_xml_ns(d, "f")) != null) {
              if (cref[1] == "") {
                if (
cref[0].indexOf('t="shared"') > -1
                ) {
                  ftag = parsexmltag(cref[0]);
                  if (sharedf[ftag.si]) p2.f = shift_formula_xlsx(sharedf[ftag.si][1], sharedf[ftag.si][2], tag.r);
                }
              } else {
                p2.f = unescapexml(utf8read(cref[1]), true);
                if (!opts.xlfn) p2.f = _xlfn(p2.f);
                if (
cref[0].indexOf('t="array"') > -1
                ) {
                  p2.F = (d.match(refregex) || [])[1];
                  if (p2.F.indexOf(":") > -1) arrayf.push([safe_decode_range(p2.F), p2.F]);
                } else if (
cref[0].indexOf('t="shared"') > -1
                ) {
                  ftag = parsexmltag(cref[0]);
                  var ___f = unescapexml(utf8read(cref[1]));
                  if (!opts.xlfn) ___f = _xlfn(___f);
                  sharedf[parseInt(ftag.si, 10)] = [ftag, ___f, tag.r];
                }
              }
            } else if (cref = d.match(/<f[^<>]*\/>/)) {
              ftag = parsexmltag(cref[0]);
              if (sharedf[ftag.si]) p2.f = shift_formula_xlsx(sharedf[ftag.si][1], sharedf[ftag.si][2], tag.r);
            }
            var _tag = decode_cell(tag.r);
            for (i = 0; i < arrayf.length; ++i)
              if (_tag.r >= arrayf[i][0].s.r && _tag.r <= arrayf[i][0].e.r) {
                if (_tag.c >= arrayf[i][0].s.c && _tag.c <= arrayf[i][0].e.c)
                  p2.F = arrayf[i][1];
              }
          }
          if (tag.t == null && p2.v === void 0) {
            if (p2.f || p2.F) {
              p2.v = 0;
              p2.t = "n";
            } else if (!sheetStubs) continue;
            else p2.t = "z";
          } else p2.t = tag.t || "n";
          if (guess.s.c > tagc) guess.s.c = tagc;
          if (guess.e.c < tagc) guess.e.c = tagc;
          switch (p2.t) {
            case "n":
              if (p2.v == "" || p2.v == null) {
                if (!sheetStubs) continue;
                p2.t = "z";
              } else p2.v = parseFloat(p2.v);
              break;
            case "s":
              if (typeof p2.v == "undefined") {
                if (!sheetStubs) continue;
                p2.t = "z";
              } else {
                sstr = strs[parseInt(p2.v, 10)];
                p2.v = sstr.t;
                p2.r = sstr.r;
                if (opts.cellHTML) p2.h = sstr.h;
              }
              break;
            case "str":
              p2.t = "s";
              p2.v = p2.v != null ? unescapexml(utf8read(p2.v), true) : "";
              if (opts.cellHTML) p2.h = escapehtml(p2.v);
              break;
            case "inlineStr":
              cref = str_match_xml_ns(d, "is");
              p2.t = "s";
              if (cref != null && (sstr = parse_si(cref[1]))) {
                p2.v = sstr.t;
                if (opts.cellHTML) p2.h = sstr.h;
              } else p2.v = "";
              break;
            case "b":
              p2.v = parsexmlbool(p2.v);
              break;
            case "d":
              if (opts.cellDates) p2.v = parseDate(p2.v, date1904);
              else {
                p2.v = datenum(parseDate(p2.v, date1904), date1904);
                p2.t = "n";
              }
              break;
case "e":
              if (!opts || opts.cellText !== false) p2.w = p2.v;
              p2.v = RBErr[p2.v];
              break;
          }
          fmtid = fillid = 0;
          cf = null;
          if (do_format && tag.s !== void 0) {
            cf = styles.CellXf[tag.s];
            if (cf != null) {
              if (cf.numFmtId != null) fmtid = cf.numFmtId;
              if (opts.cellStyles) {
                if (cf.fillId != null) fillid = cf.fillId;
              }
            }
          }
          safe_format(p2, fmtid, fillid, opts, themes, styles, date1904);
          if (opts.cellDates && do_format && p2.t == "n" && fmt_is_date(table_fmt[fmtid])) {
            p2.v = numdate(p2.v + (date1904 ? 1462 : 0));
            p2.t = typeof p2.v == "number" ? "n" : "d";
          }
          if (tag.cm && opts.xlmeta) {
            var cm = (opts.xlmeta.Cell || [])[+tag.cm - 1];
            if (cm && cm.type == "XLDAPR") p2.D = true;
          }
          var _r;
          if (opts.nodim) {
            _r = decode_cell(tag.r);
            if (guess.s.r > _r.r) guess.s.r = _r.r;
            if (guess.e.r < _r.r) guess.e.r = _r.r;
          }
          if (dense) {
            _r = decode_cell(tag.r);
            if (!s["!data"][_r.r]) s["!data"][_r.r] = [];
            s["!data"][_r.r][_r.c] = p2;
          } else s[tag.r] = p2;
        }
      }
      if (rows.length > 0) s["!rows"] = rows;
    };
  })();
  function write_ws_xml_data(ws, opts, idx, wb) {
    var o = [], r2 = [], range = safe_decode_range(ws["!ref"]), cell = "", ref2, rr = "", cols = [], R = 0, C = 0, rows = ws["!rows"];
    var dense = ws["!data"] != null, data = dense ? ws["!data"] : [];
    var params = { r: rr }, row, height = -1;
    var date1904 = (((wb || {}).Workbook || {}).WBProps || {}).date1904;
    for (C = range.s.c; C <= range.e.c; ++C) cols[C] = encode_col(C);
    for (R = range.s.r; R <= range.e.r; ++R) {
      r2 = [];
      rr = encode_row(R);
      var data_R = dense ? data[R] : [];
      for (C = range.s.c; C <= range.e.c; ++C) {
        ref2 = cols[C] + rr;
        var _cell = dense ? data_R[C] : ws[ref2];
        if (_cell === void 0) continue;
        if ((cell = write_ws_xml_cell(_cell, ref2, ws, opts, idx, wb, date1904)) != null) r2.push(cell);
      }
      if (r2.length > 0 || rows && rows[R]) {
        params = { r: rr };
        if (rows && rows[R]) {
          row = rows[R];
          if (row.hidden) params.hidden = 1;
          height = -1;
          if (row.hpx) height = px2pt(row.hpx);
          else if (row.hpt) height = row.hpt;
          if (height > -1) {
            params.ht = height;
            params.customHeight = 1;
          }
          if (row.level) {
            params.outlineLevel = row.level;
          }
        }
        o[o.length] = writextag("row", r2.join(""), params);
      }
    }
    if (rows) for (; R < rows.length; ++R) {
      if (rows && rows[R]) {
        params = { r: R + 1 };
        row = rows[R];
        if (row.hidden) params.hidden = 1;
        height = -1;
        if (row.hpx) height = px2pt(row.hpx);
        else if (row.hpt) height = row.hpt;
        if (height > -1) {
          params.ht = height;
          params.customHeight = 1;
        }
        if (row.level) {
          params.outlineLevel = row.level;
        }
        o[o.length] = writextag("row", "", params);
      }
    }
    return o.join("");
  }
  function write_ws_xml(idx, opts, wb, rels) {
    var o = [XML_HEADER, writextag("worksheet", null, {
      "xmlns": XMLNS_main[0],
      "xmlns:r": XMLNS.r
    })];
    var s = wb.SheetNames[idx], sidx = 0, rdata = "";
    var ws = wb.Sheets[s];
    if (ws == null) ws = {};
    var ref2 = ws["!ref"] || "A1";
    var range = safe_decode_range(ref2);
    if (range.e.c > 16383 || range.e.r > 1048575) {
      if (opts.WTF) throw new Error("Range " + ref2 + " exceeds format limit A1:XFD1048576");
      range.e.c = Math.min(range.e.c, 16383);
      range.e.r = Math.min(range.e.c, 1048575);
      ref2 = encode_range(range);
    }
    if (!rels) rels = {};
    ws["!comments"] = [];
    var _drawing = [];
    write_ws_xml_sheetpr(ws, wb, idx, opts, o);
    o[o.length] = writextag("dimension", null, { "ref": ref2 });
    o[o.length] = write_ws_xml_sheetviews(ws, opts, idx, wb);
    if (opts.sheetFormat) o[o.length] = writextag("sheetFormatPr", null, {
      defaultRowHeight: opts.sheetFormat.defaultRowHeight || "16",
      baseColWidth: opts.sheetFormat.baseColWidth || "10",
      outlineLevelRow: opts.sheetFormat.outlineLevelRow || "7"
    });
    if (ws["!cols"] != null && ws["!cols"].length > 0) o[o.length] = write_ws_xml_cols(ws, ws["!cols"]);
    o[sidx = o.length] = "<sheetData/>";
    ws["!links"] = [];
    if (ws["!ref"] != null) {
      rdata = write_ws_xml_data(ws, opts, idx, wb);
      if (rdata.length > 0) o[o.length] = rdata;
    }
    if (o.length > sidx + 1) {
      o[o.length] = "</sheetData>";
      o[sidx] = o[sidx].replace("/>", ">");
    }
    if (ws["!protect"]) o[o.length] = write_ws_xml_protection(ws["!protect"]);
    if (ws["!autofilter"] != null) o[o.length] = write_ws_xml_autofilter(ws["!autofilter"], ws, wb, idx);
    if (ws["!merges"] != null && ws["!merges"].length > 0) o[o.length] = write_ws_xml_merges(ws["!merges"]);
    var relc = -1, rel, rId = -1;
    if (
ws["!links"].length > 0
    ) {
      o[o.length] = "<hyperlinks>";
      ws["!links"].forEach(function(l) {
        if (!l[1].Target) return;
        rel = { "ref": l[0] };
        if (l[1].Target.charAt(0) != "#") {
          rId = add_rels(rels, -1, escapexml(l[1].Target).replace(/#[\s\S]*$/, ""), RELS.HLINK);
          rel["r:id"] = "rId" + rId;
        }
        if ((relc = l[1].Target.indexOf("#")) > -1) rel.location = escapexml(l[1].Target.slice(relc + 1));
        if (l[1].Tooltip) rel.tooltip = escapexml(l[1].Tooltip);
        rel.display = l[1].display;
        o[o.length] = writextag("hyperlink", null, rel);
      });
      o[o.length] = "</hyperlinks>";
    }
    delete ws["!links"];
    if (ws["!margins"] != null) o[o.length] = write_ws_xml_margins(ws["!margins"]);
    if (!opts || opts.ignoreEC || opts.ignoreEC == void 0) o[o.length] = writetag("ignoredErrors", writextag("ignoredError", null, { numberStoredAsText: 1, sqref: ref2 }));
    if (_drawing.length > 0) {
      rId = add_rels(rels, -1, "../drawings/drawing" + (idx + 1) + ".xml", RELS.DRAW);
      o[o.length] = writextag("drawing", null, { "r:id": "rId" + rId });
      ws["!drawing"] = _drawing;
    }
    if (ws["!comments"].length > 0) {
      rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx + 1) + ".vml", RELS.VML);
      o[o.length] = writextag("legacyDrawing", null, { "r:id": "rId" + rId });
      ws["!legacy"] = rId;
    }
    if (o.length > 1) {
      o[o.length] = "</worksheet>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  function parse_BrtRowHdr(data, length) {
    var z = {};
    var tgt = data.l + length;
    z.r = data.read_shift(4);
    data.l += 4;
    var miyRw = data.read_shift(2);
    data.l += 1;
    var flags = data.read_shift(1);
    data.l = tgt;
    if (flags & 7) z.level = flags & 7;
    if (flags & 16) z.hidden = true;
    if (flags & 32) z.hpt = miyRw / 20;
    return z;
  }
  function write_BrtRowHdr(R, range, ws) {
    var o = new_buf(17 + 8 * 16);
    var row = (ws["!rows"] || [])[R] || {};
    o.write_shift(4, R);
    o.write_shift(4, 0);
    var miyRw = 320;
    if (row.hpx) miyRw = px2pt(row.hpx) * 20;
    else if (row.hpt) miyRw = row.hpt * 20;
    o.write_shift(2, miyRw);
    o.write_shift(1, 0);
    var flags = 0;
    if (row.level) flags |= row.level;
    if (row.hidden) flags |= 16;
    if (row.hpx || row.hpt) flags |= 32;
    o.write_shift(1, flags);
    o.write_shift(1, 0);
    var ncolspan = 0, lcs = o.l;
    o.l += 4;
    var caddr = { r: R, c: 0 };
    var dense = ws["!data"] != null;
    for (var i = 0; i < 16; ++i) {
      if (range.s.c > i + 1 << 10 || range.e.c < i << 10) continue;
      var first = -1, last = -1;
      for (var j = i << 10; j < i + 1 << 10; ++j) {
        caddr.c = j;
        var cell = dense ? (ws["!data"][caddr.r] || [])[caddr.c] : ws[encode_cell(caddr)];
        if (cell) {
          if (first < 0) first = j;
          last = j;
        }
      }
      if (first < 0) continue;
      ++ncolspan;
      o.write_shift(4, first);
      o.write_shift(4, last);
    }
    var l = o.l;
    o.l = lcs;
    o.write_shift(4, ncolspan);
    o.l = l;
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function write_row_header(ba, ws, range, R) {
    var o = write_BrtRowHdr(R, range, ws);
    if (o.length > 17 || (ws["!rows"] || [])[R]) write_record(ba, 0, o);
  }
  var parse_BrtWsDim = parse_UncheckedRfX;
  var write_BrtWsDim = write_UncheckedRfX;
  function parse_BrtWsFmtInfo() {
  }
  function parse_BrtWsProp(data, length) {
    var z = {};
    var f = data[data.l];
    ++data.l;
    z.above = !(f & 64);
    z.left = !(f & 128);
    data.l += 18;
    z.name = parse_XLSBCodeName(data);
    return z;
  }
  function write_BrtWsProp(str, outl, o) {
    if (o == null) o = new_buf(84 + 4 * str.length);
    var f = 192;
    if (outl) {
      if (outl.above) f &= -65;
      if (outl.left) f &= -129;
    }
    o.write_shift(1, f);
    for (var i = 1; i < 3; ++i) o.write_shift(1, 0);
    write_BrtColor({ auto: 1 }, o);
    o.write_shift(-4, -1);
    o.write_shift(-4, -1);
    write_XLSBCodeName(str, o);
    return o.slice(0, o.l);
  }
  function parse_BrtCellBlank(data) {
    var cell = parse_XLSBCell(data);
    return [cell];
  }
  function write_BrtCellBlank(cell, ncell, o) {
    if (o == null) o = new_buf(8);
    return write_XLSBCell(ncell, o);
  }
  function parse_BrtShortBlank(data) {
    var cell = parse_XLSBShortCell(data);
    return [cell];
  }
  function write_BrtShortBlank(cell, ncell, o) {
    if (o == null) o = new_buf(4);
    return write_XLSBShortCell(ncell, o);
  }
  function parse_BrtCellBool(data) {
    var cell = parse_XLSBCell(data);
    var fBool = data.read_shift(1);
    return [cell, fBool, "b"];
  }
  function write_BrtCellBool(cell, ncell, o) {
    if (o == null) o = new_buf(9);
    write_XLSBCell(ncell, o);
    o.write_shift(1, cell.v ? 1 : 0);
    return o;
  }
  function parse_BrtShortBool(data) {
    var cell = parse_XLSBShortCell(data);
    var fBool = data.read_shift(1);
    return [cell, fBool, "b"];
  }
  function write_BrtShortBool(cell, ncell, o) {
    if (o == null) o = new_buf(5);
    write_XLSBShortCell(ncell, o);
    o.write_shift(1, cell.v ? 1 : 0);
    return o;
  }
  function parse_BrtCellError(data) {
    var cell = parse_XLSBCell(data);
    var bError = data.read_shift(1);
    return [cell, bError, "e"];
  }
  function write_BrtCellError(cell, ncell, o) {
    if (o == null) o = new_buf(9);
    write_XLSBCell(ncell, o);
    o.write_shift(1, cell.v);
    return o;
  }
  function parse_BrtShortError(data) {
    var cell = parse_XLSBShortCell(data);
    var bError = data.read_shift(1);
    return [cell, bError, "e"];
  }
  function write_BrtShortError(cell, ncell, o) {
    if (o == null) o = new_buf(8);
    write_XLSBShortCell(ncell, o);
    o.write_shift(1, cell.v);
    o.write_shift(2, 0);
    o.write_shift(1, 0);
    return o;
  }
  function parse_BrtCellIsst(data) {
    var cell = parse_XLSBCell(data);
    var isst = data.read_shift(4);
    return [cell, isst, "s"];
  }
  function write_BrtCellIsst(cell, ncell, o) {
    if (o == null) o = new_buf(12);
    write_XLSBCell(ncell, o);
    o.write_shift(4, ncell.v);
    return o;
  }
  function parse_BrtShortIsst(data) {
    var cell = parse_XLSBShortCell(data);
    var isst = data.read_shift(4);
    return [cell, isst, "s"];
  }
  function write_BrtShortIsst(cell, ncell, o) {
    if (o == null) o = new_buf(8);
    write_XLSBShortCell(ncell, o);
    o.write_shift(4, ncell.v);
    return o;
  }
  function parse_BrtCellReal(data) {
    var cell = parse_XLSBCell(data);
    var value = parse_Xnum(data);
    return [cell, value, "n"];
  }
  function write_BrtCellReal(cell, ncell, o) {
    if (o == null) o = new_buf(16);
    write_XLSBCell(ncell, o);
    write_Xnum(cell.v, o);
    return o;
  }
  function parse_BrtShortReal(data) {
    var cell = parse_XLSBShortCell(data);
    var value = parse_Xnum(data);
    return [cell, value, "n"];
  }
  function write_BrtShortReal(cell, ncell, o) {
    if (o == null) o = new_buf(12);
    write_XLSBShortCell(ncell, o);
    write_Xnum(cell.v, o);
    return o;
  }
  function parse_BrtCellRk(data) {
    var cell = parse_XLSBCell(data);
    var value = parse_RkNumber(data);
    return [cell, value, "n"];
  }
  function write_BrtCellRk(cell, ncell, o) {
    if (o == null) o = new_buf(12);
    write_XLSBCell(ncell, o);
    write_RkNumber(cell.v, o);
    return o;
  }
  function parse_BrtShortRk(data) {
    var cell = parse_XLSBShortCell(data);
    var value = parse_RkNumber(data);
    return [cell, value, "n"];
  }
  function write_BrtShortRk(cell, ncell, o) {
    if (o == null) o = new_buf(8);
    write_XLSBShortCell(ncell, o);
    write_RkNumber(cell.v, o);
    return o;
  }
  function parse_BrtCellRString(data) {
    var cell = parse_XLSBCell(data);
    var value = parse_RichStr(data);
    return [cell, value, "is"];
  }
  function parse_BrtCellSt(data) {
    var cell = parse_XLSBCell(data);
    var value = parse_XLWideString(data);
    return [cell, value, "str"];
  }
  function write_BrtCellSt(cell, ncell, o) {
    var data = cell.v == null ? "" : String(cell.v);
    if (o == null) o = new_buf(12 + 4 * cell.v.length);
    write_XLSBCell(ncell, o);
    write_XLWideString(data, o);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function parse_BrtShortSt(data) {
    var cell = parse_XLSBShortCell(data);
    var value = parse_XLWideString(data);
    return [cell, value, "str"];
  }
  function write_BrtShortSt(cell, ncell, o) {
    var data = cell.v == null ? "" : String(cell.v);
    if (o == null) o = new_buf(8 + 4 * data.length);
    write_XLSBShortCell(ncell, o);
    write_XLWideString(data, o);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function parse_BrtFmlaBool(data, length, opts) {
    var end = data.l + length;
    var cell = parse_XLSBCell(data);
    cell.r = opts["!row"];
    var value = data.read_shift(1);
    var o = [cell, value, "b"];
    if (opts.cellFormula) {
      data.l += 2;
      var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
      o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
    } else data.l = end;
    return o;
  }
  function parse_BrtFmlaError(data, length, opts) {
    var end = data.l + length;
    var cell = parse_XLSBCell(data);
    cell.r = opts["!row"];
    var value = data.read_shift(1);
    var o = [cell, value, "e"];
    if (opts.cellFormula) {
      data.l += 2;
      var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
      o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
    } else data.l = end;
    return o;
  }
  function parse_BrtFmlaNum(data, length, opts) {
    var end = data.l + length;
    var cell = parse_XLSBCell(data);
    cell.r = opts["!row"];
    var value = parse_Xnum(data);
    var o = [cell, value, "n"];
    if (opts.cellFormula) {
      data.l += 2;
      var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
      o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
    } else data.l = end;
    return o;
  }
  function parse_BrtFmlaString(data, length, opts) {
    var end = data.l + length;
    var cell = parse_XLSBCell(data);
    cell.r = opts["!row"];
    var value = parse_XLWideString(data);
    var o = [cell, value, "str"];
    if (opts.cellFormula) {
      data.l += 2;
      var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
      o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
    } else data.l = end;
    return o;
  }
  var parse_BrtMergeCell = parse_UncheckedRfX;
  var write_BrtMergeCell = write_UncheckedRfX;
  function write_BrtBeginMergeCells(cnt, o) {
    if (o == null) o = new_buf(4);
    o.write_shift(4, cnt);
    return o;
  }
  function parse_BrtHLink(data, length) {
    var end = data.l + length;
    var rfx = parse_UncheckedRfX(data);
    var relId = parse_XLNullableWideString(data);
    var loc = parse_XLWideString(data);
    var tooltip = parse_XLWideString(data);
    var display = parse_XLWideString(data);
    data.l = end;
    var o = { rfx, relId, loc, display };
    if (tooltip) o.Tooltip = tooltip;
    return o;
  }
  function write_BrtHLink(l, rId) {
    var o = new_buf(50 + 4 * (l[1].Target.length + (l[1].Tooltip || "").length));
    write_UncheckedRfX({ s: decode_cell(l[0]), e: decode_cell(l[0]) }, o);
    write_RelID("rId" + rId, o);
    var locidx = l[1].Target.indexOf("#");
    var loc = locidx == -1 ? "" : l[1].Target.slice(locidx + 1);
    write_XLWideString(loc || "", o);
    write_XLWideString(l[1].Tooltip || "", o);
    write_XLWideString("", o);
    return o.slice(0, o.l);
  }
  function parse_BrtPane() {
  }
  function parse_BrtArrFmla(data, length, opts) {
    var end = data.l + length;
    var rfx = parse_RfX(data);
    var fAlwaysCalc = data.read_shift(1);
    var o = [rfx];
    o[2] = fAlwaysCalc;
    if (opts.cellFormula) {
      var formula = parse_XLSBArrayParsedFormula(data, end - data.l, opts);
      o[1] = formula;
    } else data.l = end;
    return o;
  }
  function parse_BrtShrFmla(data, length, opts) {
    var end = data.l + length;
    var rfx = parse_UncheckedRfX(data);
    var o = [rfx];
    if (opts.cellFormula) {
      var formula = parse_XLSBSharedParsedFormula(data, end - data.l, opts);
      o[1] = formula;
      data.l = end;
    } else data.l = end;
    return o;
  }
  function write_BrtColInfo(C, col, o) {
    if (o == null) o = new_buf(18);
    var p2 = col_obj_w(C, col);
    o.write_shift(-4, C);
    o.write_shift(-4, C);
    o.write_shift(4, (p2.width || 10) * 256);
    o.write_shift(
      4,
      0
);
    var flags = 0;
    if (col.hidden) flags |= 1;
    if (typeof p2.width == "number") flags |= 2;
    if (col.level) flags |= col.level << 8;
    o.write_shift(2, flags);
    return o;
  }
  var BrtMarginKeys = ["left", "right", "top", "bottom", "header", "footer"];
  function parse_BrtMargins(data) {
    var margins = {};
    BrtMarginKeys.forEach(function(k) {
      margins[k] = parse_Xnum(data);
    });
    return margins;
  }
  function write_BrtMargins(margins, o) {
    if (o == null) o = new_buf(6 * 8);
    default_margins(margins);
    BrtMarginKeys.forEach(function(k) {
      write_Xnum(margins[k], o);
    });
    return o;
  }
  function parse_BrtBeginWsView(data) {
    var f = data.read_shift(2);
    data.l += 28;
    return { RTL: f & 32 };
  }
  function write_BrtBeginWsView(ws, Workbook, o) {
    if (o == null) o = new_buf(30);
    var f = 924;
    if ((((Workbook || {}).Views || [])[0] || {}).RTL) f |= 32;
    o.write_shift(2, f);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    o.write_shift(1, 0);
    o.write_shift(1, 0);
    o.write_shift(2, 0);
    o.write_shift(2, 100);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    o.write_shift(4, 0);
    return o;
  }
  function write_BrtCellIgnoreEC(ref2) {
    var o = new_buf(24);
    o.write_shift(4, 4);
    o.write_shift(4, 1);
    write_UncheckedRfX(ref2, o);
    return o;
  }
  function write_BrtSheetProtection(sp, o) {
    if (o == null) o = new_buf(16 * 4 + 2);
    o.write_shift(2, sp.password ? crypto_CreatePasswordVerifier_Method1(sp.password) : 0);
    o.write_shift(4, 1);
    [
      ["objects", false],
["scenarios", false],
["formatCells", true],
["formatColumns", true],
["formatRows", true],
["insertColumns", true],
["insertRows", true],
["insertHyperlinks", true],
["deleteColumns", true],
["deleteRows", true],
["selectLockedCells", false],
["sort", true],
["autoFilter", true],
["pivotTables", true],
["selectUnlockedCells", false]
].forEach(function(n) {
      if (n[1]) o.write_shift(4, sp[n[0]] != null && !sp[n[0]] ? 1 : 0);
      else o.write_shift(4, sp[n[0]] != null && sp[n[0]] ? 0 : 1);
    });
    return o;
  }
  function parse_BrtDVal() {
  }
  function parse_BrtDVal14() {
  }
  function parse_ws_bin(data, _opts, idx, rels, wb, themes, styles) {
    if (!data) return data;
    var opts = _opts || {};
    if (!rels) rels = { "!id": {} };
    var s = {};
    if (opts.dense) s["!data"] = [];
    var ref2;
    var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
    var pass = false, end = false;
    var row, p2, cf, R, C, addr, sstr, rr, cell;
    var merges = [];
    opts.biff = 12;
    opts["!row"] = 0;
    var ai = 0, af = false;
    var arrayf = [];
    var sharedf = {};
    var supbooks = opts.supbooks ||
wb.supbooks || [[]];
    supbooks.sharedf = sharedf;
    supbooks.arrayf = arrayf;
    supbooks.SheetNames = wb.SheetNames || wb.Sheets.map(function(x) {
      return x.name;
    });
    if (!opts.supbooks) {
      opts.supbooks = supbooks;
      if (wb.Names) for (var i = 0; i < wb.Names.length; ++i) supbooks[0][i + 1] = wb.Names[i];
    }
    var colinfo = [], rowinfo = [];
    var seencol = false;
    XLSBRecordEnum[16] = { n: "BrtShortReal", f: parse_BrtShortReal };
    var cm;
    var date1904 = 1462 * +!!((wb || {}).WBProps || {}).date1904;
    recordhopper(data, function ws_parse(val2, RR, RT) {
      if (end) return;
      switch (RT) {
        case 148:
          ref2 = val2;
          break;
        case 0:
          row = val2;
          if (opts.sheetRows && opts.sheetRows <= row.r) end = true;
          rr = encode_row(R = row.r);
          opts["!row"] = row.r;
          if (val2.hidden || val2.hpt || val2.level != null) {
            if (val2.hpt) val2.hpx = pt2px(val2.hpt);
            rowinfo[val2.r] = val2;
          }
          break;
        case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 13:
case 14:
case 15:
case 16:
case 17:
case 18:
case 62:
          p2 = { t: val2[2] };
          switch (val2[2]) {
            case "n":
              p2.v = val2[1];
              break;
            case "s":
              sstr = strs[val2[1]];
              p2.v = sstr.t;
              p2.r = sstr.r;
              break;
            case "b":
              p2.v = val2[1] ? true : false;
              break;
            case "e":
              p2.v = val2[1];
              if (opts.cellText !== false) p2.w = BErr[p2.v];
              break;
            case "str":
              p2.t = "s";
              p2.v = val2[1];
              break;
            case "is":
              p2.t = "s";
              p2.v = val2[1].t;
              break;
          }
          if (cf = styles.CellXf[val2[0].iStyleRef]) safe_format(p2, cf.numFmtId, null, opts, themes, styles, date1904 > 0);
          C = val2[0].c == -1 ? C + 1 : val2[0].c;
          if (opts.dense) {
            if (!s["!data"][R]) s["!data"][R] = [];
            s["!data"][R][C] = p2;
          } else s[encode_col(C) + rr] = p2;
          if (opts.cellFormula) {
            af = false;
            for (ai = 0; ai < arrayf.length; ++ai) {
              var aii = arrayf[ai];
              if (row.r >= aii[0].s.r && row.r <= aii[0].e.r) {
                if (C >= aii[0].s.c && C <= aii[0].e.c) {
                  p2.F = encode_range(aii[0]);
                  af = true;
                }
              }
            }
            if (!af && val2.length > 3) p2.f = val2[3];
          }
          if (refguess.s.r > row.r) refguess.s.r = row.r;
          if (refguess.s.c > C) refguess.s.c = C;
          if (refguess.e.r < row.r) refguess.e.r = row.r;
          if (refguess.e.c < C) refguess.e.c = C;
          if (opts.cellDates && cf && p2.t == "n" && fmt_is_date(table_fmt[cf.numFmtId])) {
            var _d = SSF_parse_date_code(p2.v + date1904);
            if (_d) {
              p2.t = "d";
              p2.v = new Date(Date.UTC(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u));
            }
          }
          if (cm) {
            if (cm.type == "XLDAPR") p2.D = true;
            cm = void 0;
          }
          break;
        case 1:
case 12:
          if (!opts.sheetStubs || pass) break;
          p2 = { t: "z", v: void 0 };
          C = val2[0].c == -1 ? C + 1 : val2[0].c;
          if (opts.dense) {
            if (!s["!data"][R]) s["!data"][R] = [];
            s["!data"][R][C] = p2;
          } else s[encode_col(C) + rr] = p2;
          if (refguess.s.r > row.r) refguess.s.r = row.r;
          if (refguess.s.c > C) refguess.s.c = C;
          if (refguess.e.r < row.r) refguess.e.r = row.r;
          if (refguess.e.c < C) refguess.e.c = C;
          if (cm) {
            if (cm.type == "XLDAPR") p2.D = true;
            cm = void 0;
          }
          break;
        case 176:
          merges.push(val2);
          break;
        case 49:
          {
            cm = ((opts.xlmeta || {}).Cell || [])[val2 - 1];
          }
          break;
        case 494:
          var rel = rels["!id"][val2.relId];
          if (rel) {
            val2.Target = rel.Target;
            if (val2.loc) val2.Target += "#" + val2.loc;
            val2.Rel = rel;
          } else if (val2.relId == "") {
            val2.Target = "#" + val2.loc;
          }
          for (R = val2.rfx.s.r; R <= val2.rfx.e.r; ++R) for (C = val2.rfx.s.c; C <= val2.rfx.e.c; ++C) {
            if (opts.dense) {
              if (!s["!data"][R]) s["!data"][R] = [];
              if (!s["!data"][R][C]) s["!data"][R][C] = { t: "z", v: void 0 };
              s["!data"][R][C].l = val2;
            } else {
              addr = encode_col(C) + encode_row(R);
              if (!s[addr]) s[addr] = { t: "z", v: void 0 };
              s[addr].l = val2;
            }
          }
          break;
        case 426:
          if (!opts.cellFormula) break;
          arrayf.push(val2);
          cell = opts.dense ? s["!data"][R][C] : s[encode_col(C) + rr];
          cell.f = stringify_formula(val2[1], refguess, { r: row.r, c: C }, supbooks, opts);
          cell.F = encode_range(val2[0]);
          break;
        case 427:
          if (!opts.cellFormula) break;
          sharedf[encode_cell(val2[0].s)] = val2[1];
          cell = opts.dense ? s["!data"][R][C] : s[encode_col(C) + rr];
          cell.f = stringify_formula(val2[1], refguess, { r: row.r, c: C }, supbooks, opts);
          break;
case 60:
          if (!opts.cellStyles) break;
          while (val2.e >= val2.s) {
            colinfo[val2.e--] = { width: val2.w / 256, hidden: !!(val2.flags & 1), level: val2.level };
            if (!seencol) {
              seencol = true;
              find_mdw_colw(val2.w / 256);
            }
            process_col(colinfo[val2.e + 1]);
          }
          break;
        case 551:
          if (val2) s["!legrel"] = val2;
          break;
        case 161:
          s["!autofilter"] = { ref: encode_range(val2) };
          break;
        case 476:
          s["!margins"] = val2;
          break;
        case 147:
          if (!wb.Sheets[idx]) wb.Sheets[idx] = {};
          if (val2.name) wb.Sheets[idx].CodeName = val2.name;
          if (val2.above || val2.left) s["!outline"] = { above: val2.above, left: val2.left };
          break;
        case 137:
          if (!wb.Views) wb.Views = [{}];
          if (!wb.Views[0]) wb.Views[0] = {};
          if (val2.RTL) wb.Views[0].RTL = true;
          break;
        case 485:
          break;
        case 64:
case 1053:
          break;
        case 151:
          break;
        case 152:
case 175:
case 644:
case 625:
case 562:
case 396:
case 1112:
case 1146:
case 471:
case 1050:
case 649:
case 1105:
case 589:
case 607:
case 564:
case 1055:
case 168:
case 174:
case 1180:
case 499:
case 507:
case 550:
case 171:
case 167:
case 1177:
case 169:
case 1181:
case 552:
case 661:
case 639:
case 478:
case 537:
case 477:
case 536:
case 1103:
case 680:
case 1104:
case 1024:
case 663:
case 535:
case 678:
case 504:
case 1043:
case 428:
case 170:
case 3072:
case 50:
case 2070:
case 1045:
          break;
        case 35:
          pass = true;
          break;
        case 36:
          pass = false;
          break;
        case 37:
          pass = true;
          break;
        case 38:
          pass = false;
          break;
        default:
          if (RR.T) ;
          else if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
      }
    }, opts);
    delete opts.supbooks;
    delete opts["!row"];
    if (!s["!ref"] && (refguess.s.r < 2e6 || ref2 && (ref2.e.r > 0 || ref2.e.c > 0 || ref2.s.r > 0 || ref2.s.c > 0))) s["!ref"] = encode_range(ref2 || refguess);
    if (opts.sheetRows && s["!ref"]) {
      var tmpref = safe_decode_range(s["!ref"]);
      if (opts.sheetRows <= +tmpref.e.r) {
        tmpref.e.r = opts.sheetRows - 1;
        if (tmpref.e.r > refguess.e.r) tmpref.e.r = refguess.e.r;
        if (tmpref.e.r < tmpref.s.r) tmpref.s.r = tmpref.e.r;
        if (tmpref.e.c > refguess.e.c) tmpref.e.c = refguess.e.c;
        if (tmpref.e.c < tmpref.s.c) tmpref.s.c = tmpref.e.c;
        s["!fullref"] = s["!ref"];
        s["!ref"] = encode_range(tmpref);
      }
    }
    if (merges.length > 0) s["!merges"] = merges;
    if (colinfo.length > 0) s["!cols"] = colinfo;
    if (rowinfo.length > 0) s["!rows"] = rowinfo;
    if (rels["!id"][s["!legrel"]]) s["!legdrawel"] = rels["!id"][s["!legrel"]];
    return s;
  }
  function write_ws_bin_cell(ba, cell, R, C, opts, ws, last_seen, date1904) {
    var o = { r: R, c: C };
    if (cell.c) ws["!comments"].push([encode_cell(o), cell.c]);
    if (cell.v === void 0) return false;
    var vv = "";
    switch (cell.t) {
      case "b":
        vv = cell.v ? "1" : "0";
        break;
      case "d":
        cell = dup(cell);
        cell.z = cell.z || table_fmt[14];
        cell.v = datenum(parseDate(cell.v, date1904), date1904);
        cell.t = "n";
        break;
case "n":
      case "e":
        vv = "" + cell.v;
        break;
      default:
        vv = cell.v;
        break;
    }
    o.s = get_cell_style(opts.cellXfs, cell, opts);
    if (cell.l) ws["!links"].push([encode_cell(o), cell.l]);
    switch (cell.t) {
      case "s":
      case "str":
        if (opts.bookSST) {
          vv = get_sst_id(opts.Strings, cell.v == null ? "" : String(cell.v), opts.revStrings);
          o.t = "s";
          o.v = vv;
          if (last_seen) write_record(ba, 18, write_BrtShortIsst(cell, o));
          else write_record(ba, 7, write_BrtCellIsst(cell, o));
        } else {
          o.t = "str";
          if (last_seen) write_record(ba, 17, write_BrtShortSt(cell, o));
          else write_record(ba, 6, write_BrtCellSt(cell, o));
        }
        return true;
      case "n":
        if (cell.v == (cell.v | 0) && cell.v > -1e3 && cell.v < 1e3) {
          if (last_seen) write_record(ba, 13, write_BrtShortRk(cell, o));
          else write_record(ba, 2, write_BrtCellRk(cell, o));
        } else if (!isFinite(cell.v)) {
          o.t = "e";
          if (isNaN(cell.v)) {
            if (last_seen) write_record(ba, 14, write_BrtShortError({ v: 36 }, o));
            else write_record(ba, 3, write_BrtCellError({ v: 36 }, o));
          } else {
            if (last_seen) write_record(ba, 14, write_BrtShortError({ v: 7 }, o));
            else write_record(ba, 3, write_BrtCellError({ v: 7 }, o));
          }
        } else {
          if (last_seen) write_record(ba, 16, write_BrtShortReal(cell, o));
          else write_record(ba, 5, write_BrtCellReal(cell, o));
        }
        return true;
      case "b":
        o.t = "b";
        if (last_seen) write_record(ba, 15, write_BrtShortBool(cell, o));
        else write_record(ba, 4, write_BrtCellBool(cell, o));
        return true;
      case "e":
        o.t = "e";
        if (last_seen) write_record(ba, 14, write_BrtShortError(cell, o));
        else write_record(ba, 3, write_BrtCellError(cell, o));
        return true;
    }
    if (last_seen) write_record(ba, 12, write_BrtShortBlank(cell, o));
    else write_record(ba, 1, write_BrtCellBlank(cell, o));
    return true;
  }
  function write_CELLTABLE(ba, ws, idx, opts, wb) {
    var range = safe_decode_range(ws["!ref"] || "A1"), rr = "", cols = [];
    var date1904 = (((wb || {}).Workbook || {}).WBProps || {}).date1904;
    write_record(
      ba,
      145
);
    var dense = ws["!data"] != null, row = dense ? ws["!data"][range.s.r] : [];
    var cap = range.e.r;
    if (ws["!rows"]) cap = Math.max(range.e.r, ws["!rows"].length - 1);
    for (var R = range.s.r; R <= cap; ++R) {
      rr = encode_row(R);
      if (dense) row = ws["!data"][R];
      write_row_header(ba, ws, range, R);
      if (dense && !row) continue;
      var last_seen = false;
      if (R <= range.e.r) for (var C = range.s.c; C <= range.e.c; ++C) {
        if (R === range.s.r) cols[C] = encode_col(C);
        var cell = dense ? row[C] : ws[cols[C] + rr];
        if (!cell) {
          last_seen = false;
          continue;
        }
        last_seen = write_ws_bin_cell(ba, cell, R, C, opts, ws, last_seen, date1904);
      }
    }
    write_record(
      ba,
      146
);
  }
  function write_MERGECELLS(ba, ws) {
    if (!ws || !ws["!merges"]) return;
    write_record(ba, 177, write_BrtBeginMergeCells(ws["!merges"].length));
    ws["!merges"].forEach(function(m) {
      write_record(ba, 176, write_BrtMergeCell(m));
    });
    write_record(
      ba,
      178
);
  }
  function write_COLINFOS(ba, ws) {
    if (!ws || !ws["!cols"]) return;
    write_record(
      ba,
      390
);
    ws["!cols"].forEach(function(m, i) {
      if (m) write_record(ba, 60, write_BrtColInfo(i, m));
    });
    write_record(
      ba,
      391
);
  }
  function write_IGNOREECS(ba, ws) {
    if (!ws || !ws["!ref"]) return;
    write_record(
      ba,
      648
);
    write_record(ba, 649, write_BrtCellIgnoreEC(safe_decode_range(ws["!ref"])));
    write_record(
      ba,
      650
);
  }
  function write_HLINKS(ba, ws, rels) {
    ws["!links"].forEach(function(l) {
      if (!l[1].Target) return;
      var rId = add_rels(rels, -1, l[1].Target.replace(/#[\s\S]*$/, ""), RELS.HLINK);
      write_record(ba, 494, write_BrtHLink(l, rId));
    });
    delete ws["!links"];
  }
  function write_LEGACYDRAWING(ba, ws, idx, rels) {
    if (ws["!comments"].length > 0) {
      var rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx + 1) + ".vml", RELS.VML);
      write_record(ba, 551, write_RelID("rId" + rId));
      ws["!legacy"] = rId;
    }
  }
  function write_AUTOFILTER(ba, ws, wb, idx) {
    if (!ws["!autofilter"]) return;
    var data = ws["!autofilter"];
    var ref2 = typeof data.ref === "string" ? data.ref : encode_range(data.ref);
    if (!wb.Workbook) wb.Workbook = { Sheets: [] };
    if (!wb.Workbook.Names) wb.Workbook.Names = [];
    var names = wb.Workbook.Names;
    var range = decode_range(ref2);
    if (range.s.r == range.e.r) {
      range.e.r = decode_range(ws["!ref"]).e.r;
      ref2 = encode_range(range);
    }
    for (var i = 0; i < names.length; ++i) {
      var name = names[i];
      if (name.Name != "_xlnm._FilterDatabase") continue;
      if (name.Sheet != idx) continue;
      name.Ref = formula_quote_sheet_name(wb.SheetNames[idx]) + "!" + fix_range(ref2);
      break;
    }
    if (i == names.length) names.push({ Name: "_xlnm._FilterDatabase", Sheet: idx, Ref: formula_quote_sheet_name(wb.SheetNames[idx]) + "!" + fix_range(ref2) });
    write_record(ba, 161, write_UncheckedRfX(safe_decode_range(ref2)));
    write_record(
      ba,
      162
);
  }
  function write_WSVIEWS2(ba, ws, Workbook) {
    write_record(
      ba,
      133
);
    {
      write_record(ba, 137, write_BrtBeginWsView(ws, Workbook));
      write_record(
        ba,
        138
);
    }
    write_record(
      ba,
      134
);
  }
  function write_SHEETPROTECT(ba, ws) {
    if (!ws["!protect"]) return;
    write_record(ba, 535, write_BrtSheetProtection(ws["!protect"]));
  }
  function write_ws_bin(idx, opts, wb, rels) {
    var ba = buf_array();
    var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};
    var c = s;
    try {
      if (wb && wb.Workbook) c = wb.Workbook.Sheets[idx].CodeName || c;
    } catch (e) {
    }
    var r2 = safe_decode_range(ws["!ref"] || "A1");
    if (r2.e.c > 16383 || r2.e.r > 1048575) {
      if (opts.WTF) throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:XFD1048576");
      r2.e.c = Math.min(r2.e.c, 16383);
      r2.e.r = Math.min(r2.e.c, 1048575);
    }
    ws["!links"] = [];
    ws["!comments"] = [];
    write_record(
      ba,
      129
);
    if (wb.vbaraw || ws["!outline"]) write_record(ba, 147, write_BrtWsProp(c, ws["!outline"]));
    write_record(ba, 148, write_BrtWsDim(r2));
    write_WSVIEWS2(ba, ws, wb.Workbook);
    write_COLINFOS(ba, ws);
    write_CELLTABLE(ba, ws, idx, opts, wb);
    write_SHEETPROTECT(ba, ws);
    write_AUTOFILTER(ba, ws, wb, idx);
    write_MERGECELLS(ba, ws);
    write_HLINKS(ba, ws, rels);
    if (ws["!margins"]) write_record(ba, 476, write_BrtMargins(ws["!margins"]));
    if (!opts || opts.ignoreEC || opts.ignoreEC == void 0) write_IGNOREECS(ba, ws);
    write_LEGACYDRAWING(ba, ws, idx, rels);
    write_record(
      ba,
      130
);
    return ba.end();
  }
  function parse_Cache(data) {
    var col = [];
    var num = data.match(/^<c:numCache>/);
    var f;
    (data.match(/<c:pt idx="(\d*)"[^<>\/]*><c:v>([^<])<\/c:v><\/c:pt>/mg) || []).forEach(function(pt) {
      var q = pt.match(/<c:pt idx="(\d*)"[^<>\/]*><c:v>([^<]*)<\/c:v><\/c:pt>/);
      if (!q) return;
      col[+q[1]] = num ? +q[2] : q[2];
    });
    var nf = unescapexml((str_match_xml(data, "c:formatCode") || ["", "General"])[1]);
    (str_match_ng(data, "<c:f>", "</c:f>") || []).forEach(function(F) {
      f = F.replace(/<[^<>]*>/g, "");
    });
    return [col, nf, f];
  }
  function parse_chart(data, name, opts, rels, wb, csheet) {
    var cs = csheet || { "!type": "chart" };
    if (!data) return csheet;
    var C = 0, R = 0, col = "A";
    var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
    (str_match_ng(data, "<c:numCache>", "</c:numCache>") || []).forEach(function(nc) {
      var cache = parse_Cache(nc);
      refguess.s.r = refguess.s.c = 0;
      refguess.e.c = C;
      col = encode_col(C);
      cache[0].forEach(function(n, i) {
        if (cs["!data"]) {
          if (!cs["!data"][i]) cs["!data"][i] = [];
          cs["!data"][i][C] = { t: "n", v: n, z: cache[1] };
        } else cs[col + encode_row(i)] = { t: "n", v: n, z: cache[1] };
        R = i;
      });
      if (refguess.e.r < R) refguess.e.r = R;
      ++C;
    });
    if (C > 0) cs["!ref"] = encode_range(refguess);
    return cs;
  }
  function parse_cs_xml(data, opts, idx, rels, wb) {
    if (!data) return data;
    if (!rels) rels = { "!id": {} };
    var s = { "!type": "chart", "!drawel": null, "!rel": "" };
    var m;
    var sheetPr = data.match(sheetprregex);
    if (sheetPr) parse_ws_xml_sheetpr(sheetPr[0], s, wb, idx);
    if (m = data.match(/drawing r:id="(.*?)"/)) s["!rel"] = m[1];
    if (rels["!id"][s["!rel"]]) s["!drawel"] = rels["!id"][s["!rel"]];
    return s;
  }
  function parse_BrtCsProp(data, length) {
    data.l += 10;
    var name = parse_XLWideString(data);
    return { name };
  }
  function parse_cs_bin(data, opts, idx, rels, wb) {
    if (!data) return data;
    if (!rels) rels = { "!id": {} };
    var s = { "!type": "chart", "!drawel": null, "!rel": "" };
    var pass = false;
    recordhopper(data, function cs_parse(val2, R, RT) {
      switch (RT) {
        case 550:
          s["!rel"] = val2;
          break;
        case 651:
          if (!wb.Sheets[idx]) wb.Sheets[idx] = {};
          if (val2.name) wb.Sheets[idx].CodeName = val2.name;
          break;
        case 562:
case 652:
case 669:
case 679:
case 551:
case 552:
case 476:
case 3072:
          break;
        case 35:
          pass = true;
          break;
        case 36:
          pass = false;
          break;
        case 37:
          break;
        case 38:
          break;
        default:
          if (R.T > 0) ;
          else if (R.T < 0) ;
          else if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
      }
    }, opts);
    if (rels["!id"][s["!rel"]]) s["!drawel"] = rels["!id"][s["!rel"]];
    return s;
  }
  var WBPropsDef = [
    ["allowRefreshQuery", false, "bool"],
    ["autoCompressPictures", true, "bool"],
    ["backupFile", false, "bool"],
    ["checkCompatibility", false, "bool"],
    ["CodeName", ""],
    ["date1904", false, "bool"],
    ["defaultThemeVersion", 0, "int"],
    ["filterPrivacy", false, "bool"],
    ["hidePivotFieldList", false, "bool"],
    ["promptedSolutions", false, "bool"],
    ["publishItems", false, "bool"],
    ["refreshAllConnections", false, "bool"],
    ["saveExternalLinkValues", true, "bool"],
    ["showBorderUnselectedTables", true, "bool"],
    ["showInkAnnotation", true, "bool"],
    ["showObjects", "all"],
    ["showPivotChartFilter", false, "bool"],
    ["updateLinks", "userSet"]
  ];
  var WBViewDef = [
    ["activeTab", 0, "int"],
    ["autoFilterDateGrouping", true, "bool"],
    ["firstSheet", 0, "int"],
    ["minimized", false, "bool"],
    ["showHorizontalScroll", true, "bool"],
    ["showSheetTabs", true, "bool"],
    ["showVerticalScroll", true, "bool"],
    ["tabRatio", 600, "int"],
    ["visibility", "visible"]
];
  var SheetDef = [
];
  var CalcPrDef = [
    ["calcCompleted", "true"],
    ["calcMode", "auto"],
    ["calcOnSave", "true"],
    ["concurrentCalc", "true"],
    ["fullCalcOnLoad", "false"],
    ["fullPrecision", "true"],
    ["iterate", "false"],
    ["iterateCount", "100"],
    ["iterateDelta", "0.001"],
    ["refMode", "A1"]
  ];
  function push_defaults_array(target, defaults) {
    for (var j = 0; j != target.length; ++j) {
      var w = target[j];
      for (var i = 0; i != defaults.length; ++i) {
        var z = defaults[i];
        if (w[z[0]] == null) w[z[0]] = z[1];
        else switch (z[2]) {
          case "bool":
            if (typeof w[z[0]] == "string") w[z[0]] = parsexmlbool(w[z[0]]);
            break;
          case "int":
            if (typeof w[z[0]] == "string") w[z[0]] = parseInt(w[z[0]], 10);
            break;
        }
      }
    }
  }
  function push_defaults(target, defaults) {
    for (var i = 0; i != defaults.length; ++i) {
      var z = defaults[i];
      if (target[z[0]] == null) target[z[0]] = z[1];
      else switch (z[2]) {
        case "bool":
          if (typeof target[z[0]] == "string") target[z[0]] = parsexmlbool(target[z[0]]);
          break;
        case "int":
          if (typeof target[z[0]] == "string") target[z[0]] = parseInt(target[z[0]], 10);
          break;
      }
    }
  }
  function parse_wb_defaults(wb) {
    push_defaults(wb.WBProps, WBPropsDef);
    push_defaults(wb.CalcPr, CalcPrDef);
    push_defaults_array(wb.WBView, WBViewDef);
    push_defaults_array(wb.Sheets, SheetDef);
    _ssfopts.date1904 = parsexmlbool(wb.WBProps.date1904);
  }
  function safe1904(wb) {
    if (!wb.Workbook) return "false";
    if (!wb.Workbook.WBProps) return "false";
    return parsexmlbool(wb.Workbook.WBProps.date1904) ? "true" : "false";
  }
  var badchars = ":][*?/\\".split("");
  function check_ws_name(n, safe) {
    try {
      if (n == "") throw new Error("Sheet name cannot be blank");
      if (n.length > 31) throw new Error("Sheet name cannot exceed 31 chars");
      if (n.charCodeAt(0) == 39 || n.charCodeAt(n.length - 1) == 39) throw new Error("Sheet name cannot start or end with apostrophe (')");
      if (n.toLowerCase() == "history") throw new Error("Sheet name cannot be 'History'");
      badchars.forEach(function(c) {
        if (n.indexOf(c) == -1) return;
        throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
      });
    } catch (e) {
      throw e;
    }
    return true;
  }
  function check_wb_names(N, S, codes) {
    N.forEach(function(n, i) {
      check_ws_name(n);
      for (var j = 0; j < i; ++j) if (n == N[j]) throw new Error("Duplicate Sheet Name: " + n);
      if (codes) {
        var cn2 = S && S[i] && S[i].CodeName || n;
        if (cn2.charCodeAt(0) == 95 && cn2.length > 22) throw new Error("Bad Code Name: Worksheet" + cn2);
      }
    });
  }
  function check_wb(wb) {
    if (!wb || !wb.SheetNames || !wb.Sheets) throw new Error("Invalid Workbook");
    if (!wb.SheetNames.length) throw new Error("Workbook is empty");
    var Sheets = wb.Workbook && wb.Workbook.Sheets || [];
    check_wb_names(wb.SheetNames, Sheets, !!wb.vbaraw);
    for (var i = 0; i < wb.SheetNames.length; ++i) check_ws(wb.Sheets[wb.SheetNames[i]], wb.SheetNames[i], i);
    wb.SheetNames.forEach(function(n, i2) {
      var ws = wb.Sheets[n];
      if (!ws || !ws["!autofilter"]) return;
      var DN;
      if (!wb.Workbook) wb.Workbook = {};
      if (!wb.Workbook.Names) wb.Workbook.Names = [];
      wb.Workbook.Names.forEach(function(dn) {
        if (dn.Name == "_xlnm._FilterDatabase" && dn.Sheet == i2) DN = dn;
      });
      var nn = formula_quote_sheet_name(n) + "!" + fix_range(ws["!autofilter"].ref);
      if (DN) DN.Ref = nn;
      else wb.Workbook.Names.push({ Name: "_xlnm._FilterDatabase", Sheet: i2, Ref: nn });
    });
  }
  var wbnsregex = /<\w+:workbook/;
  function parse_wb_xml(data, opts) {
    if (!data) throw new Error("Could not find file");
    var wb = (
{ AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, Names: [], xmlns: "" }
    );
    var pass = false, xmlns = "xmlns";
    var dname = {}, dnstart = 0;
    data.replace(tagregex, function xml_wb(x, idx) {
      var y = parsexmltag(x);
      switch (strip_ns(y[0])) {
        case "<?xml":
          break;
case "<workbook":
          if (x.match(wbnsregex)) xmlns = "xmlns" + x.match(/<(\w+):/)[1];
          wb.xmlns = y[xmlns];
          break;
        case "</workbook>":
          break;
case "<fileVersion":
          delete y[0];
          wb.AppVersion = y;
          break;
        case "<fileVersion/>":
        case "</fileVersion>":
          break;
case "<fileSharing":
          break;
        case "<fileSharing/>":
          break;
case "<workbookPr":
        case "<workbookPr/>":
          WBPropsDef.forEach(function(w) {
            if (y[w[0]] == null) return;
            switch (w[2]) {
              case "bool":
                wb.WBProps[w[0]] = parsexmlbool(y[w[0]]);
                break;
              case "int":
                wb.WBProps[w[0]] = parseInt(y[w[0]], 10);
                break;
              default:
                wb.WBProps[w[0]] = y[w[0]];
            }
          });
          if (y.codeName) wb.WBProps.CodeName = utf8read(y.codeName);
          break;
        case "</workbookPr>":
          break;
case "<workbookProtection":
          break;
        case "<workbookProtection/>":
          break;
case "<bookViews":
        case "<bookViews>":
        case "</bookViews>":
          break;
case "<workbookView":
        case "<workbookView/>":
          delete y[0];
          wb.WBView.push(y);
          break;
        case "</workbookView>":
          break;
case "<sheets":
        case "<sheets>":
        case "</sheets>":
          break;

case "<sheet":
          switch (y.state) {
            case "hidden":
              y.Hidden = 1;
              break;
            case "veryHidden":
              y.Hidden = 2;
              break;
            default:
              y.Hidden = 0;
          }
          delete y.state;
          y.name = unescapexml(utf8read(y.name));
          delete y[0];
          wb.Sheets.push(y);
          break;
        case "</sheet>":
          break;
case "<functionGroups":
        case "<functionGroups/>":
          break;
case "<functionGroup":
          break;
case "<externalReferences":
        case "</externalReferences>":
        case "<externalReferences>":
          break;
case "<externalReference":
          break;
case "<definedNames/>":
          break;
        case "<definedNames>":
        case "<definedNames":
          pass = true;
          break;
        case "</definedNames>":
          pass = false;
          break;
case "<definedName":
          {
            dname = {};
            dname.Name = utf8read(y.name);
            if (y.comment) dname.Comment = y.comment;
            if (y.localSheetId) dname.Sheet = +y.localSheetId;
            if (parsexmlbool(y.hidden || "0")) dname.Hidden = true;
            dnstart = idx + x.length;
          }
          break;
        case "</definedName>":
          {
            dname.Ref = unescapexml(utf8read(data.slice(dnstart, idx)));
            wb.Names.push(dname);
          }
          break;
        case "<definedName/>":
          break;
case "<calcPr":
          delete y[0];
          wb.CalcPr = y;
          break;
        case "<calcPr/>":
          delete y[0];
          wb.CalcPr = y;
          break;
        case "</calcPr>":
          break;
case "<oleSize":
          break;
case "<customWorkbookViews>":
        case "</customWorkbookViews>":
        case "<customWorkbookViews":
          break;
case "<customWorkbookView":
        case "</customWorkbookView>":
          break;
case "<pivotCaches>":
        case "</pivotCaches>":
        case "<pivotCaches":
          break;
case "<pivotCache":
          break;
case "<smartTagPr":
        case "<smartTagPr/>":
          break;
case "<smartTagTypes":
        case "<smartTagTypes>":
        case "</smartTagTypes>":
          break;
case "<smartTagType":
          break;
case "<webPublishing":
        case "<webPublishing/>":
          break;
case "<fileRecoveryPr":
        case "<fileRecoveryPr/>":
          break;
case "<webPublishObjects>":
        case "<webPublishObjects":
        case "</webPublishObjects>":
          break;
case "<webPublishObject":
          break;
case "<extLst":
        case "<extLst>":
        case "</extLst>":
        case "<extLst/>":
          break;
case "<ext":
          pass = true;
          break;
case "</ext>":
          pass = false;
          break;
case "<ArchID":
          break;
        case "<AlternateContent":
        case "<AlternateContent>":
          pass = true;
          break;
        case "</AlternateContent>":
          pass = false;
          break;
case "<revisionPtr":
          break;
        default:
          if (!pass && opts.WTF) throw new Error("unrecognized " + y[0] + " in workbook");
      }
      return x;
    });
    if (XMLNS_main.indexOf(wb.xmlns) === -1) throw new Error("Unknown Namespace: " + wb.xmlns);
    parse_wb_defaults(wb);
    return wb;
  }
  function write_wb_xml(wb) {
    var o = [XML_HEADER];
    o[o.length] = writextag("workbook", null, {
      "xmlns": XMLNS_main[0],

"xmlns:r": XMLNS.r
    });
    var write_names = wb.Workbook && (wb.Workbook.Names || []).length > 0;
    var workbookPr = { codeName: "ThisWorkbook" };
    if (wb.Workbook && wb.Workbook.WBProps) {
      WBPropsDef.forEach(function(x) {
        if (wb.Workbook.WBProps[x[0]] == null) return;
        if (wb.Workbook.WBProps[x[0]] == x[1]) return;
        workbookPr[x[0]] = wb.Workbook.WBProps[x[0]];
      });
      if (wb.Workbook.WBProps.CodeName) {
        workbookPr.codeName = wb.Workbook.WBProps.CodeName;
        delete workbookPr.CodeName;
      }
    }
    o[o.length] = writextag("workbookPr", null, workbookPr);
    var sheets = wb.Workbook && wb.Workbook.Sheets || [];
    var i = 0;
    if (sheets && sheets[0] && !!sheets[0].Hidden) {
      o[o.length] = "<bookViews>";
      for (i = 0; i != wb.SheetNames.length; ++i) {
        if (!sheets[i]) break;
        if (!sheets[i].Hidden) break;
      }
      if (i == wb.SheetNames.length) i = 0;
      o[o.length] = '<workbookView firstSheet="' + i + '" activeTab="' + i + '"/>';
      o[o.length] = "</bookViews>";
    }
    o[o.length] = "<sheets>";
    for (i = 0; i != wb.SheetNames.length; ++i) {
      var sht = { name: escapexml(wb.SheetNames[i].slice(0, 31)) };
      sht.sheetId = "" + (i + 1);
      sht["r:id"] = "rId" + (i + 1);
      if (sheets[i]) switch (sheets[i].Hidden) {
        case 1:
          sht.state = "hidden";
          break;
        case 2:
          sht.state = "veryHidden";
          break;
      }
      o[o.length] = writextag("sheet", null, sht);
    }
    o[o.length] = "</sheets>";
    if (write_names) {
      o[o.length] = "<definedNames>";
      if (wb.Workbook && wb.Workbook.Names) wb.Workbook.Names.forEach(function(n) {
        var d = { name: n.Name };
        if (n.Comment) d.comment = n.Comment;
        if (n.Sheet != null) d.localSheetId = "" + n.Sheet;
        if (n.Hidden) d.hidden = "1";
        if (!n.Ref) return;
        o[o.length] = writextag("definedName", escapexml(n.Ref), d);
      });
      o[o.length] = "</definedNames>";
    }
    if (o.length > 2) {
      o[o.length] = "</workbook>";
      o[1] = o[1].replace("/>", ">");
    }
    return o.join("");
  }
  function parse_BrtBundleSh(data, length) {
    var z = {};
    z.Hidden = data.read_shift(4);
    z.iTabID = data.read_shift(4);
    z.strRelID = parse_RelID(data);
    z.name = parse_XLWideString(data);
    return z;
  }
  function write_BrtBundleSh(data, o) {
    if (!o) o = new_buf(127);
    o.write_shift(4, data.Hidden);
    o.write_shift(4, data.iTabID);
    write_RelID(data.strRelID, o);
    write_XLWideString(data.name.slice(0, 31), o);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function parse_BrtWbProp(data, length) {
    var o = {};
    var flags = data.read_shift(4);
    o.defaultThemeVersion = data.read_shift(4);
    var strName = length > 8 ? parse_XLWideString(data) : "";
    if (strName.length > 0) o.CodeName = strName;
    o.autoCompressPictures = !!(flags & 65536);
    o.backupFile = !!(flags & 64);
    o.checkCompatibility = !!(flags & 4096);
    o.date1904 = !!(flags & 1);
    o.filterPrivacy = !!(flags & 8);
    o.hidePivotFieldList = !!(flags & 1024);
    o.promptedSolutions = !!(flags & 16);
    o.publishItems = !!(flags & 2048);
    o.refreshAllConnections = !!(flags & 262144);
    o.saveExternalLinkValues = !!(flags & 128);
    o.showBorderUnselectedTables = !!(flags & 4);
    o.showInkAnnotation = !!(flags & 32);
    o.showObjects = ["all", "placeholders", "none"][flags >> 13 & 3];
    o.showPivotChartFilter = !!(flags & 32768);
    o.updateLinks = ["userSet", "never", "always"][flags >> 8 & 3];
    return o;
  }
  function write_BrtWbProp(data, o) {
    if (!o) o = new_buf(72);
    var flags = 0;
    if (data) {
      if (data.date1904) flags |= 1;
      if (data.filterPrivacy) flags |= 8;
    }
    o.write_shift(4, flags);
    o.write_shift(4, 0);
    write_XLSBCodeName(data && data.CodeName || "ThisWorkbook", o);
    return o.slice(0, o.l);
  }
  function parse_BrtFRTArchID$(data, length) {
    var o = {};
    data.read_shift(4);
    o.ArchID = data.read_shift(4);
    data.l += length - 8;
    return o;
  }
  function parse_BrtName(data, length, opts) {
    var end = data.l + length;
    var flags = data.read_shift(4);
    data.l += 1;
    var itab = data.read_shift(4);
    var name = parse_XLNameWideString(data);
    var formula;
    var comment = "";
    try {
      formula = parse_XLSBNameParsedFormula(data, 0, opts);
      try {
        comment = parse_XLNullableWideString(data);
      } catch (e) {
      }
    } catch (e) {
      console.error("Could not parse defined name " + name);
    }
    if (flags & 32) name = "_xlnm." + name;
    data.l = end;
    var out = { Name: name, Ptg: formula, Flags: flags };
    if (itab < 268435455) out.Sheet = itab;
    if (comment) out.Comment = comment;
    return out;
  }
  function write_BrtName(name, wb) {
    var o = new_buf(9);
    var flags = 0;
    var dname = name.Name;
    if (XLSLblBuiltIn.indexOf(dname) > -1) {
      flags |= 32;
      dname = dname.slice(6);
    }
    o.write_shift(4, flags);
    o.write_shift(1, 0);
    o.write_shift(4, name.Sheet == null ? 4294967295 : name.Sheet);
    var arr = [
      o,
      write_XLWideString(dname),
      write_XLSBNameParsedFormula(name.Ref, wb)
    ];
    if (name.Comment) arr.push(write_XLNullableWideString(name.Comment));
    else {
      var x = new_buf(4);
      x.write_shift(4, 4294967295);
      arr.push(x);
    }
    return bconcat(arr);
  }
  function parse_wb_bin(data, opts) {
    var wb = { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, xmlns: "" };
    var state = [];
    var pass = false;
    if (!opts) opts = {};
    opts.biff = 12;
    var Names = [];
    var supbooks = [[]];
    supbooks.SheetNames = [];
    supbooks.XTI = [];
    XLSBRecordEnum[16] = { n: "BrtFRTArchID$", f: parse_BrtFRTArchID$ };
    recordhopper(data, function hopper_wb(val2, R, RT) {
      switch (RT) {
        case 156:
          supbooks.SheetNames.push(val2.name);
          wb.Sheets.push(val2);
          break;
        case 153:
          wb.WBProps = val2;
          break;
        case 39:
          if (val2.Sheet != null) opts.SID = val2.Sheet;
          val2.Ref = val2.Ptg ? stringify_formula(val2.Ptg, null, null, supbooks, opts) : "#REF!";
          delete opts.SID;
          delete val2.Ptg;
          Names.push(val2);
          break;
        case 1036:
          break;
        case 357:
case 358:
case 355:
case 667:
          if (!supbooks[0].length) supbooks[0] = [RT, val2];
          else supbooks.push([RT, val2]);
          supbooks[supbooks.length - 1].XTI = [];
          break;
        case 362:
          if (supbooks.length === 0) {
            supbooks[0] = [];
            supbooks[0].XTI = [];
          }
          supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val2);
          supbooks.XTI = supbooks.XTI.concat(val2);
          break;
        case 361:
          break;
        case 2071:
case 158:
case 143:
case 664:
case 353:
          break;
case 3072:
case 3073:
case 534:
case 677:
case 157:
case 610:
case 2050:
case 155:
case 548:
case 676:
case 128:
case 665:
case 2128:
case 2125:
case 549:
case 2053:
case 596:
case 2076:
case 2075:
case 2082:
case 397:
case 154:
case 1117:
case 553:
case 2091:
          break;
        case 35:
          state.push(RT);
          pass = true;
          break;
        case 36:
          state.pop();
          pass = false;
          break;
        case 37:
          state.push(RT);
          pass = true;
          break;
        case 38:
          state.pop();
          pass = false;
          break;
        case 16:
          break;
        default:
          if (R.T) ;
          else if (!pass || opts.WTF && state[state.length - 1] != 37 && state[state.length - 1] != 35) throw new Error("Unexpected record 0x" + RT.toString(16));
      }
    }, opts);
    parse_wb_defaults(wb);
    wb.Names = Names;
    wb.supbooks = supbooks;
    return wb;
  }
  function write_BUNDLESHS(ba, wb) {
    write_record(
      ba,
      143
);
    for (var idx = 0; idx != wb.SheetNames.length; ++idx) {
      var viz = wb.Workbook && wb.Workbook.Sheets && wb.Workbook.Sheets[idx] && wb.Workbook.Sheets[idx].Hidden || 0;
      var d = { Hidden: viz, iTabID: idx + 1, strRelID: "rId" + (idx + 1), name: wb.SheetNames[idx] };
      write_record(ba, 156, write_BrtBundleSh(d));
    }
    write_record(
      ba,
      144
);
  }
  function write_BrtFileVersion(data, o) {
    if (!o) o = new_buf(127);
    for (var i = 0; i != 4; ++i) o.write_shift(4, 0);
    write_XLWideString("SheetJS", o);
    write_XLWideString(XLSX.version, o);
    write_XLWideString(XLSX.version, o);
    write_XLWideString("7262", o);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function write_BrtBookView(idx, o) {
    if (!o) o = new_buf(29);
    o.write_shift(-4, 0);
    o.write_shift(-4, 460);
    o.write_shift(4, 28800);
    o.write_shift(4, 17600);
    o.write_shift(4, 500);
    o.write_shift(4, idx);
    o.write_shift(4, idx);
    var flags = 120;
    o.write_shift(1, flags);
    return o.length > o.l ? o.slice(0, o.l) : o;
  }
  function write_BOOKVIEWS(ba, wb) {
    if (!wb.Workbook || !wb.Workbook.Sheets) return;
    var sheets = wb.Workbook.Sheets;
    var i = 0, vistab = -1, hidden = -1;
    for (; i < sheets.length; ++i) {
      if (!sheets[i] || !sheets[i].Hidden && vistab == -1) vistab = i;
      else if (sheets[i].Hidden == 1 && hidden == -1) hidden = i;
    }
    if (hidden > vistab) return;
    write_record(
      ba,
      135
);
    write_record(ba, 158, write_BrtBookView(vistab));
    write_record(
      ba,
      136
);
  }
  function write_BRTNAMES(ba, wb) {
    if (!wb.Workbook || !wb.Workbook.Names) return;
    wb.Workbook.Names.forEach(function(name) {
      try {
        if (name.Flags & 14) return;
        write_record(ba, 39, write_BrtName(name, wb));
      } catch (e) {
        console.error("Could not serialize defined name " + JSON.stringify(name));
      }
    });
  }
  function write_SELF_EXTERNS_xlsb(wb) {
    var L = wb.SheetNames.length;
    var o = new_buf(12 * L + 28);
    o.write_shift(4, L + 2);
    o.write_shift(4, 0);
    o.write_shift(4, -2);
    o.write_shift(4, -2);
    o.write_shift(4, 0);
    o.write_shift(4, -1);
    o.write_shift(4, -1);
    for (var i = 0; i < L; ++i) {
      o.write_shift(4, 0);
      o.write_shift(4, i);
      o.write_shift(4, i);
    }
    return o;
  }
  function write_EXTERNALS_xlsb(ba, wb) {
    write_record(
      ba,
      353
);
    write_record(
      ba,
      357
);
    write_record(ba, 362, write_SELF_EXTERNS_xlsb(wb));
    write_record(
      ba,
      354
);
  }
  function write_wb_bin(wb, opts) {
    var ba = buf_array();
    write_record(
      ba,
      131
);
    write_record(ba, 128, write_BrtFileVersion());
    write_record(ba, 153, write_BrtWbProp(wb.Workbook && wb.Workbook.WBProps || null));
    write_BOOKVIEWS(ba, wb);
    write_BUNDLESHS(ba, wb);
    write_EXTERNALS_xlsb(ba, wb);
    if ((wb.Workbook || {}).Names) write_BRTNAMES(ba, wb);
    write_record(
      ba,
      132
);
    return ba.end();
  }
  function parse_wb(data, name, opts) {
    if (name.slice(-4) === ".bin") return parse_wb_bin(data, opts);
    return parse_wb_xml(data, opts);
  }
  function parse_ws(data, name, idx, opts, rels, wb, themes, styles) {
    if (name.slice(-4) === ".bin") return parse_ws_bin(data, opts, idx, rels, wb, themes, styles);
    return parse_ws_xml(data, opts, idx, rels, wb, themes, styles);
  }
  function parse_cs(data, name, idx, opts, rels, wb, themes, styles) {
    if (name.slice(-4) === ".bin") return parse_cs_bin(data, opts, idx, rels, wb);
    return parse_cs_xml(data, opts, idx, rels, wb);
  }
  function parse_ms(data, name, idx, opts, rels, wb, themes, styles) {
    if (name.slice(-4) === ".bin") return parse_ms_bin();
    return parse_ms_xml();
  }
  function parse_ds(data, name, idx, opts, rels, wb, themes, styles) {
    if (name.slice(-4) === ".bin") return parse_ds_bin();
    return parse_ds_xml();
  }
  function parse_sty(data, name, themes, opts) {
    if (name.slice(-4) === ".bin") return parse_sty_bin(data, themes, opts);
    return parse_sty_xml(data, themes, opts);
  }
  function parse_sst(data, name, opts) {
    if (name.slice(-4) === ".bin") return parse_sst_bin(data, opts);
    return parse_sst_xml(data, opts);
  }
  function parse_cmnt(data, name, opts) {
    if (name.slice(-4) === ".bin") return parse_comments_bin(data, opts);
    return parse_comments_xml(data, opts);
  }
  function parse_cc(data, name, opts) {
    if (name.slice(-4) === ".bin") return parse_cc_bin(data);
    return parse_cc_xml(data);
  }
  function parse_xlink(data, rel, name, opts) {
    if (name.slice(-4) === ".bin") return parse_xlink_bin(data, rel, name, opts);
    return parse_xlink_xml();
  }
  function parse_xlmeta(data, name, opts) {
    if (name.slice(-4) === ".bin") return parse_xlmeta_bin(data, name, opts);
    return parse_xlmeta_xml(data, name, opts);
  }
  var attregexg2 = /\b((?:\w+:)?[\w]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g;
  var attregex2 = /\b((?:\w+:)?[\w]+)=((?:")(?:[^"]*)(?:")|(?:')(?:[^']*)(?:'))/;
  function xlml_parsexmltag(tag, skip_root) {
    var words = tag.split(/\s+/);
    var z = [];
    z[0] = words[0];
    if (words.length === 1) return z;
    var m = tag.match(attregexg2), y, j, w, i;
    if (m) for (i = 0; i != m.length; ++i) {
      y = m[i].match(attregex2);
      if ((j = y[1].indexOf(":")) === -1) z[y[1]] = y[2].slice(1, y[2].length - 1);
      else {
        if (y[1].slice(0, 6) === "xmlns:") w = "xmlns" + y[1].slice(6);
        else w = y[1].slice(j + 1);
        z[w] = y[2].slice(1, y[2].length - 1);
      }
    }
    return z;
  }
  function xlml_parsexmltagobj(tag) {
    var words = tag.split(/\s+/);
    var z = {};
    if (words.length === 1) return z;
    var m = tag.match(attregexg2), y, j, w, i;
    if (m) for (i = 0; i != m.length; ++i) {
      y = m[i].match(attregex2);
      if ((j = y[1].indexOf(":")) === -1) z[y[1]] = y[2].slice(1, y[2].length - 1);
      else {
        if (y[1].slice(0, 6) === "xmlns:") w = "xmlns" + y[1].slice(6);
        else w = y[1].slice(j + 1);
        z[w] = y[2].slice(1, y[2].length - 1);
      }
    }
    return z;
  }
  var XLMLFormatMap;
  function xlml_format(format, value, date1904) {
    var fmt = XLMLFormatMap[format] || unescapexml(format);
    if (fmt === "General") return SSF_general(value);
    return SSF_format(fmt, value, { date1904: !!date1904 });
  }
  function xlml_set_custprop(Custprops, key, cp, val2) {
    var oval = val2;
    switch ((cp[0].match(/dt:dt="([\w.]+)"/) || ["", ""])[1]) {
      case "boolean":
        oval = parsexmlbool(val2);
        break;
      case "i2":
      case "int":
        oval = parseInt(val2, 10);
        break;
      case "r4":
      case "float":
        oval = parseFloat(val2);
        break;
      case "date":
      case "dateTime.tz":
        oval = parseDate(val2);
        break;
      case "i8":
      case "string":
      case "fixed":
      case "uuid":
      case "bin.base64":
        break;
      default:
        throw new Error("bad custprop:" + cp[0]);
    }
    Custprops[unescapexml(key)] = oval;
  }
  function safe_format_xlml(cell, nf, o, date1904) {
    if (cell.t === "z") return;
    if (!o || o.cellText !== false) try {
      if (cell.t === "e") {
        cell.w = cell.w || BErr[cell.v];
      } else if (nf === "General") {
        if (cell.t === "n") {
          if ((cell.v | 0) === cell.v) cell.w = cell.v.toString(10);
          else cell.w = SSF_general_num(cell.v);
        } else cell.w = SSF_general(cell.v);
      } else cell.w = xlml_format(nf || "General", cell.v, date1904);
    } catch (e) {
      if (o.WTF) throw e;
    }
    try {
      var z = XLMLFormatMap[nf] || nf || "General";
      if (o.cellNF) cell.z = z;
      if (o.cellDates && cell.t == "n" && fmt_is_date(z)) {
        var _d = SSF_parse_date_code(cell.v + (date1904 ? 1462 : 0));
        if (_d) {
          cell.t = "d";
          cell.v = new Date(Date.UTC(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u));
        }
      }
    } catch (e) {
      if (o.WTF) throw e;
    }
  }
  function process_style_xlml(styles, stag, opts) {
    if (opts.cellStyles) {
      if (stag.Interior) {
        var I = stag.Interior;
        if (I.Pattern) I.patternType = XLMLPatternTypeMap[I.Pattern] || I.Pattern;
      }
    }
    styles[stag.ID] = stag;
  }
  function parse_xlml_data(xml, ss, data, cell, base, styles, csty, row, arrayf, o, date1904) {
    var nf = "General", sid = cell.StyleID, S = {};
    o = o || {};
    var interiors = [];
    var i = 0;
    if (sid === void 0 && row) sid = row.StyleID;
    if (sid === void 0 && csty) sid = csty.StyleID;
    while (styles[sid] !== void 0) {
      var ssid = styles[sid];
      if (ssid.nf) nf = ssid.nf;
      if (ssid.Interior) interiors.push(ssid.Interior);
      if (!ssid.Parent) break;
      sid = ssid.Parent;
    }
    switch (data.Type) {
      case "Boolean":
        cell.t = "b";
        cell.v = parsexmlbool(xml);
        break;
      case "String":
        cell.t = "s";
        cell.r = xlml_fixstr(unescapexml(xml));
        cell.v = xml.indexOf("<") > -1 ? unescapexml(ss || xml).replace(/<[^<>]*>/g, "") : cell.r;
        break;
      case "DateTime":
        if (xml.slice(-1) != "Z") xml += "Z";
        cell.v = datenum(parseDate(xml, date1904), date1904);
        if (cell.v !== cell.v) cell.v = unescapexml(xml);
        if (!nf || nf == "General") nf = "yyyy-mm-dd";
case "Number":
        if (cell.v === void 0) cell.v = +xml;
        if (!cell.t) cell.t = "n";
        break;
      case "Error":
        cell.t = "e";
        cell.v = RBErr[xml];
        if (o.cellText !== false) cell.w = xml;
        break;
      default:
        if (xml == "" && ss == "") {
          cell.t = "z";
        } else {
          cell.t = "s";
          cell.v = xlml_fixstr(ss || xml);
        }
        break;
    }
    safe_format_xlml(cell, nf, o, date1904);
    if (o.cellFormula !== false) {
      if (cell.Formula) {
        var fstr = unescapexml(cell.Formula);
        if (fstr.charCodeAt(0) == 61) fstr = fstr.slice(1);
        cell.f = rc_to_a1(fstr, base);
        delete cell.Formula;
        if (cell.ArrayRange == "RC") cell.F = rc_to_a1("RC:RC", base);
        else if (cell.ArrayRange) {
          cell.F = rc_to_a1(cell.ArrayRange, base);
          arrayf.push([safe_decode_range(cell.F), cell.F]);
        }
      } else {
        for (i = 0; i < arrayf.length; ++i)
          if (base.r >= arrayf[i][0].s.r && base.r <= arrayf[i][0].e.r) {
            if (base.c >= arrayf[i][0].s.c && base.c <= arrayf[i][0].e.c)
              cell.F = arrayf[i][1];
          }
      }
    }
    if (o.cellStyles) {
      interiors.forEach(function(x) {
        if (!S.patternType && x.patternType) S.patternType = x.patternType;
      });
      cell.s = S;
    }
    if (cell.StyleID !== void 0) cell.ixfe = cell.StyleID;
  }
  function xlml_prefix_dname(dname) {
    return XLSLblBuiltIn.indexOf("_xlnm." + dname) > -1 ? "_xlnm." + dname : dname;
  }
  function xlml_clean_comment(comment) {
    comment.t = comment.v || "";
    comment.t = comment.t.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    comment.v = comment.w = comment.ixfe = void 0;
  }
  function parse_xlml_xml(d, _opts) {
    var opts = _opts || {};
    make_ssf();
    var str = debom(xlml_normalize(d));
    if (opts.type == "binary" || opts.type == "array" || opts.type == "base64") {
      if (typeof $cptable !== "undefined") str = $cptable.utils.decode(65001, char_codes(str));
      else str = utf8read(str);
    }
    var opening = str.slice(0, 1024).toLowerCase(), ishtml = false;
    opening = opening.replace(/".*?"/g, "");
    if ((opening.indexOf(">") & 1023) > Math.min(opening.indexOf(",") & 1023, opening.indexOf(";") & 1023)) {
      var _o = dup(opts);
      _o.type = "string";
      return PRN.to_workbook(str, _o);
    }
    if (opening.indexOf("<?xml") == -1) ["html", "table", "head", "meta", "script", "style", "div"].forEach(function(tag) {
      if (opening.indexOf("<" + tag) >= 0) ishtml = true;
    });
    if (ishtml) return html_to_workbook(str, opts);
    XLMLFormatMap = {
      "General Number": "General",
      "General Date": table_fmt[22],
      "Long Date": "dddd, mmmm dd, yyyy",
      "Medium Date": table_fmt[15],
      "Short Date": table_fmt[14],
      "Long Time": table_fmt[19],
      "Medium Time": table_fmt[18],
      "Short Time": table_fmt[20],
      "Currency": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
      "Fixed": table_fmt[2],
      "Standard": table_fmt[4],
      "Percent": table_fmt[10],
      "Scientific": table_fmt[11],
      "Yes/No": '"Yes";"Yes";"No";@',
      "True/False": '"True";"True";"False";@',
      "On/Off": '"Yes";"Yes";"No";@'
    };
    var Rn;
    var state = [], tmp;
    var sheets = {}, sheetnames = [], cursheet = {}, sheetname = "";
    if (opts.dense) cursheet["!data"] = [];
    var cell = {}, row = {};
    var dtag = xlml_parsexmltag('<Data ss:Type="String">'), didx = 0;
    var c = 0, r2 = 0;
    var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
    var styles = {}, stag = {};
    var ss = "", fidx = 0;
    var merges = [];
    var Props = {}, Custprops = {}, pidx = 0, cp = [];
    var comments = [], comment = {};
    var cstys = [], csty, seencol = false;
    var arrayf = [];
    var rowinfo = [], rowobj = {}, cc = 0, rr = 0;
    var Workbook = { Sheets: [], WBProps: { date1904: false } }, wsprops = {};
    xlmlregex.lastIndex = 0;
    str = str_remove_ng(str, "<!--", "-->");
    var raw_Rn3 = "";
    while (Rn = xlmlregex.exec(str)) switch (Rn[3] = (raw_Rn3 = Rn[3]).toLowerCase()) {
      case "data":
        if (raw_Rn3 == "data") {
          if (Rn[1] === "/") {
            if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
          } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], true]);
          break;
        }
        if (state[state.length - 1][1]) break;
        if (Rn[1] === "/") parse_xlml_data(str.slice(didx, Rn.index), ss, dtag, state[state.length - 1][0] ==
"comment" ? comment : cell, { c, r: r2 }, styles, cstys[c], row, arrayf, opts, Workbook.WBProps.date1904);
        else {
          ss = "";
          dtag = xlml_parsexmltag(Rn[0]);
          didx = Rn.index + Rn[0].length;
        }
        break;
      case "cell":
        if (Rn[1] === "/") {
          if (comments.length > 0) cell.c = comments;
          if ((!opts.sheetRows || opts.sheetRows > r2) && cell.v !== void 0) {
            if (opts.dense) {
              if (!cursheet["!data"][r2]) cursheet["!data"][r2] = [];
              cursheet["!data"][r2][c] = cell;
            } else cursheet[encode_col(c) + encode_row(r2)] = cell;
          }
          if (cell.HRef) {
            cell.l = { Target: unescapexml(cell.HRef) };
            if (cell.HRefScreenTip) cell.l.Tooltip = cell.HRefScreenTip;
            delete cell.HRef;
            delete cell.HRefScreenTip;
          }
          if (cell.MergeAcross || cell.MergeDown) {
            cc = c + (parseInt(cell.MergeAcross, 10) | 0);
            rr = r2 + (parseInt(cell.MergeDown, 10) | 0);
            if (cc > c || rr > r2) merges.push({ s: { c, r: r2 }, e: { c: cc, r: rr } });
          }
          if (!opts.sheetStubs) {
            if (cell.MergeAcross) c = cc + 1;
            else ++c;
          } else if (cell.MergeAcross || cell.MergeDown) {
            for (var cma = c; cma <= cc; ++cma) {
              for (var cmd = r2; cmd <= rr; ++cmd) {
                if (cma > c || cmd > r2) {
                  if (opts.dense) {
                    if (!cursheet["!data"][cmd]) cursheet["!data"][cmd] = [];
                    cursheet["!data"][cmd][cma] = { t: "z" };
                  } else cursheet[encode_col(cma) + encode_row(cmd)] = { t: "z" };
                }
              }
            }
            c = cc + 1;
          } else ++c;
        } else {
          cell = xlml_parsexmltagobj(Rn[0]);
          if (cell.Index) c = +cell.Index - 1;
          if (c < refguess.s.c) refguess.s.c = c;
          if (c > refguess.e.c) refguess.e.c = c;
          if (Rn[0].slice(-2) === "/>") ++c;
          comments = [];
        }
        break;
      case "row":
        if (Rn[1] === "/" || Rn[0].slice(-2) === "/>") {
          if (r2 < refguess.s.r) refguess.s.r = r2;
          if (r2 > refguess.e.r) refguess.e.r = r2;
          if (Rn[0].slice(-2) === "/>") {
            row = xlml_parsexmltag(Rn[0]);
            if (row.Index) r2 = +row.Index - 1;
          }
          c = 0;
          ++r2;
        } else {
          row = xlml_parsexmltag(Rn[0]);
          if (row.Index) r2 = +row.Index - 1;
          rowobj = {};
          if (row.AutoFitHeight == "0" || row.Height) {
            rowobj.hpx = parseInt(row.Height, 10);
            rowobj.hpt = px2pt(rowobj.hpx);
            rowinfo[r2] = rowobj;
          }
          if (row.Hidden == "1") {
            rowobj.hidden = true;
            rowinfo[r2] = rowobj;
          }
        }
        break;
      case "worksheet":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
          sheetnames.push(sheetname);
          if (refguess.s.r <= refguess.e.r && refguess.s.c <= refguess.e.c) {
            cursheet["!ref"] = encode_range(refguess);
            if (opts.sheetRows && opts.sheetRows <= refguess.e.r) {
              cursheet["!fullref"] = cursheet["!ref"];
              refguess.e.r = opts.sheetRows - 1;
              cursheet["!ref"] = encode_range(refguess);
            }
          }
          if (merges.length) cursheet["!merges"] = merges;
          if (cstys.length > 0) cursheet["!cols"] = cstys;
          if (rowinfo.length > 0) cursheet["!rows"] = rowinfo;
          sheets[sheetname] = cursheet;
        } else {
          refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
          r2 = c = 0;
          state.push([Rn[3], false]);
          tmp = xlml_parsexmltag(Rn[0]);
          sheetname = unescapexml(tmp.Name);
          cursheet = {};
          if (opts.dense) cursheet["!data"] = [];
          merges = [];
          arrayf = [];
          rowinfo = [];
          wsprops = { name: sheetname, Hidden: 0 };
          Workbook.Sheets.push(wsprops);
        }
        break;
      case "table":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
        } else if (Rn[0].slice(-2) == "/>") break;
        else {
          state.push([Rn[3], false]);
          cstys = [];
          seencol = false;
        }
        break;
      case "style":
        if (Rn[1] === "/") process_style_xlml(styles, stag, opts);
        else stag = xlml_parsexmltag(Rn[0]);
        break;
      case "numberformat":
        stag.nf = unescapexml(xlml_parsexmltag(Rn[0]).Format || "General");
        if (XLMLFormatMap[stag.nf]) stag.nf = XLMLFormatMap[stag.nf];
        for (var ssfidx = 0; ssfidx != 392; ++ssfidx) if (table_fmt[ssfidx] == stag.nf) break;
        if (ssfidx == 392) {
          for (ssfidx = 57; ssfidx != 392; ++ssfidx) if (table_fmt[ssfidx] == null) {
            SSF__load(stag.nf, ssfidx);
            break;
          }
        }
        break;
      case "column":
        if (state[state.length - 1][0] !==
"table") break;
        if (Rn[1] === "/") break;
        csty = xlml_parsexmltag(Rn[0]);
        if (csty.Hidden) {
          csty.hidden = true;
          delete csty.Hidden;
        }
        if (csty.Width) csty.wpx = parseInt(csty.Width, 10);
        if (!seencol && csty.wpx > 10) {
          seencol = true;
          MDW = DEF_MDW;
          for (var _col = 0; _col < cstys.length; ++_col) if (cstys[_col]) process_col(cstys[_col]);
        }
        if (seencol) process_col(csty);
        cstys[csty.Index - 1 || cstys.length] = csty;
        for (var i = 0; i < +csty.Span; ++i) cstys[cstys.length] = dup(csty);
        break;
      case "namedrange":
        if (Rn[1] === "/") break;
        if (!Workbook.Names) Workbook.Names = [];
        var _NamedRange = parsexmltag(Rn[0]);
        var _DefinedName = {
          Name: xlml_prefix_dname(_NamedRange.Name),
          Ref: rc_to_a1(_NamedRange.RefersTo.slice(1), { r: 0, c: 0 })
        };
        if (Workbook.Sheets.length > 0) _DefinedName.Sheet = Workbook.Sheets.length - 1;
        Workbook.Names.push(_DefinedName);
        break;
      case "namedcell":
        break;
      case "b":
        break;
      case "i":
        break;
      case "u":
        break;
      case "s":
        break;
      case "em":
        break;
      case "h2":
        break;
      case "h3":
        break;
      case "sub":
        break;
      case "sup":
        break;
      case "span":
        break;
      case "alignment":
        break;
      case "borders":
        break;
      case "border":
        break;
      case "font":
        if (Rn[0].slice(-2) === "/>") break;
        else if (Rn[1] === "/") ss += str.slice(fidx, Rn.index);
        else fidx = Rn.index + Rn[0].length;
        break;
      case "interior":
        if (!opts.cellStyles) break;
        stag.Interior = xlml_parsexmltag(Rn[0]);
        break;
      case "protection":
        break;
      case "author":
      case "title":
      case "description":
      case "created":
      case "keywords":
      case "subject":
      case "category":
      case "company":
      case "lastauthor":
      case "lastsaved":
      case "lastprinted":
      case "version":
      case "revision":
      case "totaltime":
      case "hyperlinkbase":
      case "manager":
      case "contentstatus":
      case "identifier":
      case "language":
      case "appname":
        if (Rn[0].slice(-2) === "/>") break;
        else if (Rn[1] === "/") xlml_set_prop(Props, raw_Rn3, str.slice(pidx, Rn.index));
        else pidx = Rn.index + Rn[0].length;
        break;
      case "paragraphs":
        break;
      case "styles":
      case "workbook":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
        } else state.push([Rn[3], false]);
        break;
      case "comment":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
          xlml_clean_comment(comment);
          comments.push(comment);
        } else {
          state.push([Rn[3], false]);
          tmp = xlml_parsexmltag(Rn[0]);
          if (!parsexmlbool(tmp["ShowAlways"] || "0")) comments.hidden = true;
          comment = { a: tmp.Author };
        }
        break;
      case "autofilter":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          var AutoFilter = xlml_parsexmltag(Rn[0]);
          cursheet["!autofilter"] = { ref: rc_to_a1(AutoFilter.Range).replace(/\$/g, "") };
          state.push([Rn[3], true]);
        }
        break;
      case "name":
        break;
      case "datavalidation":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
        } else {
          if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], true]);
        }
        break;
      case "pixelsperinch":
        break;
      case "componentoptions":
      case "documentproperties":
      case "customdocumentproperties":
      case "officedocumentsettings":
      case "pivottable":
      case "pivotcache":
      case "names":
      case "mapinfo":
      case "pagebreaks":
      case "querytable":
      case "sorting":
      case "schema":
case "conditionalformatting":
      case "smarttagtype":
      case "smarttags":
      case "excelworkbook":
      case "workbookoptions":
      case "worksheetoptions":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], true]);
        break;
      case "null":
        break;
      default:
        if (state.length == 0 && Rn[3] == "document") return parse_fods(str, opts);
        if (state.length == 0 && Rn[3] == "uof") return parse_fods(str, opts);
        var seen = true;
        switch (state[state.length - 1][0]) {
case "officedocumentsettings":
            switch (Rn[3]) {
              case "allowpng":
                break;
              case "removepersonalinformation":
                break;
              case "downloadcomponents":
                break;
              case "locationofcomponents":
                break;
              case "colors":
                break;
              case "color":
                break;
              case "index":
                break;
              case "rgb":
                break;
              case "targetscreensize":
                break;
              case "readonlyrecommended":
                break;
              default:
                seen = false;
            }
            break;
case "componentoptions":
            switch (Rn[3]) {
              case "toolbar":
                break;
              case "hideofficelogo":
                break;
              case "spreadsheetautofit":
                break;
              case "label":
                break;
              case "caption":
                break;
              case "maxheight":
                break;
              case "maxwidth":
                break;
              case "nextsheetnumber":
                break;
              default:
                seen = false;
            }
            break;
case "excelworkbook":
            switch (Rn[3]) {
              case "date1904":
                Workbook.WBProps.date1904 = true;
                break;
              case "hidehorizontalscrollbar":
                break;
              case "hideverticalscrollbar":
                break;
              case "hideworkbooktabs":
                break;
              case "windowheight":
                break;
              case "windowwidth":
                break;
              case "windowtopx":
                break;
              case "windowtopy":
                break;
              case "tabratio":
                break;
              case "protectstructure":
                break;
              case "protectwindow":
                break;
              case "protectwindows":
                break;
              case "activesheet":
                break;
              case "displayinknotes":
                break;
              case "firstvisiblesheet":
                break;
              case "supbook":
                break;
              case "sheetname":
                break;
              case "sheetindex":
                break;
              case "sheetindexfirst":
                break;
              case "sheetindexlast":
                break;
              case "dll":
                break;
              case "acceptlabelsinformulas":
                break;
              case "donotsavelinkvalues":
                break;
              case "iteration":
                break;
              case "maxiterations":
                break;
              case "maxchange":
                break;
              case "path":
                break;
              case "xct":
                break;
              case "count":
                break;
              case "selectedsheets":
                break;
              case "calculation":
                break;
              case "uncalced":
                break;
              case "startupprompt":
                break;
              case "crn":
                break;
              case "externname":
                break;
              case "formula":
                break;
              case "colfirst":
                break;
              case "collast":
                break;
              case "wantadvise":
                break;
              case "boolean":
                break;
              case "error":
                break;
              case "text":
                break;
              case "ole":
                break;
              case "noautorecover":
                break;
              case "publishobjects":
                break;
              case "donotcalculatebeforesave":
                break;
              case "number":
                break;
              case "refmoder1c1":
                break;
              case "embedsavesmarttags":
                break;
              default:
                seen = false;
            }
            break;
case "workbookoptions":
            switch (Rn[3]) {
              case "owcversion":
                break;
              case "height":
                break;
              case "width":
                break;
              default:
                seen = false;
            }
            break;
case "worksheetoptions":
            switch (Rn[3]) {
              case "visible":
                if (Rn[0].slice(-2) === "/>") ;
                else if (Rn[1] === "/") switch (str.slice(pidx, Rn.index)) {
                  case "SheetHidden":
                    wsprops.Hidden = 1;
                    break;
                  case "SheetVeryHidden":
                    wsprops.Hidden = 2;
                    break;
                }
                else pidx = Rn.index + Rn[0].length;
                break;
              case "header":
                if (!cursheet["!margins"]) default_margins(cursheet["!margins"] = {}, "xlml");
                if (!isNaN(+parsexmltag(Rn[0]).Margin)) cursheet["!margins"].header = +parsexmltag(Rn[0]).Margin;
                break;
              case "footer":
                if (!cursheet["!margins"]) default_margins(cursheet["!margins"] = {}, "xlml");
                if (!isNaN(+parsexmltag(Rn[0]).Margin)) cursheet["!margins"].footer = +parsexmltag(Rn[0]).Margin;
                break;
              case "pagemargins":
                var pagemargins = parsexmltag(Rn[0]);
                if (!cursheet["!margins"]) default_margins(cursheet["!margins"] = {}, "xlml");
                if (!isNaN(+pagemargins.Top)) cursheet["!margins"].top = +pagemargins.Top;
                if (!isNaN(+pagemargins.Left)) cursheet["!margins"].left = +pagemargins.Left;
                if (!isNaN(+pagemargins.Right)) cursheet["!margins"].right = +pagemargins.Right;
                if (!isNaN(+pagemargins.Bottom)) cursheet["!margins"].bottom = +pagemargins.Bottom;
                break;
              case "displayrighttoleft":
                if (!Workbook.Views) Workbook.Views = [];
                if (!Workbook.Views[0]) Workbook.Views[0] = {};
                Workbook.Views[0].RTL = true;
                break;
              case "freezepanes":
                break;
              case "frozennosplit":
                break;
              case "splithorizontal":
              case "splitvertical":
                break;
              case "donotdisplaygridlines":
                break;
              case "activerow":
                break;
              case "activecol":
                break;
              case "toprowbottompane":
                break;
              case "leftcolumnrightpane":
                break;
              case "unsynced":
                break;
              case "print":
                break;
              case "printerrors":
                break;
              case "panes":
                break;
              case "scale":
                break;
              case "pane":
                break;
              case "number":
                break;
              case "layout":
                break;
              case "pagesetup":
                break;
              case "selected":
                break;
              case "protectobjects":
                break;
              case "enableselection":
                break;
              case "protectscenarios":
                break;
              case "validprinterinfo":
                break;
              case "horizontalresolution":
                break;
              case "verticalresolution":
                break;
              case "numberofcopies":
                break;
              case "activepane":
                break;
              case "toprowvisible":
                break;
              case "leftcolumnvisible":
                break;
              case "fittopage":
                break;
              case "rangeselection":
                break;
              case "papersizeindex":
                break;
              case "pagelayoutzoom":
                break;
              case "pagebreakzoom":
                break;
              case "filteron":
                break;
              case "fitwidth":
                break;
              case "fitheight":
                break;
              case "commentslayout":
                break;
              case "zoom":
                break;
              case "lefttoright":
                break;
              case "gridlines":
                break;
              case "allowsort":
                break;
              case "allowfilter":
                break;
              case "allowinsertrows":
                break;
              case "allowdeleterows":
                break;
              case "allowinsertcols":
                break;
              case "allowdeletecols":
                break;
              case "allowinserthyperlinks":
                break;
              case "allowformatcells":
                break;
              case "allowsizecols":
                break;
              case "allowsizerows":
                break;
              case "nosummaryrowsbelowdetail":
                if (!cursheet["!outline"]) cursheet["!outline"] = {};
                cursheet["!outline"].above = true;
                break;
              case "tabcolorindex":
                break;
              case "donotdisplayheadings":
                break;
              case "showpagelayoutzoom":
                break;
              case "nosummarycolumnsrightdetail":
                if (!cursheet["!outline"]) cursheet["!outline"] = {};
                cursheet["!outline"].left = true;
                break;
              case "blackandwhite":
                break;
              case "donotdisplayzeros":
                break;
              case "displaypagebreak":
                break;
              case "rowcolheadings":
                break;
              case "donotdisplayoutline":
                break;
              case "noorientation":
                break;
              case "allowusepivottables":
                break;
              case "zeroheight":
                break;
              case "viewablerange":
                break;
              case "selection":
                break;
              case "protectcontents":
                break;
              default:
                seen = false;
            }
            break;
case "pivottable":
          case "pivotcache":
            switch (Rn[3]) {
              case "immediateitemsondrop":
                break;
              case "showpagemultipleitemlabel":
                break;
              case "compactrowindent":
                break;
              case "location":
                break;
              case "pivotfield":
                break;
              case "orientation":
                break;
              case "layoutform":
                break;
              case "layoutsubtotallocation":
                break;
              case "layoutcompactrow":
                break;
              case "position":
                break;
              case "pivotitem":
                break;
              case "datatype":
                break;
              case "datafield":
                break;
              case "sourcename":
                break;
              case "parentfield":
                break;
              case "ptlineitems":
                break;
              case "ptlineitem":
                break;
              case "countofsameitems":
                break;
              case "item":
                break;
              case "itemtype":
                break;
              case "ptsource":
                break;
              case "cacheindex":
                break;
              case "consolidationreference":
                break;
              case "filename":
                break;
              case "reference":
                break;
              case "nocolumngrand":
                break;
              case "norowgrand":
                break;
              case "blanklineafteritems":
                break;
              case "hidden":
                break;
              case "subtotal":
                break;
              case "basefield":
                break;
              case "mapchilditems":
                break;
              case "function":
                break;
              case "refreshonfileopen":
                break;
              case "printsettitles":
                break;
              case "mergelabels":
                break;
              case "defaultversion":
                break;
              case "refreshname":
                break;
              case "refreshdate":
                break;
              case "refreshdatecopy":
                break;
              case "versionlastrefresh":
                break;
              case "versionlastupdate":
                break;
              case "versionupdateablemin":
                break;
              case "versionrefreshablemin":
                break;
              case "calculation":
                break;
              default:
                seen = false;
            }
            break;
case "pagebreaks":
            switch (Rn[3]) {
              case "colbreaks":
                break;
              case "colbreak":
                break;
              case "rowbreaks":
                break;
              case "rowbreak":
                break;
              case "colstart":
                break;
              case "colend":
                break;
              case "rowend":
                break;
              default:
                seen = false;
            }
            break;
case "autofilter":
            switch (Rn[3]) {
              case "autofiltercolumn":
                break;
              case "autofiltercondition":
                break;
              case "autofilterand":
                break;
              case "autofilteror":
                break;
              default:
                seen = false;
            }
            break;
case "querytable":
            switch (Rn[3]) {
              case "id":
                break;
              case "autoformatfont":
                break;
              case "autoformatpattern":
                break;
              case "querysource":
                break;
              case "querytype":
                break;
              case "enableredirections":
                break;
              case "refreshedinxl9":
                break;
              case "urlstring":
                break;
              case "htmltables":
                break;
              case "connection":
                break;
              case "commandtext":
                break;
              case "refreshinfo":
                break;
              case "notitles":
                break;
              case "nextid":
                break;
              case "columninfo":
                break;
              case "overwritecells":
                break;
              case "donotpromptforfile":
                break;
              case "textwizardsettings":
                break;
              case "source":
                break;
              case "number":
                break;
              case "decimal":
                break;
              case "thousandseparator":
                break;
              case "trailingminusnumbers":
                break;
              case "formatsettings":
                break;
              case "fieldtype":
                break;
              case "delimiters":
                break;
              case "tab":
                break;
              case "comma":
                break;
              case "autoformatname":
                break;
              case "versionlastedit":
                break;
              case "versionlastrefresh":
                break;
              default:
                seen = false;
            }
            break;
          case "datavalidation":
            switch (Rn[3]) {
              case "range":
                break;
              case "type":
                break;
              case "min":
                break;
              case "max":
                break;
              case "sort":
                break;
              case "descending":
                break;
              case "order":
                break;
              case "casesensitive":
                break;
              case "value":
                break;
              case "errorstyle":
                break;
              case "errormessage":
                break;
              case "errortitle":
                break;
              case "inputmessage":
                break;
              case "inputtitle":
                break;
              case "combohide":
                break;
              case "inputhide":
                break;
              case "condition":
                break;
              case "qualifier":
                break;
              case "useblank":
                break;
              case "value1":
                break;
              case "value2":
                break;
              case "format":
                break;
              case "cellrangelist":
                break;
              default:
                seen = false;
            }
            break;
          case "sorting":
          case "conditionalformatting":
            switch (Rn[3]) {
              case "range":
                break;
              case "type":
                break;
              case "min":
                break;
              case "max":
                break;
              case "sort":
                break;
              case "descending":
                break;
              case "order":
                break;
              case "casesensitive":
                break;
              case "value":
                break;
              case "errorstyle":
                break;
              case "errormessage":
                break;
              case "errortitle":
                break;
              case "cellrangelist":
                break;
              case "inputmessage":
                break;
              case "inputtitle":
                break;
              case "combohide":
                break;
              case "inputhide":
                break;
              case "condition":
                break;
              case "qualifier":
                break;
              case "useblank":
                break;
              case "value1":
                break;
              case "value2":
                break;
              case "format":
                break;
              default:
                seen = false;
            }
            break;
case "mapinfo":
          case "schema":
          case "data":
            switch (Rn[3]) {
              case "map":
                break;
              case "entry":
                break;
              case "range":
                break;
              case "xpath":
                break;
              case "field":
                break;
              case "xsdtype":
                break;
              case "filteron":
                break;
              case "aggregate":
                break;
              case "elementtype":
                break;
              case "attributetype":
                break;
case "schema":
              case "element":
              case "complextype":
              case "datatype":
              case "all":
              case "attribute":
              case "extends":
                break;
              case "row":
                break;
              default:
                seen = false;
            }
            break;
case "smarttags":
            break;
          default:
            seen = false;
            break;
        }
        if (seen) break;
        if (Rn[3].match(/!\[CDATA/)) break;
        if (!state[state.length - 1][1]) throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|");
        if (state[state.length - 1][0] ===
"customdocumentproperties") {
          if (Rn[0].slice(-2) === "/>") break;
          else if (Rn[1] === "/") xlml_set_custprop(Custprops, raw_Rn3, cp, str.slice(pidx, Rn.index));
          else {
            cp = Rn;
            pidx = Rn.index + Rn[0].length;
          }
          break;
        }
        if (opts.WTF) throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|");
    }
    var out = {};
    if (!opts.bookSheets && !opts.bookProps) out.Sheets = sheets;
    out.SheetNames = sheetnames;
    out.Workbook = Workbook;
    out.SSF = dup(table_fmt);
    out.Props = Props;
    out.Custprops = Custprops;
    out.bookType = "xlml";
    return out;
  }
  function parse_xlml(data, opts) {
    fix_read_opts(opts = opts || {});
    switch (opts.type || "base64") {
      case "base64":
        return parse_xlml_xml(Base64_decode(data), opts);
      case "binary":
      case "buffer":
      case "file":
        return parse_xlml_xml(data, opts);
      case "array":
        return parse_xlml_xml(a2s(data), opts);
    }
  }
  function write_props_xlml(wb, opts) {
    var o = [];
    if (wb.Props) o.push(xlml_write_docprops(wb.Props, opts));
    if (wb.Custprops) o.push(xlml_write_custprops(wb.Props, wb.Custprops));
    return o.join("");
  }
  function write_wb_xlml(wb) {
    if ((((wb || {}).Workbook || {}).WBProps || {}).date1904) return '<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel"><Date1904/></ExcelWorkbook>';
    return "";
  }
  function write_sty_xlml(wb, opts) {
    var styles = ['<Style ss:ID="Default" ss:Name="Normal"><NumberFormat/></Style>'];
    opts.cellXfs.forEach(function(xf, id) {
      var payload = [];
      payload.push(writextag("NumberFormat", null, { "ss:Format": escapexml(table_fmt[xf.numFmtId]) }));
      var o = (
{ "ss:ID": "s" + (21 + id) }
      );
      styles.push(writextag("Style", payload.join(""), o));
    });
    return writextag("Styles", styles.join(""));
  }
  function write_name_xlml(n) {
    return writextag("NamedRange", null, { "ss:Name": n.Name.slice(0, 6) == "_xlnm." ? n.Name.slice(6) : n.Name, "ss:RefersTo": "=" + a1_to_rc(n.Ref, { r: 0, c: 0 }) });
  }
  function write_names_xlml(wb) {
    if (!((wb || {}).Workbook || {}).Names) return "";
    var names = wb.Workbook.Names;
    var out = [];
    for (var i = 0; i < names.length; ++i) {
      var n = names[i];
      if (n.Sheet != null) continue;
      if (n.Name.match(/^_xlfn\./)) continue;
      out.push(write_name_xlml(n));
    }
    return writextag("Names", out.join(""));
  }
  function write_ws_xlml_names(ws, opts, idx, wb) {
    if (!ws) return "";
    if (!((wb || {}).Workbook || {}).Names) return "";
    var names = wb.Workbook.Names;
    var out = [];
    for (var i = 0; i < names.length; ++i) {
      var n = names[i];
      if (n.Sheet != idx) continue;
      if (n.Name.match(/^_xlfn\./)) continue;
      out.push(write_name_xlml(n));
    }
    return out.join("");
  }
  function write_ws_xlml_wsopts(ws, opts, idx, wb) {
    if (!ws) return "";
    var o = [];
    if (ws["!margins"]) {
      o.push("<PageSetup>");
      if (ws["!margins"].header) o.push(writextag("Header", null, { "x:Margin": ws["!margins"].header }));
      if (ws["!margins"].footer) o.push(writextag("Footer", null, { "x:Margin": ws["!margins"].footer }));
      o.push(writextag("PageMargins", null, {
        "x:Bottom": ws["!margins"].bottom || "0.75",
        "x:Left": ws["!margins"].left || "0.7",
        "x:Right": ws["!margins"].right || "0.7",
        "x:Top": ws["!margins"].top || "0.75"
      }));
      o.push("</PageSetup>");
    }
    if (wb && wb.Workbook && wb.Workbook.Sheets && wb.Workbook.Sheets[idx]) {
      if (wb.Workbook.Sheets[idx].Hidden) o.push(writextag("Visible", wb.Workbook.Sheets[idx].Hidden == 1 ? "SheetHidden" : "SheetVeryHidden", {}));
      else {
        for (var i = 0; i < idx; ++i) if (wb.Workbook.Sheets[i] && !wb.Workbook.Sheets[i].Hidden) break;
        if (i == idx) o.push("<Selected/>");
      }
    }
    if (((((wb || {}).Workbook || {}).Views || [])[0] || {}).RTL) o.push("<DisplayRightToLeft/>");
    if (ws["!protect"]) {
      o.push(writetag("ProtectContents", "True"));
      if (ws["!protect"].objects) o.push(writetag("ProtectObjects", "True"));
      if (ws["!protect"].scenarios) o.push(writetag("ProtectScenarios", "True"));
      if (ws["!protect"].selectLockedCells != null && !ws["!protect"].selectLockedCells) o.push(writetag("EnableSelection", "NoSelection"));
      else if (ws["!protect"].selectUnlockedCells != null && !ws["!protect"].selectUnlockedCells) o.push(writetag("EnableSelection", "UnlockedCells"));
      [
        ["formatCells", "AllowFormatCells"],
        ["formatColumns", "AllowSizeCols"],
        ["formatRows", "AllowSizeRows"],
        ["insertColumns", "AllowInsertCols"],
        ["insertRows", "AllowInsertRows"],
        ["insertHyperlinks", "AllowInsertHyperlinks"],
        ["deleteColumns", "AllowDeleteCols"],
        ["deleteRows", "AllowDeleteRows"],
        ["sort", "AllowSort"],
        ["autoFilter", "AllowFilter"],
        ["pivotTables", "AllowUsePivotTables"]
      ].forEach(function(x) {
        if (ws["!protect"][x[0]]) o.push("<" + x[1] + "/>");
      });
    }
    if (o.length == 0) return "";
    return writextag("WorksheetOptions", o.join(""), { xmlns: XLMLNS.x });
  }
  function write_ws_xlml_comment(comments) {
    return comments.map(function(c) {
      var t = xlml_unfixstr(c.t || "");
      var d = writextag("ss:Data", t, { "xmlns": "http://www.w3.org/TR/REC-html40" });
      var p2 = {};
      if (c.a) p2["ss:Author"] = c.a;
      if (!comments.hidden) p2["ss:ShowAlways"] = "1";
      return writextag("Comment", d, p2);
    }).join("");
  }
  function write_ws_xlml_cell(cell, ref2, ws, opts, idx, wb, addr) {
    if (!cell || cell.v == void 0 && cell.f == void 0) return "";
    var attr = {};
    if (cell.f) attr["ss:Formula"] = "=" + escapexml(a1_to_rc(cell.f, addr));
    if (cell.F && cell.F.slice(0, ref2.length) == ref2) {
      var end = decode_cell(cell.F.slice(ref2.length + 1));
      attr["ss:ArrayRange"] = "RC:R" + (end.r == addr.r ? "" : "[" + (end.r - addr.r) + "]") + "C" + (end.c == addr.c ? "" : "[" + (end.c - addr.c) + "]");
    }
    if (cell.l && cell.l.Target) {
      attr["ss:HRef"] = escapexml(cell.l.Target);
      if (cell.l.Tooltip) attr["x:HRefScreenTip"] = escapexml(cell.l.Tooltip);
    }
    if (ws["!merges"]) {
      var marr = ws["!merges"];
      for (var mi = 0; mi != marr.length; ++mi) {
        if (marr[mi].s.c != addr.c || marr[mi].s.r != addr.r) continue;
        if (marr[mi].e.c > marr[mi].s.c) attr["ss:MergeAcross"] = marr[mi].e.c - marr[mi].s.c;
        if (marr[mi].e.r > marr[mi].s.r) attr["ss:MergeDown"] = marr[mi].e.r - marr[mi].s.r;
      }
    }
    var t = "", p2 = "";
    switch (cell.t) {
      case "z":
        if (!opts.sheetStubs) return "";
        break;
      case "n":
        {
          if (!isFinite(cell.v)) {
            t = "Error";
            p2 = BErr[isNaN(cell.v) ? 36 : 7];
          } else {
            t = "Number";
            p2 = String(cell.v);
          }
        }
        break;
      case "b":
        t = "Boolean";
        p2 = cell.v ? "1" : "0";
        break;
      case "e":
        t = "Error";
        p2 = BErr[cell.v];
        break;
      case "d":
        t = "DateTime";
        p2 = new Date(cell.v).toISOString();
        if (cell.z == null) cell.z = cell.z || table_fmt[14];
        break;
      case "s":
        t = "String";
        p2 = escapexlml(cell.v || "");
        break;
    }
    var os = get_cell_style(opts.cellXfs, cell, opts);
    attr["ss:StyleID"] = "s" + (21 + os);
    attr["ss:Index"] = addr.c + 1;
    var _v = cell.v != null ? p2 : "";
    var m = cell.t == "z" ? "" : '<Data ss:Type="' + t + '">' + _v + "</Data>";
    if ((cell.c || []).length > 0) m += write_ws_xlml_comment(cell.c);
    return writextag("Cell", m, attr);
  }
  function write_ws_xlml_row(R, row) {
    var o = '<Row ss:Index="' + (R + 1) + '"';
    if (row) {
      if (row.hpt && !row.hpx) row.hpx = pt2px(row.hpt);
      if (row.hpx) o += ' ss:AutoFitHeight="0" ss:Height="' + row.hpx + '"';
      if (row.hidden) o += ' ss:Hidden="1"';
    }
    return o + ">";
  }
  function write_ws_xlml_table(ws, opts, idx, wb) {
    if (!ws["!ref"]) return "";
    var range = safe_decode_range(ws["!ref"]);
    var marr = ws["!merges"] || [], mi = 0;
    var o = [];
    if (ws["!cols"]) ws["!cols"].forEach(function(n, i) {
      process_col(n);
      var w = !!n.width;
      var p2 = col_obj_w(i, n);
      var k = { "ss:Index": i + 1 };
      if (w) k["ss:Width"] = width2px(p2.width);
      if (n.hidden) k["ss:Hidden"] = "1";
      o.push(writextag("Column", null, k));
    });
    var dense = ws["!data"] != null;
    var addr = { r: 0, c: 0 };
    for (var R = range.s.r; R <= range.e.r; ++R) {
      var row = [write_ws_xlml_row(R, (ws["!rows"] || [])[R])];
      addr.r = R;
      for (var C = range.s.c; C <= range.e.c; ++C) {
        addr.c = C;
        var skip = false;
        for (mi = 0; mi != marr.length; ++mi) {
          if (marr[mi].s.c > C) continue;
          if (marr[mi].s.r > R) continue;
          if (marr[mi].e.c < C) continue;
          if (marr[mi].e.r < R) continue;
          if (marr[mi].s.c != C || marr[mi].s.r != R) skip = true;
          break;
        }
        if (skip) continue;
        var ref2 = encode_col(C) + encode_row(R), cell = dense ? (ws["!data"][R] || [])[C] : ws[ref2];
        row.push(write_ws_xlml_cell(cell, ref2, ws, opts, idx, wb, addr));
      }
      row.push("</Row>");
      if (row.length > 2) o.push(row.join(""));
    }
    return o.join("");
  }
  function write_ws_xlml(idx, opts, wb) {
    var o = [];
    var s = wb.SheetNames[idx];
    var ws = wb.Sheets[s];
    var t = ws ? write_ws_xlml_names(ws, opts, idx, wb) : "";
    if (t.length > 0) o.push("<Names>" + t + "</Names>");
    t = ws ? write_ws_xlml_table(ws, opts, idx, wb) : "";
    if (t.length > 0) o.push("<Table>" + t + "</Table>");
    o.push(write_ws_xlml_wsopts(ws, opts, idx, wb));
    if (ws && ws["!autofilter"]) o.push('<AutoFilter x:Range="' + a1_to_rc(fix_range(ws["!autofilter"].ref), { r: 0, c: 0 }) + '" xmlns="urn:schemas-microsoft-com:office:excel"></AutoFilter>');
    return o.join("");
  }
  function write_xlml(wb, opts) {
    if (!opts) opts = {};
    if (!wb.SSF) wb.SSF = dup(table_fmt);
    if (wb.SSF) {
      make_ssf();
      SSF_load_table(wb.SSF);
      opts.revssf = evert_num(wb.SSF);
      opts.revssf[wb.SSF[65535]] = 0;
      opts.ssf = wb.SSF;
      opts.cellXfs = [];
      get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
    }
    var d = [];
    d.push(write_props_xlml(wb, opts));
    d.push(write_wb_xlml(wb));
    d.push("");
    d.push(write_names_xlml(wb));
    for (var i = 0; i < wb.SheetNames.length; ++i)
      d.push(writextag("Worksheet", write_ws_xlml(i, opts, wb), { "ss:Name": escapexml(wb.SheetNames[i]) }));
    d[2] = write_sty_xlml(wb, opts);
    return XML_HEADER + writextag("Workbook", d.join(""), {
      "xmlns": XLMLNS.ss,
      "xmlns:o": XLMLNS.o,
      "xmlns:x": XLMLNS.x,
      "xmlns:ss": XLMLNS.ss,
      "xmlns:dt": XLMLNS.dt,
      "xmlns:html": XLMLNS.html
    });
  }
  function parse_compobj(obj) {
    var v = {};
    var o = obj.content;
    o.l = 28;
    v.AnsiUserType = o.read_shift(0, "lpstr-ansi");
    v.AnsiClipboardFormat = parse_ClipboardFormatOrAnsiString(o);
    if (o.length - o.l <= 4) return v;
    var m = o.read_shift(4);
    if (m == 0 || m > 40) return v;
    o.l -= 4;
    v.Reserved1 = o.read_shift(0, "lpstr-ansi");
    if (o.length - o.l <= 4) return v;
    m = o.read_shift(4);
    if (m !== 1907505652) return v;
    v.UnicodeClipboardFormat = parse_ClipboardFormatOrUnicodeString(o);
    m = o.read_shift(4);
    if (m == 0 || m > 40) return v;
    o.l -= 4;
    v.Reserved2 = o.read_shift(0, "lpwstr");
  }
  var CONTINUE_RT = [60, 1084, 2066, 2165, 2175];
  function slurp(RecordType, R, blob, length, opts) {
    var l = length;
    var bufs = [];
    var d = blob.slice(blob.l, blob.l + l);
    if (opts && opts.enc && opts.enc.insitu && d.length > 0) switch (RecordType) {
      case 9:
      case 521:
      case 1033:
      case 2057:
      case 47:
      case 405:
      case 225:
      case 406:
      case 312:
      case 404:
      case 10:
        break;
      case 133:
        break;
      default:
        opts.enc.insitu(d);
    }
    bufs.push(d);
    blob.l += l;
    var nextrt = __readUInt16LE(blob, blob.l), next = XLSRecordEnum[nextrt];
    var start = 0;
    while (next != null && CONTINUE_RT.indexOf(nextrt) > -1) {
      l = __readUInt16LE(blob, blob.l + 2);
      start = blob.l + 4;
      if (nextrt == 2066) start += 4;
      else if (nextrt == 2165 || nextrt == 2175) {
        start += 12;
      }
      d = blob.slice(start, blob.l + 4 + l);
      bufs.push(d);
      blob.l += 4 + l;
      next = XLSRecordEnum[nextrt = __readUInt16LE(blob, blob.l)];
    }
    var b = bconcat(bufs);
    prep_blob(b, 0);
    var ll = 0;
    b.lens = [];
    for (var j = 0; j < bufs.length; ++j) {
      b.lens.push(ll);
      ll += bufs[j].length;
    }
    if (b.length < length) throw "XLS Record 0x" + RecordType.toString(16) + " Truncated: " + b.length + " < " + length;
    return R.f(b, b.length, opts);
  }
  function safe_format_xf(p2, opts, date1904) {
    if (p2.t === "z") return;
    if (!p2.XF) return;
    var fmtid = 0;
    try {
      fmtid = p2.z || p2.XF.numFmtId || 0;
      if (opts.cellNF && p2.z == null) p2.z = table_fmt[fmtid];
    } catch (e) {
      if (opts.WTF) throw e;
    }
    if (!opts || opts.cellText !== false) try {
      if (p2.t === "e") {
        p2.w = p2.w || BErr[p2.v];
      } else if (fmtid === 0 || fmtid == "General") {
        if (p2.t === "n") {
          if ((p2.v | 0) === p2.v) p2.w = p2.v.toString(10);
          else p2.w = SSF_general_num(p2.v);
        } else p2.w = SSF_general(p2.v);
      } else p2.w = SSF_format(fmtid, p2.v, { date1904: !!date1904, dateNF: opts && opts.dateNF });
    } catch (e) {
      if (opts.WTF) throw e;
    }
    if (opts.cellDates && fmtid && p2.t == "n" && fmt_is_date(table_fmt[fmtid] || String(fmtid))) {
      var _d = SSF_parse_date_code(p2.v + (date1904 ? 1462 : 0));
      if (_d) {
        p2.t = "d";
        p2.v = new Date(Date.UTC(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u));
      }
    }
  }
  function make_cell(val2, ixfe, t) {
    return { v: val2, ixfe, t };
  }
  function parse_workbook(blob, options) {
    var wb = { opts: {} };
    var Sheets = {};
    var out = {};
    if (options.dense) out["!data"] = [];
    var Directory = {};
    var range = {};
    var last_formula = null;
    var sst = [];
    var cur_sheet = "";
    var Preamble = {};
    var lastcell, last_cell = "", cc, cmnt, rngC, rngR;
    var sharedf = {};
    var arrayf = [];
    var temp_val;
    var country;
    var XFs = [];
    var palette = [];
    var Workbook = { Sheets: [], WBProps: { date1904: false }, Views: [{}] }, wsprops = {};
    var biff4w = false;
    var get_rgb = function getrgb(icv) {
      if (icv < 8) return XLSIcv[icv];
      if (icv < 64) return palette[icv - 8] || XLSIcv[icv];
      return XLSIcv[icv];
    };
    var process_cell_style = function pcs(line, options2) {
      var xfd = line.XF.data;
      if (!xfd || !xfd.patternType || !options2 || !options2.cellStyles) return;
      line.s = {};
      line.s.patternType = xfd.patternType;
      var t;
      if (t = rgb2Hex(get_rgb(xfd.icvFore))) {
        line.s.fgColor = { rgb: t };
      }
      if (t = rgb2Hex(get_rgb(xfd.icvBack))) {
        line.s.bgColor = { rgb: t };
      }
    };
    var addcell = function addcell2(cell, line, options2) {
      if (!biff4w && file_depth > 1) return;
      if (options2.sheetRows && cell.r >= options2.sheetRows) return;
      if (options2.cellStyles && line.XF && line.XF.data) process_cell_style(line, options2);
      delete line.ixfe;
      delete line.XF;
      lastcell = cell;
      last_cell = encode_cell(cell);
      if (!range || !range.s || !range.e) range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
      if (cell.r < range.s.r) range.s.r = cell.r;
      if (cell.c < range.s.c) range.s.c = cell.c;
      if (cell.r + 1 > range.e.r) range.e.r = cell.r + 1;
      if (cell.c + 1 > range.e.c) range.e.c = cell.c + 1;
      if (options2.cellFormula && line.f) {
        for (var afi = 0; afi < arrayf.length; ++afi) {
          if (arrayf[afi][0].s.c > cell.c || arrayf[afi][0].s.r > cell.r) continue;
          if (arrayf[afi][0].e.c < cell.c || arrayf[afi][0].e.r < cell.r) continue;
          line.F = encode_range(arrayf[afi][0]);
          if (arrayf[afi][0].s.c != cell.c || arrayf[afi][0].s.r != cell.r) delete line.f;
          if (line.f) line.f = "" + stringify_formula(arrayf[afi][1], range, cell, supbooks, opts);
          break;
        }
      }
      {
        if (options2.dense) {
          if (!out["!data"][cell.r]) out["!data"][cell.r] = [];
          out["!data"][cell.r][cell.c] = line;
        } else out[last_cell] = line;
      }
    };
    var opts = {
      enc: false,
sbcch: 0,
snames: [],
sharedf,
arrayf,
rrtabid: [],
lastuser: "",
biff: 8,
codepage: 0,
winlocked: 0,
cellStyles: !!options && !!options.cellStyles,
      WTF: !!options && !!options.wtf
    };
    if (options.password) opts.password = options.password;
    var themes;
    var merges = [];
    var objects = [];
    var colinfo = [], rowinfo = [];
    var seencol = false;
    var supbooks = [];
    supbooks.SheetNames = opts.snames;
    supbooks.sharedf = opts.sharedf;
    supbooks.arrayf = opts.arrayf;
    supbooks.names = [];
    supbooks.XTI = [];
    var last_RT = 0;
    var file_depth = 0;
    var BIFF2Fmt = 0, BIFF2FmtTable = [];
    var FilterDatabases = [];
    var last_lbl;
    opts.codepage = 1200;
    set_cp(1200);
    var seen_codepage = false;
    while (blob.l < blob.length - 1) {
      var s = blob.l;
      var RecordType = blob.read_shift(2);
      if (RecordType === 0 && last_RT === 10) break;
      var length = blob.l === blob.length ? 0 : blob.read_shift(2);
      var R = XLSRecordEnum[RecordType];
      if (file_depth == 0 && [9, 521, 1033, 2057].indexOf(RecordType) == -1) break;
      if (R && R.f) {
        if (options.bookSheets) {
          if (last_RT === 133 && RecordType !== 133) break;
        }
        last_RT = RecordType;
        if (R.r === 2 || R.r == 12) {
          var rt = blob.read_shift(2);
          length -= 2;
          if (!opts.enc && rt !== RecordType && ((rt & 255) << 8 | rt >> 8) !== RecordType) throw new Error("rt mismatch: " + rt + "!=" + RecordType);
          if (R.r == 12) {
            blob.l += 10;
            length -= 10;
          }
        }
        var val2 = {};
        if (RecordType === 10) val2 =
R.f(blob, length, opts);
        else val2 =
slurp(RecordType, R, blob, length, opts);
        if (file_depth == 0 && [9, 521, 1033, 2057].indexOf(last_RT) === -1) continue;
        switch (RecordType) {
          case 34:
            wb.opts.Date1904 = Workbook.WBProps.date1904 = val2;
            break;
          case 134:
            wb.opts.WriteProtect = true;
            break;
          case 47:
            if (!opts.enc) blob.l = 0;
            opts.enc = val2;
            if (!options.password) throw new Error("File is password-protected");
            if (val2.valid == null) throw new Error("Encryption scheme unsupported");
            if (!val2.valid) throw new Error("Password is incorrect");
            break;
          case 92:
            opts.lastuser = val2;
            break;
          case 66:
            var cpval = Number(val2);
            switch (cpval) {
              case 21010:
                cpval = 1200;
                break;
              case 32768:
                cpval = 1e4;
                break;
              case 32769:
                cpval = 1252;
                break;
            }
            set_cp(opts.codepage = cpval);
            seen_codepage = true;
            break;
          case 317:
            opts.rrtabid = val2;
            break;
          case 25:
            opts.winlocked = val2;
            break;
          case 439:
            wb.opts["RefreshAll"] = val2;
            break;
          case 12:
            wb.opts["CalcCount"] = val2;
            break;
          case 16:
            wb.opts["CalcDelta"] = val2;
            break;
          case 17:
            wb.opts["CalcIter"] = val2;
            break;
          case 13:
            wb.opts["CalcMode"] = val2;
            break;
          case 14:
            wb.opts["CalcPrecision"] = val2;
            break;
          case 95:
            wb.opts["CalcSaveRecalc"] = val2;
            break;
          case 15:
            opts.CalcRefMode = val2;
            break;
case 2211:
            wb.opts.FullCalc = val2;
            break;
          case 129:
            if (val2.fDialog) out["!type"] = "dialog";
            if (!val2.fBelow) (out["!outline"] || (out["!outline"] = {})).above = true;
            if (!val2.fRight) (out["!outline"] || (out["!outline"] = {})).left = true;
            break;
case 67:
case 579:
case 1091:
case 224:
            XFs.push(val2);
            break;
          case 430:
            supbooks.push([val2]);
            supbooks[supbooks.length - 1].XTI = [];
            break;
          case 35:
          case 547:
            supbooks[supbooks.length - 1].push(val2);
            break;
          case 24:
          case 536:
            last_lbl = {
              Name: val2.Name,
              Ref: stringify_formula(val2.rgce, range, null, supbooks, opts)
            };
            if (val2.itab > 0) last_lbl.Sheet = val2.itab - 1;
            supbooks.names.push(last_lbl);
            if (!supbooks[0]) {
              supbooks[0] = [];
              supbooks[0].XTI = [];
            }
            supbooks[supbooks.length - 1].push(val2);
            if (val2.Name == "_xlnm._FilterDatabase" && val2.itab > 0) {
              if (val2.rgce && val2.rgce[0] && val2.rgce[0][0] && val2.rgce[0][0][0] == "PtgArea3d")
                FilterDatabases[val2.itab - 1] = { ref: encode_range(val2.rgce[0][0][1][2]) };
            }
            break;
          case 22:
            opts.ExternCount = val2;
            break;
          case 23:
            if (supbooks.length == 0) {
              supbooks[0] = [];
              supbooks[0].XTI = [];
            }
            supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val2);
            supbooks.XTI = supbooks.XTI.concat(val2);
            break;
          case 2196:
            if (opts.biff < 8) break;
            if (last_lbl != null) last_lbl.Comment = val2[1];
            break;
          case 18:
            out["!protect"] = val2;
            break;
case 19:
            if (val2 !== 0 && opts.WTF) console.error("Password verifier: " + val2);
            break;
          case 133:
            {
              Directory[opts.biff == 4 ? opts.snames.length : val2.pos] = val2;
              opts.snames.push(val2.name);
            }
            break;
          case 10:
            {
              if (--file_depth ? !biff4w : biff4w) break;
              if (range.e) {
                if (range.e.r > 0 && range.e.c > 0) {
                  range.e.r--;
                  range.e.c--;
                  out["!ref"] = encode_range(range);
                  if (options.sheetRows && options.sheetRows <= range.e.r) {
                    var tmpri = range.e.r;
                    range.e.r = options.sheetRows - 1;
                    out["!fullref"] = out["!ref"];
                    out["!ref"] = encode_range(range);
                    range.e.r = tmpri;
                  }
                  range.e.r++;
                  range.e.c++;
                }
                if (merges.length > 0) out["!merges"] = merges;
                if (objects.length > 0) out["!objects"] = objects;
                if (colinfo.length > 0) out["!cols"] = colinfo;
                if (rowinfo.length > 0) out["!rows"] = rowinfo;
                Workbook.Sheets.push(wsprops);
              }
              if (cur_sheet === "") Preamble = out;
              else Sheets[cur_sheet] = out;
              out = {};
              if (options.dense) out["!data"] = [];
            }
            break;
          case 9:
          case 521:
          case 1033:
          case 2057:
            {
              if (opts.biff === 8) opts.biff = {
                9: 2,
                521: 3,
                1033: 4
              }[RecordType] || {
                512: 2,
                768: 3,
                1024: 4,
                1280: 5,
                1536: 8,
                2: 2,
                7: 2
              }[val2.BIFFVer] || 8;
              opts.biffguess = val2.BIFFVer == 0;
              if (val2.BIFFVer == 0 && val2.dt == 4096) {
                opts.biff = 5;
                seen_codepage = true;
                set_cp(opts.codepage = 28591);
              }
              if (opts.biff == 4 && val2.dt & 256) biff4w = true;
              if (opts.biff == 8 && val2.BIFFVer == 0 && val2.dt == 16) opts.biff = 2;
              if (file_depth++ && !biff4w) break;
              out = {};
              if (options.dense) out["!data"] = [];
              if (opts.biff < 8 && !seen_codepage) {
                seen_codepage = true;
                set_cp(opts.codepage = options.codepage || 1252);
              }
              if (opts.biff == 4 && biff4w) {
                cur_sheet = (Directory[opts.snames.indexOf(cur_sheet) + 1] || { name: "" }).name;
              } else if (opts.biff < 5 || val2.BIFFVer == 0 && val2.dt == 4096) {
                if (cur_sheet === "") cur_sheet = "Sheet1";
                range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
                var fakebs8 = { pos: blob.l - length, name: cur_sheet };
                Directory[fakebs8.pos] = fakebs8;
                opts.snames.push(cur_sheet);
              } else cur_sheet = (Directory[s] || { name: "" }).name;
              if (val2.dt == 32) out["!type"] = "chart";
              if (val2.dt == 64) out["!type"] = "macro";
              merges = [];
              objects = [];
              opts.arrayf = arrayf = [];
              colinfo = [];
              rowinfo = [];
              seencol = false;
              wsprops = { Hidden: (Directory[s] || { hs: 0 }).hs, name: cur_sheet };
            }
            break;
          case 515:
          case 3:
          case 2:
            {
              if (out["!type"] == "chart") {
                if (options.dense ? (out["!data"][val2.r] || [])[val2.c] : out[encode_col(val2.c) + encode_row(val2.r)]) ++val2.c;
              }
              temp_val = { ixfe: val2.ixfe, XF: XFs[val2.ixfe] || {}, v: val2.val, t: "n" };
              if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options, wb.opts.Date1904);
              addcell({ c: val2.c, r: val2.r }, temp_val, options);
            }
            break;
          case 5:
          case 517:
            {
              temp_val = { ixfe: val2.ixfe, XF: XFs[val2.ixfe], v: val2.val, t: val2.t };
              if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options, wb.opts.Date1904);
              addcell({ c: val2.c, r: val2.r }, temp_val, options);
            }
            break;
          case 638:
            {
              temp_val = { ixfe: val2.ixfe, XF: XFs[val2.ixfe], v: val2.rknum, t: "n" };
              if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options, wb.opts.Date1904);
              addcell({ c: val2.c, r: val2.r }, temp_val, options);
            }
            break;
          case 189:
            {
              for (var j = val2.c; j <= val2.C; ++j) {
                var ixfe = val2.rkrec[j - val2.c][0];
                temp_val = { ixfe, XF: XFs[ixfe], v: val2.rkrec[j - val2.c][1], t: "n" };
                if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
                safe_format_xf(temp_val, options, wb.opts.Date1904);
                addcell({ c: j, r: val2.r }, temp_val, options);
              }
            }
            break;
          case 6:
          case 518:
          case 1030:
            {
              if (val2.val == "String") {
                last_formula = val2;
                break;
              }
              temp_val = make_cell(val2.val, val2.cell.ixfe, val2.tt);
              temp_val.XF = XFs[temp_val.ixfe];
              if (options.cellFormula) {
                var _f = val2.formula;
                if (_f && _f[0] && _f[0][0] && _f[0][0][0] == "PtgExp") {
                  var _fr = _f[0][0][1][0], _fc = _f[0][0][1][1];
                  var _fe = encode_cell({ r: _fr, c: _fc });
                  if (sharedf[_fe]) temp_val.f = "" + stringify_formula(val2.formula, range, val2.cell, supbooks, opts);
                  else temp_val.F = ((options.dense ? (out["!data"][_fr] || [])[_fc] : out[_fe]) || {}).F;
                } else temp_val.f = "" + stringify_formula(val2.formula, range, val2.cell, supbooks, opts);
              }
              if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options, wb.opts.Date1904);
              addcell(val2.cell, temp_val, options);
              last_formula = val2;
            }
            break;
          case 7:
          case 519:
            {
              if (last_formula) {
                last_formula.val = val2;
                temp_val = make_cell(val2, last_formula.cell.ixfe, "s");
                temp_val.XF = XFs[temp_val.ixfe];
                if (options.cellFormula) {
                  temp_val.f = "" + stringify_formula(last_formula.formula, range, last_formula.cell, supbooks, opts);
                }
                if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
                safe_format_xf(temp_val, options, wb.opts.Date1904);
                addcell(last_formula.cell, temp_val, options);
                last_formula = null;
              } else throw new Error("String record expects Formula");
            }
            break;
          case 33:
          case 545:
            {
              arrayf.push(val2);
              var _arraystart = encode_cell(val2[0].s);
              cc = options.dense ? (out["!data"][val2[0].s.r] || [])[val2[0].s.c] : out[_arraystart];
              if (options.cellFormula && cc) {
                if (!last_formula) break;
                if (!_arraystart || !cc) break;
                cc.f = "" + stringify_formula(val2[1], range, val2[0], supbooks, opts);
                cc.F = encode_range(val2[0]);
              }
            }
            break;
          case 1212:
            {
              if (!options.cellFormula) break;
              if (last_cell) {
                if (!last_formula) break;
                sharedf[encode_cell(last_formula.cell)] = val2[0];
                cc = options.dense ? (out["!data"][last_formula.cell.r] || [])[last_formula.cell.c] : out[encode_cell(last_formula.cell)];
                (cc || {}).f = "" + stringify_formula(val2[0], range, lastcell, supbooks, opts);
              }
            }
            break;
          case 253:
            temp_val = make_cell(sst[val2.isst].t, val2.ixfe, "s");
            if (sst[val2.isst].h) temp_val.h = sst[val2.isst].h;
            temp_val.XF = XFs[temp_val.ixfe];
            if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb.opts.Date1904);
            addcell({ c: val2.c, r: val2.r }, temp_val, options);
            break;
          case 513:
            if (options.sheetStubs) {
              temp_val = { ixfe: val2.ixfe, XF: XFs[val2.ixfe], t: "z" };
              if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options, wb.opts.Date1904);
              addcell({ c: val2.c, r: val2.r }, temp_val, options);
            }
            break;
          case 190:
            if (options.sheetStubs) {
              for (var _j = val2.c; _j <= val2.C; ++_j) {
                var _ixfe = val2.ixfe[_j - val2.c];
                temp_val = { ixfe: _ixfe, XF: XFs[_ixfe], t: "z" };
                if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
                safe_format_xf(temp_val, options, wb.opts.Date1904);
                addcell({ c: _j, r: val2.r }, temp_val, options);
              }
            }
            break;
          case 214:
          case 516:
          case 4:
            temp_val = make_cell(val2.val, val2.ixfe, "s");
            temp_val.XF = XFs[temp_val.ixfe];
            if (BIFF2Fmt > 0) temp_val.z = temp_val.XF && temp_val.XF.numFmtId && BIFF2FmtTable[temp_val.XF.numFmtId] || BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb.opts.Date1904);
            addcell({ c: val2.c, r: val2.r }, temp_val, options);
            break;
          case 0:
          case 512:
            {
              if (file_depth === 1) range = val2;
            }
            break;
          case 252:
            {
              sst = val2;
            }
            break;
          case 1054:
            {
              if (opts.biff >= 3 && opts.biff <= 4) {
                BIFF2FmtTable[BIFF2Fmt++] = val2[1];
                for (var b4idx = 0; b4idx < BIFF2Fmt + 163; ++b4idx) if (table_fmt[b4idx] == val2[1]) break;
                if (b4idx >= 163) SSF__load(val2[1], BIFF2Fmt + 163);
              } else SSF__load(val2[1], val2[0]);
            }
            break;
          case 30:
            {
              BIFF2FmtTable[BIFF2Fmt++] = val2;
              for (var b2idx = 0; b2idx < BIFF2Fmt + 163; ++b2idx) if (table_fmt[b2idx] == val2) break;
              if (b2idx >= 163) SSF__load(val2, BIFF2Fmt + 163);
            }
            break;
          case 229:
            merges = merges.concat(val2);
            break;
          case 93:
            objects[val2.cmo[0]] = opts.lastobj = val2;
            break;
          case 438:
            opts.lastobj.TxO = val2;
            break;
          case 127:
            opts.lastobj.ImData = val2;
            break;
          case 440:
            {
              for (rngR = val2[0].s.r; rngR <= val2[0].e.r; ++rngR)
                for (rngC = val2[0].s.c; rngC <= val2[0].e.c; ++rngC) {
                  cc = options.dense ? (out["!data"][rngR] || [])[rngC] : out[encode_cell({ c: rngC, r: rngR })];
                  if (cc) cc.l = val2[1];
                }
            }
            break;
          case 2048:
            {
              for (rngR = val2[0].s.r; rngR <= val2[0].e.r; ++rngR)
                for (rngC = val2[0].s.c; rngC <= val2[0].e.c; ++rngC) {
                  cc = options.dense ? (out["!data"][rngR] || [])[rngC] : out[encode_cell({ c: rngC, r: rngR })];
                  if (cc && cc.l) cc.l.Tooltip = val2[1];
                }
            }
            break;
          case 28:
            {
              cc = options.dense ? (out["!data"][val2[0].r] || [])[val2[0].c] : out[encode_cell(val2[0])];
              if (!cc) {
                if (options.dense) {
                  if (!out["!data"][val2[0].r]) out["!data"][val2[0].r] = [];
                  cc = out["!data"][val2[0].r][val2[0].c] = { t: "z" };
                } else {
                  cc = out[encode_cell(val2[0])] = { t: "z" };
                }
                range.e.r = Math.max(range.e.r, val2[0].r);
                range.s.r = Math.min(range.s.r, val2[0].r);
                range.e.c = Math.max(range.e.c, val2[0].c);
                range.s.c = Math.min(range.s.c, val2[0].c);
              }
              if (!cc.c) cc.c = [];
              if (opts.biff <= 5 && opts.biff >= 2) cmnt = { a: "SheetJ5", t: val2[1] };
              else {
                var noteobj = objects[val2[2]];
                cmnt = { a: val2[1], t: noteobj.TxO.t };
                if (val2[3] != null && !(val2[3] & 2)) cc.c.hidden = true;
              }
              cc.c.push(cmnt);
            }
            break;
          case 2173:
            update_xfext(XFs[val2.ixfe], val2.ext);
            break;
          case 125:
            {
              if (!opts.cellStyles) break;
              while (val2.e >= val2.s) {
                colinfo[val2.e--] = { width: val2.w / 256, level: val2.level || 0, hidden: !!(val2.flags & 1) };
                if (!seencol) {
                  seencol = true;
                  find_mdw_colw(val2.w / 256);
                }
                process_col(colinfo[val2.e + 1]);
              }
            }
            break;
          case 520:
            {
              var rowobj = {};
              if (val2.level != null) {
                rowinfo[val2.r] = rowobj;
                rowobj.level = val2.level;
              }
              if (val2.hidden) {
                rowinfo[val2.r] = rowobj;
                rowobj.hidden = true;
              }
              if (val2.hpt) {
                rowinfo[val2.r] = rowobj;
                rowobj.hpt = val2.hpt;
                rowobj.hpx = pt2px(val2.hpt);
              }
            }
            break;
          case 38:
          case 39:
          case 40:
          case 41:
            if (!out["!margins"]) default_margins(out["!margins"] = {});
            out["!margins"][{ 38: "left", 39: "right", 40: "top", 41: "bottom" }[RecordType]] = val2;
            break;
          case 161:
            if (!out["!margins"]) default_margins(out["!margins"] = {});
            out["!margins"].header = val2.header;
            out["!margins"].footer = val2.footer;
            break;
          case 574:
            if (val2.RTL) Workbook.Views[0].RTL = true;
            break;
          case 146:
            palette = val2;
            break;
          case 2198:
            themes = val2;
            break;
          case 140:
            country = val2;
            break;
          case 442:
            {
              if (!cur_sheet) Workbook.WBProps.CodeName = val2 || "ThisWorkbook";
              else wsprops.CodeName = val2 || wsprops.name;
            }
            break;
        }
      } else {
        if (!R) console.error("Missing Info for XLS Record 0x" + RecordType.toString(16));
        blob.l += length;
      }
    }
    wb.SheetNames = keys(Directory).sort(function(a, b) {
      return Number(a) - Number(b);
    }).map(function(x) {
      return Directory[x].name;
    });
    if (!options.bookSheets) wb.Sheets = Sheets;
    if (!wb.SheetNames.length && Preamble["!ref"]) {
      wb.SheetNames.push("Sheet1");
      if (wb.Sheets) wb.Sheets["Sheet1"] = Preamble;
    } else wb.Preamble = Preamble;
    if (wb.Sheets) FilterDatabases.forEach(function(r2, i) {
      wb.Sheets[wb.SheetNames[i]]["!autofilter"] = r2;
    });
    wb.Strings = sst;
    wb.SSF = dup(table_fmt);
    if (opts.enc) wb.Encryption = opts.enc;
    if (themes) wb.Themes = themes;
    wb.Metadata = {};
    if (country !== void 0) wb.Metadata.Country = country;
    if (supbooks.names.length > 0) Workbook.Names = supbooks.names;
    wb.Workbook = Workbook;
    return wb;
  }
  var PSCLSID = {
    SI: "e0859ff2f94f6810ab9108002b27b3d9",
    DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
    UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
  };
  function parse_xls_props(cfb, props, o) {
    var DSI = CFB.find(cfb, "/!DocumentSummaryInformation");
    if (DSI && DSI.size > 0) try {
      var DocSummary = parse_PropertySetStream(DSI, DocSummaryPIDDSI, PSCLSID.DSI);
      for (var d in DocSummary) props[d] = DocSummary[d];
    } catch (e) {
      if (o.WTF) throw e;
    }
    var SI = CFB.find(cfb, "/!SummaryInformation");
    if (SI && SI.size > 0) try {
      var Summary = parse_PropertySetStream(SI, SummaryPIDSI, PSCLSID.SI);
      for (var s in Summary) if (props[s] == null) props[s] = Summary[s];
    } catch (e) {
      if (o.WTF) throw e;
    }
    if (props.HeadingPairs && props.TitlesOfParts) {
      load_props_pairs(props.HeadingPairs, props.TitlesOfParts, props, o);
      delete props.HeadingPairs;
      delete props.TitlesOfParts;
    }
  }
  function write_xls_props(wb, cfb) {
    var DSEntries = [], SEntries = [], CEntries = [];
    var i = 0, Keys;
    var DocSummaryRE = evert_key(DocSummaryPIDDSI, "n");
    var SummaryRE = evert_key(SummaryPIDSI, "n");
    if (wb.Props) {
      Keys = keys(wb.Props);
      for (i = 0; i < Keys.length; ++i) (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i]) ? SEntries : CEntries).push([Keys[i], wb.Props[Keys[i]]]);
    }
    if (wb.Custprops) {
      Keys = keys(wb.Custprops);
      for (i = 0; i < Keys.length; ++i) if (!Object.prototype.hasOwnProperty.call(wb.Props || {}, Keys[i])) (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i]) ? SEntries : CEntries).push([Keys[i], wb.Custprops[Keys[i]]]);
    }
    var CEntries2 = [];
    for (i = 0; i < CEntries.length; ++i) {
      if (XLSPSSkip.indexOf(CEntries[i][0]) > -1 || PseudoPropsPairs.indexOf(CEntries[i][0]) > -1) continue;
      if (CEntries[i][1] == null) continue;
      CEntries2.push(CEntries[i]);
    }
    if (SEntries.length) CFB.utils.cfb_add(cfb, "/SummaryInformation", write_PropertySetStream(SEntries, PSCLSID.SI, SummaryRE, SummaryPIDSI));
    if (DSEntries.length || CEntries2.length) CFB.utils.cfb_add(cfb, "/DocumentSummaryInformation", write_PropertySetStream(DSEntries, PSCLSID.DSI, DocSummaryRE, DocSummaryPIDDSI, CEntries2.length ? CEntries2 : null, PSCLSID.UDI));
  }
  function parse_xlscfb(cfb, options) {
    if (!options) options = {};
    fix_read_opts(options);
    reset_cp();
    if (options.codepage) set_ansi(options.codepage);
    var CompObj, WB;
    if (cfb.FullPaths) {
      if (CFB.find(cfb, "/encryption")) throw new Error("File is password-protected");
      CompObj = CFB.find(cfb, "!CompObj");
      WB = CFB.find(cfb, "/Workbook") || CFB.find(cfb, "/Book");
    } else {
      switch (options.type) {
        case "base64":
          cfb = s2a(Base64_decode(cfb));
          break;
        case "binary":
          cfb = s2a(cfb);
          break;
        case "buffer":
          break;
        case "array":
          if (!Array.isArray(cfb)) cfb = Array.prototype.slice.call(cfb);
          break;
      }
      prep_blob(cfb, 0);
      WB = { content: cfb };
    }
    var WorkbookP;
    var _data;
    if (CompObj) parse_compobj(CompObj);
    if (options.bookProps && !options.bookSheets) WorkbookP = {};
    else {
      var T = has_buf ? "buffer" : "array";
      if (WB && WB.content) WorkbookP = parse_workbook(WB.content, options);
      else if ((_data = CFB.find(cfb, "PerfectOffice_MAIN")) && _data.content) WorkbookP = WK_.to_workbook(_data.content, (options.type = T, options));
      else if ((_data = CFB.find(cfb, "NativeContent_MAIN")) && _data.content) WorkbookP = WK_.to_workbook(_data.content, (options.type = T, options));
      else if ((_data = CFB.find(cfb, "MN0")) && _data.content) throw new Error("Unsupported Works 4 for Mac file");
      else throw new Error("Cannot find Workbook stream");
      if (options.bookVBA && cfb.FullPaths && CFB.find(cfb, "/_VBA_PROJECT_CUR/VBA/dir")) WorkbookP.vbaraw = make_vba_xls(cfb);
    }
    var props = {};
    if (cfb.FullPaths) parse_xls_props(
cfb,
      props,
      options
    );
    WorkbookP.Props = WorkbookP.Custprops = props;
    if (options.bookFiles) WorkbookP.cfb = cfb;
    return WorkbookP;
  }
  function write_xlscfb(wb, opts) {
    var o = opts || {};
    var cfb = CFB.utils.cfb_new({ root: "R" });
    var wbpath = "/Workbook";
    switch (o.bookType || "xls") {
      case "xls":
        o.bookType = "biff8";
case "xla":
        if (!o.bookType) o.bookType = "xla";
case "biff8":
        wbpath = "/Workbook";
        o.biff = 8;
        break;
      case "biff5":
        wbpath = "/Book";
        o.biff = 5;
        break;
      default:
        throw new Error("invalid type " + o.bookType + " for XLS CFB");
    }
    CFB.utils.cfb_add(cfb, wbpath, write_biff_buf(wb, o));
    if (o.biff == 8 && (wb.Props || wb.Custprops)) write_xls_props(wb, cfb);
    if (o.biff == 8 && wb.vbaraw) fill_vba_xls(cfb, CFB.read(wb.vbaraw, { type: typeof wb.vbaraw == "string" ? "binary" : "buffer" }));
    return cfb;
  }
  var XLSBRecordEnum = {
    0: {
f: parse_BrtRowHdr
    },
    1: {
f: parse_BrtCellBlank
    },
    2: {
f: parse_BrtCellRk
    },
    3: {
f: parse_BrtCellError
    },
    4: {
f: parse_BrtCellBool
    },
    5: {
f: parse_BrtCellReal
    },
    6: {
f: parse_BrtCellSt
    },
    7: {
f: parse_BrtCellIsst
    },
    8: {
f: parse_BrtFmlaString
    },
    9: {
f: parse_BrtFmlaNum
    },
    10: {
f: parse_BrtFmlaBool
    },
    11: {
f: parse_BrtFmlaError
    },
    12: {
f: parse_BrtShortBlank
    },
    13: {
f: parse_BrtShortRk
    },
    14: {
f: parse_BrtShortError
    },
    15: {
f: parse_BrtShortBool
    },
    16: {
f: parse_BrtShortReal
    },
    17: {
f: parse_BrtShortSt
    },
    18: {
f: parse_BrtShortIsst
    },
    19: {
f: parse_RichStr
    },
    20: {
},
    21: {
},
    22: {
},
    23: {
},
    24: {
},
    25: {
},
    26: {
},
    27: {
},
    28: {
},
    29: {
},
    30: {
},
    31: {
},
    32: {
},
    33: {
},
    34: {
},
    35: {
T: 1
    },
    36: {
T: -1
    },
    37: {
T: 1
    },
    38: {
T: -1
    },
    39: {
f: parse_BrtName
    },
    40: {
},
    42: {
},
    43: {
f: parse_BrtFont
    },
    44: {
f: parse_BrtFmt
    },
    45: {
f: parse_BrtFill
    },
    46: {
f: parse_BrtBorder
    },
    47: {
f: parse_BrtXF
    },
    48: {
},
    49: {
f: parse_Int32LE
    },
    50: {
},
    51: {
f: parse_BrtMdb
    },
    52: {
T: 1
    },
    53: {
T: -1
    },
    54: {
T: 1
    },
    55: {
T: -1
    },
    56: {
T: 1
    },
    57: {
T: -1
    },
    58: {
},
    59: {
},
    60: {
f: parse_ColInfo
    },
    62: {
f: parse_BrtCellRString
    },
    63: {
f: parse_BrtCalcChainItem$
    },
    64: {
f: parse_BrtDVal
    },
    65: {
},
    66: {
},
    67: {
},
    68: {
},
    69: {
},
    70: {
},
    128: {
},
    129: {
T: 1
    },
    130: {
T: -1
    },
    131: {
T: 1,
      f: parsenoop,
      p: 0
    },
    132: {
T: -1
    },
    133: {
T: 1
    },
    134: {
T: -1
    },
    135: {
T: 1
    },
    136: {
T: -1
    },
    137: {
T: 1,
      f: parse_BrtBeginWsView
    },
    138: {
T: -1
    },
    139: {
T: 1
    },
    140: {
T: -1
    },
    141: {
T: 1
    },
    142: {
T: -1
    },
    143: {
T: 1
    },
    144: {
T: -1
    },
    145: {
T: 1
    },
    146: {
T: -1
    },
    147: {
f: parse_BrtWsProp
    },
    148: {
f: parse_BrtWsDim,
      p: 16
    },
    151: {
f: parse_BrtPane
    },
    152: {
},
    153: {
f: parse_BrtWbProp
    },
    154: {
},
    155: {
},
    156: {
f: parse_BrtBundleSh
    },
    157: {
},
    158: {
},
    159: {
T: 1,
      f: parse_BrtBeginSst
    },
    160: {
T: -1
    },
    161: {
T: 1,
      f: parse_UncheckedRfX
    },
    162: {
T: -1
    },
    163: {
T: 1
    },
    164: {
T: -1
    },
    165: {
T: 1
    },
    166: {
T: -1
    },
    167: {
},
    168: {
},
    169: {
},
    170: {
},
    171: {
},
    172: {
T: 1
    },
    173: {
T: -1
    },
    174: {
},
    175: {
},
    176: {
f: parse_BrtMergeCell
    },
    177: {
T: 1
    },
    178: {
T: -1
    },
    179: {
T: 1
    },
    180: {
T: -1
    },
    181: {
T: 1
    },
    182: {
T: -1
    },
    183: {
T: 1
    },
    184: {
T: -1
    },
    185: {
T: 1
    },
    186: {
T: -1
    },
    187: {
T: 1
    },
    188: {
T: -1
    },
    189: {
T: 1
    },
    190: {
T: -1
    },
    191: {
T: 1
    },
    192: {
T: -1
    },
    193: {
T: 1
    },
    194: {
T: -1
    },
    195: {
T: 1
    },
    196: {
T: -1
    },
    197: {
T: 1
    },
    198: {
T: -1
    },
    199: {
T: 1
    },
    200: {
T: -1
    },
    201: {
T: 1
    },
    202: {
T: -1
    },
    203: {
T: 1
    },
    204: {
T: -1
    },
    205: {
T: 1
    },
    206: {
T: -1
    },
    207: {
T: 1
    },
    208: {
T: -1
    },
    209: {
T: 1
    },
    210: {
T: -1
    },
    211: {
T: 1
    },
    212: {
T: -1
    },
    213: {
T: 1
    },
    214: {
T: -1
    },
    215: {
T: 1
    },
    216: {
T: -1
    },
    217: {
T: 1
    },
    218: {
T: -1
    },
    219: {
T: 1
    },
    220: {
T: -1
    },
    221: {
T: 1
    },
    222: {
T: -1
    },
    223: {
T: 1
    },
    224: {
T: -1
    },
    225: {
T: 1
    },
    226: {
T: -1
    },
    227: {
T: 1
    },
    228: {
T: -1
    },
    229: {
T: 1
    },
    230: {
T: -1
    },
    231: {
T: 1
    },
    232: {
T: -1
    },
    233: {
T: 1
    },
    234: {
T: -1
    },
    235: {
T: 1
    },
    236: {
T: -1
    },
    237: {
T: 1
    },
    238: {
T: -1
    },
    239: {
T: 1
    },
    240: {
T: -1
    },
    241: {
T: 1
    },
    242: {
T: -1
    },
    243: {
T: 1
    },
    244: {
T: -1
    },
    245: {
T: 1
    },
    246: {
T: -1
    },
    247: {
T: 1
    },
    248: {
T: -1
    },
    249: {
T: 1
    },
    250: {
T: -1
    },
    251: {
T: 1
    },
    252: {
T: -1
    },
    253: {
T: 1
    },
    254: {
T: -1
    },
    255: {
T: 1
    },
    256: {
T: -1
    },
    257: {
T: 1
    },
    258: {
T: -1
    },
    259: {
T: 1
    },
    260: {
T: -1
    },
    261: {
T: 1
    },
    262: {
T: -1
    },
    263: {
T: 1
    },
    264: {
T: -1
    },
    265: {
T: 1
    },
    266: {
T: -1
    },
    267: {
T: 1
    },
    268: {
T: -1
    },
    269: {
T: 1
    },
    270: {
T: -1
    },
    271: {
T: 1
    },
    272: {
T: -1
    },
    273: {
T: 1
    },
    274: {
T: -1
    },
    275: {
T: 1
    },
    276: {
T: -1
    },
    277: {
},
    278: {
T: 1
    },
    279: {
T: -1
    },
    280: {
T: 1
    },
    281: {
T: -1
    },
    282: {
T: 1
    },
    283: {
T: 1
    },
    284: {
T: -1
    },
    285: {
T: 1
    },
    286: {
T: -1
    },
    287: {
T: 1
    },
    288: {
T: -1
    },
    289: {
T: 1
    },
    290: {
T: -1
    },
    291: {
T: 1
    },
    292: {
T: -1
    },
    293: {
T: 1
    },
    294: {
T: -1
    },
    295: {
T: 1
    },
    296: {
T: -1
    },
    297: {
T: 1
    },
    298: {
T: -1
    },
    299: {
T: 1
    },
    300: {
T: -1
    },
    301: {
T: 1
    },
    302: {
T: -1
    },
    303: {
T: 1
    },
    304: {
T: -1
    },
    305: {
T: 1
    },
    306: {
T: -1
    },
    307: {
T: 1
    },
    308: {
T: -1
    },
    309: {
T: 1
    },
    310: {
T: -1
    },
    311: {
T: 1
    },
    312: {
T: -1
    },
    313: {
T: -1
    },
    314: {
T: 1
    },
    315: {
T: -1
    },
    316: {
T: 1
    },
    317: {
T: -1
    },
    318: {
T: 1
    },
    319: {
T: -1
    },
    320: {
T: 1
    },
    321: {
T: -1
    },
    322: {
T: 1
    },
    323: {
T: -1
    },
    324: {
T: 1
    },
    325: {
T: -1
    },
    326: {
T: 1
    },
    327: {
T: -1
    },
    328: {
T: 1
    },
    329: {
T: -1
    },
    330: {
T: 1
    },
    331: {
T: -1
    },
    332: {
T: 1
    },
    333: {
T: -1
    },
    334: {
T: 1
    },
    335: {
f: parse_BrtMdtinfo
    },
    336: {
T: -1
    },
    337: {
f: parse_BrtBeginEsmdb,
      T: 1
    },
    338: {
T: -1
    },
    339: {
T: 1
    },
    340: {
T: -1
    },
    341: {
T: 1
    },
    342: {
T: -1
    },
    343: {
T: 1
    },
    344: {
T: -1
    },
    345: {
T: 1
    },
    346: {
T: -1
    },
    347: {
T: 1
    },
    348: {
T: -1
    },
    349: {
T: 1
    },
    350: {
T: -1
    },
    351: {
},
    352: {
},
    353: {
T: 1
    },
    354: {
T: -1
    },
    355: {
f: parse_RelID
    },
    357: {
},
    358: {
},
    359: {
},
    360: {
T: 1
    },
    361: {
},
    362: {
f: parse_ExternSheet
    },
    363: {
},
    364: {
},
    366: {
},
    367: {
},
    368: {
},
    369: {
},
    370: {
},
    371: {
},
    372: {
T: 1
    },
    373: {
T: -1
    },
    374: {
T: 1
    },
    375: {
T: -1
    },
    376: {
T: 1
    },
    377: {
T: -1
    },
    378: {
T: 1
    },
    379: {
T: -1
    },
    380: {
T: 1
    },
    381: {
T: -1
    },
    382: {
T: 1
    },
    383: {
T: -1
    },
    384: {
T: 1
    },
    385: {
T: -1
    },
    386: {
T: 1
    },
    387: {
T: -1
    },
    388: {
T: 1
    },
    389: {
T: -1
    },
    390: {
T: 1
    },
    391: {
T: -1
    },
    392: {
T: 1
    },
    393: {
T: -1
    },
    394: {
T: 1
    },
    395: {
T: -1
    },
    396: {
},
    397: {
},
    398: {
},
    399: {
},
    400: {
},
    401: {
T: 1
    },
    403: {
},
    404: {
},
    405: {
},
    406: {
},
    407: {
},
    408: {
},
    409: {
},
    410: {
},
    411: {
},
    412: {
},
    413: {
},
    414: {
},
    415: {
},
    416: {
},
    417: {
},
    418: {
},
    419: {
},
    420: {
},
    421: {
},
    422: {
T: 1
    },
    423: {
T: 1
    },
    424: {
T: -1
    },
    425: {
T: -1
    },
    426: {
f: parse_BrtArrFmla
    },
    427: {
f: parse_BrtShrFmla
    },
    428: {
},
    429: {
T: 1
    },
    430: {
T: -1
    },
    431: {
T: 1
    },
    432: {
T: -1
    },
    433: {
T: 1
    },
    434: {
T: -1
    },
    435: {
T: 1
    },
    436: {
T: -1
    },
    437: {
T: 1
    },
    438: {
T: -1
    },
    439: {
T: 1
    },
    440: {
T: -1
    },
    441: {
T: 1
    },
    442: {
T: -1
    },
    443: {
T: 1
    },
    444: {
T: -1
    },
    445: {
T: 1
    },
    446: {
T: -1
    },
    447: {
T: 1
    },
    448: {
T: -1
    },
    449: {
T: 1
    },
    450: {
T: -1
    },
    451: {
T: 1
    },
    452: {
T: -1
    },
    453: {
T: 1
    },
    454: {
T: -1
    },
    455: {
T: 1
    },
    456: {
T: -1
    },
    457: {
T: 1
    },
    458: {
T: -1
    },
    459: {
T: 1
    },
    460: {
T: -1
    },
    461: {
T: 1
    },
    462: {
T: -1
    },
    463: {
T: 1
    },
    464: {
T: -1
    },
    465: {
T: 1
    },
    466: {
T: -1
    },
    467: {
T: 1
    },
    468: {
T: -1
    },
    469: {
T: 1
    },
    470: {
T: -1
    },
    471: {
},
    472: {
},
    473: {
T: 1
    },
    474: {
T: -1
    },
    475: {
},
    476: {
f: parse_BrtMargins
    },
    477: {
},
    478: {
},
    479: {
T: 1
    },
    480: {
T: -1
    },
    481: {
T: 1
    },
    482: {
T: -1
    },
    483: {
T: 1
    },
    484: {
T: -1
    },
    485: {
f: parse_BrtWsFmtInfo
    },
    486: {
T: 1
    },
    487: {
T: -1
    },
    488: {
T: 1
    },
    489: {
T: -1
    },
    490: {
T: 1
    },
    491: {
T: -1
    },
    492: {
T: 1
    },
    493: {
T: -1
    },
    494: {
f: parse_BrtHLink
    },
    495: {
T: 1
    },
    496: {
T: -1
    },
    497: {
T: 1
    },
    498: {
T: -1
    },
    499: {
},
    500: {
T: 1
    },
    501: {
T: -1
    },
    502: {
T: 1
    },
    503: {
T: -1
    },
    504: {
},
    505: {
T: 1
    },
    506: {
T: -1
    },
    507: {
},
    508: {
T: 1
    },
    509: {
T: -1
    },
    510: {
T: 1
    },
    511: {
T: -1
    },
    512: {
},
    513: {
},
    514: {
T: 1
    },
    515: {
T: -1
    },
    516: {
T: 1
    },
    517: {
T: -1
    },
    518: {
T: 1
    },
    519: {
T: -1
    },
    520: {
T: 1
    },
    521: {
T: -1
    },
    522: {
},
    523: {
},
    524: {
},
    525: {
},
    526: {
},
    527: {
},
    528: {
T: 1
    },
    529: {
T: -1
    },
    530: {
T: 1
    },
    531: {
T: -1
    },
    532: {
T: 1
    },
    533: {
T: -1
    },
    534: {
},
    535: {
},
    536: {
},
    537: {
},
    538: {
T: 1
    },
    539: {
T: -1
    },
    540: {
T: 1
    },
    541: {
T: -1
    },
    542: {
T: 1
    },
    548: {
},
    549: {
},
    550: {
f: parse_RelID
    },
    551: {
f: parse_XLNullableWideString
    },
    552: {
},
    553: {
},
    554: {
T: 1
    },
    555: {
T: -1
    },
    556: {
T: 1
    },
    557: {
T: -1
    },
    558: {
T: 1
    },
    559: {
T: -1
    },
    560: {
T: 1
    },
    561: {
T: -1
    },
    562: {
},
    564: {
},
    565: {
T: 1
    },
    566: {
T: -1
    },
    569: {
T: 1
    },
    570: {
T: -1
    },
    572: {
},
    573: {
T: 1
    },
    574: {
T: -1
    },
    577: {
},
    578: {
},
    579: {
},
    580: {
},
    581: {
},
    582: {
},
    583: {
},
    584: {
},
    585: {
},
    586: {
},
    587: {
},
    588: {
T: -1
    },
    589: {
},
    590: {
T: 1
    },
    591: {
T: -1
    },
    592: {
T: 1
    },
    593: {
T: -1
    },
    594: {
T: 1
    },
    595: {
T: -1
    },
    596: {
},
    597: {
T: 1
    },
    598: {
T: -1
    },
    599: {
T: 1
    },
    600: {
T: -1
    },
    601: {
T: 1
    },
    602: {
T: -1
    },
    603: {
T: 1
    },
    604: {
T: -1
    },
    605: {
T: 1
    },
    606: {
T: -1
    },
    607: {
},
    608: {
T: 1
    },
    609: {
T: -1
    },
    610: {
},
    611: {
T: 1
    },
    612: {
T: -1
    },
    613: {
T: 1
    },
    614: {
T: -1
    },
    615: {
T: 1
    },
    616: {
T: -1
    },
    617: {
T: 1
    },
    618: {
T: -1
    },
    619: {
T: 1
    },
    620: {
T: -1
    },
    625: {
},
    626: {
T: 1
    },
    627: {
T: -1
    },
    628: {
T: 1
    },
    629: {
T: -1
    },
    630: {
T: 1
    },
    631: {
T: -1
    },
    632: {
f: parse_BrtCommentAuthor
    },
    633: {
T: 1
    },
    634: {
T: -1
    },
    635: {
T: 1,
      f: parse_BrtBeginComment
    },
    636: {
T: -1
    },
    637: {
f: parse_BrtCommentText
    },
    638: {
T: 1
    },
    639: {
},
    640: {
T: -1
    },
    641: {
T: 1
    },
    642: {
T: -1
    },
    643: {
T: 1
    },
    644: {
},
    645: {
T: -1
    },
    646: {
T: 1
    },
    648: {
T: 1
    },
    649: {
},
    650: {
T: -1
    },
    651: {
f: parse_BrtCsProp
    },
    652: {
},
    653: {
T: 1
    },
    654: {
T: -1
    },
    655: {
T: 1
    },
    656: {
T: -1
    },
    657: {
T: 1
    },
    658: {
T: -1
    },
    659: {
},
    660: {
T: 1
    },
    661: {
},
    662: {
T: -1
    },
    663: {
},
    664: {
T: 1
    },
    665: {
},
    666: {
T: -1
    },
    667: {
},
    668: {
},
    669: {
},
    671: {
T: 1
    },
    672: {
T: -1
    },
    673: {
T: 1
    },
    674: {
T: -1
    },
    675: {
},
    676: {
},
    677: {
},
    678: {
},
    679: {
},
    680: {
},
    681: {
},
    1024: {
},
    1025: {
},
    1026: {
T: 1
    },
    1027: {
T: -1
    },
    1028: {
T: 1
    },
    1029: {
T: -1
    },
    1030: {
},
    1031: {
T: 1
    },
    1032: {
T: -1
    },
    1033: {
T: 1
    },
    1034: {
T: -1
    },
    1035: {
},
    1036: {
},
    1037: {
},
    1038: {
T: 1
    },
    1039: {
T: -1
    },
    1040: {
},
    1041: {
T: 1
    },
    1042: {
T: -1
    },
    1043: {
},
    1044: {
},
    1045: {
},
    1046: {
T: 1
    },
    1047: {
T: -1
    },
    1048: {
T: 1
    },
    1049: {
T: -1
    },
    1050: {
},
    1051: {
T: 1
    },
    1052: {
T: 1
    },
    1053: {
f: parse_BrtDVal14
    },
    1054: {
T: 1
    },
    1055: {
},
    1056: {
T: 1
    },
    1057: {
T: -1
    },
    1058: {
T: 1
    },
    1059: {
T: -1
    },
    1061: {
},
    1062: {
T: 1
    },
    1063: {
T: -1
    },
    1064: {
T: 1
    },
    1065: {
T: -1
    },
    1066: {
T: 1
    },
    1067: {
T: -1
    },
    1068: {
T: 1
    },
    1069: {
T: -1
    },
    1070: {
T: 1
    },
    1071: {
T: -1
    },
    1072: {
T: 1
    },
    1073: {
T: -1
    },
    1075: {
T: 1
    },
    1076: {
T: -1
    },
    1077: {
T: 1
    },
    1078: {
T: -1
    },
    1079: {
T: 1
    },
    1080: {
T: -1
    },
    1081: {
T: 1
    },
    1082: {
T: -1
    },
    1083: {
T: 1
    },
    1084: {
T: -1
    },
    1085: {
},
    1086: {
T: 1
    },
    1087: {
T: -1
    },
    1088: {
T: 1
    },
    1089: {
T: -1
    },
    1090: {
T: 1
    },
    1091: {
T: -1
    },
    1092: {
T: 1
    },
    1093: {
T: -1
    },
    1094: {
T: 1
    },
    1095: {
T: -1
    },
    1096: {
},
    1097: {
T: 1
    },
    1098: {
},
    1099: {
T: -1
    },
    1100: {
T: 1
    },
    1101: {
T: -1
    },
    1102: {
},
    1103: {
},
    1104: {
},
    1105: {
},
    1111: {
},
    1112: {
},
    1113: {
T: 1
    },
    1114: {
T: -1
    },
    1115: {
T: 1
    },
    1116: {
T: -1
    },
    1117: {
},
    1118: {
T: 1
    },
    1119: {
T: -1
    },
    1120: {
T: 1
    },
    1121: {
T: -1
    },
    1122: {
T: 1
    },
    1123: {
T: -1
    },
    1124: {
T: 1
    },
    1125: {
T: -1
    },
    1126: {
},
    1128: {
T: 1
    },
    1129: {
T: -1
    },
    1130: {
},
    1131: {
T: 1
    },
    1132: {
T: -1
    },
    1133: {
T: 1
    },
    1134: {
T: -1
    },
    1135: {
T: 1
    },
    1136: {
T: -1
    },
    1137: {
T: 1
    },
    1138: {
T: -1
    },
    1139: {
T: 1
    },
    1140: {
T: -1
    },
    1141: {
},
    1142: {
T: 1
    },
    1143: {
T: -1
    },
    1144: {
T: 1
    },
    1145: {
T: -1
    },
    1146: {
},
    1147: {
T: 1
    },
    1148: {
T: -1
    },
    1149: {
T: 1
    },
    1150: {
T: -1
    },
    1152: {
T: 1
    },
    1153: {
T: -1
    },
    1154: {
T: -1
    },
    1155: {
T: -1
    },
    1156: {
T: -1
    },
    1157: {
T: 1
    },
    1158: {
T: -1
    },
    1159: {
T: 1
    },
    1160: {
T: -1
    },
    1161: {
T: 1
    },
    1162: {
T: -1
    },
    1163: {
T: 1
    },
    1164: {
T: -1
    },
    1165: {
T: 1
    },
    1166: {
T: -1
    },
    1167: {
T: 1
    },
    1168: {
T: -1
    },
    1169: {
T: 1
    },
    1170: {
T: -1
    },
    1171: {
},
    1172: {
T: 1
    },
    1173: {
T: -1
    },
    1177: {
},
    1178: {
T: 1
    },
    1180: {
},
    1181: {
},
    1182: {
},
    2048: {
T: 1
    },
    2049: {
T: -1
    },
    2050: {
},
    2051: {
T: 1
    },
    2052: {
T: -1
    },
    2053: {
},
    2054: {
},
    2055: {
T: 1
    },
    2056: {
T: -1
    },
    2057: {
T: 1
    },
    2058: {
T: -1
    },
    2060: {
},
    2067: {
},
    2068: {
T: 1
    },
    2069: {
T: -1
    },
    2070: {
},
    2071: {
},
    2072: {
T: 1
    },
    2073: {
T: -1
    },
    2075: {
},
    2076: {
},
    2077: {
T: 1
    },
    2078: {
T: -1
    },
    2079: {
},
    2080: {
T: 1
    },
    2081: {
T: -1
    },
    2082: {
},
    2083: {
T: 1
    },
    2084: {
T: -1
    },
    2085: {
T: 1
    },
    2086: {
T: -1
    },
    2087: {
T: 1
    },
    2088: {
T: -1
    },
    2089: {
T: 1
    },
    2090: {
T: -1
    },
    2091: {
},
    2092: {
},
    2093: {
T: 1
    },
    2094: {
T: -1
    },
    2095: {
},
    2096: {
T: 1
    },
    2097: {
T: -1
    },
    2098: {
T: 1
    },
    2099: {
T: -1
    },
    2100: {
T: 1
    },
    2101: {
T: -1
    },
    2102: {
},
    2103: {
T: 1
    },
    2104: {
T: -1
    },
    2105: {
},
    2106: {
T: 1
    },
    2107: {
T: -1
    },
    2108: {
},
    2109: {
T: 1
    },
    2110: {
T: -1
    },
    2111: {
T: 1
    },
    2112: {
T: -1
    },
    2113: {
T: 1
    },
    2114: {
T: -1
    },
    2115: {
},
    2116: {
},
    2117: {
},
    2118: {
T: 1
    },
    2119: {
T: -1
    },
    2120: {
},
    2121: {
T: 1
    },
    2122: {
T: -1
    },
    2123: {
T: 1
    },
    2124: {
T: -1
    },
    2125: {
},
    2126: {
T: 1
    },
    2127: {
T: -1
    },
    2128: {
},
    2129: {
T: 1
    },
    2130: {
T: -1
    },
    2131: {
T: 1
    },
    2132: {
T: -1
    },
    2133: {
T: 1
    },
    2134: {
},
    2135: {
},
    2136: {
},
    2137: {
T: 1
    },
    2138: {
T: -1
    },
    2139: {
T: 1
    },
    2140: {
T: -1
    },
    2141: {
},
    3072: {
},
    3073: {
},
    4096: {
T: 1
    },
    4097: {
T: -1
    },
    5002: {
T: 1
    },
    5003: {
T: -1
    },
    5081: {
T: 1
    },
    5082: {
T: -1
    },
    5083: {
},
    5084: {
T: 1
    },
    5085: {
T: -1
    },
    5086: {
T: 1
    },
    5087: {
T: -1
    },
    5088: {
},
    5089: {
},
    5090: {
},
    5092: {
T: 1
    },
    5093: {
T: -1
    },
    5094: {
},
    5095: {
T: 1
    },
    5096: {
T: -1
    },
    5097: {
},
    5099: {
},
    65535: { n: "" }
  };
  var XLSRecordEnum = {
6: {
f: parse_Formula
    },
    10: {
f: parsenoop2
    },
    12: {
f: parseuint16
    },
13: {
f: parseuint16
    },
14: {
f: parsebool
    },
15: {
f: parsebool
    },
16: {
f: parse_Xnum
    },
17: {
f: parsebool
    },
18: {
f: parsebool
    },
    19: {
f: parseuint16
    },
    20: {
f: parse_XLHeaderFooter
    },
    21: {
f: parse_XLHeaderFooter
    },
    23: {
f: parse_ExternSheet
    },
    24: {
f: parse_Lbl
    },
    25: {
f: parsebool
    },
    26: {
},
    27: {
},
    28: {
f: parse_Note
    },
    29: {
},
    34: {
f: parsebool
    },
    35: {
f: parse_ExternName
    },
    38: {
f: parse_Xnum
    },
39: {
f: parse_Xnum
    },
40: {
f: parse_Xnum
    },
41: {
f: parse_Xnum
    },
42: {
f: parsebool
    },
    43: {
f: parsebool
    },
    47: {
f: parse_FilePass
    },
    49: {
f: parse_Font
    },
    51: {
f: parseuint16
    },
    60: {
},
    61: {
f: parse_Window1
    },
    64: {
f: parsebool
    },
    65: {
f: parse_Pane
    },
    66: {
f: parseuint16
    },
    77: {
},
    80: {
},
    81: {
},
    82: {
},
    85: {
f: parseuint16
    },
    89: {
},
    90: {
},
    91: {
},
    92: {
f: parse_WriteAccess
    },
    93: {
f: parse_Obj
    },
    94: {
},
    95: {
f: parsebool
    },
96: {
},
    97: {
},
    99: {
f: parsebool
    },
    125: {
f: parse_ColInfo
    },
    128: {
f: parse_Guts
    },
    129: {
f: parse_WsBool
    },
    130: {
f: parseuint16
    },
    131: {
f: parsebool
    },
    132: {
f: parsebool
    },
    133: {
f: parse_BoundSheet8
    },
    134: {
},
    140: {
f: parse_Country
    },
    141: {
f: parseuint16
    },
    144: {
},
    146: {
f: parse_Palette
    },
    151: {
},
    152: {
},
    153: {
},
    154: {
},
    155: {
},
    156: {
f: parseuint16
    },
    157: {
},
    158: {
},
    160: {
f: parse_Scl
    },
    161: {
f: parse_Setup
    },
    174: {
},
    175: {
},
    176: {
},
    177: {
},
    178: {
},
    180: {
},
    181: {
},
    182: {
},
    184: {
},
    185: {
},
    189: {
f: parse_MulRk
    },
    190: {
f: parse_MulBlank
    },
    193: {
f: parsenoop2
    },
    197: {
},
    198: {
},
    199: {
},
    200: {
},
    201: {
},
    202: {
f: parsebool
    },
    203: {
},
    204: {
},
    205: {
},
    206: {
},
    207: {
},
    208: {
},
    209: {
},
    210: {
},
    211: {
},
    213: {
},
    215: {
},
    216: {
},
    217: {
},
    218: {
f: parseuint16
    },
    220: {
},
    221: {
f: parsebool
    },
    222: {
},
    224: {
f: parse_XF
    },
    225: {
f: parse_InterfaceHdr
    },
    226: {
f: parsenoop2
    },
    227: {
},
    229: {
f: parse_MergeCells
    },
    233: {
},
    235: {
},
    236: {
},
    237: {
},
    239: {
},
    240: {
},
    241: {
},
    242: {
},
    244: {
},
    245: {
},
    246: {
},
    247: {
},
    248: {
},
    249: {
},
    251: {
},
    252: {
f: parse_SST
    },
    253: {
f: parse_LabelSst
    },
    255: {
f: parse_ExtSST
    },
    256: {
},
    259: {
},
    290: {
},
    311: {
},
    312: {
},
    315: {
},
    317: {
f: parseuint16a
    },
    318: {
},
    319: {
},
    320: {
},
    330: {
},
    331: {
},
    333: {
},
    334: {
},
    335: {
},
    336: {
},
    337: {
},
    338: {
},
    339: {
},
    340: {
},
    351: {
},
    352: {
f: parsebool
    },
    353: {
f: parsenoop2
    },
    401: {
},
    402: {
},
    403: {
},
    404: {
},
    405: {
},
    406: {
},
    407: {
},
    408: {
},
    425: {
},
    426: {
},
    427: {
},
    428: {
},
    429: {
},
    430: {
f: parse_SupBook
    },
    431: {
f: parsebool
    },
    432: {
},
    433: {
},
    434: {
},
    437: {
},
    438: {
f: parse_TxO
    },
    439: {
f: parsebool
    },
440: {
f: parse_HLink
    },
    441: {
},
    442: {
f: parse_XLUnicodeString
    },
    443: {
},
    444: {
f: parseuint16
    },
    445: {
},
    446: {
},
    448: {
f: parsenoop2
    },
    449: {
f: parse_RecalcId,
      r: 2
    },
    450: {
f: parsenoop2
    },
    512: {
f: parse_Dimensions
    },
    513: {
f: parse_Blank
    },
    515: {
f: parse_Number
    },
    516: {
f: parse_Label
    },
    517: {
f: parse_BoolErr
    },
    519: {
f: parse_String
    },
    520: {
f: parse_Row
    },
    523: {
},
    545: {
f: parse_Array
    },
    549: {
f: parse_DefaultRowHeight
    },
    566: {
},
    574: {
f: parse_Window2
    },
    638: {
f: parse_RK
    },
    659: {
},
    1048: {
},
    1054: {
f: parse_Format
    },
    1084: {
},
    1212: {
f: parse_ShrFmla
    },
    2048: {
f: parse_HLinkTooltip
    },
    2049: {
},
    2050: {
},
    2051: {
},
    2052: {
},
    2053: {
},
    2054: {
},
    2055: {
},
    2056: {
},
    2057: {
f: parse_BOF
    },
    2058: {
},
    2059: {
},
    2060: {
},
    2061: {
},
    2062: {
},
    2063: {
},
    2064: {
},
    2066: {
},
    2067: {
},
    2128: {
},
    2129: {
},
    2130: {
},
    2131: {
},
    2132: {
},
    2133: {
},
    2134: {
},
    2135: {
},
    2136: {
},
    2137: {
},
    2138: {
},
    2146: {
},
    2147: {
r: 12
    },
    2148: {
},
    2149: {
},
    2150: {
},
    2151: {
f: parsenoop2
    },
    2152: {
},
    2154: {
},
    2155: {
},
    2156: {
},
    2161: {
},
    2162: {
},
    2164: {
},
    2165: {
},
    2166: {
},
    2167: {
},
    2168: {
},
    2169: {
},
    2170: {
},
    2171: {
},
    2172: {
f: parse_XFCRC,
      r: 12
    },
    2173: {
f: parse_XFExt,
      r: 12
    },
    2174: {
},
    2175: {
},
    2180: {
},
    2181: {
},
    2182: {
},
    2183: {
},
    2184: {
},
    2185: {
},
    2186: {
},
    2187: {
},
    2188: {
f: parsebool,
      r: 12
    },
    2189: {
},
    2190: {
r: 12
    },
    2191: {
},
    2192: {
},
    2194: {
},
    2195: {
},
    2196: {
f: parse_NameCmt,
      r: 12
    },
    2197: {
},
    2198: {
f: parse_Theme,
      r: 12
    },
    2199: {
},
    2200: {
},
    2201: {
},
    2202: {
f: parse_MTRSettings,
      r: 12
    },
    2203: {
f: parsenoop2
    },
    2204: {
},
    2205: {
},
    2206: {
},
    2207: {
},
    2211: {
f: parse_ForceFullCalculation
    },
    2212: {
},
    2213: {
},
    2214: {
},
    2215: {
},
    4097: {
},
    4098: {
},
    4099: {
},
    4102: {
},
    4103: {
},
    4105: {
},
    4106: {
},
    4107: {
},
    4108: {
},
    4109: {
},
    4116: {
},
    4117: {
},
    4118: {
},
    4119: {
},
    4120: {
},
    4121: {
},
    4122: {
},
    4123: {
},
    4124: {
},
    4125: {
},
    4126: {
},
    4127: {
},
    4128: {
},
    4129: {
},
    4130: {
},
    4132: {
},
    4133: {
},
    4134: {
f: parseuint16
    },
    4135: {
},
    4146: {
},
    4147: {
},
    4148: {
},
    4149: {
},
    4154: {
},
    4156: {
},
    4157: {
},
    4158: {
},
    4159: {
},
    4160: {
},
    4161: {
},
    4163: {
},
    4164: {
f: parse_ShtProps
    },
    4165: {
},
    4166: {
},
    4168: {
},
    4170: {
},
    4171: {
},
    4174: {
},
    4175: {
},
    4176: {
},
    4177: {
},
    4187: {
},
    4188: {
f: parse_ClrtClient
    },
    4189: {
},
    4191: {
},
    4192: {
},
    4193: {
},
    4194: {
},
    4195: {
},
    4196: {
},
    4197: {
},
    4198: {
},
    4199: {
},
    4200: {
},
    0: {
f: parse_Dimensions
    },
    1: {
},
    2: {
f: parse_BIFF2INT
    },
    3: {
f: parse_BIFF2NUM
    },
    4: {
f: parse_BIFF2STR
    },
    5: {
f: parse_BIFF2BOOLERR
    },
    7: {
f: parse_BIFF2STRING
    },
    8: {
},
    9: {
f: parse_BOF
    },
    11: {
},
    22: {
f: parseuint16
    },
    30: {
f: parse_BIFF2Format
    },
    31: {
},
32: {
},
    33: {
f: parse_Array
    },
    36: {
},
    37: {
f: parse_DefaultRowHeight
    },



50: {
f: parse_BIFF2FONTXTRA
    },






62: {
},











52: {
},
    67: {
f: parse_BIFF2XF
    },
    68: {
f: parseuint16
    },
    69: {
},
    86: {
},
126: {
},
127: {
f: parse_ImData
    },
    135: {
},
    136: {
},
    137: {
},


143: {
f: parse_BIFF4SheetInfo
    },
    145: {
},
148: {
},
    149: {
},
    150: {
},


169: {
},
    171: {
},
    188: {
},
191: {
},
    192: {
},
    194: {
},
    195: {
},
    214: {
f: parse_RString
    },
    223: {
},
    234: {
},
    354: {
},
    421: {
},
    518: {
f: parse_Formula
    },
    521: {
f: parse_BOF
    },
    536: {
f: parse_Lbl
    },
    547: {
f: parse_ExternName
    },
    561: {
},
    579: {
f: parse_BIFF3XF
    },
    1030: {
f: parse_Formula
    },
    1033: {
f: parse_BOF
    },
    1091: {
f: parse_BIFF4XF
    },
    2157: {
},
    2163: {
},
    2177: {
},
    2240: {
},
    2241: {
},
    2242: {
},
    2243: {
},
    2244: {
},
    2245: {
},
    2246: {
},
    2247: {
},
    2248: {
},
    2249: {
},
    2250: {
},
    2251: {
},
    2262: {
r: 12
    },
101: {
},
102: {
},
105: {
},
106: {
},
107: {
},
109: {
},
112: {
},
114: {
},
29282: {}
  };
  function write_biff_rec(ba, type, payload, length) {
    var t = type;
    if (isNaN(t)) return;
    var len = length || (payload || []).length || 0;
    var o = ba.next(4);
    o.write_shift(2, t);
    o.write_shift(2, len);
    if (
len > 0 && is_buf(payload)
    ) ba.push(payload);
  }
  function write_biff_continue(ba, type, payload, length) {
    var len = (payload || []).length || 0;
    if (len <= 8224) return write_biff_rec(ba, type, payload, len);
    var t = type;
    if (isNaN(t)) return;
    var parts = payload.parts || [], sidx = 0;
    var i = 0, w = 0;
    while (w + (parts[sidx] || 8224) <= 8224) {
      w += parts[sidx] || 8224;
      sidx++;
    }
    var o = ba.next(4);
    o.write_shift(2, t);
    o.write_shift(2, w);
    ba.push(payload.slice(i, i + w));
    i += w;
    while (i < len) {
      o = ba.next(4);
      o.write_shift(2, 60);
      w = 0;
      while (w + (parts[sidx] || 8224) <= 8224) {
        w += parts[sidx] || 8224;
        sidx++;
      }
      o.write_shift(2, w);
      ba.push(payload.slice(i, i + w));
      i += w;
    }
  }
  function write_BIFF2BERR(r2, c, val2, t) {
    var out = new_buf(9);
    write_BIFF2Cell(out, r2, c);
    write_Bes(val2, t || "b", out);
    return out;
  }
  function write_BIFF2LABEL(r2, c, val2) {
    var out = new_buf(8 + 2 * val2.length);
    write_BIFF2Cell(out, r2, c);
    out.write_shift(1, val2.length);
    out.write_shift(val2.length, val2, "sbcs");
    return out.l < out.length ? out.slice(0, out.l) : out;
  }
  function write_comments_biff2(ba, comments) {
    comments.forEach(function(data) {
      var text = data[0].map(function(cc) {
        return cc.t;
      }).join("");
      if (text.length <= 2048) return write_biff_rec(ba, 28, write_NOTE_BIFF2(text, data[1], data[2]));
      write_biff_rec(ba, 28, write_NOTE_BIFF2(text.slice(0, 2048), data[1], data[2], text.length));
      for (var i = 2048; i < text.length; i += 2048)
        write_biff_rec(ba, 28, write_NOTE_BIFF2(text.slice(i, Math.min(i + 2048, text.length)), -1, -1, Math.min(2048, text.length - i)));
    });
  }
  function write_ws_biff2_cell(ba, cell, R, C, opts, date1904) {
    var ifmt = 0;
    if (cell.z != null) {
      ifmt = opts._BIFF2FmtTable.indexOf(cell.z);
      if (ifmt == -1) {
        opts._BIFF2FmtTable.push(cell.z);
        ifmt = opts._BIFF2FmtTable.length - 1;
      }
    }
    var ixfe = 0;
    if (cell.z != null) {
      for (; ixfe < opts.cellXfs.length; ++ixfe) if (opts.cellXfs[ixfe].numFmtId == ifmt) break;
      if (ixfe == opts.cellXfs.length) opts.cellXfs.push({ numFmtId: ifmt });
    }
    if (cell.v != null) switch (cell.t) {
      case "d":
      case "n":
        var v = cell.t == "d" ? datenum(parseDate(cell.v, date1904), date1904) : cell.v;
        if (opts.biff == 2 && v == (v | 0) && v >= 0 && v < 65536)
          write_biff_rec(ba, 2, write_BIFF2INT(R, C, v, ixfe, ifmt));
        else if (isNaN(v))
          write_biff_rec(ba, 5, write_BIFF2BERR(R, C, 36, "e"));
        else if (!isFinite(v))
          write_biff_rec(ba, 5, write_BIFF2BERR(R, C, 7, "e"));
        else
          write_biff_rec(ba, 3, write_BIFF2NUM(R, C, v, ixfe, ifmt));
        return;
      case "b":
      case "e":
        write_biff_rec(ba, 5, write_BIFF2BERR(R, C, cell.v, cell.t));
        return;
case "s":
      case "str":
        write_biff_rec(ba, 4, write_BIFF2LABEL(R, C, cell.v == null ? "" : String(cell.v).slice(0, 255)));
        return;
    }
    write_biff_rec(ba, 1, write_BIFF2Cell(null, R, C));
  }
  function write_ws_biff2(ba, ws, idx, opts, wb) {
    var dense = ws["!data"] != null;
    var range = safe_decode_range(ws["!ref"] || "A1"), rr = "", cols = [];
    if (range.e.c > 255 || range.e.r > 16383) {
      if (opts.WTF) throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:IV16384");
      range.e.c = Math.min(range.e.c, 255);
      range.e.r = Math.min(range.e.r, 16383);
    }
    var date1904 = (((wb || {}).Workbook || {}).WBProps || {}).date1904;
    var row = [], comments = [];
    for (var C = range.s.c; C <= range.e.c; ++C) cols[C] = encode_col(C);
    for (var R = range.s.r; R <= range.e.r; ++R) {
      if (dense) row = ws["!data"][R] || [];
      rr = encode_row(R);
      for (C = range.s.c; C <= range.e.c; ++C) {
        var cell = dense ? row[C] : ws[cols[C] + rr];
        if (!cell) continue;
        write_ws_biff2_cell(ba, cell, R, C, opts, date1904);
        if (cell.c) comments.push([cell.c, R, C]);
      }
    }
    write_comments_biff2(ba, comments);
  }
  function write_biff2_buf(wb, opts) {
    var o = opts || {};
    var ba = buf_array();
    var idx = 0;
    for (var i = 0; i < wb.SheetNames.length; ++i) if (wb.SheetNames[i] == o.sheet) idx = i;
    if (idx == 0 && !!o.sheet && wb.SheetNames[0] != o.sheet) throw new Error("Sheet not found: " + o.sheet);
    write_biff_rec(ba, o.biff == 4 ? 1033 : o.biff == 3 ? 521 : 9, write_BOF(wb, 16, o));
    if (((wb.Workbook || {}).WBProps || {}).date1904) write_biff_rec(ba, 34, writebool(true));
    o.cellXfs = [{ numFmtId: 0 }];
    o._BIFF2FmtTable = ["General"];
    o._Fonts = [];
    var body = buf_array();
    write_ws_biff2(body, wb.Sheets[wb.SheetNames[idx]], idx, o, wb);
    o._BIFF2FmtTable.forEach(function(f) {
      if (o.biff <= 3) write_biff_rec(ba, 30, write_BIFF2Format(f));
      else write_biff_rec(ba, 1054, write_BIFF4Format(f));
    });
    o.cellXfs.forEach(function(xf) {
      switch (o.biff) {
        case 2:
          write_biff_rec(ba, 67, write_BIFF2XF(xf));
          break;
        case 3:
          write_biff_rec(ba, 579, write_BIFF3XF(xf));
          break;
        case 4:
          write_biff_rec(ba, 1091, write_BIFF4XF(xf));
          break;
      }
    });
    delete o._BIFF2FmtTable;
    delete o.cellXfs;
    delete o._Fonts;
    ba.push(body.end());
    write_biff_rec(ba, 10);
    return ba.end();
  }
  var b8oid = 1, b8ocnts = [];
  function write_MsoDrawingGroup() {
    var buf = new_buf(82 + 8 * b8ocnts.length);
    buf.write_shift(2, 15);
    buf.write_shift(2, 61440);
    buf.write_shift(4, 74 + 8 * b8ocnts.length);
    {
      buf.write_shift(2, 0);
      buf.write_shift(2, 61446);
      buf.write_shift(4, 16 + 8 * b8ocnts.length);
      {
        buf.write_shift(4, b8oid);
        buf.write_shift(4, b8ocnts.length + 1);
        var acc = 0;
        for (var i = 0; i < b8ocnts.length; ++i) acc += b8ocnts[i] && b8ocnts[i][1] || 0;
        buf.write_shift(4, acc);
        buf.write_shift(4, b8ocnts.length);
      }
      b8ocnts.forEach(function(b8) {
        buf.write_shift(4, b8[0]);
        buf.write_shift(4, b8[2]);
      });
    }
    {
      buf.write_shift(2, 51);
      buf.write_shift(2, 61451);
      buf.write_shift(4, 18);
      buf.write_shift(2, 191);
      buf.write_shift(4, 524296);
      buf.write_shift(2, 385);
      buf.write_shift(4, 134217793);
      buf.write_shift(2, 448);
      buf.write_shift(4, 134217792);
    }
    {
      buf.write_shift(2, 64);
      buf.write_shift(2, 61726);
      buf.write_shift(4, 16);
      buf.write_shift(4, 134217741);
      buf.write_shift(4, 134217740);
      buf.write_shift(4, 134217751);
      buf.write_shift(4, 268435703);
    }
    return buf;
  }
  function write_comments_biff8(ba, comments) {
    var notes = [], sz = 0, pl = buf_array(), baseid = b8oid;
    var _oasc;
    comments.forEach(function(c, ci) {
      var author = "";
      var text = c[0].map(function(t) {
        if (t.a && !author) author = t.a;
        return t.t;
      }).join("");
      ++b8oid;
      {
        var oasc = new_buf(150);
        oasc.write_shift(2, 15);
        oasc.write_shift(2, 61444);
        oasc.write_shift(4, 150);
        {
          oasc.write_shift(2, 3234);
          oasc.write_shift(2, 61450);
          oasc.write_shift(4, 8);
          oasc.write_shift(4, b8oid);
          oasc.write_shift(4, 2560);
        }
        {
          oasc.write_shift(2, 227);
          oasc.write_shift(2, 61451);
          oasc.write_shift(4, 84);
          oasc.write_shift(2, 128);
          oasc.write_shift(4, 0);
          oasc.write_shift(2, 139);
          oasc.write_shift(4, 2);
          oasc.write_shift(2, 191);
          oasc.write_shift(4, 524296);
          oasc.write_shift(2, 344);
          oasc.l += 4;
          oasc.write_shift(2, 385);
          oasc.write_shift(4, 134217808);
          oasc.write_shift(2, 387);
          oasc.write_shift(4, 134217808);
          oasc.write_shift(2, 389);
          oasc.write_shift(4, 268435700);
          oasc.write_shift(2, 447);
          oasc.write_shift(4, 1048592);
          oasc.write_shift(2, 448);
          oasc.write_shift(4, 134217809);
          oasc.write_shift(2, 451);
          oasc.write_shift(4, 268435700);
          oasc.write_shift(2, 513);
          oasc.write_shift(4, 134217809);
          oasc.write_shift(2, 515);
          oasc.write_shift(4, 268435700);
          oasc.write_shift(2, 575);
          oasc.write_shift(4, 196609);
          oasc.write_shift(2, 959);
          oasc.write_shift(4, 131072 | (c[0].hidden ? 2 : 0));
        }
        {
          oasc.l += 2;
          oasc.write_shift(2, 61456);
          oasc.write_shift(4, 18);
          oasc.write_shift(2, 3);
          oasc.write_shift(2, c[2] + 2);
          oasc.l += 2;
          oasc.write_shift(2, c[1] + 1);
          oasc.l += 2;
          oasc.write_shift(2, c[2] + 4);
          oasc.l += 2;
          oasc.write_shift(2, c[1] + 5);
          oasc.l += 2;
        }
        {
          oasc.l += 2;
          oasc.write_shift(2, 61457);
          oasc.l += 4;
        }
        oasc.l = 150;
        if (ci == 0) _oasc = oasc;
        else write_biff_rec(pl, 236, oasc);
      }
      sz += 150;
      {
        var obj = new_buf(52);
        obj.write_shift(2, 21);
        obj.write_shift(2, 18);
        obj.write_shift(2, 25);
        obj.write_shift(2, b8oid);
        obj.write_shift(2, 0);
        obj.l = 22;
        obj.write_shift(2, 13);
        obj.write_shift(2, 22);
        obj.write_shift(4, 1651663474);
        obj.write_shift(4, 2503426821);
        obj.write_shift(4, 2150634280);
        obj.write_shift(4, 1768515844 + b8oid * 256);
        obj.write_shift(2, 0);
        obj.write_shift(4, 0);
        obj.l += 4;
        write_biff_rec(pl, 93, obj);
      }
      {
        var oact = new_buf(8);
        oact.l += 2;
        oact.write_shift(2, 61453);
        oact.l += 4;
        write_biff_rec(pl, 236, oact);
      }
      sz += 8;
      {
        var txo = new_buf(18);
        txo.write_shift(2, 18);
        txo.l += 8;
        txo.write_shift(2, text.length);
        txo.write_shift(2, 16);
        txo.l += 4;
        write_biff_rec(pl, 438, txo);
        {
          var cont = new_buf(1 + text.length);
          cont.write_shift(1, 0);
          cont.write_shift(text.length, text, "sbcs");
          write_biff_rec(pl, 60, cont);
        }
        {
          var conf = new_buf(16);
          conf.l += 8;
          conf.write_shift(2, text.length);
          conf.l += 6;
          write_biff_rec(pl, 60, conf);
        }
      }
      {
        var notesh = new_buf(12 + author.length);
        notesh.write_shift(2, c[1]);
        notesh.write_shift(2, c[2]);
        notesh.write_shift(2, 0 | (c[0].hidden ? 0 : 2));
        notesh.write_shift(2, b8oid);
        notesh.write_shift(2, author.length);
        notesh.write_shift(1, 0);
        notesh.write_shift(author.length, author, "sbcs");
        notesh.l++;
        notes.push(notesh);
      }
    });
    {
      var hdr = new_buf(80);
      hdr.write_shift(2, 15);
      hdr.write_shift(2, 61442);
      hdr.write_shift(4, sz + hdr.length - 8);
      {
        hdr.write_shift(2, 16);
        hdr.write_shift(2, 61448);
        hdr.write_shift(4, 8);
        hdr.write_shift(4, comments.length + 1);
        hdr.write_shift(4, b8oid);
      }
      {
        hdr.write_shift(2, 15);
        hdr.write_shift(2, 61443);
        hdr.write_shift(4, sz + 48);
        {
          hdr.write_shift(2, 15);
          hdr.write_shift(2, 61444);
          hdr.write_shift(4, 40);
          {
            hdr.write_shift(2, 1);
            hdr.write_shift(2, 61449);
            hdr.write_shift(4, 16);
            hdr.l += 16;
          }
          {
            hdr.write_shift(2, 2);
            hdr.write_shift(2, 61450);
            hdr.write_shift(4, 8);
            hdr.write_shift(4, baseid);
            hdr.write_shift(4, 5);
          }
        }
      }
      write_biff_rec(
        ba,
        236,
_oasc ? bconcat([hdr, _oasc]) : hdr
      );
    }
    ba.push(pl.end());
    notes.forEach(function(n) {
      write_biff_rec(ba, 28, n);
    });
    b8ocnts.push([baseid, comments.length + 1, b8oid]);
    ++b8oid;
  }
  function write_FONTS_biff8(ba, data, opts) {
    write_biff_rec(ba, 49, write_Font({
      sz: 12,
      name: "Arial"
    }, opts));
  }
  function write_FMTS_biff8(ba, NF, opts) {
    if (!NF) return;
    [[5, 8], [23, 26], [41, 44], [
50,
392
    ]].forEach(function(r2) {
      for (var i = r2[0]; i <= r2[1]; ++i) if (NF[i] != null) write_biff_rec(ba, 1054, write_Format(i, NF[i], opts));
    });
  }
  function write_FEAT(ba, ws) {
    var o = new_buf(19);
    o.write_shift(4, 2151);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    o.write_shift(2, 3);
    o.write_shift(1, 1);
    o.write_shift(4, 0);
    write_biff_rec(ba, 2151, o);
    o = new_buf(39);
    o.write_shift(4, 2152);
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    o.write_shift(2, 3);
    o.write_shift(1, 0);
    o.write_shift(4, 0);
    o.write_shift(2, 1);
    o.write_shift(4, 4);
    o.write_shift(2, 0);
    write_Ref8U(safe_decode_range(ws["!ref"] || "A1"), o);
    o.write_shift(4, 4);
    write_biff_rec(ba, 2152, o);
  }
  function write_CELLXFS_biff8(ba, opts) {
    for (var i = 0; i < 16; ++i) write_biff_rec(ba, 224, write_XF({ numFmtId: 0, style: true }, 0, opts));
    opts.cellXfs.forEach(function(c) {
      write_biff_rec(ba, 224, write_XF(c, 0, opts));
    });
  }
  function write_ws_biff8_hlinks(ba, ws) {
    for (var R = 0; R < ws["!links"].length; ++R) {
      var HL = ws["!links"][R];
      write_biff_rec(ba, 440, write_HLink(HL));
      if (HL[1].Tooltip) write_biff_rec(ba, 2048, write_HLinkTooltip(HL));
    }
    delete ws["!links"];
  }
  function write_ws_cols_biff8(ba, cols) {
    if (!cols) return;
    var cnt = 0;
    cols.forEach(function(col, idx) {
      if (++cnt <= 256 && col) {
        write_biff_rec(ba, 125, write_ColInfo(col_obj_w(idx, col), idx));
      }
    });
  }
  function write_ws_biff8_cell(ba, cell, R, C, opts, date1904) {
    var os = 16 + get_cell_style(opts.cellXfs, cell, opts);
    if (cell.v == null && !cell.bf) {
      write_biff_rec(ba, 513, write_XLSCell(R, C, os));
      return;
    }
    if (cell.bf) write_biff_rec(ba, 6, write_Formula(cell, R, C, opts, os));
    else switch (cell.t) {
      case "d":
      case "n":
        var v = cell.t == "d" ? datenum(parseDate(cell.v, date1904), date1904) : cell.v;
        if (isNaN(v)) write_biff_rec(ba, 517, write_BoolErr(R, C, 36, os, opts, "e"));
        else if (!isFinite(v)) write_biff_rec(ba, 517, write_BoolErr(R, C, 7, os, opts, "e"));
        else write_biff_rec(ba, 515, write_Number(R, C, v, os));
        break;
      case "b":
      case "e":
        write_biff_rec(ba, 517, write_BoolErr(R, C, cell.v, os, opts, cell.t));
        break;
case "s":
      case "str":
        if (opts.bookSST) {
          var isst = get_sst_id(opts.Strings, cell.v == null ? "" : String(cell.v), opts.revStrings);
          write_biff_rec(ba, 253, write_LabelSst(R, C, isst, os));
        } else write_biff_rec(ba, 516, write_Label(R, C, (cell.v == null ? "" : String(cell.v)).slice(0, 255), os, opts));
        break;
      default:
        write_biff_rec(ba, 513, write_XLSCell(R, C, os));
    }
  }
  function write_ws_biff8(idx, opts, wb) {
    var ba = buf_array();
    var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};
    var _WB = (wb || {}).Workbook || {};
    var _sheet = (_WB.Sheets || [])[idx] || {};
    var dense = ws["!data"] != null;
    var b8 = opts.biff == 8;
    var rr = "", cols = [];
    var range = safe_decode_range(ws["!ref"] || "A1");
    var MAX_ROWS = b8 ? 65536 : 16384;
    if (range.e.c > 255 || range.e.r >= MAX_ROWS) {
      if (opts.WTF) throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:IV" + MAX_ROWS);
      range.e.c = Math.min(range.e.c, 255);
      range.e.r = Math.min(range.e.r, MAX_ROWS - 1);
    }
    write_biff_rec(ba, 2057, write_BOF(wb, 16, opts));
    write_biff_rec(ba, 13, writeuint16(1));
    write_biff_rec(ba, 12, writeuint16(100));
    write_biff_rec(ba, 15, writebool(true));
    write_biff_rec(ba, 17, writebool(false));
    write_biff_rec(ba, 16, write_Xnum(1e-3));
    write_biff_rec(ba, 95, writebool(true));
    write_biff_rec(ba, 42, writebool(false));
    write_biff_rec(ba, 43, writebool(false));
    write_biff_rec(ba, 130, writeuint16(1));
    write_biff_rec(ba, 128, write_Guts());
    write_biff_rec(ba, 131, writebool(false));
    write_biff_rec(ba, 132, writebool(false));
    if (b8) write_ws_cols_biff8(ba, ws["!cols"]);
    write_biff_rec(ba, 512, write_Dimensions(range, opts));
    var date1904 = (((wb || {}).Workbook || {}).WBProps || {}).date1904;
    if (b8) ws["!links"] = [];
    for (var C = range.s.c; C <= range.e.c; ++C) cols[C] = encode_col(C);
    var comments = [];
    var row = [];
    for (var R = range.s.r; R <= range.e.r; ++R) {
      if (dense) row = ws["!data"][R] || [];
      rr = encode_row(R);
      for (C = range.s.c; C <= range.e.c; ++C) {
        var cell = dense ? row[C] : ws[cols[C] + rr];
        if (!cell) continue;
        write_ws_biff8_cell(ba, cell, R, C, opts, date1904);
        if (b8 && cell.l) ws["!links"].push([cols[C] + rr, cell.l]);
        if (cell.c) comments.push([cell.c, R, C]);
      }
    }
    var cname = _sheet.CodeName || _sheet.name || s;
    if (b8) write_comments_biff8(ba, comments);
    else write_comments_biff2(ba, comments);
    if (b8) write_biff_rec(ba, 574, write_Window2((_WB.Views || [])[0]));
    if (b8 && (ws["!merges"] || []).length) write_biff_rec(ba, 229, write_MergeCells(ws["!merges"]));
    if (b8) write_ws_biff8_hlinks(ba, ws);
    write_biff_rec(ba, 442, write_XLUnicodeString(cname));
    if (b8) write_FEAT(ba, ws);
    write_biff_rec(
      ba,
      10
);
    return ba.end();
  }
  function write_biff8_global(wb, bufs, opts) {
    var A = buf_array();
    var _WB = (wb || {}).Workbook || {};
    var _sheets = _WB.Sheets || [];
    var _wb = (
_WB.WBProps || {
}
    );
    var b8 = opts.biff == 8, b5 = opts.biff == 5;
    write_biff_rec(A, 2057, write_BOF(wb, 5, opts));
    if (opts.bookType == "xla") write_biff_rec(
      A,
      135
);
    write_biff_rec(A, 225, b8 ? writeuint16(1200) : null);
    write_biff_rec(A, 193, writezeroes(2));
    if (b5) write_biff_rec(
      A,
      191
);
    if (b5) write_biff_rec(
      A,
      192
);
    write_biff_rec(
      A,
      226
);
    write_biff_rec(A, 92, write_WriteAccess("SheetJS", opts));
    write_biff_rec(A, 66, writeuint16(b8 ? 1200 : 1252));
    if (b8) write_biff_rec(A, 353, writeuint16(0));
    if (b8) write_biff_rec(
      A,
      448
);
    write_biff_rec(A, 317, write_RRTabId(wb.SheetNames.length));
    if (b8 && wb.vbaraw) write_biff_rec(
      A,
      211
);
    if (b8 && wb.vbaraw) {
      var cname = _wb.CodeName || "ThisWorkbook";
      write_biff_rec(A, 442, write_XLUnicodeString(cname));
    }
    write_biff_rec(A, 156, writeuint16(17));
    write_biff_rec(A, 25, writebool(false));
    write_biff_rec(A, 18, writebool(false));
    write_biff_rec(A, 19, writeuint16(0));
    if (b8) write_biff_rec(A, 431, writebool(false));
    if (b8) write_biff_rec(A, 444, writeuint16(0));
    write_biff_rec(A, 61, write_Window1());
    write_biff_rec(A, 64, writebool(false));
    write_biff_rec(A, 141, writeuint16(0));
    write_biff_rec(A, 34, writebool(safe1904(wb) == "true"));
    write_biff_rec(A, 14, writebool(true));
    if (b8) write_biff_rec(A, 439, writebool(false));
    write_biff_rec(A, 218, writeuint16(0));
    write_FONTS_biff8(A, wb, opts);
    write_FMTS_biff8(A, wb.SSF, opts);
    write_CELLXFS_biff8(A, opts);
    if (b8) write_biff_rec(A, 352, writebool(false));
    var a = A.end();
    var C = buf_array();
    if (b8) write_biff_rec(C, 140, write_Country());
    if (b8 && b8ocnts.length) write_biff_rec(C, 235, write_MsoDrawingGroup());
    if (b8 && opts.Strings) write_biff_continue(C, 252, write_SST(opts.Strings));
    write_biff_rec(
      C,
      10
);
    var c = C.end();
    var B = buf_array();
    var blen = 0, j = 0;
    for (j = 0; j < wb.SheetNames.length; ++j) blen += (b8 ? 12 : 11) + (b8 ? 2 : 1) * wb.SheetNames[j].length;
    var start = a.length + blen + c.length;
    for (j = 0; j < wb.SheetNames.length; ++j) {
      var _sheet = _sheets[j] || {};
      write_biff_rec(B, 133, write_BoundSheet8({ pos: start, hs: _sheet.Hidden || 0, dt: 0, name: wb.SheetNames[j] }, opts));
      start += bufs[j].length;
    }
    var b = B.end();
    if (blen != b.length) throw new Error("BS8 " + blen + " != " + b.length);
    var out = [];
    if (a.length) out.push(a);
    if (b.length) out.push(b);
    if (c.length) out.push(c);
    return bconcat(out);
  }
  function write_biff8_buf(wb, opts) {
    var o = opts || {};
    var bufs = [];
    if (wb && !wb.SSF) {
      wb.SSF = dup(table_fmt);
    }
    if (wb && wb.SSF) {
      make_ssf();
      SSF_load_table(wb.SSF);
      o.revssf = evert_num(wb.SSF);
      o.revssf[wb.SSF[65535]] = 0;
      o.ssf = wb.SSF;
    }
    b8oid = 1;
    b8ocnts = [];
    o.Strings =
[];
    o.Strings.Count = 0;
    o.Strings.Unique = 0;
    fix_write_opts(o);
    o.cellXfs = [];
    get_cell_style(o.cellXfs, {}, { revssf: { "General": 0 } });
    if (!wb.Props) wb.Props = {};
    for (var i = 0; i < wb.SheetNames.length; ++i) bufs[bufs.length] = write_ws_biff8(i, o, wb);
    bufs.unshift(write_biff8_global(wb, bufs, o));
    return bconcat(bufs);
  }
  function write_biff_buf(wb, opts) {
    for (var i = 0; i <= wb.SheetNames.length; ++i) {
      var ws = wb.Sheets[wb.SheetNames[i]];
      if (!ws || !ws["!ref"]) continue;
      var range = decode_range(ws["!ref"]);
      if (range.e.c > 255) {
        if (typeof console != "undefined" && console.error) console.error("Worksheet '" + wb.SheetNames[i] + "' extends beyond column IV (255).  Data may be lost.");
      }
      if (range.e.r > 65535) {
        if (typeof console != "undefined" && console.error) console.error("Worksheet '" + wb.SheetNames[i] + "' extends beyond row 65536.  Data may be lost.");
      }
    }
    var o = opts || {};
    switch (o.biff || 2) {
      case 8:
      case 5:
        return write_biff8_buf(wb, opts);
      case 4:
      case 3:
      case 2:
        return write_biff2_buf(wb, opts);
    }
    throw new Error("invalid type " + o.bookType + " for BIFF");
  }
  function html_to_sheet(str, _opts) {
    var opts = _opts || {};
    var dense = opts.dense != null ? opts.dense : DENSE;
    var ws = {};
    if (dense) ws["!data"] = [];
    str = str_remove_ng(str, "<!--", "-->");
    var mtch = str.match(/<table/i);
    if (!mtch) throw new Error("Invalid HTML: could not find <table>");
    var mtch2 = str.match(/<\/table/i);
    var i = mtch.index, j = mtch2 && mtch2.index || str.length;
    var rows = split_regex(str.slice(i, j), /(:?<tr[^<>]*>)/i, "<tr>");
    var R = -1, C = 0, RS = 0, CS = 0;
    var range = { s: { r: 1e7, c: 1e7 }, e: { r: 0, c: 0 } };
    var merges = [];
    for (i = 0; i < rows.length; ++i) {
      var row = rows[i].trim();
      var hd = row.slice(0, 3).toLowerCase();
      if (hd == "<tr") {
        ++R;
        if (opts.sheetRows && opts.sheetRows <= R) {
          --R;
          break;
        }
        C = 0;
        continue;
      }
      if (hd != "<td" && hd != "<th") continue;
      var cells = row.split(/<\/t[dh]>/i);
      for (j = 0; j < cells.length; ++j) {
        var cell = cells[j].trim();
        if (!cell.match(/<t[dh]/i)) continue;
        var m = cell, cc = 0;
        while (m.charAt(0) == "<" && (cc = m.indexOf(">")) > -1) m = m.slice(cc + 1);
        for (var midx = 0; midx < merges.length; ++midx) {
          var _merge = merges[midx];
          if (_merge.s.c == C && _merge.s.r < R && R <= _merge.e.r) {
            C = _merge.e.c + 1;
            midx = -1;
          }
        }
        var tag = parsexmltag(cell.slice(0, cell.indexOf(">")));
        CS = tag.colspan ? +tag.colspan : 1;
        if ((RS = +tag.rowspan) > 1 || CS > 1) merges.push({ s: { r: R, c: C }, e: { r: R + (RS || 1) - 1, c: C + CS - 1 } });
        var _t = tag.t || tag["data-t"] || "";
        if (!m.length) {
          C += CS;
          continue;
        }
        m = htmldecode(m);
        if (range.s.r > R) range.s.r = R;
        if (range.e.r < R) range.e.r = R;
        if (range.s.c > C) range.s.c = C;
        if (range.e.c < C) range.e.c = C;
        if (!m.length) {
          C += CS;
          continue;
        }
        var o = { t: "s", v: m };
        if (opts.raw || !m.trim().length || _t == "s") ;
        else if (m === "TRUE") o = { t: "b", v: true };
        else if (m === "FALSE") o = { t: "b", v: false };
        else if (!isNaN(fuzzynum(m))) o = { t: "n", v: fuzzynum(m) };
        else if (!isNaN(fuzzydate(m).getDate())) {
          o = { t: "d", v: parseDate(m) };
          if (opts.UTC === false) o.v = utc_to_local(o.v);
          if (!opts.cellDates) o = { t: "n", v: datenum(o.v) };
          o.z = opts.dateNF || table_fmt[14];
        } else if (m.charCodeAt(0) == 35 && RBErr[m] != null) {
          o.t = "e";
          o.w = m;
          o.v = RBErr[m];
        }
        if (o.cellText !== false) o.w = m;
        if (dense) {
          if (!ws["!data"][R]) ws["!data"][R] = [];
          ws["!data"][R][C] = o;
        } else ws[encode_cell({ r: R, c: C })] = o;
        C += CS;
      }
    }
    ws["!ref"] = encode_range(range);
    if (merges.length) ws["!merges"] = merges;
    return ws;
  }
  function make_html_row(ws, r2, R, o) {
    var M = ws["!merges"] || [];
    var oo = [];
    var sp = {};
    var dense = ws["!data"] != null;
    for (var C = r2.s.c; C <= r2.e.c; ++C) {
      var RS = 0, CS = 0;
      for (var j = 0; j < M.length; ++j) {
        if (M[j].s.r > R || M[j].s.c > C) continue;
        if (M[j].e.r < R || M[j].e.c < C) continue;
        if (M[j].s.r < R || M[j].s.c < C) {
          RS = -1;
          break;
        }
        RS = M[j].e.r - M[j].s.r + 1;
        CS = M[j].e.c - M[j].s.c + 1;
        break;
      }
      if (RS < 0) continue;
      var coord = encode_col(C) + encode_row(R);
      var cell = dense ? (ws["!data"][R] || [])[C] : ws[coord];
      if (cell && cell.t == "n" && cell.v != null && !isFinite(cell.v)) {
        if (isNaN(cell.v)) cell = { t: "e", v: 36, w: BErr[36] };
        else cell = { t: "e", v: 7, w: BErr[7] };
      }
      var w = cell && cell.v != null && (cell.h || escapehtml(cell.w || (format_cell(cell), cell.w) || "")) || "";
      sp = {};
      if (RS > 1) sp.rowspan = RS;
      if (CS > 1) sp.colspan = CS;
      if (o.editable) w = '<span contenteditable="true">' + w + "</span>";
      else if (cell) {
        sp["data-t"] = cell && cell.t || "z";
        if (cell.v != null) sp["data-v"] = escapehtml(cell.v instanceof Date ? cell.v.toISOString() : cell.v);
        if (cell.z != null) sp["data-z"] = cell.z;
        if (cell.l && (cell.l.Target || "#").charAt(0) != "#") w = '<a href="' + escapehtml(cell.l.Target) + '">' + w + "</a>";
      }
      sp.id = (o.id || "sjs") + "-" + coord;
      oo.push(writextag("td", w, sp));
    }
    var preamble = "<tr>";
    return preamble + oo.join("") + "</tr>";
  }
  var HTML_BEGIN = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>';
  var HTML_END = "</body></html>";
  function html_to_workbook(str, opts) {
    var mtch = str_match_xml_ig(str, "table");
    if (!mtch || mtch.length == 0) throw new Error("Invalid HTML: could not find <table>");
    if (mtch.length == 1) {
      var w = sheet_to_workbook(html_to_sheet(mtch[0], opts), opts);
      w.bookType = "html";
      return w;
    }
    var wb = book_new();
    mtch.forEach(function(s, idx) {
      book_append_sheet(wb, html_to_sheet(s, opts), "Sheet" + (idx + 1));
    });
    wb.bookType = "html";
    return wb;
  }
  function make_html_preamble(ws, R, o) {
    var out = [];
    return out.join("") + "<table" + (o && o.id ? ' id="' + o.id + '"' : "") + ">";
  }
  function sheet_to_html(ws, opts) {
    var o = opts || {};
    var header = o.header != null ? o.header : HTML_BEGIN;
    var footer = o.footer != null ? o.footer : HTML_END;
    var out = [header];
    var r2 = decode_range(ws["!ref"] || "A1");
    out.push(make_html_preamble(ws, r2, o));
    if (ws["!ref"]) for (var R = r2.s.r; R <= r2.e.r; ++R) out.push(make_html_row(ws, r2, R, o));
    out.push("</table>" + footer);
    return out.join("");
  }
  function sheet_add_dom(ws, table, _opts) {
    var rows = table.rows;
    if (!rows) {
      throw "Unsupported origin when " + table.tagName + " is not a TABLE";
    }
    var opts = _opts || {};
    var dense = ws["!data"] != null;
    var or_R = 0, or_C = 0;
    if (opts.origin != null) {
      if (typeof opts.origin == "number") or_R = opts.origin;
      else {
        var _origin = typeof opts.origin == "string" ? decode_cell(opts.origin) : opts.origin;
        or_R = _origin.r;
        or_C = _origin.c;
      }
    }
    var sheetRows = Math.min(opts.sheetRows || 1e7, rows.length);
    var range = { s: { r: 0, c: 0 }, e: { r: or_R, c: or_C } };
    if (ws["!ref"]) {
      var _range = decode_range(ws["!ref"]);
      range.s.r = Math.min(range.s.r, _range.s.r);
      range.s.c = Math.min(range.s.c, _range.s.c);
      range.e.r = Math.max(range.e.r, _range.e.r);
      range.e.c = Math.max(range.e.c, _range.e.c);
      if (or_R == -1) range.e.r = or_R = _range.e.r + 1;
    }
    var merges = [], midx = 0;
    var rowinfo = ws["!rows"] || (ws["!rows"] = []);
    var _R = 0, R = 0, _C = 0, C = 0, RS = 0, CS = 0;
    if (!ws["!cols"]) ws["!cols"] = [];
    for (; _R < rows.length && R < sheetRows; ++_R) {
      var row = rows[_R];
      if (is_dom_element_hidden(row)) {
        if (opts.display) continue;
        rowinfo[R] = { hidden: true };
      }
      var elts = row.cells;
      for (_C = C = 0; _C < elts.length; ++_C) {
        var elt = elts[_C];
        if (opts.display && is_dom_element_hidden(elt)) continue;
        var v = elt.hasAttribute("data-v") ? elt.getAttribute("data-v") : elt.hasAttribute("v") ? elt.getAttribute("v") : htmldecode(elt.innerHTML);
        var z = elt.getAttribute("data-z") || elt.getAttribute("z");
        for (midx = 0; midx < merges.length; ++midx) {
          var m = merges[midx];
          if (m.s.c == C + or_C && m.s.r < R + or_R && R + or_R <= m.e.r) {
            C = m.e.c + 1 - or_C;
            midx = -1;
          }
        }
        CS = +elt.getAttribute("colspan") || 1;
        if ((RS = +elt.getAttribute("rowspan") || 1) > 1 || CS > 1) merges.push({ s: { r: R + or_R, c: C + or_C }, e: { r: R + or_R + (RS || 1) - 1, c: C + or_C + (CS || 1) - 1 } });
        var o = { t: "s", v };
        var _t = elt.getAttribute("data-t") || elt.getAttribute("t") || "";
        if (v != null) {
          if (v.length == 0) o.t = _t || "z";
          else if (opts.raw || v.trim().length == 0 || _t == "s") ;
          else if (_t == "e" && BErr[+v]) o = { t: "e", v: +v, w: BErr[+v] };
          else if (v === "TRUE") o = { t: "b", v: true };
          else if (v === "FALSE") o = { t: "b", v: false };
          else if (!isNaN(fuzzynum(v))) o = { t: "n", v: fuzzynum(v) };
          else if (!isNaN(fuzzydate(v).getDate())) {
            o = { t: "d", v: parseDate(v) };
            if (opts.UTC) o.v = local_to_utc(o.v);
            if (!opts.cellDates) o = { t: "n", v: datenum(o.v) };
            o.z = opts.dateNF || table_fmt[14];
          } else if (v.charCodeAt(0) == 35 && RBErr[v] != null) o = { t: "e", v: RBErr[v], w: v };
        }
        if (o.z === void 0 && z != null) o.z = z;
        var l = "", Aelts = elt.getElementsByTagName("A");
        if (Aelts && Aelts.length) {
          for (var Aelti = 0; Aelti < Aelts.length; ++Aelti) if (Aelts[Aelti].hasAttribute("href")) {
            l = Aelts[Aelti].getAttribute("href");
            if (l.charAt(0) != "#") break;
          }
        }
        if (l && l.charAt(0) != "#" && l.slice(0, 11).toLowerCase() != "javascript:") o.l = { Target: l };
        if (dense) {
          if (!ws["!data"][R + or_R]) ws["!data"][R + or_R] = [];
          ws["!data"][R + or_R][C + or_C] = o;
        } else ws[encode_cell({ c: C + or_C, r: R + or_R })] = o;
        if (range.e.c < C + or_C) range.e.c = C + or_C;
        C += CS;
      }
      ++R;
    }
    if (merges.length) ws["!merges"] = (ws["!merges"] || []).concat(merges);
    range.e.r = Math.max(range.e.r, R - 1 + or_R);
    ws["!ref"] = encode_range(range);
    if (R >= sheetRows) ws["!fullref"] = encode_range((range.e.r = rows.length - _R + R - 1 + or_R, range));
    return ws;
  }
  function parse_dom_table(table, _opts) {
    var opts = _opts || {};
    var ws = {};
    if (opts.dense) ws["!data"] = [];
    return sheet_add_dom(ws, table, _opts);
  }
  function table_to_book(table, opts) {
    var o = sheet_to_workbook(parse_dom_table(table, opts), opts);
    return o;
  }
  function is_dom_element_hidden(element) {
    var display = "";
    var get_computed_style = get_get_computed_style_function(element);
    if (get_computed_style) display = get_computed_style(element).getPropertyValue("display");
    if (!display) display = element.style && element.style.display;
    return display === "none";
  }
  function get_get_computed_style_function(element) {
    if (element.ownerDocument.defaultView && typeof element.ownerDocument.defaultView.getComputedStyle === "function") return element.ownerDocument.defaultView.getComputedStyle;
    if (typeof getComputedStyle === "function") return getComputedStyle;
    return null;
  }
  function parse_text_p(text) {
    var fixed = text.replace(/[\t\r\n]/g, " ").trim().replace(/ +/g, " ").replace(/<text:s\/>/g, " ").replace(/<text:s text:c="(\d+)"\/>/g, function($$, $1) {
      return Array(parseInt($1, 10) + 1).join(" ");
    }).replace(/<text:tab[^<>]*\/>/g, "	").replace(/<text:line-break\/>/g, "\n");
    var v = unescapexml(fixed.replace(/<[^<>]*>/g, ""));
    return [v];
  }
  function parse_ods_styles(d, _opts, _nfm) {
    var number_format_map = _nfm || {};
    var str = xlml_normalize(d);
    xlmlregex.lastIndex = 0;
    str = remove_doctype(str_remove_ng(str, "<!--", "-->"));
    var Rn, NFtag, NF = "", tNF = "", y, etpos = 0, tidx = -1, payload = "";
    while (Rn = xlmlregex.exec(str)) {
      switch (Rn[3] = Rn[3].replace(/_[\s\S]*$/, "")) {
case "number-style":
case "currency-style":
case "percentage-style":
case "date-style":
case "time-style":
case "text-style":
          if (Rn[1] === "/") {
            if (NFtag["truncate-on-overflow"] == "false") {
              if (NF.match(/h/)) NF = NF.replace(/h+/, "[$&]");
              else if (NF.match(/m/)) NF = NF.replace(/m+/, "[$&]");
              else if (NF.match(/s/)) NF = NF.replace(/s+/, "[$&]");
            }
            number_format_map[NFtag.name] = NF;
            NF = "";
          } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
            NF = "";
            NFtag = parsexmltag(Rn[0], false);
          }
          break;
case "boolean-style":
          if (Rn[1] === "/") {
            number_format_map[NFtag.name] = "General";
            NF = "";
          } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
            NF = "";
            NFtag = parsexmltag(Rn[0], false);
          }
          break;
case "boolean":
          NF += "General";
          break;
        case "text":
          if (Rn[1] === "/") {
            payload = str.slice(tidx, xlmlregex.lastIndex - Rn[0].length);
            if (payload == "%" && NFtag[0] == "<number:percentage-style") NF += "%";
            else NF += '"' + payload.replace(/"/g, '""') + '"';
          } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
            tidx = xlmlregex.lastIndex;
          }
          break;
        case "day":
          {
            y = parsexmltag(Rn[0], false);
            switch (y["style"]) {
              case "short":
                NF += "d";
                break;
              case "long":
                NF += "dd";
                break;
              default:
                NF += "dd";
                break;
            }
          }
          break;
        case "day-of-week":
          {
            y = parsexmltag(Rn[0], false);
            switch (y["style"]) {
              case "short":
                NF += "ddd";
                break;
              case "long":
                NF += "dddd";
                break;
              default:
                NF += "ddd";
                break;
            }
          }
          break;
        case "era":
          {
            y = parsexmltag(Rn[0], false);
            switch (y["style"]) {
              case "short":
                NF += "ee";
                break;
              case "long":
                NF += "eeee";
                break;
              default:
                NF += "eeee";
                break;
            }
          }
          break;
        case "hours":
          {
            y = parsexmltag(Rn[0], false);
            switch (y["style"]) {
              case "short":
                NF += "h";
                break;
              case "long":
                NF += "hh";
                break;
              default:
                NF += "hh";
                break;
            }
          }
          break;
        case "minutes":
          {
            y = parsexmltag(Rn[0], false);
            switch (y["style"]) {
              case "short":
                NF += "m";
                break;
              case "long":
                NF += "mm";
                break;
              default:
                NF += "mm";
                break;
            }
          }
          break;
        case "month":
          {
            y = parsexmltag(Rn[0], false);
            if (y["textual"]) NF += "mm";
            switch (y["style"]) {
              case "short":
                NF += "m";
                break;
              case "long":
                NF += "mm";
                break;
              default:
                NF += "m";
                break;
            }
          }
          break;
        case "seconds":
          {
            y = parsexmltag(Rn[0], false);
            switch (y["style"]) {
              case "short":
                NF += "s";
                break;
              case "long":
                NF += "ss";
                break;
              default:
                NF += "ss";
                break;
            }
            if (y["decimal-places"]) NF += "." + fill("0", +y["decimal-places"]);
          }
          break;
        case "year":
          {
            y = parsexmltag(Rn[0], false);
            switch (y["style"]) {
              case "short":
                NF += "yy";
                break;
              case "long":
                NF += "yyyy";
                break;
              default:
                NF += "yy";
                break;
            }
          }
          break;
        case "am-pm":
          NF += "AM/PM";
          break;
        case "week-of-year":
case "quarter":
          console.error("Excel does not support ODS format token " + Rn[3]);
          break;
        case "fill-character":
          if (Rn[1] === "/") {
            payload = str.slice(tidx, xlmlregex.lastIndex - Rn[0].length);
            NF += '"' + payload.replace(/"/g, '""') + '"*';
          } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
            tidx = xlmlregex.lastIndex;
          }
          break;
        case "scientific-number":
          y = parsexmltag(Rn[0], false);
          NF += "0." + fill("0", +y["min-decimal-places"] || +y["decimal-places"] || 2) + fill("?", +y["decimal-places"] - +y["min-decimal-places"] || 0) + "E" + (parsexmlbool(y["forced-exponent-sign"]) ? "+" : "") + fill("0", +y["min-exponent-digits"] || 2);
          break;
        case "fraction":
          y = parsexmltag(Rn[0], false);
          if (!+y["min-integer-digits"]) NF += "#";
          else NF += fill("0", +y["min-integer-digits"]);
          NF += " ";
          NF += fill("?", +y["min-numerator-digits"] || 1);
          NF += "/";
          if (+y["denominator-value"]) NF += y["denominator-value"];
          else NF += fill("?", +y["min-denominator-digits"] || 1);
          break;
        case "currency-symbol":
          if (Rn[1] === "/") {
            NF += '"' + str.slice(tidx, xlmlregex.lastIndex - Rn[0].length).replace(/"/g, '""') + '"';
          } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
            tidx = xlmlregex.lastIndex;
          } else NF += "$";
          break;
        case "text-properties":
          y = parsexmltag(Rn[0], false);
          switch ((y["color"] || "").toLowerCase().replace("#", "")) {
            case "ff0000":
            case "red":
              NF = "[Red]" + NF;
              break;
          }
          break;
        case "text-content":
          NF += "@";
          break;
        case "map":
          y = parsexmltag(Rn[0], false);
          if (unescapexml(y["condition"]) == "value()>=0") NF = number_format_map[y["apply-style-name"]] + ";" + NF;
          else console.error("ODS number format may be incorrect: " + y["condition"]);
          break;
        case "number":
          if (Rn[1] === "/") break;
          y = parsexmltag(Rn[0], false);
          tNF = "";
          tNF += fill("0", +y["min-integer-digits"] || 1);
          if (parsexmlbool(y["grouping"])) tNF = commaify(fill("#", Math.max(0, 4 - tNF.length)) + tNF);
          if (+y["min-decimal-places"] || +y["decimal-places"]) tNF += ".";
          if (+y["min-decimal-places"]) tNF += fill("0", +y["min-decimal-places"] || 1);
          if (+y["decimal-places"] - (+y["min-decimal-places"] || 0)) tNF += fill("0", +y["decimal-places"] - (+y["min-decimal-places"] || 0));
          NF += tNF;
          break;
        case "embedded-text":
          if (Rn[1] === "/") {
            if (etpos == 0) NF += '"' + str.slice(tidx, xlmlregex.lastIndex - Rn[0].length).replace(/"/g, '""') + '"';
            else NF = NF.slice(0, etpos) + '"' + str.slice(tidx, xlmlregex.lastIndex - Rn[0].length).replace(/"/g, '""') + '"' + NF.slice(etpos);
          } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
            tidx = xlmlregex.lastIndex;
            etpos = -+parsexmltag(Rn[0], false)["position"] || 0;
          }
          break;
      }
    }
    return number_format_map;
  }
  function parse_content_xml(d, _opts, _nfm) {
    var opts = _opts || {};
    var str = xlml_normalize(d);
    var state = [], tmp;
    var tag;
    var nfidx, NF = "", pidx = 0;
    var sheetag;
    var rowtag;
    var Sheets = {}, SheetNames = [];
    var ws = {};
    if (opts.dense) ws["!data"] = [];
    var Rn, q;
    var ctag = { value: "" }, ctag2 = {};
    var textp = "", textpidx = 0, oldtextp = "", oldtextpidx = 0;
    var textR = [], oldtextR = [];
    var R = -1, C = -1, range = { s: { r: 1e6, c: 1e7 }, e: { r: 0, c: 0 } };
    var row_ol = 0;
    var number_format_map = _nfm || {}, styles = {};
    var merges = [], mrange = {}, mR = 0, mC = 0;
    var rowinfo = [], rowpeat = 1, colpeat = 1;
    var arrayf = [];
    var WB = { Names: [], WBProps: {} };
    var atag = {};
    var _Ref = ["", ""];
    var comments = [], comment = {};
    var creator = "", creatoridx = 0;
    var isstub = false, intable = false;
    var i = 0;
    xlmlregex.lastIndex = 0;
    str = remove_doctype(str_remove_ng(str, "<!--", "-->"));
    while (Rn = xlmlregex.exec(str)) switch (Rn[3] = Rn[3].replace(/_[\s\S]*$/, "")) {
      case "table":
      case "工作表":
        if (Rn[1] === "/") {
          if (range.e.c >= range.s.c && range.e.r >= range.s.r) ws["!ref"] = encode_range(range);
          else ws["!ref"] = "A1:A1";
          if (opts.sheetRows > 0 && opts.sheetRows <= range.e.r) {
            ws["!fullref"] = ws["!ref"];
            range.e.r = opts.sheetRows - 1;
            ws["!ref"] = encode_range(range);
          }
          if (merges.length) ws["!merges"] = merges;
          if (rowinfo.length) ws["!rows"] = rowinfo;
          sheetag.name = sheetag["名称"] || sheetag.name;
          if (typeof JSON !== "undefined") JSON.stringify(sheetag);
          SheetNames.push(sheetag.name);
          Sheets[sheetag.name] = ws;
          intable = false;
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          sheetag = parsexmltag(Rn[0], false);
          R = C = -1;
          range.s.r = range.s.c = 1e7;
          range.e.r = range.e.c = 0;
          ws = {};
          if (opts.dense) ws["!data"] = [];
          merges = [];
          rowinfo = [];
          intable = true;
        }
        break;
      case "table-row-group":
        if (Rn[1] === "/") --row_ol;
        else ++row_ol;
        break;
      case "table-row":
      case "行":
        if (Rn[1] === "/") {
          R += rowpeat;
          rowpeat = 1;
          break;
        }
        rowtag = parsexmltag(Rn[0], false);
        if (rowtag["行号"]) R = rowtag["行号"] - 1;
        else if (R == -1) R = 0;
        rowpeat = +rowtag["number-rows-repeated"] || 1;
        if (rowpeat < 10) {
          for (i = 0; i < rowpeat; ++i) if (row_ol > 0) rowinfo[R + i] = { level: row_ol };
        }
        C = -1;
        break;
      case "covered-table-cell":
        if (Rn[1] !== "/") {
          ++C;
          ctag = parsexmltag(Rn[0], false);
          colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10) || 1;
          if (opts.sheetStubs) {
            while (colpeat-- > 0) {
              if (opts.dense) {
                if (!ws["!data"][R]) ws["!data"][R] = [];
                ws["!data"][R][C] = { t: "z" };
              } else ws[encode_cell({ r: R, c: C })] = { t: "z" };
              ++C;
            }
            --C;
          } else C += colpeat - 1;
        }
        textp = "";
        textR = [];
        break;
case "table-cell":
      case "数据":
        if (Rn[0].charAt(Rn[0].length - 2) === "/") {
          ++C;
          ctag = parsexmltag(Rn[0], false);
          colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10) || 1;
          q = {
            t: "z",
            v: null
};
          if (ctag.formula && opts.cellFormula != false) q.f = ods_to_csf_formula(unescapexml(ctag.formula));
          if (ctag["style-name"] && styles[ctag["style-name"]]) q.z = styles[ctag["style-name"]];
          if ((ctag["数据类型"] || ctag["value-type"]) == "string") {
            q.t = "s";
            q.v = unescapexml(ctag["string-value"] || "");
            if (opts.dense) {
              if (!ws["!data"][R]) ws["!data"][R] = [];
              ws["!data"][R][C] = q;
            } else {
              ws[encode_col(C) + encode_row(R)] = q;
            }
          }
          C += colpeat - 1;
        } else if (Rn[1] !== "/") {
          ++C;
          textp = oldtextp = "";
          textpidx = oldtextpidx = 0;
          textR = [];
          oldtextR = [];
          colpeat = 1;
          var rptR = rowpeat ? R + rowpeat - 1 : R;
          if (C > range.e.c) range.e.c = C;
          if (C < range.s.c) range.s.c = C;
          if (R < range.s.r) range.s.r = R;
          if (rptR > range.e.r) range.e.r = rptR;
          ctag = parsexmltag(Rn[0], false);
          ctag2 = parsexmltagraw(Rn[0]);
          comments = [];
          comment = {};
          q = {
            t: ctag["数据类型"] || ctag["value-type"],
            v: null
};
          if (ctag["style-name"] && styles[ctag["style-name"]]) q.z = styles[ctag["style-name"]];
          if (opts.cellFormula) {
            if (ctag.formula) ctag.formula = unescapexml(ctag.formula);
            if (ctag["number-matrix-columns-spanned"] && ctag["number-matrix-rows-spanned"]) {
              mR = parseInt(ctag["number-matrix-rows-spanned"], 10) || 0;
              mC = parseInt(ctag["number-matrix-columns-spanned"], 10) || 0;
              mrange = { s: { r: R, c: C }, e: { r: R + mR - 1, c: C + mC - 1 } };
              q.F = encode_range(mrange);
              arrayf.push([mrange, q.F]);
            }
            if (ctag.formula) q.f = ods_to_csf_formula(ctag.formula);
            else for (i = 0; i < arrayf.length; ++i)
              if (R >= arrayf[i][0].s.r && R <= arrayf[i][0].e.r) {
                if (C >= arrayf[i][0].s.c && C <= arrayf[i][0].e.c)
                  q.F = arrayf[i][1];
              }
          }
          if (ctag["number-columns-spanned"] || ctag["number-rows-spanned"]) {
            mR = parseInt(ctag["number-rows-spanned"] || "1", 10) || 1;
            mC = parseInt(ctag["number-columns-spanned"] || "1", 10) || 1;
            if (mR * mC > 1) {
              mrange = { s: { r: R, c: C }, e: { r: R + mR - 1, c: C + mC - 1 } };
              merges.push(mrange);
            }
          }
          if (ctag["number-columns-repeated"]) colpeat = parseInt(ctag["number-columns-repeated"], 10);
          switch (q.t) {
            case "boolean":
              q.t = "b";
              q.v = parsexmlbool(ctag["boolean-value"]) || +ctag["boolean-value"] >= 1;
              break;
            case "float":
              q.t = "n";
              q.v = parseFloat(ctag.value);
              if (opts.cellDates && q.z && fmt_is_date(q.z)) {
                q.v = numdate(q.v + (WB.WBProps.date1904 ? 1462 : 0));
                q.t = typeof q.v == "number" ? "n" : "d";
              }
              break;
            case "percentage":
              q.t = "n";
              q.v = parseFloat(ctag.value);
              break;
            case "currency":
              q.t = "n";
              q.v = parseFloat(ctag.value);
              break;
            case "date":
              q.t = "d";
              q.v = parseDate(ctag["date-value"], WB.WBProps.date1904);
              if (!opts.cellDates) {
                q.t = "n";
                q.v = datenum(q.v, WB.WBProps.date1904);
              }
              if (!q.z) q.z = "m/d/yy";
              break;
case "time":
              q.t = "n";
              q.v = parse_isodur(ctag["time-value"]) / 86400;
              if (opts.cellDates) {
                q.v = numdate(q.v);
                q.t = typeof q.v == "number" ? "n" : "d";
              }
              if (!q.z) q.z = "HH:MM:SS";
              break;
            case "number":
              q.t = "n";
              q.v = parseFloat(ctag["数据数值"]);
              break;
            default:
              if (q.t === "string" || q.t === "text" || !q.t) {
                q.t = "s";
                if (ctag["string-value"] != null) {
                  textp = unescapexml(ctag["string-value"]);
                  textR = [];
                }
              } else throw new Error("Unsupported value type " + q.t);
          }
        } else {
          isstub = false;
          if (ctag2["calcext:value-type"] == "error" && RBErr[textp] != null) {
            q.t = "e";
            q.w = textp;
            q.v = RBErr[textp];
          }
          if (q.t === "s") {
            q.v = textp || "";
            if (textR.length) q.R = textR;
            isstub = textpidx == 0;
          }
          if (atag.Target) q.l = atag;
          if (comments.length > 0) {
            q.c = comments;
            comments = [];
          }
          if (textp && opts.cellText !== false) q.w = textp;
          if (isstub) {
            q.t = "z";
            delete q.v;
          }
          if (!isstub || opts.sheetStubs) {
            if (!(opts.sheetRows && opts.sheetRows <= R)) {
              for (var rpt = 0; rpt < rowpeat; ++rpt) {
                colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
                if (opts.dense) {
                  if (!ws["!data"][R + rpt]) ws["!data"][R + rpt] = [];
                  ws["!data"][R + rpt][C] = rpt == 0 ? q : dup(q);
                  while (--colpeat > 0) ws["!data"][R + rpt][C + colpeat] = dup(q);
                } else {
                  ws[encode_cell({ r: R + rpt, c: C })] = q;
                  while (--colpeat > 0) ws[encode_cell({ r: R + rpt, c: C + colpeat })] = dup(q);
                }
                if (range.e.c <= C) range.e.c = C;
              }
            }
          }
          colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
          C += colpeat - 1;
          colpeat = 0;
          q = {
};
          textp = "";
          textR = [];
        }
        atag = {};
        break;

case "document":
case "document-content":
      case "电子表格文档":
case "spreadsheet":
      case "主体":
case "scripts":
case "styles":
case "font-face-decls":
case "master-styles":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], true]);
        break;
      case "annotation":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
          comment.t = textp;
          if (textR.length) comment.R = textR;
          comment.a = creator;
          comments.push(comment);
          textp = oldtextp;
          textpidx = oldtextpidx;
          textR = oldtextR;
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          state.push([Rn[3], false]);
          var annotag = parsexmltag(Rn[0], true);
          if (!(annotag["display"] && parsexmlbool(annotag["display"]))) comments.hidden = true;
          oldtextp = textp;
          oldtextpidx = textpidx;
          oldtextR = textR;
          textp = "";
          textpidx = 0;
          textR = [];
        }
        creator = "";
        creatoridx = 0;
        break;
      case "creator":
        if (Rn[1] === "/") {
          creator = str.slice(creatoridx, Rn.index);
        } else creatoridx = Rn.index + Rn[0].length;
        break;
case "meta":
      case "元数据":
case "settings":
case "config-item-set":
case "config-item-map-indexed":
case "config-item-map-entry":
case "config-item-map-named":
case "shapes":
case "frame":
case "text-box":
case "image":
case "data-pilot-tables":
case "list-style":
case "form":
case "dde-links":
case "event-listeners":
case "chart":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], false]);
        textp = "";
        textpidx = 0;
        textR = [];
        break;
      case "scientific-number":
case "currency-symbol":
case "fill-character":
        break;
      case "text-style":
case "boolean-style":
case "number-style":
case "currency-style":
case "percentage-style":
case "date-style":
case "time-style":
        if (Rn[1] === "/") {
          var xlmlidx = xlmlregex.lastIndex;
          parse_ods_styles(str.slice(nfidx, xlmlregex.lastIndex), _opts, number_format_map);
          xlmlregex.lastIndex = xlmlidx;
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          nfidx = xlmlregex.lastIndex - Rn[0].length;
        }
        break;
      case "script":
        break;
case "libraries":
        break;
case "automatic-styles":
        break;
case "default-style":
case "page-layout":
        break;
case "style":
        {
          var styletag = parsexmltag(Rn[0], false);
          if (styletag["family"] == "table-cell" && number_format_map[styletag["data-style-name"]]) styles[styletag["name"]] = number_format_map[styletag["data-style-name"]];
        }
        break;
      case "map":
        break;
case "font-face":
        break;
case "paragraph-properties":
        break;
case "table-properties":
        break;
case "table-column-properties":
        break;
case "table-row-properties":
        break;
case "table-cell-properties":
        break;
case "number":
        break;
      case "fraction":
        break;
case "day":
case "month":
case "year":
case "era":
case "day-of-week":
case "week-of-year":
case "quarter":
case "hours":
case "minutes":
case "seconds":
case "am-pm":
        break;
      case "boolean":
        break;
case "text":
        if (Rn[0].slice(-2) === "/>") break;
        else if (Rn[1] === "/") switch (state[state.length - 1][0]) {
          case "number-style":
          case "date-style":
          case "time-style":
            NF += str.slice(pidx, Rn.index);
            break;
        }
        else pidx = Rn.index + Rn[0].length;
        break;
      case "named-range":
        tag = parsexmltag(Rn[0], false);
        _Ref = ods_to_csf_3D(tag["cell-range-address"]);
        var nrange = { Name: tag.name, Ref: _Ref[0] + "!" + _Ref[1] };
        if (intable) nrange.Sheet = SheetNames.length;
        WB.Names.push(nrange);
        break;
      case "text-content":
        break;
case "text-properties":
        break;
case "embedded-text":
        break;
case "body":
      case "电子表格":
        break;
case "forms":
        break;
case "table-column":
        break;
case "table-header-rows":
        break;
case "table-rows":
        break;

case "table-column-group":
        break;
case "table-header-columns":
        break;
case "table-columns":
        break;
case "null-date":
        tag = parsexmltag(Rn[0], false);
        switch (tag["date-value"]) {
          case "1904-01-01":
            WB.WBProps.date1904 = true;
            break;
        }
        break;
      case "graphic-properties":
        break;
case "calculation-settings":
        break;
case "named-expressions":
        break;
case "label-range":
        break;
case "label-ranges":
        break;
case "named-expression":
        break;
case "sort":
        break;
case "sort-by":
        break;
case "sort-groups":
        break;
case "tab":
        break;
case "line-break":
        break;
case "span":
        break;
case "p":
      case "文本串":
        if (["master-styles"].indexOf(state[state.length - 1][0]) > -1) break;
        if (Rn[1] === "/" && (!ctag || !ctag["string-value"])) {
          var ptp = parse_text_p(str.slice(textpidx, Rn.index));
          textp = (textp.length > 0 ? textp + "\n" : "") + ptp[0];
        } else if (Rn[0].slice(-2) == "/>") {
          textp += "\n";
        } else {
          parsexmltag(Rn[0], false);
          textpidx = Rn.index + Rn[0].length;
        }
        break;
case "s":
        break;
case "database-range":
        if (Rn[1] === "/") break;
        try {
          _Ref = ods_to_csf_3D(parsexmltag(Rn[0])["target-range-address"]);
          Sheets[_Ref[0]]["!autofilter"] = { ref: _Ref[1] };
        } catch (e) {
        }
        break;
      case "date":
        break;
case "object":
        break;
case "title":
      case "标题":
        break;
case "desc":
        break;
case "binary-data":
        break;

case "table-source":
        break;
case "scenario":
        break;
case "iteration":
        break;
case "content-validations":
        break;
case "content-validation":
        break;
case "help-message":
        break;
case "error-message":
        break;
case "database-ranges":
        break;

case "filter":
        break;
case "filter-and":
        break;
case "filter-or":
        break;
case "filter-condition":
        break;
case "filter-set-item":
        break;
case "list-level-style-bullet":
        break;
case "list-level-style-number":
        break;
case "list-level-properties":
        break;

case "sender-firstname":
case "sender-lastname":
case "sender-initials":
case "sender-title":
case "sender-position":
case "sender-email":
case "sender-phone-private":
case "sender-fax":
case "sender-company":
case "sender-phone-work":
case "sender-street":
case "sender-city":
case "sender-postal-code":
case "sender-country":
case "sender-state-or-province":
case "author-name":
case "author-initials":
case "chapter":
case "file-name":
case "template-name":
case "sheet-name":
        break;
      case "event-listener":
        break;
case "initial-creator":
      case "creation-date":
      case "print-date":
      case "generator":
      case "document-statistic":
      case "user-defined":
      case "editing-duration":
      case "editing-cycles":
        break;
case "config-item":
        break;
case "page-number":
        break;
case "page-count":
        break;
case "time":
        break;

case "cell-range-source":
        break;
case "detective":
        break;
case "operation":
        break;
case "highlighted-range":
        break;

case "data-pilot-table":
case "source-cell-range":
case "source-service":
case "data-pilot-field":
case "data-pilot-level":
case "data-pilot-subtotals":
case "data-pilot-subtotal":
case "data-pilot-members":
case "data-pilot-member":
case "data-pilot-display-info":
case "data-pilot-sort-info":
case "data-pilot-layout-info":
case "data-pilot-field-reference":
case "data-pilot-groups":
case "data-pilot-group":
case "data-pilot-group-member":
        break;
case "rect":
        break;
case "dde-connection-decls":
case "dde-connection-decl":
case "dde-link":
case "dde-source":
        break;
      case "properties":
        break;
case "property":
        break;
case "a":
        if (Rn[1] !== "/") {
          atag = parsexmltag(Rn[0], false);
          if (!atag.href) break;
          atag.Target = unescapexml(atag.href);
          delete atag.href;
          if (atag.Target.charAt(0) == "#" && atag.Target.indexOf(".") > -1) {
            _Ref = ods_to_csf_3D(atag.Target.slice(1));
            atag.Target = "#" + _Ref[0] + "!" + _Ref[1];
          } else if (atag.Target.match(/^\.\.[\\\/]/)) atag.Target = atag.Target.slice(3);
        }
        break;
case "table-protection":
        break;
      case "data-pilot-grand-total":
        break;
case "office-document-common-attrs":
        break;
default:
        switch (Rn[2]) {
          case "dc:":
case "calcext:":
case "loext:":
case "ooo:":
case "chartooo:":
case "draw:":
case "style:":
case "chart:":
case "form:":
case "uof:":
case "表:":
case "字:":
            break;
          default:
            if (opts.WTF) throw new Error(Rn);
        }
    }
    var out = {
      Sheets,
      SheetNames,
      Workbook: WB
    };
    if (opts.bookSheets) delete
out.Sheets;
    return out;
  }
  function parse_ods(zip, opts) {
    opts = opts || {};
    if (safegetzipfile(zip, "META-INF/manifest.xml")) parse_manifest(getzipdata(zip, "META-INF/manifest.xml"), opts);
    var styles = getzipstr(zip, "styles.xml");
    var Styles = styles && parse_ods_styles(utf8read(styles));
    var content = getzipstr(zip, "content.xml");
    if (!content) throw new Error("Missing content.xml in ODS / UOF file");
    var wb = parse_content_xml(utf8read(content), opts, Styles);
    if (safegetzipfile(zip, "meta.xml")) wb.Props = parse_core_props(getzipdata(zip, "meta.xml"));
    wb.bookType = "ods";
    return wb;
  }
  function parse_fods(data, opts) {
    var wb = parse_content_xml(data, opts);
    wb.bookType = "fods";
    return wb;
  }
  var write_styles_ods = (function() {
    var master_styles = [
      "<office:master-styles>",
      '<style:master-page style:name="mp1" style:page-layout-name="mp1">',
      "<style:header/>",
      '<style:header-left style:display="false"/>',
      "<style:footer/>",
      '<style:footer-left style:display="false"/>',
      "</style:master-page>",
      "</office:master-styles>"
    ].join("");
    var payload = "<office:document-styles " + wxt_helper({
      "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
      "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
      "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
      "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
      "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
      "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      "xmlns:dc": "http://purl.org/dc/elements/1.1/",
      "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
      "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
      "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
      "office:version": "1.2"
    }) + ">" + master_styles + "</office:document-styles>";
    return function wso() {
      return XML_HEADER + payload;
    };
  })();
  function write_number_format_ods(nf, nfidx) {
    var type = "number", payload = "", nopts = { "style:name": nfidx }, c = "", i = 0;
    nf = nf.replace(/"[$]"/g, "$");
    j: {
      if (nf.indexOf(";") > -1) {
        console.error("Unsupported ODS Style Map exported.  Using first branch of " + nf);
        nf = nf.slice(0, nf.indexOf(";"));
      }
      if (nf == "@") {
        type = "text";
        payload = "<number:text-content/>";
        break j;
      }
      if (nf.indexOf(/\$/) > -1) {
        type = "currency";
      }
      if (nf[i] == '"') {
        c = "";
        while (nf[++i] != '"' || nf[++i] == '"') c += nf[i];
        --i;
        if (nf[i + 1] == "*") {
          i++;
          payload += "<number:fill-character>" + escapexml(c.replace(/""/g, '"')) + "</number:fill-character>";
        } else {
          payload += "<number:text>" + escapexml(c.replace(/""/g, '"')) + "</number:text>";
        }
        nf = nf.slice(i + 1);
        i = 0;
      }
      var t = nf.match(/# (\?+)\/(\?+)/);
      if (t) {
        payload += writextag("number:fraction", null, { "number:min-integer-digits": 0, "number:min-numerator-digits": t[1].length, "number:max-denominator-value": Math.max(+t[1].replace(/./g, "9"), +t[2].replace(/./g, "9")) });
        break j;
      }
      if (t = nf.match(/# (\?+)\/(\d+)/)) {
        payload += writextag("number:fraction", null, { "number:min-integer-digits": 0, "number:min-numerator-digits": t[1].length, "number:denominator-value": +t[2] });
        break j;
      }
      if (t = nf.match(/\b(\d+)(|\.\d+)%/)) {
        type = "percentage";
        payload += writextag("number:number", null, { "number:decimal-places": t[2] && t.length - 1 || 0, "number:min-decimal-places": t[2] && t.length - 1 || 0, "number:min-integer-digits": t[1].length }) + "<number:text>%</number:text>";
        break j;
      }
      var has_time = false;
      if (["y", "m", "d"].indexOf(nf[0]) > -1) {
        type = "date";
        k: for (; i < nf.length; ++i) switch (c = nf[i].toLowerCase()) {
          case "h":
          case "s":
            has_time = true;
            --i;
            break k;
          case "m":
            l: for (var h2 = i + 1; h2 < nf.length; ++h2) switch (nf[h2]) {
              case "y":
              case "d":
                break l;
              case "h":
              case "s":
                has_time = true;
                --i;
                break k;
            }
case "y":
          case "d":
            while ((nf[++i] || "").toLowerCase() == c[0]) c += c[0];
            --i;
            switch (c) {
              case "y":
              case "yy":
                payload += "<number:year/>";
                break;
              case "yyy":
              case "yyyy":
                payload += '<number:year number:style="long"/>';
                break;
              case "mmmmm":
                console.error("ODS has no equivalent of format |mmmmm|");
case "m":
              case "mm":
              case "mmm":
              case "mmmm":
                payload += '<number:month number:style="' + (c.length % 2 ? "short" : "long") + '" number:textual="' + (c.length >= 3 ? "true" : "false") + '"/>';
                break;
              case "d":
              case "dd":
                payload += '<number:day number:style="' + (c.length % 2 ? "short" : "long") + '"/>';
                break;
              case "ddd":
              case "dddd":
                payload += '<number:day-of-week number:style="' + (c.length % 2 ? "short" : "long") + '"/>';
                break;
            }
            break;
          case '"':
            while (nf[++i] != '"' || nf[++i] == '"') c += nf[i];
            --i;
            payload += "<number:text>" + escapexml(c.slice(1).replace(/""/g, '"')) + "</number:text>";
            break;
          case "\\":
            c = nf[++i];
            payload += "<number:text>" + escapexml(c) + "</number:text>";
            break;
          case "/":
          case ":":
            payload += "<number:text>" + escapexml(c) + "</number:text>";
            break;
          default:
            console.error("unrecognized character " + c + " in ODF format " + nf);
        }
        if (!has_time) break j;
        nf = nf.slice(i + 1);
        i = 0;
      }
      if (nf.match(/^\[?[hms]/)) {
        if (type == "number") type = "time";
        if (nf.match(/\[/)) {
          nf = nf.replace(/[\[\]]/g, "");
          nopts["number:truncate-on-overflow"] = "false";
        }
        for (; i < nf.length; ++i) switch (c = nf[i].toLowerCase()) {
          case "h":
          case "m":
          case "s":
            while ((nf[++i] || "").toLowerCase() == c[0]) c += c[0];
            --i;
            switch (c) {
              case "h":
              case "hh":
                payload += '<number:hours number:style="' + (c.length % 2 ? "short" : "long") + '"/>';
                break;
              case "m":
              case "mm":
                payload += '<number:minutes number:style="' + (c.length % 2 ? "short" : "long") + '"/>';
                break;
              case "s":
              case "ss":
                if (nf[i + 1] == ".") do {
                  c += nf[i + 1];
                  ++i;
                } while (nf[i + 1] == "0");
                payload += '<number:seconds number:style="' + (c.match("ss") ? "long" : "short") + '"' + (c.match(/\./) ? ' number:decimal-places="' + (c.match(/0+/) || [""])[0].length + '"' : "") + "/>";
                break;
            }
            break;
          case '"':
            while (nf[++i] != '"' || nf[++i] == '"') c += nf[i];
            --i;
            payload += "<number:text>" + escapexml(c.slice(1).replace(/""/g, '"')) + "</number:text>";
            break;
          case "/":
          case ":":
            payload += "<number:text>" + escapexml(c) + "</number:text>";
            break;
          case "a":
            if (nf.slice(i, i + 3).toLowerCase() == "a/p") {
              payload += "<number:am-pm/>";
              i += 2;
              break;
            }
            if (nf.slice(i, i + 5).toLowerCase() == "am/pm") {
              payload += "<number:am-pm/>";
              i += 4;
              break;
            }
default:
            console.error("unrecognized character " + c + " in ODF format " + nf);
        }
        break j;
      }
      if (nf.indexOf(/\$/) > -1) {
        type = "currency";
      }
      if (nf[0] == "$") {
        payload += '<number:currency-symbol number:language="en" number:country="US">$</number:currency-symbol>';
        nf = nf.slice(1);
        i = 0;
      }
      i = 0;
      if (nf[i] == '"') {
        while (nf[++i] != '"' || nf[++i] == '"') c += nf[i];
        --i;
        if (nf[i + 1] == "*") {
          i++;
          payload += "<number:fill-character>" + escapexml(c.replace(/""/g, '"')) + "</number:fill-character>";
        } else {
          payload += "<number:text>" + escapexml(c.replace(/""/g, '"')) + "</number:text>";
        }
        nf = nf.slice(i + 1);
        i = 0;
      }
      var np = nf.match(/([#0][0#,]*)(\.[0#]*|)(E[+]?0*|)/i);
      if (!np || !np[0]) console.error("Could not find numeric part of " + nf);
      else {
        var base = np[1].replace(/,/g, "");
        payload += "<number:" + (np[3] ? "scientific-" : "") + 'number number:min-integer-digits="' + (base.indexOf("0") == -1 ? "0" : base.length - base.indexOf("0")) + '"' + (np[0].indexOf(",") > -1 ? ' number:grouping="true"' : "") + (np[2] && ' number:decimal-places="' + (np[2].length - 1) + '"' || ' number:decimal-places="0"') + (np[3] && np[3].indexOf("+") > -1 ? ' number:forced-exponent-sign="true"' : "") + (np[3] ? ' number:min-exponent-digits="' + np[3].match(/0+/)[0].length + '"' : "") + "></number:" + (np[3] ? "scientific-" : "") + "number>";
        i = np.index + np[0].length;
      }
      if (nf[i] == '"') {
        c = "";
        while (nf[++i] != '"' || nf[++i] == '"') c += nf[i];
        --i;
        payload += "<number:text>" + escapexml(c.replace(/""/g, '"')) + "</number:text>";
      }
    }
    if (!payload) {
      console.error("Could not generate ODS number format for |" + nf + "|");
      return "";
    }
    return writextag("number:" + type + "-style", payload, nopts);
  }
  function write_names_ods(Names, SheetNames, idx) {
    var scoped = [];
    for (var namei = 0; namei < Names.length; ++namei) {
      var name = Names[namei];
      if (!name) continue;
      if (name.Sheet == (idx == -1 ? null : idx)) scoped.push(name);
    }
    if (!scoped.length) return "";
    return "      <table:named-expressions>\n" + scoped.map(function(name2) {
      var odsref = (idx == -1 ? "$" : "") + csf_to_ods_3D(name2.Ref);
      return "        " + writextag("table:named-range", null, {
        "table:name": name2.Name,
        "table:cell-range-address": odsref,
        "table:base-cell-address": odsref.replace(/[\.][^\.]*$/, ".$A$1")
      });
    }).join("\n") + "\n      </table:named-expressions>\n";
  }
  var write_content_ods = (function() {
    var write_text_p = function(text, span) {
      return escapexml(text).replace(/  +/g, function($$) {
        return '<text:s text:c="' + $$.length + '"/>';
      }).replace(/\t/g, "<text:tab/>").replace(/\n/g, "</text:p><text:p>").replace(/^ /, "<text:s/>").replace(/ $/, "<text:s/>");
    };
    var null_cell_xml = "          <table:table-cell />\n";
    var write_ws = function(ws, wb, i, opts, nfs, date1904) {
      var o = [];
      o.push('      <table:table table:name="' + escapexml(wb.SheetNames[i]) + '" table:style-name="ta1">\n');
      var R = 0, C = 0, range = decode_range(ws["!ref"] || "A1");
      var marr = ws["!merges"] || [], mi = 0;
      var dense = ws["!data"] != null;
      if (ws["!cols"]) {
        for (C = 0; C <= range.e.c; ++C) o.push("        <table:table-column" + (ws["!cols"][C] ? ' table:style-name="co' + ws["!cols"][C].ods + '"' : "") + "></table:table-column>\n");
      }
      var H = "", ROWS = ws["!rows"] || [];
      for (R = 0; R < range.s.r; ++R) {
        H = ROWS[R] ? ' table:style-name="ro' + ROWS[R].ods + '"' : "";
        o.push("        <table:table-row" + H + "></table:table-row>\n");
      }
      for (; R <= range.e.r; ++R) {
        H = ROWS[R] ? ' table:style-name="ro' + ROWS[R].ods + '"' : "";
        o.push("        <table:table-row" + H + ">\n");
        for (C = 0; C < range.s.c; ++C) o.push(null_cell_xml);
        for (; C <= range.e.c; ++C) {
          var skip = false, ct = {}, textp = "";
          for (mi = 0; mi != marr.length; ++mi) {
            if (marr[mi].s.c > C) continue;
            if (marr[mi].s.r > R) continue;
            if (marr[mi].e.c < C) continue;
            if (marr[mi].e.r < R) continue;
            if (marr[mi].s.c != C || marr[mi].s.r != R) skip = true;
            ct["table:number-columns-spanned"] = marr[mi].e.c - marr[mi].s.c + 1;
            ct["table:number-rows-spanned"] = marr[mi].e.r - marr[mi].s.r + 1;
            break;
          }
          if (skip) {
            o.push("          <table:covered-table-cell/>\n");
            continue;
          }
          var ref2 = encode_cell({ r: R, c: C }), cell = dense ? (ws["!data"][R] || [])[C] : ws[ref2];
          if (cell && cell.f) {
            ct["table:formula"] = escapexml(csf_to_ods_formula(cell.f));
            if (cell.F) {
              if (cell.F.slice(0, ref2.length) == ref2) {
                var _Fref = decode_range(cell.F);
                ct["table:number-matrix-columns-spanned"] = _Fref.e.c - _Fref.s.c + 1;
                ct["table:number-matrix-rows-spanned"] = _Fref.e.r - _Fref.s.r + 1;
              }
            }
          }
          if (!cell) {
            o.push(null_cell_xml);
            continue;
          }
          switch (cell.t) {
            case "b":
              textp = cell.v ? "TRUE" : "FALSE";
              ct["office:value-type"] = "boolean";
              ct["office:boolean-value"] = cell.v ? "true" : "false";
              break;
            case "n":
              if (!isFinite(cell.v)) {
                if (isNaN(cell.v)) {
                  textp = "#NUM!";
                  ct["table:formula"] = "of:=#NUM!";
                } else {
                  textp = "#DIV/0!";
                  ct["table:formula"] = "of:=" + (cell.v < 0 ? "-" : "") + "1/0";
                }
                ct["office:string-value"] = "";
                ct["office:value-type"] = "string";
                ct["calcext:value-type"] = "error";
              } else {
                textp = cell.w || String(cell.v || 0);
                ct["office:value-type"] = "float";
                ct["office:value"] = cell.v || 0;
              }
              break;
            case "s":
            case "str":
              textp = cell.v == null ? "" : cell.v;
              ct["office:value-type"] = "string";
              break;
            case "d":
              textp = cell.w || parseDate(cell.v, date1904).toISOString();
              ct["office:value-type"] = "date";
              ct["office:date-value"] = parseDate(cell.v, date1904).toISOString();
              ct["table:style-name"] = "ce1";
              break;
default:
              o.push(null_cell_xml);
              continue;
          }
          var text_p = write_text_p(textp);
          if (cell.l && cell.l.Target) {
            var _tgt = cell.l.Target;
            _tgt = _tgt.charAt(0) == "#" ? "#" + csf_to_ods_3D(_tgt.slice(1)) : _tgt;
            if (_tgt.charAt(0) != "#" && !_tgt.match(/^\w+:/)) _tgt = "../" + _tgt;
            text_p = writextag("text:a", text_p, { "xlink:href": _tgt.replace(/&/g, "&amp;") });
          }
          if (nfs[cell.z]) ct["table:style-name"] = "ce" + nfs[cell.z].slice(1);
          var payload = writextag("text:p", text_p, {});
          if (cell.c) {
            var acreator = "", apayload = "", aprops = {};
            for (var ci = 0; ci < cell.c.length; ++ci) {
              if (!acreator && cell.c[ci].a) acreator = cell.c[ci].a;
              apayload += "<text:p>" + write_text_p(cell.c[ci].t) + "</text:p>";
            }
            if (!cell.c.hidden) aprops["office:display"] = true;
            payload = writextag("office:annotation", apayload, aprops) + payload;
          }
          o.push("          " + writextag("table:table-cell", payload, ct) + "\n");
        }
        o.push("        </table:table-row>\n");
      }
      if ((wb.Workbook || {}).Names) o.push(write_names_ods(wb.Workbook.Names, wb.SheetNames, i));
      o.push("      </table:table>\n");
      return o.join("");
    };
    var write_automatic_styles_ods = function(o, wb) {
      o.push(" <office:automatic-styles>\n");
      var cidx = 0;
      wb.SheetNames.map(function(n) {
        return wb.Sheets[n];
      }).forEach(function(ws) {
        if (!ws) return;
        if (ws["!cols"]) {
          for (var C = 0; C < ws["!cols"].length; ++C) if (ws["!cols"][C]) {
            var colobj = ws["!cols"][C];
            if (colobj.width == null && colobj.wpx == null && colobj.wch == null) continue;
            process_col(colobj);
            colobj.ods = cidx;
            var w = ws["!cols"][C].wpx + "px";
            o.push('  <style:style style:name="co' + cidx + '" style:family="table-column">\n');
            o.push('   <style:table-column-properties fo:break-before="auto" style:column-width="' + w + '"/>\n');
            o.push("  </style:style>\n");
            ++cidx;
          }
        }
      });
      var ridx = 0;
      wb.SheetNames.map(function(n) {
        return wb.Sheets[n];
      }).forEach(function(ws) {
        if (!ws) return;
        if (ws["!rows"]) {
          for (var R = 0; R < ws["!rows"].length; ++R) if (ws["!rows"][R]) {
            ws["!rows"][R].ods = ridx;
            var h2 = ws["!rows"][R].hpx + "px";
            o.push('  <style:style style:name="ro' + ridx + '" style:family="table-row">\n');
            o.push('   <style:table-row-properties fo:break-before="auto" style:row-height="' + h2 + '"/>\n');
            o.push("  </style:style>\n");
            ++ridx;
          }
        }
      });
      o.push('  <style:style style:name="ta1" style:family="table" style:master-page-name="mp1">\n');
      o.push('   <style:table-properties table:display="true" style:writing-mode="lr-tb"/>\n');
      o.push("  </style:style>\n");
      o.push('  <number:date-style style:name="N37" number:automatic-order="true">\n');
      o.push('   <number:month number:style="long"/>\n');
      o.push("   <number:text>/</number:text>\n");
      o.push('   <number:day number:style="long"/>\n');
      o.push("   <number:text>/</number:text>\n");
      o.push("   <number:year/>\n");
      o.push("  </number:date-style>\n");
      var nfs = {};
      var nfi = 69;
      wb.SheetNames.map(function(n) {
        return wb.Sheets[n];
      }).forEach(function(ws) {
        if (!ws) return;
        var dense = ws["!data"] != null;
        if (!ws["!ref"]) return;
        var range = decode_range(ws["!ref"]);
        for (var R = 0; R <= range.e.r; ++R) for (var C = 0; C <= range.e.c; ++C) {
          var c = dense ? (ws["!data"][R] || [])[C] : ws[encode_cell({ r: R, c: C })];
          if (!c || !c.z || c.z.toLowerCase() == "general") continue;
          if (!nfs[c.z]) {
            var out = write_number_format_ods(c.z, "N" + nfi);
            if (out) {
              nfs[c.z] = "N" + nfi;
              ++nfi;
              o.push(out + "\n");
            }
          }
        }
      });
      o.push('  <style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/>\n');
      keys(nfs).forEach(function(nf) {
        o.push('<style:style style:name="ce' + nfs[nf].slice(1) + '" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="' + nfs[nf] + '"/>\n');
      });
      o.push(" </office:automatic-styles>\n");
      return nfs;
    };
    return function wcx(wb, opts) {
      var o = [XML_HEADER];
      var attr = wxt_helper({
        "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
        "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
        "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
        "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
        "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
        "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
        "xmlns:xlink": "http://www.w3.org/1999/xlink",
        "xmlns:dc": "http://purl.org/dc/elements/1.1/",
        "xmlns:meta": "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
        "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
        "xmlns:presentation": "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
        "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
        "xmlns:chart": "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
        "xmlns:dr3d": "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
        "xmlns:math": "http://www.w3.org/1998/Math/MathML",
        "xmlns:form": "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
        "xmlns:script": "urn:oasis:names:tc:opendocument:xmlns:script:1.0",
        "xmlns:ooo": "http://openoffice.org/2004/office",
        "xmlns:ooow": "http://openoffice.org/2004/writer",
        "xmlns:oooc": "http://openoffice.org/2004/calc",
        "xmlns:dom": "http://www.w3.org/2001/xml-events",
        "xmlns:xforms": "http://www.w3.org/2002/xforms",
        "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
        "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
        "xmlns:sheet": "urn:oasis:names:tc:opendocument:sh33tjs:1.0",
        "xmlns:rpt": "http://openoffice.org/2005/report",
        "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
        "xmlns:xhtml": "http://www.w3.org/1999/xhtml",
        "xmlns:grddl": "http://www.w3.org/2003/g/data-view#",
        "xmlns:tableooo": "http://openoffice.org/2009/table",
        "xmlns:drawooo": "http://openoffice.org/2010/draw",
        "xmlns:calcext": "urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0",
        "xmlns:loext": "urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0",
        "xmlns:field": "urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0",
        "xmlns:formx": "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0",
        "xmlns:css3t": "http://www.w3.org/TR/css3-text/",
        "office:version": "1.2"
      });
      var fods = wxt_helper({
        "xmlns:config": "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
        "office:mimetype": "application/vnd.oasis.opendocument.spreadsheet"
      });
      if (opts.bookType == "fods") {
        o.push("<office:document" + attr + fods + ">\n");
        o.push(write_meta_ods().replace(/<office:document-meta[^<>]*?>/, "").replace(/<\/office:document-meta>/, "") + "\n");
      } else o.push("<office:document-content" + attr + ">\n");
      var nfs = write_automatic_styles_ods(o, wb);
      o.push("  <office:body>\n");
      o.push("    <office:spreadsheet>\n");
      if (((wb.Workbook || {}).WBProps || {}).date1904) o.push('      <table:calculation-settings table:case-sensitive="false" table:search-criteria-must-apply-to-whole-cell="true" table:use-wildcards="true" table:use-regular-expressions="false" table:automatic-find-labels="false">\n        <table:null-date table:date-value="1904-01-01"/>\n      </table:calculation-settings>\n');
      for (var i = 0; i != wb.SheetNames.length; ++i) o.push(write_ws(wb.Sheets[wb.SheetNames[i]], wb, i, opts, nfs, ((wb.Workbook || {}).WBProps || {}).date1904));
      if ((wb.Workbook || {}).Names) o.push(write_names_ods(wb.Workbook.Names, wb.SheetNames, -1));
      o.push("    </office:spreadsheet>\n");
      o.push("  </office:body>\n");
      if (opts.bookType == "fods") o.push("</office:document>");
      else o.push("</office:document-content>");
      return o.join("");
    };
  })();
  function write_ods(wb, opts) {
    if (opts.bookType == "fods") return write_content_ods(wb, opts);
    var zip = zip_new();
    var f = "";
    var manifest = [];
    var rdf = [];
    f = "mimetype";
    zip_add_file(zip, f, "application/vnd.oasis.opendocument.spreadsheet");
    f = "content.xml";
    zip_add_file(zip, f, write_content_ods(wb, opts));
    manifest.push([f, "text/xml"]);
    rdf.push([f, "ContentFile"]);
    f = "styles.xml";
    zip_add_file(zip, f, write_styles_ods(wb, opts));
    manifest.push([f, "text/xml"]);
    rdf.push([f, "StylesFile"]);
    f = "meta.xml";
    zip_add_file(zip, f, XML_HEADER + write_meta_ods(
));
    manifest.push([f, "text/xml"]);
    rdf.push([f, "MetadataFile"]);
    f = "manifest.rdf";
    zip_add_file(zip, f, write_rdf(
      rdf
));
    manifest.push([f, "application/rdf+xml"]);
    f = "META-INF/manifest.xml";
    zip_add_file(zip, f, write_manifest(
      manifest
));
    return zip;
  }
var subarray = (function() {
    try {
      if (typeof Uint8Array == "undefined")
        return "slice";
      if (typeof Uint8Array.prototype.subarray == "undefined")
        return "slice";
      if (typeof Buffer !== "undefined") {
        if (typeof Buffer.prototype.subarray == "undefined")
          return "slice";
        if ((typeof Buffer.from == "function" ? Buffer.from([72, 62]) : new Buffer([72, 62])) instanceof Uint8Array)
          return "subarray";
        return "slice";
      }
      return "subarray";
    } catch (e) {
      return "slice";
    }
  })();
  function u8_to_dataview(array) {
    return new DataView(array.buffer, array.byteOffset, array.byteLength);
  }
  function u8str(u8) {
    return typeof TextDecoder != "undefined" ? new TextDecoder().decode(u8) : utf8read(a2s(u8));
  }
  function stru8(str) {
    return typeof TextEncoder != "undefined" ? new TextEncoder().encode(str) : s2a(utf8write(str));
  }
  function u8concat(u8a) {
    var len = 0;
    for (var i = 0; i < u8a.length; ++i)
      len += u8a[i].length;
    var out = new Uint8Array(len);
    var off = 0;
    for (i = 0; i < u8a.length; ++i) {
      var u8 = u8a[i], L = u8.length;
      if (L < 250) {
        for (var j = 0; j < L; ++j)
          out[off++] = u8[j];
      } else {
        out.set(u8, off);
        off += L;
      }
    }
    return out;
  }
  function popcnt(x) {
    x -= x >> 1 & 1431655765;
    x = (x & 858993459) + (x >> 2 & 858993459);
    return (x + (x >> 4) & 252645135) * 16843009 >>> 24;
  }
  function readDecimal128LE(buf, offset) {
    var exp = (buf[offset + 15] & 127) << 7 | buf[offset + 14] >> 1;
    var mantissa = buf[offset + 14] & 1;
    for (var j = offset + 13; j >= offset; --j)
      mantissa = mantissa * 256 + buf[j];
    return (buf[offset + 15] & 128 ? -mantissa : mantissa) * Math.pow(10, exp - 6176);
  }
  function writeDecimal128LE(buf, offset, value) {
    var exp = Math.floor(value == 0 ? 0 : Math.LOG10E * Math.log(Math.abs(value))) + 6176 - 16;
    var mantissa = value / Math.pow(10, exp - 6176);
    buf[offset + 15] |= exp >> 7;
    buf[offset + 14] |= (exp & 127) << 1;
    for (var i = 0; mantissa >= 1; ++i, mantissa /= 256)
      buf[offset + i] = mantissa & 255;
    buf[offset + 15] |= value >= 0 ? 0 : 128;
  }
  function parse_varint49(buf, ptr) {
    var l = ptr.l;
    var usz = buf[l] & 127;
    varint:
      if (buf[l++] >= 128) {
        usz |= (buf[l] & 127) << 7;
        if (buf[l++] < 128)
          break varint;
        usz |= (buf[l] & 127) << 14;
        if (buf[l++] < 128)
          break varint;
        usz |= (buf[l] & 127) << 21;
        if (buf[l++] < 128)
          break varint;
        usz += (buf[l] & 127) * Math.pow(2, 28);
        ++l;
        if (buf[l++] < 128)
          break varint;
        usz += (buf[l] & 127) * Math.pow(2, 35);
        ++l;
        if (buf[l++] < 128)
          break varint;
        usz += (buf[l] & 127) * Math.pow(2, 42);
        ++l;
        if (buf[l++] < 128)
          break varint;
      }
    ptr.l = l;
    return usz;
  }
  function write_varint49(v) {
    var usz = new Uint8Array(7);
    usz[0] = v & 127;
    var L = 1;
    sz:
      if (v > 127) {
        usz[L - 1] |= 128;
        usz[L] = v >> 7 & 127;
        ++L;
        if (v <= 16383)
          break sz;
        usz[L - 1] |= 128;
        usz[L] = v >> 14 & 127;
        ++L;
        if (v <= 2097151)
          break sz;
        usz[L - 1] |= 128;
        usz[L] = v >> 21 & 127;
        ++L;
        if (v <= 268435455)
          break sz;
        usz[L - 1] |= 128;
        usz[L] = v / 256 >>> 21 & 127;
        ++L;
        if (v <= 34359738367)
          break sz;
        usz[L - 1] |= 128;
        usz[L] = v / 65536 >>> 21 & 127;
        ++L;
        if (v <= 4398046511103)
          break sz;
        usz[L - 1] |= 128;
        usz[L] = v / 16777216 >>> 21 & 127;
        ++L;
      }
    return usz[subarray](0, L);
  }
  function parse_packed_varints(buf) {
    var ptr = { l: 0 };
    var out = [];
    while (ptr.l < buf.length)
      out.push(parse_varint49(buf, ptr));
    return out;
  }
  function write_packed_varints(nums) {
    return u8concat(nums.map(function(x) {
      return write_varint49(x);
    }));
  }
  function varint_to_i32(buf) {
    var l = 0, i32 = buf[l] & 127;
    if (buf[l++] < 128)
      return i32;
    i32 |= (buf[l] & 127) << 7;
    if (buf[l++] < 128)
      return i32;
    i32 |= (buf[l] & 127) << 14;
    if (buf[l++] < 128)
      return i32;
    i32 |= (buf[l] & 127) << 21;
    if (buf[l++] < 128)
      return i32;
    i32 |= (buf[l] & 15) << 28;
    return i32;
  }
  function parse_shallow(buf) {
    var out = [], ptr = { l: 0 };
    while (ptr.l < buf.length) {
      var off = ptr.l;
      var num = parse_varint49(buf, ptr);
      var type = num & 7;
      num = num / 8 | 0;
      var data;
      var l = ptr.l;
      switch (type) {
        case 0:
          {
            while (buf[l++] >= 128)
              ;
            data = buf[subarray](ptr.l, l);
            ptr.l = l;
          }
          break;
        case 1:
          {
            data = buf[subarray](l, l + 8);
            ptr.l = l + 8;
          }
          break;
        case 2:
          {
            var len = parse_varint49(buf, ptr);
            data = buf[subarray](ptr.l, ptr.l + len);
            ptr.l += len;
          }
          break;
        case 5:
          {
            data = buf[subarray](l, l + 4);
            ptr.l = l + 4;
          }
          break;
        default:
          throw new Error("PB Type ".concat(type, " for Field ").concat(num, " at offset ").concat(off));
      }
      var v = { data, type };
      if (out[num] == null)
        out[num] = [];
      out[num].push(v);
    }
    return out;
  }
  function write_shallow(proto) {
    var out = [];
    proto.forEach(function(field, idx) {
      if (idx == 0)
        return;
      field.forEach(function(item) {
        if (!item.data)
          return;
        out.push(write_varint49(idx * 8 + item.type));
        if (item.type == 2)
          out.push(write_varint49(item.data.length));
        out.push(item.data);
      });
    });
    return u8concat(out);
  }
  function mappa(data, cb) {
    return (data == null ? void 0 : data.map(function(d) {
      return cb(d.data);
    })) || [];
  }
  function parse_iwa_file(buf) {
    var _a;
    var out = [], ptr = { l: 0 };
    while (ptr.l < buf.length) {
      var len = parse_varint49(buf, ptr);
      var ai = parse_shallow(buf[subarray](ptr.l, ptr.l + len));
      ptr.l += len;
      var res = {
        id: varint_to_i32(ai[1][0].data),
        messages: []
      };
      ai[2].forEach(function(b) {
        var mi = parse_shallow(b.data);
        var fl = varint_to_i32(mi[3][0].data);
        res.messages.push({
          meta: mi,
          data: buf[subarray](ptr.l, ptr.l + fl)
        });
        ptr.l += fl;
      });
      if ((_a = ai[3]) == null ? void 0 : _a[0])
        res.merge = varint_to_i32(ai[3][0].data) >>> 0 > 0;
      out.push(res);
    }
    return out;
  }
  function write_iwa_file(ias) {
    var bufs = [];
    ias.forEach(function(ia) {
      var ai = [
        [],
        [{ data: write_varint49(ia.id), type: 0 }],
        []
      ];
      if (ia.merge != null)
        ai[3] = [{ data: write_varint49(+!!ia.merge), type: 0 }];
      var midata = [];
      ia.messages.forEach(function(mi) {
        midata.push(mi.data);
        mi.meta[3] = [{ type: 0, data: write_varint49(mi.data.length) }];
        ai[2].push({ data: write_shallow(mi.meta), type: 2 });
      });
      var aipayload = write_shallow(ai);
      bufs.push(write_varint49(aipayload.length));
      bufs.push(aipayload);
      midata.forEach(function(mid) {
        return bufs.push(mid);
      });
    });
    return u8concat(bufs);
  }
  function parse_snappy_chunk(type, buf) {
    if (type != 0)
      throw new Error("Unexpected Snappy chunk type ".concat(type));
    var ptr = { l: 0 };
    var usz = parse_varint49(buf, ptr);
    var chunks = [];
    var l = ptr.l;
    while (l < buf.length) {
      var tag = buf[l] & 3;
      if (tag == 0) {
        var len = buf[l++] >> 2;
        if (len < 60)
          ++len;
        else {
          var c = len - 59;
          len = buf[l];
          if (c > 1)
            len |= buf[l + 1] << 8;
          if (c > 2)
            len |= buf[l + 2] << 16;
          if (c > 3)
            len |= buf[l + 3] << 24;
          len >>>= 0;
          len++;
          l += c;
        }
        chunks.push(buf[subarray](l, l + len));
        l += len;
        continue;
      } else {
        var offset = 0, length = 0;
        if (tag == 1) {
          length = (buf[l] >> 2 & 7) + 4;
          offset = (buf[l++] & 224) << 3;
          offset |= buf[l++];
        } else {
          length = (buf[l++] >> 2) + 1;
          if (tag == 2) {
            offset = buf[l] | buf[l + 1] << 8;
            l += 2;
          } else {
            offset = (buf[l] | buf[l + 1] << 8 | buf[l + 2] << 16 | buf[l + 3] << 24) >>> 0;
            l += 4;
          }
        }
        if (offset == 0)
          throw new Error("Invalid offset 0");
        var j = chunks.length - 1, off = offset;
        while (j >= 0 && off >= chunks[j].length) {
          off -= chunks[j].length;
          --j;
        }
        if (j < 0) {
          if (off == 0)
            off = chunks[j = 0].length;
          else
            throw new Error("Invalid offset beyond length");
        }
        if (length < off)
          chunks.push(chunks[j][subarray](chunks[j].length - off, chunks[j].length - off + length));
        else {
          if (off > 0) {
            chunks.push(chunks[j][subarray](chunks[j].length - off));
            length -= off;
          }
          ++j;
          while (length >= chunks[j].length) {
            chunks.push(chunks[j]);
            length -= chunks[j].length;
            ++j;
          }
          if (length)
            chunks.push(chunks[j][subarray](0, length));
        }
        if (chunks.length > 25)
          chunks = [u8concat(chunks)];
      }
    }
    var clen = 0;
    for (var u8i = 0; u8i < chunks.length; ++u8i)
      clen += chunks[u8i].length;
    if (clen != usz)
      throw new Error("Unexpected length: ".concat(clen, " != ").concat(usz));
    return chunks;
  }
  function decompress_iwa_file(buf) {
    if (Array.isArray(buf))
      buf = new Uint8Array(buf);
    var out = [];
    var l = 0;
    while (l < buf.length) {
      var t = buf[l++];
      var len = buf[l] | buf[l + 1] << 8 | buf[l + 2] << 16;
      l += 3;
      out.push.apply(out, parse_snappy_chunk(t, buf[subarray](l, l + len)));
      l += len;
    }
    if (l !== buf.length)
      throw new Error("data is not a valid framed stream!");
    return out.length == 1 ? out[0] : u8concat(out);
  }
  function compress_iwa_file(buf) {
    var out = [];
    var l = 0;
    while (l < buf.length) {
      var c = Math.min(buf.length - l, 268435455);
      var frame = new Uint8Array(4);
      out.push(frame);
      var usz = write_varint49(c);
      var L = usz.length;
      out.push(usz);
      if (c <= 60) {
        L++;
        out.push(new Uint8Array([c - 1 << 2]));
      } else if (c <= 256) {
        L += 2;
        out.push(new Uint8Array([240, c - 1 & 255]));
      } else if (c <= 65536) {
        L += 3;
        out.push(new Uint8Array([244, c - 1 & 255, c - 1 >> 8 & 255]));
      } else if (c <= 16777216) {
        L += 4;
        out.push(new Uint8Array([248, c - 1 & 255, c - 1 >> 8 & 255, c - 1 >> 16 & 255]));
      } else if (c <= 4294967296) {
        L += 5;
        out.push(new Uint8Array([252, c - 1 & 255, c - 1 >> 8 & 255, c - 1 >> 16 & 255, c - 1 >>> 24 & 255]));
      }
      out.push(buf[subarray](l, l + c));
      L += c;
      frame[0] = 0;
      frame[1] = L & 255;
      frame[2] = L >> 8 & 255;
      frame[3] = L >> 16 & 255;
      l += c;
    }
    return u8concat(out);
  }
  var numbers_lut_new = function() {
    return { sst: [], rsst: [], ofmt: [], nfmt: [], fmla: [], ferr: [], cmnt: [] };
  };
  function numbers_format_cell(cell, t, flags, ofmt, nfmt) {
    var _a, _b, _c, _d;
    var ctype = t & 255, ver = t >> 8;
    var fmt = ver >= 5 ? nfmt : ofmt;
    dur:
      if (flags & (ver > 4 ? 8 : 4) && cell.t == "n" && ctype == 7) {
        var dstyle = ((_a = fmt[7]) == null ? void 0 : _a[0]) ? varint_to_i32(fmt[7][0].data) : -1;
        if (dstyle == -1)
          break dur;
        var dmin = ((_b = fmt[15]) == null ? void 0 : _b[0]) ? varint_to_i32(fmt[15][0].data) : -1;
        var dmax = ((_c = fmt[16]) == null ? void 0 : _c[0]) ? varint_to_i32(fmt[16][0].data) : -1;
        var auto = ((_d = fmt[40]) == null ? void 0 : _d[0]) ? varint_to_i32(fmt[40][0].data) : -1;
        var d = cell.v, dd = d;
        autodur:
          if (auto) {
            if (d == 0) {
              dmin = dmax = 2;
              break autodur;
            }
            if (d >= 604800)
              dmin = 1;
            else if (d >= 86400)
              dmin = 2;
            else if (d >= 3600)
              dmin = 4;
            else if (d >= 60)
              dmin = 8;
            else if (d >= 1)
              dmin = 16;
            else
              dmin = 32;
            if (Math.floor(d) != d)
              dmax = 32;
            else if (d % 60)
              dmax = 16;
            else if (d % 3600)
              dmax = 8;
            else if (d % 86400)
              dmax = 4;
            else if (d % 604800)
              dmax = 2;
            if (dmax < dmin)
              dmax = dmin;
          }
        if (dmin == -1 || dmax == -1)
          break dur;
        var dstr = [], zstr = [];
        if (dmin == 1) {
          dd = d / 604800;
          if (dmax == 1) {
            zstr.push('d"d"');
          } else {
            dd |= 0;
            d -= 604800 * dd;
          }
          dstr.push(dd + (dstyle == 2 ? " week" + (dd == 1 ? "" : "s") : dstyle == 1 ? "w" : ""));
        }
        if (dmin <= 2 && dmax >= 2) {
          dd = d / 86400;
          if (dmax > 2) {
            dd |= 0;
            d -= 86400 * dd;
          }
          zstr.push('d"d"');
          dstr.push(dd + (dstyle == 2 ? " day" + (dd == 1 ? "" : "s") : dstyle == 1 ? "d" : ""));
        }
        if (dmin <= 4 && dmax >= 4) {
          dd = d / 3600;
          if (dmax > 4) {
            dd |= 0;
            d -= 3600 * dd;
          }
          zstr.push((dmin >= 4 ? "[h]" : "h") + '"h"');
          dstr.push(dd + (dstyle == 2 ? " hour" + (dd == 1 ? "" : "s") : dstyle == 1 ? "h" : ""));
        }
        if (dmin <= 8 && dmax >= 8) {
          dd = d / 60;
          if (dmax > 8) {
            dd |= 0;
            d -= 60 * dd;
          }
          zstr.push((dmin >= 8 ? "[m]" : "m") + '"m"');
          if (dstyle == 0)
            dstr.push((dmin == 8 && dmax == 8 || dd >= 10 ? "" : "0") + dd);
          else
            dstr.push(dd + (dstyle == 2 ? " minute" + (dd == 1 ? "" : "s") : dstyle == 1 ? "m" : ""));
        }
        if (dmin <= 16 && dmax >= 16) {
          dd = d;
          if (dmax > 16) {
            dd |= 0;
            d -= dd;
          }
          zstr.push((dmin >= 16 ? "[s]" : "s") + '"s"');
          if (dstyle == 0)
            dstr.push((dmax == 16 && dmin == 16 || dd >= 10 ? "" : "0") + dd);
          else
            dstr.push(dd + (dstyle == 2 ? " second" + (dd == 1 ? "" : "s") : dstyle == 1 ? "s" : ""));
        }
        if (dmax >= 32) {
          dd = Math.round(1e3 * d);
          if (dmin < 32)
            zstr.push('.000"ms"');
          if (dstyle == 0)
            dstr.push((dd >= 100 ? "" : dd >= 10 ? "0" : "00") + dd);
          else
            dstr.push(dd + (dstyle == 2 ? " millisecond" + (dd == 1 ? "" : "s") : dstyle == 1 ? "ms" : ""));
        }
        cell.w = dstr.join(dstyle == 0 ? ":" : " ");
        cell.z = zstr.join(dstyle == 0 ? '":"' : " ");
        if (dstyle == 0)
          cell.w = cell.w.replace(/:(\d\d\d)$/, ".$1");
      }
  }
  function parse_old_storage(buf, lut, v, opts) {
    var dv = u8_to_dataview(buf);
    var flags = dv.getUint32(4, true);
    var ridx = -1, sidx = -1, zidx = -1, ieee = NaN, dc = 0, dt = new Date(Date.UTC(2001, 0, 1));
    var doff = v > 1 ? 12 : 8;
    if (flags & 2) {
      zidx = dv.getUint32(doff, true);
      doff += 4;
    }
    doff += popcnt(flags & (v > 1 ? 3468 : 396)) * 4;
    if (flags & 512) {
      ridx = dv.getUint32(doff, true);
      doff += 4;
    }
    doff += popcnt(flags & (v > 1 ? 12288 : 4096)) * 4;
    if (flags & 16) {
      sidx = dv.getUint32(doff, true);
      doff += 4;
    }
    if (flags & 32) {
      ieee = dv.getFloat64(doff, true);
      doff += 8;
    }
    if (flags & 64) {
      dt.setTime(dt.getTime() + (dc = dv.getFloat64(doff, true)) * 1e3);
      doff += 8;
    }
    if (v > 1) {
      flags = dv.getUint32(8, true) >>> 16;
      if (flags & 255) {
        if (zidx == -1)
          zidx = dv.getUint32(doff, true);
        doff += 4;
      }
    }
    var ret;
    var t = buf[v >= 4 ? 1 : 2];
    switch (t) {
      case 0:
        return void 0;
      case 2:
        ret = { t: "n", v: ieee };
        break;
      case 3:
        ret = { t: "s", v: lut.sst[sidx] };
        break;
      case 5:
        {
          if (opts == null ? void 0 : opts.cellDates)
            ret = { t: "d", v: dt };
          else
            ret = { t: "n", v: dc / 86400 + 35430, z: table_fmt[14] };
        }
        break;
      case 6:
        ret = { t: "b", v: ieee > 0 };
        break;
      case 7:
        ret = { t: "n", v: ieee };
        break;
      case 8:
        ret = { t: "e", v: 0 };
        break;
      case 9:
        {
          if (ridx > -1) {
            var rts = lut.rsst[ridx];
            ret = { t: "s", v: rts.v };
            if (rts.l)
              ret.l = { Target: rts.l };
          } else
            throw new Error("Unsupported cell type ".concat(buf[subarray](0, 4)));
        }
        break;
      default:
        throw new Error("Unsupported cell type ".concat(buf[subarray](0, 4)));
    }
    if (zidx > -1)
      numbers_format_cell(ret, t | v << 8, flags, lut.ofmt[zidx], lut.nfmt[zidx]);
    if (t == 7)
      ret.v /= 86400;
    return ret;
  }
  function parse_new_storage(buf, lut, opts) {
    var dv = u8_to_dataview(buf);
    dv.getUint32(4, true);
    var fields = dv.getUint32(8, true);
    var doff = 12;
    var ridx = -1, sidx = -1, zidx = -1, d128 = NaN, ieee = NaN, dc = 0, dt = new Date(Date.UTC(2001, 0, 1));
    if (fields & 1) {
      d128 = readDecimal128LE(buf, doff);
      doff += 16;
    }
    if (fields & 2) {
      ieee = dv.getFloat64(doff, true);
      doff += 8;
    }
    if (fields & 4) {
      dt.setTime(dt.getTime() + (dc = dv.getFloat64(doff, true)) * 1e3);
      doff += 8;
    }
    if (fields & 8) {
      sidx = dv.getUint32(doff, true);
      doff += 4;
    }
    if (fields & 16) {
      ridx = dv.getUint32(doff, true);
      doff += 4;
    }
    doff += popcnt(fields & 480) * 4;
    if (fields & 512) {
      dv.getUint32(doff, true);
      doff += 4;
    }
    doff += popcnt(fields & 1024) * 4;
    if (fields & 2048) {
      dv.getUint32(doff, true);
      doff += 4;
    }
    var ret;
    var t = buf[1];
    switch (t) {
      case 0:
        ret = { t: "z" };
        break;
      case 2:
        ret = { t: "n", v: d128 };
        break;
      case 3:
        ret = { t: "s", v: lut.sst[sidx] };
        break;
      case 5:
        {
          if (opts == null ? void 0 : opts.cellDates)
            ret = { t: "d", v: dt };
          else
            ret = { t: "n", v: dc / 86400 + 35430, z: table_fmt[14] };
        }
        break;
      case 6:
        ret = { t: "b", v: ieee > 0 };
        break;
      case 7:
        ret = { t: "n", v: ieee };
        break;
      case 8:
        ret = { t: "e", v: 0 };
        break;
      case 9:
        {
          if (ridx > -1) {
            var rts = lut.rsst[ridx];
            ret = { t: "s", v: rts.v };
            if (rts.l)
              ret.l = { Target: rts.l };
          } else
            throw new Error("Unsupported cell type ".concat(buf[1], " : ").concat(fields & 31, " : ").concat(buf[subarray](0, 4)));
        }
        break;
      case 10:
        ret = { t: "n", v: d128 };
        break;
      default:
        throw new Error("Unsupported cell type ".concat(buf[1], " : ").concat(fields & 31, " : ").concat(buf[subarray](0, 4)));
    }
    doff += popcnt(fields & 4096) * 4;
    if (fields & 516096) {
      if (zidx == -1)
        zidx = dv.getUint32(doff, true);
      doff += 4;
    }
    if (fields & 524288) {
      var cmntidx = dv.getUint32(doff, true);
      doff += 4;
      if (lut.cmnt[cmntidx])
        ret.c = iwa_to_s5s_comment(lut.cmnt[cmntidx]);
    }
    if (zidx > -1)
      numbers_format_cell(ret, t | 5 << 8, fields >> 13, lut.ofmt[zidx], lut.nfmt[zidx]);
    if (t == 7)
      ret.v /= 86400;
    return ret;
  }
  function write_new_storage(cell, lut) {
    var out = new Uint8Array(32), dv = u8_to_dataview(out), l = 12, fields = 0;
    out[0] = 5;
    switch (cell.t) {
      case "n":
        if (cell.z && fmt_is_date(cell.z)) {
          out[1] = 5;
          dv.setFloat64(l, (numdate(cell.v + 1462).getTime() - Date.UTC(2001, 0, 1)) / 1e3, true);
          fields |= 4;
          l += 8;
          break;
        } else {
          out[1] = 2;
          writeDecimal128LE(out, l, cell.v);
          fields |= 1;
          l += 16;
        }
        break;
      case "b":
        out[1] = 6;
        dv.setFloat64(l, cell.v ? 1 : 0, true);
        fields |= 2;
        l += 8;
        break;
      case "s":
        {
          var s = cell.v == null ? "" : String(cell.v);
          if (cell.l) {
            var irsst = lut.rsst.findIndex(function(v) {
              var _a;
              return v.v == s && v.l == ((_a = cell.l) == null ? void 0 : _a.Target);
            });
            if (irsst == -1)
              lut.rsst[irsst = lut.rsst.length] = { v: s, l: cell.l.Target };
            out[1] = 9;
            dv.setUint32(l, irsst, true);
            fields |= 16;
            l += 4;
          } else {
            var isst = lut.sst.indexOf(s);
            if (isst == -1)
              lut.sst[isst = lut.sst.length] = s;
            out[1] = 3;
            dv.setUint32(l, isst, true);
            fields |= 8;
            l += 4;
          }
        }
        break;
      case "d":
        out[1] = 5;
        dv.setFloat64(l, (cell.v.getTime() - Date.UTC(2001, 0, 1)) / 1e3, true);
        fields |= 4;
        l += 8;
        break;
      case "z":
        out[1] = 0;
        break;
      default:
        throw "unsupported cell type " + cell.t;
    }
    if (cell.c) {
      lut.cmnt.push(s5s_to_iwa_comment(cell.c));
      dv.setUint32(l, lut.cmnt.length - 1, true);
      fields |= 524288;
      l += 4;
    }
    dv.setUint32(8, fields, true);
    return out[subarray](0, l);
  }
  function write_old_storage(cell, lut) {
    var out = new Uint8Array(32), dv = u8_to_dataview(out), l = 12, fields = 0, s = "";
    out[0] = 4;
    switch (cell.t) {
      case "n":
        break;
      case "b":
        break;
      case "s":
        {
          s = cell.v == null ? "" : String(cell.v);
          if (cell.l) {
            var irsst = lut.rsst.findIndex(function(v) {
              var _a;
              return v.v == s && v.l == ((_a = cell.l) == null ? void 0 : _a.Target);
            });
            if (irsst == -1)
              lut.rsst[irsst = lut.rsst.length] = { v: s, l: cell.l.Target };
            out[1] = 9;
            dv.setUint32(l, irsst, true);
            fields |= 512;
            l += 4;
          }
        }
        break;
      case "d":
        break;
      case "e":
        break;
      case "z":
        break;
      default:
        throw "unsupported cell type " + cell.t;
    }
    if (cell.c) {
      dv.setUint32(l, lut.cmnt.length - 1, true);
      fields |= 4096;
      l += 4;
    }
    switch (cell.t) {
      case "n":
        out[1] = 2;
        dv.setFloat64(l, cell.v, true);
        fields |= 32;
        l += 8;
        break;
      case "b":
        out[1] = 6;
        dv.setFloat64(l, cell.v ? 1 : 0, true);
        fields |= 32;
        l += 8;
        break;
      case "s":
        {
          s = cell.v == null ? "" : String(cell.v);
          if (cell.l) ;
          else {
            var isst = lut.sst.indexOf(s);
            if (isst == -1)
              lut.sst[isst = lut.sst.length] = s;
            out[1] = 3;
            dv.setUint32(l, isst, true);
            fields |= 16;
            l += 4;
          }
        }
        break;
      case "d":
        out[1] = 5;
        dv.setFloat64(l, (cell.v.getTime() - Date.UTC(2001, 0, 1)) / 1e3, true);
        fields |= 64;
        l += 8;
        break;
      case "z":
        out[1] = 0;
        break;
      default:
        throw "unsupported cell type " + cell.t;
    }
    dv.setUint32(8, fields, true);
    return out[subarray](0, l);
  }
  function parse_cell_storage(buf, lut, opts) {
    switch (buf[0]) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
        return parse_old_storage(buf, lut, buf[0], opts);
      case 5:
        return parse_new_storage(buf, lut, opts);
      default:
        throw new Error("Unsupported payload version ".concat(buf[0]));
    }
  }
  function parse_TSP_Reference(buf) {
    var pb = parse_shallow(buf);
    return varint_to_i32(pb[1][0].data);
  }
  function write_TSP_Reference(idx) {
    return write_shallow([
      [],
      [{ type: 0, data: write_varint49(idx) }]
    ]);
  }
  function numbers_add_oref(iwa, ref2) {
    var _a;
    var orefs = ((_a = iwa.messages[0].meta[5]) == null ? void 0 : _a[0]) ? parse_packed_varints(iwa.messages[0].meta[5][0].data) : [];
    var orefidx = orefs.indexOf(ref2);
    if (orefidx == -1) {
      orefs.push(ref2);
      iwa.messages[0].meta[5] = [{ type: 2, data: write_packed_varints(orefs) }];
    }
  }
  function numbers_del_oref(iwa, ref2) {
    var _a;
    var orefs = ((_a = iwa.messages[0].meta[5]) == null ? void 0 : _a[0]) ? parse_packed_varints(iwa.messages[0].meta[5][0].data) : [];
    iwa.messages[0].meta[5] = [{ type: 2, data: write_packed_varints(orefs.filter(function(r2) {
      return r2 != ref2;
    })) }];
  }
  function parse_TST_TableDataList(M, root) {
    var pb = parse_shallow(root.data);
    var type = varint_to_i32(pb[1][0].data);
    var entries = pb[3];
    var data = [];
    (entries || []).forEach(function(entry) {
      var _a, _b;
      var le = parse_shallow(entry.data);
      if (!le[1])
        return;
      var key = varint_to_i32(le[1][0].data) >>> 0;
      switch (type) {
        case 1:
          data[key] = u8str(le[3][0].data);
          break;
        case 8:
          {
            var rt = M[parse_TSP_Reference(le[9][0].data)][0];
            var rtp = parse_shallow(rt.data);
            var rtpref = M[parse_TSP_Reference(rtp[1][0].data)][0];
            var mtype = varint_to_i32(rtpref.meta[1][0].data);
            if (mtype != 2001)
              throw new Error("2000 unexpected reference to ".concat(mtype));
            var tswpsa = parse_shallow(rtpref.data);
            var richtext = { v: tswpsa[3].map(function(x) {
              return u8str(x.data);
            }).join("") };
            data[key] = richtext;
            sfields:
              if ((_a = tswpsa == null ? void 0 : tswpsa[11]) == null ? void 0 : _a[0]) {
                var smartfields = (_b = parse_shallow(tswpsa[11][0].data)) == null ? void 0 : _b[1];
                if (!smartfields)
                  break sfields;
                smartfields.forEach(function(sf) {
                  var _a2, _b2, _c;
                  var attr = parse_shallow(sf.data);
                  if ((_a2 = attr[2]) == null ? void 0 : _a2[0]) {
                    var obj = M[parse_TSP_Reference((_b2 = attr[2]) == null ? void 0 : _b2[0].data)][0];
                    var objtype = varint_to_i32(obj.meta[1][0].data);
                    switch (objtype) {
                      case 2032:
                        var hlink = parse_shallow(obj.data);
                        if (((_c = hlink == null ? void 0 : hlink[2]) == null ? void 0 : _c[0]) && !richtext.l)
                          richtext.l = u8str(hlink[2][0].data);
                        break;
                      case 2039:
                        break;
                      default:
                        console.log("unrecognized ObjectAttribute type ".concat(objtype));
                    }
                  }
                });
              }
          }
          break;
        case 2:
          data[key] = parse_shallow(le[6][0].data);
          break;
        case 3:
          data[key] = parse_shallow(le[5][0].data);
          break;
        case 10:
          {
            var cs = M[parse_TSP_Reference(le[10][0].data)][0];
            data[key] = parse_TSD_CommentStorageArchive(M, cs.data);
          }
          break;
        default:
          throw type;
      }
    });
    return data;
  }
  function parse_TST_TileRowInfo(u8, type) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    var pb = parse_shallow(u8);
    var R = varint_to_i32(pb[1][0].data) >>> 0;
    var cnt = varint_to_i32(pb[2][0].data) >>> 0;
    var wide_offsets = ((_b = (_a = pb[8]) == null ? void 0 : _a[0]) == null ? void 0 : _b.data) && varint_to_i32(pb[8][0].data) > 0 || false;
    var used_storage_u8, used_storage;
    if (((_d = (_c = pb[7]) == null ? void 0 : _c[0]) == null ? void 0 : _d.data) && type != 0) {
      used_storage_u8 = (_f = (_e = pb[7]) == null ? void 0 : _e[0]) == null ? void 0 : _f.data;
      used_storage = (_h = (_g = pb[6]) == null ? void 0 : _g[0]) == null ? void 0 : _h.data;
    } else if (((_j = (_i = pb[4]) == null ? void 0 : _i[0]) == null ? void 0 : _j.data) && type != 1) {
      used_storage_u8 = (_l = (_k = pb[4]) == null ? void 0 : _k[0]) == null ? void 0 : _l.data;
      used_storage = (_n = (_m = pb[3]) == null ? void 0 : _m[0]) == null ? void 0 : _n.data;
    } else
      throw "NUMBERS Tile missing ".concat(type, " cell storage");
    var width = wide_offsets ? 4 : 1;
    var used_storage_offsets = u8_to_dataview(used_storage_u8);
    var offsets = [];
    for (var C = 0; C < used_storage_u8.length / 2; ++C) {
      var off = used_storage_offsets.getUint16(C * 2, true);
      if (off < 65535)
        offsets.push([C, off]);
    }
    if (offsets.length != cnt)
      throw "Expected ".concat(cnt, " cells, found ").concat(offsets.length);
    var cells = [];
    for (C = 0; C < offsets.length - 1; ++C)
      cells[offsets[C][0]] = used_storage[subarray](offsets[C][1] * width, offsets[C + 1][1] * width);
    if (offsets.length >= 1)
      cells[offsets[offsets.length - 1][0]] = used_storage[subarray](offsets[offsets.length - 1][1] * width);
    return { R, cells };
  }
  function parse_TST_Tile(M, root) {
    var _a;
    var pb = parse_shallow(root.data);
    var storage = -1;
    if ((_a = pb == null ? void 0 : pb[7]) == null ? void 0 : _a[0]) {
      if (varint_to_i32(pb[7][0].data) >>> 0)
        storage = 1;
      else
        storage = 0;
    }
    var ri = mappa(pb[5], function(u8) {
      return parse_TST_TileRowInfo(u8, storage);
    });
    return {
      nrows: varint_to_i32(pb[4][0].data) >>> 0,
      data: ri.reduce(function(acc, x) {
        if (!acc[x.R])
          acc[x.R] = [];
        x.cells.forEach(function(cell, C) {
          if (acc[x.R][C])
            throw new Error("Duplicate cell r=".concat(x.R, " c=").concat(C));
          acc[x.R][C] = cell;
        });
        return acc;
      }, [])
    };
  }
  function parse_TSD_CommentStorageArchive(M, data) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    var out = { t: "", a: "" };
    var csp = parse_shallow(data);
    if ((_b = (_a = csp == null ? void 0 : csp[1]) == null ? void 0 : _a[0]) == null ? void 0 : _b.data)
      out.t = u8str((_d = (_c = csp == null ? void 0 : csp[1]) == null ? void 0 : _c[0]) == null ? void 0 : _d.data) || "";
    if ((_f = (_e = csp == null ? void 0 : csp[3]) == null ? void 0 : _e[0]) == null ? void 0 : _f.data) {
      var as = M[parse_TSP_Reference((_h = (_g = csp == null ? void 0 : csp[3]) == null ? void 0 : _g[0]) == null ? void 0 : _h.data)][0];
      var asp = parse_shallow(as.data);
      if ((_j = (_i = asp[1]) == null ? void 0 : _i[0]) == null ? void 0 : _j.data)
        out.a = u8str(asp[1][0].data);
    }
    if (csp == null ? void 0 : csp[4]) {
      out.replies = [];
      csp[4].forEach(function(pi) {
        var cs = M[parse_TSP_Reference(pi.data)][0];
        out.replies.push(parse_TSD_CommentStorageArchive(M, cs.data));
      });
    }
    return out;
  }
  function iwa_to_s5s_comment(iwa) {
    var out = [];
    out.push({ t: iwa.t || "", a: iwa.a, T: iwa.replies && iwa.replies.length > 0 });
    if (iwa.replies)
      iwa.replies.forEach(function(reply) {
        out.push({ t: reply.t || "", a: reply.a, T: true });
      });
    return out;
  }
  function s5s_to_iwa_comment(s5s) {
    var out = { a: "", t: "", replies: [] };
    for (var i = 0; i < s5s.length; ++i) {
      if (i == 0) {
        out.a = s5s[i].a;
        out.t = s5s[i].t;
      } else {
        out.replies.push({ a: s5s[i].a, t: s5s[i].t });
      }
    }
    return out;
  }
  function parse_TST_TableModelArchive(M, root, ws, opts) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    var pb = parse_shallow(root.data);
    var range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
    range.e.r = (varint_to_i32(pb[6][0].data) >>> 0) - 1;
    if (range.e.r < 0)
      throw new Error("Invalid row varint ".concat(pb[6][0].data));
    range.e.c = (varint_to_i32(pb[7][0].data) >>> 0) - 1;
    if (range.e.c < 0)
      throw new Error("Invalid col varint ".concat(pb[7][0].data));
    ws["!ref"] = encode_range(range);
    var dense = ws["!data"] != null, dws = ws;
    var store = parse_shallow(pb[4][0].data);
    var lut = numbers_lut_new();
    if ((_a = store[4]) == null ? void 0 : _a[0])
      lut.sst = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[4][0].data)][0]);
    if ((_b = store[6]) == null ? void 0 : _b[0])
      lut.fmla = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[6][0].data)][0]);
    if ((_c = store[11]) == null ? void 0 : _c[0])
      lut.ofmt = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[11][0].data)][0]);
    if ((_d = store[12]) == null ? void 0 : _d[0])
      lut.ferr = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[12][0].data)][0]);
    if ((_e = store[17]) == null ? void 0 : _e[0])
      lut.rsst = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[17][0].data)][0]);
    if ((_f = store[19]) == null ? void 0 : _f[0])
      lut.cmnt = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[19][0].data)][0]);
    if ((_g = store[22]) == null ? void 0 : _g[0])
      lut.nfmt = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[22][0].data)][0]);
    var tile = parse_shallow(store[3][0].data);
    var _R = 0;
    if (!((_h = store[9]) == null ? void 0 : _h[0]))
      throw "NUMBERS file missing row tree";
    var rtt = parse_shallow(store[9][0].data)[1].map(function(p2) {
      return parse_shallow(p2.data);
    });
    rtt.forEach(function(kv) {
      _R = varint_to_i32(kv[1][0].data);
      var tidx = varint_to_i32(kv[2][0].data);
      var t = tile[1][tidx];
      if (!t)
        throw "NUMBERS missing tile " + tidx;
      var tl = parse_shallow(t.data);
      var ref22 = M[parse_TSP_Reference(tl[2][0].data)][0];
      var mtype2 = varint_to_i32(ref22.meta[1][0].data);
      if (mtype2 != 6002)
        throw new Error("6001 unexpected reference to ".concat(mtype2));
      var _tile = parse_TST_Tile(M, ref22);
      _tile.data.forEach(function(row, R) {
        row.forEach(function(buf, C) {
          var res = parse_cell_storage(buf, lut, opts);
          if (res) {
            if (dense) {
              if (!dws["!data"][_R + R])
                dws["!data"][_R + R] = [];
              dws["!data"][_R + R][C] = res;
            } else {
              ws[encode_col(C) + encode_row(_R + R)] = res;
            }
          }
        });
      });
      _R += _tile.nrows;
    });
    if ((_i = store[13]) == null ? void 0 : _i[0]) {
      var ref2 = M[parse_TSP_Reference(store[13][0].data)][0];
      var mtype = varint_to_i32(ref2.meta[1][0].data);
      if (mtype != 6144)
        throw new Error("Expected merge type 6144, found ".concat(mtype));
      ws["!merges"] = (_j = parse_shallow(ref2.data)) == null ? void 0 : _j[1].map(function(pi) {
        var merge = parse_shallow(pi.data);
        var origin = u8_to_dataview(parse_shallow(merge[1][0].data)[1][0].data), size = u8_to_dataview(parse_shallow(merge[2][0].data)[1][0].data);
        return {
          s: { r: origin.getUint16(0, true), c: origin.getUint16(2, true) },
          e: {
            r: origin.getUint16(0, true) + size.getUint16(0, true) - 1,
            c: origin.getUint16(2, true) + size.getUint16(2, true) - 1
          }
        };
      });
    }
    if (!((_k = ws["!merges"]) == null ? void 0 : _k.length) && ((_l = pb[47]) == null ? void 0 : _l[0])) {
      var merge_owner = parse_shallow(pb[47][0].data);
      if ((_m = merge_owner[2]) == null ? void 0 : _m[0]) {
        var formula_store = parse_shallow(merge_owner[2][0].data);
        if ((_n = formula_store[3]) == null ? void 0 : _n[0]) {
          ws["!merges"] = mappa(formula_store[3], function(u) {
            var _a2, _b2, _c2, _d2, _e2;
            var formula_pair = parse_shallow(u);
            var formula = parse_shallow(formula_pair[2][0].data);
            var AST_node_array = parse_shallow(formula[1][0].data);
            if (!((_a2 = AST_node_array[1]) == null ? void 0 : _a2[0]))
              return;
            var AST_node0 = parse_shallow(AST_node_array[1][0].data);
            var AST_node_type = varint_to_i32(AST_node0[1][0].data);
            if (AST_node_type != 67)
              return;
            var AST_colon_tract = parse_shallow(AST_node0[40][0].data);
            if (!((_b2 = AST_colon_tract[3]) == null ? void 0 : _b2[0]) || !((_c2 = AST_colon_tract[4]) == null ? void 0 : _c2[0]))
              return;
            var colrange = parse_shallow(AST_colon_tract[3][0].data);
            var rowrange = parse_shallow(AST_colon_tract[4][0].data);
            var c = varint_to_i32(colrange[1][0].data);
            var C = ((_d2 = colrange[2]) == null ? void 0 : _d2[0]) ? varint_to_i32(colrange[2][0].data) : c;
            var r2 = varint_to_i32(rowrange[1][0].data);
            var R = ((_e2 = rowrange[2]) == null ? void 0 : _e2[0]) ? varint_to_i32(rowrange[2][0].data) : r2;
            return { s: { r: r2, c }, e: { r: R, c: C } };
          }).filter(function(x) {
            return x != null;
          });
        }
      }
    }
  }
  function parse_TST_TableInfoArchive(M, root, opts) {
    var pb = parse_shallow(root.data);
    var out = { "!ref": "A1" };
    if (opts == null ? void 0 : opts.dense)
      out["!data"] = [];
    var tableref = M[parse_TSP_Reference(pb[2][0].data)];
    var mtype = varint_to_i32(tableref[0].meta[1][0].data);
    if (mtype != 6001)
      throw new Error("6000 unexpected reference to ".concat(mtype));
    parse_TST_TableModelArchive(M, tableref[0], out, opts);
    return out;
  }
  function parse_TN_SheetArchive(M, root, opts) {
    var _a;
    var pb = parse_shallow(root.data);
    var out = {
      name: ((_a = pb[1]) == null ? void 0 : _a[0]) ? u8str(pb[1][0].data) : "",
      sheets: []
    };
    var shapeoffs = mappa(pb[2], parse_TSP_Reference);
    shapeoffs.forEach(function(off) {
      M[off].forEach(function(m) {
        var mtype = varint_to_i32(m.meta[1][0].data);
        if (mtype == 6e3)
          out.sheets.push(parse_TST_TableInfoArchive(M, m, opts));
      });
    });
    return out;
  }
  function parse_TN_DocumentArchive(M, root, opts) {
    var _a;
    var out = book_new();
    out.Workbook = { WBProps: { date1904: true } };
    var pb = parse_shallow(root.data);
    if ((_a = pb[2]) == null ? void 0 : _a[0])
      throw new Error("Keynote presentations are not supported");
    var sheetoffs = mappa(pb[1], parse_TSP_Reference);
    sheetoffs.forEach(function(off) {
      M[off].forEach(function(m) {
        var mtype = varint_to_i32(m.meta[1][0].data);
        if (mtype == 2) {
          var root2 = parse_TN_SheetArchive(M, m, opts);
          root2.sheets.forEach(function(sheet, idx) {
            book_append_sheet(out, sheet, idx == 0 ? root2.name : root2.name + "_" + idx, true);
          });
        }
      });
    });
    if (out.SheetNames.length == 0)
      throw new Error("Empty NUMBERS file");
    out.bookType = "numbers";
    return out;
  }
  function parse_numbers_iwa(cfb, opts) {
    var _a, _b, _c, _d, _e, _f, _g;
    var M = {}, indices = [];
    cfb.FullPaths.forEach(function(p2) {
      if (p2.match(/\.iwpv2/))
        throw new Error("Unsupported password protection");
    });
    cfb.FileIndex.forEach(function(s) {
      if (!s.name.match(/\.iwa$/))
        return;
      if (s.content[0] != 0)
        return;
      var o;
      try {
        o = decompress_iwa_file(s.content);
      } catch (e) {
        return console.log("?? " + s.content.length + " " + (e.message || e));
      }
      var packets;
      try {
        packets = parse_iwa_file(o);
      } catch (e) {
        return console.log("## " + (e.message || e));
      }
      packets.forEach(function(packet) {
        M[packet.id] = packet.messages;
        indices.push(packet.id);
      });
    });
    if (!indices.length)
      throw new Error("File has no messages");
    if (((_c = (_b = (_a = M == null ? void 0 : M[1]) == null ? void 0 : _a[0].meta) == null ? void 0 : _b[1]) == null ? void 0 : _c[0].data) && varint_to_i32(M[1][0].meta[1][0].data) == 1e4)
      throw new Error("Pages documents are not supported");
    var docroot = ((_g = (_f = (_e = (_d = M == null ? void 0 : M[1]) == null ? void 0 : _d[0]) == null ? void 0 : _e.meta) == null ? void 0 : _f[1]) == null ? void 0 : _g[0].data) && varint_to_i32(M[1][0].meta[1][0].data) == 1 && M[1][0];
    if (!docroot)
      indices.forEach(function(idx) {
        M[idx].forEach(function(iwam) {
          var mtype = varint_to_i32(iwam.meta[1][0].data) >>> 0;
          if (mtype == 1) {
            if (!docroot)
              docroot = iwam;
            else
              throw new Error("Document has multiple roots");
          }
        });
      });
    if (!docroot)
      throw new Error("Cannot find Document root");
    return parse_TN_DocumentArchive(M, docroot, opts);
  }
  function write_TST_TileRowInfo(data, lut, wide) {
    var _a, _b, _c;
    var tri = [
      [],
      [{ type: 0, data: write_varint49(0) }],
      [{ type: 0, data: write_varint49(0) }],
      [{ type: 2, data: new Uint8Array([]) }],
      [{ type: 2, data: new Uint8Array(Array.from({ length: 510 }, function() {
        return 255;
      })) }],
      [{ type: 0, data: write_varint49(5) }],
      [{ type: 2, data: new Uint8Array([]) }],
      [{ type: 2, data: new Uint8Array(Array.from({ length: 510 }, function() {
        return 255;
      })) }],
      [{ type: 0, data: write_varint49(1) }]
    ];
    if (!((_a = tri[6]) == null ? void 0 : _a[0]) || !((_b = tri[7]) == null ? void 0 : _b[0]))
      throw "Mutation only works on post-BNC storages!";
    var cnt = 0;
    if (tri[7][0].data.length < 2 * data.length) {
      var new_7 = new Uint8Array(2 * data.length);
      new_7.set(tri[7][0].data);
      tri[7][0].data = new_7;
    }
    if (tri[4][0].data.length < 2 * data.length) {
      var new_4 = new Uint8Array(2 * data.length);
      new_4.set(tri[4][0].data);
      tri[4][0].data = new_4;
    }
    var dv = u8_to_dataview(tri[7][0].data), last_offset = 0, cell_storage = [];
    var _dv = u8_to_dataview(tri[4][0].data), _last_offset = 0, _cell_storage = [];
    var width = 4;
    for (var C = 0; C < data.length; ++C) {
      if (data[C] == null || data[C].t == "z" && !((_c = data[C].c) == null ? void 0 : _c.length) || data[C].t == "e") {
        dv.setUint16(C * 2, 65535, true);
        _dv.setUint16(C * 2, 65535);
        continue;
      }
      dv.setUint16(C * 2, last_offset / width, true);
      _dv.setUint16(C * 2, _last_offset / width, true);
      var celload, _celload;
      switch (data[C].t) {
        case "d":
          if (data[C].v instanceof Date) {
            celload = write_new_storage(data[C], lut);
            _celload = write_old_storage(data[C], lut);
            break;
          }
          celload = write_new_storage(data[C], lut);
          _celload = write_old_storage(data[C], lut);
          break;
        case "s":
        case "n":
        case "b":
        case "z":
          celload = write_new_storage(data[C], lut);
          _celload = write_old_storage(data[C], lut);
          break;
        default:
          throw new Error("Unsupported value " + data[C]);
      }
      cell_storage.push(celload);
      last_offset += celload.length;
      {
        _cell_storage.push(_celload);
        _last_offset += _celload.length;
      }
      ++cnt;
    }
    tri[2][0].data = write_varint49(cnt);
    tri[5][0].data = write_varint49(5);
    for (; C < tri[7][0].data.length / 2; ++C) {
      dv.setUint16(C * 2, 65535, true);
      _dv.setUint16(C * 2, 65535, true);
    }
    tri[6][0].data = u8concat(cell_storage);
    tri[3][0].data = u8concat(_cell_storage);
    tri[8] = [{ type: 0, data: write_varint49(1) }];
    return tri;
  }
  function write_iwam(type, payload) {
    return {
      meta: [
        [],
        [{ type: 0, data: write_varint49(type) }]
      ],
      data: payload
    };
  }
  function get_unique_msgid(dep, dependents) {
    if (!dependents.last)
      dependents.last = 927262;
    for (var i = dependents.last; i < 2e6; ++i)
      if (!dependents[i]) {
        dependents[dependents.last = i] = dep;
        return i;
      }
    throw new Error("Too many messages");
  }
  function build_numbers_deps(cfb) {
    var dependents = {};
    var indices = [];
    cfb.FileIndex.map(function(fi, idx) {
      return [fi, cfb.FullPaths[idx]];
    }).forEach(function(row) {
      var fi = row[0], fp = row[1];
      if (fi.type != 2)
        return;
      if (!fi.name.match(/\.iwa/))
        return;
      if (fi.content[0] != 0)
        return;
      parse_iwa_file(decompress_iwa_file(fi.content)).forEach(function(packet) {
        indices.push(packet.id);
        dependents[packet.id] = { deps: [], location: fp, type: varint_to_i32(packet.messages[0].meta[1][0].data) };
      });
    });
    cfb.FileIndex.forEach(function(fi) {
      if (!fi.name.match(/\.iwa/))
        return;
      if (fi.content[0] != 0)
        return;
      parse_iwa_file(decompress_iwa_file(fi.content)).forEach(function(ia) {
        ia.messages.forEach(function(mess) {
          [5, 6].forEach(function(f) {
            if (!mess.meta[f])
              return;
            mess.meta[f].forEach(function(x) {
              dependents[ia.id].deps.push(varint_to_i32(x.data));
            });
          });
        });
      });
    });
    return dependents;
  }
  function write_TSP_Color_RGB(r2, g, b) {
    return write_shallow([
      [],
      [{ type: 0, data: write_varint49(1) }],
      [],
      [{ type: 5, data: new Uint8Array(Float32Array.from([r2 / 255]).buffer) }],
      [{ type: 5, data: new Uint8Array(Float32Array.from([g / 255]).buffer) }],
      [{ type: 5, data: new Uint8Array(Float32Array.from([b / 255]).buffer) }],
      [{ type: 5, data: new Uint8Array(Float32Array.from([1]).buffer) }],
      [],
      [],
      [],
      [],
      [],
      [{ type: 0, data: write_varint49(1) }]
    ]);
  }
  function get_author_color(n) {
    switch (n) {
      case 0:
        return write_TSP_Color_RGB(99, 222, 171);
      case 1:
        return write_TSP_Color_RGB(162, 197, 240);
      case 2:
        return write_TSP_Color_RGB(255, 189, 189);
    }
    return write_TSP_Color_RGB(Math.random() * 255, Math.random() * 255, Math.random() * 255);
  }
  function write_numbers_iwa(wb, opts) {
    if (!opts || !opts.numbers)
      throw new Error("Must pass a `numbers` option -- check the README");
    var cfb = CFB.read(opts.numbers, { type: "base64" });
    var deps = build_numbers_deps(cfb);
    var docroot = numbers_iwa_find(cfb, deps, 1);
    if (docroot == null)
      throw "Could not find message ".concat(1, " in Numbers template");
    var sheetrefs = mappa(parse_shallow(docroot.messages[0].data)[1], parse_TSP_Reference);
    if (sheetrefs.length > 1)
      throw new Error("Template NUMBERS file must have exactly one sheet");
    wb.SheetNames.forEach(function(name, idx) {
      if (idx >= 1) {
        numbers_add_ws(cfb, deps, idx + 1);
        docroot = numbers_iwa_find(cfb, deps, 1);
        sheetrefs = mappa(parse_shallow(docroot.messages[0].data)[1], parse_TSP_Reference);
      }
      write_numbers_ws(cfb, deps, wb.Sheets[name], name, idx, sheetrefs[idx]);
    });
    return cfb;
  }
  function numbers_iwa_doit(cfb, deps, id, cb) {
    var entry = CFB.find(cfb, deps[id].location);
    if (!entry)
      throw "Could not find ".concat(deps[id].location, " in Numbers template");
    var x = parse_iwa_file(decompress_iwa_file(entry.content));
    var ainfo = x.find(function(packet) {
      return packet.id == id;
    });
    cb(ainfo, x);
    entry.content = compress_iwa_file(write_iwa_file(x));
    entry.size = entry.content.length;
  }
  function numbers_iwa_find(cfb, deps, id) {
    var entry = CFB.find(cfb, deps[id].location);
    if (!entry)
      throw "Could not find ".concat(deps[id].location, " in Numbers template");
    var x = parse_iwa_file(decompress_iwa_file(entry.content));
    var ainfo = x.find(function(packet) {
      return packet.id == id;
    });
    return ainfo;
  }
  function numbers_add_meta(mlist, newid, newloc) {
    mlist[3].push({ type: 2, data: write_shallow([
      [],
      [{ type: 0, data: write_varint49(newid) }],
      [{ type: 2, data: stru8(newloc.replace(/-[\s\S]*$/, "")) }],
      [{ type: 2, data: stru8(newloc) }],
      [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
      [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
      [],
      [],
      [],
      [],
      [{ type: 0, data: write_varint49(0) }],
      [],
      [{ type: 0, data: write_varint49(0) }]
    ]) });
    mlist[1] = [{ type: 0, data: write_varint49(Math.max(newid + 1, varint_to_i32(mlist[1][0].data))) }];
  }
  function numbers_add_msg(cfb, type, msg, path, deps, id) {
    if (!id)
      id = get_unique_msgid({ deps: [], location: "", type }, deps);
    var loc = "".concat(path, "-").concat(id, ".iwa");
    deps[id].location = "Root Entry" + loc;
    CFB.utils.cfb_add(cfb, loc, compress_iwa_file(write_iwa_file([{
      id,
      messages: [write_iwam(type, write_shallow(msg))]
    }])));
    var newloc = loc.replace(/^[\/]/, "").replace(/^Index\//, "").replace(/\.iwa$/, "");
    numbers_iwa_doit(cfb, deps, 2, function(ai) {
      var mlist = parse_shallow(ai.messages[0].data);
      numbers_add_meta(mlist, id || 0, newloc);
      ai.messages[0].data = write_shallow(mlist);
    });
    return id;
  }
  function numbers_meta_add_dep(mlist, deps, id, dep) {
    var loc = deps[id].location.replace(/^Root Entry\//, "").replace(/^Index\//, "").replace(/\.iwa$/, "");
    var parentidx = mlist[3].findIndex(function(m) {
      var _a, _b;
      var mm = parse_shallow(m.data);
      if ((_a = mm[3]) == null ? void 0 : _a[0])
        return u8str(mm[3][0].data) == loc;
      if (((_b = mm[2]) == null ? void 0 : _b[0]) && u8str(mm[2][0].data) == loc)
        return true;
      return false;
    });
    var parent = parse_shallow(mlist[3][parentidx].data);
    if (!parent[6])
      parent[6] = [];
    (Array.isArray(dep) ? dep : [dep]).forEach(function(dep2) {
      parent[6].push({
        type: 2,
        data: write_shallow([
          [],
          [{ type: 0, data: write_varint49(dep2) }]
        ])
      });
    });
    mlist[3][parentidx].data = write_shallow(parent);
  }
  function numbers_meta_del_dep(mlist, deps, id, dep) {
    var loc = deps[id].location.replace(/^Root Entry\//, "").replace(/^Index\//, "").replace(/\.iwa$/, "");
    var parentidx = mlist[3].findIndex(function(m) {
      var _a, _b;
      var mm = parse_shallow(m.data);
      if ((_a = mm[3]) == null ? void 0 : _a[0])
        return u8str(mm[3][0].data) == loc;
      if (((_b = mm[2]) == null ? void 0 : _b[0]) && u8str(mm[2][0].data) == loc)
        return true;
      return false;
    });
    var parent = parse_shallow(mlist[3][parentidx].data);
    if (!parent[6])
      parent[6] = [];
    parent[6] = parent[6].filter(function(m) {
      return varint_to_i32(parse_shallow(m.data)[1][0].data) != dep;
    });
    mlist[3][parentidx].data = write_shallow(parent);
  }
  function numbers_add_ws(cfb, deps, wsidx) {
    var sheetref = -1, newsheetref = -1;
    var remap = {};
    numbers_iwa_doit(cfb, deps, 1, function(docroot, arch) {
      var doc2 = parse_shallow(docroot.messages[0].data);
      sheetref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[1][0].data);
      newsheetref = get_unique_msgid({ deps: [1], location: deps[sheetref].location, type: 2 }, deps);
      remap[sheetref] = newsheetref;
      numbers_add_oref(docroot, newsheetref);
      doc2[1].push({ type: 2, data: write_TSP_Reference(newsheetref) });
      var sheet = numbers_iwa_find(cfb, deps, sheetref);
      sheet.id = newsheetref;
      if (deps[1].location == deps[newsheetref].location)
        arch.push(sheet);
      else
        numbers_iwa_doit(cfb, deps, newsheetref, function(_, x) {
          return x.push(sheet);
        });
      docroot.messages[0].data = write_shallow(doc2);
    });
    var tiaref = -1;
    numbers_iwa_doit(cfb, deps, newsheetref, function(sheetroot, arch) {
      var sa = parse_shallow(sheetroot.messages[0].data);
      for (var i = 3; i <= 69; ++i)
        delete sa[i];
      var drawables = mappa(sa[2], parse_TSP_Reference);
      drawables.forEach(function(n) {
        return numbers_del_oref(sheetroot, n);
      });
      tiaref = get_unique_msgid({ deps: [newsheetref], location: deps[drawables[0]].location, type: deps[drawables[0]].type }, deps);
      numbers_add_oref(sheetroot, tiaref);
      remap[drawables[0]] = tiaref;
      sa[2] = [{ type: 2, data: write_TSP_Reference(tiaref) }];
      var tia = numbers_iwa_find(cfb, deps, drawables[0]);
      tia.id = tiaref;
      if (deps[drawables[0]].location == deps[newsheetref].location)
        arch.push(tia);
      else {
        numbers_iwa_doit(cfb, deps, 2, function(ai) {
          var mlist = parse_shallow(ai.messages[0].data);
          numbers_meta_add_dep(mlist, deps, newsheetref, tiaref);
          ai.messages[0].data = write_shallow(mlist);
        });
        numbers_iwa_doit(cfb, deps, tiaref, function(_, x) {
          return x.push(tia);
        });
      }
      sheetroot.messages[0].data = write_shallow(sa);
    });
    var tmaref = -1;
    numbers_iwa_doit(cfb, deps, tiaref, function(tiaroot, arch) {
      var tia = parse_shallow(tiaroot.messages[0].data);
      var da = parse_shallow(tia[1][0].data);
      for (var i = 3; i <= 69; ++i)
        delete da[i];
      var dap = parse_TSP_Reference(da[2][0].data);
      da[2][0].data = write_TSP_Reference(remap[dap]);
      tia[1][0].data = write_shallow(da);
      var oldtmaref = parse_TSP_Reference(tia[2][0].data);
      numbers_del_oref(tiaroot, oldtmaref);
      tmaref = get_unique_msgid({ deps: [tiaref], location: deps[oldtmaref].location, type: deps[oldtmaref].type }, deps);
      numbers_add_oref(tiaroot, tmaref);
      remap[oldtmaref] = tmaref;
      tia[2][0].data = write_TSP_Reference(tmaref);
      var tma = numbers_iwa_find(cfb, deps, oldtmaref);
      tma.id = tmaref;
      if (deps[tiaref].location == deps[tmaref].location)
        arch.push(tma);
      else
        numbers_iwa_doit(cfb, deps, tmaref, function(_, x) {
          return x.push(tma);
        });
      tiaroot.messages[0].data = write_shallow(tia);
    });
    numbers_iwa_doit(cfb, deps, tmaref, function(tmaroot, arch) {
      var _a, _b;
      var tma = parse_shallow(tmaroot.messages[0].data);
      var uuid = u8str(tma[1][0].data), new_uuid = uuid.replace(/-[A-Z0-9]*/, "-".concat(("0000" + wsidx.toString(16)).slice(-4)));
      tma[1][0].data = stru8(new_uuid);
      [12, 13, 29, 31, 32, 33, 39, 44, 47, 81, 82, 84].forEach(function(n) {
        return delete tma[n];
      });
      if (tma[45]) {
        var srrta = parse_shallow(tma[45][0].data);
        var ref2 = parse_TSP_Reference(srrta[1][0].data);
        numbers_del_oref(tmaroot, ref2);
        delete tma[45];
      }
      if (tma[70]) {
        var hsoa = parse_shallow(tma[70][0].data);
        (_a = hsoa[2]) == null ? void 0 : _a.forEach(function(item) {
          var hsa = parse_shallow(item.data);
          [2, 3].map(function(n) {
            return hsa[n][0];
          }).forEach(function(hseadata) {
            var hsea = parse_shallow(hseadata.data);
            if (!hsea[8])
              return;
            var ref22 = parse_TSP_Reference(hsea[8][0].data);
            numbers_del_oref(tmaroot, ref22);
          });
        });
        delete tma[70];
      }
      [
        46,
        30,
        34,
        35,
        36,
        38,
        48,
        49,
        60,
        61,
        62,
        63,
        64,
        71,
        72,
        73,
        74,
        75,
        85,
        86,
        87,
        88,
        89
      ].forEach(function(n) {
        if (!tma[n])
          return;
        var ref22 = parse_TSP_Reference(tma[n][0].data);
        delete tma[n];
        numbers_del_oref(tmaroot, ref22);
      });
      var store = parse_shallow(tma[4][0].data);
      {
        [2, 4, 5, 6, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 22].forEach(function(n) {
          var _a2;
          if (!((_a2 = store[n]) == null ? void 0 : _a2[0]))
            return;
          var oldref = parse_TSP_Reference(store[n][0].data);
          var newref = get_unique_msgid({ deps: [tmaref], location: deps[oldref].location, type: deps[oldref].type }, deps);
          numbers_del_oref(tmaroot, oldref);
          numbers_add_oref(tmaroot, newref);
          remap[oldref] = newref;
          var msg = numbers_iwa_find(cfb, deps, oldref);
          msg.id = newref;
          if (deps[oldref].location == deps[tmaref].location)
            arch.push(msg);
          else {
            deps[newref].location = deps[oldref].location.replace(oldref.toString(), newref.toString());
            if (deps[newref].location == deps[oldref].location)
              deps[newref].location = deps[newref].location.replace(/\.iwa/, "-".concat(newref, ".iwa"));
            CFB.utils.cfb_add(cfb, deps[newref].location, compress_iwa_file(write_iwa_file([msg])));
            var newloc = deps[newref].location.replace(/^Root Entry\//, "").replace(/^Index\//, "").replace(/\.iwa$/, "");
            numbers_iwa_doit(cfb, deps, 2, function(ai) {
              var mlist = parse_shallow(ai.messages[0].data);
              numbers_add_meta(mlist, newref, newloc);
              numbers_meta_add_dep(mlist, deps, tmaref, newref);
              ai.messages[0].data = write_shallow(mlist);
            });
          }
          store[n][0].data = write_TSP_Reference(newref);
        });
        var row_headers = parse_shallow(store[1][0].data);
        {
          (_b = row_headers[2]) == null ? void 0 : _b.forEach(function(tspref) {
            var oldref = parse_TSP_Reference(tspref.data);
            var newref = get_unique_msgid({ deps: [tmaref], location: deps[oldref].location, type: deps[oldref].type }, deps);
            numbers_del_oref(tmaroot, oldref);
            numbers_add_oref(tmaroot, newref);
            remap[oldref] = newref;
            var msg = numbers_iwa_find(cfb, deps, oldref);
            msg.id = newref;
            if (deps[oldref].location == deps[tmaref].location) {
              arch.push(msg);
            } else {
              deps[newref].location = deps[oldref].location.replace(oldref.toString(), newref.toString());
              if (deps[newref].location == deps[oldref].location)
                deps[newref].location = deps[newref].location.replace(/\.iwa/, "-".concat(newref, ".iwa"));
              CFB.utils.cfb_add(cfb, deps[newref].location, compress_iwa_file(write_iwa_file([msg])));
              var newloc = deps[newref].location.replace(/^Root Entry\//, "").replace(/^Index\//, "").replace(/\.iwa$/, "");
              numbers_iwa_doit(cfb, deps, 2, function(ai) {
                var mlist = parse_shallow(ai.messages[0].data);
                numbers_add_meta(mlist, newref, newloc);
                numbers_meta_add_dep(mlist, deps, tmaref, newref);
                ai.messages[0].data = write_shallow(mlist);
              });
            }
            tspref.data = write_TSP_Reference(newref);
          });
        }
        store[1][0].data = write_shallow(row_headers);
        var tiles = parse_shallow(store[3][0].data);
        {
          tiles[1].forEach(function(t) {
            var tst = parse_shallow(t.data);
            var oldtileref = parse_TSP_Reference(tst[2][0].data);
            var newtileref = remap[oldtileref];
            if (!remap[oldtileref]) {
              newtileref = get_unique_msgid({ deps: [tmaref], location: "", type: deps[oldtileref].type }, deps);
              deps[newtileref].location = "Root Entry/Index/Tables/Tile-".concat(newtileref, ".iwa");
              remap[oldtileref] = newtileref;
              var oldtile = numbers_iwa_find(cfb, deps, oldtileref);
              oldtile.id = newtileref;
              numbers_del_oref(tmaroot, oldtileref);
              numbers_add_oref(tmaroot, newtileref);
              CFB.utils.cfb_add(cfb, "/Index/Tables/Tile-".concat(newtileref, ".iwa"), compress_iwa_file(write_iwa_file([oldtile])));
              numbers_iwa_doit(cfb, deps, 2, function(ai) {
                var mlist = parse_shallow(ai.messages[0].data);
                mlist[3].push({ type: 2, data: write_shallow([
                  [],
                  [{ type: 0, data: write_varint49(newtileref) }],
                  [{ type: 2, data: stru8("Tables/Tile") }],
                  [{ type: 2, data: stru8("Tables/Tile-".concat(newtileref)) }],
                  [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
                  [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
                  [],
                  [],
                  [],
                  [],
                  [{ type: 0, data: write_varint49(0) }],
                  [],
                  [{ type: 0, data: write_varint49(0) }]
                ]) });
                mlist[1] = [{ type: 0, data: write_varint49(Math.max(newtileref + 1, varint_to_i32(mlist[1][0].data))) }];
                numbers_meta_add_dep(mlist, deps, tmaref, newtileref);
                ai.messages[0].data = write_shallow(mlist);
              });
            }
            tst[2][0].data = write_TSP_Reference(newtileref);
            t.data = write_shallow(tst);
          });
        }
        store[3][0].data = write_shallow(tiles);
      }
      tma[4][0].data = write_shallow(store);
      tmaroot.messages[0].data = write_shallow(tma);
    });
  }
  function write_numbers_ws(cfb, deps, ws, wsname, sheetidx, rootref) {
    var drawables = [];
    numbers_iwa_doit(cfb, deps, rootref, function(docroot) {
      var sheetref = parse_shallow(docroot.messages[0].data);
      {
        sheetref[1] = [{ type: 2, data: stru8(wsname) }];
        drawables = mappa(sheetref[2], parse_TSP_Reference);
      }
      docroot.messages[0].data = write_shallow(sheetref);
    });
    var tia = numbers_iwa_find(cfb, deps, drawables[0]);
    var tmaref = parse_TSP_Reference(parse_shallow(tia.messages[0].data)[2][0].data);
    numbers_iwa_doit(cfb, deps, tmaref, function(docroot, x) {
      return write_numbers_tma(cfb, deps, ws, docroot, x, tmaref);
    });
  }
  function write_numbers_tma(cfb, deps, ws, tmaroot, tmafile, tmaref) {
    if (!ws["!ref"])
      throw new Error("Cannot export empty sheet to NUMBERS");
    var range = decode_range(ws["!ref"]);
    range.s.r = range.s.c = 0;
    var trunc = false;
    if (range.e.c > 999) {
      trunc = true;
      range.e.c = 999;
    }
    if (range.e.r > 999999) {
      trunc = true;
      range.e.r = 999999;
    }
    if (trunc)
      console.error("Truncating to ".concat(encode_range(range)));
    var data = [];
    if (ws["!data"])
      data = ws["!data"];
    else {
      var colstr = [];
      for (var _C = 0; _C <= range.e.c; ++_C)
        colstr[_C] = encode_col(_C);
      for (var R_ = 0; R_ <= range.e.r; ++R_) {
        data[R_] = [];
        var _R = "" + (R_ + 1);
        for (_C = 0; _C <= range.e.c; ++_C) {
          var _cell = ws[colstr[_C] + _R];
          if (!_cell)
            continue;
          data[R_][_C] = _cell;
        }
      }
    }
    var LUT = {
      cmnt: [{ a: "~54ee77S~", t: "... the people who are crazy enough to think they can change the world, are the ones who do." }],
      rsst: [{ v: "~54ee77S~", l: "https://sheetjs.com/" }],
      sst: ["~Sh33tJ5~"]
    };
    var pb = parse_shallow(tmaroot.messages[0].data);
    {
      pb[6][0].data = write_varint49(range.e.r + 1);
      pb[7][0].data = write_varint49(range.e.c + 1);
      delete pb[46];
      var store = parse_shallow(pb[4][0].data);
      {
        var row_header_ref = parse_TSP_Reference(parse_shallow(store[1][0].data)[2][0].data);
        numbers_iwa_doit(cfb, deps, row_header_ref, function(rowhead, _x) {
          var _a;
          var base_bucket = parse_shallow(rowhead.messages[0].data);
          if ((_a = base_bucket == null ? void 0 : base_bucket[2]) == null ? void 0 : _a[0])
            for (var R2 = 0; R2 < data.length; ++R2) {
              var _bucket = parse_shallow(base_bucket[2][0].data);
              _bucket[1][0].data = write_varint49(R2);
              _bucket[4][0].data = write_varint49(data[R2].length);
              base_bucket[2][R2] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };
            }
          rowhead.messages[0].data = write_shallow(base_bucket);
        });
        var col_header_ref = parse_TSP_Reference(store[2][0].data);
        numbers_iwa_doit(cfb, deps, col_header_ref, function(colhead, _x) {
          var base_bucket = parse_shallow(colhead.messages[0].data);
          for (var C = 0; C <= range.e.c; ++C) {
            var _bucket = parse_shallow(base_bucket[2][0].data);
            _bucket[1][0].data = write_varint49(C);
            _bucket[4][0].data = write_varint49(range.e.r + 1);
            base_bucket[2][C] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };
          }
          colhead.messages[0].data = write_shallow(base_bucket);
        });
        var rbtree = parse_shallow(store[9][0].data);
        rbtree[1] = [];
        var tilestore = parse_shallow(store[3][0].data);
        {
          var tstride = 256;
          tilestore[2] = [{ type: 0, data: write_varint49(tstride) }];
          var tileref = parse_TSP_Reference(parse_shallow(tilestore[1][0].data)[2][0].data);
          var save_token = (function() {
            var metadata = numbers_iwa_find(cfb, deps, 2);
            var mlist = parse_shallow(metadata.messages[0].data);
            var mlst = mlist[3].filter(function(m) {
              return varint_to_i32(parse_shallow(m.data)[1][0].data) == tileref;
            });
            return (mlst == null ? void 0 : mlst.length) ? varint_to_i32(parse_shallow(mlst[0].data)[12][0].data) : 0;
          })();
          {
            CFB.utils.cfb_del(cfb, deps[tileref].location);
            numbers_iwa_doit(cfb, deps, 2, function(ai) {
              var mlist = parse_shallow(ai.messages[0].data);
              mlist[3] = mlist[3].filter(function(m) {
                return varint_to_i32(parse_shallow(m.data)[1][0].data) != tileref;
              });
              numbers_meta_del_dep(mlist, deps, tmaref, tileref);
              ai.messages[0].data = write_shallow(mlist);
            });
            numbers_del_oref(tmaroot, tileref);
          }
          tilestore[1] = [];
          var ntiles = Math.ceil((range.e.r + 1) / tstride);
          for (var tidx = 0; tidx < ntiles; ++tidx) {
            var newtileid = get_unique_msgid({
              deps: [],
              location: "",
              type: 6002
            }, deps);
            deps[newtileid].location = "Root Entry/Index/Tables/Tile-".concat(newtileid, ".iwa");
            var tiledata = [
              [],
              [{ type: 0, data: write_varint49(0) }],
              [{ type: 0, data: write_varint49(Math.min(range.e.r + 1, (tidx + 1) * tstride)) }],
              [{ type: 0, data: write_varint49(0) }],
              [{ type: 0, data: write_varint49(Math.min((tidx + 1) * tstride, range.e.r + 1) - tidx * tstride) }],
              [],
              [{ type: 0, data: write_varint49(5) }],
              [{ type: 0, data: write_varint49(1) }],
              [{ type: 0, data: write_varint49(1) }]
            ];
            for (var R = tidx * tstride; R <= Math.min(range.e.r, (tidx + 1) * tstride - 1); ++R) {
              var tilerow = write_TST_TileRowInfo(data[R], LUT);
              tilerow[1][0].data = write_varint49(R - tidx * tstride);
              tiledata[5].push({ data: write_shallow(tilerow), type: 2 });
            }
            tilestore[1].push({ type: 2, data: write_shallow([
              [],
              [{ type: 0, data: write_varint49(tidx) }],
              [{ type: 2, data: write_TSP_Reference(newtileid) }]
            ]) });
            var newtile = {
              id: newtileid,
              messages: [write_iwam(6002, write_shallow(tiledata))]
            };
            var tilecontent = compress_iwa_file(write_iwa_file([newtile]));
            CFB.utils.cfb_add(cfb, "/Index/Tables/Tile-".concat(newtileid, ".iwa"), tilecontent);
            numbers_iwa_doit(cfb, deps, 2, function(ai) {
              var mlist = parse_shallow(ai.messages[0].data);
              mlist[3].push({ type: 2, data: write_shallow([
                [],
                [{ type: 0, data: write_varint49(newtileid) }],
                [{ type: 2, data: stru8("Tables/Tile") }],
                [{ type: 2, data: stru8("Tables/Tile-".concat(newtileid)) }],
                [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
                [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
                [],
                [],
                [],
                [],
                [{ type: 0, data: write_varint49(0) }],
                [],
                [{ type: 0, data: write_varint49(save_token) }]
              ]) });
              mlist[1] = [{ type: 0, data: write_varint49(Math.max(newtileid + 1, varint_to_i32(mlist[1][0].data))) }];
              numbers_meta_add_dep(mlist, deps, tmaref, newtileid);
              ai.messages[0].data = write_shallow(mlist);
            });
            numbers_add_oref(tmaroot, newtileid);
            rbtree[1].push({ type: 2, data: write_shallow([
              [],
              [{ type: 0, data: write_varint49(tidx * tstride) }],
              [{ type: 0, data: write_varint49(tidx) }]
            ]) });
          }
        }
        store[3][0].data = write_shallow(tilestore);
        store[9][0].data = write_shallow(rbtree);
        store[10] = [{ type: 2, data: new Uint8Array([]) }];
        if (ws["!merges"]) {
          var mergeid = get_unique_msgid({
            type: 6144,
            deps: [tmaref],
            location: deps[tmaref].location
          }, deps);
          tmafile.push({
            id: mergeid,
            messages: [write_iwam(6144, write_shallow([
              [],
              ws["!merges"].map(function(m) {
                return { type: 2, data: write_shallow([
                  [],
                  [{ type: 2, data: write_shallow([
                    [],
                    [{ type: 5, data: new Uint8Array(new Uint16Array([m.s.r, m.s.c]).buffer) }]
                  ]) }],
                  [{ type: 2, data: write_shallow([
                    [],
                    [{ type: 5, data: new Uint8Array(new Uint16Array([m.e.r - m.s.r + 1, m.e.c - m.s.c + 1]).buffer) }]
                  ]) }]
                ]) };
              })
            ]))]
          });
          store[13] = [{ type: 2, data: write_TSP_Reference(mergeid) }];
          numbers_iwa_doit(cfb, deps, 2, function(ai) {
            var mlist = parse_shallow(ai.messages[0].data);
            numbers_meta_add_dep(mlist, deps, tmaref, mergeid);
            ai.messages[0].data = write_shallow(mlist);
          });
          numbers_add_oref(tmaroot, mergeid);
        } else
          delete store[13];
        var sstref = parse_TSP_Reference(store[4][0].data);
        numbers_iwa_doit(cfb, deps, sstref, function(sstroot) {
          var sstdata = parse_shallow(sstroot.messages[0].data);
          {
            sstdata[3] = [];
            LUT.sst.forEach(function(str, i) {
              if (i == 0)
                return;
              sstdata[3].push({ type: 2, data: write_shallow([
                [],
                [{ type: 0, data: write_varint49(i) }],
                [{ type: 0, data: write_varint49(1) }],
                [{ type: 2, data: stru8(str) }]
              ]) });
            });
          }
          sstroot.messages[0].data = write_shallow(sstdata);
        });
        var rsstref = parse_TSP_Reference(store[17][0].data);
        numbers_iwa_doit(cfb, deps, rsstref, function(rsstroot) {
          var rsstdata = parse_shallow(rsstroot.messages[0].data);
          rsstdata[3] = [];
          var style_indices = [
            904980,
            903835,
            903815,
            903845
          ];
          LUT.rsst.forEach(function(rsst, i) {
            if (i == 0)
              return;
            var tswpsa = [
              [],
              [{ type: 0, data: new Uint8Array([5]) }],
              [],
              [{ type: 2, data: stru8(rsst.v) }]
            ];
            tswpsa[10] = [{ type: 0, data: new Uint8Array([1]) }];
            tswpsa[19] = [{ type: 2, data: new Uint8Array([10, 6, 8, 0, 18, 2, 101, 110]) }];
            tswpsa[5] = [{ type: 2, data: new Uint8Array([10, 8, 8, 0, 18, 4, 8, 155, 149, 55]) }];
            tswpsa[2] = [{ type: 2, data: new Uint8Array([8, 148, 158, 55]) }];
            tswpsa[6] = [{ type: 2, data: new Uint8Array([10, 6, 8, 0, 16, 0, 24, 0]) }];
            tswpsa[7] = [{ type: 2, data: new Uint8Array([10, 8, 8, 0, 18, 4, 8, 135, 149, 55]) }];
            tswpsa[8] = [{ type: 2, data: new Uint8Array([10, 8, 8, 0, 18, 4, 8, 165, 149, 55]) }];
            tswpsa[14] = [{ type: 2, data: new Uint8Array([10, 6, 8, 0, 16, 0, 24, 0]) }];
            tswpsa[24] = [{ type: 2, data: new Uint8Array([10, 6, 8, 0, 16, 0, 24, 0]) }];
            var tswpsaid = get_unique_msgid({ deps: [], location: "", type: 2001 }, deps);
            var tswpsarefs = [];
            if (rsst.l) {
              var newhlinkid = numbers_add_msg(cfb, 2032, [
                [],
                [],
                [{ type: 2, data: stru8(rsst.l) }]
              ], "/Index/Tables/DataList", deps);
              tswpsa[11] = [];
              var smartfield = [[], []];
              if (!smartfield[1])
                smartfield[1] = [];
              smartfield[1].push({ type: 2, data: write_shallow([
                [],
                [{ type: 0, data: write_varint49(0) }],
                [{ type: 2, data: write_TSP_Reference(newhlinkid) }]
              ]) });
              tswpsa[11][0] = { type: 2, data: write_shallow(smartfield) };
              tswpsarefs.push(newhlinkid);
            }
            numbers_add_msg(cfb, 2001, tswpsa, "/Index/Tables/DataList", deps, tswpsaid);
            numbers_iwa_doit(cfb, deps, tswpsaid, function(iwa) {
              style_indices.forEach(function(ref2) {
                return numbers_add_oref(iwa, ref2);
              });
              tswpsarefs.forEach(function(ref2) {
                return numbers_add_oref(iwa, ref2);
              });
            });
            var rtpaid = numbers_add_msg(cfb, 6218, [
              [],
              [{ type: 2, data: write_TSP_Reference(tswpsaid) }],
              [],
              [{ type: 2, data: new Uint8Array([13, 255, 255, 255, 0, 18, 10, 16, 255, 255, 1, 24, 255, 255, 255, 255, 7]) }]
            ], "/Index/Tables/DataList", deps);
            numbers_iwa_doit(cfb, deps, rtpaid, function(iwa) {
              return numbers_add_oref(iwa, tswpsaid);
            });
            rsstdata[3].push({ type: 2, data: write_shallow([
              [],
              [{ type: 0, data: write_varint49(i) }],
              [{ type: 0, data: write_varint49(1) }],
              [],
              [],
              [],
              [],
              [],
              [],
              [{ type: 2, data: write_TSP_Reference(rtpaid) }]
            ]) });
            numbers_add_oref(rsstroot, rtpaid);
            numbers_iwa_doit(cfb, deps, 2, function(ai) {
              var mlist = parse_shallow(ai.messages[0].data);
              numbers_meta_add_dep(mlist, deps, rsstref, rtpaid);
              numbers_meta_add_dep(mlist, deps, rtpaid, tswpsaid);
              numbers_meta_add_dep(mlist, deps, tswpsaid, tswpsarefs);
              numbers_meta_add_dep(mlist, deps, tswpsaid, style_indices);
              ai.messages[0].data = write_shallow(mlist);
            });
          });
          rsstroot.messages[0].data = write_shallow(rsstdata);
        });
        if (LUT.cmnt.length > 1) {
          var cmntref = parse_TSP_Reference(store[19][0].data);
          var authors = {}, iauthor = 0;
          numbers_iwa_doit(cfb, deps, cmntref, function(cmntroot) {
            var cmntdata = parse_shallow(cmntroot.messages[0].data);
            {
              cmntdata[3] = [];
              LUT.cmnt.forEach(function(cc, i) {
                if (i == 0)
                  return;
                var replies = [];
                if (cc.replies)
                  cc.replies.forEach(function(c) {
                    if (!authors[c.a || ""])
                      authors[c.a || ""] = numbers_add_msg(cfb, 212, [
                        [],
                        [{ type: 2, data: stru8(c.a || "") }],
                        [{ type: 2, data: get_author_color(++iauthor) }],
                        [],
                        [{ type: 0, data: write_varint49(0) }]
                      ], "/Index/Tables/DataList", deps);
                    var aaaid2 = authors[c.a || ""];
                    var csaid2 = numbers_add_msg(cfb, 3056, [
                      [],
                      [{ type: 2, data: stru8(c.t || "") }],
                      [{ type: 2, data: write_shallow([
                        [],
                        [{ type: 1, data: new Uint8Array([0, 0, 0, 128, 116, 109, 182, 65]) }]
                      ]) }],
                      [{ type: 2, data: write_TSP_Reference(aaaid2) }]
                    ], "/Index/Tables/DataList", deps);
                    numbers_iwa_doit(cfb, deps, csaid2, function(iwa) {
                      return numbers_add_oref(iwa, aaaid2);
                    });
                    replies.push(csaid2);
                    numbers_iwa_doit(cfb, deps, 2, function(ai) {
                      var mlist = parse_shallow(ai.messages[0].data);
                      numbers_meta_add_dep(mlist, deps, csaid2, aaaid2);
                      ai.messages[0].data = write_shallow(mlist);
                    });
                  });
                if (!authors[cc.a || ""])
                  authors[cc.a || ""] = numbers_add_msg(cfb, 212, [
                    [],
                    [{ type: 2, data: stru8(cc.a || "") }],
                    [{ type: 2, data: get_author_color(++iauthor) }],
                    [],
                    [{ type: 0, data: write_varint49(0) }]
                  ], "/Index/Tables/DataList", deps);
                var aaaid = authors[cc.a || ""];
                var csaid = numbers_add_msg(cfb, 3056, [
                  [],
                  [{ type: 2, data: stru8(cc.t || "") }],
                  [{ type: 2, data: write_shallow([
                    [],
                    [{ type: 1, data: new Uint8Array([0, 0, 0, 128, 116, 109, 182, 65]) }]
                  ]) }],
                  [{ type: 2, data: write_TSP_Reference(aaaid) }],
                  replies.map(function(r2) {
                    return { type: 2, data: write_TSP_Reference(r2) };
                  }),
                  [{ type: 2, data: write_shallow([
                    [],
                    [{ type: 0, data: write_varint49(i) }],
                    [{ type: 0, data: write_varint49(0) }]
                  ]) }]
                ], "/Index/Tables/DataList", deps);
                numbers_iwa_doit(cfb, deps, csaid, function(iwa) {
                  numbers_add_oref(iwa, aaaid);
                  replies.forEach(function(r2) {
                    return numbers_add_oref(iwa, r2);
                  });
                });
                cmntdata[3].push({ type: 2, data: write_shallow([
                  [],
                  [{ type: 0, data: write_varint49(i) }],
                  [{ type: 0, data: write_varint49(1) }],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [{ type: 2, data: write_TSP_Reference(csaid) }]
                ]) });
                numbers_add_oref(cmntroot, csaid);
                numbers_iwa_doit(cfb, deps, 2, function(ai) {
                  var mlist = parse_shallow(ai.messages[0].data);
                  numbers_meta_add_dep(mlist, deps, cmntref, csaid);
                  numbers_meta_add_dep(mlist, deps, csaid, aaaid);
                  if (replies.length)
                    numbers_meta_add_dep(mlist, deps, csaid, replies);
                  ai.messages[0].data = write_shallow(mlist);
                });
              });
            }
            cmntdata[2][0].data = write_varint49(LUT.cmnt.length + 1);
            cmntroot.messages[0].data = write_shallow(cmntdata);
          });
        }
      }
      pb[4][0].data = write_shallow(store);
    }
    tmaroot.messages[0].data = write_shallow(pb);
  }
  function fix_opts_func(defaults) {
    return function fix_opts(opts) {
      for (var i = 0; i != defaults.length; ++i) {
        var d = defaults[i];
        if (opts[d[0]] === void 0) opts[d[0]] = d[1];
        if (d[2] === "n") opts[d[0]] = Number(opts[d[0]]);
      }
    };
  }
  function fix_read_opts(opts) {
    fix_opts_func([
      ["cellNF", false],
["cellHTML", true],
["cellFormula", true],
["cellStyles", false],
["cellText", true],
["cellDates", false],
["sheetStubs", false],
["sheetRows", 0, "n"],
["bookDeps", false],
["bookSheets", false],
["bookProps", false],
["bookFiles", false],
["bookVBA", false],
["password", ""],
["WTF", false]
])(opts);
  }
  function fix_write_opts(opts) {
    fix_opts_func([
      ["cellDates", false],
["bookSST", false],
["bookType", "xlsx"],
["compression", false],
["WTF", false]
])(opts);
  }
  function get_sheet_type(n) {
    if (RELS.WS.indexOf(n) > -1) return "sheet";
    if (n == RELS.CS) return "chart";
    if (n == RELS.DS) return "dialog";
    if (n == RELS.MS) return "macro";
    return n && n.length ? n : "sheet";
  }
  function safe_parse_wbrels(wbrels, sheets) {
    if (!wbrels) return 0;
    try {
      wbrels = sheets.map(function pwbr(w) {
        if (!w.id) w.id = w.strRelID;
        return [w.name, wbrels["!id"][w.id].Target, get_sheet_type(wbrels["!id"][w.id].Type)];
      });
    } catch (e) {
      return null;
    }
    return !wbrels || wbrels.length === 0 ? null : wbrels;
  }
  function parse_sheet_legacy_drawing(sheet, type, zip, path, idx, opts, wb, comments) {
    if (!sheet || !sheet["!legdrawel"]) return;
    var dfile = resolve_path(sheet["!legdrawel"].Target, path);
    var draw = getzipstr(zip, dfile, true);
    if (draw) parse_vml(utf8read(draw), sheet, comments || []);
  }
  function safe_parse_sheet(zip, path, relsPath, sheet, idx, sheetRels, sheets, stype, opts, wb, themes, styles) {
    try {
      sheetRels[sheet] = parse_rels(getzipstr(zip, relsPath, true), path);
      var data = getzipdata(zip, path);
      var _ws;
      switch (stype) {
        case "sheet":
          _ws = parse_ws(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);
          break;
        case "chart":
          _ws = parse_cs(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);
          if (!_ws || !_ws["!drawel"]) break;
          var dfile = resolve_path(_ws["!drawel"].Target, path);
          var drelsp = get_rels_path(dfile);
          var draw = parse_drawing(getzipstr(zip, dfile, true), parse_rels(getzipstr(zip, drelsp, true), dfile));
          var chartp = resolve_path(draw, dfile);
          var crelsp = get_rels_path(chartp);
          _ws = parse_chart(getzipstr(zip, chartp, true), chartp, opts, parse_rels(getzipstr(zip, crelsp, true), chartp), wb, _ws);
          break;
        case "macro":
          _ws = parse_ms(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);
          break;
        case "dialog":
          _ws = parse_ds(data, path, idx, opts, sheetRels[sheet], wb, themes, styles);
          break;
        default:
          throw new Error("Unrecognized sheet type " + stype);
      }
      sheets[sheet] = _ws;
      var comments = [], tcomments = [];
      if (sheetRels && sheetRels[sheet]) keys(sheetRels[sheet]).forEach(function(n) {
        var dfile2 = "";
        if (sheetRels[sheet][n].Type == RELS.CMNT) {
          dfile2 = resolve_path(sheetRels[sheet][n].Target, path);
          comments = parse_cmnt(getzipdata(zip, dfile2, true), dfile2, opts);
          if (!comments || !comments.length) return;
          sheet_insert_comments(_ws, comments, false);
        }
        if (sheetRels[sheet][n].Type == RELS.TCMNT) {
          dfile2 = resolve_path(sheetRels[sheet][n].Target, path);
          tcomments = tcomments.concat(parse_tcmnt_xml(getzipdata(zip, dfile2, true), opts));
        }
      });
      if (tcomments && tcomments.length) sheet_insert_comments(_ws, tcomments, true, opts.people || []);
      parse_sheet_legacy_drawing(_ws, stype, zip, path, idx, opts, wb, comments);
    } catch (e) {
      if (opts.WTF) throw e;
    }
  }
  function strip_front_slash(x) {
    return x.charAt(0) == "/" ? x.slice(1) : x;
  }
  function parse_zip(zip, opts) {
    make_ssf();
    opts = opts || {};
    fix_read_opts(opts);
    if (safegetzipfile(zip, "META-INF/manifest.xml")) return parse_ods(zip, opts);
    if (safegetzipfile(zip, "objectdata.xml")) return parse_ods(zip, opts);
    if (safegetzipfile(zip, "Index/Document.iwa")) {
      if (typeof Uint8Array == "undefined") throw new Error("NUMBERS file parsing requires Uint8Array support");
      if (typeof parse_numbers_iwa != "undefined") {
        if (zip.FileIndex) return parse_numbers_iwa(zip, opts);
        var _zip = CFB.utils.cfb_new();
        zipentries(zip).forEach(function(e) {
          zip_add_file(_zip, e, getzipbin(zip, e));
        });
        return parse_numbers_iwa(_zip, opts);
      }
      throw new Error("Unsupported NUMBERS file");
    }
    if (!safegetzipfile(zip, "[Content_Types].xml")) {
      if (safegetzipfile(zip, "index.xml.gz")) throw new Error("Unsupported NUMBERS 08 file");
      if (safegetzipfile(zip, "index.xml")) throw new Error("Unsupported NUMBERS 09 file");
      var index_zip = CFB.find(zip, "Index.zip");
      if (index_zip) {
        opts = dup(opts);
        delete opts.type;
        if (typeof index_zip.content == "string") opts.type = "binary";
        if (typeof Bun !== "undefined" && Buffer.isBuffer(index_zip.content)) return readSync(new Uint8Array(index_zip.content), opts);
        return readSync(index_zip.content, opts);
      }
      throw new Error("Unsupported ZIP file");
    }
    var entries = zipentries(zip);
    var dir = parse_ct(getzipstr(zip, "[Content_Types].xml"));
    var xlsb = false;
    var sheets, binname;
    if (dir.workbooks.length === 0) {
      binname = "xl/workbook.xml";
      if (getzipdata(zip, binname, true)) dir.workbooks.push(binname);
    }
    if (dir.workbooks.length === 0) {
      binname = "xl/workbook.bin";
      if (!getzipdata(zip, binname, true)) throw new Error("Could not find workbook");
      dir.workbooks.push(binname);
      xlsb = true;
    }
    if (dir.workbooks[0].slice(-3) == "bin") xlsb = true;
    var themes = {};
    var styles = {};
    if (!opts.bookSheets && !opts.bookProps) {
      strs = [];
      if (dir.sst) try {
        strs = parse_sst(getzipdata(zip, strip_front_slash(dir.sst)), dir.sst, opts);
      } catch (e) {
        if (opts.WTF) throw e;
      }
      if (opts.cellStyles && dir.themes.length) themes = parse_theme_xml(getzipstr(zip, dir.themes[0].replace(/^\//, ""), true) || "", opts);
      if (dir.style) styles = parse_sty(getzipdata(zip, strip_front_slash(dir.style)), dir.style, themes, opts);
    }
    dir.links.map(function(link) {
      try {
        var rels = parse_rels(getzipstr(zip, get_rels_path(strip_front_slash(link))), link);
        return parse_xlink(getzipdata(zip, strip_front_slash(link)), rels, link, opts);
      } catch (e) {
      }
    });
    var wb = parse_wb(getzipdata(zip, strip_front_slash(dir.workbooks[0])), dir.workbooks[0], opts);
    var props = {}, propdata = "";
    if (dir.coreprops.length) {
      propdata = getzipdata(zip, strip_front_slash(dir.coreprops[0]), true);
      if (propdata) props = parse_core_props(propdata);
      if (dir.extprops.length !== 0) {
        propdata = getzipdata(zip, strip_front_slash(dir.extprops[0]), true);
        if (propdata) parse_ext_props(propdata, props, opts);
      }
    }
    var custprops = {};
    if (!opts.bookSheets || opts.bookProps) {
      if (dir.custprops.length !== 0) {
        propdata = getzipstr(zip, strip_front_slash(dir.custprops[0]), true);
        if (propdata) custprops = parse_cust_props(propdata, opts);
      }
    }
    var out = {};
    if (opts.bookSheets || opts.bookProps) {
      if (wb.Sheets) sheets = wb.Sheets.map(function pluck(x) {
        return x.name;
      });
      else if (props.Worksheets && props.SheetNames.length > 0) sheets = props.SheetNames;
      if (opts.bookProps) {
        out.Props = props;
        out.Custprops = custprops;
      }
      if (opts.bookSheets && typeof sheets !== "undefined") out.SheetNames = sheets;
      if (opts.bookSheets ? out.SheetNames : opts.bookProps) return out;
    }
    sheets = {};
    var deps = {};
    if (opts.bookDeps && dir.calcchain) deps = parse_cc(getzipdata(zip, strip_front_slash(dir.calcchain)), dir.calcchain);
    var i = 0;
    var sheetRels = {};
    var path, relsPath;
    {
      var wbsheets = wb.Sheets;
      props.Worksheets = wbsheets.length;
      props.SheetNames = [];
      for (var j = 0; j != wbsheets.length; ++j) {
        props.SheetNames[j] = wbsheets[j].name;
      }
    }
    var wbext = xlsb ? "bin" : "xml";
    var wbrelsi = dir.workbooks[0].lastIndexOf("/");
    var wbrelsfile = (dir.workbooks[0].slice(0, wbrelsi + 1) + "_rels/" + dir.workbooks[0].slice(wbrelsi + 1) + ".rels").replace(/^\//, "");
    if (!safegetzipfile(zip, wbrelsfile)) wbrelsfile = "xl/_rels/workbook." + wbext + ".rels";
    var wbrels = parse_rels(getzipstr(zip, wbrelsfile, true), wbrelsfile.replace(/_rels.*/, "s5s"));
    if ((dir.metadata || []).length >= 1) {
      opts.xlmeta = parse_xlmeta(getzipdata(zip, strip_front_slash(dir.metadata[0])), dir.metadata[0], opts);
    }
    if ((dir.people || []).length >= 1) {
      opts.people = parse_people_xml(getzipdata(zip, strip_front_slash(dir.people[0])), opts);
    }
    if (wbrels) wbrels = safe_parse_wbrels(wbrels, wb.Sheets);
    var nmode = getzipdata(zip, "xl/worksheets/sheet.xml", true) ? 1 : 0;
    wsloop: for (i = 0; i != props.Worksheets; ++i) {
      var stype = "sheet";
      if (wbrels && wbrels[i]) {
        path = "xl/" + wbrels[i][1].replace(/[\/]?xl\//, "");
        if (!safegetzipfile(zip, path)) path = wbrels[i][1];
        if (!safegetzipfile(zip, path)) path = wbrelsfile.replace(/_rels\/[\S\s]*$/, "") + wbrels[i][1];
        stype = wbrels[i][2];
      } else {
        path = "xl/worksheets/sheet" + (i + 1 - nmode) + "." + wbext;
        path = path.replace(/sheet0\./, "sheet.");
      }
      relsPath = path.replace(/^(.*)(\/)([^\/]*)$/, "$1/_rels/$3.rels");
      if (opts && opts.sheets != null) switch (typeof opts.sheets) {
        case "number":
          if (i != opts.sheets) continue wsloop;
          break;
        case "string":
          if (props.SheetNames[i].toLowerCase() != opts.sheets.toLowerCase()) continue wsloop;
          break;
        default:
          if (Array.isArray && Array.isArray(opts.sheets)) {
            var snjseen = false;
            for (var snj = 0; snj != opts.sheets.length; ++snj) {
              if (typeof opts.sheets[snj] == "number" && opts.sheets[snj] == i) snjseen = 1;
              if (typeof opts.sheets[snj] == "string" && opts.sheets[snj].toLowerCase() == props.SheetNames[i].toLowerCase()) snjseen = 1;
            }
            if (!snjseen) continue wsloop;
          }
      }
      safe_parse_sheet(zip, path, relsPath, props.SheetNames[i], i, sheetRels, sheets, stype, opts, wb, themes, styles);
    }
    out = {
      Directory: dir,
      Workbook: wb,
      Props: props,
      Custprops: custprops,
      Deps: deps,
      Sheets: sheets,
      SheetNames: props.SheetNames,
      Strings: strs,
      Styles: styles,
      Themes: themes,
      SSF: dup(table_fmt)
    };
    if (opts && opts.bookFiles) {
      if (zip.files) {
        out.keys = entries;
        out.files = zip.files;
      } else {
        out.keys = [];
        out.files = {};
        zip.FullPaths.forEach(function(p2, idx) {
          p2 = p2.replace(/^Root Entry[\/]/, "");
          out.keys.push(p2);
          out.files[p2] = zip.FileIndex[idx];
        });
      }
    }
    if (opts && opts.bookVBA) {
      if (dir.vba.length > 0) out.vbaraw = getzipdata(zip, strip_front_slash(dir.vba[0]), true);
      else if (dir.defaults && dir.defaults.bin === CT_VBA) out.vbaraw = getzipdata(zip, "xl/vbaProject.bin", true);
    }
    out.bookType = xlsb ? "xlsb" : "xlsx";
    return out;
  }
  function parse_xlsxcfb(cfb, _opts) {
    var opts = _opts || {};
    var f = "Workbook", data = CFB.find(cfb, f);
    try {
      f = "/!DataSpaces/Version";
      data = CFB.find(cfb, f);
      if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
      parse_DataSpaceVersionInfo(data.content);
      f = "/!DataSpaces/DataSpaceMap";
      data = CFB.find(cfb, f);
      if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
      var dsm = parse_DataSpaceMap(data.content);
      if (dsm.length !== 1 || dsm[0].comps.length !== 1 || dsm[0].comps[0].t !== 0 || dsm[0].name !== "StrongEncryptionDataSpace" || dsm[0].comps[0].v !== "EncryptedPackage")
        throw new Error("ECMA-376 Encrypted file bad " + f);
      f = "/!DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace";
      data = CFB.find(cfb, f);
      if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
      var seds = parse_DataSpaceDefinition(data.content);
      if (seds.length != 1 || seds[0] != "StrongEncryptionTransform")
        throw new Error("ECMA-376 Encrypted file bad " + f);
      f = "/!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary";
      data = CFB.find(cfb, f);
      if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
      parse_Primary(data.content);
    } catch (e) {
    }
    f = "/EncryptionInfo";
    data = CFB.find(cfb, f);
    if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
    var einfo = parse_EncryptionInfo(data.content);
    f = "/EncryptedPackage";
    data = CFB.find(cfb, f);
    if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f);
    if (einfo[0] == 4 && typeof decrypt_agile !== "undefined") return decrypt_agile(einfo[1], data.content, opts.password || "", opts);
    if (einfo[0] == 2 && typeof decrypt_std76 !== "undefined") return decrypt_std76(einfo[1], data.content, opts.password || "", opts);
    throw new Error("File is password-protected");
  }
  function write_zip_xlsb(wb, opts) {
    if (wb && !wb.SSF) {
      wb.SSF = dup(table_fmt);
    }
    if (wb && wb.SSF) {
      make_ssf();
      SSF_load_table(wb.SSF);
      opts.revssf = evert_num(wb.SSF);
      opts.revssf[wb.SSF[65535]] = 0;
      opts.ssf = wb.SSF;
    }
    opts.rels = {};
    opts.wbrels = {};
    opts.Strings =
[];
    opts.Strings.Count = 0;
    opts.Strings.Unique = 0;
    if (browser_has_Map) opts.revStrings = new Map();
    else {
      opts.revStrings = {};
      opts.revStrings.foo = [];
      delete opts.revStrings.foo;
    }
    var wbext = "bin";
    var vbafmt = true;
    var ct = new_ct();
    fix_write_opts(opts = opts || {});
    var zip = zip_new();
    var f = "", rId = 0;
    opts.cellXfs = [];
    get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
    if (!wb.Props) wb.Props = {};
    f = "docProps/core.xml";
    zip_add_file(zip, f, write_core_props(wb.Props, opts));
    ct.coreprops.push(f);
    add_rels(opts.rels, 2, f, RELS.CORE_PROPS);
    f = "docProps/app.xml";
    if (wb.Props && wb.Props.SheetNames) ;
    else if (!wb.Workbook || !wb.Workbook.Sheets) wb.Props.SheetNames = wb.SheetNames;
    else {
      var _sn = [];
      for (var _i = 0; _i < wb.SheetNames.length; ++_i)
        if ((wb.Workbook.Sheets[_i] || {}).Hidden != 2) _sn.push(wb.SheetNames[_i]);
      wb.Props.SheetNames = _sn;
    }
    wb.Props.Worksheets = wb.Props.SheetNames.length;
    zip_add_file(zip, f, write_ext_props(wb.Props));
    ct.extprops.push(f);
    add_rels(opts.rels, 3, f, RELS.EXT_PROPS);
    if (wb.Custprops !== wb.Props && keys(wb.Custprops || {}).length > 0) {
      f = "docProps/custom.xml";
      zip_add_file(zip, f, write_cust_props(wb.Custprops));
      ct.custprops.push(f);
      add_rels(opts.rels, 4, f, RELS.CUST_PROPS);
    }
    var people = ["SheetJ5"];
    opts.tcid = 0;
    for (rId = 1; rId <= wb.SheetNames.length; ++rId) {
      var wsrels = { "!id": {} };
      var ws = wb.Sheets[wb.SheetNames[rId - 1]];
      var _type = (ws || {})["!type"] || "sheet";
      switch (_type) {
        case "chart":
default:
          f = "xl/worksheets/sheet" + rId + "." + wbext;
          zip_add_file(zip, f, write_ws_bin(rId - 1, opts, wb, wsrels));
          ct.sheets.push(f);
          add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);
      }
      if (ws) {
        var comments = ws["!comments"];
        var need_vml = false;
        var cf = "";
        if (comments && comments.length > 0) {
          var needtc = false;
          comments.forEach(function(carr) {
            carr[1].forEach(function(c) {
              if (c.T == true) needtc = true;
            });
          });
          if (needtc) {
            cf = "xl/threadedComments/threadedComment" + rId + ".xml";
            zip_add_file(zip, cf, write_tcmnt_xml(comments, people, opts));
            ct.threadedcomments.push(cf);
            add_rels(wsrels, -1, "../threadedComments/threadedComment" + rId + ".xml", RELS.TCMNT);
          }
          cf = "xl/comments" + rId + "." + wbext;
          zip_add_file(zip, cf, write_comments_bin(comments));
          ct.comments.push(cf);
          add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);
          need_vml = true;
        }
        if (ws["!legacy"]) {
          if (need_vml) zip_add_file(zip, "xl/drawings/vmlDrawing" + rId + ".vml", write_vml(rId, ws["!comments"]));
        }
        delete ws["!comments"];
        delete ws["!legacy"];
      }
      if (wsrels["!id"].rId1) zip_add_file(zip, get_rels_path(f), write_rels(wsrels));
    }
    if (opts.Strings != null && opts.Strings.length > 0) {
      f = "xl/sharedStrings." + wbext;
      zip_add_file(zip, f, write_sst_bin(opts.Strings));
      ct.strs.push(f);
      add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);
    }
    f = "xl/workbook." + wbext;
    zip_add_file(zip, f, write_wb_bin(wb));
    ct.workbooks.push(f);
    add_rels(opts.rels, 1, f, RELS.WB);
    f = "xl/theme/theme1.xml";
    var ww = write_theme(wb.Themes, opts);
    zip_add_file(zip, f, ww);
    ct.themes.push(f);
    add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);
    f = "xl/styles." + wbext;
    zip_add_file(zip, f, write_sty_bin(wb, opts));
    ct.styles.push(f);
    add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);
    if (wb.vbaraw && vbafmt) {
      f = "xl/vbaProject.bin";
      zip_add_file(zip, f, wb.vbaraw);
      ct.vba.push(f);
      add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);
    }
    f = "xl/metadata." + wbext;
    zip_add_file(zip, f, write_xlmeta_bin());
    ct.metadata.push(f);
    add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);
    if (people.length > 1) {
      f = "xl/persons/person.xml";
      zip_add_file(zip, f, write_people_xml(people));
      ct.people.push(f);
      add_rels(opts.wbrels, -1, "persons/person.xml", RELS.PEOPLE);
    }
    zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));
    zip_add_file(zip, "_rels/.rels", write_rels(opts.rels));
    zip_add_file(zip, "xl/_rels/workbook." + wbext + ".rels", write_rels(opts.wbrels));
    delete opts.revssf;
    delete opts.ssf;
    return zip;
  }
  function write_zip_xlsx(wb, opts) {
    if (wb && !wb.SSF) {
      wb.SSF = dup(table_fmt);
    }
    if (wb && wb.SSF) {
      make_ssf();
      SSF_load_table(wb.SSF);
      opts.revssf = evert_num(wb.SSF);
      opts.revssf[wb.SSF[65535]] = 0;
      opts.ssf = wb.SSF;
    }
    opts.rels = {};
    opts.wbrels = {};
    opts.Strings =
[];
    opts.Strings.Count = 0;
    opts.Strings.Unique = 0;
    if (browser_has_Map) opts.revStrings = new Map();
    else {
      opts.revStrings = {};
      opts.revStrings.foo = [];
      delete opts.revStrings.foo;
    }
    var wbext = "xml";
    var vbafmt = VBAFMTS.indexOf(opts.bookType) > -1;
    var ct = new_ct();
    fix_write_opts(opts = opts || {});
    var zip = zip_new();
    var f = "", rId = 0;
    opts.cellXfs = [];
    get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
    if (!wb.Props) wb.Props = {};
    f = "docProps/core.xml";
    zip_add_file(zip, f, write_core_props(wb.Props, opts));
    ct.coreprops.push(f);
    add_rels(opts.rels, 2, f, RELS.CORE_PROPS);
    f = "docProps/app.xml";
    if (wb.Props && wb.Props.SheetNames) ;
    else if (!wb.Workbook || !wb.Workbook.Sheets) wb.Props.SheetNames = wb.SheetNames;
    else {
      var _sn = [];
      for (var _i = 0; _i < wb.SheetNames.length; ++_i)
        if ((wb.Workbook.Sheets[_i] || {}).Hidden != 2) _sn.push(wb.SheetNames[_i]);
      wb.Props.SheetNames = _sn;
    }
    wb.Props.Worksheets = wb.Props.SheetNames.length;
    zip_add_file(zip, f, write_ext_props(wb.Props));
    ct.extprops.push(f);
    add_rels(opts.rels, 3, f, RELS.EXT_PROPS);
    if (wb.Custprops !== wb.Props && keys(wb.Custprops || {}).length > 0) {
      f = "docProps/custom.xml";
      zip_add_file(zip, f, write_cust_props(wb.Custprops));
      ct.custprops.push(f);
      add_rels(opts.rels, 4, f, RELS.CUST_PROPS);
    }
    var people = ["SheetJ5"];
    opts.tcid = 0;
    for (rId = 1; rId <= wb.SheetNames.length; ++rId) {
      var wsrels = { "!id": {} };
      var ws = wb.Sheets[wb.SheetNames[rId - 1]];
      var _type = (ws || {})["!type"] || "sheet";
      switch (_type) {
        case "chart":
default:
          f = "xl/worksheets/sheet" + rId + "." + wbext;
          zip_add_file(zip, f, write_ws_xml(rId - 1, opts, wb, wsrels));
          ct.sheets.push(f);
          add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);
      }
      if (ws) {
        var comments = ws["!comments"];
        var need_vml = false;
        var cf = "";
        if (comments && comments.length > 0) {
          var needtc = false;
          comments.forEach(function(carr) {
            carr[1].forEach(function(c) {
              if (c.T == true) needtc = true;
            });
          });
          if (needtc) {
            cf = "xl/threadedComments/threadedComment" + rId + ".xml";
            zip_add_file(zip, cf, write_tcmnt_xml(comments, people, opts));
            ct.threadedcomments.push(cf);
            add_rels(wsrels, -1, "../threadedComments/threadedComment" + rId + ".xml", RELS.TCMNT);
          }
          cf = "xl/comments" + rId + "." + wbext;
          zip_add_file(zip, cf, write_comments_xml(comments));
          ct.comments.push(cf);
          add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);
          need_vml = true;
        }
        if (ws["!legacy"]) {
          if (need_vml) zip_add_file(zip, "xl/drawings/vmlDrawing" + rId + ".vml", write_vml(rId, ws["!comments"]));
        }
        delete ws["!comments"];
        delete ws["!legacy"];
      }
      if (wsrels["!id"].rId1) zip_add_file(zip, get_rels_path(f), write_rels(wsrels));
    }
    if (opts.Strings != null && opts.Strings.length > 0) {
      f = "xl/sharedStrings." + wbext;
      zip_add_file(zip, f, write_sst_xml(opts.Strings, opts));
      ct.strs.push(f);
      add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);
    }
    f = "xl/workbook." + wbext;
    zip_add_file(zip, f, write_wb_xml(wb));
    ct.workbooks.push(f);
    add_rels(opts.rels, 1, f, RELS.WB);
    f = "xl/theme/theme1.xml";
    zip_add_file(zip, f, write_theme(wb.Themes, opts));
    ct.themes.push(f);
    add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);
    f = "xl/styles." + wbext;
    zip_add_file(zip, f, write_sty_xml(wb, opts));
    ct.styles.push(f);
    add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);
    if (wb.vbaraw && vbafmt) {
      f = "xl/vbaProject.bin";
      zip_add_file(zip, f, wb.vbaraw);
      ct.vba.push(f);
      add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);
    }
    f = "xl/metadata." + wbext;
    zip_add_file(zip, f, write_xlmeta_xml());
    ct.metadata.push(f);
    add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);
    if (people.length > 1) {
      f = "xl/persons/person.xml";
      zip_add_file(zip, f, write_people_xml(people));
      ct.people.push(f);
      add_rels(opts.wbrels, -1, "persons/person.xml", RELS.PEOPLE);
    }
    zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));
    zip_add_file(zip, "_rels/.rels", write_rels(opts.rels));
    zip_add_file(zip, "xl/_rels/workbook." + wbext + ".rels", write_rels(opts.wbrels));
    delete opts.revssf;
    delete opts.ssf;
    return zip;
  }
  function firstbyte(f, o) {
    var x = "";
    switch ((o || {}).type || "base64") {
      case "buffer":
        return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];
      case "base64":
        x = Base64_decode(f.slice(0, 12));
        break;
      case "binary":
        x = f;
        break;
      case "array":
        return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];
      default:
        throw new Error("Unrecognized type " + (o && o.type || "undefined"));
    }
    return [x.charCodeAt(0), x.charCodeAt(1), x.charCodeAt(2), x.charCodeAt(3), x.charCodeAt(4), x.charCodeAt(5), x.charCodeAt(6), x.charCodeAt(7)];
  }
  function read_cfb(cfb, opts) {
    if (CFB.find(cfb, "EncryptedPackage")) return parse_xlsxcfb(cfb, opts);
    return parse_xlscfb(cfb, opts);
  }
  function read_zip(data, opts) {
    var zip, d = data;
    var o = opts || {};
    if (!o.type) o.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
    zip = zip_read(d, o);
    return parse_zip(zip, o);
  }
  function read_plaintext(data, o) {
    var i = 0;
    main: while (i < data.length) switch (data.charCodeAt(i)) {
      case 10:
      case 13:
      case 32:
        ++i;
        break;
      case 60:
        return parse_xlml(data.slice(i), o);
      default:
        break main;
    }
    return PRN.to_workbook(data, o);
  }
  function read_plaintext_raw(data, o) {
    var str = "", bytes = firstbyte(data, o);
    switch (o.type) {
      case "base64":
        str = Base64_decode(data);
        break;
      case "binary":
        str = data;
        break;
      case "buffer":
        str = data.toString("binary");
        break;
      case "array":
        str = cc2str(data);
        break;
      default:
        throw new Error("Unrecognized type " + o.type);
    }
    if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191) str = utf8read(str);
    o.type = "binary";
    return read_plaintext(str, o);
  }
  function read_utf16(data, o) {
    var d = data;
    if (o.type == "base64") d = Base64_decode(d);
    if (typeof ArrayBuffer !== "undefined" && data instanceof ArrayBuffer) d = new Uint8Array(data);
    d = typeof $cptable !== "undefined" ? $cptable.utils.decode(1200, d.slice(2), "str") : has_buf && Buffer.isBuffer(data) ? data.slice(2).toString("utf16le") : typeof Uint8Array !== "undefined" && d instanceof Uint8Array ? typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le").decode(d.slice(2)) : utf16lereadu(d.slice(2)) : utf16leread(d.slice(2));
    o.type = "binary";
    return read_plaintext(d, o);
  }
  function bstrify(data) {
    return !data.match(/[^\x00-\x7F]/) ? data : utf8write(data);
  }
  function read_prn(data, d, o, str) {
    if (str) {
      o.type = "string";
      return PRN.to_workbook(data, o);
    }
    return PRN.to_workbook(d, o);
  }
  function readSync(data, opts) {
    reset_cp();
    var o = opts || {};
    if (o.codepage && typeof $cptable === "undefined") console.error("Codepage tables are not loaded.  Non-ASCII characters may not give expected results");
    if (typeof ArrayBuffer !== "undefined" && data instanceof ArrayBuffer) return readSync(new Uint8Array(data), (o = dup(o), o.type = "array", o));
    if (typeof Int8Array !== "undefined" && data instanceof Int8Array) return readSync(new Uint8Array(data.buffer, data.byteOffset, data.length), o);
    if (typeof Uint8Array !== "undefined" && data instanceof Uint8Array && !o.type) o.type = typeof Deno !== "undefined" ? "buffer" : "array";
    var d = data, n = [0, 0, 0, 0], str = false;
    if (o.cellStyles) {
      o.cellNF = true;
      o.sheetStubs = true;
    }
    _ssfopts = {};
    if (o.dateNF) _ssfopts.dateNF = o.dateNF;
    if (!o.type) o.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
    if (o.type == "file") {
      o.type = has_buf ? "buffer" : "binary";
      d = read_binary(data);
      if (typeof Uint8Array !== "undefined" && !has_buf) o.type = "array";
    }
    if (o.type == "string") {
      str = true;
      o.type = "binary";
      o.codepage = 65001;
      d = bstrify(data);
    }
    if (o.type == "array" && typeof Uint8Array !== "undefined" && data instanceof Uint8Array && typeof ArrayBuffer !== "undefined") {
      var ab = new ArrayBuffer(3), vu = new Uint8Array(ab);
      vu.foo = "bar";
      if (!vu.foo) {
        o = dup(o);
        o.type = "array";
        return readSync(ab2a(d), o);
      }
    }
    switch ((n = firstbyte(d, o))[0]) {
      case 208:
        if (n[1] === 207 && n[2] === 17 && n[3] === 224 && n[4] === 161 && n[5] === 177 && n[6] === 26 && n[7] === 225) return read_cfb(CFB.read(d, o), o);
        break;
      case 9:
        if (n[1] <= 8) return parse_xlscfb(d, o);
        break;
      case 60:
        return parse_xlml(d, o);
      case 73:
        if (n[1] === 73 && n[2] === 42 && n[3] === 0) throw new Error("TIFF Image File is not a spreadsheet");
        if (n[1] === 68) return read_wb_ID(d, o);
        break;
      case 84:
        if (n[1] === 65 && n[2] === 66 && n[3] === 76) return DIF.to_workbook(d, o);
        break;
      case 80:
        return n[1] === 75 && n[2] < 9 && n[3] < 9 ? read_zip(d, o) : read_prn(data, d, o, str);
      case 239:
        return n[3] === 60 ? parse_xlml(d, o) : read_prn(data, d, o, str);
      case 255:
        if (n[1] === 254) {
          return read_utf16(d, o);
        } else if (n[1] === 0 && n[2] === 2 && n[3] === 0) return WK_.to_workbook(d, o);
        break;
      case 0:
        if (n[1] === 0) {
          if (n[2] >= 2 && n[3] === 0) return WK_.to_workbook(d, o);
          if (n[2] === 0 && (n[3] === 8 || n[3] === 9)) return WK_.to_workbook(d, o);
        }
        break;
      case 3:
      case 131:
      case 139:
      case 140:
        return DBF.to_workbook(d, o);
      case 123:
        if (n[1] === 92 && n[2] === 114 && n[3] === 116) return rtf_to_workbook(d, o);
        break;
      case 10:
      case 13:
      case 32:
        return read_plaintext_raw(d, o);
      case 137:
        if (n[1] === 80 && n[2] === 78 && n[3] === 71) throw new Error("PNG Image File is not a spreadsheet");
        break;
      case 8:
        if (n[1] === 231) throw new Error("Unsupported Multiplan 1.x file!");
        break;
      case 12:
        if (n[1] === 236) throw new Error("Unsupported Multiplan 2.x file!");
        if (n[1] === 237) throw new Error("Unsupported Multiplan 3.x file!");
        break;
    }
    if (DBF_SUPPORTED_VERSIONS.indexOf(n[0]) > -1 && n[2] <= 12 && n[3] <= 31) return DBF.to_workbook(d, o);
    return read_prn(data, d, o, str);
  }
  function readFileSync(filename, opts) {
    var o = opts || {};
    o.type = "file";
    return readSync(filename, o);
  }
  function write_cfb_ctr(cfb, o) {
    switch (o.type) {
      case "base64":
      case "binary":
        break;
      case "buffer":
      case "array":
        o.type = "";
        break;
      case "file":
        return write_dl(o.file, CFB.write(cfb, { type: has_buf ? "buffer" : "" }));
      case "string":
        throw new Error("'string' output type invalid for '" + o.bookType + "' files");
      default:
        throw new Error("Unrecognized type " + o.type);
    }
    return CFB.write(cfb, o);
  }
  function write_zip(wb, opts) {
    switch (opts.bookType) {
      case "ods":
        return write_ods(wb, opts);
      case "numbers":
        return write_numbers_iwa(wb, opts);
      case "xlsb":
        return write_zip_xlsb(wb, opts);
      default:
        return write_zip_xlsx(wb, opts);
    }
  }
  function write_zip_type(wb, opts) {
    var o = dup(opts || {});
    var z = write_zip(wb, o);
    return write_zip_denouement(z, o);
  }
  function write_zip_typeXLSX(wb, opts) {
    var o = dup(opts || {});
    var z = write_zip_xlsx(wb, o);
    return write_zip_denouement(z, o);
  }
  function write_zip_denouement(z, o) {
    var oopts = {};
    var ftype = has_buf ? "nodebuffer" : typeof Uint8Array !== "undefined" ? "array" : "string";
    if (o.compression) oopts.compression = "DEFLATE";
    if (o.password) oopts.type = ftype;
    else switch (o.type) {
      case "base64":
        oopts.type = "base64";
        break;
      case "binary":
        oopts.type = "string";
        break;
      case "string":
        throw new Error("'string' output type invalid for '" + o.bookType + "' files");
      case "buffer":
      case "file":
        oopts.type = ftype;
        break;
      default:
        throw new Error("Unrecognized type " + o.type);
    }
    var out = z.FullPaths ? CFB.write(z, { fileType: "zip", type: (
{ "nodebuffer": "buffer", "string": "binary" }[oopts.type] || oopts.type
    ), compression: !!o.compression }) : z.generate(oopts);
    if (typeof Deno !== "undefined") {
      if (typeof out == "string") {
        if (o.type == "binary" || o.type == "base64") return out;
        out = new Uint8Array(s2ab(out));
      }
    }
    if (o.password && typeof encrypt_agile !== "undefined") return write_cfb_ctr(encrypt_agile(out, o.password), o);
    if (o.type === "file") return write_dl(o.file, out);
    return o.type == "string" ? utf8read(
out
) : out;
  }
  function write_cfb_type(wb, opts) {
    var o = opts || {};
    var cfb = write_xlscfb(wb, o);
    return write_cfb_ctr(cfb, o);
  }
  function write_string_type(out, opts, bom) {
    if (!bom) bom = "";
    var o = bom + out;
    switch (opts.type) {
      case "base64":
        return Base64_encode(utf8write(o));
      case "binary":
        return utf8write(o);
      case "string":
        return out;
      case "file":
        return write_dl(opts.file, o, "utf8");
      case "buffer": {
        if (has_buf) return Buffer_from(o, "utf8");
        else if (typeof TextEncoder !== "undefined") return new TextEncoder().encode(o);
        else return write_string_type(o, { type: "binary" }).split("").map(function(c) {
          return c.charCodeAt(0);
        });
      }
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function write_stxt_type(out, opts) {
    switch (opts.type) {
      case "base64":
        return Base64_encode_pass(out);
      case "binary":
        return out;
      case "string":
        return out;
case "file":
        return write_dl(opts.file, out, "binary");
      case "buffer": {
        if (has_buf) return Buffer_from(out, "binary");
        else return out.split("").map(function(c) {
          return c.charCodeAt(0);
        });
      }
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function write_binary_type(out, opts) {
    switch (opts.type) {
      case "string":
      case "base64":
      case "binary":
        var bstr = "";
        for (var i = 0; i < out.length; ++i) bstr += String.fromCharCode(out[i]);
        return opts.type == "base64" ? Base64_encode(bstr) : opts.type == "string" ? utf8read(bstr) : bstr;
      case "file":
        return write_dl(opts.file, out);
      case "buffer":
        return out;
      default:
        throw new Error("Unrecognized type " + opts.type);
    }
  }
  function writeSyncXLSX(wb, opts) {
    reset_cp();
    check_wb(wb);
    var o = dup(opts || {});
    if (o.cellStyles) {
      o.cellNF = true;
      o.sheetStubs = true;
    }
    if (o.type == "array") {
      o.type = "binary";
      var out = writeSyncXLSX(wb, o);
      o.type = "array";
      return s2ab(out);
    }
    return write_zip_typeXLSX(wb, o);
  }
  function writeSync(wb, opts) {
    reset_cp();
    check_wb(wb);
    var o = dup(opts || {});
    if (o.cellStyles) {
      o.cellNF = true;
      o.sheetStubs = true;
    }
    if (o.type == "array") {
      o.type = "binary";
      var out = writeSync(wb, o);
      o.type = "array";
      return s2ab(out);
    }
    var idx = 0;
    if (o.sheet) {
      if (typeof o.sheet == "number") idx = o.sheet;
      else idx = wb.SheetNames.indexOf(o.sheet);
      if (!wb.SheetNames[idx]) throw new Error("Sheet not found: " + o.sheet + " : " + typeof o.sheet);
    }
    switch (o.bookType || "xlsb") {
      case "xml":
      case "xlml":
        return write_string_type(write_xlml(wb, o), o);
      case "slk":
      case "sylk":
        return write_string_type(SYLK.from_sheet(wb.Sheets[wb.SheetNames[idx]], o, wb), o);
      case "htm":
      case "html":
        return write_string_type(sheet_to_html(wb.Sheets[wb.SheetNames[idx]], o), o);
      case "txt":
        return write_stxt_type(sheet_to_txt(wb.Sheets[wb.SheetNames[idx]], o), o);
      case "csv":
        return write_string_type(sheet_to_csv(wb.Sheets[wb.SheetNames[idx]], o), o, "\uFEFF");
      case "dif":
        return write_string_type(DIF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
      case "dbf":
        return write_binary_type(DBF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
      case "prn":
        return write_string_type(PRN.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
      case "rtf":
        return write_string_type(sheet_to_rtf(wb.Sheets[wb.SheetNames[idx]]), o);
      case "eth":
        return write_string_type(ETH.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
      case "fods":
        return write_string_type(write_ods(wb, o), o);
      case "wk1":
        return write_binary_type(WK_.sheet_to_wk1(wb.Sheets[wb.SheetNames[idx]], o), o);
      case "wk3":
        return write_binary_type(WK_.book_to_wk3(wb, o), o);
      case "biff2":
        if (!o.biff) o.biff = 2;
case "biff3":
        if (!o.biff) o.biff = 3;
case "biff4":
        if (!o.biff) o.biff = 4;
        return write_binary_type(write_biff_buf(wb, o), o);
      case "biff5":
        if (!o.biff) o.biff = 5;
case "biff8":
      case "xla":
      case "xls":
        if (!o.biff) o.biff = 8;
        return write_cfb_type(wb, o);
      case "xlsx":
      case "xlsm":
      case "xlam":
      case "xlsb":
      case "numbers":
      case "ods":
        return write_zip_type(wb, o);
      default:
        throw new Error("Unrecognized bookType |" + o.bookType + "|");
    }
  }
  function resolve_book_type(o) {
    if (o.bookType) return;
    var _BT = {
      "xls": "biff8",
      "htm": "html",
      "slk": "sylk",
      "socialcalc": "eth",
      "Sh33tJS": "WTF"
    };
    var ext = o.file.slice(o.file.lastIndexOf(".")).toLowerCase();
    if (ext.match(/^\.[a-z]+$/)) o.bookType = ext.slice(1);
    o.bookType = _BT[o.bookType] || o.bookType;
  }
  function writeFileSync(wb, filename, opts) {
    var o = opts || {};
    o.type = "file";
    o.file = filename;
    resolve_book_type(o);
    return writeSync(wb, o);
  }
  function writeFileSyncXLSX(wb, filename, opts) {
    var o = opts || {};
    o.type = "file";
    o.file = filename;
    resolve_book_type(o);
    return writeSyncXLSX(wb, o);
  }
  function writeFileAsync(filename, wb, opts, cb) {
    var o = opts || {};
    o.type = "file";
    o.file = filename;
    resolve_book_type(o);
    o.type = "buffer";
    var _cb = cb;
    if (!(_cb instanceof Function)) _cb = opts;
    return _fs.writeFile(filename, writeSync(wb, o), _cb);
  }
  function make_json_row(sheet, r2, R, cols, header, hdr, o) {
    var rr = encode_row(R);
    var defval = o.defval, raw = o.raw || !Object.prototype.hasOwnProperty.call(o, "raw");
    var isempty = true, dense = sheet["!data"] != null;
    var row = header === 1 ? [] : {};
    if (header !== 1) {
      if (Object.defineProperty) try {
        Object.defineProperty(row, "__rowNum__", { value: R, enumerable: false });
      } catch (e) {
        row.__rowNum__ = R;
      }
      else row.__rowNum__ = R;
    }
    if (!dense || sheet["!data"][R]) for (var C = r2.s.c; C <= r2.e.c; ++C) {
      var val2 = dense ? (sheet["!data"][R] || [])[C] : sheet[cols[C] + rr];
      if (val2 == null || val2.t === void 0) {
        if (defval === void 0) continue;
        if (hdr[C] != null) {
          row[hdr[C]] = defval;
        }
        continue;
      }
      var v = val2.v;
      switch (val2.t) {
        case "z":
          if (v == null) break;
          continue;
        case "e":
          v = v == 0 ? null : void 0;
          break;
        case "s":
        case "b":
        case "n":
          if (!val2.z || !fmt_is_date(val2.z)) break;
          v = numdate(v);
          if (typeof v == "number") break;
case "d":
          if (!(o && (o.UTC || o.raw === false))) v = utc_to_local(new Date(v));
          break;
        default:
          throw new Error("unrecognized type " + val2.t);
      }
      if (hdr[C] != null) {
        if (v == null) {
          if (val2.t == "e" && v === null) row[hdr[C]] = null;
          else if (defval !== void 0) row[hdr[C]] = defval;
          else if (raw && v === null) row[hdr[C]] = null;
          else continue;
        } else {
          row[hdr[C]] = (val2.t === "n" && typeof o.rawNumbers === "boolean" ? o.rawNumbers : raw) ? v : format_cell(val2, v, o);
        }
        if (v != null) isempty = false;
      }
    }
    return { row, isempty };
  }
  function sheet_to_json(sheet, opts) {
    if (sheet == null || sheet["!ref"] == null) return [];
    var val2 = { t: "n", v: 0 }, header = 0, offset = 1, hdr = [], v = 0, vv = "";
    var r2 = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
    var o = opts || {};
    var range = o.range != null ? o.range : sheet["!ref"];
    if (o.header === 1) header = 1;
    else if (o.header === "A") header = 2;
    else if (Array.isArray(o.header)) header = 3;
    else if (o.header == null) header = 0;
    switch (typeof range) {
      case "string":
        r2 = safe_decode_range(range);
        break;
      case "number":
        r2 = safe_decode_range(sheet["!ref"]);
        r2.s.r = range;
        break;
      default:
        r2 = range;
    }
    if (header > 0) offset = 0;
    var rr = encode_row(r2.s.r);
    var cols = [];
    var out = [];
    var outi = 0, counter = 0;
    var dense = sheet["!data"] != null;
    var R = r2.s.r, C = 0;
    var header_cnt = {};
    if (dense && !sheet["!data"][R]) sheet["!data"][R] = [];
    var colinfo = o.skipHidden && sheet["!cols"] || [];
    var rowinfo = o.skipHidden && sheet["!rows"] || [];
    for (C = r2.s.c; C <= r2.e.c; ++C) {
      if ((colinfo[C] || {}).hidden) continue;
      cols[C] = encode_col(C);
      val2 = dense ? sheet["!data"][R][C] : sheet[cols[C] + rr];
      switch (header) {
        case 1:
          hdr[C] = C - r2.s.c;
          break;
        case 2:
          hdr[C] = cols[C];
          break;
        case 3:
          hdr[C] = o.header[C - r2.s.c];
          break;
        default:
          if (val2 == null) val2 = { w: "__EMPTY", t: "s" };
          vv = v = format_cell(val2, null, o);
          counter = header_cnt[v] || 0;
          if (!counter) header_cnt[v] = 1;
          else {
            do {
              vv = v + "_" + counter++;
            } while (header_cnt[vv]);
            header_cnt[v] = counter;
            header_cnt[vv] = 1;
          }
          hdr[C] = vv;
      }
    }
    for (R = r2.s.r + offset; R <= r2.e.r; ++R) {
      if ((rowinfo[R] || {}).hidden) continue;
      var row = make_json_row(sheet, r2, R, cols, header, hdr, o);
      if (row.isempty === false || (header === 1 ? o.blankrows !== false : !!o.blankrows)) out[outi++] = row.row;
    }
    out.length = outi;
    return out;
  }
  var qreg = /"/g;
  function make_csv_row(sheet, r2, R, cols, fs, rs, FS, w, o) {
    var isempty = true;
    var row = [], txt = "", rr = encode_row(R);
    var dense = sheet["!data"] != null;
    var datarow = dense && sheet["!data"][R] || [];
    for (var C = r2.s.c; C <= r2.e.c; ++C) {
      if (!cols[C]) continue;
      var val2 = dense ? datarow[C] : sheet[cols[C] + rr];
      if (val2 == null) txt = "";
      else if (val2.v != null) {
        isempty = false;
        txt = "" + (o.rawNumbers && val2.t == "n" ? val2.v : format_cell(val2, null, o));
        for (var i = 0, cc = 0; i !== txt.length; ++i) if ((cc = txt.charCodeAt(i)) === fs || cc === rs || cc === 34 || o.forceQuotes) {
          txt = '"' + txt.replace(qreg, '""') + '"';
          break;
        }
        if (txt == "ID" && w == 0 && row.length == 0) txt = '"ID"';
      } else if (val2.f != null && !val2.F) {
        isempty = false;
        txt = "=" + val2.f;
        if (txt.indexOf(",") >= 0) txt = '"' + txt.replace(qreg, '""') + '"';
      } else txt = "";
      row.push(txt);
    }
    if (o.strip) while (row[row.length - 1] === "") --row.length;
    if (o.blankrows === false && isempty) return null;
    return row.join(FS);
  }
  function sheet_to_csv(sheet, opts) {
    var out = [];
    var o = opts == null ? {} : opts;
    if (sheet == null || sheet["!ref"] == null) return "";
    var r2 = safe_decode_range(sheet["!ref"]);
    var FS = o.FS !== void 0 ? o.FS : ",", fs = FS.charCodeAt(0);
    var RS = o.RS !== void 0 ? o.RS : "\n", rs = RS.charCodeAt(0);
    var row = "", cols = [];
    var colinfo = o.skipHidden && sheet["!cols"] || [];
    var rowinfo = o.skipHidden && sheet["!rows"] || [];
    for (var C = r2.s.c; C <= r2.e.c; ++C) if (!(colinfo[C] || {}).hidden) cols[C] = encode_col(C);
    var w = 0;
    for (var R = r2.s.r; R <= r2.e.r; ++R) {
      if ((rowinfo[R] || {}).hidden) continue;
      row = make_csv_row(sheet, r2, R, cols, fs, rs, FS, w, o);
      if (row == null) {
        continue;
      }
      if (row || o.blankrows !== false) out.push((w++ ? RS : "") + row);
    }
    return out.join("");
  }
  function sheet_to_txt(sheet, opts) {
    if (!opts) opts = {};
    opts.FS = "	";
    opts.RS = "\n";
    var s = sheet_to_csv(sheet, opts);
    if (typeof $cptable == "undefined" || opts.type == "string") return s;
    var o = $cptable.utils.encode(1200, s, "str");
    return String.fromCharCode(255) + String.fromCharCode(254) + o;
  }
  function sheet_to_formulae(sheet, opts) {
    var y = "", x, val2 = "";
    if (sheet == null || sheet["!ref"] == null) return [];
    var r2 = safe_decode_range(sheet["!ref"]), rr = "", cols = [], C;
    var cmds = [];
    var dense = sheet["!data"] != null;
    for (C = r2.s.c; C <= r2.e.c; ++C) cols[C] = encode_col(C);
    for (var R = r2.s.r; R <= r2.e.r; ++R) {
      rr = encode_row(R);
      for (C = r2.s.c; C <= r2.e.c; ++C) {
        y = cols[C] + rr;
        x = dense ? (sheet["!data"][R] || [])[C] : sheet[y];
        val2 = "";
        if (x === void 0) continue;
        else if (x.F != null) {
          y = x.F;
          if (!x.f) continue;
          val2 = x.f;
          if (y.indexOf(":") == -1) y = y + ":" + y;
        }
        if (x.f != null) val2 = x.f;
        else if (opts && opts.values === false) continue;
        else if (x.t == "z") continue;
        else if (x.t == "n" && x.v != null) val2 = "" + x.v;
        else if (x.t == "b") val2 = x.v ? "TRUE" : "FALSE";
        else if (x.w !== void 0) val2 = "'" + x.w;
        else if (x.v === void 0) continue;
        else if (x.t == "s") val2 = "'" + x.v;
        else val2 = "" + x.v;
        cmds[cmds.length] = y + "=" + val2;
      }
    }
    return cmds;
  }
  function sheet_add_json(_ws, js, opts) {
    var o = opts || {};
    var dense = _ws ? _ws["!data"] != null : o.dense;
    var offset = +!o.skipHeader;
    var ws = _ws || {};
    if (!_ws && dense) ws["!data"] = [];
    var _R = 0, _C = 0;
    if (ws && o.origin != null) {
      if (typeof o.origin == "number") _R = o.origin;
      else {
        var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;
        _R = _origin.r;
        _C = _origin.c;
      }
    }
    var range = { s: { c: 0, r: 0 }, e: { c: _C, r: _R + js.length - 1 + offset } };
    if (ws["!ref"]) {
      var _range = safe_decode_range(ws["!ref"]);
      range.e.c = Math.max(range.e.c, _range.e.c);
      range.e.r = Math.max(range.e.r, _range.e.r);
      if (_R == -1) {
        _R = _range.e.r + 1;
        range.e.r = _R + js.length - 1 + offset;
      }
    } else {
      if (_R == -1) {
        _R = 0;
        range.e.r = js.length - 1 + offset;
      }
    }
    var hdr = o.header || [], C = 0;
    var ROW = [];
    js.forEach(function(JS, R) {
      if (dense && !ws["!data"][_R + R + offset]) ws["!data"][_R + R + offset] = [];
      if (dense) ROW = ws["!data"][_R + R + offset];
      keys(JS).forEach(function(k) {
        if ((C = hdr.indexOf(k)) == -1) hdr[C = hdr.length] = k;
        var v = JS[k];
        var t = "z";
        var z = "";
        var ref2 = dense ? "" : encode_col(_C + C) + encode_row(_R + R + offset);
        var cell = dense ? ROW[_C + C] : ws[ref2];
        if (v && typeof v === "object" && !(v instanceof Date)) {
          if (dense) ROW[_C + C] = v;
          else ws[ref2] = v;
        } else {
          if (typeof v == "number") t = "n";
          else if (typeof v == "boolean") t = "b";
          else if (typeof v == "string") t = "s";
          else if (v instanceof Date) {
            t = "d";
            if (!o.UTC) v = local_to_utc(v);
            if (!o.cellDates) {
              t = "n";
              v = datenum(v);
            }
            z = cell != null && cell.z && fmt_is_date(cell.z) ? cell.z : o.dateNF || table_fmt[14];
          } else if (v === null && o.nullError) {
            t = "e";
            v = 0;
          }
          if (!cell) {
            if (!dense) ws[ref2] = cell = { t, v };
            else ROW[_C + C] = cell = { t, v };
          } else {
            cell.t = t;
            cell.v = v;
            delete cell.w;
            delete cell.R;
            if (z) cell.z = z;
          }
          if (z) cell.z = z;
        }
      });
    });
    range.e.c = Math.max(range.e.c, _C + hdr.length - 1);
    var __R = encode_row(_R);
    if (dense && !ws["!data"][_R]) ws["!data"][_R] = [];
    if (offset) for (C = 0; C < hdr.length; ++C) {
      if (dense) ws["!data"][_R][C + _C] = { t: "s", v: hdr[C] };
      else ws[encode_col(C + _C) + __R] = { t: "s", v: hdr[C] };
    }
    ws["!ref"] = encode_range(range);
    return ws;
  }
  function json_to_sheet(js, opts) {
    return sheet_add_json(null, js, opts);
  }
  function ws_get_cell_stub(ws, R, C) {
    if (typeof R == "string") {
      if (ws["!data"] != null) {
        var RC = decode_cell(R);
        if (!ws["!data"][RC.r]) ws["!data"][RC.r] = [];
        return ws["!data"][RC.r][RC.c] || (ws["!data"][RC.r][RC.c] = { t: "z" });
      }
      return ws[R] || (ws[R] = { t: "z" });
    }
    if (typeof R != "number") return ws_get_cell_stub(ws, encode_cell(R));
    return ws_get_cell_stub(ws, encode_col(C || 0) + encode_row(R));
  }
  function wb_sheet_idx(wb, sh) {
    if (typeof sh == "number") {
      if (sh >= 0 && wb.SheetNames.length > sh) return sh;
      throw new Error("Cannot find sheet # " + sh);
    } else if (typeof sh == "string") {
      var idx = wb.SheetNames.indexOf(sh);
      if (idx > -1) return idx;
      throw new Error("Cannot find sheet name |" + sh + "|");
    } else throw new Error("Cannot find sheet |" + sh + "|");
  }
  function book_new(ws, wsname) {
    var wb = { SheetNames: [], Sheets: {} };
    if (ws) book_append_sheet(wb, ws, wsname || "Sheet1");
    return wb;
  }
  function book_append_sheet(wb, ws, name, roll) {
    var i = 1;
    if (!name) {
      for (; i <= 65535; ++i, name = void 0) if (wb.SheetNames.indexOf(name = "Sheet" + i) == -1) break;
    }
    if (!name || wb.SheetNames.length >= 65535) throw new Error("Too many worksheets");
    if (roll && wb.SheetNames.indexOf(name) >= 0 && name.length < 32) {
      var m = name.match(/\d+$/);
      i = m && +m[0] || 0;
      var root = m && name.slice(0, m.index) || name;
      for (++i; i <= 65535; ++i) if (wb.SheetNames.indexOf(name = root + i) == -1) break;
    }
    check_ws_name(name);
    if (wb.SheetNames.indexOf(name) >= 0) throw new Error("Worksheet with name |" + name + "| already exists!");
    wb.SheetNames.push(name);
    wb.Sheets[name] = ws;
    return name;
  }
  function book_set_sheet_visibility(wb, sh, vis) {
    if (!wb.Workbook) wb.Workbook = {};
    if (!wb.Workbook.Sheets) wb.Workbook.Sheets = [];
    var idx = wb_sheet_idx(wb, sh);
    if (!wb.Workbook.Sheets[idx]) wb.Workbook.Sheets[idx] = {};
    switch (vis) {
      case 0:
      case 1:
      case 2:
        break;
      default:
        throw new Error("Bad sheet visibility setting " + vis);
    }
    wb.Workbook.Sheets[idx].Hidden = vis;
  }
  function cell_set_number_format(cell, fmt) {
    cell.z = fmt;
    return cell;
  }
  function cell_set_hyperlink(cell, target, tooltip) {
    if (!target) {
      delete cell.l;
    } else {
      cell.l = { Target: target };
      if (tooltip) cell.l.Tooltip = tooltip;
    }
    return cell;
  }
  function cell_set_internal_link(cell, range, tooltip) {
    return cell_set_hyperlink(cell, "#" + range, tooltip);
  }
  function cell_add_comment(cell, text, author) {
    if (!cell.c) cell.c = [];
    cell.c.push({ t: text, a: author || "SheetJS" });
  }
  function sheet_set_array_formula(ws, range, formula, dynamic) {
    var rng = typeof range != "string" ? range : safe_decode_range(range);
    var rngstr = typeof range == "string" ? range : encode_range(range);
    for (var R = rng.s.r; R <= rng.e.r; ++R) for (var C = rng.s.c; C <= rng.e.c; ++C) {
      var cell = ws_get_cell_stub(ws, R, C);
      cell.t = "n";
      cell.F = rngstr;
      delete cell.v;
      if (R == rng.s.r && C == rng.s.c) {
        cell.f = formula;
        if (dynamic) cell.D = true;
      }
    }
    var wsr = decode_range(ws["!ref"]);
    if (wsr.s.r > rng.s.r) wsr.s.r = rng.s.r;
    if (wsr.s.c > rng.s.c) wsr.s.c = rng.s.c;
    if (wsr.e.r < rng.e.r) wsr.e.r = rng.e.r;
    if (wsr.e.c < rng.e.c) wsr.e.c = rng.e.c;
    ws["!ref"] = encode_range(wsr);
    return ws;
  }
  var utils = {
    encode_col,
    encode_row,
    encode_cell,
    encode_range,
    decode_col,
    decode_row,
    split_cell,
    decode_cell,
    decode_range,
    format_cell,
    sheet_new,
    sheet_add_aoa,
    sheet_add_json,
    sheet_add_dom,
    aoa_to_sheet,
    json_to_sheet,
    table_to_sheet: parse_dom_table,
    table_to_book,
    sheet_to_csv,
    sheet_to_txt,
    sheet_to_json,
    sheet_to_html,
    sheet_to_formulae,
    sheet_to_row_object_array: sheet_to_json,
    sheet_get_cell: ws_get_cell_stub,
    book_new,
    book_append_sheet,
    book_set_sheet_visibility,
    cell_set_number_format,
    cell_set_hyperlink,
    cell_set_internal_link,
    cell_add_comment,
    sheet_set_array_formula,
    consts: {
      SHEET_VISIBLE: 0,
      SHEET_HIDDEN: 1,
      SHEET_VERY_HIDDEN: 2
    }
  };
  var _Readable;
  function set_readable(R) {
    _Readable = R;
  }
  function write_csv_stream(sheet, opts) {
    var stream = _Readable();
    var o = opts == null ? {} : opts;
    if (sheet == null || sheet["!ref"] == null) {
      stream.push(null);
      return stream;
    }
    var r2 = safe_decode_range(sheet["!ref"]);
    var FS = o.FS !== void 0 ? o.FS : ",", fs = FS.charCodeAt(0);
    var RS = o.RS !== void 0 ? o.RS : "\n", rs = RS.charCodeAt(0);
    var row = "", cols = [];
    var colinfo = o.skipHidden && sheet["!cols"] || [];
    var rowinfo = o.skipHidden && sheet["!rows"] || [];
    for (var C = r2.s.c; C <= r2.e.c; ++C) if (!(colinfo[C] || {}).hidden) cols[C] = encode_col(C);
    var R = r2.s.r;
    var BOM = false, w = 0;
    stream._read = function() {
      if (!BOM) {
        BOM = true;
        return stream.push("\uFEFF");
      }
      while (R <= r2.e.r) {
        ++R;
        if ((rowinfo[R - 1] || {}).hidden) continue;
        row = make_csv_row(sheet, r2, R - 1, cols, fs, rs, FS, w, o);
        if (row != null) {
          if (row || o.blankrows !== false) return stream.push((w++ ? RS : "") + row);
        }
      }
      return stream.push(null);
    };
    return stream;
  }
  function write_html_stream(ws, opts) {
    var stream = _Readable();
    var o = opts || {};
    var header = o.header != null ? o.header : HTML_BEGIN;
    var footer = o.footer != null ? o.footer : HTML_END;
    stream.push(header);
    var r2 = decode_range(ws["!ref"]);
    stream.push(make_html_preamble(ws, r2, o));
    var R = r2.s.r;
    var end = false;
    stream._read = function() {
      if (R > r2.e.r) {
        if (!end) {
          end = true;
          stream.push("</table>" + footer);
        }
        return stream.push(null);
      }
      while (R <= r2.e.r) {
        stream.push(make_html_row(ws, r2, R, o));
        ++R;
        break;
      }
    };
    return stream;
  }
  function write_json_stream(sheet, opts) {
    var stream = _Readable({ objectMode: true });
    if (sheet == null || sheet["!ref"] == null) {
      stream.push(null);
      return stream;
    }
    var val2 = { t: "n", v: 0 }, header = 0, offset = 1, hdr = [], v = 0, vv = "";
    var r2 = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
    var o = opts || {};
    var range = o.range != null ? o.range : sheet["!ref"];
    if (o.header === 1) header = 1;
    else if (o.header === "A") header = 2;
    else if (Array.isArray(o.header)) header = 3;
    switch (typeof range) {
      case "string":
        r2 = safe_decode_range(range);
        break;
      case "number":
        r2 = safe_decode_range(sheet["!ref"]);
        r2.s.r = range;
        break;
      default:
        r2 = range;
    }
    if (header > 0) offset = 0;
    var rr = encode_row(r2.s.r);
    var cols = [];
    var counter = 0;
    var dense = sheet["!data"] != null;
    var R = r2.s.r, C = 0;
    var header_cnt = {};
    if (dense && !sheet["!data"][R]) sheet["!data"][R] = [];
    var colinfo = o.skipHidden && sheet["!cols"] || [];
    var rowinfo = o.skipHidden && sheet["!rows"] || [];
    for (C = r2.s.c; C <= r2.e.c; ++C) {
      if ((colinfo[C] || {}).hidden) continue;
      cols[C] = encode_col(C);
      val2 = dense ? sheet["!data"][R][C] : sheet[cols[C] + rr];
      switch (header) {
        case 1:
          hdr[C] = C - r2.s.c;
          break;
        case 2:
          hdr[C] = cols[C];
          break;
        case 3:
          hdr[C] = o.header[C - r2.s.c];
          break;
        default:
          if (val2 == null) val2 = { w: "__EMPTY", t: "s" };
          vv = v = format_cell(val2, null, o);
          counter = header_cnt[v] || 0;
          if (!counter) header_cnt[v] = 1;
          else {
            do {
              vv = v + "_" + counter++;
            } while (header_cnt[vv]);
            header_cnt[v] = counter;
            header_cnt[vv] = 1;
          }
          hdr[C] = vv;
      }
    }
    R = r2.s.r + offset;
    stream._read = function() {
      while (R <= r2.e.r) {
        if ((rowinfo[R - 1] || {}).hidden) continue;
        var row = make_json_row(sheet, r2, R, cols, header, hdr, o);
        ++R;
        if (row.isempty === false || (header === 1 ? o.blankrows !== false : !!o.blankrows)) {
          stream.push(row.row);
          return;
        }
      }
      return stream.push(null);
    };
    return stream;
  }
  function write_xlml_stream(wb, o) {
    var stream = _Readable();
    var opts = o == null ? {} : o;
    var stride = +opts.stride || 10;
    if (!wb.SSF) wb.SSF = dup(table_fmt);
    if (wb.SSF) {
      make_ssf();
      SSF_load_table(wb.SSF);
      opts.revssf = evert_num(wb.SSF);
      opts.revssf[wb.SSF[65535]] = 0;
      opts.ssf = wb.SSF;
      opts.cellXfs = [];
      get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
    }
    wb.SheetNames.forEach(function(n) {
      var ws2 = wb.Sheets[n];
      if (!ws2 || !ws2["!ref"]) return;
      var range2 = decode_range(ws2["!ref"]);
      var dense2 = ws2["!data"] != null;
      var ddata = dense2 ? ws2["!data"] : [];
      for (var R2 = range2.s.r; R2 <= range2.e.r; ++R2) {
        if (dense2 && !ddata[R2]) continue;
        for (var C = range2.s.c; C <= range2.e.c; ++C) {
          var cell = dense2 ? ddata[R2][C] : ws2[encode_col(C) + encode_row(R2)];
          if (!cell) continue;
          if (cell.t == "d" && cell.z == null) {
            cell = dup(cell);
            cell.z = table_fmt[14];
          }
          void get_cell_style(opts.cellXfs, cell, opts);
        }
      }
    });
    var sty = write_sty_xlml(wb, opts);
    var stage = 0, wsidx = 0, ws = wb.Sheets[wb.SheetNames[wsidx]], range = safe_decode_range(ws), R = -1, T = false;
    var marr = [], mi = 0, dense = false, darr = [], addr = { r: 0, c: 0 };
    stream._read = function() {
      switch (stage) {
case 0:
          {
            stage = 1;
            stream.push(XML_HEADER);
            stream.push("<Workbook" + wxt_helper({
              "xmlns": XLMLNS.ss,
              "xmlns:o": XLMLNS.o,
              "xmlns:x": XLMLNS.x,
              "xmlns:ss": XLMLNS.ss,
              "xmlns:dt": XLMLNS.dt,
              "xmlns:html": XLMLNS.html
            }) + ">");
          }
          break;
case 1:
          {
            stage = 2;
            stream.push(write_props_xlml(wb, opts));
            stream.push(write_wb_xlml(wb));
          }
          break;
case 2:
          {
            stage = 3;
            stream.push(sty);
            stream.push(write_names_xlml(wb));
          }
          break;
case 3:
          {
            T = false;
            if (wsidx >= wb.SheetNames.length) {
              stage = -1;
              stream.push("");
              break;
            }
            stream.push("<Worksheet" + wxt_helper({ "ss:Name": escapexml(wb.SheetNames[wsidx]) }) + ">");
            ws = wb.Sheets[wb.SheetNames[wsidx]];
            if (!ws) {
              stream.push("</Worksheet>");
              return void ++wsidx;
            }
            var names = write_ws_xlml_names(ws, opts, wsidx, wb);
            if (names.length) stream.push("<Names>" + names + "</Names>");
            if (!ws["!ref"]) return stage = 5;
            range = safe_decode_range(ws["!ref"]);
            R = range.s.r;
            stage = 4;
          }
          break;
case 4:
          {
            if (R < 0 || R > range.e.r) {
              if (T) stream.push("</Table>");
              return void (stage = 5);
            }
            if (R <= range.s.r) {
              if (ws["!cols"]) ws["!cols"].forEach(function(n, i) {
                process_col(n);
                var w = !!n.width;
                var p2 = col_obj_w(i, n);
                var k = { "ss:Index": i + 1 };
                if (w) k["ss:Width"] = width2px(p2.width);
                if (n.hidden) k["ss:Hidden"] = "1";
                if (!T) {
                  T = true;
                  stream.push("<Table>");
                }
                stream.push(writextag("Column", null, k));
              });
              dense = ws["!data"] != null;
              if (dense) darr = ws["!data"];
              addr.r = addr.c = 0;
            }
            for (var cnt = 0; R <= range.e.r && cnt < stride; ++R, ++cnt) {
              var row = [write_ws_xlml_row(R, (ws["!rows"] || [])[R])];
              addr.r = R;
              if (!(dense && !darr[R])) for (var C = range.s.c; C <= range.e.c; ++C) {
                addr.c = C;
                var skip = false;
                for (mi = 0; mi != marr.length; ++mi) {
                  if (marr[mi].s.c > C) continue;
                  if (marr[mi].s.r > R) continue;
                  if (marr[mi].e.c < C) continue;
                  if (marr[mi].e.r < R) continue;
                  if (marr[mi].s.c != C || marr[mi].s.r != R) skip = true;
                  break;
                }
                if (skip) continue;
                var ref2 = encode_col(C) + encode_row(R), cell = dense ? darr[R][C] : ws[ref2];
                row.push(write_ws_xlml_cell(cell, ref2, ws, opts, wsidx, wb, addr));
              }
              row.push("</Row>");
              if (!T) {
                T = true;
                stream.push("<Table>");
              }
              stream.push(row.join(""));
            }
          }
          break;
case 5: {
          stream.push(write_ws_xlml_wsopts(ws, opts, wsidx, wb));
          if (ws && ws["!autofilter"]) stream.push('<AutoFilter x:Range="' + a1_to_rc(fix_range(ws["!autofilter"].ref), { r: 0, c: 0 }) + '" xmlns="urn:schemas-microsoft-com:office:excel"></AutoFilter>');
          stream.push("</Worksheet>");
          wsidx++;
          R = -1;
          return void (stage = 3);
        }
case -1:
          {
            stage = -2;
            stream.push("</Workbook>");
          }
          break;
case -2:
          stream.push(null);
          break;
      }
    };
    return stream;
  }
  var __stream = {
    to_json: write_json_stream,
    to_html: write_html_stream,
    to_csv: write_csv_stream,
    to_xlml: write_xlml_stream,
    set_readable
  };
  const XLSX$1 = {
    parse_xlscfb,
    parse_zip,
    read: readSync,
    readFile: readFileSync,
    readFileSync,
    write: writeSync,
    writeFile: writeFileSync,
    writeFileSync,
    writeFileAsync,
    writeXLSX: writeSyncXLSX,
    writeFileXLSX: writeFileSyncXLSX,
    utils,
    set_fs,
    set_cptable,
    stream: __stream,
    SSF,
    CFB
  };
  function wareListDTO(wareList) {
    return wareList.map((value) => {
      return {
        wareId: value.wareId,
        wareName: value.wareName,
        price: value.price,
        startTime: dayjs(value.startTime).format("YYYY-MM-DD HH:mm:ss")
      };
    });
  }
  function wareListJTS(wareList) {
    const ws = XLSX$1.utils.json_to_sheet(wareList, {
      header: ["wareId", "wareName", "price", "startTime"]
    });
    ws["A1"].v = "商品编号";
    ws["B1"].v = "商品名称";
    ws["C1"].v = "含税价";
    ws["D1"].v = "开始时间";
    const wb = XLSX$1.utils.book_new();
    XLSX$1.utils.book_append_sheet(wb, ws, "Sheet1");
    XLSX$1.writeFile(wb, `商品数据表_${dayjs(Date.now()).format("MMDDmm")}.xlsx`);
  }
  function changePageSize() {
    try {
      document.querySelector('button[type="submit"]').click();
    } catch {
    }
  }
  function changePageNumber() {
    const btn = document.querySelectorAll("button.ant-pagination-item-link")[1];
    btn.click();
    if (btn.disabled) {
      throw new Error("数据获取完毕");
    }
  }
  class Observer {
    subscribers;
    constructor() {
      this.subscribers = new Map();
    }
    subscribe(event, callback2) {
      if (!this.subscribers.has(event)) {
        this.subscribers.set(event, []);
      }
      this.subscribers.get(event).push(callback2);
    }
    unsubscribe(event, callback2) {
      if (this.subscribers.has(event)) {
        const callbacks = this.subscribers.get(event);
        const index = callbacks.indexOf(callback2);
        if (index > -1) {
          callbacks.splice(index, 1);
        }
      }
      console.log(this.subscribers);
    }
    notify(event, data) {
      if (this.subscribers.has(event)) {
        this.subscribers.get(event).forEach((callback2) => {
          try {
            callback2(data);
          } catch (error) {
            console.error("Observer callback error:", error);
          }
        });
      }
    }
  }
  const observer = new Observer();
  const skuList = [];
  function startTask() {
    observer.subscribe("skuList", callback);
    changePageSize();
  }
  function stopTask() {
    observer.unsubscribe("skuList", callback);
    wareListJTS(skuList);
    skuList.length = 0;
  }
  function callback(data) {
    skuList.push(...wareListDTO(data));
    setTimeout(() => {
      try {
        changePageNumber();
      } catch (error) {
        console.log(error);
        isActive.value = false;
      }
    }, 5e3);
  }
  const isActive = ref(false);
  function activeChange() {
    isActive.value = !isActive.value;
  }
  watch(
    () => isActive.value,
    (value) => {
      if (value) {
        try {
          startTask();
        } catch {
          setTimeout(() => {
            isActive.value = false;
          }, 1e3);
        }
      } else {
        stopTask();
      }
    }
  );
  const _sfc_main$2 = defineComponent({
    __name: "ToggleButton",
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(_sfc_main$3), {
          class: "rounded-full w-9 h-9 flex items-center justify-center p-0",
          variant: unref(isActive) ? "destructive" : "outline",
          onClick: unref(activeChange)
        }, {
          default: withCtx(() => [
            !unref(isActive) ? (openBlock(), createBlock(unref(Power), { key: 0 })) : createCommentVNode("", true),
            unref(isActive) ? (openBlock(), createBlock(unref(PowerOff), { key: 1 })) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["variant", "onClick"]);
      };
    }
  });
  const _sfc_main$1 = defineComponent({
    __name: "FloatPanel",
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createBlock(_sfc_main$4, null, {
          default: withCtx(() => [
            createVNode(_sfc_main$2)
          ]),
          _: 1
        });
      };
    }
  });
  const _sfc_main = defineComponent({
    __name: "App",
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createBlock(_sfc_main$1);
      };
    }
  });
  const indexCss = `/*! tailwindcss v4.1.12 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-border-style:solid;--tw-font-weight:initial;--tw-tracking:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-animation-delay:0s;--tw-animation-direction:normal;--tw-animation-duration:initial;--tw-animation-fill-mode:none;--tw-animation-iteration-count:1;--tw-enter-blur:0;--tw-enter-opacity:1;--tw-enter-rotate:0;--tw-enter-scale:1;--tw-enter-translate-x:0;--tw-enter-translate-y:0;--tw-exit-blur:0;--tw-exit-opacity:1;--tw-exit-rotate:0;--tw-exit-scale:1;--tw-exit-translate-x:0;--tw-exit-translate-y:0}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-white:#fff;--spacing:.25rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--font-weight-medium:500;--tracking-widest:.1em;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}*{border-color:var(--border);outline-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){*{outline-color:color-mix(in oklab,var(--ring)50%,transparent)}}body{background-color:var(--background);color:var(--foreground)}}@layer components;@layer utilities{.pointer-events-none{pointer-events:none}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.left-2{left:calc(var(--spacing)*2)}.z-50{z-index:50}.-mx-1{margin-inline:calc(var(--spacing)*-1)}.my-1{margin-block:calc(var(--spacing)*1)}.ml-auto{margin-left:auto}.flex{display:flex}.inline-flex{display:inline-flex}.size-2{width:calc(var(--spacing)*2);height:calc(var(--spacing)*2)}.size-2\\.5{width:calc(var(--spacing)*2.5);height:calc(var(--spacing)*2.5)}.size-3\\.5{width:calc(var(--spacing)*3.5);height:calc(var(--spacing)*3.5)}.size-4{width:calc(var(--spacing)*4);height:calc(var(--spacing)*4)}.size-9{width:calc(var(--spacing)*9);height:calc(var(--spacing)*9)}.size-full{width:100%;height:100%}.h-2\\.5{height:calc(var(--spacing)*2.5)}.h-8{height:calc(var(--spacing)*8)}.h-9{height:calc(var(--spacing)*9)}.h-10{height:calc(var(--spacing)*10)}.h-full{height:100%}.h-px{height:1px}.max-h-\\(--reka-dropdown-menu-content-available-height\\){max-height:var(--reka-dropdown-menu-content-available-height)}.w-2\\.5{width:calc(var(--spacing)*2.5)}.w-9{width:calc(var(--spacing)*9)}.w-72{width:calc(var(--spacing)*72)}.w-80{width:calc(var(--spacing)*80)}.w-fit{width:fit-content}.min-w-\\[8rem\\]{min-width:8rem}.flex-1{flex:1}.shrink-0{flex-shrink:0}.origin-\\(--reka-dropdown-menu-content-transform-origin\\){transform-origin:var(--reka-dropdown-menu-content-transform-origin)}.origin-\\(--reka-popover-content-transform-origin\\){transform-origin:var(--reka-popover-content-transform-origin)}.translate-y-\\[calc\\(-50\\%_-_2px\\)\\]{--tw-translate-y: calc(-50% - 2px) ;translate:var(--tw-translate-x)var(--tw-translate-y)}.rotate-45{rotate:45deg}.animate-in{animation:enter var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.cursor-default{cursor:default}.cursor-grab{cursor:grab}.touch-none{touch-action:none}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.gap-1\\.5{gap:calc(var(--spacing)*1.5)}.gap-2{gap:calc(var(--spacing)*2)}.overflow-hidden{overflow:hidden}.overflow-x-hidden{overflow-x:hidden}.overflow-y-auto{overflow-y:auto}.rounded-\\[2px\\]{border-radius:2px}.rounded-\\[inherit\\]{border-radius:inherit}.rounded-full{border-radius:3.40282e38px}.rounded-md{border-radius:calc(var(--radius) - 2px)}.rounded-sm{border-radius:calc(var(--radius) - 4px)}.border{border-style:var(--tw-border-style);border-width:1px}.border-t{border-top-style:var(--tw-border-style);border-top-width:1px}.border-l{border-left-style:var(--tw-border-style);border-left-width:1px}.border-t-transparent{border-top-color:#0000}.border-l-transparent{border-left-color:#0000}.bg-background{background-color:var(--background)}.bg-border{background-color:var(--border)}.bg-destructive{background-color:var(--destructive)}.bg-popover{background-color:var(--popover)}.bg-primary{background-color:var(--primary)}.bg-secondary{background-color:var(--secondary)}.fill-current{fill:currentColor}.fill-primary{fill:var(--primary)}.p-0{padding:calc(var(--spacing)*0)}.p-1{padding:calc(var(--spacing)*1)}.p-4{padding:calc(var(--spacing)*4)}.p-px{padding:1px}.px-2{padding-inline:calc(var(--spacing)*2)}.px-3{padding-inline:calc(var(--spacing)*3)}.px-4{padding-inline:calc(var(--spacing)*4)}.px-6{padding-inline:calc(var(--spacing)*6)}.py-1\\.5{padding-block:calc(var(--spacing)*1.5)}.py-2{padding-block:calc(var(--spacing)*2)}.pr-2{padding-right:calc(var(--spacing)*2)}.pl-8{padding-left:calc(var(--spacing)*8)}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.tracking-widest{--tw-tracking:var(--tracking-widest);letter-spacing:var(--tracking-widest)}.text-balance{text-wrap:balance}.whitespace-nowrap{white-space:nowrap}.text-muted-foreground{color:var(--muted-foreground)}.text-popover-foreground{color:var(--popover-foreground)}.text-primary{color:var(--primary)}.text-primary-foreground{color:var(--primary-foreground)}.text-secondary-foreground{color:var(--secondary-foreground)}.text-white{color:var(--color-white)}.underline-offset-4{text-underline-offset:4px}.shadow-lg{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-md{--tw-shadow:0 4px 6px -1px var(--tw-shadow-color,#0000001a),0 2px 4px -2px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-xs{--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.outline-hidden{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.outline-hidden{outline-offset:2px;outline:2px solid #0000}}.outline{outline-style:var(--tw-outline-style);outline-width:1px}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.transition-\\[color\\,box-shadow\\]{transition-property:color,box-shadow;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-all{transition-property:all;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-colors{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.fade-in-0{--tw-enter-opacity:0}.outline-none{--tw-outline-style:none;outline-style:none}.select-none{-webkit-user-select:none;user-select:none}.zoom-in-95{--tw-enter-scale:.95}@media (hover:hover){.hover\\:bg-accent:hover{background-color:var(--accent)}.hover\\:bg-destructive\\/90:hover{background-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-destructive\\/90:hover{background-color:color-mix(in oklab,var(--destructive)90%,transparent)}}.hover\\:bg-primary\\/90:hover{background-color:var(--primary)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-primary\\/90:hover{background-color:color-mix(in oklab,var(--primary)90%,transparent)}}.hover\\:bg-secondary\\/80:hover{background-color:var(--secondary)}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-secondary\\/80:hover{background-color:color-mix(in oklab,var(--secondary)80%,transparent)}}.hover\\:text-accent-foreground:hover{color:var(--accent-foreground)}.hover\\:underline:hover{text-decoration-line:underline}}.focus\\:bg-accent:focus{background-color:var(--accent)}.focus\\:text-accent-foreground:focus{color:var(--accent-foreground)}.focus-visible\\:border-ring:focus-visible{border-color:var(--ring)}.focus-visible\\:ring-\\[3px\\]:focus-visible{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(3px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus-visible\\:ring-destructive\\/20:focus-visible{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:ring-destructive\\/20:focus-visible{--tw-ring-color:color-mix(in oklab,var(--destructive)20%,transparent)}}.focus-visible\\:ring-ring\\/50:focus-visible{--tw-ring-color:var(--ring)}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:ring-ring\\/50:focus-visible{--tw-ring-color:color-mix(in oklab,var(--ring)50%,transparent)}}.focus-visible\\:outline-1:focus-visible{outline-style:var(--tw-outline-style);outline-width:1px}.disabled\\:pointer-events-none:disabled{pointer-events:none}.disabled\\:opacity-50:disabled{opacity:.5}.has-\\[\\>svg\\]\\:px-2\\.5:has(>svg){padding-inline:calc(var(--spacing)*2.5)}.has-\\[\\>svg\\]\\:px-3:has(>svg){padding-inline:calc(var(--spacing)*3)}.has-\\[\\>svg\\]\\:px-4:has(>svg){padding-inline:calc(var(--spacing)*4)}.aria-invalid\\:border-destructive[aria-invalid=true]{border-color:var(--destructive)}.aria-invalid\\:ring-destructive\\/20[aria-invalid=true]{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.aria-invalid\\:ring-destructive\\/20[aria-invalid=true]{--tw-ring-color:color-mix(in oklab,var(--destructive)20%,transparent)}}.data-\\[disabled\\]\\:pointer-events-none[data-disabled]{pointer-events:none}.data-\\[disabled\\]\\:opacity-50[data-disabled]{opacity:.5}.data-\\[inset\\]\\:pl-8[data-inset]{padding-left:calc(var(--spacing)*8)}.data-\\[side\\=bottom\\]\\:slide-in-from-top-2[data-side=bottom]{--tw-enter-translate-y:calc(2*var(--spacing)*-1)}.data-\\[side\\=left\\]\\:slide-in-from-right-2[data-side=left]{--tw-enter-translate-x:calc(2*var(--spacing))}.data-\\[side\\=right\\]\\:slide-in-from-left-2[data-side=right]{--tw-enter-translate-x:calc(2*var(--spacing)*-1)}.data-\\[side\\=top\\]\\:slide-in-from-bottom-2[data-side=top]{--tw-enter-translate-y:calc(2*var(--spacing))}.data-\\[state\\=closed\\]\\:animate-out[data-state=closed]{animation:exit var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.data-\\[state\\=closed\\]\\:fade-out-0[data-state=closed]{--tw-exit-opacity:0}.data-\\[state\\=closed\\]\\:zoom-out-95[data-state=closed]{--tw-exit-scale:.95}.data-\\[state\\=open\\]\\:animate-in[data-state=open]{animation:enter var(--tw-animation-duration,var(--tw-duration,.15s))var(--tw-ease,ease)var(--tw-animation-delay,0s)var(--tw-animation-iteration-count,1)var(--tw-animation-direction,normal)var(--tw-animation-fill-mode,none)}.data-\\[state\\=open\\]\\:bg-accent[data-state=open]{background-color:var(--accent)}.data-\\[state\\=open\\]\\:text-accent-foreground[data-state=open]{color:var(--accent-foreground)}.data-\\[state\\=open\\]\\:fade-in-0[data-state=open]{--tw-enter-opacity:0}.data-\\[state\\=open\\]\\:zoom-in-95[data-state=open]{--tw-enter-scale:.95}.data-\\[variant\\=destructive\\]\\:text-destructive-foreground[data-variant=destructive]{color:var(--destructive-foreground)}.data-\\[variant\\=destructive\\]\\:focus\\:bg-destructive\\/10[data-variant=destructive]:focus{background-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.data-\\[variant\\=destructive\\]\\:focus\\:bg-destructive\\/10[data-variant=destructive]:focus{background-color:color-mix(in oklab,var(--destructive)10%,transparent)}}.data-\\[variant\\=destructive\\]\\:focus\\:text-destructive-foreground[data-variant=destructive]:focus{color:var(--destructive-foreground)}.dark\\:border-input:is(.dark *){border-color:var(--input)}.dark\\:bg-destructive\\/60:is(.dark *){background-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-destructive\\/60:is(.dark *){background-color:color-mix(in oklab,var(--destructive)60%,transparent)}}.dark\\:bg-input\\/30:is(.dark *){background-color:var(--input)}@supports (color:color-mix(in lab,red,red)){.dark\\:bg-input\\/30:is(.dark *){background-color:color-mix(in oklab,var(--input)30%,transparent)}}@media (hover:hover){.dark\\:hover\\:bg-accent\\/50:is(.dark *):hover{background-color:var(--accent)}@supports (color:color-mix(in lab,red,red)){.dark\\:hover\\:bg-accent\\/50:is(.dark *):hover{background-color:color-mix(in oklab,var(--accent)50%,transparent)}}.dark\\:hover\\:bg-input\\/50:is(.dark *):hover{background-color:var(--input)}@supports (color:color-mix(in lab,red,red)){.dark\\:hover\\:bg-input\\/50:is(.dark *):hover{background-color:color-mix(in oklab,var(--input)50%,transparent)}}}.dark\\:focus-visible\\:ring-destructive\\/40:is(.dark *):focus-visible{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.dark\\:focus-visible\\:ring-destructive\\/40:is(.dark *):focus-visible{--tw-ring-color:color-mix(in oklab,var(--destructive)40%,transparent)}}.dark\\:aria-invalid\\:ring-destructive\\/40:is(.dark *)[aria-invalid=true]{--tw-ring-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.dark\\:aria-invalid\\:ring-destructive\\/40:is(.dark *)[aria-invalid=true]{--tw-ring-color:color-mix(in oklab,var(--destructive)40%,transparent)}}.dark\\:data-\\[variant\\=destructive\\]\\:focus\\:bg-destructive\\/40:is(.dark *)[data-variant=destructive]:focus{background-color:var(--destructive)}@supports (color:color-mix(in lab,red,red)){.dark\\:data-\\[variant\\=destructive\\]\\:focus\\:bg-destructive\\/40:is(.dark *)[data-variant=destructive]:focus{background-color:color-mix(in oklab,var(--destructive)40%,transparent)}}.\\[\\&_svg\\]\\:pointer-events-none svg{pointer-events:none}.\\[\\&_svg\\]\\:shrink-0 svg{flex-shrink:0}.\\[\\&_svg\\:not\\(\\[class\\*\\=\\'size-\\'\\]\\)\\]\\:size-4 svg:not([class*=size-]){width:calc(var(--spacing)*4);height:calc(var(--spacing)*4)}.\\[\\&_svg\\:not\\(\\[class\\*\\=\\'text-\\'\\]\\)\\]\\:text-muted-foreground svg:not([class*=text-]){color:var(--muted-foreground)}:is(.data-\\[variant\\=destructive\\]\\:\\*\\:\\[svg\\]\\:\\!text-destructive-foreground[data-variant=destructive]>*):is(svg){color:var(--destructive-foreground)!important}}@property --tw-animation-delay{syntax:"*";inherits:false;initial-value:0s}@property --tw-animation-direction{syntax:"*";inherits:false;initial-value:normal}@property --tw-animation-duration{syntax:"*";inherits:false}@property --tw-animation-fill-mode{syntax:"*";inherits:false;initial-value:none}@property --tw-animation-iteration-count{syntax:"*";inherits:false;initial-value:1}@property --tw-enter-blur{syntax:"*";inherits:false;initial-value:0}@property --tw-enter-opacity{syntax:"*";inherits:false;initial-value:1}@property --tw-enter-rotate{syntax:"*";inherits:false;initial-value:0}@property --tw-enter-scale{syntax:"*";inherits:false;initial-value:1}@property --tw-enter-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-enter-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-exit-blur{syntax:"*";inherits:false;initial-value:0}@property --tw-exit-opacity{syntax:"*";inherits:false;initial-value:1}@property --tw-exit-rotate{syntax:"*";inherits:false;initial-value:0}@property --tw-exit-scale{syntax:"*";inherits:false;initial-value:1}@property --tw-exit-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-exit-translate-y{syntax:"*";inherits:false;initial-value:0}:root{--background:oklch(100% 0 0);--foreground:oklch(12.9% .042 264.695);--card:oklch(100% 0 0);--card-foreground:oklch(12.9% .042 264.695);--popover:oklch(100% 0 0);--popover-foreground:oklch(12.9% .042 264.695);--primary:oklch(20.8% .042 265.755);--primary-foreground:oklch(98.4% .003 247.858);--secondary:oklch(96.8% .007 247.896);--secondary-foreground:oklch(20.8% .042 265.755);--muted:oklch(96.8% .007 247.896);--muted-foreground:oklch(55.4% .046 257.417);--accent:oklch(96.8% .007 247.896);--accent-foreground:oklch(20.8% .042 265.755);--destructive:oklch(64.91% .19475 21.633/.966);--destructive-foreground:oklch(57.7% .245 27.325);--border:oklch(92.9% .013 255.508);--input:oklch(92.9% .013 255.508);--ring:oklch(70.4% .04 256.788);--chart-1:oklch(64.6% .222 41.116);--chart-2:oklch(60% .118 184.704);--chart-3:oklch(39.8% .07 227.392);--chart-4:oklch(82.8% .189 84.429);--chart-5:oklch(76.9% .188 70.08);--radius:.625rem;--sidebar:oklch(98.4% .003 247.858);--sidebar-foreground:oklch(12.9% .042 264.695);--sidebar-primary:oklch(20.8% .042 265.755);--sidebar-primary-foreground:oklch(98.4% .003 247.858);--sidebar-accent:oklch(96.8% .007 247.896);--sidebar-accent-foreground:oklch(20.8% .042 265.755);--sidebar-border:oklch(92.9% .013 255.508);--sidebar-ring:oklch(70.4% .04 256.788)}.dark{--background:oklch(12.9% .042 264.695);--foreground:oklch(98.4% .003 247.858);--card:oklch(12.9% .042 264.695);--card-foreground:oklch(98.4% .003 247.858);--popover:oklch(12.9% .042 264.695);--popover-foreground:oklch(98.4% .003 247.858);--primary:oklch(98.4% .003 247.858);--primary-foreground:oklch(20.8% .042 265.755);--secondary:oklch(27.9% .041 260.031);--secondary-foreground:oklch(98.4% .003 247.858);--muted:oklch(27.9% .041 260.031);--muted-foreground:oklch(70.4% .04 256.788);--accent:oklch(27.9% .041 260.031);--accent-foreground:oklch(98.4% .003 247.858);--destructive:oklch(39.6% .141 25.723);--destructive-foreground:oklch(63.7% .237 25.331);--border:oklch(27.9% .041 260.031);--input:oklch(27.9% .041 260.031);--ring:oklch(44.6% .043 257.281);--chart-1:oklch(48.8% .243 264.376);--chart-2:oklch(69.6% .17 162.48);--chart-3:oklch(76.9% .188 70.08);--chart-4:oklch(62.7% .265 303.9);--chart-5:oklch(64.5% .246 16.439);--sidebar:oklch(20.8% .042 265.755);--sidebar-foreground:oklch(98.4% .003 247.858);--sidebar-primary:oklch(48.8% .243 264.376);--sidebar-primary-foreground:oklch(98.4% .003 247.858);--sidebar-accent:oklch(27.9% .041 260.031);--sidebar-accent-foreground:oklch(98.4% .003 247.858);--sidebar-border:oklch(27.9% .041 260.031);--sidebar-ring:oklch(44.6% .043 257.281)}@property --tw-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-z{syntax:"*";inherits:false;initial-value:0}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-tracking{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-outline-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}@keyframes enter{0%{opacity:var(--tw-enter-opacity,1);transform:translate3d(var(--tw-enter-translate-x,0),var(--tw-enter-translate-y,0),0)scale3d(var(--tw-enter-scale,1),var(--tw-enter-scale,1),var(--tw-enter-scale,1))rotate(var(--tw-enter-rotate,0));filter:blur(var(--tw-enter-blur,0))}}@keyframes exit{to{opacity:var(--tw-exit-opacity,1);transform:translate3d(var(--tw-exit-translate-x,0),var(--tw-exit-translate-y,0),0)scale3d(var(--tw-exit-scale,1),var(--tw-exit-scale,1),var(--tw-exit-scale,1))rotate(var(--tw-exit-rotate,0));filter:blur(var(--tw-exit-blur,0))}}`;
  importCSS(indexCss);
  // @license      GNU LGPL-3.0
  var ajaxHooker = (function() {
    const version2 = "1.4.7";
    const hookInst = {
      hookFns: [],
      filters: []
    };
    const win = window.unsafeWindow || document.defaultView || window;
    let winAh = win.__ajaxHooker;
    const resProto = win.Response.prototype;
    const xhrResponses = ["response", "responseText", "responseXML"];
    const fetchResponses = ["arrayBuffer", "blob", "formData", "json", "text"];
    const xhrExtraProps = ["responseType", "timeout", "withCredentials"];
    const fetchExtraProps = [
      "cache",
      "credentials",
      "integrity",
      "keepalive",
      "mode",
      "priority",
      "redirect",
      "referrer",
      "referrerPolicy",
      "signal"
    ];
    const xhrAsyncEvents = ["readystatechange", "load", "loadend"];
    const getType = {}.toString.call.bind({}.toString);
    const getDescriptor = Object.getOwnPropertyDescriptor.bind(Object);
    const emptyFn = () => {
    };
    const errorFn = (e) => console.error(e);
    function isThenable(obj) {
      return obj && ["object", "function"].includes(typeof obj) && typeof obj.then === "function";
    }
    function catchError(fn, ...args) {
      try {
        const result = fn(...args);
        if (isThenable(result)) return result.then(null, errorFn);
        return result;
      } catch (err) {
        console.error(err);
      }
    }
    function defineProp(obj, prop, getter, setter) {
      Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: true,
        get: getter,
        set: setter
      });
    }
    function readonly2(obj, prop, value = obj[prop]) {
      defineProp(obj, prop, () => value, emptyFn);
    }
    function writable(obj, prop, value = obj[prop]) {
      Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: true,
        writable: true,
        value
      });
    }
    function parseHeaders(obj) {
      const headers = {};
      switch (getType(obj)) {
        case "[object String]":
          for (const line of obj.trim().split(/[\r\n]+/)) {
            const [header, value] = line.split(new RegExp("(?<=^[^:]+)\\s*:\\s*"));
            if (!value) continue;
            const lheader = header.toLowerCase();
            headers[lheader] = lheader in headers ? `${headers[lheader]}, ${value}` : value;
          }
          break;
        case "[object Headers]":
          for (const [key, val2] of obj) {
            headers[key] = val2;
          }
          break;
        case "[object Object]":
          return { ...obj };
      }
      return headers;
    }
    function stopImmediatePropagation() {
      this.ajaxHooker_isStopped = true;
    }
    class SyncThenable {
      then(fn) {
        fn && fn();
        return new SyncThenable();
      }
    }
    class AHRequest {
      constructor(request) {
        this.request = request;
        this.requestClone = { ...this.request };
      }
      _recoverRequestKey(key) {
        if (key in this.requestClone) this.request[key] = this.requestClone[key];
        else delete this.request[key];
      }
      shouldFilter(filters) {
        const { type, url, method, async } = this.request;
        return filters.length && !filters.find((obj) => {
          switch (true) {
            case (obj.type && obj.type !== type):
            case (getType(obj.url) === "[object String]" && !url.includes(obj.url)):
            case (getType(obj.url) === "[object RegExp]" && !obj.url.test(url)):
            case (obj.method && obj.method.toUpperCase() !== method.toUpperCase()):
            case ("async" in obj && obj.async !== async):
              return false;
          }
          return true;
        });
      }
      waitForRequestKeys() {
        if (!this.request.async) {
          win.__ajaxHooker.hookInsts.forEach(({ hookFns, filters }) => {
            if (this.shouldFilter(filters)) return;
            hookFns.forEach((fn) => {
              if (getType(fn) === "[object Function]")
                catchError(fn, this.request);
            });
            for (const key in this.request) {
              if (isThenable(this.request[key])) this._recoverRequestKey(key);
            }
          });
          return new SyncThenable();
        }
        const promises = [];
        const ignoreKeys = new Set(["type", "async", "response"]);
        win.__ajaxHooker.hookInsts.forEach(({ hookFns, filters }) => {
          if (this.shouldFilter(filters)) return;
          promises.push(
            Promise.all(hookFns.map((fn) => catchError(fn, this.request))).then(
              () => {
                const requestKeys = [];
                for (const key in this.request)
                  !ignoreKeys.has(key) && requestKeys.push(key);
                return Promise.all(
                  requestKeys.map(
                    (key) => Promise.resolve(this.request[key]).then(
                      (val2) => this.request[key] = val2,
                      () => this._recoverRequestKey(key)
                    )
                  )
                );
              }
            )
          );
        });
        return Promise.all(promises);
      }
      waitForResponseKeys(response) {
        const responseKeys = this.request.type === "xhr" ? xhrResponses : fetchResponses;
        if (!this.request.async) {
          if (getType(this.request.response) === "[object Function]") {
            catchError(this.request.response, response);
            responseKeys.forEach((key) => {
              if ("get" in getDescriptor(response, key) || isThenable(response[key])) {
                delete response[key];
              }
            });
          }
          return new SyncThenable();
        }
        return Promise.resolve(catchError(this.request.response, response)).then(
          () => Promise.all(
            responseKeys.map((key) => {
              const descriptor = getDescriptor(response, key);
              if (descriptor && "value" in descriptor) {
                return Promise.resolve(descriptor.value).then(
                  (val2) => response[key] = val2,
                  () => delete response[key]
                );
              } else {
                delete response[key];
              }
            })
          )
        );
      }
    }
    const proxyHandler = {
      get(target, prop) {
        const descriptor = getDescriptor(target, prop);
        if (descriptor && !descriptor.configurable && !descriptor.writable && !descriptor.get)
          return target[prop];
        const ah = target.__ajaxHooker;
        if (ah && ah.proxyProps) {
          if (prop in ah.proxyProps) {
            const pDescriptor = ah.proxyProps[prop];
            if ("get" in pDescriptor) return pDescriptor.get();
            if (typeof pDescriptor.value === "function")
              return pDescriptor.value.bind(ah);
            return pDescriptor.value;
          }
          if (typeof target[prop] === "function")
            return target[prop].bind(target);
        }
        return target[prop];
      },
      set(target, prop, value) {
        const descriptor = getDescriptor(target, prop);
        if (descriptor && !descriptor.configurable && !descriptor.writable && !descriptor.set)
          return true;
        const ah = target.__ajaxHooker;
        if (ah && ah.proxyProps && prop in ah.proxyProps) {
          const pDescriptor = ah.proxyProps[prop];
          pDescriptor.set ? pDescriptor.set(value) : pDescriptor.value = value;
        } else {
          target[prop] = value;
        }
        return true;
      }
    };
    class XhrHooker {
      constructor(xhr) {
        const ah = this;
        Object.assign(ah, {
          originalXhr: xhr,
          proxyXhr: new Proxy(xhr, proxyHandler),
          resThenable: new SyncThenable(),
          proxyProps: {},
          proxyEvents: {}
        });
        xhr.addEventListener("readystatechange", (e) => {
          if (ah.proxyXhr.readyState === 4 && ah.request && typeof ah.request.response === "function") {
            const response = {
              finalUrl: ah.proxyXhr.responseURL,
              status: ah.proxyXhr.status,
              responseHeaders: parseHeaders(ah.proxyXhr.getAllResponseHeaders())
            };
            const tempValues = {};
            for (const key of xhrResponses) {
              try {
                tempValues[key] = ah.originalXhr[key];
              } catch (err) {
              }
              defineProp(
                response,
                key,
                () => {
                  return response[key] = tempValues[key];
                },
                (val2) => {
                  delete response[key];
                  response[key] = val2;
                }
              );
            }
            ah.resThenable = new AHRequest(ah.request).waitForResponseKeys(response).then(() => {
              for (const key of xhrResponses) {
                ah.proxyProps[key] = {
                  get: () => {
                    if (!(key in response)) response[key] = tempValues[key];
                    return response[key];
                  }
                };
              }
            });
          }
          ah.dispatchEvent(e);
        });
        xhr.addEventListener("load", (e) => ah.dispatchEvent(e));
        xhr.addEventListener("loadend", (e) => ah.dispatchEvent(e));
        for (const evt of xhrAsyncEvents) {
          const onEvt = "on" + evt;
          ah.proxyProps[onEvt] = {
            get: () => ah.proxyEvents[onEvt] || null,
            set: (val2) => ah.addEvent(onEvt, val2)
          };
        }
        for (const method of [
          "setRequestHeader",
          "addEventListener",
          "removeEventListener",
          "open",
          "send"
        ]) {
          ah.proxyProps[method] = { value: ah[method] };
        }
      }
      toJSON() {
      }
addEvent(type, event) {
        if (type.startsWith("on")) {
          this.proxyEvents[type] = typeof event === "function" ? event : null;
        } else {
          if (typeof event === "object" && event !== null)
            event = event.handleEvent;
          if (typeof event !== "function") return;
          this.proxyEvents[type] = this.proxyEvents[type] || new Set();
          this.proxyEvents[type].add(event);
        }
      }
      removeEvent(type, event) {
        if (type.startsWith("on")) {
          this.proxyEvents[type] = null;
        } else {
          if (typeof event === "object" && event !== null)
            event = event.handleEvent;
          this.proxyEvents[type] && this.proxyEvents[type].delete(event);
        }
      }
      dispatchEvent(e) {
        e.stopImmediatePropagation = stopImmediatePropagation;
        defineProp(e, "target", () => this.proxyXhr);
        defineProp(e, "currentTarget", () => this.proxyXhr);
        defineProp(e, "srcElement", () => this.proxyXhr);
        this.proxyEvents[e.type] && this.proxyEvents[e.type].forEach((fn) => {
          this.resThenable.then(
            () => !e.ajaxHooker_isStopped && fn.call(this.proxyXhr, e)
          );
        });
        if (e.ajaxHooker_isStopped) return;
        const onEvent = this.proxyEvents["on" + e.type];
        onEvent && this.resThenable.then(onEvent.bind(this.proxyXhr, e));
      }
      setRequestHeader(header, value) {
        this.originalXhr.setRequestHeader(header, value);
        if (!this.request) return;
        const headers = this.request.headers;
        headers[header] = header in headers ? `${headers[header]}, ${value}` : value;
      }
      addEventListener(...args) {
        if (xhrAsyncEvents.includes(args[0])) {
          this.addEvent(args[0], args[1]);
        } else {
          this.originalXhr.addEventListener(...args);
        }
      }
      removeEventListener(...args) {
        if (xhrAsyncEvents.includes(args[0])) {
          this.removeEvent(args[0], args[1]);
        } else {
          this.originalXhr.removeEventListener(...args);
        }
      }
      open(method, url, async = true, ...args) {
        this.request = {
          type: "xhr",
          url: url.toString(),
          method: method.toUpperCase(),
          abort: false,
          headers: {},
          data: null,
          response: null,
          async: !!async
        };
        this.openArgs = args;
        this.resThenable = new SyncThenable();
        [
          "responseURL",
          "readyState",
          "status",
          "statusText",
          ...xhrResponses
        ].forEach((key) => {
          delete this.proxyProps[key];
        });
        return this.originalXhr.open(method, url, async, ...args);
      }
      send(data) {
        const ah = this;
        const xhr = ah.originalXhr;
        const request = ah.request;
        if (!request) return xhr.send(data);
        request.data = data;
        new AHRequest(request).waitForRequestKeys().then(() => {
          if (request.abort) {
            if (typeof request.response === "function") {
              Object.assign(ah.proxyProps, {
                responseURL: { value: request.url },
                readyState: { value: 4 },
                status: { value: 200 },
                statusText: { value: "OK" }
              });
              xhrAsyncEvents.forEach((evt) => xhr.dispatchEvent(new Event(evt)));
            }
          } else {
            xhr.open(request.method, request.url, request.async, ...ah.openArgs);
            for (const header in request.headers) {
              xhr.setRequestHeader(header, request.headers[header]);
            }
            for (const prop of xhrExtraProps) {
              if (prop in request) xhr[prop] = request[prop];
            }
            xhr.send(request.data);
          }
        });
      }
    }
    function fakeXHR() {
      const xhr = new winAh.realXHR();
      if ("__ajaxHooker" in xhr)
        console.warn("检测到不同版本的ajaxHooker，可能发生冲突！");
      xhr.__ajaxHooker = new XhrHooker(xhr);
      return xhr.__ajaxHooker.proxyXhr;
    }
    fakeXHR.prototype = win.XMLHttpRequest.prototype;
    Object.keys(win.XMLHttpRequest).forEach(
      (key) => fakeXHR[key] = win.XMLHttpRequest[key]
    );
    function fakeFetch(url, options = {}) {
      if (!url) return winAh.realFetch.call(win, url, options);
      return new Promise(async (resolve, reject) => {
        const init = {};
        if (getType(url) === "[object Request]") {
          init.method = url.method;
          init.headers = url.headers;
          if (url.body) init.body = await url.arrayBuffer();
          for (const prop of fetchExtraProps) init[prop] = url[prop];
          url = url.url;
        }
        url = url.toString();
        Object.assign(init, options);
        init.method = init.method || "GET";
        init.headers = init.headers || {};
        const request = {
          type: "fetch",
          url,
          method: init.method.toUpperCase(),
          abort: false,
          headers: parseHeaders(init.headers),
          data: init.body,
          response: null,
          async: true
        };
        const req = new AHRequest(request);
        await req.waitForRequestKeys();
        if (request.abort) {
          if (typeof request.response === "function") {
            const response = {
              finalUrl: request.url,
              status: 200,
              responseHeaders: {}
            };
            await req.waitForResponseKeys(response);
            const key = fetchResponses.find((k) => k in response);
            let val2 = response[key];
            if (key === "json" && typeof val2 === "object") {
              val2 = catchError(JSON.stringify.bind(JSON), val2);
            }
            const res = new Response(val2, {
              status: 200,
              statusText: "OK"
            });
            defineProp(res, "type", () => "basic");
            defineProp(res, "url", () => request.url);
            resolve(res);
          } else {
            reject(new DOMException("aborted", "AbortError"));
          }
          return;
        }
        init.method = request.method;
        init.headers = request.headers;
        init.body = request.data;
        for (const prop of fetchExtraProps) {
          if (prop in request) init[prop] = request[prop];
        }
        winAh.realFetch.call(win, request.url, init).then((res) => {
          if (typeof request.response === "function") {
            const response = {
              finalUrl: res.url,
              status: res.status,
              responseHeaders: parseHeaders(res.headers)
            };
            fetchResponses.forEach(
              (key) => res[key] = function() {
                if (key in response) return Promise.resolve(response[key]);
                return resProto[key].call(this).then((val2) => {
                  response[key] = val2;
                  return req.waitForResponseKeys(response).then(() => key in response ? response[key] : val2);
                });
              }
            );
          }
          resolve(res);
        }, reject);
      });
    }
    function fakeFetchClone() {
      const descriptors = Object.getOwnPropertyDescriptors(this);
      const res = winAh.realFetchClone.call(this);
      Object.defineProperties(res, descriptors);
      return res;
    }
    winAh = win.__ajaxHooker = winAh || {
      version: version2,
      fakeXHR,
      fakeFetch,
      fakeFetchClone,
      realXHR: win.XMLHttpRequest,
      realFetch: win.fetch,
      realFetchClone: resProto.clone,
      hookInsts: new Set()
    };
    if (winAh.version !== version2)
      console.warn("检测到不同版本的ajaxHooker，可能发生冲突！");
    win.XMLHttpRequest = winAh.fakeXHR;
    win.fetch = winAh.fakeFetch;
    resProto.clone = winAh.fakeFetchClone;
    winAh.hookInsts.add(hookInst);
    class AHFunction extends Function {
      call(thisArg, ...args) {
        if (thisArg && thisArg.__ajaxHooker && thisArg.__ajaxHooker.proxyXhr === thisArg) {
          thisArg = thisArg.__ajaxHooker.originalXhr;
        }
        return Reflect.apply(this, thisArg, args);
      }
      apply(thisArg, args) {
        if (thisArg && thisArg.__ajaxHooker && thisArg.__ajaxHooker.proxyXhr === thisArg) {
          thisArg = thisArg.__ajaxHooker.originalXhr;
        }
        return Reflect.apply(this, thisArg, args || []);
      }
    }
    function hookSecsdk(csrf) {
      Object.setPrototypeOf(
        csrf.nativeXMLHttpRequestSetRequestHeader,
        AHFunction.prototype
      );
      Object.setPrototypeOf(csrf.nativeXMLHttpRequestOpen, AHFunction.prototype);
      Object.setPrototypeOf(csrf.nativeXMLHttpRequestSend, AHFunction.prototype);
    }
    if (win.secsdk) {
      if (win.secsdk.csrf && win.secsdk.csrf.nativeXMLHttpRequestOpen)
        hookSecsdk(win.secsdk.csrf);
    } else {
      defineProp(win, "secsdk", emptyFn, (secsdk) => {
        delete win.secsdk;
        win.secsdk = secsdk;
        defineProp(secsdk, "csrf", emptyFn, (csrf) => {
          delete secsdk.csrf;
          secsdk.csrf = csrf;
          if (csrf.nativeXMLHttpRequestOpen) hookSecsdk(csrf);
        });
      });
    }
    return {
      hook: (fn) => hookInst.hookFns.push(fn),
      filter: (arr) => {
        if (Array.isArray(arr)) hookInst.filters = arr;
      },
      protect: () => {
        readonly2(win, "XMLHttpRequest", winAh.fakeXHR);
        readonly2(win, "fetch", winAh.fakeFetch);
        readonly2(resProto, "clone", winAh.fakeFetchClone);
      },
      unhook: () => {
        winAh.hookInsts.delete(hookInst);
        if (!winAh.hookInsts.size) {
          writable(win, "XMLHttpRequest", winAh.realXHR);
          writable(win, "fetch", winAh.realFetch);
          writable(resProto, "clone", winAh.realFetchClone);
          delete win.__ajaxHooker;
        }
      }
    };
  })();
  ajaxHooker.hook((request) => {
    if (request.url.includes("/api/itemExtend/purchasePrice/querySkuPriceList")) {
      request.response = (res) => {
        if (!res.responseText) return;
        const response = JSON.parse(res.responseText);
        observer.notify("skuList", response.data.data);
      };
    }
  });
  createApp(_sfc_main).mount(
    (() => {
      const appHost = document.createElement("div");
      document.documentElement.appendChild(appHost);
      return appHost;
    })()
  );

})();