// ==UserScript==
// @name         Google AI Studio æ¨¡å‹æ³¨å…¥å™¨ï¼ˆå¤šæ¨¡å‹ç‰ˆï¼‰- ä¿®å¤Tokenè®¡ç®—
// @namespace    http://tampermonkey.net/
// @version      1.6.8
// @description  æ³¨å…¥è‡ªå®šä¹‰æ¨¡å‹åˆ° Google AI Studioã€‚æ‹¦æˆª XHR/Fetch è¯·æ±‚å¤„ç†æ¨¡å‹åˆ—è¡¨ï¼Œå¹¶æ‹¦æˆª CountTokens è¯·æ±‚ä»¥ä½¿ç”¨æœ€æ–°çš„ Gemini 2.5 Pro 06-05 æ¨¡å‹è¿›è¡Œè®¡ç®—ã€‚
// @author       Generated by AI / HCPTangHY / Mozi / wisdgod / UserModified / Z_06 (Token Fix) / AI (Emoji Update)
// @match        https://aistudio.google.com/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=aistudio.google.com
// @grant        none
// @run-at       document-start
// @license      MIT
// @downloadURL https://update.greasyfork.org/scripts/539625/Google%20AI%20Studio%20%E6%A8%A1%E5%9E%8B%E6%B3%A8%E5%85%A5%E5%99%A8%EF%BC%88%E5%A4%9A%E6%A8%A1%E5%9E%8B%E7%89%88%EF%BC%89-%20%E4%BF%AE%E5%A4%8DToken%E8%AE%A1%E7%AE%97.user.js
// @updateURL https://update.greasyfork.org/scripts/539625/Google%20AI%20Studio%20%E6%A8%A1%E5%9E%8B%E6%B3%A8%E5%85%A5%E5%99%A8%EF%BC%88%E5%A4%9A%E6%A8%A1%E5%9E%8B%E7%89%88%EF%BC%89-%20%E4%BF%AE%E5%A4%8DToken%E8%AE%A1%E7%AE%97.meta.js
// ==/UserScript==

(function() {
    'use strict';

    // ==================== é…ç½®åŒºåŸŸ ====================
    const SCRIPT_VERSION = "v1.6.8";
    const LOG_PREFIX = `[AI Studio æ³¨å…¥å™¨ ${SCRIPT_VERSION}]`;
    const ANTI_HIJACK_PREFIX = ")]}'\n";

    // --- Token è®¡ç®—å¤‡ç”¨æ¨¡å‹é…ç½® ---
    // å·²æ›´æ–°ä¸ºæœ€æ–°çš„ Gemini 2.5 Pro 06-05 ç‰ˆæœ¬
    const TOKEN_COUNT_FALLBACK_MODEL = 'models/gemini-2.5-pro-preview-06-05';

    // æ¨¡å‹é…ç½®åˆ—è¡¨
    const MODELS_TO_INJECT = [
        // --- ä¹±ç æ¨¡å‹ç»„ (æŒ‰æ€§èƒ½æ’åº) ---
        {
            name: 'models/jfdksal98a',
            displayName: `ğŸ’ jfdksal98a (è„šæœ¬ ${SCRIPT_VERSION})`,
            description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹`
        },
        {
            name: 'models/68zkqbz8vs',
            displayName: `ğŸ”® 68zkqbz8vs (è„šæœ¬ ${SCRIPT_VERSION})`,
            description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹`
        },
        {
            name: 'models/a24bo28u1a',
            displayName: `âš¡ a24bo28u1a (è„šæœ¬ ${SCRIPT_VERSION})`,
            description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹`
        },
        {
            name: 'models/2vmc1bo4ri',
            displayName: `ğŸš€ 2vmc1bo4ri (è„šæœ¬ ${SCRIPT_VERSION})`,
            description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹`
        },
        {
            name: 'models/42fc3y4xfsz',
            displayName: `ğŸ¤– 42fc3y4xfsz (è„šæœ¬ ${SCRIPT_VERSION})`,
            description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹`
        },
        {
            name: 'models/ixqzem8yj4j',
            displayName: `âš™ï¸ ixqzem8yj4j (è„šæœ¬ ${SCRIPT_VERSION})`,
            description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹`
        },
        {
            name: 'models/oiy9yghoam',
            displayName: `ğŸ”§ oiy9yghoam (è„šæœ¬ ${SCRIPT_VERSION})`,
            description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹`
        },

        // --- å…¶ä»–å·²çŸ¥æ¨¡å‹ ---
        {
            name: 'models/blacktooth-ab-test',
            displayName: `ğŸ´â€â˜ ï¸ Blacktooth (AB-Test) (è„šæœ¬ ${SCRIPT_VERSION})`,
            description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹`
        },
        {
            name: 'models/gemini-2.5-pro-preview-03-25',
            displayName: `âœ¨ Gemini 2.5 Pro 03-25 (è„šæœ¬ ${SCRIPT_VERSION})`,
            description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹`
        },
        {
            name: 'models/goldmane-ab-test',
            displayName: `ğŸ¦ Goldmane (è„šæœ¬ ${SCRIPT_VERSION})`,
            description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹`
        },
        {
            name: 'models/claybrook-ab-test',
            displayName: `ğŸ’§ Claybrook (è„šæœ¬ ${SCRIPT_VERSION})`,
            description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹`
        },
        {
            name: 'models/frostwind-ab-test',
            displayName: `â„ï¸ Frostwind (è„šæœ¬ ${SCRIPT_VERSION})`,
            description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹`
        },
        {
            name: 'models/calmriver-ab-test',
            displayName: `ğŸŒŠ Calmriver (è„šæœ¬ ${SCRIPT_VERSION})`,
            description: `ç”±è„šæœ¬ ${SCRIPT_VERSION} æ³¨å…¥çš„æ¨¡å‹`
        }
    ];

    // JSON ç»“æ„ä¸­çš„å­—æ®µç´¢å¼•
    const MODEL_FIELDS = {
        NAME: 0,
        DISPLAY_NAME: 3,
        DESCRIPTION: 4,
        METHODS: 7
    };

    // ==================== å·¥å…·å‡½æ•° ====================

    /**
     * æ£€æŸ¥ URL æ˜¯å¦ä¸º ListModels API ç«¯ç‚¹
     * @param {string} url - è¦æ£€æŸ¥çš„ URL
     * @returns {boolean}
     */
    function isListModelsURL(url) {
        return url && typeof url === 'string' &&
               url.includes('alkalimakersuite') &&
               url.includes('/ListModels');
    }

    /**
     * æ£€æŸ¥ URL æ˜¯å¦ä¸º CountTokens API ç«¯ç‚¹
     * @param {string} url - è¦æ£€æŸ¥çš„ URL
     * @returns {boolean}
     */
    function isCountTokensURL(url) {
        return url && typeof url === 'string' &&
               url.includes('alkalimakersuite') &&
               url.includes('/CountTokens');
    }

    /**
     * é€’å½’æŸ¥æ‰¾æ¨¡å‹åˆ—è¡¨æ•°ç»„
     * @param {any} obj - è¦æœç´¢çš„å¯¹è±¡
     * @returns {Array|null} æ‰¾åˆ°çš„æ¨¡å‹æ•°ç»„æˆ– null
     */
    function findModelListArray(obj) {
        if (!obj) return null;

        // æ£€æŸ¥æ˜¯å¦ä¸ºç›®æ ‡æ¨¡å‹æ•°ç»„
        if (Array.isArray(obj) && obj.length > 0 && obj.every(
            item => Array.isArray(item) &&
                    typeof item[MODEL_FIELDS.NAME] === 'string' &&
                    String(item[MODEL_FIELDS.NAME]).startsWith('models/')
        )) {
            return obj;
        }

        // é€’å½’æœç´¢å­å¯¹è±¡
        if (typeof obj === 'object') {
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key) &&
                    typeof obj[key] === 'object' &&
                    obj[key] !== null) {
                    const result = findModelListArray(obj[key]);
                    if (result) return result;
                }
            }
        }
        return null;
    }

    /**
     * æŸ¥æ‰¾åˆé€‚çš„æ¨¡æ¿æ¨¡å‹
     * @param {Array} modelsArray - æ¨¡å‹æ•°ç»„
     * @returns {Array|null} æ¨¡æ¿æ¨¡å‹æˆ– null
     */
    function findTemplateModel(modelsArray) {
        // ä¼˜å…ˆæŸ¥æ‰¾åŒ…å«ç‰¹å®šå…³é”®è¯çš„æ¨¡å‹
        const templateModel =
            modelsArray.find(m => Array.isArray(m) &&
                                 m[MODEL_FIELDS.NAME] &&
                                 String(m[MODEL_FIELDS.NAME]).includes('pro') &&
                                 Array.isArray(m[MODEL_FIELDS.METHODS])) ||
            modelsArray.find(m => Array.isArray(m) &&
                                 m[MODEL_FIELDS.NAME] &&
                                 String(m[MODEL_FIELDS.NAME]).includes('flash') &&
                                 Array.isArray(m[MODEL_FIELDS.METHODS])) ||
            modelsArray.find(m => Array.isArray(m) &&
                                 m[MODEL_FIELDS.NAME] &&
                                 Array.isArray(m[MODEL_FIELDS.METHODS]));

        return templateModel;
    }

    /**
     * æ›´æ–°å·²å­˜åœ¨æ¨¡å‹çš„æ˜¾ç¤ºåç§°
     * @param {Array} existingModel - ç°æœ‰æ¨¡å‹
     * @param {Object} modelToInject - è¦æ³¨å…¥çš„æ¨¡å‹é…ç½®
     * @returns {boolean} æ˜¯å¦è¿›è¡Œäº†æ›´æ–°
     */
    function updateExistingModel(existingModel, modelToInject) {
        if (!existingModel || existingModel[MODEL_FIELDS.DISPLAY_NAME] === modelToInject.displayName) {
            return false;
        }

        // æå–åŸºç¡€åç§°ï¼ˆå»é™¤ç‰ˆæœ¬å·å’Œè¡¨æƒ…ï¼‰
        const cleanName = (name) => String(name)
            .replace(/ \(è„šæœ¬ v\d+\.\d+(\.\d+)?(-beta\d*)?\)/, '')
            // åŒ…å«æ‰€æœ‰å½“å‰ä½¿ç”¨çš„è¡¨æƒ…ï¼ŒåŒ…æ‹¬æ–°å¢çš„ ğŸ”®ğŸ’âš¡ğŸš€ğŸ¤–âš™ï¸ğŸ”§
            .replace(/^[âœ¨ğŸ¦ğŸ’§â„ï¸ğŸŒŠğŸ‰ğŸ´â€â˜ ï¸ğŸ”®ğŸ’âš¡ğŸš€ğŸ¤–âš™ï¸ğŸ”§]\s*/, '')
            .trim();

        const baseExistingName = cleanName(existingModel[MODEL_FIELDS.DISPLAY_NAME]);
        const baseInjectName = cleanName(modelToInject.displayName);

        if (baseExistingName === baseInjectName) {
            // ä»…æ›´æ–°ç‰ˆæœ¬å·å’Œè¡¨æƒ…
            existingModel[MODEL_FIELDS.DISPLAY_NAME] = modelToInject.displayName;
            console.log(LOG_PREFIX, `å·²æ›´æ–°è¡¨æƒ…/ç‰ˆæœ¬å·: ${modelToInject.displayName}`);
            return true;
        }

        // å¦‚æœæ˜¯å®˜æ–¹æ¨¡å‹å’Œæ³¨å…¥æ¨¡å‹åç§°ä¸ä¸€è‡´ä½†æ¨¡å‹IDç›¸åŒçš„æƒ…å†µï¼Œå¯ä»¥è€ƒè™‘ä¿ç•™å®˜æ–¹åç§°æˆ–æ ‡è®°
        // ä½†å¯¹äºä¹±ç æ¨¡å‹ï¼Œé€šå¸¸å®ƒä»¬ä¸ä¼šå‡ºç°åœ¨å®˜æ–¹åˆ—è¡¨ä¸­ï¼Œæ‰€ä»¥è¿™éƒ¨åˆ†é€»è¾‘å¯ä»¥ç®€åŒ–æˆ–å¿½ç•¥
        return false;
    }

    /**
     * åˆ›å»ºæ–°æ¨¡å‹
     * @param {Array} templateModel - æ¨¡æ¿æ¨¡å‹
     * @param {Object} modelToInject - è¦æ³¨å…¥çš„æ¨¡å‹é…ç½®
     * @param {string} templateName - æ¨¡æ¿åç§°
     * @returns {Array} æ–°æ¨¡å‹æ•°ç»„
     */
    function createNewModel(templateModel, modelToInject, templateName) {
        const newModel = structuredClone(templateModel);

        newModel[MODEL_FIELDS.NAME] = modelToInject.name;
        newModel[MODEL_FIELDS.DISPLAY_NAME] = modelToInject.displayName;
        newModel[MODEL_FIELDS.DESCRIPTION] = `${modelToInject.description} (åŸºäº ${templateName} ç»“æ„)`;

        // ç¡®ä¿ methods å­˜åœ¨ï¼Œè¿™è®© UI è®¤ä¸ºå®ƒå¯ä»¥è°ƒç”¨ countTokens
        if (!Array.isArray(newModel[MODEL_FIELDS.METHODS])) {
            newModel[MODEL_FIELDS.METHODS] = [
                "generateContent",
                "countTokens", // å³ä½¿åç«¯ä¸æ”¯æŒï¼Œæˆ‘ä»¬ä¹Ÿåœ¨è¿™é‡Œå£°æ˜æ”¯æŒï¼Œä»¥ä¾¿åç»­æ‹¦æˆª
                "createCachedContent",
                "batchGenerateContent"
            ];
        } else if (!newModel[MODEL_FIELDS.METHODS].includes("countTokens")) {
             newModel[MODEL_FIELDS.METHODS].push("countTokens");
        }

        return newModel;
    }

    // ==================== å“åº”å¤„ç†å‡½æ•° (ç”¨äº ListModels) ====================

    /**
     * å¤„ç†å¹¶ä¿®æ”¹ ListModels è¿”å›çš„ JSON æ•°æ®
     * @param {Object} jsonData - åŸå§‹ JSON æ•°æ®
     * @param {string} url - è¯·æ±‚ URL
     * @returns {Object} åŒ…å«å¤„ç†åæ•°æ®å’Œä¿®æ”¹æ ‡å¿—çš„å¯¹è±¡
     */
    function processListModelsResponse(jsonData, url) {
        let modificationMade = false;
        const modelsArray = findModelListArray(jsonData);

        if (!modelsArray || !Array.isArray(modelsArray)) {
            console.warn(LOG_PREFIX, 'åœ¨ JSON ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„æ¨¡å‹åˆ—è¡¨ç»“æ„:', url);
            return { data: jsonData, modified: false };
        }

        // æŸ¥æ‰¾æ¨¡æ¿æ¨¡å‹
        const templateModel = findTemplateModel(modelsArray);
        const templateName = templateModel?.[MODEL_FIELDS.NAME] || 'unknown';

        if (!templateModel) {
            console.warn(LOG_PREFIX, 'æœªæ‰¾åˆ°åˆé€‚çš„æ¨¡æ¿æ¨¡å‹ï¼Œæ— æ³•æ³¨å…¥æ–°æ¨¡å‹');
        }

        // åå‘éå†ä»¥ä¿æŒæ˜¾ç¤ºé¡ºåº (é…ç½®ä¸­é å‰çš„æ¨¡å‹æ˜¾ç¤ºåœ¨æœ€ä¸Šé¢)
        [...MODELS_TO_INJECT].reverse().forEach(modelToInject => {
            const existingModel = modelsArray.find(
                model => Array.isArray(model) && model[MODEL_FIELDS.NAME] === modelToInject.name
            );

            if (!existingModel) {
                // æ³¨å…¥æ–°æ¨¡å‹
                if (!templateModel) {
                    console.warn(LOG_PREFIX, `æ— æ³•æ³¨å…¥ ${modelToInject.name}ï¼šç¼ºå°‘æ¨¡æ¿`);
                    return;
                }

                const newModel = createNewModel(templateModel, modelToInject, templateName);
                modelsArray.unshift(newModel); // unshift å°†æ¨¡å‹æ·»åŠ åˆ°æ•°ç»„å¼€å¤´
                modificationMade = true;
                console.log(LOG_PREFIX, `æˆåŠŸæ³¨å…¥: ${modelToInject.displayName}`);
            } else {
                // æ›´æ–°ç°æœ‰æ¨¡å‹
                if (updateExistingModel(existingModel, modelToInject)) {
                    modificationMade = true;
                }
            }
        });

        return { data: jsonData, modified: modificationMade };
    }

    /**
     * ä¿®æ”¹ ListModels å“åº”ä½“
     * @param {string} originalText - åŸå§‹å“åº”æ–‡æœ¬
     * @param {string} url - è¯·æ±‚ URL
     * @returns {string} ä¿®æ”¹åçš„å“åº”æ–‡æœ¬
     */
    function modifyListModelsResponseBody(originalText, url) {
        if (!originalText || typeof originalText !== 'string') {
            return originalText;
        }

        try {
            let textBody = originalText;
            let hasPrefix = false;

            // å¤„ç†ååŠ«æŒå‰ç¼€
            if (textBody.startsWith(ANTI_HIJACK_PREFIX)) {
                textBody = textBody.substring(ANTI_HIJACK_PREFIX.length);
                hasPrefix = true;
            }

            if (!textBody.trim()) return originalText;

            const jsonData = JSON.parse(textBody);
            const result = processListModelsResponse(jsonData, url);

            if (result.modified) {
                let newBody = JSON.stringify(result.data);
                if (hasPrefix) {
                    newBody = ANTI_HIJACK_PREFIX + newBody;
                }
                return newBody;
            }
        } catch (error) {
            console.error(LOG_PREFIX, 'å¤„ç† ListModels å“åº”ä½“æ—¶å‡ºé”™:', url, error);
        }

        return originalText;
    }

    // ==================== è¯·æ±‚å¤„ç†å‡½æ•° (ç”¨äº CountTokens) ====================

    /**
     * ä¿®æ”¹ CountTokens è¯·æ±‚ä½“ï¼Œæ›¿æ¢æ¨¡å‹åç§°
     * @param {string} originalBody - åŸå§‹è¯·æ±‚ä½“ (JSON å­—ç¬¦ä¸²)
     * @returns {Object} åŒ…å«ä¿®æ”¹åè¯·æ±‚ä½“å’Œä¿®æ”¹æ ‡å¿—çš„å¯¹è±¡
     */
    function modifyCountTokensRequestBody(originalBody) {
        try {
            const payload = JSON.parse(originalBody);
            // AI Studio çš„è¯·æ±‚è´Ÿè½½ç»“æ„é€šå¸¸æ˜¯ä¸€ä¸ªæ•°ç»„: [ "models/the-model-name", { ...content... } ]
            if (Array.isArray(payload) && typeof payload[0] === 'string' && payload[0].startsWith('models/')) {
                const requestedModel = payload[0];

                // æ£€æŸ¥è¯·æ±‚çš„æ¨¡å‹æ˜¯å¦æ˜¯æˆ‘ä»¬æ³¨å…¥çš„éšè—æ¨¡å‹ä¹‹ä¸€
                const isHiddenModel = MODELS_TO_INJECT.some(m => m.name === requestedModel);

                if (isHiddenModel && requestedModel !== TOKEN_COUNT_FALLBACK_MODEL) {
                    console.log(LOG_PREFIX, `[Token Count æ‹¦æˆª] å°†è¯·æ±‚æ¨¡å‹ä» ${requestedModel} é‡å®šå‘åˆ° ${TOKEN_COUNT_FALLBACK_MODEL}`);
                    payload[0] = TOKEN_COUNT_FALLBACK_MODEL; // æ›¿æ¢ä¸ºå¤‡ç”¨æ¨¡å‹
                    return { body: JSON.stringify(payload), modified: true };
                }
            }
        } catch (e) {
            console.error(LOG_PREFIX, "è§£ææˆ–ä¿®æ”¹ CountTokens è¯·æ±‚ä½“æ—¶å‡ºé”™:", e);
        }
        return { body: originalBody, modified: false };
    }

    // ==================== è¯·æ±‚/å“åº”æ‹¦æˆª ====================

    // æ‹¦æˆª Fetch API
    const originalFetch = window.fetch;
    window.fetch = async function(...args) {
        const resource = args[0];
        const url = (resource instanceof Request) ? resource.url : String(resource);

        // --- æ‹¦æˆª 1: å‡ºç«™è¯·æ±‚ (CountTokens) ---
        // AI Studio ä¸»è¦ä½¿ç”¨ XHRï¼ŒFetch æ‹¦æˆªä½œä¸ºå¤‡ç”¨

        // æ‰§è¡ŒåŸå§‹ Fetch
        const response = await originalFetch.apply(this, args);

        // --- æ‹¦æˆª 2: å…¥ç«™å“åº” (ListModels) ---
        if (isListModelsURL(url) && response.ok) {
            console.log(LOG_PREFIX, '[Fetch] æ‹¦æˆªåˆ° ListModels å“åº”:', url);
            try {
                const cloneResponse = response.clone();
                const originalText = await cloneResponse.text();
                const newBody = modifyListModelsResponseBody(originalText, url);

                if (newBody !== originalText) {
                    return new Response(newBody, {
                        status: response.status,
                        statusText: response.statusText,
                        headers: response.headers
                    });
                }
            } catch (e) {
                console.error(LOG_PREFIX, '[Fetch] å¤„ç† ListModels å“åº”é”™è¯¯:', e);
            }
        }
        return response;
    };

    // æ‹¦æˆª XMLHttpRequest
    const xhrProto = XMLHttpRequest.prototype;
    const originalOpen = xhrProto.open;
    const originalSend = xhrProto.send; // ä¿å­˜åŸå§‹ send æ–¹æ³•
    const originalResponseTextDescriptor = Object.getOwnPropertyDescriptor(xhrProto, 'responseText');
    const originalResponseDescriptor = Object.getOwnPropertyDescriptor(xhrProto, 'response');
    let listModelsInterceptionCount = 0;

    // é‡å†™ open æ–¹æ³• (è®°å½•è¯·æ±‚ç±»å‹)
    xhrProto.open = function(method, url) {
        this._interceptorUrl = url;
        this._isListModelsXHR = isListModelsURL(url); // æ ‡è®°æ˜¯å¦ä¸º ListModels è¯·æ±‚
        this._isCountTokensXHR = isCountTokensURL(url); // æ ‡è®°æ˜¯å¦ä¸º CountTokens è¯·æ±‚

        if (this._isListModelsXHR) {
            listModelsInterceptionCount++;
            console.log(LOG_PREFIX, `[XHR Open] æ£€æµ‹åˆ° ListModels è¯·æ±‚ (${listModelsInterceptionCount})ï¼š`, url);
        }

        return originalOpen.apply(this, arguments);
    };

    // é‡å†™ send æ–¹æ³• (ä¿®æ”¹ CountTokens è¯·æ±‚)
    xhrProto.send = function(data) {
        // æ£€æŸ¥æ˜¯å¦ä¸º CountTokens è¯·æ±‚ï¼Œå¹¶ä¸”æœ‰æ•°æ®ä½“
        if (this._isCountTokensXHR && data && typeof data === 'string') {
            const { body: modifiedData, modified } = modifyCountTokensRequestBody(data);
            if (modified) {
                 // Logå·²ç»åœ¨modifyCountTokensRequestBodyä¸­æ‰“å°
            }
            return originalSend.call(this, modifiedData);
        }
        // å¯¹äºå…¶ä»–è¯·æ±‚ï¼Œæ­£å¸¸å‘é€
        return originalSend.call(this, data);
    };

    /**
     * å¤„ç† XHR å“åº” (ä¿®æ”¹ ListModels å“åº”)
     * @param {XMLHttpRequest} xhr - XHR å¯¹è±¡
     * @param {any} originalValue - åŸå§‹å“åº”å€¼
     * @param {string} type - å“åº”ç±»å‹
     * @returns {any} å¤„ç†åçš„å“åº”å€¼
     */
    const handleXHRResponse = (xhr, originalValue, type = 'text') => {
        // åªå¤„ç† ListModels çš„å“åº”
        if (!xhr._isListModelsXHR || xhr.readyState !== 4 || xhr.status !== 200) {
            return originalValue;
        }

        const cacheKey = '_modifiedResponseCache_' + type;

        if (xhr[cacheKey] === undefined) {
            const originalText = (type === 'text' || typeof originalValue !== 'object' || originalValue === null)
                ? String(originalValue || '')
                : JSON.stringify(originalValue);

            // ä½¿ç”¨ä¿®æ”¹ ListModels å“åº”çš„å‡½æ•°
            xhr[cacheKey] = modifyListModelsResponseBody(originalText, xhr._interceptorUrl);
        }

        const cachedResponse = xhr[cacheKey];

        try {
            if (type === 'json' && typeof cachedResponse === 'string') {
                const textToParse = cachedResponse.replace(ANTI_HIJACK_PREFIX, '');
                return textToParse ? JSON.parse(textToParse) : null;
            }
        } catch (e) {
            console.error(LOG_PREFIX, '[XHR] è§£æç¼“å­˜çš„ JSON æ—¶å‡ºé”™:', e);
            return originalValue;
        }

        return cachedResponse;
    };

    // é‡å†™ responseText å±æ€§
    if (originalResponseTextDescriptor?.get) {
        Object.defineProperty(xhrProto, 'responseText', {
            get: function() {
                const originalText = originalResponseTextDescriptor.get.call(this);

                if (this.responseType && this.responseType !== 'text' && this.responseType !== "") {
                    return originalText;
                }

                return handleXHRResponse(this, originalText, 'text');
            },
            configurable: true
        });
    }

    // é‡å†™ response å±æ€§
    if (originalResponseDescriptor?.get) {
        Object.defineProperty(xhrProto, 'response', {
            get: function() {
                const originalResponse = originalResponseDescriptor.get.call(this);

                if (this.responseType === 'json') {
                    return handleXHRResponse(this, originalResponse, 'json');
                }

                if (!this.responseType || this.responseType === 'text' || this.responseType === "") {
                    return handleXHRResponse(this, originalResponse, 'text');
                }

                return originalResponse;
            },
            configurable: true
        });
    }

    console.log(LOG_PREFIX, 'è„šæœ¬å·²æ¿€æ´»ã€‚ListModels å“åº”æ‹¦æˆªå’Œ CountTokens è¯·æ±‚æ‹¦æˆªå·²å¯ç”¨ã€‚');
})();