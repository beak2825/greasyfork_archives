// ==UserScript==
// @name         Symfony 翻译文档 configuration.html
// @namespace    fireloong
// @version      0.1.3
// @description  翻译文档 configuration.html
// @author       Itsky71
// @match        https://symfony.com/doc/5.x/configuration.html
// @match        https://symfony.com/doc/6.4/configuration.html
// @match        https://symfony.com/doc/7.1/configuration.html
// @match        https://symfony.com/doc/7.2/configuration.html
// @match        https://symfony.com/doc/current/configuration.html
// @icon         https://www.google.com/s2/favicons?sz=64&domain=symfony.com
// @require      https://unpkg.com/jquery@3.7.1/dist/jquery.min.js
// @require      https://update.greasyfork.org/scripts/503008/fanyi.js
// @grant        none
// @license      MIT
// @downloadURL https://update.greasyfork.org/scripts/496285/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20configurationhtml.user.js
// @updateURL https://update.greasyfork.org/scripts/496285/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20configurationhtml.meta.js
// ==/UserScript==

(function($) {
    'use strict';

    const translates = {
        '\n        \n                    Configuring Symfony\n        \n            ': '配置 Symfony',
        'Configuration Files': '配置文件',
        'Symfony applications are configured with the files stored in the config/\ndirectory, which has this default structure:': 'Symfony 应用程序通过存储在 <code translate="no" class="notranslate">config/</code> 目录中的文件进行配置，该目录具有以下默认结构：',
        'The routes.yaml file defines the routing configuration;': '<code translate="no" class="notranslate">routes.yaml</code> 文件定义了<a href="routing.html" class="reference internal">路由配置</a>；',
        'The services.yaml file configures the services of the service container;': '<code translate="no" class="notranslate">services.yaml</code> 文件用于配置<a href="service_container.html" class="reference internal">服务容器</a>的服务；',
        'The bundles.php file enables/disables packages in your application;': '<code translate="no" class="notranslate">bundles.php</code> 文件用于启用/禁用您应用程序中的包；',
        'The config/packages/ directory stores the configuration of every package\ninstalled in your application.': '<code translate="no" class="notranslate">config/packages/</code> 目录用于存储您应用程序中安装的每个包的配置。',
        'Packages (also called "bundles" in Symfony and "plugins/modules" in other\nprojects) add ready-to-use features to your projects.': '包（在 Symfony 中也称为“bundle”，在其它项目中称为“插件/模块”）为您的项目添加现成的功能。',
        'When using Symfony Flex, which is enabled by default in\nSymfony applications, packages update the bundles.php file and create new\nfiles in config/packages/ automatically during their installation. For\nexample, this is the default file created by the "API Platform" bundle:': '在使用 <a href="setup.html#symfony-flex" class="reference internal">Symfony Flex</a> 时（Symfony 应用程序默认启用），包在安装过程中会自动更新 <code translate="no" class="notranslate">bundles.php</code> 文件并在 <code translate="no" class="notranslate">config/packages/</code> 目录下创建新文件。例如，这是“API Platform”包创建的默认文件：',
        "Splitting the configuration into lots of small files might appear intimidating for some\nSymfony newcomers. However, you'll get used to them quickly and you rarely need\nto change these files after package installation.": '将配置拆分成许多小文件可能会让一些 Symfony 的新手感到有些困惑。然而，你很快就会习惯这种方式，而且在包安装后很少需要修改这些文件。',
        'To learn about all the available configuration options, check out the\nSymfony Configuration Reference or run the\nconfig:dump-reference command.': '要了解所有可用的配置选项，请查阅 <a href="reference/index.html" class="reference internal">Symfony 配置参考</a>或运行 <code translate="no" class="notranslate">config:dump-reference</code> 命令。',

        'Configuration Formats': '配置格式',
        "Unlike other frameworks, Symfony doesn't impose a specific format on you to\nconfigure your applications, but lets you choose between YAML, XML and PHP.\nThroughout the Symfony documentation, all configuration examples will be\nshown in these three formats.": '与其它框架不同，Symfony 不要求您使用特定的格式来配置您的应用程序，而是允许您选择 YAML、XML 和 PHP 这三种格式。在 Symfony 的文档中，所有配置示例都将以这三种格式展示。',
        "There isn't any practical difference between formats. In fact, Symfony\ntransforms all of them into PHP and caches them before running the application,\nso there's not even any performance difference.": '这些格式之间没有任何实际差异。事实上，Symfony 在运行应用程序之前会将它们全部转换为 PHP 并缓存起来，因此甚至没有任何性能差异。',
        "YAML is used by default when installing packages because it's concise and very\nreadable. These are the main advantages and disadvantages of each format:": '在安装包时默认使用 YAML 格式，因为它简洁且易于阅读。以下是每种格式的主要优缺点：',
        'YAML: simple, clean and readable, but not all IDEs support autocompletion\nand validation for it. Learn the YAML syntax;': '<strong>YAML</strong>：简单、清晰且可读性强，但并非所有集成开发环境（IDE）都支持其自动补全和验证功能。<a href="reference/formats/yaml.html" class="reference internal">学习 YAML 语法</a>；',
        'XML: autocompleted/validated by most IDEs and is parsed natively by PHP,\nbut sometimes it generates configuration considered too verbose. Learn the XML syntax;': '<strong>XML</strong>：大多数集成开发环境（IDE）都支持其自动补全和验证功能，并且 PHP 原生支持其解析，但有时它会生成被认为过于冗长的配置。<a href="https://en.wikipedia.org/wiki/XML" class="reference external" rel="external noopener noreferrer" target="_blank">学习 XML 语法</a>；',
        'PHP: very powerful and it allows you to create dynamic configuration with\narrays or a ConfigBuilder.': '<strong>PHP</strong>：功能非常强大，允许您使用数组或 <a href="configuration.html#config-config-builder" class="reference internal">ConfigBuilder</a> 创建动态配置。',
        'By default Symfony loads the configuration files defined in YAML and PHP\nformats. If you define configuration in XML format, update the\nconfigureContainer()\nand/or\nconfigureRoutes()\nmethods in the src/Kernel.php file to add support for the .xml file\nextension.': '默认情况下，Symfony 加载以 YAML 和 PHP 格式定义的配置文件。如果您在 XML 格式中定义配置，请更新 <code translate="no" class="notranslate">src/Kernel.php</code> 文件中的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/FrameworkBundle/Kernel/MicroKernelTrait.php#:~:text=function%20configureContainer" class="reference external" title="Symfony\Bundle\FrameworkBundle\Kernel\MicroKernelTrait::configureContainer()" rel="external noopener noreferrer" target="_blank">configureContainer()</a> 和/或 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/FrameworkBundle/Kernel/MicroKernelTrait.php#:~:text=function%20configureRoutes" class="reference external" title="Symfony\Bundle\FrameworkBundle\Kernel\MicroKernelTrait::configureRoutes()" rel="external noopener noreferrer" target="_blank">configureRoutes()</a> 方法，以添加对 <code translate="no" class="notranslate">.xml</code> 文件扩展名的支持。',
        'The automatic loading of PHP configuration files was introduced in Symfony 6.1.': 'PHP 配置文件的自动加载功能是在 Symfony 6.1 中引入的。',

        'Importing Configuration Files': '导入配置文件',
        'Symfony loads configuration files using the Config component, which provides advanced features such as importing other\nconfiguration files, even if they use a different format:': 'Symfony 使用 <a href="components/config.html" class="reference internal">Config 组件</a>加载配置文件，该组件提供了高级功能，例如导入其它配置文件，即使它们使用不同的格式：',

        'Configuration Parameters': '配置参数',
        'Sometimes the same configuration value is used in several configuration files.\nInstead of repeating it, you can define it as a "parameter", which is like a\nreusable configuration value. By convention, parameters are defined under the\nparameters key in the config/services.yaml file:': '有时，同一个配置值会用在多个配置文件中。与其重复它，你可以将其定义为一个“参数”，它就像一个可重复使用的配置值。按照惯例，参数在 <code translate="no" class="notranslate">config/services.yaml</code> 文件的 <code translate="no" class="notranslate">parameters</code> 键下定义：',
        "By default and when using XML configuration, the values between <parameter>\ntags are not trimmed. This means that the value of the following parameter will be\n'\\n    something@example.com\\n':": '默认情况下，以及在使用 XML 配置时，<code translate="no" class="notranslate">&lt;parameter&gt;</code> 标签之间的值不会被修剪。这意味着以下参数的值将是 <code translate="no" class="notranslate">\'\\n    something@example.com\\n\'</code>：',
        'If you want to trim the value of your parameter, use the trim attribute.\nWhen using it, the value of the following parameter will be something@example.com:': '如果你想修剪你的参数值，请使用 <code translate="no" class="notranslate">trim</code> 属性。使用它时，以下参数的值将会是 <code translate="no" class="notranslate">something@example.com</code>：',
        'Passing an enum case as a service parameter was introduced in Symfony 6.2.': '在 Symfony 6.2 中引入了将枚举情况作为服务参数传递的功能。',
        'The trim attribute was introduced in Symfony 6.3.': '<code translate="no" class="notranslate">trim</code> 属性是在 Symfony 6.3 中引入的。',
        'Once defined, you can reference this parameter value from any other\nconfiguration file using a special syntax: wrap the parameter name in two %\n(e.g. %app.admin_email%):':'一旦定义后，您可以使用特殊语法从任何其它配置文件中引用此参数值：将参数名包裹在两个百分号（<code translate="no" class="notranslate">%</code>）中（例如：<code translate="no" class="notranslate">%app.admin_email%</code>）：',
        "If some parameter value includes the % character, you need to escape it\nby adding another %, so Symfony doesn't consider it a reference to a\nparameter name:": '如果某个参数值包含 <code translate="no" class="notranslate">%</code> 字符，您需要通过添加另一个 <code translate="no" class="notranslate">%</code> 来转义它，以便 Symfony 不会将其视为对参数名称的引用：',
        'Due to the way in which parameters are resolved, you cannot use them\nto build paths in imports dynamically. This means that something like\nthe following does not work:': '由于参数解析的方式，您无法使用它们来动态构建导入中的路径。这意味着类似<strong>以下的内容不起作用</strong>：',
        'Configuration parameters are very common in Symfony applications. Some packages\neven define their own parameters (e.g. when installing the translation package,\na new locale parameter is added to the config/services.yaml file).': '在 Symfony 应用程序中，配置参数非常常见。一些包甚至定义了自己的参数（例如，在安装翻译包时，会在 <code translate="no" class="notranslate">config/services.yaml</code> 文件中添加一个新的 <code translate="no" class="notranslate">locale</code> 参数）。',
        "By convention, parameters whose names start with a dot . (for example,\n.mailer.transport), are available only during the container compilation.\nThey are useful when working with Compiler Passes\nto declare some temporary parameters that won't be available later in the application.": '按照惯例，名称以点号 <code translate="no" class="notranslate">.</code> 开头的参数（例如，<code translate="no" class="notranslate">.mailer.transport</code>）仅在容器编译期间可用。它们在与<a href="service_container/compiler_passes.html" class="reference internal">编译器</a>传递一起使用时很有用，可以声明一些在应用程序后续阶段中不可用的临时参数。',
        'Compile-time parameters were introduced in Symfony 6.3.': '编译时参数是在 Symfony 6.3 中引入的。',
        'Later in this article you can read how to\nget configuration parameters in controllers and services.': '在本文的后面部分，您可以阅读<a href="configuration.html#configuration-accessing-parameters" class="reference internal">如何在控制器和服务中获取配置参数</a>。',

        'Configuration Environments':'配置环境',
        'You have only one application, but whether you realize it or not, you need it\nto behave differently at different times:': '您只有一个应用程序，但不管您是否意识到，您都需要它在不同的时间表现出不同的行为：',
        'While developing, you want to log everything and expose nice debugging tools;': '在<strong>开发</strong>过程中，您希望记录所有内容并暴露出色的调试工具；',
        'After deploying to production, you want that same application to be\noptimized for speed and only log errors.': '部署到<strong>生产</strong>环境后，您希望相同的应用程序能够针对速度进行优化，并且只记录错误。',
        "The files stored in config/packages/ are used by Symfony to configure the\napplication services. In other words, you can change\nthe application behavior by changing which configuration files are loaded.\nThat's the idea of Symfony's configuration environments.": 'Symfony 使用存储在 <code translate="no" class="notranslate">config/packages/</code> 中的文件来配置<a href="service_container.html" class="reference internal">应用程序服务</a>。换句话说，您可以通过更改加载哪些配置文件来更改应用程序的行为。这就是 Symfony <strong>配置环境</strong>的理念。',
        'A typical Symfony application begins with three environments:': '一个典型的 Symfony 应用程序从三个环境开始：',
        'dev for local development,': '<code translate="no" class="notranslate">dev</code> 用于本地开发，',
        'prod for production servers,': '<code translate="no" class="notranslate">prod</code> 用于生产服务器，',
        'test for automated tests.': '<code translate="no" class="notranslate">test</code> 用于<a href="testing.html" class="reference internal">自动化测试</a>。',
        'When running the application, Symfony loads the configuration files in this\norder (the last files can override the values set in the previous ones):': '在运行应用程序时，Symfony 将按照以下顺序加载配置文件（后面的文件可以覆盖之前文件中设置的值）：',
        'The files in config/packages/*.<extension>;': '在 <code translate="no" class="notranslate">config/packages/*.&lt;extension&gt;</code> 中的文件；',
        'the files in config/packages/<environment-name>/*.<extension>;': '在 <code translate="no" class="notranslate">config/packages/&lt;environment-name&gt;/*.&lt;extension&gt;</code> 中的文件；',
        'config/services.<extension>;': '<code translate="no" class="notranslate">config/services.&lt;extension&gt;</code>；',
        'config/services_<environment-name>.<extension>.': '<code translate="no" class="notranslate">config/services_&lt;environment-name&gt;.&lt;extension&gt;</code>。',
        'Take the framework package, installed by default, as an example:': '以默认安装的 <code translate="no" class="notranslate">framework</code> 包为例：',
        'First, config/packages/framework.yaml is loaded in all environments and\nit configures the framework with some options;': '首先，<code translate="no" class="notranslate">config/packages/framework.yaml</code> 在所有环境中都会被加载，并使用一些选项来配置框架；',
        'In the prod environment, nothing extra will be set as there is no\nconfig/packages/prod/framework.yaml file;': '在 <strong>prod</strong> 环境中，由于没有 <code translate="no" class="notranslate">config/packages/prod/framework.yaml</code> 文件，因此不会设置额外的配置项；',
        'In the dev environment, there is no file either (\nconfig/packages/dev/framework.yaml does not exist).': '在 <strong>dev</strong> 环境中，也没有文件（<code translate="no" class="notranslate">config/packages/dev/framework.yaml</code> 不存在）。',
        'In the test environment, the config/packages/test/framework.yaml file\nis loaded to override some of the settings previously configured in\nconfig/packages/framework.yaml.': '在 <strong>test</strong> 环境中，会加载 <code translate="no" class="notranslate">config/packages/test/framework.yaml</code> 文件来覆盖之前在 <code translate="no" class="notranslate">config/packages/framework.yaml</code> 中配置的一些设置。',
        'In reality, each environment differs only somewhat from others. This means that\nall environments share a large base of common configuration, which is put in\nfiles directly in the config/packages/ directory.': '实际上，每个环境与其它环境只是略有不同。这意味着所有环境共享一个庞大的通用配置基础，这些配置直接放在 <code translate="no" class="notranslate">config/packages/</code> 目录下的文件中。',
        'You can also define options for different environments in a single\nconfiguration file using the special when keyword:': '你也可以使用特殊的 <code translate="no" class="notranslate">when</code> 关键字在单个配置文件中为不同的环境定义选项：',
        'See the configureContainer() method of\nthe Kernel class to\nlearn everything about the loading order of configuration files.': '查看 <a href="configuration/front_controllers_and_kernel.html" class="reference internal">Kernel 类</a>的 <code translate="no" class="notranslate">configureContainer()</code> 方法，以了解有关配置文件加载顺序的所有信息。',

        'Selecting the Active Environment': '选择激活的环境',
        "Symfony applications come with a file called .env located at the project\nroot directory. This file is used to define the value of environment variables\nand it's explained in detail later in this article.": 'Symfony 应用程序附带一个名为 <code translate="no" class="notranslate">.env</code> 的文件，该文件位于项目根目录。此文件用于定义环境变量的值，<a href="configuration.html#config-dot-env" class="reference internal">本文稍后</a>将详细介绍。',
        'Open the .env file (or better, the .env.local file if you created one)\nand edit the value of the APP_ENV variable to change the environment in\nwhich the application runs. For example, to run the application in production:': '打开 <code translate="no" class="notranslate">.env</code> 文件（或者如果你已经创建了一个，那么更好的做法是打开 <code translate="no" class="notranslate">.env.local</code> 文件），并编辑 <code translate="no" class="notranslate">APP_ENV</code> 变量的值以更改应用程序运行的环境。例如，要在生产环境中运行应用程序：',
        'This value is used both for the web and for the console commands. However, you\ncan override it for commands by setting the APP_ENV value before running them:': '这个值既用于 Web 也用于控制台命令。但是，你可以在运行命令之前设置 <code translate="no" class="notranslate">APP_ENV</code> 的值来覆盖它：',

        'Creating a New Environment': '创建一个新环境',
        'The default three environments provided by Symfony are enough for most projects,\nbut you can define your own environments too. For example, this is how you can\ndefine a staging environment where the client can test the project before\ngoing to production:': 'Symfony 提供的默认三个环境对于大多数项目来说已经足够了，但你也可以定义自己的环境。例如，你可以定义一个 <code translate="no" class="notranslate">staging</code> 环境，让客户在发布到生产环境之前测试项目，方法如下：',
        'Create a configuration directory with the same name as the environment (in\nthis case, config/packages/staging/);': '创建一个与环境同名（在本例中为 <code translate="no" class="notranslate">config/packages/staging/</code>）的配置目录；',
        'Add the needed configuration files in config/packages/staging/ to\ndefine the behavior of the new environment. Symfony loads the\nconfig/packages/*.yaml files first, so you only need to configure the\ndifferences to those files;': '在 <code translate="no" class="notranslate">config/packages/staging/</code> 中添加所需的配置文件，以定义新环境的行为。Symfony 首先加载 <code translate="no" class="notranslate">config/packages/*.yaml</code> 文件，因此您只需要配置这些文件之间的差异；',
        'Select the staging environment using the APP_ENV env var as explained\nin the previous section.': '按照上一节的说明，使用 <code translate="no" class="notranslate">APP_ENV</code> 环境变量选择 <code translate="no" class="notranslate">staging</code> 环境。',
        "It's common for environments to be similar to each other, so you can\nuse symbolic links between config/packages/<environment-name>/\ndirectories to reuse the same configuration.": '不同的环境之间通常会有相似之处，因此您可以在 <code translate="no" class="notranslate">config/packages/&lt;environment-name&gt;/</code> 目录之间使用<a href="https://en.wikipedia.org/wiki/Symbolic_link" class="reference external" rel="external noopener noreferrer" target="_blank">符号链接</a>来重用相同的配置。',
        'Instead of creating new environments, you can use environment variables as\nexplained in the following section. This way you can use the same application\nand environment (e.g. prod) but change its behavior thanks to the\nconfiguration based on environment variables (e.g. to run the application in\ndifferent scenarios: staging, quality assurance, client review, etc.)': '除了创建新环境之外，您还可以使用以下部分中解释的环境变量。这样，您可以使用相同的应用程序和环境（例如 <code translate="no" class="notranslate">prod</code>），但由于基于环境变量的配置，您可以更改其行为（例如，在不同的场景中运行应用程序：staging、质量保证、客户审查等）。',

        'Configuration Based on Environment Variables': '基于环境变量的配置',
        'Using environment variables (or "env vars" for short) is a common practice to:': '使用<a href="https://en.wikipedia.org/wiki/Environment_variable" class="reference external" rel="external noopener noreferrer" target="_blank">环境变量</a>（或简称“env vars”）是一种常见的做法，用于：',
        'Configure options that depend on where the application is run (e.g. the database\ncredentials are usually different in production versus your local machine);': '配置依赖于应用程序运行位置（例如，在生产环境中与本地计算机上的数据库凭据通常不同）的选项；',
        'Configure options that can change dynamically in a production environment (e.g.\nto update the value of an expired API key without having to redeploy the entire\napplication).': '配置在生产环境中可以动态更改的选项（例如，更新已过期的 API 密钥的值，而无需重新部署整个应用程序）。',
        "In other cases, it's recommended to keep using configuration parameters.": '在其它情况下，建议使用<a href="configuration.html#configuration-parameters" class="reference internal">配置参数</a>。',
        'Use the special syntax %env(ENV_VAR_NAME)% to reference environment variables.\nThe values of these options are resolved at runtime (only once per request, to\nnot impact performance) so you can change the application behavior without having\nto clear the cache.': '使用特殊语法 <code translate="no" class="notranslate">%env(ENV_VAR_NAME)%</code> 来引用环境变量。这些选项的值在运行时解析（每个请求只解析一次，以不影响性能），因此您可以在不清除缓存的情况下更改应用程序的行为。',
        'This example shows how you could configure the application secret using an env var:': '这个示例展示了如何使用环境变量来配置应用程序密钥：',
        'Your env vars can also be accessed via the PHP super globals $_ENV and\n$_SERVER (both are equivalent):': '您也可以通过 PHP 超全局变量 <code translate="no" class="notranslate">$_ENV</code> 和 <code translate="no" class="notranslate">$_SERVER</code>（两者是等价的）来访问您的环境变量：',
        "However, in Symfony applications there's no need to use this, because the\nconfiguration system provides a better way of working with env vars.": '但是，在 Symfony 应用程序中，没有必要使用这种方法，因为配置系统提供了更好的方式来处理环境变量。',
        'The values of env vars can only be strings, but Symfony includes some\nenv var processors to transform\ntheir contents (e.g. to turn a string value into an integer).':'环境变量的值只能是字符串，但 Symfony 包含了一些<a href="configuration/env_var_processors.html" class="reference internal">环境变量处理器</a>，用于转换它们的内容（例如，将字符串值转换为整数）。',
        'To define the value of an env var, you have several options:': '要定义环境变量的值，您有几个选项：',
        'Add the value to a .env file;': '<a href="configuration.html#config-dot-env" class="reference internal">将值添加到 .env 文件中</a>；',
        'Encrypt the value as a secret;': '<a href="configuration.html#configuration-secrets" class="reference internal">将值加密为密钥</a>；',
        'Set the value as a real environment variable in your shell or your web server.': '在您的 shell 或 web 服务器中将其值设置为真正的环境变量。',
        "If your application tries to use an env var that hasn't been defined, you'll see\nan exception. You can prevent that by defining a default value for the env var.\nTo do so, define a parameter with the same name as the env var using this syntax:": '如果您的应用程序尝试使用未定义的环境变量，您将会看到一个异常。您可以通过为环境变量定义默认值来防止这种情况。为此，请使用以下语法定义一个与环境变量同名的参数：',
        'Some hosts - like Platform.sh - offer easy utilities to manage env vars\nin production.': '一些主机，比如 Platform.sh，提供了生产环境中易于使用的<a href="https://symfony.com/doc/current/cloud/env.html" class="reference external">工具来管理环境变量</a>。',
        'Some configuration features are not compatible with env vars. For example,\ndefining some container parameters conditionally based on the existence of\nanother configuration option. When using an env var, the configuration option\nalways exists, because its value will be null when the related env var\nis not defined.': '一些配置特性与环境变量不兼容。例如，基于另一个配置选项的存在来有条件地定义某些容器参数。当使用环境变量时，配置选项始终存在，因为当相关的环境变量未定义时，其值将为 <code translate="no" class="notranslate">null</code>。',
        'Beware that dumping the contents of the $_SERVER and $_ENV variables\nor outputting the phpinfo() contents will display the values of the\nenvironment variables, exposing sensitive information such as the database\ncredentials.': '请注意，转储 <code translate="no" class="notranslate">$_SERVER</code> 和 <code translate="no" class="notranslate">$_ENV</code> 变量的内容或输出 <code translate="no" class="notranslate">phpinfo()</code> 的内容将显示环境变量的值，从而暴露敏感信息，例如数据库凭据。',
        "The values of the env vars are also exposed in the web interface of the\nSymfony profiler. In practice this shouldn't be a\nproblem because the web profiler must never be enabled in production.": '在 <a href="profiler.html" class="reference internal">Symfony Profiler</a> 的 Web 界面中也会暴露环境变量的值。实际上，这不应该是一个问题，因为 Web Profiler <strong>永远不</strong>应该在生产环境中启用。',

        'Configuring Environment Variables in .env Files': '在 .env 文件中配置环境变量',
        'Instead of defining env vars in your shell or your web server, Symfony provides\na convenient way to define them inside a .env (with a leading dot) file\nlocated at the root of your project.': '与在您的 shell 或 Web 服务器中定义环境变量不同，Symfony 提供了一种方便的方法，可以在位于项目根目录的 <code translate="no" class="notranslate">.env</code> 文件（以点开头）内部定义它们。',
        'The .env file is read and parsed on every request and its env vars are added\nto the $_ENV & $_SERVER PHP variables. Any existing env vars are never\noverwritten by the values defined in .env, so you can combine both.': '<code translate="no" class="notranslate">.env</code> 文件会在每次请求时被读取和解析，它的环境变量会被添加到 <code translate="no" class="notranslate">$_ENV</code> 和 <code translate="no" class="notranslate">$_SERVER</code> PHP 变量中。任何现有的环境变量都不会被 <code translate="no" class="notranslate">.env</code> 文件中定义的值覆盖，因此您可以结合使用它们。',
        'For example, to define the DATABASE_URL env var shown earlier in this article,\nyou can add:': '例如，要定义本文前面提到的 <code translate="no" class="notranslate">DATABASE_URL</code> 环境变量，您可以添加：',
        'This file should be committed to your repository and (due to that fact) should\nonly contain "default" values that are good for local development. This file\nshould not contain production values.': '这个文件应该提交到您的代码库中，并且（由于这个原因）只应包含适用于本地开发的“默认”值。该文件不应包含生产环境的值。',
        'In addition to your own env vars, this .env file also contains the env vars\ndefined by the third-party packages installed in your application (they are\nadded automatically by Symfony Flex when installing packages).':'除了你自己的环境变量，这个 <code translate="no" class="notranslate">.env</code> 文件还包含在你的应用程序中安装的第三方包定义的环境变量（它们是在安装包时由 <a href="setup.html#symfony-flex" class="reference internal">Symfony Flex</a> 自动添加的）。',
        "Since the .env file is read and parsed on every request, you don't need to\nclear the Symfony cache or restart the PHP container if you're using Docker.": '由于 <code translate="no" class="notranslate">.env</code> 文件会在每次请求时被读取和解析，如果你在使用 Docker，那么你不需要清除Symfony缓存或重启 PHP 容器。',

        '.env File Syntax':'.env 文件语法',
        'Add comments by prefixing them with #:': '通过在前面添加 <code translate="no" class="notranslate">#</code> 来添加注释：',
        'Use environment variables in values by prefixing variables with $:': '通过在变量前加上 <code translate="no" class="notranslate">$</code> 来在值中使用环境变量：',
        'The order is important when some env var depends on the value of other env\nvars. In the above example, DB_PASS must be defined after DB_USER.\nMoreover, if you define multiple .env files and put DB_PASS first,\nits value will depend on the DB_USER value defined in other files\ninstead of the value defined in this file.': '当某些环境变量依赖于其它环境变量的值时，它们的顺序很重要。在上面的例子中，<code translate="no" class="notranslate">DB_PASS</code> 必须在 <code translate="no" class="notranslate">DB_USER</code> 之后定义。此外，如果你定义了多个 <code translate="no" class="notranslate">.env</code> 文件，并将 <code translate="no" class="notranslate">DB_PASS</code> 放在最前面，那么它的值将取决于其它文件中定义的 <code translate="no" class="notranslate">DB_USER</code> 的值，而不是这个文件中定义的值。',
        'Define a default value in case the environment variable is not set:': '如果环境变量未设置，请定义一个默认值：',
        'Embed commands via $() (not supported on Windows):': '通过 <code translate="no" class="notranslate">$()</code> 嵌入命令（在 Windows 上不受支持）：',
        'Using $() might not work depending on your shell.':'使用 <code translate="no" class="notranslate">$()</code> 可能不起作用，具体取决于您的 shell。',
        'As a .env file is a regular shell script, you can source it in\nyour own shell scripts:': '由于 <code translate="no" class="notranslate">.env</code> 文件是一个普通的 shell 脚本，你可以在自己的 shell 脚本中 <code translate="no" class="notranslate">source</code> 它：',

        'Overriding Environment Values via .env.local': '通过 .env.local 覆盖环境变量值',
        'If you need to override an environment value (e.g. to a different value on your\nlocal machine), you can do that in a .env.local file:': '如果你需要覆盖某个环境变量的值（例如，在你的本地机器上设置不同的值），你可以在 <code translate="no" class="notranslate">.env.local</code> 文件中进行这样的操作：',
        'This file should be ignored by git and should not be committed to your repository.\nSeveral other .env files are available to set environment variables in just\nthe right situation:': '这个文件应该被 git 忽略，不应该被提交到你的仓库中。还有其它几个 <code translate="no" class="notranslate">.env</code> 文件可用于在合适的情境中设置环境变量：',
        '.env: defines the default values of the env vars needed by the application;': '<code translate="no" class="notranslate">.env</code>：定义了应用程序所需环境变量的默认值；',
        ".env.local: overrides the default values for all environments but only on\nthe machine which contains the file. This file should not be committed to the\nrepository and it's ignored in the test environment (because tests should\nproduce the same results for everyone);": '<code translate="no" class="notranslate">.env.local</code>：覆盖所有环境的默认值，但仅限于包含此文件的机器。此文件不应提交到仓库中，并且在 <code translate="no" class="notranslate">test</code> 环境中会被忽略（因为测试应该为每个人产生相同的结果）；',
        '.env.<environment> (e.g. .env.test): overrides env vars only for one\nenvironment but for all machines (these files are committed);': '<code translate="no" class="notranslate">.env.&lt;environment&gt;</code> (例如 <code translate="no" class="notranslate">.env.test</code>)：仅针对一个环境，但针对所有机器（这些文件已提交）覆盖环境变量；',
        ".env.<environment>.local (e.g. .env.test.local): defines machine-specific\nenv var overrides only for one environment. It's similar to .env.local,\nbut the overrides only apply to one environment.": '<code translate="no" class="notranslate">.env.&lt;environment&gt;.local</code> (例如 <code translate="no" class="notranslate">.env.test.local</code>)：为单一环境定义特定于机器的环境变量覆盖。它与 <code translate="no" class="notranslate">.env.local</code> 类似，但覆盖仅适用于一个环境。',
        'Real environment variables always win over env vars created by any of the\n.env files. Note that this behavior depends on the\nvariables_order\nconfiguration, which must contain an E to expose the $_ENV superglobal.\nThis is the default configuration in PHP.': '实际的环境变量总是优先于任何 <code translate="no" class="notranslate">.env</code> 文件创建的环境变量。请注意，此行为取决于 <a href="http://php.net/manual/zh/ini.core.php#ini.variables-order" class="reference external" rel="external noopener noreferrer" target="_blank">variables_order</a> 配置，该配置必须包含 <code translate="no" class="notranslate">E</code> 以公开 <code translate="no" class="notranslate">$_ENV</code> 超全局变量。这是 PHP 的默认配置。',
        'The .env and .env.<environment> files should be committed to the\nrepository because they are the same for all developers and machines. However,\nthe env files ending in .local (.env.local and .env.<environment>.local)\nshould not be committed because only you will use them. In fact, the\n.gitignore file that comes with Symfony prevents them from being committed.': '<code translate="no" class="notranslate">.env</code> 和 <code translate="no" class="notranslate">.env.&lt;environment&gt;</code> 文件应该被提交到仓库中，因为它们对所有开发人员和机器都是相同的。然而，以 <code translate="no" class="notranslate">.local</code> 结尾的 env 文件（<code translate="no" class="notranslate">.env.local</code> 和 <code translate="no" class="notranslate">.env.&lt;environment&gt;.local</code>）不应该被提交，因为只有你会使用它们。实际上，Symfony 附带的 <code translate="no" class="notranslate">.gitignore</code> 文件会阻止它们被提交。',

        'Overriding Environment Variables Defined By The System': '覆盖系统定义的环境变量',
        'If you need to override an environment variable defined by the system, use the\noverrideExistingVars parameter defined by the\nloadEnv(),\nbootEnv(), and\npopulate() methods:': '如果您需要覆盖系统定义的环境变量，请使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Dotenv/Dotenv.php#:~:text=function%20loadEnv" class="reference external" title="Symfony\Component\Dotenv\Dotenv::loadEnv()" rel="external noopener noreferrer" target="_blank">loadEnv()</a>、<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Dotenv/Dotenv.php#:~:text=function%20bootEnv" class="reference external" title="Symfony\Component\Dotenv\Dotenv::bootEnv()" rel="external noopener noreferrer" target="_blank">bootEnv()</a> 和 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Dotenv/Dotenv.php#:~:text=function%20populate" class="reference external" title="Symfony\Component\Dotenv\Dotenv::populate()" rel="external noopener noreferrer" target="_blank">populate()</a> 方法中定义的 <code translate="no" class="notranslate">overrideExistingVars</code> 参数：',
        "This will override environment variables defined by the system but it won't\noverride environment variables defined in .env files.": '这将覆盖系统定义的环境变量，但不会覆盖 <code translate="no" class="notranslate">.env</code> 文件中定义的环境变量。',

        'Configuring Environment Variables in Production': '在生产环境中配置环境变量',
        'In production, the .env files are also parsed and loaded on each request. So\nthe easiest way to define env vars is by creating a .env.local file on your\nproduction server(s) with your production values.': '在生产环境中，<code translate="no" class="notranslate">.env</code> 文件也会在每次请求时被解析和加载。因此，定义环境变量的最简单方法是在生产服务器上创建一个包含生产值的 <code translate="no" class="notranslate">.env.local</code> 文件。',
        'To improve performance, you can optionally run the dump-env Composer command:': '为了提高性能，您可以选择运行 <code translate="no" class="notranslate">dump-env</code> Composer 命令：',
        'Dumping Environment Variables without Composer': '不使用 Composer 导出环境变量',
        "If you don't have Composer installed in production, you can use the\ndotenv:dump command instead (available in Symfony Flex\n1.2 or later). The command is not registered by default, so you must register\nfirst in your services:": '如果您在生产环境中没有安装 Composer，您可以使用 <code translate="no" class="notranslate">dotenv:dump</code> 命令（在 <a href="setup.html#symfony-flex" class="reference internal">Symfony Flex</a> 1.2 或更高版本中可用）。该命令默认未注册，因此您必须首先在您的服务中进行注册：',
        'Then, run the command:': '然后，运行命令：',
        'After running this command, Symfony will load the .env.local.php file to\nget the environment variables and will not spend time parsing the .env files.': '运行此命令后，Symfony 将加载 <code translate="no" class="notranslate">.env.local.php</code> 文件以获取环境变量，而无需花费时间解析 <code translate="no" class="notranslate">.env</code> 文件。',
        'Update your deployment tools/workflow to run the dotenv:dump command after\neach deploy to improve the application performance.': '更新您的部署工具/工作流程，以便在每次部署后运行 <code translate="no" class="notranslate">dotenv:dump</code> 命令，以提高应用程序性能。',

        'Encrypting Environment Variables (Secrets)': '加密环境变量（秘密）',
        'Instead of defining a real environment variable or adding it to a .env file,\nif the value of a variable is sensitive (e.g. an API key or a database password),\nyou can encrypt the value using the secrets management system.': '如果变量的值很敏感（例如，API 密钥或数据库密码），而不是定义一个真实的环境变量或将其添加到 <code translate="no" class="notranslate">.env</code> 文件中，您可以使用<a href="configuration/secrets.html" class="reference internal">秘密管理系统</a>来加密该值。',

        'Listing Environment Variables': '列出环境变量',
        'Use the debug:dotenv command to understand how Symfony parses the different\n.env files to set the value of each environment variable:': '使用 <code translate="no" class="notranslate">debug:dotenv</code> 命令来了解 Symfony 是如何解析不同的 <code translate="no" class="notranslate">.env</code> 文件以设置每个环境变量值的：',
        'The option to pass variable names to debug:dotenv was introduced in Symfony 6.2.': '将变量名传递给 <code translate="no" class="notranslate">debug:dotenv</code> 的选项是在 Symfony 6.2 中引入的。',
        "Additionally, and regardless of how you set environment variables, you can see all\nenvironment variables, with their values, referenced in Symfony's container configuration,\nyou can also see the number of occurrences of each environment variable in the container:": '此外，无论您如何设置环境变量，您都可以在 Symfony 的容器配置中查看所有环境变量及其值，还可以查看容器中每个环境变量的出现次数：',

        'Creating Your Own Logic To Load Env Vars': '创建自己的逻辑来加载环境变量',
        "You can implement your own logic to load environment variables if the default\nSymfony behavior doesn't fit your needs. To do so, create a service whose class\nimplements EnvVarLoaderInterface.": '如果 Symfony 的默认行为不符合您的需求，您可以实现自己的逻辑来加载环境变量。为此，创建一个服务，其类实现 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/DependencyInjection/EnvVarLoaderInterface.php" class="reference external" title="Symfony\Component\DependencyInjection\EnvVarLoaderInterface" rel="external noopener noreferrer" target="_blank">EnvVarLoaderInterface</a> 接口。',
        "If you're using the default services.yaml configuration,\nthe autoconfiguration feature will enable and tag this service automatically.\nOtherwise, you need to register and tag your service\nwith the container.env_var_loader tag.": '如果您使用的是<a href="service_container.html#service-container-services-load-example" class="reference internal">默认的 services.yaml 配置</a>，自动配置功能将自动启用并标记此服务。否则，您需要使用 <code translate="no" class="notranslate">container.env_var_loader</code> 标签在容器中注册并<a href="service_container/tags.html" class="reference internal">标记您的服务</a>。',
        "Let's say you have a JSON file named env.json containing your environment\nvariables:": '假设您有一个名为 <code translate="no" class="notranslate">env.json</code> 的 JSON 文件，其中包含您的环境变量：',
        'You can define a class like the following JsonEnvVarLoader to populate the\nenvironment variables from the file:': '您可以定义一个类似于下面的 <code translate="no" class="notranslate">JsonEnvVarLoader</code> 类，从文件中填充环境变量：',
        "That's it! Now the application will look for a env.json file in the\ncurrent directory to populate environment variables (in addition to the\nalready existing .env files).": '就是这样！现在，应用程序将在当前目录中查找 <code translate="no" class="notranslate">env.json</code> 文件以填充环境变量（除了已经存在的 <code translate="no" class="notranslate">.env</code> 文件）。',
        'If you want an env var to have a value on a certain environment but to fallback\non loaders on another environment, assign an empty value to the env var for\nthe environment you want to use loaders:': '如果您希望某个环境变量在特定环境中有值，但在另一个环境中回退到加载器，请为您希望使用加载器的环境为该环境变量分配一个空值：',

        'Accessing Configuration Parameters': '访问配置参数',
        'Controllers and services can access all the configuration parameters. This\nincludes both the parameters defined by yourself\nand the parameters created by packages/bundles. Run the following command to see\nall the parameters that exist in your application:': '控制器和服务可以访问所有的配置参数。这包括<a href="configuration.html#configuration-parameters" class="reference internal">你自己定义的参数</a>以及由包/捆绑包创建的参数。运行以下命令可以查看你应用程序中所有的参数：',
        'In controllers extending from the AbstractController,\nuse the getParameter() helper:': '在继承自 <a href="controller.html#the-base-controller-class-services" class="reference internal">AbstractController</a> 的控制器中，使用 <code translate="no" class="notranslate">getParameter()</code> 辅助函数：',
        "In services and controllers not extending from AbstractController, inject\nthe parameters as arguments of their constructors. You must inject them\nexplicitly because service autowiring\ndoesn't work for parameters:": '在服务和不继承自 <code translate="no" class="notranslate">AbstractController</code> 的控制器中，将参数作为构造函数的参数注入。你必须显式地注入它们，因为<a href="service_container/autowiring.html" class="reference internal">服务的自动装配</a>不适用于参数：',
        'If you inject the same parameters over and over again, use the\nservices._defaults.bind option instead. The arguments defined in that option are\ninjected automatically whenever a service constructor or controller action\ndefines an argument with that exact name. For example, to inject the value of the\nkernel.project_dir parameter\nwhenever a service/controller defines a $projectDir argument, use this:': '如果你反复注入相同的参数，可以使用 <code translate="no" class="notranslate">services._defaults.bind</code> 选项。在该选项中定义的参数将自动注入到任何服务构造函数或控制器操作中，这些操作定义了与该名称完全匹配的参数。例如，要在服务/控制器定义 <code translate="no" class="notranslate">$projectDir</code> 参数时注入 <a href="reference/configuration/kernel.html#configuration-kernel-project-directory" class="reference internal">kernel.project_dir 参数</a>的值，请使用以下代码：',
        'Read the article about binding arguments by name and/or type\nto learn more about this powerful feature.': '阅读关于<a href="service_container.html#services-binding" class="reference internal">按名称和/或类型绑定参数</a>的文章，以了解更多关于这个强大功能的信息。',
        'Finally, if some service needs access to lots of parameters, instead of\ninjecting each of them individually, you can inject all the application\nparameters at once by type-hinting any of its constructor arguments with the\nContainerBagInterface:': '最后，如果某个服务需要访问大量的参数，而不是单独注入每个参数，你可以通过在其构造函数参数中使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/DependencyInjection/ParameterBag/ContainerBagInterface.php" class="reference external" title="Symfony\Component\DependencyInjection\ParameterBag\ContainerBagInterface" rel="external noopener noreferrer" target="_blank">ContainerBagInterface</a> 的类型提示，一次性注入所有应用程序参数：',

        'Using PHP ConfigBuilders': '使用 PHP configbuilder',
        'Writing PHP config is sometimes difficult because you end up with large nested\narrays and you have no autocompletion help from your favorite IDE. A way to\naddress this is to use "ConfigBuilders". They are objects that will help you\nbuild these arrays.': '编写 PHP 配置有时会很困难，因为最终你会得到大型嵌套数组，而且你最喜欢的 IDE 无法提供自动完成帮助。解决此问题的一种方法是使用“ConfigBuilders”。它们是用于帮助你构建这些数组的对象。',
        'Symfony generates the ConfigBuilder classes automatically in the\nkernel build directory for all the\nbundles installed in your application. By convention they all live in the\nnamespace Symfony\\Config:': 'Symfony 会在<a href="reference/configuration/kernel.html#configuration-kernel-build-directory" class="reference internal">内核构建目录</a>中自动为应用程序中安装的所有包生成 ConfigBuilder 类。按照惯例，它们都在 <code translate="no" class="notranslate">Symfony\\Config</code> 命名空间中：',
        "Only root classes in the namespace Symfony\\Config are ConfigBuilders.\nNested configs (e.g. \\Symfony\\Config\\Framework\\CacheConfig) are regular\nPHP objects which aren't autowired when using them as an argument type.": '只有位于 <code translate="no" class="notranslate">Symfony\\Config</code> 命名空间中的根类才是 ConfigBuilders。嵌套配置（例如 <code translate="no" class="notranslate"><wbr>\\Symfony<wbr>\\Config<wbr>\\Framework<wbr>\\CacheConfig</wbr></wbr></wbr></wbr></code>）是常规 PHP 对象，当将它们用作参数类型时不会被自动装配。',
        'In order to get ConfigBuilders autocompletion in your IDE/editor, make sure\nto not exclude the directory where these classes are generated (by default,\nin var/cache/dev/Symfony/Config/).': '为了在 IDE/编辑器中获得 ConfigBuilders 的自动完成功能，请确保不要排除生成这些类的目录（默认情况下，在 <code translate="no" class="notranslate">var/cache/dev/Symfony/Config/</code> 中）。',

        'Keep Going!': '继续前进！',
        "Congratulations! You've tackled the basics of Symfony. Next, learn about each\npart of Symfony individually by following the guides. Check out:": '恭喜你！你已经掌握了 Symfony 的基础知识。接下来，通过遵循指南学习 Symfony 的各个部分。请查看：',
        'Forms': '<a href="forms.html" class="reference internal">表单</a>',
        'Databases and the Doctrine ORM': '<a href="doctrine.html" class="reference internal">数据库和 Doctrine ORM</a>',
        'Service Container': '<a href="service_container.html" class="reference internal">服务容器</a>',
        'Security': '<a href="security.html" class="reference internal">安全</a>',
        'Sending Emails with Mailer': '<a href="mailer.html" class="reference internal">使用 Mailer 发送电子邮件</a>',
        'Logging': '<a href="logging.html" class="reference internal">日志</a>',
        'And all the other topics related to configuration:': '以及与配置相关的所有其它主题：',
        'Environment Variable Processors': '<a href="configuration/env_var_processors.html">环境变量处理器</a>',
        'Understanding how the Front Controller, Kernel and Environments Work together': '<a href="configuration/front_controllers_and_kernel.html">理解前端控制器、内核和环境如何协同工作</a>',
        'Building your own Framework with the MicroKernelTrait': '<a href="configuration/micro_kernel_trait.html">使用 MicroKernelTrait 构建自己的框架</a>',
        'How to Create Multiple Symfony Applications with a Single Kernel': '<a href="configuration/multiple_kernels.html">如何使用单个内核创建多个 Symfony 应用程序</a>',
        'How to Override Symfony\'s default Directory Structure': '<a href="configuration/override_dir_structure.html">如何覆盖 Symfony 的默认目录结构</a>',
        'How to Keep Sensitive Information Secret': '<a href="configuration/secrets.html">如何保护敏感信息的机密性</a>',
        'Using Parameters within a Dependency Injection Class': '<a href="configuration/using_parameters_in_dic.html">在依赖注入类中使用参数</a>',
    };

    fanyi(translates, 1);
})($);
