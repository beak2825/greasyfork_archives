// ==UserScript==
// @name         Symfony 翻译文档 controller/value_resolver.html
// @namespace    fireloong
// @version      0.1.3
// @description  翻译文档 controller/value_resolver.html
// @author       Itsky71
// @match        https://symfony.com/doc/5.x/controller/value_resolver.html
// @match        https://symfony.com/doc/6.4/controller/value_resolver.html
// @match        https://symfony.com/doc/7.1/controller/value_resolver.html
// @match        https://symfony.com/doc/7.2/controller/value_resolver.html
// @match        https://symfony.com/doc/current/controller/value_resolver.html
// @icon         https://www.google.com/s2/favicons?sz=64&domain=symfony.com
// @require      https://unpkg.com/jquery@3.7.1/dist/jquery.min.js
// @require      https://update.greasyfork.org/scripts/503008/fanyi.js
// @grant        none
// @license      MIT
// @downloadURL https://update.greasyfork.org/scripts/500900/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20controllervalue_resolverhtml.user.js
// @updateURL https://update.greasyfork.org/scripts/500900/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20controllervalue_resolverhtml.meta.js
// ==/UserScript==

(function($) {
    'use strict';

    const translates = {
        '\n        \n                    Extending Action Argument Resolving\n        \n            ': '扩展动作参数解析',
        "In the controller guide, you've learned that you can get the\nRequest object via an argument in\nyour controller. This argument has to be type-hinted by the Request class\nin order to be recognized. This is done via the\nArgumentResolver. By\ncreating and registering custom value resolvers, you can extend this\nfunctionality.": '在<a href="../controller.html" class="reference internal">控制器指南</a>中，您已经了解到可以通过控制器中的参数来获取 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpFoundation/Request.php" class="reference external" title="Symfony\Component\HttpFoundation\Request" rel="external noopener noreferrer" target="_blank">Request</a> 对象。为了使这个参数被识别，它必须通过 <code translate="no" class="notranslate">Request</code> 类进行类型提示。这是通过 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Controller/ArgumentResolver.php" class="reference external" title="Symfony\Component\HttpKernel\Controller\ArgumentResolver" rel="external noopener noreferrer" target="_blank">ArgumentResolver</a> 实现的。通过创建和注册自定义值解析器，您可以扩展这一功能。',
        'Built-In Value Resolvers': '内置值解析器',
        'Symfony ships with the following value resolvers in the\nHttpKernel component:': 'Symfony 在 <a href="../components/http_kernel.html" class="reference internal">HttpKernel 组件</a>中提供了以下值解析器：',
        "Attempts to resolve a backed enum case from a route path parameter that matches the name of the argument.\nLeads to a 404 Not Found response if the value isn't a valid backing value for the enum type.": '尝试从与参数名称匹配的路由路径参数中解析出支持枚举的情况。如果值不是枚举类型的有效支持值，则会导致 404 Not Found 响应。',
        'For example, if your backed enum is:': '例如，如果你的支持枚举是：',
        'And your controller contains the following:': '并且你的控制器包含以下内容：',
        'When requesting the /cards/H URL, the $suit variable will store the\nSuit::Hearts case.': '当请求 <code translate="no" class="notranslate">/cards/H</code> URL 时，<code translate="no" class="notranslate">$suit</code> 变量将存储 <code translate="no" class="notranslate">Suit::Hearts</code> 枚举情况。',
        "Furthermore, you can limit route parameter's allowed values to\nonly one (or more) with EnumRequirement:": '此外，您可以使用 <code translate="no" class="notranslate">EnumRequirement</code> 来限制路由参数只允许一个（或多个）允许的值：',
        'The example above allows requesting only /cards/D and /cards/S\nURLs and leads to 404 Not Found response in two other cases.': '上面的例子只允许请求 <code translate="no" class="notranslate">/cards/D</code> 和 <code translate="no" class="notranslate">/cards/S</code> 这两个 URL，而在其它两种情况下会返回 404 Not Found 响应。',
        'The BackedEnumValueResolver and EnumRequirement were introduced in Symfony 6.1.': '<code translate="no" class="notranslate">BackedEnumValueResolver</code> 和 <code translate="no" class="notranslate">EnumRequirement</code> 是在 Symfony 6.1 中引入的。',
        'Maps the request payload or the query string into the type-hinted object.': '将请求负载或查询字符串映射到类型提示的对象。',
        "Because this is a targeted value resolver,\nyou'll have to use either the MapRequestPayload\nor the MapQueryString attribute\nin order to use this resolver.": '因为这个是一个<a href="value_resolver.html#value-resolver-targeted" class="reference internal">针对性的值解析器</a>，所以你将需要使用 <a href="../controller.html#controller-mapping-request-payload" class="reference internal">MapRequestPayload</a> 或 <a href="../controller.html#controller-mapping-query-string" class="reference internal">MapQueryString</a> 属性来使用这个解析器。',
        'The RequestPayloadValueResolver was introduced in Symfony 6.3.': '<code translate="no" class="notranslate">RequestPayloadValueResolver</code> 是在 Symfony 6.3 中引入的。',
        '\n                            Attempts to find a request attribute that matches the name of the argument.\n                    ': '尝试查找与参数名称匹配的请求属性。',
        'Attempts to find a request attribute that matches the name of the argument\nand injects a DateTimeInterface object if type-hinted with a class\nextending DateTimeInterface.': '尝试查找与参数名称匹配的请求属性，并在使用继承自 <code translate="no" class="notranslate">DateTimeInterface</code> 的类进行类型提示时注入一个 <code translate="no" class="notranslate">DateTimeInterface</code> 对象。',
        'By default any input that can be parsed as a date string by PHP is accepted.\nYou can restrict how the input can be formatted with the\nMapDateTime attribute.': '默认情况下，任何能够被 PHP 解析为日期字符串的输入都是可接受的。你可以使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Attribute/MapDateTime.php" class="reference external" title="Symfony\Component\HttpKernel\Attribute\MapDateTime" rel="external noopener noreferrer" target="_blank">MapDateTime</a> 属性来限制输入的格式。',
        'The DateTimeInterface object is generated with the Clock component.\nThis. gives your full control over the date and time values the controller\nreceives when testing your application and using the\nMockClock implementation.': '<code translate="no" class="notranslate">DateTimeInterface</code> 对象是通过 <a href="../components/clock.html" class="reference internal">Clock 组件</a>生成的。这给了你在测试你的应用程序和使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Clock/MockClock.php" class="reference external" title="Symfony\Component\Clock\MockClock" rel="external noopener noreferrer" target="_blank">MockClock</a> 实现时完全控制控制器接收的日期和时间值的能力。',
        'The DateTimeValueResolver and the MapDateTime attribute were\nintroduced in Symfony 6.1.': '<code translate="no" class="notranslate">DateTimeValueResolver</code> 和 <code translate="no" class="notranslate">MapDateTime</code> 属性是在 Symfony 6.1 中引入的。',
        'The use of the Clock component to generate the\nDateTimeInterface object was introduced in Symfony 6.3.': '使用 <a href="../components/clock.html" class="reference internal">Clock 组件</a>来生成 <code translate="no" class="notranslate">DateTimeInterface</code> 对象是在 Symfony 6.3 中引入的。',
        '\n                            Injects the current Request if type-hinted with Request or a class\nextending Request.\n                    ': '如果通过 <code translate="no" class="notranslate">Request</code> 类或其子类进行类型提示，则注入当前的 <code translate="no" class="notranslate">Request</code>。',
        '\n                            Injects a service if type-hinted with a valid service class or interface. This\nworks like autowiring.\n                    ': '如果通过有效的服务类或接口进行类型提示，则注入服务。这类似于<a href="../service_container/autowiring.html" class="reference internal">自动装配</a>。',
        '\n                            Injects the configured session class implementing SessionInterface if\ntype-hinted with SessionInterface or a class implementing\nSessionInterface.\n                    ': '如果通过 <code translate="no" class="notranslate">SessionInterface</code> 或实现 <code translate="no" class="notranslate">SessionInterface</code> 的类进行类型提示，则注入已配置的会话类，该类实现了 <code translate="no" class="notranslate">SessionInterface</code>。',
        '\n                            Will set the default value of the argument if present and the argument\nis optional.\n                    ': '如果存在默认值且参数是可选的，则会设置参数的默认值。',
        "Attempts to convert any UID values from a route path parameter into UID objects.\nLeads to a 404 Not Found response if the value isn't a valid UID.": '尝试将路由路径参数中的任何 UID 值转换为 UID 对象。如果值不是有效的 UID，则会导致 404 Not Found 响应。',
        'For example, the following will convert the token parameter into a UuidV4 object:': '例如，以下示例会将 token 参数转换为 <code translate="no" class="notranslate">UuidV4</code> 对象：',
        'The UidValueResolver was introduced in Symfony 6.1.': '<code translate="no" class="notranslate">UidValueResolver</code> 是在 Symfony 6.1 中引入的。',
        '\n                            Verifies if the request data is an array and will add all of them to the\nargument list. When the action is called, the last (variadic) argument will\ncontain all the values of this array.\n                    ': '验证请求数据是否为数组，并将其全部添加到参数列表中。当调用操作时，最后一个（可变参数）参数将包含该数组的所有值。',
        'In addition, some components, bridges and official bundles provide other value resolvers:': '此外，一些组件、桥接器和官方包提供了其它值解析器：',
        'Injects the object that represents the current logged in user if type-hinted\nwith UserInterface. You can also type-hint your own User class but you\nmust then add the #[CurrentUser] attribute to the argument. Default value\ncan be set to null in case  the controller can be accessed by anonymous\nusers. It requires installing the SecurityBundle.': '如果通过 <code translate="no" class="notranslate">UserInterface</code> 进行类型提示，则注入表示当前登录用户的对象。你也可以通过你自己的 <code translate="no" class="notranslate">User</code> 类进行类型提示，但你必须向参数添加 <code translate="no" class="notranslate">#[CurrentUser]</code> 注解。如果匿名用户可以访问控制器，则可以将默认值设置为 <code translate="no" class="notranslate">null</code>。这需要安装 <a href="../security.html" class="reference internal">SecurityBundle</a>。',
        'If the argument is not nullable and there is no logged in user or the logged in\nuser has a user class not matching the type-hinted class, an AccessDeniedException\nis thrown by the resolver to prevent access to the controller.': '如果参数不是可为空的，并且没有登录用户或登录用户的用户类与类型提示的类不匹配，则解析器将抛出 <code translate="no" class="notranslate">AccessDeniedException</code> 以阻止访问控制器。',
        'Injects the object that represents the current logged in token if type-hinted\nwith TokenInterface or a class extending it.': '如果通过 <code translate="no" class="notranslate">TokenInterface</code> 或其子类进行类型提示，则注入表示当前登录令牌的对象。',
        'If the argument is not nullable and there is no logged in token, an HttpException\nwith status code 401 is thrown by the resolver to prevent access to the controller.': '如果参数不是可为空的，并且没有登录令牌，则解析器将抛出状态码为 401 的 <code translate="no" class="notranslate">HttpException</code> 以阻止访问控制器。',
        'The SecurityTokenValueResolver was introduced in Symfony 6.3.': '<code translate="no" class="notranslate">SecurityTokenValueResolver</code> 是在 Symfony 6.3 中引入的。',
        'Automatically query for an entity and pass it as an argument to your controller.': '自动查询实体并将其作为参数传递给控制器。',
        'For example, the following will query the Product entity which has {id} as primary key:': '例如，以下示例将查询主键为 <code translate="no" class="notranslate">{id}</code> 的 <code translate="no" class="notranslate">Product</code> 实体：',
        'To learn more about the use of the EntityValueResolver, see the dedicated\nsection Automatically Fetching Objects.': '要了解有关 <code translate="no" class="notranslate">EntityValueResolver</code> 的更多信息，请参阅专门的部分<a href="../doctrine.html#doctrine-entity-value-resolver" class="reference internal">自动获取对象</a>。',
        'The EntityValueResolver was introduced in Symfony 6.2.': '<code translate="no" class="notranslate">EntityValueResolver</code> 是在 Symfony 6.2 中引入的。',
        'PSR-7 Objects Resolver:': 'PSR-7 对象解析器：',
        '\n                            Injects a Symfony HttpFoundation Request object created from a PSR-7 object\nof type Psr\\Http\\Message\\ServerRequestInterface,\nPsr\\Http\\Message\\RequestInterface or Psr\\Http\\Message\\MessageInterface.\nIt requires installing the PSR-7 Bridge component.\n                    ': '从类型为 <code translate="no" class="notranslate">Psr\\Http\\Message\\ServerRequestInterface</code>、<code translate="no" class="notranslate">Psr\\Http\\Message\\RequestInterface</code> 或 <code translate="no" class="notranslate">Psr\\Http\\Message\\MessageInterface</code> 的 PSR-7 对象中注入一个 Symfony HttpFoundation <code translate="no" class="notranslate">Request</code> 对象。这需要安装 <a href="../components/psr7.html" class="reference internal">PSR-7 Bridge</a> 组件。',

        'Managing Value Resolvers': '管理值解析器',
        'For each argument, every resolver tagged with controller.argument_value_resolver\nwill be called until one provides a value. The order in which they are called depends\non their priority. For example, the SessionValueResolver will be called before the\nDefaultValueResolver because its priority is higher. This allows to write e.g.\nSessionInterface $session = null to get the session if there is one, or null\nif there is none.': '对于每个参数，将调用所有标记有 <code translate="no" class="notranslate">controller.argument_value_resolver</code> 的解析器，直到其中一个提供值为止。调用它们的顺序取决于它们的优先级。例如，<code translate="no" class="notranslate">SessionValueResolver</code> 将在 <code translate="no" class="notranslate">DefaultValueResolver</code> 之前被调用，因为它的优先级更高。这允许你编写例如 <code translate="no" class="notranslate">SessionInterface $session = null</code> 的代码，以便在存在会话时获取会话，在不存在会话时获取 <code translate="no" class="notranslate">null</code>。',
        "In that specific case, you don't need any resolver running before\nSessionValueResolver, so skipping them would not only improve performance,\nbut also prevent one of them providing a value before SessionValueResolver\nhas a chance to.": '在特定情况下，你不需要在 <code translate="no" class="notranslate">SessionValueResolver</code> 之前运行任何解析器，因此跳过它们不仅可以提高性能，还可以防止它们在 <code translate="no" class="notranslate">SessionValueResolver</code> 有机会之前提供一个值。',
        'The ValueResolver attribute\nlets you do this by "targeting" the resolver you want:': '<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Attribute/ValueResolver.php" class="reference external" title="Symfony\Component\HttpKernel\Attribute\ValueResolver" rel="external noopener noreferrer" target="_blank">ValueResolver</a> 注解允许你通过“指定”你想要的解析器来实现这一点：',
        'The ValueResolver attribute was introduced in Symfony 6.3.': '<code translate="no" class="notranslate">ValueResolver</code> 注解是在 Symfony 6.3 中引入的。',
        "In the example above, the SessionValueResolver will be called first because\nit is targeted. The DefaultValueResolver will be called next if no value has\nbeen provided; that's why you can assign null as $session's default value.": '在上面的示例中，<code translate="no" class="notranslate">SessionValueResolver</code> 将首先被调用，因为它是被指定的。如果没有提供值，则接下来将调用 <code translate="no" class="notranslate">DefaultValueResolver</code>；这就是你可以将 <code translate="no" class="notranslate">null</code> 分配为 <code translate="no" class="notranslate">$session</code> 的默认值的原因。',
        "You can target a resolver by passing its name as ValueResolver's first argument.\nFor convenience, built-in resolvers' name are their FQCN.": '你可以通过将解析器的名称作为 <code translate="no" class="notranslate">ValueResolver</code> 的第一个参数来指定解析器。为了方便起见，内置解析器的名称是它们的完全限定类名（FQCN）。',
        "A targeted resolver can also be disabled by passing ValueResolver's $disabled\nargument to true; this is how MapEntity allows to disable the\nEntityValueResolver for a specific controller.\nYes, MapEntity extends ValueResolver!": '通过将 <code translate="no" class="notranslate">ValueResolver</code> 的 <code translate="no" class="notranslate">$disabled</code> 参数设置为 <code translate="no" class="notranslate">true</code>，也可以禁用指定的解析器；这就是 <a href="../doctrine.html#doctrine-entity-value-resolver" class="reference internal">MapEntity 如何允许为特定控制器禁用 EntityValueResolver 的</a>。是的，<code translate="no" class="notranslate">MapEntity</code> 扩展了 <code translate="no" class="notranslate">ValueResolver</code>！',

        'Adding a Custom Value Resolver': '添加自定义值解析器',
        "In the next example, you'll create a value resolver to inject an ID value\nobject whenever a controller argument has a type implementing\nIdentifierInterface (e.g. BookingId):": '在接下来的示例中，你将创建一个值解析器，以便在控制器参数具有实现 <code translate="no" class="notranslate">IdentifierInterface</code>（例如 <code translate="no" class="notranslate">BookingId</code>）的类型时注入一个 ID 值对象：',
        'The ValueResolverInterface was introduced in Symfony 6.2. Prior to\n6.2, you had to use the\nArgumentValueResolverInterface,\nwhich defines different methods.': '<code translate="no" class="notranslate">ValueResolverInterface</code> 是在 Symfony 6.2 中引入的。在 6.2 之前，你必须使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Controller/ArgumentValueResolverInterface.php" class="reference external" title="Symfony\Component\HttpKernel\Controller\ArgumentValueResolverInterface" rel="external noopener noreferrer" target="_blank">ArgumentValueResolverInterface</a>，它定义了不同的方法。',
        'Adding a new value resolver requires creating a class that implements\nValueResolverInterface\nand defining a service for it.': '添加新的值解析器需要创建一个实现 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Controller/ValueResolverInterface.php" class="reference external" title="Symfony\Component\HttpKernel\Controller\ValueResolverInterface" rel="external noopener noreferrer" target="_blank">ValueResolverInterface</a> 的类，并为其定义一个服务。',
        'This interface contains a resolve() method, which is called for each\nargument of the controller. It receives the current Request object and an\nArgumentMetadata\ninstance, which contains all information from the method signature.': '该接口包含一个 <code translate="no" class="notranslate">resolve()</code> 方法，该方法针对控制器的每个参数被调用。它接收当前的 <code translate="no" class="notranslate">Request</code> 对象和一个 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/ControllerMetadata/ArgumentMetadata.php" class="reference external" title="Symfony\Component\HttpKernel\ControllerMetadata\ArgumentMetadata" rel="external noopener noreferrer" target="_blank">ArgumentMetadata</a> 实例，后者包含方法签名中的所有信息。',
        "The resolve() method should return either an empty array (if it cannot resolve\nthis argument) or an array with the resolved value(s). Usually arguments are\nresolved as a single value, but variadic arguments require resolving multiple\nvalues. That's why you must always return an array, even for single values:": '<code translate="no" class="notranslate">resolve()</code> 方法应该返回一个空数组（如果它无法解析此参数）或包含已解析值（们）的数组。通常，参数被解析为单个值，但可变参数需要解析多个值。这就是为什么即使对于单个值，你也必须始终返回一个数组的原因：',
        'This method first checks whether it can resolve the value:': '此方法首先检查它是否可以解析该值：',
        'The argument must be type-hinted with a class implementing a custom IdentifierInterface;': '参数必须通过实现自定义 <code translate="no" class="notranslate">IdentifierInterface</code> 的类进行类型提示；',
        'The argument name (e.g. $id) must match the name of a request\nattribute (e.g. using a /booking/{id} route placeholder).': '参数名称（例如 <code translate="no" class="notranslate">$id</code>）必须与请求属性的名称匹配（例如，使用 <code translate="no" class="notranslate">/booking/{id}</code> 路由占位符）。',
        'When those requirements are met, the method creates a new instance of the\ncustom value object and returns it as the value for this argument.': '当这些要求得到满足时，该方法会创建自定义值对象的新实例，并将其作为此参数的值返回。',
        "That's it! Now all you have to do is add the configuration for the service\ncontainer. This can be done by adding one of the following tags to your value resolver.": '就是这样！现在，你所需要做的就是为服务容器添加配置。这可以通过向你的值解析器添加以下标签之一来完成。',
        'This tag is automatically added to every service implementing ValueResolverInterface,\nbut you can set it yourself to change its priority or name attributes.': '这个标签会自动添加到每个实现 <code translate="no" class="notranslate">ValueResolverInterface</code> 的服务上，但你可以自己设置它来更改其 <code translate="no" class="notranslate">priority</code> 或 <code translate="no" class="notranslate">name</code> 属性。',
        "While adding a priority is optional, it's recommended to add one to make sure\nthe expected value is injected. The built-in RequestAttributeValueResolver,\nwhich fetches attributes from the Request, has a priority of 100. If your\nresolver also fetches Request attributes, set a priority of 100 or more.\nOtherwise, set a priority lower than 100 to make sure the argument resolver\nis not triggered when the Request attribute is present.": '虽然添加优先级是可选的，但建议添加一个以确保注入预期的值。内置的 <code translate="no" class="notranslate">RequestAttributeValueResolver</code>（从 <code translate="no" class="notranslate">Request</code> 中获取属性）的优先级为 <code translate="no" class="notranslate">100</code>。如果你的解析器也从 <code translate="no" class="notranslate">Request</code> 中获取属性，请设置优先级为 <code translate="no" class="notranslate">100</code> 或更高。否则，请设置低于 <code translate="no" class="notranslate">100</code> 的优先级，以确保在 <code translate="no" class="notranslate">Request</code> 属性存在时不会触发参数解析器。',
        'To ensure your resolvers are added in the right position you can run the following\ncommand to see which argument resolvers are present and in which order they run:': '为了确保你的解析器被添加到正确的位置，你可以运行以下命令来查看哪些参数解析器存在以及它们以什么顺序运行：',
        "You can also configure the name passed to the ValueResolver attribute to target\nyour resolver. Otherwise it will default to the service's id.": '你还可以配置传递给 <code translate="no" class="notranslate">ValueResolver</code> 属性的名称以指定你的解析器。否则，它将默认为服务的 ID。',
        'Set this tag if you want your resolver to be called only if it is targeted by a\nValueResolver attribute. Like controller.argument_value_resolver, you\ncan customize the name by which your resolver can be targeted.': '如果你只想在解析器被 <code translate="no" class="notranslate">ValueResolver</code> 属性指定时才调用它，请设置此标签。与 <code translate="no" class="notranslate">controller.argument_value_resolver</code> 一样，你可以自定义解析器的目标名称。',
        'As an alternative, you can add the\nAsTargetedValueResolver attribute\nto your resolver and pass your custom name as its first argument:': '作为替代方案，你可以向解析器添加 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Attribute/AsTargetedValueResolver.php" class="reference external" title="Symfony\Component\HttpKernel\Attribute\AsTargetedValueResolver" rel="external noopener noreferrer" target="_blank">AsTargetedValueResolver</a> 属性，并将你的自定义名称作为第一个参数传递：',
        "You can then pass this name as ValueResolver's first argument to target your resolver:": '然后，你可以将此名称作为 <code translate="no" class="notranslate">ValueResolver</code> 的第一个参数来指定你的解析器：',
        'The controller.targeted_value_resolver tag and AsTargetedValueResolver\nattribute were introduced in Symfony 6.3.': '<code translate="no" class="notranslate">controller.targeted_value_resolver</code> 标签和 <code translate="no" class="notranslate">AsTargetedValueResolver</code> 属性是在 Symfony 6.3 中引入的。',
    };

    fanyi(translates, 1);
})($);
