// ==UserScript==
// @name            HWH Tweaker
// @namespace       http://tampermonkey.net/
// @version         6.0.1
// @description     Extension for HeroWarsHelper by ZingerY - Adds adventure path editor, custom buttons, and tweaks
// @author          AI Assistant
// @license         MIT
// @match           https://www.hero-wars.com/*
// @match           https://apps-1701433570146040.apps.fbsbx.com/*
// @run-at          document-idle
// @grant           GM_setValue
// @grant           GM_getValue
// @downloadURL https://update.greasyfork.org/scripts/553051/HWH%20Tweaker.user.js
// @updateURL https://update.greasyfork.org/scripts/553051/HWH%20Tweaker.meta.js
// ==/UserScript==


// Configuration at the top of the script
const TWEAKER_VERSION = '6.0.1';
const DEBUG_MODE = localStorage.getItem('hwh_debug_mode') === 'true';
const TOURNAMENT_RETENTION_DAYS = 7;
const TOURNAMENT_RETENTION_MS = TOURNAMENT_RETENTION_DAYS * 24 * 60 * 60 * 1000;
// Preferred Items Settings
const HEROIC_OVERRIDE_ENABLED_KEY = 'hwh_heroic_override_enabled';
const HEROIC_OVERRIDE_MISSION_KEY = 'hwh_heroic_override_mission';
const ARENA_STATS_ENABLED_KEY = 'hwh_arena_stats_enabled';
const WINTERFEST_GIFT_CACHE_KEY = 'hwh_winterfest_gift_cache';
const WINTERFEST_CACHE_DAYS = 14; // Keep cache for 2 weeks after event ends
const XP_POTION_KEEP_KEY = 'hwh_xp_potion_keep_amount';

// Inject consolidated styles
if (!document.getElementById('twk-styles')) {
    const styleEl = document.createElement('style');
    styleEl.id = 'twk-styles';
    styleEl.textContent = `
        .twk-gold { color: #ffd700; }
        .twk-green { color: #4ae29a; }
        .twk-red { color: #ff6b6b; }
        .twk-orange { color: #ffa500; }
        .twk-white { color: #fff; }
        .twk-muted { color: #999; }
        .twk-dim { color: #aaa; }
        .twk-gold-bold { color: #ffd700; font-weight: bold; }
        .twk-green-bold { color: #4ae29a; font-weight: bold; }
        .twk-red-bold { color: #ff6b6b; font-weight: bold; }
        .twk-cell { padding: 3px; text-align: center; }
        .twk-cell-click { padding: 3px; text-align: center; cursor: pointer; }
        .twk-th { background: #8b6914; color: #ffd700; font-weight: bold; }
        .twk-label { display: block; margin-bottom: 5px; font-weight: bold; color: #999; }
        .twk-panel { border: 2px solid #8b6914; border-radius: 8px; padding: 15px; background: rgba(0,0,0,0.1); }
        .twk-overlay-box { background: rgba(0,0,0,0.3); padding: 8px; border-radius: 5px; text-align: center; }
        .twk-flex-between { display: flex; justify-content: space-between; margin-bottom: 6px; }
        .twk-flex-gap8 { display: flex; gap: 8px; }
        .twk-flex-gap10 { display: flex; gap: 10px; }
        .twk-flex-gap10-mb15 { display: flex; gap: 10px; margin-bottom: 15px; }
        .twk-mb-5 { margin-bottom: 5px; }
        .twk-mb-15 { margin-bottom: 15px; }
        .twk-center { text-align: center; }
        .twk-right { text-align: right; }
        .twk-mono { font-family: monospace; }
        .twk-icon-click { margin-left: 2px; vertical-align: middle; cursor: pointer; }
        .twk-hidden { display: none; }
    `;
    document.head.appendChild(styleEl);
}

function debugLog(...args) {
    if (DEBUG_MODE) console.log(...args);  // ‚úÖ calls console.log
}

// Visibility-aware interval - pauses when tab is hidden
const createSmartInterval = (fn, ms, name = 'unnamed') => {
    let intervalId = null;
    let lastRun = 0;

    const start = () => {
        if (intervalId) return;
        intervalId = setInterval(() => {
            if (document.hidden) {
                debugLog(`‚è∏Ô∏è ${name} skipped - tab hidden`);
                return;
            }
            lastRun = Date.now();
            fn();
        }, ms);
    };

    const stop = () => {
        if (intervalId) {
            clearInterval(intervalId);
            intervalId = null;
        }
    };

    // Auto-pause on visibility change
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            debugLog(`‚è∏Ô∏è ${name} paused`);
        } else if (Date.now() - lastRun > ms) {
            fn(); // Catch up if we missed a cycle
        }
    });

    start();
    return { start, stop, getId: () => intervalId };
};

const PerfLog = {
    start(name) {
        this[name] = performance.now();
        debugLog(`‚ñ∂Ô∏è ${name} started`);
    },
    end(name) {
        if (this[name]) {
            const ms = (performance.now() - this[name]).toFixed(1);
            debugLog(`‚è±Ô∏è ${name}: ${ms}ms`);
            delete this[name];
        }
    }
};
window.PerfLog = PerfLog;

// Shared promise for game readiness - all components wait on this
let _gameReadyPromise = null;
function waitForGameReady() {
    if (_gameReadyPromise) return _gameReadyPromise;
    _gameReadyPromise = new Promise(resolve => {
        const check = () => {
            if (typeof cheats !== 'undefined' && cheats.translate &&
                typeof lib !== 'undefined' && lib.data) {
                debugLog('‚úÖ Game ready - all dependencies available');
                resolve(true);
            } else {
                setTimeout(check, 200);
            }
        };
        check();
    });
    return _gameReadyPromise;
}


// Telegram notification helper
async function sendTelegramNotification(message) {
    const enabled = localStorage.getItem('hwh_telegram_enabled') === 'true';
    if (!enabled) return;

    const token = localStorage.getItem('hwh_telegram_token');
    const chatId = localStorage.getItem('hwh_telegram_chatid');

    if (!token || !chatId) {
        console.warn('üì± Telegram not configured');
        return;
    }

    try {
        const response = await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                chat_id: chatId,
                text: message,
                parse_mode: 'HTML'
            })
        });

        const result = await response.json();
        if (result.ok) {
            debugLog('üì± Telegram notification sent');
        } else {
            console.warn('‚ö†Ô∏è Telegram send failed:', result);
        }
    } catch (error) {
        console.error('‚ùå Telegram error:', error);
    }
}

// Track user activity for idle detection (throttled)
window._lastActivity = Date.now();
let _activityThrottled = false;
['mousedown', 'keydown', 'scroll', 'touchstart'].forEach(event => {
    document.addEventListener(event, () => {
        if (_activityThrottled) return;
        _activityThrottled = true;
        window._lastActivity = Date.now();
        setTimeout(() => { _activityThrottled = false; }, 30000);
    }, { passive: true, capture: true });
});

// Track AoC scores
window._aocLastScores = {};

async function checkAoCScoreChanges(contributors, actualUserId) {
    const myContrib = contributors.find(c => c.id === actualUserId);
    if (!myContrib) return;

    const lastScore = window._aocLastScores[actualUserId] || 0;
    const currentScore = myContrib.userExp;

    if (currentScore > lastScore && lastScore > 0) {
        const gained = currentScore - lastScore;
        const message = `üè∞ <b>AoC Score Update</b>\n+${gained.toLocaleString()} points\nTotal: ${currentScore.toLocaleString()}`;
        await sendTelegramNotification(message);
    }

    window._aocLastScores[actualUserId] = currentScore;
}

// Helper to close sync/OK popups - global so all functions can use it
async function closeSyncPopup(delay = 800) {
    await new Promise(r => setTimeout(r, delay));
    try {
        // Look for OK buttons in game popups
        const btnPlates = DOMCache.getAll('popupBtnPlates', '.PopUp_btnPlate', true);
        for (const plate of btnPlates) {
            if (plate.offsetParent !== null && plate.textContent?.trim().toUpperCase() === 'OK') {
                const parent = plate.parentElement;
                if (parent) {
                    parent.click();
                    debugLog('‚úÖ Closed sync popup');
                    return true;
                }
            }
        }
        // Fallback: direct button search
        const okButtons = DOMCache.getAll('popupOkButtons', '.PopUp_btnGap, .PopUp_button', true);
        for (const btn of okButtons) {
            if (btn.offsetParent !== null && btn.textContent?.trim().toUpperCase() === 'OK') {
                btn.click();
                debugLog('‚úÖ Closed sync popup (fallback)');
                return true;
            }
        }
    } catch (e) {
        debugLog('Could not auto-close sync popup:', e);
    }
    return false;
}
window.closeSyncPopup = closeSyncPopup;

// Silent sync - does everything refreshGame does without the popup
async function silentSync() {
    try {
        debugLog('üîÑ Silent sync starting...');
        if (HWHFuncs?.setProgress) {
            HWHFuncs.setProgress('üîÑ Syncing...', false);
        }

        const SendFunc = HWHFuncs?.Send || window.Send || (typeof Send !== 'undefined' ? Send : null);
        if (!SendFunc) {
            console.error('‚ùå silentSync: Send function not available');
            return false;
        }

        // Suppress popup temporarily
        const GPM = selfGame['game.mediator.gui.popup.GamePopupManager'];
        const hoMethod = Object.keys(GPM.prototype)[15];
        const origHo = GPM.prototype[hoMethod];
        GPM.prototype[hoMethod] = () => {};

        // Battlepass first
        const ts = Date.now();
        await SendFunc(JSON.stringify({
            calls: [
                { name: "battlePass_getInfo", args: {}, ident: "sync_bp", context: { actionTs: ts } },
                { name: "battlePass_getSpecial", args: {}, ident: "sync_bpSpecial", context: { actionTs: ts } }
            ]
        }));

        // Inventory
        if (typeof cheats !== 'undefined' && cheats.refreshInventory) {
            await cheats.refreshInventory();
        }

        // Then NDM triggers sync + UI update
        const NDM = selfGame['game.model.user.NextDayUpdatedManager'];
        const hijMethod = Object.keys(NDM.prototype)[11];
        new NDM()[hijMethod]();

        // Restore popup after 1 second
        setTimeout(() => { GPM.prototype[hoMethod] = origHo; }, 1000);

        debugLog('‚úÖ Silent sync complete');
        if (HWHFuncs?.setProgress) {
            HWHFuncs.setProgress('‚úÖ Data synced', true);
        }
        return true;

    } catch (e) {
        console.error('‚ùå Silent sync error:', e);
        if (HWHFuncs?.setProgress) {
            HWHFuncs.setProgress('‚ùå Sync failed', true);
        }
        return false;
    }
}
window.silentSync = silentSync;

// ========== HEROIC MISSION OVERRIDE ==========
function getPreferredHeroicMission() {
    return parseInt(localStorage.getItem(HEROIC_OVERRIDE_MISSION_KEY)) || 116;
}
function isHeroicOverrideEnabled() {
    return localStorage.getItem(HEROIC_OVERRIDE_ENABLED_KEY) === 'true';
}
function overrideHeroicMission() {
    const checkHWH = setInterval(() => {
        const win = typeof unsafeWindow !== 'undefined' ? unsafeWindow : window;
        if (win.HWHClasses?.dailyQuests) {
            clearInterval(checkHWH);
            const original = win.HWHClasses.dailyQuests.prototype.getHeroicMissionId;
            win.HWHClasses.dailyQuests.prototype.getHeroicMissionId = function() {
                if (!isHeroicOverrideEnabled()) {
                    return original.call(this);
                }
                const preferredMission = getPreferredHeroicMission();
                const stamina = this.questInfo.userGetInfo.refillable.find(x => x.id == 1).amount;
                const missionData = lib.data.mission[preferredMission];
                const missionStatus = this.questInfo.missionGetAll?.[preferredMission];
                if (missionData && missionStatus?.stars === 3 && stamina >= 3 * missionData.normalMode.teamExp) {
                    debugLog('üéØ Heroic override: Mission ' + preferredMission);
                    return preferredMission;
                }
                debugLog('‚ö†Ô∏è Preferred heroic mission not available, using HWH default');
                return original.call(this);
            };
            debugLog('‚úÖ Heroic mission override installed');
        }
    }, 500);
    setTimeout(() => clearInterval(checkHWH), 30000);
}
overrideHeroicMission();

// Build and send detailed AoC status notification
async function sendAoCStatusNotification() {
    const enabled = localStorage.getItem('hwh_telegram_enabled') === 'true';
    if (!enabled) return;

    try {
        // Fetch fresh data
        const liveData = await window.fetchLiveCastleData();
        const SendFunction = HWHFuncs?.Send || window.Send || (typeof Send !== 'undefined' ? Send : null);
        const guildResponse = await SendFunction(JSON.stringify({
            calls: [{
                name: "clanGetInfo",
                args: {},
                context: { actionTs: Date.now() },
                ident: "body"
            }]
        }));
        liveData.guildMembers = guildResponse?.results?.[0]?.result?.response?.clan?.members || {};

        const stats = liveData.dominationStats || {};
        const clansData = liveData.mapState?.clans || {};
        const guildMembers = liveData.guildMembers || {};
        const townPositions = liveData.mapState?.townPositions || {};
        const userPositions = liveData.mapState?.userPositions || {};
        const users = liveData.mapState?.users || {};
        const positionNames = JSON.parse(localStorage.getItem('hwh_aoc_position_names')) || {};
        const castleInfo = liveData.castleInfo || {};

        let actualUserId = localStorage.getItem('userId') || localStorage.getItem('hw_UserId');
        if (actualUserId) actualUserId = String(actualUserId);

        const myGuildMemberIds = Object.keys(guildMembers);
        const myGuildId = Object.values(guildMembers)[0]?.clanId;

        // Get guild rankings
        const guilds = [];
        for (const [guildId, guildStats] of Object.entries(stats)) {
            const clanInfo = clansData[guildId] || {};
            guilds.push({
                id: guildId,
                title: clanInfo.title || `Guild ${guildId}`,
                coins: guildStats.coins || 0
            });
        }
        guilds.sort((a, b) => b.coins - a.coins);

        const myGuildIndex = guilds.findIndex(g => g.id === String(myGuildId));
        const myGuild = myGuildIndex >= 0 ? guilds[myGuildIndex] : null;
        const myGuildRank = myGuildIndex >= 0 ? myGuildIndex + 1 : '?';

        const formatK = (n) => n >= 1000 ? (n >= 10000 ? Math.round(n/1000) + 'k' : (n/1000).toFixed(1) + 'k') : n;

        let guildLeadText = '';
        if (myGuild) {
            if (myGuildIndex === 0) {
                const lead = myGuild.coins - (guilds[1]?.coins || 0);
                guildLeadText = `+${formatK(lead)} ahead`;
            } else {
                const deficit = (guilds[0]?.coins || 0) - myGuild.coins;
                guildLeadText = `-${formatK(deficit)} behind`;
            }
        }

        // Find my location
        let myLocation = 'Unknown';
        for (const [pos, townData] of Object.entries(townPositions)) {
            if (townData.userId === parseInt(actualUserId) && townData.status === 1) {
                const locName = positionNames[pos] || `Position ${pos}`;
                const parts = locName.split(' ');
                if (parts.length >= 3) {
                    myLocation = parts.slice(0, -2).join(' ') + ' ' + parts[parts.length - 1];
                } else {
                    myLocation = locName;
                }
                break;
            }
        }
        if (myLocation === 'Unknown') {
            const myPosition = userPositions[actualUserId];
            const castlePositionValues = [693, 662, 665, 696];
            if (castlePositionValues.includes(myPosition)) {
                myLocation = 'üè∞ Castle';
            } else if (myPosition) {
                myLocation = `Moving (${myPosition})`;
            }
        }

        // Calculate guild coins/min
        const positionCoins = {1:32, 123:8, 98:8, 112:8, 115:8, 101:8, 126:8, 333:4, 33:4, 26:4, 436:4, 439:4, 29:4, 36:4, 336:4, 423:2, 446:2, 340:2, 397:2, 394:2, 343:2, 449:2, 426:2, 585:1, 596:1, 465:1, 375:1, 356:1, 404:1, 407:1, 359:1, 378:1, 468:1, 599:1, 588:1};
        let totalGuildCoins = 0;
        for (const [pos, townData] of Object.entries(townPositions)) {
            if (townData.status === 1 && townData.userId && myGuildMemberIds.includes(String(townData.userId))) {
                totalGuildCoins += positionCoins[parseInt(pos)] || 0;
            }
        }

        // Helper to get user's avg HP%
        const getUserAvgHp = (userId) => {
            for (const [guildId, guildUsers] of Object.entries(users)) {
                if (guildUsers[userId]?.defenseState) {
                    const defenseState = guildUsers[userId].defenseState;
                    let totalHp = 0, count = 0;
                    for (const [heroId, state] of Object.entries(defenseState)) {
                        if (state.maxHp > 0) {
                            totalHp += Math.round((state.hp / state.maxHp) * 100);
                            count++;
                        }
                    }
                    return count > 0 ? Math.round(totalHp / count) : 100;
                }
            }
            return '?';
        };

        // Correct direction mappings
        const highValuePositions = {
            1: 'Midtown',
            98: 'NE',      // SKULLMORE Northeast
            115: 'E',      // HELESS East
            126: 'SE',     // DRAKEMORE Southeast
            101: 'SW',     // JORIA Southwest
            112: 'W',      // MONBRIDGE West
            123: 'NW'      // VERDANT Northwest
        };

        let midtownLine = '';
        let eightCoinLines = [];

        for (const [posId, posName] of Object.entries(highValuePositions)) {
            const townData = townPositions[posId];
            if (townData && townData.status === 1 && townData.userId) {
                const isOurs = myGuildMemberIds.includes(String(townData.userId));
                const memberInfo = guildMembers[townData.userId];
                const playerName = memberInfo?.name || '???';
                const icon = isOurs ? '‚úÖ' : '‚ùå';
                const hpPct = getUserAvgHp(String(townData.userId));

                if (posId === '1') {
                    midtownLine = `üèõ ${playerName} ${icon} ${hpPct}%`;
                } else {
                    eightCoinLines.push(`${posName}: ${playerName} ${icon} ${hpPct}%`);
                }
            } else {
                if (posId === '1') {
                    midtownLine = `üèõ Empty ‚¨ú`;
                } else {
                    eightCoinLines.push(`${posName}: Empty ‚¨ú`);
                }
            }
        }

        // Castle info
        const castleLevel = castleInfo.castleLevel || 0;
        const castleExp = castleInfo.castleExp || 0;
        const levelMaxExp = castleInfo.levelMaxExp || 0;
        const toNextLevel = levelMaxExp - castleExp;

        const msg = `‚è∞ <b>AoC Status</b>

üèÜ #${myGuildRank} ${formatK(myGuild?.coins || 0)} (${guildLeadText})
‚ö° ${totalGuildCoins}/min | üìç ${myLocation}
üè∞ Lv${castleLevel} | ${formatK(castleExp)} (+${formatK(toNextLevel)} to next)

${midtownLine}
${eightCoinLines.join('\n')}`;

        await sendTelegramNotification(msg);
    } catch (error) {
        console.error('‚ùå AoC notification error:', error);
    }
}



(function () {
    'use strict';

    console.log(`HWH Tweaker v${TWEAKER_VERSION} loading...`);
    // Function to highlight active test battle button - optimized tracked version
    window.updateTestBattleHighlight = function() {
        const tracked = window._trackedButtons?.testBattle;
        if (!tracked || Object.keys(tracked).length === 0) {
            debugLog('‚ÑπÔ∏è No test battle buttons tracked');
            return false;
        }

        const valuesDetails = DOMCache.get('valuesDetails', 'details[data-name="values"]');
        if (!valuesDetails) return false;

        const testBattleInput = valuesDetails.querySelector('input[data-name="countTestBattle"]');
        if (!testBattleInput) return false;

        const currentValue = parseInt(testBattleInput.value);
        debugLog(`üéØ Test Battle: ${currentValue}`);

        // Only update tracked buttons - O(n) where n = number of test buttons (6), not all buttons
        Object.entries(tracked).forEach(([val, btn]) => {
            if (!btn || !document.contains(btn)) {
                delete tracked[val]; // Clean up stale references
                return;
            }
            const isActive = parseInt(val) === currentValue;
            btn.innerHTML = 'üéØ<span class="' + (isActive ? 'twk-gold-bold' : 'twk-dim') + '">' + val + '</span>';
        });

        return true;
    };
    // Function to highlight active titanite button - optimized tracked version
    window.updateTitaniteHighlight = function() {
        const tracked = window._trackedButtons?.titanite;
        if (!tracked || Object.keys(tracked).length === 0) {
            debugLog('‚ÑπÔ∏è No titanite buttons tracked');
            return false;
        }

        const valuesDetails = DOMCache.get('valuesDetails', 'details[data-name="values"]');
        if (!valuesDetails) return false;

        const titaniteInput = valuesDetails.querySelector('input[data-name="countTitanit"]');
        if (!titaniteInput) return false;

        const currentValue = parseInt(titaniteInput.value);
        debugLog(`‚ö° Titanite: ${currentValue}`);

        // Only update tracked buttons
        Object.entries(tracked).forEach(([val, btn]) => {
            if (!btn || !document.contains(btn)) {
                delete tracked[val];
                return;
            }
            const isActive = parseInt(val) === currentValue;
            btn.innerHTML = '‚ö°<span class="' + (isActive ? 'twk-gold-bold' : 'twk-dim') + '">' + val + '</span>';
        });

        return true;
    };

    // Prevent multiple instances
    if (window.hwhTweakerLoaded) {
        debugLog('HWH Tweaker already loaded - exiting');
        return;
    }
    window.hwhTweakerLoaded = true

    // Consolidated Send function getter - used throughout the script
    const getSend = () => HWHFuncs?.Send || window.Send || (typeof Send !== 'undefined' ? Send : null);

    // Shared fragment sell helper - used by Tab 5 and Collect More
    const executeFragmentSells = async (inventoryData, fragSellConfig) => {
        const SendFunction = getSend();
        if (!SendFunction) return { success: false, gold: 0, coins: {}, details: [], hasWork: false };

        const heroSoulMode = localStorage.getItem('hwh_hero_soul_mode') || 'gold';
        const titanSoulMode = localStorage.getItem('hwh_titan_soul_mode') || 'gold';
        const petSoulMode = localStorage.getItem('hwh_pet_soul_mode') || 'gold';

        const fragSources = {
            hero: inventoryData.fragmentHero || {},
            titan: inventoryData.fragmentTitan || {},
            pet: inventoryData.fragmentPet || {},
            artifact: inventoryData.fragmentArtifact || {},
            titanArtifact: inventoryData.fragmentTitanArtifact || {}
        };

        const sellCalls = [];
        const sellDetails = [];
        let heroSoulsToExchange = false;
        let titanSoulsToExchange = false;
        let petSoulsToExchange = false;

        Object.entries(fragSources).forEach(([type, fragments]) => {
            for (const [id, qty] of Object.entries(fragments)) {
                const settings = fragSellConfig[`${type}_${id}`];
                if (settings?.sell) {
                    const sellAmount = qty - (settings.keep || 0);
                    if (sellAmount > 0) {
                        const itemName = window.identifyItem?.(id, type) || `${type} #${id}`;
                        if (type === 'hero') {
                            if (heroSoulMode === 'coins') { heroSoulsToExchange = true; sellDetails.push(`${itemName}: ${sellAmount} ‚Üí Soul Coins`); }
                            else { sellCalls.push({ name: 'inventorySell', args: { type: 'hero', libId: id, amount: sellAmount, fragment: true }, ident: `sell_hero_${id}` }); sellDetails.push(`${itemName}: ${sellAmount} ‚Üí Gold`); }
                        } else if (type === 'titan') {
                            titanSoulsToExchange = true;
                            sellDetails.push(`${itemName}: ${sellAmount} ‚Üí ${titanSoulMode === 'gold' ? 'Gold' : 'Titan Coins'}`);
                        } else if (type === 'pet') {
                            if (petSoulMode === 'coins') { petSoulsToExchange = true; sellDetails.push(`${itemName}: ${sellAmount} ‚Üí Pet Coins`); }
                            else { sellCalls.push({ name: 'inventorySell', args: { type: 'pet', libId: id, amount: sellAmount, fragment: true }, ident: `sell_pet_${id}` }); sellDetails.push(`${itemName}: ${sellAmount} ‚Üí Gold`); }
                        } else {
                            sellCalls.push({ name: 'inventorySell', args: { type: type, libId: id, amount: sellAmount, fragment: true }, ident: `sell_${type}_${id}` });
                            sellDetails.push(`${itemName}: ${sellAmount}`);
                        }
                    }
                }
            }
        });

        const hasWork = sellCalls.length > 0 || heroSoulsToExchange || titanSoulsToExchange || petSoulsToExchange;
        if (!hasWork) return { success: true, gold: 0, coins: {}, details: [], hasWork: false, sellCount: 0 };

        let totalGold = 0;
        const totalCoins = {};

        if (heroSoulsToExchange) {
            debugLog('üíÄ Exchanging hero souls for Soul Coins...');
            try {
                const result = await SendFunction(JSON.stringify({ calls: [{ name: 'inventoryExchangeStones', args: {}, ident: 'ex' }] }));
                Object.entries(result?.results?.[0]?.result?.response?.reward?.coin || {}).forEach(([id, amt]) => { totalCoins[id] = (totalCoins[id] || 0) + amt; });
            } catch (e) { console.warn('Hero exchange error:', e); }
        }

        if (titanSoulsToExchange) {
            debugLog('‚ö° Exchanging titan souls...');
            try {
                const result = await SendFunction(JSON.stringify({ calls: [{ name: 'inventoryExchangeTitanStones', args: {}, ident: 'ex' }] }));
                let coinsGained = result?.results?.[0]?.result?.response?.reward?.coin?.[15] || 0;
                if (titanSoulMode === 'gold' && coinsGained > 0) {
                    debugLog('üî± Converting Titan Coins to gold...');
                    const shopResult = await SendFunction(JSON.stringify({ calls: [{ name: 'shopGetAll', args: {}, ident: 'shops' }] }));
                    const shops = shopResult?.results?.[0]?.result?.response;
                    if (shops?.[12]) {
                        let goldSlot = null, goldSlotId = null;
                        for (const slotId in shops[12].slots) {
                            const slot = shops[12].slots[slotId];
                            if (slot.reward?.gold && slot.cost?.coin?.[15] === 100) { goldSlot = slot; goldSlotId = parseInt(slotId); break; }
                        }
                        if (goldSlot) {
                            const invCheck = await SendFunction(JSON.stringify({ calls: [{ name: 'inventoryGet', args: {}, ident: 'inv' }] }));
                            const buyCount = Math.floor((invCheck?.results?.[0]?.result?.response?.coin?.[15] || 0) / 100);
                            if (buyCount > 0) {
                                const buyResult = await SendFunction(JSON.stringify({ calls: [{ name: 'shopBuy', args: { shopId: 12, slot: goldSlotId, cost: goldSlot.cost, reward: goldSlot.reward, amount: buyCount }, ident: 'buy' }] }));
                                if (!buyResult?.results?.[0]?.result?.error) { totalGold += buyCount * goldSlot.reward.gold; debugLog(`ü™ô Converted ${buyCount * 100} Titan Coins ‚Üí ${(buyCount * goldSlot.reward.gold).toLocaleString()} gold`); }
                            }
                        }
                    }
                } else if (coinsGained > 0) { totalCoins['15'] = (totalCoins['15'] || 0) + coinsGained; }
            } catch (e) { console.warn('Titan exchange error:', e); }
        }

        if (petSoulsToExchange) {
            debugLog('üêæ Exchanging pet souls for Pet Soul Coins...');
            try {
                const result = await SendFunction(JSON.stringify({ calls: [{ name: 'inventoryExchangePetStones', args: {}, ident: 'ex' }] }));
                Object.entries(result?.results?.[0]?.result?.response?.reward?.coin || {}).forEach(([id, amt]) => { totalCoins[id] = (totalCoins[id] || 0) + amt; });
            } catch (e) { console.warn('Pet exchange error:', e); }
        }

        if (sellCalls.length > 0) {
            debugLog('üíé Auto-selling', sellCalls.length, 'fragment types');
            try {
                const resp = await SendFunction(JSON.stringify({ calls: sellCalls }));
                resp?.results?.forEach(r => {
                    if (r?.result?.response?.gold) totalGold += r.result.response.gold;
                    Object.entries(r?.result?.response?.coin || {}).forEach(([id, amt]) => { totalCoins[id] = (totalCoins[id] || 0) + amt; });
                });
            } catch (e) { console.warn('Fragment sell error:', e); }
        }

        if (totalGold > 0) debugLog('üí∞ Fragment sell gold:', totalGold);
        Object.entries(totalCoins).forEach(([id, amt]) => debugLog(`ü™ô Fragment sell coin ${id}:`, amt));

        return { success: true, gold: totalGold, coins: totalCoins, details: sellDetails, hasWork: true, sellCount: sellCalls.length };
    };

    // ================================================================
    // DOM QUERY CACHE SYSTEM - Performance Optimization
    // ================================================================

    const DOMCache = {
        cache: {},
        stats: { hits: 0, misses: 0, clears: 0 },

        get(key, selector, forceRefresh = false) {
            if (!forceRefresh && this.cache[key] && document.contains(this.cache[key])) {
                this.stats.hits++;
                return this.cache[key];
            }
            this.stats.misses++;
            this.cache[key] = document.querySelector(selector);
            return this.cache[key];
        },

        getAll(key, selector, forceRefresh = false) {
            if (!forceRefresh && this.cache[key]) {
                this.stats.hits++;
                return this.cache[key];
            }
            this.stats.misses++;
            this.cache[key] = Array.from(document.querySelectorAll(selector));
            return this.cache[key];
        },

        clear(key) {
            this.stats.clears++;
            if (key) {
                delete this.cache[key];
            } else {
                this.cache = {};
            }
        },

        invalidate() {
            for (let key in this.cache) {
                if (Array.isArray(this.cache[key])) {
                    this.cache[key] = this.cache[key].filter(el => document.contains(el));
                    if (this.cache[key].length === 0) delete this.cache[key];
                } else if (this.cache[key] && !document.contains(this.cache[key])) {
                    delete this.cache[key];
                }
            }
        },

        getStats() {
            const hitRate = this.stats.hits + this.stats.misses > 0
            ? ((this.stats.hits / (this.stats.hits + this.stats.misses)) * 100).toFixed(1)
            : 0;
            return {
                ...this.stats,
                hitRate: `${hitRate}%`,
                cacheSize: Object.keys(this.cache).length
            };
        }
    };

    // Global functions for debugging
    window.DOMCache = DOMCache;
    window.clearDOMCache = (key) => DOMCache.clear(key);
    window.getDOMCacheStats = () => {
        const stats = DOMCache.getStats();
        debugLog('üìä DOM Cache Stats:', `Hit Rate: ${stats.hitRate}`, `Size: ${stats.cacheSize}`);
        return stats;
    };

    // Periodic cache cleanup (pauses when tab hidden)
    createSmartInterval(() => DOMCache.invalidate(), 120000, 'DOMCache cleanup');

    debugLog('‚úÖ DOM Cache system loaded');
    const ModuleTracker = {
        modules: [],
        startTime: performance.now(),
        loadTime: null,  // Store the actual load time

        register(name) {
            this.modules.push({ name: name, time: performance.now() });
        },

        summary() {
            // Store load time on first call, reuse it after
            if (this.loadTime === null) {
                this.loadTime = (performance.now() - this.startTime).toFixed(0);
            }
            const elapsed = this.loadTime;
            const count = this.modules.length;
            console.log(`‚úÖ HWH Tweaker v${TWEAKER_VERSION} loaded ${count} modules in ${elapsed}ms`);
            if (DEBUG_MODE) {
                debugLog('üì¶ Modules:', this.modules.map(m => m.name).join(', '));
            }
            return { count, elapsed: parseInt(elapsed), modules: this.modules.map(m => m.name) };
        }
    };

    window.ModuleTracker = ModuleTracker;
    window.showModuleStats = () => ModuleTracker.summary();
    ModuleTracker.register('DOM Cache');

    // Button tracking for value-based highlighting
    // Only populated when these buttons are actually rendered
    window._trackedButtons = {
        testBattle: {},  // { 1: btnElement, 10: btnElement, ... }
        titanite: {}     // { 150: btnElement, 300: btnElement, ... }
    };

    // ================================================================
    // AUTO-CLEANUP FOR OLD TOURNAMENT DATA
    // Add this near the top of your script (after line 100, with other utility functions)
    // This runs automatically on page load to keep storage clean
    // ================================================================

    window.cleanupOldTournamentData = function() {
        debugLog('üßπ Cleaning up old tournament data...');

        const ONE_WEEK_MS = TOURNAMENT_RETENTION_MS
        const now = Date.now();
        let cleanedItems = 0;
        let savedSpace = 0;


        // ============================================================
        // 1. Clean up tournament clan cache (keep only if < 1 week old)
        // ============================================================
        try {
            const clanCache = localStorage.getItem('hwh_power_tournament_clan_cache');
            if (clanCache) {
                const originalSize = clanCache.length;
                const parsed = JSON.parse(clanCache);

                if (parsed.timestamp) {
                    const age = now - parsed.timestamp;
                    const ageInDays = Math.floor(age / (24 * 60 * 60 * 1000));

                    if (age > ONE_WEEK_MS) {
                        // Cache is older than 1 week - delete it
                        localStorage.removeItem('hwh_power_tournament_clan_cache');
                        cleanedItems++;
                        savedSpace += originalSize;
                        debugLog(`  ‚úì Removed clan cache (${ageInDays} days old, ${(originalSize/1024).toFixed(1)} KB)`);
                    } else {
                        debugLog(`  ‚Ñπ Clan cache is ${ageInDays} days old - keeping it`);
                    }
                }
            }
        } catch (e) {
            console.warn('  ‚ö† Error cleaning clan cache:', e);
        }

        // ============================================================
        // 2. Clean up tournament history (keep only last 1 week)
        // ============================================================
        try {
            const historyData = localStorage.getItem('hwh_power_tournament_history');
            if (historyData) {
                const originalSize = historyData.length;
                const parsed = JSON.parse(historyData);

                if (Array.isArray(parsed)) {
                    const originalCount = parsed.length;

                    // Filter to keep only last 7 days
                    const filtered = parsed.filter(entry => {
                        if (entry.timestamp) {
                            return (now - entry.timestamp) < ONE_WEEK_MS;
                        }
                        return false;
                    });

                    const removedCount = originalCount - filtered.length;

                    if (removedCount > 0) {
                        // Save the filtered data
                        const newData = JSON.stringify(filtered);
                        localStorage.setItem('hwh_power_tournament_history', newData);
                        cleanedItems++;
                        savedSpace += (originalSize - newData.length);
                        debugLog(`  ‚úì Cleaned history: removed ${removedCount} old entries (saved ${((originalSize - newData.length)/1024).toFixed(1)} KB)`);
                    } else {
                        debugLog(`  ‚Ñπ All ${originalCount} history entries are within 1 week - keeping them`);
                    }
                }
            }
        } catch (e) {
            console.warn('  ‚ö† Error cleaning tournament history:', e);
        }

        // ============================================================
        // 3. Clean up Winterfest gift cache
        // ============================================================
        try {
            const winterfestCache = localStorage.getItem(WINTERFEST_GIFT_CACHE_KEY);
            if (winterfestCache) {
                const originalSize = winterfestCache.length;
                const parsed = JSON.parse(winterfestCache);

                if (parsed.timestamp) {
                    const maxAgeMs = WINTERFEST_CACHE_DAYS * 24 * 60 * 60 * 1000;
                    const age = now - parsed.timestamp;
                    const ageInDays = Math.floor(age / (24 * 60 * 60 * 1000));

                    if (age > maxAgeMs) {
                        localStorage.removeItem(WINTERFEST_GIFT_CACHE_KEY);
                        cleanedItems++;
                        savedSpace += originalSize;
                        debugLog(`  ‚úî Removed Winterfest cache (${ageInDays} days old, ${(originalSize/1024).toFixed(1)} KB)`);
                    } else {
                        debugLog(`  ‚Ñπ Winterfest cache is ${ageInDays} days old - keeping it`);
                    }
                }
            }
        } catch (e) {
            console.warn('  ‚ö† Error cleaning Winterfest cache:', e);
        }

        // ============================================================
        // 4. Clean up AoC history (keep only last 7 days)
        // ============================================================
        try {
            const aocHistory = localStorage.getItem('hwh_aoc_history');
            if (aocHistory) {
                const originalSize = aocHistory.length;
                const parsed = JSON.parse(aocHistory);

                if (Array.isArray(parsed)) {
                    const AOC_RETENTION_MS = 7 * 24 * 60 * 60 * 1000;
                    const originalCount = parsed.length;

                    const filtered = parsed.filter(entry =>
                                                   entry.timestamp && (now - entry.timestamp) < AOC_RETENTION_MS
                                                  );

                    const removedCount = originalCount - filtered.length;

                    if (removedCount > 0) {
                        const newData = JSON.stringify(filtered);
                        localStorage.setItem('hwh_aoc_history', newData);
                        cleanedItems++;
                        savedSpace += (originalSize - newData.length);
                        debugLog(`  ‚úî Cleaned AoC history: removed ${removedCount} old entries (saved ${((originalSize - newData.length)/1024).toFixed(1)} KB)`);
                    } else {
                        debugLog(`  ‚Ñπ All ${originalCount} AoC entries are within 7 days - keeping them`);
                    }
                }
            }
        } catch (e) {
            console.warn('  ‚ö† Error cleaning AoC history:', e);
        }

        // ============================================================
        // Summary
        // ============================================================
        if (cleanedItems > 0) {
            debugLog(`‚úÖ Cleanup complete: ${cleanedItems} item(s) cleaned, freed ${(savedSpace/1024).toFixed(1)} KB`);
        } else {
            debugLog('‚úÖ No cleanup needed - all tournament data is current');
        }

        return {
            cleanedItems,
            savedSpace
        };
    };
    // ================================================================
    // COMPLETE BACKUP/RESTORE SYSTEM FOR HWH TWEAKER & HELPER
    // This version backs up EVERYTHING including:
    // - localStorage (Tweaker settings)
    // - GM_getValue (Button editor, arena stats)
    // - Dynamic adventure paths
    // ================================================================

    // Static localStorage keys
    const TWEAKER_KEYS = [
        'hwh_tweaker_item_cache',
        'hwh_collect_settings',
        'hwh_ui_settings',
        'hwh_inventory_tab1_checked',
        'hwh_inventory_tab2_checked',
        'hwh_custom_functions',
        'hwh_favorite_functions',
        'hwh_tweaker_delay_factor',
        'hwh_collect_more_prefs',
        'hwh_clan_prestige_data',
        'hwh_battle_pass_data',
        'hwh_power_tournament_history',
        'hwh_power_tournament_clan_cache',
        'hwh_castle_user_exp',
        'hwh_castle_usernames',
        'hwh_aoc_position_names',
        'hwh_autorefresh_interval',
        'hwh_chat_sidebar_width',
        'hwh_sidebar_width',
        'hwh_lastRankingServer',
        'hwh_last_consumable_scan',
        'hwh_member_sort_mode',
        'hwh_recent_user_ids',
        // Arena stats (built into Tweaker sidebar)
        'hwh_arena_battle_history',
        'hwh_grand_battle_history',
        'hw_UserId',
        'hwh_inventory_tab2_checked',
        'hwh_fragment_sell_settings',
        // Tab 6 Craft Manager
        'hwh_craft_targets',
        'hwh_craft_color_filter',
        'hwh_craft_sort_col',
        'hwh_craft_sort_dir',
        'hwh_hero_excluded',
        'hwh_hero_soul_mode',
        'hwh_titan_soul_mode',
        'hwh_pet_soul_mode'
    ];

    const HELPER_KEY = 'scriptMenu_saveOption';

    // GM_getValue keys (Tampermonkey storage)
    const GM_KEYS = [
        'hwh_button_customizations'   // Button editor customizations
    ];

    // Backup EVERYTHING
    window.backupTweakerSettings = function() {
        try {
            const backup = {
                version: TWEAKER_VERSION,
                timestamp: new Date().toISOString(),
                tweaker: {},
                helper: null,
                adventurePaths: {},
                gmData: {}
            };

            // 1. Backup static Tweaker localStorage keys
            TWEAKER_KEYS.forEach(key => {
                const value = localStorage.getItem(key);
                if (value !== null) {
                    backup.tweaker[key] = value;
                }
            });

            // 2. Backup Helper settings
            const helperSettings = localStorage.getItem(HELPER_KEY);
            if (helperSettings) {
                backup.helper = helperSettings;
            }

            // 3. Backup ALL adventure custom paths (dynamic keys)
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('adventureCustomPaths:')) {
                    backup.adventurePaths[key] = localStorage.getItem(key);
                }
            });

            // 4. Backup GM_getValue data (button editor, arena stats)
            if (typeof GM_getValue !== 'undefined') {
                GM_KEYS.forEach(key => {
                    try {
                        const value = GM_getValue(key);
                        if (value !== undefined && value !== null) {
                            backup.gmData[key] = value;
                        }
                    } catch (e) {
                        console.warn(`Could not backup GM key ${key}:`, e);
                    }
                });
            }

            const json = JSON.stringify(backup, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `HWH_Complete_Backup_${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            const tweakerCount = Object.keys(backup.tweaker).length;
            const pathsCount = Object.keys(backup.adventurePaths).length;
            const gmCount = Object.keys(backup.gmData).length;

            debugLog(`‚úÖ Complete backup created:`);
            debugLog(`   ${tweakerCount} Tweaker settings`);
            debugLog(`   ${pathsCount} Adventure paths`);
            debugLog(`   ${gmCount} GM data items`);
            debugLog(`   ${backup.helper ? '1' : '0'} Helper settings`);

            alert(`‚úÖ Complete backup saved!\n\n` +
                  `${tweakerCount} Tweaker settings\n` +
                  `${pathsCount} Adventure paths\n` +
                  `${gmCount} Button/Arena data\n` +
                  `${backup.helper ? '1' : '0'} Helper settings`);

            return backup;
        } catch (e) {
            console.error('‚ùå Backup failed:', e);
            alert('‚ùå Backup failed: ' + e.message);
            return null;
        }
    };

    // Restore settings from backup
    window.restoreTweakerSettings = function(backupData) {
        try {
            let data;
            if (typeof backupData === 'string') {
                data = JSON.parse(backupData);
            } else {
                data = backupData;
            }

            let tweakerCount = 0;
            let helperRestored = false;
            let pathsCount = 0;
            let gmCount = 0;

            // 1. Restore Tweaker settings
            if (data.tweaker) {
                Object.entries(data.tweaker).forEach(([key, value]) => {
                    localStorage.setItem(key, value);
                    tweakerCount++;
                });
            }

            // 2. Restore Helper settings
            if (data.helper) {
                localStorage.setItem(HELPER_KEY, data.helper);
                helperRestored = true;
            }

            // 3. Restore Adventure paths
            if (data.adventurePaths) {
                Object.entries(data.adventurePaths).forEach(([key, value]) => {
                    localStorage.setItem(key, value);
                    pathsCount++;
                });
            }

            // 4. Restore GM data
            if (data.gmData && typeof GM_setValue !== 'undefined') {
                Object.entries(data.gmData).forEach(([key, value]) => {
                    try {
                        GM_setValue(key, value);
                        gmCount++;
                    } catch (e) {
                        console.warn(`Could not restore GM key ${key}:`, e);
                    }
                });
            }

            debugLog(`‚úÖ Restored:`);
            debugLog(`   ${tweakerCount} Tweaker settings`);
            debugLog(`   ${pathsCount} Adventure paths`);
            debugLog(`   ${gmCount} GM data items`);
            debugLog(`   ${helperRestored ? 1 : 0} Helper settings`);

            alert(`‚úÖ Settings restored!\n\n` +
                  `${tweakerCount} Tweaker settings\n` +
                  `${pathsCount} Adventure paths\n` +
                  `${gmCount} Button/Arena data\n` +
                  `${helperRestored ? '1' : '0'} Helper settings\n\n` +
                  `Please reload the page.`);

            return true;
        } catch (e) {
            console.error('‚ùå Restore failed:', e);
            alert('‚ùå Restore failed: ' + e.message);
            return false;
        }
    };

    // Restore from file upload
    window.restoreFromFile = function() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';

        input.onchange = function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const data = JSON.parse(event.target.result);
                    window.restoreTweakerSettings(data);
                } catch (err) {
                    alert('‚ùå Invalid backup file: ' + err.message);
                }
            };
            reader.readAsText(file);
        };

        input.click();
    };

    // Quick backup to clipboard
    window.backupToClipboard = function() {
        try {
            const backup = {
                version: TWEAKER_VERSION,
                timestamp: new Date().toISOString(),
                tweaker: {},
                helper: null,
                adventurePaths: {},
                gmData: {}
            };

            TWEAKER_KEYS.forEach(key => {
                const value = localStorage.getItem(key);
                if (value !== null) {
                    backup.tweaker[key] = value;
                }
            });

            const helperSettings = localStorage.getItem(HELPER_KEY);
            if (helperSettings) {
                backup.helper = helperSettings;
            }

            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('adventureCustomPaths:')) {
                    backup.adventurePaths[key] = localStorage.getItem(key);
                }
            });

            if (typeof GM_getValue !== 'undefined') {
                GM_KEYS.forEach(key => {
                    try {
                        const value = GM_getValue(key);
                        if (value !== undefined && value !== null) {
                            backup.gmData[key] = value;
                        }
                    } catch (e) {
                        console.warn(`Could not backup GM key ${key}:`, e);
                    }
                });
            }

            const json = JSON.stringify(backup);

            navigator.clipboard.writeText(json).then(() => {
                const size = (json.length / 1024).toFixed(1);
                const pathsCount = Object.keys(backup.adventurePaths).length;
                const gmCount = Object.keys(backup.gmData).length;
                alert(`‚úÖ Complete backup copied to clipboard!\n\nSize: ${size} KB\n` +
                      `${pathsCount} Adventure paths\n${gmCount} Button/Arena data\n\n` +
                      `Paste this somewhere safe.`);
                debugLog('‚úÖ Complete backup copied to clipboard');
            }).catch(err => {
                console.error('Clipboard copy failed:', err);
                alert('‚ùå Could not copy to clipboard. Use Download instead.');
            });
        } catch (e) {
            console.error('‚ùå Clipboard backup failed:', e);
            alert('‚ùå Backup failed: ' + e.message);
        }
    };

    // Restore from clipboard
    window.restoreFromClipboard = function() {
        navigator.clipboard.readText().then(text => {
            try {
                const data = JSON.parse(text);
                if (data.tweaker || data.helper || data.adventurePaths || data.gmData) {
                    window.restoreTweakerSettings(data);
                } else {
                    alert('‚ùå Invalid backup data in clipboard');
                }
            } catch (e) {
                alert('‚ùå Invalid backup format: ' + e.message);
            }
        }).catch(err => {
            console.error('Clipboard read failed:', err);
            alert('‚ùå Could not read clipboard. Use Upload instead.');
        });
    };

    ModuleTracker.register('Backup/Restore');


    // ================================================================
    // COMPLETE CLEAN ITEM IDENTIFICATION SYSTEM
    // ================================================================

    // Initialize cache with pre-filled common items
    unsafeWindow.itemNameCache = window.itemNameCache = {

        consumable: {},
        hero: {},
        titan: {},
        gear: {},
        scroll: {},
        coin: {},
        skill: {},
        titanArtifact: {},
        pet: {},
        artifact: {},
        skin: {},
        currency: {
            'coin': 'ü™ô Gold',
            'gold': 'ü™ô Gold',
            'starmoney': 'üíé Emeralds',
            'emerald': 'üíé Emeralds',
            'titanite': '‚ö° Titanite',
            'honor': 'üéñÔ∏è Honor',
            'friendship': 'ü§ù Friendship Coins',
            'arena': '‚öîÔ∏è Arena Coins',
            'tower': 'üè∞ Tower Coins',
            'grand': 'üåü Grand Coins',
            'outland': 'üåã Outland Coins',
            'adventure': 'üó∫Ô∏è Adventure Coins',
            'exp': '‚≠ê Experience',
            'energy': 'üîã Energy'
        }
    };

    // Translation key mappings for cheats.translate()
    const TRANSLATION_KEYS = {
        hero: 'LIB_HERO_NAME_',
        titan: 'LIB_HERO_NAME_',
        gear: 'LIB_GEAR_NAME_',
        scroll: 'LIB_SCROLL_NAME_',
        consumable: 'LIB_CONSUMABLE_NAME_',
        coin: 'LIB_COIN_NAME_',
        skill: 'LIB_SKILL_',
        titanArtifact: 'LIB_TITAN_ARTIFACT_NAME_',
        fragmentTitanArtifact: 'LIB_TITAN_ARTIFACT_NAME_',
        fragmentTitanArtifactWithBoost: 'LIB_TITAN_ARTIFACT_NAME_',
        fragmentPet: 'LIB_HERO_NAME_',
        ascensionGear: 'LIB_ASCENSION_GEAR_NAME_',
        banner: 'LIB_BANNER_NAME_',
        bannerStone: 'LIB_BANNER_STONE_NAME_',
        petGear: 'LIB_PET_GEAR_NAME_',
        avatar: 'LIB_AVATAR_NAME_',
        avatarFrame: 'LIB_AVATAR_FRAME_NAME_',
        pet: 'LIB_HERO_NAME_',
        artifact: 'LIB_ARTIFACT_NAME_',
        fragmentSkin: 'SKIN_LOOKUP',  // Special - needs lib.data.skin lookup
        fragmentHero: 'LIB_HERO_NAME_'
    };
    // Save/Load functions
    window.loadSavedItemCache = function() {
        try {
            const saved = localStorage.getItem('hwh_tweaker_item_cache');
            if (saved) {
                const cache = JSON.parse(saved);
                Object.keys(cache).forEach(category => {
                    if (window.itemNameCache[category]) {
                        Object.assign(window.itemNameCache[category], cache[category]);
                    }
                });
                const totalLoaded = Object.values(cache).reduce((sum, cat) =>
                                                                sum + (typeof cat === 'object' ? Object.keys(cat).length : 0), 0);
                debugLog(`üìö Loaded ${totalLoaded} saved item names from cache`);
            }
        } catch (e) {
            console.warn('Could not load saved item cache:', e);
        }
    };

    window.saveItemCache = function() {
        try {
            localStorage.setItem('hwh_tweaker_item_cache', JSON.stringify(window.itemNameCache));
            debugLog('üíæ Item cache saved successfully');
        } catch (e) {
            console.warn('Could not save item cache:', e);
        }
    };

    window.addItemToCache = function(type, id, name) {
        if (!window.itemNameCache[type]) {
            window.itemNameCache[type] = {};
        }
        window.itemNameCache[type][id] = name;
        debugLog(`‚úÖ Added ${type} #${id}: ${name}`);
        window.saveItemCache();
    };

    // Helper function to extract quantity from complex objects
    window.extractQuantityFromObject = function(obj) {
        if (typeof obj === 'number') {
            return obj;
        }

        if (typeof obj !== 'object' || obj === null) {
            return 1;
        }

        // Try common quantity property names
        const quantityProps = ['quantity', 'count', 'amount', 'value', 'num', 'qty'];
        for (const prop of quantityProps) {
            if (obj[prop] && typeof obj[prop] === 'number') {
                return obj[prop];
            }
        }

        // Try to find any numeric property
        const values = Object.values(obj);
        const numericValue = values.find(v => typeof v === 'number' && v > 0);
        if (numericValue) {
            return numericValue;
        }

        // If object has nested structure, try to extract from first level
        for (const key in obj) {
            if (typeof obj[key] === 'object' && obj[key] !== null) {
                const nested = window.extractQuantityFromObject(obj[key]);
                if (nested > 1) {
                    return nested;
                }
            }
        }

        return 1; // Default fallback
    };

    // Main identification function using cheats.translate()
    unsafeWindow.identifyItem = window.identifyItem = function(itemId, itemType = 'consumable') {
        // Check cache first
        if (window.itemNameCache[itemType]?.[itemId]) {
            return window.itemNameCache[itemType][itemId];
        }

        // Try cheats.translate() if available
        if (typeof cheats !== 'undefined' && cheats.translate) {
            const prefix = TRANSLATION_KEYS[itemType];
            if (prefix) {
                const key = prefix + itemId;
                const name = cheats.translate(key);

                // Check if we got a real translation (not the key back)
                if (name && name !== key) {
                    window.addItemToCache(itemType, itemId, name);
                    return name;
                }
            }
        }

        // Fallback: try lib.data.inventoryItem if available (for coins, bannerStones, etc.)
        if (typeof lib !== 'undefined' && lib.data?.inventoryItem?.[itemType]?.[itemId]) {
            const item = lib.data.inventoryItem[itemType][itemId];
            let name = null;
            if (item.localeKey) {
                name = cheats.translate(item.localeKey);
            } else if (item.name_localeKey) {
                name = cheats.translate(item.name_localeKey);
            }
            if (!name || name.startsWith('LIB_')) {
                name = item.label?.en || item.name?.en || item.label || item.name;
            }
            if (name && !name.startsWith('#LIB_') && !name.startsWith('LIB_')) {
                window.addItemToCache(itemType, itemId, name);
                return name;
            }
        }

        // Fallback: try lib.data if available (for skins, etc.)
        if (typeof lib !== 'undefined' && lib.data?.[itemType]?.[itemId]) {
            const item = lib.data[itemType][itemId];
            // Try localeKey first (for skins), then name_localeKey, then label/name
            let name = null;
            if (item.localeKey) {
                name = cheats.translate(item.localeKey);
            } else if (item.name_localeKey) {
                name = cheats.translate(item.name_localeKey);
            }
            if (!name || name.startsWith('LIB_')) {
                name = item.label?.en || item.name?.en || item.label || item.name;
            }
            if (name && !name.startsWith('#LIB_') && !name.startsWith('LIB_')) {
                window.addItemToCache(itemType, itemId, name);
                return name;
            }
        }

        // Final fallback
        return `${itemType} #${itemId}`;
    };


    // Populate cache with known items
    unsafeWindow.populateKnownItems = window.populateKnownItems = function() {
        debugLog('üîç Populating known items...');

        if (typeof cheats === 'undefined' || !cheats.translate) {
            debugLog('cheats.translate not available - skipping population');
            return;
        }

        // Check if lib and lib.data are available
        if (typeof lib === 'undefined' || !lib.data || !lib.getData) {
            debugLog('lib.data not ready yet - skipping population');
            return;
        }

        // Get inventoryItem data
        let itemData;
        try {
            itemData = lib.getData('inventoryItem');
        } catch (e) {
            debugLog('lib.getData failed - lib not fully initialized:', e.message);
            return;
        }

        if (itemData) {
            // Populate gear
            if (itemData.gear) {
                Object.keys(itemData.gear).forEach(id => {
                    const name = cheats.translate(`LIB_GEAR_NAME_${id}`);
                    if (name && name !== `LIB_GEAR_NAME_${id}`) {
                        window.itemNameCache.gear[id] = name;
                    }
                });
            }

            // Populate scrolls
            if (itemData.scroll) {
                Object.keys(itemData.scroll).forEach(id => {
                    const name = cheats.translate(`LIB_SCROLL_NAME_${id}`);
                    if (name && name !== `LIB_SCROLL_NAME_${id}`) {
                        window.itemNameCache.scroll[id] = name;
                    }
                });
            }

            // Populate coins
            if (itemData.coin) {
                Object.keys(itemData.coin).forEach(id => {
                    const name = cheats.translate(`LIB_COIN_NAME_${id}`);
                    if (name && name !== `LIB_COIN_NAME_${id}`) {
                        window.itemNameCache.coin[id] = name;
                    }
                });
            }
        }

        // Populate common heroes (including titans in 6000+ range)
        const heroIds = [
            // Regular heroes
            ...Array.from({length: 68}, (_, i) => i + 1),
            // Titans
            ...Array.from({length: 10}, (_, i) => i + 6000)
        ];

        heroIds.forEach(id => {
            const name = cheats.translate(`LIB_HERO_NAME_${id}`);
            if (name && name !== `LIB_HERO_NAME_${id}`) {
                if (id >= 6000) {
                    window.itemNameCache.titan[id] = name;
                } else {
                    window.itemNameCache.hero[id] = name;
                }
            }
        });

        debugLog('‚úÖ Cache populated:', {
            gear: Object.keys(window.itemNameCache.gear).length,
            scroll: Object.keys(window.itemNameCache.scroll).length,
            hero: Object.keys(window.itemNameCache.hero).length,
            titan: Object.keys(window.itemNameCache.titan).length,
            coin: Object.keys(window.itemNameCache.coin).length
        });

        window.saveItemCache();
    };

    // Enhanced reward parser
    window.parseRewardResponse = function(response) {
        const rewards = [];

        if (!response) return rewards;

        // Parse currencies
        ['gold', 'starmoney', 'emerald', 'energy', 'exp'].forEach(currency => {
            if (response[currency] && response[currency] > 0) {
                const name = window.itemNameCache.currency[currency] || currency;
                rewards.push({
                    type: 'currency',
                    id: currency,
                    name: name,
                    quantity: response[currency],
                    display: `${name} x${response[currency].toLocaleString()}`
                });
            }
        });

        // Parse coin (special handling - it's an object like {"9":"200"})
        if (response.coin && typeof response.coin === 'object') {
            Object.entries(response.coin).forEach(([coinId, amount]) => {
                const qty = parseInt(amount) || 0;
                if (qty > 0) {
                    const name = window.identifyItem?.(coinId, 'coin') || `Coin #${coinId}`;
                    rewards.push({
                        type: 'coin',
                        id: coinId,
                        name: name,
                        quantity: qty,
                        display: `üí∞ ${name} x${qty.toLocaleString()}`
                    });
                }
            });
        }
        // Parse items with quantities
        const itemTypes = [
            { key: 'consumable', icon: 'üì¶' },
            { key: 'gear', icon: '‚öôÔ∏è' },
            { key: 'scroll', icon: 'üìú' },
            { key: 'fragmentGear', icon: 'üîß', suffix: ' (Frag)' },
            { key: 'fragmentScroll', icon: 'üìú', suffix: ' (Frag)' },
            { key: 'heroFragment', icon: 'üë§', suffix: ' (SS)' },
            { key: 'fragmentHero', icon: 'üë§', suffix: ' (SS)' },
            { key: 'titanFragment', icon: '‚ö°', suffix: ' (SS)' },
            { key: 'fragmentTitan', icon: '‚ö°', suffix: ' (SS)' },
            { key: 'ascensionGear', icon: 'üíç', suffix: ' (Asc)' }
        ];

        itemTypes.forEach(({ key, icon, suffix }) => {
            if (response[key]) {
                Object.entries(response[key]).forEach(([itemId, quantity]) => {
                    // Extract quantity from object if needed
                    if (typeof quantity === 'object') {
                        quantity = quantity.quantity || quantity.count || quantity.amount || 1;
                    }

                    // Determine base type for identification
                    let baseType = key.replace('fragment', '').toLowerCase();
                    if (key.includes('Fragment')) {
                        baseType = key.replace('Fragment', '');
                    }
                    if (key.includes('Hero')) baseType = 'hero';
                    if (key.includes('Titan')) baseType = 'titan';

                    let itemName = window.identifyItem(itemId, baseType);
                    if (suffix) {
                        itemName = `${itemName}${suffix}`;
                    }

                    rewards.push({
                        type: key,
                        id: itemId,
                        name: itemName,
                        quantity: parseInt(quantity) || 0,
                        display: `${icon} ${itemName} x${quantity}`
                    });
                });
            }
        });

        return rewards;
    };

    // Initialize on load
    (function initializeItemCache() {
        debugLog('üöÄ Initializing item cache...');

        // Load saved cache first
        window.loadSavedItemCache();

        // Populate from cheats.translate as soon as game is ready
        waitForGameReady().then(() => window.populateKnownItems());

        ModuleTracker.register('Item Cache');
    })();

    // ================================================================
    // CONSUMABLE NAME SCANNER & UPDATER
    // ================================================================

    window.scanAndUpdateConsumables = function(maxId = 700) {
        debugLog(`üîç Scanning consumable IDs from 1 to ${maxId}...`);

        if (typeof cheats === 'undefined' || !cheats.translate) {
            alert('‚ùå Game not fully loaded yet. Wait a moment and try again.');
            return;
        }

        let foundCount = 0;
        let updatedCount = 0;

        for (let i = 1; i <= maxId; i++) {
            const key = `LIB_CONSUMABLE_NAME_${i}`;

            try {
                const name = cheats.translate(key);

                // If translation exists and isn't just the key itself
                if (name && name !== key && !name.startsWith('LIB_') && name !== "") {
                    foundCount++;

                    // Check if we need to update the cache
                    const cachedName = window.itemNameCache.consumable[i];
                    if (!cachedName || cachedName.startsWith('consumable #')) {
                        window.addItemToCache('consumable', i, name);
                        updatedCount++;
                        debugLog(`‚úÖ Added/Updated #${i}: ${name}`);
                    } else if (cachedName !== name) {
                        // Name in cache doesn't match translation
                        debugLog(`‚ö†Ô∏è  #${i}: Cache="${cachedName}" vs Game="${name}"`);
                        // Update to game's version
                        window.addItemToCache('consumable', i, name);
                        updatedCount++;
                    }
                }
            } catch (e) {
                // Skip if translation fails
            }
        }

        debugLog(`\nüìä Scan complete:`);
        debugLog(`   Found: ${foundCount} consumables`);
        debugLog(`   Updated: ${updatedCount} items`);
        debugLog(`   Cache now has: ${Object.keys(window.itemNameCache.consumable).length} entries`);

        alert(`‚úÖ Consumable scan complete!\n\nFound: ${foundCount} items\nUpdated: ${updatedCount} names\n\nCache now contains ${Object.keys(window.itemNameCache.consumable).length} consumable names.`);
    };

    // Smart auto-scan on load - runs as soon as game is ready
    waitForGameReady().then(() => {
        const cacheSize = Object.keys(window.itemNameCache.consumable).length;
        const lastScan = localStorage.getItem('hwh_last_consumable_scan');
        const daysSinceLastScan = lastScan ? (Date.now() - parseInt(lastScan)) / (1000 * 60 * 60 * 24) : 999;

        if (cacheSize < 50 || daysSinceLastScan > 7) {
            debugLog('üîç Auto-scanning consumables (cache needs update)...');
            window.scanAndUpdateConsumables(700);
            localStorage.setItem('hwh_last_consumable_scan', Date.now().toString());
        } else {
            debugLog(`‚úÖ Consumable cache OK (${cacheSize} items, last scan ${daysSinceLastScan.toFixed(1)} days ago)`);
        }
    });

    ModuleTracker.register('Consumable Scanner');

    // ================================================================
    // INVENTORY MANAGEMENT SYSTEM - CONSUMABLES
    // ================================================================

    window.showInventoryManager = async function() {
        debugLog('üì¶ Opening Inventory Manager (Consumables)...');

        // Make API call to get fresh inventory data
        let inventoryData = null;
        try {
            const data = {
                calls: [{
                    name: "inventoryGet",
                    args: {},
                    ident: "inventoryGet"
                }]
            };

            const SendFunction = getSend();
            const response = await SendFunction(JSON.stringify(data));

            debugLog('üì¶ Inventory API response:', response);

            if (response && response.results && response.results[0]) {
                const result = response.results[0];
                if (result.result && result.result.response) {
                    inventoryData = result.result.response;
                }
            }

            if (!inventoryData || !inventoryData.consumable) {
                alert('‚ùå Inventory data not available. Please refresh the game and try again.');
                return;
            }

            debugLog('‚úÖ Loaded inventory data:', Object.keys(inventoryData.consumable).length, 'consumable types');

        } catch (e) {
            console.error('Failed to get inventory data:', e);
            alert('‚ùå Error accessing inventory data: ' + e.message);
            return;
        }

        // Load saved checked items FIRST (before cache building)
        let tab1CheckedItems = {};
        let tab2CheckedItems = {};
        let tab2AutoItems = {};
        try {
            const saved1 = localStorage.getItem('hwh_inventory_tab1_checked');
            const saved2 = localStorage.getItem('hwh_inventory_tab2_checked');
            const saved2Auto = localStorage.getItem('hwh_inventory_tab2_auto');
            if (saved1) tab1CheckedItems = JSON.parse(saved1);
            if (saved2) tab2CheckedItems = JSON.parse(saved2);
            if (saved2Auto) tab2AutoItems = JSON.parse(saved2Auto);
        } catch (e) {
            console.warn('Could not load checked items:', e);
        }

        // Load fragment sell settings
        let fragmentSellSettings = {};
        try {
            const savedFragments = localStorage.getItem('hwh_fragment_sell_settings');
            if (savedFragments) fragmentSellSettings = JSON.parse(savedFragments);
        } catch (e) {
            console.warn('Could not load fragment settings:', e);
        }

        const saveFragmentSettings = () => {
            try {
                localStorage.setItem('hwh_fragment_sell_settings', JSON.stringify(fragmentSellSettings));
            } catch (e) {
                console.warn('Could not save fragment settings:', e);
            }
        };
        // Hero soul sell mode: 'gold' or 'coins'
        let heroSoulMode = localStorage.getItem('hwh_hero_soul_mode') || 'gold';
        let titanSoulMode = localStorage.getItem('hwh_titan_soul_mode') || 'gold';
        let petSoulMode = localStorage.getItem('hwh_pet_soul_mode') || 'gold';

        // Cache loot box choice data for all known consumables
        window._lootBoxCache = {};
        const allItemIds = new Set([
            ...Object.keys(inventoryData.consumable),
            ...Object.keys(window.itemNameCache?.consumable || {}),
            ...Object.keys(tab1CheckedItems),
            ...Object.keys(tab2CheckedItems)
        ]);
        allItemIds.forEach(itemId => {
            const itemData = lib?.data?.inventoryItem?.consumable?.[itemId];
            const effectDesc = itemData?.effectDescription;
            if (effectDesc?.playerChoice === true && effectDesc?.lootBox) {
                const drops = lib?.data?.lootBox?.[effectDesc.lootBox]?.dropTable_client?.drop;
                if (drops && drops.length > 1) {
                    window._lootBoxCache[itemId] = {
                        hasChoice: true,
                        drops: drops.map((dropItem, idx) => {
                            const reward = dropItem?.reward || {};
                            const rewardType = Object.keys(reward)[0];
                            const rewardData = reward[rewardType];
                            let label = `Option ${idx + 1}`;

                            // Handle direct value rewards (gold, starmoney, etc.)
                            if (typeof rewardData === 'number') {
                                const currencyNames = {
                                    gold: 'Gold',
                                    starmoney: 'Emeralds',
                                    energy: 'Energy',
                                    stamina: 'Stamina'
                                };
                                label = `${currencyNames[rewardType] || rewardType} (${rewardData.toLocaleString()})`;
                            } else if (rewardType === 'bundleHeroReward') {
                                // bundleHeroReward contains nested hero/titan/skin data
                                const bundleId = Object.keys(rewardData)[0];
                                const bundleInfo = lib?.data?.bundleHeroReward?.[bundleId];
                                if (bundleInfo?.reward?.id) {
                                    const rewardId = bundleInfo.reward.id;
                                    const bundleType = bundleInfo.type;

                                    if (bundleType === 'skin') {
                                        // Skin reward - use localeKey from skin data
                                        const skinData = lib?.data?.skin?.[rewardId];
                                        if (skinData?.localeKey) {
                                            const skinName = cheats.translate(skinData.localeKey) || `Skin #${rewardId}`;
                                            label = `${skinName}`;
                                        } else {
                                            label = `Skin #${rewardId}`;
                                        }
                                    } else {
                                        // Hero/Titan summon reward
                                        const heroName = window.identifyItem?.(rewardId, rewardId >= 4000 ? 'titan' : 'hero') || `Hero #${rewardId}`;
                                        const star = bundleInfo.reward.star || '?';
                                        label = `${heroName} (${star}‚≠ê)`;
                                    }
                                }
                            } else if (rewardData && typeof rewardData === 'object') {
                                const rewardId = Object.keys(rewardData)[0];
                                const rewardQty = rewardData[rewardId];
                                if (rewardId) {
                                    if (rewardType === 'fragmentTitan') {
                                        label = (window.identifyItem?.(rewardId, 'titan') || `Titan #${rewardId}`) + ` (${rewardQty})`;
                                    } else if (rewardType === 'fragmentHero') {
                                        label = (window.identifyItem?.(rewardId, 'hero') || `Hero #${rewardId}`) + ` (${rewardQty})`;
                                    } else if (rewardType === 'fragmentPet') {
                                        label = (window.identifyItem?.(rewardId, 'pet') || `Pet #${rewardId}`) + ` (${rewardQty})`;
                                    } else {
                                        label = (window.identifyItem?.(rewardId, rewardType) || `${rewardType} #${rewardId}`) + ` (${rewardQty})`;
                                    }
                                }
                            }
                            return { idx, label };
                        })
                    };
                }
            }
        });
        debugLog('‚úÖ Cached loot box data for', Object.keys(window._lootBoxCache).length, 'choice items');

        const saveTab1Checked = () => {
            try {
                localStorage.setItem('hwh_inventory_tab1_checked', JSON.stringify(tab1CheckedItems));
            } catch (e) {
                console.warn('Could not save tab1 checked items:', e);
            }
        };

        const saveTab2Checked = () => {
            try {
                localStorage.setItem('hwh_inventory_tab2_checked', JSON.stringify(tab2CheckedItems));
            } catch (e) {
                console.warn('Could not save tab2 checked items:', e);
            }
        };

        const saveTab2Auto = () => {
            try {
                localStorage.setItem('hwh_inventory_tab2_auto', JSON.stringify(tab2AutoItems));
            } catch (e) {
                console.warn('Could not save tab2 auto items:', e);
            }
        };

        // Create modal overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100000;
        backdrop-filter: blur(3px);
    `;

        // Create popup container
        const popup = document.createElement('div');
        popup.style.cssText = `
        background: linear-gradient(135deg, #2c2416 0%, #1a1510 100%);
        border: 3px solid #8b6914;
        border-radius: 12px;
        padding: 20px;
        width: 95%;
        max-width: 1000px;
        max-height: 85vh;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.9), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        display: flex;
        flex-direction: column;
    `;

        // Header
        const header = document.createElement('div');
        header.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 12px;
        border-bottom: 2px solid rgba(139, 105, 20, 0.5);
    `;

        const title = document.createElement('h2');
        title.textContent = 'üì¶ Inventory Manager';
        title.style.cssText = `
        color: #ffd700;
        margin: 0;
        font-size: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    `;

        const closeBtn = document.createElement('button');
        closeBtn.textContent = '‚úñ';
        closeBtn.style.cssText = `
        background: #d32f2f;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 6px 14px;
        font-size: 16px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.2s;
    `;
        closeBtn.onmouseover = () => closeBtn.style.background = '#b71c1c';
        closeBtn.onmouseout = () => closeBtn.style.background = '#d32f2f';
        closeBtn.onclick = () => document.body.removeChild(overlay);

        header.appendChild(title);
        header.appendChild(closeBtn);

        // Tab buttons
        const tabContainer = document.createElement('div');
        tabContainer.style.cssText = `
        display: flex;
        gap: 8px;
        margin-bottom: 15px;
    `;

        const tab1Btn = document.createElement('button');
        tab1Btn.textContent = 'Auto-Use All';
        tab1Btn.style.cssText = `
        flex: 1;
        background: #ff9800;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 12px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.2s;
    `;

        const tab2Btn = document.createElement('button');
        tab2Btn.textContent = 'Use Selected';
        tab2Btn.style.cssText = `
        flex: 1;
        background: rgba(139, 105, 20, 0.3);
        color: #ccc;
        border: none;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 12px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.2s;
    `;

        const tab3Btn = document.createElement('button');
        tab3Btn.textContent = 'Manage Lists';
        tab3Btn.style.cssText = `
        flex: 1;
        background: rgba(139, 105, 20, 0.3);
        color: #ccc;
        border: none;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 12px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.2s;
    `;

        const tab4Btn = document.createElement('button');
        tab4Btn.textContent = 'Import/Export';
        tab4Btn.style.cssText = `
        flex: 1;
        background: rgba(139, 105, 20, 0.3);
        color: #ccc;
        border: none;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 12px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.2s;
    `;

        const tab5Btn = document.createElement('button');
        tab5Btn.textContent = 'üíé Sell Stones & Art Frags';
        tab5Btn.style.cssText = `
        flex: 1;
        background: rgba(139, 105, 20, 0.3);
        color: #ccc;
        border: none;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 12px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.2s;
    `;

        const tab6Btn = document.createElement('button');
        tab6Btn.textContent = 'üî® Craft';
        tab6Btn.style.cssText = `
        flex: 1;
        background: rgba(139, 105, 20, 0.3);
        color: #ccc;
        border: none;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 12px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.2s;
    `;

        tabContainer.appendChild(tab1Btn);
        tabContainer.appendChild(tab2Btn);
        tabContainer.appendChild(tab3Btn);
        tabContainer.appendChild(tab4Btn);
        tabContainer.appendChild(tab5Btn);
        tabContainer.appendChild(tab6Btn);

        // Content container
        const contentContainer = document.createElement('div');
        contentContainer.style.cssText = `
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    `;

        // Footer
        const footer = document.createElement('div');
        footer.style.cssText = `
        margin-top: 12px;
        padding-top: 10px;
        border-top: 2px solid rgba(139, 105, 20, 0.5);
        color: #999;
        font-size: 10px;
        text-align: center;
    `;

        // ===== TAB 1: AUTO-USE ALL =====
        const renderTab1 = () => {
            contentContainer.innerHTML = '';

            const consumables = inventoryData.consumable || {};
            const inStockItems = Object.keys(tab1CheckedItems)
            .filter(id => consumables[id] > 0)
            .sort((a, b) => parseInt(a) - parseInt(b));

            const tab1Content = document.createElement('div');
            tab1Content.style.cssText = `
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex: 1;
        `;

            const useAllBtn = document.createElement('button');
            useAllBtn.textContent = 'üéØ Use All (with nesting)';
            useAllBtn.style.cssText = `
            background: #ff9800;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px;
            font-size: 13px;
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 12px;
            transition: all 0.2s;
        `;
            useAllBtn.onmouseover = () => useAllBtn.style.background = '#f57c00';
            useAllBtn.onmouseout = () => useAllBtn.style.background = '#ff9800';
            useAllBtn.onclick = () => useAllWithNesting(tab1CheckedItems);

            const scrollContent = document.createElement('div');
            scrollContent.style.cssText = `
            overflow-y: auto;
            flex: 1;
        `;

            if (inStockItems.length === 0) {
                scrollContent.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #999; font-size: 12px;">
                    No items in stock for auto-use.<br><br>
                    Go to "Manage Lists" tab to add items to this list.
                </div>
            `;
            } else {
                inStockItems.forEach(itemId => {
                    const quantity = consumables[itemId];
                    const itemName = window.identifyItem(itemId, 'consumable');

                    const row = document.createElement('div');
                    row.style.cssText = `
                        display: grid;
                        grid-template-columns: 70px 1fr 80px;
                        gap: 8px;
                        padding: 4px 8px;
                        border-bottom: 1px solid rgba(139, 105, 20, 0.2);
                        align-items: center;
                        font-size: 11px;
                        transition: background 0.2s;
                    `;
                    row.onmouseover = () => row.style.background = 'rgba(139, 105, 20, 0.1)';
                    row.onmouseout = () => row.style.background = 'transparent';

                    row.innerHTML = `
                        <div style="text-align: center; color: #999; font-family: monospace;">${itemId}</div>
                        <div class="twk-gold">${itemName}</div>
                        <div style="text-align: right; color: #4ae29a; font-weight: bold; font-family: monospace;">${quantity.toLocaleString()}</div>
                    `;

                    scrollContent.appendChild(row);
                });
            }

            tab1Content.appendChild(useAllBtn);
            tab1Content.appendChild(scrollContent);
            contentContainer.appendChild(tab1Content);

            footer.textContent = `Auto-Use: ${inStockItems.length} items in stock`;
        };
        // ===== TAB 2: USE SELECTED =====
        const renderTab2 = () => {
            contentContainer.innerHTML = '';

            const consumables = inventoryData.consumable || {};
            const inStockItems = Object.keys(tab2CheckedItems)
            .filter(id => {
                if (!consumables[id] || consumables[id] <= 0) return false;
                const cached = window._lootBoxCache?.[id];
                if (cached?.hasChoice) {
                    const savedChoice = localStorage.getItem(`hwh_lootbox_choice_${id}`);
                    if (savedChoice === 'wait' || savedChoice === null) return false;
                }
                return true;
            })
            .sort((a, b) => parseInt(a) - parseInt(b));

            const tab2Content = document.createElement('div');
            tab2Content.style.cssText = 'display: flex; flex-direction: column; overflow: hidden; flex: 1;';

            const useSelectedBtn = document.createElement('button');
            useSelectedBtn.textContent = 'üéØ Use Selected (no nesting)';
            useSelectedBtn.style.cssText = `
                background: #4a90e2;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 10px;
                font-size: 13px;
                cursor: pointer;
                font-weight: bold;
                margin-bottom: 12px;
                transition: all 0.2s;
            `;
            useSelectedBtn.onmouseover = () => useSelectedBtn.style.background = '#357abd';
            useSelectedBtn.onmouseout = () => useSelectedBtn.style.background = '#4a90e2';
            useSelectedBtn.onclick = () => useSelected(tab2CheckedItems);

            const scrollContent = document.createElement('div');
            scrollContent.style.cssText = 'overflow-y: auto; flex: 1;';

            if (inStockItems.length === 0) {
                scrollContent.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #999; font-size: 12px;">
                        No items selected for use.<br><br>
                        Go to "Manage Lists" tab to add items to this list.
                    </div>
                `;
            } else {
                // Header row
                const headerRow = document.createElement('div');
                headerRow.style.cssText = `
                    display: grid;
                    grid-template-columns: 50px 1fr 25px 100px 50px;
                    gap: 6px;
                    padding: 4px 8px;
                    background: rgba(139, 105, 20, 0.3);
                    border-radius: 6px;
                    margin-bottom: 6px;
                    font-size: 10px;
                    font-weight: bold;
                    color: #ffd700;
                `;
                headerRow.innerHTML = `
                    <div class="twk-center">ID</div>
                    <div>Item Name</div>
                    <div class="twk-center" title="Auto-use with Collect More">üîÑ</div>
                    <div class="twk-center">Choice</div>
                    <div class="twk-right">Qty</div>
                `;
                scrollContent.appendChild(headerRow);

                inStockItems.forEach(itemId => {
                    const quantity = consumables[itemId];
                    const itemName = window.identifyItem(itemId, 'consumable');
                    const cached = window._lootBoxCache?.[itemId];
                    const showDropdown = cached?.hasChoice;

                    const row = document.createElement('div');
                    row.style.cssText = `
                        display: grid;
                        grid-template-columns: 50px 1fr 25px 100px 50px;
                        gap: 6px;
                        padding: 4px 8px;
                        border-bottom: 1px solid rgba(139, 105, 20, 0.2);
                        align-items: center;
                        font-size: 11px;
                    `;
                    row.onmouseover = () => row.style.background = 'rgba(139, 105, 20, 0.1)';
                    row.onmouseout = () => row.style.background = 'transparent';

                    // ID cell
                    const idCell = document.createElement('div');
                    idCell.textContent = itemId;
                    idCell.style.cssText = 'text-align: center; color: #999; font-family: monospace; font-size: 10px;';
                    row.appendChild(idCell);

                    // Name cell
                    const nameCell = document.createElement('div');
                    nameCell.textContent = itemName;
                    nameCell.title = itemName;
                    nameCell.style.cssText = 'color: #ffd700; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;';
                    row.appendChild(nameCell);

                    // Auto checkbox cell
                    const autoCell = document.createElement('div');
                    autoCell.style.cssText = 'display: flex; justify-content: center;';
                    if (showDropdown) {
                        const autoCheck = document.createElement('input');
                        autoCheck.type = 'checkbox';
                        autoCheck.checked = tab2AutoItems[itemId] || false;
                        autoCheck.title = 'Include in Auto-Use All';
                        autoCheck.style.cssText = 'width: 14px; height: 14px; cursor: pointer;';
                        autoCheck.onchange = () => {
                            if (autoCheck.checked) {
                                tab2AutoItems[itemId] = true;
                            } else {
                                delete tab2AutoItems[itemId];
                            }
                            saveTab2Auto();
                        };
                        autoCell.appendChild(autoCheck);
                    } else {
                        autoCell.textContent = '-';
                        autoCell.style.color = '#555';
                    }
                    row.appendChild(autoCell);

                    // Choice dropdown cell
                    const choiceCell = document.createElement('div');
                    choiceCell.style.cssText = 'display: flex; justify-content: center;';
                    if (showDropdown) {
                        const select = document.createElement('select');
                        select.style.cssText = `
                            background: rgba(0,0,0,0.6);
                            color: #ffd700;
                            border: 1px solid rgba(139,105,20,0.6);
                            border-radius: 4px;
                            padding: 2px;
                            font-size: 10px;
                            width: 100%;
                            cursor: pointer;
                        `;

                        const waitOpt = document.createElement('option');
                        waitOpt.value = 'wait';
                        waitOpt.textContent = '‚è∏Ô∏è Wait...';
                        select.appendChild(waitOpt);

                        cached.drops.forEach(drop => {
                            const opt = document.createElement('option');
                            opt.value = drop.idx;
                            opt.textContent = drop.label;
                            select.appendChild(opt);
                        });

                        const savedChoice = localStorage.getItem(`hwh_lootbox_choice_${itemId}`);
                        select.value = savedChoice !== null ? savedChoice : 'wait';

                        select.onchange = () => {
                            localStorage.setItem(`hwh_lootbox_choice_${itemId}`, select.value);
                            // If set to wait, uncheck auto-collect
                            if (select.value === 'wait') {
                                delete tab2AutoItems[itemId];
                                localStorage.setItem('hwh_inventory_tab2_auto', JSON.stringify(tab2AutoItems));
                            }
                            renderTab2(); // Re-render to update üîÑ column
                        };

                        choiceCell.appendChild(select);
                    } else {
                        choiceCell.textContent = '-';
                        choiceCell.style.color = '#555';
                    }
                    row.appendChild(choiceCell);

                    // Quantity cell
                    const qtyCell = document.createElement('div');
                    if (showDropdown) {
                        const qtyInput = document.createElement('input');
                        qtyInput.type = 'number';
                        qtyInput.min = 1;
                        qtyInput.max = quantity;
                        const savedQty = localStorage.getItem(`hwh_lootbox_qty_${itemId}`);
                        qtyInput.value = savedQty !== null ? savedQty : quantity;
                        qtyInput.style.cssText = `
                            background: rgba(0,0,0,0.6);
                            color: #4ae29a;
                            border: 1px solid rgba(139,105,20,0.6);
                            border-radius: 4px;
                            padding: 2px;
                            font-size: 10px;
                            width: 100%;
                            text-align: center;
                        `;
                        qtyInput.onchange = () => {
                            const val = Math.min(Math.max(1, parseInt(qtyInput.value) || 1), quantity);
                            qtyInput.value = val;
                            localStorage.setItem(`hwh_lootbox_qty_${itemId}`, val);
                        };
                        qtyCell.appendChild(qtyInput);
                    } else {
                        qtyCell.textContent = quantity.toLocaleString();
                        qtyCell.style.cssText = 'text-align: right; color: #4ae29a; font-weight: bold; font-family: monospace;';
                    }
                    row.appendChild(qtyCell);

                    scrollContent.appendChild(row);
                });
            }

            tab2Content.appendChild(useSelectedBtn);
            tab2Content.appendChild(scrollContent);
            contentContainer.appendChild(tab2Content);

            footer.textContent = `Use Selected: ${inStockItems.length} items in stock`;
        };

        // ===== TAB 3: MANAGE LISTS =====
        const renderTab3 = () => {
            contentContainer.innerHTML = '';

            const consumables = inventoryData.consumable || {};

            // Get all known item IDs - sorted by ID, 0 qty last
            const allKnownIds = Array.from(new Set([
                ...Object.keys(window.itemNameCache?.consumable || {}),
                ...Object.keys(tab1CheckedItems),
                ...Object.keys(tab2CheckedItems),
                ...Object.keys(consumables)
            ])).sort((a, b) => {
                const qtyA = consumables[a] || 0;
                const qtyB = consumables[b] || 0;
                if (qtyA > 0 && qtyB === 0) return -1;
                if (qtyA === 0 && qtyB > 0) return 1;
                return parseInt(a) - parseInt(b);
            });

            const tab3Content = document.createElement('div');
            tab3Content.style.cssText = 'display: flex; flex-direction: column; overflow: hidden; flex: 1;';

            // Search box
            const searchContainer = document.createElement('div');
            searchContainer.style.cssText = 'margin-bottom: 8px;';

            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.placeholder = 'üîç Search item name or ID...';
            searchInput.style.cssText = `
                width: 100%;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid rgba(139, 105, 20, 0.5);
                color: #ffd700;
                padding: 6px 10px;
                border-radius: 6px;
                font-size: 12px;
            `;
            searchContainer.appendChild(searchInput);

            // Filter checkboxes
            const filterContainer = document.createElement('div');
            filterContainer.style.cssText = 'display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 8px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 6px;';

            const filters = {
                hasQty: { label: 'üì¶ In Stock', checked: false },
                isAuto: { label: 'üî∂ Auto-Use', checked: false },
                isSel: { label: 'üî∑ Selected', checked: false },
                isNeither: { label: '‚¨ú Neither', checked: false },
                hasChoice: { label: 'üéØ Has Choice', checked: false },
                isWait: { label: '‚è∏Ô∏è Waiting', checked: false },
                hasSelection: { label: '‚úÖ Choice Set', checked: false },
                isAutoCollect: { label: 'üîÑ Auto Collect', checked: false }
            };

            Object.entries(filters).forEach(([key, filter]) => {
                const label = document.createElement('label');
                label.style.cssText = 'display: flex; align-items: center; gap: 4px; color: #ccc; font-size: 11px; cursor: pointer;';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = filter.checked;
                checkbox.style.cssText = 'cursor: pointer;';
                checkbox.onchange = () => {
                    filters[key].checked = checkbox.checked;
                    renderVisibleRows();
                };

                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(filter.label));
                filterContainer.appendChild(label);
            });

            // Clear buttons
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'display: flex; gap: 8px; margin-bottom: 8px;';

            const clearTab1Btn = document.createElement('button');
            clearTab1Btn.textContent = 'Clear Auto-Use';
            clearTab1Btn.style.cssText = 'flex: 1; background: #ff9800; color: white; border: none; border-radius: 4px; padding: 5px 8px; font-size: 11px; cursor: pointer; font-weight: bold;';
            clearTab1Btn.onclick = () => {
                if (confirm('Clear all items from Auto-Use list?')) {
                    tab1CheckedItems = {};
                    saveTab1Checked();
                    renderVisibleRows();
                }
            };

            const clearTab2Btn = document.createElement('button');
            clearTab2Btn.textContent = 'Clear Selected';
            clearTab2Btn.style.cssText = 'flex: 1; background: #4a90e2; color: white; border: none; border-radius: 4px; padding: 5px 8px; font-size: 11px; cursor: pointer; font-weight: bold;';
            clearTab2Btn.onclick = () => {
                if (confirm('Clear all items from Use Selected list?')) {
                    tab2CheckedItems = {};
                    saveTab2Checked();
                    renderVisibleRows();
                }
            };

            buttonContainer.appendChild(clearTab1Btn);
            buttonContainer.appendChild(clearTab2Btn);

            // Grid header
            const gridHeader = document.createElement('div');
            gridHeader.style.cssText = `
                display: grid;
                grid-template-columns: 50px 50px 30px 50px 1fr 120px 55px;
                gap: 6px;
                padding: 6px 8px;
                background: rgba(139, 105, 20, 0.3);
                border-radius: 6px;
                font-weight: bold;
                margin-bottom: 6px;
                font-size: 11px;
                color: #ffd700;
            `;
            gridHeader.innerHTML = `
                <div class="twk-center" title="Auto-use items without choices">Auto</div>
                <div class="twk-center" title="Pick choice and use (for items with choices)">Pick</div>
                <div class="twk-center" title="Include in Collect More auto-use">üîÑ</div>
                <div class="twk-center">ID</div>
                <div>Item Name</div>
                <div class="twk-center">Choice</div>
                <div class="twk-right">Qty</div>
            `;

            // Scrollable content
            const scrollContent = document.createElement('div');
            scrollContent.style.cssText = 'overflow-y: auto; flex: 1;';

            // Virtual scrolling
            const ROW_HEIGHT = 30;
            const BUFFER = 10;
            let filteredIds = [];
            let lastStart = -1;
            let lastEnd = -1;

            const virtualContainer = document.createElement('div');
            virtualContainer.style.cssText = 'position: relative;';
            scrollContent.appendChild(virtualContainer);

            // Debounce helper
            let searchTimeout;
            const debounce = (fn, delay) => {
                return (...args) => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => fn(...args), delay);
                };
            };

            const applyFilters = () => {
                const searchTerm = searchInput.value.toLowerCase();

                filteredIds = allKnownIds.filter(itemId => {
                    const quantity = consumables[itemId] || 0;
                    const itemName = window.identifyItem(itemId, 'consumable');
                    const isAuto = !!tab1CheckedItems[itemId];
                    const isSel = !!tab2CheckedItems[itemId];
                    const cached = window._lootBoxCache?.[itemId];
                    const hasChoice = cached?.hasChoice || false;
                    const savedChoice = localStorage.getItem(`hwh_lootbox_choice_${itemId}`);
                    const isWait = hasChoice && (savedChoice === 'wait' || savedChoice === null);

                    // Search filter
                    if (searchTerm && !itemName.toLowerCase().includes(searchTerm) && !itemId.includes(searchTerm)) {
                        return false;
                    }

                    // Checkbox filters (OR logic within active filters)
                    const activeFilters = Object.entries(filters).filter(([_, f]) => f.checked);
                    if (activeFilters.length === 0) return true;

                    for (const [key, _] of activeFilters) {
                        if (key === 'hasQty' && quantity > 0) return true;
                        if (key === 'isAuto' && isAuto) return true;
                        if (key === 'isSel' && isSel) return true;
                        if (key === 'isNeither' && !isAuto && !isSel) return true;
                        if (key === 'isWait' && isWait) return true;
                        if (key === 'hasSelection' && hasChoice && savedChoice !== null && savedChoice !== 'wait') return true;
                        if (key === 'isAutoCollect' && tab2AutoItems[itemId]) return true;
                    }
                    return false;
                });

                virtualContainer.style.height = `${filteredIds.length * ROW_HEIGHT}px`;
                lastStart = -1;
                lastEnd = -1;
            };

            let cachedViewHeight = null;
            window.addEventListener('resize', () => { cachedViewHeight = null; }, { passive: true });

            const renderVisibleRows = () => {
                if (document.hidden) return;

                applyFilters();

                const scrollTop = scrollContent.scrollTop;
                if (!cachedViewHeight) cachedViewHeight = scrollContent.clientHeight;
                const viewHeight = cachedViewHeight;
                const start = Math.max(0, Math.floor(scrollTop / ROW_HEIGHT) - BUFFER);
                const end = Math.min(filteredIds.length, Math.ceil((scrollTop + viewHeight) / ROW_HEIGHT) + BUFFER);

                if (start === lastStart && end === lastEnd) return;
                lastStart = start;
                lastEnd = end;

                virtualContainer.innerHTML = '';

                for (let i = start; i < end; i++) {
                    const itemId = filteredIds[i];
                    const quantity = consumables[itemId] || 0;
                    const itemName = window.identifyItem(itemId, 'consumable');

                    const row = document.createElement('div');
                    row.style.cssText = `
                        position: absolute;
                        top: ${i * ROW_HEIGHT}px;
                        left: 0;
                        right: 0;
                        height: ${ROW_HEIGHT}px;
                        display: grid;
                        grid-template-columns: 50px 50px 30px 50px 1fr 120px 55px;
                        gap: 6px;
                        padding: 3px 8px;
                        border-bottom: 1px solid rgba(139, 105, 20, 0.2);
                        align-items: center;
                        font-size: 11px;
                        box-sizing: border-box;
                    `;
                    row.onmouseover = () => row.style.background = 'rgba(139, 105, 20, 0.15)';
                    row.onmouseout = () => row.style.background = 'transparent';

                    // Determine item type for checkbox availability
                    const cached = window._lootBoxCache?.[itemId];
                    const hasChoice = cached?.hasChoice || false;
                    const savedChoice = localStorage.getItem(`hwh_lootbox_choice_${itemId}`);
                    const isWaiting = hasChoice && (savedChoice === 'wait' || savedChoice === null);

                    // Auto-Use checkbox (only for items WITHOUT choices)
                    const autoUseCell = document.createElement('div');
                    autoUseCell.style.cssText = 'display: flex; justify-content: center;';
                    if (!hasChoice) {
                        const autoUseCheckbox = document.createElement('input');
                        autoUseCheckbox.type = 'checkbox';
                        autoUseCheckbox.checked = tab1CheckedItems[itemId] || false;
                        autoUseCheckbox.style.cssText = 'width: 16px; height: 16px; cursor: pointer;';
                        autoUseCheckbox.onchange = () => {
                            if (autoUseCheckbox.checked) {
                                tab1CheckedItems[itemId] = true;
                            } else {
                                delete tab1CheckedItems[itemId];
                            }
                            saveTab1Checked();
                            updateFooter();
                        };
                        autoUseCell.appendChild(autoUseCheckbox);
                    } else {
                        autoUseCell.innerHTML = '<span style="color: #444;">-</span>';
                    }

                    // Pick checkbox (only for items WITH choices)
                    const useSelectedCell = document.createElement('div');
                    useSelectedCell.style.cssText = 'display: flex; justify-content: center;';
                    if (hasChoice) {
                        const useSelectedCheckbox = document.createElement('input');
                        useSelectedCheckbox.type = 'checkbox';
                        useSelectedCheckbox.checked = tab2CheckedItems[itemId] || false;
                        useSelectedCheckbox.style.cssText = 'width: 16px; height: 16px; cursor: pointer;';
                        useSelectedCheckbox.onchange = () => {
                            if (useSelectedCheckbox.checked) {
                                tab2CheckedItems[itemId] = true;
                            } else {
                                delete tab2CheckedItems[itemId];
                                delete tab2AutoItems[itemId];
                                localStorage.setItem('hwh_inventory_tab2_auto', JSON.stringify(tab2AutoItems));
                            }
                            saveTab2Checked();
                            updateFooter();
                            renderVisibleRows(); // Re-render to update üîÑ column
                        };
                        useSelectedCell.appendChild(useSelectedCheckbox);
                    } else {
                        useSelectedCell.innerHTML = '<span style="color: #444;">-</span>';
                    }

                    // Auto Collect checkbox (only for Pick items with choice set, not waiting)
                    const autoCollectCell = document.createElement('div');
                    autoCollectCell.style.cssText = 'display: flex; justify-content: center;';
                    if (hasChoice && tab2CheckedItems[itemId] && !isWaiting) {
                        const autoCollectCheckbox = document.createElement('input');
                        autoCollectCheckbox.type = 'checkbox';
                        autoCollectCheckbox.checked = tab2AutoItems[itemId] || false;
                        autoCollectCheckbox.style.cssText = 'width: 14px; height: 14px; cursor: pointer;';
                        autoCollectCheckbox.title = 'Include in Collect More auto-use';
                        autoCollectCheckbox.onchange = () => {
                            if (autoCollectCheckbox.checked) {
                                tab2AutoItems[itemId] = true;
                            } else {
                                delete tab2AutoItems[itemId];
                            }
                            localStorage.setItem('hwh_inventory_tab2_auto', JSON.stringify(tab2AutoItems));
                        };
                        autoCollectCell.appendChild(autoCollectCheckbox);
                    } else if (hasChoice && isWaiting) {
                        autoCollectCell.innerHTML = '<span style="color: #444;" title="Set a choice first">-</span>';
                    } else {
                        autoCollectCell.innerHTML = '<span style="color: #444;">-</span>';
                    }

                    // Item ID
                    const idCell = document.createElement('div');
                    idCell.textContent = itemId;
                    idCell.style.cssText = 'text-align: center; color: #999; font-family: monospace; font-size: 10px;';

                    // Item Name
                    const nameCell = document.createElement('div');
                    nameCell.textContent = itemName;
                    nameCell.title = itemName;
                    nameCell.style.cssText = 'color: #ffd700; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;';

                    // Choice dropdown
                    const choiceCell = document.createElement('div');
                    choiceCell.style.cssText = 'display: flex; justify-content: center;';
                    if (cached?.hasChoice) {
                        const select = document.createElement('select');
                        select.style.cssText = `
                            background: rgba(0,0,0,0.6);
                            color: #ffd700;
                            border: 1px solid rgba(139,105,20,0.6);
                            border-radius: 4px;
                            padding: 2px 3px;
                            font-size: 10px;
                            width: 100%;
                            cursor: pointer;
                        `;

                        const waitOpt = document.createElement('option');
                        waitOpt.value = 'wait';
                        waitOpt.textContent = '‚è∏Ô∏è Wait...';
                        select.appendChild(waitOpt);

                        cached.drops.forEach(drop => {
                            const opt = document.createElement('option');
                            opt.value = drop.idx;
                            opt.textContent = drop.label;
                            select.appendChild(opt);
                        });

                        const savedChoice = localStorage.getItem(`hwh_lootbox_choice_${itemId}`);
                        select.value = savedChoice !== null ? savedChoice : 'wait';

                        select.onchange = () => {
                            localStorage.setItem(`hwh_lootbox_choice_${itemId}`, select.value);
                            // If set to wait, uncheck auto-collect
                            if (select.value === 'wait') {
                                delete tab2AutoItems[itemId];
                                localStorage.setItem('hwh_inventory_tab2_auto', JSON.stringify(tab2AutoItems));
                            }
                            renderVisibleRows(); // Re-render to update üîÑ column availability
                        };

                        choiceCell.appendChild(select);
                    } else {
                        choiceCell.textContent = '-';
                        choiceCell.style.color = '#555';
                        choiceCell.style.textAlign = 'center';
                    }

                    // Quantity
                    const qtyCell = document.createElement('div');
                    qtyCell.textContent = quantity > 0 ? quantity.toLocaleString() : '0';
                    qtyCell.style.cssText = `
                        text-align: right;
                        color: ${quantity > 0 ? '#4ae29a' : '#555'};
                        font-weight: ${quantity > 0 ? 'bold' : 'normal'};
                        font-family: monospace;
                    `;

                    row.appendChild(autoUseCell);
                    row.appendChild(useSelectedCell);
                    row.appendChild(autoCollectCell);
                    row.appendChild(idCell);
                    row.appendChild(nameCell);
                    row.appendChild(choiceCell);
                    row.appendChild(qtyCell);

                    virtualContainer.appendChild(row);
                }

                updateFooter();
            };

            const updateFooter = () => {
                const tab1Count = Object.keys(tab1CheckedItems).length;
                const tab2Count = Object.keys(tab2CheckedItems).length;
                footer.textContent = `Showing ${filteredIds.length} of ${allKnownIds.length} ‚Ä¢ Auto: ${tab1Count} ‚Ä¢ Pick: ${tab2Count}`;
            };

            // Debounced search
            searchInput.oninput = debounce(() => {
                scrollContent.scrollTop = 0;
                renderVisibleRows();
            }, 150);

            // Scroll handler
            let scrollRaf;
            scrollContent.onscroll = () => {
                if (scrollRaf) cancelAnimationFrame(scrollRaf);
                scrollRaf = requestAnimationFrame(renderVisibleRows);
            };

            tab3Content.appendChild(searchContainer);
            tab3Content.appendChild(filterContainer);
            tab3Content.appendChild(buttonContainer);
            tab3Content.appendChild(gridHeader);
            tab3Content.appendChild(scrollContent);
            contentContainer.appendChild(tab3Content);

            // Initial render
            renderVisibleRows();
        };

        // ===== TAB 4: IMPORT/EXPORT =====
        const renderTab4 = () => {
            contentContainer.innerHTML = '';

            const tab4Content = document.createElement('div');
            tab4Content.style.cssText = `
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            overflow: hidden;
            flex: 1;
        `;

            // LEFT COLUMN: Export Section
            const exportSection = document.createElement('div');
            exportSection.style.cssText = `
            background: rgba(139, 105, 20, 0.15);
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;

            const exportTitle = document.createElement('h3');
            exportTitle.textContent = 'üì§ Export Lists';
            exportTitle.style.cssText = `
            color: #ffd700;
            margin: 0 0 12px 0;
            font-size: 14px;
        `;

            const exportTab1Btn = document.createElement('button');
            exportTab1Btn.textContent = 'üìã Copy Auto-Use List';
            exportTab1Btn.style.cssText = `
            background: #ff9800;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px;
            font-size: 12px;
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 8px;
        `;
            exportTab1Btn.onclick = () => {
                const ids = Object.keys(tab1CheckedItems).sort((a, b) => parseInt(a) - parseInt(b));
                const text = ids.join(',');
                navigator.clipboard.writeText(text).then(() => {
                    alert(`‚úÖ Copied ${ids.length} Auto-Use item IDs to clipboard:\n\n${text}`);
                }).catch(() => {
                    prompt('Copy this text:', text);
                });
            };

            const exportTab2Btn = document.createElement('button');
            exportTab2Btn.textContent = 'üìã Copy Use Selected List';
            exportTab2Btn.style.cssText = `
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px;
            font-size: 12px;
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 12px;
        `;
            exportTab2Btn.onclick = () => {
                const ids = Object.keys(tab2CheckedItems).sort((a, b) => parseInt(a) - parseInt(b));
                const text = ids.join(',');
                navigator.clipboard.writeText(text).then(() => {
                    alert(`‚úÖ Copied ${ids.length} Use Selected item IDs to clipboard:\n\n${text}`);
                }).catch(() => {
                    prompt('Copy this text:', text);
                });
            };

            const exportPreview = document.createElement('div');
            exportPreview.style.cssText = `
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(139, 105, 20, 0.5);
            border-radius: 6px;
            padding: 10px;
            font-size: 10px;
            color: #999;
            font-family: monospace;
            flex: 1;
            overflow-y: auto;
        `;

            const updateExportPreview = () => {
                const tab1Ids = Object.keys(tab1CheckedItems).sort((a, b) => parseInt(a) - parseInt(b));
                const tab2Ids = Object.keys(tab2CheckedItems).sort((a, b) => parseInt(a) - parseInt(b));
                exportPreview.innerHTML = `
                <div style="color: #ff9800; margin-bottom: 8px; font-weight: bold;">Auto-Use (${tab1Ids.length} items):</div>
                <div style="margin-bottom: 15px; line-height: 1.5;">${tab1Ids.join(', ') || 'None'}</div>
                <div style="color: #4a90e2; margin-bottom: 8px; font-weight: bold;">Use Selected (${tab2Ids.length} items):</div>
                <div style="line-height: 1.5;">${tab2Ids.join(', ') || 'None'}</div>
            `;
            };

            exportSection.appendChild(exportTitle);
            exportSection.appendChild(exportTab1Btn);
            exportSection.appendChild(exportTab2Btn);
            exportSection.appendChild(exportPreview);

            // RIGHT COLUMN: Import Section
            const importSection = document.createElement('div');
            importSection.style.cssText = `
            background: rgba(139, 105, 20, 0.15);
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;

            const importTitle = document.createElement('h3');
            importTitle.textContent = 'üì• Import Lists';
            importTitle.style.cssText = `
            color: #ffd700;
            margin: 0 0 12px 0;
            font-size: 14px;
        `;

            const importInstructions = document.createElement('div');
            importInstructions.style.cssText = `
            color: #999;
            font-size: 10px;
            margin-bottom: 10px;
        `;
            importInstructions.textContent = 'Paste comma-separated item IDs (e.g., 1,2,3,4,10,56) and choose which list to import to:';

            const importTextarea = document.createElement('textarea');
            importTextarea.placeholder = 'Paste item IDs here... (e.g., 1,2,3,4,10,56)';
            importTextarea.style.cssText = `
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(139, 105, 20, 0.5);
            color: #ffd700;
            padding: 10px;
            border-radius: 6px;
            font-size: 11px;
            font-family: monospace;
            resize: vertical;
            flex: 1;
            margin-bottom: 12px;
        `;

            const importOptions = document.createElement('div');
            importOptions.style.cssText = `
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            align-items: center;
        `;

            const importModeLabel = document.createElement('span');
            importModeLabel.textContent = 'Import mode:';
            importModeLabel.style.cssText = `
            color: #ffd700;
            font-size: 11px;
        `;

            const importModeSelect = document.createElement('select');
            importModeSelect.style.cssText = `
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(139, 105, 20, 0.5);
            color: #ffd700;
            padding: 6px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
        `;
            importModeSelect.innerHTML = `
            <option value="add">Add to existing</option>
            <option value="replace">Replace existing</option>
        `;

            importOptions.appendChild(importModeLabel);
            importOptions.appendChild(importModeSelect);

            const importToTab1Btn = document.createElement('button');
            importToTab1Btn.textContent = 'üì• Import to Auto-Use';
            importToTab1Btn.style.cssText = `
            background: #ff9800;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px;
            font-size: 12px;
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 8px;
        `;
            importToTab1Btn.onclick = () => {
                const text = importTextarea.value.trim();
                if (!text) {
                    alert('‚ùå Please paste item IDs first');
                    return;
                }

                const ids = text.split(',').map(id => id.trim()).filter(id => id && !isNaN(id));
                if (ids.length === 0) {
                    alert('‚ùå No valid item IDs found');
                    return;
                }

                const mode = importModeSelect.value;

                if (mode === 'replace') {
                    if (!confirm(`Replace Auto-Use list with ${ids.length} new items?`)) {
                        return;
                    }
                    tab1CheckedItems = {};
                }

                ids.forEach(id => {
                    tab1CheckedItems[id] = true;
                });

                saveTab1Checked();
                updateExportPreview();
                alert(`‚úÖ Imported ${ids.length} items to Auto-Use list (${mode})`);
                importTextarea.value = '';
            };

            const importToTab2Btn = document.createElement('button');
            importToTab2Btn.textContent = 'üì• Import to Use Selected';
            importToTab2Btn.style.cssText = `
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px;
            font-size: 12px;
            cursor: pointer;
            font-weight: bold;
        `;
            importToTab2Btn.onclick = () => {
                const text = importTextarea.value.trim();
                if (!text) {
                    alert('‚ùå Please paste item IDs first');
                    return;
                }

                const ids = text.split(',').map(id => id.trim()).filter(id => id && !isNaN(id));
                if (ids.length === 0) {
                    alert('‚ùå No valid item IDs found');
                    return;
                }

                const mode = importModeSelect.value;

                if (mode === 'replace') {
                    if (!confirm(`Replace Use Selected list with ${ids.length} new items?`)) {
                        return;
                    }
                    tab2CheckedItems = {};
                }

                ids.forEach(id => {
                    tab2CheckedItems[id] = true;
                });

                saveTab2Checked();
                updateExportPreview();
                alert(`‚úÖ Imported ${ids.length} items to Use Selected list (${mode})`);
                importTextarea.value = '';
            };

            importSection.appendChild(importTitle);
            importSection.appendChild(importInstructions);
            importSection.appendChild(importTextarea);
            importSection.appendChild(importOptions);
            importSection.appendChild(importToTab1Btn);
            importSection.appendChild(importToTab2Btn);

            tab4Content.appendChild(exportSection);
            tab4Content.appendChild(importSection);

            contentContainer.appendChild(tab4Content);

            // Initial preview update
            updateExportPreview();

            const tab1Count = Object.keys(tab1CheckedItems).length;
            const tab2Count = Object.keys(tab2CheckedItems).length;
            footer.textContent = `Auto-Use: ${tab1Count} items ‚Ä¢ Use Selected: ${tab2Count} items`;
        };
        // ===== TAB 5: SELL FRAGMENTS =====
        // Pre-build fragment master list ONCE (outside render function)
        let fragmentMasterList = null;
        const buildFragmentMasterList = () => {
            if (fragmentMasterList) return fragmentMasterList;

            const heroArtifactIds = new Set();
            const titanArtifactIds = new Set();

            // Extract artifact IDs from heroes/titans
            Object.values(lib?.data?.hero || {}).forEach(h => {
                if (h?.artifacts) h.artifacts.forEach(a => heroArtifactIds.add(String(typeof a === 'number' ? a : a?.id)));
            });
            Object.values(lib?.data?.titan || {}).forEach(t => {
                if (t?.artifacts) t.artifacts.forEach(a => titanArtifactIds.add(String(typeof a === 'number' ? a : a?.id)));
            });

            const types = [
                { key: 'hero', lib: lib?.data?.hero, label: 'ü¶∏ Hero', color: '#4a90e2' },
                { key: 'titan', lib: lib?.data?.titan, label: 'üóø Titan', color: '#ff9800' },
                { key: 'pet', lib: lib?.data?.pet, label: 'üêæ Pet', color: '#4caf50' },
                { key: 'artifact', lib: null, manual: heroArtifactIds, label: 'üè∫ Artifact', color: '#e91e63' },
                { key: 'titanArtifact', lib: null, manual: titanArtifactIds, label: '‚ö° TitanArt', color: '#ff5722' }
            ];

            const list = [];
            types.forEach(t => {
                const ids = new Set();
                if (t.lib) {
                    Object.keys(t.lib).forEach(id => { if (/^\d+$/.test(id)) ids.add(id); });
                }
                if (t.manual) {
                    t.manual.forEach(id => ids.add(id));
                }
                // Add from settings
                Object.keys(fragmentSellSettings).forEach(k => {
                    if (k.startsWith(t.key + '_')) ids.add(k.replace(t.key + '_', ''));
                });

                ids.forEach(id => {
                    list.push({ id, type: t.key, typeLabel: t.label, color: t.color, _name: null });
                });
            });

            fragmentMasterList = list;
            return list;
        };

        // Helper: get fragments needed to craft one item
        const getFragmentMergeCost = (type, id) => {
            try {
                return lib.data?.inventoryItem?.[type]?.[id]?.fragmentMergeCost?.fragmentCount || null;
            } catch (e) { return null; }
        };

        // Helper: get complete (built) item count
        const getCompleteCount = (type, id) => {
            return inventoryData[type]?.[id] || 0;
        };

        const renderTab5 = () => {
            contentContainer.innerHTML = '';

            // Get current inventory quantities (gear/scroll moved to Tab 6 Craft)
            const invData = {
                hero: inventoryData.fragmentHero || {},
                titan: inventoryData.fragmentTitan || {},
                pet: inventoryData.fragmentPet || {},
                artifact: inventoryData.fragmentArtifact || {},
                titanArtifact: inventoryData.fragmentTitanArtifact || {}
            };

            // Get master list (cached)
            const masterList = buildFragmentMasterList();

            // Add inventory items that might not be in master list
            Object.entries(invData).forEach(([type, data]) => {
                Object.keys(data).forEach(id => {
                    if (!masterList.find(m => m.type === type && m.id === id)) {
                        const typeInfo = { hero: ['ü¶∏ Hero', '#4a90e2'], titan: ['üóø Titan', '#ff9800'], pet: ['üêæ Pet', '#4caf50'], artifact: ['üè∫ Artifact', '#e91e63'], titanArtifact: ['‚ö° TitanArt', '#ff5722'] };
                        masterList.push({ id, type, typeLabel: typeInfo[type][0], color: typeInfo[type][1], _name: null });
                    }
                });
            });

            const tab5Content = document.createElement('div');
            tab5Content.style.cssText = 'display: flex; flex-direction: column; overflow: hidden; flex: 1;';

            // Search box
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.placeholder = 'üîç Search fragment name or ID...';
            searchInput.style.cssText = 'width:100%;background:rgba(0,0,0,0.3);border:1px solid rgba(156,39,176,0.5);color:#ce93d8;padding:6px 10px;border-radius:6px;font-size:12px;margin-bottom:8px;';

            // Filter row
            const filterRow = document.createElement('div');
            filterRow.style.cssText = 'display:flex;flex-wrap:wrap;gap:8px;margin-bottom:8px;padding:8px;background:rgba(0,0,0,0.2);border-radius:6px;align-items:center;';

            const typeSelect = document.createElement('select');
            typeSelect.style.cssText = 'background:rgba(0,0,0,0.5);color:#ce93d8;border:1px solid rgba(156,39,176,0.5);border-radius:4px;padding:4px 8px;font-size:11px;';
            typeSelect.innerHTML = '<option value="all">All Types</option><option value="hero">ü¶∏ Hero</option><option value="titan">üóø Titan</option><option value="pet">üêæ Pet</option><option value="artifact">üè∫ Artifact</option><option value="titanArtifact">‚ö° TitanArt</option>';            filterRow.appendChild(typeSelect);

            const filters = { hasQty: true, zeroQty: false, sellEnabled: false };
            ['üì¶ In Stock|hasQty', '0Ô∏è‚É£ Zero|zeroQty', '‚òëÔ∏è Sell On|sellEnabled'].forEach(f => {
                const [label, key] = f.split('|');
                const lbl = document.createElement('label');
                lbl.style.cssText = 'display:flex;align-items:center;gap:4px;color:#ccc;font-size:11px;cursor:pointer;';
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.checked = filters[key];
                cb.onchange = () => { filters[key] = cb.checked; doFilter(); };
                lbl.appendChild(cb);
                lbl.appendChild(document.createTextNode(label));
                filterRow.appendChild(lbl);
            });

            // Action row 1 - Main buttons
            const actionRow1 = document.createElement('div');
            actionRow1.style.cssText = 'display:flex;gap:8px;margin-bottom:6px;';

            const sellBtn = document.createElement('button');
            sellBtn.textContent = 'üí∞ Sell Excess Now';
            sellBtn.style.cssText = 'flex:2;background:#9c27b0;color:white;border:none;border-radius:6px;padding:8px;font-size:12px;cursor:pointer;font-weight:bold;';
            sellBtn.onclick = () => sellFragmentsNow();

            const selAllBtn = document.createElement('button');
            selAllBtn.textContent = '‚òëÔ∏è Sell All';
            selAllBtn.style.cssText = 'flex:1;background:rgba(156,39,176,0.5);color:#ce93d8;border:none;border-radius:6px;padding:8px 12px;font-size:11px;cursor:pointer;font-weight:bold;';
            selAllBtn.onclick = () => { filtered.forEach(f => { const k = `${f.type}_${f.id}`; if (!fragmentSellSettings[k]) fragmentSellSettings[k] = {keep:0,sell:false}; fragmentSellSettings[k].sell = true; }); saveFragmentSettings(); renderRows(); };

            const deselBtn = document.createElement('button');
            deselBtn.textContent = '‚¨ú Sell None';
            deselBtn.style.cssText = 'flex:1;background:rgba(139,105,20,0.3);color:#ccc;border:none;border-radius:6px;padding:8px 12px;font-size:11px;cursor:pointer;font-weight:bold;';
            deselBtn.onclick = () => { filtered.forEach(f => { const k = `${f.type}_${f.id}`; if (fragmentSellSettings[k]) fragmentSellSettings[k].sell = false; }); saveFragmentSettings(); renderRows(); };

            const keepBtn = document.createElement('button');
            keepBtn.textContent = 'üìå Keep=Have';
            keepBtn.style.cssText = 'flex:1;background:rgba(76,175,80,0.5);color:#a5d6a7;border:none;border-radius:6px;padding:8px 12px;font-size:11px;cursor:pointer;font-weight:bold;';
            keepBtn.onclick = () => { filtered.forEach(f => { const k = `${f.type}_${f.id}`; if (!fragmentSellSettings[k]) fragmentSellSettings[k] = {keep:0,sell:false}; fragmentSellSettings[k].keep = invData[f.type]?.[f.id] || 0; }); saveFragmentSettings(); renderRows(); };

            actionRow1.append(sellBtn, selAllBtn, deselBtn, keepBtn);

            // Action row 2 - Unit type controls (6‚òÖ select + mode dropdown grouped)
            const actionRow2 = document.createElement('div');
            actionRow2.style.cssText = 'display:flex;gap:16px;margin-bottom:8px;padding:6px 10px;background:rgba(0,0,0,0.2);border-radius:6px;align-items:center;flex-wrap:wrap;';

            // Hero group
            const heroGrp = document.createElement('div');
            heroGrp.style.cssText = 'display:flex;align-items:center;gap:4px;';
            const heroBtn = document.createElement('button');
            heroBtn.textContent = 'üëª 6‚òÖ Hero';
            heroBtn.style.cssText = 'background:rgba(206,147,216,0.4);color:#ce93d8;border:none;border-radius:4px;padding:4px 8px;font-size:10px;cursor:pointer;font-weight:bold;';
            heroBtn.title = 'Select all 6‚òÖ hero frags to sell';
            heroBtn.onclick = async () => {
                const origText = heroBtn.textContent;
                heroBtn.textContent = '‚è≥';
                try {
                    const resp = await Send(JSON.stringify({calls:[{name:'heroGetAll',args:{},ident:'h'}]}));
                    const heroes = resp.results[0].result.response;
                    let count = 0;
                    Object.entries(heroes).forEach(([id, h]) => {
                        if (h.star === 6) {
                            const k = `hero_${id}`;
                            if (!fragmentSellSettings[k]) fragmentSellSettings[k] = {keep: 0, sell: false};
                            fragmentSellSettings[k].sell = true;
                            count++;
                        }
                    });
                    saveFragmentSettings();
                    renderRows();
                    console.log(`‚úÖ Selected ${count} 6‚òÖ hero frags for sell`);
                } catch (e) { console.error('Failed to get heroes:', e); }
                heroBtn.textContent = origText;
            };
            const heroArrow = document.createElement('span');
            heroArrow.textContent = '‚Üí';
            heroArrow.style.cssText = 'color:#666;font-size:10px;';
            const heroSelect = document.createElement('select');
            heroSelect.style.cssText = 'background:#1a0f08;color:#ffd700;border:1px solid #8b6914;border-radius:4px;padding:2px 4px;font-size:10px;';
            heroSelect.title = 'Hero soul conversion mode';
            heroSelect.innerHTML = `<option value="gold" ${heroSoulMode === 'gold' ? 'selected' : ''}>ü™ô Gold</option><option value="coins" ${heroSoulMode === 'coins' ? 'selected' : ''}>üíÄ Soul Coins</option>`;
            heroSelect.onchange = () => { heroSoulMode = heroSelect.value; localStorage.setItem('hwh_hero_soul_mode', heroSoulMode); };
            heroGrp.append(heroBtn, heroArrow, heroSelect);

            // Titan group
            const titanGrp = document.createElement('div');
            titanGrp.style.cssText = 'display:flex;align-items:center;gap:4px;';
            const titanBtn = document.createElement('button');
            titanBtn.textContent = 'üóø 6‚òÖ Titan';
            titanBtn.style.cssText = 'background:rgba(255,152,0,0.4);color:#ff9800;border:none;border-radius:4px;padding:4px 8px;font-size:10px;cursor:pointer;font-weight:bold;';
            titanBtn.title = 'Select all 6‚òÖ titan frags to sell';
            titanBtn.onclick = async () => {
                const origText = titanBtn.textContent;
                titanBtn.textContent = '‚è≥';
                try {
                    const resp = await Send(JSON.stringify({calls:[{name:'titanGetAll',args:{},ident:'t'}]}));
                    const titans = resp.results[0].result.response;
                    let count = 0;
                    Object.entries(titans).forEach(([id, t]) => {
                        if (t.star === 6) {
                            const k = `titan_${id}`;
                            if (!fragmentSellSettings[k]) fragmentSellSettings[k] = {keep: 0, sell: false};
                            fragmentSellSettings[k].sell = true;
                            count++;
                        }
                    });
                    saveFragmentSettings();
                    renderRows();
                    console.log(`‚úÖ Selected ${count} 6‚òÖ titan frags for sell`);
                } catch (e) { console.error('Failed to get titans:', e); }
                titanBtn.textContent = origText;
            };
            const titanArrow = document.createElement('span');
            titanArrow.textContent = '‚Üí';
            titanArrow.style.cssText = 'color:#666;font-size:10px;';
            const titanSelect = document.createElement('select');
            titanSelect.style.cssText = 'background:#1a0f08;color:#ffd700;border:1px solid #8b6914;border-radius:4px;padding:2px 4px;font-size:10px;';
            titanSelect.title = 'Titan soul conversion mode';
            titanSelect.innerHTML = `<option value="gold" ${titanSoulMode === 'gold' ? 'selected' : ''}>ü™ô Gold</option><option value="coins" ${titanSoulMode === 'coins' ? 'selected' : ''}>‚ö° Titan Coins</option>`;
            titanSelect.onchange = () => { titanSoulMode = titanSelect.value; localStorage.setItem('hwh_titan_soul_mode', titanSoulMode); };
            titanGrp.append(titanBtn, titanArrow, titanSelect);

            // Pet group
            const petGrp = document.createElement('div');
            petGrp.style.cssText = 'display:flex;align-items:center;gap:4px;';
            const petBtn = document.createElement('button');
            petBtn.textContent = 'üêæ 6‚òÖ Pet';
            petBtn.style.cssText = 'background:rgba(76,175,80,0.4);color:#4caf50;border:none;border-radius:4px;padding:4px 8px;font-size:10px;cursor:pointer;font-weight:bold;';
            petBtn.title = 'Select all 6‚òÖ pet frags to sell';
            petBtn.onclick = async () => {
                const origText = petBtn.textContent;
                petBtn.textContent = '‚è≥';
                try {
                    const resp = await Send(JSON.stringify({calls:[{name:'pet_getAll',args:{},ident:'p'}]}));
                    const pets = resp.results[0].result.response;
                    let count = 0;
                    // pet_getAll returns array, not object
                    pets.forEach(p => {
                        if (p.star === 6) {
                            const k = `pet_${p.id}`;
                            if (!fragmentSellSettings[k]) fragmentSellSettings[k] = {keep: 0, sell: false};
                            fragmentSellSettings[k].sell = true;
                            count++;
                        }
                    });
                    saveFragmentSettings();
                    renderRows();
                    console.log(`‚úÖ Selected ${count} 6‚òÖ pet frags for sell`);
                } catch (e) { console.error('Failed to get pets:', e); }
                petBtn.textContent = origText;
            };
            const petArrow = document.createElement('span');
            petArrow.textContent = '‚Üí';
            petArrow.style.cssText = 'color:#666;font-size:10px;';
            const petSelect = document.createElement('select');
            petSelect.style.cssText = 'background:#1a0f08;color:#ffd700;border:1px solid #8b6914;border-radius:4px;padding:2px 4px;font-size:10px;';
            petSelect.title = 'Pet soul conversion mode';
            petSelect.innerHTML = `<option value="gold" ${petSoulMode === 'gold' ? 'selected' : ''}>ü™ô Gold</option><option value="coins" ${petSoulMode === 'coins' ? 'selected' : ''}>üêæ Pet Coins</option>`;
            petSelect.onchange = () => { petSoulMode = petSelect.value; localStorage.setItem('hwh_pet_soul_mode', petSoulMode); };
            petGrp.append(petBtn, petArrow, petSelect);

            actionRow2.append(heroGrp, titanGrp, petGrp);

            // Grid header
            const gridHeader = document.createElement('div');
            gridHeader.style.cssText = 'display:grid;grid-template-columns:70px 1fr 50px 90px 60px 50px;gap:6px;padding:8px 10px;background:rgba(156,39,176,0.3);border-radius:6px;font-weight:bold;margin-bottom:6px;font-size:11px;color:#ce93d8;';
            gridHeader.innerHTML = '<div style="text-align:center">Type</div><div>Name</div><div style="text-align:center" title="Complete items built">üéÅ</div><div style="text-align:center" title="Fragments / Needed">Frags</div><div style="text-align:center">Keep</div><div style="text-align:center">Sell</div>';

            // Scroll container
            const scrollBox = document.createElement('div');
            scrollBox.style.cssText = 'overflow-y:auto;flex:1;';
            const virtualBox = document.createElement('div');
            virtualBox.style.cssText = 'position:relative;';
            scrollBox.appendChild(virtualBox);

            // Footer
            const footerEl = document.createElement('div');
            footerEl.style.cssText = 'padding-top:8px;font-size:11px;color:#999;';

            let filtered = [];
            let lastRange = [-1, -1];
            const ROW_H = 32, BUFFER = 5;

            // Name cache for lazy loading
            const nameCache = {};
            // Build artifact-to-user maps (cached globally)
            if (!window._artifactUserMaps) {
                const heroArtMap = {}, titanArtMap = {};
                if (lib?.data?.hero) {
                    Object.entries(lib.data.hero).forEach(([heroId, hero]) => {
                        if (parseInt(heroId) >= 100) return; // Skip computer/event heroes
                        if (hero.artifacts?.length) {
                            const heroName = window.identifyItem?.(heroId, 'hero') || `Hero #${heroId}`;
                            hero.artifacts.forEach(artId => {
                                if (artId > 0) {
                                    if (!heroArtMap[artId]) heroArtMap[artId] = [];
                                    if (!heroArtMap[artId].includes(heroName)) heroArtMap[artId].push(heroName);
                                }
                            });
                        }
                    });
                }
                if (lib?.data?.titan) {
                    Object.entries(lib.data.titan).forEach(([titanId, titan]) => {
                        const id = parseInt(titanId);
                        if (id < 4000 || id > 4050) return; // Skip non-standard titans
                        if (titan.artifacts?.length) {
                            const titanName = window.identifyItem?.(titanId, 'titan') || `Titan #${titanId}`;
                            titan.artifacts.forEach(artId => {
                                if (artId > 0) {
                                    if (!titanArtMap[artId]) titanArtMap[artId] = [];
                                    if (!titanArtMap[artId].includes(titanName)) titanArtMap[artId].push(titanName);
                                }
                            });
                        }
                    });
                }
                window._artifactUserMaps = { hero: heroArtMap, titan: titanArtMap };
            }
            const artMaps = window._artifactUserMaps;

            const getName = (type, id) => {
                const k = `${type}_${id}`;
                if (!nameCache[k]) {
                    let name = window.identifyItem?.(id, type) || `${type} #${id}`;
                    if (type === 'artifact' && artMaps.hero[id]?.length) {
                        name += ` (${artMaps.hero[id].join(', ')})`;
                    } else if (type === 'titanArtifact' && artMaps.titan[id]?.length) {
                        name += ` (${artMaps.titan[id].join(', ')})`;
                    }
                    nameCache[k] = name;
                }
                return nameCache[k];
            };

            const doFilter = () => {
                const search = searchInput.value.toLowerCase();
                const typeF = typeSelect.value;

                filtered = masterList.filter(f => {
                    if (typeF !== 'all' && f.type !== typeF) return false;

                    const qty = invData[f.type]?.[f.id] || 0;
                    const settings = fragmentSellSettings[`${f.type}_${f.id}`];

                    // Filter checkboxes
                    // Quantity filters (In Stock / Zero) are OR with each other
                    // Sell On is AND with quantity filters
                    const hasQtyFilter = filters.hasQty || filters.zeroQty;

                    if (hasQtyFilter) {
                        let qtyPass = false;
                        if (filters.hasQty && qty > 0) qtyPass = true;
                        if (filters.zeroQty && qty === 0) qtyPass = true;
                        if (!qtyPass) return false;
                    }

                    if (filters.sellEnabled && !settings?.sell) return false;

                    // Search
                    if (search) {
                        const name = getName(f.type, f.id).toLowerCase();
                        if (!name.includes(search) && !f.id.includes(search)) return false;
                    }

                    return true;
                });

                // Sort: by type, then qty desc
                const typeOrder = { hero: 1, titan: 2, pet: 3, artifact: 4, titanArtifact: 5 };
                filtered.sort((a, b) => {
                    if (typeOrder[a.type] !== typeOrder[b.type]) return typeOrder[a.type] - typeOrder[b.type];
                    const qA = invData[a.type]?.[a.id] || 0, qB = invData[b.type]?.[b.id] || 0;
                    return qB - qA;
                });

                lastRange = [-1, -1];
                scrollBox.scrollTop = 0;
                renderRows();
            };

            const renderRows = () => {
                const scrollTop = scrollBox.scrollTop;
                const viewH = scrollBox.clientHeight || 400;
                virtualBox.style.height = filtered.length * ROW_H + 'px';

                const start = Math.max(0, Math.floor(scrollTop / ROW_H) - BUFFER);
                const end = Math.min(filtered.length, Math.ceil((scrollTop + viewH) / ROW_H) + BUFFER);

                if (start === lastRange[0] && end === lastRange[1]) return;
                lastRange = [start, end];

                virtualBox.innerHTML = '';

                for (let i = start; i < end; i++) {
                    const f = filtered[i];
                    const k = `${f.type}_${f.id}`;
                    const fragQty = invData[f.type]?.[f.id] || 0;
                    const settings = fragmentSellSettings[k] || { keep: 0, sell: false };

                    // Get complete item count and fragments needed (gear/scroll only)
                    const completeQty = getCompleteCount(f.type, f.id);
                    const needed = getFragmentMergeCost(f.type, f.id);

                    // Build fragments display: "35/50" or just "35" if no merge info
                    let fragDisplay;
                    if (needed) {
                        const pct = fragQty / needed;
                        const fragColor = pct >= 1 ? '#4ae29a' : (pct >= 0.5 ? '#ffd700' : (fragQty > 0 ? '#ff9800' : '#666'));
                        fragDisplay = `<span style="color:${fragColor}">${fragQty}/${needed}</span>`;
                    } else {
                        fragDisplay = `<span style="color:${fragQty > 0 ? '#4ae29a' : '#666'}">${fragQty.toLocaleString()}</span>`;
                    }

                    // Built column: show count or dash
                    const builtDisplay = completeQty > 0
                    ? `<span style="color:#4ae29a;font-weight:bold">${completeQty}</span>`
                        : `<span style="color:#555">-</span>`;

                    const row = document.createElement('div');
                    row.style.cssText = `display:grid;grid-template-columns:70px 1fr 50px 90px 60px 50px;gap:6px;padding:4px 10px;align-items:center;font-size:11px;position:absolute;top:${i * ROW_H}px;left:0;right:0;height:${ROW_H}px;border-bottom:1px solid rgba(139,105,20,0.2);`;

                    row.innerHTML = `
                        <div style="text-align:center;font-size:10px;color:${f.color};font-weight:bold">${f.typeLabel}</div>
                        <div class="twk-gold" style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="ID:${f.id}">${getName(f.type, f.id)}</div>
                        <div style="text-align:center;font-family:monospace">${builtDisplay}</div>
                        <div style="text-align:center;font-family:monospace">${fragDisplay}</div>
                        <div style="text-align:center"><input type="number" min="0" value="${settings.keep}" style="width:45px;background:rgba(0,0,0,0.5);color:#ffd700;border:1px solid rgba(139,105,20,0.5);border-radius:4px;padding:2px;font-size:10px;text-align:center"></div>
                        <div style="text-align:center"><input type="checkbox" ${settings.sell ? 'checked' : ''} style="width:16px;height:16px;cursor:pointer"></div>
                    `;
                    const keepInput = row.querySelector('input[type="number"]');
                    const sellCb = row.querySelector('input[type="checkbox"]');

                    keepInput.onchange = () => {
                        if (!fragmentSellSettings[k]) fragmentSellSettings[k] = { keep: 0, sell: false };
                        fragmentSellSettings[k].keep = Math.max(0, parseInt(keepInput.value) || 0);
                        saveFragmentSettings();
                    };

                    sellCb.onchange = () => {
                        if (!fragmentSellSettings[k]) fragmentSellSettings[k] = { keep: 0, sell: false };
                        fragmentSellSettings[k].sell = sellCb.checked;
                        saveFragmentSettings();
                        updateFooter();
                    };

                    virtualBox.appendChild(row);
                }

                updateFooter();
            };

            const updateFooter = () => {
                const sellCount = Object.values(fragmentSellSettings).filter(s => s.sell).length;
                const excess = filtered.reduce((sum, f) => {
                    const s = fragmentSellSettings[`${f.type}_${f.id}`];
                    if (s?.sell) return sum + Math.max(0, (invData[f.type]?.[f.id] || 0) - (s.keep || 0));
                    return sum;
                }, 0);
                footerEl.textContent = `Showing ${filtered.length} of ${masterList.length} ‚Ä¢ ${sellCount} marked ‚Ä¢ ${excess.toLocaleString()} excess`;
            };

            // Event handlers with debounce
            let timeout;
            searchInput.oninput = () => { clearTimeout(timeout); timeout = setTimeout(doFilter, 150); };
            typeSelect.onchange = doFilter;
            let raf;
            scrollBox.onscroll = () => { if (raf) cancelAnimationFrame(raf); raf = requestAnimationFrame(renderRows); };

            // Build UI
            tab5Content.append(searchInput, filterRow, actionRow1, actionRow2, gridHeader, scrollBox, footerEl);
            contentContainer.appendChild(tab5Content);

            doFilter();
        };
        // ===== TAB 6: CRAFT MANAGER (Gear & Scroll only) =====
        const craftTargets = JSON.parse(localStorage.getItem('hwh_craft_targets') || '{}');
        const saveCraftTargets = () => localStorage.setItem('hwh_craft_targets', JSON.stringify(craftTargets));
        let tab6ColorFilter = localStorage.getItem('hwh_craft_color_filter') || 'all';
        const heroExcluded = JSON.parse(localStorage.getItem('hwh_hero_excluded') || '[]');
        const saveHeroExcluded = (ids) => localStorage.setItem('hwh_hero_excluded', JSON.stringify(ids));

        // Confirmation modal for craft/sell operations
        const showCraftSellConfirmModal = async (craftList, sellFragList, sellItemList) => {
            return new Promise((resolve) => {
                const modal = document.createElement('div');
                modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.85);z-index:999999999;display:flex;align-items:center;justify-content:center;';

                const totalCraft = craftList.reduce((s, i) => s + i.amount, 0);
                const totalSellFrags = sellFragList.reduce((s, i) => s + i.amount, 0);
                const totalSellItems = sellItemList.reduce((s, i) => s + i.amount, 0);

                const box = document.createElement('div');
                box.style.cssText = 'background:#1a1a2e;border:2px solid #8b6914;border-radius:10px;padding:14px;max-width:500px;max-height:80vh;display:flex;flex-direction:column;';

                box.innerHTML = `
                    <div style="color:#ffd700;font-size:14px;font-weight:bold;margin-bottom:10px;">‚ö†Ô∏è Confirm Actions</div>

                    ${craftList.length > 0 ? `
                    <div style="margin-bottom:10px;">
                        <label style="display:flex;align-items:center;gap:8px;color:#4caf50;font-size:12px;font-weight:bold;cursor:pointer;">
                            <input type="checkbox" id="csm_craft" checked style="width:16px;height:16px;">
                            üî® Craft ${totalCraft} items (${craftList.length} types)
                        </label>
                        <div id="csm_craftList" style="max-height:100px;overflow-y:auto;padding-left:24px;margin-top:4px;font-size:10px;color:#a5d6a7;">
                            ${craftList.slice(0, 20).map(i => `${i.name}: ${i.amount}`).join('<br>')}
                            ${craftList.length > 20 ? `<br><i>...and ${craftList.length - 20} more</i>` : ''}
                        </div>
                    </div>
                    ` : ''}

                    ${sellFragList.length > 0 ? `
                    <div style="margin-bottom:10px;">
                        <label style="display:flex;align-items:center;gap:8px;color:#ff9800;font-size:12px;font-weight:bold;cursor:pointer;">
                            <input type="checkbox" id="csm_sellFrags" checked style="width:16px;height:16px;">
                            üí∞ Sell ${totalSellFrags.toLocaleString()} excess fragments (${sellFragList.length} types)
                        </label>
                        <div id="csm_fragList" style="max-height:100px;overflow-y:auto;padding-left:24px;margin-top:4px;font-size:10px;color:#ffe0b2;">
                            ${sellFragList.slice(0, 20).map(i => `${i.name}: ${i.amount}`).join('<br>')}
                            ${sellFragList.length > 20 ? `<br><i>...and ${sellFragList.length - 20} more</i>` : ''}
                        </div>
                    </div>
                    ` : ''}

                    ${sellItemList.length > 0 ? `
                    <div style="margin-bottom:10px;">
                        <label style="display:flex;align-items:center;gap:8px;color:#f44336;font-size:12px;font-weight:bold;cursor:pointer;">
                            <input type="checkbox" id="csm_sellItems" checked style="width:16px;height:16px;">
                            üóëÔ∏è Sell ${totalSellItems} excess built items (${sellItemList.length} types)
                        </label>
                        <div id="csm_itemList" style="max-height:100px;overflow-y:auto;padding-left:24px;margin-top:4px;font-size:10px;color:#ef9a9a;">
                            ${sellItemList.slice(0, 20).map(i => `${i.name}: ${i.amount}`).join('<br>')}
                            ${sellItemList.length > 20 ? `<br><i>...and ${sellItemList.length - 20} more</i>` : ''}
                        </div>
                    </div>
                    ` : ''}

                    ${craftList.length === 0 && sellFragList.length === 0 && sellItemList.length === 0 ? `
                    <div style="color:#999;font-size:12px;text-align:center;padding:20px;">Nothing to do!</div>
                    ` : ''}

                    <div style="display:flex;gap:8px;margin-top:10px;">
                        <button id="csm_confirm" style="flex:1;background:#4caf50;color:white;border:none;border-radius:6px;padding:10px;cursor:pointer;font-weight:bold;font-size:12px;" ${craftList.length === 0 && sellFragList.length === 0 && sellItemList.length === 0 ? 'disabled' : ''}>‚úì Confirm</button>
                        <button id="csm_cancel" style="background:#666;color:white;border:none;border-radius:6px;padding:10px 16px;cursor:pointer;font-size:12px;">Cancel</button>
                    </div>
                `;

                modal.appendChild(box);
                document.body.appendChild(modal);

                box.querySelector('#csm_cancel').onclick = () => {
                    modal.remove();
                    resolve({ confirmed: false });
                };

                box.querySelector('#csm_confirm').onclick = () => {
                    const result = {
                        confirmed: true,
                        doCraft: box.querySelector('#csm_craft')?.checked ?? false,
                        doSellFrags: box.querySelector('#csm_sellFrags')?.checked ?? false,
                        doSellItems: box.querySelector('#csm_sellItems')?.checked ?? false
                    };
                    modal.remove();
                    resolve(result);
                };
            });
        };

        // Calculate what would be crafted/sold (shared logic)
        const calculateCraftSellLists = () => {
            const fragData = { gear: {...(inventoryData.fragmentGear || {})}, scroll: {...(inventoryData.fragmentScroll || {})} };
            const builtData = { gear: {...(inventoryData.gear || {})}, scroll: {...(inventoryData.scroll || {})} };
            const usedInRecipes = getUsedInRecipes();

            const craftList = [];
            const sellFragList = [];
            const sellItemList = [];

            ['gear', 'scroll'].forEach(type => {
                Object.keys(fragData[type]).forEach(id => {
                    const mergeCost = lib.data?.inventoryItem?.[type]?.[id]?.fragmentMergeCost;
                    if (mergeCost?.fragmentCount) {
                        const k = `${type}_${id}`;
                        const fragCount = fragData[type][id] || 0;
                        const builtCount = builtData[type][id] || 0;
                        const needed = mergeCost.fragmentCount;
                        const canMake = Math.floor(fragCount / needed);
                        const isIngredient = usedInRecipes.has(k);
                        const defaultTarget = isIngredient ? Math.max(builtCount, 50) : builtCount;
                        const target = craftTargets[k] ?? defaultTarget;
                        const name = window.identifyItem?.(id, type) || `${type} #${id}`;

                        // What to craft
                        const needToCraft = Math.max(0, Math.min(canMake, target - builtCount));
                        if (needToCraft > 0) {
                            craftList.push({ type, id: parseInt(id), amount: needToCraft, needed, name });
                        }

                        // Excess frags to sell (only if target is explicitly set)
                        if (craftTargets[k] !== undefined) {
                            const fragsNeededForTarget = Math.max(0, (target - builtCount) * needed);
                            const excessFrags = fragCount - fragsNeededForTarget;
                            if (excessFrags > 0) {
                                sellFragList.push({ type: `fragment${type.charAt(0).toUpperCase() + type.slice(1)}`, id: parseInt(id), amount: excessFrags, name });
                            }
                        }
                    }
                });

                // Excess built items to sell
                Object.keys(builtData[type]).forEach(id => {
                    const k = `${type}_${id}`;
                    const builtCount = builtData[type][id] || 0;
                    const target = craftTargets[k];
                    if (target !== undefined && builtCount > target) {
                        const excess = builtCount - target;
                        const name = window.identifyItem?.(id, type) || `${type} #${id}`;
                        sellItemList.push({ type, id: parseInt(id), amount: excess, name });
                    }
                });
            });

            return { craftList, sellFragList, sellItemList };
        };

        // Build set of items used as ingredients in recipes
        const getUsedInRecipes = () => {
            const used = new Set();
            const gear = lib.data?.inventoryItem?.gear || {};
            const scroll = lib.data?.inventoryItem?.scroll || {};
            Object.values(gear).forEach(g => {
                if (g.craftRecipe?.gear) Object.keys(g.craftRecipe.gear).forEach(id => used.add('gear_' + id));
                if (g.craftRecipe?.scroll) Object.keys(g.craftRecipe.scroll).forEach(id => used.add('scroll_' + id));
            });
            Object.values(scroll).forEach(s => {
                if (s.craftRecipe?.gear) Object.keys(s.craftRecipe.gear).forEach(id => used.add('gear_' + id));
                if (s.craftRecipe?.scroll) Object.keys(s.craftRecipe.scroll).forEach(id => used.add('scroll_' + id));
            });
            return used;
        };

        // Build gear->recipe scroll mapping
        const gearToScrollMap = {};
        Object.entries(lib.data?.inventoryItem?.scroll || {}).forEach(([scrollId, s]) => {
            const scrollName = window.identifyItem?.(scrollId, 'scroll');
            if (scrollName?.endsWith(' - Recipe')) {
                const gearName = scrollName.replace(' - Recipe', '');
                Object.entries(lib.data?.inventoryItem?.gear || {}).forEach(([gearId, g]) => {
                    if (window.identifyItem?.(gearId, 'gear') === gearName) {
                        gearToScrollMap[gearId] = scrollId;
                    }
                });
            }
        });

        const renderTab6 = () => {
            contentContainer.innerHTML = '';

            const usedInRecipes = getUsedInRecipes();

            const fragData = {
                gear: inventoryData.fragmentGear || {},
                scroll: inventoryData.fragmentScroll || {}
            };
            const builtData = {
                gear: inventoryData.gear || {},
                scroll: inventoryData.scroll || {}
            };

            // Build list of craftable items
            const craftableItems = [];
            ['gear', 'scroll'].forEach(type => {
                Object.keys(fragData[type]).forEach(id => {
                    const itemData = lib.data?.inventoryItem?.[type]?.[id];
                    const mergeCost = itemData?.fragmentMergeCost;
                    if (mergeCost?.fragmentCount) {
                        const isIngredient = usedInRecipes.has(`${type}_${id}`);
                        const fragCount = fragData[type][id] || 0;
                        const builtCount = builtData[type][id] || 0;
                        const needed = mergeCost.fragmentCount;
                        const canMake = Math.floor(fragCount / needed);
                        const name = window.identifyItem?.(id, type) || `${type} #${id}`;
                        craftableItems.push({
                            type, id, name, fragCount, builtCount, needed, canMake,
                            goldCost: mergeCost.gold || 0,
                            isIngredient,
                            color: itemData?.color || 0
                        });
                    }
                });
            });

            // Sort state
            let sortCol = localStorage.getItem('hwh_craft_sort_col') || 'canMake';
            let sortDir = localStorage.getItem('hwh_craft_sort_dir') || 'desc';
            let searchText = '';

            const doSort = (items) => {
                return [...items].sort((a, b) => {
                    let av, bv;
                    switch (sortCol) {
                        case 'type': av = a.type; bv = b.type; break;
                        case 'color': av = a.color; bv = b.color; break;
                        case 'name': av = a.name.toLowerCase(); bv = b.name.toLowerCase(); break;
                        case 'built': av = a.builtCount; bv = b.builtCount; break;
                        case 'frags': av = a.fragCount; bv = b.fragCount; break;
                        case 'canMake': av = a.canMake; bv = b.canMake; break;
                        case 'target':
                            av = craftTargets[`${a.type}_${a.id}`] ?? a.builtCount;
                            bv = craftTargets[`${b.type}_${b.id}`] ?? b.builtCount;
                            break;
                        default: av = a.canMake; bv = b.canMake;
                    }
                    if (typeof av === 'string') {
                        return sortDir === 'asc' ? av.localeCompare(bv) : bv.localeCompare(av);
                    }
                    return sortDir === 'asc' ? av - bv : bv - av;
                });
            };

            const doFilter = (items) => {
                if (!searchText) return items;
                const s = searchText.toLowerCase();
                return items.filter(i => i.name.toLowerCase().includes(s) || i.id.includes(s));
            };

            const tab6Content = document.createElement('div');
            tab6Content.style.cssText = 'display:flex;flex-direction:column;overflow:hidden;flex:1;';

            // Search box
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.placeholder = 'üîç Search gear/scroll...';
            searchInput.style.cssText = 'width:100%;background:rgba(0,0,0,0.3);border:1px solid rgba(76,175,80,0.5);color:#a5d6a7;padding:6px 10px;border-radius:6px;font-size:11px;margin-bottom:8px;';
            searchInput.oninput = () => {
                searchText = searchInput.value;
                renderRows();
            };

            // Action row - keep your existing buttons
            const actionRow = document.createElement('div');
            actionRow.style.cssText = 'display:flex;gap:6px;margin-bottom:8px;flex-wrap:wrap;align-items:center;';

            const craftAllBtn = document.createElement('button');
            craftAllBtn.textContent = 'üî® Craft';
            craftAllBtn.style.cssText = 'flex:1;background:#4caf50;color:white;border:none;border-radius:6px;padding:8px;font-size:11px;cursor:pointer;font-weight:bold;';
            craftAllBtn.onclick = async () => {
                const { craftList, sellFragList, sellItemList } = calculateCraftSellLists();
                const result = await showCraftSellConfirmModal(craftList, [], []);
                if (!result.confirmed || !result.doCraft) return;

                craftAllBtn.textContent = '‚è≥';
                const craftResults = await craftAllToTarget();
                craftAllBtn.textContent = 'üî® Craft';

                // Show results
                alert(`‚úì Crafted ${craftResults?.crafted || 0} items (${craftResults?.types || 0} types)`);
            };

            const sellExcessBtn = document.createElement('button');
            sellExcessBtn.textContent = 'üí∞ Sell Excess';
            sellExcessBtn.style.cssText = 'flex:1;background:#9c27b0;color:white;border:none;border-radius:6px;padding:8px;font-size:11px;cursor:pointer;font-weight:bold;';
            sellExcessBtn.onclick = async () => {
                const { craftList, sellFragList, sellItemList } = calculateCraftSellLists();
                const result = await showCraftSellConfirmModal([], sellFragList, sellItemList);
                if (!result.confirmed) return;
                if (!result.doSellFrags && !result.doSellItems) return;

                sellExcessBtn.textContent = '‚è≥';
                const sellResults = await sellExcessFragments(result.doSellFrags, result.doSellItems);
                sellExcessBtn.textContent = 'üí∞ Sell Excess';

                // Show results
                const goldStr = sellResults?.gold > 0 ? `\nü™ô Gold: ${sellResults.gold.toLocaleString()}` : '';
                const coinStr = Object.entries(sellResults?.coins || {}).map(([id, amt]) =>
                                                                             `\nüí∞ ${window.identifyItem?.(id, 'coin') || 'Coin'}: ${amt.toLocaleString()}`
                ).join('');
                alert(`‚úì Sold ${sellResults?.fragTypes || 0} frag types, ${sellResults?.itemTypes || 0} item types${goldStr}${coinStr}`);
            };

            const setTargetBtn = document.createElement('button');
            setTargetBtn.textContent = 'üéØ=Built';
            setTargetBtn.style.cssText = 'background:rgba(76,175,80,0.5);color:#a5d6a7;border:none;border-radius:6px;padding:6px 8px;font-size:10px;cursor:pointer;font-weight:bold;';
            setTargetBtn.onclick = () => {
                craftableItems.forEach(item => {
                    if (tab6ColorFilter === 'all' || item.color == tab6ColorFilter) {
                        craftTargets[`${item.type}_${item.id}`] = item.builtCount;
                    }
                });
                saveCraftTargets();
                renderRows();
            };

            const bulkTargetInput = document.createElement('input');
            bulkTargetInput.type = 'text';
            bulkTargetInput.inputMode = 'numeric';
            bulkTargetInput.placeholder = '#';
            bulkTargetInput.style.cssText = 'width:36px;background:rgba(0,0,0,0.5);color:#ffd700;border:1px solid rgba(76,175,80,0.5);border-radius:4px;padding:4px;font-size:10px;text-align:center;';

            const bulkTargetBtn = document.createElement('button');
            bulkTargetBtn.textContent = 'üéØ All';
            bulkTargetBtn.style.cssText = 'background:rgba(76,175,80,0.5);color:#a5d6a7;border:none;border-radius:6px;padding:6px 8px;font-size:10px;cursor:pointer;font-weight:bold;';
            bulkTargetBtn.onclick = () => {
                const val = parseInt(bulkTargetInput.value) || 0;
                craftableItems.forEach(item => {
                    if (tab6ColorFilter === 'all' || item.color == tab6ColorFilter) {
                        craftTargets[`${item.type}_${item.id}`] = val;
                    }
                });
                saveCraftTargets();
                renderRows();
            };

            // Color filter
            const colorSelect = document.createElement('select');
            colorSelect.style.cssText = 'background:#1a0f08;color:#ffd700;border:1px solid #8b6914;border-radius:4px;padding:4px;font-size:10px;';
            colorSelect.innerHTML = `
                <option value="all" ${tab6ColorFilter==='all'?'selected':''}>All</option>
                <option value="1" ${tab6ColorFilter==='1'?'selected':''}>‚¨ú</option>
                <option value="2" ${tab6ColorFilter==='2'?'selected':''}>üü©</option>
                <option value="3" ${tab6ColorFilter==='3'?'selected':''}>üü¶</option>
                <option value="4" ${tab6ColorFilter==='4'?'selected':''}>üü™</option>
                <option value="5" ${tab6ColorFilter==='5'?'selected':''}>üüß</option>
                <option value="6" ${tab6ColorFilter==='6'?'selected':''}>üü•</option>
            `;
            colorSelect.onchange = () => {
                tab6ColorFilter = colorSelect.value;
                localStorage.setItem('hwh_craft_color_filter', tab6ColorFilter);
                renderRows();
            };

            const refreshBtn = document.createElement('button');
            refreshBtn.textContent = 'üîÑ';
            refreshBtn.style.cssText = 'background:rgba(139,105,20,0.5);color:#ffd700;border:none;border-radius:6px;padding:6px 10px;font-size:11px;cursor:pointer;font-weight:bold;';
            refreshBtn.onclick = async () => {
                refreshBtn.textContent = '‚è≥';
                const resp = await Send(JSON.stringify({calls:[{name:'inventoryGet',args:{},ident:'inv'}]}));
                const freshInv = resp?.results?.[0]?.result?.response;
                if (freshInv) {
                    inventoryData.fragmentGear = freshInv.fragmentGear || {};
                    inventoryData.fragmentScroll = freshInv.fragmentScroll || {};
                    inventoryData.gear = freshInv.gear || {};
                    inventoryData.scroll = freshInv.scroll || {};
                }
                refreshBtn.textContent = 'üîÑ';
                renderTab6();
            };



            // Hero needs button (insert your full heroNeedsBtn code here)
            const heroNeedsBtn = document.createElement('button');
            heroNeedsBtn.textContent = 'üéØ Hero';
            heroNeedsBtn.style.cssText = 'background:rgba(255,152,0,0.5);color:#ffe0b2;border:none;border-radius:6px;padding:6px 8px;font-size:10px;cursor:pointer;font-weight:bold;';
            heroNeedsBtn.title = 'Set targets from hero gear needs';
            heroNeedsBtn.onclick = async () => {
                heroNeedsBtn.textContent = '‚è≥';
                const heroExcluded = JSON.parse(localStorage.getItem('hwh_hero_excluded') || '[]');

                try {
                    const resp = await Send(JSON.stringify({calls:[{name:'heroGetAll',args:{},ident:'h'}]}));
                    const userHeroes = resp.results[0].result.response;

                    // Build gearToScrollMap
                    const gearToScrollMap = {};
                    Object.entries(lib.data.inventoryItem.scroll).forEach(([scrollId, s]) => {
                        const scrollName = window.identifyItem?.(scrollId, 'scroll');
                        if (scrollName?.endsWith(' - Recipe')) {
                            const gearName = scrollName.replace(' - Recipe', '');
                            Object.entries(lib.data.inventoryItem.gear).forEach(([gearId, g]) => {
                                if (window.identifyItem?.(gearId, 'gear') === gearName) {
                                    gearToScrollMap[gearId] = scrollId;
                                }
                            });
                        }
                    });

                    const resolveRecipe = (type, id, qty = 1, result = {gear: {}, scroll: {}}) => {
                        const item = lib.data.inventoryItem[type]?.[id];
                        if (!item) return result;
                        if (item.craftRecipe) {
                            if (item.craftRecipe.gear) {
                                Object.entries(item.craftRecipe.gear).forEach(([gid, gqty]) => {
                                    resolveRecipe('gear', gid, qty * gqty, result);
                                });
                            }
                            if (item.craftRecipe.scroll) {
                                Object.entries(item.craftRecipe.scroll).forEach(([sid, sqty]) => {
                                    resolveRecipe('scroll', sid, qty * sqty, result);
                                });
                            }
                            if (type === 'gear' && gearToScrollMap[id]) {
                                resolveRecipe('scroll', gearToScrollMap[id], qty, result);
                            }
                        } else if (item.fragmentMergeCost) {
                            result[type][id] = (result[type][id] || 0) + qty;
                        }
                        return result;
                    };

                    // Calculate max any single hero needs (for buffer)
                    const maxAnyHero = {gear: {}, scroll: {}};
                    Object.entries(lib.data.hero).forEach(([heroId, hd]) => {
                        if (parseInt(heroId) >= 150 || !hd?.color) return;
                        const heroNeeds = {gear: {}, scroll: {}};
                        for (let c = 1; c <= 18; c++) {
                            (hd.color[c]?.items || []).forEach(gearId => {
                                resolveRecipe('gear', String(gearId), 1, heroNeeds);
                            });
                        }
                        ['gear', 'scroll'].forEach(type => {
                            Object.entries(heroNeeds[type]).forEach(([id, qty]) => {
                                maxAnyHero[type][id] = Math.max(maxAnyHero[type][id] || 0, qty);
                            });
                        });
                    });

                    // Build hero list (ALL heroes id < 150)
                    const heroList = [];
                    Object.entries(lib.data.hero).forEach(([id, hd]) => {
                        if (parseInt(id) >= 150) return;
                        const userHero = userHeroes[id];
                        const currentColor = userHero?.color || 0;
                        const owned = !!userHero;
                        const maxed = currentColor >= 18;
                        heroList.push({ id, name: window.identifyItem(id, 'hero'), owned, currentColor, maxed, colorsRemaining: 18 - currentColor });
                    });
                    heroList.sort((a, b) => {
                        if (a.maxed !== b.maxed) return a.maxed ? 1 : -1;
                        if (a.owned !== b.owned) return a.owned ? -1 : 1;
                        return b.colorsRemaining - a.colorsRemaining;
                    });

                    // Create modal
                    const modal = document.createElement('div');
                    modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);z-index:999999999;display:flex;align-items:center;justify-content:center;';

                    const box = document.createElement('div');
                    box.style.cssText = 'background:#1a1a2e;border:2px solid #8b6914;border-radius:10px;padding:12px;max-width:440px;max-height:80vh;display:flex;flex-direction:column;';

                    box.innerHTML = `
                        <div style="color:#ffd700;font-size:14px;font-weight:bold;margin-bottom:8px;">üéØ Select Heroes to Include</div>
                        <div style="display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap;">
                            <button id="hm_selAll" style="background:#4caf50;color:white;border:none;border-radius:4px;padding:4px 8px;cursor:pointer;font-size:10px;">‚úì All</button>
                            <button id="hm_selOwned" style="background:#2196f3;color:white;border:none;border-radius:4px;padding:4px 8px;cursor:pointer;font-size:10px;">‚úì Owned</button>
                            <button id="hm_selNone" style="background:#666;color:white;border:none;border-radius:4px;padding:4px 8px;cursor:pointer;font-size:10px;">‚úó None</button>
                            <button id="hm_selUnowned" style="background:#ff9800;color:white;border:none;border-radius:4px;padding:4px 8px;cursor:pointer;font-size:10px;">‚úì Unowned</button>
                            <button id="hm_selUnmaxed" style="background:#9c27b0;color:white;border:none;border-radius:4px;padding:4px 8px;cursor:pointer;font-size:10px;">‚úì Unmaxed</button>
                        </div>
                        <div style="display:flex;align-items:center;gap:6px;padding:6px;background:rgba(76,175,80,0.2);border-radius:4px;margin-bottom:6px;">
                            <span style="color:#a5d6a7;font-size:11px;">üõ°Ô∏è Buffer for</span>
                            <input type="number" id="hm_buffer" value="2" min="0" max="10" style="width:32px;background:rgba(0,0,0,0.5);color:#ffd700;border:1px solid rgba(76,175,80,0.5);border-radius:3px;padding:2px;font-size:11px;text-align:center;">
                            <span style="color:#a5d6a7;font-size:11px;">future hero(s)</span>
                        </div>
                        <div id="hm_list" style="overflow-y:auto;flex:1;margin-bottom:8px;max-height:350px;">
                            ${heroList.map(h => `
                                <div style="display:flex;align-items:center;gap:6px;padding:4px 6px;border-bottom:1px solid rgba(139,105,20,0.2);${h.maxed ? 'opacity:0.5;' : ''}${!h.owned ? 'opacity:0.7;' : ''}">
                                    <input type="checkbox" class="hm_cb" data-id="${h.id}" data-owned="${h.owned}" data-maxed="${h.maxed}" ${!h.maxed && !heroExcluded.includes(h.id) ? 'checked' : ''} style="cursor:pointer;width:14px;height:14px;">                                    <span style="color:${h.maxed ? '#666' : (h.owned ? '#4ae29a' : '#ff9800')};font-size:10px;width:14px;">${h.maxed ? '‚òÖ' : (h.owned ? '‚úì' : '?')}</span>
                                    <span class="hm_name" data-id="${h.id}" style="color:#ffd700;flex:1;cursor:pointer;font-size:11px;text-decoration:underline dotted;" title="Click for details">${h.name}</span>
                                    <span style="color:#999;font-size:10px;">${h.maxed ? 'MAX' : `C${h.currentColor}‚Üí18`}</span>
                                </div>
                            `).join('')}
                        </div>
                        <div style="color:#999;font-size:10px;margin-bottom:6px;">Selected: <span id="hm_count">${heroList.filter(h=>!h.maxed && !heroExcluded.includes(h.id)).length}</span> / ${heroList.length}</div>
                        <div style="display:flex;gap:6px;">
                            <button id="hm_calc" style="flex:1;background:#4caf50;color:white;border:none;border-radius:4px;padding:8px;cursor:pointer;font-weight:bold;font-size:12px;">üéØ Calculate Targets</button>
                            <button id="hm_cancel" style="background:#666;color:white;border:none;border-radius:4px;padding:8px 12px;cursor:pointer;font-size:12px;">Cancel</button>
                        </div>
                    `;

                    modal.appendChild(box);
                    document.body.appendChild(modal);

                    const updateCount = () => {
                        box.querySelector('#hm_count').textContent = box.querySelectorAll('.hm_cb:checked').length;
                    };
                    box.querySelectorAll('.hm_cb').forEach(cb => cb.onchange = updateCount);

                    box.querySelector('#hm_selAll').onclick = () => { box.querySelectorAll('.hm_cb').forEach(cb => cb.checked = true); updateCount(); };
                    box.querySelector('#hm_selOwned').onclick = () => { box.querySelectorAll('.hm_cb').forEach(cb => cb.checked = cb.dataset.owned === 'true'); updateCount(); };
                    box.querySelector('#hm_selNone').onclick = () => { box.querySelectorAll('.hm_cb').forEach(cb => cb.checked = false); updateCount(); };
                    box.querySelector('#hm_selUnowned').onclick = () => { box.querySelectorAll('.hm_cb').forEach(cb => cb.checked = cb.dataset.owned === 'false'); updateCount(); };
                    box.querySelector('#hm_selUnmaxed').onclick = () => { box.querySelectorAll('.hm_cb').forEach(cb => cb.checked = cb.dataset.maxed === 'false'); updateCount(); };
                    box.querySelector('#hm_cancel').onclick = () => {
                        const uncheckedIds = [...box.querySelectorAll('.hm_cb:not(:checked)')]
                        .filter(cb => cb.dataset.maxed === 'false')
                        .map(cb => cb.dataset.id);
                        saveHeroExcluded(uncheckedIds);
                        modal.remove();
                    };

                    // Hero name click - show requirements in separate popup
                    box.querySelectorAll('.hm_name').forEach(el => {
                        el.onclick = (e) => {
                            e.stopPropagation();
                            const heroId = el.dataset.id;
                            const hd = lib.data.hero[heroId];
                            const userHero = userHeroes[heroId];
                            const currentColor = userHero?.color || 0;
                            const heroName = window.identifyItem(heroId, 'hero');

                            const heroNeeds = {gear: {}, scroll: {}};
                            let colorBreakdown = [];

                            for (let c = 1; c <= 18; c++) {
                                const items = hd.color?.[c]?.items || [];
                                if (items.length) {
                                    const isPast = c <= currentColor;
                                    colorBreakdown.push(`<div style="color:${isPast ? '#666' : '#ffd700'};${isPast ? 'text-decoration:line-through;' : ''}font-size:10px;">C${c}: ${items.map(g => window.identifyItem(String(g), 'gear')).join(', ')}</div>`);
                                    if (!isPast) {
                                        items.forEach(gearId => resolveRecipe('gear', String(gearId), 1, heroNeeds));
                                    }
                                }
                            }

                            const gearList = Object.entries(heroNeeds.gear).sort((a,b) => b[1] - a[1]).map(([id, qty]) => `${window.identifyItem(id, 'gear')}: ${qty}`);
                            const scrollList = Object.entries(heroNeeds.scroll).sort((a,b) => b[1] - a[1]).map(([id, qty]) => `${window.identifyItem(id, 'scroll')}: ${qty}`);

                            document.querySelector('#hm_detail')?.remove();

                            const detailPopup = document.createElement('div');
                            detailPopup.id = 'hm_detail';
                            detailPopup.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#252540;border:2px solid #ffd700;border-radius:8px;padding:12px;width:480px;max-width:90vw;max-height:70vh;overflow-y:auto;z-index:9999999999;box-shadow:0 4px 20px rgba(0,0,0,0.5);';

                            detailPopup.innerHTML = `
                                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                                    <span style="color:#ffd700;font-weight:bold;font-size:13px;">${heroName} (C${currentColor}‚Üí18)</span>
                                    <button id="hm_closeDetail" style="background:none;border:none;color:#999;cursor:pointer;font-size:16px;">‚úï</button>
                                </div>
                                <details style="margin-bottom:8px;">
                                    <summary style="color:#a5d6a7;cursor:pointer;font-size:11px;">Color Breakdown</summary>
                                    <div style="padding-left:12px;color:#ccc;max-height:150px;overflow-y:auto;">${colorBreakdown.join('')}</div>
                                </details>
                                <details open style="margin-bottom:8px;">
                                    <summary style="color:#a5d6a7;cursor:pointer;font-size:11px;">Base Gear (${gearList.length})</summary>
                                    <div style="padding-left:12px;color:#ccc;font-size:10px;max-height:120px;overflow-y:auto;">${gearList.join('<br>') || 'None'}</div>
                                </details>
                                <details open style="margin-bottom:8px;">
                                    <summary style="color:#a5d6a7;cursor:pointer;font-size:11px;">Recipe Scrolls (${scrollList.length})</summary>
                                    <div style="padding-left:12px;color:#ccc;font-size:10px;max-height:120px;overflow-y:auto;">${scrollList.join('<br>') || 'None'}</div>
                                </details>
                                <button id="hm_copy" style="background:#666;color:white;border:none;border-radius:4px;padding:6px 10px;font-size:10px;cursor:pointer;">üìã Copy to Clipboard</button>
                            `;

                            document.body.appendChild(detailPopup);

                            detailPopup.querySelector('#hm_closeDetail').onclick = () => detailPopup.remove();

                            detailPopup.querySelector('#hm_copy').onclick = () => {
                                const text = `=== ${heroName} (C${currentColor}‚Üí18) ===\n\nBase Gear:\n${gearList.join('\n')}\n\nRecipe Scrolls:\n${scrollList.join('\n')}`;
                                navigator.clipboard.writeText(text);
                                alert('Copied!');
                            };
                        };
                    });
                    box.querySelector('#hm_calc').onclick = () => {
                        document.querySelector('#hm_detail')?.remove();
                        const selectedIds = new Set([...box.querySelectorAll('.hm_cb:checked')].map(cb => cb.dataset.id));
                        // Save unchecked heroes (exclude maxed since they're always unchecked)
                        const uncheckedIds = [...box.querySelectorAll('.hm_cb:not(:checked)')]
                        .filter(cb => cb.dataset.maxed === 'false')
                        .map(cb => cb.dataset.id);
                        saveHeroExcluded(uncheckedIds);
                        const bufferMultiplier = parseInt(box.querySelector('#hm_buffer')?.value) || 0;
                        modal.remove();

                        // Calculate per-hero needs for report
                        const perHeroNeeds = [];
                        const totalBase = {gear: {}, scroll: {}};

                        selectedIds.forEach(heroId => {
                            const hd = lib.data.hero[heroId];
                            if (!hd?.color) return;
                            const userHero = userHeroes[heroId];
                            const currentColor = userHero?.color || 0;
                            const heroName = window.identifyItem(heroId, 'hero');
                            const heroNeeds = {gear: {}, scroll: {}};

                            for (let c = currentColor + 1; c <= 18; c++) {
                                (hd.color[c]?.items || []).forEach(gearId => {
                                    resolveRecipe('gear', String(gearId), 1, heroNeeds);
                                });
                            }

                            // Add to total
                            ['gear', 'scroll'].forEach(type => {
                                Object.entries(heroNeeds[type]).forEach(([id, qty]) => {
                                    totalBase[type][id] = (totalBase[type][id] || 0) + qty;
                                });
                            });

                            if (Object.keys(heroNeeds.gear).length || Object.keys(heroNeeds.scroll).length) {
                                perHeroNeeds.push({ heroId, heroName, currentColor, heroNeeds });
                            }
                        });

                        // Reset all craftable items to 0
                        ['gear', 'scroll'].forEach(type => {
                            Object.keys(lib.data.inventoryItem[type] || {}).forEach(id => {
                                if (lib.data.inventoryItem[type][id]?.fragmentMergeCost) {
                                    craftTargets[`${type}_${id}`] = 0;
                                }
                            });
                        });

                        // Set targets from selected heroes
                        ['gear', 'scroll'].forEach(type => {
                            Object.entries(totalBase[type]).forEach(([id, qty]) => {
                                craftTargets[`${type}_${id}`] = qty;
                            });
                        });

                        // Calculate buffer additions
                        const bufferAdded = {gear: {}, scroll: {}};
                        if (bufferMultiplier > 0) {
                            ['gear', 'scroll'].forEach(type => {
                                Object.entries(maxAnyHero[type]).forEach(([id, qty]) => {
                                    const key = `${type}_${id}`;
                                    const floor = qty * bufferMultiplier;
                                    const current = craftTargets[key] || 0;
                                    if (floor > current) {
                                        bufferAdded[type][id] = floor - current;
                                        craftTargets[key] = floor;
                                    }
                                });
                            });
                        }

                        saveCraftTargets();

                        // Build summary report
                        let report = [];
                        report.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                        report.push('üéØ HERO GEAR TARGET CALCULATION');
                        report.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                        report.push(`Selected: ${selectedIds.size} heroes | Buffer: ${bufferMultiplier}x`);
                        report.push('');

                        // Per-hero breakdown
                        report.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                        report.push('üìã PER-HERO NEEDS');
                        report.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                        perHeroNeeds.forEach(h => {
                            report.push(`\n${h.heroName} (C${h.currentColor}‚Üí18):`);
                            const gearItems = Object.entries(h.heroNeeds.gear).sort((a,b) => b[1] - a[1]);
                            const scrollItems = Object.entries(h.heroNeeds.scroll).sort((a,b) => b[1] - a[1]);
                            if (gearItems.length) {
                                report.push('  Gear: ' + gearItems.map(([id, qty]) => `${window.identifyItem(id, 'gear')}√ó${qty}`).join(', '));
                            }
                            if (scrollItems.length) {
                                report.push('  Scrolls: ' + scrollItems.map(([id, qty]) => `${window.identifyItem(id, 'scroll')}√ó${qty}`).join(', '));
                            }
                        });

                        // Buffer additions
                        if (bufferMultiplier > 0 && (Object.keys(bufferAdded.gear).length || Object.keys(bufferAdded.scroll).length)) {
                            report.push('');
                            report.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                            report.push(`üõ°Ô∏è BUFFER ADDITIONS (${bufferMultiplier}x max single hero)`);
                            report.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                            const bufferGear = Object.entries(bufferAdded.gear).sort((a,b) => b[1] - a[1]);
                            const bufferScroll = Object.entries(bufferAdded.scroll).sort((a,b) => b[1] - a[1]);
                            if (bufferGear.length) {
                                report.push('Gear: ' + bufferGear.map(([id, qty]) => `${window.identifyItem(id, 'gear')}+${qty}`).join(', '));
                            }
                            if (bufferScroll.length) {
                                report.push('Scrolls: ' + bufferScroll.map(([id, qty]) => `${window.identifyItem(id, 'scroll')}+${qty}`).join(', '));
                            }
                        }

                        // Final totals
                        report.push('');
                        report.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                        report.push('üìä FINAL TARGETS');
                        report.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');

                        const finalGear = Object.entries(craftTargets)
                        .filter(([k, v]) => k.startsWith('gear_') && v > 0)
                        .map(([k, v]) => [k.replace('gear_', ''), v])
                        .sort((a, b) => b[1] - a[1]);
                        const finalScroll = Object.entries(craftTargets)
                        .filter(([k, v]) => k.startsWith('scroll_') && v > 0)
                        .map(([k, v]) => [k.replace('scroll_', ''), v])
                        .sort((a, b) => b[1] - a[1]);

                        report.push(`\nBase Gear (${finalGear.length} items):`);
                        finalGear.forEach(([id, qty]) => report.push(`  ${window.identifyItem(id, 'gear')}: ${qty}`));

                        report.push(`\nRecipe Scrolls (${finalScroll.length} items):`);
                        finalScroll.forEach(([id, qty]) => report.push(`  ${window.identifyItem(id, 'scroll')}: ${qty}`));

                        report.push('');
                        report.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                        const reportText = report.join('\n');
                        navigator.clipboard.writeText(reportText);

                        console.log(`üéØ Targets set for ${selectedIds.size} heroes (buffer: ${bufferMultiplier}x). Gear: ${finalGear.length}, Scrolls: ${finalScroll.length}`);
                        console.log('üìã Summary copied to clipboard!');
                        renderTab6();
                    };

                } catch (e) {
                    console.error('Hero needs calc failed:', e);
                }
                heroNeedsBtn.textContent = 'üéØ Hero';
            };


            actionRow.append(craftAllBtn, sellExcessBtn, setTargetBtn, bulkTargetInput, bulkTargetBtn, heroNeedsBtn, colorSelect, refreshBtn);

            // Grid header with sortable columns
            const gridHeader = document.createElement('div');
            gridHeader.style.cssText = 'display:grid;grid-template-columns:50px 28px 1fr 50px 75px 45px 55px 36px;gap:4px;padding:8px 10px;background:rgba(76,175,80,0.3);border-radius:6px;font-weight:bold;margin-bottom:6px;font-size:10px;color:#a5d6a7;';

            const headers = [
                { col: 'type', label: 'Type', align: 'center' },
                { col: 'color', label: 'Clr', align: 'center' },
                { col: 'name', label: 'Name', align: 'left' },
                { col: 'built', label: 'Built', align: 'center' },
                { col: 'frags', label: 'Frags', align: 'center' },
                { col: 'canMake', label: 'Can', align: 'center' },
                { col: 'target', label: 'Target', align: 'center' },
                { col: null, label: '', align: 'center' }
            ];

            headers.forEach(h => {
                const div = document.createElement('div');
                div.style.cssText = `text-align:${h.align};${h.col ? 'cursor:pointer;user-select:none;' : ''}`;
                div.textContent = h.label + (h.col === sortCol ? (sortDir === 'asc' ? ' ‚ñ≤' : ' ‚ñº') : '');
                if (h.col) {
                    div.onclick = () => {
                        if (sortCol === h.col) {
                            sortDir = sortDir === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortCol = h.col;
                            sortDir = 'desc';
                        }
                        localStorage.setItem('hwh_craft_sort_col', sortCol);
                        localStorage.setItem('hwh_craft_sort_dir', sortDir);
                        // Update header indicators
                        [...gridHeader.children].forEach((c, i) => {
                            if (headers[i].col) {
                                c.textContent = headers[i].label + (headers[i].col === sortCol ? (sortDir === 'asc' ? ' ‚ñ≤' : ' ‚ñº') : '');
                            }
                        });
                        renderRows();
                    };
                }
                gridHeader.appendChild(div);
            });

            // Scroll container with virtual scrolling
            const scrollBox = document.createElement('div');
            scrollBox.style.cssText = 'overflow-y:auto;flex:1;';

            // Virtual scrolling setup
            const ROW_HEIGHT = 32;
            const BUFFER = 8;
            let filteredItems = [];
            let lastStart = -1;
            let lastEnd = -1;

            const virtualContainer = document.createElement('div');
            virtualContainer.style.cssText = 'position:relative;';
            scrollBox.appendChild(virtualContainer);

            // Footer
            const footerEl = document.createElement('div');
            footerEl.style.cssText = 'padding-top:8px;font-size:11px;color:#999;';

            const colorMap = {1:'‚¨ú',2:'üü©',3:'üü¶',4:'üü™',5:'üüß',6:'üü•'};

            const applyFilters = () => {
                let items = craftableItems;
                if (tab6ColorFilter !== 'all') {
                    items = items.filter(i => i.color == tab6ColorFilter);
                }
                items = doFilter(items);
                items = doSort(items);
                filteredItems = items;
                virtualContainer.style.height = `${filteredItems.length * ROW_HEIGHT}px`;
                lastStart = -1;
                lastEnd = -1;
            };

            let cachedViewHeight = null;

            const renderVisibleRows = () => {
                if (document.hidden) return;

                const scrollTop = scrollBox.scrollTop;
                if (!cachedViewHeight) cachedViewHeight = scrollBox.clientHeight;
                const viewHeight = cachedViewHeight;
                const start = Math.max(0, Math.floor(scrollTop / ROW_HEIGHT) - BUFFER);
                const end = Math.min(filteredItems.length, Math.ceil((scrollTop + viewHeight) / ROW_HEIGHT) + BUFFER);

                if (start === lastStart && end === lastEnd) return;
                lastStart = start;
                lastEnd = end;

                virtualContainer.innerHTML = '';

                for (let i = start; i < end; i++) {
                    const item = filteredItems[i];
                    const k = `${item.type}_${item.id}`;
                    const defaultTarget = item.isIngredient ? Math.max(item.builtCount, 50) : item.builtCount;
                    const target = craftTargets[k] ?? defaultTarget;
                    const needToCraft = Math.max(0, target - item.builtCount);
                    const willCraft = Math.min(item.canMake, needToCraft);

                    const typeIcon = item.type === 'gear' ? '‚öôÔ∏è' : 'üìú';
                    const typeColor = item.type === 'gear' ? '#607d8b' : '#9c27b0';
                    const ingredientFlag = item.isIngredient ? '<span title="Used in recipes" style="color:#ff9800">‚ö†Ô∏è</span>' : '';
                    const fragColor = item.canMake > 0 ? '#4ae29a' : (item.fragCount > 0 ? '#ffd700' : '#666');
                    const targetColor = willCraft > 0 ? '#4ae29a' : '#999';

                    const row = document.createElement('div');
                    row.style.cssText = `position:absolute;top:${i * ROW_HEIGHT}px;left:0;right:0;height:${ROW_HEIGHT}px;display:grid;grid-template-columns:50px 28px 1fr 50px 75px 45px 55px 36px;gap:4px;padding:4px 10px;align-items:center;font-size:11px;border-bottom:1px solid rgba(139,105,20,0.2);box-sizing:border-box;`;

                    row.innerHTML = `
                        <div style="text-align:center;color:${typeColor};font-weight:bold">${typeIcon}${ingredientFlag}</div>
                        <div style="text-align:center;font-size:9px">${colorMap[item.color]||'‚ö´'}</div>
                        <div class="twk-gold" style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="ID:${item.id}">${item.name}</div>
                        <div style="text-align:center;font-weight:bold;color:#4ae29a">${item.builtCount}</div>
                        <div style="text-align:center;font-family:monospace;color:${fragColor};font-size:10px">${item.fragCount}/${item.needed}</div>
                        <div style="text-align:center;font-weight:bold;color:${item.canMake > 0 ? '#4ae29a' : '#666'}">${item.canMake}</div>
                        <div style="text-align:center"><input type="text" inputmode="numeric" value="${target}" style="width:44px;background:rgba(0,0,0,0.5);color:${targetColor};border:1px solid rgba(76,175,80,0.5);border-radius:4px;padding:2px;font-size:10px;text-align:center;-moz-appearance:textfield;"></div>
                        <div style="text-align:center">${item.canMake > 0 ? `<button style="background:#4caf50;color:white;border:none;border-radius:4px;padding:2px 5px;font-size:10px;cursor:pointer" title="Craft ${willCraft > 0 ? willCraft : item.canMake}">üî®</button>` : ''}</div>
                    `;

                    const targetInput = row.querySelector('input');
                    targetInput.onchange = () => {
                        craftTargets[k] = Math.max(0, parseInt(targetInput.value) || 0);
                        saveCraftTargets();
                        const newTarget = craftTargets[k];
                        const newNeedToCraft = Math.max(0, newTarget - item.builtCount);
                        const newWillCraft = Math.min(item.canMake, newNeedToCraft);
                        targetInput.style.color = newWillCraft > 0 ? '#4ae29a' : '#999';
                    };

                    const craftBtn = row.querySelector('button');
                    if (craftBtn) {
                        craftBtn.onclick = async () => {
                            const amt = willCraft > 0 ? willCraft : item.canMake;
                            if (amt > 0) {
                                craftBtn.textContent = '‚è≥';
                                try {
                                    await Send(JSON.stringify({calls:[{name:'inventoryCraftFragments',args:{type:item.type,libId:parseInt(item.id),amount:amt},ident:'craft'}]}));
                                    item.fragCount -= amt * item.needed;
                                    item.builtCount += amt;
                                    item.canMake = Math.floor(item.fragCount / item.needed);
                                    inventoryData[`fragment${item.type.charAt(0).toUpperCase() + item.type.slice(1)}`][item.id] = item.fragCount;
                                    inventoryData[item.type][item.id] = item.builtCount;
                                } catch (e) { console.error('Craft failed:', e); }
                                renderRows();
                            }
                        };
                    }

                    virtualContainer.appendChild(row);
                }

                // Update footer
                const totalCanMake = filteredItems.reduce((sum, i) => sum + i.canMake, 0);
                const ingredientCount = filteredItems.filter(i => i.isIngredient).length;
                footerEl.textContent = `${filteredItems.length}/${craftableItems.length} items (${ingredientCount} ‚ö†Ô∏è) ‚Ä¢ ${totalCanMake.toLocaleString()} craftable`;
            };

            const renderRows = () => {
                applyFilters();
                renderVisibleRows();
            };

            // Scroll event for virtual rendering
            let scrollTimeout;
            scrollBox.addEventListener('scroll', () => {
                if (scrollTimeout) cancelAnimationFrame(scrollTimeout);
                scrollTimeout = requestAnimationFrame(renderVisibleRows);
            }, { passive: true });

            // Reset cached height on resize
            window.addEventListener('resize', () => { cachedViewHeight = null; }, { passive: true });

            tab6Content.append(searchInput, actionRow, gridHeader, scrollBox, footerEl);
            contentContainer.appendChild(tab6Content);

            renderRows();
        };

        // Craft all items to their targets
        const craftAllToTarget = async () => {
            const fragData = { gear: {...(inventoryData.fragmentGear || {})}, scroll: {...(inventoryData.fragmentScroll || {})} };
            const builtData = { gear: {...(inventoryData.gear || {})}, scroll: {...(inventoryData.scroll || {})} };
            const usedInRecipes = getUsedInRecipes();

            const toCraft = [];
            ['gear', 'scroll'].forEach(type => {
                Object.keys(fragData[type]).forEach(id => {
                    const mergeCost = lib.data?.inventoryItem?.[type]?.[id]?.fragmentMergeCost;
                    if (mergeCost?.fragmentCount) {
                        const k = `${type}_${id}`;
                        const fragCount = fragData[type][id] || 0;
                        const builtCount = builtData[type][id] || 0;
                        const needed = mergeCost.fragmentCount;
                        const canMake = Math.floor(fragCount / needed);
                        const isIngredient = usedInRecipes.has(k);
                        const defaultTarget = isIngredient ? Math.max(builtCount, 50) : builtCount;
                        const target = craftTargets[k] ?? defaultTarget;
                        const needToCraft = Math.max(0, Math.min(canMake, target - builtCount));
                        if (needToCraft > 0) {
                            toCraft.push({ type, id: parseInt(id), amount: needToCraft, needed });
                        }
                    }
                });
            });

            if (toCraft.length === 0) { console.log('Nothing to craft'); return; }

            console.log(`Crafting ${toCraft.length} items...`);
            for (const item of toCraft) {
                try {
                    await Send(JSON.stringify({calls:[{name:'inventoryCraftFragments',args:{type:item.type,libId:item.id,amount:item.amount},ident:'craft'}]}));
                    fragData[item.type][item.id] = (fragData[item.type][item.id] || 0) - (item.amount * item.needed);
                    builtData[item.type][item.id] = (builtData[item.type][item.id] || 0) + item.amount;
                    await new Promise(r => setTimeout(r, 100));
                } catch (e) { console.error('Craft failed:', item, e); }
            }

            inventoryData.fragmentGear = fragData.gear;
            inventoryData.fragmentScroll = fragData.scroll;
            inventoryData.gear = builtData.gear;
            inventoryData.scroll = builtData.scroll;
            renderTab6();

            const totalCrafted = toCraft.reduce((s, i) => s + i.amount, 0);
            return { crafted: totalCrafted, types: toCraft.length };
        };

        const sellExcessFragments = async (doFrags = true, doItems = true) => {
            const fragData = { gear: {...(inventoryData.fragmentGear || {})}, scroll: {...(inventoryData.fragmentScroll || {})} };
            const builtData = { gear: {...(inventoryData.gear || {})}, scroll: {...(inventoryData.scroll || {})} };
            let totalGold = 0;
            const coinRewards = {};
            const toSellFrags = [];
            const toSellItems = [];

            ['gear', 'scroll'].forEach(type => {
                // Sell excess fragments
                Object.keys(fragData[type]).forEach(id => {
                    const mergeCost = lib.data?.inventoryItem?.[type]?.[id]?.fragmentMergeCost;
                    if (mergeCost?.fragmentCount) {
                        const k = `${type}_${id}`;
                        const fragCount = fragData[type][id] || 0;
                        const builtCount = builtData[type][id] || 0;
                        const needed = mergeCost.fragmentCount;
                        const target = craftTargets[k] ?? builtCount;
                        const fragsNeededForTarget = Math.max(0, (target - builtCount) * needed);
                        const excess = fragCount - fragsNeededForTarget;
                        if (excess > 0) {
                            toSellFrags.push({ type: `fragment${type.charAt(0).toUpperCase() + type.slice(1)}`, id: parseInt(id), amount: excess, name: window.identifyItem?.(id, type) || id });
                        }
                    }
                });

                // Sell excess built items
                Object.keys(builtData[type]).forEach(id => {
                    const k = `${type}_${id}`;
                    const builtCount = builtData[type][id] || 0;
                    const target = craftTargets[k];
                    if (target !== undefined && builtCount > target) {
                        const excess = builtCount - target;
                        toSellItems.push({ type, id: parseInt(id), amount: excess, name: window.identifyItem?.(id, type) || id });
                    }
                });
            });

            if (toSellFrags.length === 0 && toSellItems.length === 0) {
                console.log('No excess to sell');
                return;
            }

            console.log(`Selling ${toSellFrags.length} frag types, ${toSellItems.length} item types...`);

            // Sell fragments
            for (const item of (doFrags ? toSellFrags : [])) {
                try {
                    const resp = await Send(JSON.stringify({calls:[{name:'inventorySell',args:{type:item.type,libId:item.id,amount:item.amount},ident:'sell'}]}));
                    const r = resp?.results?.[0]?.result?.response;
                    if (r?.gold) totalGold += r.gold;
                    if (r?.coin) {
                        Object.entries(r.coin).forEach(([coinId, amt]) => {
                            coinRewards[coinId] = (coinRewards[coinId] || 0) + amt;
                        });
                    }
                    console.log(`  Sold ${item.amount} ${item.name} frags`);
                    const baseType = item.type.replace('fragment', '').toLowerCase();
                    fragData[baseType][item.id] = (fragData[baseType][item.id] || 0) - item.amount;
                    await new Promise(r => setTimeout(r, 100));
                } catch (e) { console.error('Sell frag failed:', item, e); }
            }


            // Sell built items
            for (const item of (doItems ? toSellItems : [])) {
                try {
                    const resp = await Send(JSON.stringify({calls:[{name:'inventorySell',args:{type:item.type,libId:item.id,amount:item.amount},ident:'sell'}]}));
                    const r = resp?.results?.[0]?.result?.response;
                    if (r?.gold) totalGold += r.gold;
                    if (r?.coin) {
                        Object.entries(r.coin).forEach(([coinId, amt]) => {
                            coinRewards[coinId] = (coinRewards[coinId] || 0) + amt;
                        });
                    }
                    console.log(`  Sold ${item.amount} ${item.name}`);
                    builtData[item.type][item.id] = (builtData[item.type][item.id] || 0) - item.amount;
                    await new Promise(r => setTimeout(r, 100));
                } catch (e) { console.error('Sell item failed:', item, e); }
            }

            inventoryData.fragmentGear = fragData.gear;
            inventoryData.fragmentScroll = fragData.scroll;
            inventoryData.gear = builtData.gear;
            inventoryData.scroll = builtData.scroll;
            renderTab6();

            return {
                fragTypes: doFrags ? toSellFrags.length : 0,
                itemTypes: doItems ? toSellItems.length : 0,
                gold: totalGold,
                coins: coinRewards
            };
        };


        // ===== SELL FRAGMENTS NOW =====
        const sellFragmentsNow = async () => {
            const SendFunction = getSend();
            if (!SendFunction) { alert('‚ùå Send function not available'); return; }

            // Refresh inventory first
            let freshInventory;
            try {
                const result = await SendFunction(JSON.stringify({ calls: [{ name: 'inventoryGet', args: {}, ident: 'inv' }] }));
                freshInventory = result?.results?.[0]?.result?.response;
            } catch (e) { alert('‚ùå Could not refresh inventory: ' + e.message); return; }
            if (!freshInventory) { alert('‚ùå Could not get inventory data'); return; }

            // Preview what will be sold
            const preview = await executeFragmentSells(freshInventory, fragmentSellSettings, { includeGearScroll: true, dryRun: true });
            if (!preview.hasWork) {
                alert('‚ÑπÔ∏è No fragments to sell.\n\nMake sure you have:\n‚Ä¢ Checked the "Sell" checkbox for items\n‚Ä¢ Set a "Keep" amount lower than current quantity');
                return;
            }

            // Confirm
            const confirmMsg = `Sell ${preview.details.length} fragment type(s)?\n\n${preview.details.slice(0, 10).join('\n')}${preview.details.length > 10 ? `\n...and ${preview.details.length - 10} more` : ''}`;
            if (!confirm(confirmMsg)) return;

            // Execute
            const result = await executeFragmentSells(freshInventory, fragmentSellSettings, { includeGearScroll: true });

            // Refresh display
            try {
                const refreshResult = await SendFunction(JSON.stringify({ calls: [{ name: 'inventoryGet', args: {}, ident: 'inv' }] }));
                const newInv = refreshResult?.results?.[0]?.result?.response;
                if (newInv) {
                    inventoryData.fragmentHero = newInv.fragmentHero || {};
                    inventoryData.fragmentTitan = newInv.fragmentTitan || {};
                    inventoryData.fragmentPet = newInv.fragmentPet || {};
                    inventoryData.fragmentScroll = newInv.fragmentScroll || {};
                    inventoryData.fragmentGear = newInv.fragmentGear || {};
                    inventoryData.fragmentArtifact = newInv.fragmentArtifact || {};
                    inventoryData.fragmentTitanArtifact = newInv.fragmentTitanArtifact || {};
                }
            } catch (e) { debugLog('Inventory refresh after sell failed:', e); }

            fragmentMasterList = null;
            renderTab5();

            // Show results
            let resultMsg = `‚úÖ Sold fragments!`;
            if (result.gold > 0) resultMsg += `\nü™ô Gold: +${result.gold.toLocaleString()}`;
            Object.entries(result.coins).forEach(([coinId, amount]) => {
                const coinName = window.identifyItem?.(coinId, 'coin') || `Coin #${coinId}`;
                resultMsg += `\nüí∞ ${coinName}: +${amount.toLocaleString()}`;
            });
            alert(resultMsg);
        };

        // ===== CUSTOM REWARD POPUP =====
        const showRewardSummary = (summaryText) => {
            // Create overlay for reward popup
            const rewardOverlay = document.createElement('div');
            rewardOverlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200000;
            backdrop-filter: blur(5px);
            animation: fadeIn 0.2s ease-in;
        `;

            // Create popup
            const rewardPopup = document.createElement('div');
            rewardPopup.style.cssText = `
            background: linear-gradient(135deg, #1a3d1a 0%, #0d1f0d 100%);
            border: 3px solid #4ae29a;
            border-radius: 12px;
            padding: 20px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            box-shadow: 0 10px 50px rgba(74, 226, 154, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            animation: slideIn 0.3s ease-out;
        `;

            // Add animations
            const style = document.createElement('style');
            style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes slideIn {
                from { transform: translateY(-30px); opacity: 0; }
                to { transform: translateY(0); opacity: 1; }
            }
        `;
            document.head.appendChild(style);

            // Header
            const header = document.createElement('div');
            header.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 2px solid rgba(74, 226, 154, 0.3);
        `;

            const title = document.createElement('h2');
            title.textContent = 'üéÅ Rewards Summary';
            title.style.cssText = `
            color: #4ae29a;
            margin: 0;
            font-size: 20px;
            text-shadow: 0 0 10px rgba(74, 226, 154, 0.5);
        `;

            const closeBtn = document.createElement('button');
            closeBtn.textContent = '‚úñ';
            closeBtn.style.cssText = `
            background: #4ae29a;
            color: #0d1f0d;
            border: none;
            border-radius: 6px;
            padding: 6px 14px;
            font-size: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        `;
            closeBtn.onmouseover = () => {
                closeBtn.style.background = '#5ff3ae';
                closeBtn.style.transform = 'scale(1.1)';
            };
            closeBtn.onmouseout = () => {
                closeBtn.style.background = '#4ae29a';
                closeBtn.style.transform = 'scale(1)';
            };
            closeBtn.onclick = () => {
                document.body.removeChild(rewardOverlay);
                // Close main inventory and reopen to refresh
                try {
                    if (overlay && overlay.parentNode) {
                        overlay.parentNode.removeChild(overlay);
                    }
                } catch (err) {
                    console.error('Error removing overlay:', err);
                }
                setTimeout(() => {
                    window.showInventoryManager();
                }, 100);
            };

            header.appendChild(title);
            header.appendChild(closeBtn);

            // Content
            const content = document.createElement('div');
            content.style.cssText = `
            overflow-y: auto;
            flex: 1;
            color: #ccc;
            font-size: 12px;
            line-height: 1.8;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 6px;
            white-space: pre-wrap;
        `;

            // Parse and format the summary text
            const formattedText = summaryText
            .replace(/‚úÖ/g, '<span class="twk-green">‚úÖ</span>')
            .replace(/‚ùå/g, '<span class="twk-red">‚ùå</span>')
            .replace(/üîÑ Round \d+:/g, match => `<span class="twk-gold-bold">${match}</span>`)
            .replace(/üìä TOTAL REWARDS:/g, '<span style="color: #4ae29a; font-weight: bold; font-size: 14px;">üìä TOTAL REWARDS:</span>')
            .replace(/‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ/g, '<span class="twk-green">‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</span>')
            .replace(/‚Ä¢ (.+?): (\d[\d,]*)/g, (match, item, amount) => {
                return `‚Ä¢ <span class="twk-gold">${item}</span>: <span class="twk-green-bold">${amount}</span>`;
            });

            content.innerHTML = formattedText;

            // Footer button
            const footer = document.createElement('div');
            footer.style.cssText = `
            margin-top: 15px;
            padding-top: 12px;
            border-top: 2px solid rgba(74, 226, 154, 0.3);
            text-align: center;
        `;

            const okBtn = document.createElement('button');
            okBtn.textContent = 'OK';
            okBtn.style.cssText = `
            background: #4ae29a;
            color: #0d1f0d;
            border: none;
            border-radius: 6px;
            padding: 10px 40px;
            font-size: 14px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        `;
            okBtn.onmouseover = () => {
                okBtn.style.background = '#5ff3ae';
                okBtn.style.transform = 'scale(1.05)';
            };
            okBtn.onmouseout = () => {
                okBtn.style.background = '#4ae29a';
                okBtn.style.transform = 'scale(1)';
            };
            okBtn.onclick = closeBtn.onclick;

            footer.appendChild(okBtn);

            rewardPopup.appendChild(header);
            rewardPopup.appendChild(content);
            rewardPopup.appendChild(footer);
            rewardOverlay.appendChild(rewardPopup);
            document.body.appendChild(rewardOverlay);
        };

        // ===== USE ALL WITH NESTING =====
        const useAllWithNesting = async (checkedItems) => {
            // Get fresh inventory data first
            try {
                const data = {
                    calls: [{
                        name: "inventoryGet",
                        args: {},
                        ident: "inventoryGet"
                    }]
                };

                const SendFunction = getSend();
                const response = await SendFunction(JSON.stringify(data));

                if (response && response.results && response.results[0]) {
                    const result = response.results[0];
                    if (result.result && result.result.response) {
                        inventoryData = result.result.response;
                    }
                }
            } catch (e) {
                console.error('Failed to refresh inventory:', e);
            }

            // Get all checked items that are in stock
            const consumables = inventoryData.consumable || {};

            // Get Auto-Use list items
            let checkedItemIds = Object.keys(checkedItems).filter(id => consumables[id] > 0);

            // Add Use Selected items marked for auto AND have choice set
            const autoSelectedItems = Object.keys(tab2AutoItems).filter(id => {
                if (!consumables[id] || consumables[id] <= 0) return false;
                if (checkedItemIds.includes(id)) return false;
                const cached = window._lootBoxCache?.[id];
                if (cached?.hasChoice) {
                    const savedChoice = localStorage.getItem(`hwh_lootbox_choice_${id}`);
                    return savedChoice !== null && savedChoice !== 'wait';
                }
                return false;
            });

            checkedItemIds = [...checkedItemIds, ...autoSelectedItems];
            debugLog(`üì¶ Processing ${checkedItemIds.length} items (${Object.keys(checkedItems).filter(id => consumables[id] > 0).length} auto-use + ${autoSelectedItems.length} auto-selected)`);

            if (checkedItemIds.length === 0) {
                alert('‚ùå No checked items in stock. Please check items in Manage Lists tab.');
                return;
            }

            // Build list of items to use
            let itemsList = '';
            let totalItems = 0;

            checkedItemIds.forEach(id => {
                const qty = consumables[id];
                const name = window.identifyItem(id, 'consumable');
                itemsList += `  ‚Ä¢ ${name} (ID: ${id}): ${qty.toLocaleString()}\n`;
                totalItems++;
            });

            // Confirm
            if (!confirm(`Use ALL of the following items (including nested rewards)?\n\n${itemsList}\nTotal: ${totalItems} item types\n\nThis will continue until all nested loot boxes are opened.\n\nThis cannot be undone!`)) {
                return;
            }

            // Find the button to update its text
            const useAllBtn = document.querySelector('button');

            try {
                if (useAllBtn) {
                    useAllBtn.disabled = true;
                    useAllBtn.textContent = '‚è≥ Processing...';
                    useAllBtn.style.background = '#666';
                }

                suppressPopups();

                let successCount = 0;
                let failCount = 0;
                let allRewards = [];
                let iterationCount = 0;
                const maxIterations = 50; // Safety limit

                // Keep processing until no more checked items with quantity > 0
                while (iterationCount < maxIterations) {
                    iterationCount++;
                    debugLog(`üîÑ Iteration ${iterationCount}: Checking inventory...`);

                    // Refresh inventory data
                    try {
                        const data = {
                            calls: [{
                                name: "inventoryGet",
                                args: {},
                                ident: "inventoryGet"
                            }]
                        };

                        const SendFunction = getSend();
                        const response = await SendFunction(JSON.stringify(data));

                        if (response && response.results && response.results[0]) {
                            const result = response.results[0];
                            if (result.result && result.result.response) {
                                inventoryData = result.result.response;
                            }
                        }
                    } catch (e) {
                        console.error('Failed to refresh inventory:', e);
                        break;
                    }

                    const currentConsumables = inventoryData.consumable || {};
                    const itemsToUse = Object.keys(checkedItems).filter(id => currentConsumables[id] > 0);

                    if (itemsToUse.length === 0) {
                        debugLog('‚úÖ No more checked items with quantity > 0');
                        break;
                    }

                    debugLog(`üì¶ Round ${iterationCount}: Processing ${itemsToUse.length} items`);
                    if (useAllBtn) {
                        useAllBtn.textContent = `‚è≥ Round ${iterationCount}... (${itemsToUse.length} items)`;
                    }

                    // Process each checked item in this iteration
                    for (const itemId of itemsToUse) {
                        const quantity = currentConsumables[itemId];
                        if (!quantity || quantity <= 0) continue;

                        try {
                            // Check for choice items
                            const cached = window._lootBoxCache?.[itemId];
                            const hasChoice = cached?.hasChoice;
                            const savedChoice = localStorage.getItem(`hwh_lootbox_choice_${itemId}`);

                            // Skip choice items that are waiting
                            if (hasChoice && (savedChoice === 'wait' || savedChoice === null)) {
                                debugLog(`‚è∏Ô∏è Skipping ${itemId} (waiting for choice)`);
                                continue;
                            }

                            const choiceIdx = hasChoice ? (parseInt(savedChoice) || 0) : 0;
                            const savedQty = localStorage.getItem(`hwh_lootbox_qty_${itemId}`);
                            const useQuantity = hasChoice && savedQty ? Math.min(parseInt(savedQty) || quantity, quantity) : quantity;

                            const data = {
                                calls: [{
                                    name: "consumableUseLootBox",
                                    args: {
                                        libId: parseInt(itemId),
                                        amount: useQuantity,
                                        playerRewardChoiceIndex: choiceIdx
                                    },
                                    context: {
                                        actionTs: Math.floor(performance.now())
                                    },
                                    ident: "body"
                                }]
                            };

                            const SendFunction = getSend();
                            const response = await SendFunction(JSON.stringify(data));

                            if (response && response.results && response.results[0]) {
                                const result = response.results[0];
                                if (result.result && result.result.response) {
                                    allRewards.push({
                                        itemId: itemId,
                                        itemName: window.identifyItem(itemId, 'consumable'),
                                        quantity: quantity,
                                        iteration: iterationCount,
                                        rewards: result.result.response
                                    });
                                    successCount++;

                                    // Check if we got more consumables that are checked
                                    const newConsumables = result.result.response.consumable || {};
                                    for (const [newItemId, newQty] of Object.entries(newConsumables)) {
                                        if (checkedItems[newItemId]) {
                                            debugLog(`üéÅ Got ${newQty}x checked item #${newItemId} as reward - will use in next round`);
                                        }
                                    }
                                }
                            }

                            // Small delay between requests
                            await new Promise(resolve => setTimeout(resolve, 100));

                        } catch (e) {
                            console.error(`Failed to use item ${itemId}:`, e);
                            failCount++;
                        }
                    }

                    // Small delay between iterations
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                if (iterationCount >= maxIterations) {
                    alert(`‚ö†Ô∏è Stopped after ${maxIterations} iterations for safety. Some items may remain.`);
                }

                // Show summary of all rewards
                let summaryText = `‚úÖ Completed in ${iterationCount} round(s)\n`;
                summaryText += `‚úÖ Used ${successCount} item batch(es) successfully`;
                if (failCount > 0) {
                    summaryText += `\n‚ùå ${failCount} failed`;
                }
                summaryText += '\n\nüìä TOTAL REWARDS:\n\n';

                // Aggregate all rewards by type
                const aggregatedRewards = {};

                // Process all rewards to build aggregated totals
                allRewards.forEach(item => {
                    const rewards = item.rewards;
                    for (const [key, value] of Object.entries(rewards)) {
                        if (key === 'quests') continue;

                        if (typeof value === 'object') {
                            for (const [rewardType, rewardItems] of Object.entries(value)) {
                                if (typeof rewardItems === 'object') {
                                    for (const [itemKey, itemAmount] of Object.entries(rewardItems)) {
                                        let displayName = '';
                                        if (rewardType === 'coin') {
                                            displayName = window.identifyItem(itemKey, 'coin');
                                        } else if (rewardType === 'consumable') {
                                            displayName = window.identifyItem(itemKey, 'consumable');
                                        } else if (rewardType === 'fragmentHero') {
                                            displayName = window.identifyItem(itemKey, 'hero') + ' (SS)';
                                        } else if (rewardType === 'fragmentGear') {
                                            displayName = window.identifyItem(itemKey, 'gear') + ' (Frag)';
                                        } else if (rewardType === 'fragmentTitan') {
                                            displayName = window.identifyItem(itemKey, 'titan') + ' (SS)';
                                        } else if (rewardType === 'fragmentPet') {
                                            displayName = window.identifyItem(itemKey, 'pet') + ' (SS)';
                                        } else {
                                            displayName = window.identifyItem?.(itemKey, rewardType) || `${rewardType} #${itemKey}`;
                                        }

                                        if (!aggregatedRewards[displayName]) {
                                            aggregatedRewards[displayName] = 0;
                                        }
                                        aggregatedRewards[displayName] += parseInt(itemAmount);
                                    }
                                } else {
                                    const displayName = window.itemNameCache.currency[rewardType] || rewardType;
                                    if (!aggregatedRewards[displayName]) {
                                        aggregatedRewards[displayName] = 0;
                                    }
                                    aggregatedRewards[displayName] += parseInt(rewardItems);
                                }
                            }
                        } else if (key === 'gold') {
                            if (!aggregatedRewards['ü™ô Gold']) {
                                aggregatedRewards['ü™ô Gold'] = 0;
                            }
                            aggregatedRewards['ü™ô Gold'] += parseInt(value);
                        } else if (key !== 'quests') {
                            const displayName = window.itemNameCache.currency[key] || key;
                            if (!aggregatedRewards[displayName]) {
                                aggregatedRewards[displayName] = 0;
                            }
                            aggregatedRewards[displayName] += parseInt(value);
                        }
                    }
                });

                // Show only totals
                for (const [rewardName, rewardAmount] of Object.entries(aggregatedRewards)) {
                    summaryText += `  ‚Ä¢ ${rewardName}: ${rewardAmount.toLocaleString()}\n`;
                }


                showRewardSummary(summaryText);

                // Re-enable button after successful completion
                if (useAllBtn) {
                    useAllBtn.disabled = false;
                    useAllBtn.textContent = 'üéØ Use All (with nesting)';
                    useAllBtn.style.background = '#ff9800';
                }

                // Close and reopen to refresh - FIX THE DOM REMOVAL
                //                 try {
                //                     if (overlay && overlay.parentNode) {
                //                         overlay.parentNode.removeChild(overlay);
                //                     }
                //                 } catch (err) {
                //                     console.error('Error removing overlay:', err);
                //                 }

                //                 setTimeout(() => {
                //                     window.showInventoryManager();
                //                 }, 100);

            } catch (e) {
                console.error('Failed to use all items:', e);
                alert('‚ùå Error using items: ' + (e.message || 'Unknown error'));

                if (useAllBtn) {
                    useAllBtn.disabled = false;
                    useAllBtn.textContent = 'üéØ Use All (with nesting)';
                    useAllBtn.style.background = '#ff9800';
                }
            } finally {
                restorePopups();
                // Refresh inventory after using items
                try {
                    if (typeof cheats !== 'undefined' && cheats.refreshInventory) {
                        await cheats.refreshInventory();
                    }
                } catch (e) { debugLog('Inventory refresh skipped:', e); }
            }
        };
        // ===== SUPPRESS HELPER POPUPS DURING BATCH OPERATIONS =====
        let originalConfirm = null;
        let originalAlert = null;
        let originalPopupConfirm = null;
        let originalCountControl = null;

        const suppressPopups = () => {
            if (!originalConfirm) {
                originalConfirm = window.confirm;
                originalAlert = window.alert;
            }

            // Replace native popups with silent versions that auto-accept
            window.confirm = () => true;
            window.alert = () => {};

            // Suppress HeroWarsHelper's custom popup system
            if (typeof HWHFuncs !== 'undefined' && HWHFuncs.popup && HWHFuncs.popup.confirm) {
                originalPopupConfirm = HWHFuncs.popup.confirm;
                HWHFuncs.popup.confirm = async (title, buttons) => {
                    debugLog('üîá Suppressed HWH popup:', title);
                    const actionButton = buttons.find(btn => !btn.isClose);
                    return actionButton ? actionButton.result : false;
                };
            }

            // Temporarily disable countControl to bypass HWH's quantity prompt for item 148
            if (typeof HWHData !== 'undefined' && HWHData.checkboxes?.countControl?.cbox) {
                const cbox = HWHData.checkboxes.countControl.cbox;
                originalCountControl = cbox.checked;
                debugLog('üîç countControl found, was:', originalCountControl);
                if (originalCountControl) {
                    cbox.checked = false;
                    debugLog('üîá countControl now:', cbox.checked);
                }
            } else {
                debugLog('‚ö†Ô∏è countControl checkbox NOT FOUND!', typeof HWHData, HWHData?.checkboxes?.countControl);
            }

            debugLog('üîá Popups suppressed during batch operation');
        };

        const restorePopups = () => {
            if (originalConfirm) {
                window.confirm = originalConfirm;
                window.alert = originalAlert;
                originalConfirm = null;
                originalAlert = null;
            }

            // Restore HWH popup system
            if (originalPopupConfirm && typeof HWHFuncs !== 'undefined' && HWHFuncs.popup) {
                HWHFuncs.popup.confirm = originalPopupConfirm;
                originalPopupConfirm = null;
            }

            // Restore countControl checkbox
            if (originalCountControl !== null && typeof HWHData !== 'undefined' && HWHData.checkboxes?.countControl?.cbox) {
                HWHData.checkboxes.countControl.cbox.checked = originalCountControl;
                originalCountControl = null;
                debugLog('üîä countControl restored');
            }

            debugLog('üîä Popups restored');
        };

        // ===== USE SELECTED (NO NESTING) =====
        const useSelected = async (checkedItems) => {
            const consumables = inventoryData.consumable || {};
            const itemsToUse = Object.keys(checkedItems).filter(id => consumables[id] > 0);

            if (itemsToUse.length === 0) {
                alert('‚ùå No checked items in stock.');
                return;
            }

            // Filter out choice items set to "wait"
            const itemsFiltered = itemsToUse.filter(id => {
                const hasChoice = window._lootBoxCache?.[id]?.hasChoice;
                const savedChoice = localStorage.getItem(`hwh_lootbox_choice_${id}`);
                // Skip choice items that are set to wait or not yet chosen
                if (hasChoice && (savedChoice === 'wait' || savedChoice === null)) {
                    return false;
                }
                return true;
            });

            if (itemsFiltered.length === 0) {
                alert('‚ùå No items ready to use. Set choices for items with dropdowns first.');
                return;
            }

            const itemsList = itemsFiltered.map(id => {
                const name = window.identifyItem(id, 'consumable');
                const itemData = lib?.data?.inventoryItem?.consumable?.[id];
                const hasChoice = itemData?.effectDescription?.playerChoice === true;
                const savedChoice = localStorage.getItem(`hwh_lootbox_choice_${id}`);
                const savedQty = localStorage.getItem(`hwh_lootbox_qty_${id}`);
                const qty = hasChoice && savedQty ? savedQty : consumables[id];
                const choiceNote = hasChoice ? ` [choice: ${savedChoice}]` : '';
                return `‚Ä¢ ${name} (${qty})${choiceNote}`;
            }).join('\n');

            if (!confirm(`Use the following items (no nesting)?\n\n${itemsList}\n\nThis cannot be undone!`)) {
                return;
            }

            const getSend = () => HWHFuncs?.Send || window.Send || (typeof Send !== 'undefined' ? Send : null);
            const SendFunction = getSend();
            if (!SendFunction) {
                alert('‚ùå Send function not available');
                return;
            }

            let successCount = 0;
            let failCount = 0;
            const allRewards = [];
            // Suppress HWH popups during batch operation
            suppressPopups();

            try {
                for (const itemId of itemsFiltered) {
                    const quantity = consumables[itemId];
                    if (!quantity || quantity <= 0) continue;

                    // Check if this is a choice item
                    const itemData = lib?.data?.inventoryItem?.consumable?.[itemId];
                    const effectDesc = itemData?.effectDescription;
                    const hasChoice = effectDesc?.playerChoice === true;

                    // Get stored choice index - skip if "wait" or not set (for choice items)
                    const savedChoice = localStorage.getItem(`hwh_lootbox_choice_${itemId}`);
                    if (hasChoice && (savedChoice === 'wait' || savedChoice === null)) {
                        debugLog(`‚è∏Ô∏è Skipping item ${itemId} (waiting for choice)`);
                        continue;
                    }
                    const choiceIdx = parseInt(savedChoice) || 0;

                    // Get custom quantity if set (for choice items)
                    const savedQty = localStorage.getItem(`hwh_lootbox_qty_${itemId}`);
                    const useQuantity = savedQty ? Math.min(parseInt(savedQty), quantity) : quantity;

                    try {
                        const data = {
                            calls: [{
                                name: "consumableUseLootBox",
                                args: {
                                    libId: parseInt(itemId),
                                    amount: quantity,
                                    playerRewardChoiceIndex: choiceIdx
                                },
                                context: { actionTs: Math.floor(performance.now()) },
                                ident: "body"
                            }]
                        };

                        debugLog(`üì¶ Using item ${itemId} x${quantity} with choice ${choiceIdx}`);
                        const response = await SendFunction(JSON.stringify(data));

                        if (response?.results?.[0]?.result?.response) {
                            successCount++;
                            allRewards.push({
                                itemId,
                                itemName: window.identifyItem(itemId, 'consumable'),
                                quantity,
                                rewards: response.results[0].result.response
                            });
                            debugLog(`‚úÖ Used ${itemId}:`, response.results[0].result.response);
                        } else {
                            failCount++;
                            console.warn(`‚ö†Ô∏è Item ${itemId} response:`, response);
                        }
                    } catch (e) {
                        failCount++;
                        console.error(`‚ùå Error using item ${itemId}:`, e);
                    }

                    // Small delay between items
                    await new Promise(r => setTimeout(r, 300));
                }

                // Build summary
                let summaryText = `‚úÖ Used ${successCount} item types successfully`;
                if (failCount > 0) summaryText += `\n‚ùå ${failCount} failed`;
                summaryText += '\n\nüìä REWARDS:\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n';

                // Aggregate all rewards
                const aggregatedRewards = {};

                allRewards.forEach(item => {
                    const rewards = item.rewards;
                    for (const [key, value] of Object.entries(rewards)) {
                        if (key === 'quests') continue;

                        if (typeof value === 'object') {
                            for (const [rewardType, rewardItems] of Object.entries(value)) {
                                if (typeof rewardItems === 'object') {
                                    for (const [itemKey, itemAmount] of Object.entries(rewardItems)) {
                                        let displayName = '';
                                        if (rewardType === 'coin') {
                                            displayName = window.identifyItem(itemKey, 'coin');
                                        } else if (rewardType === 'consumable') {
                                            displayName = window.identifyItem(itemKey, 'consumable');
                                        } else if (rewardType === 'fragmentHero') {
                                            displayName = window.identifyItem(itemKey, 'hero') + ' (SS)';
                                        } else if (rewardType === 'fragmentGear') {
                                            displayName = window.identifyItem(itemKey, 'gear') + ' (Frag)';
                                        } else if (rewardType === 'fragmentTitan') {
                                            displayName = window.identifyItem(itemKey, 'titan') + ' (SS)';
                                        } else if (rewardType === 'fragmentPet') {
                                            displayName = window.identifyItem(itemKey, 'pet') + ' (SS)';
                                        } else {
                                            displayName = window.identifyItem?.(itemKey, rewardType) || `${rewardType} #${itemKey}`;
                                        }

                                        if (!aggregatedRewards[displayName]) {
                                            aggregatedRewards[displayName] = 0;
                                        }
                                        aggregatedRewards[displayName] += parseInt(itemAmount);
                                    }
                                } else {
                                    const displayName = window.itemNameCache?.currency?.[rewardType] || rewardType;
                                    if (!aggregatedRewards[displayName]) {
                                        aggregatedRewards[displayName] = 0;
                                    }
                                    aggregatedRewards[displayName] += parseInt(rewardItems);
                                }
                            }
                        } else if (key === 'gold') {
                            if (!aggregatedRewards['ü™ô Gold']) {
                                aggregatedRewards['ü™ô Gold'] = 0;
                            }
                            aggregatedRewards['ü™ô Gold'] += parseInt(value);
                        }
                    }
                });

                for (const [rewardName, rewardAmount] of Object.entries(aggregatedRewards)) {
                    summaryText += `  ‚Ä¢ ${rewardName}: ${rewardAmount.toLocaleString()}\n`;
                }

                debugLog('üì¶ Use Selected complete:', allRewards);
                showRewardSummary(summaryText);
            } finally {
                restorePopups();
                // Refresh inventory after using items
                try {
                    if (typeof cheats !== 'undefined' && cheats.refreshInventory) {
                        await cheats.refreshInventory();
                    }
                } catch (e) { debugLog('Inventory refresh skipped:', e); }
            }
        };

        // Tab button handlers
        const resetTabStyles = () => {
            [tab1Btn, tab2Btn, tab3Btn, tab4Btn, tab5Btn, tab6Btn].forEach(btn => {
                btn.style.background = 'rgba(139, 105, 20, 0.3)';
                btn.style.color = '#ddd';
            });
        };
        tab1Btn.onclick = () => { resetTabStyles(); tab1Btn.style.background = '#ff9800'; tab1Btn.style.color = 'white'; renderTab1(); };
        tab2Btn.onclick = () => { resetTabStyles(); tab2Btn.style.background = '#4a90e2'; tab2Btn.style.color = 'white'; renderTab2(); };
        tab3Btn.onclick = () => { resetTabStyles(); tab3Btn.style.background = '#8b6914'; tab3Btn.style.color = 'white'; renderTab3(); };
        tab4Btn.onclick = () => { resetTabStyles(); tab4Btn.style.background = '#8b6914'; tab4Btn.style.color = 'white'; renderTab4(); };
        tab5Btn.onclick = () => { resetTabStyles(); tab5Btn.style.background = '#9c27b0'; tab5Btn.style.color = 'white'; renderTab5(); };
        tab6Btn.onclick = () => { resetTabStyles(); tab6Btn.style.background = '#4caf50'; tab6Btn.style.color = 'white'; renderTab6(); };
        // Build popup
        popup.appendChild(header);
        popup.appendChild(tabContainer);
        popup.appendChild(contentContainer);
        popup.appendChild(footer);
        overlay.appendChild(popup);
        document.body.appendChild(overlay);

        // Start with Tab 1
        renderTab1();

        debugLog(`‚úÖ Inventory Manager opened`);
    };

    // ============================================================================
    // üéØ FRAGMENT HUNTER v4
    // ============================================================================
    // 1. Paste this code into Tweaker (after showInventoryManager function)
    // 2. Add to custom buttons section (~line 28821, after 'Artifacts Up'):
    //
    //            'Fragment Hunter': {
    //                action: () => {
    //                    if (window.showFragmentHunter) {
    //                        window.showFragmentHunter();
    //                    } else {
    //                        console.error('showFragmentHunter not loaded yet');
    //                    }
    //                },
    //                icon: 'üéØ',
    //                color: 'red',
    //                description: 'Hunt gear/scroll fragments by category or hero needs'
    //            },
    //
    // ============================================================================

    // Storage keys
    const FRAG_HUNT_MISSION = 'hwh_frag_hunt_mission';
    const FRAG_HUNT_X10 = 'hwh_frag_hunt_x10';
    const FRAG_HUNT_CLAN = 'hwh_frag_hunt_clan';
    const FRAG_HUNT_BUY = 'hwh_frag_hunt_buy';
    const FRAG_HUNT_DROPTABLE = 'hwh_frag_hunt_droptable';
    const DROP_TABLE_TTL = 24 * 60 * 60 * 1000;

    let _fragDropTable = null;
    let _fragDropTableExpiry = 0;

    window.showFragmentHunter = async function() {
        debugLog('üéØ Opening Fragment Hunter...');
        await waitForGameReady();

        const SendFunc = getSend();
        if (!SendFunc) { alert('‚ùå Send function unavailable'); return; }

        // ===== HELPERS =====
        const energy = id => id === 0 ? 999 : id > 145 ? 10 : id < 86 ? 6 : 8;
        const inR = (v, a, b) => v >= a && v <= b;

        const itemType = id => {
            if (inR(id,21,55)||inR(id,56,99)||inR(id,167,178)||inR(id,221,232)) return 'gear';
            if (inR(id,141,166)||inR(id,190,220)||inR(id,244,254)) return 'scroll';
            return 'unknown';
        };

        const itemColor = id => {
            if (inR(id,21,55)||inR(id,141,145)) return {bg:'#2e7d32',b:'#4caf50'};
            if (inR(id,56,90)) return {bg:'#1565c0',b:'#42a5f5'};
            if (inR(id,91,166)) return {bg:'#6a1b9a',b:'#ab47bc'};
            if (inR(id,167,220)) return {bg:'#e65100',b:'#ff9800'};
            if (inR(id,221,254)) return {bg:'#b71c1c',b:'#f44336'};
            return {bg:'#424242',b:'#757575'};
        };

        const colorNames = {1:'Gray',2:'Green',3:'Green+1',4:'Blue',5:'Blue+1',6:'Blue+2',7:'Violet',8:'Violet+1',9:'Violet+2',10:'Violet+3',11:'Orange',12:'Orange+1',13:'Orange+2',14:'Orange+3',15:'Orange+4',16:'Red',17:'Red+1',18:'Red+2'};
        const colorStyles = {1:'#888',2:'#4caf50',3:'#66bb6a',4:'#2196f3',5:'#42a5f5',6:'#64b5f6',7:'#9c27b0',8:'#ab47bc',9:'#ba68c8',10:'#ce93d8',11:'#ff9800',12:'#ffa726',13:'#ffb74d',14:'#ffcc80',15:'#ffe0b2',16:'#f44336',17:'#ef5350',18:'#e57373'};

        // Use lib.data for actual fragment merge cost
        const getFragMergeCost = (type, id) => {
            return lib.data?.inventoryItem?.[type]?.[id]?.fragmentMergeCost?.fragmentCount || 0;
        };

        const itemName = id => {
            const type = itemType(id);
            if (window.itemNameCache?.[type]?.[id]) return window.itemNameCache[type][id];
            const key = type === 'gear' ? 'LIB_GEAR_NAME_' : 'LIB_SCROLL_NAME_';
            const name = cheats.translate(`${key}${id}`) || `${type} #${id}`;
            if (window.itemNameCache?.[type]) window.itemNameCache[type][id] = name;
            return name;
        };

        // ===== DROP TABLE (cached) =====
        const getDropTable = () => {
            if (_fragDropTable && Date.now() < _fragDropTableExpiry) return _fragDropTable;
            try {
                const saved = localStorage.getItem(FRAG_HUNT_DROPTABLE);
                if (saved) {
                    const { data, expiry } = JSON.parse(saved);
                    if (Date.now() < expiry) { _fragDropTable = data; _fragDropTableExpiry = expiry; return data; }
                }
            } catch (e) {}
            const types = ['gear','fragmentGear','scroll','fragmentScroll'];
            const table = Object.values(lib.data.mission).map(m => {
                const drops = m.normalMode?.waves?.at(-1)?.enemies?.at(-1)?.drop ?? [];
                if (drops.some(d => Object.keys(d.reward)[0] === 'fragmentHero')) return null;
                const items = [], items2 = [];
                drops.forEach(d => {
                    const t = Object.keys(d.reward).pop();
                    if (d.chance && types.includes(t)) {
                        const id = +Object.keys(d.reward[t]).pop();
                        if (id > 90) { items.push(id); items2.push({id, chance: d.chance}); }
                    }
                });
                return items.length ? {id:m.id, world:m.world, index:m.index, drop:items, drop2:items2} : null;
            }).filter(Boolean);
            _fragDropTable = table; _fragDropTableExpiry = Date.now() + DROP_TABLE_TTL;
            try { localStorage.setItem(FRAG_HUNT_DROPTABLE, JSON.stringify({data:table, expiry:_fragDropTableExpiry})); } catch(e){}
            return table;
        };

        // ===== GEAR ‚Üí SCROLL MAP =====
        const buildGearToScrollMap = () => {
            const map = {};
            Object.entries(lib.data.inventoryItem.scroll || {}).forEach(([scrollId, s]) => {
                const scrollName = itemName(+scrollId);
                if (scrollName?.includes('Recipe') || scrollName?.includes('recipe')) {
                    const gearName = scrollName.replace(/ - Recipe.*| recipe.*/i, '').trim();
                    Object.entries(lib.data.inventoryItem.gear || {}).forEach(([gearId, g]) => {
                        if (itemName(+gearId) === gearName) map[gearId] = scrollId;
                    });
                }
            });
            return map;
        };

        // ===== RESOLVE RECIPE TO BASE FRAGMENTS (inventory-aware at each level) =====
        // Returns: for each base fragment type, how many MORE fragments we need to farm
        const resolveRecipe = (type, id, qty, result, gearToScrollMap) => {
            const item = lib.data.inventoryItem[type]?.[id];
            if (!item || qty <= 0) return result;

            // Check how many of this CRAFTED item we already have
            const haveCrafted = inv[type]?.[id] || 0;
            const stillNeedItems = Math.max(0, qty - haveCrafted);

            if (stillNeedItems === 0) {
                // We have enough crafted items already
                return result;
            }

            if (item.craftRecipe) {
                // This item is craftable from components - recurse
                if (item.craftRecipe.gear) {
                    Object.entries(item.craftRecipe.gear).forEach(([gid, gqty]) => {
                        resolveRecipe('gear', gid, stillNeedItems * gqty, result, gearToScrollMap);
                    });
                }
                if (item.craftRecipe.scroll) {
                    Object.entries(item.craftRecipe.scroll).forEach(([sid, sqty]) => {
                        resolveRecipe('scroll', sid, stillNeedItems * sqty, result, gearToScrollMap);
                    });
                }
                // Check if this gear needs a recipe scroll
                if (type === 'gear' && gearToScrollMap[id]) {
                    resolveRecipe('scroll', gearToScrollMap[id], stillNeedItems, result, gearToScrollMap);
                }
            } else if (item.fragmentMergeCost) {
                // Base fragment item - this is what we actually need to farm
                // Just record how many of this item we need (fragments calculated later)
                result[type][id] = (result[type][id] || 0) + stillNeedItems;
            }
            return result;
        };

        // ===== FETCH DATA =====
        let stamina = 0, staminaBought = 0, vipLevel = 0, inv = {}, userHeroes = {};
        try {
            const r = await SendFunc(JSON.stringify({ calls: [
                { name: "userGetInfo", args: {}, ident: "user" },
                { name: "inventoryGet", args: {}, ident: "inv" },
                { name: "heroGetAll", args: {}, ident: "heroes" }
            ]}));
            const user = r.results[0].result.response;
            const stam = user.refillable.find(n => n.id === 1);
            stamina = stam?.amount || 0;
            staminaBought = stam?.boughtToday || 0;
            inv = r.results[1].result.response;
            userHeroes = r.results[2].result.response;
            const vp = user.vipPoints;
            vipLevel = (vp > 999 || inv.consumable?.[151]) ? 5 : vp > 9 ? 1 : 0;
        } catch (e) { alert('‚ùå Error: ' + e.message); return; }

        const dropTable = getDropTable();
        const gearToScrollMap = buildGearToScrollMap();

        // Stock helper
        const stock = id => {
            const t = itemType(id);
            const frags = inv[t==='gear'?'fragmentGear':'fragmentScroll']?.[id] || 0;
            const full = inv[t==='gear'?'gear':'scroll']?.[id] || 0;
            const mergeCost = getFragMergeCost(t, id);
            return { frags, full, mergeCost };
        };

        // Calculate fragments still needed (accounts for full items + frags)
        const fragsStillNeeded = (id, qtyItemsNeeded) => {
            const s = stock(id);
            if (s.mergeCost === 0) return 0;
            const totalFragsNeeded = qtyItemsNeeded * s.mergeCost;
            const totalFragsHave = (s.full * s.mergeCost) + s.frags;
            return Math.max(0, totalFragsNeeded - totalFragsHave);
        };

        // ===== SETTINGS =====
        let missionId = +localStorage.getItem(FRAG_HUNT_MISSION) || 0;
        let useX10 = localStorage.getItem(FRAG_HUNT_X10) === 'true';
        let getClan = localStorage.getItem(FRAG_HUNT_CLAN) === 'true';
        let buyStam = localStorage.getItem(FRAG_HUNT_BUY) === 'true';

        // ===== PRE-BUILD HERO LIST =====
        const heroListData = [];
        Object.entries(lib.data.hero).forEach(([id, hd]) => {
            if (parseInt(id) >= 150 || !hd?.color) return;
            const uh = userHeroes[id];
            heroListData.push({
                id,
                name: window.identifyItem?.(id,'hero') || cheats.translate(`LIB_HERO_NAME_${id}`) || `Hero ${id}`,
                owned: !!uh,
                currentColor: uh?.color || 0,
                maxed: (uh?.color || 0) >= 18
            });
        });
        heroListData.sort((a,b) => {
            if (a.maxed !== b.maxed) return a.maxed ? 1 : -1;
            if (a.owned !== b.owned) return a.owned ? -1 : 1;
            return a.name.localeCompare(b.name);
        });

        // ===== CREATE UI =====
        const overlay = document.createElement('div');
        overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.85);display:flex;justify-content:center;align-items:center;z-index:100000;backdrop-filter:blur(3px);';

        const box = document.createElement('div');
        box.style.cssText = 'background:linear-gradient(135deg,#2c2416 0%,#1a1510 100%);border:3px solid #8b6914;border-radius:12px;padding:20px;width:95%;max-width:900px;max-height:85vh;display:flex;flex-direction:column;box-shadow:0 10px 40px rgba(0,0,0,0.9),inset 0 1px 0 rgba(255,255,255,0.1);';

        box.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding-bottom:12px;border-bottom:2px solid rgba(139,105,20,0.5);">
            <div><h2 style="color:#ffd700;margin:0;font-size:20px;text-shadow:2px 2px 4px rgba(0,0,0,0.8);">üéØ Fragment Hunter</h2>
            <div class="twk-muted" style="font-size:11px;margin-top:4px;">Farm fragments by category or hero needs</div></div>
            <button id="fh-x" style="background:#d32f2f;color:#fff;border:none;border-radius:6px;padding:6px 14px;font-size:16px;cursor:pointer;font-weight:bold;">‚úñ</button>
        </div>
        <div id="fh-stats" style="display:flex;gap:20px;margin-bottom:12px;padding:12px;background:rgba(0,0,0,0.3);border-radius:8px;flex-wrap:wrap;"></div>
        <div id="fh-opts" style="display:flex;gap:15px;margin-bottom:12px;padding:10px;background:rgba(0,0,0,0.2);border-radius:8px;flex-wrap:wrap;align-items:center;"></div>
        <div id="fh-target" class="twk-panel" style="margin-bottom:12px;min-height:100px;"></div>
        <div id="fh-btns" class="twk-flex-gap10" style="margin-bottom:12px;"></div>
        <div id="fh-results" style="display:none;padding:15px;background:rgba(0,0,0,0.3);border-radius:8px;max-height:180px;overflow-y:auto;"></div>
        <div class="twk-muted twk-center" style="margin-top:auto;padding-top:10px;border-top:1px solid rgba(139,105,20,0.3);font-size:10px;">Based on dimaka1256's HWHhuntFragmentExt</div>
    `;

        // Stats
        box.querySelector('#fh-stats').innerHTML = `
        <div style="display:flex;align-items:center;gap:6px;"><span style="font-size:22px;">‚ö°</span><div><div class="twk-gold-bold" style="font-size:18px;">${stamina}</div><div class="twk-muted" style="font-size:10px;">Stamina</div></div></div>
        <div style="display:flex;align-items:center;gap:6px;"><span style="font-size:22px;">üëë</span><div><div style="color:${vipLevel>=5?'#4caf50':vipLevel>=1?'#ff9800':'#f44336'};font-size:18px;font-weight:bold;">VIP${vipLevel}</div><div class="twk-muted" style="font-size:10px;">${vipLevel>=5?'x10 raids':vipLevel>=1?'Single':'No raids'}</div></div></div>
        <div style="display:flex;align-items:center;gap:6px;"><span style="font-size:22px;">üíé</span><div><div style="color:#ce93d8;font-size:18px;font-weight:bold;">${2-staminaBought}/2</div><div class="twk-muted" style="font-size:10px;">Refills left</div></div></div>
    `;

        // Options
        const optsEl = box.querySelector('#fh-opts');
        const mkCb = (lbl, chk, fn, dis) => {
            const l = document.createElement('label');
            l.style.cssText = `display:flex;align-items:center;gap:6px;color:${dis?'#555':'#bbb'};font-size:12px;cursor:${dis?'not-allowed':'pointer'};`;
            const c = document.createElement('input'); c.type='checkbox'; c.checked=chk; c.disabled=dis;
            c.onchange = () => fn(c.checked);
            l.appendChild(c); l.append(lbl); return l;
        };
        optsEl.appendChild(mkCb('üè∞ Clan stamina', getClan, v=>{getClan=v;localStorage.setItem(FRAG_HUNT_CLAN,v);}));
        optsEl.appendChild(mkCb('üíé Buy stamina', buyStam, v=>{buyStam=v;localStorage.setItem(FRAG_HUNT_BUY,v);}));
        optsEl.appendChild(mkCb('‚ö° x10 raids', useX10, v=>{useX10=v;localStorage.setItem(FRAG_HUNT_X10,v);}, vipLevel<5));

        // Target display
        const targetEl = box.querySelector('#fh-target');
        const showTarget = () => {
            const m = dropTable.find(x => x.id === missionId);
            if (!m) {
                targetEl.innerHTML = `<div class="twk-center twk-muted" style="padding:25px;"><div style="font-size:28px;margin-bottom:8px;">üéØ</div><div>No mission selected</div><div style="font-size:11px;">Choose by Category or by Hero needs</div></div>`;
                return;
            }
            const e = energy(m.id), raids = Math.floor(stamina/e);
            let drops = m.drop.map(id => {
                const it = m.drop2.find(d=>d.id===id), c = itemColor(id), s = stock(id);
                const canCraft = s.mergeCost > 0 ? s.full + Math.floor(s.frags/s.mergeCost) : s.full;
                return `<div style="display:flex;align-items:center;gap:8px;padding:5px 10px;background:${c.bg}33;border-left:3px solid ${c.b};border-radius:4px;margin:3px 0;">
                <span style="color:${c.b};font-weight:bold;min-width:42px;">[${it?.chance||'?'}%]</span>
                <span class="twk-white" style="flex:1;">${itemName(id)}</span>
                <span style="color:${canCraft>0?'#4caf50':'#ff9800'};font-size:11px;">${s.full}+${s.frags}/${s.mergeCost}üß©</span>
            </div>`;
            }).join('');
            targetEl.innerHTML = `
            <div class="twk-flex-between" style="margin-bottom:10px;">
                <div><div class="twk-gold-bold" style="font-size:15px;">üìç World ${m.world} - Mission ${m.index}</div>
                <div class="twk-muted" style="font-size:11px;margin-top:3px;">${e}‚ö°/raid ‚Ä¢ ${raids} raids ‚Ä¢ ${raids*e}‚ö° total</div></div>
                <button id="fh-chg" style="background:rgba(139,105,20,0.5);color:#ffd700;border:1px solid #8b6914;border-radius:5px;padding:6px 14px;font-size:11px;cursor:pointer;">üîÑ Change</button>
            </div>
            <div class="twk-muted twk-mb-5" style="font-size:11px;">Drops:</div>${drops}
        `;
        };
        showTarget();

        // Buttons
        const btnsEl = box.querySelector('#fh-btns');
        const startBtn = document.createElement('button');
        startBtn.innerHTML = 'üöÄ Start Hunting';
        startBtn.style.cssText = 'flex:2;background:linear-gradient(135deg,#4caf50,#2e7d32);color:#fff;border:none;border-radius:8px;padding:14px;font-size:15px;font-weight:bold;cursor:pointer;box-shadow:0 4px 15px rgba(76,175,80,0.4);';

        const catBtn = document.createElement('button');
        catBtn.innerHTML = 'üì¶ Category';
        catBtn.style.cssText = 'flex:1;background:rgba(139,105,20,0.5);color:#ffd700;border:2px solid #8b6914;border-radius:8px;padding:14px;font-size:12px;font-weight:bold;cursor:pointer;';

        const heroBtn = document.createElement('button');
        heroBtn.innerHTML = 'ü¶∏ Hero';
        heroBtn.style.cssText = 'flex:1;background:rgba(33,150,243,0.4);color:#90caf9;border:2px solid #2196f3;border-radius:8px;padding:14px;font-size:12px;font-weight:bold;cursor:pointer;';

        btnsEl.appendChild(startBtn);
        btnsEl.appendChild(catBtn);
        btnsEl.appendChild(heroBtn);

        const resultsEl = box.querySelector('#fh-results');

        overlay.appendChild(box);
        document.body.appendChild(overlay);

        // ===== EVENTS =====
        box.querySelector('#fh-x').onclick = () => overlay.remove();
        overlay.onclick = e => { if (e.target === overlay) overlay.remove(); };
        box.addEventListener('click', e => { if (e.target.id === 'fh-chg' || e.target.closest('#fh-chg')) pickCategory(); });
        catBtn.onclick = pickCategory;
        heroBtn.onclick = pickHero;

        // ===== START HUNTING =====
        startBtn.onclick = async () => {
            const m = dropTable.find(x => x.id === missionId);
            if (!m) { alert('‚ùå Select a mission first'); return; }
            startBtn.disabled = true; startBtn.innerHTML = '‚è≥ Hunting...';
            resultsEl.style.display = 'block';
            resultsEl.innerHTML = '<div class="twk-muted">Starting...</div>';
            try {
                if (getClan) {
                    resultsEl.innerHTML += '<div class="twk-muted">üè∞ Checking clan...</div>';
                    const q = await Caller.send(['questGetAll']);
                    if (q?.filter(e => e.state === 2 && e.id === 20010002)?.length) {
                        await Caller.send({ name: 'quest_questsFarm', args: { questIds: [20010002] } });
                        resultsEl.innerHTML += '<div class="twk-green">‚úÖ +200 stamina</div>';
                    }
                }
                if (buyStam && staminaBought < 2) {
                    const n = 2 - staminaBought;
                    for (let i = 0; i < n; i++) await Caller.send('refillableBuyStamina');
                    resultsEl.innerHTML += `<div class="twk-green">‚úÖ +${n*120} stamina bought</div>`;
                }
                const ref = await SendFunc(JSON.stringify({ calls: [{ name: "userGetInfo", args: {}, ident: "u" }] }));
                stamina = ref.results[0].result.response.refillable.find(n => n.id === 1)?.amount || 0;
                const e = energy(m.id);
                let raids = Math.floor(stamina / e);
                if (useX10 && vipLevel >= 5) raids = Math.floor(raids/10)*10;
                if (!raids) { resultsEl.innerHTML += '<div class="twk-orange">‚ö†Ô∏è No stamina</div>'; startBtn.disabled = false; startBtn.innerHTML = 'üöÄ Start Hunting'; return; }
                resultsEl.innerHTML += `<div class="twk-muted">üéØ Raiding ${raids}x...</div>`;
                const calls = vipLevel >= 5 ? [{ name: "missionRaid", args: { id: m.id, times: raids }, ident: "r" }]
                : Array.from({length: raids}, (_, i) => ({ name: "missionRaid", args: { id: m.id, times: 1 }, ident: `r${i}` }));
                const all = [];
                for (let i = 0; i < calls.length; i += 20) {
                    const res = await SendFunc(JSON.stringify({ calls: calls.slice(i, i+20) }));
                    if (res?.results) all.push(...res.results);
                    await new Promise(r => setTimeout(r, 80));
                }
                const loot = {};
                all.forEach(r => {
                    const resp = r.result?.response; if (!resp) return;
                    Object.values(resp).forEach(item => {
                        ['fragmentScroll','fragmentGear'].forEach(k => {
                            if (item[k]) Object.keys(item[k]).forEach(id => { loot[id] = (loot[id]||0) + 1; });
                        });
                    });
                });
                let html = `<div class="twk-gold-bold" style="font-size:14px;margin-bottom:8px;">‚úÖ Done! Spent ${raids*e}‚ö°</div>`;
                if (!Object.keys(loot).length) { html += '<div class="twk-orange">üò¢ No fragments</div>'; }
                else {
                    html += '<div class="twk-muted twk-mb-5">Loot:</div>';
                    Object.entries(loot).forEach(([id, qty]) => {
                        const c = itemColor(+id);
                        html += `<div style="display:flex;gap:8px;padding:3px 8px;background:${c.bg}22;border-left:3px solid ${c.b};margin:2px 0;"><span class="twk-white">${itemName(+id)}</span><span class="twk-green-bold">√ó${qty}</span></div>`;
                    });
                }
                resultsEl.innerHTML = html;
            } catch (err) { resultsEl.innerHTML += `<div class="twk-red">‚ùå ${err.message}</div>`; }
            startBtn.disabled = false; startBtn.innerHTML = 'üöÄ Start Hunting';
        };

        // ===== CATEGORY PICKER =====
        function pickCategory() {
            const cats = [
                { label: 'üíú Purple Gear', color: '#9c27b0', items: [91,92,93,94,95,96,97,98] },
                { label: 'üìú Purple Scrolls A-N', color: '#9c27b0', items: [158,153,162,164,165,157,152,166] },
                { label: 'üìú Purple Scrolls O-Z', color: '#9c27b0', items: [163,159,154,161,156,160,155] },
                { label: 'üß° Orange Gear', color: '#ff9800', items: [167,168,169,170,171,172,173,174,175,176,177,178] },
                { label: 'üìú Orange Scrolls A-K', color: '#ff9800', items: [190,194,197,205,204,215,214,196,218,193,219,217,206] },
                { label: 'üìú Orange Scrolls L-Z', color: '#ff9800', items: [198,220,195,192,216,191,199,200] },
                { label: '‚ù§Ô∏è Red Gear', color: '#f44336', items: [221,222,223,224,225,226,227,228,229,230,231,232] },
                { label: 'üìú Red Scrolls', color: '#f44336', items: [244,245,246,247,248,249,250,251,252,253,254] },
            ];
            const ov = document.createElement('div');
            ov.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.85);display:flex;justify-content:center;align-items:center;z-index:100001;';
            const pk = document.createElement('div');
            pk.style.cssText = 'background:linear-gradient(135deg,#2c2416,#1a1510);border:3px solid #8b6914;border-radius:12px;padding:20px;max-width:550px;';
            pk.innerHTML = `<h3 class="twk-gold" style="margin:0 0 12px;">Select Category</h3><div id="pk-cats" style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;"></div>
            <button id="pk-x" style="margin-top:12px;width:100%;background:rgba(0,0,0,0.3);color:#888;border:1px solid #555;border-radius:6px;padding:10px;cursor:pointer;">Cancel</button>`;
            cats.forEach(cat => {
                const b = document.createElement('button');
                b.style.cssText = `background:${cat.color}33;border:2px solid ${cat.color};color:#fff;border-radius:8px;padding:10px;cursor:pointer;text-align:left;`;
                b.innerHTML = `<div style="font-weight:bold;">${cat.label}</div><div class="twk-muted" style="font-size:10px;">${cat.items.length} items</div>`;
                b.onclick = () => { ov.remove(); pickItem(cat); };
                pk.querySelector('#pk-cats').appendChild(b);
            });
            pk.querySelector('#pk-x').onclick = () => ov.remove();
            ov.onclick = e => { if (e.target === ov) ov.remove(); };
            ov.appendChild(pk); document.body.appendChild(ov);
        }

        function pickItem(cat) {
            const ov = document.createElement('div');
            ov.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.85);display:flex;justify-content:center;align-items:center;z-index:100001;';
            const pk = document.createElement('div');
            pk.style.cssText = 'background:linear-gradient(135deg,#2c2416,#1a1510);border:3px solid #8b6914;border-radius:12px;padding:20px;max-width:650px;max-height:75vh;overflow-y:auto;';
            pk.innerHTML = `<h3 class="twk-gold" style="margin:0 0 5px;">${cat.label}</h3><div class="twk-muted" style="font-size:11px;margin-bottom:12px;">Select item</div>
            <div id="pk-items" style="display:flex;flex-direction:column;gap:5px;"></div>
            <button id="pk-back" style="margin-top:12px;width:100%;background:rgba(0,0,0,0.3);color:#888;border:1px solid #555;border-radius:6px;padding:10px;cursor:pointer;">‚Üê Back</button>`;
            const itemsEl = pk.querySelector('#pk-items');
            cat.items.forEach(id => {
                const s = stock(id), c = itemColor(id);
                const canCraft = s.mergeCost > 0 ? s.full + Math.floor(s.frags/s.mergeCost) : s.full;
                const b = document.createElement('button');
                b.style.cssText = `background:${c.bg}22;border:2px solid ${c.b}44;border-left:4px solid ${c.b};color:#fff;border-radius:6px;padding:8px 10px;cursor:pointer;text-align:left;display:flex;justify-content:space-between;align-items:center;`;
                b.innerHTML = `<span>${itemName(id)}</span><span style="color:${canCraft>0?'#4caf50':'#ff9800'};font-size:11px;">${s.full}+${s.frags}/${s.mergeCost}üß©</span>`;
                b.onclick = () => { ov.remove(); pickMission(id); };
                itemsEl.appendChild(b);
            });
            pk.querySelector('#pk-back').onclick = () => { ov.remove(); pickCategory(); };
            ov.onclick = e => { if (e.target === ov) ov.remove(); };
            ov.appendChild(pk); document.body.appendChild(ov);
        }

        function pickMission(itemId) {
            const missions = dropTable.filter(m => m.drop.includes(itemId));
            const ov = document.createElement('div');
            ov.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.85);display:flex;justify-content:center;align-items:center;z-index:100001;';
            const pk = document.createElement('div');
            pk.style.cssText = 'background:linear-gradient(135deg,#2c2416,#1a1510);border:3px solid #8b6914;border-radius:12px;padding:20px;max-width:650px;max-height:75vh;overflow-y:auto;';
            const ic = itemColor(itemId);
            pk.innerHTML = `<h3 class="twk-gold" style="margin:0 0 5px;">Select Mission</h3>
            <div style="color:${ic.b};font-size:12px;margin-bottom:12px;padding:8px;background:${ic.bg}22;border-radius:6px;">üéØ ${itemName(itemId)}</div>
            <div id="pk-missions" style="display:flex;flex-direction:column;gap:6px;"></div>
            <button id="pk-x" style="margin-top:12px;width:100%;background:rgba(0,0,0,0.3);color:#888;border:1px solid #555;border-radius:6px;padding:10px;cursor:pointer;">Cancel</button>`;
            const missEl = pk.querySelector('#pk-missions');
            missions.forEach(m => {
                const e = energy(m.id), it = m.drop2.find(d => d.id === itemId);
                const others = m.drop.filter(id => id !== itemId).map(id => {
                    const d = m.drop2.find(x => x.id === id), c = itemColor(id);
                    return `<span style="color:${c.b};font-size:10px;">[${d?.chance}%] ${itemName(id)}</span>`;
                }).join('<br>');
                const b = document.createElement('button');
                b.style.cssText = 'background:rgba(0,0,0,0.3);border:2px solid rgba(139,105,20,0.5);color:#fff;border-radius:8px;padding:10px;cursor:pointer;text-align:left;';
                b.innerHTML = `<div class="twk-flex-between" style="margin-bottom:4px;"><span class="twk-gold-bold">üìç W${m.world} M${m.index}</span><span class="twk-green-bold" style="font-size:13px;">[${it?.chance}%]</span></div>
                <div class="twk-muted" style="font-size:10px;">${e}‚ö°/raid</div>
                ${others ? `<div style="margin-top:5px;padding-top:5px;border-top:1px solid #333;"><div class="twk-dim" style="font-size:9px;margin-bottom:2px;">Also drops:</div>${others}</div>` : ''}`;
                b.onclick = () => { missionId = m.id; localStorage.setItem(FRAG_HUNT_MISSION, m.id); ov.remove(); showTarget(); };
                missEl.appendChild(b);
            });
            pk.querySelector('#pk-x').onclick = () => ov.remove();
            ov.onclick = e => { if (e.target === ov) ov.remove(); };
            ov.appendChild(pk); document.body.appendChild(ov);
        }

        // ===== HERO PICKER (fast) =====
        function pickHero() {
            const ov = document.createElement('div');
            ov.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.85);display:flex;justify-content:center;align-items:center;z-index:100001;';
            const pk = document.createElement('div');
            pk.style.cssText = 'background:linear-gradient(135deg,#2c2416,#1a1510);border:3px solid #2196f3;border-radius:12px;padding:20px;max-width:500px;max-height:80vh;display:flex;flex-direction:column;';
            pk.innerHTML = `
            <h3 style="color:#90caf9;margin:0 0 8px;">ü¶∏ Select Hero</h3>
            <input id="hero-search" type="text" placeholder="Type to search..." style="width:100%;padding:8px;margin-bottom:10px;background:rgba(0,0,0,0.4);border:1px solid #2196f3;border-radius:6px;color:#fff;font-size:12px;box-sizing:border-box;">
            <div id="hero-list" style="flex:1;overflow-y:auto;min-height:200px;"></div>
            <button id="pk-x" style="margin-top:12px;background:rgba(0,0,0,0.3);color:#888;border:1px solid #555;border-radius:6px;padding:10px;cursor:pointer;">Cancel</button>
        `;

            const listEl = pk.querySelector('#hero-list');
            const searchEl = pk.querySelector('#hero-search');

            const renderHeroes = (filter = '') => {
                const frag = document.createDocumentFragment();
                const filterLower = filter.toLowerCase();
                let count = 0;

                for (const h of heroListData) {
                    if (filter && !h.name.toLowerCase().includes(filterLower)) continue;
                    if (count++ >= 40) break;

                    const b = document.createElement('button');
                    b.style.cssText = `display:flex;justify-content:space-between;align-items:center;width:100%;background:rgba(0,0,0,0.3);border:2px solid ${h.maxed?'#444':h.owned?'#4caf50':'#ff9800'};color:#fff;border-radius:6px;padding:8px 12px;cursor:pointer;text-align:left;opacity:${h.maxed?'0.5':'1'};margin-bottom:4px;box-sizing:border-box;`;
                    b.innerHTML = `<span>${h.owned?'‚úì':'?'} ${h.name}</span><span style="color:${colorStyles[h.currentColor]||'#888'};font-size:11px;">${h.maxed?'MAX':`C${h.currentColor}`}</span>`;
                    b.onclick = () => { ov.remove(); pickHeroTarget(h); };
                    frag.appendChild(b);
                }

                listEl.innerHTML = '';
                if (count === 0) {
                    listEl.innerHTML = '<div class="twk-muted twk-center" style="padding:20px;">No heroes found</div>';
                } else {
                    listEl.appendChild(frag);
                    const total = heroListData.filter(h => !filter || h.name.toLowerCase().includes(filterLower)).length;
                    if (count < total) {
                        const more = document.createElement('div');
                        more.className = 'twk-muted twk-center';
                        more.style.cssText = 'padding:10px;font-size:11px;';
                        more.textContent = `Showing ${count} of ${total} ‚Äî type to filter`;
                        listEl.appendChild(more);
                    }
                }
            };

            renderHeroes();

            let debounceTimer;
            searchEl.oninput = () => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => renderHeroes(searchEl.value), 100);
            };

            pk.querySelector('#pk-x').onclick = () => ov.remove();
            ov.onclick = e => { if (e.target === ov) ov.remove(); };
            ov.appendChild(pk); document.body.appendChild(ov);
            searchEl.focus();
        }

        // ===== HERO TARGET PICKER (Finish Current vs Next vs All) =====
        function pickHeroTarget(hero) {
            const hd = lib.data.hero[hero.id];
            const currentColor = hero.currentColor;
            const nextColor = currentColor + 1;
            const colorsRemaining = 18 - currentColor;

            // Check if current color has empty slots (unequipped gear)
            const userHero = userHeroes[hero.id];
            const emptySlots = userHero?.slots?.length || 0;
            const currentGearIds = hd.color?.[currentColor]?.items || [];

            // Calculate needs for FINISHING current color (only unequipped slots)
            let finishNeeds = null;
            let finishGearIds = [];
            let finishGearNames = [];
            let finishStillNeeded = 0;

            if (emptySlots > 0 && currentColor > 0) {
                finishNeeds = {gear:{}, scroll:{}};
                // Empty slots are the LAST N items in the gear list
                finishGearIds = currentGearIds.slice(-emptySlots);
                finishGearIds.forEach(gearId => {
                    resolveRecipe('gear', String(gearId), 1, finishNeeds, gearToScrollMap);
                });
                finishGearNames = finishGearIds.map(id => window.identifyItem?.(String(id), 'gear') || `Gear ${id}`);

                Object.entries(finishNeeds.gear).forEach(([id, qty]) => { finishStillNeeded += fragsStillNeeded(+id, qty); });
                Object.entries(finishNeeds.scroll).forEach(([id, qty]) => { finishStillNeeded += fragsStillNeeded(+id, qty); });
            }

            // Calculate needs for NEXT color
            const nextNeeds = {gear:{}, scroll:{}};
            const nextGearIds = hd.color?.[nextColor]?.items || [];
            nextGearIds.forEach(gearId => resolveRecipe('gear', String(gearId), 1, nextNeeds, gearToScrollMap));
            const nextGearNames = nextGearIds.map(id => window.identifyItem?.(String(id), 'gear') || `Gear ${id}`);

            let nextStillNeeded = 0;
            Object.entries(nextNeeds.gear).forEach(([id, qty]) => { nextStillNeeded += fragsStillNeeded(+id, qty); });
            Object.entries(nextNeeds.scroll).forEach(([id, qty]) => { nextStillNeeded += fragsStillNeeded(+id, qty); });

            // Calculate needs for ALL remaining (current unequipped + all future colors)
            const allNeeds = {gear:{}, scroll:{}};
            // First add unequipped current slots
            if (emptySlots > 0) {
                finishGearIds.forEach(gearId => resolveRecipe('gear', String(gearId), 1, allNeeds, gearToScrollMap));
            }
            // Then add all future colors
            for (let c = nextColor; c <= 18; c++) {
                (hd.color?.[c]?.items || []).forEach(gearId => resolveRecipe('gear', String(gearId), 1, allNeeds, gearToScrollMap));
            }

            let allStillNeeded = 0;
            Object.entries(allNeeds.gear).forEach(([id, qty]) => { allStillNeeded += fragsStillNeeded(+id, qty); });
            Object.entries(allNeeds.scroll).forEach(([id, qty]) => { allStillNeeded += fragsStillNeeded(+id, qty); });

            const ov = document.createElement('div');
            ov.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.85);display:flex;justify-content:center;align-items:center;z-index:100001;';
            const pk = document.createElement('div');
            pk.style.cssText = 'background:linear-gradient(135deg,#2c2416,#1a1510);border:3px solid #2196f3;border-radius:12px;padding:20px;max-width:550px;';

            const finishDone = finishStillNeeded === 0;
            const nextDone = nextStillNeeded === 0;
            const allDone = allStillNeeded === 0;
            const finishTypes = finishNeeds ? Object.keys(finishNeeds.gear).length + Object.keys(finishNeeds.scroll).length : 0;
            const nextTypes = Object.keys(nextNeeds.gear).length + Object.keys(nextNeeds.scroll).length;
            const allTypes = Object.keys(allNeeds.gear).length + Object.keys(allNeeds.scroll).length;

            // Build buttons HTML
            let buttonsHTML = '';

            // Show "Finish Current" if there are empty slots
            if (emptySlots > 0 && finishNeeds) {
                buttonsHTML += `
                <button id="pick-finish" style="width:100%;background:${colorStyles[currentColor]}22;border:2px solid ${colorStyles[currentColor]};color:#fff;border-radius:8px;padding:12px;cursor:pointer;text-align:left;margin-bottom:10px;opacity:${finishDone?'0.6':'1'};">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                        <span style="color:${colorStyles[currentColor]};font-weight:bold;font-size:14px;">üîß Finish C${currentColor} ${colorNames[currentColor]}</span>
                        <span style="color:${finishDone?'#4caf50':'#ff9800'};font-size:12px;font-weight:bold;">${finishDone?'‚úì READY':finishStillNeeded+' frags'}</span>
                    </div>
                    <div class="twk-muted" style="font-size:11px;">${emptySlots} empty slots ‚Ä¢ ${finishTypes} base fragments</div>
                    <div class="twk-muted" style="font-size:10px;margin-top:4px;color:#888;">Need: ${finishGearNames.join(', ')}</div>
                </button>
            `;
            }

            // Show "Next Color" if not already at max
            if (nextColor <= 18) {
                buttonsHTML += `
                <button id="pick-next" style="width:100%;background:${colorStyles[nextColor]}22;border:2px solid ${colorStyles[nextColor]};color:#fff;border-radius:8px;padding:12px;cursor:pointer;text-align:left;margin-bottom:10px;opacity:${nextDone?'0.6':'1'};">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                        <span style="color:${colorStyles[nextColor]};font-weight:bold;font-size:14px;">‚≠ê Next: C${nextColor} ${colorNames[nextColor]}</span>
                        <span style="color:${nextDone?'#4caf50':'#ff9800'};font-size:12px;font-weight:bold;">${nextDone?'‚úì READY':nextStillNeeded+' frags'}</span>
                    </div>
                    <div class="twk-muted" style="font-size:11px;">${nextGearIds.length} gear pieces ‚Ä¢ ${nextTypes} base fragments</div>
                    <div class="twk-muted" style="font-size:10px;margin-top:4px;color:#888;">Gear: ${nextGearNames.slice(0,3).join(', ')}${nextGearNames.length > 3 ? '...' : ''}</div>
                </button>
            `;
            }

            // Show "All" if more than 1 option makes sense
            if (colorsRemaining > 0 || emptySlots > 0) {
                const allLabel = emptySlots > 0 ? `C${currentColor} (finish) + C${nextColor}‚Üí18` : `C${nextColor}‚Üí18`;
                buttonsHTML += `
                <button id="pick-all" style="width:100%;background:rgba(76,175,80,0.2);border:2px solid #4caf50;color:#fff;border-radius:8px;padding:12px;cursor:pointer;text-align:left;opacity:${allDone?'0.6':'1'};">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                        <span style="color:#4caf50;font-weight:bold;font-size:14px;">üìä All: ${allLabel}</span>
                        <span style="color:${allDone?'#4caf50':'#ff9800'};font-size:12px;font-weight:bold;">${allDone?'‚úì READY':allStillNeeded+' frags'}</span>
                    </div>
                    <div class="twk-muted" style="font-size:11px;">${allTypes} base fragments total</div>
                </button>
            `;
            }

            pk.innerHTML = `
            <h3 style="color:#90caf9;margin:0 0 5px;">ü¶∏ ${hero.name}</h3>
            <div class="twk-muted" style="font-size:11px;margin-bottom:15px;">
                Current: <span style="color:${colorStyles[currentColor]}">${colorNames[currentColor] || 'None'}</span>
                ${emptySlots > 0 ? `<span style="color:#ff9800;"> (${emptySlots} slots empty!)</span>` : ''}
                ‚Ä¢ ${colorsRemaining} color${colorsRemaining !== 1 ? 's' : ''} to max
            </div>
            ${buttonsHTML}
            <button id="pk-back" style="margin-top:15px;width:100%;background:rgba(0,0,0,0.3);color:#888;border:1px solid #555;border-radius:6px;padding:10px;cursor:pointer;">‚Üê Back</button>
        `;

            // Event handlers
            if (emptySlots > 0 && finishNeeds) {
                pk.querySelector('#pick-finish').onclick = () => { ov.remove(); pickHeroFragment(hero, currentColor, finishNeeds, finishGearNames); };
            }
            if (nextColor <= 18) {
                pk.querySelector('#pick-next').onclick = () => { ov.remove(); pickHeroFragment(hero, nextColor, nextNeeds, nextGearNames); };
            }
            const pickAllBtn = pk.querySelector('#pick-all');
            if (pickAllBtn) pickAllBtn.onclick = () => { ov.remove(); pickHeroFragment(hero, 'all', allNeeds); };
            pk.querySelector('#pk-back').onclick = () => { ov.remove(); pickHero(); };
            ov.onclick = e => { if (e.target === ov) ov.remove(); };
            ov.appendChild(pk); document.body.appendChild(ov);
        }

        // ===== HERO FRAGMENT PICKER =====
        function pickHeroFragment(hero, targetColor, needs, gearNames = null) {
            const fragments = [];

            Object.entries(needs.gear).forEach(([id, qty]) => {
                const s = stock(+id);
                const totalNeeded = qty * s.mergeCost;
                const have = (s.full * s.mergeCost) + s.frags;
                const stillNeed = Math.max(0, totalNeeded - have);
                fragments.push({ id: +id, type: 'gear', qty, mergeCost: s.mergeCost, totalNeeded, have, stillNeed, name: itemName(+id) });
            });
            Object.entries(needs.scroll).forEach(([id, qty]) => {
                const s = stock(+id);
                const totalNeeded = qty * s.mergeCost;
                const have = (s.full * s.mergeCost) + s.frags;
                const stillNeed = Math.max(0, totalNeeded - have);
                fragments.push({ id: +id, type: 'scroll', qty, mergeCost: s.mergeCost, totalNeeded, have, stillNeed, name: itemName(+id) });
            });

            fragments.sort((a,b) => {
                if ((a.stillNeed > 0) !== (b.stillNeed > 0)) return a.stillNeed > 0 ? -1 : 1;
                return b.stillNeed - a.stillNeed;
            });

            const ov = document.createElement('div');
            ov.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.85);display:flex;justify-content:center;align-items:center;z-index:100001;';
            const pk = document.createElement('div');
            pk.style.cssText = 'background:linear-gradient(135deg,#2c2416,#1a1510);border:3px solid #2196f3;border-radius:12px;padding:20px;max-width:700px;max-height:80vh;overflow-y:auto;';

            const label = targetColor === 'all' ? `C${hero.currentColor+1}‚Üí18` : `C${targetColor} ${colorNames[targetColor]}`;
            const doneCount = fragments.filter(f => f.stillNeed === 0).length;

            // Build gear list header if we have gear names
            let gearHeader = '';
            if (gearNames && gearNames.length > 0) {
                gearHeader = `
                <div style="margin-bottom:12px;padding:10px;background:rgba(255,215,0,0.1);border:1px solid rgba(255,215,0,0.3);border-radius:6px;">
                    <div class="twk-muted" style="font-size:10px;margin-bottom:5px;">üì¶ Top-level gear needed:</div>
                    <div style="color:#ffd700;font-size:11px;">${gearNames.join(', ')}</div>
                </div>
            `;
            }

            pk.innerHTML = `
            <h3 style="color:#90caf9;margin:0 0 5px;">ü¶∏ ${hero.name} ‚Üí ${label}</h3>
            <div class="twk-muted" style="font-size:11px;margin-bottom:12px;">${doneCount}/${fragments.length} base fragments complete ‚Ä¢ Click to hunt missing</div>
            ${gearHeader}
            <div id="frag-list" style="display:flex;flex-direction:column;gap:5px;"></div>
            <button id="pk-back" style="margin-top:12px;width:100%;background:rgba(0,0,0,0.3);color:#888;border:1px solid #555;border-radius:6px;padding:10px;cursor:pointer;">‚Üê Back</button>
        `;

            const fragList = pk.querySelector('#frag-list');
            fragments.forEach(f => {
                const c = itemColor(f.id);
                const done = f.stillNeed === 0;
                const pct = f.totalNeeded > 0 ? Math.min(100, Math.round(f.have / f.totalNeeded * 100)) : 100;

                const b = document.createElement('button');
                b.style.cssText = `background:${c.bg}22;border:2px solid ${done?'#4caf50':c.b}44;border-left:4px solid ${done?'#4caf50':c.b};color:#fff;border-radius:6px;padding:8px 12px;cursor:${done?'default':'pointer'};text-align:left;display:flex;justify-content:space-between;align-items:center;opacity:${done?'0.6':'1'};`;
                b.innerHTML = `
                <div style="flex:1;">
                    <div>${done?'‚úì ':''}<span style="color:${c.b}">${f.name}</span></div>
                    <div class="twk-muted" style="font-size:10px;">Need ${f.qty}√ó (${f.totalNeeded} frags)</div>
                </div>
                <div style="text-align:right;">
                    <div style="color:${done?'#4caf50':pct>=50?'#ff9800':'#f44336'};font-weight:bold;">${done?'DONE':f.stillNeed+' to go'}</div>
                    <div class="twk-muted" style="font-size:10px;">${f.have}/${f.totalNeeded} (${pct}%)</div>
                </div>
            `;
                if (!done) {
                    b.onclick = () => { ov.remove(); pickMission(f.id); };
                }
                fragList.appendChild(b);
            });

            pk.querySelector('#pk-back').onclick = () => { ov.remove(); pickHeroTarget(hero); };
            ov.onclick = e => { if (e.target === ov) ov.remove(); };
            ov.appendChild(pk); document.body.appendChild(ov);
        }
    };

    debugLog('‚úÖ Fragment Hunter v4 loaded');

    // ================================================================
    // SECTION 1: CORE SETTINGS AND DATA MANAGEMENT
    // ================================================================

    // Collection automation settings
    window.collectSettings = {

    };

    // UI customization settings
    window.uiSettings = {

    };

    // Collection settings management
    window.loadCollectSettings = function() {
        try {
            const saved = localStorage.getItem('hwh_collect_settings');
            if (saved) {
                const parsed = JSON.parse(saved);
                Object.keys(window.collectSettings).forEach(key => {
                    if (parsed[key] !== undefined) {
                        window.collectSettings[key].checked = parsed[key];
                    }
                });
            }
        } catch (e) {
            console.warn('Could not load collect settings:', e);
        }
    };

    window.saveCollectSettings = function() {
        try {
            const toSave = {};
            Object.keys(window.collectSettings).forEach(key => {
                toSave[key] = window.collectSettings[key].checked;
            });
            localStorage.setItem('hwh_collect_settings', JSON.stringify(toSave));
        } catch (e) {
            console.warn('Could not save collect settings:', e);
        }
    };

    window.isCollectSettingEnabled = function(settingName) {
        return window.collectSettings[settingName]?.checked || false;
    };

    // UI settings management
    window.loadUISettings = function() {
        try {
            const saved = localStorage.getItem('hwh_ui_settings');
            if (saved) {
                const parsed = JSON.parse(saved);
                Object.keys(window.uiSettings).forEach(key => {
                    if (parsed[key] !== undefined) {
                        window.uiSettings[key].checked = parsed[key];
                    }
                });
            }
        } catch (e) {
            console.warn('Could not load UI settings:', e);
        }
    };

    window.saveUISettings = function() {
        try {
            const toSave = {};
            Object.keys(window.uiSettings).forEach(key => {
                toSave[key] = window.uiSettings[key].checked;
            });
            localStorage.setItem('hwh_ui_settings', JSON.stringify(toSave));
        } catch (e) {
            console.warn('Could not save UI settings:', e);
        }
    };

    window.isUISettingEnabled = function(settingName) {
        return window.uiSettings[settingName]?.checked || false;
    };

    // ================================================================
    // SECTION 2: ADVENTURE EXTENSION
    // ================================================================
    // ================================================================
    // COMPLETE ADVENTURE EXTENSION - COPY THIS ENTIRE SECTION
    // Replace your entire initializeAdventureExtension function with this
    // ================================================================
    let lastManualPath = '';
    // Make popup draggable by its header
    function makeDraggable(popupElement, headerSelector = null) {
        const header = headerSelector ? popupElement.querySelector(headerSelector) : popupElement.firstElementChild;
        if (!header) return;

        header.style.cursor = 'move';
        header.title = 'Drag to move';

        let isDragging = false;
        let startX, startY, startLeft, startTop;

        // Convert from right-positioned to left-positioned for dragging
        const rect = popupElement.getBoundingClientRect();
        popupElement.style.right = 'auto';
        popupElement.style.left = rect.left + 'px';
        popupElement.style.top = rect.top + 'px';
        popupElement.style.transform = 'none';

        header.addEventListener('mousedown', (e) => {
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            startLeft = popupElement.offsetLeft;
            startTop = popupElement.offsetTop;
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            popupElement.style.left = (startLeft + dx) + 'px';
            popupElement.style.top = (startTop + dy) + 'px';
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
    }



    function initializeAdventureExtension() {
        if (!HWHClasses || !HWHClasses.executeAdventure) {
            debugLog('HWHClasses.executeAdventure not found');
            return;
        }

        debugLog('Initializing Adventure Extension...');

        // Static Solfors paths data
        const SOLFORS_PATHS = {
            "1": {
                "blue": "02-03-05",
                "orange": "02-04-07"
            },
            "2": {
                "blue": "03-06-09",
                "orange": "02-05-08-09",
                "green": "04-07-10-09"
            },
            "3": {
                "blue": "04-12-13",
                "orange": "05-06-09",
                "green": "02-03-07-10"
            },
            "4": {
                "blue": "02-04-07-18-08-12-19-22",
                "orange": "05-24-25-09-14-13-20-22",
                "green": "03-06-11-17-10-16-21-22"
            },
            "5": {
                "blue": "05-09-10-14-17-20-27-25-21",
                "orange": "04-06-10-11-15-19-18",
                "green": "02-07-08-12-16-23-26-25-22"
            },
            "6": {
                "blue": "02-04-07-10-13-16-19-24-22",
                "orange": "05-07-08-11-14-17-20-23",
                "green": "03-06-09-12-15-18-21-26"
            },
            "7": {
                "blue": "08-01-11-12-15-12-11-21-25",
                "orange": "11-10-14-17-13-19-20-24",
                "green": "07-03-04-05-09-16-23-22-26"
            },
            "8": {
                "blue": "03-02-06-07-09-10-13-17-16-20-22-21-28",
                "orange": "03-05-07-09-11-14-18-20-22-24-27-30-26-29-25",
                "green": "03-04-08-07-09-11-15-19-20-22-23-31"
            },
            "9": {
                "blue": "02-06-10-15-20-14-24-29-25-36-39-42-44",
                "orange": "03-08-12-11-07-16-21-26-30-31-32-35-37-40",
                "green": "03-04-13-19-18-23-17-22-38-41-43-46"
            },
            "10": {
                "blue": "03-02-06-11-17-25-30-35-34-29-24-21-17-12-07",
                "orange": "04-08-13-18-22-26-31-36-40-45-44-43-38-33-28",
                "green": "05-09-14-19-23-27-32-37-42-48-51-50-49-46"
            },
            "11": {
                "blue": "02-03-06-07-12-11-15-21-27-36-39-40-41",
                "orange": "02-04-06-08-12-17-18-19-25-31-30-29-28-22-16",
                "green": "02-05-06-09-13-14-20-26-32-38-35-33-34"
            },
            "12": {
                "blue": "9-3-6-10-22-31-36-35-29-34-29-30-21-13",
                "orange": "5-12-15-28-20-12-14-26-18-19-20",
                "green": "8-2-4-7-16-23-32-33-25-24-17-11",
                "solblue1stblue": "8-1-9-3-6-10-22-31-36-31-30-15-30-21-13",
                "solblue1storange": "5-12-14-26-25-34-29-28-20-19-18",
                "solblue1stgreen": "2-4-7-16-23-32-23-24-17-11",
                "solgreen1stblue": "9-3-6-10-22-31-36-31-30-21-13",
                "solgreen1storange": "5-12-15-28-29-34-25-26-18-19-20",
                "solgreen1stgreen": "8-2-4-7-16-23-32-23-24-14-24-17-11"
            }
        };



        // Static paths for Adventure 13 (Valley of the Elements) - organized by map
        const ADVENTURE_13_PATHS = {
            9: {
                north: "01,02,06,12,15,20,14,24,29,25,35,38,41,43,44",
                mid: "01,03,08,09,13,07,16,21,26,30,31,42,34,36,39,44",
                south: "01,03,04,10,19,18,23,17,22,37,40,32,45,44"
            },
            10: {
                north: "01,03,02,06,11,17,25,30,35,34,29,24,21,17,12,07",
                mid: "01,04,08,13,18,22,26,31,36,40,45,44,43,38,33,28",
                south: "01,05,09,14,19,23,27,32,37,42,48,51,50,49,46,52"
            },
            11: {
                north: "01,02,03,06,07,12,11,15,21,27,36,39,40,41,37",
                mid: "01,02,04,06,08,12,17,18,19,25,31,30,29,28,22,16",
                south: "01,02,05,06,09,13,14,20,26,32,38,35,33,34,37"
            },
            12: {
                east: "01,09,03,05,10,22,31,36,35,29,32,29,30,21,13",
                mideast: "01,08,12,15,28,20,12,14,26,18,19,20,27",
                midwest: "01,08,12,14,26,18,12,15,28,20,19,18,27",
                west: "01,07,02,04,06,16,23,33,34,25,32,25,24,17,11",
                solblue1st: "7-1-9-3-5-10-22-31-36-31-30-15-30-21-13",
                westfinish: "2-4-6-16-23-33-34-25-24-17-11"
            }
        };

        // Storm default paths
        const STORM_DEFAULT_PATHS = {
            titles: [
                'HW-Fun Full Walk',
                'A1',
                'A2',
                'A3',
                'A4',
                'A5'
            ],
            paths: [
                '1,2,3,4,5,56,55,53,50,49,48,45,46,43,41,39,38,40,36,35,33,31,29,28,27,25,26,22,21,20,17,18,15,11,14,16,19,23,24,30,32,37,42,44,47,51,52,6,8,57,12,7,9,10',
                '1,2,3,7,11,9,10',
                '13,15,18,17,20,21,22,25,27,28,26,29,33,31',
                '34,35,36,38,39,41,40,43,45,48,49,46,50',
                '54,53,55,56,5,4,8',
                '8,57,6,52,51,47,44,42,37,32,30,24,23,19,16,14,12'
            ]
        };

        // Storm path selection popup (used when running Storm via getPath)
        async function showStormPathPopup() {
            let stormPaths = { paths: [], titles: [] };
            try {
                const saved = localStorage.getItem('stormCustomPaths');
                if (saved) {
                    stormPaths = JSON.parse(saved);
                }
            } catch (e) {}

            // Use defaults if empty
            if (!stormPaths.paths.length || !stormPaths.paths.some(p => p && p.trim())) {
                stormPaths = JSON.parse(JSON.stringify(STORM_DEFAULT_PATHS));
            }

            function parsePath(pathString) {
                let path = pathString.split(',');
                if (path.length < 2) path = pathString.split('-');
                for (let i = 0; i < path.length; i++) {
                    path[i] = +path[i].trim();
                    if (Number.isNaN(path[i])) return false;
                }
                return path;
            }
            async function selectStopPoint(pathString) {
                return new Promise((resolve) => {
                    let pathArray = pathString.split(',');
                    if (pathArray.length < 2) {
                        pathArray = pathString.split('-');
                    }

                    const stopPopupDiv = document.createElement('div');
                    stopPopupDiv.style.cssText = `
                        position: fixed;
                        top: 15%;
                        right: 20px;
                        width: 320px;
                        max-height: 70vh;
                        background: linear-gradient(135deg, #1a1410 0%, #2a1f18 100%);
                        border: 3px solid #8b6914;
                        border-radius: 10px;
                        box-shadow: 0 10px 40px rgba(0,0,0,0.8);
                        z-index: 999999;
                        display: flex;
                        flex-direction: column;
                        overflow: hidden;
                        font-family: Arial, sans-serif;
                    `;

                    // Drag state
                    let isDragging = false;
                    let dragOffsetX = 0;
                    let dragOffsetY = 0;

                    // Create grid of stop points
                    const stopPointsHTML = pathArray.map((point, index) => `
                        <div class="stop-point-btn" data-index="${index + 1}" style="
                            padding: 8px 4px;
                            background: rgba(255,255,255,0.05);
                            border: 1px solid #5a4a2a;
                            border-radius: 4px;
                            cursor: pointer;
                            transition: all 0.2s;
                            text-align: center;
                        ">
                            <div style="color: #ffd700; font-size: 14px; font-weight: bold;">üéØ ${point.trim()}</div>
                            <div style="color: #666; font-size: 9px;">${index + 1}/${pathArray.length}</div>
                        </div>
                    `).join('');

                    stopPopupDiv.innerHTML = `
                        <div id="stop-popup-header" style="padding: 10px; background: rgba(139,105,20,0.3); border-bottom: 2px solid #8b6914; cursor: move;">
                            <h3 style="margin: 0; color: #ffd700; font-size: 16px; text-align: center; font-weight: bold;">
                                üéØ Select Stop Point <span style="font-size: 11px; color: #999;">(drag to move)</span>
                            </h3>
                        </div>

                        <div style="padding: 8px; overflow-y: auto; background: #0a0a0a; flex: 1;">
                            <div style="
                                display: grid;
                                grid-template-columns: repeat(5, 1fr);
                                gap: 4px;
                            ">
                                ${stopPointsHTML}
                            </div>
                        </div>

                        <div style="padding: 8px; background: rgba(139,105,20,0.3); border-top: 2px solid #8b6914;">
                            <button id="stop-full-path-btn" style="
                                width: 100%;
                                padding: 8px;
                                background: #2a6b3a;
                                color: #4ae29a;
                                border: 2px solid #4ae29a;
                                border-radius: 4px;
                                cursor: pointer;
                                font-weight: bold;
                                font-size: 13px;
                                margin-bottom: 4px;
                            ">‚úÖ Full Path (${pathArray.length} stops)</button>
                            <button id="stop-cancel-btn" style="
                                width: 100%;
                                padding: 8px;
                                background: #8b4049;
                                color: #ffd700;
                                border: 2px solid #d46a6a;
                                border-radius: 4px;
                                cursor: pointer;
                                font-weight: bold;
                                font-size: 13px;
                            ">‚úñ Cancel</button>
                        </div>
                    `;

                    document.body.appendChild(stopPopupDiv);
                    makeDraggable(stopPopupDiv);

                    // Drag functionality
                    const header = stopPopupDiv.querySelector('#stop-popup-header');

                    const onMouseMove = (e) => {
                        if (isDragging) {
                            stopPopupDiv.style.left = (e.clientX - dragOffsetX) + 'px';
                            stopPopupDiv.style.top = (e.clientY - dragOffsetY) + 'px';
                        }
                    };

                    const onMouseUp = () => {
                        isDragging = false;
                    };

                    header.onmousedown = (e) => {
                        isDragging = true;
                        dragOffsetX = e.clientX - stopPopupDiv.offsetLeft;
                        dragOffsetY = e.clientY - stopPopupDiv.offsetTop;
                        stopPopupDiv.style.right = 'auto';
                    };

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);

                    function stopCleanup() {
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                        stopPopupDiv.remove();
                    }

                    // Add click handlers for stop points
                    stopPopupDiv.querySelectorAll('.stop-point-btn').forEach(btn => {
                        btn.onmouseenter = () => {
                            btn.style.background = 'rgba(139,105,20,0.4)';
                            btn.style.transform = 'scale(1.05)';
                        };
                        btn.onmouseleave = () => {
                            btn.style.background = 'rgba(255,255,255,0.05)';
                            btn.style.transform = 'scale(1)';
                        };
                        btn.onclick = () => {
                            const stopIndex = parseInt(btn.dataset.index);
                            stopCleanup();
                            const truncatedPath = pathArray.slice(0, stopIndex);
                            const result = parsePath(truncatedPath.join(','));
                            resolve(result);
                        };
                    });

                    stopPopupDiv.querySelector('#stop-full-path-btn').onclick = () => {
                        stopCleanup();
                        const result = parsePath(pathArray.join(','));
                        resolve(result);
                    };

                    stopPopupDiv.querySelector('#stop-cancel-btn').onclick = () => {
                        stopCleanup();
                        resolve(false);
                    };
                });
            }

            return new Promise((resolve) => {
                const backdrop = document.createElement('div');
                backdrop.style.cssText = `
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: transparent;
    pointer-events: none;
    z-index: 1000000;
`;

                const popup = document.createElement('div');
                popup.style.cssText = `
                    position: fixed;
                    top: 50%;
                    right: 20px;
                    transform: translateY(-50%);
                    width: 420px;
                    max-height: 85vh;
                    background: linear-gradient(135deg, #1a1a2a 0%, #2a2a3a 100%);
                    border: 3px solid #4a6a8a;
                    border-radius: 10px;
                    box-shadow: 0 10px 40px rgba(0,0,0,0.8);
                    z-index: 1000001;
                    display: flex;
                    flex-direction: column;
                    overflow: hidden;
                    font-family: Arial, sans-serif;
                `;

                let pathButtonsHTML = '';
                for (let i = 0; i < stormPaths.paths.length; i++) {
                    const path = stormPaths.paths[i];
                    const title = stormPaths.titles[i] || `Path ${i + 1}`;
                    if (path && path.trim()) {
                        pathButtonsHTML += `
                            <div style="margin-bottom: 4px; background: rgba(255,255,255,0.05); border: 1px solid #4a6a8a; border-radius: 4px; overflow: hidden;">
                                <div style="display: flex; border-bottom: 1px solid #2a3a4a;">
                                    <div class="storm-path-full-btn" data-path="${path.replace(/"/g, '&quot;')}" style="
                                        flex: 1;
                                        padding: 6px 8px;
                                        cursor: pointer;
                                        transition: background 0.2s;
                                        border-right: 1px solid #2a3a4a;
                                    ">
                                        <div style="display: flex; align-items: center; gap: 6px;">
                                            <span style="font-size: 16px;">‚õàÔ∏è</span>
                                            <div style="color: #7fbfff; font-size: 12px; font-weight: bold;">${title}</div>
                                        </div>
                                    </div>
                                    <div class="storm-path-stop-btn" data-path="${path.replace(/"/g, '&quot;')}" style="
                                        padding: 6px 10px;
                                        cursor: pointer;
                                        background: rgba(0,0,0,0.2);
                                        transition: background 0.2s;
                                        display: flex;
                                        align-items: center;
                                        gap: 4px;
                                    ">
                                        <span style="font-size: 14px;">üéØ</span>
                                        <div style="color: #ffc107; font-size: 11px; font-weight: bold;">Stop at</div>
                                    </div>
                                </div>
                                <div style="padding: 4px 8px; color: #4ae29a; font-size: 10px; font-family: monospace; line-height: 1.3; word-break: break-all;">
                                    ${path}
                                </div>
                            </div>
                        `;
                    }
                }

                popup.innerHTML = `
                    <div style="padding: 12px; background: rgba(70,100,140,0.3); border-bottom: 2px solid #4a6a8a;">
                        <h3 style="margin: 0; color: #7fbfff; font-size: 16px; text-align: center; font-weight: bold;">
                            ‚õàÔ∏è Select Storm Path
                        </h3>
                    </div>

                    <div id="storm-path-list" style="flex: 1; overflow-y: auto; padding: 6px; background: #0a0a1a;">
                        ${pathButtonsHTML || '<div style="color: #999; text-align: center; padding: 20px;">No paths configured</div>'}
                    </div>

                    <div style="padding: 8px; background: rgba(70,100,140,0.3); border-top: 2px solid #4a6a8a;">
                        <button id="storm-manual-btn" style="
                            width: 100%;
                            padding: 6px;
                            background: #3a4a5a;
                            color: #7fbfff;
                            border: 2px solid #4a6a8a;
                            border-radius: 4px;
                            cursor: pointer;
                            font-weight: bold;
                            font-size: 13px;
                            margin-bottom: 4px;
                        ">üìù Enter Manual Path</button>
                        <button id="storm-cancel" style="
                            width: 100%;
                            padding: 6px;
                            background: #4a2a2a;
                            border: 2px solid #8b4444;
                            border-radius: 4px;
                            color: #ff9999;
                            font-weight: bold;
                            cursor: pointer;
                            font-size: 13px;
                        ">‚úñ Cancel</button>
                    </div>
                `;

                document.body.appendChild(backdrop);
                document.body.appendChild(popup);
                makeDraggable(popup);

                function cleanup() {
                    backdrop.remove();
                    popup.remove();
                }

                // Full path buttons
                popup.querySelectorAll('.storm-path-full-btn').forEach(btn => {
                    btn.onmouseenter = () => btn.style.background = 'rgba(70,100,140,0.3)';
                    btn.onmouseleave = () => btn.style.background = 'transparent';
                    btn.onclick = async () => {
                        cleanup();
                        const result = await selectStopPoint(btn.dataset.path);
                        resolve(result);
                    };
                });

                // Stop point buttons
                popup.querySelectorAll('.storm-path-stop-btn').forEach(btn => {
                    btn.onmouseenter = () => btn.style.background = 'rgba(70,100,140,0.2)';
                    btn.onmouseleave = () => btn.style.background = 'rgba(0,0,0,0.2)';
                    btn.onclick = async () => {
                        cleanup();
                        const result = await selectStopPoint(btn.dataset.path);
                        resolve(result);
                    };
                });

                // Manual path button
                popup.querySelector('#storm-manual-btn').onclick = async () => {
                    cleanup();

                    const manualPopup = document.createElement('div');
                    manualPopup.style.cssText = `
        position: fixed;
        top: 50%;
        right: 20px;
        transform: translateY(-50%);
        width: 350px;
        background: linear-gradient(135deg, #1a1a2a 0%, #2a2a3a 100%);
        border: 3px solid #4a6a8a;
        border-radius: 10px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        z-index: 999999;
        font-family: Arial, sans-serif;
        pointer-events: auto;
    `;

                    manualPopup.innerHTML = `
        <div style="padding: 10px; background: rgba(70,100,140,0.3); border-bottom: 2px solid #4a6a8a;">
            <h3 style="margin: 0; color: #7fbfff; font-size: 14px; text-align: center; font-weight: bold;">
                üî¢ Enter Storm Path Manually
            </h3>
        </div>
        <div style="padding: 12px;">
            <div style="color: #aaa; font-size: 11px; margin-bottom: 8px; padding: 6px; background: rgba(70,100,140,0.2); border-left: 3px solid #7fbfff; border-radius: 3px;">
                üí° Start with your <span style="color: #4ae29a;">current position</span>, then each node to visit
            </div>
            <input id="storm-manual-path-input" type="text" placeholder="1,2,3,4,5,6" value="${lastManualPath}" style="
                width: 100%;
                padding: 10px;
                background: rgba(0,0,0,0.5);
                border: 1px solid #4a6a8a;
                color: #4ae29a;
                border-radius: 4px;
                font-family: monospace;
                font-size: 14px;
                box-sizing: border-box;
            ">
<div id="storm-manual-path-count" style="color: #99bbdd; font-size: 11px; margin-top: 6px; text-align: center;">
                0 stops (excluding start)
            </div>
        </div>
        <div style="padding: 8px; background: rgba(70,100,140,0.3); border-top: 2px solid #4a6a8a; display: flex; gap: 6px;">
            <button id="storm-manual-start-btn" style="
                flex: 1;
                padding: 8px;
                background: #3a5a7a;
                color: #7fbfff;
                border: 2px solid #7fbfff;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                font-size: 12px;
            ">‚ñ∂Ô∏è Start</button>
            <button id="storm-manual-cancel-btn" style="
                flex: 1;
                padding: 8px;
                background: #4a2a2a;
                color: #ff9999;
                border: 2px solid #8b4444;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                font-size: 12px;
            ">‚úñ Cancel</button>
        </div>
    `;

                    document.body.appendChild(manualPopup);
                    makeDraggable(manualPopup);

                    const input = manualPopup.querySelector('#storm-manual-path-input');
                    input.focus();
                    input.select();
                    const counter = manualPopup.querySelector('#storm-manual-path-count');
                    function updateCount() {
                        const value = input.value.trim();
                        if (!value) { counter.textContent = '0 stops (excluding start)'; return; }
                        let parts = value.split(',');
                        if (parts.length < 2) parts = value.split('-');
                        const stops = Math.max(0, parts.filter(p => p.trim() && !isNaN(parseInt(p.trim()))).length - 1);
                        counter.textContent = `${stops} stop${stops !== 1 ? 's' : ''} (excluding start)`;
                    }
                    input.addEventListener('input', updateCount);
                    updateCount();

                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            manualPopup.querySelector('#storm-manual-start-btn').click();
                        }
                    });

                    manualPopup.querySelector('#storm-manual-start-btn').onclick = () => {
                        const answer = input.value.trim();
                        lastManualPath = answer;
                        manualPopup.remove();
                        if (!answer) {
                            resolve(false);
                        } else {
                            const pathArray = parsePath(answer);
                            resolve(pathArray);
                        }
                    };

                    manualPopup.querySelector('#storm-manual-cancel-btn').onclick = () => {
                        manualPopup.remove();
                        resolve(false);
                    };
                };
                popup.querySelector('#storm-cancel').onclick = () => {
                    cleanup();
                    resolve(false);
                };

                backdrop.onclick = () => {
                    cleanup();
                    resolve(false);
                };
            });
        }
        // ================================================================
        // PART 1: IN-ADVENTURE PATH SELECTION (when you start adventure)
        // ================================================================

        // This changes the buttons when you're IN an adventure selecting a path
        HWHClasses.executeAdventure.prototype.getPath = async function() {
            // Check if this is a solo/storm adventure
            if (this.type === 'solo') {
                debugLog('Storm/Solo adventure detected');
                return await showStormPathPopup();
            }

            // Regular adventure - get info
            const adventureInfo = await Caller.send('adventure_getInfo');
            const adventureId = adventureInfo.adventureId;

            debugLog('Adventure detected:', adventureId, adventureInfo);

            const isValleyOfElements = adventureId > 12 ||
                  (adventureInfo.name && adventureInfo.name.toLowerCase().includes('valley')) ||
                  (adventureInfo.name && adventureInfo.name.toLowerCase().includes('elements'));

            if (isValleyOfElements) {
                debugLog('Valley of the Elements detected - using map selection');
                return await this.getPathForAdventure13();
            }

            // Regular adventures 1-12 - Use custom popup
            return await showPathSelectionPopup(adventureId, null);
        };

        // Custom path selection popup (AoC style, compact, right-side)
        async function showPathSelectionPopup(adventureId, mapNumber) {
            function parsePath(pathString) {
                let path = pathString.split(',');
                if (path.length < 2) {
                    path = pathString.split('-');
                }

                for (let i = 0; i < path.length; i++) {
                    path[i] = +path[i].trim();
                    if (Number.isNaN(path[i])) {
                        return false;
                    }
                }

                return path;
            }

            async function selectStopPoint(pathString) {
                return new Promise((resolve) => {
                    let pathArray = pathString.split(',');
                    if (pathArray.length < 2) {
                        pathArray = pathString.split('-');
                    }

                    const stopPopupDiv = document.createElement('div');
                    stopPopupDiv.style.cssText = `
                        position: fixed;
                        top: 50%;
                        right: 20px;
                        transform: translateY(-50%);
                        width: 420px;
                        max-height: 85vh;
                        background: linear-gradient(135deg, #1a1410 0%, #2a1f18 100%);
                        border: 3px solid #8b6914;
                        border-radius: 10px;
                        box-shadow: 0 10px 40px rgba(0,0,0,0.8);
                        z-index: 999999;
                        display: flex;
                        flex-direction: column;
                        overflow: hidden;
                        font-family: Arial, sans-serif;
                    `;

                    const stopBackdrop = document.createElement('div');
                    stopBackdrop.style.cssText = `
                        position: fixed;
                        top: 0; left: 0; width: 100%; height: 100%;
                        background: transparent;
                        pointer-events: none;
                        z-index: 999998;
                    `;

                    // Create grid of stop points
                    const stopPointsHTML = pathArray.map((point, index) => `
                        <div class="stop-point-btn" data-index="${index + 1}" style="
                            padding: 8px 4px;
                            background: rgba(255,255,255,0.05);
                            border: 1px solid #5a4a2a;
                            border-radius: 4px;
                            cursor: pointer;
                            transition: all 0.2s;
                            text-align: center;
                        ">
                            <div style="color: #ffd700; font-size: 14px; font-weight: bold;">üéØ ${point.trim()}</div>
                            <div style="color: #666; font-size: 9px;">${index + 1}/${pathArray.length}</div>
                        </div>
                    `).join('');

                    stopPopupDiv.innerHTML = `
                        <div style="padding: 10px; background: rgba(139,105,20,0.3); border-bottom: 2px solid #8b6914;">
                            <h3 style="margin: 0; color: #ffd700; font-size: 16px; text-align: center; font-weight: bold;">
                                üéØ Select Stop Point
                            </h3>
                        </div>

                        <div style="padding: 8px; overflow-y: auto; background: #0a0a0a; flex: 1;">
                            <div style="
                                display: grid;
                                grid-template-columns: repeat(5, 1fr);
                                gap: 4px;
                            ">
                                ${stopPointsHTML}
                            </div>
                        </div>

                        <div style="padding: 8px; background: rgba(139,105,20,0.3); border-top: 2px solid #8b6914;">
                            <button id="stop-cancel-btn" style="
                                width: 100%;
                                padding: 8px;
                                background: #8b4049;
                                color: #ffd700;
                                border: 2px solid #d46a6a;
                                border-radius: 4px;
                                cursor: pointer;
                                font-weight: bold;
                                font-size: 13px;
                            ">‚úñ Cancel</button>
                        </div>
                    `;

                    document.body.appendChild(stopBackdrop);
                    document.body.appendChild(stopPopupDiv);
                    makeDraggable(stopPopupDiv);

                    function stopCleanup() {
                        stopBackdrop.remove();
                        stopPopupDiv.remove();
                    }

                    // Add click handlers for stop points
                    stopPopupDiv.querySelectorAll('.stop-point-btn').forEach(btn => {
                        btn.onmouseenter = () => {
                            btn.style.background = 'rgba(139,105,20,0.4)';
                            btn.style.transform = 'scale(1.05)';
                        };
                        btn.onmouseleave = () => {
                            btn.style.background = 'rgba(255,255,255,0.05)';
                            btn.style.transform = 'scale(1)';
                        };
                        btn.onclick = () => {
                            const stopIndex = parseInt(btn.dataset.index);
                            stopCleanup();
                            const truncatedPath = pathArray.slice(0, stopIndex);
                            const result = parsePath(truncatedPath.join(','));
                            resolve(result);
                        };
                    });

                    stopBackdrop.onclick = () => {
                        stopCleanup();
                        resolve(false);
                    };

                    stopPopupDiv.querySelector('#stop-cancel-btn').onclick = () => {
                        stopCleanup();
                        resolve(false);
                    };
                });
            }
            return new Promise((resolve) => {
                const isMap13 = mapNumber !== null;
                const storageKey = isMap13
                ? `adventureCustomPaths:13_map${mapNumber}`
                : `adventureCustomPaths:${adventureId}`;

                let customPathsData = { paths: [], titles: [] };
                try {
                    const saved = localStorage.getItem(storageKey);
                    if (saved) customPathsData = JSON.parse(saved);
                } catch (e) {}

                while (customPathsData.paths.length < 12) {
                    customPathsData.paths.push('');
                    customPathsData.titles.push('');
                }

                if (isMap13 && mapNumber) {
                    // Adventure 13 paths
                    const adventure13Paths = ADVENTURE_13_PATHS[mapNumber] || {};
                    const pathKeys = Object.keys(adventure13Paths);
                    pathKeys.forEach((pathName, index) => {
                        if (adventure13Paths[pathName] && !customPathsData.paths[index]) {
                            customPathsData.paths[index] = adventure13Paths[pathName];
                            customPathsData.titles[index] = `Solfors ${pathName.charAt(0).toUpperCase() + pathName.slice(1)}`;
                        }
                    });
                } else if (adventureId >= 1 && adventureId <= 12) {
                    // Adventures 1-12 paths
                    const solforsPaths = SOLFORS_PATHS[adventureId] || {};
                    ['blue', 'orange', 'green'].forEach((color, index) => {
                        if (solforsPaths[color] && !customPathsData.paths[index]) {
                            customPathsData.paths[index] = solforsPaths[color].replace(/-/g, ','); // Convert dashes to commas
                            customPathsData.titles[index] = `Solfors ${color.charAt(0).toUpperCase() + color.slice(1)}`;
                        }
                    });
                }
                const popupDiv = document.createElement('div');
                popupDiv.style.cssText = `
                position: fixed;
                top: 50%;
                right: 20px;
                transform: translateY(-50%);
                width: 420px;
                max-height: 85vh;
                background: linear-gradient(135deg, #1a1410 0%, #2a1f18 100%);
                border: 3px solid #8b6914;
                border-radius: 10px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.8);
                z-index: 999999;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                font-family: Arial, sans-serif;
                pointer-events: auto;
            `;

                const backdrop = document.createElement('div');
                backdrop.style.cssText = `
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: transparent;
pointer-events: none;
z-index: 999998;
`;

                const title = isMap13
                ? `Adventure 13 - Map ${mapNumber}`
                : `Adventure ${adventureId}`;

                debugLog('Creating path selection popup for:', title);

                popupDiv.innerHTML = `
                <div style="padding: 10px; background: rgba(139,105,20,0.3); border-bottom: 2px solid #8b6914;">
                    <h3 style="margin: 0; color: #ffd700; font-size: 16px; text-align: center; font-weight: bold;">
                        ${title} - Select Path
                    </h3>
                </div>

                <div id="path-list-area" style="
                    flex: 1;
                    overflow-y: auto;
                    padding: 6px;
                    background: #0a0a0a;
                "></div>

                <div style="padding: 8px; background: rgba(139,105,20,0.3); border-top: 2px solid #8b6914;">
                    <button id="path-edit-btn" style="
                        width: 100%;
                        padding: 6px;
                        background: #8b6914;
                        color: #ffd700;
                        border: 2px solid #ffd700;
                        border-radius: 4px;
                        cursor: pointer;
                        font-weight: bold;
                        font-size: 13px;
                        margin-bottom: 4px;
                    ">‚úèÔ∏è Edit Paths</button>
                    <button id="path-manual-btn" style="
                        width: 100%;
                        padding: 6px;
                        background: #5a4a2a;
                        color: #ffd700;
                        border: 2px solid #8b6914;
                        border-radius: 4px;
                        cursor: pointer;
                        font-weight: bold;
                        font-size: 13px;
                        margin-bottom: 4px;
                    ">üìù Enter Manual Path</button>
                    <button id="path-cancel-btn" style="
                        width: 100%;
                        padding: 6px;
                        background: #8b4049;
                        color: #ffd700;
                        border: 2px solid #d46a6a;
                        border-radius: 4px;
                        cursor: pointer;
                        font-weight: bold;
                        font-size: 13px;
                    ">Cancel</button>
                </div>
            `;

                const pathListArea = popupDiv.querySelector('#path-list-area');

                function renderPathList() {
                    const items = [];

                    for (let i = 0; i < 12; i++) {
                        const path = customPathsData.paths[i];
                        const title = customPathsData.titles[i] || `Path ${i + 1}`;
                        if (path) {
                            const icon = i < 3 ? ['üîµ','üü°','üü¢'][i] : 'üíæ';

                            items.push(`
                            <div class="path-select-btn" data-path="${path.replace(/"/g, '&quot;')}" style="
                                margin-bottom: 4px;
                                background: rgba(255,255,255,0.05);
                                border: 1px solid #5a4a2a;
                                border-radius: 4px;
                                overflow: hidden;
                                cursor: pointer;
                                transition: background 0.2s;
                            ">
                                <div style="display: flex; align-items: center; justify-content: space-between; padding: 6px 8px; border-bottom: 1px solid #3a2a1a;">
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <span style="font-size: 16px;">${icon}</span>
                                        <div style="color: #ffd700; font-size: 12px; font-weight: bold;">${title}</div>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 4px; color: #ffc107; font-size: 11px;">
                                        <span style="font-size: 14px;">üéØ</span>
                                        <span>Choose Stop</span>
                                    </div>
                                </div>
                                <div style="padding: 4px 8px; color: #4ae29a; font-size: 10px; font-family: monospace; line-height: 1.3; word-break: break-all;">
                                    ${path}
                                </div>
                            </div>
                        `);
                        }
                    }

                    if (items.length === 0) {
                        pathListArea.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #999;">
                            No paths configured<br>
                            <span style="font-size: 11px;">Click "Edit Paths" to add some</span>
                        </div>
                    `;
                    } else {
                        pathListArea.innerHTML = items.join('');

                        // All paths open the stop point selector
                        popupDiv.querySelectorAll('.path-select-btn').forEach(btn => {
                            btn.onmouseenter = () => btn.style.background = 'rgba(139,105,20,0.3)';
                            btn.onmouseleave = () => btn.style.background = 'rgba(255,255,255,0.05)';
                            btn.onclick = async () => {
                                cleanup();
                                const result = await selectStopPoint(btn.dataset.path);
                                resolve(result);
                            };
                        });
                    }
                }

                function cleanup() {
                    debugLog('üßπ Cleanup called');
                    backdrop.remove();
                    popupDiv.remove();
                }

                debugLog('About to render path list...');
                renderPathList();
                debugLog('Finished rendering');

                // ADD THESE TWO LINES:
                document.body.appendChild(backdrop);
                document.body.appendChild(popupDiv);
                makeDraggable(popupDiv);


                // ADD THIS DEBUG LINE:
                debugLog('path-cancel-btn exists?', document.getElementById('path-cancel-btn'));


                backdrop.onclick = () => {
                    cleanup();
                    resolve(false);
                };

                document.getElementById('path-cancel-btn').onclick = () => {
                    cleanup();
                    resolve(false);
                };

                document.getElementById('path-edit-btn').onclick = async () => {
                    const result = await createPathEditor(adventureId, mapNumber, customPathsData);

                    // If user clicked back, just return to path selection (do nothing)
                    if (result === 'back') {
                        return;
                    }

                    // If saved successfully, reload the paths
                    if (result === true) {
                        const newSaved = localStorage.getItem(storageKey);
                        if (newSaved) {
                            customPathsData = JSON.parse(newSaved);
                            while (customPathsData.paths.length < 12) {
                                customPathsData.paths.push('');
                                customPathsData.titles.push('');
                            }
                        }
                        renderPathList();
                    }
                };
                document.getElementById('path-manual-btn').onclick = async () => {
                    cleanup();

                    const manualPopup = document.createElement('div');
                    manualPopup.style.cssText = `
        position: fixed;
        top: 50%;
        right: 20px;
        transform: translateY(-50%);
        width: 350px;
        background: linear-gradient(135deg, #1a1410 0%, #2a1f18 100%);
        border: 3px solid #8b6914;
        border-radius: 10px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        z-index: 999999;
        font-family: Arial, sans-serif;
        pointer-events: auto;
    `;

                    manualPopup.innerHTML = `
        <div style="padding: 10px; background: rgba(139,105,20,0.3); border-bottom: 2px solid #8b6914;">
            <h3 style="margin: 0; color: #ffd700; font-size: 14px; text-align: center; font-weight: bold;">
                üî¢ Enter Path Manually
            </h3>
        </div>
        <div style="padding: 12px;">
            <div style="color: #aaa; font-size: 11px; margin-bottom: 8px; padding: 6px; background: rgba(139,105,20,0.2); border-left: 3px solid #ffd700; border-radius: 3px;">
                üí° Start with your <span style="color: #4ae29a;">current position</span>, then each node to visit
            </div>
            <input id="manual-path-input" type="text" placeholder="1,2,3,4,5,6" value="${lastManualPath}" style="
                width: 100%;
                padding: 10px;
                background: rgba(0,0,0,0.5);
                border: 1px solid #5a4a2a;
                color: #4ae29a;
                border-radius: 4px;
                font-family: monospace;
                font-size: 14px;
                box-sizing: border-box;
            ">
                        <div id="manual-path-count" style="color: #999; font-size: 11px; margin-top: 6px; text-align: center;">
                0 stops (excluding start)
            </div>
        </div>
        <div style="padding: 8px; background: rgba(139,105,20,0.3); border-top: 2px solid #8b6914; display: flex; gap: 6px;">
            <button id="manual-start-btn" style="
                flex: 1;
                padding: 8px;
                background: #8b6914;
                color: #ffd700;
                border: 2px solid #ffd700;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                font-size: 12px;
            ">‚ñ∂Ô∏è Start</button>
            <button id="manual-cancel-btn" style="
                flex: 1;
                padding: 8px;
                background: #8b4049;
                color: #ffd700;
                border: 2px solid #d46a6a;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
                font-size: 12px;
            ">‚úñ Cancel</button>
        </div>
    `;

                    document.body.appendChild(manualPopup);
                    makeDraggable(manualPopup);

                    const input = manualPopup.querySelector('#manual-path-input');
                    input.focus();
                    input.select();  // Select existing text so user can easily replace or continue
                    const counter = manualPopup.querySelector('#manual-path-count');
                    function updateCount() {
                        const value = input.value.trim();
                        if (!value) { counter.textContent = '0 stops (excluding start)'; return; }
                        let parts = value.split(',');
                        if (parts.length < 2) parts = value.split('-');
                        const stops = Math.max(0, parts.filter(p => p.trim() && !isNaN(parseInt(p.trim()))).length - 1);
                        counter.textContent = `${stops} stop${stops !== 1 ? 's' : ''} (excluding start)`;
                    }
                    input.addEventListener('input', updateCount);
                    updateCount(); // Initial count if lastManualPath has value

                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            manualPopup.querySelector('#manual-start-btn').click();
                        }
                    });

                    manualPopup.querySelector('#manual-start-btn').onclick = () => {
                        const answer = input.value.trim();
                        lastManualPath = answer;
                        manualPopup.remove();
                        if (!answer) {
                            resolve(false);
                        } else {
                            const pathArray = parsePath(answer);
                            resolve(pathArray);
                        }
                    };

                    manualPopup.querySelector('#manual-cancel-btn').onclick = () => {
                        manualPopup.remove();
                        resolve(false);
                    };
                };
            });
        }

        // Adventure 13 path selection with auto-detection and compact popup
        HWHClasses.executeAdventure.prototype.getPathForAdventure13 = async function() {
            const { popup } = HWHFuncs;

            // Auto-detect the map based on mapIdent (if we're already in the adventure)
            let selectedMap = null;

            if (this.mapIdent) {
                const mapIdentToNumber = {
                    'adv_strongford_3pl_hell': 9,
                    'adv_valley_3pl_hell': 10,
                    'adv_ghirwil_3pl_hell': 11,
                    'adv_angels_3pl_hell': 12,
                };

                selectedMap = mapIdentToNumber[this.mapIdent];

                if (selectedMap) {
                    debugLog(`Auto-detected map ${selectedMap} from mapIdent: ${this.mapIdent}`);
                    // Skip map selection, go directly to path selection
                    return await showPathSelectionPopup(null, selectedMap);
                }
            }

            // If we couldn't auto-detect, show compact map selection popup
            return new Promise(async (resolve) => {
                const popupDiv = document.createElement('div');
                popupDiv.style.cssText = `
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            width: 350px;
            max-height: 85vh;
            background: linear-gradient(135deg, #1a1410 0%, #2a1f18 100%);
            border: 3px solid #8b6914;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            z-index: 999999;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-family: Arial, sans-serif;
        `;

                const backdrop = document.createElement('div');
                backdrop.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
background: transparent;
                        pointer-events: none;
            z-index: 999998;
        `;

                popupDiv.innerHTML = `
            <div style="padding: 10px; background: rgba(139,105,20,0.3); border-bottom: 2px solid #8b6914;">
                <h3 style="margin: 0; color: #ffd700; font-size: 14px; text-align: center; font-weight: bold;">
                    Adventure 13 - Select Map
                </h3>
            </div>

            <div style="padding: 8px; overflow-y: auto; background: #0a0a0a; flex: 1;">
                <div class="map-btn" data-map="9" style="
                    padding: 8px;
                    margin-bottom: 4px;
                    background: rgba(255,255,255,0.05);
                    border: 1px solid #555;
                    border-radius: 4px;
                    cursor: pointer;
                    color: #ffd700;
                    font-size: 11px;
                ">üó∫Ô∏è Map 9 - Standard Path</div>

                <div class="map-btn" data-map="10" style="
                    padding: 8px;
                    margin-bottom: 4px;
                    background: rgba(255,255,255,0.05);
                    border: 1px solid #555;
                    border-radius: 4px;
                    cursor: pointer;
                    color: #ffd700;
                    font-size: 11px;
                ">üî• Map 10 - Fire Path</div>

                <div class="map-btn" data-map="11" style="
                    padding: 8px;
                    margin-bottom: 4px;
                    background: rgba(255,255,255,0.05);
                    border: 1px solid #555;
                    border-radius: 4px;
                    cursor: pointer;
                    color: #ffd700;
                    font-size: 11px;
                ">üíß Map 11 - Water Path</div>

                <div class="map-btn" data-map="12" style="
                    padding: 8px;
                    margin-bottom: 4px;
                    background: rgba(255,255,255,0.05);
                    border: 1px solid #555;
                    border-radius: 4px;
                    cursor: pointer;
                    color: #ffd700;
                    font-size: 11px;
                ">üåç Map 12 - Earth Path</div>
            </div>

            <div style="padding: 8px; background: rgba(139,105,20,0.2); border-top: 1px solid #8b6914;">
                <button id="map-cancel-btn" style="
                    width: 100%;
                    padding: 6px;
                    background: #8b4049;
                    color: #ffd700;
                    border: 2px solid #d46a6a;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 11px;
                ">Cancel</button>
            </div>
        `;

                document.body.appendChild(backdrop);
                document.body.appendChild(popupDiv);
                makeDraggable(popupDiv);

                function cleanup() {
                    backdrop.remove();
                    popupDiv.remove();
                }

                DOMCache.getAll('mapButtons', '.map-btn').forEach(btn => {
                    btn.onmouseenter = () => btn.style.background = 'rgba(139,105,20,0.3)';
                    btn.onmouseleave = () => btn.style.background = 'rgba(255,255,255,0.05)';
                    btn.onclick = async () => {
                        const mapNum = parseInt(btn.dataset.map);
                        cleanup();
                        const result = await showPathSelectionPopup(null, mapNum);
                        resolve(result);
                    };
                });

                backdrop.onclick = () => {
                    cleanup();
                    resolve(false);
                };

                document.getElementById('map-cancel-btn').onclick = () => {
                    cleanup();
                    resolve(false);
                };
            });
        };

        // ================================================================
        // PART 2: CUSTOM POPUP EDITOR (AoC Style)
        // ================================================================

        // Used when editing paths (both standalone and in-adventure)
        function createPathEditor(adventureId, mapNumber, customPathsData) {
            return new Promise((resolve) => {
                const isMap13 = mapNumber !== null;
                const title = isMap13
                ? `Edit Paths - Adventure 13 Map ${mapNumber}`
            : `Edit Paths - Adventure ${adventureId}`;

                const storageKey = isMap13
                ? `adventureCustomPaths:13_map${mapNumber}`
            : `adventureCustomPaths:${adventureId}`;

                // Create custom popup
                const popupDiv = document.createElement('div');
                popupDiv.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            background: linear-gradient(135deg, #1a1410 0%, #2a1f18 100%);
            border: 3px solid #8b6914;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            z-index: 1000001;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-family: Arial, sans-serif;
        `;

                const backdrop = document.createElement('div');
                backdrop.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000000;
        `;

                let currentMode = 'individual';

                popupDiv.innerHTML = `
            <div style="padding: 12px; background: rgba(139,105,20,0.3); border-bottom: 2px solid #8b6914;">
                <h3 style="margin: 0; color: #ffd700; font-size: 15px; text-align: center; font-weight: bold;">
                    ${title}
                </h3>
            </div>

            <div style="padding: 8px; background: rgba(139,105,20,0.15);">
                <div style="display: flex; gap: 6px;">
                    <button id="adv-individual-btn" style="
                        flex: 1;
                        padding: 5px;
                        background: #8b6914;
                        color: #ffd700;
                        border: 2px solid #ffd700;
                        border-radius: 4px;
                        cursor: pointer;
                        font-weight: bold;
                        font-size: 11px;
                    ">üìù Individual</button>
                    <button id="adv-bulk-btn" style="
                        flex: 1;
                        padding: 5px;
                        background: #3a2f14;
                        color: #999;
                        border: 2px solid #5a4a2a;
                        border-radius: 4px;
                        cursor: pointer;
                        font-weight: bold;
                        font-size: 11px;
                    ">üìã Bulk</button>
                </div>
            </div>

            <div id="adv-content-area" style="
                flex: 1;
                overflow-y: auto;
                padding: 6px;
                background: #0a0a0a;
                min-height: 400px;
            "></div>

            <div style="padding: 8px; background: rgba(139,105,20,0.3); border-top: 2px solid #8b6914; display: flex; gap: 8px;">
                <button id="adv-reset-btn" style="
                    padding: 6px 8px;
                    background: #6b5416;
                    color: #ffd700;
                    border: 2px solid #8b6914;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 12px;
                ">üîÑ Reset</button>
                <button id="adv-save-btn" style="
                    flex: 1;
                    padding: 6px;
                    background: #8b6914;
                    color: #ffd700;
                    border: 2px solid #ffd700;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 12px;
                ">üíæ Save</button>
                <button id="adv-cancel-btn" style="
                    flex: 1;
                    padding: 6px;
                    background: #8b4049;
                    color: #ffd700;
                    border: 2px solid #d46a6a;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 12px;
                ">‚ùå Back</button>
            </div>
        `;

                const contentArea = popupDiv.querySelector('#adv-content-area');

                function renderIndividual() {
                    contentArea.innerHTML = `
                <div style="color: #ffd700; font-size: 12px; margin-bottom: 4px; padding: 4px; background: rgba(139,105,20,0.2); border-left: 3px solid #ffd700; border-radius: 3px;">
                    üí° Edit each path individually
                </div>
                ${[...Array(12)].map((_, i) => `
                    <div style="margin-bottom: 3px; padding: 3px 5px; background: rgba(255,255,255,0.05); border: 1px solid #5a4a2a; border-radius: 3px;">
                        <div style="display: flex; gap: 4px; align-items: center;">
                            <span style="font-size: 16px; min-width: 18px; text-align: center;">${i < 3 ? ['üîµ','üü°','üü¢'][i] : 'üíæ'}</span>
                            <input type="text" id="adv-title-${i}" placeholder="Title ${i + 1}" value="${customPathsData.titles[i] || ''}" style="
                                width: 110px;
                                padding: 2px 4px;
                                background: rgba(0,0,0,0.3);
                                border: 1px solid #5a4a2a;
                                color: #ffd700;
                                border-radius: 2px;
                                font-size: 11px;
                            ">
                            <input type="text" id="adv-path-${i}" placeholder="Path (e.g., 1,2,3,4,5,6)" value="${customPathsData.paths[i] || ''}" style="
                                flex: 1;
                                padding: 2px 4px;
                                background: rgba(0,0,0,0.3);
                                border: 1px solid #5a4a2a;
                                color: #4ae29a;
                                border-radius: 2px;
                                font-size: 11px;
                                font-family: monospace;
                            ">
                        </div>
                    </div>
                `).join('')}
            `;
                }

                function renderBulk() {
                    const bulkText = [...Array(12)].map((_, i) => {
                        const title = customPathsData.titles[i] || '';
                        const path = customPathsData.paths[i] || '';
                        return title || path ? `${title} | ${path}` : '';
                    }).join('\n');

                    contentArea.innerHTML = `
                <div style="color: #ffd700; font-size: 12px; margin-bottom: 4px; padding: 4px; background: rgba(139,105,20,0.2); border-left: 3px solid #ffd700; border-radius: 3px;">
                    üí° One path per line: <code>Title | 1,2,3,4,5</code>
                </div>
                <textarea id="adv-bulk-area" style="
                    width: 100%;
                    height: 450px;
                    background: rgba(0,0,0,0.5);
                    border: 1px solid #5a4a2a;
                    color: #4ae29a;
                    border-radius: 4px;
                    padding: 8px;
                    font-family: monospace;
                    font-size: 11px;
                    resize: vertical;
                ">${bulkText}</textarea>
            `;
                }

                function switchMode(mode) {
                    // Save current data before switching
                    if (currentMode === 'bulk') {
                        const bulkArea = document.getElementById('adv-bulk-area');
                        const lines = bulkArea.value.split('\n').filter(l => l.trim());
                        for (let i = 0; i < 12; i++) {
                            if (i < lines.length && lines[i].includes('|')) {
                                const [t, p] = lines[i].split('|').map(s => s.trim());
                                customPathsData.titles[i] = t || '';
                                customPathsData.paths[i] = p || '';
                            } else {
                                customPathsData.titles[i] = '';
                                customPathsData.paths[i] = '';
                            }
                        }
                    } else {
                        for (let i = 0; i < 12; i++) {
                            const t = document.getElementById(`adv-title-${i}`);
                            const p = document.getElementById(`adv-path-${i}`);
                            if (t && p) {
                                customPathsData.titles[i] = t.value.trim();
                                customPathsData.paths[i] = p.value.trim();
                            }
                        }
                    }

                    currentMode = mode;

                    // Render FIRST
                    if (mode === 'individual') {
                        renderIndividual();
                    } else {
                        renderBulk();
                    }

                    // THEN update button styles
                    const indBtn = document.getElementById('adv-individual-btn');
                    const bulkBtn = document.getElementById('adv-bulk-btn');

                    if (indBtn && bulkBtn) {
                        if (mode === 'individual') {
                            indBtn.style.background = '#8b6914';
                            indBtn.style.color = '#ffd700';
                            indBtn.style.borderColor = '#ffd700';
                            bulkBtn.style.background = '#3a2f14';
                            bulkBtn.style.color = '#999';
                            bulkBtn.style.borderColor = '#5a4a2a';
                        } else {
                            bulkBtn.style.background = '#8b6914';
                            bulkBtn.style.color = '#ffd700';
                            bulkBtn.style.borderColor = '#ffd700';
                            indBtn.style.background = '#3a2f14';
                            indBtn.style.color = '#999';
                            indBtn.style.borderColor = '#5a4a2a';
                        }
                    }
                }

                renderIndividual();
                document.body.appendChild(backdrop);
                document.body.appendChild(popupDiv);
                makeDraggable(popupDiv);

                document.getElementById('adv-individual-btn').onclick = () => switchMode('individual');
                document.getElementById('adv-bulk-btn').onclick = () => switchMode('bulk');

                backdrop.onclick = () => {
                    backdrop.remove();
                    popupDiv.remove();
                    resolve('back');
                };

                document.getElementById('adv-cancel-btn').onclick = () => {
                    backdrop.remove();
                    popupDiv.remove();
                    resolve('back');
                };

                // Reset button handler
                document.getElementById('adv-reset-btn').onclick = async () => {
                    // Temporarily hide BOTH the editor and backdrop to show confirm dialog on top
                    popupDiv.style.display = 'none';
                    backdrop.style.display = 'none';

                    const confirmed = await HWHFuncs.popup.confirm(
                        'Reset all paths to Solfors defaults?\n\nThis will clear all your custom paths.',
                        [
                            { msg: 'Yes, Reset', result: true },
                            { msg: 'Cancel', result: false, isCancel: true }
                        ]
                    );

                    // Show both again
                    backdrop.style.display = 'block';
                    popupDiv.style.display = 'flex';

                    if (!confirmed) return;

                    // Clear localStorage
                    localStorage.removeItem(storageKey);

                    // Reload defaults
                    const defaultPaths = { paths: [], titles: [] };
                    for (let i = 0; i < 12; i++) {
                        defaultPaths.paths.push('');
                        defaultPaths.titles.push('');
                    }

                    // Pre-populate with Solfors defaults
                    if (isMap13 && mapNum) {
                        const adventure13Paths = ADVENTURE_13_PATHS[mapNumber] || {};
                        const pathKeys = Object.keys(adventure13Paths);
                        pathKeys.forEach((pathName, index) => {
                            if (adventure13Paths[pathName]) {
                                defaultPaths.paths[index] = adventure13Paths[pathName].replace(/-/g, ',');
                                const formattedName = pathName
                                .replace(/^sol/i, '')
                                .replace(/blue1st/i, 'Blue 1st')
                                .replace(/westfinish/i, 'West Finish')
                                .replace(/east/i, 'East')
                                .replace(/mideast/i, 'Mid East')
                                .replace(/midwest/i, 'Mid West')
                                .replace(/west/i, 'West')
                                .replace(/north/i, 'North')
                                .replace(/mid/i, 'Mid')
                                .replace(/south/i, 'South');
                                defaultPaths.titles[index] = `Solfors ${formattedName}`;
                            }
                        });
                    } else if (adventureId >= 1 && adventureId <= 12) {
                        const solforsPaths = SOLFORS_PATHS[adventureId] || {};
                        const pathKeys = Object.keys(solforsPaths);
                        pathKeys.forEach((pathName, index) => {
                            if (solforsPaths[pathName]) {
                                defaultPaths.paths[index] = solforsPaths[pathName].replace(/-/g, ',');
                                const formattedName = pathName
                                .replace(/^sol/i, '')
                                .replace(/blue1stblue/i, 'Blue 1st Blue')
                                .replace(/blue1storange/i, 'Blue 1st Orange')
                                .replace(/blue1stgreen/i, 'Blue 1st Green')
                                .replace(/green1stblue/i, 'Green 1st Blue')
                                .replace(/green1storange/i, 'Green 1st Orange')
                                .replace(/green1stgreen/i, 'Green 1st Green')
                                .replace(/blue/i, 'Blue')
                                .replace(/orange/i, 'Orange')
                                .replace(/green/i, 'Green');
                                defaultPaths.titles[index] = `Solfors ${formattedName}`;
                            }
                        });
                    }

                    // Update the form with defaults
                    customPathsData = defaultPaths;
                    switchMode(currentMode);

                    // Hide both again for success message
                    popupDiv.style.display = 'none';
                    backdrop.style.display = 'none';
                    await HWHFuncs.popup.confirm(
                        '‚úÖ Paths reset to Solfors defaults!',
                        [{ msg: 'OK', result: true }]
                    );
                    backdrop.style.display = 'block';
                    popupDiv.style.display = 'flex';
                };

                document.getElementById('adv-save-btn').onclick = () => {
                    // Get final data
                    if (currentMode === 'bulk') {
                        const bulkArea = document.getElementById('adv-bulk-area');
                        const lines = bulkArea.value.split('\n').filter(l => l.trim());
                        const newData = { paths: [], titles: [] };
                        for (let i = 0; i < 12; i++) {
                            if (i < lines.length && lines[i].includes('|')) {
                                const [t, p] = lines[i].split('|').map(s => s.trim());
                                newData.titles[i] = t || `Path ${i + 1}`;
                                newData.paths[i] = p || '';
                            } else {
                                newData.titles[i] = '';
                                newData.paths[i] = '';
                            }
                        }
                        customPathsData = newData;
                    } else {
                        const newData = { paths: [], titles: [] };
                        for (let i = 0; i < 12; i++) {
                            const t = document.getElementById(`adv-title-${i}`);
                            const p = document.getElementById(`adv-path-${i}`);
                            if (t && p) {
                                newData.titles[i] = t.value.trim() || `Path ${i + 1}`;
                                newData.paths[i] = p.value.trim();
                            }
                        }
                        customPathsData = newData;
                    }

                    try {
                        localStorage.setItem(storageKey, JSON.stringify(customPathsData));
                        backdrop.remove();
                        popupDiv.remove();
                        resolve(true);
                    } catch (e) {
                        console.error('Save failed:', e);
                        alert('Failed to save: ' + e.message);
                        resolve(false);
                    }
                };
            });
        }
        // ================================================================
        // PART 3: STANDALONE EDITOR (from Actions/Others menu)
        // ================================================================
        // Replace the editAdventurePathsStandalone function
        // This makes the adventure selection screen match the modern path selection window style

        window.editAdventurePathsStandalone = async function() {
            return new Promise((resolve) => {
                const popupDiv = document.createElement('div');
                popupDiv.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 420px;
            max-height: 80vh;
            background: linear-gradient(135deg, #1a1410 0%, #2a1f18 100%);
            border: 3px solid #8b6914;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            z-index: 1000001;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-family: Arial, sans-serif;
        `;

                const backdrop = document.createElement('div');
                backdrop.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
                    pointer-events: none;
            z-index: 1000000;
        `;

                popupDiv.innerHTML = `
            <div style="padding: 10px; background: rgba(139,105,20,0.3); border-bottom: 2px solid #8b6914;">
                <h3 style="margin: 0; color: #ffd700; font-size: 16px; text-align: center; font-weight: bold;">
                    ‚úèÔ∏è Edit Adventure Paths
                </h3>
            </div>

            <div id="adventure-list-area" style="
                flex: 1;
                overflow-y: auto;
                padding: 6px;
                background: #0a0a0a;
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 4px;
            ">
                ${generateAdventureList()}
            </div>

            <div style="padding: 8px; background: rgba(139,105,20,0.3); border-top: 2px solid #8b6914;">
                <button id="reset-all-btn" style="
                    width: 100%;
                    padding: 6px;
                    background: #8b4049;
                    color: #ffd700;
                    border: 2px solid #d46a6a;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 13px;
                    margin-bottom: 4px;
                ">üîÑ Reset All Adventures</button>
                <button id="adv-select-cancel-btn" style="
                    width: 100%;
                    padding: 6px;
                    background: #5a4a2a;
                    color: #ffd700;
                    border: 2px solid #8b6914;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 13px;
                ">Cancel</button>
            </div>
        `;

                function generateAdventureList() {
                    const items = [];

                    // Storm at the top
                    items.push(`
                    <div class="storm-btn" data-storm="true" style="
                        padding: 6px;
                        cursor: pointer;
                        background: rgba(70,100,140,0.2);
                        border: 1px solid #4a6a8a;
                        border-radius: 3px;
                        transition: background 0.2s;
                        text-align: center;
                        grid-column: span 2;
                    ">
                        <div style="color: #7fbfff; font-size: 12px; font-weight: bold;">‚õàÔ∏è Storm</div>
                        <div style="color: #999; font-size: 9px;">${getStormPathCount()} paths</div>
                    </div>
                `);

                    // Adventures 1-12
                    for (let i = 1; i <= 12; i++) {
                        items.push(`
                    <div class="adventure-btn" data-adventure="${i}" style="
                        padding: 6px;
                        cursor: pointer;
                        background: rgba(255,255,255,0.05);
                        border: 1px solid #5a4a2a;
                        border-radius: 3px;
                        transition: background 0.2s;
                        text-align: center;
                    ">
                        <div style="color: #ffd700; font-size: 12px; font-weight: bold;">Adventure ${i}</div>
                        <div style="color: #999; font-size: 9px;">${getPathCount(i)} paths</div>
                    </div>
                `);
                    }

                    // Adventure 13 Maps
                    for (let mapNum = 9; mapNum <= 12; mapNum++) {
                        items.push(`
                    <div class="map-btn" data-map="${mapNum}" style="
                        padding: 6px;
                        cursor: pointer;
                        background: rgba(255,255,255,0.05);
                        border: 1px solid #5a4a2a;
                        border-radius: 3px;
                        transition: background 0.2s;
                        text-align: center;
                    ">
                        <div style="color: #ffd700; font-size: 12px; font-weight: bold;">Adventure 13, Map ${mapNum}</div>
                        <div style="color: #999; font-size: 9px;">${getPathCountMap13(mapNum)} paths</div>
                    </div>
                `);
                    }

                    return items.join('');
                }

                function getPathCount(advId) {
                    try {
                        const saved = localStorage.getItem(`adventureCustomPaths:${advId}`);
                        if (saved) {
                            const data = JSON.parse(saved);
                            return data.paths.filter(p => p && p.trim()).length;
                        }
                        // Check Solfors defaults
                        const solforsPaths = window.SOLFORS_PATHS?.[advId] || {};
                        return Object.keys(solforsPaths).length;
                    } catch (e) {
                        return 0;
                    }
                }

                function getPathCountMap13(mapNum) {
                    try {
                        const saved = localStorage.getItem(`adventureCustomPaths:13_map${mapNum}`);
                        if (!saved) return 0;
                        const data = JSON.parse(saved);
                        return data.paths.filter(p => p && p.trim()).length;
                    } catch (e) {
                        return 0;
                    }
                }
                function getStormPathCount() {
                    try {
                        const saved = localStorage.getItem('stormCustomPaths');
                        if (!saved) return 6; // Default paths count
                        const data = JSON.parse(saved);
                        return data.paths.filter(p => p && p.trim()).length;
                    } catch (e) {
                        return 6;
                    }
                }
                function cleanup() {
                    backdrop.remove();
                    popupDiv.remove();
                }


                document.body.appendChild(backdrop);
                document.body.appendChild(popupDiv);
                makeDraggable(popupDiv);

                // Adventure button handlers
                popupDiv.querySelectorAll('.adventure-btn').forEach(btn => {
                    btn.onmouseenter = () => btn.style.background = 'rgba(139,105,20,0.3)';
                    btn.onmouseleave = () => btn.style.background = 'rgba(255,255,255,0.05)';
                    btn.onclick = async () => {
                        const advId = parseInt(btn.dataset.adventure);
                        cleanup();
                        await handleAdventureEdit(advId, null);
                        resolve();
                    };
                });

                // Map button handlers
                popupDiv.querySelectorAll('.map-btn').forEach(btn => {
                    btn.onmouseenter = () => btn.style.background = 'rgba(139,105,20,0.3)';
                    btn.onmouseleave = () => btn.style.background = 'rgba(255,255,255,0.05)';
                    btn.onclick = async () => {
                        const mapNum = parseInt(btn.dataset.map);
                        cleanup();
                        await handleAdventureEdit(null, mapNum);
                        resolve();
                    };
                });

                // Storm button handler
                const stormBtn = popupDiv.querySelector('.storm-btn');
                if (stormBtn) {
                    stormBtn.onmouseenter = () => stormBtn.style.background = 'rgba(70,100,140,0.4)';
                    stormBtn.onmouseleave = () => stormBtn.style.background = 'rgba(70,100,140,0.2)';
                    stormBtn.onclick = async () => {
                        cleanup();
                        await handleStormEdit();
                        resolve();
                    };
                }

                // Reset all button
                document.getElementById('reset-all-btn').onclick = async () => {
                    const { popup } = HWHFuncs;

                    // Hide popup temporarily
                    popupDiv.style.display = 'none';
                    backdrop.style.display = 'none';

                    const confirmed = await popup.confirm(
                        '‚ö†Ô∏è Reset ALL adventure paths to Solfors defaults?\n\nThis will clear ALL custom paths for:\n‚Ä¢ Adventures 1-12\n‚Ä¢ Adventure 13 Maps 9-12',
                        [
                            { msg: 'Yes, Reset All', result: true },
                            { msg: 'Cancel', result: false, isCancel: true }
                        ]
                    );

                    if (confirmed) {
                        // Clear all localStorage keys
                        for (let i = 1; i <= 12; i++) {
                            localStorage.removeItem(`adventureCustomPaths:${i}`);
                        }
                        localStorage.removeItem('adventureCustomPaths:13_map9');
                        localStorage.removeItem('adventureCustomPaths:13_map10');
                        localStorage.removeItem('adventureCustomPaths:13_map11');
                        localStorage.removeItem('adventureCustomPaths:13_map12');
                        localStorage.removeItem('stormCustomPaths');

                        await popup.confirm(
                            '‚úÖ All adventure paths have been reset to Solfors defaults!',
                            [{ msg: 'OK', result: true }]
                        );

                        cleanup();
                        // Reopen the selection window
                        await window.editAdventurePathsStandalone();
                    } else {
                        // Restore popup
                        popupDiv.style.display = 'flex';
                        backdrop.style.display = 'block';
                    }
                };

                backdrop.onclick = () => {
                    cleanup();
                    resolve();
                };

                document.getElementById('adv-select-cancel-btn').onclick = () => {
                    cleanup();
                    resolve();
                };
            });


            // Handle Storm path editing
            async function handleStormEdit() {
                const storageKey = 'stormCustomPaths';
                let data = { paths: [], titles: [] };

                try {
                    const saved = localStorage.getItem(storageKey);
                    if (saved) {
                        data = JSON.parse(saved);
                    }
                } catch (e) {}

                // Fill with defaults if empty
                if (!data.paths.length || !data.paths.some(p => p && p.trim())) {
                    data = JSON.parse(JSON.stringify(STORM_DEFAULT_PATHS));
                }

                // Ensure 12 slots
                while (data.paths.length < 12) {
                    data.paths.push('');
                    data.titles.push('');
                }

                const result = await createStormEditor(data);

                if (result === 'back') {
                    return await window.editAdventurePathsStandalone();
                }

                if (result === true) {
                    const { popup } = HWHFuncs;
                    await popup.confirm(
                        `‚úÖ Saved ${data.paths.filter(p => p && p.trim()).length} Storm paths!`,
                        [{ msg: 'OK', result: true }]
                    );
                }
            }

            // Storm editor UI
            async function createStormEditor(customPathsData) {
                return new Promise((resolve) => {
                    const backdrop = document.createElement('div');
                    backdrop.style.cssText = `
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: transparent;
    pointer-events: none;
    z-index: 1000000;
`;

                    const popupDiv = document.createElement('div');
                    popupDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 500px;
                    max-height: 85vh;
                    background: linear-gradient(135deg, #1a1a2a 0%, #2a2a3a 100%);
                    border: 3px solid #4a6a8a;
                    border-radius: 10px;
                    box-shadow: 0 10px 40px rgba(0,0,0,0.8);
                    z-index: 1000001;
                    display: flex;
                    flex-direction: column;
                    overflow: hidden;
                    font-family: Arial, sans-serif;
                `;

                    let pathInputsHTML = '';
                    for (let i = 0; i < 12; i++) {
                        pathInputsHTML += `
                        <div style="display: flex; gap: 6px; margin-bottom: 6px; align-items: center;">
                            <span style="color: #4a6a8a; font-size: 10px; width: 20px;">${i + 1}.</span>
                            <input type="text" id="storm-title-${i}" value="${customPathsData.titles[i] || ''}" placeholder="Title" style="
                                width: 100px;
                                padding: 6px;
                                background: #1a1a1a;
                                border: 1px solid #4a6a8a;
                                border-radius: 4px;
                                color: #7fbfff;
                                font-size: 11px;
                            ">
                            <input type="text" id="storm-path-${i}" value="${customPathsData.paths[i] || ''}" placeholder="1,2,3,4,5..." style="
                                flex: 1;
                                padding: 6px;
                                background: #1a1a1a;
                                border: 1px solid #4a6a8a;
                                border-radius: 4px;
                                color: #fff;
                                font-size: 11px;
                            ">
                        </div>
                    `;
                    }

                    popupDiv.innerHTML = `
                    <div style="padding: 12px; background: rgba(70,100,140,0.3); border-bottom: 2px solid #4a6a8a;">
                        <h3 style="margin: 0; color: #7fbfff; font-size: 16px; text-align: center; font-weight: bold;">
                            ‚õàÔ∏è Edit Storm Paths
                        </h3>
                    </div>

                    <div style="flex: 1; overflow-y: auto; padding: 12px;">
                        ${pathInputsHTML}
                    </div>

                    <div style="padding: 10px; background: rgba(70,100,140,0.3); border-top: 2px solid #4a6a8a; display: flex; gap: 8px;">
                        <button id="storm-back" style="
                            padding: 10px;
                            background: #3a3a4a;
                            border: 2px solid #5a5a6a;
                            border-radius: 6px;
                            color: #999;
                            font-weight: bold;
                            cursor: pointer;
                        ">‚Üê Back</button>
                        <button id="storm-reset" style="
                            padding: 10px;
                            background: #5a4a2a;
                            border: 2px solid #8b6914;
                            border-radius: 6px;
                            color: #ffd700;
                            font-weight: bold;
                            cursor: pointer;
                        ">üîÑ Defaults</button>
                        <button id="storm-save" style="
                            flex: 1;
                            padding: 10px;
                            background: #2a4a2a;
                            border: 2px solid #4a8a4a;
                            border-radius: 6px;
                            color: #7fff7f;
                            font-weight: bold;
                            cursor: pointer;
                        ">üíæ Save</button>
                    </div>
                `;

                    document.body.appendChild(backdrop);
                    document.body.appendChild(popupDiv);
                    makeDraggable(popupDiv);

                    function cleanup() {
                        backdrop.remove();
                        popupDiv.remove();
                    }

                    // Back button
                    popupDiv.querySelector('#storm-back').onclick = () => {
                        cleanup();
                        resolve('back');
                    };

                    // Reset to defaults
                    popupDiv.querySelector('#storm-reset').onclick = () => {
                        for (let i = 0; i < 12; i++) {
                            document.getElementById(`storm-title-${i}`).value = STORM_DEFAULT_PATHS.titles[i] || '';
                            document.getElementById(`storm-path-${i}`).value = STORM_DEFAULT_PATHS.paths[i] || '';
                        }
                    };

                    // Save
                    popupDiv.querySelector('#storm-save').onclick = () => {
                        const newData = { paths: [], titles: [] };
                        for (let i = 0; i < 12; i++) {
                            newData.titles[i] = document.getElementById(`storm-title-${i}`).value.trim();
                            newData.paths[i] = document.getElementById(`storm-path-${i}`).value.trim();
                        }
                        customPathsData.paths = newData.paths;
                        customPathsData.titles = newData.titles;

                        try {
                            localStorage.setItem('stormCustomPaths', JSON.stringify(newData));
                            cleanup();
                            resolve(true);
                        } catch (e) {
                            alert('Failed to save: ' + e.message);
                            resolve(false);
                        }
                    };

                    backdrop.onclick = () => {
                        cleanup();
                        resolve(false);
                    };
                });
            }

            async function handleAdventureEdit(advId, mapNum) {
                const { popup } = HWHFuncs;
                const isMap13 = mapNum !== null;

                let data = { paths: [], titles: [] };
                const key = isMap13
                ? `adventureCustomPaths:13_map${mapNum}`
            : `adventureCustomPaths:${advId}`;

                try {
                    const saved = localStorage.getItem(key);
                    if (saved) data = JSON.parse(saved);
                } catch (e) {}

                while (data.paths.length < 12) {
                    data.paths.push('');
                    data.titles.push('');
                }

                // Pre-populate with Solfors defaults if empty
                if (isMap13 && mapNum) {
                    const adventure13Paths = ADVENTURE_13_PATHS[mapNum] || {};
                    const pathKeys = Object.keys(adventure13Paths);
                    pathKeys.forEach((pathName, index) => {
                        if (adventure13Paths[pathName] && !data.paths[index]) {
                            data.paths[index] = adventure13Paths[pathName].replace(/-/g, ',');
                            const formattedName = pathName
                            .replace(/^sol/i, '')
                            .replace(/blue1st/i, 'Blue 1st')
                            .replace(/westfinish/i, 'West Finish')
                            .replace(/east/i, 'East')
                            .replace(/mideast/i, 'Mid East')
                            .replace(/midwest/i, 'Mid West')
                            .replace(/west/i, 'West')
                            .replace(/north/i, 'North')
                            .replace(/mid/i, 'Mid')
                            .replace(/south/i, 'South');
                            data.titles[index] = `Solfors ${formattedName}`;
                        }
                    });
                } else if (advId >= 1 && advId <= 12) {
                    const solforsPaths = SOLFORS_PATHS[advId] || {};
                    const pathKeys = Object.keys(solforsPaths);
                    pathKeys.forEach((pathName, index) => {
                        if (solforsPaths[pathName] && !data.paths[index]) {
                            data.paths[index] = solforsPaths[pathName].replace(/-/g, ',');
                            const formattedName = pathName
                            .replace(/^sol/i, '')
                            .replace(/blue1stblue/i, 'Blue 1st Blue')
                            .replace(/blue1storange/i, 'Blue 1st Orange')
                            .replace(/blue1stgreen/i, 'Blue 1st Green')
                            .replace(/green1stblue/i, 'Green 1st Blue')
                            .replace(/green1storange/i, 'Green 1st Orange')
                            .replace(/green1stgreen/i, 'Green 1st Green')
                            .replace(/blue/i, 'Blue')
                            .replace(/orange/i, 'Orange')
                            .replace(/green/i, 'Green');
                            data.titles[index] = `Solfors ${formattedName}`;
                        }
                    });
                }

                const result = await createPathEditor(advId, mapNum, data);

                // If user clicked back, return to adventure selection
                if (result === 'back') {
                    return await window.editAdventurePathsStandalone();
                }

                // If saved successfully
                if (result === true) {
                    await popup.confirm(
                        `‚úÖ Saved ${data.paths.filter(p => p).length} paths!`,
                        [{ msg: 'OK', result: true }]
                    );
                }
            }
        };
        ModuleTracker.register('Adventure Extension');
    }

    // ================================================================
    // SECTION 3: DELAY FACTOR AND AUTOMATION CONTROL
    // ================================================================
    // Emergency stop variable (kept for backwards compatibility)
    let automationInterval = null;

    // Emergency stop function (simplified)
    window.stopAllAutomation = function() {
        debugLog('No continuous automation to stop - using collect on load only');
        return false;
    };

    // Delay factor system
    function loadDelayFactor() {
        try {
            const saved = localStorage.getItem('hwh_tweaker_delay_factor');
            const factor = saved ? parseFloat(saved) : 1.0;
            return isNaN(factor) ? 1.0 : factor;
        } catch (e) {
            return 1.0;
        }
    }

    function saveDelayFactor(factor) {
        try {
            localStorage.setItem('hwh_tweaker_delay_factor', factor.toString());
            return true;
        } catch (e) {
            return false;
        }
    }

    function setDelayFactor(newFactor) {
        const clampedFactor = Math.max(0.1, Math.min(10, newFactor));
        window.tweakerDelayFactor = clampedFactor;
        saveDelayFactor(clampedFactor);
        return clampedFactor;
    }

    function loadClanPrestigeData() {
        const defaults = {
            lastSuccess: null,
            runCount: 0,
            fullScanInterval: 5
        };

        try {
            const saved = localStorage.getItem('hwh_clan_prestige_data');
            if (saved) {
                const parsed = JSON.parse(saved);
                return { ...defaults, ...parsed };
            }
        } catch (e) {
            console.warn('Could not load clan prestige data:', e);
        }
        return defaults;
    }

    function saveClanPrestigeData(data) {
        try {
            const jsonString = JSON.stringify(data);
            localStorage.setItem('hwh_clan_prestige_data', jsonString);
            return true;
        } catch (e) {
            console.warn('Could not save clan prestige data:', e);
            return false;
        }
    }

    // ================================================================
    // BATTLE PASS DATA MANAGEMENT - ENHANCED
    // ================================================================

    // Enhanced Battle Pass data management - now tracks per-season progress properly
    function loadBattlePassData() {
        const defaults = {
            runCount: 0,
            lastRun: null
        };

        try {
            const saved = localStorage.getItem('hwh_battle_pass_data');
            if (saved) {
                const parsed = JSON.parse(saved);
                return { ...defaults, ...parsed };
            }
        } catch (e) {
            console.warn('Could not load battle pass data:', e);
        }
        return defaults;
    }

    function saveBattlePassData(data) {
        try {
            const jsonString = JSON.stringify(data);
            localStorage.setItem('hwh_battle_pass_data', jsonString);
            return true;
        } catch (e) {
            console.warn('Could not save battle pass data:', e);
            return false;
        }
    }


    // ================================================================
    // INITIALIZE DATA - MOVED HERE AFTER FUNCTIONS ARE DEFINED
    // ================================================================

    window.tweakerDelayFactor = loadDelayFactor();

    // Load clan prestige data
    if (!window.clanPrestigeData) {
        window.clanPrestigeData = loadClanPrestigeData();
    }

    // Load battle pass data - NOW AFTER FUNCTION IS DEFINED
    if (!window.battlePassData) {
        window.battlePassData = loadBattlePassData();
    }

    function getDelayFactor() {
        return Math.max(0.1, Math.min(10, window.tweakerDelayFactor || 1.0));
    }

    function getAdjustedDelay(baseDelay) {
        const factor = getDelayFactor();
        const adjusted = Math.round(baseDelay * factor);
        return adjusted;
    }

    window.checkDelayFactor = function() {
        const factor = getDelayFactor();
        const message = `Current delay factor: ${factor}x`;
        debugLog(message);
        if (HWHFuncs && HWHFuncs.setProgress) {
            HWHFuncs.setProgress(message, true);
        }
        return factor;
    };

    // ================================================================
    // SECTION 4: INTERFACE DETECTION AND INITIALIZATION
    // ================================================================

    // Then update the function to use the variable:
    function earlyRegisterTweaker() {
        if (typeof HWHFuncs !== 'undefined' && HWHFuncs.addExtentionName) {
            if (!window.tweakerRegistered) {
                HWHFuncs.addExtentionName('HWH Tweaker', TWEAKER_VERSION, 'AI Assistant (Extension for ZingerY\'s HeroWarsHelper)');
                window.tweakerRegistered = true;
                debugLog(`Early registered HWH Tweaker v${TWEAKER_VERSION}`);
            }
        } else {
            setTimeout(earlyRegisterTweaker, 500);
        }
    }

    setTimeout(earlyRegisterTweaker, 100);

    // Wait for interface
    function waitForTweakerInterface() {
        return new Promise((resolve) => {
            let attempts = 0;
            const maxAttempts = 60;

            function checkInterface() {
                attempts++;

                const hwhLoaded = typeof HWHClasses !== 'undefined' &&
                      typeof HWHFuncs !== 'undefined' &&
                      typeof HWHData !== 'undefined';

                const sendAvailable = typeof Send !== 'undefined' ||
                      (HWHFuncs && HWHFuncs.Send) ||
                      window.Send;

                const interfaceElements = DOMCache.get('btnPlate1', '.scriptMenu_btnPlate') ||
                      DOMCache.get('btnSocket', '.scriptMenu_btnSocket') ||
                      DOMCache.get('btnRow', '.scriptMenu_btnRow') ||
                      DOMCache.getAll('btnPlates', '.scriptMenu_btnPlate').some(el =>
                                                                                el.textContent.includes('Do All') ||
                                                                                el.textContent.includes('Actions')
                                                                               );

                debugLog(`Tweaker interface check ${attempts}: HWH=${hwhLoaded}, Send=${sendAvailable}, Elements=${interfaceElements}`);

                if (hwhLoaded && sendAvailable && interfaceElements) {
                    debugLog('Tweaker interface ready - initializing');
                    resolve(true);
                    return;
                }

                if (attempts >= maxAttempts) {
                    console.warn('Tweaker interface detection timeout - proceeding anyway');
                    resolve(false);
                    return;
                }

                setTimeout(checkInterface, 1000);
            }

            checkInterface();
        });
    }

    function waitForHWH() {
        waitForTweakerInterface().then(() => {
            initTweaker();
        });
    }
    // ================================================================
    // SECTION 5: COLLECTION AUTOMATION FUNCTIONS
    // ================================================================

    // Soul Shop function - CLEANED (minimal debugging)
    window.buyAllInSoulShop = async function() {
        try {
            if (HWHFuncs.setProgress) HWHFuncs.setProgress('üõí Checking Soul Shop...', false);

            const SendFunction = getSend();
            if (!SendFunction) {
                return { success: false, error: 'No Send function available' };
            }

            const result = await SendFunction('{"calls":[{"name":"shopGetAll","args":{},"ident":"body"}]}').then(e => e.results.map(n => n.result.response));
            const shops = result[0];
            const calls = [];
            let slots = null;

            if (shops[8]) {
                slots = shops[8].slots;

                for (const slotId in slots) {
                    if (slotId == 1) continue; // Skip slot 1

                    const slot = slots[slotId];
                    if (!slot.bought) {
                        calls.push({
                            name: "shopBuy",
                            args: { shopId: 8, slot: parseInt(slotId), cost: slot.cost, reward: slot.reward },
                            context: { actionTs: Date.now() },
                            ident: "body_" + slotId
                        });
                    }
                }
            } else {
                if (HWHFuncs.setProgress) HWHFuncs.setProgress('‚ùå Soul Shop not found', true);
                return { success: false, error: 'Soul Shop not found' };
            }

            if (calls.length && slots) {
                if (HWHFuncs.setProgress) HWHFuncs.setProgress(`üõí Buying ${calls.length} items from Soul Shop...`, false);

                const results = await SendFunction(JSON.stringify({ calls }));
                let successfulPurchases = 0;
                const structuredRewards = {};

                const addReward = (name, amount) => {
                    if (structuredRewards[name]) {
                        structuredRewards[name].amount += amount;
                    } else {
                        structuredRewards[name] = { amount, source: 'S' };
                    }
                };

                if (results && results.results) {
                    results.results.forEach((result, index) => {
                        const call = calls[index];
                        const slotId = call.args.slot;
                        const slot = slots[slotId];

                        if (result && !result.result?.error) {
                            successfulPurchases++;

                            if (slot.reward.consumable) {
                                Object.entries(slot.reward.consumable).forEach(([itemId, qtyObj]) => {
                                    const quantity = window.extractQuantityFromObject(qtyObj);
                                    const itemName = window.identifyItem(itemId, 'consumable');
                                    addReward(`üì¶ ${itemName}`, quantity);
                                });
                            }
                            if (slot.reward.gear) {
                                Object.entries(slot.reward.gear).forEach(([gearId, qtyObj]) => {
                                    const quantity = window.extractQuantityFromObject(qtyObj);
                                    const itemName = window.identifyItem(gearId, 'gear');
                                    addReward(`‚öôÔ∏è ${itemName}`, quantity);
                                });
                            }
                            if (slot.reward.fragmentGear) {
                                Object.entries(slot.reward.fragmentGear).forEach(([gearId, qtyObj]) => {
                                    const quantity = window.extractQuantityFromObject(qtyObj);
                                    const itemName = window.identifyItem(gearId, 'gear');
                                    addReward(`üîß ${itemName} (Frag)`, quantity);
                                });
                            }
                            if (slot.reward.scroll) {
                                Object.entries(slot.reward.scroll).forEach(([scrollId, qtyObj]) => {
                                    const quantity = window.extractQuantityFromObject(qtyObj);
                                    const itemName = window.identifyItem(scrollId, 'scroll');
                                    addReward(`üìú ${itemName}`, quantity);
                                });
                            }
                            if (slot.reward.fragmentScroll) {
                                Object.entries(slot.reward.fragmentScroll).forEach(([scrollId, qtyObj]) => {
                                    const quantity = window.extractQuantityFromObject(qtyObj);
                                    const itemName = window.identifyItem(scrollId, 'scroll');
                                    addReward(`üìú ${itemName} (Frag)`, quantity);
                                });
                            }
                            if (slot.reward.heroFragment || slot.reward.fragmentHero) {
                                const fragments = slot.reward.heroFragment || slot.reward.fragmentHero;
                                Object.entries(fragments).forEach(([heroId, qtyObj]) => {
                                    const quantity = window.extractQuantityFromObject(qtyObj);
                                    const heroName = window.itemNameCache?.hero?.[heroId] || `Hero #${heroId}`;
                                    addReward(`üë§ ${heroName} (SS)`, quantity);
                                });
                            }
                            if (slot.reward.coin) {
                                for (const [coinId, amt] of Object.entries(slot.reward.coin)) {
                                    const name = window.identifyItem?.(coinId, 'coin') || `Coin #${coinId}`;
                                    const quantity = parseInt(amt) || 0;
                                    addReward(`üí∞ ${name}`, quantity);
                                }
                            }
                            if (slot.reward.starmoney) {
                                const quantity = window.extractQuantityFromObject(slot.reward.starmoney);
                                addReward(`üíé Emeralds`, quantity);
                            }
                        }
                    });
                }

                const rewardCount = Object.keys(structuredRewards).length;

                if (successfulPurchases > 0) {
                    if (HWHFuncs.setProgress) {
                        HWHFuncs.setProgress(`‚úÖ Soul Shop: ${successfulPurchases} slots bought`, false);
                    }
                    return {
                        success: true,
                        items: `${successfulPurchases} items`,
                        count: successfulPurchases,
                        hasItems: rewardCount > 0,
                        rewards: structuredRewards
                    };
                } else {
                    if (HWHFuncs.setProgress) HWHFuncs.setProgress('‚ö†Ô∏è Soul Shop: No purchases made', false);
                    return {
                        success: true,
                        items: 'No items to buy',
                        count: 0,
                        hasItems: false,
                        rewards: {}
                    };
                }
            } else {
                if (HWHFuncs.setProgress) HWHFuncs.setProgress('‚úÖ Soul Shop: No items to buy', false);
                return {
                    success: true,
                    items: 'No items to buy',
                    rewards: [],
                    count: 0
                };
            }
        } catch (error) {
            console.error('Soul Shop error:', error);
            if (HWHFuncs.setProgress) HWHFuncs.setProgress('‚ùå Soul Shop purchase failed', true);
            return {
                success: false,
                error: error.message
            };
        }
    };
    // Buy gear/scrolls from Arena, Grand, Tower, Friendship, Outland shops - prioritized by craft targets
    window.buyShopsWithCraftPriority = async function() {
        try {
            if (HWHFuncs.setProgress) HWHFuncs.setProgress('üõí Checking shops...', false);

            const SendFunction = getSend();
            if (!SendFunction) return { success: false, error: 'No Send function available' };

            const result = await SendFunction(JSON.stringify({calls:[
                {name:'inventoryGet',args:{},ident:'inv'},
                {name:'shopGetAll',args:{},ident:'shops'}
            ]}));
            const inv = result.results[0].result.response;
            const shops = result.results[1].result.response;

            // Load craft targets from tab 6
            let craftTargets = {};
            try { craftTargets = JSON.parse(localStorage.getItem('hwh_craft_targets') || '{}'); } catch(e){}

            const SHOPS = {4:'Arena', 5:'Grand', 6:'Tower', 9:'Friendship', 10:'Outland'};
            const VALID_TYPES = ['gear', 'scroll', 'fragmentGear', 'fragmentScroll'];

            const buyList = [];
            const invTracker = JSON.parse(JSON.stringify(inv)); // clone for tracking spending

            for (const [shopId, shopName] of Object.entries(SHOPS)) {
                const shop = shops[shopId];
                if (!shop?.slots) continue;

                for (const [slotId, slot] of Object.entries(shop.slots)) {
                    if (slot.bought) continue;

                    const costType = Object.keys(slot.cost)[0];
                    const costId = Object.keys(slot.cost[costType])[0];
                    const costAmt = parseInt(slot.cost[costType][costId]);
                    const have = invTracker[costType]?.[costId] || 0;
                    if (have < costAmt) continue;

                    const rwdType = Object.keys(slot.reward)[0];
                    if (!VALID_TYPES.includes(rwdType)) continue;

                    const rwdId = Object.keys(slot.reward[rwdType])[0];
                    const rwdQty = parseInt(slot.reward[rwdType][rwdId]) || 1;

                    const isFragment = rwdType.startsWith('fragment');
                    const baseType = isFragment ? rwdType.replace('fragment','').toLowerCase() : rwdType;
                    const targetKey = `${baseType}_${rwdId}`;
                    const target = craftTargets[targetKey] || 0;

                    const haveBuilt = inv[baseType]?.[rwdId] || 0;
                    const fragKey = `fragment${baseType.charAt(0).toUpperCase() + baseType.slice(1)}`;
                    const haveFrags = inv[fragKey]?.[rwdId] || 0;
                    const mergeCost = lib.data?.inventoryItem?.[baseType]?.[rwdId]?.fragmentMergeCost?.fragmentCount || 50;

                    const effectiveHave = haveBuilt + Math.floor(haveFrags / mergeCost);
                    const needItems = Math.max(0, target - effectiveHave);

                    if (needItems <= 0) continue; // Skip if at or above target

                    const contribution = isFragment ? (rwdQty / mergeCost) : rwdQty;
                    const priority = needItems * contribution;

                    // Deduct cost from tracker
                    invTracker[costType][costId] -= costAmt;

                    const itemName = window.identifyItem?.(rwdId, baseType) || `${rwdType}#${rwdId}`;

                    buyList.push({
                        shopId: parseInt(shopId), slotId: parseInt(slotId),
                        shopName, itemName, rwdType, rwdQty, priority,
                        cost: slot.cost, reward: slot.reward
                    });
                }
            }

            if (!buyList.length) {
                if (HWHFuncs.setProgress) HWHFuncs.setProgress('‚úÖ Shops: No items to buy', false);
                return { success: true, items: 'No items to buy', count: 0, hasItems: false, rewards: {} };
            }

            // Sort by priority (highest first)
            buyList.sort((a,b) => b.priority - a.priority);

            if (HWHFuncs.setProgress) HWHFuncs.setProgress(`üõí Buying ${buyList.length} items...`, false);

            const structuredRewards = {};
            let bought = 0;

            for (const item of buyList) {
                try {
                    const r = await SendFunction(JSON.stringify({calls:[{
                        name: 'shopBuy',
                        args: { shopId: item.shopId, slot: item.slotId, cost: item.cost, reward: item.reward },
                        ident: 'buy'
                    }]}));

                    if (r.results[0].result.response && !r.results[0].result.error) {
                        bought++;
                        const icon = item.rwdType.includes('Gear') ? '‚öôÔ∏è' : 'üìú';
                        const frag = item.rwdType.startsWith('fragment') ? ' (Frag)' : '';
                        const key = `${icon} ${item.itemName}${frag}`;
                        structuredRewards[key] = { amount: (structuredRewards[key]?.amount || 0) + item.rwdQty, source: item.shopName[0] };
                    }
                } catch (e) {
                    debugLog(`Shop buy failed: ${item.itemName}`, e);
                }
                await new Promise(r => setTimeout(r, 50));
            }

            if (HWHFuncs.setProgress) HWHFuncs.setProgress(`‚úÖ Shops: ${bought} items bought`, false);

            return {
                success: true,
                items: `${bought} items`,
                count: bought,
                hasItems: bought > 0,
                rewards: structuredRewards
            };
        } catch (error) {
            console.error('Shop buy error:', error);
            if (HWHFuncs.setProgress) HWHFuncs.setProgress('‚ùå Shop purchase failed', true);
            return { success: false, error: error.message };
        }
    };

    window.collectAllGuildQuestRewards = async function() {
        try {
            if (HWHFuncs.setProgress) HWHFuncs.setProgress('üè∞ Starting guild quest collection...', false);

            const SendFunction = getSend();
            let totalCollected = 0;
            let roundNumber = 1;
            let maxRounds = 10; // Increased from 8 to handle more iterations

            while (roundNumber <= maxRounds) {
                if (HWHFuncs.setProgress) HWHFuncs.setProgress(`üè∞ Guild quests: Round ${roundNumber}/${maxRounds}...`, false);

                // Get all quests
                const questResponse = await SendFunction('{"calls":[{"name":"questGetAll","args":{},"ident":"body"}]}');

                if (!questResponse?.results?.[0]?.result?.response) {
                    debugLog('No quest data found');
                    break;
                }

                const allQuests = questResponse.results[0].result.response;
                let roundCollected = 0;

                // Phase 1: Batch collect state 2 quests
                const state2Quests = [];
                for (let i = 0; i < allQuests.length; i++) {
                    const quest = allQuests[i];
                    if (quest.id >= 20000000 && quest.id <= 20000200) {
                        debugLog(`Guild quest ${quest.id}: state=${quest.state}, progress=${quest.progress}`);
                        if (quest.state === 2) {
                            state2Quests.push(quest.id);
                        }
                    }
                }

                if (state2Quests.length > 0) {
                    debugLog(`Round ${roundNumber}: Found ${state2Quests.length} state 2 quests for batch collection:`, state2Quests);

                    const collectResponse = await SendFunction(JSON.stringify({
                        calls: [{
                            name: "quest_questsFarm",
                            args: { questIds: state2Quests },
                            context: { actionTs: Date.now() },
                            ident: "body"
                        }]
                    }));

                    if (collectResponse?.results?.[0]?.result && !collectResponse.results?.[0]?.result.error) {
                        debugLog('üè∞ Guild quest rewards:', JSON.stringify(collectResponse.results[0].result.response));
                        roundCollected += state2Quests.length;
                        totalCollected += state2Quests.length;
                        debugLog(`State 2 batch: ${state2Quests.length} collected`);
                    }
                }

                // Phase 2: Individual test state 1 quests
                const state1Quests = [];
                for (let i = 0; i < allQuests.length; i++) {
                    const quest = allQuests[i];
                    if (quest.id >= 20000000 && quest.id <= 20000200 && quest.state === 1) {
                        state1Quests.push(quest.id);
                    }
                }

                if (state1Quests.length > 0) {
                    debugLog(`Testing ${state1Quests.length} state 1 quests individually...`);
                    let state1Collected = 0;

                    for (const questId of state1Quests) {
                        try {
                            const response = await SendFunction(`{"calls":[{"name":"quest_questsFarm","args":{"questIds":[${questId}]},"context":{"actionTs":${Date.now()}},"ident":"body"}]}`);
                            if (response?.results?.[0]?.result && !response.results[0].result.error) {
                                debugLog('üè∞ Guild quest reward:', JSON.stringify(response.results[0].result.response));
                                state1Collected++;
                                totalCollected++;
                                roundCollected++;
                            }
                            await new Promise(resolve => setTimeout(resolve, getAdjustedDelay(38)));
                        } catch (error) {
                            // Silent error handling
                        }
                    }
                    debugLog(`State 1 results: ${state1Collected}/${state1Quests.length} collected`);
                }

                // If no quests were collected this round, we're done
                if (roundCollected === 0) {
                    debugLog(`Round ${roundNumber}: No quests collected, stopping`);
                    break;
                }

                if (HWHFuncs.setProgress) {
                    HWHFuncs.setProgress(`üè∞ Round ${roundNumber}: +${roundCollected} quests (${totalCollected} total)`, false);
                }

                roundNumber++;

                // Small delay between rounds
                await new Promise(resolve => setTimeout(resolve, getAdjustedDelay(40)));
            }

            if (HWHFuncs.setProgress) HWHFuncs.setProgress(`‚úÖ Guild quests: ${totalCollected} collected in ${roundNumber-1} rounds`, false);

            return {
                success: true,
                items: totalCollected > 0 ? `${totalCollected} guild quests collected` : 'All guild quests already collected',
                count: totalCollected,
                hasItems: false
            };

        } catch (error) {
            console.error('Error collecting guild quests:', error);
            if (HWHFuncs.setProgress) HWHFuncs.setProgress('‚ùå Guild quest collection failed', false);
            return {
                success: false,
                items: 'Guild quest collection failed',
                count: 0
            };
        }
    };
    // Keep daily rewards as the original working version with reduced delay:
    window.harvestDailyRewards = async function() {
        try {
            if (HWHFuncs.setProgress) HWHFuncs.setProgress('üéÅ Starting daily rewards collection...', false);

            const SendFunction = getSend();
            const questResponse = await SendFunction('{"calls":[{"name":"questGetAll","args":{},"ident":"body"}]}');

            if (!questResponse.results?.[0]?.result.response) {
                if (HWHFuncs.setProgress) HWHFuncs.setProgress('‚ùå No quest data for daily rewards', false);
                return {
                    success: false,
                    items: 'No quest data available',
                    count: 0
                };
            }

            const allQuests = questResponse.results[0].result.response;
            const dailyRewardsToTest = [];
            const structuredRewards = {};

            // Find daily quests (20010000-20010005)
            for (let i = 0; i <= 5; i++) {
                const questId = 20010000 + i;
                if (Object.values(allQuests).some(quest => quest?.id === questId)) {
                    dailyRewardsToTest.push(questId);
                }
            }

            if (dailyRewardsToTest.length === 0) {
                if (HWHFuncs.setProgress) HWHFuncs.setProgress('‚úÖ Daily rewards: No quests found', false);
                return {
                    success: true,
                    items: 'All daily rewards already collected',
                    count: 0
                };
            }

            let successCount = 0;
            if (HWHFuncs.setProgress) HWHFuncs.setProgress(`üéÅ Testing ${dailyRewardsToTest.length} daily rewards...`, false);

            // Map of daily reward items (fallback)
            const dailyRewardItems = {
                20010000: { name: 'üè∞ Guild Activity', qty: 150 },
                20010001: { name: 'üîÆ Titanite', qty: 75 },
                20010002: { name: '‚ö° Energy', qty: 200 },
                20010003: { name: 'üÉè Dungeon Cards', qty: 5 },
                20010004: { name: 'üí† Soul Crystal', qty: 1 },
                20010005: { name: 'üåÄ Portal Charge', qty: 1 }
            };

            for (let index = 0; index < dailyRewardsToTest.length; index++) {
                const questId = dailyRewardsToTest[index];
                const questPosition = index + 1;
                const isLastQuest = questPosition === 6;

                try {
                    const response = await SendFunction(`{"calls":[{"name":"quest_questsFarm","args":{"questIds":[${questId}]},"context":{"actionTs":${Date.now()}},"ident":"body"}]}`);

                    if (response?.results?.[0]?.result && !response.results[0].result.error) {
                        debugLog('üéÅ Daily reward response:', JSON.stringify(response.results[0].result.response));
                        successCount++;

                        // Parse actual rewards from response
                        let rewardResponse = response.results[0].result.response;
                        // Unwrap if response is an array (e.g., [{"clanActivity":150}])
                        if (Array.isArray(rewardResponse)) {
                            rewardResponse = rewardResponse.reduce((acc, item) => ({ ...acc, ...item }), {});
                        }
                        let foundReward = false;

                        for (const [key, value] of Object.entries(rewardResponse)) {
                            if (key === 'quests') continue;

                            // Handle nested objects like {"refillable":{"45":"1"}} or {"consumable":{"81":5}}
                            if (typeof value === 'object' && value !== null) {
                                for (const [itemId, itemQty] of Object.entries(value)) {
                                    const qty = parseInt(itemQty) || 1;
                                    let itemName = '';
                                    if (key === 'refillable') {
                                        itemName = 'üîã ' + (window.identifyItem?.(itemId, 'consumable') || `Refillable #${itemId}`);
                                    } else if (key === 'consumable') {
                                        itemName = 'üì¶ ' + (window.identifyItem?.(itemId, 'consumable') || `Item #${itemId}`);
                                    } else if (key === 'coin') {
                                        itemName = 'üí∞ ' + (window.identifyItem?.(itemId, 'coin') || `Coin #${itemId}`);
                                    } else {
                                        itemName = window.identifyItem?.(itemId, key) || `${key} #${itemId}`;
                                    }
                                    if (!structuredRewards[itemName]) structuredRewards[itemName] = { amount: 0, source: 'D' };
                                    structuredRewards[itemName].amount += qty;
                                    foundReward = true;
                                }
                                continue;
                            }

                            let itemName = '';
                            let qty = typeof value === 'number' ? value : parseInt(value) || 1;

                            if (key === 'stamina') itemName = '‚ö° Energy';
                            else if (key === 'skillPoint') itemName = 'üîÆ Titanite';
                            else if (key === 'gold') itemName = 'ü™ô Gold';
                            else if (key === 'starmoney') itemName = 'üíé Emeralds';
                            else if (key === 'dungeonActivity') itemName = 'üÉè Dungeon Cards';
                            else if (key === 'soulCrystal') itemName = 'üí† Soul Crystal';
                            else if (key === 'adventure') itemName = 'üåÄ Portal Charge';
                            else if (key === 'clanActivity') itemName = 'üè∞ Guild Activity';
                            else itemName = key;

                            if (!structuredRewards[itemName]) structuredRewards[itemName] = { amount: 0, source: 'D' };
                            structuredRewards[itemName].amount += qty;
                            foundReward = true;
                        }

                        // Fallback to hardcoded if no rewards parsed
                        if (!foundReward) {
                            const fallback = dailyRewardItems[questId] || { name: `Daily reward ${questPosition}`, qty: 1 };
                            if (!structuredRewards[fallback.name]) structuredRewards[fallback.name] = { amount: 0, source: 'D' };
                            structuredRewards[fallback.name].amount += fallback.qty;
                        }
                        const icon = isLastQuest ? 'üåÄ' : '‚úÖ';
                        if (HWHFuncs.setProgress) HWHFuncs.setProgress(`${icon} Daily reward ${questPosition}/6 collected (${successCount} total)`, false);
                    }

                    // Reduced delay from 100ms to 30ms
                    //await new Promise(resolve => setTimeout(resolve, getAdjustedDelay(5)));
                } catch (error) {
                    // Silent error handling
                }
            }

            if (HWHFuncs.setProgress) HWHFuncs.setProgress(`‚úÖ Daily rewards: ${successCount}/6 collected`, false);

            const rewardCount = Object.keys(structuredRewards).length;

            return {
                success: true,
                items: rewardCount > 0 ? `${successCount} items` : 'All daily rewards already collected',
                count: successCount,
                hasItems: rewardCount > 0,
                rewards: structuredRewards
            };
        } catch (error) {
            console.error('Error collecting daily rewards:', error);
            if (HWHFuncs.setProgress) HWHFuncs.setProgress('‚ùå Daily rewards failed', false);
            return {
                success: false,
                items: 'Daily rewards collection failed',
                count: 0
            };
        }
    };
    window.collectAllGuildRewards = async function() {
        try {
            // Phase 1: Guild quests (working version)
            const guildResults = await window.collectAllGuildQuestRewards();
            debugLog('üè∞ Phase 1 results:', guildResults);

            // SPEED IMPROVEMENT: Shorter wait between phases
            //await new Promise(resolve => setTimeout(resolve, getAdjustedDelay(5)));

            // Phase 2: Daily rewards (working version with items)
            const dailyResults = await window.harvestDailyRewards();
            debugLog('üè∞ Phase 2 results:', dailyResults);

            // Combine all items from both sources
            const totalCount = guildResults.count + dailyResults.count;
            const allItems = [];

            // Add daily reward items (already in good format like "Guild Activity x150")
            if (dailyResults.count > 0 && dailyResults.items && !dailyResults.items.includes('already collected')) {
                allItems.push(dailyResults.items);
            }

            // Guild quests don't return specific items, just count - skip adding text for them

            // Merge rewards from daily (already structured)
            const structuredRewards = dailyResults.rewards || {};
            const rewardCount = Object.keys(structuredRewards).length;

            // Build summary text
            let summaryItems;
            const questCount = guildResults.count || 0;
            const itemCount = dailyResults.count || 0;

            if (questCount > 0 || itemCount > 0) {
                const parts = [];
                if (questCount > 0) parts.push(`${questCount} quests`);
                if (rewardCount > 0) parts.push(`${rewardCount} items`);
                summaryItems = parts.join(', ') || 'Done';
            } else {
                summaryItems = 'All guild and daily rewards already collected';
            }

            const finalResult = {
                success: guildResults.success && dailyResults.success,
                items: summaryItems,
                count: totalCount,
                hasItems: rewardCount > 0,
                rewards: structuredRewards
            };
            return finalResult;

        } catch (error) {
            console.error('Error in guild rewards collection:', error);
            if (HWHFuncs.setProgress) HWHFuncs.setProgress('‚ùå Guild rewards collection failed', true);
            return {
                success: false,
                items: `Error: ${error.message}`,
                count: 0
            };
        }
    };

    // Replace the existing collectClanPrestigeRewards function with this improved version
    window.collectClanPrestigeRewards = async function() {
        try {
            if (HWHFuncs.setProgress) HWHFuncs.setProgress('üèÜ Starting clan prestige collection...', false);

            const SendFunction = getSend();
            window.clanPrestigeData = loadClanPrestigeData();

            // First, get current prestige info to see what's already collected
            const infoResponse = await SendFunction('{"calls":[{"name":"clan_prestigeGetInfo","args":{},"ident":"body"}]}');

            if (!infoResponse?.results?.[0]?.result?.response) {
                if (HWHFuncs.setProgress) HWHFuncs.setProgress('‚ùå Could not get prestige info', true);
                return {
                    success: false,
                    items: 'Could not get prestige info',
                    count: 0
                };
            }

            const prestigeInfo = infoResponse.results[0].result.response;
            const farmedLevels = prestigeInfo.farmedPrestigeLevels || [];

            debugLog(`Already farmed ${farmedLevels.length} prestige levels: ${farmedLevels.join(', ')}`);

            // Prestige level thresholds (from wiki)
            const PRESTIGE_THRESHOLDS = [
                0, 5000, 10500, 18000, 27000, 37500, 49750, 63500, 78750, 95500,        // 1-10
                113500, 133000, 154000, 176250, 199750, 224750, 251000, 278500, 307250, 337500, // 11-20
                368750, 401250, 435250, 470250, 506500, 544000, 582750, 622500, 663500, 705750, // 21-30
                749250, 793750, 839500, 886500, 934500, 983750, 1034000, 1085000, 1138000, 1191500, // 31-40
                1246500, 1302250, 1359250, 1417250, 1476500, 1536750, 1598250, 1660500, 1724000, 1788750, // 41-50
                1854250, 1921000, 1988750, 2057500, 2127500, 2198500, 2270500, 2343500, 2417500, 2492500, // 51-60
                2568750, 2645750, 2724000, 2803250, 2883500, 2964750, 3047000, 3130250, 3214500, 3300000  // 61-70
            ];

            // Calculate current max level from prestigeCount
            const prestigePoints = prestigeInfo.prestigeCount || 0;
            let currentMaxLevel = 1;
            for (let i = 0; i < PRESTIGE_THRESHOLDS.length; i++) {
                if (prestigePoints >= PRESTIGE_THRESHOLDS[i]) {
                    currentMaxLevel = i + 1;
                } else {
                    break;
                }
            }
            // Handle levels 71+ (every 90,000 after 3,300,000)
            if (prestigePoints >= 3300000) {
                currentMaxLevel = 70 + Math.floor((prestigePoints - 3300000) / 90000) + 1;
            }

            console.log(`üèÜ Prestige: ${prestigePoints.toLocaleString()} pts = Level ${currentMaxLevel} (farmed ${farmedLevels.length})`);

            // Only check levels up to what's actually unlocked
            const farmedSet = new Set(farmedLevels);
            const uncollectedLevels = [];

            for (let level = 1; level <= currentMaxLevel; level++) {
                if (!farmedSet.has(level)) {
                    uncollectedLevels.push(level);
                }
            }
            if (uncollectedLevels.length === 0) {
                if (HWHFuncs.setProgress) HWHFuncs.setProgress('‚úÖ Clan prestige: All available rewards collected', false);
                return {
                    success: true,
                    items: 'All prestige rewards already collected',
                    count: 0
                };
            }

            debugLog(`Found ${uncollectedLevels.length} uncollected levels: ${uncollectedLevels.slice(0, 10).join(', ')}${uncollectedLevels.length > 10 ? '...' : ''}`);

            // Try to collect uncollected levels (limit to first 10 to avoid timeout)
            const levelsToTry = uncollectedLevels.slice(0, 10);
            const collectedRewards = [];
            let successCount = 0;

            if (HWHFuncs.setProgress) {
                HWHFuncs.setProgress(`üèÜ Attempting to collect ${levelsToTry.length} prestige levels...`, false);
            }

            for (const level of levelsToTry) {
                try {
                    const response = await SendFunction(JSON.stringify({
                        calls: [{
                            name: "clan_prestigeFarmReward",
                            args: { level: level },
                            context: { actionTs: Date.now() },
                            ident: "body"
                        }]
                    }));

                    if (response?.results?.[0]?.result && !response.results[0].result.error) {
                        successCount++;

                        // Update last successful level for backwards compatibility
                        window.clanPrestigeData.lastSuccess = level;

                        // Parse the reward response
                        const rewardResponse = response.results[0].result.response;
                        debugLog('üèÜ Clan Prestige reward response:', JSON.stringify(rewardResponse));
                        const rewards = window.parseRewardResponse(rewardResponse);
                        const itemsText = rewards.map(r => r.display + ' [P]').join(', ');

                        collectedRewards.push({
                            level: level,
                            items: itemsText,
                            rewards: rewards
                        });

                        debugLog(`üèÜ Collected prestige level ${level}: ${itemsText}`);

                        if (HWHFuncs.setProgress) {
                            HWHFuncs.setProgress(`üèÜ Collected level ${level}: ${itemsText}`, false);
                        }

                        // Small delay between collections
                        // await new Promise(resolve => setTimeout(resolve, getAdjustedDelay(5)));
                    } else {
                        // Check if it's a "not enough prestige points" error
                        const error = response?.results?.[0]?.result?.error;
                        if (error?.name === 'NotEnough' || error?.name === 'NotEnoughClanScore') {
                            debugLog(`Not enough prestige points for level ${level} - stopping collection`);
                            break;
                        } else {
                            debugLog(`Could not collect level ${level}:`, error);
                        }
                    }
                } catch (error) {
                    debugLog(`Error collecting level ${level}:`, error);
                }
            }

            // Update tracking data
            window.clanPrestigeData.runCount = (window.clanPrestigeData.runCount || 0) + 1;
            saveClanPrestigeData(window.clanPrestigeData);

            // Build summary
            if (successCount > 0) {
                const levelsList = collectedRewards.map(r => r.level).join(', ');

                // Merge all rewards into structured format
                const structuredRewards = {};
                collectedRewards.forEach(cr => {
                    cr.rewards.forEach(r => {
                        const name = r.display.replace(/\s*x\s*\d+$/, '').trim(); // remove "x123" suffix
                        const amount = r.quantity || 1;
                        if (structuredRewards[name]) {
                            structuredRewards[name].amount += amount;
                        } else {
                            structuredRewards[name] = { amount, source: 'P' };
                        }
                    });
                });
                const rewardCount = Object.keys(structuredRewards).length;

                if (HWHFuncs.setProgress) {
                    HWHFuncs.setProgress(`‚úÖ Clan prestige: ${successCount} levels collected (${levelsList})`, false);
                }

                return {
                    success: true,
                    items: `${successCount} levels, ${rewardCount} items`,
                    count: successCount,
                    hasItems: rewardCount > 0,
                    rewards: structuredRewards
                };
            } else {
                const remainingCount = uncollectedLevels.length;
                const message = remainingCount > 0 ?
                      `No prestige rewards available (${remainingCount} levels locked)` :
                'All prestige rewards already collected';

                if (HWHFuncs.setProgress) {
                    HWHFuncs.setProgress(`‚úÖ Clan prestige: ${message}`, false);
                }

                return {
                    success: true,
                    items: message,
                    count: 0
                };
            }

        } catch (error) {
            console.error('Error collecting clan prestige:', error);
            if (HWHFuncs.setProgress) HWHFuncs.setProgress('‚ùå Clan prestige failed', false);

            return {
                success: false,
                items: `Clan prestige error: ${error.message}`,
                count: 0
            };
        }
    };


    // ================================================================
    // SECTION 6: NAVIGATION FUNCTIONS
    // ================================================================
    function getFnP(classF, nameF) {
        let prop = Object.entries(classF.__properties__);
        return prop.filter((e) => e[1] == nameF).pop()[0];
    }
    function getPlayer() {
        let instance = getFnP(Game.GameModel, 'get_instance');
        const playerProp = Object.keys(Game.GameModel.prototype)[0];
        return Game.GameModel[instance]()[playerProp];
    }
    window.goGuildMembers = function () {
        try {
            let player = getPlayer();
            let clanInfoMediator = selfGame['game.mediator.gui.popup.clan.ClanInfoPopupMediator'];
            new clanInfoMediator(player).open();
        } catch (e) {
            console.error('Failed to open Guild Members popup:', e);
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('Failed to open Guild Members', true);
            }
        }
    };

    // Reusable clan popup - can be called from tournament or AoC
    window.showClanPopup = async function(clanId, highlightUserId = null) {
        if (!clanId) {
            debugLog('No clan ID provided');
            return;
        }

        const SendFunction = getSend();
        if (!SendFunction) {
            console.error('SendFunction not available');
            return;
        }

        // Remove any existing clan popup
        const existing = document.getElementById('clan-info-popup');
        if (existing) existing.remove();

        try {
            debugLog(`Fetching clan info for clan ID: ${clanId}...`);
            const clanResponse = await SendFunction(`{"calls":[{"name":"clanGetInfo","args":{"clanId":${clanId}},"context":{"actionTs":${Date.now()}},"ident":"body"}]}`);

            if (!clanResponse?.results?.[0]?.result?.response) {
                debugLog('Failed to fetch clan info');
                return;
            }

            const responseData = clanResponse.results[0].result.response;
            const clanData = responseData.clan;
            const membersStat = responseData.membersStat || [];
            const now = Date.now();

            const languageMap = {
                '1': 'üá©üá™ German', '2': 'üá¨üáß English', '4': 'üá´üá∑ French',
                '6': 'üá∑üá∫ Russian', '9': 'üáØüáµ Japanese', '10': 'üá∞üá∑ Korean',
                '11': 'üáµüá± Polish', '13': 'üáµüáπ Portuguese'
            };

            const clanPopup = document.createElement('div');
            clanPopup.id = 'clan-info-popup';
            clanPopup.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: rgba(42,24,16); border: 2px solid #8b6914; border-radius: 6px;
                padding: 15px; width: 650px; max-height: 80vh; overflow-y: auto;
                color: #ffd700; font-family: Arial, sans-serif; font-size: 12px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.5); z-index: 10001;
            `;

            let totalActivity = 0;
            const activityByUserId = {};
            membersStat.forEach(stat => {
                totalActivity += stat.activitySum || 0;
                activityByUserId[stat.userId] = stat;
            });

            const languageDisplay = languageMap[clanData.country] || `Unknown (${clanData.country})`;

            let clanContent = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h3 style="margin: 0; font-size: 14px;">üè∞ ${clanData.title}</h3>
                    <button id="close-clan-popup" style="background: #666; color: #fff; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 14px; font-weight: bold;">‚úï</button>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 12px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 4px;">
                    <div><span class="twk-muted">Server:</span> <span class="twk-green-bold">${clanData.serverId}</span></div>
                    <div><span class="twk-muted">Level:</span> <span class="twk-green-bold">${clanData.level}</span></div>
                    <div><span class="twk-muted">Members:</span> <span class="twk-green-bold">${clanData.membersCount}</span></div>
                    <div><span class="twk-muted">Language:</span> <span class="twk-green-bold">${languageDisplay}</span></div>
                    <div><span class="twk-muted">Min Level:</span> <span class="twk-green-bold">${clanData.minLevel}</span></div>
                    <div><span class="twk-muted">Frame ID:</span> <span class="twk-green-bold">${clanData.frameId}</span></div>
                    <div><span class="twk-muted">Top Activity:</span> <span class="twk-green-bold">${clanData.topActivity?.toLocaleString() || 'N/A'}</span></div>
                    <div><span class="twk-muted">Top Dungeon:</span> <span class="twk-green-bold">${clanData.topDungeon?.toLocaleString() || 'N/A'}</span></div>
                    <div><span class="twk-muted">Clan ID:</span> <span class="twk-green-bold">${clanData.id}</span></div>
                </div>
                ${clanData.description ? `<div style="margin-bottom: 12px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 4px;">
                    <div style="color: #999; margin-bottom: 4px;">Description:</div>
                    <div class="twk-gold">${clanData.description}</div>
                </div>` : ''}
                ${membersStat.length > 0 ? `<div style="margin-bottom: 12px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 4px;">
                    <div style="color: #4ae29a; margin-bottom: 6px; font-weight: bold;">üìä Total Guild Activity: ${totalActivity.toLocaleString()}</div>
                </div>` : ''}
                ${clanData.icon ? `<div style="margin-bottom: 12px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 4px;">
                    <div style="color: #999; margin-bottom: 4px;">Icon:</div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; font-size: 10px;">
                        <div>FlagColor1: <span class="twk-green">${clanData.icon.flagColor1}</span></div>
                        <div>FlagColor2: <span class="twk-green">${clanData.icon.flagColor2}</span></div>
                        <div>FlagShape: <span class="twk-green">${clanData.icon.flagShape}</span></div>
                        <div>IconColor: <span class="twk-green">${clanData.icon.iconColor}</span></div>
                        <div>IconShape: <span class="twk-green">${clanData.icon.iconShape}</span></div>
                    </div>
                </div>` : ''}
                <div style="border-top: 1px solid #666; padding-top: 10px;">
                    <div style="color: #4ae29a; margin-bottom: 8px; font-weight: bold; font-size: 11px;">üë• Members with Activity (${Object.keys(clanData.members).length}):</div>
                    <div style="display: grid; grid-template-columns: 150px 100px 50px 80px 90px; gap: 6px; padding: 6px; font-size: 11px; color: #999; font-weight: bold; border-bottom: 1px solid #666; margin-bottom: 4px;">
                        <div>Name</div>
                        <div class="twk-center">User ID</div>
                        <div class="twk-center">Lvl</div>
                        <div class="twk-center">Role</div>
                        <div class="twk-right">Activity</div>
                    </div>
            `;

            const members = Object.values(clanData.members);
            members.sort((a, b) => {
                const activityA = activityByUserId[a.id]?.activitySum || 0;
                const activityB = activityByUserId[b.id]?.activitySum || 0;
                if (activityB !== activityA) return activityB - activityA;
                if (a.clanRole !== b.clanRole) return b.clanRole - a.clanRole;
                return a.name.localeCompare(b.name);
            });

            const formatNum = (num) => {
                if (num === 0) return '0';
                if (num >= 1000000) return (num/1000000).toFixed(1) + 'M';
                if (num >= 1000) return (num/1000).toFixed(1) + 'K';
                return num.toString();
            };

            members.forEach(member => {
                const isGM = member.clanRole == 255;
                const isGen = member.clanRole == 4;
                const isCmd = member.commander;
                const isMod = member.isChatModerator;
                const roleDisplay = isGM ? 'üëëGM' : isGen ? '‚≠êGen' : '';
                const cmdDisplay = isCmd ? '‚öîÔ∏è' : '';
                const modDisplay = isMod ? 'üõ°Ô∏è' : '';
                const memberActivity = activityByUserId[member.id] || {};
                const activitySum = memberActivity.activitySum || 0;
                const isHighlighted = highlightUserId && member.id === highlightUserId;

                clanContent += `
                    <div style="display: grid; grid-template-columns: 150px 100px 50px 80px 90px; gap: 6px; padding: 5px 6px; margin-bottom: 1px; border-bottom: 1px solid #333; font-size: 12px; align-items: center;">
                        <span style="font-weight: bold; color: ${isHighlighted ? '#4ae29a' : '#ffd700'}; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${member.name}">${member.name}</span>
                        <span class="copyable-user-id" data-user-id="${member.id}" style="text-align: center; color: #4ae29a; cursor: pointer; text-decoration: underline; font-family: monospace; font-size: 11px;" title="Click to copy: ${member.id}">${member.id}</span>
                        <span style="text-align: center; color: #999;">${member.level}</span>
                        <span style="text-align: center; color: #999; font-size: 11px;">${roleDisplay}${cmdDisplay}${modDisplay}</span>
                        <span style="text-align: right; color: ${activitySum > 0 ? '#ffd700' : '#666'}; font-family: monospace; font-weight: bold;">${formatNum(activitySum)}</span>
                    </div>
                `;
            });

            clanContent += `</div>`;
            clanPopup.innerHTML = clanContent;
            document.body.appendChild(clanPopup);

            // Click-to-copy for user IDs
            clanPopup.querySelectorAll('.copyable-user-id').forEach(element => {
                element.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const userIdToCopy = this.getAttribute('data-user-id');
                    navigator.clipboard.writeText(userIdToCopy).then(() => {
                        const originalText = this.textContent;
                        this.textContent = '‚úì';
                        setTimeout(() => { this.textContent = originalText; }, 800);
                    }).catch(err => console.error('Failed to copy:', err));
                });
            });

            document.getElementById('close-clan-popup').addEventListener('click', () => clanPopup.remove());

        } catch (error) {
            console.error('Error fetching clan info:', error);
        }
    };

    window.goGuildOverview = function () {
        try {
            let player = getPlayer();
            let clanHubMediator = selfGame['game.mediator.gui.popup.clan.hub.ClanHubPopupMediator'];
            new clanHubMediator(player).open();
        } catch (e) {
            console.error('Failed to open Guild Overview:', e);
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('Failed to open Guild Overview', true);
            }
        }
    };

    window.goConsumables = function (filter = 'consumable') {
        try {
            let player = getPlayer();
            let invMedClass = selfGame['game.mediator.gui.popup.inventory.PlayerInventoryPopupMediator'];
            let mediator = new invMedClass(player);
            let proto = invMedClass.prototype;

            // Dynamically find the filter property from get_currentFilter getter
            let propsObj = proto.__properties__;
            let getterMethodName = Object.entries(propsObj).find(e => e[1] === 'get_currentFilter')?.[0];
            let filterProp = null;
            if (getterMethodName) {
                let getterFunc = proto[getterMethodName].toString();
                let filterPropMatch = getterFunc.match(/return\s+this\.(\w+)/);
                if (filterPropMatch) {
                    filterProp = filterPropMatch[1];
                    mediator[filterProp] = filter;
                }
            }

            mediator.open();

            // Find and call the refresh method to update content
            if (filterProp) {
                let refreshMethod = null;
                for (let key of Object.getOwnPropertyNames(proto)) {
                    if (typeof proto[key] === 'function') {
                        let str = proto[key].toString();
                        let pattern = new RegExp('this\\.' + filterProp + '=[^,]+,this\\.(\\w+)\\(\\)');
                        let match = str.match(pattern);
                        if (match) {
                            refreshMethod = match[1];
                            break;
                        }
                    }
                }
                if (refreshMethod) {
                    setTimeout(() => {
                        try { mediator[refreshMethod](); } catch(e) {}
                    }, 150);
                }
            }

            debugLog('Opened Inventory - ' + filter + ' tab');
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('Opened Inventory - ' + filter + ' tab', true);
            }
        } catch (e) {
            console.error('Failed to open Inventory:', e);
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('Failed to open Inventory', true);
            }
        }
    };

    window.goHeroes = function () {
        try {
            let player = getPlayer();
            let heroesMediator = selfGame['game.mediator.gui.popup.hero.HeroesHubPopupMediator'];
            new heroesMediator(player).open();
            debugLog('Opened Heroes Hub');
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('Opened Heroes Hub', true);
            }
        } catch (e) {
            console.error('Failed to open Heroes:', e);
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('Failed to open Heroes', true);
            }
        }
    };



    window.goHome = async function () {
        try {
            debugLog('Returning to city screen...');

            for (let i = 0; i < 20; i++) {
                document.dispatchEvent(new KeyboardEvent('keydown', {
                    key: 'Escape',
                    keyCode: 27,
                    bubbles: true
                }));
                await new Promise(resolve => setTimeout(resolve, 50));
            }

            debugLog('Closed all popups - should be on city screen');
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('Returned to city screen', true);
            }

        } catch (e) {
            console.error('Failed to return to city screen:', e);
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('Failed to return to city screen', true);
            }
        }
    };

    window.goTitans = function () {
        try {

            let player = getPlayer();
            let titanListMediator = selfGame['game.mediator.gui.popup.titan.TitanListPopupMediator'];
            new titanListMediator(player).open();
            debugLog('Opened Titans Hub');
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('Opened Titans Hub', true);
            }
        } catch (e) {
            console.error('Failed to open Titans:', e);
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('Failed to open Titans', true);
            }
        }
    };

    window.goTitanSpiritArtifact = function () {
        try {

            let player = getPlayer();
            let titanSpiritArtifactMediator = selfGame['game.mediator.gui.popup.titanspiritartifact.TitanSpiritArtifactPopupMediator'];
            new titanSpiritArtifactMediator(player).open();
            debugLog('Opened Titan Spirit Artifact');
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('Opened Titan Spirit Artifact', true);
            }
        } catch (e) {
            console.error('Failed to open Titan Spirit Artifact:', e);
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('Failed to open Titan Spirit Artifact', true);
            }
        }
    };
    // Cache for dynamic method names
    let _petSoulShopMethod = null;
    let _titanSoulShopMethod = null;

    function findMethod(med, searchString) {
        return Object.keys(Object.getPrototypeOf(med)).find(k => {
            if (typeof med[k] !== 'function') return false;
            try { return med[k].toString().includes(searchString); }
            catch(e) { return false; }
        });
    }

    // Pet Soul Shop Opener - CACHED DYNAMIC VERSION
    window.openPetSoulShop = function() {
        try {
            let player = getPlayer();
            let mediatorClass = selfGame['game.mediator.gui.popup.pet.expConsumableNotEnough.PetExpConsumableNotEnoughPopupMediator'];
            let med = new mediatorClass(player);
            med.open();

            setTimeout(() => {
                // Try cached method first
                if (_petSoulShopMethod && typeof med[_petSoulShopMethod] === 'function') {
                    try {
                        med[_petSoulShopMethod]();
                        med.close();
                        return;
                    } catch(e) {
                        debugLog('Cached pet method failed, searching...');
                    }
                }

                // Search for method
                _petSoulShopMethod = findMethod(med, 'pet_soul_shop');
                if (_petSoulShopMethod) {
                    debugLog('Found pet soul shop method:', _petSoulShopMethod);
                    med[_petSoulShopMethod]();
                } else {
                    console.error('Pet soul shop method not found');
                }
                med.close();
            }, 50);
        } catch(e) {
            console.error('Pet Soul Shop error:', e.message);
        }
    };

    // Titan Soul Shop Opener - CACHED DYNAMIC VERSION
    window.openTitanSoulShop = function() {
        try {
            let player = getPlayer();
            let mediatorClass = selfGame['game.view.gui.ClanIslandPopupMediator'];
            let med = new mediatorClass(player);
            med.open();

            setTimeout(() => {
                // Try cached method first
                if (_titanSoulShopMethod && typeof med[_titanSoulShopMethod] === 'function') {
                    try {
                        med[_titanSoulShopMethod]();
                        med.close();
                        return;
                    } catch(e) {
                        debugLog('Cached titan method failed, searching...');
                    }
                }

                // Search for method
                _titanSoulShopMethod = findMethod(med, 'titan_soul_shop');
                if (_titanSoulShopMethod) {
                    debugLog('Found titan soul shop method:', _titanSoulShopMethod);
                    med[_titanSoulShopMethod]();
                } else {
                    console.error('Titan soul shop method not found');
                }
                med.close();
            }, 50);
        } catch(e) {
            console.error('Titan Soul Shop error:', e.message);
        }
    };
    window.openDungeon = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.mechanics.dungeon.mediator.DungeonScreenMediator'];
            new Med(player).open();
        } catch(e) { console.error('Dungeon error:', e.message); }
    };



    // Cosmic-Gold Season opener
    window.openBattlePass = function() {
        try {
            let player = getPlayer();
            let BattlePassMed = selfGame['game.mediator.gui.popup.battlepass.BattlePassFullscreenPopupMediator'];
            new BattlePassMed(player).open();
        } catch(e) {
            console.error('Battle Pass error:', e.message);
        }
    };
    // Season Hub
    window.openSeasonHub = function() {
        try {
            let player = getPlayer();
            let HubMed = selfGame['game.mechanics.hub.mediator.HubPopupMediator'];
            new HubMed(player, "test").open();
        } catch(e) {
            console.error('Season Hub error:', e.message);
        }
    };
    // ===== ASGARD =====
    window.openAsgardBuffShop = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.mechanics.clan_raid.shop.ClanRaidBuffShopPopupMediator'];
            new Med(player).open();
        } catch(e) { console.error('Asgard Buff Shop error:', e.message); }
    };

    window.openAsgardHallOfFame = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.mechanics.clan_raid.rating.hall_of_fame.ClanRaidHallOfFamePopupMediator'];
            new Med(player).open();
        } catch(e) { console.error('Asgard Hall of Fame error:', e.message); }
    };

    window.openAsgardStats = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.mechanics.clan_raid.statistic.ClanRaidStatisticPopupMediator'];
            new Med(player).open();
        } catch(e) { console.error('Asgard Stats error:', e.message); }
    };

    // ===== CLASH OF WORLDS (CoW) =====
    window.openCoWShop = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.mechanics.cross_clan_war.popup.shop.CrossClanWarShopMediator'];
            new Med(player).open();
        } catch(e) { console.error('CoW Shop error:', e.message); }
    };

    window.openCoWLogs = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.mechanics.cross_clan_war.popup.log.wars.CrossClanWarLogPopupMediator'];
            new Med(player).open();
        } catch(e) { console.error('CoW Logs error:', e.message); }
    };

    window.openCoWDefenders = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.mechanics.cross_clan_war.popup.defenders.CrossClanWarDefendersPopupMediator'];
            new Med(player).open();
        } catch(e) { console.error('CoW Defenders error:', e.message); }
    };

    window.openCoWAttackSettings = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.mechanics.cross_clan_war.popup.settings.attack.CrossClanAttackSettingsPopupMediator'];
            new Med(player).open();
        } catch(e) { console.error('CoW Attack Settings error:', e.message); }
    };

    window.openCoWDefenseSettings = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.mechanics.cross_clan_war.popup.settings.defense.CrossClanDefenseSettingsPopupMediator'];
            new Med(player).open();
        } catch(e) { console.error('CoW Defense Settings error:', e.message); }
    };

    window.openCoWTeamList = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.mechanics.cross_clan_war.popup.members.plan.CrossClanWarPlanMembersPopupMediator'];
            new Med(player).open();
        } catch(e) { console.error('CoW Team List error:', e.message); }
    };

    // ===== GUILD WAR =====
    window.openGWLeaderboard = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.mechanics.clan_war.mediator.ClanWarLeaguesPopupMediator'];
            new Med(player).open();
        } catch(e) { console.error('GW Leaderboard error:', e.message); }
    };

    // ===== TITANS / ToE =====
    window.openTitanSim = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.view.popup.demoBattle.DemoBattleCreatePopupMediator'];
            new Med(player).open();
        } catch(e) { console.error('Titan Sim error:', e.message); }
    };

    window.openToEUnfinished = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.mechanics.titan_arena.mediator.TitanArenaPopupMediator'];
            new Med(player).open();
        } catch(e) { console.error('ToE Unfinished error:', e.message); }
    };

    window.openAltarOfElements = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.mechanics.titan_arena.mediator.chest.TitanArtifactChestPopupMediator'];
            new Med(player).open();
        } catch(e) { console.error('Altar of Elements error:', e.message); }
    };

    // ===== PLAYER / PROFILE =====
    window.openAvatars = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.mediator.gui.popup.player.AvatarSelectPopupMediator'];
            new Med(player).open();
        } catch(e) { console.error('Avatars error:', e.message); }
    };

    window.openFrames = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.mediator.gui.popup.player.PlayerAvatarFrameChangePopupMediator'];
            new Med(player).open();
        } catch(e) { console.error('Frames error:', e.message); }
    };

    // ===== MISC =====
    window.openGameSettings = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.mechanics.settings.popup.SettingsPopupMediator'];
            new Med(player).open();
        } catch(e) { console.error('Game Settings error:', e.message); }
    };

    window.openSummoningCircle = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.view.popup.summoningcircle.SummoningCirclePopUpMediator'];
            new Med(player).open();
        } catch(e) { console.error('Summoning Circle error:', e.message); }
    };

    window.openGlyphGifts = function() {
        try {
            let player = getPlayer();
            let Med = selfGame['game.mediator.gui.popup.hero.HeroRuneListPopupMediator'];
            new Med(player).open();
        } catch(e) { console.error('Glyph/Gifts error:', e.message); }
    };

    // ============================================================================
    // HWH ACTION BUTTON FUNCTIONS
    // Click the Outland, Tower, Expeditions, Minions buttons from HWH
    // ============================================================================


    // Helper to find and click action popup button by name (I18N key match)
    window.clickActionButtonByName = function(targetName) {
        try {
            if (!HWHData || !HWHData.actionsPopupButtons) {
                console.error('HWHData.actionsPopupButtons not available');
                return false;
            }
            // Find button where msg matches the target (handles I18N getters)
            const btn = HWHData.actionsPopupButtons.find(b => {
                try {
                    return b.msg && b.msg.toLowerCase().includes(targetName.toLowerCase());
                } catch(e) { return false; }
            });
            if (btn && typeof btn.result === 'function') {
                btn.result();
                return true;
            }
            console.error('Action button "' + targetName + '" not found');
            return false;
        } catch(e) {
            console.error('clickActionButtonByName error:', e.message);
            return false;
        }
    };

    // Legacy index-based function (still works, but name-based is safer)
    window.clickActionButton = function(index) {
        try {
            if (!HWHData || !HWHData.actionsPopupButtons) {
                console.error('HWHData.actionsPopupButtons not available');
                return false;
            }
            const btn = HWHData.actionsPopupButtons[index];
            if (btn && typeof btn.result === 'function') {
                btn.result();
                return true;
            }
            console.error('Button at index', index, 'not found');
            return false;
        } catch(e) {
            console.error('clickActionButton error:', e.message);
            return false;
        }
    };

    // Name-based wrappers (resilient to menu changes)
    window.clickOutland = function() {
        return clickActionButtonByName('Outland') || clickActionButtonByName('OUTLAND');
    };

    window.clickTower = function() {
        return clickActionButtonByName('Tower') || clickActionButtonByName('TOWER');
    };

    window.clickExpeditions = function() {
        return clickActionButtonByName('Expedition') || clickActionButtonByName('EXPEDITIONS');
    };

    window.clickMinions = function() {
        return clickActionButtonByName('Minion') || clickActionButtonByName('MINIONS');
    };

    window.clickEsterEggs = function() {
        return clickActionButtonByName('Easter') || clickActionButtonByName('ESTER');
    };

    window.clickStorm = function() {
        return clickActionButtonByName('Storm') || clickActionButtonByName('STORM');
    };

    window.clickRewards = function() {
        return clickActionButtonByName('Reward') || clickActionButtonByName('REWARDS');
    };

    window.clickMail = function() {
        return clickActionButtonByName('Mail') || clickActionButtonByName('MAIL');
    };

    window.clickSeer = function() {
        return clickActionButtonByName('Seer') || clickActionButtonByName('SEER');
    };

    window.clickTidyInventory = function() {
        return clickActionButtonByName('Tidy') || clickActionButtonByName('TIDY');
    };



    // ================================================================
    // OTHERS MENU BUTTON WRAPPERS (name-based)
    // ================================================================

    window.clickOthersButtonByName = function(targetName) {
        try {
            if (!HWHData || !HWHData.othersPopupButtons) {
                console.error('HWHData.othersPopupButtons not available');
                return false;
            }
            const btn = HWHData.othersPopupButtons.find(b => {
                try {
                    return b.msg && b.msg.toLowerCase().includes(targetName.toLowerCase());
                } catch(e) { return false; }
            });
            if (btn && typeof btn.result === 'function') {
                btn.result();
                return true;
            }
            console.error('Others button "' + targetName + '" not found');
            return false;
        } catch(e) {
            console.error('clickOthersButtonByName error:', e.message);
            return false;
        }
    };

    // Others - name-based wrappers
    window.clickGetEnergy = function() {
        return clickOthersButtonByName('Energy') || clickOthersButtonByName('GET_ENERGY');
    };
    window.clickItemExchange = function() {
        return clickOthersButtonByName('Exchange') || clickOthersButtonByName('ITEM_EXCHANGE');
    };
    window.clickBuySouls = function() {
        return clickOthersButtonByName('Souls') || clickOthersButtonByName('BUY_SOULS');
    };
    window.clickBuyForGold = function() {
        return clickOthersButtonByName('Gold') || clickOthersButtonByName('BUY_FOR_GOLD');
    };
    window.clickBuyOutland = function() {
        return clickOthersButtonByName('Outland') || clickOthersButtonByName('BUY_OUTLAND');
    };
    window.clickClanStat = function() {
        return clickOthersButtonByName('Clan Stat') || clickOthersButtonByName('CLAN_STAT');
    };
    window.clickEpicBrawl = function() {
        return clickOthersButtonByName('Brawl') || clickOthersButtonByName('EPIC_BRAWL');
    };
    window.clickArtifactsUpgrade = function() {
        return clickOthersButtonByName('Artifact') || clickOthersButtonByName('ARTIFACTS_UPGRADE');
    };
    window.clickSkinsUpgrade = function() {
        return clickOthersButtonByName('Skin') || clickOthersButtonByName('SKINS_UPGRADE');
    };
    window.clickSeasonReward = function() {
        return clickOthersButtonByName('Season') || clickOthersButtonByName('SEASON_REWARD');
    };
    window.clickSellHeroSouls = function() {
        return clickOthersButtonByName('Sell') || clickOthersButtonByName('SELL_HERO_SOULS');
    };
    window.clickChangeMap = function() {
        return clickOthersButtonByName('Map') || clickOthersButtonByName('CHANGE_MAP');
    };
    window.clickHeroPower = function() {
        return clickOthersButtonByName('Power') || clickOthersButtonByName('HERO_POWER');
    };

    // ================================================================
    // GIFT OF ELEMENTS BUYER
    // ================================================================
    const GOE_POWER_PER_LEVEL = [22,22,22,22,22,66,66,66,66,66,110,110,110,110,110,154,154,154,154,154,198,198,198,198,198,242,242,242,242,242];

    window.showGoEBuyer = function() {
        const existing = document.getElementById('goe-popup');
        if (existing) existing.remove();

        const popup = document.createElement('div');
        popup.id = 'goe-popup';
        popup.innerHTML = `
            <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 999999; display: flex; align-items: center; justify-content: center;">
                <div style="background: linear-gradient(180deg, #1a0f08 0%, #2a1810 100%); border: 3px solid #8b6914; border-radius: 10px; padding: 15px; min-width: 360px; color: #ffd700;">
                    <h3 style="margin: 0 0 12px 0; text-align: center; border-bottom: 1px solid #8b6914; padding-bottom: 8px; font-size: 16px;">
                        ‚ö° Gift of Elements
                    </h3>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                        <button id="goe-spend" style="padding: 10px; background: #2a5a2a; border: 2px solid #1a4a1a; border-radius: 5px; color: white; cursor: pointer; font-weight: bold; font-size: 13px;"
                            title="Spend a specified number of Sparks of Power to upgrade heroes' Gift of Elements levels evenly">
                            ‚ö° Spend Sparks
                        </button>
                        <button id="goe-power" style="padding: 10px; background: #2a5a2a; border: 2px solid #1a4a1a; border-radius: 5px; color: white; cursor: pointer; font-weight: bold; font-size: 13px;"
                            title="Upgrade Gift of Elements until you gain a target amount of hero power">
                            üéØ Get Power
                        </button>
                        <button id="goe-reset" style="padding: 10px; background: #4a3010; border: 2px solid #8b6914; border-radius: 5px; color: #ffd700; cursor: pointer; font-weight: bold; font-size: 13px;"
                            title="Reset Gift of Elements for heroes at levels 1-29 (preserves level 30 heroes)">
                            üîÑ Reset 1-29
                        </button>
                        <button id="goe-reset30" style="padding: 10px; background: #c41e3a; border: 2px solid #8b0000; border-radius: 5px; color: white; cursor: pointer; font-weight: bold; font-size: 13px;"
                            title="Reset ALL Gift of Elements including level 30 heroes (starts with weakest)">
                            üíÄ Reset Lv30
                        </button>
                    </div>

                    <div style="text-align: center;">
                        <button id="goe-close" style="padding: 8px 24px; background: #4a3010; border: 1px solid #8b6914; border-radius: 4px; color: #ffd700; cursor: pointer; font-size: 13px;">
                            Close
                        </button>
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(popup);

        popup.querySelector('#goe-close').onclick = () => popup.remove();
        popup.querySelector('#goe-spend').onclick = async () => { popup.remove(); await goeSpendSparks(); };
        popup.querySelector('#goe-power').onclick = async () => { popup.remove(); await goeGetPower(); };
        popup.querySelector('#goe-reset').onclick = async () => { popup.remove(); await goeReset(); };
        popup.querySelector('#goe-reset30').onclick = async () => { popup.remove(); await goeReset30(); };

        popup.firstElementChild.onclick = (e) => { if (e.target === popup.firstElementChild) popup.remove(); };
    };

    function goeResultPopup(title, message) {
        const existing = document.getElementById('goe-result-popup');
        if (existing) existing.remove();

        const popup = document.createElement('div');
        popup.id = 'goe-result-popup';
        popup.innerHTML = `
            <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 999999; display: flex; align-items: center; justify-content: center;">
                <div style="background: linear-gradient(180deg, #1a0f08 0%, #2a1810 100%); border: 3px solid #8b6914; border-radius: 10px; padding: 15px; min-width: 300px; max-width: 380px; color: #ffd700;">
                    <h3 style="margin: 0 0 12px 0; text-align: center; border-bottom: 1px solid #8b6914; padding-bottom: 8px; font-size: 16px;">${title}</h3>
                    <div style="margin-bottom: 15px; color: #ccc; font-size: 14px; text-align: center; line-height: 1.5;">${message}</div>
                    <div style="text-align: center;">
                        <button id="goe-result-ok" style="padding: 10px 30px; background: #8b6914; border: 2px solid #ffd700; border-radius: 5px; color: #fff; cursor: pointer; font-weight: bold; font-size: 14px;">OK</button>
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(popup);
        popup.querySelector('#goe-result-ok').onclick = () => popup.remove();
        popup.firstElementChild.onclick = (e) => { if (e.target === popup.firstElementChild) popup.remove(); };
    }

    function goeInputPopup(title, message, defaultValue, buttonText, buttonColor = 'green', calcFn = null) {
        return new Promise((resolve) => {
            const existing = document.getElementById('goe-input-popup');
            if (existing) existing.remove();

            const colors = {
                green: { bg: '#2a5a2a', border: '#1a4a1a', text: 'white' },
                blue: { bg: '#4a3010', border: '#8b6914', text: '#ffd700' },
                red: { bg: '#c41e3a', border: '#8b0000', text: 'white' }
            };
            const c = colors[buttonColor] || colors.green;

            const popup = document.createElement('div');
            popup.id = 'goe-input-popup';
            popup.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 999999; display: flex; align-items: center; justify-content: center;">
                    <div style="background: linear-gradient(180deg, #1a0f08 0%, #2a1810 100%); border: 3px solid #8b6914; border-radius: 10px; padding: 15px; min-width: 340px; color: #ffd700;">
                        <h3 style="margin: 0 0 12px 0; text-align: center; border-bottom: 1px solid #8b6914; padding-bottom: 8px; font-size: 16px;">${title}</h3>
                        <div style="margin-bottom: 12px; color: #ccc; font-size: 14px; text-align: center; line-height: 1.4;">${message}</div>
                        <input type="number" id="goe-input-value" value="${defaultValue}" style="width: 100%; padding: 10px; background: #1a0f08; border: 1px solid #8b6914; border-radius: 4px; color: #ffd700; font-size: 14px; text-align: center; box-sizing: border-box; margin-bottom: 10px;">
                        <div id="goe-cost-display" style="margin-bottom: 12px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px; font-size: 13px; text-align: center; color: #ccc; display: none;"></div>
                        <div style="display: flex; gap: 8px;">
                            <button id="goe-input-cancel" style="flex: 1; padding: 10px; background: #4a3010; border: 1px solid #8b6914; border-radius: 5px; color: #ffd700; cursor: pointer; font-size: 13px;">Cancel</button>
                            <button id="goe-input-ok" style="flex: 1; padding: 10px; background: ${c.bg}; color: ${c.text}; border: 2px solid ${c.border}; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 13px;">${buttonText}</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(popup);

            const input = popup.querySelector('#goe-input-value');
            const costDisplay = popup.querySelector('#goe-cost-display');
            input.focus();
            input.select();

            if (calcFn) {
                costDisplay.style.display = 'block';
                const updateCost = () => {
                    const val = +input.value || 0;
                    costDisplay.innerHTML = calcFn(val);
                };
                updateCost();
                input.addEventListener('input', updateCost);
            }

            const close = (value) => { popup.remove(); resolve(value); };

            popup.querySelector('#goe-input-cancel').onclick = () => close(null);
            popup.querySelector('#goe-input-ok').onclick = () => close(+input.value);
            input.onkeydown = (e) => { if (e.key === 'Enter') close(+input.value); if (e.key === 'Escape') close(null); };
            popup.firstElementChild.onclick = (e) => { if (e.target === popup.firstElementChild) close(null); };
        });
    }

    function goeConfirmPopup(title, message, buttons) {
        return new Promise((resolve) => {
            const existing = document.getElementById('goe-confirm-popup');
            if (existing) existing.remove();

            const colors = {
                green: { bg: '#2a5a2a', border: '#1a4a1a', text: 'white' },
                blue: { bg: '#4a3010', border: '#8b6914', text: '#ffd700' },
                red: { bg: '#c41e3a', border: '#8b0000', text: 'white' }
            };

            const buttonsHTML = buttons.map((btn, i) => {
                const c = colors[btn.color] || colors.green;
                return `<button id="goe-confirm-btn-${i}" style="flex: 1; padding: 10px; background: ${c.bg}; color: ${c.text}; border: 2px solid ${c.border}; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 13px;">${btn.text}</button>`;
            }).join('');

            const popup = document.createElement('div');
            popup.id = 'goe-confirm-popup';
            popup.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 999999; display: flex; align-items: center; justify-content: center;">
                    <div style="background: linear-gradient(180deg, #1a0f08 0%, #2a1810 100%); border: 3px solid #8b6914; border-radius: 10px; padding: 15px; min-width: 320px; color: #ffd700;">
                        <h3 style="margin: 0 0 12px 0; text-align: center; border-bottom: 1px solid #8b6914; padding-bottom: 8px; font-size: 16px;">${title}</h3>
                        <div style="margin-bottom: 15px; color: #ccc; font-size: 14px; text-align: center; line-height: 1.4;">${message}</div>
                        <div style="display: flex; gap: 8px;">${buttonsHTML}</div>
                    </div>
                </div>
            `;

            document.body.appendChild(popup);

            const close = (value) => { popup.remove(); resolve(value); };

            buttons.forEach((btn, i) => {
                popup.querySelector(`#goe-confirm-btn-${i}`).onclick = () => close(btn.value);
            });
            popup.firstElementChild.onclick = (e) => { if (e.target === popup.firstElementChild) close(null); };
        });
    }

    function goeCalcSparksCost(heroes, sparksToSpend, gold, titanGiftLib) {
        let tempSparks = sparksToSpend;
        let tempGold = 0;
        let upgrades = 0;
        let powerGain = 0;

        for (let lvl = heroes[0].titanGiftLevel; lvl < 30 && tempSparks > 0; lvl++) {
            for (const hero of heroes) {
                if (hero.titanGiftLevel > lvl) continue;
                const cost = titanGiftLib[lvl + 1]?.cost;
                if (!cost || tempSparks < cost.consumable[24]) break;
                tempSparks -= cost.consumable[24];
                tempGold += cost.gold;
                powerGain += GOE_POWER_PER_LEVEL[lvl];
                upgrades++;
            }
        }

        const goldOk = tempGold <= gold;
        return `üí∞ Gold: <span style="color:${goldOk ? '#4ae29a' : '#ff6b6b'}">${tempGold.toLocaleString()}</span> / ${gold.toLocaleString()}<br>‚ö° Power: +${powerGain.toLocaleString()} ¬∑ üìà ${upgrades} upgrades`;
    }

    function goeCalcPowerCost(heroes, targetPower, sparks, gold, titanGiftLib) {
        let tempSparks = sparks;
        let tempGold = 0;
        let currentPower = 0;
        let upgrades = 0;

        for (let lvl = heroes[0].titanGiftLevel; lvl < 30 && currentPower < targetPower; lvl++) {
            for (const hero of heroes) {
                if (hero.titanGiftLevel > lvl) continue;
                const cost = titanGiftLib[lvl + 1]?.cost;
                if (!cost || tempSparks < cost.consumable[24]) break;
                tempSparks -= cost.consumable[24];
                tempGold += cost.gold;
                currentPower += GOE_POWER_PER_LEVEL[lvl];
                upgrades++;
                if (currentPower >= targetPower) break;
            }
        }

        const goldOk = tempGold <= gold;
        return `üí∞ Gold: <span style="color:${goldOk ? '#4ae29a' : '#ff6b6b'}">${tempGold.toLocaleString()}</span> / ${gold.toLocaleString()}<br>‚ú® Sparks: ${(sparks - tempSparks).toLocaleString()} ¬∑ üìà ${upgrades} upgrades`;
    }

    async function goeSpendSparks() {
        try {
            const { setProgress } = HWHFuncs;
            const [heroGetAll, inventory, user] = await Caller.send(['heroGetAll', 'inventoryGet', 'userGetInfo']);

            let heroes = Object.values(heroGetAll).sort((a, b) => a.titanGiftLevel - b.titanGiftLevel);
            const titanGiftLib = lib.getData('titanGift');
            let sparks = inventory.consumable[24] || 0;
            const maxSparks = sparks;
            let gold = user.gold;

            if (user.level < 30) { goeResultPopup('‚ö†Ô∏è Error', 'Need team level 30'); return; }
            if (heroes[0].titanGiftLevel >= 30) { goeResultPopup('‚úÖ Complete', 'All heroes at max GoE level'); return; }

            const calcFn = (val) => goeCalcSparksCost(heroes, val, gold, titanGiftLib);

            const value = await goeInputPopup(
                '‚ö° Spend Sparks',
                `Available: <span style="color:#4ae29a">${sparks.toLocaleString()}</span> Sparks of Power`,
                sparks, 'Spend', 'green', calcFn
            );

            if (!value || value <= 0 || value > maxSparks) { if (value) goeResultPopup('‚ö†Ô∏è Error', 'Invalid amount'); return; }

            await goeProcessUpgrades(heroes, value, gold, titanGiftLib, null);
        } catch (e) {
            goeResultPopup('‚ùå Error', `Failed to load data<br><span style="color:#ff6b6b">${e.message || 'Unknown error'}</span>`);
        }
    }

    async function goeGetPower() {
        try {
            const { setProgress } = HWHFuncs;
            const [heroGetAll, inventory, user] = await Caller.send(['heroGetAll', 'inventoryGet', 'userGetInfo']);

            let heroes = Object.values(heroGetAll).sort((a, b) => a.titanGiftLevel - b.titanGiftLevel);
            const titanGiftLib = lib.getData('titanGift');
            let sparks = inventory.consumable[24] || 0;
            let gold = user.gold;

            if (user.level < 30) { goeResultPopup('‚ö†Ô∏è Error', 'Need team level 30'); return; }
            if (heroes[0].titanGiftLevel >= 30) { goeResultPopup('‚úÖ Complete', 'All heroes at max GoE level'); return; }

            // Calculate max possible power
            let tempSparks = sparks;
            let maxPower = 0;
            for (let lvl = heroes[0].titanGiftLevel; lvl < 30; lvl++) {
                for (const hero of heroes) {
                    if (hero.titanGiftLevel > lvl) continue;
                    const cost = titanGiftLib[lvl + 1]?.cost;
                    if (!cost || tempSparks < cost.consumable[24]) break;
                    tempSparks -= cost.consumable[24];
                    maxPower += GOE_POWER_PER_LEVEL[lvl];
                }
            }

            const calcFn = (val) => goeCalcPowerCost(heroes, val, sparks, gold, titanGiftLib);

            const value = await goeInputPopup(
                'üéØ Get Power',
                `Max available: <span style="color:#4ae29a">${maxPower.toLocaleString()}</span> hero power`,
                maxPower, 'Upgrade', 'green', calcFn
            );

            if (!value || value <= 0 || value > maxPower) { if (value) goeResultPopup('‚ö†Ô∏è Error', 'Invalid amount'); return; }

            await goeProcessUpgrades(heroes, sparks, gold, titanGiftLib, value);
        } catch (e) {
            goeResultPopup('‚ùå Error', `Failed to load data<br><span style="color:#ff6b6b">${e.message || 'Unknown error'}</span>`);
        }
    }

    async function goeProcessUpgrades(heroes, sparks, gold, titanGiftLib, targetPower) {
        const { setProgress } = HWHFuncs;
        const startPower = heroes.reduce((sum, h) => sum + h.power, 0);
        let calls = [], upgrades = 0, currentPower = 0;
        let currentLevel = heroes[0].titanGiftLevel;

        // Pre-calculate total gold needed
        let tempSparks = sparks, tempGold = 0, tempPower = 0;
        for (let lvl = currentLevel; lvl < 30; lvl++) {
            for (const hero of heroes) {
                if (hero.titanGiftLevel > lvl) continue;
                const cost = titanGiftLib[lvl + 1]?.cost;
                if (!cost || tempSparks < cost.consumable[24]) break;
                tempSparks -= cost.consumable[24];
                tempGold += cost.gold;
                tempPower += GOE_POWER_PER_LEVEL[lvl];
                if (targetPower && tempPower >= targetPower) break;
            }
            if (targetPower && tempPower >= targetPower) break;
        }

        if (tempGold > gold) {
            goeResultPopup('‚ö†Ô∏è Not Enough Gold', `Need <span style="color:#ff6b6b">${tempGold.toLocaleString()}</span> gold<br>Have <span style="color:#4ae29a">${gold.toLocaleString()}</span>`);
            return;
        }

        setProgress('‚ö° Upgrading Gift of Elements...', false);

        try {
            let running = true;
            while (running) {
                for (const hero of heroes) {
                    if (currentLevel >= 30) { running = false; break; }
                    if (hero.titanGiftLevel > currentLevel) break;

                    const cost = titanGiftLib[hero.titanGiftLevel + 1]?.cost;
                    if (!cost || sparks < cost.consumable[24] || gold < cost.gold) { running = false; break; }

                    calls.push({ name: 'heroTitanGiftLevelUp', args: { heroId: hero.id } });
                    sparks -= cost.consumable[24];
                    gold -= cost.gold;
                    currentPower += GOE_POWER_PER_LEVEL[hero.titanGiftLevel];

                    if (targetPower && currentPower >= targetPower) { running = false; break; }
                }

                if (calls.length > 0) {
                    await Caller.send(calls);
                    upgrades += calls.length;
                    const heroData = await Caller.send('heroGetAll');
                    heroes = Object.values(heroData).sort((a, b) => a.titanGiftLevel - b.titanGiftLevel);
                    calls = [];
                    currentLevel++;
                    setProgress(`‚ö° GoE level ${currentLevel} ¬∑ ${upgrades} upgrades`, false);
                }
            }

            const endPower = heroes.reduce((sum, h) => sum + h.power, 0);
            setProgress('', true);
            goeResultPopup('‚úÖ Complete', `Upgraded <span style="color:#4ae29a">${upgrades}</span> times<br>Power gained: <span style="color:#4ae29a">+${(endPower - startPower).toLocaleString()}</span>`);
        } catch (e) {
            setProgress('', true);
            goeResultPopup('‚ùå Error', `Failed after ${upgrades} upgrades<br><span style="color:#ff6b6b">${e.message || 'Unknown error'}</span>`);
        }
    }

    async function goeReset() {
        try {
            const [heroGetAll, user] = await Caller.send(['heroGetAll', 'userGetInfo']);
            const heroes = Object.values(heroGetAll).sort((a, b) => a.titanGiftLevel - b.titanGiftLevel);

            if (user.level < 30) { goeResultPopup('‚ö†Ô∏è Error', 'Need team level 30'); return; }

            let minLevel = 0;
            for (const h of heroes) { if (h.titanGiftLevel > 0 && h.titanGiftLevel < 30) { minLevel = h.titanGiftLevel; break; } }
            if (minLevel === 0) { goeResultPopup('‚ö†Ô∏è Error', 'Nothing to reset (all at 0 or 30)'); return; }

            const value = await goeInputPopup(
                'üîÑ Reset GoE 1-29',
                'Reset up to level:<br><span style="color:#999">Range: 1-29 (preserves level 30)</span>',
                minLevel, 'Reset', 'blue'
            );

            if (!value || value < 1 || value > 29) { if (value) goeResultPopup('‚ö†Ô∏è Error', 'Invalid level (1-29)'); return; }

            const calls = heroes
            .filter(h => h.titanGiftLevel > 0 && h.titanGiftLevel <= value && h.titanGiftLevel < 30)
            .map(h => ({ name: 'heroTitanGiftDrop', args: { heroId: h.id } }));

            if (calls.length === 0) { goeResultPopup('‚ö†Ô∏è Error', 'No heroes in that range'); return; }

            await Caller.send(calls);
            goeResultPopup('‚úÖ Reset Complete', `Reset <span style="color:#4ae29a">${calls.length}</span> heroes`);
        } catch (e) {
            goeResultPopup('‚ùå Error', `Reset failed<br><span style="color:#ff6b6b">${e.message || 'Unknown error'}</span>`);
        }
    }

    async function goeReset30() {
        try {
            const [heroGetAll, user] = await Caller.send(['heroGetAll', 'userGetInfo']);

            if (user.level < 30) { goeResultPopup('‚ö†Ô∏è Error', 'Need team level 30'); return; }

            const heroes1to29 = Object.values(heroGetAll).filter(h => h.titanGiftLevel > 0 && h.titanGiftLevel < 30);
            const heroes30 = Object.values(heroGetAll).filter(h => h.titanGiftLevel === 30).sort((a, b) => a.power - b.power);

            if (heroes30.length === 0 && heroes1to29.length === 0) { goeResultPopup('‚ö†Ô∏è Error', 'Nothing to reset'); return; }

            let count30 = heroes30.length;
            if (heroes30.length === 0) {
                const proceed = await goeConfirmPopup(
                    'üîÑ No Level 30',
                    'No heroes at level 30.<br>Reset lower levels instead?',
                    [{ text: 'Cancel', value: false, color: 'red' }, { text: 'Reset <30', value: true, color: 'blue' }]
                );
                if (!proceed) return;
                count30 = 0;
            } else {
                count30 = await goeInputPopup(
                    'üíÄ Reset Level 30',
                    `<span style="color:#4ae29a">${heroes30.length}</span> heroes at lv30<br><span style="color:#ff6b6b">Weakest first</span> ¬∑ Lower levels auto-reset`,
                    heroes30.length, 'Reset', 'red'
                );
                if (!count30 || count30 < 0 || count30 > heroes30.length) { if (count30) goeResultPopup('‚ö†Ô∏è Error', 'Invalid count'); return; }
            }

            const calls = [
                ...heroes1to29.map(h => ({ name: 'heroTitanGiftDrop', args: { heroId: h.id } })),
                ...heroes30.slice(0, count30).map(h => ({ name: 'heroTitanGiftDrop', args: { heroId: h.id } }))
            ];

            if (calls.length === 0) { goeResultPopup('‚ö†Ô∏è Error', 'Nothing to reset'); return; }

            await Caller.send(calls);
            goeResultPopup('‚úÖ Reset Complete', `Reset <span style="color:#4ae29a">${calls.length}</span> heroes<br>(${count30} were lv30)`);
        } catch (e) {
            goeResultPopup('‚ùå Error', `Reset failed<br><span style="color:#ff6b6b">${e.message || 'Unknown error'}</span>`);
        }
    }

    // Power Tournament with time range buckets - UPDATED VERSION with daily caching
    window.goPowerTournament = async function() {
        try {
            debugLog('Opening Power Tournament leaderboard...');

            const SendFunction = getSend();
            const response = await SendFunction('{"calls":[{"name":"powerTournament_getState","args":{},"context":{"actionTs":' + Date.now() + '},"ident":"body"},{"name":"powerTournament_getGroupInfo","args":{},"context":{"actionTs":' + Date.now() + '},"ident":"powerTournament_getGroupInfo"}]}');

            if (!response.results || !response.results[1] || !response.results[1].result.response) {
                debugLog('No Power Tournament data available');
                if (HWHFuncs && HWHFuncs.setProgress) {
                    HWHFuncs.setProgress('No Power Tournament data available', true);
                }
                return;
            }

            const groupData = response.results[1].result.response;
            const now = Date.now();
            const tournamentState = response.results[0]?.result?.response;
            const wasEnded = window._tournamentEnded;
            window._tournamentEnded = tournamentState?.state === 2;

            // Load end time if tournament is ended
            if (window._tournamentEnded && !window._tournamentEndTime) {
                window._tournamentEndTime = parseInt(localStorage.getItem('hwh_tournament_end_time')) || null;
            }

            // Load historical data
            let historicalData = [];
            try {
                const saved = localStorage.getItem('hwh_power_tournament_history');
                if (saved && saved !== 'undefined' && saved !== 'null') {
                    const parsed = JSON.parse(saved);
                    if (Array.isArray(parsed)) {
                        historicalData = parsed;
                        debugLog(`Loaded ${historicalData.length} historical data points`);
                    } else {
                        debugLog('Historical data was not an array, resetting');
                        historicalData = [];
                    }
                } else {
                    debugLog('No valid historical data found, starting fresh');
                }
            } catch (e) {
                console.warn('Error loading historical data:', e);
                historicalData = [];
            }


            // Tournament just ended - record end time (defer until after historicalData is loaded)
            const justEnded = window._tournamentEnded && !wasEnded;

            // Load clan data cache (with daily expiry)
            let clanDataCache = {};
            try {
                const savedCache = localStorage.getItem('hwh_power_tournament_clan_cache');
                if (savedCache && savedCache !== 'undefined' && savedCache !== 'null') {
                    const parsed = JSON.parse(savedCache);
                    // Check if cache is from today
                    const cacheDate = new Date(parsed.timestamp).toDateString();
                    const todayDate = new Date().toDateString();
                    if (cacheDate === todayDate) {
                        clanDataCache = parsed.clans || {};
                        debugLog(`Loaded ${Object.keys(clanDataCache).length} clans from today's cache`);
                    } else {
                        debugLog('Clan cache expired, will refresh');
                    }
                }
            } catch (e) {
                console.warn('Error loading clan cache:', e);
            }

            // Process current rankings
            const userRankings = [];
            if (groupData.users && groupData.points) {
                Object.keys(groupData.users).forEach(userId => {
                    const user = groupData.users[userId];
                    const points = groupData.points[userId] || 0;

                    // Calculate last login time ago
                    const lastLoginTimestamp = parseInt(user.lastLoginTime) * 1000; // Convert to ms
                    const timeAgo = now - lastLoginTimestamp;
                    const hoursAgo = timeAgo / (1000 * 60 * 60);
                    const daysAgo = hoursAgo / 24;

                    let lastLoginDisplay;
                    if (hoursAgo < 1) {
                        lastLoginDisplay = Math.floor(timeAgo / (1000 * 60)) + 'm';
                    } else if (hoursAgo < 24) {
                        lastLoginDisplay = Math.floor(hoursAgo) + 'h';
                    } else {
                        lastLoginDisplay = Math.floor(daysAgo) + 'd';
                    }

                    userRankings.push({
                        userId,
                        name: user.name || 'Player',
                        points,
                        serverId: user.serverId || '',
                        clanTitle: user.clanTitle || '',
                        clanId: user.clanId || '',
                        lastLoginDisplay,
                        lastLoginTimestamp,
                        memberCount: '?' // Will be loaded from cache or fetched
                    });
                });
            }

            // Sort by points and add ranks
            userRankings.sort((a, b) => b.points - a.points);
            userRankings.forEach((user, index) => {
                user.rank = index + 1;
            });

            // Load member counts from cache
            userRankings.forEach(user => {
                if (user.clanId && clanDataCache[user.clanId]) {
                    user.memberCount = clanDataCache[user.clanId].membersCount;
                    user.clanData = clanDataCache[user.clanId]; // Store full clan data
                } else {
                    user.memberCount = '?';
                }
            });

            // Only save new data if tournament is active or ended within 1 day
            const ONE_DAY_MS = 24 * 60 * 60 * 1000;
            const tournamentEndTime = window._tournamentEndTime || parseInt(localStorage.getItem('hwh_tournament_end_time')) || 0;
            const skipNewData = window._tournamentEnded && tournamentEndTime && (now - tournamentEndTime > ONE_DAY_MS);

            if (!skipNewData) {
                const currentSnapshot = {
                    timestamp: now,
                    users: {}
                };
                userRankings.forEach(user => {
                    currentSnapshot.users[user.userId] = {
                        points: user.points,
                        rank: user.rank,
                        name: user.name
                    };
                });

                // ====== NEW TOURNAMENT DETECTION ======
                const lastEntry = historicalData[historicalData.length - 1];
                if (lastEntry) {
                    const currentPlayerIds = new Set(Object.keys(currentSnapshot.users));
                    const lastPlayerIds = new Set(Object.keys(lastEntry.users));
                    const overlap = [...currentPlayerIds].filter(id => lastPlayerIds.has(id)).length;
                    const minPlayers = Math.min(currentPlayerIds.size, lastPlayerIds.size);

                    if (minPlayers > 0 && overlap < minPlayers * 0.2) {
                        console.log(`üèÜ New tournament detected! Only ${overlap}/${minPlayers} players match - clearing old data`);
                        historicalData = [];

                        // Insert synthetic zero-point at tournament start
                        // Tournament start = 7 days before end, or use current time - 1 hour as fallback
                        const tournamentStartTime = tournamentState?.startTime
                        ? tournamentState.startTime * 1000  // API might return seconds
                        : now - (7 * 24 * 60 * 60 * 1000);  // Assume 7-day tournament

                        const zeroSnapshot = {
                            timestamp: tournamentStartTime,
                            users: {}
                        };
                        Object.keys(currentSnapshot.users).forEach(id => {
                            zeroSnapshot.users[id] = {
                                points: 0,
                                rank: 0,
                                name: currentSnapshot.users[id].name
                            };
                        });
                        historicalData.push(zeroSnapshot);
                        console.log(`üìä Inserted zero-point at ${new Date(tournamentStartTime).toLocaleString()}`);
                    }
                }
                // ====== END NEW TOURNAMENT DETECTION ======
                // Add current snapshot to history
                historicalData.push(currentSnapshot);
            } else {
                debugLog('‚èπÔ∏è Tournament ended >1 day ago - skipping data collection');
            }

            // Define time ranges in milliseconds
            const minute = 60 * 1000;
            const hour = 60 * minute;

            const timeRanges = {
                recent: { min: 0, max: 10 * minute - 1, label: '0-10m' },           // 0 to 9:59
                medium: { min: 10 * minute, max: 1 * hour - 1, label: '10-60m' },   // 10:00 to 59:59
                hour1to6: { min: 1 * hour, max: 6 * hour - 1, label: '1-6h' },      // 1:00:00 to 5:59:59
                hour6to24: { min: 6 * hour, max: 24 * hour - 1, label: '6-24h' },   // 6:00:00 to 23:59:59
                day1: { min: 24 * hour, max: 48 * hour - 1, label: '1d' },          // 24h to 47:59:59
                day2: { min: 48 * hour, max: 72 * hour - 1, label: '2d' },          // 48h to 71:59:59
                day3: { min: 72 * hour, max: 96 * hour - 1, label: '3d' },          // 72h to 95:59:59
                day4: { min: 96 * hour, max: 120 * hour - 1, label: '4d' }          // 96h to 119:59:59
            };

            // Find data points in each time range for each user
            userRankings.forEach(user => {
                // Find most recent entry (last click - excluding current)
                const lastEntry = historicalData.length > 1 ?
                      historicalData[historicalData.length - 2].users[user.userId] : null;

                // Function to find data point closest to a specific time ago
                const findDataAtTime = (millisAgo) => {
                    const targetTime = now - millisAgo;
                    let closestData = null;
                    let closestTimeDiff = Infinity;

                    // Find the data point closest to (but not newer than) the target time
                    for (let i = historicalData.length - 1; i >= 0; i--) {
                        const entry = historicalData[i];

                        // Only consider entries at or before the target time
                        if (entry.timestamp > targetTime) continue;

                        const timeDiff = targetTime - entry.timestamp;

                        if (timeDiff < closestTimeDiff) {
                            const userData = entry.users[user.userId];
                            if (userData) {
                                closestData = userData;
                                closestTimeDiff = timeDiff;
                            }
                        }
                    }

                    return closestData;
                };

                // Find data at boundary times
                const data10min = findDataAtTime(10 * minute);
                const data60min = findDataAtTime(60 * minute);
                const data1h = findDataAtTime(1 * hour);
                const data6h = findDataAtTime(6 * hour);
                const data24h = findDataAtTime(24 * hour);
                const data48h = findDataAtTime(48 * hour);
                const data72h = findDataAtTime(72 * hour);
                const data96h = findDataAtTime(96 * hour);
                const data120h = findDataAtTime(120 * hour);

                // Calculate INCREMENTAL changes for each time window using boundaries
                // Each column shows points gained DURING that specific period
                // FIXED: Handle missing data points by using closest available data

                // For ranges, we need two boundary points. If one is missing, use what we have
                user.changes = {
                    lastClick: lastEntry ? user.points - lastEntry.points : 0,
                    // 0-10min: current minus 10min ago
                    recent: data10min ? user.points - data10min.points : 0,
                    // 10-60min: 10min ago minus 60min ago (if both exist, otherwise show gap)
                    medium: (data10min && data60min) ? data10min.points - data60min.points :
                    (!data10min && data60min) ? user.points - data60min.points : 0,
                    // 1-6h: 1h ago minus 6h ago
                    hour1to6: (data1h && data6h) ? data1h.points - data6h.points :
                    (!data1h && data6h) ? user.points - data6h.points : 0,
                    // 6-24h: 6h ago minus 24h ago
                    hour6to24: (data6h && data24h) ? data6h.points - data24h.points :
                    (!data6h && data24h) ? user.points - data24h.points : 0,
                    // 1d (24-48h): 24h ago minus 48h ago
                    day1: (data24h && data48h) ? data24h.points - data48h.points :
                    (!data24h && data48h) ? user.points - data48h.points : 0,
                    // 2d (48-72h): 48h ago minus 72h ago
                    day2: (data48h && data72h) ? data48h.points - data72h.points :
                    (!data48h && data72h) ? user.points - data72h.points : 0,
                    // 3d (72-96h): 72h ago minus 96h ago
                    day3: (data72h && data96h) ? data72h.points - data96h.points :
                    (!data72h && data96h) ? user.points - data96h.points : 0,
                    // 4d (96-120h): 96h ago minus 120h ago
                    day4: (data96h && data120h) ? data96h.points - data120h.points :
                    (!data96h && data120h) ? user.points - data120h.points : 0
                };

                // Track if we have data for each period
                user.hasData = {
                    lastClick: !!lastEntry,
                    recent: !!data10min,
                    medium: !!(data10min || data60min),
                    hour1to6: !!(data1h || data6h),
                    hour6to24: !!(data6h || data24h),
                    day1: !!(data24h || data48h),
                    day2: !!(data48h || data72h),
                    day3: !!(data72h || data96h),
                    day4: !!(data96h || data120h)
                };
            });


            const retentionMs = TOURNAMENT_RETENTION_MS

            historicalData = historicalData.filter(entry => now - entry.timestamp < retentionMs);

            // Save updated historical data
            try {
                localStorage.setItem('hwh_power_tournament_history', JSON.stringify(historicalData));
                debugLog(`Saved ${historicalData.length} data points to localStorage`);
            } catch (e) {
                console.error('Error saving historical data:', e);
            }

            // Remove any existing tournament popup
            const existingPopup = DOMCache.get('tournamentPopup', '#power-tournament-popup');
            if (existingPopup) {
                existingPopup.remove();
                DOMCache.clear('tournamentPopup');
            }

            // Create centered backdrop
            const backdrop = document.createElement('div');
            backdrop.id = 'power-tournament-popup';
            // Global auto-refresh state (persists across popup refreshes)
            if (!window._tournamentAutoRefresh) {
                window._tournamentAutoRefresh = {
                    timer: null,
                    timeout: null,
                    interval: 0,
                    startTime: null
                };
            }
            backdrop.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.5); z-index: 10000;
    display: flex; align-items: center; justify-content: center;
`;

            // Create popup - wider to accommodate new columns, now resizable
            const popup = document.createElement('div');
            popup.id = 'power-tournament-popup-inner';
            const gameCanvas = DOMCache.get('gameCanvas', 'canvas');
            const popupWidth = gameCanvas ? gameCanvas.getBoundingClientRect().width * 0.92 : Math.min(window.innerWidth - 60, 820);
            popup.style.cssText = `
    background: rgba(42,24,16); border: 2px solid #8b6914; border-radius: 6px;
    padding: 12px; width: ${popupWidth}px; min-width: 500px; min-height: 300px; max-height: 85vh; overflow-y: auto;
color: #ffd700; font-family: Arial, sans-serif; font-size: 14px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    overflow: auto;
`;

            // Load saved refresh interval (default 60 seconds)
            const savedRefreshInterval = parseInt(localStorage.getItem('hwh_tournament_refresh_interval')) || 60;
            // Status variables (needed for status bar in header area)
            const _tar = window._tournamentAutoRefresh;
            const fastActive = _tar && _tar.timer;
            const topActive = !!window._topRefreshInterval;
            const endTimeDisplay = window._tournamentEndTime
            ? new Date(window._tournamentEndTime).toLocaleTimeString([], {hour: 'numeric', minute: '2-digit'})
            : '';
            const lastRefresh = window._topLastRefresh
            ? new Date(window._topLastRefresh).toLocaleTimeString()
            : 'Never';
            // Use fast interval if running, otherwise 60 min background interval
            const activeInterval = fastActive ? _tar.interval : 3600;
            const nextRefresh = (window._topLastRefresh)
            ? new Date(window._topLastRefresh + activeInterval * 1000).toLocaleTimeString()
            : '‚Äî';
            const oldestEntry = historicalData.length > 0 ? historicalData[0].timestamp : null;
            const purgeDate = oldestEntry
            ? new Date(oldestEntry + retentionMs).toLocaleDateString([], {month: 'numeric', day: 'numeric'}) + ' ' + new Date(oldestEntry + retentionMs).toLocaleTimeString([], {hour: 'numeric', minute: '2-digit'})
            : '‚Äî';
            // Header with close and refresh buttons
            let content = `
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
        <div style="display: flex; align-items: center; gap: 15px;">
            <h3 style="margin: 0; font-size: 13px;">üèÜ Power Tournament</h3>
            <span style="font-size: 12px; color: #ccc;">${new Date().toLocaleTimeString()} ‚Ä¢ Data points: ${historicalData.length}</span>
        </div>
        <div>
        <button id="export-tournament-btn" style="background: #28a745; color: #fff; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 13px; margin-right: 5px;">üìä Export</button>
            <button id="refresh-tournament-btn" style="background: #4a90e2; color: #fff; border: none; padding: 5px 8px; border-radius: 3px; cursor: pointer; font-size: 13px; margin-right: 5px;">üîÑ</button>
<button id="close-tournament-btn" style="background: #666; color: #fff; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 14px; font-weight: bold;">‚úï</button>
        </div>
    </div>

    <!-- Status Bar (moved here to show on all tabs) -->
   <div style="margin-bottom: 8px; padding: 6px 10px; background: rgba(0,0,0,0.3); border: 1px solid #555; border-radius: 4px; font-size: 11px; display: flex; justify-content: space-between; align-items: center;">
<div style="display: flex; gap: 10px; align-items: center;">
<span style="color: ${window._tournamentEnded ? '#ff6b6b' : (fastActive ? '#4ae29a' : (topActive ? '#ffa500' : '#ff6b6b'))};">‚óè ${window._tournamentEnded ? 'üèÅ Ended' + (endTimeDisplay ? ' ' + endTimeDisplay : '') : (fastActive ? 'Fast' : (topActive ? 'Hourly' : 'Off'))}</span>
            <span class="twk-muted">Last: <span class="twk-gold">${lastRefresh}</span></span>
            <span class="twk-muted">Next: <span class="twk-gold">${nextRefresh}</span></span>
            <span class="twk-muted">Oldest purges: <span class="twk-gold">${purgeDate}</span></span>
        </div>
        <div style="display: flex; gap: 8px; align-items: center;">
            <label style="color: #999; display: flex; align-items: center; gap: 4px;">
                <span>Auto ‚ü≥</span>
                <input id="tournament-refresh-interval" type="number" min="1" max="3600" value="${savedRefreshInterval}" style="background: #1a1408; color: #ffd700; border: 1px solid #8b6914; border-radius: 3px; padding: 2px 4px; font-size: 11px; width: 50px; text-align: center;">
                <span>sec</span>
            </label>
            <button id="apply-refresh-btn" style="background: #4a90e2; color: #fff; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 11px;">Apply</button>
            <button id="stop-refresh-btn" style="background: #666; color: #fff; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 11px; display: none;">Stop</button>
            <span id="refresh-status" style="color: #666; font-size: 10px; min-width: 70px;"></span>
            <button id="purge-tournament-btn" style="background: #c0392b; color: #fff; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 11px;">üóëÔ∏è Purge All</button>
        </div>
    </div>

    <!-- Tab Navigation -->
    <div style="display: flex; gap: 5px; margin-bottom: 8px; border-bottom: 2px solid #8b6914;">
        <button id="tab-leaderboard" class="tournament-tab" style="background: #8b6914; color: #ffd700; border: none; padding: 6px 15px; cursor: pointer; font-size: 12px; font-weight: bold; border-radius: 4px 4px 0 0;">Leaderboard</button>
        <button id="tab-graph" class="tournament-tab" style="background: transparent; color: #999; border: none; padding: 6px 15px; cursor: pointer; font-size: 12px; border-radius: 4px 4px 0 0;">Graph</button>
    </div>

    <!-- Leaderboard Content -->
    <div id="leaderboard-content">
    <!-- Updated Column Headers with Server, Guild, Members, Last Login -->
    <div style="display: grid; grid-template-columns: 34px 90px 30px 36px 36px 120px 58px 42px 46px 40px 46px 36px 36px 36px 36px 100px;gap: 4px; padding: 3px 2px; border-bottom: 1px solid #8b6914; margin-bottom: 6px; font-weight: bold; font-size: 11px; color: #4ae29a;">
        <div class="twk-center">Svr</div>
        <div>Guild</div>
        <div class="twk-center">Mbr</div>
        <div class="twk-center">Login</div>
        <div>Rank</div>
        <div>Player</div>
        <div class="twk-right">Points</div>
        <div class="twk-center">0-10m</div>
        <div class="twk-center">10-60m</div>
        <div class="twk-center">1-6h</div>
        <div class="twk-center">6-24h</div>
        <div class="twk-center">1d</div>
        <div class="twk-center">2d</div>
        <div class="twk-center">3d</div>
        <div class="twk-center">4d</div>
        <div>Rewards</div>
    </div>
`;

            // Player rows with all columns
            userRankings.forEach(user => {
                const medal = user.rank === 1 ? 'ü•á' : user.rank === 2 ? 'ü•à' : user.rank === 3 ? 'ü•â' : '';

                // Helper function to format change
                const formatChange = (change, hasData) => {
                    if (!hasData) return '<span style="color: #666;">‚Äî</span>';
                    if (change === 0) return '<span class="twk-muted">0</span>';

                    let displayValue = change;
                    if (Math.abs(change) >= 1000) {
                        displayValue = (change / 1000).toFixed(0) + 'K';
                    }

                    if (change > 0) return `<span class="twk-green">+${displayValue}</span>`;
                    return `<span class="twk-red">${displayValue}</span>`;
                };

                // Get reward for this rank
                const userReward = groupData.rewards?.find(r => r.place === user.rank);
                let rewardDisplay = '‚Äî';
                if (userReward && userReward.reward) {
                    const items = [];
                    const formatK = (n) => n >= 1000 ? (n/1000).toFixed(0) + 'K' : n;
                    if (userReward.reward.starmoney) {
                        items.push(`üíé${formatK(userReward.reward.starmoney)}`);
                    }
                    if (userReward.reward.consumable) {
                        Object.values(userReward.reward.consumable).forEach(qty => {
                            items.push(`üì¶${formatK(qty)}`);
                        });
                    }
                    if (userReward.reward.avatar) {
                        items.push(`üë§`);
                    }
                    rewardDisplay = items.join(' ');
                }

                // Format points with 1 decimal place for K format
                let pointsDisplay;
                if (user.points > 999999) {
                    pointsDisplay = (user.points/1000000).toFixed(1) + 'M';
                } else if (user.points > 999) {
                    pointsDisplay = (user.points/1000).toFixed(1) + 'K';
                } else {
                    pointsDisplay = user.points.toLocaleString();
                }

                content += `
<div data-user-id="${user.userId}" style="display: grid; grid-template-columns: 34px 90px 30px 36px 36px 120px 58px 42px 46px 40px 46px 36px 36px 36px 36px 100px; gap: 4px; padding: 2px 2px; border-bottom: 1px solid #333; align-items: center; font-size: 11px;">
            <div style="text-align: center; font-size: 11px; color: #999; font-weight: bold;">${user.serverId}</div>
<div class="guild-name-link" data-clan-id="${user.clanId}" data-user-id="${user.userId}" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 11px; color: #888; cursor: pointer; text-decoration: underline;">${user.clanTitle}</div>            <div class="member-count" style="text-align: center; font-size: 11px; color: #999;">${user.memberCount}</div>
            <div style="text-align: center; font-size: 11px; color: #999;">${user.lastLoginDisplay}</div>
            <div style="font-size: 13px; text-align: center;">${medal || user.rank}</div>
            <div style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                <span style="font-weight: bold;">${user.name}</span>
            </div>
            <div style="text-align: right; font-family: monospace; font-weight: bold; font-size: 13px;">
                ${pointsDisplay}
            </div>
            <div class="twk-center twk-mono">
                ${formatChange(user.changes.recent, user.hasData.recent)}
            </div>
            <div class="twk-center twk-mono">
                ${formatChange(user.changes.medium, user.hasData.medium)}
            </div>
            <div class="twk-center twk-mono">
                ${formatChange(user.changes.hour1to6, user.hasData.hour1to6)}
            </div>
            <div class="twk-center twk-mono">
                ${formatChange(user.changes.hour6to24, user.hasData.hour6to24)}
            </div>
            <div class="twk-center twk-mono">
                ${formatChange(user.changes.day1, user.hasData.day1)}
            </div>
            <div class="twk-center twk-mono">
                ${formatChange(user.changes.day2, user.hasData.day2)}
            </div>
            <div class="twk-center twk-mono">
                ${formatChange(user.changes.day3, user.hasData.day3)}
            </div>
            <div class="twk-center twk-mono">
                ${formatChange(user.changes.day4, user.hasData.day4)}
            </div>
            <div style="font-size: 10px; color: #ccc; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                ${rewardDisplay}
            </div>
        </div>
    `;
            });



            content += `</div>`; // Close leaderboard-content



            // Graph section - initially hidden, will be shown when Graph tab is clicked
            content += '<div id="graph-content" class="twk-hidden">';
            content += '<div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid #666;">';

            // Clean historical data - remove inconsistent entries BUT keep most recent
            const cleanedHistory = [];
            for (let i = 0; i < historicalData.length; i++) {
                const entry = historicalData[i];
                let isValid = true;

                // ALWAYS include the most recent entry (current snapshot)
                const isLastEntry = (i === historicalData.length - 1);

                // Check if this entry has reasonable data (but skip checks for last entry)
                if (i > 0 && !isLastEntry) {
                    const prevEntry = historicalData[i - 1];
                    const timeDiff = entry.timestamp - prevEntry.timestamp;

                    // Skip entries that are too close together (< 10 seconds) - reduced from 30
                    if (timeDiff < 10000) {
                        isValid = false;
                    }

                    // Check for unreasonable point changes
                    for (const userId in entry.users) {
                        const currentPoints = entry.users[userId]?.points || 0;
                        const prevPoints = prevEntry.users[userId]?.points || 0;
                        const pointChange = Math.abs(currentPoints - prevPoints);

                        // Skip if point change is too large (> 500K in one interval)
                        if (pointChange > 500000 && timeDiff < 3600000) {
                            isValid = false;
                            break;
                        }
                    }
                }

                if (isValid || isLastEntry) {
                    cleanedHistory.push(entry);
                }
            }


            // Create graph for all players WITH NAMES ON RIGHT - RESPONSIVE
            const allPlayers = userRankings;

            // Calculate responsive dimensions based on window size
            const nameColumnWidth = 140;
            const graphWidth = Math.max(400, popupWidth - nameColumnWidth - 60);
            const graphHeight = Math.min(500, Math.max(300, window.innerHeight * 0.5)); // 50% of window, 300-500 range

            const padding = { top: 10, right: 20, bottom: 20, left: 60 };
            const plotWidth = graphWidth - padding.left - padding.right;
            const plotHeight = graphHeight - padding.top - padding.bottom;
            // Find min/max points and timestamps
            let minPoints = Infinity;
            let maxPoints = 0;
            let minTime = Infinity;
            let maxTime = 0;

            cleanedHistory.forEach(entry => {
                allPlayers.forEach(user => {
                    const points = entry.users[user.userId]?.points || 0;
                    if (points > 0) {
                        minPoints = Math.min(minPoints, points);
                        maxPoints = Math.max(maxPoints, points);
                    }
                });
                minTime = Math.min(minTime, entry.timestamp);
                maxTime = Math.max(maxTime, entry.timestamp);
            });


            // If tournament still active, extend to now; if ended, snap to 2:00 UTC after last score change
            if (!window._tournamentEnded) {
                maxTime = now;
            } else if (cleanedHistory.length > 1) {
                // Find the last time any score changed
                let lastChangeTime = cleanedHistory[0].timestamp;

                for (let i = 1; i < cleanedHistory.length; i++) {
                    const entry = cleanedHistory[i];
                    const prevEntry = cleanedHistory[i - 1];

                    for (const userId in entry.users) {
                        if (entry.users[userId]?.points !== prevEntry.users[userId]?.points) {
                            lastChangeTime = entry.timestamp;
                            break;
                        }
                    }
                }

                // Snap to next 2:00 UTC after last score change
                const changeDate = new Date(lastChangeTime);
                const endTime = new Date(Date.UTC(
                    changeDate.getUTCFullYear(),
                    changeDate.getUTCMonth(),
                    changeDate.getUTCDate(),
                    2, 0, 0, 0
                ));
                // If 2:00 UTC is before or at the last change, go forward a day
                if (endTime.getTime() <= lastChangeTime) {
                    endTime.setUTCDate(endTime.getUTCDate() + 1);
                }

                maxTime = endTime.getTime();
                window._tournamentEndTime = maxTime;
                localStorage.setItem('hwh_tournament_end_time', maxTime);
            }

            // Snap left edge to 2:00 UTC before first data (tournament start)
            const startDate = new Date(minTime);
            const startTime = new Date(Date.UTC(
                startDate.getUTCFullYear(),
                startDate.getUTCMonth(),
                startDate.getUTCDate(),
                2, 0, 0, 0
            ));
            // If 2:00 UTC is after our first data, go back a day
            if (startTime.getTime() > minTime) {
                startTime.setUTCDate(startTime.getUTCDate() - 1);
            }
            minTime = startTime.getTime();

            // Add 1% padding on right side only so lines don't touch edge
            const timeRange = maxTime - minTime;
            const timePadding = timeRange * 0.01;
            maxTime = maxTime + timePadding;

            // Add only 5% padding to the scale (reduced from 10%)
            const pointRange = maxPoints - minPoints;
            minPoints = Math.max(0, minPoints - pointRange * 0.05);
            maxPoints = maxPoints + pointRange * 0.05;

            // Container for graph and names
            content += `<div class="twk-flex-gap10">`;

            // SVG graph
            content += `<svg width="${graphWidth}" height="${graphHeight}" style="background: rgba(0,0,0,0.2); border-radius: 4px; overflow: hidden;">`;

            // Define clipPath to prevent lines from extending beyond plot area
            content += `<defs>`;
            content += `<clipPath id="plot-clip">`;
            content += `<rect x="${padding.left}" y="${padding.top}" width="${plotWidth}" height="${plotHeight}"/>`;
            content += `</clipPath>`;
            content += `</defs>`;

            // Draw grid lines (horizontal)
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (plotHeight / 4) * i;
                const points = maxPoints - (pointRange / 4) * i;
                content += `<line x1="${padding.left}" y1="${y}" x2="${graphWidth - padding.right}" y2="${y}" stroke="#999" stroke-width="0.5"/>`;
                content += `<text x="${padding.left - 5}" y="${y + 4}" text-anchor="end" fill="#ccc" font-size="11">${(points / 1000).toFixed(1)}K</text>`;
            }

            // Draw vertical grid lines aligned with duration columns from the table
            // Time ranges that match the table columns
            const durationRanges = [
                { label: '1h', hours: 1 },
                { label: '6h', hours: 6 },
                { label: '1d', days: 1 },
                { label: '2d', days: 2 },
                { label: '3d', days: 3 },
                { label: '4d', days: 4 }
            ];

            const currentTime = window._tournamentEnded ? maxTime : now;
            durationRanges.forEach(range => {
                let millisAgo;
                if (range.minutes) {
                    millisAgo = range.minutes * 60 * 1000;
                } else if (range.hours) {
                    millisAgo = range.hours * 60 * 60 * 1000;
                } else if (range.days) {
                    millisAgo = range.days * 24 * 60 * 60 * 1000;
                }

                const timestamp = currentTime - millisAgo;

                if (timestamp >= minTime && timestamp <= maxTime) {
                    const x = padding.left + ((timestamp - minTime) / (maxTime - minTime)) * plotWidth;

                    // Draw vertical line
                    content += `<line x1="${x}" y1="${padding.top}" x2="${x}" y2="${graphHeight - padding.bottom}" stroke="#999" stroke-width="0.5"/>`;

                    // Add label above top edge, bottom-middle justified
                    content += `<text x="${x}" y="${padding.top - 2}" text-anchor="middle" fill="#ccc" font-size="11">${range.label}</text>`;
                }
            });

            // Draw lines for each player and track their final Y positions
            const playerFinalPositions = [];
            allPlayers.forEach((user, index) => {
                let pathData = '';
                let firstPoint = true;
                let lastX = 0;
                let lastY = 0;

                // Start all players at 0 points at tournament start
                if (window._tournamentEnded || cleanedHistory.length > 0) {
                    const startX = padding.left;
                    const startY = padding.top + plotHeight - ((0 - minPoints) / (maxPoints - minPoints)) * plotHeight;
                    pathData += `M ${startX} ${startY}`;
                    firstPoint = false;
                }

                cleanedHistory.forEach(entry => {
                    const userData = entry.users[user.userId];
                    if (userData && userData.points) {
                        const x = padding.left + ((entry.timestamp - minTime) / (maxTime - minTime)) * plotWidth;
                        const y = padding.top + plotHeight - ((userData.points - minPoints) / (maxPoints - minPoints)) * plotHeight;

                        pathData += ` L ${x} ${y}`;
                        lastX = x;
                        lastY = y;
                    }
                });

                if (pathData) {
                    // Use different width based on rank, but keep all colors bright
                    const strokeWidth = index < 5 ? 2 : 1; // Top 5 thicker, rest thin

                    // Better color distribution - use golden ratio for better spread
                    const goldenRatio = 0.618033988749895;
                    const hue = ((index * goldenRatio) % 1) * 360;
                    const color = `hsl(${hue}, 70%, 60%)`;

                    content += `<path d="${pathData}" fill="none" stroke="${color}" stroke-width="${strokeWidth}" clip-path="url(#plot-clip)"/>`;

                    // Store final position for name placement
                    playerFinalPositions.push({
                        user,
                        y: lastY,
                        color,
                        rank: index
                    });
                }
            });

            content += '</svg>';

            // Names in single column on the right, sorted by rank
            content += `<div style="width: ${nameColumnWidth}px; font-size: 12px;">`;

            // Sort by rank (1, 2, 3...) instead of Y position
            playerFinalPositions.sort((a, b) => a.rank - b.rank);

            playerFinalPositions.forEach(item => {
                const fontWeight = item.rank < 5 ? 'bold' : 'normal';
                const rankNum = item.rank + 1; // rank index is 0-based, display as 1-based
                // Format points for display
                let pointsDisplay;
                if (item.user.points > 999999) {
                    pointsDisplay = (item.user.points/1000000).toFixed(1) + 'M';
                } else if (item.user.points > 999) {
                    pointsDisplay = (item.user.points/1000).toFixed(1) + 'K';
                } else {
                    pointsDisplay = item.user.points.toLocaleString();
                }
                content += `<div style="display: flex; align-items: flex-start; margin-bottom: 4px;">`;
                content += `<div style="width: 10px; height: 2px; background: ${item.color}; margin-right: 5px; flex-shrink: 0; margin-top: 6px;"></div>`;
                content += `<span style="color: ${item.color}; margin-right: 5px; min-width: 15px; font-size: 12px;">${rankNum}</span>`;
                content += `<div style="display: flex; flex-direction: column; overflow: hidden;">`;
                content += `<span style="color: ${item.color}; font-weight: ${fontWeight}; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 11px;">${item.user.name}</span>`;
                content += `<span style="color: #999; font-size: 10px; font-family: monospace;">${pointsDisplay}</span>`;
                content += `</div>`;
                content += `</div>`;
            });

            content += '</div>';
            content += '</div>'; // Close flex container
            content += '</div>'; // Close graph section
            content += '</div>'; // Close graph-content


            popup.innerHTML = content;
            backdrop.appendChild(popup);
            document.body.appendChild(backdrop);
            // Show docked summary bar
            window.showTournamentDock(userRankings);

            // Tab switching logic
            const leaderboardTab = document.getElementById('tab-leaderboard');
            const graphTab = document.getElementById('tab-graph');
            const leaderboardContent = document.getElementById('leaderboard-content');
            const graphContent = document.getElementById('graph-content');

            leaderboardTab.addEventListener('click', function() {
                leaderboardTab.style.background = '#8b6914';
                leaderboardTab.style.color = '#ffd700';
                graphTab.style.background = 'transparent';
                graphTab.style.color = '#999';
                leaderboardContent.style.display = 'block';
                graphContent.style.display = 'none';
            });

            graphTab.addEventListener('click', function() {
                graphTab.style.background = '#8b6914';
                graphTab.style.color = '#ffd700';
                leaderboardTab.style.background = 'transparent';
                leaderboardTab.style.color = '#999';
                leaderboardContent.style.display = 'none';
                graphContent.style.display = 'block';
            });

            // Event listeners
            document.getElementById('close-tournament-btn').addEventListener('click', function() {
                backdrop.remove();
            });

            document.getElementById('refresh-tournament-btn').addEventListener('click', async function() {
                this.textContent = '‚ü≥';
                this.style.background = '#28a745';
                await window.refreshPowerTournamentData(true);
                // Store state before refresh
                const activeTab = document.getElementById('tab-graph').style.background === '#8b6914' ? 'graph' : 'leaderboard';
                const scrollPos = popup.scrollTop;
                backdrop.remove();
                await window.goPowerTournament();
                // Restore state after refresh
                if (activeTab === 'graph') {
                    document.getElementById('tab-graph')?.click();
                }
                const newPopup = document.getElementById('power-tournament-popup-inner');
                if (newPopup) newPopup.scrollTop = scrollPos;
            });

            document.getElementById('export-tournament-btn').addEventListener('click', function() {
                // Create export data in tab-separated format for Google Sheets
                let exportData = '';

                // Header row with timestamp info
                exportData += `Power Tournament Data Export\t\t\t\t\t\t\t\t\t\t\n`;
                exportData += `Export Time: ${new Date().toLocaleString()}\t\t\t\t\t\t\t\t\t\t\n`;
                exportData += `Total Data Points: ${historicalData.length}\t\t\t\t\t\t\t\t\t\t\n`;
                exportData += `\n`;

                // Get all unique users
                const allUserIds = new Set();
                historicalData.forEach(entry => {
                    Object.keys(entry.users).forEach(userId => allUserIds.add(userId));
                });

                // Column headers
                exportData += `Timestamp\tDate/Time\t`;
                const userArray = Array.from(allUserIds);
                userArray.forEach(userId => {
                    const userName = historicalData[historicalData.length - 1].users[userId]?.name || userId;
                    exportData += `${userName}\t`;
                });
                exportData += `\n`;

                // Data rows - one per timestamp
                historicalData.forEach(entry => {
                    const date = new Date(entry.timestamp);
                    exportData += `${entry.timestamp}\t${date.toLocaleString()}\t`;
                    userArray.forEach(userId => {
                        const points = entry.users[userId]?.points || '';
                        exportData += `${points}\t`;
                    });
                    exportData += `\n`;
                });

                // Copy to clipboard with feedback
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(exportData).then(() => {
                        const btn = document.getElementById('export-tournament-btn');
                        const originalText = btn.innerHTML;
                        btn.innerHTML = '‚úì Copied!';
                        btn.style.background = '#20c997';
                        setTimeout(() => {
                            btn.innerHTML = originalText;
                            btn.style.background = '#28a745';
                        }, 2000);
                    });
                }
            });


            // Backdrop click no longer closes - must use X button


            // Purge button handler
            document.getElementById('purge-tournament-btn').addEventListener('click', function() {
                if (confirm('‚ö†Ô∏è Delete ALL Power Tournament history data?\n\nThis cannot be undone.')) {
                    localStorage.removeItem('hwh_power_tournament_history');
                    localStorage.removeItem('hwh_power_tournament_clan_cache');
                    window._topLastRefresh = null;
                    alert('‚úÖ Tournament data purged!');
                    backdrop.remove();
                }
            });

            // Auto-refresh system (uses global state)
            const refreshIntervalInput = document.getElementById('tournament-refresh-interval');
            const applyRefreshBtn = document.getElementById('apply-refresh-btn');
            const stopRefreshBtn = document.getElementById('stop-refresh-btn');
            const refreshStatus = DOMCache.get('popupRefreshStatus', '#refresh-status');

            const stopAutoRefresh = (switchTo15Min = false) => {
                if (_tar.timer) {
                    clearInterval(_tar.timer);
                    _tar.timer = null;
                }
                if (_tar.timeout) {
                    clearTimeout(_tar.timeout);
                    _tar.timeout = null;
                }
                _tar.startTime = null;
                _tar.interval = 0;

                if (switchTo15Min) {
                    // Auto-switch to 15 minute interval
                    setTimeout(() => {
                        const input = document.getElementById('tournament-refresh-interval');
                        if (input) input.value = '900';
                        localStorage.setItem('hwh_tournament_refresh_interval', 900);
                        startAutoRefresh(900);
                    }, 100);
                } else {
                    if (stopRefreshBtn) stopRefreshBtn.style.display = 'none';
                    if (applyRefreshBtn) applyRefreshBtn.style.display = 'inline-block';
                    if (refreshStatus) refreshStatus.textContent = '';
                    // Also update dock
                    const dockStatus = DOMCache.get('dockRefreshStatus', '#dock-refresh-status');
                    if (dockStatus) dockStatus.textContent = '';
                }
            };

            const flashUpdate = () => {
                // Flash indicator in popup
                const popupStatus = DOMCache.get('popupRefreshStatus', '#refresh-status');
                if (popupStatus) {
                    const origText = popupStatus.textContent;
                    popupStatus.textContent = '‚úì Updated';
                    popupStatus.style.color = '#4ae29a';
                    setTimeout(() => {
                        if (_tar.interval > 0) {
                            const isFast = _tar.interval < 1800;
                            popupStatus.textContent = isFast ? `‚ü≥ ${_tar.interval}s` : `‚ü≥ ${Math.floor(_tar.interval/60)}m`;
                            popupStatus.style.color = isFast ? '#ffa500' : '#4ae29a';
                        }
                    }, 1500);
                }
                // Flash indicator in dock
                const dock = DOMCache.get('tournamentDock', '#tournament-dock');
                const dockStatus = DOMCache.get('dockRefreshStatus', '#dock-refresh-status');
                if (dock) {
                    dock.style.borderColor = '#4ae29a';
                    setTimeout(() => dock.style.borderColor = '#8b6914', 1500);
                }
                if (dockStatus) {
                    dockStatus.textContent = '‚úì';
                    dockStatus.style.color = '#4ae29a';
                    setTimeout(() => {
                        dockStatus.textContent = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                        dockStatus.style.color = '#999';
                    }, 1500);
                }
            };

            const startAutoRefresh = (intervalSec) => {
                // Clear any existing
                if (_tar.timer) clearInterval(_tar.timer);
                if (_tar.timeout) clearTimeout(_tar.timeout);

                if (intervalSec < 1) return;

                _tar.interval = intervalSec;
                _tar.startTime = Date.now();
                const isFastInterval = intervalSec < 1800; // Less than 30 minutes

                const doRefresh = async () => {
                    if (document.hidden) {
                        debugLog('‚è∏Ô∏è Tournament refresh skipped - tab hidden');
                        return;
                    }
                    const existingPopup = DOMCache.get('tournamentPopup', '#power-tournament-popup');
                    const existingDock = DOMCache.get('tournamentDock', '#tournament-dock');
                    if (!existingPopup && !existingDock) {
                        stopAutoRefresh(false);
                        return;
                    }

                    // Store state if popup exists
                    let activeTab = 'leaderboard';
                    let scrollPos = 0;
                    if (existingPopup) {
                        activeTab = document.getElementById('graph-content')?.style.display !== 'none' ? 'graph' : 'leaderboard';
                        const currentPopup = document.getElementById('power-tournament-popup-inner');
                        scrollPos = currentPopup?.scrollTop || 0;
                    }

                    // Refresh data silently
                    await window.refreshPowerTournamentData(true);

                    // Rebuild popup if it exists
                    if (existingPopup) {
                        await window.goPowerTournament();

                        // Restore state
                        if (activeTab === 'graph') {
                            document.getElementById('tab-graph')?.click();
                        }
                        const newPopup = document.getElementById('power-tournament-popup-inner');
                        if (newPopup) newPopup.scrollTop = scrollPos;
                    } else if (existingDock) {
                        // Just update the dock with fresh data
                        const saved = localStorage.getItem('hwh_power_tournament_history');
                        if (saved) {
                            const historicalData = JSON.parse(saved);
                            if (historicalData.length > 0) {
                                const latestEntry = historicalData[historicalData.length - 1];
                                const rankings = Object.entries(latestEntry.users)
                                .map(([userId, data]) => ({ userId, ...data }))
                                .sort((a, b) => b.points - a.points);
                                window.showTournamentDock(rankings);
                            }
                        }
                    }

                    // Flash update indicator
                    flashUpdate();
                };

                _tar.timer = setInterval(doRefresh, intervalSec * 1000);

                // Update UI
                if (applyRefreshBtn) applyRefreshBtn.style.display = 'none';
                if (stopRefreshBtn) stopRefreshBtn.style.display = 'inline-block';

                if (isFastInterval) {
                    if (refreshStatus) {
                        refreshStatus.textContent = `‚ü≥ ${intervalSec}s (15m‚Üí15m)`;
                        refreshStatus.style.color = '#ffa500';
                    }
                    _tar.timeout = setTimeout(() => {
                        stopAutoRefresh(true); // Switch to 15 min after 15 min
                    }, 15 * 60 * 1000);
                } else {
                    if (refreshStatus) {
                        refreshStatus.textContent = `‚ü≥ ${Math.floor(intervalSec/60)}m`;
                        refreshStatus.style.color = '#4ae29a';
                    }
                }

                // Update dock status
                const dockStatus = DOMCache.get('dockRefreshStatus', '#dock-refresh-status');
                if (dockStatus) {
                    dockStatus.textContent = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    dockStatus.style.color = '#999';
                }
            };

            applyRefreshBtn.addEventListener('click', function() {
                const interval = Math.max(1, parseInt(refreshIntervalInput.value) || 60);
                localStorage.setItem('hwh_tournament_refresh_interval', interval);
                startAutoRefresh(interval);
            });

            stopRefreshBtn.addEventListener('click', () => stopAutoRefresh(false));

            // Restore UI state if auto-refresh is already running
            if (_tar.timer && _tar.interval > 0) {
                applyRefreshBtn.style.display = 'none';
                stopRefreshBtn.style.display = 'inline-block';
                const isFast = _tar.interval < 1800;
                if (isFast) {
                    const elapsed = Math.floor((Date.now() - _tar.startTime) / 1000);
                    const remaining = Math.max(0, 900 - elapsed); // 15 min = 900 sec
                    refreshStatus.textContent = `‚ü≥ ${_tar.interval}s (${Math.floor(remaining/60)}m left)`;
                    refreshStatus.style.color = '#ffa500';
                } else {
                    refreshStatus.textContent = `‚ü≥ ${Math.floor(_tar.interval/60)}m`;
                    refreshStatus.style.color = '#4ae29a';
                }
            }
            DOMCache.getAll('guildLinks', '.guild-name-link').forEach(link => {
                link.addEventListener('click', async function(e) {
                    e.stopPropagation();
                    const clanId = this.getAttribute('data-clan-id');
                    const userId = this.getAttribute('data-user-id');
                    if (clanId) window.showClanPopup(clanId, userId);
                });
            });

            // Fetch member counts in background ONLY if cache is missing data - runs once per day
            setTimeout(async () => {
                try {
                    const clansToFetch = new Map();
                    userRankings.forEach(user => {
                        if (user.clanId && user.memberCount === '?') {
                            if (!clansToFetch.has(user.clanId)) {
                                clansToFetch.set(user.clanId, { users: [] });
                            }
                            clansToFetch.get(user.clanId).users.push(user);
                        }
                    });

                    if (clansToFetch.size > 0) {
                        debugLog(`Fetching data for ${clansToFetch.size} clans not in cache...`);

                        // Fetch clan data one at a time to avoid overwhelming the API
                        for (const [clanId, clanInfo] of clansToFetch.entries()) {
                            try {
                                const clanResponse = await SendFunction(`{"calls":[{"name":"clanGetInfo","args":{"clanId":${clanId}},"context":{"actionTs":${Date.now()}},"ident":"body"}]}`);
                                if (clanResponse && clanResponse.results && clanResponse.results[0] && clanResponse.results[0].result && clanResponse.results[0].result.response) {
                                    const clanData = clanResponse.results[0].result.response.clan;

                                    // Cache this clan data
                                    clanDataCache[clanId] = clanData;

                                    // Update all users in this clan
                                    clanInfo.users.forEach(user => {
                                        user.memberCount = clanData.membersCount;
                                        user.clanData = clanData;
                                        // Find and update the display element
                                        const rows = popup.querySelectorAll('[data-user-id="' + user.userId + '"]');
                                        rows.forEach(row => {
                                            const memberCell = row.querySelector('.member-count');
                                            if (memberCell) {
                                                memberCell.textContent = clanData.membersCount;
                                            }
                                        });
                                    });
                                }
                            } catch (e) {
                                console.warn(`Failed to fetch clan ${clanId}:`, e);
                            }
                            // Small delay between requests
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }

                        // Save updated cache with today's timestamp
                        try {
                            localStorage.setItem('hwh_power_tournament_clan_cache', JSON.stringify({
                                timestamp: Date.now(),
                                clans: clanDataCache
                            }));
                            debugLog(`Saved clan cache with ${Object.keys(clanDataCache).length} clans`);
                        } catch (e) {
                            console.error('Error saving clan cache:', e);
                        }

                        debugLog('Finished fetching and caching clan data');
                    } else {
                        debugLog('All clan data loaded from cache, no fetching needed');
                    }
                } catch (e) {
                    console.error('Error in background clan data fetch:', e);
                }
            }, 100);

        } catch (error) {
            console.error('Error in goPowerTournament:', error);
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('Error loading Power Tournament: ' + error.message, true);
            }
        }
    };
    // Background refresh for Power Tournament data (no popup)
    window.refreshPowerTournamentData = async function(silent = true) {
        try {
            if (!silent) debugLog('üîÑ Background refresh: Power Tournament data...');

            const SendFunction = getSend();
            if (!SendFunction) {
                if (!silent) debugLog('‚ö†Ô∏è No Send function available for ToP refresh');
                return false;
            }

            const response = await SendFunction('{"calls":[{"name":"powerTournament_getState","args":{},"context":{"actionTs":' + Date.now() + '},"ident":"body"},{"name":"powerTournament_getGroupInfo","args":{},"context":{"actionTs":' + Date.now() + '},"ident":"powerTournament_getGroupInfo"}]}');

            if (!response?.results?.[1]?.result?.response) {
                if (!silent) debugLog('‚ÑπÔ∏è No Power Tournament active');
                window._tournamentEnded = true;
                // Tournament ended - update dock and stop refresh
                const dock = DOMCache.get('tournamentDock', '#tournament-dock');
                if (dock) {
                    dock.style.borderColor = '#ff6b6b';
                    dock.style.background = 'rgba(60,20,20,0.95)';
                    const dockStatus = DOMCache.get('dockRefreshStatus', '#dock-refresh-status');
                    if (dockStatus) {
                        dockStatus.textContent = '‚ö†Ô∏è ENDED';
                        dockStatus.style.color = '#ff6b6b';
                    }
                }
                // Stop auto-refresh
                if (window._tournamentAutoRefresh) {
                    if (window._tournamentAutoRefresh.timer) {
                        clearInterval(window._tournamentAutoRefresh.timer);
                        window._tournamentAutoRefresh.timer = null;
                    }
                    if (window._tournamentAutoRefresh.timeout) {
                        clearTimeout(window._tournamentAutoRefresh.timeout);
                        window._tournamentAutoRefresh.timeout = null;
                    }
                    window._tournamentAutoRefresh.interval = 0;
                }
                return false;
            }

            const groupData = response.results[1].result.response;
            const now = Date.now();
            const tournamentState = response.results[0]?.result?.response;
            const wasEnded = window._tournamentEnded;
            window._tournamentEnded = tournamentState?.state === 2;

            // Tournament just ended - defer handling until historicalData is loaded
            const justEnded = window._tournamentEnded && !wasEnded;

            // Load end time if tournament is ended
            if (window._tournamentEnded && !window._tournamentEndTime) {
                window._tournamentEndTime = parseInt(localStorage.getItem('hwh_tournament_end_time')) || null;
            }

            // Load existing historical data
            let historicalData = [];
            try {
                const saved = localStorage.getItem('hwh_power_tournament_history');
                if (saved && saved !== 'undefined' && saved !== 'null') {
                    const parsed = JSON.parse(saved);
                    if (Array.isArray(parsed)) {
                        historicalData = parsed;
                    }
                }
            } catch (e) {
                historicalData = [];
            }
            // Now handle tournament just ended (historicalData is loaded)
            if (justEnded) {
                debugLog('üèÜ Tournament ended - logging final data point');
                const lastTimestamp = historicalData.length > 0 ? historicalData[historicalData.length - 1].timestamp : now;
                localStorage.setItem('hwh_tournament_end_time', lastTimestamp);
            }

            // Process current rankings
            const currentSnapshot = {
                timestamp: now,
                users: {}
            };

            if (groupData.users && groupData.points) {
                // Sort by points to get rankings
                const rankings = Object.keys(groupData.users).map(userId => ({
                    userId,
                    points: groupData.points[userId] || 0,
                    name: groupData.users[userId]?.name || 'Player'
                })).sort((a, b) => b.points - a.points);

                rankings.forEach((user, index) => {
                    currentSnapshot.users[user.userId] = {
                        points: user.points,
                        rank: index + 1,
                        name: user.name
                    };
                });
            }

            // Add current snapshot to history
            historicalData.push(currentSnapshot);

            // Keep only last 5 days of data
            const fiveDays = TOURNAMENT_RETENTION_MS
            historicalData = historicalData.filter(entry => now - entry.timestamp < fiveDays);

            // Save updated historical data
            try {
                localStorage.setItem('hwh_power_tournament_history', JSON.stringify(historicalData));
                if (!silent) debugLog(`‚úÖ ToP data refreshed: ${Object.keys(currentSnapshot.users).length} players, ${historicalData.length} total snapshots`);
            } catch (e) {
                console.error('Error saving ToP historical data:', e);
                return false;
            }

            // Track last successful refresh
            window._topLastRefresh = Date.now();

            // If tournament ended, stop auto-refresh and update dock
            if (window._tournamentEnded) {
                if (window._tournamentAutoRefresh) {
                    if (window._tournamentAutoRefresh.timer) {
                        clearInterval(window._tournamentAutoRefresh.timer);
                        window._tournamentAutoRefresh.timer = null;
                    }
                    if (window._tournamentAutoRefresh.timeout) {
                        clearTimeout(window._tournamentAutoRefresh.timeout);
                        window._tournamentAutoRefresh.timeout = null;
                    }
                    window._tournamentAutoRefresh.interval = 0;
                }
                // Update dock
                const dock = DOMCache.get('tournamentDock', '#tournament-dock');
                if (dock) {
                    dock.style.borderColor = '#ff6b6b';
                    const dockStatus = DOMCache.get('dockRefreshStatus', '#dock-refresh-status');
                    if (dockStatus) {
                        const endTime = window._tournamentEndTime
                        ? new Date(window._tournamentEndTime).toLocaleTimeString([], {hour: 'numeric', minute: '2-digit'})
                        : '';
                        dockStatus.textContent = 'üèÅ Ended' + (endTime ? ' ' + endTime : '');
                        dockStatus.style.color = '#ff6b6b';
                    }
                }
            }
            return true;
        } catch (error) {
            if (!silent) console.error('Error in refreshPowerTournamentData:', error);
            return false;
        }
    };
    // Docked tournament summary bar at bottom of screen - aligned to game
    window.showTournamentDock = function(userRankings) {
        // Remove existing dock
        const existing = document.getElementById('tournament-dock');
        if (existing) existing.remove();

        if (!userRankings || userRankings.length === 0) return;

        // Find game container to align with (try canvas first, then fallback)
        const gameCanvas = DOMCache.get('gameCanvas', 'canvas');
        const scriptMenu = document.querySelector('.scriptMenu_scriptMenu');
        let dockLeft = '50%';
        let dockTransform = 'translateX(-50%)';
        let dockWidth = '800px';

        if (gameCanvas) {
            const rect = gameCanvas.getBoundingClientRect();
            dockLeft = rect.left + 'px';
            dockTransform = 'none';
            dockWidth = rect.width + 'px';
        } else if (scriptMenu) {
            const rect = scriptMenu.getBoundingClientRect();
            dockLeft = rect.left + 'px';
            dockTransform = 'none';
            dockWidth = rect.width + 'px';
        }

        const dock = document.createElement('div');
        dock.id = 'tournament-dock';
        const dockBorderColor = window._tournamentEnded ? '#ff6b6b' : '#8b6914';
        dock.style.cssText = `
    position: fixed; bottom: 0; left: ${dockLeft}; transform: ${dockTransform};
    width: ${dockWidth}; height: 28px; background: rgba(42,24,16,0.95);
    border: 1px solid ${dockBorderColor};
            z-index: 9999; display: flex; align-items: center; justify-content: space-between;
            padding: 0 10px; font-family: Arial, sans-serif; font-size: 12px;
            box-shadow: 0 -2px 8px rgba(0,0,0,0.3); transition: border-color 0.3s;
            box-sizing: border-box;
        `;

        // Build summary - top 10 players
        const top10 = userRankings.slice(0, 10);
        let summaryHTML = '<div style="display: flex; gap: 12px; align-items: center; overflow: hidden; flex: 1;">';
        summaryHTML += '<span class="twk-gold-bold">üèÜ</span>';

        top10.forEach((user, i) => {
            let pts;
            if (user.points > 999999) pts = (user.points/1000000).toFixed(1) + 'M';
            else if (user.points > 999) pts = (user.points/1000).toFixed(0) + 'K';
            else pts = user.points;

            const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${i+1}.`;
            const color = i < 3 ? '#ffd700' : '#ccc';
            summaryHTML += `<span style="color: ${color}; white-space: nowrap;">${medal} ${user.name.substring(0,8)} <span class="twk-green">${pts}</span></span>`;
        });
        summaryHTML += '</div>';

        // Right side: status + close
        summaryHTML += '<div style="display: flex; align-items: center; gap: 8px;">';
        const dockEndTime = window._tournamentEndTime
        ? new Date(window._tournamentEndTime).toLocaleTimeString([], {hour: 'numeric', minute: '2-digit'})
        : '';
        const dockStatusText = window._tournamentEnded
        ? 'üèÅ Ended' + (dockEndTime ? ' ' + dockEndTime : '')
        : new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const dockStatusColor = window._tournamentEnded ? '#ff6b6b' : '#999';
        summaryHTML += `<span id="dock-refresh-status" style="color: ${dockStatusColor}; font-size: 11px; padding: 0 8px;">${dockStatusText}</span>`;
        summaryHTML += '<button id="close-tournament-dock" style="background: transparent; border: none; color: #666; cursor: pointer; font-size: 14px; padding: 2px 6px;">‚úï</button>';
        summaryHTML += '</div>';

        dock.innerHTML = summaryHTML;
        document.body.appendChild(dock);

        // Reposition on window resize
        const repositionDock = () => {
            const canvas = DOMCache.get('gameCanvas', 'canvas');
            if (canvas && dock) {
                const rect = canvas.getBoundingClientRect();
                dock.style.left = rect.left + 'px';
                dock.style.width = rect.width + 'px';
                dock.style.transform = 'none';
            }
        };
        window.addEventListener('resize', repositionDock);

        document.getElementById('close-tournament-dock').addEventListener('click', (e) => {
            e.stopPropagation();
            window.removeEventListener('resize', repositionDock);
            dock.remove();
            DOMCache.clear('tournamentDock');
            DOMCache.clear('dockRefreshStatus');
            // Stop auto-refresh when dock is closed
            if (window._tournamentAutoRefresh) {
                if (window._tournamentAutoRefresh.timer) {
                    clearInterval(window._tournamentAutoRefresh.timer);
                    window._tournamentAutoRefresh.timer = null;
                }
                if (window._tournamentAutoRefresh.timeout) {
                    clearTimeout(window._tournamentAutoRefresh.timeout);
                    window._tournamentAutoRefresh.timeout = null;
                }
                window._tournamentAutoRefresh.interval = 0;
            }
        });

        // Click dock to open full popup
        dock.addEventListener('click', (e) => {
            if (e.target.id !== 'close-tournament-dock') {
                window.goPowerTournament();
            }
        });
    };
    window.hideTournamentDock = function() {
        const dock = DOMCache.get('tournamentDock', '#tournament-dock');
        if (dock) {
            dock.remove();
            DOMCache.clear('tournamentDock');
            DOMCache.clear('dockRefreshStatus');
        }
    };

    // ===== TOP STATUS BAR =====
    window.showTopStatusBar = async function() {
        const existing = document.getElementById('hwh-top-statusbar');
        if (existing) existing.remove();
        if (window._tsbTimer) clearInterval(window._tsbTimer);
        if (window._tsbRefresh) clearInterval(window._tsbRefresh);
        if (window._tsbResizeHandler) window.removeEventListener('resize', window._tsbResizeHandler);

        const gameCanvas = DOMCache.get('gameCanvas', 'canvas');
        let barLeft = '50%';
        let barTransform = 'translateX(-50%)';
        let barWidth = '800px';

        if (gameCanvas) {
            const rect = gameCanvas.getBoundingClientRect();
            barLeft = rect.left + 'px';
            barTransform = 'none';
            barWidth = rect.width + 'px';
        }

        const bar = document.createElement('div');
        bar.id = 'hwh-top-statusbar';
        bar.style.cssText = `
            position: fixed; top: 0; left: ${barLeft}; transform: ${barTransform};
            width: ${barWidth}; height: 28px; background: rgba(42,24,16,0.95);
            border: 1px solid #8b6914; border-top: none;
            z-index: 9990; display: flex; align-items: center; justify-content: space-between;
            padding: 0 10px; font-family: Arial, sans-serif; font-size: 11px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3); box-sizing: border-box;
        `;

        bar.innerHTML = `
            <div id="tsb-content" style="display: flex; gap: 15px; align-items: center; flex: 1; color: #ccc;">
                <span style="color: #666;">Loading...</span>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
                <span id="tsb-lastrefresh" style="color: #666; font-size: 10px;">‚Äî</span>
                <button id="tsb-close" style="background: transparent; border: none; color: #666; cursor: pointer; font-size: 14px; padding: 2px 6px;">‚úï</button>
            </div>
        `;

        document.body.appendChild(bar);

        // Reposition on window resize - same as tournament dock
        window._tsbResizeHandler = () => {
            const canvas = DOMCache.get('gameCanvas', 'canvas');
            if (canvas && bar) {
                const rect = canvas.getBoundingClientRect();
                bar.style.left = rect.left + 'px';
                bar.style.width = rect.width + 'px';
                bar.style.transform = 'none';
            }
        };
        window.addEventListener('resize', window._tsbResizeHandler);

        document.getElementById('tsb-close').onclick = (e) => {
            e.stopPropagation();
            window.removeEventListener('resize', window._tsbResizeHandler);
            bar.remove();
            if (window._tsbTimer) clearInterval(window._tsbTimer);
            if (window._tsbRefresh) clearInterval(window._tsbRefresh);
        };

        await updateTopStatusBar();

        // Update timers every second
        window._tsbTimer = setInterval(updateTopStatusBarTimers, 1000);

        // Refresh API data every 5 minutes
        window._tsbRefresh = setInterval(async () => {
            if (document.hidden) {
                debugLog('‚è∏Ô∏è Top status bar refresh skipped - tab hidden');
                return;
            }
            const bar = document.getElementById('hwh-top-statusbar');
            if (!bar) {
                clearInterval(window._tsbRefresh);
                return;
            }
            await updateTopStatusBar();
        }, 5 * 60 * 1000);
    };

    window.hideTopStatusBar = function() {
        const bar = document.getElementById('hwh-top-statusbar');
        if (bar) bar.remove();
        if (window._tsbTimer) clearInterval(window._tsbTimer);
        if (window._tsbRefresh) clearInterval(window._tsbRefresh);
        if (window._tsbResizeHandler) window.removeEventListener('resize', window._tsbResizeHandler);
    };

    window._tsbCache = {};

    async function updateTopStatusBar() {
        try {
            const SendFunction = getSend();
            const response = await SendFunction(JSON.stringify({
                calls: [
                    { name: "arenaGetAll", args: {}, ident: "arena" },
                    { name: "clanWarGetBriefInfo", args: {}, ident: "gw" },
                    { name: "crossClanWar_getBriefInfo", args: {}, ident: "cow" },
                    { name: "clanRaid_getInfo", args: {}, ident: "asgard" },
                    { name: "questGetEvents", args: {}, ident: "events" },
                    { name: "questGetAll", args: {}, ident: "quests" }
                ]
            }));

            const r = {};
            response?.results?.forEach(x => { r[x.ident] = x.result?.response; });

            const c = window._tsbCache;
            c.arenaPlace = r.arena?.arenaPlace || '?';
            c.grandPlace = r.arena?.grandPlace || '?';
            c.rewardTime = r.arena?.rewardTime || 0;

            c.gwActive = r.gw?.hasActiveWar;
            c.gwTries = r.gw?.tries || 0;
            c.gwEnd = r.gw?.nearestWarEndTime || 0;

            c.cowActive = r.cow?.hasActiveWar;
            c.cowHero = r.cow?.heroTries || 0;
            c.cowTitan = r.cow?.titanTries || 0;
            c.cowEnd = r.cow?.endTime || 0;

            c.asgardEnd = r.asgard?.boss?.timestamps?.end || 0;
            c.asgardLevel = r.asgard?.boss?.level || 0;

            const events = r.events || [];
            const now = Date.now() / 1000;
            const activeEvents = events.filter(e => e.endTime > now).sort((a, b) => a.endTime - b.endTime);
            if (activeEvents[0]) {
                c.eventName = cheats?.translate(activeEvents[0].name_localeKey) || 'Event';
                c.eventEnd = activeEvents[0].endTime || 0;
            }

            c.questTotal = Array.isArray(r.quests) ? r.quests.filter(q => q.state === 1).length : 0;

            // Update last refresh time
            c.lastRefresh = Date.now();
            const refreshEl = document.getElementById('tsb-lastrefresh');
            if (refreshEl) {
                refreshEl.textContent = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                refreshEl.style.color = '#4ae29a';
                setTimeout(() => { refreshEl.style.color = '#666'; }, 1500);
            }

            updateTopStatusBarTimers();
        } catch (e) {
            console.error('Top status bar error:', e);
        }
    }

    function updateTopStatusBarTimers() {
        const content = document.getElementById('tsb-content');
        if (!content) return;

        const c = window._tsbCache;
        const now = Math.floor(Date.now() / 1000);

        const fmt = (secs) => {
            if (secs <= 0) return '‚Äî';
            if (secs < 3600) return Math.floor(secs / 60) + 'm';
            if (secs < 86400) return Math.floor(secs / 3600) + 'h' + (Math.floor((secs % 3600) / 60) + '').padStart(2, '0') + 'm';
            return Math.floor(secs / 86400) + 'd' + Math.floor((secs % 86400) / 3600) + 'h';
        };

        const click = 'cursor:pointer;';
        let html = '';
        const arenaTime = fmt(c.rewardTime - now);

        // Arena/Grand - clickable
        html += `<span style="${click}" onclick="cheats.goNavigtor('ARENA')">‚öîÔ∏è A:<span class="twk-gold">#${c.arenaPlace}</span> <span class="twk-muted">${arenaTime}</span></span>`;
        html += `<span style="${click}" onclick="cheats.goNavigtor('GRAND')">G:<span class="twk-gold">#${c.grandPlace}</span> <span class="twk-muted">${arenaTime}</span></span>`;

        // GW
        if (c.gwActive) {
            html += `<span style="${click}" onclick="cheats.goNavigtor('CLAN_PVP')">üè∞ GW:<span class="twk-green">${c.gwTries}</span> <span class="twk-muted">${fmt(c.gwEnd - now)}</span></span>`;
        } else {
            html += `<span style="color:#666;${click}" onclick="cheats.goNavigtor('CLAN_PVP')">üè∞ GW:‚Äî</span>`;
        }

        // CoW
        if (c.cowActive) {
            html += `<span style="${click}" onclick="cheats.goNavigtor('CLAN_GLOBAL_PVP')">üåç CoW:H<span class="twk-green">${c.cowHero}</span>/T<span class="twk-green">${c.cowTitan}</span> <span class="twk-muted">${fmt(c.cowEnd - now)}</span></span>`;
        } else {
            html += `<span style="color:#666;${click}" onclick="cheats.goNavigtor('CLAN_GLOBAL_PVP')">üåç CoW:‚Äî</span>`;
        }

        // Asgard
        if (c.asgardEnd > now) {
            const bossName = c.asgardLevel >= 100 ? 'Maes' : 'Osh';
            html += `<span style="${click}" onclick="cheats.goNavigtor('CLAN_RAID')">üêâ ${bossName} <span class="twk-muted">${fmt(c.asgardEnd - now)}</span></span>`;
        } else {
            html += `<span style="color:#666;${click}" onclick="cheats.goNavigtor('CLAN_RAID')">üêâ Asgard:‚Äî</span>`;
        }

        // Event
        if (c.eventEnd > now) {
            const name = (c.eventName || 'Event').substring(0, 12);
            html += `<span style="${click}" onclick="window.goSpecialEvents()">üéØ <span class="twk-gold">${name}</span> <span class="twk-muted">${fmt(c.eventEnd - now)}</span></span>`;
        }

        // Quests
        if (c.questTotal > 0) {
            html += `<span style="${click}" onclick="window.goSpecialEvents()">üìã <span class="twk-orange">${c.questTotal}</span></span>`;
        }

        content.innerHTML = html;
    }
    ModuleTracker.register('Top Status Bar');

    // Initialize top status bar when game ready
    waitForGameReady().then(() => {
        window.showTopStatusBar();
    });


    // Placeholder for second stats function
    window.goStats2 = function() {
        // For now, also opens Power Tournament
        window.goPowerTournament();
    };



    // Function to open Special Events popup
    window.goSpecialEvents = function() {
        try {
            let player = getPlayer();
            let specialQuestMediator = selfGame['game.view.popup.activity.SpecialQuestEventPopupMediator'];
            new specialQuestMediator(player).open();
            debugLog('Opened Special Events');
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('Opened Special Events', true);
            }
        } catch (e) {
            console.error('Failed to open Special Events:', e);
        }
    };
    window.goPets = async function() {
        try {
            cheats.goNavigtor('PET_LIST');
        } catch (e) {
            console.error('Failed to handle Merchant:', e);
        }
    };
    // ===================================================================
    // COMPLETE CASTLE SYSTEM - ALL FUNCTIONS INCLUDED
    // ===================================================================

    // Manual database update functions - LOADED IMMEDIATELY
    window.batchUpdateCastle = function(userArray) {
        let userData = JSON.parse(localStorage.getItem('hwh_castle_user_exp')) || {};
        let updated = 0;

        userArray.forEach(([userId, userExp]) => {
            userData[userId] = { userExp: parseInt(userExp), lastUpdated: new Date().toISOString() };
            updated++;
        });

        localStorage.setItem('hwh_castle_user_exp', JSON.stringify(userData));
        debugLog(`‚úÖ Batch updated ${updated} users`);
        return userData;
    };

    window.updateCastleUser = function(userId, userExp) {
        let userData = JSON.parse(localStorage.getItem('hwh_castle_user_exp')) || {};
        userData[userId] = { userExp: parseInt(userExp), lastUpdated: new Date().toISOString() };
        localStorage.setItem('hwh_castle_user_exp', JSON.stringify(userData));
        debugLog(`‚úÖ Updated user ${userId} with userExp ${userExp}`);
        return userData;
    };

    window.viewCastleData = function() {
        const userData = JSON.parse(localStorage.getItem('hwh_castle_user_exp')) || {};
        console.table(userData);
        return userData;
    };

    window.clearCastleData = function() {
        localStorage.removeItem('hwh_castle_user_exp');
        debugLog('üóëÔ∏è Castle database cleared');
    };

    // Username system - LOADS FROM DATABASE ONLY (NO HARDCODED DATA)
    window.castleUserNames = {};

    window.getCastleUsername = function(userId) {
        return window.castleUserNames[userId] || `User ${userId}`;
    };

    window.editCastleExp = function(userId, currentExp) {
        try {
            const username = window.getCastleUsername ? window.getCastleUsername(userId) : `User ${userId}`;
            const newExp = prompt(`Edit experience for ${username}:\nCurrent: ${currentExp.toLocaleString()}`, currentExp);

            if (newExp === null) {
                // User cancelled
                return;
            }

            const parsedExp = parseInt(newExp);

            if (isNaN(parsedExp) || parsedExp < 0) {
                alert('Please enter a valid positive number');
                return;
            }

            // Use existing updateCastleUser function with confirmation for decreases
            const result = window.updateCastleUser(userId, parsedExp);

            if (result !== false) {
                // Refresh the popup to show changes
                setTimeout(() => {
                    window.showCastleUserExpPopup();
                }, 200);

                debugLog(`‚úÖ Updated ${username} (${userId}) experience: ${currentExp} ‚Üí ${parsedExp}`);

                if (HWHFuncs && HWHFuncs.setProgress) {
                    HWHFuncs.setProgress(`‚úÖ Updated ${username} experience to ${parsedExp.toLocaleString()}`, false);
                }
            }

        } catch (error) {
            console.error('Error editing castle experience:', error);
            alert('Error updating experience: ' + error.message);
        }
    };

    window.setCastleUsername = function(userId, username) {
        window.castleUserNames[userId] = username;
        localStorage.setItem('hwh_castle_usernames', JSON.stringify(window.castleUserNames));
        debugLog(`‚úÖ Set username for ${userId}: ${username}`);
    };

    // Batch username update function
    window.batchUpdateUsernames = function(usernameArray) {
        let updated = 0;

        usernameArray.forEach(([userId, username]) => {
            window.castleUserNames[userId] = username;
            updated++;
        });

        localStorage.setItem('hwh_castle_usernames', JSON.stringify(window.castleUserNames));
        debugLog(`‚úÖ Batch updated ${updated} usernames`);
        return window.castleUserNames;
    };

    // Function to view all current usernames
    window.viewCastleUsernames = function() {
        console.table(window.castleUserNames);
        return window.castleUserNames;
    };

    // Function to add new guild members to the master list
    window.addNewGuildMembers = function(newMembersObject) {
        window.castleUserNames = { ...window.castleUserNames, ...newMembersObject };
        localStorage.setItem('hwh_castle_usernames', JSON.stringify(window.castleUserNames));
        debugLog(`‚úÖ Added ${Object.keys(newMembersObject).length} new guild members`);
        return window.castleUserNames;
    };

    window.importGuildUsernames = function() {
        // Now just saves whatever is already loaded
        localStorage.setItem('hwh_castle_usernames', JSON.stringify(window.castleUserNames));
        debugLog(`‚úÖ Saved ${Object.keys(window.castleUserNames).length} usernames to database!`);
        return window.castleUserNames;
    };

    // Load usernames from localStorage ONLY
    try {
        const savedNames = localStorage.getItem('hwh_castle_usernames');
        if (savedNames) {
            window.castleUserNames = JSON.parse(savedNames);
            debugLog(`‚úÖ Loaded ${Object.keys(window.castleUserNames).length} usernames from database`);
        } else {
            debugLog('‚ÑπÔ∏è No usernames in database - use Update Usernames to add them');
        }
    } catch (e) {
        console.warn('Could not load saved usernames:', e);
        window.castleUserNames = {};
    }

    // ===================================================================
    // COMPLETE CASTLE SYSTEM - ALL FUNCTIONS INCLUDED
    // ===================================================================

    // Manual database update functions - LOADED IMMEDIATELY
    window.batchUpdateCastle = function(userArray) {
        let userData = JSON.parse(localStorage.getItem('hwh_castle_user_exp')) || {};
        let updated = 0;
        let warnings = [];

        userArray.forEach(([userId, userExp]) => {
            const newExp = parseInt(userExp);
            const currentExp = userData[userId]?.userExp || 0;

            // Check for decreases
            if (currentExp > 0 && newExp < currentExp) {
                warnings.push(`‚ö†Ô∏è ${userId}: ${currentExp} ‚Üí ${newExp} (DECREASE of ${currentExp - newExp})`);
            }

            userData[userId] = { userExp: newExp, lastUpdated: new Date().toISOString() };
            updated++;
        });

        // Show confirmation if there are decreases
        if (warnings.length > 0) {
            const warningMsg = `Found ${warnings.length} DECREASES:\n\n${warnings.join('\n')}\n\nDo you want to continue anyway?`;
            if (!confirm(warningMsg)) {
                debugLog('‚ùå Batch update cancelled due to decreases');
                return false;
            }
        }

        localStorage.setItem('hwh_castle_user_exp', JSON.stringify(userData));
        debugLog(`‚úÖ Batch updated ${updated} users`);
        if (warnings.length > 0) {
            console.warn(`‚ö†Ô∏è Applied ${warnings.length} decreases after confirmation`);
        }
        return userData;
    };

    window.updateCastleUser = function(userId, userExp) {
        let userData = JSON.parse(localStorage.getItem('hwh_castle_user_exp')) || {};
        const newExp = parseInt(userExp);
        const currentExp = userData[userId]?.userExp || 0;

        // Check for decreases
        if (currentExp > 0 && newExp < currentExp) {
            const decrease = currentExp - newExp;
            if (!confirm(`‚ö†Ô∏è DECREASE detected for ${userId}:\n${currentExp} ‚Üí ${newExp} (decrease of ${decrease})\n\nContinue anyway?`)) {
                debugLog(`‚ùå Update cancelled for ${userId}`);
                return false;
            }
        }

        userData[userId] = { userExp: newExp, lastUpdated: new Date().toISOString() };
        localStorage.setItem('hwh_castle_user_exp', JSON.stringify(userData));
        debugLog(`‚úÖ Updated user ${userId} with userExp ${userExp}`);
        return userData;
    };

    window.viewCastleData = function() {
        const userData = JSON.parse(localStorage.getItem('hwh_castle_user_exp')) || {};
        console.table(userData);
        return userData;
    };

    window.clearCastleData = function() {
        localStorage.removeItem('hwh_castle_user_exp');
        debugLog('üóëÔ∏è Castle database cleared');
    };

    // Username system - LOADS FROM DATABASE ONLY (NO HARDCODED DATA)
    window.castleUserNames = {};

    window.getCastleUsername = function(userId) {
        return window.castleUserNames[userId] || `User ${userId}`;
    };

    window.setCastleUsername = function(userId, username) {
        window.castleUserNames[userId] = username;
        localStorage.setItem('hwh_castle_usernames', JSON.stringify(window.castleUserNames));
        debugLog(`‚úÖ Set username for ${userId}: ${username}`);
    };

    // Batch username update function
    window.batchUpdateUsernames = function(usernameArray) {
        let updated = 0;

        usernameArray.forEach(([userId, username]) => {
            window.castleUserNames[userId] = username;
            updated++;
        });

        localStorage.setItem('hwh_castle_usernames', JSON.stringify(window.castleUserNames));
        debugLog(`‚úÖ Batch updated ${updated} usernames`);
        return window.castleUserNames;
    };

    // Function to view all current usernames
    window.viewCastleUsernames = function() {
        console.table(window.castleUserNames);
        return window.castleUserNames;
    };

    // Function to add new guild members to the master list
    window.addNewGuildMembers = function(newMembersObject) {
        window.castleUserNames = { ...window.castleUserNames, ...newMembersObject };
        localStorage.setItem('hwh_castle_usernames', JSON.stringify(window.castleUserNames));
        debugLog(`‚úÖ Added ${Object.keys(newMembersObject).length} new guild members`);
        return window.castleUserNames;
    };

    window.importGuildUsernames = function() {
        // Now just saves whatever is already loaded
        localStorage.setItem('hwh_castle_usernames', JSON.stringify(window.castleUserNames));
        debugLog(`‚úÖ Saved ${Object.keys(window.castleUserNames).length} usernames to database!`);
        return window.castleUserNames;
    };

    // Load usernames from localStorage ONLY
    try {
        const savedNames = localStorage.getItem('hwh_castle_usernames');
        if (savedNames) {
            window.castleUserNames = JSON.parse(savedNames);
            debugLog(`‚úÖ Loaded ${Object.keys(window.castleUserNames).length} usernames from database`);
        } else {
            debugLog('‚ÑπÔ∏è No usernames in database - use Auto-Update Guild Names to load them');
        }
    } catch (e) {
        console.warn('Could not load saved usernames:', e);
        window.castleUserNames = {};
    }

    // Function to format castle upgrade messages into batchUpdateCastle format
    window.formatCastleMessages = function(messages) {
        const userExpMap = new Map();
        const results = [];

        messages.forEach(msg => {
            // Parse the message if it's a string
            let data;
            if (typeof msg === 'string') {
                try {
                    data = JSON.parse(msg);
                } catch (e) {
                    console.warn('Could not parse message:', msg);
                    return;
                }
            } else {
                data = msg;
            }

            // Extract castle upgrade data
            if (data && data.result && data.result.body &&
                data.result.body.userId && data.result.body.userExp !== undefined) {

                const userId = data.result.body.userId;
                const userExp = data.result.body.userExp;

                // Store the latest experience for each user
                userExpMap.set(userId, userExp);

                debugLog(`üìä Found: User ${userId} = ${userExp} exp`);
            }
        });

        // Convert to array format
        userExpMap.forEach((exp, userId) => {
            results.push([userId, exp]);
        });

        // Generate the batchUpdateCastle command
        if (results.length > 0) {
            const batchCommand = `batchUpdateCastle([\n${results.map(([id, exp]) =>
                                                                     `    ["${id}", ${exp}]`).join(',\n')}\n]);`;

            debugLog('üìã Copy this command:');
            debugLog(batchCommand);

            // Copy to clipboard if possible
            if (navigator.clipboard) {
                navigator.clipboard.writeText(batchCommand).then(() => {
                    debugLog('‚úÖ Command copied to clipboard!');
                }).catch(err => {
                    debugLog('Could not copy to clipboard:', err);
                });
            }

            return batchCommand;
        } else {
            debugLog('No castle upgrade data found in messages');
            return null;
        }
    };

    // Function to extract data from your specific message format
    window.extractFromCastleMessages = function(messageStrings) {
        const results = [];

        messageStrings.forEach(msgStr => {
            // Look for the pattern: "userId":"271418174" and "userExp":41543
            const userIdMatch = msgStr.match(/"userId":"(\d+)"/);
            const userExpMatch = msgStr.match(/"userExp":(\d+)/);

            if (userIdMatch && userExpMatch) {
                const userId = userIdMatch[1];
                const userExp = parseInt(userExpMatch[1]);

                // Add or update the user's experience
                const existingIndex = results.findIndex(([id, _]) => id === userId);
                if (existingIndex >= 0) {
                    results[existingIndex][1] = userExp; // Update with latest value
                } else {
                    results.push([userId, userExp]);
                }
            }
        });

        if (results.length > 0) {
            const batchCommand = `batchUpdateCastle([\n${results.map(([id, exp]) =>
                                                                     `    ["${id}", ${exp}]`).join(',\n')}\n]);`;

            debugLog('üìã Extracted batch command:');
            debugLog(batchCommand);

            return batchCommand;
        }

        return null;
    };

    // ===================================================================
    // AUTO-UPDATE GUILD MEMBERS SYSTEM
    // ===================================================================

    // Function to automatically fetch and update guild member usernames
    window.updateGuildMembersFromAPI = async function() {
        try {
            debugLog('üîç Fetching guild member data...');
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('üîç Fetching guild member data...', false);
            }

            const SendFunction = getSend();

            const response = await SendFunction('{"calls":[{"name":"clanGetInfo","args":{},"context":{"actionTs":' + Date.now() + '},"ident":"group_0_body"},{"name":"clanGetOnline","args":{},"context":{"actionTs":' + (Date.now() + 1) + '},"ident":"group_1_body"}]}');

            if (response && response.results && response.results[0] && response.results[0].result.response.clan.members) {
                const members = response.results[0].result.response.clan.members;
                debugLog('üë• Found members:', Object.keys(members).length);

                const memberEntries = [];

                Object.entries(members).forEach(([userId, memberData]) => {
                    memberEntries.push([userId, memberData.name]);
                });

                // Execute the batch update
                if (typeof window.batchUpdateUsernames === 'function') {
                    debugLog('‚úÖ Executing batch update for', memberEntries.length, 'members...');
                    const result = window.batchUpdateUsernames(memberEntries);

                    if (HWHFuncs && HWHFuncs.setProgress) {
                        HWHFuncs.setProgress(`‚úÖ Updated ${memberEntries.length} guild member usernames!`, false);
                    }

                    debugLog(`‚úÖ Successfully updated ${memberEntries.length} guild members`);
                    return result;
                } else {
                    console.error('‚ùå batchUpdateUsernames function not found');
                    if (HWHFuncs && HWHFuncs.setProgress) {
                        HWHFuncs.setProgress('‚ùå batchUpdateUsernames function not found', true);
                    }
                    return false;
                }

            } else {
                console.error('‚ùå Could not find member data in response');
                if (HWHFuncs && HWHFuncs.setProgress) {
                    HWHFuncs.setProgress('‚ùå Could not fetch guild member data', true);
                }
                return false;
            }

        } catch (error) {
            console.error('‚ùå Error updating guild members:', error);
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress(`‚ùå Error updating guild members: ${error.message}`, true);
            }
            return false;
        }
    };

    ModuleTracker.register('Castle Functions');

    // ===================================================================
    // AOC LIVE API FUNCTIONS - OPTION 2 (LIVE ONLY)
    // ===================================================================
    // Fetch live castle data from API
    window.fetchLiveCastleData = async function() {
        try {
            const SendFunction = getSend();

            const response = await SendFunction(JSON.stringify({
                calls: [
                    {
                        name: "clanDomination_mapState",
                        args: {},
                        context: { actionTs: Date.now() },
                        ident: "body"
                    },
                    {
                        name: "clanCastle_getInfo",
                        args: {},
                        context: { actionTs: Date.now() + 1 },
                        ident: "clanCastle_getInfo"
                    },
                    {
                        name: "clanDomination_stats",
                        args: {},
                        context: { actionTs: Date.now() + 2 },
                        ident: "clanDomination_stats"
                    },
                    {
                        name: "clanDomination_passiveQueueReward",
                        args: {},
                        context: { actionTs: Date.now() + 3 },
                        ident: "clanDomination_passiveQueueReward"
                    },
                    {
                        name: "clanDomination_getInfo",
                        args: {},
                        context: { actionTs: Date.now() + 4 },
                        ident: "clanDomination_getInfo"
                    }
                ]
            }));

            if (!response?.results) {
                throw new Error('Invalid response from server');
            }

            return {
                mapState: response.results[0]?.result?.response,
                castleInfo: response.results[1]?.result?.response,
                dominationStats: response.results[2]?.result?.response,
                passiveReward: response.results[3]?.result?.response,
                eventInfo: response.results[4]?.result?.response
            };
        } catch (error) {
            // Return null instead of throwing - event likely ended
            return null;
        }
    };
    window.showAoCStatsUnified = async function() {
        try {
            // Global auto-refresh state for AoC
            if (!window._aocAutoRefresh) {
                const savedInterval = parseInt(localStorage.getItem('hwh_aoc_refresh_interval')) || 15;
                window._aocAutoRefresh = {
                    timer: null,
                    interval: savedInterval,
                    lastRefresh: null
                };
                const aocRefreshFn = async () => {
                    if (document.hidden) return; // Skip if tab hidden
                    window.showAoCDock(null);
                    debugLog('üè∞ AoC auto-refreshed (dock only)');
                    const idleTime = Date.now() - (window._lastActivity || Date.now());
                    if (idleTime > 60000) {
                        await sendAoCStatusNotification();
                    }
                };
                window._aocAutoRefresh.timer = setInterval(aocRefreshFn, savedInterval * 60 * 1000);
                window._aocAutoRefresh.lastRefresh = Date.now();
            }


            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('üìä Loading AoC stats...', false);
            }

            const liveData = await window.fetchLiveCastleData();
            if (!liveData) {
                // Event ended or API failed - show historical data
                throw new Error('AoC event not active');
            }
            const SendFunction = getSend();
            const guildResponse = await SendFunction(JSON.stringify({
                calls: [{
                    name: "clanGetInfo",
                    args: {},
                    context: { actionTs: Date.now() },
                    ident: "body"
                }]
            }));

            // Attach guild members to liveData
            liveData.guildMembers = guildResponse?.results?.[0]?.result?.response?.clan?.members || {};

            // Save castle/contributor data for when event ends
            localStorage.setItem('hwh_aoc_last_castle', JSON.stringify({
                timestamp: Date.now(),
                castleInfo: liveData.castleInfo,
                guildMembers: liveData.guildMembers
            }));

            displayUnifiedAoCWindow(liveData);

            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('‚úÖ AoC stats loaded', 3000);
            }

        } catch (error) {
            // Silently handle - likely event ended

            // Try to show last saved data when event is over
            try {
                // STOP all auto-refresh when event ended
                if (window._aocAutoRefresh?.timer) {
                    clearInterval(window._aocAutoRefresh.timer);
                    window._aocAutoRefresh.timer = null;
                    debugLog('üõë AoC auto-refresh stopped (event ended)');
                }

                const stored = localStorage.getItem('hwh_aoc_history');
                if (stored) {
                    const history = JSON.parse(stored);
                    if (history.length > 0) {
                        const lastEntry = history[history.length - 1];
                        // Build fake liveData from historical snapshot
                        const fakeLiveData = {
                            eventEnded: true,
                            lastTimestamp: lastEntry.timestamp,
                            dominationStats: {},
                            mapState: { clans: {}, townPositions: {} },
                            castleInfo: {
                                points: {},
                                castleLevel: 0,
                                castleExp: 0,
                                levelMaxExp: 0
                            },
                            guildMembers: {}
                        };
                        // Rebuild stats from saved guilds
                        for (const [guildId, guildInfo] of Object.entries(lastEntry.guilds || {})) {
                            fakeLiveData.dominationStats[guildId] = {
                                coins: guildInfo.coins,
                                towns: guildInfo.towns,
                                power: guildInfo.power
                            };
                            fakeLiveData.mapState.clans[guildId] = {
                                title: guildInfo.title
                            };
                        }

                        // Load last castle/contributor data
                        const lastCastle = localStorage.getItem('hwh_aoc_last_castle');
                        if (lastCastle) {
                            const parsed = JSON.parse(lastCastle);
                            fakeLiveData.castleInfo = parsed.castleInfo || fakeLiveData.castleInfo;
                            fakeLiveData.guildMembers = parsed.guildMembers || {};
                        }

                        displayUnifiedAoCWindow(fakeLiveData);
                        if (HWHFuncs && HWHFuncs.setProgress) {
                            HWHFuncs.setProgress('üìä Showing last AoC data (event ended)', 5000);
                        }
                        return;
                    }
                }
            } catch (historyError) {
                console.error('Failed to load AoC history:', historyError);
            }

            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress(`‚ùå Error: ${error.message}`, true);
            }
        }
    };

    // ================================================================
    // MANUAL FETCH VERSION - GAME DATA TABLE
    // This version fetches data on-demand instead of intercepting
    // Replace your existing game data code with this
    // ================================================================

    // Store the data globally
    window.gameLoadData = {
        heroes: null,
        titans: null,
        pets: null,
        flags: null
    };

    // Helper function to get hero/titan/pet name
    function getName(id, type = 'hero') {
        try {
            if (typeof cheats !== 'undefined' && cheats.translate) {
                const name = cheats.translate(`LIB_HERO_NAME_${id}`);
                if (name && !name.startsWith('LIB_HERO_NAME_')) {
                    return name;
                }
            }
        } catch (e) {
            console.warn(`Failed to get name for ${type} ${id}:`, e);
        }
        return `${type.charAt(0).toUpperCase() + type.slice(1)} #${id}`;
    }

    // Export data to clipboard for Google Sheets
    function exportToClipboard(tabName) {
        const { heroes, titans, pets, flags } = window.gameLoadData;
        let data = [];

        if (tabName === 'heroes') {
            data.push(['Name', 'ID', 'Level', 'Color', 'Stars', 'Power', 'XP', 'Pet ID'].join('\t'));
            Object.values(heroes).sort((a, b) => b.power - a.power).forEach(hero => {
                data.push([
                    getName(hero.id, 'hero'),
                    hero.id,
                    hero.level,
                    hero.color,
                    hero.star,
                    hero.power,
                    hero.xp,
                    hero.petId || ''
                ].join('\t'));
            });
        } else if (tabName === 'titans') {
            data.push(['Name', 'ID', 'Level', 'Stars', 'Power', 'XP', 'Perks'].join('\t'));
            Object.values(titans).sort((a, b) => b.power - a.power).forEach(titan => {
                data.push([
                    getName(titan.id, 'titan'),
                    titan.id,
                    titan.level,
                    titan.star,
                    titan.power,
                    titan.xp,
                    (titan.perks || []).join(', ')
                ].join('\t'));
            });
        } else if (tabName === 'pets') {
            data.push(['Name', 'ID', 'Level', 'Color', 'Stars', 'Power', 'XP', 'Perks'].join('\t'));
            pets.sort((a, b) => b.power - a.power).forEach(pet => {
                const colorNames = {8: 'Green', 9: 'Blue', 10: 'Violet'};
                data.push([
                    getName(pet.id, 'pet'),
                    pet.id,
                    pet.level,
                    colorNames[pet.color] || pet.color,
                    pet.star,
                    pet.power,
                    pet.xp,
                    (pet.perks || []).join(', ')
                ].join('\t'));
            });
        } else if (tabName === 'flags') {
            data.push(['Banner', 'Slot', 'Pattern', 'Tier', 'Buff'].join('\t'));
            Object.values(flags).forEach(banner => {
                if (banner.slots) {
                    const bannerName = window.identifyItem?.(banner.id, 'banner') || `Banner ${banner.id}`;
                    if (Array.isArray(banner.slots)) {
                        banner.slots.forEach((slotId, idx) => {
                            const stoneData = lib?.data?.inventoryItem?.bannerStone?.[slotId];
                            const patternName = window.identifyItem?.(slotId, 'bannerStone') || `Pattern ${slotId}`;
                            const level = stoneData?.level !== undefined ? stoneData.level + 1 : '?';
                            const mainBuffId = stoneData?.mainBuffId;
                            const pct = mainBuffId && stoneData?.buffs?.[mainBuffId];
                            const pctStr = pct !== undefined ? (pct > 0 ? `+${pct}%` : `${pct}%`) : '?';
                            data.push([bannerName, idx, patternName, level, pctStr].join('\t'));
                        });
                    } else {
                        Object.entries(banner.slots).forEach(([slotKey, slotId]) => {
                            const stoneData = lib?.data?.inventoryItem?.bannerStone?.[slotId];
                            const patternName = window.identifyItem?.(slotId, 'bannerStone') || `Pattern ${slotId}`;
                            const level = stoneData?.level !== undefined ? stoneData.level + 1 : '?';
                            const mainBuffId = stoneData?.mainBuffId;
                            const pct = mainBuffId && stoneData?.buffs?.[mainBuffId];
                            const pctStr = pct !== undefined ? (pct > 0 ? `+${pct}%` : `${pct}%`) : '?';
                            data.push([bannerName, slotKey, patternName, level, pctStr].join('\t'));
                        });
                    }
                }
            });
        }
        // IMPORTANT: Add the clipboard copy code that was missing
        const text = data.join('\n');
        navigator.clipboard.writeText(text).then(() => {
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('üìã Copied to clipboard! Ready to paste into Google Sheets', true);
            }
            debugLog('‚úÖ Exported data copied to clipboard');
        }).catch(err => {
            console.error('Failed to copy:', err);
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('‚ùå Failed to copy to clipboard', true);
            }
        });
    }

    // Export ALL data to clipboard
    function exportAllToClipboard() {
        const { heroes, titans, pets, flags } = window.gameLoadData;
        let allData = [];

        // HEROES
        allData.push('--- HEROES ---');
        allData.push(['Name', 'ID', 'Level', 'Color', 'Stars', 'Power', 'XP', 'Pet ID', 'Skin', 'Sparks', 'Slots', 'Skins', 'Artifacts', 'Skills', 'Perks', 'Ascensions'].join('\t'));
        Object.values(heroes).sort((a, b) => b.power - a.power).forEach(hero => {
            const slots = Array.isArray(hero.slots) ? hero.slots.join(',') : JSON.stringify(hero.slots);
            const skins = hero.runes ? (Array.isArray(hero.runes) ? hero.runes.join(',') : JSON.stringify(hero.runes)) : '-';
            const artifacts = hero.artifacts ? hero.artifacts.map(a => `L${a.level}‚òÖ${a.star}`).join(', ') : '-';
            const skills = hero.skills ? Object.entries(hero.skills).map(([k,v]) => `${k}:${v}`).join(', ') : '-';
            const perks = Array.isArray(hero.perks) ? hero.perks.join(',') : '-';
            const ascensions = hero.ascensions ? Object.entries(hero.ascensions).map(([k,v]) => `${k}:[${Array.isArray(v) ? v.join(',') : v}]`).join(' | ') : '-';

            allData.push([
                getName(hero.id, 'hero'),
                hero.id,
                hero.level,
                hero.color,
                hero.star,
                hero.power,
                hero.xp,
                hero.petId || '-',
                hero.currentSkin || 0,
                hero.titanGiftLevel || '-',
                slots,
                skins,
                artifacts,
                skills,
                perks,
                ascensions
            ].join('\t'));
        });

        // TITANS
        allData.push('');
        allData.push('--- TITANS ---');
        allData.push(['Name', 'ID', 'Level', 'Stars', 'Power', 'XP', 'Slots', 'Skins', 'Artifacts', 'Skills', 'Perks'].join('\t'));
        Object.values(titans).sort((a, b) => b.power - a.power).forEach(titan => {
            const slots = Array.isArray(titan.slots) ? titan.slots.join(',') : JSON.stringify(titan.slots);
            const skins = titan.runes ? (Array.isArray(titan.runes) ? titan.runes.join(',') : JSON.stringify(titan.runes)) : '-';
            const artifacts = titan.artifacts ? titan.artifacts.map(a => `L${a.level}‚òÖ${a.star}`).join(', ') : '-';
            const skills = titan.skills ? Object.entries(titan.skills).map(([k,v]) => `${k}:${v}`).join(', ') : '-';
            const perks = Array.isArray(titan.perks) ? titan.perks.join(',') : '-';

            allData.push([
                getName(titan.id, 'titan'),
                titan.id,
                titan.level,
                titan.star,
                titan.power,
                titan.xp,
                slots,
                skins,
                artifacts,
                skills,
                perks
            ].join('\t'));
        });

        // PETS
        allData.push('');
        allData.push('--- PETS ---');
        allData.push(['Name', 'ID', 'Level', 'Color', 'Stars', 'Power', 'XP', 'Slots', 'Skills', 'Perks'].join('\t'));
        pets.sort((a, b) => b.power - a.power).forEach(pet => {
            const colorNames = {8: 'Green', 9: 'Blue', 10: 'Violet'};
            const slots = Array.isArray(pet.slots) ? pet.slots.join(',') : JSON.stringify(pet.slots);
            const skills = pet.skills ? Object.entries(pet.skills).map(([k,v]) => `${k}:${v}`).join(', ') : '-';
            const perks = Array.isArray(pet.perks) ? pet.perks.join(',') : '-';

            allData.push([
                getName(pet.id, 'pet'),
                pet.id,
                pet.level,
                colorNames[pet.color] || pet.color,
                pet.star,
                pet.power,
                pet.xp,
                slots,
                skills,
                perks
            ].join('\t'));
        });

        // FLAGS (BANNERS)
        if (flags && Object.keys(flags).length > 0) {
            allData.push('');
            allData.push('--- FLAGS (BANNERS) ---');
            allData.push(['Banner', 'Slot', 'Pattern', 'Tier', 'Buff'].join('\t'));
            Object.values(flags).forEach(banner => {
                if (banner.slots) {
                    const bannerName = window.identifyItem?.(banner.id, 'banner') || `Banner ${banner.id}`;
                    if (Array.isArray(banner.slots)) {
                        banner.slots.forEach((slotId, idx) => {
                            const stoneData = lib?.data?.inventoryItem?.bannerStone?.[slotId];
                            const patternName = window.identifyItem?.(slotId, 'bannerStone') || `Pattern ${slotId}`;
                            const level = stoneData?.level !== undefined ? stoneData.level + 1 : '?';
                            const mainBuffId = stoneData?.mainBuffId;
                            const pct = mainBuffId && stoneData?.buffs?.[mainBuffId];
                            const pctStr = pct !== undefined ? (pct > 0 ? `+${pct}%` : `${pct}%`) : '?';
                            allData.push([bannerName, idx, patternName, level, pctStr].join('\t'));
                        });
                    } else {
                        Object.entries(banner.slots).forEach(([slotKey, slotId]) => {
                            const stoneData = lib?.data?.inventoryItem?.bannerStone?.[slotId];
                            const patternName = window.identifyItem?.(slotId, 'bannerStone') || `Pattern ${slotId}`;
                            const level = stoneData?.level !== undefined ? stoneData.level + 1 : '?';
                            const mainBuffId = stoneData?.mainBuffId;
                            const pct = mainBuffId && stoneData?.buffs?.[mainBuffId];
                            const pctStr = pct !== undefined ? (pct > 0 ? `+${pct}%` : `${pct}%`) : '?';
                            allData.push([bannerName, slotKey, patternName, level, pctStr].join('\t'));
                        });
                    }
                }
            });
        }

        const text = allData.join('\n');
        navigator.clipboard.writeText(text).then(() => {
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('üìã All data copied to clipboard! Ready to paste into Google Sheets', true);
            }
            debugLog('‚úÖ All data exported to clipboard');
        }).catch(err => {
            console.error('Failed to copy:', err);
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('‚ùå Failed to copy to clipboard', true);
            }
        });
    }

    // Function to manually fetch the data
    // Find the fetchGameData function and replace the Send call with:
    async function fetchGameData() {
        try {
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('üìä Loading game data...', false);
            }

            const response = await Send({
                calls: [
                    { name: 'heroGetAll', args: {}, ident: 'heroGetAll' },
                    { name: 'titanGetAll', args: {}, ident: 'titanGetAll' },
                    { name: 'pet_getAll', args: {}, ident: 'pet_getAll' },
                    { name: 'banner_getAll', args: {}, ident: 'banner_getAll' }  // ADD THIS LINE
                ]
            });

            if (response && response.results) {
                response.results.forEach(result => {
                    if (result.ident === 'heroGetAll' && result.result && result.result.response) {
                        window.gameLoadData.heroes = result.result.response;
                        debugLog('‚úÖ Loaded hero data:', Object.keys(result.result.response).length, 'heroes');
                    }
                    if (result.ident === 'titanGetAll' && result.result && result.result.response) {
                        window.gameLoadData.titans = result.result.response;
                        debugLog('‚úÖ Loaded titan data:', Object.keys(result.result.response).length, 'titans');
                    }
                    if (result.ident === 'pet_getAll' && result.result && result.result.response) {
                        window.gameLoadData.pets = result.result.response;
                        debugLog('‚úÖ Loaded pet data:', result.result.response.length, 'pets');
                    }
                    if (result.ident === 'banner_getAll' && result.result && result.result.response) {
                        window.gameLoadData.flags = result.result.response;
                        debugLog('‚úÖ Loaded flag data:', Object.keys(result.result.response).length, 'banners');
                    }
                });
                window.gameLoadData.timestamp = Date.now();

                if (HWHFuncs && HWHFuncs.setProgress) {
                    HWHFuncs.setProgress('‚úÖ Game data loaded successfully', true);
                }
                return true;
            } else {
                throw new Error('Invalid response from server');
            }
        } catch (error) {
            console.error('Error fetching game data:', error);
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('‚ùå Failed to load game data', true);
            }
            return false;
        }
    }

    // Browser functions - open Game Data popup with specific tab selected
    window.showHeroBrowser = async function() {
        await window.showGameDataPopup('heroes');
    };

    window.showTitanBrowser = async function() {
        await window.showGameDataPopup('titans');
    };

    window.showPetBrowser = async function() {
        await window.showGameDataPopup('pets');
    };

    window.showFlagBrowser = async function() {
        await window.showGameDataPopup('flags');
    };
    // Helper function to find unit collections dynamically (survives game obfuscation changes)
    function getUnitCollections() {
        let game = cheats.getGame();
        let GameModel = game.GameModel;
        let props = Object.entries(GameModel.__properties__);
        let instanceMethod = props.find(e => e[1] === 'get_instance')[0];
        let instance = GameModel[instanceMethod]();
        let playerProp = Object.keys(GameModel.prototype)[0];
        let player = instance[playerProp];

        let collections = { heroes: null, titans: null, pets: null, player: player };

        // Helper to traverse path
        const getByPath = (obj, pathArr) => {
            try { return pathArr.reduce((o, k) => o[k], obj); } catch(e) { return null; }
        };

        // Try last working paths from localStorage first
        let savedPaths = null;
        try { savedPaths = JSON.parse(localStorage.getItem('hwh_unit_paths')); } catch(e) {}

        if (savedPaths) {
            let h = getByPath(player, savedPaths.heroes);
            let t = getByPath(player, savedPaths.titans);
            let p = getByPath(player, savedPaths.pets);
            if (h && Object.keys(h).length > 0 &&
                t && Object.keys(t).length > 0 &&
                p && Object.keys(p).length > 0) {
                collections.heroes = h;
                collections.titans = t;
                collections.pets = p;
                return collections;
            }
        }

        // Try hardcoded paths (update these when game changes)
        try { if (Object.keys(player.La.uob.F).length > 0) collections.heroes = player.La.uob.F; } catch(e) {}
        try { if (Object.keys(player.Rd.Ysb.F).length > 0) collections.titans = player.Rd.Ysb.F; } catch(e) {}
        try { if (Object.keys(player.ji.HFb.F).length > 0) collections.pets = player.ji.HFb.F; } catch(e) {}

        // If all found, save paths
        if (collections.heroes && collections.titans && collections.pets) {
            localStorage.setItem('hwh_unit_paths', JSON.stringify({
                heroes: ['La', 'uob', 'F'],
                titans: ['Rd', 'Ysb', 'F'],
                pets: ['ji', 'HFb', 'F']
            }));
            return collections;
        }

        // Dynamic detection fallback - use ID ranges + count
        debugLog('Fallback to dynamic unit collection detection...');
        let foundPaths = {};

        for (let k1 in player) {
            let v1 = player[k1];
            if (v1 && typeof v1 === 'object') {
                for (let k2 in v1) {
                    let v2 = v1[k2];
                    if (v2?.F && typeof v2.F === 'object') {
                        let keys = Object.keys(v2.F);
                        let count = keys.length;
                        if (count === 0) continue;
                        let firstKey = parseInt(keys[0]);

                        // Heroes: IDs < 500, count 65-150
                        if (!collections.heroes && firstKey > 0 && firstKey < 500 && count >= 65 && count <= 150) {
                            collections.heroes = v2.F;
                            foundPaths.heroes = [k1, k2, 'F'];
                            debugLog('Found heroes:', `player.${k1}.${k2}.F`, count);
                        }
                        // Titans: IDs 4000-4999, count >= 20
                        else if (!collections.titans && firstKey >= 4000 && firstKey < 5000 && count >= 20) {
                            collections.titans = v2.F;
                            foundPaths.titans = [k1, k2, 'F'];
                            debugLog('Found titans:', `player.${k1}.${k2}.F`, count);
                        }
                        // Pets: IDs 6000-6999, count >= 7
                        else if (!collections.pets && firstKey >= 6000 && firstKey < 7000 && count >= 7) {
                            collections.pets = v2.F;
                            foundPaths.pets = [k1, k2, 'F'];
                            debugLog('Found pets:', `player.${k1}.${k2}.F`, count);
                        }
                    }
                }
            }
        }

        // Save whatever we found
        if (foundPaths.heroes && foundPaths.titans && foundPaths.pets) {
            localStorage.setItem('hwh_unit_paths', JSON.stringify(foundPaths));
        }

        return collections;
    }
    unsafeWindow.getUnitCollections = window.getUnitCollections = getUnitCollections;

    // Unit detail view - replaces tab content with detail view for a specific unit
    unsafeWindow.showUnitDetail = window.showUnitDetail = function(unitType, unitId) {
        const data = window.gameLoadData;
        let unit, unitName;

        if (unitType === 'hero') {
            unit = data.heroes[unitId];
            unitName = getName(unitId, 'hero');
        } else if (unitType === 'titan') {
            unit = data.titans[unitId];
            unitName = getName(unitId, 'titan');
        } else if (unitType === 'pet') {
            unit = data.pets.find(p => p.id === unitId);
            unitName = getName(unitId, 'pet');
        } else if (unitType === 'flag') {
            unit = data.flags[unitId];
            unitName = `Flag ${unitId}`;
        }

        if (!unit) {
            console.error(`Unit not found: ${unitType} ${unitId}`);
            return;
        }

        // Store current tab for back button
        const activeTab = document.querySelector('.data-tab.active');
        const currentTab = activeTab ? activeTab.dataset.tab : 'heroes';



        // Build glyph section for heroes
        let glyphSection = '';
        if (unitType === 'hero' && unit.runes && Array.isArray(unit.runes)) {
            // XP thresholds for each 5-level tier (cumulative)
            const glyphTiers = [
                { level: 5, xp: 250 },
                { level: 10, xp: 650 },
                { level: 15, xp: 1600 },
                { level: 20, xp: 2700 },
                { level: 25, xp: 5300 },
                { level: 30, xp: 8250 },
                { level: 35, xp: 12200 },
                { level: 40, xp: 16550 },
                { level: 45, xp: 26400 },
                { level: 50, xp: 43750 }
            ];

            const getGlyphLevel = (xp) => {
                for (let i = glyphTiers.length - 1; i >= 0; i--) {
                    if (xp >= glyphTiers[i].xp) return glyphTiers[i].level;
                }
                // For levels 1-4, calculate based on 50 XP per level
                return Math.floor(xp / 50);
            };

            const glyphNames = window.getHeroGlyphNames ? window.getHeroGlyphNames(unitId) : ['Glyph 1','Glyph 2','Glyph 3','Glyph 4','Glyph 5'];

            glyphSection = `
                <div class="twk-mb-15">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; border-bottom: 1px solid #8b6914; padding-bottom: 5px;">
                        <h4 style="color: #ffd700; margin: 0;">‚¨° Glyphs</h4>
                        <button onclick="window.showGlyphUpgrade(${unitId}, '${unitName.replace(/'/g, "\\'")}')" style="
                            background: #4a3010;
                            color: #ffd700;
                            border: 1px solid #8b6914;
                            border-radius: 4px;
                            padding: 4px 10px;
                            cursor: pointer;
                            font-size: 11px;
                        ">‚¨ÜÔ∏è Upgrade</button>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px;">
                        ${unit.runes.map((xp, idx) => {
                const lvl = getGlyphLevel(xp);
                const isMaxed = xp >= 43750;
                return `
                            <div style="background: rgba(0,0,0,0.3); padding: 6px 4px; border-radius: 5px; text-align: center;">
                                <div style="color: #999; font-size: 9px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${glyphNames[idx]}">${glyphNames[idx]}</div>
                                <div style="color: ${isMaxed ? '#4ae29a' : '#ffd700'}; font-size: 14px; font-weight: bold;">${isMaxed ? '‚úì' : lvl + '/50'}</div>
                                <div style="color: #999; font-size: 9px;">${xp.toLocaleString()}</div>
                            </div>
                        `}).join('')}
                    </div>
                </div>
            `;
        }

        // Future sections placeholders
        const futureSections = `
            <div style="margin-top: 15px; padding: 10px; background: rgba(100,100,100,0.2); border-radius: 5px; color: #999;">
                <div style="font-size: 11px; color: #999;">Future upgrade sections:</div>
                <div style="font-size: 10px; margin-top: 5px; line-height: 1.6;">
                    ‚Ä¢ Skins (multiple per unit)<br>
                    ‚Ä¢ Artifacts (Weapon, Book, Ring)<br>
                    ‚Ä¢ Skills<br>
                    ‚Ä¢ Gift of Elements<br>
                    ‚Ä¢ Ascension<br>
                    ‚Ä¢ Role Branch<br>
                    ‚Ä¢ Items
                </div>
            </div>
        `;

        // Build the detail HTML
        const detailHTML = `
            <div style="max-width: 600px; margin: 0 auto;">
                <!-- Breadcrumb / Back button -->
                <div style="display: flex; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #8b6914;">
                    <button onclick="window.backToUnitList('${currentTab}')" style="
                        background: #4a3010;
                        color: #ffd700;
                        border: 1px solid #8b6914;
                        border-radius: 5px;
                        padding: 6px 12px;
                        cursor: pointer;
                        font-size: 12px;
                        margin-right: 10px;
                    ">‚Üê Back</button>
                    <span style="color: #999; font-size: 12px;">${currentTab.charAt(0).toUpperCase() + currentTab.slice(1)}</span>
                    <span style="color: #666; margin: 0 8px;">‚Ä∫</span>
                    <span style="color: #ffd700; font-size: 14px; font-weight: bold;">${unitName}</span>
                </div>

                <!-- Open in Game button -->
                <button onclick="window.openUnitInGame('${unitType}', ${unitId})" style="
                    width: 100%;
                    background: #2a5a2a;
                    color: white;
                    border: 2px solid #1a4a1a;
                    border-radius: 5px;
                    padding: 10px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: bold;
                    margin-bottom: 15px;
                ">üéÆ Open in Game</button>

                <!-- Basic Info Grid -->
                <div style="margin-bottom: 15px; display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;">
                    <div class="twk-overlay-box">
                        <div style="color: #999; font-size: 10px;">ID</div>
                        <div style="color: #fff; font-size: 14px; font-weight: bold;">${unit.id || unitId}</div>
                    </div>
                    <div class="twk-overlay-box">
                        <div style="color: #999; font-size: 10px;">Level</div>
                        <div style="color: #fff; font-size: 14px; font-weight: bold;">${unit.level || '-'}</div>
                    </div>
                    <div class="twk-overlay-box">
                        <div style="color: #999; font-size: 10px;">Stars</div>
                        <div style="color: #ffd700; font-size: 14px; font-weight: bold;">${unit.star || '-'}‚≠ê</div>
                    </div>
                    <div class="twk-overlay-box">
                        <div style="color: #999; font-size: 10px;">Power</div>
                        <div style="color: #4ae29a; font-size: 14px; font-weight: bold;">${(unit.power || 0).toLocaleString()}</div>
                    </div>
                </div>

                ${glyphSection}
                ${futureSections}
            </div>
        `;

        // Replace tab content
        const content = document.getElementById('tab-content');
        if (content) {
            content.innerHTML = detailHTML;
        }
    };

    // Back to unit list - restores the table view
    unsafeWindow.backToUnitList = window.backToUnitList = function(tabName) {
        const data = window.gameLoadData;

        // Re-enable tabs
        document.querySelectorAll('.data-tab').forEach(tab => {
            tab.style.opacity = '1';
            tab.style.pointerEvents = 'auto';
        });

        // Restore content based on tab
        const content = document.getElementById('tab-content');
        if (tabName === 'heroes') {
            content.innerHTML = generateHeroesTable(data.heroes);
        } else if (tabName === 'titans') {
            content.innerHTML = generateTitansTable(data.titans);
        } else if (tabName === 'pets') {
            content.innerHTML = generatePetsTable(data.pets);
        } else if (tabName === 'flags') {
            content.innerHTML = generateFlagsTable(data.flags);
        }
    };


    unsafeWindow.openUnitInGame = window.openUnitInGame = function(unitType, unitId, closePopup = false) {
        const gameDataPopup = document.getElementById('game-data-popup');
        if (gameDataPopup) {
            if (closePopup) {
                gameDataPopup.remove();
            } else {
                gameDataPopup.style.visibility = 'hidden';
            }
        }
        try {
            let cols = getUnitCollections();
            let player = cols.player;

            if (unitType === 'hero') {
                let heroEntry = cols.heroes?.[unitId];
                if (!heroEntry) {
                    console.error(`Hero ${unitId} not found`);
                    if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`Hero ${unitId} not found`, true);
                    return;
                }
                let HeroPopupMediator = selfGame['game.mediator.gui.popup.hero.HeroPopupMediator'];
                new HeroPopupMediator(player, heroEntry).open();
                debugLog(`Opened hero ${unitId}`);
                if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`Opened hero ${unitId}`, true);
            } else if (unitType === 'titan') {
                let titanEntry = cols.titans?.[unitId];
                if (!titanEntry) {
                    console.error(`Titan ${unitId} not found`);
                    if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`Titan ${unitId} not found`, true);
                    return;
                }
                let TitanPopupMediator = selfGame['game.mediator.gui.popup.titan.TitanPopupMediator'];
                new TitanPopupMediator(player, titanEntry).open();
                debugLog(`Opened titan ${unitId}`);
                if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`Opened titan ${unitId}`, true);
            } else if (unitType === 'pet') {
                let petEntry = cols.pets?.[unitId];
                if (!petEntry) {
                    console.error(`Pet ${unitId} not found`);
                    if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`Pet ${unitId} not found`, true);
                    return;
                }
                let PetPopupMediator = selfGame['game.mediator.gui.popup.pet.PetPopupMediator'];
                new PetPopupMediator(player, petEntry).open();
                debugLog(`Opened pet ${unitId}`);
                if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`Opened pet ${unitId}`, true);
            } else if (unitType === 'flag') {
                debugLog(`Flag ${unitId} - mediator TBD`);
                if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`Flag popup not yet implemented`, true);
            }
        } catch (e) {
            console.error('Failed to open unit in game:', e);
            if (HWHFuncs?.setProgress) HWHFuncs.setProgress('Failed to open unit in game', true);
        }
    };
    // Convenience functions for direct console/script access
    unsafeWindow.goHero = window.goHero = function(heroIdOrName) {
        try {
            let cols = getUnitCollections();
            let player = cols.player;
            let heroes = cols.heroes;

            let heroEntry = null;
            let heroName = '';

            if (typeof heroIdOrName === 'string') {
                let searchName = heroIdOrName.toLowerCase();
                for (let key in heroes) {
                    let hero = heroes[key];
                    // Try to find name in any string property
                    let name = Object.values(hero).find(v => v?.ki)?.ki || '';
                    if (name.toLowerCase().includes(searchName)) {
                        heroEntry = hero;
                        heroName = name;
                        break;
                    }
                }
            } else {
                heroEntry = heroes[heroIdOrName];
                heroName = Object.values(heroEntry || {}).find(v => v?.ki)?.ki || heroIdOrName;
            }

            if (!heroEntry) {
                console.error(`Hero "${heroIdOrName}" not found`);
                if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`Hero "${heroIdOrName}" not found`, true);
                return;
            }

            let HeroPopupMediator = selfGame['game.mediator.gui.popup.hero.HeroPopupMediator'];
            new HeroPopupMediator(player, heroEntry).open();
            debugLog(`Opened ${heroName}`);
            if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`Opened ${heroName}`, true);
        } catch(e) {
            console.error('Failed to open hero:', e);
            if (HWHFuncs?.setProgress) HWHFuncs.setProgress('Failed to open hero', true);
        }
    };

    unsafeWindow.goTitan = window.goTitan = function(titanIdOrName) {
        try {
            let cols = getUnitCollections();
            let player = cols.player;
            let titans = cols.titans;

            let titanEntry = null;
            let titanName = '';

            if (typeof titanIdOrName === 'string') {
                let searchName = titanIdOrName.toLowerCase();
                for (let key in titans) {
                    let titan = titans[key];
                    // Try to find name in any string property
                    let name = Object.values(titan).find(v => v?.ki)?.ki || '';
                    if (name.toLowerCase().includes(searchName)) {
                        titanEntry = titan;
                        titanName = name;
                        break;
                    }
                }
            } else {
                titanEntry = titans[titanIdOrName];
                titanName = Object.values(titanEntry || {}).find(v => v?.ki)?.ki || titanIdOrName;
            }

            if (!titanEntry) {
                console.error(`Titan "${titanIdOrName}" not found`);
                if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`Titan "${titanIdOrName}" not found`, true);
                return;
            }

            let TitanPopupMediator = selfGame['game.mediator.gui.popup.titan.TitanPopupMediator'];
            new TitanPopupMediator(player, titanEntry).open();
            debugLog(`Opened ${titanName}`);
            if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`Opened ${titanName}`, true);
        } catch(e) {
            console.error('Failed to open titan:', e);
            if (HWHFuncs?.setProgress) HWHFuncs.setProgress('Failed to open titan', true);
        }
    };

    unsafeWindow.goPet = window.goPet = function(petIdOrName) {
        try {
            let cols = getUnitCollections();
            let player = cols.player;
            let pets = cols.pets;

            let petEntry = null;
            let petName = '';

            if (typeof petIdOrName === 'string') {
                let searchName = petIdOrName.toLowerCase();
                for (let key in pets) {
                    let pet = pets[key];
                    // Try to find name - pets have 'mi' property for name
                    let name = pet.mi || Object.values(pet).find(v => v?.ki)?.ki || '';
                    if (name.toLowerCase().includes(searchName)) {
                        petEntry = pet;
                        petName = name;
                        break;
                    }
                }
            } else {
                petEntry = pets[petIdOrName];
                petName = petEntry?.mi || Object.values(petEntry || {}).find(v => v?.ki)?.ki || petIdOrName;
            }

            if (!petEntry) {
                console.error(`Pet "${petIdOrName}" not found`);
                if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`Pet "${petIdOrName}" not found`, true);
                return;
            }

            let PetPopupMediator = selfGame['game.mediator.gui.popup.pet.PetPopupMediator'];
            new PetPopupMediator(player, petEntry).open();
            debugLog(`Opened ${petName}`);
            if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`Opened ${petName}`, true);
        } catch(e) {
            console.error('Failed to open pet:', e);
            if (HWHFuncs?.setProgress) HWHFuncs.setProgress('Failed to open pet', true);
        }
    };

    // XP thresholds for each glyph level (cumulative XP to COMPLETE that level)
    const glyphLevelXP = [
        0, 50, 100, 150, 200, 250,            // 0-5 (50 each)
        330, 410, 490, 570, 650,              // 6-10 (80 each)
        840, 1030, 1220, 1410, 1600,          // 11-15 (190 each)
        1820, 2040, 2260, 2480, 2700,         // 16-20 (220 each)
        3220, 3740, 4260, 4780, 5300,         // 21-25 (520 each)
        5890, 6480, 7070, 7660, 8250,         // 26-30 (590 each)
        9040, 9830, 10620, 11410, 12200,      // 31-35 (790 each)
        13070, 13940, 14810, 15680, 16550,    // 36-40 (870 each)
        18520, 20490, 22460, 24430, 26400,    // 41-45 (1970 each)
        29870, 33340, 36810, 40280, 43750     // 46-50 (3470 each)
    ];
    // XP per consumable type
    const consumableXP = { 1: 10, 2: 20, 3: 50, 4: 100 };
    window.getGlyphLevel = function(xp) {
        for (let i = glyphLevelXP.length - 1; i >= 0; i--) {
            if (xp >= glyphLevelXP[i]) return i;
        }
        return 0;
    };

    // Calculate consumables needed for target XP
    window.calcConsumablesForXP = function(targetXP, inventory) {
        const toUse = { 4: 0, 3: 0, 2: 0, 1: 0 };
        let remaining = targetXP;

        for (let id = 4; id >= 1; id--) {
            const available = inventory[id] || 0;
            const xpPer = consumableXP[id];
            const needed = Math.floor(remaining / xpPer);
            const use = Math.min(needed, available);
            toUse[id] = use;
            remaining -= use * xpPer;
        }

        const actualXP = Object.entries(toUse).reduce((sum, [id, count]) => sum + count * consumableXP[id], 0);
        return { toUse, actualXP, remaining: targetXP - actualXP };
    };

    // Get glyph stat names for a hero
    window.getHeroGlyphNames = function(heroId) {
        const defaultNames = ['Glyph 1', 'Glyph 2', 'Glyph 3', 'Glyph 4', 'Glyph 5'];
        const statNames = {
            1: 'Strength', 2: 'Intelligence', 3: 'Agility', 4: 'Health', 5: 'Phys Atk',
            6: 'Magic Atk', 7: 'Armor', 8: 'Magic Def', 9: 'Crit Hit Chance', 10: 'Dodge',
            11: 'Magic Pen', 12: 'Armor Pen'
        };

        try {
            if (typeof lib !== 'undefined' && lib.data?.hero?.[heroId]?.runes) {
                const heroRunes = lib.data.hero[heroId].runes;
                if (Array.isArray(heroRunes)) {
                    return heroRunes.map((statId, idx) => statNames[statId] || `Glyph ${idx + 1}`);
                }
            }
        } catch (e) {}
        return defaultNames;
    };

    window.glyphUpgradeInventory = {};
    window.glyphMode = 'count';

    // Toggle mode function
    window.setGlyphMode = function(mode) {
        window.glyphMode = mode;

        const countMode = document.getElementById('count-mode');
        const xpMode = document.getElementById('xp-mode');
        const btnCount = document.getElementById('mode-count');
        const btnXP = document.getElementById('mode-xp');

        if (!countMode || !xpMode || !btnCount || !btnXP) {
            console.error('Mode elements not found');
            return;
        }

        if (mode === 'count') {
            countMode.style.display = 'block';
            xpMode.style.display = 'none';
            btnCount.style.background = '#8b6914';
            btnCount.style.color = '#fff';
            btnXP.style.background = '#4a3010';
            btnXP.style.color = '#ffd700';
        } else {
            countMode.style.display = 'none';
            xpMode.style.display = 'block';
            btnCount.style.background = '#4a3010';
            btnCount.style.color = '#ffd700';
            btnXP.style.background = '#8b6914';
            btnXP.style.color = '#fff';
            window.updateXPPreview();
        }
    };

    // Update XP preview
    window.updateXPPreview = function() {
        const xpInput = document.getElementById('xp-input');
        const preview = document.getElementById('xp-preview');
        if (!xpInput || !preview) return;

        const targetXP = parseInt(xpInput.value) || 0;
        const calc = window.calcConsumablesForXP(targetXP, window.glyphUpgradeInventory);
        const names = { 1: 'Small', 2: 'Rune', 3: 'Big', 4: 'Great' };

        let breakdown = Object.entries(calc.toUse)
        .filter(([id, count]) => count > 0)
        .map(([id, count]) => `${names[id]}: ${count.toLocaleString()}`)
        .join(', ') || 'None available';

        preview.innerHTML = `
            <div style="color: #ffd700; margin-bottom: 4px;">Will use: <span style="color: #fff;">${breakdown}</span></div>
            <div class="twk-green">Actual XP: ${calc.actualXP.toLocaleString()} ${calc.remaining > 0 ? `<span class="twk-red">(${calc.remaining.toLocaleString()} short)</span>` : ''}</div>
        `;
    };

    // Show glyph upgrade popup
    unsafeWindow.showGlyphUpgrade = window.showGlyphUpgrade = async function(heroId, heroName) {
        const existing = document.getElementById('glyph-upgrade-popup');
        if (existing) existing.remove();

        // Show loading popup immediately
        const popup = document.createElement('div');
        popup.id = 'glyph-upgrade-popup';
        popup.innerHTML = `
        <div style="
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); z-index: 999999;
            display: flex; align-items: center; justify-content: center;
        " onclick="if(event.target === this) this.parentElement.remove()">
            <div style="
                background: linear-gradient(135deg, #2d1810 0%, #1a0f08 100%);
                border: 3px solid #8b6914; border-radius: 10px;
                padding: 40px; color: #ffd700; text-align: center;
            ">
                <div style="font-size: 18px;">‚¨° Loading Glyph Data...</div>
                <div style="margin-top: 10px; color: #999;">${heroName}</div>
            </div>
        </div>`;
        document.body.appendChild(popup);

        // Now fetch data
        let inventory = {};
        let heroRunes = [0, 0, 0, 0, 0];
        try {
            const SendFunction = getSend();
            if (!SendFunction) throw new Error('Send function not available');
            const result = await SendFunction(JSON.stringify({ calls: [
                { name: 'inventoryGet', args: {}, ident: 'inv' },
                { name: 'heroGetAll', args: {}, ident: 'heroes' }
            ]}));
            inventory = result?.results?.find(r => r.ident === 'inv')?.result?.response?.consumable || {};
            const heroes = result?.results?.find(r => r.ident === 'heroes')?.result?.response || {};
            const rawRunes = heroes[heroId]?.runes;
            heroRunes = Array.isArray(rawRunes) ? rawRunes :
            (rawRunes ? [rawRunes[0]||0, rawRunes[1]||0, rawRunes[2]||0, rawRunes[3]||0, rawRunes[4]||0] : [0,0,0,0,0]);
        } catch (e) {
            console.error('Failed to get data:', e);
            popup.remove();
            return;
        }

        // Now build the real popup with data...
        window.glyphUpgradeInventory = inventory;
        window.glyphUpgradeHeroRunes = heroRunes;
        window.glyphMode = 'xp';
        window.selectedGlyph = 0;
        window.selectedConsumable = 4;

        const cNames = { 1: 'Small', 2: 'Rune', 3: 'Big', 4: 'Great' };
        const glyphNames = window.getHeroGlyphNames(heroId);
        const maxPossibleXP = Object.entries(inventory).reduce((sum, [id, count]) => sum + (count * (consumableXP[id] || 0)), 0);

        // Find first non-maxed glyph
        for (let i = 0; i < 5; i++) {
            if (heroRunes[i] < 43750) {
                window.selectedGlyph = i;
                break;
            }
        }

        popup.innerHTML = `
        <div style="
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); z-index: 999999;
            display: flex; align-items: center; justify-content: center;
        " onclick="if(event.target === this) this.parentElement.remove()">
            <div style="
                background: linear-gradient(135deg, #2d1810 0%, #1a0f08 100%);
                border: 3px solid #8b6914; border-radius: 10px;
                padding: 15px; width: 420px; color: #ffd700;
            ">
                <h3 style="margin: 0 0 12px 0; text-align: center; border-bottom: 1px solid #8b6914; padding-bottom: 8px; font-size: 16px;">
                    ‚¨° Upgrade Glyph - <span class="twk-dim">${heroName}</span>
                </h3>

                <!-- Glyph Selection (clickable boxes) -->
                <div style="margin-bottom: 4px; font-size: 12px; color: #999;">Select Glyph:</div>
                <div id="glyph-buttons" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-bottom: 12px;">
${heroRunes.map((xp, idx) => {
            const lvl = window.getGlyphLevel(xp);
            const isMaxed = xp >= 43750;
            const needed = 43750 - xp;
            const currentLevelXP = glyphLevelXP[lvl] || 0;
            const nextLevelXP = glyphLevelXP[lvl + 1] || 43750;
            const progressInLevel = xp - currentLevelXP;
            const xpForLevel = nextLevelXP - currentLevelXP;
            const isSelected = idx === window.selectedGlyph;
            return `<div class="glyph-btn" data-idx="${idx}" data-xp="${xp}" style="
                            text-align: center; padding: 8px 4px;
                            background: ${isMaxed ? 'rgba(0,0,0,0.2)' : (isSelected ? '#8b6914' : 'rgba(0,0,0,0.3)')};
                            border: 2px solid ${isMaxed ? '#333' : (isSelected ? '#ffd700' : '#8b6914')};
                            border-radius: 5px; cursor: ${isMaxed ? 'not-allowed' : 'pointer'};
                            opacity: ${isMaxed ? '0.5' : '1'};
                        ">
                            <div style="color: ${isSelected ? '#fff' : '#ccc'}; font-size: 11px; white-space: nowrap; overflow: hidden;">${glyphNames[idx]}</div>
                            <div style="color: ${isMaxed ? '#4ae29a' : '#ffd700'}; font-weight: bold; font-size: 16px;">${isMaxed ? '‚úì' : lvl + '/50'}</div>
                            <div style="color: #fff; font-size: 11px;">${isMaxed ? 'MAX' : progressInLevel + '/' + xpForLevel}</div>
                            <div style="color: #ccc; font-size: 10px;">${isMaxed ? '' : needed.toLocaleString() + ' need'}</div>
                            </div>`;
        }).join('')}
                </div>

                <!-- Inventory Display (clickable for By Count mode) -->
                <div style="margin-bottom: 4px; font-size: 12px; color: #999;">Consumables:</div>
                <div id="consumable-buttons" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin-bottom: 8px;">
                    ${[1,2,3,4].map(id => {
            const isSelected = id === window.selectedConsumable;
            return `<div class="cons-btn" data-id="${id}" data-count="${inventory[id] || 0}" style="
                            text-align: center; padding: 8px 4px;
                            background: ${isSelected ? '#8b6914' : 'rgba(0,0,0,0.3)'};
                            border: 2px solid ${isSelected ? '#ffd700' : '#8b6914'};
                            border-radius: 5px; cursor: pointer;
                        ">
                            <div style="color: ${isSelected ? '#fff' : '#ccc'}; font-size: 12px;">${cNames[id]}</div>
                            <div style="color: #fff; font-size: 14px; font-weight: bold;">${(inventory[id] || 0).toLocaleString()}</div>
                             <div style="color: #fff; font-size: 12px;">${consumableXP[id]}xp</div>
                              </div>`;
        }).join('')}
                </div>
                <div style="text-align: center; margin-bottom: 12px; color: #4ae29a; font-size: 13px;">
                    Max XP: ${maxPossibleXP.toLocaleString()}
                </div>

                <!-- Mode Toggle -->
                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                    <button id="mode-count" type="button" style="flex:1; padding: 10px; background: #4a3010; border: 2px solid #8b6914; border-radius: 5px; color: #ffd700; cursor: pointer; font-size: 13px; font-weight: bold;">By Count</button>
                    <button id="mode-xp" type="button" style="flex:1; padding: 10px; background: #8b6914; border: 2px solid #8b6914; border-radius: 5px; color: #fff; cursor: pointer; font-size: 13px; font-weight: bold;">By XP</button>
                </div>

                <!-- Count Mode -->
                <div id="count-mode" class="twk-hidden">
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; margin-bottom: 4px; font-size: 12px; color: #999;">Amount (click consumable above to select):</label>
                        <input type="number" id="amount-input" value="1" min="1" style="
                            width: 100%; padding: 10px; background: #1a0f08;
                            border: 1px solid #8b6914; border-radius: 4px; color: #ffd700; font-size: 14px;
                            box-sizing: border-box;
                        ">
                        <div style="display: flex; gap: 5px; margin-top: 6px;">
                            <button type="button" onclick="document.getElementById('amount-input').value = 1" style="flex:1; padding: 8px; background: #4a3010; border: 1px solid #8b6914; border-radius: 4px; color: #ffd700; cursor: pointer; font-size: 12px;">1</button>
                            <button type="button" onclick="document.getElementById('amount-input').value = 10" style="flex:1; padding: 8px; background: #4a3010; border: 1px solid #8b6914; border-radius: 4px; color: #ffd700; cursor: pointer; font-size: 12px;">10</button>
                            <button type="button" onclick="document.getElementById('amount-input').value = 100" style="flex:1; padding: 8px; background: #4a3010; border: 1px solid #8b6914; border-radius: 4px; color: #ffd700; cursor: pointer; font-size: 12px;">100</button>
                            <button type="button" onclick="document.getElementById('amount-input').value = 1000" style="flex:1; padding: 8px; background: #4a3010; border: 1px solid #8b6914; border-radius: 4px; color: #ffd700; cursor: pointer; font-size: 12px;">1k</button>
                            <button type="button" id="all-btn" style="flex:1; padding: 8px; background: #2a5a2a; border: 1px solid #1a4a1a; border-radius: 4px; color: #fff; cursor: pointer; font-size: 12px; font-weight: bold;">All</button>
                        </div>
                    </div>
                </div>

                <!-- XP Mode -->
                <div id="xp-mode">
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 4px; font-size: 12px; color: #999;">Target XP to add:</label>
                        <input type="number" id="xp-input" value="2500" min="1" style="
                            width: 100%; padding: 10px; background: #1a0f08;
                            border: 1px solid #8b6914; border-radius: 4px; color: #ffd700; font-size: 14px;
                            box-sizing: border-box;
                        ">
                        <div style="display: flex; gap: 5px; margin-top: 6px;">
                            <button type="button" class="xp-btn" data-xp="500" style="flex:1; padding: 8px; background: #4a3010; border: 1px solid #8b6914; border-radius: 4px; color: #ffd700; cursor: pointer; font-size: 12px;">500</button>
                            <button type="button" class="xp-btn" data-xp="1000" style="flex:1; padding: 8px; background: #4a3010; border: 1px solid #8b6914; border-radius: 4px; color: #ffd700; cursor: pointer; font-size: 12px;">1k</button>
                            <button type="button" class="xp-btn" data-xp="2500" style="flex:1; padding: 8px; background: #4a3010; border: 1px solid #8b6914; border-radius: 4px; color: #ffd700; cursor: pointer; font-size: 12px;">2.5k</button>
                            <button type="button" class="xp-btn" data-xp="5000" style="flex:1; padding: 8px; background: #4a3010; border: 1px solid #8b6914; border-radius: 4px; color: #ffd700; cursor: pointer; font-size: 12px;">5k</button>
                            <button type="button" class="xp-btn" data-xp="10000" style="flex:1; padding: 8px; background: #4a3010; border: 1px solid #8b6914; border-radius: 4px; color: #ffd700; cursor: pointer; font-size: 12px;">10k</button>
                        </div>
                    </div>
                    <div id="xp-preview" style="padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px; font-size: 13px; margin-bottom: 12px;"></div>
                </div>

                <div id="upgrade-result" style="margin-bottom: 12px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px; font-size: 13px; color: #ccc; display: none;"></div>

                <div class="twk-flex-gap8">
                    <button id="upgrade-btn" type="button" style="
                        flex: 1; padding: 12px; background: #2a5a2a; border: 2px solid #1a4a1a;
                        border-radius: 5px; color: white; font-weight: bold; cursor: pointer; font-size: 14px;
                    ">‚¨ÜÔ∏è Upgrade</button>
                    <button id="max-btn" type="button" style="
                        flex: 1; padding: 12px; background: #5a2a8a; border: 2px solid #4a1a6a;
                        border-radius: 5px; color: white; font-weight: bold; cursor: pointer; font-size: 14px;
                    ">‚≠ê Max</button>
                    <button type="button" onclick="document.getElementById('glyph-upgrade-popup').remove()" style="
                        padding: 12px 16px; background: #c41e3a; border: 2px solid #8b0000;
                        border-radius: 5px; color: white; font-weight: bold; cursor: pointer; font-size: 14px;
                    ">‚úï</button>
                </div>
            </div>
        </div>
        `;

        document.body.appendChild(popup);

        // Glyph selection click handlers
        document.querySelectorAll('.glyph-btn').forEach(btn => {
            btn.onclick = function() {
                const idx = parseInt(this.dataset.idx);
                const xp = parseInt(this.dataset.xp);
                if (xp >= 43750) return; // Can't select maxed

                window.selectedGlyph = idx;
                document.querySelectorAll('.glyph-btn').forEach(b => {
                    const bIdx = parseInt(b.dataset.idx);
                    const bXp = parseInt(b.dataset.xp);
                    const isMaxed = bXp >= 43750;
                    const isSel = bIdx === idx;
                    b.style.background = isMaxed ? 'rgba(0,0,0,0.2)' : (isSel ? '#8b6914' : 'rgba(0,0,0,0.3)');
                    b.style.borderColor = isMaxed ? '#333' : (isSel ? '#ffd700' : '#8b6914');
                    b.querySelector('div').style.color = isSel ? '#fff' : '#ccc';
                });
                window.updateXPPreview();
            };
        });

        // Consumable selection click handlers
        document.querySelectorAll('.cons-btn').forEach(btn => {
            btn.onclick = function() {
                const id = parseInt(this.dataset.id);
                window.selectedConsumable = id;
                document.querySelectorAll('.cons-btn').forEach(b => {
                    const bId = parseInt(b.dataset.id);
                    const isSel = bId === id;
                    b.style.background = isSel ? '#8b6914' : 'rgba(0,0,0,0.3)';
                    b.style.borderColor = isSel ? '#ffd700' : '#8b6914';
                    b.querySelector('div').style.color = isSel ? '#fff' : '#ccc';
                });
            };
        });

        // XP quick buttons
        document.querySelectorAll('.xp-btn').forEach(btn => {
            btn.onclick = function() {
                document.getElementById('xp-input').value = this.dataset.xp;
                window.updateXPPreview();
            };
        });

        // Mode buttons
        document.getElementById('mode-count').onclick = function() { window.setGlyphMode('count'); };
        document.getElementById('mode-xp').onclick = function() { window.setGlyphMode('xp'); };

        // XP input change
        document.getElementById('xp-input').oninput = function() { window.updateXPPreview(); };

        // All button for count mode
        document.getElementById('all-btn').onclick = function() {
            const count = window.glyphUpgradeInventory[window.selectedConsumable] || 0;
            document.getElementById('amount-input').value = count;
        };

        // Action buttons
        document.getElementById('upgrade-btn').onclick = function() { window.executeGlyphUpgrade(heroId); };
        document.getElementById('max-btn').onclick = function() { window.maxGlyphUpgrade(heroId); };

        window.updateXPPreview();
    };

    // Execute glyph upgrade
    unsafeWindow.executeGlyphUpgrade = window.executeGlyphUpgrade = async function(heroId) {
        const tier = window.selectedGlyph;
        const resultDiv = document.getElementById('upgrade-result');
        const upgradeBtn = document.getElementById('upgrade-btn');
        const maxBtn = document.getElementById('max-btn');

        resultDiv.style.display = 'block';
        resultDiv.innerHTML = '‚è≥ Upgrading...';
        upgradeBtn.disabled = true;
        maxBtn.disabled = true;

        let result;
        let consumables = {};
        try {

            if (window.glyphMode === 'xp') {
                const targetXP = parseInt(document.getElementById('xp-input').value) || 0;
                const calc = window.calcConsumablesForXP(targetXP, window.glyphUpgradeInventory);

                for (let id = 1; id <= 4; id++) {
                    if (calc.toUse[id] > 0) consumables[id] = calc.toUse[id];
                }

                if (Object.keys(consumables).length === 0) {
                    resultDiv.innerHTML = `<span class="twk-red">‚úó No consumables available</span>`;
                    upgradeBtn.disabled = false;
                    maxBtn.disabled = false;
                    return;
                }
            } else {
                const consumableId = window.selectedConsumable;
                const amount = parseInt(document.getElementById('amount-input').value) || 1;
                consumables[consumableId] = amount;
            }

            const calls = [{
                name: 'heroEnchantRune',
                args: { heroId: heroId, tier: tier, items: { consumable: consumables } },
                ident: 'heroEnchantRune'
            }];

            result = await Send(JSON.stringify({ calls }));
            if (result?.results?.[0]?.result?.response !== undefined) {
                const currentXP = window.glyphUpgradeHeroRunes[tier] || 0;
                const addedXP = Object.entries(consumables).reduce((sum, [id, count]) => sum + (count * consumableXP[id]), 0);
                const newXP = currentXP + addedXP;
                const lvl = window.getGlyphLevel(newXP);
                const isMaxed = newXP >= 43750;

                // Calculate progress into current level
                const currentLevelXP = glyphLevelXP[lvl] || 0;
                const nextLevelXP = glyphLevelXP[lvl + 1] || 43750;
                const progressInLevel = newXP - currentLevelXP;
                const xpForLevel = nextLevelXP - currentLevelXP;

                resultDiv.innerHTML = `<span class="twk-green">‚úî Glyph ${tier + 1}: Level ${lvl}/50</span><br>
                    <span style="color: #fff; font-size: 15px;">XP: ${newXP.toLocaleString()} / 43,750 ${isMaxed ? '‚≠ê MAX!' : `(${progressInLevel}/${xpForLevel})`}</span>`;
                if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`Glyph ${tier + 1}: Lv${lvl}`, true);
            } else {
                resultDiv.innerHTML = `<span class="twk-red">‚úó Error: ${result?.results?.[0]?.result?.error || 'Unknown'}</span>`;
            }
        } catch (e) {
            resultDiv.innerHTML = `<span class="twk-red">‚úó Failed: ${e.message}</span>`;
        }

        upgradeBtn.disabled = false;
        maxBtn.disabled = false;

        // Update the UI in place using calculated data
        try {
            // Update the selected glyph with calculated XP
            const currentXP = window.glyphUpgradeHeroRunes[tier] || 0;
            const addedXP = Object.entries(consumables).reduce((sum, [id, count]) => sum + (count * consumableXP[id]), 0);
            const calculatedNewXP = currentXP + addedXP;
            window.glyphUpgradeHeroRunes[tier] = calculatedNewXP;

            // Update game's internal hero model so UI stays in sync
            try {
                const collections = getUnitCollections();
                const hero = collections.heroes?.[heroId];
                if (hero) {
                    // Find runes array dynamically (5-element array with XP values)
                    for (let k in hero) {
                        let v = hero[k];
                        if (v && typeof v === 'object') {
                            for (let k2 in v) {
                                if (Array.isArray(v[k2]) && v[k2].length === 5 && typeof v[k2][0] === 'number') {
                                    v[k2][tier] = calculatedNewXP;
                                    debugLog('‚¨° Updated game model:', heroId, k + '.' + k2, tier, '‚Üí', calculatedNewXP);
                                    break;
                                }
                            }
                        }
                    }
                }
            } catch(e) { debugLog('Could not update game model:', e); }
            // Update gameLoadData cache so hero browser table stays in sync
            try {
                if (window.gameLoadData?.heroes?.[heroId]?.runes) {
                    window.gameLoadData.heroes[heroId].runes[tier] = calculatedNewXP;
                    window.gameLoadData.timestamp = Date.now(); // Invalidate display cache
                    debugLog('‚¨° Updated gameLoadData:', heroId, 'runes', tier, '‚Üí', calculatedNewXP);
                }
            } catch(e) { debugLog('Could not update gameLoadData:', e); }

            // Update inventory locally (subtract what we used)
            for (const [id, count] of Object.entries(consumables)) {
                window.glyphUpgradeInventory[id] = (window.glyphUpgradeInventory[id] || 0) - count;
            }

            // Update glyph buttons
            document.querySelectorAll('.glyph-btn').forEach(btn => {
                const idx = parseInt(btn.dataset.idx);
                const xp = window.glyphUpgradeHeroRunes[idx];
                const lvl = window.getGlyphLevel(xp);
                const isMaxed = xp >= 43750;
                const needed = 43750 - xp;
                const currentLevelXP = glyphLevelXP[lvl] || 0;
                const nextLevelXP = glyphLevelXP[lvl + 1] || 43750;
                const progressInLevel = xp - currentLevelXP;
                const xpForLevel = nextLevelXP - currentLevelXP;
                const isSelected = idx === window.selectedGlyph;

                btn.dataset.xp = xp;
                btn.style.background = isMaxed ? 'rgba(0,0,0,0.2)' : (isSelected ? '#8b6914' : 'rgba(0,0,0,0.3)');
                btn.style.borderColor = isMaxed ? '#333' : (isSelected ? '#ffd700' : '#8b6914');
                btn.style.cursor = isMaxed ? 'not-allowed' : 'pointer';
                btn.style.opacity = isMaxed ? '0.5' : '1';
                btn.children[1].textContent = isMaxed ? '‚úî' : lvl + '/50';
                btn.children[1].style.color = isMaxed ? '#4ae29a' : '#ffd700';
                btn.children[2].textContent = isMaxed ? 'MAX' : progressInLevel + '/' + xpForLevel;
                if (btn.children[3]) {
                    btn.children[3].textContent = isMaxed ? '' : needed.toLocaleString() + ' need';
                }
            });

            // Update consumable buttons
            document.querySelectorAll('.cons-btn').forEach(btn => {
                const id = parseInt(btn.dataset.id);
                const count = window.glyphUpgradeInventory[id] || 0;
                btn.dataset.count = count;
                btn.children[1].textContent = count.toLocaleString();
            });

            // Update preview
            window.updateXPPreview();
        } catch (e) { debugLog('UI refresh failed:', e); }
    };
    // Max out selected glyph
    unsafeWindow.maxGlyphUpgrade = window.maxGlyphUpgrade = async function(heroId) {
        const tier = window.selectedGlyph;
        const currentXP = window.glyphUpgradeHeroRunes[tier] || 0;
        const neededXP = 43750 - currentXP;

        if (neededXP <= 0) {
            document.getElementById('upgrade-result').style.display = 'block';
            document.getElementById('upgrade-result').innerHTML = '<span class="twk-green">‚úì Already maxed!</span>';
            return;
        }

        // Set XP mode and target to max
        window.setGlyphMode('xp');
        document.getElementById('xp-input').value = neededXP;
        window.updateXPPreview();

        // Execute the upgrade
        await window.executeGlyphUpgrade(heroId);
    };
    // Function to show the popup with hero/titan/pet data
    window.showGameDataPopup = async function(initialTab = 'heroes') {
        // Check if popup exists but is just hidden - restore it
        const existingPopup = document.getElementById('game-data-popup');
        if (existingPopup) {
            if (existingPopup.style.visibility === 'hidden') {
                existingPopup.style.visibility = 'visible';
                return;
            }
            // If visible, remove and recreate (refresh)
            existingPopup.remove();
        }

        const { heroes, titans, pets, flags } = window.gameLoadData;

        // If data isn't loaded yet, fetch it
        if (!heroes || !titans || !pets || !flags) {
            debugLog('Data not loaded, fetching...');
            const success = await fetchGameData();
            if (!success) {
                return; // fetchGameData already showed error message
            }
        }

        // Now the data should be available
        const updatedData = window.gameLoadData;
        if (!updatedData.heroes || !updatedData.titans || !updatedData.pets || !updatedData.flags) {
            console.error('Failed to load game data');
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('‚ùå Could not load game data', true);
            }
            return;
        }

        // Create popup
        const popup = document.createElement('div');
        popup.id = 'game-data-popup';
        popup.innerHTML = `
        <div style="
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 99999;
            display: flex;
            align-items: center;
            justify-content: center;
        ">
            <div style="
                background: linear-gradient(135deg, #2d1810 0%, #1a0f08 100%);
                border: 3px solid #8b6914;
                border-radius: 15px;
                width: 90%;
                max-width: 900px;
                max-height: 85vh;
                display: flex;
                flex-direction: column;
                box-shadow: 0 0 40px rgba(139, 105, 20, 0.5);
            ">
                <!-- Header -->
                <div style="
                    background: linear-gradient(to bottom, #8b6914, #6b5010);
                    border-radius: 12px 12px 0 0;
                    padding: 12px 20px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    border-bottom: 2px solid #8b6914;
                ">
                    <h2 style="
                        margin: 0;
                        color: #ffd700;
                        font-size: 20px;
                        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
                    ">üìä Game Data Overview</h2>
                    <div class="twk-flex-gap8">
                        <button id="refresh-game-data-btn" style="
                            background: #2a5a2a;
                            color: white;
                            border: 2px solid #1a4a1a;
                            border-radius: 5px;
                            padding: 6px 12px;
                            cursor: pointer;
                            font-size: 12px;
                            font-weight: bold;
                        ">üîÑ Refresh</button>
                        <button id="export-game-data-btn" style="
                            background: #4a4a90;
                            color: white;
                            border: 2px solid #3a3a70;
                            border-radius: 5px;
                            padding: 6px 12px;
                            cursor: pointer;
                            font-size: 12px;
                            font-weight: bold;
                        ">üì§ Export Tab</button>
                        <button id="export-all-data-btn" style="
    background: #4a4a90;
    color: white;
    border: 2px solid #3a3a70;
    border-radius: 5px;
    padding: 6px 12px;
    cursor: pointer;
    font-size: 12px;
    font-weight: bold;
">üíæ Export All</button>
                        <button id="close-game-data" style="
                            background: #c41e3a;
                            color: white;
                            border: 2px solid #8b0000;
                            border-radius: 5px;
                            padding: 6px 15px;
                            cursor: pointer;
                            font-size: 14px;
                            font-weight: bold;
                        ">‚úï</button>
                    </div>
                </div>

<!-- Tabs -->
                <div style="
display: flex;
background: #1a0f08;
border-bottom: 2px solid #8b6914;
gap: 2px;
padding: 0;
">
<button class="data-tab" data-tab="heroes" style="
flex: 1;
padding: 10px;
background: #8b6914;
color: #ffd700;
border: none;
border-bottom: 3px solid #ffd700;
cursor: pointer;
font-size: 13px;
font-weight: bold;
transition: all 0.2s;
">ü¶∏ Heroes (${Object.keys(updatedData.heroes).length})</button>
<button class="data-tab" data-tab="titans" style="
flex: 1;
padding: 10px;
background: #4a3010;
color: #ccc;
border: none;
border-bottom: 3px solid transparent;
cursor: pointer;
font-size: 13px;
font-weight: bold;
transition: all 0.2s;
">‚ö° Titans (${Object.keys(updatedData.titans).length})</button>
<button class="data-tab" data-tab="pets" style="
flex: 1;
padding: 10px;
background: #4a3010;
color: #ccc;
border: none;
border-bottom: 3px solid transparent;
cursor: pointer;
font-size: 13px;
font-weight: bold;
transition: all 0.2s;
">üêæ Pets (${updatedData.pets.length})</button>
<button class="data-tab" data-tab="flags" style="
flex: 1;
padding: 10px;
background: #4a3010;
color: #ccc;
border: none;
border-bottom: 3px solid transparent;
cursor: pointer;
font-size: 13px;
font-weight: bold;
transition: all 0.2s;
">üö© Flags (${updatedData.flags ? Object.keys(updatedData.flags).length : 0})</button>
</div>

<!-- Table Header (fixed) -->
<div id="tab-header" style="
padding: 8px 15px 0 15px;
background: #1a0f08;
">
</div>

<!-- Table Body (scrolls) -->
<div id="tab-content" style="
flex: 1;
overflow-y: auto;
padding: 0 15px 15px 15px;
scrollbar-width: thin;
scrollbar-color: #8b6914 #1a0f08;
">
</div>
</div>
</div>
`;

        document.body.appendChild(popup);

        // Activate the initial tab
        const initialTabBtn = document.querySelector(`.data-tab[data-tab="${initialTab}"]`);
        if (initialTabBtn) {
            initialTabBtn.classList.add('active');
            initialTabBtn.style.background = '#8b6914';
            initialTabBtn.style.color = '#ffd700';
        }

        // Set initial content based on initialTab
        const header = document.getElementById('tab-header');
        const content = document.getElementById('tab-content');
        if (initialTab === 'heroes') {
            const parts = generateHeroesTable(updatedData.heroes);
            header.innerHTML = parts.header;
            content.innerHTML = parts.body;
        } else if (initialTab === 'titans') {
            const parts = generateTitansTable(updatedData.titans);
            header.innerHTML = parts.header;
            content.innerHTML = parts.body;
        } else if (initialTab === 'pets') {
            const parts = generatePetsTable(updatedData.pets);
            header.innerHTML = parts.header;
            content.innerHTML = parts.body;
        } else if (initialTab === 'flags') {
            const parts = generateFlagsTable(updatedData.flags);
            header.innerHTML = parts.header;
            content.innerHTML = parts.body;
        }

        // Add event listeners
        document.getElementById('close-game-data').onclick = () => popup.remove();

        // Refresh button
        document.getElementById('refresh-game-data-btn').onclick = async () => {
            const activeTab = document.querySelector('.data-tab.active');
            const currentTab = activeTab ? activeTab.dataset.tab : 'heroes';
            popup.remove();
            await fetchGameData();
            window.showGameDataPopup(currentTab);
        };

        // Export button
        document.getElementById('export-game-data-btn').onclick = () => {
            const activeTab = document.querySelector('.data-tab.active');
            if (activeTab) {
                exportToClipboard(activeTab.dataset.tab);
            }
        };
        document.getElementById('export-all-data-btn').onclick = () => {
            exportAllToClipboard();
        };

        // Tab switching
        DOMCache.getAll('dataTabs', '.data-tab', true).forEach(tab => {
            tab.onclick = function() {
                DOMCache.getAll('dataTabs', '.data-tab', true).forEach(t => {
                    t.style.background = '#4a3010';
                    t.style.color = '#ccc';
                    t.style.borderBottom = '3px solid transparent';
                    t.classList.remove('active');
                });
                this.style.background = '#8b6914';
                this.style.color = '#ffd700';
                this.style.borderBottom = '3px solid #ffd700';
                this.classList.add('active');

                const tabName = this.dataset.tab;
                const header = document.getElementById('tab-header');
                const content = document.getElementById('tab-content');

                if (tabName === 'heroes') {
                    const parts = generateHeroesTable(updatedData.heroes);
                    header.innerHTML = parts.header;
                    content.innerHTML = parts.body;
                } else if (tabName === 'titans') {
                    const parts = generateTitansTable(updatedData.titans);
                    header.innerHTML = parts.header;
                    content.innerHTML = parts.body;
                } else if (tabName === 'pets') {
                    const parts = generatePetsTable(updatedData.pets);
                    header.innerHTML = parts.header;
                    content.innerHTML = parts.body;
                } else if (tabName === 'flags') {
                    const parts = generateFlagsTable(updatedData.flags);
                    header.innerHTML = parts.header;
                    content.innerHTML = parts.body;
                }
            };
        });
    };

    // Color mapping for heroes (1-18)
    const colorMap = {
        1: { abbr: 'W', color: '#ffffff', name: 'White' },
        2: { abbr: 'G', color: '#4ae29a', name: 'Green' },
        3: { abbr: 'G1', color: '#4ae29a', name: 'Green +1' },
        4: { abbr: 'B', color: '#5b9bd5', name: 'Blue' },
        5: { abbr: 'B1', color: '#5b9bd5', name: 'Blue +1' },
        6: { abbr: 'B2', color: '#5b9bd5', name: 'Blue +2' },
        7: { abbr: 'V', color: '#b366ff', name: 'Violet' },
        8: { abbr: 'V1', color: '#b366ff', name: 'Violet +1' },
        9: { abbr: 'V2', color: '#b366ff', name: 'Violet +2' },
        10: { abbr: 'V3', color: '#b366ff', name: 'Violet +3' },
        11: { abbr: 'O', color: '#ff9900', name: 'Orange' },
        12: { abbr: 'O1', color: '#ff9900', name: 'Orange +1' },
        13: { abbr: 'O2', color: '#ff9900', name: 'Orange +2' },
        14: { abbr: 'O3', color: '#ff9900', name: 'Orange +3' },
        15: { abbr: 'O4', color: '#ff9900', name: 'Orange +4' },
        16: { abbr: 'R', color: '#ff4444', name: 'Red' },
        17: { abbr: 'R1', color: '#ff4444', name: 'Red +1' },
        18: { abbr: 'R2', color: '#ff4444', name: 'Red +2' }
    };

    // Helper functions for max checks
    function getColorDisplay(colorNum) {
        const c = colorMap[colorNum] || { abbr: colorNum, color: '#fff', name: 'Unknown' };
        const isMax = colorNum === 18;
        return `<span style="color: ${c.color}; font-weight: bold;" title="${c.name}">${isMax ? '‚úì' : c.abbr}</span>`;
    }

    function getItemsDisplay(slots) {
        let filledCount = 0;
        if (Array.isArray(slots)) {
            filledCount = slots.filter(s => s === 0).length;
        } else if (slots && typeof slots === 'object') {
            filledCount = Object.keys(slots).length;
        }
        const isMax = filledCount === 6;
        return isMax ? '<span class="twk-green">‚úì</span>' : `<span class="twk-dim">${filledCount}/6</span>`;
    }
    function getSkinsDisplay(skins, heroId) {
        if (!skins || typeof skins !== 'object') return '-';

        // Check if skin has real stat bonuses (not cosmetic)
        const hasRealStats = (skinId) => {
            const skin = lib?.data?.skin?.[skinId];
            const bonus = skin?.statData?.levels?.[1]?.statBonus || {};
            return Object.keys(bonus).some(k => k.length > 0);
        };

        // Split owned skins into: stat skins vs cosmetic
        const skinEntries = Object.entries(skins);
        const statOwned = skinEntries.filter(([id]) => hasRealStats(id));
        const cosmeticOwned = skinEntries.filter(([id]) => !hasRealStats(id));
        const ownedIds = skinEntries.map(([id]) => parseInt(id));

        const owned = statOwned.length;
        const maxed = statOwned.filter(([, v]) => v >= 60).length;
        const cosmeticOwnedCount = cosmeticOwned.length;

        // Get available skins from lib
        let available = owned;
        let unownedEventSkins = 0;
        let unownedCosmeticSkins = 0;
        try {
            if (lib?.data?.skin) {
                const allSkins = Object.values(lib.data.skin).filter(s => s.heroId === heroId && s.enabled === 1);

                const statSkins = allSkins.filter(s => {
                    const bonus = s.statData?.levels?.[1]?.statBonus || {};
                    return Object.keys(bonus).some(k => k.length > 0);
                });

                const cosmeticSkins = allSkins.filter(s => {
                    const bonus = s.statData?.levels?.[1]?.statBonus || {};
                    return !Object.keys(bonus).some(k => k.length > 0);
                });

                // Available = obtainable stat skins + event stat skins you own
                const obtainableCount = statSkins.filter(s => !s.notObtainable).length;
                const ownedEventCount = statSkins.filter(s => s.notObtainable && ownedIds.includes(s.id)).length;
                available = obtainableCount + ownedEventCount;
                // Unowned event = stat skins with notObtainable that you don't own
                unownedEventSkins = statSkins.filter(s => s.notObtainable && !ownedIds.includes(s.id)).length;
                // Unowned cosmetic = cosmetic skins you don't own
                unownedCosmeticSkins = cosmeticSkins.filter(s => !ownedIds.includes(s.id)).length;
            }
        } catch(e) {}

        const allMaxed = owned > 0 && maxed === owned && owned >= available;
        let display;
        if (allMaxed) {
            display = `<span class="twk-green">‚úì${owned}</span>`;
        } else if (owned >= available) {
            display = `<span class="twk-dim">${maxed}/${owned}</span>`;
        } else {
            display = `<span class="twk-dim">${maxed}/${owned}/${available}</span>`;
        }

        // Orange: unowned event stat skins
        if (unownedEventSkins > 0) {
            display += `<span style="color:#ff8c00;">+${unownedEventSkins}</span>`;
        }

        // Gray: unowned cosmetic skins
        if (unownedCosmeticSkins > 0) {
            display += `<span style="color:#888;">+${unownedCosmeticSkins}</span>`;
        }

        // Cyan: owned cosmetic skins
        if (cosmeticOwnedCount > 0) {
            display += `<span style="color:#00bfff;">+${cosmeticOwnedCount}</span>`;
        }

        return display;
    }




    function getArtifactStarsDisplay(artifacts) {
        if (!artifacts || !Array.isArray(artifacts)) return '-';
        const allMaxed = artifacts.every(a => a.star >= 6);
        if (allMaxed) return '<span class="twk-green">‚úì3</span>';
        return `<span class="twk-dim">${artifacts.map(a => a.star).join('/')}</span>`;
    }

    function getArtifactLevelsDisplay(artifacts) {
        if (!artifacts || !Array.isArray(artifacts)) return '-';
        const allMaxed = artifacts.every(a => a.level >= 130);
        if (allMaxed) return '<span class="twk-green">‚úì3</span>';
        return `<span class="twk-dim">${artifacts.map(a => a.level).join('/')}</span>`;
    }

    function getSkillsDisplay(skills, heroLevel) {
        if (!skills || typeof skills !== 'object') return '-';
        const skillEntries = Object.entries(skills);
        const regularSkills = skillEntries.filter(([id]) => parseInt(id) < 8000);
        const allMaxed = regularSkills.every(([, level]) => level >= heroLevel);
        const maxedCount = regularSkills.filter(([, level]) => level >= heroLevel).length;
        return allMaxed ? `<span class="twk-green">‚úì${regularSkills.length}</span>` : `<span class="twk-dim">${maxedCount}/${regularSkills.length}</span>`;
    }

    function getGlyphsDisplay(runes) {
        if (!runes || !Array.isArray(runes)) return '-';
        const maxGlyph = 43750;
        const maxedCount = runes.filter(r => r >= maxGlyph).length;
        const allMaxed = maxedCount === 5;
        if (allMaxed) return '<span class="twk-green">‚úî5</span>';
        return `<span class="twk-gold" style="text-decoration: underline;">${maxedCount}/5</span>`;
    }

    function getAscensionsDisplay(ascensions) {
        if (!ascensions || typeof ascensions !== 'object') return '-';
        const tiers = Object.keys(ascensions).length;
        let allComplete = true;
        let completeTiers = 0;
        for (const [tier, nodes] of Object.entries(ascensions)) {
            if (!Array.isArray(nodes)) continue;
            let expected;
            if (tier === '2' || tier === '5') {
                // If has node 10 but not 9, then 9 is placeholder - expect only 10
                const has10 = nodes.includes(10);
                const has9 = nodes.includes(9);
                expected = (has10 && !has9) ? 10 : 11;
            } else {
                expected = 10;
            }
            if (nodes.length >= expected) {
                completeTiers++;
            } else {
                allComplete = false;
            }
        }
        if (allComplete && tiers > 0) return `<span class="twk-green">‚úì${tiers}</span>`;
        return `<span class="twk-dim">${completeTiers}/${tiers}</span>`;
    }
    function getAscPlusDisplay(ascensions) {
        if (!ascensions || typeof ascensions !== 'object') return '-';

        let filled = 0;
        let available = 0;

        for (const tier of ['2', '5']) {
            const nodes = ascensions[tier];
            if (!Array.isArray(nodes)) continue;

            const has9 = nodes.includes(9);
            const has10 = nodes.includes(10);

            if (has9) {
                filled++;
                available++;
            } else if (has10) {
                // Has 10 but not 9 = placeholder, don't count
            } else if (nodes.length >= 8) {
                // Far enough, slot 9 might be fillable
                available++;
            }
        }

        if (available === 0) return '<span style="color: #666;">-</span>';
        if (filled === available && filled > 0) return `<span class="twk-green">‚úì${filled}</span>`;
        return `<span class="twk-dim">${filled}/${available}</span>`;
    }
    function generateHeroesTable(heroes) {
        const heroArray = Object.values(heroes);
        const totalPower = heroArray.reduce((sum, h) => sum + h.power, 0);
        const avgLevel = (heroArray.reduce((sum, h) => sum + h.level, 0) / heroArray.length).toFixed(1);

        // Cache display values once
        if (!window.heroDisplayCache || window.heroDisplayCacheTime !== window.gameLoadData.timestamp) {
            window.heroDisplayCache = {};
            window.heroDisplayCacheTime = window.gameLoadData.timestamp;
            heroArray.forEach(h => {
                window.heroDisplayCache[h.id] = {
                    name: getName(h.id, 'hero'),
                    color: getColorDisplay(h.color),
                    items: getItemsDisplay(h.slots),
                    skins: getSkinsDisplay(h.skins, h.id),
                    artStars: getArtifactStarsDisplay(h.artifacts),
                    artLevels: getArtifactLevelsDisplay(h.artifacts),
                    skills: getSkillsDisplay(h.skills, h.level),
                    glyphs: getGlyphsDisplay(h.runes),
                    asc: getAscensionsDisplay(h.ascensions),
                    ascPlus: getAscPlusDisplay(h.ascensions)
                };
            });
        }
        const cache = window.heroDisplayCache;

        if (!window.heroTableState) {
            window.heroTableState = { hideMaxed: false, sortBy: 'power', sortDir: 'desc', nameSearch: '' };
        }
        const state = window.heroTableState;

        if (!window.heroHideMax) {
            window.heroHideMax = { core: false, stars: false, skins: false, artStars: false, artLevels: false, skills: false, glyph: false, asc: false, goe: false };
        }

        const isStarsMxd = h => h.star >= 6;
        const isGlyphsMxd = h => cache[h.id].glyphs.includes('twk-green');
        const isGoeMxd = h => h.titanGiftLevel >= 30;
        const isCoreMxd = h => h.level >= 130 && h.color >= 18 && cache[h.id].items.includes('twk-green');
        const isSkinsMxd = h => cache[h.id].skins.includes('twk-green');
        const isArtsMxd = h => cache[h.id].artStars.includes('twk-green') && cache[h.id].artLevels.includes('twk-green');
        const isSkillsMxd = h => cache[h.id].skills.includes('twk-green');
        const isAscMxd = h => cache[h.id].asc.includes('twk-green');

        let filtered = heroArray.filter(h => {
            if (state.nameSearch && !cache[h.id].name.toLowerCase().includes(state.nameSearch.toLowerCase())) return false;

            if (window.heroHideMax.core && isCoreMxd(h)) return false;
            if (window.heroHideMax.stars && isStarsMxd(h)) return false;
            if (window.heroHideMax.skins && isSkinsMxd(h)) return false;
            if (window.heroHideMax.artStars && cache[h.id].artStars.includes('twk-green')) return false;
            if (window.heroHideMax.artLevels && cache[h.id].artLevels.includes('twk-green')) return false;
            if (window.heroHideMax.skills && isSkillsMxd(h)) return false;
            if (window.heroHideMax.glyph && isGlyphsMxd(h)) return false;
            if (window.heroHideMax.asc && isAscMxd(h)) return false;
            if (window.heroHideMax.goe && isGoeMxd(h)) return false;
            return true;
        });

        filtered.sort((a, b) => {
            let aVal, bVal;
            if (state.sortBy === 'name') {
                aVal = cache[a.id].name.toLowerCase();
                bVal = cache[b.id].name.toLowerCase();
                return state.sortDir === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
            } else if (state.sortBy === 'id') {
                aVal = a.id; bVal = b.id;
            } else {
                aVal = a.power; bVal = b.power;
            }
            return state.sortDir === 'asc' ? aVal - bVal : bVal - aVal;
        });

        const sortIcon = (col) => {
            if (state.sortBy !== col) return '';
            return state.sortDir === 'asc' ? ' ‚ñ≤' : ' ‚ñº';
        };

        // HEADER: totals + thead
        const header = `
            <div style="padding: 6px; background: rgba(139,105,20,0.2); border-radius: 5px; font-size: 10px; display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <div>
                    <strong class="twk-gold">Total:</strong> <span class="twk-green">${totalPower.toLocaleString()}</span> |
                    <strong class="twk-gold">Avg Lvl:</strong> <span class="twk-green">${avgLevel}</span> |
                    <strong class="twk-gold">Showing:</strong> <span class="twk-green">${filtered.length}/${heroArray.length}</span>
                </div>
                <div>
                    <input type="text" id="heroNameSearch" placeholder="Search name..." value="${state.nameSearch || ''}" style="padding: 3px 6px; border: 1px solid #8b6914; border-radius: 3px; background: #1a0f08; color: #ffd700; font-size: 11px; width: 120px;">
                </div>
            </div>
            <table style="width: 100%; border-collapse: collapse; font-size: 12px; table-layout: fixed;">
<thead>
    <tr class="twk-th" style="background: #8b6914;">
        <th style="padding: 5px; width: 35px;">üéÆ</th>
        <th style="padding: 5px; text-align: left; width: 100px; cursor: pointer;" onclick="window.sortHeroTable('name')">Name${sortIcon('name')}</th>
        <th style="padding: 5px; width: 30px; cursor: pointer;" onclick="window.sortHeroTable('id')">ID${sortIcon('id')}</th>
        <th style="padding: 5px; width: 35px;">Lvl</th>
        <th style="padding: 5px; width: 50px;">Color</th>
        <th style="padding: 5px; width: 40px;">Items</th>
        <th style="padding: 5px; width: 30px;">‚òÖ</th>
        <th style="padding: 5px; width: 65px; cursor: pointer;" onclick="window.sortHeroTable('power')">Power${sortIcon('power')}</th>
        <th style="padding: 5px; width: 45px;">Skins</th>
     <th style="padding: 5px; width: 45px;" title="Artifact Stars">Art‚≠ê</th>
        <th style="padding: 5px; width: 55px;" title="Artifact Levels">Artüìä</th>
        <th style="padding: 5px; width: 45px;">Skills</th>
        <th style="padding: 5px; width: 35px;">Prks</th>
        <th style="padding: 5px; width: 50px;">Glyph</th>
        <th style="padding: 5px; width: 45px;">Asc</th>
        <th style="padding: 5px; width: 30px;" title="Bonus ascension slots (node 9)">Asc+</th>
        <th style="padding: 5px; width: 40px;">GoE</th>
    </tr>
    <tr style="background: #6b5010; font-size: 10px;">
        <th></th>
        <th></th>
        <th></th>
        <th></th>
<th><input type="checkbox" id="heroHideCore1" ${window.heroHideMax.core ? 'checked' : ''} title="Hide maxed"></th>
<th><input type="checkbox" id="heroHideCore2" ${window.heroHideMax.core ? 'checked' : ''} title="Hide maxed"></th>
        <th><input type="checkbox" id="heroHideStars" ${window.heroHideMax.stars ? 'checked' : ''} title="Hide maxed"></th>
        <th></th>
        <th><input type="checkbox" id="heroHideSkins" ${window.heroHideMax.skins ? 'checked' : ''} title="Hide maxed"></th>
<th><input type="checkbox" id="heroHideArtStars" ${window.heroHideMax.artStars ? 'checked' : ''} title="Hide maxed"></th>
        <th><input type="checkbox" id="heroHideArtLevels" ${window.heroHideMax.artLevels ? 'checked' : ''} title="Hide maxed"></th>
        <th><input type="checkbox" id="heroHideSkills" ${window.heroHideMax.skills ? 'checked' : ''} title="Hide maxed"></th>
        <th></th>
        <th><input type="checkbox" id="heroHideGlyph" ${window.heroHideMax.glyph ? 'checked' : ''} title="Hide maxed"></th>
        <th><input type="checkbox" id="heroHideAsc" ${window.heroHideMax.asc ? 'checked' : ''} title="Hide maxed"></th>
        <th></th>
        <th><input type="checkbox" id="heroHideGoe" ${window.heroHideMax.goe ? 'checked' : ''} title="Hide maxed"></th>
    </tr>
</thead>
            </table>
        `;

        // BODY: tbody rows
        let body = `
            <table style="width: 100%; border-collapse: collapse; font-size: 12px; table-layout: fixed;">
<colgroup>
    <col style="width: 35px;"><col style="width: 100px;"><col style="width: 30px;"><col style="width: 35px;">
    <col style="width: 50px;"><col style="width: 40px;"><col style="width: 30px;"><col style="width: 65px;">
    <col style="width: 45px;"><col style="width: 45px;"><col style="width: 55px;"><col style="width: 45px;"><col style="width: 35px;">
    <col style="width: 50px;"><col style="width: 45px;"><col style="width: 30px;"><col style="width: 40px;">
</colgroup>
                <tbody>
        `;

        filtered.forEach((hero, index) => {
            const bgColor = index % 2 === 0 ? 'rgba(0, 0, 0, 0.15)' : 'rgba(0, 0, 0, 0.25)';
            const levelDisplay = hero.level >= 130 ? '<span class="twk-green">‚úì</span>' : `<span class="twk-dim">${hero.level}</span>`;
            const starsDisplay = hero.star >= 6 ? '<span class="twk-green">‚úì</span>' : `<span class="twk-gold">${hero.star}</span>`;
            const perksCount = Array.isArray(hero.perks) ? hero.perks.length : 0;

            body += `
                <tr style="background: ${bgColor}; border-bottom: 1px solid #333;">
                    <td class="twk-cell"><button onclick="event.stopPropagation(); window.openUnitInGame('hero', ${hero.id})" style="background: #2a5a2a; color: #fff; border: 1px solid #1a4a1a; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 10px;">Go</button></td>
<td style="padding: 3px; font-weight: bold; color: #ffd700; cursor: pointer; text-decoration: underline; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" onclick="window.openUnitInGame('hero', ${hero.id})">${cache[hero.id].name}</td>
                    <td style="padding: 3px; text-align: center; color: #999; font-size: 10px;">${hero.id}</td>
                    <td class="twk-cell">${levelDisplay}</td>
<td class="twk-cell">${cache[hero.id].color}</td>
<td class="twk-cell">${cache[hero.id].items}</td>
                    <td class="twk-cell">${starsDisplay}</td>
                    <td style="padding: 3px; text-align: right; font-family: monospace; color: #fff;">${hero.power.toLocaleString()}</td>
<td class="twk-cell">${cache[hero.id].skins}</td>
<td class="twk-cell">${cache[hero.id].artStars}</td>
<td class="twk-cell">${cache[hero.id].artLevels}</td>
<td class="twk-cell">${cache[hero.id].skills}</td>
<td class="twk-cell" style="color: #ccc;">${perksCount}</td>
<td class="twk-cell" style="cursor: pointer;" onclick="window.showGlyphUpgrade(${hero.id}, '${cache[hero.id].name.replace(/'/g, "\\'")}')">${cache[hero.id].glyphs}</td>
<td class="twk-cell">${cache[hero.id].asc}</td>
<td class="twk-cell">${cache[hero.id].ascPlus}</td>
                    <td class="twk-cell">${hero.titanGiftLevel >= 30 ? '<span class="twk-green">‚úì</span>' : `<span class="twk-dim">${hero.titanGiftLevel || 0}/30</span>`}</td>
                </tr>
            `;
        });

        body += `</tbody></table>`;

        // Event listeners
        setTimeout(() => {
            const keyMap = { Stars: 'stars', Skins: 'skins', ArtStars: 'artStars', ArtLevels: 'artLevels', Skills: 'skills', Glyph: 'glyph', Asc: 'asc', Goe: 'goe' };
            Object.keys(keyMap).forEach(key => {
                const cb = document.getElementById('heroHide' + key);
                if (cb) {
                    cb.onchange = function() {
                        window.heroHideMax[keyMap[key]] = this.checked;
                        const parts = generateHeroesTable(window.gameLoadData.heroes);
                        document.getElementById('tab-header').innerHTML = parts.header;
                        document.getElementById('tab-content').innerHTML = parts.body;
                    };
                }
            });
            // Handle linked Core checkboxes
            ['heroHideCore1', 'heroHideCore2'].forEach(id => {
                const cb = document.getElementById(id);
                if (cb) {
                    cb.onchange = function() {
                        window.heroHideMax.core = this.checked;
                        const parts = generateHeroesTable(window.gameLoadData.heroes);
                        document.getElementById('tab-header').innerHTML = parts.header;
                        document.getElementById('tab-content').innerHTML = parts.body;
                    };
                }
            });
            const searchInput = document.getElementById('heroNameSearch');
            if (searchInput) {
                searchInput.oninput = function() {
                    window.heroTableState.nameSearch = this.value;
                    const parts = generateHeroesTable(window.gameLoadData.heroes);
                    document.getElementById('tab-header').innerHTML = parts.header;
                    document.getElementById('tab-content').innerHTML = parts.body;
                    const newInput = document.getElementById('heroNameSearch');
                    if (newInput) { newInput.focus(); newInput.setSelectionRange(this.value.length, this.value.length); }
                };
            }
        }, 10);

        return { header, body };
    }

    unsafeWindow.sortHeroTable = window.sortHeroTable = function(column) {
        if (!window.heroTableState) {
            window.heroTableState = { sortBy: 'power', sortDir: 'desc', nameSearch: '' };
        }
        if (window.heroTableState.sortBy === column) {
            window.heroTableState.sortDir = window.heroTableState.sortDir === 'asc' ? 'desc' : 'asc';
        } else {
            window.heroTableState.sortBy = column;
            window.heroTableState.sortDir = column === 'name' ? 'asc' : 'desc';
        }
        const parts = generateHeroesTable(window.gameLoadData.heroes);
        document.getElementById('tab-header').innerHTML = parts.header;
        document.getElementById('tab-content').innerHTML = parts.body;
    };
    function generateTitansTable(titans) {
        if (!window.titanTableState) {
            window.titanTableState = { sortBy: 'power', sortDir: 'desc' };
        }
        const state = window.titanTableState;


        const sortIcon = (col) => {
            if (state.sortBy !== col) return '';
            return state.sortDir === 'asc' ? ' ‚ñ≤' : ' ‚ñº';
        };

        const titanArray = Object.values(titans);
        const totalPower = titanArray.reduce((sum, t) => sum + t.power, 0);
        const avgLevel = (titanArray.reduce((sum, t) => sum + t.level, 0) / titanArray.length).toFixed(1);

        titanArray.sort((a, b) => {
            let aVal, bVal;
            if (state.sortBy === 'name') {
                aVal = getName(a.id, 'titan').toLowerCase();
                bVal = getName(b.id, 'titan').toLowerCase();
                return state.sortDir === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
            } else if (state.sortBy === 'id') {
                aVal = a.id; bVal = b.id;
            } else {
                aVal = a.power; bVal = b.power;
            }
            return state.sortDir === 'asc' ? aVal - bVal : bVal - aVal;
        });

        if (!window.titanTableState) { window.titanTableState = { nameSearch: '' }; }
        if (!window.titanHideMax) { window.titanHideMax = { stars: false, skins: false, artStars: false, artLevels: false, skills: false }; }
        const isStarsMxd = t => t.star >= 6;
        const isSkinsMxd = t => {
            if (!t.skins || typeof t.skins !== 'object') return false;
            const vals = Object.values(t.skins);
            return vals.length > 0 && vals.every(s => s >= 60);
        };
        const isArtStarsMxd = t => {
            const arts = t.artifacts || [];
            return arts.length >= 3 && arts.every(a => a.star >= 6);
        };
        const isArtLevelsMxd = t => {
            const arts = t.artifacts || [];
            return arts.length >= 3 && arts.every(a => a.level >= 130);
        };
        const isSkillsMxd = t => {
            const skills = t.skills || {};
            const vals = Object.values(skills);
            return vals.length > 0 && vals.every(s => s >= 130);
        };

        let filtered = titanArray.filter(t => {
            if (window.titanTableState.nameSearch && !getName(t.id, 'titan').toLowerCase().includes(window.titanTableState.nameSearch.toLowerCase())) return false;
            if (window.titanHideMax.stars && isStarsMxd(t)) return false;
            if (window.titanHideMax.skins && isSkinsMxd(t)) return false;
            if (window.titanHideMax.artStars && isArtStarsMxd(t)) return false;
            if (window.titanHideMax.artLevels && isArtLevelsMxd(t)) return false;
            if (window.titanHideMax.skills && isSkillsMxd(t)) return false;
            return true;
        });

        const header = `
            <div style="padding: 6px; background: rgba(139,105,20,0.2); border-radius: 5px; font-size: 10px; display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <div>
                    <strong class="twk-gold">Total:</strong> <span class="twk-green">${totalPower.toLocaleString()}</span> |
                    <strong class="twk-gold">Avg Lvl:</strong> <span class="twk-green">${avgLevel}</span> |
                    <strong class="twk-gold">Showing:</strong> <span class="twk-green">${filtered.length}/${titanArray.length}</span>
                </div>
                <div>
                    <input type="text" id="titanNameSearch" placeholder="Search name..." value="${window.titanTableState.nameSearch || ''}" style="padding: 3px 6px; border: 1px solid #8b6914; border-radius: 3px; background: #1a0f08; color: #ffd700; font-size: 11px; width: 120px;">
                </div>
            </div>
            <table style="width: 100%; border-collapse: collapse; font-size: 12px; table-layout: fixed;">
<thead>
    <tr class="twk-th" style="background: #8b6914;">
        <th style="padding: 5px; width: 35px;">üéÆ</th>
        <th style="padding: 5px; text-align: left; width: 100px; cursor: pointer;" onclick="window.sortTitanTable('name')">Name${sortIcon('name')}</th>
<th style="padding: 5px; width: 45px; cursor: pointer;" onclick="window.sortTitanTable('id')">ID${sortIcon('id')}</th>
<th style="padding: 5px; width: 45px;">Level</th>
<th style="padding: 5px; width: 35px;">‚òÖ</th>
<th style="padding: 5px; text-align: right; width: 75px; cursor: pointer;" onclick="window.sortTitanTable('power')">Power${sortIcon('power')}</th>
        <th style="padding: 5px; width: 50px;">Skins</th>
<th style="padding: 5px; width: 45px;" title="Artifact Stars">Art‚≠ê</th>
        <th style="padding: 5px; width: 55px;" title="Artifact Levels">Artüìä</th>
        <th style="padding: 5px; width: 50px;">Skills</th>
    </tr>
    <tr style="background: #6b5010; font-size: 10px;">
        <th></th>
        <th></th>
        <th></th>
        <th></th>
        <th><input type="checkbox" id="titanHideStars" ${window.titanHideMax.stars ? 'checked' : ''} title="Hide maxed"></th>
        <th></th>
        <th><input type="checkbox" id="titanHideSkins" ${window.titanHideMax.skins ? 'checked' : ''} title="Hide maxed"></th>
<th><input type="checkbox" id="titanHideArtStars" ${window.titanHideMax.artStars ? 'checked' : ''} title="Hide maxed"></th>
        <th><input type="checkbox" id="titanHideArtLevels" ${window.titanHideMax.artLevels ? 'checked' : ''} title="Hide maxed"></th>
        <th><input type="checkbox" id="titanHideSkills" ${window.titanHideMax.skills ? 'checked' : ''} title="Hide maxed"></th>
    </tr>
</thead>
            </table>
        `;

        let body = `
            <table style="width: 100%; border-collapse: collapse; font-size: 12px; table-layout: fixed;">
                <colgroup>
                    <col style="width: 35px;"><col style="width: 100px;"><col style="width: 45px;"><col style="width: 45px;">
<col style="width: 35px;"><col style="width: 75px;"><col style="width: 50px;"><col style="width: 45px;"><col style="width: 55px;"><col style="width: 50px;">
</colgroup>
                <tbody>
        `;

        filtered.forEach((titan, index) => {
            const bgColor = index % 2 === 0 ? 'rgba(0, 0, 0, 0.15)' : 'rgba(0, 0, 0, 0.25)';
            const levelDisplay = titan.level >= 130 ? '<span class="twk-green">‚úì</span>' : `<span class="twk-dim">${titan.level}</span>`;
            const starsDisplay = titan.star >= 6 ? '<span class="twk-green">‚úì</span>' : `<span class="twk-gold">${titan.star}</span>`;

            const skinsDisplay = getSkinsDisplay(titan.skins, titan.id);

            const arts = titan.artifacts || [];
            const artStarsMaxed = arts.length >= 3 && arts.every(a => a.star >= 6);
            const artStarsDisplay = artStarsMaxed ? '<span class="twk-green">‚úì3</span>' : `<span class="twk-dim">${arts.map(a => a.star).join('/')}</span>`;
            const artLevelsMaxed = arts.length >= 3 && arts.every(a => a.level >= 130);
            const artLevelsDisplay = artLevelsMaxed ? '<span class="twk-green">‚úì3</span>' : `<span class="twk-dim">${arts.map(a => a.level).join('/')}</span>`;

            const skills = titan.skills || {};
            const skillVals = Object.values(skills);
            const skillsMaxed = skillVals.length > 0 && skillVals.every(s => s >= 130);
            const skillsDisplay = skillsMaxed ? '<span class="twk-green">‚úì</span>' : `<span class="twk-dim">${skillVals.filter(s => s >= 130).length}/${skillVals.length}</span>`;

            body += `
                <tr style="background: ${bgColor}; border-bottom: 1px solid #333;">
                    <td class="twk-cell"><button onclick="window.openUnitInGame('titan', ${titan.id})" style="background: #2a5a2a; color: #fff; border: 1px solid #1a4a1a; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 10px;">Go</button></td>
                    <td style="padding: 3px; font-weight: bold; color: #ffd700; cursor: pointer; text-decoration: underline; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" onclick="window.openUnitInGame('titan', ${titan.id})">${getName(titan.id, 'titan')}</td>
                    <td style="padding: 3px; text-align: center; color: #999; font-size: 10px;">${titan.id}</td>
                    <td class="twk-cell">${levelDisplay}</td>
                    <td class="twk-cell">${starsDisplay}</td>
                    <td style="padding: 3px; text-align: right; font-family: monospace; color: #fff;">${titan.power.toLocaleString()}</td>
                    <td class="twk-cell">${skinsDisplay}</td>
<td class="twk-cell">${artStarsDisplay}</td>
                    <td class="twk-cell">${artLevelsDisplay}</td>
                    <td class="twk-cell">${skillsDisplay}</td>
                </tr>
            `;
        });

        body += `</tbody></table>`;

        setTimeout(() => {
            const searchInput = document.getElementById('titanNameSearch');
            if (searchInput) {
                searchInput.oninput = function() {
                    window.titanTableState.nameSearch = this.value;
                    const parts = generateTitansTable(window.gameLoadData.titans);
                    document.getElementById('tab-header').innerHTML = parts.header;
                    document.getElementById('tab-content').innerHTML = parts.body;
                    const newInput = document.getElementById('titanNameSearch');
                    if (newInput) { newInput.focus(); newInput.setSelectionRange(this.value.length, this.value.length); }
                };
            }
            const keyMap = { Stars: 'stars', Skins: 'skins', ArtStars: 'artStars', ArtLevels: 'artLevels', Skills: 'skills' };
            Object.keys(keyMap).forEach(key => {
                const cb = document.getElementById('titanHide' + key);
                if (cb) {
                    cb.onchange = function() {
                        window.titanHideMax[keyMap[key]] = this.checked;
                        const parts = generateTitansTable(window.gameLoadData.titans);
                        document.getElementById('tab-header').innerHTML = parts.header;
                        document.getElementById('tab-content').innerHTML = parts.body;
                    };
                }
            });
        }, 10);

        return { header, body };
    }
    unsafeWindow.sortTitanTable = window.sortTitanTable = function(column) {
        if (!window.titanTableState) {
            window.titanTableState = { sortBy: 'power', sortDir: 'desc', nameSearch: '' };
        }
        if (window.titanTableState.sortBy === column) {
            window.titanTableState.sortDir = window.titanTableState.sortDir === 'asc' ? 'desc' : 'asc';
        } else {
            window.titanTableState.sortBy = column;
            window.titanTableState.sortDir = column === 'name' ? 'asc' : 'desc';
        }
        const parts = generateTitansTable(window.gameLoadData.titans);
        document.getElementById('tab-header').innerHTML = parts.header;
        document.getElementById('tab-content').innerHTML = parts.body;
    };

    function generatePetsTable(pets) {
        if (!window.petTableState) {
            window.petTableState = { sortBy: 'power', sortDir: 'desc' };
        }
        const state = window.petTableState;


        const sortIcon = (col) => {
            if (state.sortBy !== col) return '';
            return state.sortDir === 'asc' ? ' ‚ñ≤' : ' ‚ñº';
        };

        const petArray = [...pets];
        const totalPower = petArray.reduce((sum, p) => sum + p.power, 0);
        const avgLevel = (petArray.reduce((sum, p) => sum + p.level, 0) / petArray.length).toFixed(1);

        petArray.sort((a, b) => {
            let aVal, bVal;
            if (state.sortBy === 'name') {
                aVal = getName(a.id, 'pet').toLowerCase();
                bVal = getName(b.id, 'pet').toLowerCase();
                return state.sortDir === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
            } else if (state.sortBy === 'id') {
                aVal = a.id; bVal = b.id;
            } else {
                aVal = a.power; bVal = b.power;
            }
            return state.sortDir === 'asc' ? aVal - bVal : bVal - aVal;
        });
        const colorNames = {
            1: 'White', 2: 'Grn', 3: 'Grn+1', 4: 'Blu', 5: 'Blu+1',
            6: 'Blu+2', 7: 'Vio', 8: 'Vio+1', 9: 'Vio+2', 10: 'Vio+3'
        };

        if (!window.petHideMax) { window.petHideMax = { color: false, gems: false, stars: false, skills: false }; }

        const isColorMxd = p => p.color >= 10;

        const getPetSlotMax = (color) => {
            const maxes = {
                1:  [5, 5, 5, 5, 5, 5],
                2:  [5, 5, 5, 5, 10, 10],
                3:  [5, 5, 10, 10, 10, 10],
                4:  [10, 10, 15, 10, 10, 15],
                5:  [10, 15, 15, 10, 15, 15],
                6:  [15, 15, 20, 15, 15, 20],
                7:  [20, 20, 25, 20, 20, 25],
                8:  [20, 25, 25, 20, 25, 25],
                9:  [25, 25, 50, 25, 25, 50],
                10: [25, 50, 50, 25, 50, 50]
            };
            return maxes[color] || maxes[10];
        };

        const isGemsMxd = p => {
            if (!p.slots || typeof p.slots !== 'object') return false;
            const s = p.slots;
            const g = i => s[i] ?? s[String(i)] ?? 0;
            const max = getPetSlotMax(p.color);
            return g(0) >= max[0] && g(1) >= max[1] && g(2) >= max[2] && g(3) >= max[3] && g(4) >= max[4] && g(5) >= max[5];
        };
        const isStarsMxd = p => p.star >= 6;
        const isSkillsMxd = p => {
            const skills = p.skills || {};
            const vals = Object.values(skills);
            return vals.length > 0 && vals.every(s => s >= 130);
        };

        let filtered = petArray.filter(p => {
            if (window.petHideMax.color && isColorMxd(p)) return false;
            if (window.petHideMax.gems && isGemsMxd(p)) return false;
            if (window.petHideMax.stars && isStarsMxd(p)) return false;
            if (window.petHideMax.skills && isSkillsMxd(p)) return false;
            return true;
        });

        const header = `
            <div style="padding: 6px; background: rgba(139,105,20,0.2); border-radius: 5px; font-size: 10px; margin-bottom: 8px;">
                <strong class="twk-gold">Total:</strong> <span class="twk-green">${totalPower.toLocaleString()}</span> |
                <strong class="twk-gold">Avg Lvl:</strong> <span class="twk-green">${avgLevel}</span> |
                <strong class="twk-gold">Showing:</strong> <span class="twk-green">${filtered.length}/${petArray.length}</span>
            </div>
            <table style="width: 100%; border-collapse: collapse; font-size: 12px; table-layout: fixed;">
<thead>
    <tr class="twk-th" style="background: #8b6914;">
        <th style="padding: 5px; width: 35px;">üéÆ</th>
<th style="padding: 5px; text-align: left; width: 100px; cursor: pointer;" onclick="window.sortPetTable('name')">Name${sortIcon('name')}</th>
<th style="padding: 5px; width: 45px; cursor: pointer;" onclick="window.sortPetTable('id')">ID${sortIcon('id')}</th>
<th style="padding: 5px; width: 45px;">Level</th>
<th style="padding: 5px; width: 55px;">Color</th>
<th style="padding: 5px; width: 50px;" title="Gems maxed for color">Gems</th>
<th style="padding: 5px; width: 35px;">‚òÖ</th>
<th style="padding: 5px; text-align: right; width: 75px; cursor: pointer;" onclick="window.sortPetTable('power')">Power${sortIcon('power')}</th>
        <th style="padding: 5px; width: 50px;">Skills</th>
    </tr>
    <tr style="background: #6b5010; font-size: 10px;">
        <th></th>
        <th></th>
        <th></th>
        <th></th>
        <th><input type="checkbox" id="petHideColor" ${window.petHideMax.color ? 'checked' : ''} title="Hide maxed"></th>
        <th><input type="checkbox" id="petHideGems" ${window.petHideMax.gems ? 'checked' : ''} title="Hide maxed"></th>
        <th><input type="checkbox" id="petHideStars" ${window.petHideMax.stars ? 'checked' : ''} title="Hide maxed"></th>
        <th></th>
        <th><input type="checkbox" id="petHideSkills" ${window.petHideMax.skills ? 'checked' : ''} title="Hide maxed"></th>
    </tr>
</thead>
            </table>
        `;

        let body = `
            <table style="width: 100%; border-collapse: collapse; font-size: 12px; table-layout: fixed;">
                <colgroup>
                    <col style="width: 35px;"><col style="width: 100px;"><col style="width: 45px;"><col style="width: 45px;">
                    <col style="width: 55px;"><col style="width: 50px;"><col style="width: 35px;"><col style="width: 75px;"><col style="width: 50px;">
                </colgroup>
                <tbody>
        `;

        filtered.forEach((pet, index) => {
            const bgColor = index % 2 === 0 ? 'rgba(0, 0, 0, 0.15)' : 'rgba(0, 0, 0, 0.25)';
            const levelDisplay = pet.level >= 130 ? '<span class="twk-green">‚úì</span>' : `<span class="twk-dim">${pet.level}</span>`;
            const colorDisplay = pet.color >= 10 ? '<span class="twk-green">‚úì</span>' : `<span class="twk-dim">${colorNames[pet.color] || pet.color}</span>`;

            let gemsDisplay = '-';
            if (pet.slots && typeof pet.slots === 'object') {
                const s = pet.slots;
                const g = i => s[i] ?? s[String(i)] ?? 0;
                const max = getPetSlotMax(pet.color);
                let maxed = 0;
                for (let i = 0; i < 6; i++) {
                    if (g(i) >= max[i]) maxed++;
                }
                gemsDisplay = maxed >= 6 ? '<span class="twk-green">‚úì</span>' : `<span class="twk-dim">${maxed}/6</span>`;
            }

            const starsDisplay = pet.star >= 6 ? '<span class="twk-green">‚úì</span>' : `<span class="twk-gold">${pet.star}</span>`;

            const skills = pet.skills || {};
            const skillVals = Object.values(skills);
            const skillsMaxed = skillVals.length > 0 && skillVals.every(s => s >= 130);
            const skillsDisplay = skillsMaxed ? '<span class="twk-green">‚úì</span>' : `<span class="twk-dim">${skillVals.filter(s => s >= 130).length}/${skillVals.length}</span>`;

            body += `
                <tr style="background: ${bgColor}; border-bottom: 1px solid #333;">
                    <td class="twk-cell"><button onclick="window.openUnitInGame('pet', ${pet.id})" style="background: #2a5a2a; color: #fff; border: 1px solid #1a4a1a; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 10px;">Go</button></td>
                    <td style="padding: 3px; font-weight: bold; color: #ffd700; cursor: pointer; text-decoration: underline; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" onclick="window.openUnitInGame('pet', ${pet.id})">${getName(pet.id, 'pet')}</td>
                    <td style="padding: 3px; text-align: center; color: #999; font-size: 10px;">${pet.id}</td>
                    <td class="twk-cell">${levelDisplay}</td>
                    <td class="twk-cell">${colorDisplay}</td>
                    <td class="twk-cell">${gemsDisplay}</td>
                    <td class="twk-cell">${starsDisplay}</td>
                    <td style="padding: 3px; text-align: right; font-family: monospace; color: #fff;">${pet.power.toLocaleString()}</td>
                    <td class="twk-cell">${skillsDisplay}</td>
                </tr>
            `;
        });

        body += `</tbody></table>`;

        setTimeout(() => {
            ['Color', 'Gems', 'Stars', 'Skills'].forEach(key => {
                const cb = document.getElementById('petHide' + key);
                if (cb) {
                    cb.onchange = function() {
                        window.petHideMax[key.toLowerCase()] = this.checked;
                        const parts = generatePetsTable(window.gameLoadData.pets);
                        document.getElementById('tab-header').innerHTML = parts.header;
                        document.getElementById('tab-content').innerHTML = parts.body;
                    };
                }
            });
        }, 10);

        return { header, body };
    }
    unsafeWindow.sortPetTable = window.sortPetTable = function(column) {
        if (!window.petTableState) {
            window.petTableState = { sortBy: 'power', sortDir: 'desc' };
        }
        if (window.petTableState.sortBy === column) {
            window.petTableState.sortDir = window.petTableState.sortDir === 'asc' ? 'desc' : 'asc';
        } else {
            window.petTableState.sortBy = column;
            window.petTableState.sortDir = column === 'name' ? 'asc' : 'desc';
        }
        const parts = generatePetsTable(window.gameLoadData.pets);
        document.getElementById('tab-header').innerHTML = parts.header;
        document.getElementById('tab-content').innerHTML = parts.body;
    };

    function generateFlagsTable(flags) {
        if (!flags || Object.keys(flags).length === 0) {
            return { header: '', body: '<div style="padding: 20px; text-align: center; color: #999;">No flag data available</div>' };
        }

        let allSlots = [];
        Object.values(flags).forEach(banner => {
            if (banner.slots) {
                const bannerName = window.identifyItem?.(banner.id, 'banner') || `Banner ${banner.id}`;
                if (Array.isArray(banner.slots)) {
                    banner.slots.forEach((slotId, idx) => {
                        const stoneData = lib?.data?.inventoryItem?.bannerStone?.[slotId];
                        const mainBuffId = stoneData?.mainBuffId;
                        const pct = mainBuffId && stoneData?.buffs?.[mainBuffId];
                        allSlots.push({
                            bannerId: banner.id, bannerName, slotKey: idx, slotId,
                            patternName: window.identifyItem?.(slotId, 'bannerStone') || `Pattern ${slotId}`,
                            level: stoneData?.level !== undefined ? stoneData.level + 1 : '?',
                            pctRaw: pct, pct: pct !== undefined ? (pct > 0 ? `+${pct}%` : `${pct}%`) : '?'
                        });
                    });
                } else {
                    Object.entries(banner.slots).forEach(([slotKey, slotId]) => {
                        const stoneData = lib?.data?.inventoryItem?.bannerStone?.[slotId];
                        const mainBuffId = stoneData?.mainBuffId;
                        const pct = mainBuffId && stoneData?.buffs?.[mainBuffId];
                        allSlots.push({
                            bannerId: banner.id, bannerName, slotKey, slotId,
                            patternName: window.identifyItem?.(slotId, 'bannerStone') || `Pattern ${slotId}`,
                            level: stoneData?.level !== undefined ? stoneData.level + 1 : '?',
                            pctRaw: pct, pct: pct !== undefined ? (pct > 0 ? `+${pct}%` : `${pct}%`) : '?'
                        });
                    });
                }
            }
        });

        const header = `
            <div style="padding: 6px; background: rgba(139,105,20,0.2); border-radius: 5px; font-size: 10px; margin-bottom: 8px;">
                <strong class="twk-gold">Total Banners:</strong> <span class="twk-green">${Object.keys(flags).length}</span> |
                <strong class="twk-gold">Total Slots:</strong> <span class="twk-green">${allSlots.length}</span>
            </div>
            <div style="padding: 8px; background: rgba(0,0,0,0.3); border-radius: 5px; font-size: 10px; color: #ccc; margin-bottom: 8px;">
                <strong class="twk-gold">üß© Pattern Ranges (White ‚Üí Ultimate-6):</strong><br>
                <span class="twk-green">Magic Atk</span>: 1.15-16% |
                <span class="twk-green">Magic Def</span>: 2-24% |
                <span class="twk-green">Physical Atk</span>: 1-14% |
                <span class="twk-green">Armor</span>: 1.5-18%<br>
                <span class="twk-red">Enemy Dodge</span>: 1.5-22% |
                <span class="twk-green">Armor Pen</span>: 1-12% |
                <span class="twk-red">Enemy Crit</span>: 1-22% |
                <span class="twk-green">Magic Pen</span>: 1-12%<br>
                <span class="twk-green">Magic Mastery</span>: MAtk 0.5-8% + MPen 0.5-6% |
                <span class="twk-green">Health</span>: 1-13%
            </div>
            <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                <thead>
                    <tr class="twk-th" style="background: #8b6914;">
                        <th style="padding: 5px;">Banner</th>
                        <th style="padding: 5px; width: 50px;">Slot</th>
                        <th style="padding: 5px;">Pattern</th>
                        <th style="padding: 5px; width: 50px;">Tier</th>
                        <th style="padding: 5px; width: 70px;">Buff</th>
                    </tr>
                </thead>
            </table>
        `;

        let body = `<table style="width: 100%; border-collapse: collapse; font-size: 12px;"><tbody>`;

        allSlots.forEach((slot, index) => {
            const bgColor = index % 2 === 0 ? 'rgba(0, 0, 0, 0.15)' : 'rgba(0, 0, 0, 0.25)';
            const pctColor = slot.pctRaw !== undefined && slot.pctRaw < 0 ? '#ff6b6b' : '#4ae29a';
            body += `
                <tr style="background: ${bgColor}; border-bottom: 1px solid #333;">
                    <td style="padding: 5px; color: #ffd700; cursor: pointer; text-decoration: underline; font-weight: bold;" onclick="window.openUnitInGame('flag', ${slot.bannerId})">${slot.bannerName}</td>
                    <td style="padding: 5px; text-align: center; font-family: monospace; color: #fff; width: 50px;">${slot.slotKey !== undefined ? slot.slotKey : '-'}</td>
                    <td style="padding: 5px; color: #4ae29a; font-weight: bold;">${slot.patternName}</td>
                    <td style="padding: 5px; text-align: center; color: #ff9; font-weight: bold; width: 50px;">${slot.level}</td>
                    <td style="padding: 5px; text-align: center; color: ${pctColor}; font-weight: bold; width: 70px;">${slot.pct}</td>
                </tr>
            `;
        });

        body += `</tbody></table>`;
        return { header, body };
    }

    ModuleTracker.register('Game Data Table');
    // STEP 3: Main unified window display function
    function displayUnifiedAoCWindow(liveData) {
        const existingPopup = document.getElementById('aoc-unified-popup');
        if (existingPopup) {
            existingPopup.remove();
        }

        // Load historical AoC data
        let aocHistoricalData = [];
        try {
            const stored = localStorage.getItem('hwh_aoc_history');
            if (stored) {
                aocHistoricalData = JSON.parse(stored);
            }
        } catch (e) {
            aocHistoricalData = [];
        }

        // Retention: 7 days
        const AOC_RETENTION_MS = 7 * 24 * 60 * 60 * 1000;
        const now = Date.now();
        aocHistoricalData = aocHistoricalData.filter(entry => now - entry.timestamp < AOC_RETENTION_MS);
        // Skip snapshot saving if showing historical data
        const isHistorical = liveData.eventEnded === true;
        // Get guild data for snapshot
        const stats = liveData.dominationStats || {};
        const clansData = liveData.mapState?.clans || {};

        if (!isHistorical) {
            // Check if we have a zero baseline (first entry should have all coins = 0)
            const hasZeroBaseline = aocHistoricalData.length > 0 &&
                  Object.values(aocHistoricalData[0].guilds || {}).every(g => g.coins === 0);

            // If no zero baseline exists, add one at 2:00 UTC
            if (!hasZeroBaseline) {
                // Find the 2:00 UTC BEFORE our first real data point
                const firstTime = aocHistoricalData.length > 0 ? aocHistoricalData[0].timestamp : now;
                const startDate = new Date(Date.UTC(
                    new Date(firstTime).getUTCFullYear(),
                    new Date(firstTime).getUTCMonth(),
                    new Date(firstTime).getUTCDate(),
                    2, 0, 0, 0
                ));
                // If 2:00 UTC is after first data, go back a day
                if (startDate.getTime() > firstTime) {
                    startDate.setUTCDate(startDate.getUTCDate() - 1);
                }
                const startSnapshot = {
                    timestamp: startDate.getTime(),
                    guilds: {}
                };
                for (const [guildId, guildStats] of Object.entries(stats)) {
                    const clanInfo = clansData[guildId] || {};
                    startSnapshot.guilds[guildId] = {
                        title: clanInfo.title || `Guild ${guildId}`,
                        coins: 0,
                        towns: 0,
                        power: 0
                    };
                }
                // Insert at beginning
                aocHistoricalData.unshift(startSnapshot);
            }

            // Save current snapshot to history
            const currentSnapshot = {
                timestamp: now,
                guilds: {}
            };
            for (const [guildId, guildStats] of Object.entries(stats)) {
                const clanInfo = clansData[guildId] || {};
                currentSnapshot.guilds[guildId] = {
                    title: clanInfo.title || `Guild ${guildId}`,
                    coins: guildStats.coins || 0,
                    towns: guildStats.towns || 0,
                    power: guildStats.power || 0
                };
            }
            aocHistoricalData.push(currentSnapshot);

            // Save to localStorage
            try {
                localStorage.setItem('hwh_aoc_history', JSON.stringify(aocHistoricalData));
            } catch (e) {
                console.error('Failed to save AoC history:', e);
            }

            window._aocAutoRefresh.lastRefresh = now;
        }


        const backdrop = document.createElement('div');
        backdrop.id = 'aoc-unified-popup';
        backdrop.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.5); z-index: 10000;
display: flex; align-items: center; justify-content: center;
`;

        // Get canvas width for popup sizing
        const gameCanvas = DOMCache.get('gameCanvas', 'canvas');
        const popupWidth = gameCanvas ? gameCanvas.getBoundingClientRect().width + 'px' : '1200px';

        const popup = document.createElement('div');
        popup.style.cssText = `
        background: rgba(42,24,16); border: 2px solid #8b6914; border-radius: 6px;
padding: 12px; width: ${popupWidth}; max-height: 90vh;
color: #ffd700; font-family: Arial, sans-serif; font-size: 12px;
box-shadow: 0 4px 12px rgba(0,0,0,0.5);
display: flex; flex-direction: column;
`;

        // Handle resize to keep popup matched to canvas
        const resizeHandler = () => {
            if (gameCanvas && popup) {
                popup.style.width = gameCanvas.getBoundingClientRect().width + 'px';
            }
        };
        window.addEventListener('resize', resizeHandler);
        backdrop._resizeHandler = resizeHandler; // Store for cleanup

        // === EVENT ENDED BANNER (if showing historical data) ===
        let content = '';
        if (isHistorical) {
            const lastTime = liveData.lastTimestamp ? new Date(liveData.lastTimestamp).toLocaleString() : 'Unknown';
            content += `
            <div style="background: linear-gradient(90deg, #8b0000, #dc3545, #8b0000); color: #fff; padding: 10px 16px; border-radius: 4px; margin-bottom: 10px; text-align: center; font-weight: bold; font-size: 14px; box-shadow: 0 2px 8px rgba(220,53,69,0.4);">
                üèÅ EVENT ENDED ‚Äî Showing Final Results from ${lastTime}
            </div>
            `;
        }

        // === HEADER WITH ALL BUTTONS ===
        // Event timing display
        let eventTimingHtml = '';
        if (liveData.eventInfo?.startTime && liveData.eventInfo?.endTime) {
            const evtStart = new Date(liveData.eventInfo.startTime * 1000);
            const evtEnd = new Date(liveData.eventInfo.endTime * 1000);
            const remaining = liveData.eventInfo.endTime * 1000 - now;
            const formatDT = (d) => d.toLocaleDateString([], {month: 'short', day: 'numeric'}) + ' ' + d.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
            let remainingStr = '';
            if (remaining > 0) {
                const days = Math.floor(remaining / (1000 * 60 * 60 * 24));
                const hours = Math.floor((remaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const mins = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
                remainingStr = days > 0 ? `‚è±Ô∏è ${days}d ${hours}h remaining` : `‚è±Ô∏è ${hours}h ${mins}m remaining`;
            } else {
                remainingStr = '‚ö†Ô∏è Event ended';
            }
            eventTimingHtml = `</h3><div style="font-size: 11px; color: #aaa; margin-top: 2px;">üìÖ ${formatDT(evtStart)} ‚Üí ${formatDT(evtEnd)} | ${remainingStr}</div>`;
        }

        content += `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 2px solid #8b6914; flex-shrink: 0;">
<div><h3 style="margin: 0; color: #ffd700; font-size: 14px;">üó∫Ô∏è Area of Conquest${eventTimingHtml}</div>
<div class="twk-flex-gap8">
    <button id="contribute-coins-btn" style="background: #2a5a2a; color: #fff; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px;">üí∞ Contribute</button>
<button id="export-data-btn" style="background: #4a4a90; color: #fff; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px;">üì§ Export</button>
<button id="edit-positions-btn" style="background: #4a90e2; color: #fff; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px;">‚úèÔ∏è Edit Towns</button>
<button id="reset-names-btn" style="background: #dc3545; color: #fff; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px;">üîÑ Reset Names</button>
<button id="refresh-aoc-btn" style="background: #2a5a2a; color: #fff; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px;">üîÑ Refresh</button>
<button id="test-telegram-btn" style="background: #0088cc; color: #fff; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px;" title="Test Telegram notification">üì± Test</button>
<button id="close-aoc-btn" style="background: #8b6914; color: #fff; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px;">Close</button>
</div>
</div>
`;
        // === AUTO-REFRESH STATUS BAR ===
        const savedAocInterval = parseInt(localStorage.getItem('hwh_aoc_refresh_interval')) || 15;
        const _aar = window._aocAutoRefresh;
        const aocRefreshActive = _aar && _aar.timer;
        const aocLastRefresh = _aar?.lastRefresh ? new Date(_aar.lastRefresh).toLocaleTimeString() : 'Never';
        const aocNextRefresh = (_aar?.lastRefresh && _aar?.interval)
        ? new Date(_aar.lastRefresh + _aar.interval * 60 * 1000).toLocaleTimeString()
        : '‚Äî';

        // Show different status bar if event ended
        if (isHistorical) {
            content += `
            <div style="margin-bottom: 8px; padding: 6px 10px; background: rgba(139,0,0,0.3); border: 1px solid #dc3545; border-radius: 4px; font-size: 11px; display: flex; justify-content: center; align-items: center; flex-shrink: 0;">
                <span class="twk-red">üõë Auto-refresh stopped ‚Äî Event has ended</span>
                <span style="color: #999; margin-left: 15px;">Data points: <span class="twk-gold">${aocHistoricalData.length}</span></span>
            </div>
            `;
        } else {
            content += `
            <div style="margin-bottom: 8px; padding: 6px 10px; background: rgba(0,0,0,0.3); border: 1px solid #555; border-radius: 4px; font-size: 11px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0;">
                <div style="display: flex; gap: 10px; align-items: center;">
                    <span style="color: ${aocRefreshActive ? '#4ae29a' : '#666'};">‚óè ${aocRefreshActive ? 'Auto' : 'Off'}</span>
                    <span class="twk-muted">Last: <span class="twk-gold">${aocLastRefresh}</span></span>
                    <span class="twk-muted">Next: <span class="twk-gold">${aocNextRefresh}</span></span>
                    <span class="twk-muted">Data points: <span class="twk-gold">${aocHistoricalData.length}</span></span>
                </div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <label style="color: #999; display: flex; align-items: center; gap: 4px;">
                        <span>Auto ‚ü≥</span>
                        <input id="aoc-refresh-interval" type="number" min="1" max="60" value="${savedAocInterval}" style="background: #1a1408; color: #ffd700; border: 1px solid #8b6914; border-radius: 3px; padding: 2px 4px; font-size: 11px; width: 40px; text-align: center;">
                        <span>min</span>
                    </label>
                    <button id="aoc-apply-refresh-btn" style="background: #4a90e2; color: #fff; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 11px;">Apply</button>
                    <button id="aoc-stop-refresh-btn" style="background: #666; color: #fff; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; font-size: 11px; ${aocRefreshActive ? '' : 'display: none;'}">Stop</button>
                    <span id="aoc-refresh-status" style="color: #666; font-size: 10px; min-width: 50px;"></span>
                </div>
            </div>
            `;
        }

        // === TAB NAVIGATION ===
        content += `
        <div style="display: flex; gap: 5px; margin-bottom: 10px; border-bottom: 1px solid #8b6914; padding-bottom: 5px; flex-shrink: 0;">
            <button class="aoc-tab-btn" data-tab="castle" style="background: #8b6914; color: #ffd700; border: none; padding: 6px 16px; border-radius: 3px 3px 0 0; cursor: pointer; font-size: 11px; font-weight: bold;">
                üè∞ Castle Stats
            </button>
            <button class="aoc-tab-btn" data-tab="rankings" style="background: #5a4a2a; color: #ccc; border: none; padding: 6px 16px; border-radius: 3px 3px 0 0; cursor: pointer; font-size: 11px;">
                ‚öîÔ∏è Guild Rankings
            </button>
            <button class="aoc-tab-btn" data-tab="graph" style="background: #5a4a2a; color: #ccc; border: none; padding: 6px 16px; border-radius: 3px 3px 0 0; cursor: pointer; font-size: 11px;">
                üìà Score Graph
            </button>
            <button class="aoc-tab-btn" data-tab="teams" style="background: #5a4a2a; color: #ccc; border: none; padding: 6px 16px; border-radius: 3px 3px 0 0; cursor: pointer; font-size: 11px;">
                ‚ù§Ô∏è Team Health
            </button>
        </div>
        `;

        // === TAB CONTENT CONTAINER ===
        content += `<div id="aoc-tab-content" style="flex: 1; overflow-y: auto; overflow-x: hidden; scrollbar-width: none; -ms-overflow-style: none;"></div>`;

        popup.innerHTML = content;
        backdrop.appendChild(popup);
        document.body.appendChild(backdrop);

        // === TAB SWITCHING LOGIC ===
        const tabButtons = popup.querySelectorAll('.aoc-tab-btn');
        const tabContent = document.getElementById('aoc-tab-content');

        tabButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                // Update button styles
                tabButtons.forEach(b => {
                    b.style.background = '#5a4a2a';
                    b.style.color = '#ccc';
                    b.style.fontWeight = 'normal';
                });
                btn.style.background = '#8b6914';
                btn.style.color = '#ffd700';
                btn.style.fontWeight = 'bold';

                // Load tab content
                const tabName = btn.dataset.tab;
                if (tabName === 'castle') {
                    loadCastleTab(tabContent, liveData);
                } else if (tabName === 'rankings') {
                    loadRankingsTab(tabContent, liveData);
                } else if (tabName === 'teams') {
                    loadTeamHealthTab(tabContent, liveData);
                } else if (tabName === 'graph') {
                    let graphData = [];
                    try {
                        graphData = JSON.parse(localStorage.getItem('hwh_aoc_history')) || [];
                    } catch(e) {}
                    loadAocGraphTab(tabContent, graphData, liveData, liveData.eventEnded === true);
                }
            });
        });

        // === BUTTON HANDLERS ===
        document.getElementById('close-aoc-btn').onclick = () => {
            if (backdrop._resizeHandler) {
                window.removeEventListener('resize', backdrop._resizeHandler);
            }
            backdrop.remove();
            // Show dock with the data we already have
            window.showAoCDock(liveData);
        };

        document.getElementById('refresh-aoc-btn').onclick = async () => {
            backdrop.remove();
            await window.showAoCStatsUnified();
        };
        // Auto-refresh
        if (!isHistorical) {
            document.getElementById('aoc-apply-refresh-btn').onclick = () => {
                const input = document.getElementById('aoc-refresh-interval');
                const interval = parseInt(input.value) || 5;
                localStorage.setItem('hwh_aoc_refresh_interval', interval);

                // Clear existing timer
                if (window._aocAutoRefresh.timer) {
                    clearInterval(window._aocAutoRefresh.timer);
                }

                window._aocAutoRefresh.interval = interval;
                window._aocAutoRefresh.timer = setInterval(async () => {
                    if (document.hidden) return; // Skip if tab hidden
                    window.showAoCDock(null);
                    debugLog('üè∞ AoC auto-refreshed (dock only)');
                    const idleTime = Date.now() - (window._lastActivity || Date.now());
                    if (idleTime > 60000) {
                        await sendAoCStatusNotification();
                    }
                }, interval * 60 * 1000);

                document.getElementById('aoc-stop-refresh-btn').style.display = '';
                document.getElementById('aoc-refresh-status').textContent = `‚ü≥ ${interval}m`;
                document.getElementById('aoc-refresh-status').style.color = '#4ae29a';
            };

            document.getElementById('aoc-stop-refresh-btn').onclick = () => {
                if (window._aocAutoRefresh.timer) {
                    clearInterval(window._aocAutoRefresh.timer);
                    window._aocAutoRefresh.timer = null;
                }
                document.getElementById('aoc-stop-refresh-btn').style.display = 'none';
                document.getElementById('aoc-refresh-status').textContent = 'Stopped';
                document.getElementById('aoc-refresh-status').style.color = '#666';
            };
        }
        document.getElementById('test-telegram-btn').onclick = async () => {
            const enabled = localStorage.getItem('hwh_telegram_enabled') === 'true';
            if (!enabled) {
                alert('‚ö†Ô∏è Telegram notifications are disabled.\nEnable them in Settings (gear icon).');
                return;
            }
            const token = localStorage.getItem('hwh_telegram_token');
            const chatId = localStorage.getItem('hwh_telegram_chatid');
            if (!token || !chatId) {
                alert('‚ö†Ô∏è Telegram not configured.\nSet token and chat ID in Settings.');
                return;
            }
            await sendAoCStatusNotification();
            alert('‚úÖ Test notification sent!');
        };

        document.getElementById('contribute-coins-btn').onclick = async () => {
            // Close the main popup first to prevent z-index issues
            backdrop.remove();

            const coinAmount = await HWHFuncs.popup.confirm(
                'Enter coin amount to contribute:',
                [
                    { msg: 'Contribute', placeholder: '1', isInput: true, default: '1' },
                    { msg: 'Cancel', result: false, isCancel: true }
                ]
            );

            if (coinAmount && !isNaN(parseInt(coinAmount))) {
                await window.upgradeCastle(parseInt(coinAmount));
            }

            // Reopen the window after contribution
            await window.showAoCStatsUnified();
        };

        document.getElementById('export-data-btn').onclick = async () => {
            try {
                const data = await window.fetchLiveCastleData();
                debugLog('üìä Full AoC Data:', data);

                const activeFarmers = Object.values(data.mapState?.townPositions || {})
                .filter(t => t.status === 1).length;
                const unfarmedChests = Object.values(data.mapState?.chestPositions || {})
                .filter(c => !c.farmed).length;

                const summary = `
üè∞ Castle: Level ${data.castleInfo?.castleLevel || 'N/A'} (${(data.castleInfo?.castleExp || 0).toLocaleString()} coins)
üë• Contributors: ${Object.keys(data.castleInfo?.points || {}).length}
üåæ Active Farmers: ${activeFarmers}
üéÅ Unfarmed Chests: ${unfarmedChests}
üó∫Ô∏è Guilds Tracked: ${Object.keys(data.dominationStats || {}).length}
            `.trim();

                if (HWHFuncs && HWHFuncs.setProgress) {
                    HWHFuncs.setProgress('‚úÖ Data exported to console (F12)', false);
                }

                alert(summary + '\n\n‚úÖ Full data exported to console (F12)');
            } catch (error) {
                if (HWHFuncs && HWHFuncs.setProgress) {
                    HWHFuncs.setProgress(`‚ùå Export error: ${error.message}`, true);
                }
            }
        };

        // Reset Names button handler
        document.getElementById('reset-names-btn').onclick = async function() {
            const confirmed = await HWHFuncs.popup.confirm(
                'Reset all town names to defaults?\n\nThis will restore original names with coins and directions.',
                [
                    { msg: 'Yes, Reset', result: true },
                    { msg: 'Cancel', result: false, isClose: true }
                ]
            );

            if (confirmed) {
                if (resetPositionNamesToDefaults()) {
                    await HWHFuncs.popup.confirm(
                        '‚úÖ Town names reset successfully!',
                        [{ msg: 'OK', result: true }]
                    );
                    backdrop.remove();
                    await window.showAoCStatsUnified();
                }
            }
        };

        // Edit Positions button handler (keep existing logic)
        document.getElementById('edit-positions-btn').onclick = async () => {
            if (!HWHFuncs?.popup?.confirm) {
                alert('Position editor requires HWH popup system');
                return;
            }

            initializePositionNames();

            const editablePositions = [
                1, 26, 29, 33, 36, 98, 101, 112, 115, 123, 126,
                333, 336, 436, 439, 356, 397, 404, 446, 596,
                340, 375, 423, 465, 585, 359, 394, 407, 449, 599,
                343, 378, 426, 468, 588
            ];

            const editBackdrop = document.createElement('div');
            editBackdrop.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); z-index: 10001;
            display: flex; align-items: center; justify-content: center;
        `;

            let editHTML = `
            <div style="background: rgba(42,24,16); border: 3px solid #8b6914; border-radius: 8px; padding: 20px; max-width: 1400px; max-height: 80vh; overflow-y: auto;">
                <h3 style="margin: 0 0 15px 0; color: #ffd700; font-size: 16px; text-align: center;">‚úèÔ∏è Edit Position Names</h3>
                <div style="background: rgba(255, 215, 0, 0.1); border: 1px solid #8b6914; border-radius: 4px; padding: 10px; margin-bottom: 15px; text-align: center;">
                    <div style="color: #ffd700; font-size: 11px; font-weight: bold; margin-bottom: 5px;">üìù Format Instructions</div>
                    <div style="color: #4ae29a; font-size: 10px;">Use exactly 3 spaces: <strong>TOWNNAME Direction Coins</strong></div>
                    <div style="color: #8ab4f8; font-size: 9px; margin-top: 3px;">Example: <code style="background: rgba(0,0,0,0.3); padding: 2px 4px; border-radius: 2px;">KIATON Northwest 4ü™ô</code></div>
                </div>
                <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 10px 12px; padding: 10px;">
        `;

            editablePositions.forEach(pos => {
                const currentName = getPositionName(pos);
                editHTML += `
                <div style="display: flex; flex-direction: column; gap: 3px;">
                    <label style="color: #ffd700; font-size: 9px; font-weight: bold;">Pos ${pos}</label>
                    <input type="text" id="pos-name-${pos}" value="${currentName}"
                           placeholder="Position ${pos}"
                           style="padding: 5px 6px; background: #2a2a2a; border: 1px solid #8b6914; color: #ffd700; border-radius: 3px; font-size: 10px; width: 100%;">
                </div>
            `;
            });

            editHTML += `
                </div>
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px; padding-top: 15px; border-top: 1px solid #8b6914;">
                    <button id="save-positions-btn" style="background: #2a5a2a; color: #fff; border: none; padding: 8px 20px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold;">üíæ Save All</button>
                    <button id="cancel-positions-btn" style="background: #666; color: #fff; border: none; padding: 8px 20px; border-radius: 4px; cursor: pointer; font-size: 12px;">Cancel</button>
                </div>
            </div>
        `;

            editBackdrop.innerHTML = editHTML;
            document.body.appendChild(editBackdrop);

            document.getElementById('save-positions-btn').onclick = async () => {
                let saved = 0;
                editablePositions.forEach(pos => {
                    const input = document.getElementById(`pos-name-${pos}`);
                    if (input) {
                        const newName = input.value.trim();
                        if (newName && newName !== `Position ${pos}`) {
                            savePositionName(pos, newName);
                            saved++;
                        }
                    }
                });

                editBackdrop.remove();

                if (HWHFuncs?.popup?.confirm) {
                    await HWHFuncs.popup.confirm(
                        `‚úÖ Saved ${saved} position names!`,
                        [{ msg: 'OK', result: true }]
                    );
                }

                backdrop.remove();
                await window.showAoCStatsUnified();
            };

            document.getElementById('cancel-positions-btn').onclick = () => {
                editBackdrop.remove();
            };

            editBackdrop.onclick = (e) => {
                if (e.target === editBackdrop) {
                    editBackdrop.remove();
                }
            };
        };

        backdrop.onclick = (e) => {
            if (e.target === backdrop) {
                if (backdrop._resizeHandler) {
                    window.removeEventListener('resize', backdrop._resizeHandler);
                }
                backdrop.remove();
                window.showAoCDock(liveData);
            }
        };
        // Load default tab (Castle Stats)
        loadCastleTab(tabContent, liveData);
    }
    // AoC Dock - shows summary when popup is closed
    window.showAoCDock = async function(liveData = null) {
        // Remove existing dock
        const existing = document.getElementById('aoc-dock');
        if (existing) existing.remove();

        // Skip dock if event has ended
        if (liveData?.eventEnded) {
            debugLog('üõë AoC dock skipped - event ended');
            return;
        }

        try {
            // Fetch data if not provided
            if (!liveData) {
                liveData = await window.fetchLiveCastleData();
                if (!liveData) {
                    debugLog('üõë AoC dock skipped - event not active');
                    return;
                }
                const SendFunction = getSend();
                const guildResponse = await SendFunction(JSON.stringify({
                    calls: [{
                        name: "clanGetInfo",
                        args: {},
                        context: { actionTs: Date.now() },
                        ident: "body"
                    }]
                }));
                liveData.guildMembers = guildResponse?.results?.[0]?.result?.response?.clan?.members || {};
            }

            // Get my user ID from localStorage (reliable cross-scope)
            let actualUserId = localStorage.getItem('userId') || localStorage.getItem('hw_UserId');
            if (actualUserId) actualUserId = String(actualUserId);

            // Build contributors list
            const guildMembers = liveData.guildMembers || {};
            const castleInfo = liveData.castleInfo || {};
            const points = castleInfo.points || {};

            const contributors = [];
            Object.entries(guildMembers).forEach(([id, member]) => {
                const userExp = points[id] || 0;
                contributors.push({
                    id,
                    name: member.name || `User ${id}`,
                    userExp
                });
            });
            contributors.sort((a, b) => b.userExp - a.userExp);

            const totalExp = contributors.reduce((sum, c) => sum + c.userExp, 0);
            await checkAoCScoreChanges(contributors, actualUserId);

            // Find my location from localStorage position names (same source as Active Farmers)
            const userPositions = liveData.mapState?.userPositions || {};
            const townPositions = liveData.mapState?.townPositions || {};
            const positionNames = JSON.parse(localStorage.getItem('hwh_aoc_position_names')) || {};
            // Position to coins mapping
            const positionCoins = {
                1: 32,   // MIDTOWN Center
                123: 8, 98: 8, 112: 8, 115: 8, 101: 8, 126: 8,  // 8-coin towns
                333: 4, 33: 4, 26: 4, 436: 4, 439: 4, 29: 4, 36: 4, 336: 4,  // 4-coin towns
                423: 2, 446: 2, 340: 2, 397: 2, 394: 2, 343: 2, 449: 2, 426: 2,  // 2-coin towns
                585: 1, 596: 1, 465: 1, 375: 1, 356: 1, 404: 1, 407: 1, 359: 1, 378: 1, 468: 1, 599: 1, 588: 1  // 1-coin towns
            };

            // Calculate total coins/min for our guild and build farm data
            let totalGuildCoins = 0;
            const farmData = [];
            const myGuildMemberIds = Object.keys(guildMembers);

            for (const [pos, townData] of Object.entries(townPositions)) {
                if (townData.status === 1 && townData.userId) {
                    const posNum = parseInt(pos);
                    const coins = positionCoins[posNum] || 0;
                    const isOurGuild = myGuildMemberIds.includes(String(townData.userId));
                    const memberInfo = guildMembers[townData.userId];
                    const playerName = memberInfo?.name || `User ${townData.userId}`;

                    farmData.push({
                        position: posNum,
                        coins: coins,
                        userId: townData.userId,
                        playerName: isOurGuild ? playerName : playerName,
                        isOurs: isOurGuild,
                        isEnemy: !isOurGuild
                    });

                    if (isOurGuild) {
                        totalGuildCoins += coins;
                    }
                }
            }

            window._aocFarmData = farmData;
            window._aocTotalCoins = totalGuildCoins;

            let myLocation = 'Unknown';
            let myFarmCoins = '';

            for (const [pos, townData] of Object.entries(townPositions)) {
                if (townData.userId === parseInt(actualUserId) && townData.status === 1) {
                    const locName = positionNames[pos] || `Position ${pos}`;
                    const parts = locName.split(' ');
                    if (parts.length >= 3) {
                        myFarmCoins = parts[parts.length - 1];
                        myLocation = parts.slice(0, -2).join(' ');
                    } else {
                        myLocation = locName;
                    }
                    break;
                }
            }

            if (myLocation === 'Unknown') {
                const myPosition = userPositions[actualUserId];
                const castlePositionValues = [693, 662, 665, 696];
                if (castlePositionValues.includes(myPosition)) {
                    myLocation = 'Castle';
                } else if (myPosition) {
                    myLocation = `Moving (${myPosition})`;
                }
            }

            // Get guild rankings from dominationStats
            const stats = liveData.dominationStats || {};
            const clansData = liveData.mapState?.clans || {};

            const guilds = [];
            for (const [guildId, guildStats] of Object.entries(stats)) {
                const clanInfo = clansData[guildId] || {};
                guilds.push({
                    id: guildId,
                    title: clanInfo.title || `Guild ${guildId}`,
                    coins: guildStats.coins || 0
                });
            }
            guilds.sort((a, b) => b.coins - a.coins);

            // Find our guild - use the guild from guildMembers
            const myGuildId = Object.values(liveData.guildMembers || {})[0]?.clanId;
            const myGuildIndex = guilds.findIndex(g => g.id === String(myGuildId));
            const myGuild = myGuildIndex >= 0 ? guilds[myGuildIndex] : null;
            const myGuildRank = myGuildIndex >= 0 ? myGuildIndex + 1 : '?';

            // Format numbers: 214k, 10.3k, 555
            const formatK = (n) => n >= 1000 ? (n >= 10000 ? Math.round(n/1000) + 'k' : (n/1000).toFixed(1) + 'k') : n;

            let guildLeadText = '';
            if (myGuild) {
                if (myGuildIndex === 0) {
                    const lead = myGuild.coins - (guilds[1]?.coins || 0);
                    guildLeadText = `+${formatK(lead)}`;
                } else {
                    const deficit = (guilds[0]?.coins || 0) - myGuild.coins;
                    guildLeadText = `-${formatK(deficit)}`;
                }
            }
            // Find game canvas for positioning
            const gameCanvas = DOMCache.get('gameCanvas', 'canvas');
            let dockLeft = '50%';
            let dockTransform = 'translateX(-50%)';
            let dockWidth = '800px';

            if (gameCanvas) {
                const rect = gameCanvas.getBoundingClientRect();
                dockLeft = rect.left + 'px';
                dockTransform = 'none';
                dockWidth = rect.width + 'px';
            }

            // Add blink animation style
            if (!document.getElementById('aoc-dock-styles')) {
                const style = document.createElement('style');
                style.id = 'aoc-dock-styles';
                style.textContent = `
                    @keyframes blink {
                        0%, 50% { opacity: 1; }
                        51%, 100% { opacity: 0.3; }
                    }
                `;
                document.head.appendChild(style);
            }

            const dock = document.createElement('div');
            dock.id = 'aoc-dock';
            dock.style.cssText = `
                position: fixed; bottom: 0; left: ${dockLeft}; transform: ${dockTransform};
                width: ${dockWidth}; height: 28px; background: rgba(42,24,16,0.95);
                border: 1px solid #8b6914; border-bottom: none;
                z-index: 9998; display: flex; align-items: center; justify-content: space-between;
                padding: 0 10px; font-family: Arial, sans-serif; font-size: 12px;
                box-shadow: 0 -2px 8px rgba(0,0,0,0.3);
                box-sizing: border-box; cursor: pointer;
            `;

            // Build dock content
            let dockHTML = '<div style="display: flex; gap: 15px; align-items: center; flex: 1;">';
            dockHTML += '<span class="twk-gold-bold">üè∞ AoC</span>';

            // Guild name, score, and lead
            const guildName = myGuild?.title || 'Unknown';
            const guildScore = myGuild?.coins || 0;
            const leadColor = myGuildIndex === 0 ? '#4ae29a' : '#ffa500';
            dockHTML += `<span class="twk-green-bold">${guildName}</span>`;
            dockHTML += `<span class="twk-gold">${formatK(guildScore)}</span>`;
            if (guildLeadText) {
                dockHTML += `<span style="color: ${leadColor}; font-weight: bold;">${guildLeadText}</span>`;
            }
            // Hero name lookup (shortened)
            const heroNames = {
                1: 'Aur', 2: 'Gal', 3: 'Keir', 4: 'Asta', 5: 'Kai', 6: 'Phob', 7: 'Thea', 8: 'DD', 9: 'Heid',
                10: 'Face', 11: 'Chab', 12: 'Arach', 13: 'Ori', 14: 'Fox', 15: 'Ging', 16: 'Dan', 17: 'Moj',
                18: 'Judg', 19: 'DStar', 20: 'Artm', 21: 'Mark', 22: 'Pepp', 23: 'Lian', 24: 'Cleav', 25: 'Ish',
                26: 'Lil', 27: 'Luth', 28: 'QM', 29: 'Dor', 30: 'Corn', 31: 'Jet', 32: 'Heli', 33: 'Lars',
                34: 'Kris', 35: 'Jorg', 36: 'Maya', 37: 'Jhu', 38: 'Elm', 39: 'Zir', 40: 'Neb', 41: "Kark",
                42: 'Ruf', 43: 'Cel', 44: 'As&L', 45: 'Sat', 46: 'Marth', 47: 'Andv', 48: 'Seb', 49: 'Yas',
                50: 'Corv', 51: 'Morr', 52: 'Isc', 53: 'Alv', 54: 'Tris', 55: 'Iris', 56: 'Amira', 57: 'Faf',
                58: 'Aid', 59: 'Kayl', 60: 'M&S', 61: 'Jul', 62: 'Pol', 63: 'Lara', 64: 'Aug', 65: 'TMNT',
                66: 'Fol', 67: 'Lyr', 68: 'Guus', 69: 'Casc', 70: 'Elec',
                6000: 'Fenr', 6001: 'Olvr', 6002: 'Merl', 6003: 'Mara', 6004: 'Cain', 6005: 'Alb',
                6006: 'Axel', 6007: 'Bisc', 6008: 'Khor', 6009: 'Vex'
            };

            // Get my defense state
            const myUserData = liveData.mapState?.users?.[myGuildId]?.[actualUserId];
            let healthDisplay = '‚ù§Ô∏è ---';

            if (myUserData?.defenseState) {
                const parts = [];
                for (const [heroId, state] of Object.entries(myUserData.defenseState)) {
                    const name = heroNames[heroId] || heroId;
                    if (state.maxHp > 0) {
                        const hpPct = Math.round((state.hp / state.maxHp) * 100);
                        const worseHpPct = hpPct <= 10 ? 10 : (hpPct <= 30 ? 30 : hpPct); // for color breaks
                        const worseEnergy = state.energy <= 100 ? 100 : state.energy;
                        const nrgPct = Math.round(state.energy / 10); // 0-1000 -> 0-100
                        const hpColor = hpPct === 100 ? '#4ae29a' : hpPct > 50 ? '#ffa500' : '#ff6b6b';
                        const nrgColor = nrgPct === 100 ? '#4ae29a' : '#ffd700';
                        parts.push(`<span style="color:#ccc">${name}</span> <span style="color:${hpColor}">${hpPct}</span>/<span style="color:${nrgColor}">${nrgPct}</span>`);
                    } else {
                        // Pet (maxHp is -1)
                        parts.push(`<span style="color:#4ae29a">${name}</span>`);
                    }
                }
                healthDisplay = '‚ù§Ô∏è‚ö° ' + parts.join(' | ');

            }


            // My location & coins/min - highlight Castle/Idle prominently
            const isCastle = myLocation === 'Castle';
            const isIdle = myLocation === 'Unknown' || myLocation.startsWith('Moving');
            const locationColor = isCastle ? '#ff6b6b' : (isIdle ? '#ff6b6b' : '#4ae29a');
            const locationIcon = isCastle ? 'üè∞' : (isIdle ? '‚ö†Ô∏è' : 'üìç');
            const locationStyle = (isCastle || isIdle) ? 'font-weight: bold; animation: blink 1s infinite;' : '';

            dockHTML += `<span class="twk-dim">${locationIcon} <span style="color: ${locationColor}; ${locationStyle}">${myLocation}</span>`;
            if (myFarmCoins) {
                dockHTML += ` <span class="twk-orange">${myFarmCoins}/m</span>`;
            } else if (isCastle || isIdle) {
                dockHTML += ` <span class="twk-red-bold">0/m!</span>`;
            }
            dockHTML += '</span>';

            // Team health placeholder
            dockHTML += `<span style="font-size: 11px;">${healthDisplay}</span>`;

            // Total guild coins/min with map popup trigger
            dockHTML += `<span id="aoc-coins-trigger" style="color: #ffa500; cursor: pointer; padding: 2px 6px; border-radius: 4px; background: rgba(255,165,0,0.1);" title="Hover for farm map">üí∞ ${totalGuildCoins}/m</span>`;

            dockHTML += '</div>';

            // Right side: auto-refresh status + time + close
            dockHTML += '<div style="display: flex; align-items: center; gap: 8px;">';

            // Auto-refresh indicator (just time left)
            const _aar = window._aocAutoRefresh;
            if (_aar && _aar.timer) {
                const nextRefresh = _aar.lastRefresh ? new Date(_aar.lastRefresh + _aar.interval * 60 * 1000) : null;
                const timeLeft = nextRefresh ? Math.max(0, Math.round((nextRefresh - Date.now()) / 60000)) : 0;
                dockHTML += `<span id="aoc-dock-refresh" style="color: #4ae29a; font-size: 10px; cursor: pointer;" title="Click to refresh now">‚ü≥ ${timeLeft}m</span>`;
            } else {
                dockHTML += `<span id="aoc-dock-refresh" style="color: #666; font-size: 10px; cursor: pointer;" title="Click to refresh">‚ü≥ Off</span>`;
            }

            // Gift countdown (GMT+1: 3:15, 7:15, 11:15, 15:15, 19:15, 23:15)
            const giftTimes = [3, 7, 11, 15, 19, 23]; // Hours in GMT+1
            const now = new Date();
            const gmtPlus1 = new Date(now.getTime() + (1 * 60 * 60 * 1000) + (now.getTimezoneOffset() * 60 * 1000));
            const currentHour = gmtPlus1.getHours();
            const currentMin = gmtPlus1.getMinutes();
            const currentSec = gmtPlus1.getSeconds();

            // Find next gift time
            let nextGiftHour = giftTimes.find(h => h > currentHour || (h === currentHour && currentMin < 15));
            let daysToAdd = 0;
            if (!nextGiftHour) {
                nextGiftHour = giftTimes[0]; // Wrap to next day
                daysToAdd = 1;
            }

            // Calculate time until next gift
            const nextGift = new Date(gmtPlus1);
            nextGift.setHours(nextGiftHour, 15, 0, 0);
            if (daysToAdd) nextGift.setDate(nextGift.getDate() + 1);

            const diffMs = nextGift - gmtPlus1;
            const diffH = Math.floor(diffMs / (1000 * 60 * 60));
            const diffM = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
            const diffS = Math.floor((diffMs % (1000 * 60)) / 1000);

            let giftCountdown;
            const giftSoon = diffH === 0 && diffM < 5; // Under 5 minutes
            if (diffH > 0) {
                giftCountdown = `${diffH}h${diffM}m`;
            } else if (diffM > 0) {
                giftCountdown = `${diffM}m${diffS}s`;
            } else {
                giftCountdown = `${diffS}s`;
            }
            const giftStyle = giftSoon ? 'color: #4ae29a; font-size: 10px; font-weight: bold; animation: blink 1s infinite;' : 'color: #ffa500; font-size: 10px;';
            dockHTML += `<span style="${giftStyle}">üéÅ ${giftCountdown}</span>`;

            dockHTML += `<span style="color: #999; font-size: 11px;">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>`;
            dockHTML += '<button id="close-aoc-dock" style="background: transparent; border: none; color: #666; cursor: pointer; font-size: 14px; padding: 2px 6px;">‚úï</button>';
            dockHTML += '</div>';

            dock.innerHTML = dockHTML;
            document.body.appendChild(dock);

            // Click refresh timer to refresh now
            const refreshTrigger = document.getElementById('aoc-dock-refresh');
            if (refreshTrigger) {
                refreshTrigger.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    dock.remove();
                    await window.showAoCStatsUnified();
                });
            }

            // Farm map popup on hover
            const coinsTrigger = document.getElementById('aoc-coins-trigger');
            if (coinsTrigger) {
                let mapPopup = null;

                const buildMapPopup = () => {
                    // Position grid mapping
                    const gridPositions = {
                        // Row 1: C, 585, 423, 333, 446, 596, C
                        585: [0, 1], 423: [0, 2], 333: [0, 3], 446: [0, 4], 596: [0, 5],
                        // Row 2: 465, 375, _, _, _, 356, 404
                        465: [1, 0], 375: [1, 1], 356: [1, 5], 404: [1, 6],
                        // Row 3: 340, 123, 33, _, 26, 98, 397
                        340: [2, 0], 123: [2, 1], 33: [2, 2], 26: [2, 4], 98: [2, 5], 397: [2, 6],
                        // Row 4: 436, 112, _, 1, _, 115, 439
                        436: [3, 0], 112: [3, 1], 1: [3, 3], 115: [3, 5], 439: [3, 6],
                        // Row 5: 394, 101, 29, _, 36, 126, 343
                        394: [4, 0], 101: [4, 1], 29: [4, 2], 36: [4, 4], 126: [4, 5], 343: [4, 6],
                        // Row 6: 407, 359, _, _, _, 378, 468
                        407: [5, 0], 359: [5, 1], 378: [5, 5], 468: [5, 6],
                        // Row 7: C, 599, 449, 336, 426, 588, C
                        599: [6, 1], 449: [6, 2], 336: [6, 3], 426: [6, 4], 588: [6, 5]
                    };

                    const positionCoins = {
                        1: 32, 123: 8, 98: 8, 112: 8, 115: 8, 101: 8, 126: 8,
                        333: 4, 33: 4, 26: 4, 436: 4, 439: 4, 29: 4, 36: 4, 336: 4,
                        423: 2, 446: 2, 340: 2, 397: 2, 394: 2, 343: 2, 449: 2, 426: 2,
                        585: 1, 596: 1, 465: 1, 375: 1, 356: 1, 404: 1, 407: 1, 359: 1, 378: 1, 468: 1, 599: 1, 588: 1
                    };

                    const townNames = {
                        1: 'MIDTOWN', 123: 'VERDANT', 98: 'SKULLMORE', 112: 'MONBRIDGE', 115: 'HELESS', 101: 'JORIA', 126: 'DRAKEMORE',
                        333: 'LORENNDOR', 33: 'KIATON', 26: 'FRADO', 436: 'SLAPDALE', 439: 'CRISTALLION', 29: 'WRAND', 36: 'HIMDALE', 336: 'UGGARIO',
                        423: 'FJEMARK', 446: 'ULEYIM', 340: 'OFFORD', 397: 'AVELEW', 394: 'VIATON', 343: 'LORDARONE', 449: 'SHADOWMOORE', 426: 'ODENGUARD',
                        585: 'CLEARBERT', 596: 'ARCANIA', 465: 'DALEMONT', 375: 'LANDO', 356: 'CRADENA', 404: 'GALADOR', 407: 'EVERFORT', 359: 'MOONGRAVE', 378: 'STRAMGUARD', 468: 'FORGALE', 599: 'TERRANORE', 588: 'MORPORK'
                    };

                    // Build lookup from farm data
                    const farmLookup = {};
                    let ourCount = 0, enemyCount = 0;
                    let actualUserId = localStorage.getItem('userId') || localStorage.getItem('hw_UserId');
                    if (actualUserId) actualUserId = String(actualUserId);

                    (window._aocFarmData || []).forEach(f => {
                        farmLookup[f.position] = f;
                        if (f.isOurs) ourCount++; else enemyCount++;
                    });

                    // Castle position mapping
                    const cornerToCastlePos = {
                        '0,0': 693,  // NW - Orle Gniazdo
                        '0,6': 662,  // NE - Sky Country
                        '6,0': 665,  // SW - Mordor
                        '6,6': 696   // SE - Welcome
                    };
                    const castlePos = liveData.mapState?.castlePositions || {};
                    const myClanId = Object.values(liveData.guildMembers || {})[0]?.clanId;
                    const myCastlePos = castlePos[myClanId];

                    // Build grid HTML
                    let gridHTML = '';
                    for (let row = 0; row < 7; row++) {
                        for (let col = 0; col < 7; col++) {
                            // Corners are castles
                            if ((row === 0 || row === 6) && (col === 0 || col === 6)) {
                                const thisCastlePos = cornerToCastlePos[`${row},${col}`];
                                const isOurs = (thisCastlePos === myCastlePos);
                                gridHTML += `<div class="aoc-castle ${isOurs ? 'ours' : ''}" title="${isOurs ? 'Our Castle' : 'Enemy Castle'}">üè∞</div>`;
                                continue;
                            }

                            // Find position for this grid cell
                            let foundPos = null;
                            for (const [pos, coords] of Object.entries(gridPositions)) {
                                if (coords[0] === row && coords[1] === col) {
                                    foundPos = parseInt(pos);
                                    break;
                                }
                            }

                            if (foundPos) {
                                const coins = positionCoins[foundPos] || 0;
                                const townName = townNames[foundPos] || `Pos ${foundPos}`;
                                const farm = farmLookup[foundPos];

                                let stateClass = 'empty';
                                let occupant = 'Empty';
                                let isMe = false;
                                if (farm) {
                                    stateClass = farm.isOurs ? 'occupied' : 'enemy';
                                    occupant = farm.isOurs ? `‚úî ${farm.playerName}` : `‚öîÔ∏è ${farm.playerName}`;
                                    isMe = String(farm.userId) === actualUserId;
                                }

                                gridHTML += `<div class="aoc-town c${coins} ${stateClass}${isMe ? ' me' : ''}" title="${townName}\n${coins} coins\n${occupant}${isMe ? '\nüëâ YOU' : ''}">${coins}</div>`;
                            } else {
                                gridHTML += `<div class="aoc-spacer"></div>`;
                            }
                        }
                    }

                    return { gridHTML, ourCount, enemyCount };
                };

                const closeMapPopup = () => {
                    const popup = document.getElementById('aoc-farm-map-popup');
                    if (popup) popup.remove();
                    mapPopup = null;
                };

                const openMapPopup = () => {
                    if (mapPopup) return;

                    const { gridHTML, ourCount, enemyCount } = buildMapPopup();

                    mapPopup = document.createElement('div');
                    mapPopup.id = 'aoc-farm-map-popup';
                    mapPopup.innerHTML = `
                        <style>
                            #aoc-farm-map-popup {
                                position: fixed; bottom: 50px; left: 50%; transform: translateX(-50%);
                                background: linear-gradient(180deg, #342111 0%, #1d140d 100%);
                                border: 2px solid #8b6914; border-radius: 8px; padding: 12px;
                                z-index: 1000001; box-shadow: 0 4px 20px rgba(0,0,0,0.5);
                            }
                            #aoc-farm-map-popup .map-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
                            #aoc-farm-map-popup .map-title { color: #ffd700; font-size: 12px; font-weight: bold; }
                            #aoc-farm-map-popup .map-buttons { display: flex; gap: 6px; }
                            #aoc-farm-map-popup .map-btn { background: #2a2a2a; border: 1px solid #555; color: #ccc; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 10px; }
                            #aoc-farm-map-popup .map-btn:hover { background: #3a3a3a; color: #fff; }
                            #aoc-farm-map-popup .map-btn.close-btn { color: #ff6b6b; }
                            #aoc-farm-map-popup .map-btn.close-btn:hover { background: #4a2a2a; }
                            #aoc-farm-map-popup .map-grid { display: grid; grid-template-columns: repeat(7, 32px); grid-template-rows: repeat(7, 32px); gap: 2px; }
                            #aoc-farm-map-popup .aoc-town { width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: bold; color: #fff; cursor: default; margin: auto; }
                            #aoc-farm-map-popup .aoc-town.empty { opacity: 0.3; }
                            #aoc-farm-map-popup .aoc-town.c32 { background: #1a6a3a; border: 2px solid #4ae29a; }
                            #aoc-farm-map-popup .aoc-town.c32.occupied { background: #4ae29a; box-shadow: 0 0 8px #4ae29a; }
                            #aoc-farm-map-popup .aoc-town.c8 { background: #2a4a6a; border: 2px solid #5a9acf; }
                            #aoc-farm-map-popup .aoc-town.c8.occupied { background: #5a9acf; box-shadow: 0 0 8px #5a9acf; }
                            #aoc-farm-map-popup .aoc-town.c4 { background: #3a3a5a; border: 2px solid #6a6a9a; }
                            #aoc-farm-map-popup .aoc-town.c4.occupied { background: #6a6a9a; box-shadow: 0 0 6px #6a6a9a; }
                                 #aoc-farm-map-popup .aoc-town.c2 { background: #3a2a2a; border: 2px solid #6a4a4a; }
                            #aoc-farm-map-popup .aoc-town.c2.occupied { background: #6a4a4a; box-shadow: 0 0 5px #6a4a4a; }
                            #aoc-farm-map-popup .aoc-town.me { animation: mePulse 1.5s ease-in-out infinite; border-width: 3px !important; }
                            @keyframes mePulse {
                                0%, 100% { box-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #4ae29a; transform: scale(1); }
                                50% { box-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #4ae29a; transform: scale(1.1); }
                            }
                            #aoc-farm-map-popup .aoc-town.c1 { background: #2a2a2a; border: 2px solid #5a5a5a; }
                            #aoc-farm-map-popup .aoc-town.c1.occupied { background: #4a4a4a; box-shadow: 0 0 4px #4a4a4a; }
                            #aoc-farm-map-popup .aoc-town.enemy { opacity: 1; border: 2px solid #ff4444 !important; box-shadow: 0 0 6px #ff4444 !important; }
                            #aoc-farm-map-popup .aoc-castle { width: 28px; height: 28px; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 14px; background: #444; border: 2px solid #666; opacity: 0.4; margin: auto; }
                            #aoc-farm-map-popup .aoc-castle.ours { background: #2a5a2a; border: 2px solid #4ae29a; opacity: 1; box-shadow: 0 0 8px #4ae29a; }
                            #aoc-farm-map-popup .aoc-spacer { width: 28px; height: 28px; }
                            #aoc-farm-map-popup .map-stats { text-align: center; margin-top: 8px; font-size: 10px; color: #ccc; }
                        </style>
                        <div class="map-header">
                            <div class="map-title">üè∞ Farm Map</div>
<div class="map-buttons">
                                <button class="map-btn map-open-btn" title="Open AoC Map">üó∫Ô∏è</button>
                                <button class="map-btn refresh-btn" title="Refresh">üîÑ</button>
                                <button class="map-btn close-btn" title="Close">‚úï</button>
                            </div>
                        </div>
                        <div class="map-grid">${gridHTML}</div>
                        <div class="map-stats">üåæ Ours: ${ourCount} | ‚öîÔ∏è Enemy: ${enemyCount} | üí∞ ${window._aocTotalCoins || 0}/m</div>
                    `;
                    document.body.appendChild(mapPopup);

                    // Close button
                    mapPopup.querySelector('.close-btn').addEventListener('click', closeMapPopup);

                    // Open AoC Map button
                    mapPopup.querySelector('.map-open-btn').addEventListener('click', () => {
                        closeMapPopup();
                        if (window.goAoC) window.goAoC();
                    });
                    // Refresh button
                    mapPopup.querySelector('.refresh-btn').addEventListener('click', async () => {
                        closeMapPopup();
                        if (window.showCastleContributorsLive) {
                            await window.showCastleContributorsLive();
                        }
                        setTimeout(openMapPopup, 500);
                    });

                    // Click outside to close
                    setTimeout(() => {
                        document.addEventListener('click', function outsideClick(e) {
                            const popup = document.getElementById('aoc-farm-map-popup');
                            const trigger = document.getElementById('aoc-coins-trigger');
                            if (popup && !popup.contains(e.target) && !trigger?.contains(e.target)) {
                                closeMapPopup();
                                document.removeEventListener('click', outsideClick);
                            }
                        });
                    }, 100);
                };

                coinsTrigger.addEventListener('mouseenter', openMapPopup);
            }

            // Reposition on resize
            const repositionDock = () => {
                const canvas = DOMCache.get('gameCanvas', 'canvas');
                if (canvas && dock) {
                    const rect = canvas.getBoundingClientRect();
                    dock.style.left = rect.left + 'px';
                    dock.style.width = rect.width + 'px';
                    dock.style.transform = 'none';
                }
            };
            window.addEventListener('resize', repositionDock);

            // Close button
            document.getElementById('close-aoc-dock').addEventListener('click', (e) => {
                e.stopPropagation();
                window.removeEventListener('resize', repositionDock);
                dock.remove();
            });

            // Click dock to open full popup
            dock.addEventListener('click', (e) => {
                if (e.target.id !== 'close-aoc-dock') {
                    dock.remove();
                    window.showAoCStatsUnified();
                }
            });

        } catch (error) {
            console.error('Error showing AoC dock:', error);
        }
    };

    window.hideAoCDock = function() {
        const dock = document.getElementById('aoc-dock');
        if (dock) dock.remove();
    };

    // === CASTLE TAB CONTENT - 3 COLUMN LAYOUT ===
    function loadCastleTab(container, liveData) {
        const guildMembers = liveData.guildMembers || {};
        const contributors = [];
        const points = liveData.castleInfo.points;

        // Get my user ID for highlighting
        let actualUserId = localStorage.getItem('userId') || localStorage.getItem('hw_UserId');
        if (actualUserId) actualUserId = String(actualUserId);

        for (const [userId, exp] of Object.entries(points)) {
            const memberInfo = guildMembers[userId];
            contributors.push({
                userId,
                name: memberInfo?.name || `User ${userId}`,
                userExp: exp
            });
        }

        contributors.sort((a, b) => b.userExp - a.userExp);

        const totalExp = contributors.reduce((sum, c) => sum + c.userExp, 0);
        const totalMembers = contributors.length;
        const membersWithExp = contributors.filter(c => c.userExp > 0).length;
        const avgExp = membersWithExp > 0 ? Math.round(totalExp / membersWithExp) : 0;

        // Get guild ranking info for Castle Statistics box
        const domStats = liveData.dominationStats || {};
        const myGuildId = Object.values(guildMembers)[0]?.clanId;

        const guildsList = [];
        for (const [guildId, guildStats] of Object.entries(domStats)) {
            guildsList.push({ id: guildId, coins: guildStats.coins || 0 });
        }
        guildsList.sort((a, b) => b.coins - a.coins);

        const myGuildRank = guildsList.findIndex(g => g.id === String(myGuildId)) + 1;
        const myGuildScore = guildsList.find(g => g.id === String(myGuildId))?.coins || 0;
        // Calculate our guild's CURRENT coins/min from active farm positions
        const positionCoinsMap = {
            1: 32, 123: 8, 98: 8, 112: 8, 115: 8, 101: 8, 126: 8,
            333: 4, 33: 4, 26: 4, 436: 4, 439: 4, 29: 4, 36: 4, 336: 4,
            423: 2, 446: 2, 340: 2, 397: 2, 394: 2, 343: 2, 449: 2, 426: 2,
            585: 1, 596: 1, 465: 1, 375: 1, 356: 1, 404: 1, 407: 1, 359: 1, 378: 1, 468: 1, 599: 1, 588: 1
        };
        const myGuildMemberIds = Object.keys(guildMembers);
        let ourCurrentRate = 0;
        for (const [pos, townData] of Object.entries(liveData.mapState?.townPositions || {})) {
            if (townData.status === 1 && myGuildMemberIds.includes(String(townData.userId))) {
                ourCurrentRate += positionCoinsMap[parseInt(pos)] || 0;
            }
        }

        // Calculate our guild's AVG coins/min from historical data
        let ourAvgRate = 0;
        let historicalData = [];
        try {
            historicalData = JSON.parse(localStorage.getItem('hwh_aoc_history')) || [];
        } catch(e) {}

        // Use actual event start time if available for accurate rate calculation
        const eventStartMs = liveData.eventInfo?.startTime ? liveData.eventInfo.startTime * 1000 : null;

        if (eventStartMs && myGuildId) {
            const elapsedMinutes = (Date.now() - eventStartMs) / (1000 * 60);
            if (elapsedMinutes > 0) {
                ourAvgRate = Math.round(myGuildScore / elapsedMinutes);
            }
        } else if (historicalData.length >= 2) {
            // Fallback to historical data
            const firstEntry = historicalData[0];
            const lastEntry = historicalData[historicalData.length - 1];
            const elapsedMinutes = (lastEntry.timestamp - firstEntry.timestamp) / (1000 * 60);

            if (elapsedMinutes > 0 && myGuildId) {
                const firstCoins = firstEntry.guilds?.[myGuildId]?.coins || 0;
                const lastCoins = lastEntry.guilds?.[myGuildId]?.coins || myGuildScore;
                ourAvgRate = Math.round((lastCoins - firstCoins) / elapsedMinutes);
            }
        }
        // Process farming data

        // Process farming data
        const activeFarmers = [];
        if (liveData.mapState?.townPositions) {
            Object.entries(liveData.mapState.townPositions).forEach(([position, townData]) => {
                if (townData.status === 1 && townData.userId) {
                    const memberInfo = guildMembers[townData.userId];
                    const posNum = parseInt(position);

                    activeFarmers.push({
                        userId: townData.userId,
                        userName: memberInfo?.name || `User ${townData.userId}`,
                        position: posNum,
                        locationName: getPositionName(posNum),
                        farmStart: townData.farmStart ? new Date(townData.farmStart * 1000) : null
                    });
                }
            });
        }
        activeFarmers.sort((a, b) => {
            const coinsA = parseInt(parseLocationName(a.locationName).coins) || 0;
            const coinsB = parseInt(parseLocationName(b.locationName).coins) || 0;
            if (coinsB !== coinsA) {
                return coinsB - coinsA; // Higher coins first
            }
            return a.position - b.position; // Then by position
        });

        // Process user positions - categorize members
        const userPositions = liveData.mapState?.userPositions || {};
        const townPositions = liveData.mapState?.townPositions || {};
        const castlePositions = liveData.mapState?.castlePositions || {};

        const inCastle = [];
        const inTowns = [];
        const moving = [];

        // Get all guild member IDs
        const allMemberIds = Object.keys(guildMembers);

        allMemberIds.forEach(userId => {
            const memberInfo = guildMembers[userId];
            const userName = memberInfo?.name || `User ${userId}`;
            const userPos = userPositions[userId];

            // Check if user is in castle - check BOTH castlePositions object AND position values
            const isInCastle = castlePositions.hasOwnProperty(userId);
            const castlePositionValues = [693, 662, 665, 696]; // Castle position numbers
            const isAtCastlePosition = castlePositionValues.includes(userPos);

            // Check if user is in a town (farming)
            let isInTown = false;
            for (const [position, townData] of Object.entries(townPositions)) {
                if (townData.userId === parseInt(userId) && townData.status === 1) {
                    isInTown = true;
                    break;
                }
            }

            if (isInTown) {
                inTowns.push({ userId, userName });
            } else if (isInCastle || isAtCastlePosition) {
                const castlePos = castlePositions[userId] || userPos;
                inCastle.push({ userId, userName, position: castlePos });
            } else if (userPos) {
                moving.push({ userId, userName, position: userPos });
            }
        });

        inCastle.sort((a, b) => a.userName.localeCompare(b.userName));
        moving.sort((a, b) => a.userName.localeCompare(b.userName));

        // Process chest positions
        const chestPositions = liveData.mapState?.chestPositions || {};
        const unfarmedChests = [];

        Object.entries(chestPositions).forEach(([position, chestData]) => {
            if (!chestData.farmed) {
                unfarmedChests.push(parseInt(position));
            }
        });
        unfarmedChests.sort((a, b) => a - b);

        function parseLocationName(locationName) {
            const directionEmoji = {
                'Center': '‚è∫Ô∏è',
                'North': '‚¨ÜÔ∏è',
                'Northeast': '‚ÜóÔ∏è',
                'East': '‚û°Ô∏è',
                'Southeast': '‚ÜòÔ∏è',
                'South': '‚¨áÔ∏è',
                'Southwest': '‚ÜôÔ∏è',
                'West': '‚¨ÖÔ∏è',
                'Northwest': '‚ÜñÔ∏è'
            };

            const parts = locationName.split(' ');
            if (parts.length >= 3) {
                const coins = parts[parts.length - 1];
                const dirText = parts[parts.length - 2];
                const direction = directionEmoji[dirText] || dirText;
                const townName = parts.slice(0, -2).join(' ');
                return { townName, direction, coins };
            }
            return { townName: locationName, direction: '', coins: '' };
        }

        // START 3-COLUMN LAYOUT
        let content = `
<div style="display: grid; grid-template-columns: 20% 1fr 28%; gap: 12px; overflow: hidden;">
            <!-- COLUMN 1: Castle Statistics -->
            <div style="overflow: hidden;">
                <div style="padding: 10px; background: rgba(139, 105, 20, 0.2); border-radius: 4px;">
                    <div style="font-weight: bold; color: #ffd700; font-size: 15px; margin-bottom: 12px; text-align: center;">
                        üè∞ Castle Statistics
                    </div>
                    <div style="font-size: 13px; line-height: 1.6;">
                        <div class="twk-flex-between">
                            <span class="twk-gold-bold">üè∞ Level:</span>
                            <span class="twk-green">${liveData.castleInfo.castleLevel || 'N/A'}</span>
                        </div>
                        <div class="twk-flex-between">
                            <span class="twk-gold-bold">üìä EXP:</span>
                            <span class="twk-green">${(liveData.castleInfo.castleExp || 0).toLocaleString()}</span>
                        </div>
                        <div class="twk-flex-between">
                            <span class="twk-gold-bold">üéØ To Next:</span>
                            <span class="twk-green">${((liveData.castleInfo.levelMaxExp || 0) - (liveData.castleInfo.castleExp || 0)).toLocaleString()}</span>
                        </div>
                        <div class="twk-flex-between">
                            <span class="twk-gold-bold">üë• Members:</span>
                            <span class="twk-green">${totalMembers}</span>
                        </div>
                        <div class="twk-flex-between">
                            <span class="twk-gold-bold">‚úÖ Contributing:</span>
                            <span class="twk-green">${membersWithExp}</span>
                        </div>
                        <div class="twk-flex-between">
                            <span class="twk-gold-bold">‚ö†Ô∏è Zero:</span>
                            <span class="twk-red">${totalMembers - membersWithExp}</span>
                        </div>
                        <div class="twk-flex-between">
                            <span class="twk-gold-bold">üí∞ Coins:</span>
                            <span class="twk-green">${totalExp.toLocaleString()}</span>
                        </div>
<div class="twk-flex-between">
                            <span class="twk-gold-bold">üìà Average:</span>
                            <span class="twk-green">${avgExp.toLocaleString()}</span>
                        </div>
<div class="twk-flex-between">
                            <span class="twk-gold-bold">üèÜ Rank:</span>
                            <span class="twk-green">#${myGuildRank} (${myGuildScore.toLocaleString()})</span>
                        </div>
                        <div class="twk-flex-between">
                            <span class="twk-gold-bold">ü™ô Current:</span>
                            <span class="twk-orange">${ourCurrentRate}/m</span>
                        </div>
                        <div class="twk-flex-between">
                            <span class="twk-gold-bold">ü™ô Avg:</span>
                            <span class="twk-orange">${ourAvgRate}/m</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span class="twk-gold-bold">üìÖ Updated:</span>
                            <span style="color: #4ae29a; font-size: 11px;">${new Date().toLocaleTimeString()}</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- COLUMN 2: Activity (Chests, Farmers, Moving, Castle) -->
            <div style="overflow: hidden;">
    `;


        // Active Farmers
        if (activeFarmers.length > 0) {
            content += `
            <div style="margin-bottom: 10px; padding: 10px; background: rgba(139, 105, 20, 0.2); border-radius: 4px;">
                <div style="font-weight: bold; color: #ffd700; font-size: 13px; margin-bottom: 5px;">
                    üåæ Active Farmers (${activeFarmers.length})
                </div>
<div style="display: grid; grid-template-columns: 24% 23% 16% 18% 16%; gap: 4px; padding: 4px 0; border-bottom: 1px solid rgba(139, 105, 20, 0.3); margin-bottom: 4px; font-weight: bold; font-size: 11px; color: #ffd700;">
                    <div>Name</div>
                    <div>Town</div>
                    <div>Dir</div>
<div class="twk-center">Coins</div>
                    <div class="twk-right">Start</div>
                </div>
        `;

            activeFarmers.forEach(farmer => {
                let timeStr = 'Unknown';
                let totalHarvested = 0;

                if (farmer.farmStart) {
                    const farmDate = farmer.farmStart instanceof Date ? farmer.farmStart : new Date(farmer.farmStart);
                    timeStr = farmDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});

                    // Calculate total harvested: coins per minute * minutes elapsed
                    const now = new Date();
                    const minutesElapsed = (now - farmDate) / (1000 * 60); // milliseconds to minutes
                    const { coins } = parseLocationName(farmer.locationName);
                    const coinsPerMinute = parseInt(coins) || 0;
                    totalHarvested = Math.floor(coinsPerMinute * minutesElapsed);
                }

                const { townName, direction, coins } = parseLocationName(farmer.locationName);

                const isMe = String(farmer.userId) === actualUserId;
                const rowBg = isMe ? 'background: rgba(74, 226, 154, 0.25); border: 1px solid #4ae29a; border-radius: 3px;' : '';
                const nameStyle = isMe ? 'color: #4ae29a; font-weight: bold;' : 'color: #ffd700;';

                content += `
<div style="display: grid; grid-template-columns: 24% 23% 16% 18% 16%; gap: 4px; padding: 4px 0; border-bottom: 1px solid rgba(139, 105, 20, 0.1); font-size: 11px; align-items: center; ${rowBg}">
<div style="${nameStyle} overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${isMe ? 'üëâ ' : ''}${farmer.userName}</div>
                    <div class="twk-green-bold">${townName}</div>
                    <div style="color: #4ae29a; font-size: 18px; line-height: 1; padding: 0; margin: 0;">${direction}</div>
<div style="color: #ffa500; text-align: center;">${coins} (${totalHarvested.toLocaleString()})</div>
                    <div style="color:  #ffd700; font-size: 11px; text-align: right;">${timeStr}</div>
                </div>
            `;
            });

            content += `</div>`;
        } else {
            content += `
            <div style="margin-bottom: 10px; padding: 8px; background: rgba(139, 105, 20, 0.15); border-radius: 4px;">
                <div style="font-size: 11px; color: #999;">
                    ‚ö†Ô∏è No active farmers detected
                </div>
            </div>
        `;
        }

        // Members Moving
        if (moving.length > 0) {
            const castlePositionValues = [693, 662, 665, 696];
            const actuallyMoving = moving.filter(m => !castlePositionValues.includes(m.position));

            if (actuallyMoving.length > 0) {
                content += `
            <div style="margin-bottom: 10px; padding: 10px; background: rgba(139, 105, 20, 0.2); border-radius: 4px;">
                    <div style="font-size: 11px;">
                        <span class="twk-gold-bold">üö∂ Moving/Traveling (${actuallyMoving.length}):</span>
                        <span style="color: #4ae29a; margin-left: 10px;">${actuallyMoving.map(m => m.userName).join(', ')}</span>
                    </div>
                </div>
            `;
            }
        }

        // Members in Castle
        if (inCastle.length > 0) {
            content += `
            <div style="margin-bottom: 10px; padding: 10px; background: rgba(139, 105, 20, 0.2); border-radius: 4px;">
                <div style="font-size: 11px;">
                    <span class="twk-gold-bold">üè∞ In Castle (${inCastle.length}):</span>
                    <span style="color: #4ae29a; margin-left: 10px;">${inCastle.map(m => m.userName).join(', ')}</span>
                </div>
            </div>
        `;
        }
        // Unfarmed Chests - moved to bottom, single line format
        if (unfarmedChests.length > 0) {
            content += `
            <div style="margin-bottom: 10px; padding: 10px; background: rgba(139, 105, 20, 0.2); border-radius: 4px;">
                <div style="font-size: 11px;">
                    <span class="twk-gold-bold">üéÅ Unfarmed Chests (${unfarmedChests.length}):</span>
                    <span style="color: #ffa500; margin-left: 10px;">${unfarmedChests.join(', ')}</span>
                </div>
            </div>
        `;
        }

        // Close column 2
        content += `
            </div>

            <!-- COLUMN 3: Contributors -->
            <div style="display: flex; flex-direction: column; max-height: 70vh;">
                <div style="margin-bottom: 8px; flex-shrink: 0;">
                    <div style="font-weight: bold; color: #ffd700; font-size: 13px; margin-bottom: 5px;">
                        üí∞ Contributors (${contributors.length})
                    </div>
                </div>
<div style="display: grid; grid-template-columns: 13% 42% 24% 17%; gap: 4px; padding: 3px 6px; background: rgba(139, 105, 20, 0.3); border-radius: 4px; font-weight: bold; margin-bottom: 5px; flex-shrink: 0; font-size: 12px;">
<div>Rank</div>
                    <div>Name</div>
                    <div class="twk-right">Coins</div>
                    <div class="twk-right">%</div>
                </div>
                <div style="overflow-y: auto; flex: 1; scrollbar-width: none; -ms-overflow-style: none;">
    `;

        const displayLimit = 30;
        const topContributors = contributors.slice(0, displayLimit);

        topContributors.forEach((member, index) => {
            const rank = index + 1;
            const isZeroExp = member.userExp === 0;
            const expColor = isZeroExp ? '#666' : '#4ae29a';
            const rowBg = rank <= 3 ? 'rgba(255, 215, 0, 0.1)' : 'transparent';
            const percentage = totalExp > 0 ? ((member.userExp / totalExp) * 100).toFixed(1) : '0.0';

            let rankIcon = rank;
            if (rank === 1) rankIcon = 'ü•á';
            else if (rank === 2) rankIcon = 'ü•à';
            else if (rank === 3) rankIcon = 'ü•â';

            content += `
<div style="display: grid; grid-template-columns: 13% 42% 24% 17%; gap: 4px; padding: 3px 6px; background: ${rowBg}; border-bottom: 1px solid rgba(139, 105, 20, 0.2); align-items: center;">
<div style="font-size: ${rank <= 3 ? '14px' : '12px'};">${rankIcon}</div>
                <div style="color: ${isZeroExp ? '#999' : '#ffd700'}; font-weight: ${rank <= 10 ? 'bold' : 'normal'}; font-size: 12px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${member.name}</div>
                <div style="color: ${expColor}; font-family: monospace; font-size: 11px; text-align: right;">${member.userExp.toLocaleString()}</div>
                <div style="text-align: right; color: ${isZeroExp ? '#666' : '#4ae29a'}; font-family: monospace; font-size: 11px;">${percentage}%</div>
            </div>
        `;
        });

        // Close column 3 and main grid
        content += `
                </div>
            </div>
        </div>
    `;

        container.innerHTML = content;
    }
    // === RANKINGS TAB CONTENT ===
    function loadRankingsTab(container, liveData) {
        const stats = liveData.dominationStats || {};
        const clansData = liveData.mapState?.clans || {};

        const guilds = [];

        for (const [guildId, guildStats] of Object.entries(stats)) {
            const clanInfo = clansData[guildId] || {};

            guilds.push({
                id: guildId,
                title: clanInfo.title || `Guild ${guildId}`,
                serverId: clanInfo.serverId || '-',
                country: clanInfo.country || '-',
                membersCount: clanInfo.membersCount || '-',
                topActivity: clanInfo.topActivity || '-',
                topDungeon: clanInfo.topDungeon || '-',
                power: guildStats.power || 0,
                towns: guildStats.towns || 0,
                coins: guildStats.coins || 0
            });
        }

        guilds.sort((a, b) => b.coins - a.coins);

        // Calculate coins/min for each guild using historical data
        let historicalData = [];
        try {
            historicalData = JSON.parse(localStorage.getItem('hwh_aoc_history')) || [];
        } catch(e) {}

        const guildRates = {};
        let totalHistoricalRate = 0;

        // Use actual event start time if available for accurate rate calculation
        const eventStartMs = liveData.eventInfo?.startTime ? liveData.eventInfo.startTime * 1000 : null;

        if (eventStartMs) {
            const elapsedMinutes = (Date.now() - eventStartMs) / (1000 * 60);
            if (elapsedMinutes > 0) {
                guilds.forEach(guild => {
                    const rate = Math.round(guild.coins / elapsedMinutes);
                    guildRates[guild.id] = rate;
                    totalHistoricalRate += rate;
                });
            }
        } else if (historicalData.length >= 2) {
            // Fallback to historical data
            const firstEntry = historicalData[0];
            const lastEntry = historicalData[historicalData.length - 1];
            const elapsedMinutes = (lastEntry.timestamp - firstEntry.timestamp) / (1000 * 60);
            if (elapsedMinutes > 0) {
                guilds.forEach(guild => {
                    const firstCoins = firstEntry.guilds?.[guild.id]?.coins || 0;
                    const lastCoins = lastEntry.guilds?.[guild.id]?.coins || guild.coins;
                    const coinGain = lastCoins - firstCoins;
                    const rate = Math.round(coinGain / elapsedMinutes);
                    guildRates[guild.id] = rate;
                    totalHistoricalRate += rate;
                });
            }
        }

        const avgCoinsPerGuild = guilds.length > 0 ? Math.round(totalHistoricalRate / guilds.length) : 0;

        const languageMap = {
            '1': 'üá©üá™', '2': 'üá¨üáß', '4': 'üá´üá∑',
            '6': 'üá∑üá∫', '9': 'üáØüáµ', '10': 'üá∞üá∑',
            '11': 'üáµüá±', '13': 'üáµüáπ'
        };


        let content = `
<div style="display: grid; grid-template-columns: 4% 16% 8% 6% 5% 5% 6% 6% 5% 9% 8% 7%; gap: 8px; padding: 8px; background: rgba(139, 105, 20, 0.3); border-radius: 4px; font-weight: bold; margin-bottom: 8px; font-size: 13px; white-space: nowrap;"><div class="twk-center">#</div>
<div>Guild</div>
<div class="twk-right">üí∞Score</div>
<div class="twk-right">ü™ô/m</div>
<div class="twk-right">üìäDiff</div>
<div class="twk-center">üèòÔ∏è</div>
<div class="twk-right">üñ•Ô∏èSvr</div>
<div class="twk-right">üë•Mem</div>
<div class="twk-center">üåê</div>
<div class="twk-right">üí™Power</div>
<div class="twk-right">üìäAct</div>
<div class="twk-right">üèõÔ∏èDng</div>
        </div>
    `;

        guilds.forEach((guild, index) => {
            const rank = index + 1;
            let rankIcon = rank;
            if (rank === 1) rankIcon = 'ü•á';
            else if (rank === 2) rankIcon = 'ü•à';
            else if (rank === 3) rankIcon = 'ü•â';

            const rowBg = rank <= 3 ? 'rgba(255, 215, 0, 0.1)' : 'transparent';
            const borderColor = rank === 1 ? '#ffd700' : rank <= 3 ? '#cd7f32' : 'rgba(139, 105, 20, 0.2)';

            // Calculate difference from position above
            let scoreDiff = '-';
            let diffColor = '#999';
            if (rank > 1) {
                const prevGuild = guilds[index - 1];
                const diff = prevGuild.coins - guild.coins;
                scoreDiff = diff.toLocaleString();
                diffColor = diff > 1000 ? '#ff6b6b' : diff > 100 ? '#ffa500' : '#4ae29a';
            }

            content += `
            <div style="display: grid; grid-template-columns: 4% 16% 8% 6% 5% 5% 6% 6% 5% 9% 8% 7%; gap: 8px; padding: 8px; background: ${rowBg}; border-bottom: 1px solid ${borderColor}; align-items: center; font-size: 12px;">
                <div style="text-align: center; font-size: ${rank <= 3 ? '16px' : '12px'};">${rankIcon}</div>
                <div class="clickable-guild" data-clan-id="${guild.id}" style="color: ${rank <= 3 ? '#ffd700' : '#ddd'}; font-weight: ${rank <= 5 ? 'bold' : 'normal'}; cursor: pointer; text-decoration: underline; font-size: 13px;" title="Click for guild details">${guild.title}</div>
                <div style="text-align: right; font-family: monospace; color: #4ae29a; font-weight: bold; font-size: 14px;">${guild.coins.toLocaleString()}</div>
                <div style="text-align: right; font-family: monospace; color: #ffa500; font-weight: bold; font-size: 12px;">${guildRates[guild.id] || '-'}</div>
                <div style="text-align: right; font-family: monospace; color: ${diffColor}; font-weight: bold; font-size: 14px;">${scoreDiff}</div>
                <div style="text-align: center; color: #ccc; font-weight: bold; font-size: 14px;">${guild.towns}</div>
                <div style="text-align: right; color: #999; font-weight: bold; font-size: 14px;">${guild.serverId}</div>
                <div style="text-align: right; color: #ccc; font-weight: bold; font-size: 14px;">${guild.membersCount}</div>
                <div class="twk-center">${languageMap[guild.country] || guild.country}</div>
                <div style="text-align: right; font-family: monospace; color: #999; font-weight: bold; font-size: 14px;">${guild.power.toLocaleString()}</div>
                <div style="text-align: right; font-family: monospace; color: #8ab4f8; font-weight: bold; font-size: 14px;">${typeof guild.topActivity === 'number' ? guild.topActivity.toLocaleString() : guild.topActivity}</div>
                <div style="text-align: right; font-family: monospace; color: #f4b183; font-weight: bold; font-size: 14px;">${typeof guild.topDungeon === 'number' ? guild.topDungeon.toLocaleString() : guild.topDungeon}</div>
            </div>
        `;
        });

        content += `
        <div style="margin-top: 15px; padding: 10px; background: rgba(139, 105, 20, 0.2); border-radius: 4px; font-size: 11px; color: #999; text-align: center;">
            üìä Total Guilds: ${guilds.length} ‚Ä¢ ü™ô Map Total: ${totalHistoricalRate}/m (Avg: ${avgCoinsPerGuild}/m) ‚Ä¢ Data refreshed at: ${new Date().toLocaleString()}
        </div>
    `;

        container.innerHTML = content;

        // Add click handlers for guild names
        container.querySelectorAll('.clickable-guild').forEach(el => {
            el.addEventListener('click', (e) => {
                e.stopPropagation();
                const clanId = el.getAttribute('data-clan-id');
                if (clanId && window.showClanPopup) window.showClanPopup(clanId);
            });
        });
    }

    ModuleTracker.register('AoC Stats');

    function initializePositionNames() {
        const defaultNames = {
            397: "AVELEW Northeast 2",
            596: "ARCANIA Northeast 1",
            585: "CLEARBERT Northwest 1",
            439: "CRISTALLION East 4",
            356: "CRADENA Northeast 1",
            465: "DALEMONT Northwest 1",
            126: "DRAKEMORE Southeast 8",
            407: "EVERFORT Southwest 1",
            423: "FJEMARK Northwest 2",
            468: "FORGALE Southeast 1",
            26: "FRADO Northeast 4",
            404: "GALADOR Northeast 1",
            115: "HELESS East 8",
            36: "HIMDALE Southeast 4",
            101: "JORIA Southwest 8",
            33: "KIATON Northwest 4",
            375: "LANDO Northwest 1",
            343: "LORDARONE Southeast 2",
            333: "LORENNDOR North 4",
            1: "MIDTOWN Center 32",
            112: "MONBRIDGE West 8",
            359: "MOONGRAVE Southwest 1",
            588: "MORPORK Southeast 1",
            426: "ODENGUARD Southeast 2",
            340: "OFFORD Northwest 2",
            449: "SHADOWMOORE Southwest 2",
            98: "SKULLMORE Northeast 8",
            436: "SLAPDALE West 4",
            378: "STRAMGUARD Southeast 1",
            599: "TERRANORE Southwest 1",
            336: "UGGARIO South 4",
            446: "ULEYIM Northeast 2",
            123: "VERDANT Northwest 8",
            394: "VIATON Southwest 2",
            29: "WRAND Southwest 4"
        };

        try {
            let positionNames = JSON.parse(localStorage.getItem('hwh_aoc_position_names')) || {};
            let updated = false;

            for (const [pos, name] of Object.entries(defaultNames)) {
                if (!positionNames[pos]) {
                    positionNames[pos] = name;
                    updated = true;
                }
            }

            if (updated) {
                localStorage.setItem('hwh_aoc_position_names', JSON.stringify(positionNames));
            }

            return positionNames;
        } catch (e) {
            console.error('Failed to initialize position names:', e);
            return defaultNames;
        }
    }

    function savePositionName(position, name) {
        try {
            let positionNames = JSON.parse(localStorage.getItem('hwh_aoc_position_names')) || {};
            positionNames[position] = name;
            localStorage.setItem('hwh_aoc_position_names', JSON.stringify(positionNames));
            debugLog(`‚úÖ Saved position ${position} as "${name}"`);
            return true;
        } catch (e) {
            console.error('Failed to save position name:', e);
            return false;
        }
    }

    function loadAocGraphTab(container, historicalData, liveData, eventEnded = false) {
        if (!historicalData || historicalData.length < 2) {
            container.innerHTML = '<div style="padding: 40px; text-align: center; color: #999;">Not enough data points yet. Enable auto-refresh to collect data over time.</div>';
            return;
        }
        // Event ended banner
        const endedBanner = eventEnded ? `
            <div style="background: linear-gradient(90deg, #8b0000, #dc3545, #8b0000); color: #fff; padding: 8px 16px; border-radius: 4px; margin-bottom: 10px; text-align: center; font-weight: bold; font-size: 13px; box-shadow: 0 2px 8px rgba(220,53,69,0.4);">
                üèÅ EVENT ENDED ‚Äî Final Results
            </div>
        ` : '';

        // Get guild info
        const stats = liveData.dominationStats || {};
        const clansData = liveData.mapState?.clans || {};
        const guilds = [];
        for (const [guildId, guildStats] of Object.entries(stats)) {
            const clanInfo = clansData[guildId] || {};
            guilds.push({
                id: guildId,
                title: clanInfo.title || `Guild ${guildId}`,
                coins: guildStats.coins || 0
            });
        }
        guilds.sort((a, b) => b.coins - a.coins);

        // Graph dimensions
        // Graph dimensions - fill container width
        const graphWidth = container.clientWidth - 40 || 900;
        const graphHeight = 350;
        const padding = { top: 20, right: 120, bottom: 40, left: 70 };
        const plotWidth = graphWidth - padding.left - padding.right;
        const plotHeight = graphHeight - padding.top - padding.bottom;

        // Find min/max values
        let minCoins = Infinity, maxCoins = 0;
        let minTime = historicalData[0].timestamp;
        let maxTime = historicalData[historicalData.length - 1].timestamp;

        // Use actual event times if available, otherwise fall back to 2:00 UTC snapping
        const eventInfo = liveData?.eventInfo;
        let snapTime; // Keep defined for dayOfEvent calculation

        if (eventInfo?.startTime) {
            minTime = eventInfo.startTime * 1000;
            snapTime = new Date(minTime);
            debugLog(`üè∞ AoC graph using server startTime: ${new Date(minTime).toISOString()}`);
        } else {
            // Fallback: Snap left edge to 2:00 UTC before first data
            const startDate = new Date(minTime);
            snapTime = new Date(Date.UTC(
                startDate.getUTCFullYear(),
                startDate.getUTCMonth(),
                startDate.getUTCDate(),
                2, 0, 0, 0
            ));
            if (snapTime.getTime() > minTime) {
                snapTime.setUTCDate(snapTime.getUTCDate() - 1);
            }
            minTime = snapTime.getTime();
        }

        if (eventInfo?.endTime) {
            const eventEndMs = eventInfo.endTime * 1000;
            const now = Date.now();
            // Clip to current time if event still active, otherwise show full range
            maxTime = eventEnded ? eventEndMs : Math.min(eventEndMs, now);
            debugLog(`üè∞ AoC graph using ${eventEnded ? 'server endTime' : 'current time'}: ${new Date(maxTime).toISOString()}`);
        } else if (!eventEnded) {
            // No event info, clip to now
            maxTime = Math.min(maxTime, Date.now());
        }
        historicalData.forEach(entry => {
            Object.values(entry.guilds || {}).forEach(g => {
                maxCoins = Math.max(maxCoins, g.coins);
            });
        });

        // Force Y-axis to start at 0, add padding to top only
        minCoins = 0;
        const yPadding = maxCoins * 0.1;
        maxCoins = maxCoins + yPadding;

        const timeRange = maxTime - minTime;

        // Build day shading and day boundary lines (at 2:00 UTC)
        let dayShading = '';
        let dayLines = '';
        const dayBoundaries = [];

        // Find all 2:00 UTC boundaries within our time range
        let boundaryTime = new Date(minTime);
        boundaryTime.setUTCHours(2, 0, 0, 0);
        if (boundaryTime.getTime() < minTime) {
            boundaryTime.setUTCDate(boundaryTime.getUTCDate() + 1);
        }

        // Collect all day boundaries
        while (boundaryTime.getTime() <= maxTime) {
            dayBoundaries.push(boundaryTime.getTime());
            boundaryTime = new Date(boundaryTime.getTime());
            boundaryTime.setUTCDate(boundaryTime.getUTCDate() + 1);
        }

        // Draw alternating day shading
        let prevX = padding.left;
        let dayIndex = 0;

        // Determine starting day parity based on first boundary
        const firstBoundaryDate = new Date(minTime);
        const dayOfEvent = Math.floor((minTime - snapTime.getTime()) / (24 * 60 * 60 * 1000));

        dayBoundaries.forEach((boundary, i) => {
            const x = padding.left + ((boundary - minTime) / timeRange) * plotWidth;
            // Shade the region from prevX to x
            const shade = (dayIndex % 2 === 0) ? 'rgba(255,255,255,0.03)' : 'rgba(0,0,0,0.1)';
            dayShading += `<rect x="${prevX}" y="${padding.top}" width="${x - prevX}" height="${plotHeight}" fill="${shade}"/>`;
            // Draw day boundary line
            dayLines += `<line x1="${x}" y1="${padding.top}" x2="${x}" y2="${padding.top + plotHeight}" stroke="rgba(255,215,0,0.3)" stroke-width="1" stroke-dasharray="4,4"/>`;
            prevX = x;
            dayIndex++;
        });

        // Shade final region to right edge
        const finalShade = (dayIndex % 2 === 0) ? 'rgba(255,255,255,0.03)' : 'rgba(0,0,0,0.1)';
        dayShading += `<rect x="${prevX}" y="${padding.top}" width="${padding.left + plotWidth - prevX}" height="${plotHeight}" fill="${finalShade}"/>`;


        // Guild colors
        const colors = ['#ffd700', '#c0c0c0', '#cd7f32', '#4ae29a'];

        // Build SVG paths for each guild
        let paths = '';
        let legends = '';

        guilds.forEach((guild, idx) => {
            const color = colors[idx] || '#888';
            let pathData = '';
            let lastY = 0;
            let lastCoins = 0;

            historicalData.forEach((entry, i) => {
                const guildData = entry.guilds?.[guild.id];
                if (guildData) {
                    const x = padding.left + ((entry.timestamp - minTime) / timeRange) * plotWidth;
                    const y = padding.top + plotHeight - ((guildData.coins - minCoins) / (maxCoins - minCoins)) * plotHeight;
                    pathData += (pathData === '' ? 'M' : 'L') + `${x.toFixed(1)},${y.toFixed(1)} `;
                    lastY = y;
                    lastCoins = guildData.coins;
                }
            });

            // Extend line horizontally to current time (not future)
            if (pathData) {
                const now = Date.now();
                const effectiveEndTime = Math.min(maxTime, now);
                const rightEdgeX = padding.left + ((effectiveEndTime - minTime) / timeRange) * plotWidth;
                pathData += `L${rightEdgeX.toFixed(1)},${lastY.toFixed(1)} `;
                paths += `<path d="${pathData}" stroke="${color}" stroke-width="2" fill="none" clip-path="url(#plotClip)"/>`;
                // Legend positioned at right edge
                legends += `<text x="${graphWidth - padding.right + 10}" y="${lastY}" fill="${color}" font-size="11" alignment-baseline="middle">${guild.title}</text>`;
            }
        });



        // Y-axis labels
        let yLabels = '';
        for (let i = 0; i <= 5; i++) {
            const val = minCoins + (maxCoins - minCoins) * (i / 5);
            const y = padding.top + plotHeight - (i / 5) * plotHeight;
            yLabels += `<text x="${padding.left - 10}" y="${y}" fill="#999" font-size="10" text-anchor="end" alignment-baseline="middle">${Math.round(val).toLocaleString()}</text>`;
            yLabels += `<line x1="${padding.left}" y1="${y}" x2="${padding.left + plotWidth}" y2="${y}" stroke="#333" stroke-dasharray="2,2"/>`;
        }

        // X-axis labels (time with day/date)
        let xLabels = '';
        for (let i = 0; i <= 4; i++) {
            const t = minTime + (timeRange * i / 4);
            const x = padding.left + (i / 4) * plotWidth;
            const d = new Date(t);
            const dayName = d.toLocaleDateString([], {weekday: 'short'});
            const dateStr = d.toLocaleDateString([], {month: 'short', day: 'numeric'});
            const timeStr = d.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
            xLabels += `<text x="${x}" y="${graphHeight - 22}" fill="#999" font-size="9" text-anchor="middle">${dayName} ${dateStr}</text>`;
            xLabels += `<text x="${x}" y="${graphHeight - 10}" fill="#ccc" font-size="10" text-anchor="middle">${timeStr}</text>`;
        }

        container.innerHTML = `
            <div style="padding: 10px;">
                ${endedBanner}
                <div style="text-align: center; margin-bottom: 10px; color: #ffd700; font-weight: bold;">Guild Score Over Time</div>
                <svg width="${graphWidth}" height="${graphHeight}" style="background: rgba(0,0,0,0.2); border-radius: 4px;">
                    <!-- Clip path for plot area -->
                    <defs>
                        <clipPath id="plotClip">
                            <rect x="${padding.left}" y="${padding.top}" width="${plotWidth}" height="${plotHeight}"/>
                        </clipPath>
                    </defs>
                    <!-- Day shading (behind everything) -->
                    ${dayShading}
                    <!-- Grid -->
                    ${yLabels}
                    ${xLabels}
                    <!-- Day boundary lines -->
                    ${dayLines}
                    <!-- Axes -->
                    <line x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${padding.top + plotHeight}" stroke="#666"/>
                    <line x1="${padding.left}" y1="${padding.top + plotHeight}" x2="${padding.left + plotWidth}" y2="${padding.top + plotHeight}" stroke="#666"/>
                    <!-- Data (clipped to plot area) -->
                    ${paths}
                    <!-- Legend -->
                    ${legends}
                </svg>
                <div style="margin-top: 10px; color: #999; font-size: 11px; text-align: center;">
                    ${historicalData.length} data points over ${Math.round(timeRange / 60000)} minutes
                </div>
            </div>
        `;
    }

    function loadTeamHealthTab(container, liveData) {
        const users = liveData.mapState?.users || {};
        const clansData = liveData.mapState?.clans || {};
        const guildMembers = liveData.guildMembers || {};
        const userPositions = liveData.mapState?.userPositions || {};
        const townPositions = liveData.mapState?.townPositions || {};
        const positionNames = JSON.parse(localStorage.getItem('hwh_aoc_position_names')) || {};
        const castlePositions = [693, 662, 665, 696];

        // Get my guild ID
        const myGuildId = Object.values(guildMembers)[0]?.clanId;

        // Build lookup: position -> town data (for farming status)
        const farmingByUser = {};
        for (const [pos, townData] of Object.entries(townPositions)) {
            if (townData.userId && townData.status === 1) {
                const locName = positionNames[pos] || `Position ${pos}`;
                const parts = locName.split(' ');
                let townName = locName;
                let coins = '';
                if (parts.length >= 3) {
                    coins = parts[parts.length - 1];
                    townName = parts.slice(0, -2).join(' ');
                }
                farmingByUser[String(townData.userId)] = { townName, coins, position: pos };
            }
        }

        let html = '<div style="padding: 10px;">';

        // Process each guild
        for (const [guildId, guildUsers] of Object.entries(users)) {
            const clanInfo = clansData[guildId] || {};
            const guildTitle = clanInfo.title || `Guild ${guildId}`;
            const isMyGuild = String(guildId) === String(myGuildId);
            const guildColor = isMyGuild ? '#4ae29a' : '#ffd700';

            // Categorize players
            const farmers = [];
            const atCastle = [];
            const moving = [];

            for (const [userId, userData] of Object.entries(guildUsers)) {
                const defenseState = userData.defenseState || {};
                const playerName = userData.name || `User ${userId}`;
                const userPos = userPositions[userId];

                if (Object.keys(defenseState).length === 0) continue;

                let totalHpPct = 0;
                let totalNrgPct = 0;
                let heroCount = 0;
                let teamHeroes = [];

                for (const [heroId, state] of Object.entries(defenseState)) {
                    const isPet = parseInt(heroId) >= 6000;
                    const name = getName(parseInt(heroId), isPet ? 'pet' : 'hero');

                    if (state.maxHp > 0) {
                        const hpPct = Math.round((state.hp / state.maxHp) * 100);
                        const nrgPct = Math.round(state.energy / 10);
                        totalHpPct += hpPct;
                        totalNrgPct += nrgPct;
                        heroCount++;

                        teamHeroes.push({ name, hpPct, nrgPct, isPet: false });
                    } else {
                        // Pet with -1 hp (full)
                        teamHeroes.push({ name, hpPct: 100, nrgPct: 100, isPet: true });
                    }
                }

                const avgHp = heroCount > 0 ? Math.round(totalHpPct / heroCount) : 0;
                const avgNrg = heroCount > 0 ? Math.round(totalNrgPct / heroCount) : 0;

                const playerData = {
                    name: playerName,
                    odId: userId,
                    teamHeroes,
                    avgHp,
                    avgNrg
                };

                // Determine location
                const farmInfo = farmingByUser[userId];
                if (farmInfo) {
                    playerData.location = farmInfo.townName;
                    playerData.coins = farmInfo.coins;
                    farmers.push(playerData);
                } else if (castlePositions.includes(userPos)) {
                    playerData.location = 'Castle';
                    atCastle.push(playerData);
                } else {
                    playerData.location = userPos ? `Pos ${userPos}` : 'Unknown';
                    moving.push(playerData);
                }
            }

            // Sort farmers by coins descending
            farmers.sort((a, b) => parseInt(b.coins || 0) - parseInt(a.coins || 0));

            html += `<div style="margin-bottom: 20px;">`;
            html += `<h4 style="color: ${guildColor}; margin: 0 0 8px 0; border-bottom: 1px solid #555; padding-bottom: 4px;">${isMyGuild ? '‚≠ê ' : ''}${guildTitle}</h4>`;

            // Farmers section
            if (farmers.length > 0) {
                html += `<div style="margin-bottom: 10px;"><span class="twk-green-bold">üåæ Farming (${farmers.length})</span></div>`;
                html += buildTeamTable(farmers, true);
            }

            // Castle section
            if (atCastle.length > 0) {
                html += `<div style="margin: 10px 0;"><span style="color: #ffa500; font-weight: bold;">üè∞ At Castle (${atCastle.length})</span></div>`;
                html += buildTeamTable(atCastle, false);
            }

            // Moving/Idle section
            if (moving.length > 0) {
                html += `<div style="margin: 10px 0;"><span class="twk-red-bold">üö∂ Moving/Idle (${moving.length})</span></div>`;
                html += buildTeamTable(moving, false);
            }

            html += `</div>`;
        }

        html += '</div>';
        container.innerHTML = html;

        function buildTeamTable(players, showCoins) {
            let table = `<table style="width: 100%; border-collapse: collapse; font-size: 11px;">`;
            table += `<thead><tr style="background: rgba(139,105,20,0.3);">
                <th style="padding: 4px; text-align: left; color: #ccc;">Player</th>
                <th style="padding: 4px; text-align: left; color: #ccc;">Location</th>
                ${showCoins ? '<th style="padding: 4px; text-align: center; color: #ccc;">üí∞</th>' : ''}
                <th style="padding: 4px; text-align: center; color: #ccc;">Hero 1</th>
                <th style="padding: 4px; text-align: center; color: #ccc;">Hero 2</th>
                <th style="padding: 4px; text-align: center; color: #ccc;">Hero 3</th>
                <th style="padding: 4px; text-align: center; color: #ccc;">Hero 4</th>
                <th style="padding: 4px; text-align: center; color: #ccc;">Hero 5</th>
                <th style="padding: 4px; text-align: center; color: #ccc;">Pet</th>
                <th style="padding: 4px; text-align: center; color: #ccc;">‚ù§Ô∏è</th>
                <th style="padding: 4px; text-align: center; color: #ccc;">‚ö°</th>
            </tr></thead><tbody>`;

            for (const p of players) {
                const avgHpColor = p.avgHp === 100 ? '#4ae29a' : p.avgHp > 50 ? '#ffa500' : '#ff6b6b';
                const avgNrgColor = p.avgNrg === 100 ? '#4ae29a' : '#ffd700';

                // Build hero cells (5 heroes + 1 pet)
                let heroCells = '';
                for (let i = 0; i < 6; i++) {
                    const hero = p.teamHeroes[i];
                    if (hero) {
                        const isDead = hero.hpPct === 0;
                        const nameColor = isDead ? '#ff6b6b' : '#ccc';
                        const hpColor = isDead ? '#ff6b6b' : (hero.hpPct === 100 ? '#4ae29a' : hero.hpPct > 50 ? '#ffa500' : '#ff6b6b');
                        const nrgColor = hero.nrgPct === 100 ? '#4ae29a' : '#ffd700';

                        if (hero.isPet) {
                            heroCells += `<td style="padding: 4px; text-align: center;"><span class="twk-green">${hero.name}</span></td>`;
                        } else {
                            heroCells += `<td style="padding: 4px; text-align: center;"><span style="color: ${nameColor};">${hero.name}</span><br><span style="color: ${hpColor};">${hero.hpPct}</span>/<span style="color: ${nrgColor};">${hero.nrgPct}</span></td>`;
                        }
                    } else {
                        heroCells += `<td style="padding: 4px; text-align: center; color: #444;">-</td>`;
                    }
                }

                table += `<tr style="border-bottom: 1px solid #333;">
                    <td style="padding: 4px; color: #fff;">${p.name}</td>
                    <td style="padding: 4px; color: #4ae29a;">${p.location}</td>
                    ${showCoins ? `<td style="padding: 4px; text-align: center; color: #ffa500;">${p.coins || '-'}</td>` : ''}
                    ${heroCells}
                    <td style="padding: 4px; text-align: center; color: ${avgHpColor}; font-weight: bold;">${p.avgHp}%</td>
                    <td style="padding: 4px; text-align: center; color: ${avgNrgColor}; font-weight: bold;">${p.avgNrg}%</td>
                </tr>`;
            }

            table += `</tbody></table>`;
            return table;
        }
    }

    function getPositionName(position) {
        try {
            initializePositionNames();
            let positionNames = JSON.parse(localStorage.getItem('hwh_aoc_position_names')) || {};
            return positionNames[position] || `Position ${position}`;
        } catch (e) {
            console.error('Failed to load position name:', e);
            return `Position ${position}`;
        }
    }

    function viewAllPositionNames() {
        try {
            let positionNames = JSON.parse(localStorage.getItem('hwh_aoc_position_names')) || {};
            console.table(positionNames);
            return positionNames;
        } catch (e) {
            console.error('Failed to view position names:', e);
            return {};
        }
    }

    function resetPositionNamesToDefaults() {
        try {
            // Clear the saved position names
            localStorage.removeItem('hwh_aoc_position_names');

            // Re-initialize from defaults (uses the defaultNames inside initializePositionNames)
            initializePositionNames();

            debugLog('‚úÖ Reset all position names to defaults');
            return true;
        } catch (e) {
            console.error('Failed to reset position names:', e);
            return false;
        }
    }

    // Make functions available globally
    window.savePositionName = savePositionName;
    window.getPositionName = getPositionName;
    window.viewAllPositionNames = viewAllPositionNames;

    window.upgradeCastle = async function(coinAmount = 1) {
        try {
            const SendFunction = getSend();
            const amount = parseInt(coinAmount);

            if (isNaN(amount) || amount <= 0) {
                console.error('Invalid coin amount:', coinAmount);
                return false;
            }

            debugLog(`Upgrading castle with ${amount} coins...`);
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress(`üè∞ Upgrading castle with ${amount} coins...`, false);
            }

            const response = await SendFunction(`{"calls":[{"name":"clanCastle_upgrade","args":{"optionId":1,"amount":${amount}},"context":{"actionTs":${Date.now()}},"ident":"body"}]}`);

            if (response?.results?.[0]?.result && !response.results[0].result.error) {
                debugLog(`‚úÖ Castle upgraded successfully with ${amount} coins`);
                if (HWHFuncs && HWHFuncs.setProgress) {
                    HWHFuncs.setProgress(`‚úÖ Castle upgraded with ${amount} coins`, false);
                }

                // Show enhanced AoC stats popup after successful contribution
                // Refresh inventory after contribution
                try {
                    if (typeof cheats !== 'undefined' && cheats.refreshInventory) {
                        await cheats.refreshInventory();
                    }
                } catch(e) { debugLog('Inventory refresh skipped:', e); }

                setTimeout(() => {
                    window.showAoCStatsEnhanced();  // ‚Üê CHANGED FROM showCastleContributorsLive
                }, 500);

                return true;
            } else {
                const error = response?.results?.[0]?.result?.error || 'Unknown error';
                console.error('Castle upgrade error:', error);
                if (HWHFuncs && HWHFuncs.setProgress) {
                    HWHFuncs.setProgress(`‚ùå Castle upgrade failed: ${error}`, true);
                }
                return false;
            }
        } catch (error) {
            console.error('Error upgrading castle:', error);
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress(`‚ùå Castle upgrade error: ${error.message}`, true);
            }
            return false;
        }
    };

    ModuleTracker.register('Enhanced Button Calls');



    // ================================================================
    // SECTION 7: COLLECT MORE FUNCTIONALITY (REFACTORED & FIXED FOR 2.403)
    // ================================================================

    // Function availability checker - Updated for 2.403
    function checkFunctionAvailability(name, fallbackName) {
        // Special case for reload
        if (fallbackName === 'reloadGame') {
            return typeof location !== 'undefined' && typeof location.reload === 'function';
        }

        // Special case for Do All HWH - Updated for 2.403
        if (fallbackName === 'doAllHWH') {
            // Check both old and new button structures
            const doAllButton =
                  DOMCache.getAll('scriptBtnPlates', '.scriptMenu_btnPlate').find(el =>
                                                                                  el.textContent?.trim() === 'Do All'
                                                                                 ) ||
                  Array.from(document.querySelectorAll('.scriptMenu_button, .scriptMenu_btnGap')).find(el =>
                                                                                                       el.textContent?.trim() === 'Do All'
                                                                                                      );
            return !!doAllButton;
        }

        // Check direct window access first
        if (typeof window[fallbackName] === 'function') {
            return true;
        }

        // Try eval (careful)
        try {
            if (typeof eval(fallbackName) === 'function') {
                return true;
            }
        } catch (e) {
            // Function not available
        }

        return false;
    }
    // Helper to close sync/OK popups
    async function closeSyncPopup(delay = 800) {
        await new Promise(r => setTimeout(r, delay));

        // Try multiple times since popup may appear with delay
        for (let attempt = 0; attempt < 3; attempt++) {
            try {
                // Send Escape keypress to close game native popups (like "New day in Dominion")
                document.dispatchEvent(new KeyboardEvent('keydown', {
                    key: 'Escape',
                    keyCode: 27,
                    bubbles: true
                }));

                // Also try clicking HWH popup OK buttons
                const btnPlates = DOMCache.getAll('popupBtnPlates', '.PopUp_btnPlate', true);
                for (const plate of btnPlates) {
                    if (plate.offsetParent !== null && plate.textContent?.trim().toUpperCase() === 'OK') {
                        const parent = plate.parentElement;
                        if (parent) {
                            parent.click();
                            debugLog('‚úÖ Closed sync popup (HWH)');
                            return true;
                        }
                    }
                }

                // Fallback: direct button search
                const okButtons = DOMCache.getAll('popupOkButtons', '.PopUp_btnGap, .PopUp_button', true);
                for (const btn of okButtons) {
                    if (btn.offsetParent !== null && btn.textContent?.trim().toUpperCase() === 'OK') {
                        btn.click();
                        debugLog('‚úÖ Closed sync popup (fallback)');
                        return true;
                    }
                }
            } catch (e) {
                debugLog('closeSyncPopup attempt failed:', e);
            }

            // Wait before next attempt
            if (attempt < 2) {
                await new Promise(r => setTimeout(r, 500));
            }
        }
        debugLog('üì§ Sent Escape keypresses to close game popup');
        return true;
    }
    // Function mapping for Collect More - Fixed for 2.403
    function createFunctionMap() {
        return {
            // Collection functions
            collectSoulShop: () => {
                if (!window.buyAllInSoulShop) throw new Error('Soul Shop function not available');
                return window.buyAllInSoulShop();
            },
            buyShopsWithPriority: () => {
                if (!window.buyShopsWithCraftPriority) throw new Error('Shop Priority function not available');
                return window.buyShopsWithCraftPriority();
            },
            collectGuildRewards: async () => {
                if (!window.collectAllGuildRewards) throw new Error('Guild Rewards function not available');
                const results = await window.collectAllGuildRewards();
                return {
                    success: results.success,
                    items: results.items,
                    count: results.count,
                    hasItems: results.hasItems,
                    rewards: results.rewards
                };
            },

            collectClanPrestige: async () => {
                if (!window.collectClanPrestigeRewards) throw new Error('Clan Prestige function not available');
                const result = await window.collectClanPrestigeRewards();
                return {
                    success: result.success,
                    items: result.items,
                    count: result.count,
                    hasItems: result.hasItems,
                    rewards: result.rewards
                };
            },
            collectMail: async () => {
                try {
                    debugLog('üì¨ Starting mail collection...');
                    const SendFunction = getSend();

                    // Get all mail
                    const mailResponse = await SendFunction(JSON.stringify({
                        calls: [{ name: 'mailGetAll', args: {}, ident: 'mailGetAll' }]
                    }));

                    const letters = mailResponse?.results?.[0]?.result?.response?.letters;
                    if (!letters || !Object.keys(letters).length) {
                        return { success: true, items: 'No mail to collect', count: 0, hasItems: false };
                    }

                    // Filter using same logic as HWH Letters class
                    const letterIds = [];
                    for (const id in letters) {
                        const letter = letters[id];
                        const reward = letter?.reward;
                        if (!reward || !Object.keys(reward).length) continue;

                        const shouldSkip = (
                            reward?.refillable?.[45] ||
                            reward?.stamina ||
                            reward?.buff ||
                            reward?.vipPoints ||
                            reward?.fragmentHero ||
                            reward?.bundleHeroReward
                        );

                        if (!shouldSkip) letterIds.push(~~letter.id);
                    }

                    if (!letterIds.length) {
                        return { success: true, items: 'No safe mail to collect', count: 0, hasItems: false };
                    }

                    if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`üì¨ Collecting ${letterIds.length} letters...`, false);

                    // Collect filtered mail
                    const collectResponse = await SendFunction(JSON.stringify({
                        calls: [{ name: 'mailFarm', args: { letterIds }, ident: 'mailFarm' }]
                    }));

                    const results = collectResponse?.results?.[0]?.result?.response || {};
                    const collectedRewards = {};

                    // Aggregate rewards from all letters
                    for (const [letterId, reward] of Object.entries(results)) {
                        if (reward.gold) collectedRewards['ü™ô Gold'] = (collectedRewards['ü™ô Gold'] || 0) + reward.gold;
                        if (reward.starmoney) collectedRewards['üíé Emeralds'] = (collectedRewards['üíé Emeralds'] || 0) + reward.starmoney;
                        if (reward.coin) {
                            for (const [coinId, amt] of Object.entries(reward.coin)) {
                                const name = window.identifyItem?.(coinId, 'coin') || `Coin #${coinId}`;
                                collectedRewards[`üí∞ ${name}`] = (collectedRewards[`üí∞ ${name}`] || 0) + (parseInt(amt) || 0);
                            }
                        }
                        if (reward.consumable) {
                            for (const [itemId, qty] of Object.entries(reward.consumable)) {
                                const name = window.identifyItem?.(itemId, 'consumable') || `Item #${itemId}`;
                                collectedRewards[`üì¶ ${name}`] = (collectedRewards[`üì¶ ${name}`] || 0) + (parseInt(qty) || 0);
                            }
                        }
                        if (reward.gear) {
                            for (const [itemId, qty] of Object.entries(reward.gear)) {
                                const name = window.identifyItem?.(itemId, 'gear') || `Gear #${itemId}`;
                                collectedRewards[`‚öôÔ∏è ${name}`] = (collectedRewards[`‚öôÔ∏è ${name}`] || 0) + (parseInt(qty) || 0);
                            }
                        }
                    }

                    const count = Object.keys(results).length;
                    const rewardCount = Object.keys(collectedRewards).length;
                    // Convert to structured format
                    const structuredRewards = {};
                    for (const [name, amount] of Object.entries(collectedRewards)) {
                        structuredRewards[name] = { amount, source: 'M' };
                    }

                    if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`‚úÖ Mail: ${count} letters collected`, false);

                    return {
                        success: true,
                        items: rewardCount > 0 ? `${count} letters` : `${count} letters collected`,
                        count,
                        hasItems: rewardCount > 0,
                        rewards: structuredRewards
                    };

                } catch (error) {
                    console.error('Mail collection error:', error);
                    return { success: false, items: 'Error: ' + error.message, count: 0, hasItems: false };
                }
            },
            collectBattlePass: async () => {
                try {
                    debugLog('üé´ Starting Battle Pass (Season Rewards) collection...');

                    const isFarmReward = (reward) => {
                        return !(reward?.buff || reward?.fragmentHero || reward?.bundleHeroReward);
                    };

                    const battlePassProcess = (pass) => {
                        if (!pass.id && !pass.gold) { return [] }

                        let levels;
                        try {
                            if (typeof lib !== 'undefined' && lib.getData) {
                                const bpData = lib.getData('battlePass');
                                if (bpData?.level) {
                                    levels = Object.values(bpData.level).filter(x => x.battlePass == pass.id);
                                }
                            }
                            if (!levels?.length && lib?.data?.battlePass?.level) {
                                levels = Object.values(lib.data.battlePass.level).filter(x => x.battlePass == pass.id);
                            }
                            if (!levels?.length) {
                                debugLog(`No level data for ${pass.gold ? 'gold' : 'special'} pass`);
                                return [];
                            }
                        } catch (e) {
                            console.warn('Error accessing battle pass levels:', e);
                            return [];
                        }

                        const last_level = levels[levels.length - 1];
                        let actual = Math.max(...levels.filter(p => pass.exp >= p.experience).map(p => p.level));

                        if (pass.exp > last_level.experience) {
                            actual = last_level.level + (pass.exp - last_level.experience) / last_level.experienceByLevel;
                        }

                        const calls = [];
                        for (let i = 1; i <= actual; i++) {
                            const level = i >= last_level.level ? last_level : levels.find(l => l.level === i);
                            const reward = { free: level?.freeReward, paid: level?.paidReward };

                            if (!pass.rewards[i]?.free && isFarmReward(reward.free)) {
                                const args = { level: i, free: true };
                                if (!pass.gold) { args.id = pass.id }
                                calls.push({
                                    name: 'battlePass_farmReward',
                                    args,
                                    ident: `${pass.gold ? 'body' : 'spesial'}_free_${args.id || 'gold'}_${i}`
                                });
                            }
                            if (pass.ticket && !pass.rewards[i]?.paid && isFarmReward(reward.paid)) {
                                const args = { level: i, free: false };
                                if (!pass.gold) { args.id = pass.id }
                                calls.push({
                                    name: 'battlePass_farmReward',
                                    args,
                                    ident: `${pass.gold ? 'body' : 'spesial'}_paid_${args.id || 'gold'}_${i}`
                                });
                            }
                        }
                        return calls;
                    };

                    const SendFunction = getSend();

                    // FIRST: Harvest BP quests (they give XP which may unlock more levels)
                    let bpQuestCount = 0;
                    const bpQuestRewards = {};
                    try {
                        const questResp = await SendFunction('{"calls":[{"name":"questGetAll","args":{},"ident":"body"}]}');
                        const allQuests = questResp?.results?.[0]?.result?.response || [];

                        const bpReady = allQuests.filter(q =>
                                                         q.state == 2 &&
                                                         +q.id >= 14e8 &&
                                                         +q.id < 2e9 &&
                                                         q.reward?.battlePassExp
                                                        );

                        if (bpReady.length > 0) {
                            debugLog(`üé´ Harvesting ${bpReady.length} BP quests first (for XP)...`);
                            if (HWHFuncs?.setProgress) {
                                HWHFuncs.setProgress(`üé´ Harvesting ${bpReady.length} BP quests...`, false);
                            }

                            const bpCalls = bpReady.map((q, i) => ({
                                name: 'questFarm',
                                args: { questId: +q.id },
                                ident: `bpq_${i}`
                            }));

                            const bpResult = await SendFunction(JSON.stringify({ calls: bpCalls }));

                            if (bpResult?.results) {
                                bpResult.results.forEach((result, index) => {
                                    if (!result.result?.error && result.result?.response) {
                                        bpQuestCount++;
                                        debugLog(`üé´ BP quest ${bpReady[index].id} harvested:`, result.result.response);

                                        const rewards = window.parseRewardResponse?.(result.result.response) || [];
                                        rewards.forEach(r => {
                                            if (r.name && r.quantity) {
                                                if (!bpQuestRewards[r.name]) bpQuestRewards[r.name] = { amount: 0, source: 'B' };
                                                bpQuestRewards[r.name].amount += r.quantity;
                                            }
                                        });
                                    }
                                });
                            }
                        }
                    } catch (bpQuestError) {
                        console.warn('BP quest harvest error:', bpQuestError);
                    }

                    // THEN: Get fresh BP info (with updated XP from quests)
                    const passResponse = await SendFunction(JSON.stringify({
                        calls: [
                            { name: 'battlePass_getInfo', args: {}, ident: 'getInfo' },
                            { name: 'battlePass_getSpecial', args: {}, ident: 'getSpecial' },
                        ],
                    }));

                    if (!passResponse?.results) {
                        return { success: false, items: 'Could not get Battle Pass info', count: 0, hasItems: false };
                    }

                    const goldPass = passResponse.results[0]?.result?.response?.battlePass;
                    const specialPasses = Object.values(passResponse.results[1]?.result?.response || {});

                    const allPasses = [];
                    if (goldPass) allPasses.push({ ...goldPass, gold: true });
                    allPasses.push(...specialPasses);

                    const calls = allPasses.map(p => battlePassProcess(p)).flat();

                    if (!calls.length) {
                        if (HWHFuncs?.setProgress) HWHFuncs.setProgress('‚úÖ Season Rewards: All already collected', false);
                        return { success: true, items: 'All season rewards already collected', count: 0, hasItems: false };
                    }

                    if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`üé´ Collecting ${calls.length} season rewards...`, false);

                    const results = await SendFunction(JSON.stringify({ calls }));

                    if (results.error) {
                        console.error('Season rewards collection error:', results.error);
                        return { success: false, items: 'Season rewards collection failed', count: 0, hasItems: false };
                    }

                    let freeCollected = 0, paidCollected = 0;
                    const structuredRewards = {};

                    if (results.results) {
                        results.results.forEach((result, index) => {
                            if (!result.result?.error && result.result?.response) {
                                debugLog('üé´ BP reward response:', JSON.stringify(result.result.response));
                                const call = calls[index];
                                call.args.free ? freeCollected++ : paidCollected++;

                                const rewards = window.parseRewardResponse?.(result.result.response) || [];
                                rewards.forEach(r => {
                                    if (r.name && r.quantity) {
                                        const name = r.name;
                                        if (!structuredRewards[name]) structuredRewards[name] = { amount: 0, source: 'B' };
                                        structuredRewards[name].amount += r.quantity;
                                    }
                                });
                            }
                        });
                    }

                    const count = freeCollected + paidCollected;

                    // Merge BP quest rewards into structuredRewards
                    Object.entries(bpQuestRewards).forEach(([name, data]) => {
                        if (!structuredRewards[name]) structuredRewards[name] = { amount: 0, source: 'B' };
                        structuredRewards[name].amount += data.amount;
                    });

                    const totalCount = count + bpQuestCount;
                    const rewardCount = Object.keys(structuredRewards).length;

                    // Refresh local state
                    if (bpQuestCount > 0 && typeof silentSync === 'function') {
                        await silentSync();
                    }

                    if (HWHFuncs?.setProgress) {
                        const questMsg = bpQuestCount > 0 ? `, ${bpQuestCount} quests` : '';
                        HWHFuncs.setProgress(`‚úÖ Season Rewards: ${totalCount} collected (${freeCollected} free, ${paidCollected} premium${questMsg})`, false);
                    }

                    return {
                        success: true,
                        items: rewardCount > 0 ? `${totalCount} items` : `${totalCount} rewards`,
                        count: totalCount,
                        hasItems: rewardCount > 0,
                        rewards: structuredRewards
                    };

                } catch (error) {
                    console.error('Error in collectBattlePass:', error);
                    return { success: false, items: 'Error: ' + error.message, count: 0, hasItems: false };
                }
            },
            buyTitanShopGold: async () => {
                try {
                    debugLog('üî± Buying gold from Titan Soul Shop...');
                    const SendFunction = getSend();

                    // Check for cached inventory
                    const cachedInventory = cheats?.inventory;
                    const needInventory = !cachedInventory || !cachedInventory.coin;

                    const getCalls = needInventory ? [
                        { name: 'shopGetAll', args: {}, ident: 'shops' },
                        { name: 'inventoryGet', args: {}, ident: 'inventory' }
                    ] : [
                        { name: 'shopGetAll', args: {}, ident: 'shops' }
                    ];

                    const result = await SendFunction(JSON.stringify({ calls: getCalls }));
                    const shops = result?.results?.[0]?.result?.response;
                    const inventory = needInventory ? result?.results?.[1]?.result?.response : cachedInventory;

                    if (!shops?.[12]) {
                        return { success: false, items: 'Titan Soul Shop not found', count: 0, hasItems: false };
                    }

                    const titanCoins = inventory?.coin?.[15] || 0;
                    if (titanCoins < 100) {
                        return { success: true, items: 'Not enough Titan Soul Coins', count: 0, hasItems: false };
                    }

                    // Find the 100-coin gold slot
                    const slots = shops[12].slots;
                    let goldSlot = null;
                    let goldSlotId = null;

                    for (const slotId in slots) {
                        const slot = slots[slotId];
                        if (slot.reward?.gold && slot.cost?.coin?.[15] === 100) {
                            goldSlot = slot;
                            goldSlotId = parseInt(slotId);
                            break;
                        }
                    }

                    if (!goldSlot) {
                        return { success: false, items: 'Gold slot not found', count: 0, hasItems: false };
                    }

                    const buyCount = Math.floor(titanCoins / 100);

                    if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`üî± Buying gold ${buyCount}x...`, false);

                    // Single call with amount
                    const buyResult = await SendFunction(JSON.stringify({
                        calls: [{
                            name: 'shopBuy',
                            args: {
                                shopId: 12,
                                slot: goldSlotId,
                                cost: goldSlot.cost,
                                reward: goldSlot.reward,
                                amount: buyCount
                            },
                            ident: 'buy'
                        }]
                    }));

                    const success = !buyResult?.results?.[0]?.result?.error;
                    const totalGold = success ? buyCount * goldSlot.reward.gold : 0;

                    return {
                        success: true,
                        items: totalGold > 0 ? `+${totalGold.toLocaleString()} gold (${buyCount}x)` : 'No gold bought',
                        count: buyCount,
                        hasItems: totalGold > 0,
                        rewards: totalGold > 0 ? { 'ü™ô Gold': { amount: totalGold, source: 'TS' } } : {}
                    };
                } catch (error) {
                    console.error('Titan Shop Gold error:', error);
                    return { success: false, items: 'Error: ' + error.message, count: 0, hasItems: false };
                }
            },

            sellXPPotions: async () => {
                try {
                    debugLog('üß™ Starting XP Potion sale...');
                    const SendFunction = getSend();

                    const keepLargest = parseInt(localStorage.getItem(XP_POTION_KEEP_KEY)) || 484;

                    const XP_POTIONS = [
                        { libId: 9, keep: 0, name: 'Small' },
                        { libId: 10, keep: 0, name: 'Medium' },
                        { libId: 11, keep: 0, name: 'Large' },
                        { libId: 12, keep: keepLargest, name: 'Huge' }
                    ];

                    const invResponse = await SendFunction(JSON.stringify({
                        calls: [{ name: 'inventoryGet', args: {}, ident: 'inventory' }]
                    }));

                    const inventory = invResponse?.results?.[0]?.result?.response;
                    const consumables = inventory?.consumable || {};

                    const sellCalls = [];
                    const potionInfo = [];

                    for (const potion of XP_POTIONS) {
                        const owned = consumables[potion.libId] || 0;
                        const toSell = Math.max(0, owned - potion.keep);

                        if (toSell > 0) {
                            sellCalls.push({
                                name: 'inventorySell',
                                args: { type: 'consumable', libId: potion.libId, amount: toSell, fragment: false },
                                ident: `sell_potion_${potion.libId}`
                            });
                            potionInfo.push({ libId: potion.libId, name: potion.name, amount: toSell });
                            debugLog(`üß™ Will sell ${toSell}x ${potion.name} XP potions`);
                        }
                    }

                    if (!sellCalls.length) {
                        return { success: true, items: 'No XP potions to sell', count: 0, hasItems: false };
                    }

                    if (HWHFuncs?.setProgress) HWHFuncs.setProgress(`üß™ Selling ${sellCalls.length} potion types...`, false);

                    const sellResponse = await SendFunction(JSON.stringify({ calls: sellCalls }));
                    let totalGold = 0;

                    sellResponse?.results?.forEach(r => {
                        if (r?.result?.response?.gold) totalGold += r.result.response.gold;
                    });

                    const totalPotions = potionInfo.reduce((sum, p) => sum + p.amount, 0);

                    return {
                        success: true,
                        items: totalGold > 0 ? `${totalPotions} potions ‚Üí +${totalGold.toLocaleString()} gold` : 'No gold received',
                        count: totalPotions,
                        hasItems: totalGold > 0,
                        rewards: totalGold > 0 ? { 'ü™ô Gold': { amount: totalGold, source: 'XP' } } : {}
                    };
                } catch (error) {
                    console.error('Sell XP Potions error:', error);
                    return { success: false, items: 'Error: ' + error.message, count: 0, hasItems: false };
                }
            },
            autoUseInventory: async () => {
                let wasCountControl = false;
                try {

                    debugLog('üì¶ Starting Auto-Use Inventory Items...');

                    // Get inventory data
                    const data = {
                        calls: [{
                            name: "inventoryGet",
                            args: {},
                            ident: "inventoryGet"
                        }]
                    };

                    const SendFunction = getSend();
                    const response = await SendFunction(JSON.stringify(data));

                    let inventoryData = null;
                    if (response && response.results && response.results[0]) {
                        const result = response.results[0];
                        if (result.result && result.result.response) {
                            inventoryData = result.result.response;
                        }
                    }

                    if (!inventoryData || !inventoryData.consumable) {
                        return {
                            success: false,
                            items: 'Could not access inventory data',
                            count: 0,
                            hasItems: false
                        };
                    }

                    // Load Tab 1 checked items and Tab 2 auto items
                    let tab1CheckedItems = {};
                    let tab2AutoItems = {};
                    try {
                        const saved1 = localStorage.getItem('hwh_inventory_tab1_checked');
                        const saved2Auto = localStorage.getItem('hwh_inventory_tab2_auto');
                        if (saved1) tab1CheckedItems = JSON.parse(saved1);
                        if (saved2Auto) tab2AutoItems = JSON.parse(saved2Auto);
                    } catch (e) {
                        console.warn('Could not load checked items:', e);
                    }

                    // Sell excess fragments using shared helper
                    let fragSellConfig = {};
                    try {
                        const savedFrags = localStorage.getItem('hwh_fragment_sell_settings');
                        if (savedFrags) fragSellConfig = JSON.parse(savedFrags);
                    } catch (e) { console.warn('Could not load fragment settings:', e); }

                    const fragResult = await executeFragmentSells(inventoryData, fragSellConfig, { includeGearScroll: false });
                    const fragSellGold = fragResult.gold || 0;
                    const fragSellCoins = fragResult.coins || {};



                    // Get items to use from Tab 1
                    const consumables = inventoryData.consumable || {};
                    let itemsToUse = Object.keys(tab1CheckedItems).filter(id => consumables[id] > 0);

                    // Add Tab 2 auto items that have choices set (not waiting)
                    const autoSelectedItems = Object.keys(tab2AutoItems).filter(id => {
                        if (!consumables[id] || consumables[id] <= 0) return false;
                        if (itemsToUse.includes(id)) return false; // avoid duplicates
                        const itemData = lib?.data?.inventoryItem?.consumable?.[id];
                        const hasChoice = itemData?.effectDescription?.playerChoice === true;
                        if (hasChoice) {
                            const savedChoice = localStorage.getItem(`hwh_lootbox_choice_${id}`);
                            return savedChoice !== null && savedChoice !== 'wait';
                        }
                        return false;
                    });

                    itemsToUse = [...itemsToUse, ...autoSelectedItems];
                    debugLog(`üì¶ Processing ${itemsToUse.length} items (${Object.keys(tab1CheckedItems).filter(id => consumables[id] > 0).length} auto-use + ${autoSelectedItems.length} auto-selected)`);

                    if (itemsToUse.length === 0) {
                        // Still report fragment sell results even if no consumables to use
                        const fragRewards = {};
                        if (fragSellGold > 0) {
                            fragRewards['ü™ô Gold'] = { amount: fragSellGold, source: 'FS' };
                        }
                        Object.entries(fragSellCoins).forEach(([coinId, amount]) => {
                            const coinName = window.identifyItem?.(coinId, 'coin') || `Coin #${coinId}`;
                            fragRewards[coinName] = { amount, source: 'FS' };
                        });

                        const hasFragResults = fragSellGold > 0 || Object.keys(fragSellCoins).length > 0;
                        return {
                            success: true,
                            items: hasFragResults ? `Sold fragments` : 'No items in Tab 1 list to use',
                            count: hasFragResults ? (fragResult.sellCount || 0) : 0,
                            hasItems: hasFragResults,
                            rewards: fragRewards
                        };
                    }

                    if (HWHFuncs?.setProgress) {
                        HWHFuncs.setProgress(`üì¶ Using ${itemsToUse.length} inventory item types...`, false);
                    }
                    // Save and disable countControl to skip quantity popups
                    wasCountControl = HWHData?.checkboxes?.countControl?.cbox?.checked;
                    if (wasCountControl) {
                        HWHData.checkboxes.countControl.cbox.checked = false;
                    }


                    let successCount = 0;
                    let totalUsed = 0;
                    let iterationCount = 0;
                    const maxIterations = 50;
                    const aggregatedRewards = {};

                    // Process with nesting (same logic as Use All button)
                    while (iterationCount < maxIterations) {
                        iterationCount++;

                        // Refresh inventory
                        const refreshResponse = await SendFunction(JSON.stringify(data));
                        if (refreshResponse && refreshResponse.results && refreshResponse.results[0]) {
                            const result = refreshResponse.results[0];
                            if (result.result && result.result.response) {
                                inventoryData = result.result.response;
                            }
                        }

                        const currentConsumables = inventoryData.consumable || {};
                        // Get current items including auto-selected
                        let currentItemsToUse = Object.keys(tab1CheckedItems).filter(id => currentConsumables[id] > 0);

                        // Add auto-selected items with choices set
                        const currentAutoSelected = Object.keys(tab2AutoItems).filter(id => {
                            if (!currentConsumables[id] || currentConsumables[id] <= 0) return false;
                            if (currentItemsToUse.includes(id)) return false;
                            const itemData = lib?.data?.inventoryItem?.consumable?.[id];
                            const hasChoice = itemData?.effectDescription?.playerChoice === true;
                            if (hasChoice) {
                                const savedChoice = localStorage.getItem(`hwh_lootbox_choice_${id}`);
                                return savedChoice !== null && savedChoice !== 'wait';
                            }
                            return false;
                        });

                        currentItemsToUse = [...currentItemsToUse, ...currentAutoSelected];
                        if (currentItemsToUse.length === 0) {
                            break;
                        }

                        // Process each item
                        for (const itemId of currentItemsToUse) {
                            const quantity = currentConsumables[itemId];
                            if (!quantity || quantity <= 0) continue;

                            try {
                                // Check for choice items
                                const itemData = lib?.data?.inventoryItem?.consumable?.[itemId];
                                const hasChoice = itemData?.effectDescription?.playerChoice === true;
                                const savedChoice = localStorage.getItem(`hwh_lootbox_choice_${itemId}`);

                                // Skip choice items that are waiting
                                if (hasChoice && (savedChoice === 'wait' || savedChoice === null)) {
                                    debugLog(`‚è∏Ô∏è Skipping ${itemId} (waiting for choice)`);
                                    continue;
                                }

                                const choiceIdx = hasChoice ? (parseInt(savedChoice) || 0) : 0;
                                const savedQty = localStorage.getItem(`hwh_lootbox_qty_${itemId}`);
                                const useQuantity = hasChoice && savedQty ? Math.min(parseInt(savedQty) || quantity, quantity) : quantity;

                                const useData = {
                                    calls: [{
                                        name: "consumableUseLootBox",
                                        args: {
                                            libId: parseInt(itemId),
                                            amount: useQuantity,
                                            playerRewardChoiceIndex: choiceIdx
                                        },
                                        context: {
                                            actionTs: Math.floor(performance.now())
                                        },
                                        ident: "body"
                                    }]
                                };

                                const useResponse = await SendFunction(JSON.stringify(useData));

                                // Track rewards
                                if (useResponse && useResponse.results && useResponse.results[0]) {
                                    const result = useResponse.results[0];
                                    if (result.result && result.result.response) {
                                        debugLog('üì¶ Inventory use response:', JSON.stringify(result.result.response));
                                        const rewards = result.result.response;
                                        // Aggregate rewards
                                        for (const [key, value] of Object.entries(rewards)) {
                                            if (key === 'quests') continue;

                                            // Handle direct number values (gold, starmoney, etc.)
                                            if (typeof value === 'number') {
                                                let displayName;
                                                if (key === 'gold') {
                                                    displayName = 'ü™ô Gold';
                                                } else if (key === 'starmoney') {
                                                    displayName = 'üíé Emeralds';
                                                } else if (key === 'energy') {
                                                    displayName = '‚ö° Energy';
                                                } else {
                                                    displayName = window.itemNameCache?.currency?.[key] || key;
                                                }
                                                aggregatedRewards[displayName] = (aggregatedRewards[displayName] || 0) + value;
                                                continue;
                                            }

                                            // Handle object values
                                            if (typeof value === 'object') {
                                                // Check if key is a loot box ID (numeric) - response is {lootboxId: {rewards}}
                                                if (/^\d+$/.test(key)) {
                                                    for (const [rewardType, rewardData] of Object.entries(value)) {
                                                        if (rewardType === 'gold' && typeof rewardData === 'number') {
                                                            aggregatedRewards['ü™ô Gold'] = (aggregatedRewards['ü™ô Gold'] || 0) + rewardData;
                                                        } else if ((rewardType === 'starmoney' || rewardType === 'starmoneyPayed') && typeof rewardData === 'number') {
                                                            aggregatedRewards['üíé Emeralds'] = (aggregatedRewards['üíé Emeralds'] || 0) + rewardData;
                                                        } else if (rewardType === 'energy' && typeof rewardData === 'number') {
                                                            aggregatedRewards['‚ö° Energy'] = (aggregatedRewards['‚ö° Energy'] || 0) + rewardData;
                                                        } else if (rewardType === 'coin' && typeof rewardData === 'object') {
                                                            for (const [coinId, coinAmt] of Object.entries(rewardData)) {
                                                                const coinName = window.identifyItem?.(coinId, 'coin') || `Coin #${coinId}`;
                                                                aggregatedRewards[`üí∞ ${coinName}`] = (aggregatedRewards[`üí∞ ${coinName}`] || 0) + parseInt(coinAmt);
                                                            }
                                                        } else if (typeof rewardData === 'object') {
                                                            for (const [itemId, qty] of Object.entries(rewardData)) {
                                                                let name = '';
                                                                if (rewardType === 'consumable') name = 'üì¶ ' + (window.identifyItem?.(itemId, 'consumable') || `Item #${itemId}`);
                                                                else if (rewardType === 'fragmentHero') name = 'üë§ ' + (window.identifyItem?.(itemId, 'hero') || `Hero #${itemId}`) + ' (SS)';
                                                                else if (rewardType === 'fragmentTitan') name = '‚ö° ' + (window.identifyItem?.(itemId, 'titan') || `Titan #${itemId}`) + ' (SS)';
                                                                else if (rewardType === 'fragmentGear') name = 'üîß ' + (window.identifyItem?.(itemId, 'gear') || `Gear #${itemId}`) + ' (Frag)';
                                                                else if (rewardType === 'fragmentScroll') name = 'üìú ' + (window.identifyItem?.(itemId, 'scroll') || `Scroll #${itemId}`) + ' (Frag)';
                                                                else if (rewardType === 'gear') name = '‚öôÔ∏è ' + (window.identifyItem?.(itemId, 'gear') || `Gear #${itemId}`);
                                                                else if (rewardType === 'scroll') name = 'üìú ' + (window.identifyItem?.(itemId, 'scroll') || `Scroll #${itemId}`);
                                                                else if (rewardType === 'ascensionGear') name = 'üíç ' + (window.identifyItem?.(itemId, 'ascensionGear') || `Asc Crystal #${itemId}`);
                                                                else name = window.identifyItem?.(itemId, rewardType) || `${rewardType} #${itemId}`;
                                                                aggregatedRewards[name] = (aggregatedRewards[name] || 0) + parseInt(qty);
                                                            }
                                                        }
                                                    }
                                                    continue;
                                                }

                                                // coin: {id: amount} - direct ID to amount mapping
                                                if (key === 'coin') {
                                                    for (const [coinId, amount] of Object.entries(value)) {
                                                        const coinName = window.identifyItem?.(coinId, 'coin') || `Coin #${coinId}`;
                                                        aggregatedRewards[`üí∞ ${coinName}`] = (aggregatedRewards[`üí∞ ${coinName}`] || 0) + parseInt(amount);
                                                    }
                                                    continue;
                                                }

                                                // Other type: {id: amount} direct mapping
                                                for (const [itemId, itemValue] of Object.entries(value)) {
                                                    if (typeof itemValue === 'number') {
                                                        let name = '';
                                                        if (key === 'consumable') name = 'üì¶ ' + (window.identifyItem?.(itemId, 'consumable') || `Item #${itemId}`);
                                                        else if (key === 'fragmentHero') name = 'üë§ ' + (window.identifyItem?.(itemId, 'hero') || `Hero #${itemId}`) + ' (SS)';
                                                        else if (key === 'fragmentTitan') name = '‚ö° ' + (window.identifyItem?.(itemId, 'titan') || `Titan #${itemId}`) + ' (SS)';
                                                        else if (key === 'fragmentGear') name = 'üîß ' + (window.identifyItem?.(itemId, 'gear') || `Gear #${itemId}`) + ' (Frag)';
                                                        else if (key === 'fragmentScroll') name = 'üìú ' + (window.identifyItem?.(itemId, 'scroll') || `Scroll #${itemId}`) + ' (Frag)';
                                                        else if (key === 'fragmentPet') name = 'üêæ ' + (window.identifyItem?.(itemId, 'pet') || `Pet #${itemId}`) + ' (SS)';
                                                        else if (key === 'gear') name = '‚öôÔ∏è ' + (window.identifyItem?.(itemId, 'gear') || `Gear #${itemId}`);
                                                        else if (key === 'scroll') name = 'üìú ' + (window.identifyItem?.(itemId, 'scroll') || `Scroll #${itemId}`);
                                                        else if (key === 'ascensionGear') name = 'üíç ' + (window.identifyItem?.(itemId, 'ascensionGear') || `Asc Crystal #${itemId}`);
                                                        else name = window.identifyItem?.(itemId, key) || `${key} #${itemId}`;
                                                        aggregatedRewards[name] = (aggregatedRewards[name] || 0) + itemValue;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                successCount++;
                                totalUsed += quantity;
                                // Small delay between items
                                await new Promise(resolve => setTimeout(resolve, 50));

                            } catch (e) {
                                console.error(`Failed to use item ${itemId}:`, e);
                            }
                        }

                        // Small delay between rounds
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    // Add fragment sell rewards to aggregated rewards
                    if (fragSellGold > 0) {
                        aaggregatedRewards['ü™ô Gold'] = (aggregatedRewards['ü™ô Gold'] || 0) + fragSellGold;
                    }
                    if (Object.keys(fragSellCoins).length > 0) {
                        Object.entries(fragSellCoins).forEach(([coinId, amount]) => {
                            if (amount > 0) {
                                const coinName = window.identifyItem?.(coinId, 'coin') || `Coin #${coinId}`;
                                aggregatedRewards[`üí∞ ${coinName}`] = (aggregatedRewards[`üí∞ ${coinName}`] || 0) + amount;
                            }
                        });
                    }


                    const rewardCount = Object.keys(aggregatedRewards).length;
                    // Convert to structured format
                    const structuredRewards = {};
                    for (const [name, amount] of Object.entries(aggregatedRewards)) {
                        structuredRewards[name] = { amount, source: 'I' };
                    }
                    // Restore countControl
                    if (wasCountControl && HWHData?.checkboxes?.countControl?.cbox) {
                        HWHData.checkboxes.countControl.cbox.checked = true;
                    }
                    return {
                        success: true,
                        items: rewardCount > 0 ? `${totalUsed} items` : 'No items to use',
                        count: totalUsed,
                        hasItems: rewardCount > 0,
                        rewards: structuredRewards
                    };

                } catch (error) {
                    console.error('Error in inventory auto-use:', error);
                    // Restore countControl on error too
                    if (wasCountControl && HWHData?.checkboxes?.countControl?.cbox) {
                        HWHData.checkboxes.countControl.cbox.checked = true;
                    }
                    return {
                        success: false,
                        items: `Error: ${error.message}`,
                        count: 0,
                        hasItems: false
                    };
                }
            },

            // Sell excess gear/scroll items and frags based on Tab 6 targets
            sellCraftExcess: async () => {
                try {
                    debugLog('‚öôÔ∏è Starting Sell Craft Excess (Tab 6)...');

                    const SendFunction = getSend();
                    const response = await SendFunction(JSON.stringify({calls:[{name:'inventoryGet',args:{},ident:'inv'}]}));
                    const inv = response?.results?.[0]?.result?.response;
                    if (!inv) return { success: false, items: 'Could not get inventory', count: 0, hasItems: false };

                    const fragData = { gear: inv.fragmentGear || {}, scroll: inv.fragmentScroll || {} };
                    const builtData = { gear: inv.gear || {}, scroll: inv.scroll || {} };

                    // Load craft targets
                    let targets = {};
                    try {
                        const saved = localStorage.getItem('hwh_craft_targets');
                        if (saved) targets = JSON.parse(saved);
                    } catch (e) { console.warn('Could not load craft targets:', e); }

                    const toSellFrags = [];
                    const toSellItems = [];

                    ['gear', 'scroll'].forEach(type => {
                        // Excess fragments
                        Object.keys(fragData[type]).forEach(id => {
                            const mergeCost = lib.data?.inventoryItem?.[type]?.[id]?.fragmentMergeCost;
                            if (mergeCost?.fragmentCount) {
                                const k = `${type}_${id}`;
                                const fragCount = fragData[type][id] || 0;
                                const builtCount = builtData[type][id] || 0;
                                const needed = mergeCost.fragmentCount;
                                const target = targets[k];
                                if (target !== undefined) {
                                    const fragsNeededForTarget = Math.max(0, (target - builtCount) * needed);
                                    const excess = fragCount - fragsNeededForTarget;
                                    if (excess > 0) {
                                        toSellFrags.push({ type: `fragment${type.charAt(0).toUpperCase() + type.slice(1)}`, id: parseInt(id), amount: excess, name: window.identifyItem?.(id, type) || id });
                                    }
                                }
                            }
                        });

                        // Excess built items
                        Object.keys(builtData[type]).forEach(id => {
                            const k = `${type}_${id}`;
                            const builtCount = builtData[type][id] || 0;
                            const target = targets[k];
                            if (target !== undefined && builtCount > target) {
                                const excess = builtCount - target;
                                toSellItems.push({ type, id: parseInt(id), amount: excess, name: window.identifyItem?.(id, type) || id });
                            }
                        });
                    });

                    if (toSellFrags.length === 0 && toSellItems.length === 0) {
                        return { success: true, items: 'No excess to sell', count: 0, hasItems: false };
                    }

                    // Update progress
                    if (HWHFuncs?.setProgress) {
                        HWHFuncs.setProgress(`‚öôÔ∏è Selling ${toSellFrags.length + toSellItems.length} excess types...`, false);
                    }

                    let totalGold = 0;
                    let soldCount = 0;
                    const coinRewards = {};

                    // Sell fragments
                    for (const item of toSellFrags) {
                        try {
                            const resp = await SendFunction(JSON.stringify({calls:[{name:'inventorySell',args:{type:item.type,libId:item.id,amount:item.amount},ident:'sell'}]}));
                            const r = resp?.results?.[0]?.result?.response;
                            if (r?.gold) totalGold += r.gold;
                            if (r?.coin) {
                                Object.entries(r.coin).forEach(([coinId, amt]) => {
                                    coinRewards[coinId] = (coinRewards[coinId] || 0) + amt;
                                });
                            }
                            soldCount++;
                            debugLog(`  Sold ${item.amount} ${item.name} frags`);
                            await new Promise(r => setTimeout(r, 50));
                        } catch (e) { console.error('Sell frag failed:', item, e); }
                    }

                    // Sell built items
                    for (const item of toSellItems) {
                        try {
                            const resp = await SendFunction(JSON.stringify({calls:[{name:'inventorySell',args:{type:item.type,libId:item.id,amount:item.amount},ident:'sell'}]}));
                            const r = resp?.results?.[0]?.result?.response;
                            if (r?.gold) totalGold += r.gold;
                            if (r?.coin) {
                                Object.entries(r.coin).forEach(([coinId, amt]) => {
                                    coinRewards[coinId] = (coinRewards[coinId] || 0) + amt;
                                });
                            }
                            soldCount++;
                            debugLog(`  Sold ${item.amount} ${item.name}`);
                            await new Promise(r => setTimeout(r, 50));
                        } catch (e) { console.error('Sell item failed:', item, e); }
                    }

                    // Build rewards object
                    const rewards = {};
                    if (totalGold > 0) {
                        rewards['ü™ô Gold'] = { amount: totalGold, source: 'Craft' };
                    }
                    Object.entries(coinRewards).forEach(([coinId, amount]) => {
                        if (amount > 0) {
                            const coinName = window.identifyItem?.(coinId, 'coin') || `Coin #${coinId}`;
                            rewards[`üí∞ ${coinName}`] = { amount, source: 'Craft' };
                        }
                    });

                    return {
                        success: true,
                        items: `${toSellFrags.length} frag types, ${toSellItems.length} item types ‚Üí ${totalGold.toLocaleString()} gold`,
                        count: soldCount,
                        hasItems: Object.keys(rewards).length > 0,
                        rewards
                    };
                } catch (error) {
                    console.error('Sell Craft Excess error:', error);
                    return { success: false, items: 'Error: ' + error.message, count: 0, hasItems: false };
                }
            },

            // HWH Do All - Fixed for 2.403 button structure
            // HWH Do All - Updated for 2.411 button structure
            doAllHWH: async () => {
                if (typeof HWHFuncs === 'undefined') {
                    throw new Error('HWH system not available - ensure HWH main script is loaded');
                }

                try {
                    debugLog('Triggering HWH Do All popup...');

                    // Find Do All button - works with 2.376, 2.403, and 2.411
                    const doAllButton =
                          DOMCache.getAll('scriptBtnPlates', '.scriptMenu_btnPlate').find(el =>
                                                                                          el.textContent?.trim() === 'Do All'
                                                                                         )?.parentElement || // 2.403+: text in btnPlate, click parent btnGap
                          Array.from(document.querySelectorAll('.scriptMenu_button, .scriptMenu_btnGap')).find(el =>
                                                                                                               el.textContent?.trim() === 'Do All'
                                                                                                              ); // 2.376: text directly in button

                    if (!doAllButton) {
                        throw new Error('Do All button not found');
                    }

                    // Click the Do All button to open popup
                    doAllButton.click();

                    // Wait for popup to appear
                    await new Promise(resolve => setTimeout(resolve, 800));

                    // Find and click Go! button - Updated for 2.411 structure
                    const tryClickGo = () => {
                        // Method 1: New 2.411 structure - find PopUp_btnPlate with "Go!" text, then click parent PopUp_btnGap
                        const btnPlates = DOMCache.getAll('popupBtnPlates', '.PopUp_btnPlate').filter(el =>
                                                                                                      el.textContent?.trim() === 'Go!' && el.offsetParent !== null
                                                                                                     );

                        if (btnPlates.length > 0) {
                            debugLog(`Found ${btnPlates.length} PopUp_btnPlate with "Go!" text`);
                            btnPlates.forEach((btnPlate, i) => {
                                const btnGap = btnPlate.parentElement;
                                if (btnGap && btnGap.classList.contains('PopUp_btnGap')) {
                                    debugLog(`Clicking PopUp_btnGap parent ${i + 1}...`);
                                    btnGap.click();
                                }
                            });
                            return;
                        }

                        // Method 2: Fallback for older versions - direct button search
                        const goButtons = DOMCache.getAll('popupGoButtons', '.PopUp_button, .scriptMenu_btnGap, .scriptMenu_button').filter(el =>
                                                                                                                                            el.textContent?.trim() === 'Go!' && el.offsetParent !== null
                                                                                                                                           );

                        debugLog(`Found ${goButtons.length} direct Go! buttons (fallback method)`);

                        goButtons.forEach((btn, i) => {
                            debugLog(`Clicking Go! button ${i + 1}...`);
                            btn.click();
                        });
                    };

                    // Try multiple times with delays
                    tryClickGo();
                    setTimeout(tryClickGo, 500);
                    setTimeout(tryClickGo, 1000);

                    // Wait for Do All to complete and close any sync popup
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    await closeSyncPopup(500);

                    debugLog('HWH Do All executed successfully');
                    return Promise.resolve();

                } catch (error) {
                    console.error('Error in HWH Do All execution:', error);
                    throw error;
                }
            },

            // Sync game data (runs last)
            syncGameData: async () => {
                try {
                    const success = await silentSync();
                    return {
                        success: success,
                        items: success ? 'Game data synchronized' : 'Sync failed',
                        count: 0,
                        hasItems: false
                    };
                } catch (error) {
                    console.error('Sync error:', error);
                    return {
                        success: false,
                        items: `Error: ${error.message}`,
                        count: 0,
                        hasItems: false
                    };
                }
            }
        };
    }
    // Helper to get current currency values
    async function getCurrentCurrencies() {
        try {
            const SendFunction = getSend();
            const response = await SendFunction(JSON.stringify({
                calls: [
                    { name: 'userGetInfo', args: {}, ident: 'user' },
                    { name: 'inventoryGet', args: {}, ident: 'inv' }
                ]
            }));

            const userInfo = response?.results?.[0]?.result?.response;
            const inventory = response?.results?.[1]?.result?.response;

            return {
                gold: userInfo?.gold || 0,
                emeralds: userInfo?.starMoney || 0,
                soulCoins: inventory?.coin?.[5] || 0
            };
        } catch (e) {
            console.warn('Could not get currencies:', e);
            return { gold: 0, emeralds: 0, soulCoins: 0 };
        }
    }

    // Main Collect More function - Exposed globally
    // IMPROVED POPUP VERSION with modern UI
    window.runCollectMore = async function() {
        debugLog('üéØ Running Collect More...');

        // Task definitions with icons and descriptions
        const taskDefinitions = {
            doAllHWH: {
                icon: '‚ö°',
                label: 'HWH Do All',
                desc: 'Runs tower, expeditions, arena, etc. Generates rewards to collect.',
                group: 'pre',
                default: false,
                disabled: !checkFunctionAvailability('doAllHWH', 'doAllHWH')
            },
            collectMail: {
                icon: 'üì¨',
                label: 'Collect Mail',
                desc: 'Collect mail (skips energy, portal, hero souls)',
                group: 'collect',
                default: false,
                disabled: false
            },
            collectSoulShop: {
                icon: 'üëª',
                label: 'Soul Shop',
                desc: 'Buy all items from the Soul Shop',
                group: 'collect',
                default: true,
                disabled: false
            },
            buyShopsWithPriority: {
                icon: 'üè™',
                label: 'Buy Shops (Priority)',
                desc: 'Buy gear/scrolls from Arena, Grand, Tower, Friendship, Outland - by craft target priority',
                group: 'collect',
                default: false,
                disabled: false
            },
            collectGuildRewards: {
                icon: 'üè∞',
                label: 'Guild Rewards',
                desc: 'Collect guild quests and daily rewards',
                group: 'collect',
                default: true,
                disabled: false
            },
            collectClanPrestige: {
                icon: 'üÖ∞',
                label: 'Clan Prestige',
                desc: 'Collect 5 levels of prestige rewards',
                group: 'collect',
                default: false,
                disabled: false
            },
            collectBattlePass: {
                icon: 'üé´',
                label: 'Battle Pass',
                desc: 'Collect silver and gold battle pass rewards',
                group: 'collect',
                default: false,
                disabled: false
            },
            autoUseInventory: {
                icon: 'üì¶',
                label: 'Use Inventory + Sell Frags',
                desc: 'Auto-use checked items from Inventory Tab 1',
                group: 'collect',
                default: false,
                disabled: false
            },
            buyTitanShopGold: {
                icon: 'üî±',
                label: 'Sell Titan Soul Coins ‚Üí Gold',
                desc: 'Buy gold from Titan Soul Shop',
                group: 'collect',
                default: false,
                disabled: false
            },
            // === REMAINING CONVERSIONS LAST ===
            sellXPPotions: {
                icon: 'üß™',
                label: 'Sell XP Potions ‚Üí Gold',
                desc: `Sell excess XP potions (keeps ${localStorage.getItem(XP_POTION_KEEP_KEY) || 484} Huge)`,
                group: 'collect',
                default: false,
                disabled: false
            },
            sellCraftExcess: {
                icon: '‚öôÔ∏è',
                label: 'Sell Excess Gear/Scrolls',
                desc: 'Sell gear & scroll frags/items above Tab 6 targets',
                group: 'collect',
                default: false,
                disabled: false
            },
            syncGameData: {
                icon: 'üîÑ',
                label: 'Sync Data',
                desc: 'Refresh game data without reloading page',
                group: 'post',
                default: true,
                disabled: !(typeof cheats !== 'undefined' && cheats.refreshGame)
            }
        };

        // Load saved preferences
        let savedPrefs = {};
        try {
            const saved = localStorage.getItem('hwh_collect_more_prefs');
            if (saved) savedPrefs = JSON.parse(saved);
        } catch (e) {
            console.warn('Could not load Collect More preferences:', e);
        }

        // Build task list with saved state
        const tasks = Object.entries(taskDefinitions).map(([name, def]) => ({
            name,
            ...def,
            checked: savedPrefs[name] !== undefined ? savedPrefs[name] : def.default
        }));

        // Show custom popup
        const result = await showCollectMorePopup(tasks);

        if (!result) {
            debugLog('Collect More cancelled');
            return;
        }

        const { selectedTasks, showSummary } = result;

        // Save preferences
        selectedTasks.forEach(task => {
            if (!task.disabled) savedPrefs[task.name] = task.checked;
        });
        try {
            localStorage.setItem('hwh_collect_more_prefs', JSON.stringify(savedPrefs));
        } catch (e) {}

        // Execute tasks
        await executeCollectMoreTasks(selectedTasks, showSummary);
    };

    // Custom popup for Collect More
    async function showCollectMorePopup(tasks) {
        // Get currencies BEFORE the Promise
        const currencies = await getCurrentCurrencies();
        const formatNum = n => n >= 1000000 ? (n/1000000).toFixed(1) + 'M' : n >= 1000 ? (n/1000).toFixed(1) + 'K' : n.toLocaleString();

        return new Promise((resolve) => {
            // Remove existing popup
            const existing = document.getElementById('collect-more-popup');
            if (existing) existing.remove();

            const popup = document.createElement('div');
            popup.id = 'collect-more-popup';

            // Group tasks
            const preTasks = tasks.filter(t => t.group === 'pre');
            const collectTasks = tasks.filter(t => t.group === 'collect');
            const postTasks = tasks.filter(t => t.group === 'post');

            // Count enabled/checked
            const enabledCount = tasks.filter(t => !t.disabled).length;
            const checkedCount = tasks.filter(t => t.checked && !t.disabled).length;

            popup.innerHTML = `
                <div class="cm-overlay">
                    <div class="cm-modal">
                        <div class="cm-header">
                            <span class="cm-title">üì¶ Collect More</span>
                            <span class="cm-subtitle">${checkedCount}/${enabledCount} selected</span>
                        </div>
                        <div class="cm-currencies">
                            <span class="cm-currency" title="Gold">ü™ô ${formatNum(currencies.gold)}</span>
                            <span class="cm-currency" title="Emeralds">üíé ${formatNum(currencies.emeralds)}</span>
                            <span class="cm-currency" title="Soul Coins">üëª ${formatNum(currencies.soulCoins)}</span>
                        </div>
                        <div class="cm-body">
${preTasks.length ? `
<div class="cm-section">
                                <div class="cm-section-header">
                                    <span class="cm-section-icon">‚ñ∂Ô∏è</span>
                                    <span>Pre-Collection</span>
                                </div>
                                <div class="cm-tasks">
                                    ${preTasks.map(t => createTaskRow(t)).join('')}
                                </div>
                            </div>
                            ` : ''}

                                <div class="cm-section">
                                    <div class="cm-section-header">
                                        <span class="cm-section-icon">üì•</span>
                                <span>Collection Tasks</span>
                                <div class="cm-section-actions">
                                    <button class="cm-link-btn" data-action="select-all" data-group="collect">All</button>
                                <button class="cm-link-btn" data-action="select-none" data-group="collect">None</button>
                                </div>
                                </div>
                                <div class="cm-tasks">
                                    ${collectTasks.map(t => createTaskRow(t)).join('')}
                                </div>
                                </div>

                                ${postTasks.length ? `
                            <div class="cm-section">
                                <div class="cm-section-header">
                                    <span class="cm-section-icon">‚ú®</span>
                                    <span>Post-Collection</span>
                                </div>
                                <div class="cm-tasks">
                                    ${postTasks.map(t => createTaskRow(t)).join('')}
                                </div>
                            </div>
                            ` : ''}
                                </div>

                                <div class="cm-footer">
                                    <button class="cm-btn cm-btn-cancel" data-action="cancel">Cancel</button>
                                <button class="cm-btn cm-btn-primary" data-action="run">‚ñ∂Ô∏è Run</button>
                                </div>
                                </div>
                                </div>
                                `;

            // Add styles - COMPACT VERSION
            const style = document.createElement('style');
            style.textContent = `
                .cm-overlay {
                    position: fixed;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.7);
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-family: Arial, sans-serif;
                }
                                .cm-modal {
                                    background: linear-gradient(180deg, #3d2817 0%, #2a1810 100%);
                                    border: 3px solid #8b6914;
                                    border-radius: 10px;
                                    width: 340px;
                                    display: flex;
                                    flex-direction: column;
                                    box-shadow: 0 8px 30px rgba(0,0,0,0.5);
                                }
                                .cm-header {
                                    padding: 10px 14px;
                                    border-bottom: 2px solid #8b6914;
                                    display: flex;
                                    justify-content: space-between;
                                    align-items: center;
                                }
                                .cm-title {
                                    font-size: 14px;
                                    font-weight: bold;
                                    color: #ffd700;
                                }
                                .cm-subtitle {
                                    font-size: 10px;
                                    color: #999;
                                    background: rgba(0,0,0,0.3);
                                    padding: 2px 7px;
                                    border-radius: 8px;
}
                                .cm-currencies {
                                    display: flex;
                                    justify-content: space-around;
                                    padding: 6px 10px;
                                    background: rgba(0,0,0,0.3);
                                    border-bottom: 1px solid #5a4a2a;
                                    font-size: 11px;
                                }
                                .cm-currency {
                                    color: #ffd700;
                                    padding: 2px 8px;
                                    background: rgba(139,105,20,0.2);
                                    border-radius: 4px;
                                }
                                .cm-body {
                                    padding: 8px 10px;
                                }
                                .cm-section {
                                    margin-bottom: 6px;
                                }
                                .cm-section:last-child {
                                    margin-bottom: 0;
                                }
                                .cm-section-header {
                                    display: flex;
                                    align-items: center;
                                    gap: 5px;
                                    padding: 4px 8px;
                                    background: rgba(139,105,20,0.3);
                                    border-radius: 4px;
                                    margin-bottom: 4px;
                                    font-size: 11px;
                                    font-weight: bold;
                                    color: #ffd700;
                                }
                                .cm-section-icon {
                                    font-size: 11px;
                                }
                                .cm-section-actions {
                                    margin-left: auto;
                                    display: flex;
                                    gap: 6px;
                                }
                                .cm-link-btn {
                                    background: none;
                                    border: none;
                                    color: #4ae29a;
                                    cursor: pointer;
                                    font-size: 10px;
                                    padding: 1px 4px;
                                    border-radius: 2px;
                                    transition: background 0.2s;
                                }
                                .cm-link-btn:hover {
                                    background: rgba(74,226,154,0.2);
                                }
                                .cm-tasks {
                                    display: flex;
                                    flex-direction: column;
                                    gap: 2px;
                                }
                                .cm-task {
                                    display: flex;
                                    align-items: center;
                                    gap: 6px;
                                    padding: 5px 8px;
                                    background: rgba(0,0,0,0.2);
                                    border-radius: 4px;
                                    cursor: pointer;
                                    transition: all 0.15s;
                                    border: 1px solid transparent;
                                }
                                .cm-task:hover:not(.cm-task-disabled) {
                                    background: rgba(139,105,20,0.2);
                                    border-color: rgba(139,105,20,0.5);
                                }
                                .cm-task.cm-task-checked {
                                    background: rgba(74,226,154,0.1);
                                    border-color: rgba(74,226,154,0.3);
                                }
                                .cm-task.cm-task-disabled {
                                    opacity: 0.4;
                                    cursor: not-allowed;
                                }
                                .cm-task-checkbox {
                                    width: 14px;
                                    height: 14px;
                                    border: 2px solid #8b6914;
                                    border-radius: 3px;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    flex-shrink: 0;
                                    background: rgba(0,0,0,0.3);
                                    transition: all 0.15s;
                                }
                                .cm-task-checked .cm-task-checkbox {
                                    background: #4ae29a;
                                    border-color: #4ae29a;
                                }
                                .cm-task-checkbox::after {
                                    content: '‚úì';
                                    color: #1a1a1a;
                                    font-size: 10px;
                                    font-weight: bold;
                                    opacity: 0;
                                    transition: opacity 0.15s;
                                }
                                .cm-task-checked .cm-task-checkbox::after {
                                    opacity: 1;
                                }
                                .cm-task-icon {
                                    font-size: 14px;
                                    width: 18px;
                                    text-align: center;
                                }
                                .cm-task-info {
                                    flex: 1;
                                    min-width: 0;
                                }
                                .cm-task-label {
                                    font-size: 11px;
                                    font-weight: 600;
                                    color: #ffd700;
                                }
                                .cm-task-desc {
                                    display: none;
                                }
                                .cm-footer {
                                    padding: 10px 12px;
                                    border-top: 2px solid #8b6914;
                                    display: flex;
                                    justify-content: space-between;
                                    align-items: center;
                                    gap: 8px;
                                }

                                .cm-btn {
                                    padding: 7px 12px;
                                    border: none;
                                    border-radius: 5px;
                                    cursor: pointer;
                                    font-size: 11px;
                                    font-weight: bold;
                                    transition: all 0.15s;
                                }
                                .cm-btn-cancel {
                                    background: rgba(255,255,255,0.1);
                                    color: #ccc;
                                }
                                .cm-btn-cancel:hover {
                                    background: rgba(255,255,255,0.2);
                                }

                                .cm-btn-primary {
                                    background: linear-gradient(180deg, #4ae29a 0%, #2ecc71 100%);
                                    color: #1a1a1a;
                                }
                                .cm-btn-primary:hover {
                                    transform: translateY(-1px);
                                    box-shadow: 0 3px 10px rgba(74,226,154,0.4);
                                }
                                `;
            popup.appendChild(style);

            function createTaskRow(task) {
                const checkedClass = task.checked ? 'cm-task-checked' : '';
                const disabledClass = task.disabled ? 'cm-task-disabled' : '';
                return `
                    <div class="cm-task ${checkedClass} ${disabledClass}" data-task="${task.name}">
                        <div class="cm-task-checkbox"></div>
                        <div class="cm-task-icon">${task.icon}</div>
                        <div class="cm-task-info">
                            <div class="cm-task-label">${task.label}</div>
                            <div class="cm-task-desc">${task.desc}</div>
                        </div>
                    </div>
                `;
            }

            function updateSubtitle() {
                const checked = popup.querySelectorAll('.cm-task-checked:not(.cm-task-disabled)').length;
                const enabled = popup.querySelectorAll('.cm-task:not(.cm-task-disabled)').length;
                popup.querySelector('.cm-subtitle').textContent = `${checked}/${enabled} selected`;
            }

            // Event handlers
            popup.addEventListener('click', (e) => {
                // Task toggle
                const taskRow = e.target.closest('.cm-task:not(.cm-task-disabled)');
                if (taskRow) {
                    const taskName = taskRow.dataset.task;
                    const task = tasks.find(t => t.name === taskName);
                    if (!task) return;

                    const willBeChecked = !taskRow.classList.contains('cm-task-checked');

                    // Handle mutual exclusivity
                    if (willBeChecked && task.exclusive) {
                        tasks.forEach(t => {
                            if (t.name !== taskName && t.exclusive === task.exclusive && t.checked) {
                                t.checked = false;
                                const otherRow = popup.querySelector(`.cm-task[data-task="${t.name}"]`);
                                if (otherRow) otherRow.classList.remove('cm-task-checked');
                            }
                        });
                    }

                    taskRow.classList.toggle('cm-task-checked');
                    task.checked = willBeChecked;
                    updateSubtitle();
                    return;
                }

                // Action buttons
                const action = e.target.dataset.action;
                if (action === 'cancel') {
                    popup.remove();
                    resolve(null);
                } else if (action === 'run') {
                    popup.remove();
                    resolve({
                        selectedTasks: tasks,
                        showSummary: true  // Always show summary
                    });
                } else if (action === 'select-all' || action === 'select-none') {
                    const group = e.target.dataset.group;
                    const checked = action === 'select-all';
                    popup.querySelectorAll(`.cm-task[data-task]`).forEach(row => {
                        const task = tasks.find(t => t.name === row.dataset.task);
                        if (task && task.group === group && !task.disabled) {
                            task.checked = checked;
                            row.classList.toggle('cm-task-checked', checked);
                        }
                    });
                    updateSubtitle();
                }
            });

            // Close on overlay click
            popup.querySelector('.cm-overlay').addEventListener('click', (e) => {
                if (e.target === e.currentTarget) {
                    popup.remove();
                    resolve(null);
                }
            });

            // ESC to close
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    popup.remove();
                    document.removeEventListener('keydown', escHandler);
                    resolve(null);
                }
            };
            document.addEventListener('keydown', escHandler);

            document.body.appendChild(popup);
        });
    }

    // Execute the tasks
    async function executeCollectMoreTasks(tasks, showSummary) {
        const functionMap = createFunctionMap();
        const selectedTasks = tasks.filter(t => t.checked && !t.disabled);

        if (selectedTasks.length === 0) {
            if (HWHFuncs?.setProgress) {
                HWHFuncs.setProgress('No tasks selected', true);
            }
            return;
        }

        let completedTasks = 0;
        const totalTasks = selectedTasks.length;
        const collectionResults = [];

        // Capture "before" currencies for summary comparison
        const currenciesBefore = await getCurrentCurrencies();

        // Separate by group
        const doAllTask = selectedTasks.find(t => t.name === 'doAllHWH');
        const collectionTasks = selectedTasks.filter(t => t.group === 'collect');
        const postTasks = selectedTasks.filter(t => t.group === 'post');

        // Phase 1: Pre-collection (Do All)
        if (doAllTask) {
            try {
                if (HWHFuncs?.setProgress) {
                    HWHFuncs.setProgress(`${doAllTask.icon} ${doAllTask.label}...`, false);
                }
                const func = functionMap[doAllTask.name];
                if (func) {
                    await func();
                    completedTasks++;
                    if (HWHFuncs?.setProgress) {
                        HWHFuncs.setProgress(`‚úÖ ${doAllTask.label} done (${completedTasks}/${totalTasks})`, false);
                    }
                }
            } catch (error) {
                console.error('Error in Do All:', error);
                if (HWHFuncs?.setProgress) {
                    HWHFuncs.setProgress(`‚ùå ${doAllTask.label} failed`, true);
                }
            }

            // Wait for rewards to generate
            if (collectionTasks.length > 0) {
                for (let i = 5; i > 0; i--) {
                    if (HWHFuncs?.setProgress) {
                        HWHFuncs.setProgress(`‚è≥ Starting collection in ${i}s...`, false);
                    }
                    await new Promise(r => setTimeout(r, 1000));
                }
            }
        }

        // Phase 2: Collection tasks
        for (const task of collectionTasks) {
            try {
                if (HWHFuncs?.setProgress) {
                    HWHFuncs.setProgress(`${task.icon} ${task.label}...`, false);
                }

                const func = functionMap[task.name];
                if (func) {
                    const startTime = Date.now();
                    const result = await func();
                    const duration = ((Date.now() - startTime) / 1000).toFixed(1);
                    completedTasks++;

                    collectionResults.push({
                        name: task.label,
                        icon: task.icon,
                        success: result?.success !== false,
                        duration,
                        count: result?.count || 0,
                        items: result?.items || 'Completed',
                        hasItems: result?.hasItems || false,
                        rewards: result?.rewards || {}
                    });

                    if (HWHFuncs?.setProgress) {
                        HWHFuncs.setProgress(`‚úÖ ${task.label} done (${completedTasks}/${totalTasks})`, false);
                    }
                }
            } catch (error) {
                console.error(`Error in ${task.name}:`, error);
                collectionResults.push({
                    name: task.label,
                    icon: task.icon,
                    success: false,
                    items: error.message
                });
                completedTasks++;
            }
            await new Promise(r => setTimeout(r, 500));
        }

        // Phase 3: Post-collection tasks
        for (const task of postTasks) {
            try {
                if (HWHFuncs?.setProgress) {
                    HWHFuncs.setProgress(`${task.icon} ${task.label}...`, false);
                }

                const func = functionMap[task.name];
                if (func) {
                    const result = await func();
                    completedTasks++;

                    collectionResults.push({
                        name: task.label,
                        icon: task.icon,
                        success: result?.success !== false,
                        items: result?.items || 'Completed'
                    });

                    if (HWHFuncs?.setProgress) {
                        HWHFuncs.setProgress(`‚úÖ ${task.label} done (${completedTasks}/${totalTasks})`, false);
                    }
                }
            } catch (error) {
                console.error(`Error in ${task.name}:`, error);
                completedTasks++;
            }
        }
        debugLog('üìä All collection results:', JSON.stringify(collectionResults, null, 2));
        // Show summary if requested
        if (showSummary && collectionResults.length > 0) {
            const currenciesAfter = await getCurrentCurrencies();
            await showCollectMoreSummary(collectionResults, currenciesBefore, currenciesAfter);
        }

        // Final notification
        if (HWHFuncs?.setProgress) {
            HWHFuncs.setProgress(`üéâ Done! ${completedTasks}/${totalTasks} tasks completed`, false);
            setTimeout(() => HWHFuncs?.setProgress?.('', false), 3000);
        }

        debugLog('‚úÖ Collect More finished');
    }

    // Summary popup - READABLE VERSION with grouped items
    async function showCollectMoreSummary(results, currenciesBefore = null, currenciesAfter = null) {
        const successCount = results.filter(r => r.success).length;
        const failCount = results.length - successCount;

        // Format currency changes
        const formatNum = n => n >= 1000000 ? (n/1000000).toFixed(1) + 'M' : n >= 1000 ? (n/1000).toFixed(1) + 'K' : n.toLocaleString();
        const formatDelta = (before, after) => {
            const diff = after - before;
            if (diff === 0) return `<span style="color:#999">${formatNum(after)}</span>`;
            const color = diff > 0 ? '#4ae29a' : '#ff6b6b';
            const sign = diff > 0 ? '+' : '';
            return `<span style="color:#999">${formatNum(before)}</span> ‚Üí <span style="color:${color}">${formatNum(after)} (${sign}${formatNum(diff)})</span>`;
        };

        // Build inline currency display for header
        let currencyHeaderHtml = '';
        if (currenciesBefore && currenciesAfter) {
            const makeDeltaSpan = (before, after, icon, title) => {
                const diff = after - before;
                let deltaHtml = '';
                if (diff !== 0) {
                    const color = diff > 0 ? '#4ae29a' : '#ff6b6b';
                    const sign = diff > 0 ? '+' : '';
                    deltaHtml = ` <span style="color:${color}">(${sign}${formatNum(diff)})</span>`;
                }
                return `<span title="${title}">${icon} ${formatNum(after)}${deltaHtml}</span>`;
            };
            currencyHeaderHtml = `
                <div style="display:flex; gap:12px; font-size:11px; background:rgba(0,0,0,0.3); padding:4px 10px; border-radius:4px; margin-right:10px;">
                    ${makeDeltaSpan(currenciesBefore.gold, currenciesAfter.gold, 'ü™ô', 'Gold')}
                    ${makeDeltaSpan(currenciesBefore.emeralds, currenciesAfter.emeralds, 'üíé', 'Emeralds')}
                    ${makeDeltaSpan(currenciesBefore.soulCoins, currenciesAfter.soulCoins, 'üëª', 'Soul Coins')}
                </div>
            `;
        }

        // Remove any existing summary popup
        const existing = document.getElementById('collect-summary-popup');
        if (existing) existing.remove();

        // Get canvas dimensions for sizing
        const canvas = DOMCache.get('gameCanvas', 'canvas');
        const canvasRect = canvas ? canvas.getBoundingClientRect() : { width: 800, height: 600 };
        const popupWidth = Math.min(canvasRect.width * 0.6, 750);
        const maxPopupHeight = canvasRect.height * 0.8;

        const summaryPopup = document.createElement('div');
        summaryPopup.id = 'collect-summary-popup';
        summaryPopup.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(42,24,16); border: 2px solid #8b6914; border-radius: 6px;
            padding: 15px; width: ${popupWidth}px; max-height: ${maxPopupHeight}px;
            color: #ffd700; font-family: Arial, sans-serif; font-size: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5); z-index: 10001;
            display: flex; flex-direction: column;
        `;


        // Parse and aggregate all items (only actual items, not status messages)
        // Merge all structured rewards from results
        const allItems = {};
        results.forEach(r => {
            if (r.rewards && typeof r.rewards === 'object') {
                for (const [name, data] of Object.entries(r.rewards)) {
                    if (!allItems[name]) {
                        allItems[name] = { amount: 0, sources: new Set() };
                    }
                    allItems[name].amount += data.amount || 0;
                    if (data.source) {
                        allItems[name].sources.add(data.source);
                    }
                }
            }
        });

        const totalItemTypes = Object.keys(allItems).length;

        // Helper to create short summary from items text
        const getShortSummary = (r) => {
            if (!r.items || r.items === 'Completed') return '';
            // If it's a status message (no actual items), show abbreviated version
            if (!r.hasItems) {
                const text = r.items;
                if (text.includes('No items')) return 'None';
                if (text.includes('already collected')) return 'Done';
                if (text.includes('No prestige')) return 'Locked';
                if (text.includes('synchronized')) return 'Synced';
                if (text.length > 20) return text.substring(0, 18) + '...';
                return text;
            }
            // Has items - show count
            return r.count > 0 ? `${r.count} items` : '';
        };

        let content = `
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3 style="margin: 0; font-size: 14px;">üìä Collection Summary</h3>
                <div style="display:flex; align-items:center;">
                    ${currencyHeaderHtml}
                    <button id="close-collect-summary" style="background: #666; color: #fff; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 14px; font-weight: bold;">‚úï</button>
                </div>
            </div>
            <div style="display: flex; gap: 20px; margin-bottom: 12px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 4px;">
                <span class="twk-green-bold">‚úÖ ${successCount} completed</span>
                ${failCount > 0 ? `<span class="twk-red-bold">‚ùå ${failCount} failed</span>` : ''}
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; flex: 1; min-height: 0; overflow: hidden;">
                <!-- Left column: Tasks -->
                <div style="display: flex; flex-direction: column; min-height: 0; overflow: hidden;">
                    <div style="color: #999; font-size: 11px; padding: 4px 8px; border-bottom: 1px solid #555; margin-bottom: 4px;">Tasks</div>
                    <div style="flex: 1; overflow-y: auto; min-height: 0;">
        `;

        results.forEach(r => {
            const statusColor = r.success ? '#4ae29a' : '#ff6b6b';
            const statusIcon = r.success ? '‚úÖ' : '‚ùå';
            const shortSummary = getShortSummary(r);
            const durationDisplay = r.duration ? `${r.duration}s` : '';

            content += `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; margin-bottom: 2px; border-bottom: 1px solid #333; font-size: 11px;">
                    <span style="color: #ffd700; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-shrink: 1;" title="${r.name}">${r.icon} ${r.name}</span>
                    <span style="flex-shrink: 0; display: flex; align-items: center; gap: 6px;">
                        ${shortSummary ? `<span style="color: #999; font-size: 10px;">${shortSummary}</span>` : ''}
                        ${durationDisplay ? `<span style="color: #666; font-size: 10px;">${durationDisplay}</span>` : ''}
                        <span style="color: ${statusColor};">${statusIcon}</span>
                    </span>
                </div>
            `;
        });

        // Close scrollable task list, add currency section at bottom of column 1
        content += `
                    </div>
                </div>
                <!-- Right column: All Items -->
                <div style="display: flex; flex-direction: column; min-height: 0; overflow: hidden;">
                    <div style="color: #999; font-size: 11px; padding: 4px 8px; border-bottom: 1px solid #555; margin-bottom: 4px; display: flex; justify-content: space-between;">
                        <span>Items Collected</span>
                        <span class="twk-green">${totalItemTypes}</span>
                    </div>
                    <div style="flex: 1; overflow-y: auto; min-height: 0;">
        `;



        const itemEntries = Object.entries(allItems);
        // Sort: coins first, then consumables, then others - alphabetically within each group
        itemEntries.sort(([a], [b]) => {
            const getTypeOrder = (name) => {
                if (name.includes('coin') || name.includes('Coin') || name.includes('Chip')) return 0;
                if (name.startsWith('üí∞')) return 0;
                if (name.startsWith('ü™ô')) return 1;
                if (name.startsWith('üíé')) return 2;
                if (name.startsWith('üì¶')) return 3;
                if (name.startsWith('‚öôÔ∏è')) return 4;
                if (name.startsWith('üìú')) return 5;
                if (name.startsWith('üë§') || name.includes('(SS)')) return 6;
                if (name.startsWith('üîß') || name.includes('(Frag)')) return 7;
                return 8;
            };
            const orderA = getTypeOrder(a);
            const orderB = getTypeOrder(b);
            if (orderA !== orderB) return orderA - orderB;
            return a.localeCompare(b);
        });

        if (itemEntries.length > 0) {
            itemEntries.forEach(([name, data]) => {
                const sourceList = Array.from(data.sources).sort().join(',');
                content += `
                    <div style="padding: 4px 8px; margin-bottom: 1px; border-bottom: 1px solid #333; font-size: 11px; display: flex; justify-content: space-between;">
                        <span style="color: #ccc; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${name}</span>
                        <span style="flex-shrink: 0; font-family: monospace;"><span class="twk-green">x${data.amount.toLocaleString()}</span> <span style="color: #999; font-size: 9px;">[${sourceList}]</span></span>
                    </div>
                `;
            });
        } else {
            content += `<div style="padding: 8px; color: #666; font-style: italic;">No items collected</div>`;
        }

        content += `
                    </div>
                </div>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 12px; padding-top: 10px; border-top: 1px solid #666;">
                <button id="collect-summary-reload" style="flex: 1; padding: 8px; background: #8b6914; color: #ffd700; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">üîÑ Reload</button>
                <button id="collect-summary-ok" style="flex: 1; padding: 8px; background: #4a4a4a; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">OK</button>
            </div>
        `;

        summaryPopup.innerHTML = content;
        document.body.appendChild(summaryPopup);
        // Resize handler
        const resizeHandler = () => {
            const canvas = DOMCache.get('gameCanvas', 'canvas');
            const canvasRect = canvas ? canvas.getBoundingClientRect() : { width: 800, height: 600 };
            summaryPopup.style.width = Math.min(canvasRect.width * 0.6, 750) + 'px';
            summaryPopup.style.maxHeight = (canvasRect.height * 0.8) + 'px';
        };
        window.addEventListener('resize', resizeHandler);
        summaryPopup._cleanupResize = () => window.removeEventListener('resize', resizeHandler);

        // Event listeners
        document.getElementById('close-collect-summary').addEventListener('click', () => { window.removeEventListener('resize', resizeHandler); summaryPopup.remove(); });
        document.getElementById('collect-summary-ok').addEventListener('click', () => { window.removeEventListener('resize', resizeHandler); summaryPopup.remove(); });
        document.getElementById('collect-summary-reload').addEventListener('click', () => location.reload());
    }

    ModuleTracker.register('Collect More');

    // ================================================================
    // SECTION 8: CUSTOM BUTTON MANAGEMENT
    // ================================================================

    // First, add the goAoC function to open the map
    window.goAoC = function () {
        try {
            if (typeof selfGame === 'undefined') {
                selfGame = Game;
            }

            let player = getPlayer();
            let aocMediator = selfGame['game.mechanics.clanDomination.mediator.ClanDominationMapPopupMediator'];
            new aocMediator(player).open();
            debugLog('Opened Clan Domination Map');
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('Opened Clan Domination Map', true);
            }
        } catch (e) {
            console.error('Failed to open Clan Domination Map:', e);
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('Failed to open Clan Domination Map', true);
            }
        }
    };
    window.goGuildChat = function (tabName = 'CLAN_TAB') {
        try {
            let player = getPlayer();
            let chatPopupMediator = selfGame['game.mediator.gui.popup.chat.ChatPopupMediator'];
            let mediator = new chatPopupMediator(player);

            // Set the tab before opening
            let chatProps = chatPopupMediator.prototype.__properties__;
            let setTabMethod = Object.entries(chatProps).find(e => e[1] === 'set_selectedTab')?.[0];
            if (setTabMethod && tabName) {
                mediator[setTabMethod](tabName);
            }

            mediator.open();
        } catch (e) {
            console.error('Failed to open Chat:', e);
            if (HWHFuncs && HWHFuncs.setProgress) {
                HWHFuncs.setProgress('Failed to open Chat', true);
            }
        }
    };


    function createBackHomeSyncButton(templateWrapper, buttonContainer, insertionPoint) {
        if (!window.isUISettingEnabled('showBackHomeSyncButton')) return null;

        try {
            const buttonGroup = document.createElement('div');
            buttonGroup.classList.add('scriptMenu_buttonGroup');
            buttonGroup.dataset.customBackHomeSyncButton = "true";

            const backButton = document.createElement('div');
            backButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonLeft';
            backButton.innerHTML = `<div class="scriptMenu_buttonText" style="font-size: 85%; line-height: 1.4; text-shadow: none;">‚óÄÔ∏è</div>`;
            backButton.title = 'Go back (single Escape press)';

            backButton.onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                document.dispatchEvent(new KeyboardEvent('keydown', {
                    key: 'Escape',
                    keyCode: 27,
                    bubbles: true
                }));
                debugLog('Sent single Escape press');
                if (HWHFuncs && HWHFuncs.setProgress) {
                    HWHFuncs.setProgress('Back', true);
                }
            };

            const homeButton = document.createElement('div');
            homeButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonCenter';
            homeButton.innerHTML = `<div class="scriptMenu_buttonText" style="font-size: 85%; line-height: 1.4; text-shadow: none;">üè†</div>`;

            homeButton.title = 'Return to main screen (close all popups)';

            homeButton.onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (window.goHome) {
                    window.goHome();
                } else {
                    console.error('goHome function not available');
                }
            };

            const syncButton = document.createElement('div');
            syncButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonRight';
            syncButton.innerHTML = `<div class="scriptMenu_buttonText" style="font-size: 85%; line-height: 1.4; text-shadow: none;">üîÑ</div>`;

            syncButton.title = 'Partial synchronization of game data without reloading the page';

            syncButton.onclick = async function(e) {
                e.preventDefault();
                e.stopPropagation();
                await silentSync();
            };

            buttonGroup.appendChild(backButton);
            buttonGroup.appendChild(homeButton);
            buttonGroup.appendChild(syncButton);

            const dotAtention = document.createElement('div');
            dotAtention.classList.add('scriptMenu_dot');
            buttonGroup.appendChild(dotAtention);

            buttonContainer.insertBefore(buttonGroup, insertionPoint.nextSibling);
            debugLog('Added Back/Home/Sync button');
            return buttonGroup;
        } catch (e) {
            console.error('Failed to add Back/Home/Sync button:', e);
            return null;
        }
    };

    function createInventoryHeroesButtons(templateWrapper, buttonContainer, insertionPoint) {
        if (!window.isUISettingEnabled('showInventoryHeroesButton')) return null;

        try {
            const buttonGroup = document.createElement('div');
            buttonGroup.classList.add('scriptMenu_buttonGroup');
            buttonGroup.dataset.customConsumablesHeroesLine = "true";

            const heroesButton = document.createElement('div');
            heroesButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonLeft';
            heroesButton.innerHTML = `<div class="scriptMenu_buttonText" style="font-size: 80%;">Heroes</div>`;
            heroesButton.style.padding = '6.5px 8px 10px';
            heroesButton.onclick = (e) => { e.stopPropagation(); window.goHeroes(); };
            heroesButton.title = 'Open Heroes Hub';

            const petsButton = document.createElement('div');
            petsButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonRight';
            petsButton.innerHTML = `<div class="scriptMenu_buttonText" style="font-size: 80%;">Pets</div>`;
            petsButton.style.padding = '6.5px 8px 10px';
            petsButton.onclick = (e) => { e.stopPropagation(); window.goPets(); };
            petsButton.title = 'Open Pets';

            buttonGroup.appendChild(heroesButton);
            buttonGroup.appendChild(petsButton);

            const dotAtention = document.createElement('div');
            dotAtention.classList.add('scriptMenu_dot');
            buttonGroup.appendChild(dotAtention);

            buttonContainer.insertBefore(buttonGroup, insertionPoint.nextSibling);
            debugLog('Added Heroes/Pets buttons');
            return buttonGroup;

        } catch (e) {
            console.error('Failed to add Heroes/Pets buttons:', e);
            return null;
        }
    };

    function createTitansButtons(templateWrapper, buttonContainer, insertionPoint) {
        if (!window.isUISettingEnabled('showTitansCombinedButton')) return null;

        try {
            const buttonGroup = document.createElement('div');
            buttonGroup.classList.add('scriptMenu_buttonGroup');
            buttonGroup.dataset.customTitansButtonsLine = "true";

            const titansButton = document.createElement('div');
            titansButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonLeft';
            titansButton.innerHTML = `<div class="scriptMenu_buttonText" style="font-size: 80%;">Titans</div>`;
            titansButton.style.padding = '6.5px 8px 10px';
            titansButton.onclick = (e) => { e.stopPropagation(); window.goTitans(); };
            titansButton.title = 'Open Titans Hub';

            const artifactButton = document.createElement('div');
            artifactButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonRight';
            artifactButton.innerHTML = `<div class="scriptMenu_buttonText" style="font-size: 80%;">Totems</div>`;
            artifactButton.style.padding = '6.5px 8px 10px';
            artifactButton.onclick = (e) => { e.stopPropagation(); window.goTitanSpiritArtifact(); };
            artifactButton.title = 'Open Titan Spirit Artifact';

            buttonGroup.appendChild(titansButton);
            buttonGroup.appendChild(artifactButton);

            const dotAtention = document.createElement('div');
            dotAtention.classList.add('scriptMenu_dot');
            buttonGroup.appendChild(dotAtention);

            buttonContainer.insertBefore(buttonGroup, insertionPoint.nextSibling);
            debugLog('Added Titans buttons');
            return buttonGroup;

        } catch (e) {
            console.error('Failed to add Titans buttons:', e);
            return null;
        }
    };

    function createEventsSeasonButton(templateWrapper, buttonContainer, insertionPoint) {
        if (!window.isUISettingEnabled('showEventsSeasonButton')) return null;

        try {
            const buttonGroup = document.createElement('div');
            buttonGroup.classList.add('scriptMenu_buttonGroup');
            buttonGroup.dataset.customEventsSeasonLine = "true";

            const eventsButton = document.createElement('div');
            eventsButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonLeft';
            eventsButton.innerHTML = `<div class="scriptMenu_buttonText" style="font-size: 80%;">Events</div>`;
            eventsButton.style.padding = '6.5px 8px 10px';
            eventsButton.onclick = (e) => { e.stopPropagation(); window.goSpecialEvents(); };
            eventsButton.title = 'Open Special Events';

            const inventoryButton = document.createElement('div');
            inventoryButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonRight';
            inventoryButton.innerHTML = `<div class="scriptMenu_buttonText" style="font-size: 80%;">Inventory</div>`;
            inventoryButton.style.padding = '6.5px 8px 10px';
            inventoryButton.onclick = (e) => { e.stopPropagation(); window.goConsumables(); };
            inventoryButton.title = 'Open Inventory';

            buttonGroup.appendChild(eventsButton);
            buttonGroup.appendChild(inventoryButton);

            const dotAtention = document.createElement('div');
            dotAtention.classList.add('scriptMenu_dot');
            buttonGroup.appendChild(dotAtention);

            buttonContainer.insertBefore(buttonGroup, insertionPoint.nextSibling);
            debugLog('Added Events/Inventory button');
            return buttonGroup;

        } catch (e) {
            console.error('Failed to add Events/Inventory button:', e);
            return null;
        }
    };

    function createActionsOthersButton(templateWrapper, buttonContainer, insertionPoint) {
        if (!window.isUISettingEnabled('showActionsOthersButton')) return null;

        try {
            const buttonGroup = document.createElement('div');
            buttonGroup.classList.add('scriptMenu_buttonGroup');
            buttonGroup.dataset.customActionsOthersButton = "true";

            const actionsButton = document.createElement('div');
            actionsButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonLeft';
            actionsButton.innerHTML = `<div class="scriptMenu_buttonText">Actions</div>`;
            actionsButton.title = 'Dialog box with various actions';
            actionsButton.onclick = async function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (typeof HWHData !== 'undefined' && HWHData.actionsPopupButtons) {
                    const buttons = [...HWHData.actionsPopupButtons];
                    buttons.push({ result: false, isClose: true });
                    const answer = await HWHFuncs.popup.confirm('Choose an action:', buttons);
                    if (typeof answer === 'function') {
                        answer();
                    }
                }
            };

            const othersButton = document.createElement('div');
            othersButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonRight';
            othersButton.innerHTML = `<div class="scriptMenu_buttonText">Others</div>`;
            othersButton.title = 'Others';
            othersButton.onclick = async function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (typeof HWHData !== 'undefined' && HWHData.othersPopupButtons) {
                    const buttons = [...HWHData.othersPopupButtons];
                    buttons.push({ result: false, isClose: true });
                    const answer = await HWHFuncs.popup.confirm('Choose an action:', buttons);
                    if (typeof answer === 'function') {
                        answer();
                    }
                }
            };

            buttonGroup.appendChild(actionsButton);
            buttonGroup.appendChild(othersButton);

            const dotAtention = document.createElement('div');
            dotAtention.classList.add('scriptMenu_dot');
            buttonGroup.appendChild(dotAtention);

            buttonContainer.insertBefore(buttonGroup, insertionPoint.nextSibling);
            debugLog('‚úÖ Added Actions & Others compound button');
            return buttonGroup;
        } catch (e) {
            console.error('Failed to add Actions & Others button:', e);
            return null;
        }
    };

    function createRewardsQuestsButton(templateWrapper, buttonContainer, insertionPoint) {
        if (!window.isUISettingEnabled('showRewardsQuestsButton')) return null;

        try {
            const buttonGroup = document.createElement('div');
            buttonGroup.classList.add('scriptMenu_buttonGroup');
            buttonGroup.dataset.customRewardsQuestsButton = "true";

            const rewardsButton = document.createElement('div');
            rewardsButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonLeft';
            rewardsButton.innerHTML = `<div class="scriptMenu_buttonText">Rewards</div>`;
            rewardsButton.title = 'Collect all quest rewards';
            rewardsButton.onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                try {
                    HWHData.buttons.rewardsAndMailFarm.onClick();
                } catch (error) {
                    console.error('Error calling rewardsAndMailFarm:', error);
                }
            };

            const questsButton = document.createElement('div');
            questsButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonRight';
            questsButton.innerHTML = `<div class="scriptMenu_buttonText">Quests</div>`;
            questsButton.title = 'Complete daily quests';
            questsButton.onclick = async function(e) {
                e.preventDefault();
                e.stopPropagation();
                try {
                    await HWHData.buttons.dailyQuests.onClick();
                } catch (error) {
                    console.error('Error calling dailyQuests:', error);
                }
            };

            buttonGroup.appendChild(rewardsButton);
            buttonGroup.appendChild(questsButton);

            const dotAtention = document.createElement('div');
            dotAtention.classList.add('scriptMenu_dot');
            buttonGroup.appendChild(dotAtention);

            buttonContainer.insertBefore(buttonGroup, insertionPoint.nextSibling);
            debugLog('‚úÖ Added Rewards & Quests compound button');
            return buttonGroup;
        } catch (e) {
            console.error('Failed to add Rewards & Quests button:', e);
            return null;
        }
    };
    function createCollectMoreButton(templateWrapper, buttonContainer, insertionPoint) {
        if (window.isUISettingEnabled('showCollectMoreButton')) {
            debugLog('üîç DEBUG: Collect More button setting is ENABLED');
            try {
                // Create button group directly (no wrapper) - same as Overview/Members
                const buttonGroup = document.createElement('div');
                buttonGroup.classList.add('scriptMenu_buttonGroup');
                buttonGroup.dataset.customCollectMore = "true";

                // Main "Collect" button (left side) - bigger font
                const collectButton = document.createElement('div');
                collectButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonLeft';
                collectButton.innerHTML = `<div class="scriptMenu_buttonText" style="font-size: 90%;">Collect <span class="twk-green">+</span></div>`;
                collectButton.style.padding = '6.5px 8px 10px';
                collectButton.title = 'Run collection tasks including internal collection functions';

                // Gear button (right side) - just a little wider than before
                const gearButton = document.createElement('div');
                gearButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonRight';
                gearButton.innerHTML = `<div class="scriptMenu_buttonText" style="font-size: 80%;">‚öô</div>`;
                gearButton.style.padding = '6.5px 6px 10px'; // Little wider: 6px instead of 4px
                gearButton.style.minWidth = '28px'; // Little wider min width
                gearButton.style.maxWidth = '32px'; // Little wider max width
                gearButton.title = 'HWH Tweaker Settings';

                // REPLACE your entire Collect More button onclick function with this:


                collectButton.onclick = async function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    await window.runCollectMore();
                };

                // Settings menu functionality for the gear button - FIXED CLICK HANDLERS
                gearButton.onclick = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    window.showTweakerSettings();
                };

                // Assemble the button group
                buttonGroup.appendChild(collectButton);
                buttonGroup.appendChild(gearButton);

                // Add the standard dot attention element
                const dotAtention = document.createElement('div');
                dotAtention.classList.add('scriptMenu_dot');
                buttonGroup.appendChild(dotAtention);

                // Insert directly into container (NO wrapper)
                buttonContainer.insertBefore(buttonGroup, insertionPoint.nextSibling);
                insertionPoint = buttonGroup;
                debugLog('üîç DEBUG: ‚úÖ Added Collect More as compound button with gear');
            } catch (e) {
                console.error('üîç DEBUG: ‚ùå Failed to add compound Collect More button:', e);
            }
        }
    };

    function createStatsButtons(templateWrapper, buttonContainer, insertionPoint) {
        if (!window.isUISettingEnabled('showStatsButtons')) return null;

        try {
            const buttonGroup = document.createElement('div');
            buttonGroup.classList.add('scriptMenu_buttonGroup');
            buttonGroup.dataset.customStatsButtons = "true";

            const powerTournamentButton = document.createElement('div');
            powerTournamentButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonLeft';
            powerTournamentButton.innerHTML = `<div class="scriptMenu_buttonText" style="font-size: 80%;">üèÜ</div>`;
            powerTournamentButton.style.padding = '6.5px 8px 10px';
            powerTournamentButton.onclick = (e) => { e.stopPropagation(); window.goPowerTournament(); };
            powerTournamentButton.title = 'Power Tournament Stats';

            const stats2Button = document.createElement('div');
            stats2Button.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonRight';
            stats2Button.innerHTML = `<div class="scriptMenu_buttonText" style="font-size: 80%;">Stats 2</div>`;
            stats2Button.style.padding = '6.5px 8px 10px';
            stats2Button.onclick = (e) => { e.stopPropagation(); window.goStats2(); };
            stats2Button.title = 'Stats 2 (Power Tournament for now)';

            buttonGroup.appendChild(powerTournamentButton);
            buttonGroup.appendChild(stats2Button);  // Changed from quizRankButton

            const dotAtention = document.createElement('div');
            dotAtention.classList.add('scriptMenu_dot');
            buttonGroup.appendChild(dotAtention);

            buttonContainer.insertBefore(buttonGroup, insertionPoint.nextSibling);
            debugLog('Added Stats buttons');
            return buttonGroup;
        } catch (e) {
            console.error('Failed to add Stats buttons:', e);
            return null;
        }
    };

    function createAoCButton(templateWrapper, buttonContainer, insertionPoint) {
        if (!window.isUISettingEnabled('showAoCButton')) return null;

        try {
            const buttonGroup = document.createElement('div');
            buttonGroup.classList.add('scriptMenu_buttonGroup');
            buttonGroup.dataset.customAocButton = "true";

            // Left button - AoC Map
            const aocMapButton = document.createElement('div');
            aocMapButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonLeft';
            aocMapButton.innerHTML = `<div class="scriptMenu_buttonText" style="font-size: 85%; line-height: 1.4; text-shadow: none;">üè∞</div>`;
            aocMapButton.title = 'Open AoC Map';
            aocMapButton.onclick = (e) => { e.stopPropagation(); window.goAoC(); };

            // Right button - AoC Stats (current functionality)
            const aocStatsButton = document.createElement('div');
            aocStatsButton.className = 'scriptMenu_button scriptMenu_beigeButton scriptMenu_combineButtonRight';
            aocStatsButton.innerHTML = `<div class="scriptMenu_buttonText" style="font-size: 85%; line-height: 1.4; text-shadow: none;">üìä</div>`;
            aocStatsButton.title = 'AoC Stats';
            aocStatsButton.onclick = (e) => { e.stopPropagation(); window.showAoCStatsUnified(); };

            buttonGroup.appendChild(aocMapButton);
            buttonGroup.appendChild(aocStatsButton);

            const dotAtention = document.createElement('div');
            dotAtention.classList.add('scriptMenu_dot');
            buttonGroup.appendChild(dotAtention);

            buttonContainer.insertBefore(buttonGroup, insertionPoint.nextSibling);
            debugLog('‚úÖ Added AoC Map & Stats compound button');
            return buttonGroup;
        } catch (e) {
            console.error('Failed to add AoC button:', e);
            return null;
        }
    };
    // ================================================================
    // SECTION 10: SETTINGS POPUPS
    // ================================================================
    // HWH SETTINGS EDITOR - WITH TOP-LEVEL TABS
    // Replace your showTweakerSettings function with this version

    window.showTweakerSettings = function() {
        debugLog('Opening HWH Tweaker Settings...');

        const popup = document.createElement('div');
        popup.id = 'hwh-tweaker-popup';

        // Build HTML safely
        const delayFactor = getDelayFactor();
        const autoRefreshInterval = parseInt(localStorage.getItem('hwh_autorefresh_interval')) || 60;

        popup.innerHTML =
            '<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;">' +
            '<div style="background: #2a1810; border: 3px solid #8b6914; border-radius: 10px; padding: 20px; min-width: 900px; max-width: 1000px; color: #ffd700; font-family: Arial, sans-serif; max-height: 90vh; overflow-y: auto;">' +
            '<h2 style="margin: 0 0 15px 0; text-align: center; color: #ffd700;">HWH Tweaker Settings v' + TWEAKER_VERSION + '</h2>' +

            // Top-level Tab bar
            '<div style="display: flex; gap: 8px; margin-bottom: 20px; border-bottom: 2px solid #8b6914; padding-bottom: 10px;">' +
            '<button id="tab-settings" class="tweaker-tab" style="flex: 1; padding: 10px 16px; border: none; border-radius: 6px 6px 0 0; cursor: pointer; font-size: 14px; font-weight: bold; background: #8b6914; color: #ffd700;">‚öôÔ∏è Settings</button>' +
            '<button id="tab-data" class="tweaker-tab" style="flex: 1; padding: 10px 16px; border: none; border-radius: 6px 6px 0 0; cursor: pointer; font-size: 14px; font-weight: bold; background: #3a2a1a; color: #999;">üìä Data</button>' +
            '<button id="tab-prefs" class="tweaker-tab" style="flex: 1; padding: 10px 16px; border: none; border-radius: 6px 6px 0 0; cursor: pointer; font-size: 14px; font-weight: bold; background: #3a2a1a; color: #999;">‚≠ê Preferences</button>' +
            '</div>' +

            // ==================== SETTINGS TAB CONTENT ====================
            '<div id="tab-content-settings" style="display: block;">' +

            // Two column layout for Settings
            '<div style="display: grid; grid-template-columns: 1.5fr 0.8fr; gap: 20px;">' +

            // LEFT BOX - HW Helper Settings & Values (two columns inside)
            '<div class="twk-panel">' +
            '<h3 style="margin: 0 0 15px 0; color: #4ae29a; text-align: center;">HW Helper Settings & Values</h3>' +
            '<div style="display: grid; grid-template-columns: 1fr auto; gap: 20px;">' +
            '<div id="checkbox-container" style="max-height: 400px; overflow-y: auto; padding-right: 5px;"></div>' +
            '<div id="values-container" style="display: flex; flex-direction: column; gap: 12px; min-width: 100px;"></div>' +
            '</div>' +
            '</div>' +

            // RIGHT COLUMN - Tweaker Settings
            '<div class="twk-panel">' +
            '<h3 style="margin: 0 0 15px 0; color: #4ae29a; text-align: center;">Tweaker</h3>' +

            // Delay Factor
            '<div class="twk-mb-15">' +
            '<label style="display: block; margin-bottom: 8px; font-weight: bold; font-size: 13px;">Performance:</label>' +
            '<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">' +
            '<label style="min-width: 85px; font-size: 12px;">Delay Factor:</label>' +
            '<input type="number" id="delay-input" min="0.1" max="10.0" step="0.1" value="' + delayFactor + '"' +
            ' style="width: 55px; padding: 4px; background: #1a1a1a; color: #ffd700; border: 1px solid #8b6914; border-radius: 3px; font-size: 12px;">' +
            '<span style="font-size: 11px; color: #ccc;">' + delayFactor + 'x</span>' +
            '</div>' +
            '<div style="font-size: 10px; color: #999; line-height: 1.3;">Speed of multi-step collections<br>(0.5=faster, 2.0=slower)</div>' +
            '</div>' +

            // Guild Members Auto-Refresh
            '<div class="twk-mb-15">' +
            '<label style="display: block; margin-bottom: 8px; font-weight: bold; font-size: 13px;">Guild Members:</label>' +
            '<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">' +
            '<label style="min-width: 85px; font-size: 12px;">Auto-Refresh:</label>' +
            '<input type="number" id="autorefresh-input" min="60" max="600" step="30" value="' + autoRefreshInterval + '"' +
            ' style="width: 55px; padding: 4px; background: #1a1a1a; color: #ffd700; border: 1px solid #8b6914; border-radius: 3px; font-size: 12px;">' +
            '<span style="font-size: 11px; color: #ccc;">seconds</span>' +
            '</div>' +
            '<div style="font-size: 10px; color: #999; line-height: 1.3;">Speed of multi-step collections<br>(0.5=faster, 2.0=slower)</div>' +
            '</div>' +

            '<div class="twk-mb-15">' +
            '<div style="display: flex; align-items: center; gap: 8px;">' +
            '<label style="display: flex; align-items: center; cursor: pointer; font-size: 12px;">' +
            '<input type="checkbox" id="arena-stats-enabled" ' + (localStorage.getItem('hwh_arena_stats_enabled') !== 'false' ? 'checked' : '') + ' style="margin-right: 6px; cursor: pointer;">' +
            '<span>Arena Stats Tracking</span>' +
            '</label>' +
            '</div>' +
            '<div style="font-size: 10px; color: #999; line-height: 1.3; margin-top: 4px;">Disable to reduce CPU usage<br>(requires page reload)</div>' +
            '</div>' +

            '<div class="twk-mb-15">' +
            '<div style="display: flex; align-items: center; gap: 8px;">' +
            '<label style="display: flex; align-items: center; cursor: pointer; font-size: 12px;">' +
            '<input type="checkbox" id="debug-mode-enabled" ' + (localStorage.getItem('hwh_debug_mode') === 'true' ? 'checked' : '') + ' style="margin-right: 6px; cursor: pointer;">' +
            '<span>Debug Mode</span>' +
            '</label>' +
            '</div>' +
            '<div style="font-size: 10px; color: #999; line-height: 1.3; margin-top: 4px;">Show debug logs in console<br>(requires page reload)</div>' +
            '</div>' +
            '</div>' + // end right column

            '</div>' + // end grid
            '</div>' + // end Settings tab content

            // ==================== DATA TAB CONTENT ====================
            '<div id="tab-content-data" class="twk-hidden">' +

            // Two column layout for Data
            '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">' +

            // LEFT COLUMN - Storage & History
            '<div class="twk-panel">' +
            '<h3 style="margin: 0 0 15px 0; color: #4ae29a; text-align: center;">Storage</h3>' +

            // Storage Report
            '<div class="twk-mb-15">' +
            '<label style="display: block; margin-bottom: 8px; font-weight: bold; font-size: 13px;">üíæ localStorage:</label>' +
            '<button id="show-storage-btn" style="background: #27ae60; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold; width: 100%;">' +
            'üìä Show Storage Report' +
            '</button>' +
            '<div id="storage-display" style="margin-top: 8px; font-size: 10px; color: #ccc; display: none; max-height: 150px; overflow-y: auto;"></div>' +
            '</div>' +

            // History Data Management
            '<div class="twk-mb-15">' +
            '<label style="display: block; margin-bottom: 8px; font-weight: bold; font-size: 13px;">üìú History Data:</label>' +
            '<div id="history-data-list" style="font-size: 11px; color: #ccc; margin-bottom: 8px;"></div>' +
            '<button id="clear-all-history-btn" style="background: #c0392b; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold; width: 100%; margin-top: 8px;">' +
            'üóëÔ∏è Clear All History' +
            '</button>' +
            '</div>' +

            '</div>' + // end left column

            // RIGHT COLUMN - Notifications & Diagnostics
            '<div style="display: flex; flex-direction: column; gap: 15px;">' +

            // Notifications box
            '<div class="twk-panel">' +
            '<h3 style="margin: 0 0 15px 0; color: #4ae29a; text-align: center;">Notifications</h3>' +

            // Telegram Notifications
            '<div class="twk-mb-15">' +
            '<label style="display: block; margin-bottom: 8px; font-weight: bold; font-size: 13px;">üì± Telegram:</label>' +
            '<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">' +
            '<label style="display: flex; align-items: center; cursor: pointer; font-size: 12px;">' +
            '<input type="checkbox" id="telegram-enabled" ' + (localStorage.getItem('hwh_telegram_enabled') === 'true' ? 'checked' : '') + ' style="margin-right: 6px; cursor: pointer;">' +
            '<span>Enable Notifications</span>' +
            '</label>' +
            '</div>' +
            '<div style="margin-bottom: 12px;">' +
            '<label style="display: block; font-size: 11px; color: #ccc; margin-bottom: 3px;">Bot Token:</label>' +
            '<input type="text" id="telegram-token" placeholder="1234567890:ABC..." value="' + (localStorage.getItem('hwh_telegram_token') || '') + '"' +
            ' style="width: 100%; padding: 6px; background: #1a1a1a; color: #ffd700; border: 1px solid #8b6914; border-radius: 3px; font-size: 11px; box-sizing: border-box;">' +
            '</div>' +
            '<div style="margin-bottom: 12px;">' +
            '<label style="display: block; font-size: 11px; color: #ccc; margin-bottom: 3px;">Chat ID:</label>' +
            '<input type="text" id="telegram-chatid" placeholder="123456789" value="' + (localStorage.getItem('hwh_telegram_chatid') || '') + '"' +
            ' style="width: 100%; padding: 6px; background: #1a1a1a; color: #ffd700; border: 1px solid #8b6914; border-radius: 3px; font-size: 11px; box-sizing: border-box;">' +
            '</div>' +
            '<button id="test-telegram-btn" style="background: #3498db; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold; width: 100%;">' +
            'üì± Test Notification' +
            '</button>' +
            '<div style="font-size: 10px; color: #999; line-height: 1.3; margin-top: 8px;">Get bot token from @BotFather<br>Get chat ID from @userinfobot</div>' +
            '</div>' +

            '</div>' + // end Notifications box

            // Diagnostics box
            '<div class="twk-panel">' +
            '<h3 style="margin: 0 0 15px 0; color: #4ae29a; text-align: center;">Diagnostics</h3>' +
            '<button id="show-performance-btn" style="background: #3498db; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold; width: 100%;">' +
            'üìä Show Performance Stats' +
            '</button>' +
            '<div id="performance-display" style="margin-top: 8px; font-size: 11px; color: #ccc; display: none;"></div>' +
            '</div>' + // end Diagnostics box

            '</div>' + // end right column

            '</div>' + // end grid
            '</div>' + // end Data tab content

            // ==================== PREFERENCES TAB CONTENT ====================
            '<div id="tab-content-prefs" class="twk-hidden">' +
            '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">' +

            // LEFT COLUMN - Daily Quest Preferences
            '<div class="twk-panel">' +
            '<h3 style="margin: 0 0 15px 0; color: #4ae29a; text-align: center;">üéØ Daily Quest Preferences</h3>' +

            // Heroic Mission Override
            '<div class="twk-mb-15">' +
            '<label style="display: block; margin-bottom: 8px; font-weight: bold; font-size: 13px;">Heroic Mission Override:</label>' +
            '<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">' +
            '<label style="display: flex; align-items: center; cursor: pointer; font-size: 12px;">' +
            '<input type="checkbox" id="heroic-override-enabled" ' + (localStorage.getItem(HEROIC_OVERRIDE_ENABLED_KEY) === 'true' ? 'checked' : '') + ' style="margin-right: 6px; cursor: pointer;">' +
            '<span>Enable Override</span>' +
            '</label>' +
            '</div>' +
            '<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">' +
            '<label style="min-width: 100px; font-size: 12px;">Mission ID:</label>' +
            '<input type="number" id="heroic-mission-id" min="1" max="500" value="' + (localStorage.getItem(HEROIC_OVERRIDE_MISSION_KEY) || '116') + '"' +
            ' style="width: 70px; padding: 4px; background: #1a1a1a; color: #ffd700; border: 1px solid #8b6914; border-radius: 3px; font-size: 12px;">' +
            '</div>' +
            '<div style="font-size: 10px; color: #999; line-height: 1.3;">Override the heroic mission for daily quest.<br>Default: 116 (Aurora Ch.9)<br>Useful when all heroes are 6‚≠ê</div>' +
            '<button id="test-heroic-btn" style="background: #3498db; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold; width: 100%; margin-top: 10px;">' +
            'üß™ Test Override' +
            '</button>' +
            '</div>' +

            '</div>' + // end left column

            // RIGHT COLUMN - Collect More Preferences
            '<div class="twk-panel">' +
            '<h3 style="margin: 0 0 15px 0; color: #4ae29a; text-align: center;">üì¶ Collect More</h3>' +

            // XP Potion Keep Amount
            '<div class="twk-mb-15">' +
            '<label style="display: block; margin-bottom: 8px; font-weight: bold; font-size: 13px;">üß™ Sell XP Potions:</label>' +
            '<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">' +
            '<label style="min-width: 100px; font-size: 12px;">Keep Huge:</label>' +
            '<input type="number" id="xp-potion-keep" min="0" max="9999" value="' + (localStorage.getItem(XP_POTION_KEEP_KEY) || '484') + '"' +
            ' style="width: 70px; padding: 4px; background: #1a1a1a; color: #ffd700; border: 1px solid #8b6914; border-radius: 3px; font-size: 12px;">' +
            '</div>' +
            '<div style="font-size: 10px; color: #999; line-height: 1.3;">Sells all Small/Medium/Large potions.<br>Keeps this many Huge (libId 12).<br>Default: 484 (for hero 1‚Üí130)</div>' +
            '</div>' +

            '</div>' + // end right column

            '</div>' + // end grid
            '</div>' + // end Preferences tab content

            // Buttons section - all on one row
            '<div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #8b6914;">' +
            '<div style="display: flex; justify-content: space-between; align-items: center; gap: 6px;">' +

            // Left side - Backup/Restore buttons
            '<div style="display: flex; gap: 6px;">' +
            '<button id="backup-download-btn" style="background: #27ae60; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: bold; white-space: nowrap;">' +
            'üíæ Download' +
            '</button>' +
            '<button id="backup-clipboard-btn" style="background: #3498db; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: bold; white-space: nowrap;">' +
            'üìã Copy' +
            '</button>' +
            '<button id="restore-upload-btn" style="background: #e67e22; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: bold; white-space: nowrap;">' +
            'üìÇ Upload' +
            '</button>' +
            '<button id="restore-clipboard-btn" style="background: #9b59b6; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: bold; white-space: nowrap;">' +
            'üìÑ Paste' +
            '</button>' +
            '</div>' +

            // Right side - Close button
            '<button id="close-tweaker-popup" style="background: #8b6914; color: #ffd700; border: none; padding: 6px 20px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold;">Close</button>' +

            '</div>' +
            '</div>' +
            '</div>' +
            '</div>';

        document.body.appendChild(popup);

        // Tab switching logic
        const tabSettings = popup.querySelector('#tab-settings');
        const tabData = popup.querySelector('#tab-data');
        const tabPrefs = popup.querySelector('#tab-prefs');
        const contentSettings = popup.querySelector('#tab-content-settings');
        const contentData = popup.querySelector('#tab-content-data');
        const contentPrefs = popup.querySelector('#tab-content-prefs');

        const switchTab = (activeTab, activeContent, inactiveTabs, inactiveContents) => {
            activeTab.style.background = '#8b6914';
            activeTab.style.color = '#ffd700';
            activeContent.style.display = 'block';
            inactiveTabs.forEach(t => { t.style.background = '#3a2a1a'; t.style.color = '#999'; });
            inactiveContents.forEach(c => { c.style.display = 'none'; });
        };

        tabSettings.onclick = () => switchTab(tabSettings, contentSettings, [tabData, tabPrefs], [contentData, contentPrefs]);
        tabData.onclick = () => switchTab(tabData, contentData, [tabSettings, tabPrefs], [contentSettings, contentPrefs]);
        tabPrefs.onclick = () => switchTab(tabPrefs, contentPrefs, [tabSettings, tabData], [contentSettings, contentData]);

        // Storage report button handler
        const showStorageBtn = popup.querySelector('#show-storage-btn');
        if (showStorageBtn) {
            showStorageBtn.onclick = () => {
                const storageDisplay = document.getElementById('storage-display');
                const formatBytes = (bytes) => {
                    if (bytes < 1024) return bytes + ' B';
                    if (bytes < 1024*1024) return (bytes/1024).toFixed(1) + ' KB';
                    return (bytes/(1024*1024)).toFixed(2) + ' MB';
                };
                const getSize = (val) => new Blob([val || '']).size;

                let totalHWH = 0, totalTweaker = 0, totalOther = 0;
                const largeItems = [];
                const LARGE_THRESHOLD = 1 * 1024; // 1KB

                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    const size = getSize(key) + getSize(localStorage.getItem(key));

                    if (size >= LARGE_THRESHOLD) {
                        largeItems.push({ key, size });
                    }

                    if (key.startsWith('Hero Wars Helper') || key.startsWith('HeroWarsHelper')) totalHWH += size;
                    else if (key.startsWith('hwh_') || key.startsWith('adventureCustomPaths') || key === 'stormCustomPaths') totalTweaker += size;
                    else totalOther += size;
                }

                largeItems.sort((a, b) => b.size - a.size);

                let largeItemsHtml = '';
                if (largeItems.length > 0) {
                    largeItemsHtml = '<div style="border-top: 1px solid #8b6914; margin-top: 8px; padding-top: 8px;">' +
                        '<div style="color: #ffd700; margin-bottom: 5px;"><b>üìã Items (>1KB):</b></div>';
                    largeItems.forEach(item => {
                        const shortKey = item.key.length > 28 ? item.key.substring(0, 25) + '...' : item.key;
                        largeItemsHtml += '<div style="display: flex; justify-content: space-between; font-size: 10px; color: #ccc;">' +
                            '<span title="' + item.key + '">' + shortKey + '</span>' +
                            '<span class="twk-gold">' + formatBytes(item.size) + '</span></div>';
                    });
                    largeItemsHtml += '</div>';
                }

                storageDisplay.innerHTML =
                    '<div style="background: #1a1a1a; padding: 8px; border-radius: 4px; border: 1px solid #8b6914;">' +
                    '<div>üì¶ <b>HWH:</b> ' + formatBytes(totalHWH) + '</div>' +
                    '<div>üîß <b>Tweaker:</b> ' + formatBytes(totalTweaker) + '</div>' +
                    '<div>üìÑ <b>Other:</b> ' + formatBytes(totalOther) + '</div>' +
                    '<div style="border-top: 1px solid #8b6914; margin-top: 5px; padding-top: 5px;"><b>Total:</b> ' + formatBytes(totalHWH + totalTweaker + totalOther) + '</div>' +
                    largeItemsHtml +
                    '</div>';
                storageDisplay.style.display = 'block';
            };
        }

        // History data list and clear buttons
        const historyDataList = popup.querySelector('#history-data-list');
        const clearAllHistoryBtn = popup.querySelector('#clear-all-history-btn');

        // Define history items to track
        const historyItems = [
            { key: 'hwh_power_tournament_history', label: 'üèÜ Tournament', related: ['hwh_power_tournament_clan_cache', 'hwh_tournament_end_time'] },
            { key: 'hwh_grand_battle_history', label: '‚öîÔ∏è Grand Arena', related: [] },
            { key: 'hwh_arena_battle_history', label: 'üèüÔ∏è Arena', related: [] },
            { key: 'hwh_aoc_history', label: 'üè∞ AoC', related: [] },
            { key: 'hwh_winterfest_gift_cache', label: 'üéÑ Winterfest', related: [] }
        ];

        const formatBytes = (bytes) => {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024*1024) return (bytes/1024).toFixed(1) + ' KB';
            return (bytes/(1024*1024)).toFixed(2) + ' MB';
        };

        const refreshHistoryList = () => {
            // Calculate total localStorage usage
            let totalBytes = 0;
            for (let key in localStorage) {
                if (localStorage.hasOwnProperty(key)) {
                    totalBytes += (localStorage[key].length * 2); // UTF-16 = 2 bytes per char
                }
            }
            const totalMB = (totalBytes / (1024 * 1024)).toFixed(2);
            const WARNING_THRESHOLD_MB = 3; // Warn at 3MB (localStorage limit is ~5MB)

            let html = '';

            // Show storage warning if over threshold
            if (totalBytes > WARNING_THRESHOLD_MB * 1024 * 1024) {
                html += '<div style="background: #c0392b; color: #fff; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-size: 11px;">' +
                    '‚ö†Ô∏è <b>Storage Warning:</b> ' + totalMB + ' MB used (limit ~5 MB)<br>' +
                    '<span style="font-size: 10px;">Clear old data to prevent issues</span>' +
                    '</div>';
            } else if (totalBytes > 1 * 1024 * 1024) {
                // Info level at 1MB+
                html += '<div style="background: #8b6914; color: #ffd700; padding: 6px; border-radius: 4px; margin-bottom: 10px; font-size: 10px;">' +
                    'üíæ Storage: ' + totalMB + ' MB used' +
                    '</div>';
            }

            historyItems.forEach((item, index) => {
                const data = localStorage.getItem(item.key);
                const size = data ? new Blob([data]).size : 0;
                if (size > 0) {
                    html += '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; padding: 4px; background: rgba(0,0,0,0.2); border-radius: 3px;">' +
                        '<span>' + item.label + ' <span class="twk-gold">' + formatBytes(size) + '</span></span>' +
                        '<button class="clear-history-btn" data-index="' + index + '" style="background: #c0392b; color: white; border: none; padding: 2px 8px; border-radius: 3px; cursor: pointer; font-size: 10px;">üóëÔ∏è</button>' +
                        '</div>';
                }
            });

            if (!html) {
                html = '<div style="color: #666;">No history data</div>';
            }
            historyDataList.innerHTML = html;

            // Attach click handlers to clear buttons
            historyDataList.querySelectorAll('.clear-history-btn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const idx = parseInt(btn.dataset.index);
                    const item = historyItems[idx];
                    if (confirm('üóëÔ∏è Clear ' + item.label + ' history?')) {
                        localStorage.removeItem(item.key);
                        item.related.forEach(k => localStorage.removeItem(k));
                        refreshHistoryList();
                    }
                };
            });
        };

        refreshHistoryList();

        if (clearAllHistoryBtn) {
            clearAllHistoryBtn.onclick = () => {
                if (confirm('üóëÔ∏è Clear ALL history data?\n\n(Tournament, Grand Arena, Arena, AoC)')) {
                    historyItems.forEach(item => {
                        localStorage.removeItem(item.key);
                        item.related.forEach(k => localStorage.removeItem(k));
                    });
                    refreshHistoryList();
                }
            };
        }

        const checkboxContainer = document.getElementById('checkbox-container');
        const valuesContainer = document.getElementById('values-container');

        // Store moved inputs so we can restore them
        const movedInputs = [];

        // List of checkboxes we want, in order
        const checkboxList = [
            {name: 'passBattle', label: 'Skip battle'},
            {name: 'sendExpedition', label: 'Auto Expedition'},
            {name: 'cancelBattle', label: 'Cancel battle'},
            {name: 'preCalcBattle', label: 'Battle recalculation'},
            {name: 'countControl', label: 'Quantity control'},
            {name: 'repeatMission', label: 'Repeat missions'},
            {name: 'noOfferDonat', label: 'Disable donation'},
            {name: 'dailyQuests', label: 'Quests'},
            {name: 'autoBrawls', label: 'Brawls'},
            {name: 'getAnswer', label: 'AutoQuiz'},
            {name: 'tryFixIt_v2', label: 'Fix it'},
            {name: 'showErrors', label: 'Show errors'},
            {name: 'buyForGold', label: 'Buy for gold'}
        ];

        // CLONE checkboxes
        const settingsDetails = DOMCache.get('settingsDetails', 'details[data-name="settings"]');
        if (settingsDetails) {
            checkboxList.forEach(item => {
                const realCheckbox = settingsDetails.querySelector(`input[type="checkbox"][data-name="${item.name}"]`);
                if (realCheckbox) {
                    const wrapper = document.createElement('label');
                    wrapper.style.cssText = 'display: flex; align-items: center; cursor: pointer; padding: 3px; margin-bottom: 4px; font-size: 12px;';

                    const clonedCheckbox = document.createElement('input');
                    clonedCheckbox.type = 'checkbox';
                    clonedCheckbox.checked = realCheckbox.checked;
                    clonedCheckbox.style.cssText = 'margin-right: 8px; cursor: pointer;';

                    clonedCheckbox.addEventListener('change', function() {
                        debugLog('Clone changed:', item.name, 'from', realCheckbox.checked, 'to', this.checked);
                        realCheckbox.checked = this.checked;
                        const changeEvent = new Event('change', { bubbles: true, cancelable: true });
                        realCheckbox.dispatchEvent(changeEvent);
                        debugLog('‚úì Real checkbox updated:', item.name, '=', realCheckbox.checked);
                    });

                    wrapper.appendChild(clonedCheckbox);
                    const span = document.createElement('span');
                    span.textContent = item.label;
                    wrapper.appendChild(span);
                    checkboxContainer.appendChild(wrapper);
                    debugLog('‚úì Cloned checkbox:', item.name, '=', realCheckbox.checked);
                } else {
                    console.warn('‚úó Checkbox not found:', item.name);
                }
            });
        } else {
            checkboxContainer.innerHTML = '<div style="color: #ff6666; text-align: center; padding: 20px; font-size: 12px;">HWH Settings not found!</div>';
        }

        // List of inputs we want, in order
        const inputList = [
            {name: 'countTitanit', label: 'Titanite:'},
            {name: 'speedBattle', label: 'Speed:'},
            {name: 'countTestBattle', label: 'Test Battle:'},
            {name: 'countAutoBattle', label: 'Auto Battle:'},
            {name: 'FPS', label: 'FPS:'}
        ];

        // MOVE inputs
        const valuesDetails = DOMCache.get('valuesDetails', 'details[data-name="values"]');
        if (valuesDetails) {
            inputList.forEach(item => {
                const input = valuesDetails.querySelector(`input[data-name="${item.name}"]`);
                if (input) {
                    const originalParent = input.parentElement;
                    movedInputs.push({element: input, parent: originalParent});

                    const wrapper = document.createElement('div');
                    const label = document.createElement('label');
                    label.style.cssText = 'display: block; font-size: 11px; color: #ccc; margin-bottom: 5px;';
                    label.textContent = item.label;

                    input.style.cssText = 'width: 80px; padding: 6px; background: #1a1a1a; color: #ffd700; border: 1px solid #8b6914; border-radius: 3px; text-align: center; font-size: 13px;';
                    input.type = 'text';

                    input.addEventListener('wheel', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }, { passive: false });

                    wrapper.appendChild(label);
                    wrapper.appendChild(input);
                    valuesContainer.appendChild(wrapper);
                    debugLog('‚úì Moved input:', item.name, '=', input.value);
                }
            });
        }

        // Delay Factor handler
        const delayInput = document.getElementById('delay-input');
        if (delayInput) {
            delayInput.addEventListener('wheel', function(e) {
                e.preventDefault();
            }, { passive: false });

            delayInput.addEventListener('blur', function() {
                const factor = parseFloat(this.value);
                if (!isNaN(factor) && factor >= 0.1 && factor <= 10.0) {
                    setDelayFactor(factor);
                    debugLog('‚úì Updated delay factor:', factor);
                }
            });
        }

        // Telegram notification handlers
        document.getElementById('telegram-enabled').addEventListener('change', function() {
            localStorage.setItem('hwh_telegram_enabled', this.checked);
            debugLog('Telegram notifications:', this.checked ? 'enabled' : 'disabled');
        });

        document.getElementById('telegram-token').addEventListener('input', function() {
            localStorage.setItem('hwh_telegram_token', this.value.trim());
        });

        document.getElementById('telegram-chatid').addEventListener('input', function() {
            localStorage.setItem('hwh_telegram_chatid', this.value.trim());
        });

        document.getElementById('test-telegram-btn').addEventListener('click', async function() {
            const enabled = document.getElementById('telegram-enabled').checked;
            const token = document.getElementById('telegram-token').value.trim();
            const chatId = document.getElementById('telegram-chatid').value.trim();

            if (!enabled) {
                alert('Please enable Telegram notifications first');
                return;
            }

            if (!token || !chatId) {
                alert('Please enter both Bot Token and Chat ID');
                return;
            }

            try {
                const response = await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        chat_id: chatId,
                        text: 'üè∞ HW Tweaker test notification!\n\nTelegram notifications are working! ‚úÖ'
                    })
                });

                const result = await response.json();
                if (result.ok) {
                    alert('‚úÖ Test notification sent successfully!');
                } else {
                    alert('‚ùå Failed to send: ' + (result.description || 'Unknown error'));
                }
            } catch (error) {
                alert('‚ùå Error: ' + error.message);
            }
        });

        // Arena stats toggle handler
        document.getElementById('arena-stats-enabled').addEventListener('change', function() {
            localStorage.setItem('hwh_arena_stats_enabled', this.checked ? 'true' : 'false');
            debugLog('Arena stats:', this.checked ? 'enabled' : 'disabled', '(reload required)');
        });

        // Debug mode toggle handler
        document.getElementById('debug-mode-enabled').addEventListener('change', function() {
            localStorage.setItem('hwh_debug_mode', this.checked ? 'true' : 'false');
            console.log('üîß Debug mode:', this.checked ? 'enabled' : 'disabled', '(reload required)');
        });

        // Heroic Override handlers
        const heroicOverrideCheckbox = popup.querySelector('#heroic-override-enabled');
        const heroicMissionInput = popup.querySelector('#heroic-mission-id');
        const testHeroicBtn = popup.querySelector('#test-heroic-btn');

        if (heroicOverrideCheckbox) {
            heroicOverrideCheckbox.onchange = () => {
                localStorage.setItem(HEROIC_OVERRIDE_ENABLED_KEY, heroicOverrideCheckbox.checked ? 'true' : 'false');
                debugLog('üéØ Heroic override:', heroicOverrideCheckbox.checked ? 'enabled' : 'disabled');
            };
        }

        if (heroicMissionInput) {
            heroicMissionInput.onchange = () => {
                const val = parseInt(heroicMissionInput.value);
                if (val > 0 && val < 500) {
                    localStorage.setItem(HEROIC_OVERRIDE_MISSION_KEY, val.toString());
                    debugLog('üéØ Heroic mission set to:', val);
                }
            };
        }

        if (testHeroicBtn) {
            testHeroicBtn.onclick = async () => {
                debugLog('üß™ Testing Heroic Mission Selection...');
                const PREFERRED_MISSION = parseInt(localStorage.getItem(HEROIC_OVERRIDE_MISSION_KEY)) || 116;
                const heroNames = {1:'Aurora',2:'Galahad',3:'Keira',4:'Astaroth',6:'Phobos',7:'Thea',8:'Daredevil',9:'Heidi'};

                try {
                    const [missions, heroes, userInfo] = await Caller.send(['missionGetAll', 'heroGetAll', 'userGetInfo']);

                    const available = Object.values(missions).filter(m => m.stars === 3).map(m => m.id);
                    const heroicMissions = Object.values(lib.data.mission).filter(m => m.isHeroic && available.includes(m.id));

                    const drops = heroicMissions.map(m => {
                        const lastWave = m.normalMode.waves[m.normalMode.waves.length - 1];
                        const rewards = lastWave.enemies[lastWave.enemies.length - 1].drop.map(d => d.reward);
                        const heroFragment = rewards.find(r => r.fragmentHero);
                        const heroId = heroFragment ? +Object.keys(heroFragment.fragmentHero)[0] : 0;
                        return { missionId: m.id, heroId, chapter: m.world };
                    });

                    const heroesToUpgrade = Object.values(heroes).filter(h => h.star < 6).sort((a, b) => b.power - a.power);

                    let hwhChoice = null;
                    for (const hero of heroesToUpgrade) {
                        const match = drops.find(d => d.heroId === hero.id);
                        if (match) { hwhChoice = match; break; }
                    }

                    const stamina = userInfo.refillable.find(x => x.id == 1).amount;
                    const missionData = lib.data.mission[PREFERRED_MISSION];
                    const missionStatus = missions[PREFERRED_MISSION];
                    const staminaCost = 3 * missionData.normalMode.teamExp;

                    const hwhText = hwhChoice
                    ? `Mission ${hwhChoice.missionId} (${heroNames[hwhChoice.heroId] || 'Hero '+hwhChoice.heroId} Ch.${hwhChoice.chapter})`
                        : 'Mission 1 (fallback - no heroes under 6‚≠ê)';

                    const overrideWorks = missionStatus?.stars === 3 && stamina >= staminaCost;

                    alert(
                        'üß™ HEROIC MISSION TEST\n\n' +
                        'üìä Heroes under 6‚≠ê: ' + heroesToUpgrade.length + '\n' +
                        '‚ö†Ô∏è HWH would pick: ' + hwhText + '\n\n' +
                        'üéØ Override target: Mission ' + PREFERRED_MISSION + '\n' +
                        '   3-starred: ' + (missionStatus?.stars === 3 ? '‚úÖ Yes' : '‚ùå No') + '\n' +
                        '   Stamina: ' + stamina + '/' + staminaCost + ' ' + (stamina >= staminaCost ? '‚úÖ' : '‚ùå') + '\n\n' +
                        '‚úÖ Override would work: ' + (overrideWorks ? 'YES' : 'NO')
                    );
                } catch (e) {
                    alert('‚ùå Test failed: ' + e.message);
                }
            };
        }

        // XP Potion Keep handler
        const xpPotionKeepInput = popup.querySelector('#xp-potion-keep');
        if (xpPotionKeepInput) {
            xpPotionKeepInput.onchange = () => {
                const val = parseInt(xpPotionKeepInput.value);
                if (!isNaN(val) && val >= 0) {
                    localStorage.setItem(XP_POTION_KEEP_KEY, val.toString());
                    debugLog('üß™ XP potion keep amount set to:', val);
                }
            };
        }

        // Close handler
        const closeDialog = function() {
            const factor = parseFloat(delayInput.value);
            if (!isNaN(factor) && factor >= 0.1 && factor <= 10.0) {
                setDelayFactor(factor);
            }

            movedInputs.forEach(item => {
                if (item.parent && item.element.parentElement !== item.parent) {
                    item.parent.appendChild(item.element);
                }
            });

            popup.remove();
            debugLog('Settings closed');
        };

        const autoRefreshInput = popup.querySelector('#autorefresh-input');
        if (autoRefreshInput) {
            autoRefreshInput.addEventListener('change', (e) => {
                const interval = Math.max(60, Math.min(600, parseInt(e.target.value) || 60));
                localStorage.setItem('hwh_autorefresh_interval', interval.toString());
                debugLog('‚úì Updated auto-refresh interval:', interval, 'seconds');
                autoRefreshInput.value = interval;
            });
        }

        // Backup/Restore button handlers
        const backupDownloadBtn = popup.querySelector('#backup-download-btn');
        if (backupDownloadBtn) {
            backupDownloadBtn.onclick = (e) => {
                e.stopPropagation();
                window.backupTweakerSettings();
            };
        }

        const backupClipboardBtn = popup.querySelector('#backup-clipboard-btn');
        if (backupClipboardBtn) {
            backupClipboardBtn.onclick = (e) => {
                e.stopPropagation();
                window.backupToClipboard();
            };
        }

        const restoreUploadBtn = popup.querySelector('#restore-upload-btn');
        if (restoreUploadBtn) {
            restoreUploadBtn.onclick = (e) => {
                e.stopPropagation();
                if (confirm('‚ö†Ô∏è This will overwrite your current settings.\n\nContinue with restore?')) {
                    window.restoreFromFile();
                }
            };
        }

        const restoreClipboardBtn = popup.querySelector('#restore-clipboard-btn');
        if (restoreClipboardBtn) {
            restoreClipboardBtn.onclick = (e) => {
                e.stopPropagation();
                if (confirm('‚ö†Ô∏è This will overwrite your current settings.\n\nContinue with restore?')) {
                    window.restoreFromClipboard();
                }
            };
        }

        // Performance button handler
        const showPerfBtn = popup.querySelector('#show-performance-btn');
        if (showPerfBtn) {
            showPerfBtn.onclick = (e) => {
                e.stopPropagation();
                const perfDisplay = document.getElementById('performance-display');
                const cacheStats = DOMCache.getStats();
                const moduleStats = ModuleTracker.summary();

                perfDisplay.innerHTML =
                    '<div style="background: #1a1a1a; padding: 10px; border-radius: 4px; border: 1px solid #8b6914;">' +
                    '<div class="twk-mb-5">‚è±Ô∏è <b>Load Time:</b> ' + moduleStats.elapsed + 'ms</div>' +
                    '<div class="twk-mb-5">üì¶ <b>Modules:</b> ' + moduleStats.count + '</div>' +
                    '<div class="twk-mb-5">üóÑÔ∏è <b>Cache Hit Rate:</b> ' + cacheStats.hitRate + '</div>' +
                    '<div class="twk-mb-5">üìù <b>Cached Elements:</b> ' + cacheStats.cacheSize + '</div>' +
                    '<div class="twk-mb-5">üîÑ <b>Cache Hits:</b> ' + cacheStats.hits + '</div>' +
                    '<div>‚ùå <b>Cache Misses:</b> ' + cacheStats.misses + '</div>' +
                    '</div>';
                perfDisplay.style.display = 'block';

                debugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                debugLog('üìä HWH TWEAKER v' + TWEAKER_VERSION + ' PERFORMANCE');
                debugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                debugLog('‚è±Ô∏è  Load Time:', moduleStats.elapsed + 'ms');
                debugLog('üì¶ Modules:', moduleStats.count);
                debugLog('üóÑÔ∏è  Cache Hit Rate:', cacheStats.hitRate);
                debugLog('üìù Cached Elements:', cacheStats.cacheSize);
                debugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            };
        }

        document.getElementById('close-tweaker-popup').onclick = closeDialog;

        popup.onclick = function(e) {
            if (e.target === popup) {
                closeDialog();
            }
        };
    };

    window.showCollectSettings = window.showTweakerSettings;
    window.showButtonSettings = window.showTweakerSettings;



    // ================================================================
    // SECTION 12: MAIN INITIALIZATION
    // ================================================================

    async function initTweaker() {
        debugLog(`Initializing HWH Tweaker v${TWEAKER_VERSION}...`);

        // Weekly storage check
        const STORAGE_CHECK_KEY = 'hwh_last_storage_check';
        const WEEK_MS = 7 * 24 * 60 * 60 * 1000;
        const lastCheck = parseInt(localStorage.getItem(STORAGE_CHECK_KEY)) || 0;

        if (Date.now() - lastCheck > WEEK_MS) {
            let totalBytes = 0;
            for (let key in localStorage) {
                if (localStorage.hasOwnProperty(key)) {
                    totalBytes += (localStorage[key].length * 2);
                }
            }
            const totalMB = (totalBytes / (1024 * 1024)).toFixed(2);
            const WARNING_THRESHOLD_MB = 3;

            if (totalBytes > WARNING_THRESHOLD_MB * 1024 * 1024) {
                console.warn(`‚ö†Ô∏è HWH Tweaker: localStorage at ${totalMB} MB (limit ~5 MB)`);
                setTimeout(() => {
                    if (HWHFuncs?.setProgress) {
                        HWHFuncs.setProgress(`‚ö†Ô∏è Storage: ${totalMB} MB - Clear old data in Settings`, 8000);
                    }
                }, 5000);
            }
            localStorage.setItem(STORAGE_CHECK_KEY, Date.now().toString());
        }

        // Load settings immediately
        window.loadCollectSettings();
        window.loadUISettings();

        // Only register with old system if not already registered
        if (!window.tweakerRegistered) {
            const { addExtentionName } = HWHFuncs;
            addExtentionName('HWH Tweaker', TWEAKER_VERSION, 'AI Assistant (Extension for ZingerY\'s HeroWarsHelper)');
            window.tweakerRegistered = true;
            debugLog('Main registration completed');
        } else {
            debugLog('Already registered, skipping main registration');
        }

        // Registration methods for better detection
        if (HWHData) {
            if (HWHData.extensions) {
                HWHData.extensions = HWHData.extensions || {};
                HWHData.extensions['HWH Tweaker'] = {
                    version: TWEAKER_VERSION,
                    author: 'AI Assistant (Extension for ZingerY\'s HeroWarsHelper)',
                    loaded: true,
                    timestamp: Date.now()
                };
            }

            if (!HWHData.extensionVersions) {
                HWHData.extensionVersions = {};
            }
            HWHData.extensionVersions['HWH Tweaker'] = TWEAKER_VERSION;
        }

        if (typeof window.loadedExtensions === 'undefined') {
            window.loadedExtensions = {};
        }
        window.loadedExtensions['HWH Tweaker'] = {
            version: TWEAKER_VERSION,
            author: 'AI Assistant (Extension for ZingerY\'s HeroWarsHelper)',
            loaded: Date.now()
        };

        debugLog(`HWH Tweaker v${TWEAKER_VERSION} registered with main system`);

        // Checkbox cleanup - immediate, no delay needed
        if (HWHData?.checkboxes) {
            ['buySoulShop', 'autoCollectGuildRewards', 'autoCollectClanPrestige']
                .forEach(name => {
                if (HWHData.checkboxes[name]) {
                    delete HWHData.checkboxes[name];
                    debugLog(`Removed ${name} from HWH Settings`);
                }
            });
        }

        // Run all initialization tasks in parallel
        const parallelTasks = [
            // Adventure extension
            Promise.resolve().then(() => {
                try {
                    initializeAdventureExtension();
                } catch (error) {
                    console.error('Error initializing adventure extension:', error);
                }
            }),

            // Button clickers
            Promise.resolve().then(() => {
                try {
                    initHWHButtonClickers();
                } catch (error) {
                    console.error('Error initializing HWH button clickers:', error);
                }
            }),

            // ToP refresh - no need to wait, Send is already available
            window.refreshPowerTournamentData(false).then(success => {
                if (success) debugLog('‚úÖ Power Tournament data refreshed on load');
            }).catch(e => {
                console.warn('‚ö†Ô∏è Could not refresh ToP data on load:', e.message);
            })
        ];

        // Fire all parallel tasks
        Promise.all(parallelTasks).then(() => {
            debugLog('‚úÖ All parallel initialization complete');
        });

        // Set up hourly ToP refresh interval
        if (!window._topRefreshInterval) {
            window._topRefreshInterval = setInterval(async () => {
                if (document.hidden) return; // Skip if tab hidden
                // Skip if tournament ended
                const endTime = parseInt(localStorage.getItem('hwh_tournament_end_time')) || 0;
                if (endTime && Date.now() > endTime) {
                    debugLog('‚è∏Ô∏è Tournament ended - skipping refresh');
                    return;
                }
                try {
                    debugLog('üîÑ Hourly Power Tournament data refresh...');
                    await window.refreshPowerTournamentData(false);
                } catch (e) {
                    console.warn('‚ö†Ô∏è Hourly ToP refresh failed:', e.message);
                }
            }, 60 * 60 * 1000);
            debugLog('‚è∞ Power Tournament hourly refresh scheduled');
        }
        // === HWH POPUP HOOK ===

        setTimeout(() => {
            if (HWHFuncs && HWHFuncs.popup && HWHFuncs.popup.confirm) {
                if (!HWHFuncs.popup.confirm.__tweaker_hooked__) {
                    const originalConfirm = HWHFuncs.popup.confirm;
                    HWHFuncs.popup.confirm = async function(msg, buttOpt, checkBoxes) {
                        // Tweaker buttons removed - using standalone buttons now
                        return originalConfirm.call(this, msg, buttOpt, checkBoxes);
                    };






                    // Combined Export UI
                    window.exportGameDataWithUI = async function()  {
                        // Remove any existing UI first
                        const existingUI = document.getElementById('export-ui-container');
                        if (existingUI) {
                            existingUI.remove();
                        }

                        // Get last used values
                        const lastServer = localStorage.getItem('hwh_lastRankingServer') ||
                              window.serverId ||
                              lib.data.serverId ||
                              '1';

                        // Create HTML interface
                        const uiHTML = `
    <div id="export-backdrop" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 9999;
    "></div>
    <div id="export-ui" style="
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #1a1a1a;
        border: 2px solid #444;
        padding: 20px;
        border-radius: 10px;
        z-index: 10000;
        box-shadow: 0 4px 20px rgba(0,0,0,0.8);
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        font-family: Arial, sans-serif;
        color: #ccc;
    ">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h2 style="margin: 0; color: #f4e4c1;">üìä Export Game Data</h2>
            <button id="close-x" style="
                background: none;
                border: none;
                font-size: 24px;
                cursor: pointer;
                color: #999;
                padding: 0;
                width: 30px;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 4px;
                transition: all 0.2s;
            " onmouseover="this.style.color='#fff';this.style.background='#333'" onmouseout="this.style.color='#999';this.style.background='none'">√ó</button>
        </div>

        <!-- Export Type Selection -->
        <div style="margin-bottom: 20px;">
            <label class="twk-label">Export Type:</label>
<select id="export-type" style="
    width: 100%;
    padding: 10px;
    background: #2a2a2a;
    border: 1px solid #444;
    color: #ccc;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
">
    <option value="myheroes">ü¶∏ My Heroes</option>
    <option value="rankings">üèÜ Server Rankings</option>
    <option value="myguildwar">‚öîÔ∏è My Guild War Defense</option>
    <option value="allusers">üë• All Top Users (Cross-Server)</option>
    <option value="allguilds">üè∞ All Top Guilds (Cross-Server)</option>
</select>
        </div>

        <!-- My Heroes Options -->
        <div id="myheroes-options" class="export-options">
            <div style="margin-bottom: 15px; padding: 10px; background: #2a2a2a; border-radius: 5px;">
                <p style="margin: 0; color: #999;">This will export all your owned heroes including:</p>
                <ul style="margin: 5px 0 0 20px; color: #999; font-size: 14px;">
                    <li>Hero levels, stars, and power</li>
                    <li>Skills, runes, and artifacts</li>
                    <li>Skins and equipment</li>
                    <li>Analysis fields (max level, stars to max, etc.)</li>
                </ul>
            </div>
        </div>

        <!-- Rankings Options -->
<div id="rankings-options" class="export-options twk-hidden">
            <div class="twk-mb-15">
                <label class="twk-label">Ranking Type:</label>
                <select id="ranking-type" style="
                    width: 100%;
                    padding: 8px;
                    background: #2a2a2a;
                    border: 1px solid #444;
                    color: #ccc;
                    border-radius: 4px;
                ">
                    <option value="all">All Rankings (Single Server Only)</option>
                    <option value="power">Hero Power</option>
                    <option value="titanPower">Titan Power</option>
                    <option value="dungeonFloor">Dungeon Floor</option>
                    <option value="arena">Arena</option>
                    <option value="grand">Grand Arena</option>
                    <option value="clan">Guild Activity</option>
                    <option value="clanDungeon">Guild Titanite</option>
                    <option value="prestige">Guild Prestige</option>
                </select>
            </div>

            <div class="twk-flex-gap10-mb15">
                <div style="flex: 1;">
                    <label class="twk-label">Start Server:</label>
<input type="number" id="server-start" value="${lastServer}" min="1" style="
width: 100%;
padding: 8px;
background: #2a2a2a;
border: 1px solid #444;
color: #ccc;
border-radius: 4px;
">
</div>
<div style="flex: 1;">
    <label class="twk-label">End Server:</label>
<input type="number" id="server-end" value="${lastServer}" min="1" style="
width: 100%;
padding: 8px;
background: #2a2a2a;
border: 1px solid #444;
color: #ccc;
border-radius: 4px;
">
</div>
</div>

<div class="twk-flex-gap10-mb15">
    <div style="flex: 1;">
        <label class="twk-label">Start Rank:</label>
<input type="number" id="rank-start" value="1" min="1" max="50" style="
width: 100%;
padding: 8px;
background: #2a2a2a;
border: 1px solid #444;
color: #ccc;
border-radius: 4px;
">
</div>
<div style="flex: 1;">
    <label class="twk-label">End Rank:</label>
<input type="number" id="rank-end" value="50" min="1" max="50" style="
width: 100%;
padding: 8px;
background: #2a2a2a;
border: 1px solid #444;
color: #ccc;
border-radius: 4px;
">
</div>
</div>
</div>

<!-- My Guild War Options -->
<div id="myguildwar-options" class="export-options twk-hidden">
    <div style="margin-bottom: 15px; padding: 10px; background: #2a2a2a; border-radius: 5px;">
        <p style="margin: 0; color: #999;">This will export your guild's complete war defense setup:</p>
<ul style="margin: 5px 0 0 20px; color: #999; font-size: 14px;">
    <li>All defender positions and slots</li>
<li>Hero teams with power, levels, colors, stars</li>
<li>Titan teams with elements and spirit levels</li>
<li>Pet information and Banner configurations</li>
</ul>
</div>

<div class="twk-mb-15">
    <label class="twk-label">
        <input type="checkbox" id="include-war-details" checked style="margin-right: 5px;">
            Include detailed unit stats
                </label>
</div>
</div>

// Add after the myguildwar-options div:

<!-- All Users Options -->
<div id="allusers-options" class="export-options twk-hidden">
    <div style="margin-bottom: 15px; padding: 10px; background: #2a2a2a; border-radius: 5px;">
        <p style="margin: 0; color: #999;">This will collect all unique users from top 50 of each ranking type:</p>
<ul style="margin: 5px 0 0 20px; color: #999; font-size: 14px;">
    <li>Hero Power, Titan Power, Arena, Grand Arena, Dungeon Floor</li>
<li>Combines data from multiple servers</li>
<li>Includes: Name, Level, Guild info, Avatar, Frame, Last login, Best rankings</li>
<li>One row per unique user with all their data</li>
</ul>
</div>

<div class="twk-flex-gap10-mb15">
    <div style="flex: 1;">
        <label class="twk-label">Start Server:</label>
<input type="number" id="user-server-start" value="1" min="1" style="
width: 100%;
padding: 8px;
background: #2a2a2a;
border: 1px solid #444;
color: #ccc;
border-radius: 4px;
">
</div>
<div style="flex: 1;">
    <label class="twk-label">End Server:</label>
<input type="number" id="user-server-end" value="10" min="1" style="
width: 100%;
padding: 8px;
background: #2a2a2a;
border: 1px solid #444;
color: #ccc;
border-radius: 4px;
">
</div>
</div>
</div>

<!-- All Guilds Options -->
<div id="allguilds-options" class="export-options twk-hidden">
    <div style="margin-bottom: 15px; padding: 10px; background: #2a2a2a; border-radius: 5px;">
        <p style="margin: 0; color: #999;">This will collect all unique guilds from top 50 of each ranking type:</p>
<ul style="margin: 5px 0 0 20px; color: #999; font-size: 14px;">
    <li>Guild Activity, Guild Titanite, Guild Prestige</li>
<li>Combines data from multiple servers</li>
<li>Includes: Name, Icon colors/shapes, Owner, Members, Country, Min level, Best rankings</li>
<li>One row per unique guild with all their data</li>
</ul>
</div>

<div class="twk-flex-gap10-mb15">
    <div style="flex: 1;">
        <label class="twk-label">Start Server:</label>
<input type="number" id="guild-server-start" value="1" min="1" style="
width: 100%;
padding: 8px;
background: #2a2a2a;
border: 1px solid #444;
color: #ccc;
border-radius: 4px;
">
</div>
<div style="flex: 1;">
    <label class="twk-label">End Server:</label>
<input type="number" id="guild-server-end" value="10" min="1" style="
width: 100%;
padding: 8px;
background: #2a2a2a;
border: 1px solid #444;
color: #ccc;
border-radius: 4px;
">
</div>
</div>
</div>

<!-- Common Options -->
<div id="delay-section" style="margin-bottom: 15px; display: none;">
    <label class="twk-label">Delay (seconds):</label>
<input type="number" id="delay" value="0.5" min="0" step="0.1" style="
width: 100%;
padding: 8px;
background: #2a2a2a;
border: 1px solid #444;
color: #ccc;
border-radius: 4px;
">
</div>

<div class="twk-flex-gap10">
    <button id="start-export" style="
flex: 1;
padding: 10px;
background: #4a7c59;
color: white;
border: none;
border-radius: 5px;
cursor: pointer;
font-size: 16px;
font-weight: bold;
transition: all 0.2s;
" onmouseover="this.style.background='#5a8d69'" onmouseout="this.style.background='#4a7c59'">Start Export</button>
<button id="cancel-export" style="
flex: 1;
padding: 10px;
background: #8b4049;
color: white;
border: none;
border-radius: 5px;
cursor: pointer;
font-size: 16px;
font-weight: bold;
transition: all 0.2s;
" onmouseover="this.style.background='#9b5059'" onmouseout="this.style.background='#8b4049'">Cancel</button>
</div>

<div id="progress-area" style="display: none; margin-top: 20px;">
    <div style="background: #2a2a2a; height: 20px; border-radius: 10px; overflow: hidden; border: 1px solid #444;">
        <div id="progress-bar" style="background: #4a7c59; height: 100%; width: 0%; transition: width 0.3s;"></div>
</div>
<div id="progress-text" style="text-align: center; margin-top: 10px; color: #ccc;"></div>
<div id="time-remaining" style="text-align: center; font-size: 12px; color: #999;"></div>
</div>

<div id="result-area" style="display: none; margin-top: 20px; text-align: center;">
    <div id="result-message" style="margin-bottom: 10px; color: #4a7c59; font-weight: bold;"></div>
<button id="copy-button" style="
width: 100%;
padding: 10px;
background: #4a6fa5;
color: white;
border: none;
border-radius: 5px;
cursor: pointer;
font-size: 16px;
margin-bottom: 10px;
font-weight: bold;
transition: all 0.2s;
" onmouseover="this.style.background='#5a7fb5'" onmouseout="this.style.background='#4a6fa5'">üìã Copy to Clipboard</button>
<button id="download-button" style="
width: 100%;
padding: 10px;
background: #b17c3a;
color: white;
border: none;
border-radius: 5px;
cursor: pointer;
font-size: 16px;
margin-bottom: 10px;
font-weight: bold;
transition: all 0.2s;
" onmouseover="this.style.background='#c18c4a'" onmouseout="this.style.background='#b17c3a'">üíæ Download File</button>
<button id="close-button" style="
width: 100%;
padding: 10px;
background: #555;
color: white;
border: none;
border-radius: 5px;
cursor: pointer;
font-size: 16px;
font-weight: bold;
transition: all 0.2s;
" onmouseover="this.style.background='#666'" onmouseout="this.style.background='#555'">Close</button>
</div>
</div>
`;

                        // Add UI to page
                        const uiContainer = document.createElement('div');
                        uiContainer.id = 'export-ui-container';
                        uiContainer.innerHTML = uiHTML;
                        document.body.appendChild(uiContainer);

                        let exportData = '';
                        let fileName = '';
                        let isExporting = false;

                        // Close function
                        const closeUI = () => {
                            if (!isExporting || confirm('Export is in progress. Are you sure you want to close?')) {
                                isExporting = false;
                                uiContainer.remove();
                            }
                        };

                        // Event handlers
                        document.getElementById('cancel-export').onclick = closeUI;
                        document.getElementById('close-x').onclick = closeUI;
                        document.getElementById('export-backdrop').onclick = closeUI;

                        const closeBtn = document.getElementById('close-button');
                        if (closeBtn) closeBtn.onclick = closeUI;

                        // ESC key to close
                        const escHandler = (e) => {
                            if (e.key === 'Escape') closeUI();
                        };
                        document.addEventListener('keydown', escHandler);

                        const originalRemove = uiContainer.remove;
                        uiContainer.remove = function() {
                            document.removeEventListener('keydown', escHandler);
                            originalRemove.call(this);
                        };

                        // In the export type change handler:
                        document.getElementById('export-type').addEventListener('change', function() {
                            // Hide all option sections
                            document.querySelectorAll('.export-options').forEach(el => el.style.display = 'none');

                            // Show selected option section
                            const selectedType = this.value;
                            const optionSection = document.getElementById(selectedType + '-options');
                            if (optionSection) {
                                optionSection.style.display = 'block';
                            }

                            // Show/hide delay section
                            const delaySection = document.getElementById('delay-section');
                            if (selectedType === 'rankings' || selectedType === 'allusers' || selectedType === 'allguilds') {
                                delaySection.style.display = 'block';
                            } else {
                                delaySection.style.display = 'none';
                            }
                        });
                        // Handle ranking type change
                        document.getElementById('ranking-type').addEventListener('change', function() {
                            if (this.value === 'all') {
                                const serverStart = document.getElementById('server-start').value;
                                document.getElementById('server-end').value = serverStart;
                            }
                        });

                        // Validate rank inputs
                        document.getElementById('rank-start').addEventListener('input', function() {
                            if (this.value > 50) this.value = 50;
                            if (this.value < 1) this.value = 1;
                        });

                        document.getElementById('rank-end').addEventListener('input', function() {
                            if (this.value > 50) this.value = 50;
                            if (this.value < 1) this.value = 1;
                        });

                        // Start export handler
                        document.getElementById('start-export').onclick = async () => {
                            if (isExporting) return;

                            const exportType = document.getElementById('export-type').value;

                            isExporting = true;
                            document.getElementById('start-export').disabled = true;
                            document.getElementById('cancel-export').textContent = 'Stop';
                            document.getElementById('progress-area').style.display = 'block';

                            try {
                                switch (exportType) {
                                    case 'myheroes':
                                        await exportMyHeroes();
                                        break;
                                    case 'rankings':
                                        await exportRankings();
                                        break;
                                    case 'myguildwar':
                                        await exportMyGuildWar();
                                        break;
                                    case 'allusers':
                                        // Set fileName globally before calling the function
                                        fileName = `all_top_users_s${document.getElementById('user-server-start').value}-${document.getElementById('user-server-end').value}_${new Date().toISOString().split('T')[0]}.tsv`;

                                        // Call the export function and capture the result
                                        exportData = await exportAllUsers((progress, text, timeRemaining) => {
                                            if (!isExporting) throw new Error('Export cancelled');
                                            document.getElementById('progress-bar').style.width = `${progress}%`;
                                            document.getElementById('progress-text').innerHTML = text;
                                            if (timeRemaining !== null) {
                                                document.getElementById('time-remaining').innerHTML = `Est. time remaining: ${timeRemaining}s`;
                                            }
                                        }, isExporting);
                                        break;
                                    case 'allguilds':
                                        // Set fileName globally before calling the function
                                        fileName = `all_top_guilds_s${document.getElementById('guild-server-start').value}-${document.getElementById('guild-server-end').value}_${new Date().toISOString().split('T')[0]}.tsv`;

                                        // Call the export function and capture the result
                                        exportData = await exportAllGuilds((progress, text, timeRemaining) => {
                                            if (!isExporting) throw new Error('Export cancelled');
                                            document.getElementById('progress-bar').style.width = `${progress}%`;
                                            document.getElementById('progress-text').innerHTML = text;
                                            if (timeRemaining !== null) {
                                                document.getElementById('time-remaining').innerHTML = `Est. time remaining: ${timeRemaining}s`;
                                            }
                                        }, isExporting);
                                        break;
                                }
                                // Show results
                                document.getElementById('progress-area').style.display = 'none';
                                document.getElementById('result-area').style.display = 'block';
                                const entryCount = exportData.split('\n').length - 1;
                                document.getElementById('result-message').innerHTML = `‚úÖ Exported ${entryCount} entries!`;

                                // Hide form controls
                                document.querySelectorAll('#export-ui > div:not(#result-area):not(:first-child)').forEach(el => {
                                    el.style.display = 'none';
                                });

                            } catch (error) {
                                if (error.message !== 'Export cancelled') {
                                    alert(`Export failed: ${error.message}`);
                                }
                                closeUI();
                            }

                            isExporting = false;
                        };

                        // Export My Heroes function
                        async function exportMyHeroes() {
                            document.getElementById('progress-bar').style.width = '50%';
                            document.getElementById('progress-text').innerHTML = 'Fetching hero data...';

                            const SendFunction = getSend();
                            const response = await SendFunction('{"calls":[{"name":"heroGetAll","args":{},"ident":"body"}]}');

                            if (!response?.results?.[0]?.result?.response) {
                                throw new Error('No hero data available!');
                            }

                            document.getElementById('progress-bar').style.width = '100%';
                            document.getElementById('progress-text').innerHTML = 'Processing heroes...';

                            const heroResponse = response.results[0].result.response;
                            const myHeroes = [];
                            const timestamp = new Date().toISOString();
                            const gameData = window.getGameData();

                            Object.entries(heroResponse).forEach(([key, hero]) => {
                                if (hero && hero.id) {
                                    const heroName = window.itemNameCache?.hero?.[hero.id] || `Hero #${hero.id}`;
                                    const heroDefinition = gameData?.hero?.[hero.id];

                                    let gameMaxStar = 6;
                                    if (heroDefinition?.stars) {
                                        const availableStars = Object.keys(heroDefinition.stars).map(Number);
                                        gameMaxStar = Math.max(...availableStars, 6);
                                    }

                                    const flatHero = {
                                        timestamp: timestamp,
                                        id: hero.id,
                                        name: heroName,
                                        level: hero.level || 0,
                                        star: hero.star || 0,
                                        absoluteStar: hero.absoluteStar || 0,
                                        color: hero.color || 0,
                                        power: hero.power || 0,
                                        xp: hero.xp || 0,
                                        characterType: heroDefinition?.characterType || '',
                                        role: heroDefinition?.role || '',
                                        mainStat: heroDefinition?.mainStat || '',
                                        skills: hero.skills ? Object.entries(hero.skills).map(([k,v]) => `${k}:${v}`).join(';') : '',
                                        runes: hero.runes ? hero.runes.join(';') : '',
                                        runeCount: hero.runes ? hero.runes.length : 0,
                                        skins: hero.skins ? Object.keys(hero.skins).join(';') : '',
                                        skinCount: hero.skins ? Object.keys(hero.skins).length : 0,
                                        currentSkin: hero.currentSkin || 'default',
                                        artifacts: hero.artifacts ? hero.artifacts.join(';') : '',
                                        artifactCount: hero.artifacts ? hero.artifacts.length : 0,
                                        slots: hero.slots ? Object.keys(hero.slots).join(';') : '',
                                        slotCount: hero.slots ? Object.keys(hero.slots).length : 0,
                                        titanGiftLevel: hero.titanGiftLevel || 0,
                                        petId: hero.petId || 0,
                                        isMaxLevel: hero.level === 130,
                                        isMaxStar: hero.star === gameMaxStar,
                                        starsToMax: gameMaxStar - hero.star,
                                        canGetMoreStars: hero.star < gameMaxStar
                                    };

                                    myHeroes.push(flatHero);
                                }
                            });

                            myHeroes.sort((a, b) => Number(a.id) - Number(b.id));

                            const headers = Object.keys(myHeroes[0]);
                            exportData = [
                                headers.join('\t'),
                                ...myHeroes.map(hero =>
                                                headers.map(header => {
                                    const value = hero[header];
                                    return value === null || value === undefined ? '' : String(value);
                                }).join('\t')
                                               )
                            ].join('\n');

                            fileName = `my_heroes_${new Date().toISOString().split('T')[0]}.tsv`;
                        }

                        // Export Rankings function
                        async function exportRankings() {
                            const rankingType = document.getElementById('ranking-type').value;
                            const serverStart = parseInt(document.getElementById('server-start').value);
                            const serverEnd = parseInt(document.getElementById('server-end').value);
                            const rankStart = parseInt(document.getElementById('rank-start').value);
                            const rankEnd = parseInt(document.getElementById('rank-end').value);
                            const delaySeconds = parseFloat(document.getElementById('delay').value);

                            localStorage.setItem('hwh_lastRankingServer', serverStart);

                            if (serverEnd < serverStart || rankEnd < rankStart) {
                                throw new Error('Invalid range!');
                            }

                            if (rankingType === 'all' && serverStart !== serverEnd) {
                                document.getElementById('server-end').value = serverStart;
                                throw new Error('All Rankings option requires a single server!');
                            }

                            fileName = `rankings_${rankingType}_s${serverStart}-${serverEnd}_r${rankStart}-${rankEnd}_${new Date().toISOString().split('T')[0]}.tsv`;

                            const rankingTypes = {
                                'power': { name: 'Hero Power', valueField: 'sumPower', isGuild: false },
                                'titanPower': { name: 'Titan Power', valueField: 'sumPower', isGuild: false },
                                'dungeonFloor': { name: 'Dungeon Floor', valueField: 'maxFloorNum', isGuild: false },
                                'arena': { name: 'Arena', valueField: 'sumPower', isGuild: false },
                                'grand': { name: 'Grand Arena', valueField: 'sumPower', isGuild: false },
                                'clan': { name: 'Guild Activity', valueField: 'activity', isGuild: true },
                                'clanDungeon': { name: 'Guild Titanite', valueField: 'dungeonActivity', isGuild: true },
                                'prestige': { name: 'Guild Prestige', valueField: 'score', isGuild: true }
                            };

                            if (rankingType === 'all') {
                                exportData = await exportAllRankingsData({
                                    serverId: serverStart,
                                    rankStart,
                                    rankEnd,
                                    delaySeconds,
                                    onProgress: (progress, text, timeRemaining) => {
                                        if (!isExporting) throw new Error('Export cancelled');
                                        document.getElementById('progress-bar').style.width = `${progress}%`;
                                        document.getElementById('progress-text').innerHTML = text;
                                        if (timeRemaining !== null) {
                                            document.getElementById('time-remaining').innerHTML = `Est. time remaining: ${timeRemaining}s`;
                                        }
                                    }
                                });
                            } else {
                                exportData = await exportRankingsData({
                                    rankingType,
                                    serverStart,
                                    serverEnd,
                                    rankStart,
                                    rankEnd,
                                    delaySeconds,
                                    rankingDef: rankingTypes[rankingType],
                                    onProgress: (progress, text, timeRemaining) => {
                                        if (!isExporting) throw new Error('Export cancelled');
                                        document.getElementById('progress-bar').style.width = `${progress}%`;
                                        document.getElementById('progress-text').innerHTML = text;
                                        if (timeRemaining !== null) {
                                            document.getElementById('time-remaining').innerHTML = `Est. time remaining: ${timeRemaining}s`;
                                        }
                                    }
                                });
                            }
                        }

                        // Export My Guild War function
                        async function exportMyGuildWar() {
                            const includeDetails = document.getElementById('include-war-details').checked;

                            document.getElementById('progress-bar').style.width = '50%';
                            document.getElementById('progress-text').innerHTML = 'Fetching guild war data...';

                            const SendFunction = getSend();
                            const response = await SendFunction(JSON.stringify({
                                calls: [{
                                    name: "clanWarGetDefence",
                                    args: {},
                                    context: {
                                        actionTs: Date.now()
                                    },
                                    ident: "body"
                                }]
                            }));

                            document.getElementById('progress-bar').style.width = '100%';
                            document.getElementById('progress-text').innerHTML = 'Processing data...';

                            if (!response?.results?.[0]?.result?.response) {
                                throw new Error('No war defense data found');
                            }

                            const warData = response.results[0].result.response;
                            exportData = await exportMyGuildWarData(warData, includeDetails);
                            fileName = `my_guild_war_defense_${new Date().toISOString().split('T')[0]}.tsv`;
                        }

                        // Copy button handler
                        document.getElementById('copy-button').onclick = () => {
                            const textarea = document.createElement('textarea');
                            textarea.value = exportData;
                            textarea.style.position = 'fixed';
                            textarea.style.opacity = '0';
                            document.body.appendChild(textarea);
                            textarea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textarea);

                            const btn = document.getElementById('copy-button');
                            btn.innerHTML = '‚úÖ Copied!';
                            setTimeout(() => {
                                if (document.getElementById('copy-button')) {
                                    btn.innerHTML = 'üìã Copy to Clipboard';
                                }
                            }, 2000);
                        };

                        // In the download button handler:
                        document.getElementById('download-button').onclick = () => {
                            const blob = new Blob([exportData], { type: 'text/tab-separated-values;charset=utf-8' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = window.exportFileName || fileName || 'export.tsv'; // Use saved filename
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);

                            const btn = document.getElementById('download-button');
                            btn.innerHTML = '‚úÖ Downloaded!';
                            setTimeout(() => {
                                if (document.getElementById('download-button')) {
                                    btn.innerHTML = 'üíæ Download File';
                                }
                            }, 2000);
                        };
                    }

                    // In the exportRankingsData function, update the part that processes guild rankings:

                    // Updated exportRankingsData function with complete clan data handling:

                    async function exportRankingsData(options) {
                        const {
                            rankingType,
                            serverStart,
                            serverEnd,
                            rankStart,
                            rankEnd,
                            delaySeconds,
                            rankingDef,
                            onProgress
                        } = options;

                        const SendFunction = getSend();
                        const allData = [];
                        const totalServers = serverEnd - serverStart + 1;

                        for (let serverId = serverStart; serverId <= serverEnd; serverId++) {
                            const progress = ((serverId - serverStart) / totalServers) * 100;
                            const serversRemaining = serverEnd - serverId + 1;
                            const timeRemaining = Math.ceil(serversRemaining * delaySeconds);

                            onProgress(
                                progress,
                                `Fetching server ${serverId} of ${serverEnd}...<br>Found: ${allData.length} entries`,
                                timeRemaining
                            );

                            try {
                                const response = await SendFunction(JSON.stringify({
                                    calls: [{
                                        name: "topGet",
                                        args: {
                                            type: rankingType,
                                            extraId: 0,
                                            serverId: serverId
                                        },
                                        context: {
                                            actionTs: Date.now()
                                        },
                                        ident: "body"
                                    }]
                                }));

                                if (response?.results?.[0]?.result?.response?.top) {
                                    const data = response.results[0].result.response;

                                    // Build a clan lookup map - handle different structures
                                    const clanLookup = {};

                                    // For clanDungeon and clan: data.clans is an array
                                    if (data.clans && Array.isArray(data.clans)) {
                                        data.clans.forEach(clan => {
                                            if (clan.id) {
                                                clanLookup[clan.id] = clan;
                                            }
                                        });
                                    }
                                    // For prestige: data.items is an object
                                    else if (data.items && typeof data.items === 'object') {
                                        Object.entries(data.items).forEach(([clanId, clan]) => {
                                            clanLookup[clanId] = clan;
                                        });
                                    }

                                    data.top.forEach((entry, index) => {
                                        const rank = entry.place || (index + 1);
                                        if (rank >= rankStart && rank <= rankEnd) {
                                            if (rankingDef.isGuild) {
                                                // For prestige, clanId is stored in itemId
                                                const clanId = entry.clanId || entry.itemId || entry.id;
                                                const clanInfo = clanLookup[clanId] || {};

                                                // Get the value based on ranking type
                                                let value = 0;
                                                if (rankingType === 'clanDungeon' && entry.dungeonActivity) {
                                                    value = parseInt(entry.dungeonActivity) || 0;
                                                } else if (rankingType === 'prestige' && entry.score) {
                                                    value = parseInt(entry.score) || 0;
                                                } else {
                                                    value = parseInt(entry[rankingDef.valueField] || 0);
                                                }

                                                allData.push({
                                                    Type: rankingDef.name,
                                                    Rank: rank,
                                                    Value: value,
                                                    UserName: '',
                                                    GuildName: clanInfo.title || clanInfo.name || `Guild ${clanId}`,
                                                    UserLevel: '',
                                                    GWLeague: '',
                                                    UserID: '',
                                                    FrameID: '',
                                                    AvatarID: '',
                                                    GuildID: clanId,
                                                    ServerID: serverId,
                                                    LastLoginTime: '',
                                                    TimeStamp: new Date().toISOString(),
                                                    isGuildRanking: 'TRUE'
                                                });
                                            } else {
                                                const userId = entry.userId || entry.id;
                                                const userInfo = data.users?.[userId] || {};

                                                allData.push({
                                                    Type: rankingDef.name,
                                                    Rank: rank,
                                                    Value: parseInt(entry[rankingDef.valueField] || 0),
                                                    UserName: userInfo.name || 'Unknown',
                                                    GuildName: userInfo.clanTitle || '',
                                                    UserLevel: parseInt(userInfo.level || 0),
                                                    GWLeague: userInfo.leagueId || '',
                                                    UserID: userId,
                                                    FrameID: userInfo.frameId || 0,
                                                    AvatarID: userInfo.avatarId || '',
                                                    GuildID: userInfo.clanId || '',
                                                    ServerID: serverId,
                                                    LastLoginTime: userInfo.lastLoginTime ?
                                                    `=((${userInfo.lastLoginTime}/86400)+25569)` : '',
                                                    TimeStamp: new Date().toISOString(),
                                                    isGuildRanking: 'FALSE'
                                                });
                                            }
                                        }
                                    });

                                    debugLog(`‚úì Server ${serverId}: Found ${data.top.length} entries`);
                                }
                            } catch (err) {
                                debugLog(`‚úó Server ${serverId}: Error`, err);
                            }

                            if (serverId < serverEnd) {
                                await new Promise(r => setTimeout(r, delaySeconds * 1000));
                            }
                        }

                        onProgress(100, `Processing ${allData.length} entries...`, 0);

                        if (allData.length === 0) {
                            throw new Error('No data collected!');
                        }

                        const headers = [
                            'Type', 'Rank', 'Value', 'UserName', 'GuildName', 'UserLevel',
                            'GWLeague', 'UserID', 'FrameID', 'AvatarID', 'GuildID',
                            'ServerID', 'LastLoginTime', 'TimeStamp', 'isGuildRanking'
                        ];

                        const delimiter = '\t';
                        const content = [
                            headers.join(delimiter),
                            ...allData.map(row =>
                                           headers.map(header => {
                                const value = row[header];
                                if (value === undefined || value === null) return '';
                                if (typeof value === 'string') {
                                    return value.replace(/\t/g, ' ').replace(/\n/g, ' ');
                                }
                                return value;
                            }).join(delimiter)
                                          )
                        ].join('\n');

                        return content;
                    }

                    // Updated exportAllRankingsData function with complete clan data handling:

                    async function exportAllRankingsData(options) {
                        const {
                            serverId,
                            rankStart,
                            rankEnd,
                            delaySeconds,
                            onProgress
                        } = options;

                        const SendFunction = getSend();
                        const allData = [];
                        const allRankingTypes = [
                            { type: 'power', name: 'Hero Power', valueField: 'sumPower', isGuild: false },
                            { type: 'titanPower', name: 'Titan Power', valueField: 'sumPower', isGuild: false },
                            { type: 'dungeonFloor', name: 'Dungeon Floor', valueField: 'maxFloorNum', isGuild: false },
                            { type: 'arena', name: 'Arena', valueField: 'sumPower', isGuild: false },
                            { type: 'grand', name: 'Grand Arena', valueField: 'sumPower', isGuild: false },
                            { type: 'clan', name: 'Guild Activity', valueField: 'activity', isGuild: true },
                            { type: 'clanDungeon', name: 'Guild Titanite', valueField: 'dungeonActivity', isGuild: true },
                            { type: 'prestige', name: 'Guild Prestige', valueField: 'score', isGuild: true }
                        ];

                        const totalTypes = allRankingTypes.length;

                        for (let i = 0; i < allRankingTypes.length; i++) {
                            const rankingDef = allRankingTypes[i];
                            const progress = (i / totalTypes) * 100;
                            const typesRemaining = totalTypes - i;
                            const timeRemaining = Math.ceil(typesRemaining * delaySeconds);

                            onProgress(
                                progress,
                                `Fetching ${rankingDef.name} rankings...<br>Progress: ${i}/${totalTypes} types<br>Found: ${allData.length} entries`,
                                timeRemaining
                            );

                            try {
                                const response = await SendFunction(JSON.stringify({
                                    calls: [{
                                        name: "topGet",
                                        args: {
                                            type: rankingDef.type,
                                            extraId: 0,
                                            serverId: serverId
                                        },
                                        context: {
                                            actionTs: Date.now()
                                        },
                                        ident: "body"
                                    }]
                                }));

                                if (response?.results?.[0]?.result?.response?.top) {
                                    const data = response.results[0].result.response;

                                    // Build a clan lookup map - handle different structures
                                    const clanLookup = {};

                                    // For clanDungeon and clan: data.clans is an array
                                    if (data.clans && Array.isArray(data.clans)) {
                                        data.clans.forEach(clan => {
                                            if (clan.id) {
                                                clanLookup[clan.id] = clan;
                                            }
                                        });
                                    }
                                    // For prestige: data.items is an object
                                    else if (data.items && typeof data.items === 'object') {
                                        Object.entries(data.items).forEach(([clanId, clan]) => {
                                            clanLookup[clanId] = clan;
                                        });
                                    }

                                    data.top.forEach((entry, index) => {
                                        const rank = entry.place || (index + 1);
                                        if (rank >= rankStart && rank <= rankEnd) {
                                            if (rankingDef.isGuild) {
                                                // For prestige, clanId is stored in itemId
                                                const clanId = entry.clanId || entry.itemId || entry.id;
                                                const clanInfo = clanLookup[clanId] || {};

                                                // Get the value based on ranking type
                                                let value = 0;
                                                if (rankingDef.type === 'clanDungeon' && entry.dungeonActivity) {
                                                    value = parseInt(entry.dungeonActivity) || 0;
                                                } else if (rankingDef.type === 'prestige' && entry.score) {
                                                    value = parseInt(entry.score) || 0;
                                                } else {
                                                    value = parseInt(entry[rankingDef.valueField] || 0);
                                                }

                                                allData.push({
                                                    Type: rankingDef.name,
                                                    Rank: rank,
                                                    Value: value,
                                                    UserName: '',
                                                    GuildName: clanInfo.title || clanInfo.name || `Guild ${clanId}`,
                                                    UserLevel: '',
                                                    GWLeague: '',
                                                    UserID: '',
                                                    FrameID: '',
                                                    AvatarID: '',
                                                    GuildID: clanId,
                                                    ServerID: serverId,
                                                    LastLoginTime: '',
                                                    TimeStamp: new Date().toISOString(),
                                                    isGuildRanking: 'TRUE'
                                                });
                                            } else {
                                                const userId = entry.userId || entry.id;
                                                const userInfo = data.users?.[userId] || {};

                                                allData.push({
                                                    Type: rankingDef.name,
                                                    Rank: rank,
                                                    Value: parseInt(entry[rankingDef.valueField] || 0),
                                                    UserName: userInfo.name || 'Unknown',
                                                    GuildName: userInfo.clanTitle || '',
                                                    UserLevel: parseInt(userInfo.level || 0),
                                                    GWLeague: userInfo.leagueId || '',
                                                    UserID: userId,
                                                    FrameID: userInfo.frameId || 0,
                                                    AvatarID: userInfo.avatarId || '',
                                                    GuildID: userInfo.clanId || '',
                                                    ServerID: serverId,
                                                    LastLoginTime: userInfo.lastLoginTime ?
                                                    `=((${userInfo.lastLoginTime}/86400)+25569)` : '',
                                                    TimeStamp: new Date().toISOString(),
                                                    isGuildRanking: 'FALSE'
                                                });
                                            }
                                        }
                                    });

                                    debugLog(`‚úì ${rankingDef.name}: Found ${data.top.length} entries`);
                                }
                            } catch (err) {
                                debugLog(`‚úó ${rankingDef.name}: Error`, err);
                            }

                            if (i < allRankingTypes.length - 1) {
                                await new Promise(r => setTimeout(r, delaySeconds * 1000));
                            }
                        }

                        onProgress(100, `Processing ${allData.length} entries...`, 0);

                        if (allData.length === 0) {
                            throw new Error('No data collected!');
                        }

                        const headers = [
                            'Type', 'Rank', 'Value', 'UserName', 'GuildName', 'UserLevel',
                            'GWLeague', 'UserID', 'FrameID', 'AvatarID', 'GuildID',
                            'ServerID', 'LastLoginTime', 'TimeStamp', 'isGuildRanking'
                        ];

                        const delimiter = '\t';
                        const content = [
                            headers.join(delimiter),
                            ...allData.map(row =>
                                           headers.map(header => {
                                const value = row[header];
                                if (value === undefined || value === null) return '';
                                if (typeof value === 'string') {
                                    return value.replace(/\t/g, ' ').replace(/\n/g, ' ');
                                }
                                return value;
                            }).join(delimiter)
                                          )
                        ].join('\n');

                        return content;
                    }

                    async function exportMyGuildWarData(warData, includeDetails) {
                        const allData = [];
                        const teams = warData.teams || {};
                        const warriors = warData.warriors || {};
                        const slots = warData.slots || {};
                        const league = warData.league || 0;

                        // Create a reverse mapping of userId to slots
                        const userToSlots = {};
                        for (const [slot, userId] of Object.entries(slots)) {
                            if (!userToSlots[userId]) {
                                userToSlots[userId] = [];
                            }
                            userToSlots[userId].push(parseInt(slot));
                        }

                        // Process ALL teams (not just those in slots)
                        for (const [userId, teamData] of Object.entries(teams)) {
                            if (!teamData) continue;

                            const isChampion = warriors[userId] === 1;
                            const assignedSlots = userToSlots[userId] || [];
                            const slotsString = assignedSlots.length > 0 ? assignedSlots.sort((a, b) => a - b).join(',') : 'BACKUP';

                            // Hero defense
                            if (teamData.clanDefence_heroes?.units) {
                                const heroes = Object.values(teamData.clanDefence_heroes.units);
                                const heroUnits = heroes.filter(u => u.type !== 'pet');
                                const pet = heroes.find(u => u.type === 'pet');
                                const banner = teamData.clanDefence_heroes.banner;
                                const totalPower = heroes.reduce((sum, unit) => sum + (unit.power || 0), 0);

                                const row = {
                                    timestamp: new Date().toISOString(),
                                    userId: userId,
                                    slots: slotsString,
                                    slotCount: assignedSlots.length,
                                    isChampion: isChampion ? 'YES' : 'NO',
                                    isBackup: assignedSlots.length === 0 ? 'YES' : 'NO',
                                    defenseType: 'Heroes',
                                    totalPower: totalPower,
                                    bannerId: banner?.id || '',
                                    bannerSlots: banner?.slots ? (Array.isArray(banner.slots) ? banner.slots.join(',') : Object.values(banner.slots).join(',')) : ''
                                };

                                // Add hero details
                                heroUnits.forEach((hero, idx) => {
                                    row[`hero${idx+1}Id`] = hero.id || '';
                                    row[`hero${idx+1}Power`] = hero.power || '';
                                    row[`hero${idx+1}Level`] = hero.level || '';
                                    row[`hero${idx+1}Color`] = hero.color || '';
                                    row[`hero${idx+1}Star`] = hero.star || '';

                                    if (includeDetails) {
                                        row[`hero${idx+1}Skills`] = hero.skills ? Object.keys(hero.skills).join(',') : '';
                                        row[`hero${idx+1}Artifacts`] = hero.artifacts ? Object.keys(hero.artifacts).join(',') : '';
                                    }
                                });

                                // Fill empty hero slots
                                for (let i = heroUnits.length; i < 5; i++) {
                                    row[`hero${i+1}Id`] = '';
                                    row[`hero${i+1}Power`] = '';
                                    row[`hero${i+1}Level`] = '';
                                    row[`hero${i+1}Color`] = '';
                                    row[`hero${i+1}Star`] = '';
                                    if (includeDetails) {
                                        row[`hero${i+1}Skills`] = '';
                                        row[`hero${i+1}Artifacts`] = '';
                                    }
                                }

                                // Add pet details
                                row['petId'] = pet?.id || '';
                                row['petPower'] = pet?.power || '';
                                row['petLevel'] = pet?.level || '';
                                row['petColor'] = pet?.color || '';
                                row['petStar'] = pet?.star || '';

                                allData.push(row);
                            }

                            // Titan defense
                            if (teamData.clanDefence_titans?.units) {
                                const titans = Object.values(teamData.clanDefence_titans.units);
                                const totalPower = titans.reduce((sum, unit) => sum + (unit.power || 0), 0);

                                const row = {
                                    timestamp: new Date().toISOString(),
                                    userId: userId,
                                    slots: slotsString,
                                    slotCount: assignedSlots.length,
                                    isChampion: isChampion ? 'YES' : 'NO',
                                    isBackup: assignedSlots.length === 0 ? 'YES' : 'NO',
                                    defenseType: 'Titans',
                                    totalPower: totalPower,
                                    bannerId: '',
                                    bannerSlots: ''
                                };

                                // Add titan details
                                titans.forEach((titan, idx) => {
                                    row[`titan${idx+1}Id`] = titan.id || '';
                                    row[`titan${idx+1}Power`] = titan.power || '';
                                    row[`titan${idx+1}Level`] = titan.level || '';
                                    row[`titan${idx+1}Star`] = titan.star || '';
                                    row[`titan${idx+1}Element`] = titan.element || '';
                                    row[`titan${idx+1}ElementLevel`] = titan.elementSpiritLevel || '';
                                    row[`titan${idx+1}ElementStar`] = titan.elementSpiritStar || '';

                                    if (includeDetails) {
                                        row[`titan${idx+1}Artifacts`] = titan.artifacts ? Object.keys(titan.artifacts).join(',') : '';
                                    }
                                });

                                // Fill empty titan slots
                                for (let i = titans.length; i < 5; i++) {
                                    row[`titan${i+1}Id`] = '';
                                    row[`titan${i+1}Power`] = '';
                                    row[`titan${i+1}Level`] = '';
                                    row[`titan${i+1}Star`] = '';
                                    row[`titan${i+1}Element`] = '';
                                    row[`titan${i+1}ElementLevel`] = '';
                                    row[`titan${i+1}ElementStar`] = '';
                                    if (includeDetails) {
                                        row[`titan${i+1}Artifacts`] = '';
                                    }
                                }

                                allData.push(row);
                            }
                        }

                        // Sort by: active defenders first, then backups, then by userId
                        allData.sort((a, b) => {
                            // Active defenders before backups
                            if (a.isBackup !== b.isBackup) {
                                return a.isBackup === 'YES' ? 1 : -1;
                            }
                            // Then by userId
                            if (a.userId !== b.userId) {
                                return parseInt(a.userId) - parseInt(b.userId);
                            }
                            // Then by defense type
                            return a.defenseType.localeCompare(b.defenseType);
                        });

                        // Create headers dynamically based on defense type
                        let headers = ['Timestamp', 'UserID', 'Slots', 'SlotCount', 'IsChampion', 'IsBackup', 'DefenseType', 'TotalPower', 'BannerId', 'BannerSlots'];

                        // Add unit-specific headers
                        const hasHeroes = allData.some(row => row.defenseType === 'Heroes');
                        const hasTitans = allData.some(row => row.defenseType === 'Titans');

                        if (hasHeroes) {
                            for (let i = 1; i <= 5; i++) {
                                headers.push(`Hero${i}Id`, `Hero${i}Power`, `Hero${i}Level`, `Hero${i}Color`, `Hero${i}Star`);
                                if (includeDetails) {
                                    headers.push(`Hero${i}Skills`, `Hero${i}Artifacts`);
                                }
                            }
                            headers.push('PetId', 'PetPower', 'PetLevel', 'PetColor', 'PetStar');
                        }

                        if (hasTitans) {
                            for (let i = 1; i <= 5; i++) {
                                headers.push(`Titan${i}Id`, `Titan${i}Power`, `Titan${i}Level`, `Titan${i}Star`,
                                             `Titan${i}Element`, `Titan${i}ElementLevel`, `Titan${i}ElementStar`);
                                if (includeDetails) {
                                    headers.push(`Titan${i}Artifacts`);
                                }
                            }
                        }

                        const rows = [headers.join('\t')];

                        // Add data rows with fixed UserID mapping
                        allData.forEach(row => {
                            const values = headers.map(header => {
                                // Special case for UserID
                                if (header === 'UserID') {
                                    return row['userId'] !== undefined ? row['userId'] : '';
                                }
                                // Special case for Slots
                                if (header === 'Slots') {
                                    return row['slots'] !== undefined ? row['slots'] : '';
                                }
                                // Special case for SlotCount
                                if (header === 'SlotCount') {
                                    return row['slotCount'] !== undefined ? row['slotCount'] : '';
                                }
                                // Special case for IsChampion
                                if (header === 'IsChampion') {
                                    return row['isChampion'] !== undefined ? row['isChampion'] : '';
                                }
                                // Special case for IsBackup
                                if (header === 'IsBackup') {
                                    return row['isBackup'] !== undefined ? row['isBackup'] : '';
                                }
                                // For other headers, lowercase the first character
                                const key = header.charAt(0).toLowerCase() + header.slice(1);
                                return row[key] !== undefined ? row[key] : '';
                            });
                            rows.push(values.join('\t'));
                        });

                        return rows.join('\n');
                    }
                    // Export All Users function - WITH PROGRESSIVE SORTING
                    async function exportAllUsers(onProgress, isExportingRef) {
                        const serverStart = parseInt(document.getElementById('user-server-start').value);
                        const serverEnd = parseInt(document.getElementById('user-server-end').value);
                        const delaySeconds = parseFloat(document.getElementById('delay').value);

                        if (serverEnd < serverStart) {
                            throw new Error('Invalid server range!');
                        }

                        const SendFunction = getSend();
                        const allUsers = [];
                        const globalUserMap = new Map();

                        const rankingTypes = [
                            { type: 'power', name: 'Hero Power' },
                            { type: 'titanPower', name: 'Titan Power' },
                            { type: 'arena', name: 'Arena' },
                            { type: 'grand', name: 'Grand Arena' },
                            { type: 'dungeonFloor', name: 'Dungeon Floor' }
                        ];

                        const totalRequests = (serverEnd - serverStart + 1) * rankingTypes.length;
                        let completedRequests = 0;

                        for (let serverId = serverStart; serverId <= serverEnd && isExportingRef; serverId++) {
                            const serverUserMap = new Map();

                            for (const ranking of rankingTypes) {
                                if (!isExportingRef) break;

                                const progress = (completedRequests / totalRequests) * 100;
                                const timeRemaining = Math.ceil((totalRequests - completedRequests) * delaySeconds);

                                onProgress(
                                    progress,
                                    `Server ${serverId}/${serverEnd} - ${ranking.name}<br>Server users: ${serverUserMap.size} | Total unique users: ${globalUserMap.size}`,
                                    timeRemaining
                                );

                                try {
                                    const response = await SendFunction(JSON.stringify({
                                        calls: [{
                                            name: "topGet",
                                            args: {
                                                type: ranking.type,
                                                extraId: 0,
                                                serverId: serverId
                                            },
                                            context: { actionTs: Date.now() },
                                            ident: "body"
                                        }]
                                    }));

                                    if (response?.results?.[0]?.result?.response?.top) {
                                        const data = response.results[0].result.response;

                                        data.top.slice(0, 50).forEach((entry, index) => {
                                            const userId = entry.userId || entry.id;
                                            const userInfo = data.users?.[userId];

                                            if (userInfo) {
                                                if (!globalUserMap.has(userId)) {
                                                    const userData = {
                                                        rankings: {},
                                                        servers: new Set([serverId]),
                                                        userData: {
                                                            id: userId,
                                                            name: userInfo.name || 'Unknown',
                                                            level: parseInt(userInfo.level || 0),
                                                            clanId: userInfo.clanId || '',
                                                            clanTitle: userInfo.clanTitle || '',
                                                            clanRole: userInfo.clanRole || '',
                                                            clanIcon: userInfo.clanIcon || {},
                                                            avatarId: userInfo.avatarId || '',
                                                            frameId: userInfo.frameId || 0,
                                                            commander: userInfo.commander ? 'YES' : 'NO',
                                                            leagueId: userInfo.leagueId || '',
                                                            lastLoginTime: userInfo.lastLoginTime || '',
                                                            isChatModerator: userInfo.isChatModerator ? 'YES' : 'NO',
                                                            allowPm: userInfo.allowPm || '',
                                                            mainServer: userInfo.serverId || serverId
                                                        }
                                                    };

                                                    userData.rankings[ranking.type] = {
                                                        rank: entry.place || (index + 1),
                                                        value: parseInt(entry.sumPower || entry.maxFloorNum || 0),
                                                        server: serverId
                                                    };

                                                    serverUserMap.set(userId, userData);
                                                    globalUserMap.set(userId, userData);
                                                } else {
                                                    const existingUser = globalUserMap.get(userId);
                                                    existingUser.servers.add(serverId);
                                                    existingUser.rankings[ranking.type] = {
                                                        rank: entry.place || (index + 1),
                                                        value: parseInt(entry.sumPower || entry.maxFloorNum || 0),
                                                        server: serverId
                                                    };

                                                    if (!serverUserMap.has(userId)) {
                                                        serverUserMap.set(userId, existingUser);
                                                    }
                                                }
                                            }
                                        });
                                    }

                                    completedRequests++;
                                } catch (err) {
                                    debugLog(`Error fetching ${ranking.name} for server ${serverId}:`, err);
                                    completedRequests++;
                                }

                                if (completedRequests < totalRequests) {
                                    await new Promise(r => setTimeout(r, delaySeconds * 1000));
                                }
                            }

                            const serverUsers = Array.from(serverUserMap.values());
                            serverUsers.sort((a, b) => {
                                const powerA = a.rankings.power?.value || 0;
                                const powerB = b.rankings.power?.value || 0;
                                return powerB - powerA;
                            });

                            serverUsers.forEach(userData => {
                                const user = userData.userData;
                                const rankings = userData.rankings;

                                allUsers.push({
                                    UserID: user.id,
                                    Name: user.name,
                                    Level: user.level,
                                    MainServer: user.mainServer,
                                    CurrentProcessingServer: serverId,
                                    ServersFound: Array.from(userData.servers).sort((a,b) => a-b).join(','),
                                    ServerCount: userData.servers.size,
                                    HeroPowerRank: rankings.power?.rank || '',
                                    HeroPowerValue: rankings.power?.value || '',
                                    HeroPowerServer: rankings.power?.server || '',
                                    TitanPowerRank: rankings.titanPower?.rank || '',
                                    TitanPowerValue: rankings.titanPower?.value || '',
                                    TitanPowerServer: rankings.titanPower?.server || '',
                                    ArenaRank: rankings.arena?.rank || '',
                                    ArenaValue: rankings.arena?.value || '',
                                    ArenaServer: rankings.arena?.server || '',
                                    GrandArenaRank: rankings.grand?.rank || '',
                                    GrandArenaValue: rankings.grand?.value || '',
                                    GrandArenaServer: rankings.grand?.server || '',
                                    DungeonFloorRank: rankings.dungeonFloor?.rank || '',
                                    DungeonFloorValue: rankings.dungeonFloor?.value || '',
                                    DungeonFloorServer: rankings.dungeonFloor?.server || '',
                                    GuildID: user.clanId,
                                    GuildName: user.clanTitle,
                                    GuildRole: user.clanRole,
                                    GuildFlagColor1: user.clanIcon.flagColor1 !== undefined ? user.clanIcon.flagColor1 : '',
                                    GuildFlagColor2: user.clanIcon.flagColor2 !== undefined ? user.clanIcon.flagColor2 : '',
                                    GuildFlagShape: user.clanIcon.flagShape !== undefined ? user.clanIcon.flagShape : '',
                                    GuildIconColor: user.clanIcon.iconColor !== undefined ? user.clanIcon.iconColor : '',
                                    GuildIconShape: user.clanIcon.iconShape !== undefined ? user.clanIcon.iconShape : '',
                                    AvatarID: user.avatarId,
                                    FrameID: user.frameId,
                                    Commander: user.commander,
                                    LeagueID: user.leagueId,
                                    ChatModerator: user.isChatModerator,
                                    AllowPM: user.allowPm,
                                    LastLoginTime: user.lastLoginTime ? `=((${user.lastLoginTime}/86400)+25569)` : '',
                                    TimeStamp: new Date().toISOString()
                                });
                            });
                        }

                        onProgress(100, `Finalizing ${allUsers.length} users...`, 0);

                        const headers = Object.keys(allUsers[0] || {});
                        return [
                            headers.join('\t'),
                            ...allUsers.map(user =>
                                            headers.map(header => {
                                const value = user[header];
                                return value === null || value === undefined ? '' : String(value);
                            }).join('\t')
                                           )
                        ].join('\n');
                    }
                    // Export All Guilds function - WITH PROGRESSIVE SORTING
                    async function exportAllGuilds(onProgress, isExportingRef) {
                        const serverStart = parseInt(document.getElementById('guild-server-start').value);
                        const serverEnd = parseInt(document.getElementById('guild-server-end').value);
                        const delaySeconds = parseFloat(document.getElementById('delay').value);

                        if (serverEnd < serverStart) {
                            throw new Error('Invalid server range!');
                        }

                        // Set the filename in the parent scope
                        window.exportFileName = `all_top_guilds_s${serverStart}-${serverEnd}_${new Date().toISOString().split('T')[0]}.tsv`;

                        const SendFunction = getSend();

                        // Build the final array progressively
                        const allGuilds = [];
                        const globalGuildMap = new Map(); // Track unique guilds across all servers

                        const rankingTypes = [
                            { type: 'clan', name: 'Guild Activity' },
                            { type: 'clanDungeon', name: 'Guild Titanite' },
                            { type: 'prestige', name: 'Guild Prestige' }
                        ];

                        const totalRequests = (serverEnd - serverStart + 1) * rankingTypes.length;
                        let completedRequests = 0;

                        // Process each server completely before moving to next
                        for (let serverId = serverStart; serverId <= serverEnd && isExportingRef; serverId++) {
                            const serverGuildMap = new Map(); // Guilds for this specific server

                            // Collect all rankings for this server
                            for (const ranking of rankingTypes) {
                                if (!isExportingRef) break;

                                const progress = (completedRequests / totalRequests) * 100;
                                const timeRemaining = Math.ceil((totalRequests - completedRequests) * delaySeconds);

                                onProgress(
                                    progress,
                                    `Server ${serverId}/${serverEnd} - ${ranking.name}<br>Server guilds: ${serverGuildMap.size} | Total unique guilds: ${globalGuildMap.size}`,
                                    timeRemaining
                                );

                                try {
                                    const response = await SendFunction(JSON.stringify({
                                        calls: [{
                                            name: "topGet",
                                            args: {
                                                type: ranking.type,
                                                extraId: 0,
                                                serverId: serverId
                                            },
                                            context: { actionTs: Date.now() },
                                            ident: "body"
                                        }]
                                    }));

                                    if (response?.results?.[0]?.result?.response?.top) {
                                        const data = response.results[0].result.response;

                                        // Build clan lookup
                                        const clanLookup = {};
                                        if (data.clans && Array.isArray(data.clans)) {
                                            data.clans.forEach(clan => {
                                                if (clan.id) {
                                                    clanLookup[clan.id] = clan;
                                                }
                                            });
                                        } else if (data.items && typeof data.items === 'object') {
                                            Object.entries(data.items).forEach(([clanId, clan]) => {
                                                clanLookup[clanId] = clan;
                                            });
                                        }

                                        // Process top 50 guilds
                                        data.top.slice(0, 50).forEach((entry, index) => {
                                            const clanId = entry.clanId || entry.itemId || entry.id;
                                            const clanInfo = clanLookup[clanId];

                                            if (clanInfo) {
                                                // Get value based on ranking type
                                                let value = 0;
                                                if (ranking.type === 'clanDungeon' && entry.dungeonActivity) {
                                                    value = parseInt(entry.dungeonActivity) || 0;
                                                } else if (ranking.type === 'prestige' && entry.score) {
                                                    value = parseInt(entry.score) || 0;
                                                } else if (entry.activity) {
                                                    value = parseInt(entry.activity) || 0;
                                                }

                                                // Check if we've seen this guild globally
                                                if (!globalGuildMap.has(clanId)) {
                                                    // New guild - add to both maps
                                                    const icon = clanInfo.icon || {};
                                                    const guildData = {
                                                        rankings: {},
                                                        servers: new Set([serverId]),
                                                        guildData: {
                                                            id: clanId,
                                                            name: clanInfo.title || clanInfo.name || 'Unknown Guild',
                                                            ownerId: clanInfo.ownerId || '',
                                                            level: clanInfo.level || '',
                                                            description: clanInfo.description || '',
                                                            country: clanInfo.country || '',
                                                            minLevel: clanInfo.minLevel || '',
                                                            homeServer: clanInfo.serverId || serverId,
                                                            membersCount: clanInfo.membersCount || '',
                                                            disbanding: clanInfo.disbanding ? 'YES' : 'NO',
                                                            topActivity: clanInfo.topActivity || '',
                                                            topDungeon: clanInfo.topDungeon || '',
                                                            frameId: clanInfo.frameId || '',
                                                            flagColor1: icon.flagColor1 !== undefined ? icon.flagColor1 : '',
                                                            flagColor2: icon.flagColor2 !== undefined ? icon.flagColor2 : '',
                                                            flagShape: icon.flagShape !== undefined ? icon.flagShape : '',
                                                            iconColor: icon.iconColor !== undefined ? icon.iconColor : '',
                                                            iconShape: icon.iconShape !== undefined ? icon.iconShape : '',
                                                            iconFrame: icon.frame !== undefined ? icon.frame : '',
                                                            roleNames: clanInfo.roleNames || {}
                                                        }
                                                    };

                                                    guildData.rankings[ranking.type] = {
                                                        rank: entry.place || (index + 1),
                                                        value: value,
                                                        server: serverId
                                                    };

                                                    serverGuildMap.set(clanId, guildData);
                                                    globalGuildMap.set(clanId, guildData);
                                                } else {
                                                    // Existing guild - update their rankings
                                                    const existingGuild = globalGuildMap.get(clanId);
                                                    existingGuild.servers.add(serverId);
                                                    existingGuild.rankings[ranking.type] = {
                                                        rank: entry.place || (index + 1),
                                                        value: value,
                                                        server: serverId
                                                    };

                                                    // Also add to this server's map if not already there
                                                    if (!serverGuildMap.has(clanId)) {
                                                        serverGuildMap.set(clanId, existingGuild);
                                                    }
                                                }
                                            }
                                        });
                                    }

                                    completedRequests++;
                                } catch (err) {
                                    debugLog(`Error fetching ${ranking.name} for server ${serverId}:`, err);
                                    completedRequests++;
                                }

                                if (completedRequests < totalRequests) {
                                    await new Promise(r => setTimeout(r, delaySeconds * 1000));
                                }
                            }

                            // Process this server's guilds and add to results
                            const serverGuilds = Array.from(serverGuildMap.values());

                            // Sort by Guild Activity for this server
                            serverGuilds.sort((a, b) => {
                                const activityA = a.rankings.clan?.value || 0;
                                const activityB = b.rankings.clan?.value || 0;
                                return activityB - activityA;
                            });

                            // Convert to final format and add to results
                            serverGuilds.forEach(guildData => {
                                const guild = guildData.guildData;
                                const rankings = guildData.rankings;
                                const roles = guild.roleNames;

                                allGuilds.push({
                                    GuildID: guild.id,
                                    Name: guild.name,
                                    Level: guild.level,
                                    HomeServer: guild.homeServer,
                                    CurrentProcessingServer: serverId,
                                    ServersFound: Array.from(guildData.servers).sort((a,b) => a-b).join(','),
                                    ServerCount: guildData.servers.size,

                                    // Rankings
                                    ActivityRank: rankings.clan?.rank || '',
                                    ActivityValue: rankings.clan?.value || '',
                                    ActivityServer: rankings.clan?.server || '',

                                    TitaniteRank: rankings.clanDungeon?.rank || '',
                                    TitaniteValue: rankings.clanDungeon?.value || '',
                                    TitaniteServer: rankings.clanDungeon?.server || '',

                                    PrestigeRank: rankings.prestige?.rank || '',
                                    PrestigeValue: rankings.prestige?.value || '',
                                    PrestigeServer: rankings.prestige?.server || '',

                                    // Guild details
                                    OwnerID: guild.ownerId,
                                    Description: guild.description.replace(/\n/g, ' '),
                                    Country: guild.country,
                                    MinLevel: guild.minLevel,
                                    MembersCount: guild.membersCount,
                                    Disbanding: guild.disbanding,
                                    TopActivity: guild.topActivity,
                                    TopDungeon: guild.topDungeon,
                                    FrameID: guild.frameId,

                                    // Icon details
                                    FlagColor1: guild.flagColor1,
                                    FlagColor2: guild.flagColor2,
                                    FlagShape: guild.flagShape,
                                    IconColor: guild.iconColor,
                                    IconShape: guild.iconShape,
                                    IconFrame: guild.iconFrame,

                                    // Custom role names
                                    RoleOwner: roles.owner || '',
                                    RoleOfficer: roles.officer || '',
                                    RoleMember: roles.member || '',
                                    RoleWarlord: roles.warlord || '',

                                    TimeStamp: new Date().toISOString()
                                });
                            });
                        }

                        onProgress(100, `Finalizing ${allGuilds.length} guilds...`, 0);

                        // Create TSV content
                        const headers = Object.keys(allGuilds[0] || {});
                        return [
                            headers.join('\t'),
                            ...allGuilds.map(guild =>
                                             headers.map(header => {
                                const value = guild[header];
                                return value === null || value === undefined ? '' : String(value);
                            }).join('\t')
                                            )
                        ].join('\n');
                    }

                    // ================================================================
                    // WINTERFEST GIFT TRACKER
                    // ================================================================

                    window.showWinterfestGifts = async function() {
                        debugLog('üéÑ Loading Winterfest gift data...');

                        const GIFT_TYPES = {
                            1: { name: 'Upgrade', coinId: 16, cost: 1000, pts: 4, bp: 50 },
                            2: { name: 'Pet', coinId: 16, cost: 2000, pts: 8, bp: 100 },
                            3: { name: 'Ascension', coinId: 16, cost: 5000, pts: 20, bp: 250 },
                            4: { name: 'Skin', coinId: 16, cost: 20000, pts: 80, bp: 1000 },
                            5: { name: 'Transform', coinId: 63, cost: 20, pts: 80, bp: 1000 },
                            6: { name: 'Power', coinId: 63, cost: 40, pts: 160, bp: 2000 }
                        };

                        const CURRENCIES = {
                            16: { name: 'Candy', icon: 'üç¨' },
                            63: { name: 'Cookie', icon: '‚ùÑÔ∏è' }
                        };

                        const NPC_NAMES = {
                            '-306': 'üéÅ Wendy',
                            '-307': 'üéÅ Wendy 2',
                        };

                        const SELF_ID = 'self';
                        const SELF_NAME = 'üéÅ Self (Quest Farm)';

                        const SendFunction = getSend();
                        if (!SendFunction) {
                            alert('‚ùå Send function not available');
                            return;
                        }

                        // State
                        let balances = { 16: 0, 63: 0 };
                        let currentSort = { column: 'total', direction: 'desc' };
                        let sendLog = [];
                        let currentPersonStats = {};
                        let currentNpcStats = {};
                        let currentTopsData = {};
                        let currentBehindByType = {};
                        let unopenedRecv = 0;
                        let unopenedSent = 0;
                        let currentTab = 'players';

                        // Rewards tracking
                        let rewardsByGiftType = { recv: {}, sent: {} };

                        const getBalances = async () => {
                            try {
                                const inv = await SendFunction(JSON.stringify({
                                    calls: [{ name: "inventoryGet", args: {}, ident: "inv" }]
                                }));
                                const coin = inv?.results?.[0]?.result?.response?.coin || {};
                                balances = {
                                    16: parseInt(coin[16]) || 0,
                                    63: parseInt(coin[63]) || 0
                                };
                            } catch (e) {
                                console.error('Failed to get balances:', e);
                            }
                            return balances;
                        };

                        // Get item name
                        const getItemName = (id, type) => {
                            // Special handling for skins FIRST - need to look up localeKey + hero name
                            if (type === 'fragmentSkin' || type === 'skin') {
                                const skinData = lib?.data?.skin?.[id];
                                if (skinData) {
                                    const skinName = skinData.localeKey ? cheats.translate(skinData.localeKey) : null;
                                    const heroName = skinData.heroId ? cheats.translate('LIB_HERO_NAME_' + skinData.heroId) : null;
                                    if (heroName && skinName && !skinName.startsWith('LIB_')) {
                                        return `${heroName} - ${skinName}`;
                                    }
                                    if (skinName && !skinName.startsWith('LIB_')) return skinName;
                                }
                            }
                            if (window.identifyItem) {
                                const name = window.identifyItem(id, type);
                                if (name && !name.startsWith('Unknown') && !name.startsWith('fragmentSkin')) return name;
                            }
                            if (cheats?.translate) {
                                const keyMap = {
                                    'consumable': 'LIB_CONSUMABLE_NAME_',
                                    'coin': 'LIB_COIN_NAME_',
                                    'fragmentHero': 'LIB_HERO_NAME_',
                                    'fragmentTitanArtifact': 'LIB_TITAN_ARTIFACT_NAME_'
                                };
                                const prefix = keyMap[type];
                                if (prefix) {
                                    const translated = cheats.translate(prefix + id);
                                    if (translated && !translated.startsWith('LIB_')) return translated;
                                }
                            }
                            return `${type} #${id}`;
                        };

                        // Sort function
                        const sortPeople = (people, column, direction) => {
                            return [...people].sort((a, b) => {
                                let aVal, bVal;
                                const [aId, aP] = a;
                                const [bId, bP] = b;

                                if (column === 'name') {
                                    aVal = aP.name.toLowerCase();
                                    bVal = bP.name.toLowerCase();
                                } else if (column === 'sent') {
                                    aVal = aP.sentPts;
                                    bVal = bP.sentPts;
                                } else if (column === 'recv') {
                                    aVal = aP.recvPts;
                                    bVal = bP.recvPts;
                                } else if (column === 'balance') {
                                    aVal = aP.sentPts - aP.recvPts;
                                    bVal = bP.sentPts - bP.recvPts;
                                } else if (column === 'total') {
                                    aVal = aP.sentPts + aP.recvPts;
                                    bVal = bP.sentPts + bP.recvPts;
                                } else if (column >= 1 && column <= 6) {
                                    aVal = aP.recv[column] || 0;
                                    bVal = bP.recv[column] || 0;
                                } else {
                                    aVal = aP.sentPts + aP.recvPts;
                                    bVal = bP.sentPts + bP.recvPts;
                                }

                                if (direction === 'asc') {
                                    return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
                                } else {
                                    return aVal < bVal ? 1 : aVal > bVal ? -1 : 0;
                                }
                            });
                        };

                        // Send gift to multiple users in ONE call
                        const sendGiftBatch = async (userList, giftNum) => {
                            if (userList.length === 0) return { success: [], failed: [] };

                            const users = {};
                            userList.forEach(u => { users[u.id] = 1; });

                            try {
                                const response = await SendFunction(JSON.stringify({
                                    calls: [{
                                        name: "newYear_giftSend",
                                        args: {
                                            userId: userList[0].id,
                                            amount: 1,
                                            giftNum: giftNum,
                                            users: users
                                        },
                                        context: { actionTs: Date.now() },
                                        ident: "body"
                                    }]
                                }));

                                const result = response?.results?.[0]?.result?.response;
                                if (result?.giftIds && result.giftIds.length > 0) {
                                    userList.forEach(u => {
                                        sendLog.push({ userName: u.name, giftType: GIFT_TYPES[giftNum].name, giftNum, success: true });
                                    });
                                    return { success: userList.map(u => u.name), failed: [] };
                                } else {
                                    userList.forEach(u => {
                                        sendLog.push({ userName: u.name, giftType: GIFT_TYPES[giftNum].name, giftNum, success: false });
                                    });
                                    return { success: [], failed: userList.map(u => u.name) };
                                }
                            } catch (e) {
                                console.error('Send gift batch error:', e);
                                userList.forEach(u => {
                                    sendLog.push({ userName: u.name, giftType: GIFT_TYPES[giftNum].name, giftNum, success: false });
                                });
                                return { success: [], failed: userList.map(u => u.name) };
                            }
                        };

                        // Send multiple gifts to match deficits
                        const sendGiftDeficits = async (needsList, giftNum, statusCallback) => {
                            const maxDeficit = Math.max(...needsList.map(u => u.deficit));
                            let totalSent = 0;
                            const totalToSend = needsList.reduce((sum, u) => sum + u.deficit, 0);

                            for (let round = 1; round <= maxDeficit; round++) {
                                const usersThisRound = needsList.filter(u => u.deficit >= round);
                                if (usersThisRound.length === 0) continue;

                                totalSent += usersThisRound.length;
                                if (statusCallback) statusCallback(`Round ${round}/${maxDeficit} (${totalSent}/${totalToSend})`);

                                await sendGiftBatch(usersThisRound, giftNum);

                                if (round < maxDeficit) {
                                    await new Promise(r => setTimeout(r, 300));
                                }
                            }
                        };

                        // Nice confirmation popup
                        const showConfirmPopup = (title, message, details, costInfo) => {
                            return new Promise((resolve) => {
                                const confirmModal = document.createElement('div');
                                confirmModal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.85); z-index: 99999999;
                display: flex; justify-content: center; align-items: center;
            `;

                                const confirmPopup = document.createElement('div');
                                confirmPopup.style.cssText = `
                background: linear-gradient(135deg, #2d2416 0%, #1a1408 100%);
                border: 3px solid #c9a227; border-radius: 12px;
                padding: 20px; min-width: 400px; max-width: 500px;
                color: #f4e4c1; font-family: sans-serif;
            `;

                                let html = `
                <div style="margin-bottom:15px;padding-bottom:10px;border-bottom:2px solid #c9a227;">
                    <h3 style="margin:0;color:#ffd700;font-size:16px;">${title}</h3>
                </div>
                <div style="margin-bottom:15px;color:#ccc;font-size:14px;">${message}</div>`;

                                if (details) {
                                    html += `<div style="background:rgba(0,0,0,0.3);padding:10px;border-radius:6px;margin-bottom:15px;max-height:150px;overflow-y:auto;">
                    <div style="color:#999;font-size:12px;white-space:pre-line;">${details}</div>
                </div>`;
                                }

                                if (costInfo) {
                                    html += `<div style="background:rgba(139,105,20,0.3);padding:12px;border-radius:8px;border:1px solid #8b6914;margin-bottom:15px;">
                    <div style="display:flex;justify-content:space-between;margin-bottom:8px;">
                        <span style="color:#999;">Current balance:</span>
                        <span style="color:#4ae29a;font-weight:bold;">${costInfo.currentBalance.toLocaleString()} ${costInfo.icon}</span>
                    </div>
                    <div style="display:flex;justify-content:space-between;margin-bottom:8px;">
                        <span style="color:#999;">Cost:</span>
                        <span style="color:#ff6b6b;font-weight:bold;">-${costInfo.totalCost.toLocaleString()} ${costInfo.icon}</span>
                    </div>
                    <div style="display:flex;justify-content:space-between;padding-top:8px;border-top:1px solid #555;">
                        <span style="color:#ffd700;">After sending:</span>
                        <span style="color:${costInfo.remaining >= 0 ? '#4ae29a' : '#ff6b6b'};font-weight:bold;">${costInfo.remaining.toLocaleString()} ${costInfo.icon}</span>
                    </div>
                </div>`;
                                }

                                html += `<div style="display:flex;gap:10px;justify-content:flex-end;">
                <button id="confirmNo" style="background:#4a3510;color:#ccc;border:1px solid #666;padding:8px 20px;border-radius:6px;cursor:pointer;font-size:14px;">Cancel</button>
                <button id="confirmYes" style="background:#4a8f4a;color:white;border:none;padding:8px 20px;border-radius:6px;cursor:pointer;font-size:14px;">Send</button>
            </div>`;

                                confirmPopup.innerHTML = html;
                                confirmModal.appendChild(confirmPopup);
                                document.body.appendChild(confirmModal);

                                confirmPopup.querySelector('#confirmYes').onclick = () => {
                                    confirmModal.remove();
                                    resolve(true);
                                };
                                confirmPopup.querySelector('#confirmNo').onclick = () => {
                                    confirmModal.remove();
                                    resolve(false);
                                };
                                confirmModal.onclick = (e) => {
                                    if (e.target === confirmModal) {
                                        confirmModal.remove();
                                        resolve(false);
                                    }
                                };
                            });
                        };

                        // Show styled summary popup
                        const showFinalSummary = async () => {
                            if (sendLog.length === 0) return;

                            await getBalances();

                            const successful = sendLog.filter(s => s.success);
                            const failed = sendLog.filter(s => !s.success);

                            const byType = {};
                            successful.forEach(s => {
                                if (!byType[s.giftType]) byType[s.giftType] = [];
                                byType[s.giftType].push(s.userName);
                            });

                            const totalPts = successful.reduce((sum, s) => sum + (GIFT_TYPES[s.giftNum]?.pts || 0), 0);

                            const costCounts = {};
                            successful.forEach(s => {
                                const gift = GIFT_TYPES[s.giftNum];
                                const coinId = gift?.coinId;
                                if (!costCounts[coinId]) costCounts[coinId] = { count: 0, cost: 0 };
                                costCounts[coinId].count++;
                                costCounts[coinId].cost += gift?.cost || 0;
                            });

                            const summaryModal = document.createElement('div');
                            summaryModal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 9999999;
            display: flex; justify-content: center; align-items: center;
        `;

                            const summaryPopup = document.createElement('div');
                            summaryPopup.style.cssText = `
            background: linear-gradient(135deg, #2d2416 0%, #1a1408 100%);
            border: 3px solid #c9a227; border-radius: 12px;
            padding: 20px; min-width: 420px; max-width: 520px; max-height: 80vh;
            overflow-y: auto; color: #f4e4c1;
            font-family: sans-serif;
        `;

                            let summaryHtml = `
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding-bottom:10px;border-bottom:2px solid #c9a227;">
                <h3 style="margin:0;color:#ffd700;font-size:16px;">üì§ Gift Summary</h3>
                <button id="wfSummaryClose" style="background:#ff4444;color:white;border:none;padding:5px 12px;border-radius:5px;cursor:pointer;font-size:14px;">‚úï</button>
            </div>`;

                            if (successful.length > 0) {
                                summaryHtml += `<div style="background:rgba(74,226,154,0.15);padding:12px;border-radius:8px;border:1px solid #4aa24a;margin-bottom:12px;">
                <div style="color:#4ae29a;font-weight:bold;margin-bottom:10px;font-size:14px;">‚úÖ Sent Successfully (${successful.length})</div>`;

                                for (const [giftType, names] of Object.entries(byType)) {
                                    const nameCounts = {};
                                    names.forEach(n => { nameCounts[n] = (nameCounts[n] || 0) + 1; });
                                    const nameList = Object.entries(nameCounts)
                                    .map(([name, count]) => count > 1 ? `${name} √ó${count}` : name)
                                    .join(', ');

                                    summaryHtml += `<div style="margin-bottom:8px;">
                    <span style="color:#ffd700;font-weight:bold;">${giftType}:</span>
                    <span style="color:#ccc;font-size:12px;margin-left:8px;">${nameList}</span>
                </div>`;
                                }
                                summaryHtml += `</div>`;
                            }

                            if (failed.length > 0) {
                                summaryHtml += `<div style="background:rgba(255,100,100,0.15);padding:12px;border-radius:8px;border:1px solid #8b4444;margin-bottom:12px;">
                <div style="color:#ff6b6b;font-weight:bold;margin-bottom:10px;font-size:14px;">‚ùå Failed (${failed.length})</div>
                <span style="color:#ccc;font-size:12px;">${failed.map(f => `${f.userName} (${f.giftType})`).join(', ')}</span>
            </div>`;
                            }

                            summaryHtml += `<div style="background:rgba(139,105,20,0.3);padding:12px;border-radius:8px;border:1px solid #8b6914;">
            <div style="display:flex;justify-content:space-between;margin-bottom:8px;">
                <span style="color:#999;">Total gifts sent:</span>
                <span style="color:#4ae29a;font-weight:bold;">${successful.length}</span>
            </div>
            <div style="display:flex;justify-content:space-between;margin-bottom:8px;">
                <span style="color:#999;">Points earned:</span>
                <span style="color:#ffd700;font-weight:bold;">+${totalPts}</span>
            </div>`;

                            for (const [coinId, data] of Object.entries(costCounts)) {
                                const currency = CURRENCIES[coinId];
                                summaryHtml += `<div style="display:flex;justify-content:space-between;margin-bottom:8px;">
                <span style="color:#999;">Spent ${currency?.icon || ''}:</span>
                <span style="color:#ff6b6b;font-weight:bold;">-${data.cost.toLocaleString()}</span>
            </div>`;
                            }

                            summaryHtml += `<div style="border-top:1px solid #555;padding-top:8px;margin-top:8px;">
            <div style="color:#ffd700;margin-bottom:6px;">Current Balances:</div>
            <div style="display:flex;justify-content:space-between;">
                <span style="color:#ccc;">${CURRENCIES[16].icon} Candy:</span>
                <span style="color:#4ae29a;font-weight:bold;">${balances[16].toLocaleString()}</span>
            </div>
            <div style="display:flex;justify-content:space-between;">
                <span style="color:#ccc;">${CURRENCIES[63].icon} Cookies:</span>
                <span style="color:#4ae29a;font-weight:bold;">${balances[63].toLocaleString()}</span>
            </div>
        </div>`;

                            summaryHtml += `</div>`;

                            summaryPopup.innerHTML = summaryHtml;
                            summaryModal.appendChild(summaryPopup);
                            document.body.appendChild(summaryModal);

                            summaryModal.onclick = (e) => { if (e.target === summaryModal) summaryModal.remove(); };
                            summaryPopup.querySelector('#wfSummaryClose').onclick = () => summaryModal.remove();

                            sendLog = [];
                        };

                        // Create modal
                        const modal = document.createElement('div');
                        modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); z-index: 999999;
        display: flex; justify-content: center; align-items: center;
    `;

                        const popup = document.createElement('div');
                        popup.style.cssText = `
        background: linear-gradient(135deg, #2d2416 0%, #1a1408 100%);
        border: 3px solid #c9a227; border-radius: 12px;
        padding: 20px; min-width: 900px; max-height: 85vh;
        overflow-y: auto; color: #f4e4c1;
        font-family: sans-serif;
    `;

                        popup.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding-bottom:10px;border-bottom:2px solid #c9a227;">
            <h3 style="margin:0;color:#ffd700;font-size:16px;">üéÅ Winterfest Gifts</h3>
            <button id="wfGiftsClose" style="background:#ff4444;color:white;border:none;padding:5px 12px;border-radius:5px;cursor:pointer;font-size:14px;">‚úï</button>
        </div>
        <p style="text-align:center;color:#999;">Loading gift data...</p>
    `;

                        modal.appendChild(popup);
                        document.body.appendChild(modal);
                        modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
                        popup.querySelector('#wfGiftsClose').onclick = () => modal.remove();

                        // Render Players tab
                        const renderPlayersTab = () => {
                            const recvPlace = currentTopsData?.received?.place || '?';
                            const recvPts = currentTopsData?.received?.points?.toLocaleString() || 0;
                            const sentPlace = currentTopsData?.sent?.place || '?';
                            const sentPts = currentTopsData?.sent?.points?.toLocaleString() || 0;

                            const sortArrow = (col) => currentSort.column === col ? (currentSort.direction === 'desc' ? ' ‚ñº' : ' ‚ñ≤') : '';

                            // Calculate totals (including NPCs)
                            const totals = { sent: {}, recv: {}, sentPts: 0, recvPts: 0 };
                            for (let g = 1; g <= 6; g++) {
                                totals.sent[g] = 0;
                                totals.recv[g] = 0;
                            }
                            Object.values(currentPersonStats).forEach(p => {
                                totals.sentPts += p.sentPts;
                                totals.recvPts += p.recvPts;
                                for (let g = 1; g <= 6; g++) {
                                    totals.sent[g] += p.sent[g] || 0;
                                    totals.recv[g] += p.recv[g] || 0;
                                }
                            });


                            // Calculate Wendy totals
                            let wendyTotalPts = 0;
                            Object.values(currentNpcStats).forEach(npc => {
                                Object.entries(npc.gifts).forEach(([lib, cnt]) => {
                                    wendyTotalPts += (GIFT_TYPES[lib]?.pts || 0) * cnt;
                                });
                            });

                            let html = `
            <div style="display:flex;gap:10px;margin-bottom:12px;">
                <div style="flex:1;background:rgba(139,105,20,0.3);padding:8px;border-radius:6px;border:1px solid #8b6914;">
                    <span style="color:#ffd700;">üèÜ Received:</span> <span style="color:#ff6b6b;">#${recvPlace}</span> <span style="color:#999;">(${recvPts} pts)</span>
                    <span style="margin-left:15px;color:#ffd700;">üì§ Sent:</span> <span style="color:#4ae29a;">#${sentPlace}</span> <span style="color:#999;">(${sentPts} pts)</span>
                    <span style="margin-left:15px;color:#666;font-size:10px;font-style:italic;">(Received total includes Wendy's gifts)</span>
                </div>
                <div style="background:rgba(139,105,20,0.3);padding:8px;border-radius:6px;border:1px solid #8b6914;display:flex;align-items:center;gap:10px;">
                    <span style="color:#999;">üì¨ ${unopenedRecv}‚Üì ${unopenedSent}‚Üë</span>
                    <button id="wfCopyPlayers" style="background:#4a3510;color:#ffd700;border:1px solid #8b6914;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:10px;">üìã Copy</button>
                </div>
            </div>`;



                            // Send controls
                            html += `<div style="margin-bottom:12px;padding:10px;background:rgba(139,105,20,0.2);border:1px solid #8b6914;border-radius:6px;">
            <div style="display:flex;align-items:center;flex-wrap:wrap;gap:8px;">
                <span style="color:#ffd700;font-weight:bold;">üì§ Send to checked:</span>
                <select id="wfBulkGiftType" style="background:#2d2416;color:#f4e4c1;border:1px solid #8b6914;border-radius:4px;padding:4px 8px;font-size:12px;">
                    <option value="">Select gift...</option>
                    <option value="1">Upgrade (1,000 üç¨)</option>
                    <option value="2">Pet (2,000 üç¨)</option>
                    <option value="3">Ascension (5,000 üç¨)</option>
                    <option value="4">Skin (20,000 üç¨)</option>
                    <option value="5">Transform (20 ‚ùÑÔ∏è)</option>
                    <option value="6">Power (40 ‚ùÑÔ∏è)</option>
                </select>
                <button id="wfSendChecked" style="background:#4a8f4a;color:white;border:none;padding:5px 12px;border-radius:4px;cursor:pointer;font-size:12px;">Send</button>
                <span id="wfCheckedCount" style="color:#999;font-size:11px;">(0 selected)</span>

                <span style="color:#555;margin:0 5px;">|</span>

                <span style="color:#ffd700;">Match:</span>`;

                            for (let g = 1; g <= 6; g++) {
                                const totalDeficit = (currentBehindByType[g] || []).reduce((sum, u) => sum + u.deficit, 0);
                                const disabled = totalDeficit === 0 ? 'opacity:0.3;pointer-events:none;' : '';
                                const tooltip = (currentBehindByType[g] || []).map(u => `${u.name}√ó${u.deficit}`).join(', ') || 'None';
                                html += `<button class="wf-match-all" data-gift="${g}" style="background:#4a3510;color:#ffd700;border:1px solid #8b6914;padding:3px 6px;border-radius:4px;cursor:pointer;font-size:10px;${disabled}" title="${tooltip}">${GIFT_TYPES[g].name.substring(0,3)}${totalDeficit > 0 ? `(${totalDeficit})` : ''}</button>`;
                            }

                            html += `</div></div>`;

                            // Player table with sortable headers
                            html += `<table style="width:100%;border-collapse:collapse;font-size:12px;">
<tr style="background:#8b6914;color:#ffd700;">
    <th style="padding:5px;width:30px;"><input type="checkbox" id="wfCheckAll" title="Select/Deselect All"></th>
    <th class="wf-sort" data-col="name" style="padding:5px;text-align:left;cursor:pointer;" title="Sort by name">Player${sortArrow('name')}</th>
    <th class="wf-sort" data-col="1" style="padding:5px;cursor:pointer;" title="Sort by Upgrade received">‚ù§Ô∏è Upgr${sortArrow(1)}</th>
    <th class="wf-sort" data-col="2" style="padding:5px;cursor:pointer;" title="Sort by Pet received">üß° Pet${sortArrow(2)}</th>
    <th class="wf-sort" data-col="3" style="padding:5px;cursor:pointer;" title="Sort by Ascension received">üíõ Asc${sortArrow(3)}</th>
    <th class="wf-sort" data-col="4" style="padding:5px;cursor:pointer;" title="Sort by Skin received">üíö Skin${sortArrow(4)}</th>
    <th class="wf-sort" data-col="5" style="padding:5px;cursor:pointer;" title="Sort by Transform received">üíú Trans${sortArrow(5)}</th>
    <th class="wf-sort" data-col="6" style="padding:5px;cursor:pointer;" title="Sort by Power received">üíô Pwr${sortArrow(6)}</th>
    <th class="wf-sort" data-col="sent" style="padding:5px;cursor:pointer;" title="Sort by total sent">üü© Sent${sortArrow('sent')}</th>
    <th class="wf-sort" data-col="recv" style="padding:5px;cursor:pointer;" title="Sort by total received">üü• Recv${sortArrow('recv')}</th>
    <th class="wf-sort" data-col="balance" style="padding:5px;cursor:pointer;" title="Sort by balance">‚úÖ +/-${sortArrow('balance')}</th>
</tr>`;

                            // Totals row
                            const totalBalance = totals.sentPts - totals.recvPts;
                            let totalBalanceStr, totalBalanceColor;
                            if (totalBalance > 0) {
                                totalBalanceStr = `+${totalBalance}`;
                                totalBalanceColor = '#4ae29a';
                            } else if (totalBalance < 0) {
                                totalBalanceStr = `${totalBalance}`;
                                totalBalanceColor = '#ff6b6b';
                            } else {
                                totalBalanceStr = '0';
                                totalBalanceColor = '#999';
                            }

                            html += `<tr style="background:rgba(255,215,0,0.15);border-bottom:2px solid #c9a227;font-weight:bold;">
            <td style="padding:5px;"></td>
            <td style="padding:5px;color:#ffd700;text-align:left;">TOTALS</td>`;

                            for (let lib = 1; lib <= 6; lib++) {
                                const sent = totals.sent[lib] || 0;
                                const recv = totals.recv[lib] || 0;
                                html += `<td style="padding:5px;text-align:center;">`;
                                if (sent || recv) {
                                    if (sent) html += `<span style="color:#4ae29a;">${sent}</span>`;
                                    if (sent && recv) html += `<span style="color:#666;">/</span>`;
                                    if (recv) html += `<span style="color:#ff6b6b;">${recv}</span>`;
                                } else {
                                    html += `<span style="color:#333;">-</span>`;
                                }
                                html += `</td>`;
                            }

                            html += `<td style="padding:5px;text-align:center;color:#4ae29a;">${totals.sentPts}</td>
            <td style="padding:5px;text-align:center;color:#ff6b6b;">${totals.recvPts}</td>
            <td style="padding:5px;text-align:center;color:${totalBalanceColor};">${totalBalanceStr}</td>
        </tr>`;

                            // Combine players and NPCs for sorting
                            const allEntries = [
                                ...Object.entries(currentPersonStats),
                                ...Object.entries(currentNpcStats).map(([id, npc]) => {
                                    // Convert NPC to player-like format
                                    let recvPts = 0;
                                    const recv = {};
                                    Object.entries(npc.gifts).forEach(([lib, cnt]) => {
                                        recv[lib] = cnt;
                                        recvPts += (GIFT_TYPES[lib]?.pts || 0) * cnt;
                                    });
                                    return [id, {
                                        name: npc.name,
                                        sent: {},
                                        recv: recv,
                                        sentPts: 0,
                                        recvPts: recvPts,
                                        isNpc: true
                                    }];
                                })
                            ];

                            const sortedPeople = sortPeople(allEntries, currentSort.column, currentSort.direction);

                            let rowIndex = 0;
                            for (const [id, p] of sortedPeople) {
                                const balance = p.sentPts - p.recvPts;
                                const behind = balance < 0;

                                let rowBg;
                                if (behind) {
                                    rowBg = rowIndex % 2 === 0 ? 'rgba(255,100,100,0.26)' : 'rgba(255,100,100,0.10)';
                                } else {
                                    rowBg = rowIndex % 2 === 0 ? 'rgba(255,255,255,0.09)' : 'rgba(255,255,255,0.02)';
                                }

                                const rowStyle = `border-bottom:1px solid #4a3510;background:${rowBg};`;

                                const isNpc = p.isNpc || id.startsWith('-') || id === 'self';
                                const nameColor = isNpc ? '#4ae29a' : '#f4e4c1';
                                const nameStyle = isNpc ? 'font-style:italic;' : '';

                                html += `<tr style="${rowStyle}">
    <td style="padding:5px;text-align:center;">
        ${isNpc ? '' : `<input type="checkbox" class="wf-player-check" data-userid="${id}" data-username="${p.name}" ${behind ? 'checked' : ''}>`}
    </td>
    <td style="padding:5px;color:${nameColor};text-align:left;${nameStyle}">${p.name}${behind && !isNpc ? ' ‚ö†Ô∏è' : ''}</td>`;

                                for (let lib = 1; lib <= 6; lib++) {
                                    const sent = p.sent[lib] || 0;
                                    const recv = p.recv[lib] || 0;
                                    html += `<td style="padding:5px;text-align:center;">`;
                                    if (sent || recv) {
                                        if (sent) html += `<span style="color:#4ae29a;">${sent}</span>`;
                                        if (sent && recv) html += `<span style="color:#666;">/</span>`;
                                        if (recv) html += `<span style="color:#ff6b6b;">${recv}</span>`;
                                    } else {
                                        html += `<span style="color:#333;">-</span>`;
                                    }
                                    html += `</td>`;
                                }

                                let balanceStr, balanceColor;
                                if (balance > 0) {
                                    balanceStr = `+${balance}`;
                                    balanceColor = '#4ae29a';
                                } else if (balance < 0) {
                                    balanceStr = `${balance}`;
                                    balanceColor = '#ff6b6b';
                                } else {
                                    balanceStr = '0';
                                    balanceColor = '#999';
                                }

                                if (isNpc) {
                                    html += `<td style="padding:5px;text-align:center;color:#666;">-</td>
        <td style="padding:5px;text-align:center;color:#ff6b6b;font-style:italic;">${p.recvPts || '-'}</td>
        <td style="padding:5px;text-align:center;color:#666;">-</td>
    </tr>`;
                                } else {
                                    html += `<td style="padding:5px;text-align:center;color:#4ae29a;font-weight:bold;">${p.sentPts || '-'}</td>
        <td style="padding:5px;text-align:center;color:#ff6b6b;font-weight:bold;">${p.recvPts || '-'}</td>
        <td style="padding:5px;text-align:center;color:${balanceColor};font-weight:bold;">${balanceStr}</td>
    </tr>`;
                                }

                                rowIndex++;
                            }

                            html += `</table>`;

                            return html;
                        };

                        // Render Rewards tab
                        const renderRewardsTab = () => {
                            // Track rewards by player and gift type
                            const rewardsByPlayer = {
                                recv: {},
                                sent: {}
                            };

                            // Track totals by category
                            const totalsByCategory = {
                                recv: {},
                                sent: {}
                            };

                            // Get myId once
                            let myId = '';
                            try {
                                const userInfo = HWHFuncs.getUserInfo();
                                myId = userInfo?.id?.toString() || '';
                            } catch(e) {
                                myId = localStorage['userId'] || '';
                            }

                            const addToTotals = (tracker, category, id, amt) => {
                                const key = `${category}|${id}`;
                                if (!tracker[key]) {
                                    tracker[key] = { category, id, amount: 0 };
                                }
                                tracker[key].amount += amt;
                            };

                            // Process gifts
                            if (window._wfRawGifts) {
                                // Received gifts - group by sender and gift type
                                window._wfRawGifts.recv.forEach(g => {
                                    if (g.opened !== '1' || !g.reward) return;
                                    const fromId = String(g.from);
                                    const giftType = g.libId;

                                    // Track self (questFarm) as special entry
                                    if (fromId === myId) {
                                        const selfId = 'self';
                                        if (!rewardsByPlayer.recv[selfId]) {
                                            rewardsByPlayer.recv[selfId] = { name: 'üéÅ Self (Quest Farm)', giftCounts: {}, byGift: {} };
                                        }

                                        rewardsByPlayer.recv[selfId].giftCounts[giftType] = (rewardsByPlayer.recv[selfId].giftCounts[giftType] || 0) + 1;

                                        if (!rewardsByPlayer.recv[selfId].byGift[giftType]) {
                                            rewardsByPlayer.recv[selfId].byGift[giftType] = {};
                                        }

                                        const addSelfReward = (category, items) => {
                                            if (!items) return;
                                            for (const [id, amt] of Object.entries(items)) {
                                                const amount = parseInt(amt) || 0;
                                                const key = `${category}|${id}`;
                                                if (!rewardsByPlayer.recv[selfId].byGift[giftType][key]) {
                                                    rewardsByPlayer.recv[selfId].byGift[giftType][key] = { category, id, amount: 0 };
                                                }
                                                rewardsByPlayer.recv[selfId].byGift[giftType][key].amount += amount;
                                                addToTotals(totalsByCategory.recv, category, id, amount);
                                            }
                                        };

                                        const r = g.reward;
                                        addSelfReward('consumable', r.consumable);
                                        addSelfReward('coin', r.coin);
                                        addSelfReward('fragmentSkin', r.fragmentSkin);
                                        addSelfReward('fragmentHero', r.fragmentHero);
                                        addSelfReward('fragmentTitanArtifact', r.fragmentTitanArtifact);
                                        if (r.gold) addSelfReward('gold', { gold: r.gold });

                                        return;
                                    }

                                    if (!rewardsByPlayer.recv[fromId]) {
                                        const isNpc = fromId.startsWith('-');
                                        const name = isNpc ? (NPC_NAMES[fromId] || `NPC ${fromId}`) :
                                        (currentPersonStats[fromId]?.name) || `Player ${fromId}`;
                                        rewardsByPlayer.recv[fromId] = { name, giftCounts: {}, byGift: {} };
                                    }

                                    rewardsByPlayer.recv[fromId].giftCounts[giftType] = (rewardsByPlayer.recv[fromId].giftCounts[giftType] || 0) + 1;

                                    if (!rewardsByPlayer.recv[fromId].byGift[giftType]) {
                                        rewardsByPlayer.recv[fromId].byGift[giftType] = {};
                                    }

                                    const addReward = (category, items) => {
                                        if (!items) return;
                                        for (const [id, amt] of Object.entries(items)) {
                                            const amount = parseInt(amt) || 0;
                                            const key = `${category}|${id}`;
                                            if (!rewardsByPlayer.recv[fromId].byGift[giftType][key]) {
                                                rewardsByPlayer.recv[fromId].byGift[giftType][key] = { category, id, amount: 0 };
                                            }
                                            rewardsByPlayer.recv[fromId].byGift[giftType][key].amount += amount;
                                            addToTotals(totalsByCategory.recv, category, id, amount);
                                        }
                                    };

                                    const r = g.reward;
                                    addReward('consumable', r.consumable);
                                    addReward('coin', r.coin);
                                    addReward('fragmentSkin', r.fragmentSkin);
                                    addReward('fragmentHero', r.fragmentHero);
                                    addReward('fragmentTitanArtifact', r.fragmentTitanArtifact);
                                    if (r.gold) addReward('gold', { gold: r.gold });
                                });

                                // Sent gifts - group by recipient and gift type
                                window._wfRawGifts.sent.forEach(g => {
                                    if (g.opened !== '1' || !g.reward) return;
                                    if (g.reason !== 'send') return;

                                    const toId = String(g.to);
                                    const giftType = g.libId;

                                    if (!rewardsByPlayer.sent[toId]) {
                                        const name = currentPersonStats[toId]?.name || `Player ${toId}`;
                                        rewardsByPlayer.sent[toId] = { name, giftCounts: {}, byGift: {} };
                                    }

                                    rewardsByPlayer.sent[toId].giftCounts[giftType] = (rewardsByPlayer.sent[toId].giftCounts[giftType] || 0) + 1;

                                    if (!rewardsByPlayer.sent[toId].byGift[giftType]) {
                                        rewardsByPlayer.sent[toId].byGift[giftType] = {};
                                    }

                                    const addReward = (category, items) => {
                                        if (!items) return;
                                        for (const [id, amt] of Object.entries(items)) {
                                            const amount = parseInt(amt) || 0;
                                            const key = `${category}|${id}`;
                                            if (!rewardsByPlayer.sent[toId].byGift[giftType][key]) {
                                                rewardsByPlayer.sent[toId].byGift[giftType][key] = { category, id, amount: 0 };
                                            }
                                            rewardsByPlayer.sent[toId].byGift[giftType][key].amount += amount;
                                            addToTotals(totalsByCategory.sent, category, id, amount);
                                        }
                                    };

                                    const r = g.reward;
                                    addReward('consumable', r.consumable);
                                    addReward('coin', r.coin);
                                    addReward('fragmentSkin', r.fragmentSkin);
                                    addReward('fragmentHero', r.fragmentHero);
                                    addReward('fragmentTitanArtifact', r.fragmentTitanArtifact);
                                    if (r.gold) addReward('gold', { gold: r.gold });
                                });
                            }

                            const categoryIcons = {
                                consumable: 'üß™',
                                coin: 'üí∞',
                                fragmentSkin: 'üëî',
                                fragmentHero: '‚≠ê',
                                fragmentTitanArtifact: 'üîÆ',
                                gold: 'ü™ô'
                            };

                            const categoryOrder = ['gold', 'coin', 'fragmentSkin', 'fragmentHero', 'fragmentTitanArtifact', 'consumable'];

                            // Build player breakdown for totals columns
                            const buildPlayerBreakdown = (rewardsByPlayerData) => {
                                const itemToPlayers = {};

                                for (const [playerId, data] of Object.entries(rewardsByPlayerData)) {
                                    for (const [gType, items] of Object.entries(data.byGift)) {
                                        for (const [key, item] of Object.entries(items)) {
                                            if (!itemToPlayers[key]) {
                                                itemToPlayers[key] = [];
                                            }
                                            const existing = itemToPlayers[key].find(p => p.name === data.name);
                                            if (existing) {
                                                existing.amount += item.amount;
                                            } else {
                                                itemToPlayers[key].push({ name: data.name, amount: item.amount, isNpc: playerId.startsWith('-') || playerId === 'self' });
                                            }
                                        }
                                    }
                                }

                                return itemToPlayers;
                            };

                            const recvPlayerBreakdown = buildPlayerBreakdown(rewardsByPlayer.recv);
                            const sentPlayerBreakdown = buildPlayerBreakdown(rewardsByPlayer.sent);

                            // Store data for filtering
                            window._wfRewardsData = {
                                rewardsByPlayer,
                                totalsByCategory,
                                recvPlayerBreakdown,
                                sentPlayerBreakdown,
                                categoryIcons,
                                categoryOrder
                            };

                            let html = `<div style="margin-bottom:12px;display:flex;justify-content:space-between;align-items:center;">
        <p style="color:#999;margin:0;">Rewards grouped by player and gift type (filter by name or item)</p>
        <button id="wfCopyRewards" style="background:#4a3510;color:#ffd700;border:1px solid #8b6914;padding:4px 12px;border-radius:4px;cursor:pointer;font-size:11px;">üìã Copy All to Spreadsheet</button>
    </div>`;
                            // 4 column layout
                            html += `<div style="display:flex;gap:10px;">`;

                            // Column 1: Received From (player breakdown)
                            html += `<div style="flex:1;background:rgba(255,100,100,0.08);padding:10px;border-radius:6px;display:flex;flex-direction:column;max-height:500px;">
        <div style="position:sticky;top:0;background:rgba(40,20,20,0.98);padding:5px;margin:-10px -10px 0 -10px;border-radius:6px 6px 0 0;">
            <div style="color:#ff6b6b;font-weight:bold;font-size:13px;margin-bottom:6px;">üì• Received From</div>
            <input type="text" class="wf-filter" data-col="recvFrom" placeholder="Filter..." style="width:calc(100% - 10px);padding:4px 6px;font-size:11px;background:#1a1408;border:1px solid #8b6914;border-radius:4px;color:#f4e4c1;">
        </div>
        <div id="wfCol1Content" style="overflow-y:auto;flex:1;margin-top:10px;">`;

                            const recvPlayers = Object.entries(rewardsByPlayer.recv)
                            .filter(([id, data]) => Object.keys(data.byGift).length > 0)
                            .sort((a, b) => {
                                const aIsNpc = a[0].startsWith('-') || a[0] === 'self';
                                const bIsNpc = b[0].startsWith('-') || b[0] === 'self';
                                if (aIsNpc && !bIsNpc) return -1;
                                if (!aIsNpc && bIsNpc) return 1;
                                const aTotal = Object.values(a[1].giftCounts).reduce((s, c) => s + c, 0);
                                const bTotal = Object.values(b[1].giftCounts).reduce((s, c) => s + c, 0);
                                return bTotal - aTotal;
                            });

                            if (recvPlayers.length === 0) {
                                html += `<div style="color:#666;font-size:12px;">No rewards tracked</div>`;
                            } else {
                                for (const [id, data] of recvPlayers) {
                                    const isNpc = id.startsWith('-') || id === 'self';
                                    const nameColor = isNpc ? '#4ae29a' : '#f4e4c1';

                                    // Build item names for searching
                                    const allItems = [];
                                    for (const [gType, items] of Object.entries(data.byGift)) {
                                        for (const [key, item] of Object.entries(items)) {
                                            const itemName = item.category === 'gold' ? 'Gold' : getItemName(item.id, item.category);
                                            allItems.push(itemName.toLowerCase());
                                        }
                                    }

                                    html += `<div class="wf-row" data-name="${data.name.toLowerCase()}" data-items="${allItems.join(' ')}" style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid rgba(255,255,255,0.1);">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                    <span style="color:${nameColor};font-weight:bold;font-size:12px;">${data.name}</span>
                    <span style="color:#888;font-size:10px;">${Object.entries(data.giftCounts).sort((a,b) => parseInt(a[0]) - parseInt(b[0])).map(([gType, count]) => `${GIFT_TYPES[gType]?.name || gType} √ó${count}`).join(', ')}</span>
                </div>`;

                                    for (const [gType, items] of Object.entries(data.byGift).sort((a, b) => parseInt(a[0]) - parseInt(b[0]))) {
                                        const giftName = GIFT_TYPES[gType]?.name || `Gift ${gType}`;
                                        const count = data.giftCounts[gType] || 0;
                                        const itemsFormatted = Object.values(items).sort((a, b) => b.amount - a.amount).map(item => {
                                            const icon = categoryIcons[item.category] || 'üì¶';
                                            const name = item.category === 'gold' ? 'Gold' : getItemName(item.id, item.category);
                                            return `${icon} ${name} √ó${item.amount.toLocaleString()}`;
                                        }).join(', ');

                                        html += `<div style="margin-left:8px;margin-bottom:4px;">
                    <span style="color:#ffd700;font-size:11px;">${giftName} √ó${count}:</span>
                    <div style="color:#ccc;font-size:10px;margin-left:8px;line-height:1.4;">${itemsFormatted}</div>
                </div>`;
                                    }

                                    html += `</div>`;
                                }
                            }
                            html += `</div></div>`;

                            // Column 2: Œ£ Received (totals with player breakdown)
                            html += `<div style="flex:1;background:rgba(255,100,100,0.15);padding:10px;border-radius:6px;display:flex;flex-direction:column;max-height:500px;">
        <div style="position:sticky;top:0;background:rgba(50,20,20,0.98);padding:5px;margin:-10px -10px 0 -10px;border-radius:6px 6px 0 0;">
            <div style="color:#ff6b6b;font-weight:bold;font-size:13px;margin-bottom:6px;">Œ£ Received</div>
            <input type="text" class="wf-filter" data-col="recvTotals" placeholder="Filter..." style="width:calc(100% - 10px);padding:4px 6px;font-size:11px;background:#1a1408;border:1px solid #8b6914;border-radius:4px;color:#f4e4c1;">
        </div>
        <div id="wfCol2Content" style="overflow-y:auto;flex:1;margin-top:10px;">`;

                            const recvTotalsSorted = Object.values(totalsByCategory.recv)
                            .sort((a, b) => {
                                const aOrder = categoryOrder.indexOf(a.category);
                                const bOrder = categoryOrder.indexOf(b.category);
                                if (aOrder !== bOrder) return aOrder - bOrder;
                                return b.amount - a.amount;
                            });

                            if (recvTotalsSorted.length === 0) {
                                html += `<div style="color:#666;font-size:12px;">None</div>`;
                            } else {
                                for (const item of recvTotalsSorted) {
                                    const icon = categoryIcons[item.category] || 'üì¶';
                                    const name = item.category === 'gold' ? 'Gold' : getItemName(item.id, item.category);
                                    const key = `${item.category}|${item.id}`;
                                    const players = recvPlayerBreakdown[key] || [];

                                    const sortedPlayers = [...players].sort((a, b) => {
                                        if (a.isNpc && !b.isNpc) return -1;
                                        if (!a.isNpc && b.isNpc) return 1;
                                        return b.amount - a.amount;
                                    });

                                    const playerNames = sortedPlayers.map(p => p.name.toLowerCase()).join(' ');

                                    html += `<div class="wf-row" data-name="${name.toLowerCase()}" data-items="${playerNames}" style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid rgba(255,255,255,0.1);">
                <div style="display:flex;justify-content:space-between;font-size:12px;margin-bottom:4px;">
                    <span style="color:#eee;">${icon} ${name}</span>
                    <span style="color:#ff6b6b;font-weight:bold;">√ó${item.amount.toLocaleString()}</span>
                </div>`;

                                    for (const p of sortedPlayers) {
                                        html += `<div data-player="${p.name.toLowerCase()}" style="display:flex;justify-content:space-between;font-size:10px;margin-left:12px;">
    <span style="color:${p.isNpc ? '#4ae29a' : '#999'};">${p.name}</span>
    <span style="color:#ff8888;">√ó${p.amount.toLocaleString()}</span>
</div>`;
                                    }

                                    html += `</div>`;
                                }
                            }
                            html += `</div></div>`;

                            // Column 3: From Sending To (player breakdown)
                            html += `<div style="flex:1;background:rgba(74,226,154,0.08);padding:10px;border-radius:6px;display:flex;flex-direction:column;max-height:500px;">
        <div style="position:sticky;top:0;background:rgba(20,40,20,0.98);padding:5px;margin:-10px -10px 0 -10px;border-radius:6px 6px 0 0;">
            <div style="color:#4ae29a;font-weight:bold;font-size:13px;margin-bottom:6px;">üì§ From Sending To</div>
            <input type="text" class="wf-filter" data-col="sentTo" placeholder="Filter..." style="width:calc(100% - 10px);padding:4px 6px;font-size:11px;background:#1a1408;border:1px solid #8b6914;border-radius:4px;color:#f4e4c1;">
        </div>
        <div id="wfCol3Content" style="overflow-y:auto;flex:1;margin-top:10px;">`;

                            const sentPlayers = Object.entries(rewardsByPlayer.sent)
                            .filter(([id, data]) => Object.keys(data.byGift).length > 0)
                            .sort((a, b) => {
                                const aTotal = Object.values(a[1].giftCounts).reduce((s, c) => s + c, 0);
                                const bTotal = Object.values(b[1].giftCounts).reduce((s, c) => s + c, 0);
                                return bTotal - aTotal;
                            });

                            if (sentPlayers.length === 0) {
                                html += `<div style="color:#666;font-size:12px;">No rewards tracked</div>`;
                            } else {
                                for (const [id, data] of sentPlayers) {
                                    // Build item names for searching
                                    const allItems = [];
                                    for (const [gType, items] of Object.entries(data.byGift)) {
                                        for (const [key, item] of Object.entries(items)) {
                                            const itemName = item.category === 'gold' ? 'Gold' : getItemName(item.id, item.category);
                                            allItems.push(itemName.toLowerCase());
                                        }
                                    }

                                    html += `<div class="wf-row" data-name="${data.name.toLowerCase()}" data-items="${allItems.join(' ')}" style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid rgba(255,255,255,0.1);">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                    <span style="color:#f4e4c1;font-weight:bold;font-size:12px;">${data.name}</span>
                    <span style="color:#888;font-size:10px;">${Object.entries(data.giftCounts).sort((a,b) => parseInt(a[0]) - parseInt(b[0])).map(([gType, count]) => `${GIFT_TYPES[gType]?.name || gType} √ó${count}`).join(', ')}</span>
                </div>`;

                                    for (const [gType, items] of Object.entries(data.byGift).sort((a, b) => parseInt(a[0]) - parseInt(b[0]))) {
                                        const giftName = GIFT_TYPES[gType]?.name || `Gift ${gType}`;
                                        const count = data.giftCounts[gType] || 0;
                                        const itemsFormatted = Object.values(items).sort((a, b) => b.amount - a.amount).map(item => {
                                            const icon = categoryIcons[item.category] || 'üì¶';
                                            const name = item.category === 'gold' ? 'Gold' : getItemName(item.id, item.category);
                                            return `${icon} ${name} √ó${item.amount.toLocaleString()}`;
                                        }).join(', ');

                                        html += `<div style="margin-left:8px;margin-bottom:4px;">
                    <span style="color:#ffd700;font-size:11px;">${giftName} √ó${count}:</span>
                    <div style="color:#ccc;font-size:10px;margin-left:8px;line-height:1.4;">${itemsFormatted}</div>
                </div>`;
                                    }

                                    html += `</div>`;
                                }
                            }
                            html += `</div></div>`;

                            // Column 4: Œ£ Sent (totals with player breakdown)
                            html += `<div style="flex:1;background:rgba(74,226,154,0.15);padding:10px;border-radius:6px;display:flex;flex-direction:column;max-height:500px;">
        <div style="position:sticky;top:0;background:rgba(20,50,20,0.98);padding:5px;margin:-10px -10px 0 -10px;border-radius:6px 6px 0 0;">
            <div style="color:#4ae29a;font-weight:bold;font-size:13px;margin-bottom:6px;">Œ£ Sent</div>
            <input type="text" class="wf-filter" data-col="sentTotals" placeholder="Filter..." style="width:calc(100% - 10px);padding:4px 6px;font-size:11px;background:#1a1408;border:1px solid #8b6914;border-radius:4px;color:#f4e4c1;">
        </div>
        <div id="wfCol4Content" style="overflow-y:auto;flex:1;margin-top:10px;">`;

                            const sentTotalsSorted = Object.values(totalsByCategory.sent)
                            .sort((a, b) => {
                                const aOrder = categoryOrder.indexOf(a.category);
                                const bOrder = categoryOrder.indexOf(b.category);
                                if (aOrder !== bOrder) return aOrder - bOrder;
                                return b.amount - a.amount;
                            });

                            if (sentTotalsSorted.length === 0) {
                                html += `<div style="color:#666;font-size:12px;">None</div>`;
                            } else {
                                for (const item of sentTotalsSorted) {
                                    const icon = categoryIcons[item.category] || 'üì¶';
                                    const name = item.category === 'gold' ? 'Gold' : getItemName(item.id, item.category);
                                    const key = `${item.category}|${item.id}`;
                                    const players = sentPlayerBreakdown[key] || [];

                                    const sortedPlayers = [...players].sort((a, b) => b.amount - a.amount);
                                    const playerNames = sortedPlayers.map(p => p.name.toLowerCase()).join(' ');

                                    html += `<div class="wf-row" data-name="${name.toLowerCase()}" data-items="${playerNames}" style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid rgba(255,255,255,0.1);">
                <div style="display:flex;justify-content:space-between;font-size:12px;margin-bottom:4px;">
                    <span style="color:#eee;">${icon} ${name}</span>
                    <span style="color:#4ae29a;font-weight:bold;">√ó${item.amount.toLocaleString()}</span>
                </div>`;

                                    for (const p of sortedPlayers) {
                                        html += `<div data-player="${p.name.toLowerCase()}" style="display:flex;justify-content:space-between;font-size:10px;margin-left:12px;">
    <span style="color:${p.isNpc ? '#4ae29a' : '#999'};">${p.name}</span>
    <span style="color:#ff8888;">√ó${p.amount.toLocaleString()}</span>
</div>`;
                                    }

                                    html += `</div>`;
                                }
                            }
                            html += `</div></div>`;

                            html += `</div>`; // End 4 columns

                            return html;
                        };

                        // Render UI
                        const renderUI = () => {
                            let html = `
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding-bottom:10px;border-bottom:2px solid #c9a227;">
<h3 style="margin:0;color:#ffd700;font-size:16px;">üéÅ Winterfest Gifts${usingCachedData ? ` <span style="color:#ff9800;font-size:11px;font-weight:normal;">(üì¶ Cached: ${new Date(cacheTimestamp).toLocaleDateString()})</span>` : ''}</h3>
                <div style="display:flex;align-items:center;gap:15px;">
                    <div style="background:rgba(0,0,0,0.3);padding:5px 10px;border-radius:4px;">
                        <span style="color:#ffd700;">${CURRENCIES[16].icon}</span>
                        <span style="color:#4ae29a;font-weight:bold;">${balances[16].toLocaleString()}</span>
                    </div>
                    <div style="background:rgba(0,0,0,0.3);padding:5px 10px;border-radius:4px;">
                        <span style="color:#ffd700;">${CURRENCIES[63].icon}</span>
                        <span style="color:#4ae29a;font-weight:bold;">${balances[63].toLocaleString()}</span>
                    </div>
                    <button id="wfShowSummary" style="background:#4a3510;color:#ffd700;border:1px solid #8b6914;padding:5px 10px;border-radius:5px;cursor:pointer;font-size:12px;${sendLog.length === 0 ? 'display:none;' : ''}">üìã (${sendLog.length})</button>
                    <button id="wfGiftsClose" style="background:#ff4444;color:white;border:none;padding:5px 12px;border-radius:5px;cursor:pointer;font-size:14px;">‚úï</button>
                </div>
            </div>`;

                            // Tabs
                            html += `<div style="display:flex;gap:5px;margin-bottom:15px;">
    <button class="wf-tab" data-tab="players" style="padding:8px 20px;border:none;border-radius:6px 6px 0 0;cursor:pointer;font-size:13px;font-weight:bold;
        background:${currentTab === 'players' ? '#8b6914' : '#4a3510'};color:${currentTab === 'players' ? '#ffd700' : '#999'};">
        üë• Players
    </button>
    <button class="wf-tab" data-tab="rewards" style="padding:8px 20px;border:none;border-radius:6px 6px 0 0;cursor:pointer;font-size:13px;font-weight:bold;
        background:${currentTab === 'rewards' ? '#8b6914' : '#4a3510'};color:${currentTab === 'rewards' ? '#ffd700' : '#999'};">
        üéÅ Rewards
    </button>
    <button class="wf-tab" data-tab="droprates" style="padding:8px 20px;border:none;border-radius:6px 6px 0 0;cursor:pointer;font-size:13px;font-weight:bold;
        background:${currentTab === 'droprates' ? '#8b6914' : '#4a3510'};color:${currentTab === 'droprates' ? '#ffd700' : '#999'};">
        üìä Drop Rates
    </button>
</div>`;

                            // Tab content
                            html += `<div id="wfTabContent">`;
                            if (currentTab === 'players') {
                                html += renderPlayersTab();
                            } else if (currentTab === 'rewards') {
                                html += renderRewardsTab();
                            } else if (currentTab === 'droprates') {
                                html += renderDropRatesTab();
                            }
                            html += `</div>`;

                            popup.innerHTML = html;

                            // Attach event handlers
                            attachEventHandlers();
                        };

                        // Attach all event handlers
                        const attachEventHandlers = () => {
                            popup.querySelector('#wfGiftsClose').onclick = async () => {
                                if (sendLog.length > 0) await showFinalSummary();
                                modal.remove();
                            };

                            const summaryBtn = popup.querySelector('#wfShowSummary');
                            if (summaryBtn) summaryBtn.onclick = () => showFinalSummary();

                            // Tab click handlers
                            popup.querySelectorAll('.wf-tab').forEach(btn => {
                                btn.onclick = () => {
                                    currentTab = btn.dataset.tab;
                                    renderUI();
                                };
                            });
                            // Copy players handler
                            const copyPlayersBtn = popup.querySelector('#wfCopyPlayers');
                            if (copyPlayersBtn) {
                                copyPlayersBtn.onclick = () => {
                                    const lines = [];

                                    lines.push('=== WINTERFEST PLAYERS SUMMARY ===');
                                    lines.push(`Generated: ${new Date().toLocaleString()}${usingCachedData ? ' (from cache: ' + new Date(cacheTimestamp).toLocaleString() + ')' : ''}`);
                                    lines.push(`Ranking - Received: #${currentTopsData?.received?.place || '?'} (${currentTopsData?.received?.points?.toLocaleString() || 0} pts) | Sent: #${currentTopsData?.sent?.place || '?'} (${currentTopsData?.sent?.points?.toLocaleString() || 0} pts)`);
                                    lines.push('');

                                    // Header
                                    lines.push('Player\tUpgr Sent\tUpgr Recv\tPet Sent\tPet Recv\tAsc Sent\tAsc Recv\tSkin Sent\tSkin Recv\tTrans Sent\tTrans Recv\tPwr Sent\tPwr Recv\tTotal Sent\tTotal Recv\tBalance');

                                    // Combine players and NPCs
                                    const allEntries = [
                                        ...Object.entries(currentPersonStats),
                                        ...Object.entries(currentNpcStats).map(([id, npc]) => {
                                            let recvPts = 0;
                                            const recv = {};
                                            Object.entries(npc.gifts).forEach(([lib, cnt]) => {
                                                recv[lib] = cnt;
                                                recvPts += (GIFT_TYPES[lib]?.pts || 0) * cnt;
                                            });
                                            return [id, { name: npc.name, sent: {}, recv, sentPts: 0, recvPts, isNpc: true }];
                                        })
                                    ];

                                    // Totals
                                    const totals = { sent: {}, recv: {}, sentPts: 0, recvPts: 0 };
                                    for (let g = 1; g <= 6; g++) { totals.sent[g] = 0; totals.recv[g] = 0; }

                                    for (const [id, p] of allEntries) {
                                        const cols = [p.name];
                                        for (let g = 1; g <= 6; g++) {
                                            const s = p.sent[g] || 0;
                                            const r = p.recv[g] || 0;
                                            cols.push(s || '');
                                            cols.push(r || '');
                                            totals.sent[g] += s;
                                            totals.recv[g] += r;
                                        }
                                        cols.push(p.sentPts);
                                        cols.push(p.recvPts);
                                        cols.push(p.sentPts - p.recvPts);
                                        totals.sentPts += p.sentPts;
                                        totals.recvPts += p.recvPts;
                                        lines.push(cols.join('\t'));
                                    }

                                    // Totals row
                                    const totalCols = ['TOTALS'];
                                    for (let g = 1; g <= 6; g++) {
                                        totalCols.push(totals.sent[g] || '');
                                        totalCols.push(totals.recv[g] || '');
                                    }
                                    totalCols.push(totals.sentPts);
                                    totalCols.push(totals.recvPts);
                                    totalCols.push(totals.sentPts - totals.recvPts);
                                    lines.push('');
                                    lines.push(totalCols.join('\t'));

                                    const text = lines.join('\n');
                                    navigator.clipboard.writeText(text).then(() => {
                                        copyPlayersBtn.textContent = '‚úÖ';
                                        setTimeout(() => { copyPlayersBtn.textContent = 'üìã Copy'; }, 2000);
                                    });
                                };
                            }

                            // Copy rewards handler
                            const copyRewardsBtn = popup.querySelector('#wfCopyRewards');
                            if (copyRewardsBtn) {
                                copyRewardsBtn.onclick = () => {
                                    const lines = [];

                                    // Header
                                    lines.push('=== WINTERFEST REWARDS SUMMARY ===');
                                    lines.push(`Generated: ${new Date().toLocaleString()}${usingCachedData ? ' (from cache: ' + new Date(cacheTimestamp).toLocaleString() + ')' : ''}`);
                                    lines.push('');

                                    // Section 1: Received From (by player)
                                    lines.push('--- RECEIVED FROM (by player) ---');
                                    lines.push('Player\tGift Type\tItem\tAmount');
                                    const recvByPlayer = Object.entries(window._wfRewardsData?.rewardsByPlayer?.recv || {})
                                    .filter(([id, data]) => Object.keys(data.byGift).length > 0);
                                    for (const [id, data] of recvByPlayer) {
                                        for (const [gType, items] of Object.entries(data.byGift)) {
                                            const giftName = GIFT_TYPES[gType]?.name || `Gift ${gType}`;
                                            for (const item of Object.values(items)) {
                                                const icon = item.category === 'gold' ? 'üí∞' : '';
                                                const name = item.category === 'gold' ? 'Gold' : getItemName(item.id, item.category);
                                                lines.push(`${data.name}\t${giftName}\t${icon}${name}\t${item.amount}`);
                                            }
                                        }
                                    }
                                    lines.push('');

                                    // Section 2: Received Totals
                                    lines.push('--- RECEIVED TOTALS ---');
                                    lines.push('Item\tTotal Amount');
                                    const recvTotals = Object.values(window._wfRewardsData?.totalsByCategory?.recv || {})
                                    .sort((a, b) => b.amount - a.amount);
                                    for (const item of recvTotals) {
                                        const name = item.category === 'gold' ? 'Gold' : getItemName(item.id, item.category);
                                        lines.push(`${name}\t${item.amount}`);
                                    }
                                    lines.push('');

                                    // Section 3: From Sending To (by player)
                                    lines.push('--- FROM SENDING TO (by player) ---');
                                    lines.push('Player\tGift Type\tItem\tAmount');
                                    const sentByPlayer = Object.entries(window._wfRewardsData?.rewardsByPlayer?.sent || {})
                                    .filter(([id, data]) => Object.keys(data.byGift).length > 0);
                                    for (const [id, data] of sentByPlayer) {
                                        for (const [gType, items] of Object.entries(data.byGift)) {
                                            const giftName = GIFT_TYPES[gType]?.name || `Gift ${gType}`;
                                            for (const item of Object.values(items)) {
                                                const name = item.category === 'gold' ? 'Gold' : getItemName(item.id, item.category);
                                                lines.push(`${data.name}\t${giftName}\t${name}\t${item.amount}`);
                                            }
                                        }
                                    }
                                    lines.push('');

                                    // Section 4: Sent Totals
                                    lines.push('--- SENT TOTALS ---');
                                    lines.push('Item\tTotal Amount');
                                    const sentTotals = Object.values(window._wfRewardsData?.totalsByCategory?.sent || {})
                                    .sort((a, b) => b.amount - a.amount);
                                    for (const item of sentTotals) {
                                        const name = item.category === 'gold' ? 'Gold' : getItemName(item.id, item.category);
                                        lines.push(`${name}\t${item.amount}`);
                                    }

                                    const text = lines.join('\n');
                                    navigator.clipboard.writeText(text).then(() => {
                                        copyRewardsBtn.textContent = '‚úÖ Copied!';
                                        setTimeout(() => { copyRewardsBtn.textContent = 'üìã Copy All to Spreadsheet'; }, 2000);
                                    });
                                };
                            }

                            // Filter handlers for rewards tab

                            if (currentTab === 'rewards') {
                                let filterTimeout = null;

                                popup.querySelectorAll('.wf-filter').forEach(input => {
                                    const container = input.parentElement.nextElementSibling;
                                    if (!container) return;

                                    input.oninput = (e) => {
                                        if (filterTimeout) clearTimeout(filterTimeout);

                                        filterTimeout = setTimeout(() => {
                                            const filter = e.target.value.toLowerCase().trim();

                                            container.querySelectorAll('.wf-row').forEach(row => {
                                                const name = row.dataset.name || '';
                                                const items = row.dataset.items || '';

                                                if (!filter) {
                                                    // Show all rows and all player lines
                                                    row.style.display = '';
                                                    row.querySelectorAll('[data-player]').forEach(p => p.style.display = '');
                                                } else if (name.includes(filter)) {
                                                    // Item/player name matches - show whole row
                                                    row.style.display = '';
                                                    row.querySelectorAll('[data-player]').forEach(p => p.style.display = '');
                                                } else if (items.includes(filter)) {
                                                    // A player within this item matches - show row but highlight matching players
                                                    row.style.display = '';
                                                    row.querySelectorAll('[data-player]').forEach(p => {
                                                        const playerName = p.dataset.player || '';
                                                        p.style.display = playerName.includes(filter) ? '' : 'none';
                                                    });
                                                } else {
                                                    row.style.display = 'none';
                                                }
                                            });
                                        }, 150);
                                    };
                                });
                            }

                            // Copy buttons for drop rates
                            if (currentTab === 'droprates') {
                                popup.querySelectorAll('.wf-copy-btn').forEach(btn => {
                                    btn.onclick = async (e) => {
                                        const giftNum = e.target.dataset.gift;
                                        const text = window[`_wfClipboard_${giftNum}`];
                                        if (text) {
                                            await navigator.clipboard.writeText(text);
                                            e.target.textContent = '‚úì Copied!';
                                            setTimeout(() => { e.target.textContent = 'üìã Copy'; }, 1500);
                                        }
                                    };
                                });

                                const copyAllBtn = popup.querySelector('#wfCopyAll');
                                if (copyAllBtn) {
                                    copyAllBtn.onclick = async (e) => {
                                        if (window._wfClipboardAll) {
                                            await navigator.clipboard.writeText(window._wfClipboardAll);
                                            e.target.textContent = '‚úì Copied!';
                                            setTimeout(() => { e.target.textContent = 'üìã Copy All'; }, 1500);
                                        }
                                    };
                                }
                            }



                            if (currentTab === 'players') {
                                const updateCheckedCount = () => {
                                    const count = popup.querySelectorAll('.wf-player-check:checked').length;
                                    const countEl = popup.querySelector('#wfCheckedCount');
                                    if (countEl) countEl.textContent = `(${count} selected)`;
                                };

                                const checkAll = popup.querySelector('#wfCheckAll');
                                if (checkAll) {
                                    checkAll.onchange = (e) => {
                                        popup.querySelectorAll('.wf-player-check').forEach(cb => cb.checked = e.target.checked);
                                        updateCheckedCount();
                                    };
                                }

                                popup.querySelectorAll('.wf-player-check').forEach(cb => cb.onchange = updateCheckedCount);
                                updateCheckedCount();

                                // Sort column click handlers
                                popup.querySelectorAll('.wf-sort').forEach(th => {
                                    th.onclick = () => {
                                        const col = th.dataset.col;
                                        const colVal = isNaN(col) ? col : parseInt(col);

                                        if (currentSort.column === colVal) {
                                            currentSort.direction = currentSort.direction === 'desc' ? 'asc' : 'desc';
                                        } else {
                                            currentSort.column = colVal;
                                            currentSort.direction = 'desc';
                                        }

                                        renderUI();
                                    };
                                });

                                // Send to checked
                                const sendBtn = popup.querySelector('#wfSendChecked');
                                if (sendBtn) {
                                    sendBtn.onclick = async (e) => {
                                        const giftNum = parseInt(popup.querySelector('#wfBulkGiftType').value);
                                        if (!giftNum) {
                                            alert('Please select a gift type first!');
                                            return;
                                        }

                                        const checkedUsers = [];
                                        popup.querySelectorAll('.wf-player-check:checked').forEach(cb => {
                                            checkedUsers.push({ id: cb.dataset.userid, name: cb.dataset.username });
                                        });

                                        if (checkedUsers.length === 0) {
                                            alert('No players selected!');
                                            return;
                                        }

                                        const gift = GIFT_TYPES[giftNum];
                                        const totalCost = checkedUsers.length * gift.cost;
                                        const coinId = gift.coinId;
                                        const currency = CURRENCIES[coinId];
                                        const currentBal = balances[coinId];
                                        const remaining = currentBal - totalCost;

                                        const details = checkedUsers.map(u => u.name).join(', ');

                                        const confirmed = await showConfirmPopup(
                                            `üì§ Send ${gift.name}`,
                                            `Send ${gift.name} to ${checkedUsers.length} players?`,
                                            details,
                                            {
                                                currentBalance: currentBal,
                                                totalCost: totalCost,
                                                remaining: remaining,
                                                icon: currency.icon
                                            }
                                        );

                                        if (!confirmed) return;

                                        popup.querySelectorAll('button, select, input').forEach(el => el.disabled = true);
                                        e.target.textContent = 'Sending...';

                                        await sendGiftBatch(checkedUsers, giftNum);

                                        await fetchData();
                                        renderUI();
                                    };
                                }

                                // Match buttons
                                popup.querySelectorAll('.wf-match-all').forEach(btn => {
                                    btn.onclick = async (e) => {
                                        const giftNum = parseInt(e.target.dataset.gift);

                                        const needsList = [];
                                        Object.entries(currentPersonStats).forEach(([id, p]) => {
                                            const sent = p.sent[giftNum] || 0;
                                            const recv = p.recv[giftNum] || 0;
                                            const deficit = recv - sent;
                                            if (deficit > 0) {
                                                needsList.push({ id, name: p.name, deficit });
                                            }
                                        });

                                        if (needsList.length === 0) {
                                            alert('No one needs this gift type!');
                                            return;
                                        }

                                        const gift = GIFT_TYPES[giftNum];
                                        const totalGifts = needsList.reduce((sum, u) => sum + u.deficit, 0);
                                        const maxDeficit = Math.max(...needsList.map(u => u.deficit));
                                        const totalCost = totalGifts * gift.cost;
                                        const coinId = gift.coinId;
                                        const currency = CURRENCIES[coinId];
                                        const currentBal = balances[coinId];
                                        const remaining = currentBal - totalCost;

                                        const details = needsList.map(u => `${u.name} √ó${u.deficit}`).join('\n');

                                        const confirmed = await showConfirmPopup(
                                            `üì§ Match ${gift.name} Deficits`,
                                            `Send ${gift.name} √ó${totalGifts} to ${needsList.length} players?\n(${maxDeficit} batch${maxDeficit > 1 ? 'es' : ''})`,
                                            details,
                                            {
                                                currentBalance: currentBal,
                                                totalCost: totalCost,
                                                remaining: remaining,
                                                icon: currency.icon
                                            }
                                        );

                                        if (!confirmed) return;

                                        popup.querySelectorAll('button, select, input').forEach(el => el.disabled = true);

                                        await sendGiftDeficits(needsList, giftNum, (status) => {
                                            e.target.textContent = status;
                                        });

                                        await fetchData();
                                        renderUI();
                                    };
                                });
                            }
                        };

                        // Extract rewards from gift
                        const extractRewards = (gift) => {
                            const rewards = {};
                            if (!gift.reward) return rewards;

                            const r = gift.reward;
                            if (r.consumable) {
                                rewards.consumable = {};
                                for (const [id, amt] of Object.entries(r.consumable)) {
                                    rewards.consumable[id] = parseInt(amt) || 0;
                                }
                            }
                            if (r.coin) {
                                rewards.coin = {};
                                for (const [id, amt] of Object.entries(r.coin)) {
                                    rewards.coin[id] = parseInt(amt) || 0;
                                }
                            }
                            if (r.fragmentSkin) {
                                rewards.fragmentSkin = {};
                                for (const [id, amt] of Object.entries(r.fragmentSkin)) {
                                    rewards.fragmentSkin[id] = parseInt(amt) || 0;
                                }
                            }
                            if (r.fragmentHero) {
                                rewards.fragmentHero = {};
                                for (const [id, amt] of Object.entries(r.fragmentHero)) {
                                    rewards.fragmentHero[id] = parseInt(amt) || 0;
                                }
                            }
                            if (r.fragmentTitanArtifact) {
                                rewards.fragmentTitanArtifact = {};
                                for (const [id, amt] of Object.entries(r.fragmentTitanArtifact)) {
                                    rewards.fragmentTitanArtifact[id] = parseInt(amt) || 0;
                                }
                            }
                            if (r.gold) {
                                rewards.gold = { gold: parseInt(r.gold) || 0 };
                            }
                            return rewards;
                        };

                        // Merge rewards into totals
                        const mergeRewards = (totals, rewards, giftNum) => {
                            if (!totals[giftNum]) totals[giftNum] = {};
                            for (const [category, items] of Object.entries(rewards)) {
                                if (!totals[giftNum][category]) totals[giftNum][category] = {};
                                for (const [itemId, amount] of Object.entries(items)) {
                                    totals[giftNum][category][itemId] = (totals[giftNum][category][itemId] || 0) + amount;
                                }
                            }
                        };

                        // Render Drop Rates tab
                        const renderDropRatesTab = () => {
                            // Get myId for debug
                            let myId = '';
                            try {
                                const userInfo = HWHFuncs.getUserInfo();
                                myId = userInfo?.id?.toString() || '';
                            } catch(e) {
                                myId = localStorage['userId'] || '';
                            }

                            // Track drops separately for sent and received
                            const dropsByGiftType = {
                                recv: {},
                                sent: {},
                                combined: {}
                            };

                            // Process a gift into the appropriate tracker
                            const processGift = (gift, tracker) => {
                                if (gift.opened !== '1' || !gift.reward) return;

                                const lib = gift.libId;
                                if (!tracker[lib]) {
                                    tracker[lib] = { total: 0, drops: {}, battlePass: { recv: 0, sent: 0 } };
                                }
                                tracker[lib].total++;

                                const r = gift.reward;

                                const processCategory = (category, items, prefix = '') => {
                                    if (!items) return;
                                    for (const [id, amt] of Object.entries(items)) {
                                        const amount = parseInt(amt) || 0;
                                        const key = `${prefix || category}|${id}|${amount}`;
                                        if (!tracker[lib].drops[key]) {
                                            tracker[lib].drops[key] = { category: prefix || category, id, amount, count: 0 };
                                        }
                                        tracker[lib].drops[key].count++;
                                    }
                                };

                                processCategory('consumable', r.consumable);
                                processCategory('coin', r.coin);
                                processCategory('fragmentSkin', r.fragmentSkin, 'skin');
                                processCategory('fragmentHero', r.fragmentHero, 'hero');
                                processCategory('fragmentTitanArtifact', r.fragmentTitanArtifact, 'titan');
                                if (r.gold) {
                                    const key = `gold|gold|${r.gold}`;
                                    if (!tracker[lib].drops[key]) {
                                        tracker[lib].drops[key] = { category: 'gold', id: 'gold', amount: parseInt(r.gold), count: 0 };
                                    }
                                    tracker[lib].drops[key].count++;
                                }

                                // Track battlepass XP
                                if (r.battlePassExp) {
                                    for (const [id, amt] of Object.entries(r.battlePassExp)) {
                                        tracker[lib].battlePass = tracker[lib].battlePass || { total: 0 };
                                        tracker[lib].battlePass.total = (tracker[lib].battlePass.total || 0) + (parseInt(amt) || 0);
                                    }
                                }
                            };

                            // Track battlepass separately for recv/sent
                            const battlePassTotals = { recv: {}, sent: {} };

                            // Process from raw gift data
                            if (window._wfRawGifts) {
                                window._wfRawGifts.recv.forEach(g => {
                                    processGift(g, dropsByGiftType.recv);
                                    processGift(g, dropsByGiftType.combined);
                                    if (g.opened === '1' && g.reward?.battlePassExp) {
                                        const lib = g.libId;
                                        if (!battlePassTotals.recv[lib]) battlePassTotals.recv[lib] = 0;
                                        for (const amt of Object.values(g.reward.battlePassExp)) {
                                            battlePassTotals.recv[lib] += parseInt(amt) || 0;
                                        }
                                    }
                                });
                                window._wfRawGifts.sent.forEach(g => {
                                    processGift(g, dropsByGiftType.sent);
                                    processGift(g, dropsByGiftType.combined);
                                    if (g.opened === '1' && g.reward?.battlePassExp) {
                                        const lib = g.libId;
                                        if (!battlePassTotals.sent[lib]) battlePassTotals.sent[lib] = 0;
                                        for (const amt of Object.values(g.reward.battlePassExp)) {
                                            battlePassTotals.sent[lib] += parseInt(amt) || 0;
                                        }
                                    }
                                });
                            }

                            const categoryIcons = {
                                consumable: 'üß™',
                                coin: 'üí∞',
                                skin: 'üëî',
                                hero: '‚≠ê',
                                titan: 'üîÆ',
                                gold: 'ü™ô',
                                battlePass: 'üé´'
                            };

                            // Build data for clipboard
                            const allClipboardData = [];

                            let html = `<div style="margin-bottom:12px;">
        <p style="color:#999;margin:0 0 10px 0;">Drop rates from opened chests (rate % with count, Œ£ = total amount)</p>
    </div>`;

                            for (let giftNum = 1; giftNum <= 6; giftNum++) {
                                const gift = GIFT_TYPES[giftNum];
                                const recvData = dropsByGiftType.recv[giftNum];
                                const sentData = dropsByGiftType.sent[giftNum];
                                const combinedData = dropsByGiftType.combined[giftNum];

                                if (!combinedData || combinedData.total === 0) {
                                    html += `<div style="margin-bottom:15px;padding:10px;background:rgba(0,0,0,0.2);border-radius:6px;border:1px solid #4a3510;">
                <div style="color:#ffd700;font-weight:bold;margin-bottom:5px;">${gift.name}</div>
                <div style="color:#666;font-size:12px;">No chests opened</div>
            </div>`;
                                    continue;
                                }

                                // Get all unique drop keys from combined
                                const allDropKeys = Object.keys(combinedData.drops);
                                const sortedDrops = allDropKeys
                                .map(key => combinedData.drops[key])
                                .sort((a, b) => b.count - a.count);

                                // Build clipboard text for this gift type
                                const clipboardLines = [`${gift.name} - ${recvData?.total || 0} recv, ${sentData?.total || 0} sent, ${combinedData.total} total`];
                                clipboardLines.push('Item\tAmt\tRecv %\t(#)\tŒ£ Recv\tSent %\t(#)\tŒ£ Sent\tTotal %\t(#)\tŒ£ Total');

                                html += `<div style="margin-bottom:15px;padding:12px;background:rgba(139,105,20,0.15);border-radius:8px;border:1px solid #8b6914;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                <span style="color:#ffd700;font-weight:bold;font-size:14px;">${gift.name}</span>
                <div style="display:flex;align-items:center;gap:10px;">
                    <div style="font-size:11px;">
                        <span style="color:#ff6b6b;margin-right:10px;">üì• ${recvData?.total || 0} recv</span>
                        <span style="color:#4ae29a;margin-right:10px;">üì§ ${sentData?.total || 0} sent</span>
                        <span style="color:#ffd700;">üì¶ ${combinedData.total} total</span>
                    </div>
                    <button class="wf-copy-btn" data-gift="${giftNum}" style="background:#4a3510;color:#ffd700;border:1px solid #8b6914;padding:3px 8px;border-radius:4px;cursor:pointer;font-size:10px;">üìã Copy</button>
                </div>
            </div>`;

                                html += `<table style="width:100%;border-collapse:collapse;font-size:10px;">
            <tr style="background:rgba(0,0,0,0.3);color:#999;">
                <th style="padding:4px 6px;text-align:left;">Item</th>
                <th style="padding:4px 6px;text-align:right;width:45px;">Amt</th>
                <th style="padding:4px 6px;text-align:right;width:75px;color:#ff6b6b;">Recv %</th>
                <th style="padding:4px 6px;text-align:right;width:55px;color:#ff6b6b;">Œ£ Recv</th>
                <th style="padding:4px 6px;text-align:right;width:75px;color:#4ae29a;">Sent %</th>
                <th style="padding:4px 6px;text-align:right;width:55px;color:#4ae29a;">Œ£ Sent</th>
                <th style="padding:4px 6px;text-align:right;width:75px;color:#ffd700;">Total %</th>
                <th style="padding:4px 6px;text-align:right;width:55px;color:#ffd700;">Œ£ Total</th>
            </tr>`;

                                let rowIndex = 0;
                                for (const drop of sortedDrops) {
                                    const icon = categoryIcons[drop.category] || 'üì¶';
                                    const name = drop.category === 'gold' ? 'Gold' : getItemName(drop.id,
                                                                                                 drop.category === 'skin' ? 'fragmentSkin' :
                                                                                                 drop.category === 'hero' ? 'fragmentHero' :
                                                                                                 drop.category === 'titan' ? 'fragmentTitanArtifact' : drop.category);

                                    const dropKey = `${drop.category}|${drop.id}|${drop.amount}`;
                                    const recvCount = recvData?.drops?.[dropKey]?.count || 0;
                                    const sentCount = sentData?.drops?.[dropKey]?.count || 0;
                                    const totalCount = drop.count;

                                    const recvTotal = recvCount * drop.amount;
                                    const sentTotal = sentCount * drop.amount;
                                    const allTotal = totalCount * drop.amount;

                                    const recvRate = recvData?.total ? ((recvCount / recvData.total) * 100).toFixed(1) : '0.0';
                                    const sentRate = sentData?.total ? ((sentCount / sentData.total) * 100).toFixed(1) : '0.0';
                                    const totalRate = ((totalCount / combinedData.total) * 100).toFixed(1);

                                    const rowBg = rowIndex % 2 === 0 ? 'rgba(255,255,255,0.05)' : 'transparent';

                                    // Add to clipboard data
                                    clipboardLines.push(`${name}\t√ó${drop.amount}\t${recvRate}%\t(${recvCount})\t${recvTotal}\t${sentRate}%\t(${sentCount})\t${sentTotal}\t${totalRate}%\t(${totalCount})\t${allTotal}`);

                                    html += `<tr style="background:${rowBg};">
                <td style="padding:4px 6px;color:#ccc;white-space:nowrap;">${icon} ${name}</td>
                <td style="padding:4px 6px;text-align:right;color:#888;">√ó${drop.amount.toLocaleString()}</td>
                <td style="padding:4px 6px;text-align:right;color:#ff6b6b;white-space:nowrap;">${recvCount > 0 ? `${recvRate}% <span style="color:#aa6666;">(${recvCount})</span>` : '-'}</td>
                <td style="padding:4px 6px;text-align:right;color:#ff8888;">${recvTotal > 0 ? recvTotal.toLocaleString() : '-'}</td>
                <td style="padding:4px 6px;text-align:right;color:#4ae29a;white-space:nowrap;">${sentCount > 0 ? `${sentRate}% <span style="color:#3a9a6a;">(${sentCount})</span>` : '-'}</td>
                <td style="padding:4px 6px;text-align:right;color:#6aff9a;">${sentTotal > 0 ? sentTotal.toLocaleString() : '-'}</td>
                <td style="padding:4px 6px;text-align:right;color:#ffd700;white-space:nowrap;">${totalRate}% <span style="color:#aa9922;">(${totalCount})</span></td>
                <td style="padding:4px 6px;text-align:right;color:#ffe766;">${allTotal.toLocaleString()}</td>
            </tr>`;
                                    rowIndex++;
                                }

                                // Add battlepass row
                                const bpRecv = battlePassTotals.recv[giftNum] || 0;
                                const bpSent = battlePassTotals.sent[giftNum] || 0;
                                const bpTotal = bpRecv + bpSent;
                                const bpPerChest = gift.bp;

                                if (bpTotal > 0) {
                                    const rowBg = rowIndex % 2 === 0 ? 'rgba(255,255,255,0.05)' : 'transparent';
                                    clipboardLines.push(`Battle Pass XP\t√ó${bpPerChest}\t-\t${bpRecv}\t-\t${bpSent}\t-\t${bpTotal}`);

                                    html += `<tr style="background:${rowBg};border-top:1px solid #4a3510;">
                <td style="padding:4px 6px;color:#ccc;white-space:nowrap;">${categoryIcons.battlePass} Battle Pass XP</td>
                <td style="padding:4px 6px;text-align:right;color:#888;">√ó${bpPerChest}</td>
                <td style="padding:4px 6px;text-align:right;color:#ff6b6b;">-</td>
                <td style="padding:4px 6px;text-align:right;color:#ff8888;">${bpRecv > 0 ? bpRecv.toLocaleString() : '-'}</td>
                <td style="padding:4px 6px;text-align:right;color:#4ae29a;">-</td>
                <td style="padding:4px 6px;text-align:right;color:#6aff9a;">${bpSent > 0 ? bpSent.toLocaleString() : '-'}</td>
                <td style="padding:4px 6px;text-align:right;color:#ffd700;">-</td>
                <td style="padding:4px 6px;text-align:right;color:#ffe766;">${bpTotal.toLocaleString()}</td>
            </tr>`;
                                }

                                html += `</table></div>`;

                                // Store clipboard data for this gift
                                window[`_wfClipboard_${giftNum}`] = clipboardLines.join('\n');
                                allClipboardData.push(clipboardLines.join('\n'));
                            }

                            // Store all clipboard data
                            window._wfClipboardAll = allClipboardData.join('\n\n');

                            // Grand totals
                            let totalRecv = 0, totalSent = 0, totalCombined = 0;
                            let totalBpRecv = 0, totalBpSent = 0;
                            for (let g = 1; g <= 6; g++) {
                                totalRecv += dropsByGiftType.recv[g]?.total || 0;
                                totalSent += dropsByGiftType.sent[g]?.total || 0;
                                totalCombined += dropsByGiftType.combined[g]?.total || 0;
                                totalBpRecv += battlePassTotals.recv[g] || 0;
                                totalBpSent += battlePassTotals.sent[g] || 0;
                            }

                            html += `<div style="margin-top:10px;padding:10px;background:rgba(255,215,0,0.1);border-radius:6px;border:1px solid #ffd700;">
        <div style="display:flex;justify-content:space-between;align-items:center;">
            <div style="display:flex;gap:20px;">
                <div><span style="color:#ff6b6b;">üì• Received:</span> <span style="font-weight:bold;">${totalRecv}</span></div>
                <div><span style="color:#4ae29a;">üì§ Sent:</span> <span style="font-weight:bold;">${totalSent}</span></div>
                <div><span style="color:#ffd700;">üì¶ Total:</span> <span style="font-weight:bold;">${totalCombined}</span></div>
                <div><span style="color:#ccc;">üé´ BP XP:</span> <span style="font-weight:bold;">${(totalBpRecv + totalBpSent).toLocaleString()}</span></div>
            </div>
            <button id="wfCopyAll" style="background:#4a3510;color:#ffd700;border:1px solid #8b6914;padding:4px 12px;border-radius:4px;cursor:pointer;font-size:11px;">üìã Copy All</button>
        </div>
    </div>`;
                            // Debug counts
                            const debugRecv = window._wfRawGifts?.recv?.filter(g => g.opened === '1').length || 0;
                            const debugSent = window._wfRawGifts?.sent?.filter(g => g.opened === '1').length || 0;
                            const debugSelf = window._wfRawGifts?.recv?.filter(g => g.opened === '1' && String(g.from) === myId).length || 0;
                            const debugNpc = window._wfRawGifts?.recv?.filter(g => g.opened === '1' && String(g.from).startsWith('-')).length || 0;
                            const debugPlayers = window._wfRawGifts?.recv?.filter(g => g.opened === '1' && !String(g.from).startsWith('-') && String(g.from) !== myId).length || 0;

                            html += `<div style="margin-top:10px;padding:8px;background:rgba(0,0,0,0.3);border-radius:4px;font-size:10px;color:#666;">
        Debug: Raw recv=${debugRecv} sent=${debugSent} | self=${debugSelf} npc=${debugNpc} players=${debugPlayers} | check=${debugSelf + debugNpc + debugPlayers}
    </div>`;

                            return html;
                        };
                        // Cache management
                        let usingCachedData = false;
                        let cacheTimestamp = null;

                        const saveGiftCache = (recvData, sentData, topsData, usersData) => {
                            try {
                                const cache = {
                                    timestamp: Date.now(),
                                    recvData,
                                    sentData,
                                    topsData,
                                    users: usersData
                                };
                                localStorage.setItem(WINTERFEST_GIFT_CACHE_KEY, JSON.stringify(cache));
                                debugLog('üéÅ Gift data cached');
                            } catch (e) {
                                console.warn('Could not cache gift data:', e);
                            }
                        };

                        const loadGiftCache = () => {
                            try {
                                const cached = localStorage.getItem(WINTERFEST_GIFT_CACHE_KEY);
                                if (!cached) return null;
                                const data = JSON.parse(cached);
                                const ageMs = Date.now() - data.timestamp;
                                const maxAgeMs = WINTERFEST_CACHE_DAYS * 24 * 60 * 60 * 1000;
                                if (ageMs > maxAgeMs) {
                                    localStorage.removeItem(WINTERFEST_GIFT_CACHE_KEY);
                                    return null;
                                }
                                return data;
                            } catch (e) {
                                return null;
                            }
                        };

                        // Fetch data from API
                        const fetchData = async () => {
                            try {
                                await getBalances();

                                let recvData, sentData, allUsers;

                                try {
                                    const [recvResp, sentResp] = await Promise.all([
                                        SendFunction(JSON.stringify({
                                            calls: [
                                                { name: "newYear_giftGet", args: { type: 0 }, ident: "received" },
                                                { name: "newYear_getPersonalTops", args: {}, ident: "tops" }
                                            ]
                                        })),
                                        SendFunction(JSON.stringify({
                                            calls: [{ name: "newYear_giftGet", args: { type: 1 }, ident: "sent" }]
                                        }))
                                    ]);

                                    recvData = recvResp.results.find(r => r.ident === 'received')?.result?.response;
                                    sentData = sentResp.results[0]?.result?.response;
                                    currentTopsData = recvResp.results.find(r => r.ident === 'tops')?.result?.response || {};

                                    if (recvData && sentData) {
                                        allUsers = { ...recvData.users, ...sentData.users };
                                        saveGiftCache(recvData, sentData, currentTopsData, allUsers);
                                    }
                                } catch (apiError) {
                                    console.warn('üéÅ API call failed, checking cache:', apiError);
                                    recvData = null;
                                    sentData = null;
                                }

                                // If API failed, try cache
                                if (!recvData || !sentData) {
                                    const cached = loadGiftCache();
                                    if (cached) {
                                        recvData = cached.recvData;
                                        sentData = cached.sentData;
                                        currentTopsData = cached.topsData || {};
                                        allUsers = cached.users || {};
                                        usingCachedData = true;
                                        cacheTimestamp = cached.timestamp;
                                        debugLog('üéÅ Using cached gift data from', new Date(cacheTimestamp).toLocaleString());
                                    } else {
                                        popup.innerHTML += `<p style="color:#ff6b6b;">‚ùå Could not load gift data (event may have ended, no cache available)</p>`;
                                        return false;
                                    }
                                }

                                // Get myId
                                let myId = '';
                                try {
                                    const userInfo = HWHFuncs.getUserInfo();
                                    myId = userInfo?.id?.toString() || '';
                                } catch(e) {
                                    myId = localStorage['userId'] || '';
                                }

                                currentNpcStats = {};
                                currentPersonStats = {};
                                rewardsByGiftType = { recv: {}, sent: {} };

                                recvData.gifts.forEach(g => {
                                    const id = String(g.from);
                                    const lib = g.libId;

                                    // Track rewards from received gifts
                                    if (g.opened === '1' && g.reward) {
                                        const rewards = extractRewards(g);
                                        mergeRewards(rewardsByGiftType.recv, rewards, lib);
                                    }

                                    // Track self gifts (questFarm) separately
                                    if (id === myId) {
                                        if (!currentNpcStats[SELF_ID]) currentNpcStats[SELF_ID] = { name: SELF_NAME, gifts: {}, total: 0 };
                                        currentNpcStats[SELF_ID].gifts[lib] = (currentNpcStats[SELF_ID].gifts[lib] || 0) + 1;
                                        currentNpcStats[SELF_ID].total++;
                                        return;
                                    }

                                    if (id.startsWith('-')) {
                                        if (!currentNpcStats[id]) currentNpcStats[id] = { name: NPC_NAMES[id] || `NPC ${id}`, gifts: {}, total: 0 };
                                        currentNpcStats[id].gifts[lib] = (currentNpcStats[id].gifts[lib] || 0) + 1;
                                        currentNpcStats[id].total++;
                                        return;
                                    }

                                    if (!currentPersonStats[id]) currentPersonStats[id] = { name: allUsers[id]?.name || id, sent: {}, recv: {}, sentPts: 0, recvPts: 0 };
                                    currentPersonStats[id].recv[lib] = (currentPersonStats[id].recv[lib] || 0) + 1;
                                    currentPersonStats[id].recvPts += GIFT_TYPES[lib]?.pts || 0;
                                });

                                sentData.gifts.forEach(g => {
                                    const id = String(g.to);
                                    const lib = g.libId;

                                    // Track rewards from sent gifts (rewards we got for sending)
                                    if (g.opened === '1' && g.reward) {
                                        const rewards = extractRewards(g);
                                        mergeRewards(rewardsByGiftType.sent, rewards, lib);
                                    }

                                    if (id === myId || g.reason !== 'send') return;

                                    if (!currentPersonStats[id]) currentPersonStats[id] = { name: allUsers[id]?.name || id, sent: {}, recv: {}, sentPts: 0, recvPts: 0 };
                                    currentPersonStats[id].sent[lib] = (currentPersonStats[id].sent[lib] || 0) + 1;
                                    currentPersonStats[id].sentPts += GIFT_TYPES[lib]?.pts || 0;
                                });

                                window._wfGiftUsers = currentPersonStats;
                                window._wfRewards = rewardsByGiftType;
                                window._wfRawGifts = {
                                    recv: recvData.gifts,
                                    sent: sentData.gifts
                                };

                                unopenedRecv = recvData.gifts.filter(g => g.opened === '0').length;
                                unopenedSent = sentData.gifts.filter(g => g.opened === '0').length;

                                // Calculate deficits
                                currentBehindByType = {};
                                for (let g = 1; g <= 6; g++) {
                                    currentBehindByType[g] = [];
                                    Object.entries(currentPersonStats).forEach(([id, p]) => {
                                        const sent = p.sent[g] || 0;
                                        const recv = p.recv[g] || 0;
                                        const deficit = recv - sent;
                                        if (deficit > 0) {
                                            currentBehindByType[g].push({ id, name: p.name, deficit });
                                        }
                                    });
                                }

                                return true;
                            } catch (e) {
                                console.error('üéÅ Gift tracker error:', e);
                                popup.innerHTML += `<p style="color:#ff6b6b;">‚ùå Error: ${e.message}</p>`;
                                return false;
                            }
                        };

                        // Initial load
                        if (await fetchData()) {
                            renderUI();
                        }
                    };

                    ModuleTracker.register('Winterfest Gifts');

                    // ================================================================
                    // WINTERFEST 2025 RANKINGS - Gifts Sent, Gifts Received, NY Tree
                    // ================================================================

                    window.showWinterfestRankings = async function() {
                        const SendFunction = getSend();
                        if (!SendFunction) {
                            alert('Send function not available');
                            return;
                        }

                        // Create modal
                        const modal = document.createElement('div');
                        modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); z-index: 999999;
        display: flex; justify-content: center; align-items: center;
    `;

                        const popup = document.createElement('div');
                        popup.style.cssText = `
        background: linear-gradient(135deg, #2d2416 0%, #1a1408 100%);
        border: 3px solid #c9a227; border-radius: 12px;
        padding: 20px; max-width: 950px; max-height: 95vh;
        overflow-y: auto; color: #f4e4c1;
        font-family: Arial, sans-serif;
    `;

                        popup.innerHTML = `
        <h3 style="margin: 0 0 15px 0; color: #ffd700; font-size: 18px; text-align: center;">üéÑ Winterfest 2025 Rankings</h3>
        <p style="text-align: center; color: #999;">Detecting server...</p>
    `;

                        modal.appendChild(popup);
                        document.body.appendChild(modal);
                        modal.onclick = (e) => { if (e.target === modal) modal.remove(); };

                        // Tab definitions
                        const tabs = [
                            { id: 'giftsSend', label: 'üéÅ Gifts Sent', valueField: 'giftsSum', isGuild: false },
                            { id: 'giftsReceived', label: 'üì¨ Gifts Received', valueField: 'giftsSum', isGuild: false },
                            { id: 'nyTree', label: 'üéÑ NY Tree', valueField: 'decorateActions', isGuild: true }
                        ];

                        // Auto-detect server first
                        let currentServer = window.serverId || 1;
                        try {
                            const detectResponse = await SendFunction(JSON.stringify({
                                calls: [{
                                    name: "topGet",
                                    args: { type: 'giftsSend', extraId: 0 },
                                    context: { actionTs: Date.now() },
                                    ident: "body"
                                }]
                            }));

                            const detectData = detectResponse?.results?.[0]?.result?.response;
                            if (detectData?.users) {
                                const firstUser = detectData.users[Object.keys(detectData.users)[0]];
                                if (firstUser?.serverId) {
                                    currentServer = parseInt(firstUser.serverId, 10);
                                    window.serverId = currentServer;
                                }
                            }
                        } catch (e) {
                            console.warn('Server detection failed:', e);
                        }

                        let activeTab = 0;
                        let cachedData = {};

                        // Build UI
                        popup.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #c9a227;">
            <h3 style="margin: 0; color: #ffd700; font-size: 18px;">üéÑ Winterfest 2025 Rankings</h3>
            <button id="closeBtn" style="background: #ff4444; color: white; border: none; padding: 5px 12px; border-radius: 5px; cursor: pointer; font-size: 14px;">‚úï</button>
        </div>

        <div id="tabBar" style="display: flex; gap: 4px; margin-bottom: 15px;">
            ${tabs.map((tab, i) => `
                <button class="wf-tab" data-index="${i}" style="
                    flex: 1; padding: 8px 12px; border: none; border-radius: 4px 4px 0 0; cursor: pointer;
                    font-size: 13px; font-weight: bold; transition: all 0.2s;
                    background: ${i === 0 ? '#8b6914' : '#4a3510'}; color: ${i === 0 ? '#ffd700' : '#999'};
                ">${tab.label}</button>
            `).join('')}
        </div>

        <div style="display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; align-items: center;">
            <div style="display: flex; align-items: center; gap: 8px;">
                <label style="color: #c9a227;">Server:</label>
                <input type="number" id="serverInput" value="${currentServer}" min="1" style="
                    width: 70px; padding: 5px 8px; border-radius: 4px; border: 1px solid #c9a227;
                    background: rgba(0,0,0,0.3); color: #fff; text-align: center;
                ">
                <button id="refreshBtn" style="background: #4CAF50; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">üîÑ Load</button>
            </div>

            <div style="border-left: 1px solid #555; padding-left: 15px; display: flex; align-items: center; gap: 8px;">
                <label style="color: #c9a227;">Export:</label>
                <input type="number" id="exportFrom" value="${currentServer}" min="1" style="
                    width: 55px; padding: 5px; border-radius: 4px; border: 1px solid #666;
                    background: rgba(0,0,0,0.3); color: #fff; text-align: center;
                ">
                <span style="color: #999;">to</span>
                <input type="number" id="exportTo" value="${currentServer}" min="1" style="
                    width: 55px; padding: 5px; border-radius: 4px; border: 1px solid #666;
                    background: rgba(0,0,0,0.3); color: #fff; text-align: center;
                ">
<label style="color: #666; font-size: 11px;">Delay:</label>
                <input type="number" id="exportDelay" value="100" min="50" max="5000" step="50" style="
                    width: 55px; padding: 5px; border-radius: 4px; border: 1px solid #666;
                    background: rgba(0,0,0,0.3); color: #fff; text-align: center;
                ">
                <span style="color: #666; font-size: 11px;">ms</span>
<button id="exportBtn" style="background: #2196F3; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">üì• Export</button>
                <button id="copyBtn" style="background: #9C27B0; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">üìã Copy</button>
            </div>
        </div>

        <div id="statusBar" style="display: none; margin-bottom: 10px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; text-align: center; color: #999;"></div>

        <div id="rankingsContent" style="text-align: center; color: #999;">Loading...</div>
    `;

                        popup.querySelector('#closeBtn').onclick = () => modal.remove();

                        const tabBar = popup.querySelector('#tabBar');
                        const serverInput = popup.querySelector('#serverInput');
                        const refreshBtn = popup.querySelector('#refreshBtn');
                        const exportFrom = popup.querySelector('#exportFrom');
                        const exportTo = popup.querySelector('#exportTo');
                        const exportDelay = popup.querySelector('#exportDelay');
                        const exportBtn = popup.querySelector('#exportBtn');
                        const copyBtn = popup.querySelector('#copyBtn');
                        const statusBar = popup.querySelector('#statusBar');
                        const rankingsContent = popup.querySelector('#rankingsContent');

                        // Update tab styles
                        function updateTabStyles() {
                            tabBar.querySelectorAll('.wf-tab').forEach((btn, i) => {
                                btn.style.background = i === activeTab ? '#8b6914' : '#4a3510';
                                btn.style.color = i === activeTab ? '#ffd700' : '#999';
                            });
                        }

                        // Load rankings for a server and tab
                        async function loadRankings(serverId, tabIndex = activeTab) {
                            const tab = tabs[tabIndex];
                            const cacheKey = `${tab.id}_${serverId}`;

                            rankingsContent.innerHTML = `<p style="color: #999;">Loading ${tab.label} for Server ${serverId}...</p>`;

                            // Check cache first
                            if (cachedData[cacheKey]) {
                                displayRankings(cachedData[cacheKey], serverId, tab);
                                return cachedData[cacheKey];
                            }

                            try {
                                const response = await SendFunction(JSON.stringify({
                                    calls: [{
                                        name: "topGet",
                                        args: { type: tab.id, extraId: 0, serverId: parseInt(serverId) },
                                        context: { actionTs: Date.now() },
                                        ident: "body"
                                    }]
                                }));

                                const data = response?.results?.[0]?.result?.response;
                                if (!data?.top || data.top.length === 0) {
                                    rankingsContent.innerHTML = `<p style="color: #ff6b6b;">No data for Server ${serverId}</p>`;
                                    return null;
                                }

                                cachedData[cacheKey] = data;
                                displayRankings(data, serverId, tab);
                                return data;
                            } catch (err) {
                                rankingsContent.innerHTML = `<p style="color: #ff6b6b;">Error: ${err.message}</p>`;
                                return null;
                            }
                        }

                        // Display rankings in 3 columns of 17
                        function displayRankings(data, serverId, tab) {
                            const myPlace = data.place || '?';
                            const myScore = data[tab.valueField] || 0;
                            const COLS = 3;
                            const ROWS = 17;

                            let html = `
            <div style="text-align: center; margin-bottom: 12px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 6px;">
                <span style="color: #fff;">Server ${serverId}</span>
                <span style="color: #4ae29a; margin-left: 15px;">Your Position: #${myPlace}</span>
                <span style="color: #999; margin-left: 15px;">Score: ${parseInt(myScore).toLocaleString()}</span>
            </div>
            <div style="display: flex; gap: 8px;">
        `;

                            for (let col = 0; col < COLS; col++) {
                                html += `
                <table style="flex: 1; border-collapse: collapse; font-size: 11px;">
                    <thead>
                        <tr style="background: #8b6914; color: #ffd700;">
                            <th style="padding: 3px; text-align: center; width: 25px;">#</th>
                            <th style="padding: 3px; text-align: left;">Name</th>
                            ${!tab.isGuild ? '<th style="padding: 3px; text-align: left;">Guild</th>' : ''}
                            <th style="padding: 3px; text-align: right;">Score</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

                                for (let row = 0; row < ROWS; row++) {
                                    const index = col * ROWS + row;
                                    if (index >= data.top.length) {
                                        html += `<tr><td colspan="${tab.isGuild ? 3 : 4}" style="padding: 2px; color: #333;">-</td></tr>`;
                                        continue;
                                    }

                                    const entry = data.top[index];
                                    const rank = index + 1;
                                    const score = parseInt(entry[tab.valueField] || 0);
                                    let name = 'Unknown';
                                    let guild = '';
                                    let highlight = '';

                                    if (tab.isGuild) {
                                        const clanId = entry.clanId;
                                        const clan = data.clans?.find(c => c.id === clanId);
                                        name = clan?.title || `Guild ${clanId}`;
                                    } else {
                                        const userId = entry.userId;
                                        const user = data.users?.[userId];
                                        name = user?.name || `User ${userId}`;
                                        guild = user?.clanTitle || '';
                                    }

                                    if (rank === 1) highlight = 'background: rgba(255, 215, 0, 0.2);';
                                    else if (rank === 2) highlight = 'background: rgba(192, 192, 192, 0.2);';
                                    else if (rank === 3) highlight = 'background: rgba(205, 127, 50, 0.2);';
                                    else if (rank == myPlace) highlight = 'background: rgba(74, 226, 154, 0.2);';

                                    html += `
                    <tr style="${highlight} border-bottom: 1px solid #333;">
                        <td style="padding: 2px; text-align: center; color: ${rank <= 3 ? '#ffd700' : '#999'};">${rank}</td>
                        <td style="padding: 2px; text-align: left; max-width: 90px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${name}">${name}</td>
                        ${!tab.isGuild ? `<td style="padding: 2px; text-align: left; max-width: 70px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; color: #888;" title="${guild}">${guild}</td>` : ''}
                        <td style="padding: 2px; text-align: right; color: #4ae29a;">${score.toLocaleString()}</td>
                    </tr>
                `;
                                }

                                html += `</tbody></table>`;
                            }

                            html += `</div>`;
                            rankingsContent.innerHTML = html;
                        }

                        // Tab click handler
                        tabBar.onclick = (e) => {
                            const btn = e.target.closest('.wf-tab');
                            if (!btn) return;
                            activeTab = parseInt(btn.dataset.index);
                            updateTabStyles();
                            loadRankings(serverInput.value);
                        };

                        // Refresh button
                        refreshBtn.onclick = () => {
                            const serverId = serverInput.value;
                            // Clear cache for this server to force refresh
                            tabs.forEach(tab => delete cachedData[`${tab.id}_${serverId}`]);
                            loadRankings(serverId);
                        };

                        // Shared export/copy logic
                        async function gatherData() {
                            const from = parseInt(exportFrom.value);
                            const to = parseInt(exportTo.value);
                            const delay = parseInt(exportDelay.value) || 100;
                            const tab = tabs[activeTab];

                            if (from > to) {
                                alert('From server must be <= To server');
                                return null;
                            }

                            const totalServers = to - from + 1;
                            if (totalServers > 50 && !confirm(`Export ${totalServers} servers? This will take ~${Math.ceil(totalServers * delay / 60000)} minutes.`)) {
                                return null;
                            }

                            exportBtn.disabled = true;
                            copyBtn.disabled = true;
                            exportBtn.textContent = '‚è≥...';
                            copyBtn.textContent = '‚è≥...';
                            statusBar.style.display = 'block';

                            const allData = [];
                            const typeName = tab.label.replace(/[^\w\s]/g, '').trim();

                            for (let serverId = from; serverId <= to; serverId++) {
                                const progress = ((serverId - from + 1) / totalServers * 100).toFixed(0);
                                const remaining = Math.ceil((to - serverId) * delay / 1000);
                                statusBar.innerHTML = `Server ${serverId}/${to} (${progress}%) - ~${remaining}s remaining`;

                                try {
                                    const response = await SendFunction(JSON.stringify({
                                        calls: [{
                                            name: "topGet",
                                            args: { type: tab.id, extraId: 0, serverId: serverId },
                                            context: { actionTs: Date.now() },
                                            ident: "body"
                                        }]
                                    }));

                                    const data = response?.results?.[0]?.result?.response;
                                    const topEntries = data?.top || [];

                                    // Always output 50 slots per server
                                    for (let rank = 1; rank <= 50; rank++) {
                                        const entry = topEntries[rank - 1];

                                        if (tab.isGuild) {
                                            if (entry) {
                                                const clanId = entry.clanId;
                                                const clan = data.clans?.find(c => c.id === clanId);
                                                allData.push({
                                                    Server: serverId,
                                                    Rank: rank,
                                                    GuildName: clan?.title || '',
                                                    GuildID: clanId,
                                                    Score: parseInt(entry[tab.valueField] || 0),
                                                    Members: clan?.membersCount || ''
                                                });
                                            } else {
                                                allData.push({
                                                    Server: serverId,
                                                    Rank: rank,
                                                    GuildName: '',
                                                    GuildID: '',
                                                    Score: '',
                                                    Members: ''
                                                });
                                            }
                                        } else {
                                            if (entry) {
                                                const userId = entry.userId;
                                                const user = data.users?.[userId];
                                                allData.push({
                                                    Server: serverId,
                                                    Rank: rank,
                                                    PlayerName: user?.name || '',
                                                    PlayerID: userId,
                                                    GuildName: user?.clanTitle || '',
                                                    GuildID: user?.clanId || '',
                                                    Level: user?.level || '',
                                                    Score: parseInt(entry[tab.valueField] || 0)
                                                });
                                            } else {
                                                allData.push({
                                                    Server: serverId,
                                                    Rank: rank,
                                                    PlayerName: '',
                                                    PlayerID: '',
                                                    GuildName: '',
                                                    GuildID: '',
                                                    Level: '',
                                                    Score: ''
                                                });
                                            }
                                        }
                                    }
                                } catch (err) {
                                    console.warn(`Server ${serverId} failed:`, err);
                                    // Still pad with 50 empty rows for failed servers
                                    for (let rank = 1; rank <= 50; rank++) {
                                        if (tab.isGuild) {
                                            allData.push({ Server: serverId, Rank: rank, GuildName: '', GuildID: '', Score: '', Members: '' });
                                        } else {
                                            allData.push({ Server: serverId, Rank: rank, PlayerName: '', PlayerID: '', GuildName: '', GuildID: '', Level: '', Score: '' });
                                        }
                                    }
                                }

                                if (serverId < to) {
                                    await new Promise(r => setTimeout(r, delay));
                                }
                            }

                            exportBtn.disabled = false;
                            copyBtn.disabled = false;
                            exportBtn.textContent = 'üì• Export';
                            copyBtn.textContent = 'üìã Copy';

                            return { allData, typeName, from, to, totalServers };
                        }

                        // Export button - download as file
                        exportBtn.onclick = async () => {
                            const result = await gatherData();
                            if (!result || result.allData.length === 0) {
                                statusBar.innerHTML = `‚ö†Ô∏è No data collected`;
                                return;
                            }

                            const { allData, typeName, from, to, totalServers } = result;
                            const headers = Object.keys(allData[0]);
                            const tsv = [
                                headers.join('\t'),
                                ...allData.map(row => headers.map(h => row[h] ?? '').join('\t'))
                            ].join('\n');

                            const blob = new Blob([tsv], { type: 'text/tab-separated-values' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `Winterfest_${typeName}_${from}-${to}_${Date.now()}.tsv`;
                            a.click();
                            URL.revokeObjectURL(url);

                            statusBar.innerHTML = `‚úÖ Exported ${allData.length} entries from ${totalServers} servers`;
                        };

                        // Copy button - copy to clipboard
                        copyBtn.onclick = async () => {
                            const result = await gatherData();
                            if (!result || result.allData.length === 0) {
                                statusBar.innerHTML = `‚ö†Ô∏è No data collected`;
                                return;
                            }

                            const { allData, totalServers } = result;
                            const headers = Object.keys(allData[0]);
                            const tsv = [
                                headers.join('\t'),
                                ...allData.map(row => headers.map(h => row[h] ?? '').join('\t'))
                            ].join('\n');

                            try {
                                await navigator.clipboard.writeText(tsv);
                                statusBar.innerHTML = `‚úÖ Copied ${allData.length} entries from ${totalServers} servers to clipboard`;
                            } catch (err) {
                                console.error('Clipboard write failed:', err);
                                statusBar.innerHTML = `‚ùå Clipboard access denied - try Export instead`;
                            }
                        };

                        // Initial load
                        await loadRankings(currentServer);
                    };


                    // Quiz Rankings - HWH Tweaker Integration with 2-Column Layout
                    // Add this complete function to your HWH Tweaker script

                    window.showQuizRankings = function() {
                        // Get current server ID
                        if (!window.serverId) {
                            try {
                                const req = {
                                    calls: [{
                                        name: "topGet",
                                        args: { type: "quiz", extraId: 0 },   // omit hard-coded serverId to prove detection
                                        context: { actionTs: Math.floor(Date.now()/1000) },
                                        ident: "body"
                                    }]
                                };

                                const sendFn =
                                      (typeof HWHFuncs?.Send === "function" ? HWHFuncs.Send.bind(HWHFuncs) :
                                       (typeof unsafeWindow !== "undefined" && typeof unsafeWindow.Send === "function") ? unsafeWindow.Send :
                                       (typeof window.Send === "function" ? window.Send :
                                        (typeof Send === "function" ? Send : null)));

                                if (!sendFn) {
                                    console.warn("[ServerDetect] ‚ùå No Send function available yet");
                                    return;
                                }
                                debugLog("[ServerDetect] ‚úÖ Using:", sendFn.name || "anonymous Send");

                                sendFn(req)
                                    .then(raw => {
                                    debugLog("[ServerDetect] ‚Ü© Raw response:", raw);
                                    return (typeof raw === "string" ? JSON.parse(raw) : raw);
                                })
                                    .then(resp => {
                                    const r0 = resp?.results?.[0];
                                    const users = r0?.result?.response?.users;
                                    if (!users) {
                                        console.warn("[ServerDetect] ‚ö† No users block in response");
                                        return;
                                    }

                                    const firstUser = users[Object.keys(users)[0]];
                                    const sid = parseInt(firstUser?.serverId, 10);
                                    if (!Number.isNaN(sid)) {
                                        window.serverId = sid;
                                        debugLog("[ServerDetect] üéØ Detected serverId =", sid);
                                    } else {
                                        console.warn("[ServerDetect] ‚ö† serverId missing in user entry:", firstUser);
                                    }
                                })
                                    .catch(e => {
                                    console.error("[ServerDetect] ‚ùå Send promise rejected:", e);
                                });

                            } catch (e) {
                                console.error("[ServerDetect] ‚ùå Immediate failure (before Send call):", e);
                            }
                        }
                        const existingPanel = document.getElementById('quiz-rankings-panel');
                        if (existingPanel) existingPanel.remove();

                        // Create the main panel - wider for 2 columns
                        const panel = document.createElement('div');
                        panel.id = 'quiz-rankings-panel';
                        panel.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        border: 2px solid #ffd700;
        border-radius: 10px;
        padding: 20px;
        z-index: 100000;
        box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        font-family: Arial, sans-serif;
        color: white;
        width: 1000px;
        max-width: 95vw;
        max-height: 90vh;
    `;

                        // Create header with close button
                        const header = document.createElement('div');
                        header.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        padding-bottom: 8px;
        border-bottom: 2px solid #ffd700;
    `;
                        header.innerHTML = `
        <h3 style="margin: 0; color: #ffd700; font-size: 18px;">üèÜ Quiz Rankings Explorer</h3>
        <button id="close-rankings" style="
            background: #ff4444;
            color: white;
            border: none;
            padding: 4px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        ">‚úï</button>
    `;
                        panel.appendChild(header);

                        // Create server input section
                        const serverSection = document.createElement('div');
                        serverSection.style.cssText = 'margin-bottom: 15px;';
                        serverSection.innerHTML = `
        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
            <label class="twk-gold">Server:</label>
            <input type="number" id="server-input" value="${window.serverId || 324}" style="
                padding: 5px 10px;
                border-radius: 5px;
                border: 1px solid #ffd700;
                background: rgba(255,255,255,0.1);
                color: white;
                width: 100px;
            ">
            <button id="refresh-rankings" style="
                background: #4CAF50;
                color: white;
                border: none;
                padding: 5px 15px;
                border-radius: 5px;
                cursor: pointer;
            ">üîÑ Refresh</button>
            <button id="export-current" style="
                background: #2196F3;
                color: white;
                border: none;
                padding: 5px 15px;
                border-radius: 5px;
                cursor: pointer;
            ">üíæ Export CSV</button>
        </div>
    `;
                        panel.appendChild(serverSection);

                        // Create rankings display area
                        const rankingsArea = document.createElement('div');
                        rankingsArea.id = 'rankings-display';
                        rankingsArea.style.cssText = `
        background: rgba(0,0,0,0.3);
        border-radius: 5px;
        padding: 10px;
        max-height: 550px;
        overflow-y: auto;
        margin-bottom: 15px;
    `;
                        rankingsArea.innerHTML = '<p>Click Refresh to load rankings...</p>';
                        panel.appendChild(rankingsArea);

                        // Create bulk export section - single line
                        const bulkSection = document.createElement('div');
                        bulkSection.style.cssText = `
        background: rgba(0,0,0,0.3);
        border-radius: 5px;
        padding: 8px;
        margin-top: 10px;
    `;
                        bulkSection.innerHTML = `
        <div style="display: flex; gap: 10px; align-items: center;">
            <span class="twk-gold-bold">üìä Bulk Export:</span>
            <label style="color: white;">From:</label>
            <input type="number" id="server-from" value="200" style="
                padding: 3px 5px;
                border-radius: 3px;
                border: 1px solid #ffd700;
                background: rgba(255,255,255,0.1);
                color: white;
                width: 60px;
            ">
            <label style="color: white;">To:</label>
            <input type="number" id="server-to" value="210" style="
                padding: 3px 5px;
                border-radius: 3px;
                border: 1px solid #ffd700;
                background: rgba(255,255,255,0.1);
                color: white;
                width: 60px;
            ">
            <button id="export-range" style="
                background: #ff9800;
                color: white;
                border: none;
                padding: 4px 12px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 13px;
            ">üì¶ Export All</button>
            <span id="export-progress" style="color: #ffd700; font-size: 12px;"></span>
        </div>
    `;
                        panel.appendChild(bulkSection);

                        // Add panel to page
                        document.body.appendChild(panel);

                        // Function to fetch rankings
                        async function fetchRankings(serverId) {
                            try {
                                const response = await Send({
                                    calls: [{
                                        name: "topGet",
                                        args: {
                                            type: "quiz",
                                            extraId: 0,
                                            serverId: parseInt(serverId)
                                        },
                                        context: {
                                            actionTs: Date.now()
                                        },
                                        ident: "body"
                                    }]
                                });

                                if (response?.results?.[0]?.result?.response?.top) {
                                    return response.results[0].result.response;
                                }
                                return null;
                            } catch (error) {
                                console.error('Error fetching rankings:', error);
                                return null;
                            }
                        }

                        // Function to display rankings with 2-column layout
                        function displayRankings(data, serverId) {
                            if (!data || !data.top) {
                                rankingsArea.innerHTML = `<p style="color: #ff4444;">‚ùå No data for Server ${serverId}</p>`;
                                return;
                            }

                            const players = data.top;
                            const users = data.users || {};
                            const activePlayers = players.filter(p => parseInt(p.points) > 0);

                            // Trophy emojis for top 3
                            const trophies = ['ü•á', 'ü•à', 'ü•â'];

                            // Build the HTML for 2-column layout
                            let html = `
            <div style="text-align: center; margin-bottom: 10px;">
                <h3 style="color: #ffd700; margin: 0; display: inline;">Server ${serverId} - Quiz Rankings</h3>
                <span style="color: #ffffff; margin-left: 20px;">Total: ${players.length} | Active: ${activePlayers.length}</span>
            </div>
            <div style="display: flex; gap: 15px;">
        `;

                            // Function to create a column of players
                            function createColumn(startIdx, endIdx) {
                                let columnHtml = `
                <div style="flex: 1;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="border-bottom: 2px solid #ffd700;">
                                <th style="padding: 4px; text-align: center; color: #ffd700; font-size: 12px;">Rank</th>
                                <th style="padding: 4px; text-align: left; color: #ffd700; font-size: 12px;">Name</th>
                                <th style="padding: 4px; text-align: center; color: #ffd700; font-size: 12px;">Lvl</th>
                                <th style="padding: 4px; text-align: right; color: #ffd700; font-size: 12px;">Points</th>
                                <th style="padding: 4px; text-align: left; color: #ffd700; font-size: 12px;">Clan</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

                                for (let i = startIdx; i < endIdx && i < players.length; i++) {
                                    const player = players[i];
                                    const user = users[player.userId];
                                    const name = (user?.name || `Team ${player.userId}`).substring(0, 16);
                                    const level = user?.level || '‚Äî';
                                    const clan = (user?.clanTitle || '---').substring(0, 14);
                                    const points = parseInt(player.points);
                                    const rank = i + 1;

                                    // Determine colors - matching Power Tournament style
                                    let nameColor = '#808080';  // Gray for inactive
                                    let rankColor = '#ffffff';  // Default white

                                    if (points > 0) {
                                        // Active players get colored based on rank
                                        if (rank === 1) {
                                            nameColor = '#FFD700';  // Gold
                                            rankColor = '#FFD700';
                                        } else if (rank === 2) {
                                            nameColor = '#FFA500';  // Orange
                                            rankColor = '#FFA500';
                                        } else if (rank === 3) {
                                            nameColor = '#FF8C00';  // Dark Orange
                                            rankColor = '#FF8C00';
                                        } else if (rank <= 10) {
                                            nameColor = '#00FF00';  // Green
                                            rankColor = '#FFFF00';  // Yellow rank numbers
                                        } else if (rank <= 20) {
                                            nameColor = '#00FF00';  // Green
                                            rankColor = '#ffffff';
                                        } else {
                                            nameColor = '#ffffff';  // White
                                            rankColor = '#ffffff';
                                        }
                                    }

                                    const rankDisplay = rank <= 3 && points > 0 ?
                                          `${trophies[rank - 1]} ${rank}` :
                                    rank;

                                    columnHtml += `
                    <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <td style="padding: 3px; text-align: center; color: ${rankColor}; font-size: 11px; font-weight: ${rank <= 3 && points > 0 ? 'bold' : 'normal'};">${rankDisplay}</td>
                        <td style="padding: 3px; color: ${nameColor}; font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${name}</td>
                        <td style="padding: 3px; text-align: center; color: ${nameColor}; font-size: 11px;">${level}</td>
                        <td style="padding: 3px; text-align: right; color: ${points > 0 ? '#FFFF00' : '#808080'}; font-size: 11px; font-weight: ${rank <= 10 && points > 0 ? 'bold' : 'normal'};">${points}</td>
                        <td style="padding: 3px; color: ${nameColor}; font-size: 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${clan}</td>
                    </tr>
                `;
                                }

                                columnHtml += `
                        </tbody>
                    </table>
                </div>
            `;
                                return columnHtml;
                            }

                            // Create left column (1-25) and right column (26-50)
                            html += createColumn(0, 25);
                            html += createColumn(25, 50);
                            html += '</div>';

                            rankingsArea.innerHTML = html;

                            // Store current data for export
                            window.currentRankingData = { serverId, data };
                        }

                        // Function to export to CSV
                        function exportToCSV(rankings) {
                            const rows = [['Server', 'Rank', 'UserID', 'Name', 'Level', 'Points', 'Clan', 'Last Login']];

                            rankings.forEach(({ serverId, data }) => {
                                if (data && data.top) {
                                    data.top.forEach((player, index) => {
                                        const user = data.users?.[player.userId] || {};
                                        rows.push([
                                            serverId,
                                            index + 1,
                                            player.userId,
                                            user.name || `Player_${player.userId}`,
                                            user.level || '',
                                            player.points,
                                            user.clanTitle || '',
                                            user.lastLoginTime ? new Date(user.lastLoginTime * 1000).toISOString() : ''
                                        ]);
                                    });
                                }
                            });

                            const csv = rows.map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');
                            const blob = new Blob([csv], { type: 'text/csv' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `quiz_rankings_${new Date().toISOString().split('T')[0]}.csv`;
                            a.click();
                            URL.revokeObjectURL(url);
                        }

                        // Event listeners
                        document.getElementById('close-rankings').onclick = () => {
                            panel.remove();
                        };

                        document.getElementById('refresh-rankings').onclick = async () => {
                            const serverId = document.getElementById('server-input').value;
                            rankingsArea.innerHTML = '<p>Loading...</p>';
                            const data = await fetchRankings(serverId);
                            displayRankings(data, serverId);
                        };

                        document.getElementById('export-current').onclick = () => {
                            if (window.currentRankingData) {
                                exportToCSV([window.currentRankingData]);
                            } else {
                                alert('No data to export. Please refresh rankings first.');
                            }
                        };

                        document.getElementById('export-range').onclick = async () => {
                            const from = parseInt(document.getElementById('server-from').value);
                            const to = parseInt(document.getElementById('server-to').value);
                            const progress = document.getElementById('export-progress');

                            if (from > to) {
                                alert('Invalid range: From must be less than To');
                                return;
                            }

                            if (to - from > 50) {
                                if (!confirm(`This will fetch data from ${to - from + 1} servers. Continue?`)) {
                                    return;
                                }
                            }

                            const allRankings = [];

                            for (let serverId = from; serverId <= to; serverId++) {
                                progress.textContent = `Processing ${serverId}/${to}...`;
                                const data = await fetchRankings(serverId);
                                if (data) {
                                    allRankings.push({ serverId, data });
                                }
                                // Small delay to avoid overwhelming the server
                                await new Promise(resolve => setTimeout(resolve, 200));
                            }

                            progress.textContent = `Exporting ${allRankings.length} servers...`;
                            exportToCSV(allRankings);
                            progress.textContent = `‚úÖ Exported ${allRankings.length} servers!`;

                            setTimeout(() => {
                                progress.textContent = '';
                            }, 3000);
                        };
                    };
                    HWHFuncs.popup.confirm.__tweaker_hooked__ = true;
                    debugLog('HWH popup confirm hooked for Tweaker settings access');
                }
            }
        }, 5000);

        // ================================================================
        // COMPLETE ARENA STATS + ENHANCED SIDEBAR REPLACEMENT
        // Replace entire sidebar section in Tweaker 4.6
        // ================================================================

        // Arena Stats Storage Keys
        const STORAGE_KEY_ARENA = 'hwh_arena_battle_history';
        const STORAGE_KEY_GRAND = 'hwh_grand_battle_history';
        const MAX_HISTORY_SIZE = 500;

        // Arena Stats State
        let arenaHistory = [];
        let grandHistory = [];
        let currentUserId = null;

        // Try to get user ID from localStorage on startup
        try {
            // 1. Check our own cache first (fastest)
            const storedUserId = localStorage.getItem('hw_UserId');
            if (storedUserId) {
                currentUserId = parseInt(storedUserId, 10);
                debugLog('üîë User ID loaded from storage:', currentUserId);
            }

            // 2. Check HWH's localStorage key (very reliable)
            if (!currentUserId) {
                const hwUserId = localStorage.getItem('userId');
                if (hwUserId) {
                    currentUserId = parseInt(hwUserId, 10);
                    localStorage.setItem('hw_UserId', currentUserId);
                    debugLog('üîë User ID loaded from HWH localStorage:', currentUserId);
                }
            }
        } catch (e) {}

        // Helper function to get the "true" userId from game sources
        function getGameUserId() {
            // Check global userId variable
            if (typeof userId !== 'undefined' && userId) {
                return parseInt(userId, 10);
            }

            // Check HWH's localStorage
            const hwUserId = localStorage.getItem('userId');
            if (hwUserId) {
                return parseInt(hwUserId, 10);
            }

            // Check gameUserData
            try {
                const gameData = JSON.parse(localStorage.getItem('gameUserData'));
                const userIdKey = Object.keys(gameData)[0];
                if (userIdKey && !isNaN(userIdKey)) {
                    return parseInt(userIdKey, 10);
                }
            } catch (e) {}

            return null;
        }

        // Wait for game to fully load, then check global variables
        setTimeout(() => {
            // 3. Check global userId variable (set by HWH early in load)
            if (!currentUserId && typeof userId !== 'undefined' && userId) {
                currentUserId = parseInt(userId, 10);
                localStorage.setItem('hw_UserId', currentUserId);
                debugLog('üîë User ID captured from global userId:', currentUserId);
            }

            // 4. Check gameUserData as last fallback before prompt
            if (!currentUserId && localStorage.getItem('gameUserData')) {
                try {
                    const gameData = JSON.parse(localStorage.getItem('gameUserData'));
                    const userIdKey = Object.keys(gameData)[0];
                    if (userIdKey && !isNaN(userIdKey)) {
                        currentUserId = parseInt(userIdKey, 10);
                        localStorage.setItem('hw_UserId', currentUserId);
                        debugLog('üîë User ID loaded from gameUserData:', currentUserId);
                    }
                } catch (e) {}
            }

            // 5. Last resort: prompt user WITH VALIDATION
            if (!currentUserId) {
                const trueUserId = getGameUserId();

                if (trueUserId) {
                    // We found it in game sources - just use it!
                    currentUserId = trueUserId;
                    localStorage.setItem('hw_UserId', currentUserId);
                    debugLog('üîë User ID auto-detected:', currentUserId);
                } else {
                    // Truly can't find it anywhere - ask user
                    const userInput = prompt('Arena Stats needs your User ID to track battles.\n\nEnter your User ID (found in game settings/profile):');
                    if (userInput && !isNaN(userInput)) {
                        const enteredId = parseInt(userInput, 10);

                        // Double-check if we can now verify it
                        const verifyId = getGameUserId();
                        if (verifyId && verifyId !== enteredId) {
                            alert(`‚ö†Ô∏è Warning: You entered ${enteredId}, but the game shows ${verifyId}.\n\nUsing game's ID: ${verifyId}`);
                            currentUserId = verifyId;
                        } else {
                            currentUserId = enteredId;
                        }

                        localStorage.setItem('hw_UserId', currentUserId);
                        debugLog('üîë User ID set:', currentUserId);
                    }
                }
            }
        }, 3000);



        function isPet(id) {
            return id >= 6000;
        }


        // Load/Save History
        function loadArenaHistory(key) {
            try {
                const data = localStorage.getItem(key);
                return data ? JSON.parse(data) : [];
            } catch (e) {
                console.warn('Failed to load arena history:', e);
                return [];
            }
        }

        function saveArenaHistory(key, history) {
            try {
                localStorage.setItem(key, JSON.stringify(history));
            } catch (e) {
                console.warn('Failed to save arena history:', e);
            }
        }

        // Initialize histories
        arenaHistory = loadArenaHistory(STORAGE_KEY_ARENA);
        grandHistory = loadArenaHistory(STORAGE_KEY_GRAND);

        // ADD THESE DEBUG LINES:
        debugLog('üîç Arena history loaded:', arenaHistory.length, 'sessions');
        debugLog('üîç Grand history loaded:', grandHistory.length, 'sessions');
        debugLog('üîç Arena data:', arenaHistory);
        debugLog('üîç Grand data:', grandHistory);


        // Hook into XMLHttpRequest to detect arena screens AND battles
        // Skip if arena stats disabled for performance
        if (localStorage.getItem('hwh_arena_stats_enabled') === 'false') {
            debugLog('‚è∏Ô∏è Arena stats disabled - skipping XHR hook');
        } else {
            (function() {
                const originalOpen = XMLHttpRequest.prototype.open;
                const originalSend = XMLHttpRequest.prototype.send;

                // Call names we care about
                const TRACKED_CALLS = ['arena', 'grand', 'userGetInfo', 'clanWarGetInfo'];

                XMLHttpRequest.prototype.open = function(method, url, ...args) {
                    this._arenaTrackedUrl = url;
                    return originalOpen.call(this, method, url, ...args);
                };

                XMLHttpRequest.prototype.send = function(data) {
                    // Quick bail - only process /api/ calls
                    if (!this._arenaTrackedUrl || !this._arenaTrackedUrl.includes('/api/')) {
                        return originalSend.call(this, data);
                    }

                    // Quick string check before expensive JSON parse
                    const dataStr = typeof data === 'string' ? data : '';
                    const mightBeRelevant = TRACKED_CALLS.some(t => dataStr.includes(t));

                    if (!mightBeRelevant) {
                        return originalSend.call(this, data);
                    }

                    // Now parse - we likely have something relevant
                    let requestData = null;
                    try {
                        if (typeof data === 'string') {
                            requestData = JSON.parse(data);
                        } else if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
                            const decoder = new TextDecoder('utf-8');
                            requestData = JSON.parse(decoder.decode(data));
                        }
                    } catch (e) {
                        return originalSend.call(this, data);
                    }

                    if (!requestData?.calls) {
                        return originalSend.call(this, data);
                    }

                    const oldOnReadyStateChange = this.onreadystatechange;

                    this.onreadystatechange = function(e) {
                        if (this.readyState === 4 && this.status === 200) {
                            try {
                                let response;
                                if (this.responseType === 'json') {
                                    response = this.response;
                                } else {
                                    response = JSON.parse(this.responseText || this.response);
                                }

                                if (response?.results && Array.isArray(response.results)) {
                                    response.results.forEach((result, idx) => {
                                        const call = requestData.calls[idx];
                                        if (!call || !result.result?.response) return;

                                        const callName = call.name;
                                        const responseData = result.result.response;

                                        // Arena enemies screen
                                        if (callName === 'arenaFindEnemies' && Array.isArray(responseData)) {
                                            debugLog('‚öîÔ∏è Arena enemies detected:', responseData.length);
                                            updateStatsForEnemies(responseData, false);
                                        }

                                        // Grand arena enemies screen
                                        if (callName === 'grandFindEnemies' && Array.isArray(responseData)) {
                                            debugLog('üèÜ Grand Arena enemies detected:', responseData.length);
                                            updateStatsForEnemies(responseData, true);
                                        }

                                        // Capture user ID
                                        if (callName === 'userGetInfo' && responseData?.userId) {
                                            currentUserId = parseInt(responseData.userId, 10);
                                            debugLog('üë§ User ID captured:', currentUserId);
                                        }

                                        // Capture GW member tries
                                        if (callName === 'clanWarGetInfo' && responseData) {
                                            window.gwMemberTries = responseData.clanTries || {};
                                            window.gwMyTries = responseData.myTries ?? 0;
                                            window.gwEnemyTries = responseData.enemyClanTries || {};
                                            window.gwActive = !!responseData.enemyId;
                                            debugLog('‚öîÔ∏è GW Tries captured:', window.gwMyTries, 'active:', window.gwActive);
                                        }

                                        // Arena battle completed
                                        if (callName === 'arenaAttack' || callName === 'arenaEndBattle') {
                                            debugLog('‚öîÔ∏è Arena battle completed');
                                            if (currentUserId && responseData?.battles?.[0]) {
                                                const battleData = responseData.battles[0];
                                                const battleRecord = {
                                                    timestamp: Math.floor(Date.now() / 1000),
                                                    opponentId: parseInt(call.args?.userId, 10),
                                                    type: 'A',
                                                    myTeam: extractTeam(battleData.attackers),
                                                    opponentTeam: extractTeam(battleData.defenders[0] || battleData.defenders),
                                                    win: responseData.win || false
                                                };
                                                battleRecord.myTeamKey = generateTeamKey(battleRecord.myTeam);
                                                battleRecord.opponentTeamKey = generateTeamKey(battleRecord.opponentTeam);
                                                battleRecord.myTeamKeyNoPet = generateTeamKeyNoPet(battleRecord.myTeam);
                                                battleRecord.opponentTeamKeyNoPet = generateTeamKeyNoPet(battleRecord.opponentTeam);

                                                if (battleRecord.opponentId) {
                                                    debugLog('üíæ Saving arena battle');
                                                    addBattleToHistory(arenaHistory, STORAGE_KEY_ARENA, battleRecord, 1);
                                                }
                                            }
                                        }

                                        // Grand arena battle completed
                                        if (callName === 'grandAttack' || callName === 'grandEndBattle') {
                                            debugLog('üèÜ Grand Arena battle completed');
                                            if (currentUserId && responseData?.battles?.[0]) {
                                                const battleData = responseData.battles[0];
                                                const battleRecord = {
                                                    timestamp: Math.floor(Date.now() / 1000),
                                                    opponentId: parseInt(call.args?.userId, 10) || null,
                                                    type: 'A',
                                                    myTeam: extractTeam(battleData.attackers),
                                                    opponentTeam: extractTeam(battleData.defenders[0] || battleData.defenders),
                                                    win: responseData.win || false
                                                };
                                                battleRecord.myTeamKey = generateTeamKey(battleRecord.myTeam);
                                                battleRecord.opponentTeamKey = generateTeamKey(battleRecord.opponentTeam);
                                                battleRecord.myTeamKeyNoPet = generateTeamKeyNoPet(battleRecord.myTeam);
                                                battleRecord.opponentTeamKeyNoPet = generateTeamKeyNoPet(battleRecord.opponentTeam);

                                                if (battleRecord.opponentId) {
                                                    debugLog('üíæ Saving grand arena battle');
                                                    addBattleToHistory(grandHistory, STORAGE_KEY_GRAND, battleRecord, 2);
                                                }
                                            }
                                        }
                                    });
                                }
                            } catch (err) {
                                console.error('Arena hook error:', err);
                            }
                        }

                        if (oldOnReadyStateChange) {
                            return oldOnReadyStateChange.apply(this, arguments);
                        }
                    };

                    return originalSend.call(this, data);
                };
            })();
        } // end arena stats enabled check

        // Update stats tab when enemies are detected
        function updateStatsForEnemies(enemies, isGrand) {
            const statsContent = document.getElementById('stats-tab-content');
            if (!statsContent) return;

            const history = isGrand ? grandHistory : arenaHistory;
            const arenaType = isGrand ? 'üèÜ Grand Arena' : '‚öîÔ∏è Arena';

            let html = `<div style="text-align: center; color: #ffd700; font-weight: bold; font-size: 13px; margin-bottom: 12px;">${arenaType} - Current Enemies</div>`;

            enemies.forEach((enemy, idx) => {
                const enemyName = enemy.user?.name || enemy.name || 'Unknown';
                const enemyRank = enemy.place ? `[${enemy.place}]` : '';
                const enemyId = parseInt(enemy.user?.id || enemy.userId || enemy.id || 0, 10);

                // Get current enemy team
                let currentEnemyTeam = [];
                if (isGrand && enemy.heroes && enemy.heroes.length > 0) {
                    currentEnemyTeam = extractTeam(enemy.heroes[0]);
                } else if (!isGrand && enemy.heroes) {
                    currentEnemyTeam = extractTeam(enemy.heroes);
                }
                const currentEnemyTeamKey = generateTeamKey(currentEnemyTeam);

                // Find battles against this opponent's CURRENT team
                const sessions = history.filter(s => s.opponentId === enemyId && s.type === 'A');

                // Group by MY team composition
                const myTeamStats = {};

                sessions.forEach(session => {
                    session.battles.forEach(battle => {
                        // Only count battles vs their CURRENT team
                        if (battle.opponentTeamKey === currentEnemyTeamKey) {
                            const myTeamKey = battle.myTeamKey;

                            if (!myTeamStats[myTeamKey]) {
                                myTeamStats[myTeamKey] = {
                                    team: battle.myTeam,
                                    wins: 0,
                                    losses: 0
                                };
                            }

                            if (battle.win) {
                                myTeamStats[myTeamKey].wins++;
                            } else {
                                myTeamStats[myTeamKey].losses++;
                            }
                        }
                    });
                });

                // Calculate overall vs current team
                let totalWins = 0;
                let totalLosses = 0;
                Object.values(myTeamStats).forEach(stats => {
                    totalWins += stats.wins;
                    totalLosses += stats.losses;
                });

                const total = totalWins + totalLosses;
                const winRate = total > 0 ? ((totalWins / total) * 100).toFixed(0) : '0';

                const bgColor = total === 0 ? 'rgba(100,100,100,0.15)' :
                winRate >= 70 ? 'rgba(74,226,154,0.15)' :
                winRate >= 40 ? 'rgba(139,105,20,0.15)' :
                'rgba(255,107,107,0.15)';

                html += `
            <div style="background: ${bgColor}; padding: 8px; border-radius: 4px; margin-bottom: 8px; border-left: 3px solid ${total === 0 ? '#666' : winRate >= 70 ? '#4ae29a' : winRate >= 40 ? '#ffd700' : '#ff6b6b'};">
                <div class="enemy-header" data-enemy-id="${idx}" style="font-size: 12px; font-weight: bold; margin-bottom: 4px;">
                    <span class="enemy-collapse-icon">‚ñº</span>
                    <span class="twk-gold">${enemyName}</span>
                    <span style="color: #999; font-size: 11px;">${enemyRank}</span>
                </div>
                <div class="enemy-content" data-enemy-id="${idx}">
        `;

                if (total > 0) {
                    html += `
                <div style="font-size: 11px; margin-bottom: 6px;">
                    <span class="twk-green">W: ${totalWins}</span> /
                    <span class="twk-red">L: ${totalLosses}</span>
                    <span class="twk-gold"> (${winRate}%)</span>
                    <span style="color: #999; font-size: 10px;"> vs current team</span>
                </div>
            `;

                    // Show each of YOUR teams vs their current team
                    const sortedTeams = Object.values(myTeamStats).sort((a, b) => {
                        const aRate = a.wins / (a.wins + a.losses);
                        const bRate = b.wins / (b.wins + b.losses);
                        return bRate - aRate;
                    });

                    html += '<div style="margin-left: 10px; padding-top: 6px; border-top: 1px solid rgba(139,105,20,0.3);">';

                    sortedTeams.forEach(stats => {
                        const teamWinRate = ((stats.wins / (stats.wins + stats.losses)) * 100).toFixed(0);
                        const heroNames = stats.team.map(h => getHeroName(h.id)).join(', ');

                        html += `
                    <div style="font-size: 10px; padding: 3px 0; color: #ccc; line-height: 1.4;">
                        <div>
                            <span style="color: ${teamWinRate >= 70 ? '#4ae29a' : teamWinRate >= 40 ? '#ffd700' : '#ff6b6b'}; font-weight: bold;">
                                ${stats.wins}-${stats.losses} (${teamWinRate}%)
                            </span>
                        </div>
                        <div style="color: #999; font-size: 9px; margin-top: 2px;">
                            ${heroNames}
                        </div>
                    </div>
                `;
                    });

                    html += '</div>';
                } else {
                    html += '<div style="font-size: 11px;"><span class="twk-muted">No battle history vs current team</span></div>';
                }

                html += '</div></div>';
            });

            html += `
        <div style="text-align: center; margin-top: 14px;">
            <button id="view-overall-stats-btn" style="background: #8b6914; color: #ffd700; border: none; padding: 8px 14px; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: bold;">üìä View Overall Stats</button>
        </div>
    `;

            statsContent.innerHTML = html;

            // Add collapse/expand functionality
            statsContent.querySelectorAll('.enemy-header').forEach(header => {
                header.addEventListener('click', () => {
                    const enemyId = header.dataset.enemyId;
                    const content = statsContent.querySelector(`.enemy-content[data-enemy-id="${enemyId}"]`);
                    const icon = header.querySelector('.enemy-collapse-icon');

                    content.classList.toggle('collapsed');
                    icon.classList.toggle('collapsed');
                });
            });

            // Button to switch back to overall stats
            const viewOverallBtn = document.getElementById('view-overall-stats-btn');
            if (viewOverallBtn) {
                viewOverallBtn.addEventListener('click', () => {
                    loadStatsTab();
                });
            }
        }

        // Hero Name Resolution
        const heroNameCache = {};
        function getHeroName(heroId) {
            if (heroNameCache[heroId]) return heroNameCache[heroId];

            // Use cheats.translate - works for all heroes, titans, and pets
            try {
                if (typeof cheats !== 'undefined' && cheats.translate) {
                    const name = cheats.translate(`LIB_HERO_NAME_${heroId}`);
                    if (name && !name.startsWith('LIB_HERO_NAME_')) {
                        heroNameCache[heroId] = name;
                        return name;
                    }
                }
            } catch (e) {
                console.warn(`Failed to get name for hero ${heroId}:`, e);
            }

            // Fallback only if translate fails
            return `Hero_${heroId}`;
        }

        function generateTeamKey(team) {
            if (!team || !Array.isArray(team)) return '';
            return team.map(h => `${h.id}_${h.level || 0}_${h.color || 0}_${h.star || 0}`).join('|');
        }

        function generateTeamKeyNoPet(team) {
            if (!team || !Array.isArray(team)) return '';
            const noPetTeam = team.filter(h => !isPet(h.id));
            return noPetTeam.map(h => `${h.id}_${h.level || 0}_${h.color || 0}_${h.star || 0}`).join('|');
        }

        function extractTeam(heroes) {
            if (!heroes) return [];
            const teamArray = Array.isArray(heroes) ? heroes : Object.values(heroes);
            return teamArray.map(h => ({
                id: h.id || 0,
                level: h.level || 0,
                color: h.color || 0,
                star: h.star || 0
            })).filter(h => h.id > 0);
        }

        // Battle History Storage Function
        function addBattleToHistory(history, storageKey, battle, minWins = 1) {
            if (!battle) return;

            let session = history.find(s =>
                                       s.opponentId === battle.opponentId &&
                                       s.timestamp === battle.timestamp &&
                                       s.type === battle.type
                                      );

            if (!session) {
                session = {
                    opponentId: battle.opponentId,
                    timestamp: battle.timestamp,
                    type: battle.type,
                    battles: []
                };
                history.push(session);
            }

            const exists = session.battles.some(b =>
                                                b.opponentTeamKey === battle.opponentTeamKey &&
                                                b.myTeamKey === battle.myTeamKey
                                               );

            if (!exists) {
                session.battles.push(battle);
                const winCount = session.battles.filter(b => b.win).length;
                session.win = winCount >= minWins;

                if (history.length > MAX_HISTORY_SIZE) {
                    history.sort((a, b) => a.timestamp - b.timestamp);
                    history.shift();
                }

                // Debounce save to avoid blocking during rapid battles
                clearTimeout(window._arenaHistorySaveTimeout);
                window._arenaHistorySaveTimeout = setTimeout(() => {
                    saveArenaHistory(storageKey, history);
                }, 500);
                debugLog(`üíæ Battle saved to ${storageKey}`);
            }
        }
        // Enhanced Chat Sidebar with Mass PM and Stats Tab
        window.createChatPopup = function(){
            const existing = DOMCache.get('quickChatSidebar', '#quickChatSidebar');
            if (existing) {
                existing.classList.toggle('collapsed');
                return;
            }

            const savedUsers = JSON.parse(localStorage.getItem('quickChatUsers') || '[]');
            let guildMembers = [];
            let selectedRecipient = null;
            let selectedMembers = new Set();
            let currentSortMode = 'alphabetical'; // Default sort mode (A-Z within groups)

            let sidebarWidth = parseInt(localStorage.getItem('hwh_chat_sidebar_width') || '224');

            let warStatus = {
                gw: { active: false, tries: 0, targets: 0 },
                cow: { active: false, heroTries: 0, titanTries: 0, heroTargets: 0, titanTargets: 0 }
            };

            const sidebar = document.createElement('div');
            sidebar.id = 'quickChatSidebar';
            sidebar.className = '';

            sidebar.innerHTML = `
        <style>
            #quickChatSidebar {
                position: fixed;
                right: -${sidebarWidth}px;
                top: 50px;
                height: calc(100vh - 70px);
                background: linear-gradient(180deg, #2a1810 0%, #1a0f08 100%);
                border: 3px solid #8b6914;
                border-right: none;
                border-radius: 12px 0 0 12px;
                padding: 0;
                z-index: 9999;
                width: ${sidebarWidth}px;
                box-shadow: -4px 0 10px rgba(0,0,0,0.5);
                font-family: Arial, sans-serif;
                transition: right 0.3s ease-in-out;
                display: flex;
                flex-direction: column;
            }
            #quickChatSidebar:not(.collapsed) {
                right: 0;
            }
            #quickChatSidebar .resize-handle {
                position: absolute;
                left: 0;
                top: 0;
                width: 5px;
                height: 100%;
                cursor: ew-resize;
                background: rgba(255,215,0,0.1);
                z-index: 10;
            }
            #quickChatSidebar .resize-handle:hover {
                background: rgba(255,215,0,0.3);
            }
            #quickChatSidebar .toggle-btn {
                position: absolute;
                left: -30px;
                top: 50%;
                transform: translateY(-50%);
                width: 30px;
                height: 50px;
                background: linear-gradient(135deg, #8b6914 0%, #6d5210 100%);
                border: 2px solid #8b6914;
                border-right: none;
                border-radius: 8px 0 0 8px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                font-size: 16px;
                color: #ffd700;
                transition: all 0.2s ease;
                box-shadow: -2px 0 6px rgba(0,0,0,0.5);
            }
            #quickChatSidebar .toggle-btn:hover {
                background: linear-gradient(135deg, #a67c16 0%, #8b6914 100%);
                left: -32px;
            }

/* Quick Actions - COMPACT 40px height */
            .quick-actions-section {
                padding: 6px 6px 4px 6px;
                border-bottom: none;
                background: rgba(139,105,20,0.1);
            }

.quick-actions-section h4 {
    margin: 0 0 4px;
    padding-left: 8px;
    font-size: 10px;
    text-align: left;
    color: #ffd700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.quick-actions-section h4 .version-number {
    font-size: 9px;
    color: #999;
    font-weight: normal;
    text-transform: none;
    letter-spacing: normal;
}

/* Remove .quick-actions-grid - replace with individual rows */
.quick-actions-row {
    display: flex;
    gap: 2px;        /* Reduce from 3px to 2px - tighter horizontal spacing */
    margin-bottom: 2px;  /* Reduce from 3px to 2px - tighter vertical spacing */
    width: 100%;
    transition: opacity 0.3s ease;
}

.action-btn {
    background: transparent;
    border: none;
    padding: 0px 1px 2px 1px;  /* Reduce bottom padding from 3px to 2px */
    border-radius: 4px;
    cursor: pointer;
    flex: 1;
    min-height: 36px;  /* Reduce from 38px to 36px */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 0;
    transition: all 0.2s ease;
}

.action-btn:first-child { padding-left: 2px; }
.action-btn:last-child { padding-right: 2px; }

.action-btn span:first-child {
    height: 32px;
    width: 100%;
    border-radius: 4px;
    background: linear-gradient(135deg, #8b6914 0%, #6d5210 100%);
    border: 1px solid #a67c16;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    color: #ffd700;
    font-weight: bold;
    font-size: 13px;
    font-family: Arial, sans-serif;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 8px;
    box-sizing: border-box;
    transition: all 0.2s ease;
}

.action-btn:hover span:first-child {
    background: linear-gradient(135deg, #a67c16 0%, #8b6914 100%);
    transform: translateY(-1px);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
}

.action-btn:active {
    padding-top: 2px;
    padding-bottom: 1px;
}

.action-btn:active span:first-child {
    transform: translateY(0);
}

/* Blue collect button only */
.collect-btn span:first-child {
    background: linear-gradient(135deg, #4a90e2 0%, #2d5f8f 100%);
    border-color: #5ea8f3;
    color: #ffd700;
}

.collect-btn:hover span:first-child {
    background: linear-gradient(135deg, #5ea8f3 0%, #4a90e2 100%);
    transform: translateY(-1px);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
}
            /* Tabs */
            .chat-tabs {
                display: flex;
                background: rgba(0,0,0,0.2);
                margin-top: 0;
                padding-top: 0;
            }
.tab-btn {
    flex: 1;
    background: #4a3510;
    color: #999;
    border: none;
    padding: 6px;
    cursor: pointer;
    font-size: 10px;
    font-weight: bold;
    transition: all 0.2s ease;
}
            .tab-btn.active {
                background: #8b6914;
                color: #ffd700;
            }

            /* Tab content */
            .tab-content {
                display: none;
                flex: 1;
                overflow-y: auto;
                overflow-x: hidden;
                padding: 8px;
            }
            .tab-content.active {
                display: flex;
                flex-direction: column;
            }

            /* Mass PM - INLINE WITH ONLINE COUNT */
            .select-all-container {
                padding: 4px;
                background: linear-gradient(135deg, rgba(139,105,20,0.25) 0%, rgba(139,105,20,0.15) 100%);
                border-bottom: 2px solid #8b6914;
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: 8px;
                font-weight: bold;
                font-size: 11px;
                margin-bottom: 8px;
                border-radius: 4px 4px 0 0;
                color: #ffd700;
            }
            .select-all-left {
                display: flex;
                align-items: center;
                gap: 6px;
                flex: 1;
            }
            .select-all-container label {
                cursor: pointer;
                user-select: none;
                color: #ffd700;
            }
            .online-count {
                display: flex;
                flex-direction: column;
                align-items: center;
                color: #4ae29a;
                font-weight: bold;
                line-height: 1.1;
            }

            .members-header {
                display: flex;
                justify-content: flex-end;
                align-items: center;
                padding: 2px 0;
                border-bottom: 1px solid #8b6914;
                margin-bottom: 1px;
                font-size: 10px;
            }
            /* Hide the entire header when PM all button is not visible */
.members-header:has(.pm-all-btn[style*="display: none"]) {
    display: none;
}
            .members-header-buttons {
                display: flex;
                gap: 4px;
            }
.members-list {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE/Edge */
}
.members-list::-webkit-scrollbar {
    display: none; /* Chrome/Safari/Opera */
}
.member-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 2px 2px 2px 6px;  /* CHANGED: reduced from 3px to 2px */
    border-bottom: 1px solid #333;
    border-left: 3px solid transparent;
    cursor: pointer;
    transition: all 0.2s ease;
}
            .member-item:hover {
                background: rgba(139,105,20,0.2);
                border-left-color: #8b6914;
            }
            .member-item.online {
                border-left-color: #4ae29a;
            }
.member-checkbox {
    width: 14px;              /* CHANGED: reduced from 16px to 14px */
    height: 14px;             /* CHANGED: reduced from 16px to 14px */
    cursor: pointer;
    flex-shrink: 0;
    appearance: none;
    -webkit-appearance: none;
    background: #8b6914;
    border: 2px solid #a67c16;
    border-radius: 3px;
    position: relative;
}

.member-checkbox:checked::after {
    content: '‚úì';
    position: absolute;
    top: -3px;               /* CHANGED: adjusted for smaller size */
    left: 1px;               /* CHANGED: adjusted for smaller size */
    font-size: 12px;         /* CHANGED: reduced from 14px to 12px */
    font-weight: bold;
    color: #ffd700;
}

#select-all-members {
    width: 14px;             /* CHANGED: reduced from 16px to 14px */
    height: 14px;            /* CHANGED: reduced from 16px to 14px */
    appearance: none;
    -webkit-appearance: none;
    background: #8b6914;
    border: 2px solid #ffd700;
    border-radius: 3px;
    position: relative;
}
#select-all-members:checked::after {
    content: '‚úì';
    position: absolute;
    top: -3px;               /* CHANGED: adjusted for smaller size */
    left: 1px;               /* CHANGED: adjusted for smaller size */
    font-size: 12px;         /* CHANGED: reduced from 14px to 12px */
    font-weight: bold;
    color: #ffd700;
}
            .member-info {
                flex: 1;
                display: flex;
                align-items: center;
                gap: 4px;
                min-width: 0;
            }
            .status-dot {
                width: 6px;
                height: 6px;
                border-radius: 50%;
                flex-shrink: 0;
            }
            .status-dot.online {
                background: #4ae29a;
                box-shadow: 0 0 6px rgba(74,226,154,0.6);
            }
            .status-dot:not(.online) {
                background: #666;
            }
            .status-dot.away {
    background: #ffa500;  /* Orange */
    box-shadow: 0 0 6px rgba(255,165,0,0.6);
}

.member-item.away {
    border-left-color: #ffa500;
}
/* 4. Member name - make larger and bolder */
.member-name {
    font-size: 11px;         /* CHANGED: increased from 9px to 11px */
    color: #ccc;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    font-weight: 500;        /* ADDED: slightly bolder */
}

.member-name.owner {
    color: #ffd700;
    font-weight: bold;
}

/* 5. Member stats - make slightly larger */
.member-stats {
    font-size: 9px;          /* CHANGED: increased from 8px to 9px */
    color: #999;
    flex-shrink: 0;
}

            .mass-pm-btn {
                width: 100%;
                margin-top: 8px;
                background: linear-gradient(135deg, #4ae29a 0%, #2d8f5f 100%);
                color: #fff;
                border: 1px solid #5ef3a8;
                padding: 10px;
                border-radius: 5px;
                cursor: pointer;
                font-weight: bold;
                font-size: 12px;
                transition: all 0.2s ease;
                display: none;
            }
            .mass-pm-btn:hover {
                background: linear-gradient(135deg, #5ef3a8 0%, #4ae29a 100%);
                transform: translateY(-1px);
                box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            }

.refresh-btn, .pm-all-btn {
                background: #8b6914;
                color: #ffd700;
                border: 1px solid #8b6914;
                border-radius: 3px;
                cursor: pointer;
                font-size: 11px;
                transition: all 0.2s ease;
                min-width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 0;
            }
            .refresh-btn:hover, .pm-all-btn:hover {
                background: #a67c16;
                border-color: #ffd700;
            }
.sort-btn-compact {
                background: rgba(139,105,20,0.3);
                color: #ffd700;
                border: 1px solid #8b6914;
                padding: 3px 6px;
                border-radius: 3px;
                cursor: pointer;
                font-size: 11px;
                transition: all 0.2s ease;
                min-width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .sort-btn-compact:hover {
                background: rgba(139,105,20,0.5);
                border-color: #ffd700;
            }
            .sort-btn-compact.active {
                background: #8b6914;
                border-color: #ffd700;
                box-shadow: 0 0 6px rgba(255,215,0,0.4);
            }



            .enemy-header {
                cursor: pointer;
                user-select: none;
                display: flex;
                align-items: center;
                gap: 6px;
            }
            .enemy-collapse-icon {
                transition: transform 0.2s ease;
                font-size: 10px;
            }
            .enemy-collapse-icon.collapsed {
                transform: rotate(-90deg);
            }
            .enemy-content {
                max-height: 1000px;
                overflow: hidden;
                transition: max-height 0.3s ease;
            }
            .enemy-content.collapsed {
                max-height: 0;
            }

            /* Scrollbar */
            .members-list::-webkit-scrollbar,
            .tab-content::-webkit-scrollbar {
                width: 5px;
            }
            .members-list::-webkit-scrollbar-track,
            .tab-content::-webkit-scrollbar-track {
                background: rgba(0,0,0,0.2);
            }
            .members-list::-webkit-scrollbar-thumb,
            .tab-content::-webkit-scrollbar-thumb {
                background: rgba(139,105,20,0.5);
                border-radius: 3px;
            }
        </style>

        <div class="resize-handle" title="Drag to resize"></div>
<div class="toggle-btn" title="Toggle Chat Sidebar">‚ñ∂</div>

<!-- Quick Actions - COMPACT -->
<div class="quick-actions-section">
    <h4><span class="version-number">v${TWEAKER_VERSION}</span></h4>

    <!-- Row 1 -->
    <div class="quick-actions-row">
        <button class="action-btn" data-action="back">
            <span>‚óÄ Back</span>
        </button>
        <button class="action-btn" data-action="home">
            <span>üè† Home</span>
        </button>
    </div>

    <!-- Row 2 -->
    <div class="quick-actions-row">
        <button class="action-btn" data-action="sync">
            <span>üîÑ Sync</span>
        </button>
        <button class="action-btn" data-action="reload">
            <span>‚Üª Reload</span>
        </button>
    </div>

    <!-- Row 3 -->
    <div class="quick-actions-row">
        <button class="action-btn collect-btn" data-action="collect">
            <span>üéÅ Collect</span>
        </button>
<button class="action-btn settings-btn" data-action="settings">
            <span>‚öôÔ∏è Settings</span>
        </button>
    </div>
</div>

        <!-- Tabs - NOW WITH STATS -->
        <div class="chat-tabs">
            <button class="tab-btn members-tab active" data-tab="members">
                üë• Guild
            </button>
            <button class="tab-btn chat-tab" data-tab="chat">
                üí¨ Chat
            </button>
            <button class="tab-btn stats-tab" data-tab="stats">
                üìä Arena
            </button>
        </div>

<!-- Members Tab with Mass PM -->
<div class="tab-content members-content active">
    <div class="select-all-container">
        <div class="select-all-left">
            <input type="checkbox" id="select-all-members" class="member-checkbox">
            <label for="select-all-members">PM all</label>
        </div>
  <div style="display: flex; align-items: center; gap: 6px;">
            <span class="online-count"><span>Online</span><span><span id="onlineCount">0</span>/<span id="totalCount">0</span></span></span>
            <span id="warStatusDisplay" style="font-size: 10px; font-weight: bold;"></span>

<!-- Compact Sort & Refresh Buttons -->
          <button class="refresh-btn" id="refreshMembersBtn">üîÑ</button>
           <button class="sort-btn-compact active" id="sortToggleBtn" data-sort="alphabetical" title="Sort: A-Z (click to toggle to Last Active)">A</button>
        </div>
    </div>

    <div class="members-header">
        <div class="members-header-buttons">
<button class="pm-all-btn" id="pmAllBtn" style="display: none;">üì§ PM All</button>
        </div>
    </div>

            <div class="members-list" id="membersList" style="overflow-y: visible;">
                <div style="text-align: center; color: #999; font-size: 10px; padding: 20px;">
                    Loading members...
                </div>
            </div>
        </div>

        <!-- Chat Tab -->
        <div class="tab-content chat-content">
            <div class="chat-section">
                <h4 style="margin: 0 0 8px; font-size: 11px; color: #ffd700;">SEND MESSAGE TO:</h4>
                <button class="open-game-chat-btn" id="openGameChatBtn" style="width: 100%; padding: 8px; margin-bottom: 8px; background: #6d5210; color: #ffd700; border: 1px solid #8b6914; border-radius: 4px; cursor: pointer; font-size: 10px;">
                    üí¨ Open Game Chat
                </button>
                <button class="recipient-btn guild-chat-btn" data-type="guild" style="width: 100%; padding: 8px; background: #8b6914; color: #ffd700; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 10px;">
                    üì¢ Guild Chat (Quick)
                </button>

<!-- Direct User ID Input -->
                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #8b6914;">
                    <h4 style="margin: 0 0 8px; font-size: 11px; color: #ffd700;">DIRECT USER ID:</h4>
                    <div style="display: flex; gap: 4px; margin-bottom: 8px;">
                        <input type="text" id="directUserIdInput" placeholder="Enter User ID..." style="flex: 1; padding: 6px; background: rgba(0,0,0,0.3); border: 1px solid #8b6914; border-radius: 4px; color: #ffd700; font-size: 10px;">
                        <button id="selectUserIdBtn" style="padding: 6px 12px; background: #8b6914; color: #ffd700; border: none; border-radius: 4px; cursor: pointer; font-size: 10px; white-space: nowrap;">‚úì Select</button>
                    </div>
                    <div id="recentUsersContainer" style="display: none; margin-top: 8px;">
                        <h5 style="margin: 0 0 6px; font-size: 10px; color: #ccc;">Recent:</h5>
                        <div id="recentUsersList" style="max-height: 120px; overflow-y: auto;"></div>
                    </div>
                </div>

                <div id="selectedRecipientDisplay" style="display: none; margin-top: 8px;">
                    <div class="selected-recipient" style="background: rgba(139,105,20,0.3); padding: 6px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center;">
                        <span id="selectedRecipientName" style="font-size: 10px;">üë§ Selected</span>
                        <button class="clear-btn" style="background: #d32f2f; color: #fff; border: none; padding: 3px 6px; border-radius: 3px; cursor: pointer; font-size: 10px;">‚úï</button>
                    </div>
                </div>
            </div>

            <div class="message-compose" style="margin-top: 12px; flex: 1; display: flex; flex-direction: column;">
                <textarea id="messageInput" placeholder="Select recipient first..." style="flex: 1; width: 100%; min-height: 80px; padding: 6px; background: rgba(0,0,0,0.3); border: 1px solid #8b6914; border-radius: 4px; color: #ffd700; font-family: Arial; font-size: 10px; resize: vertical;" disabled></textarea>
<button class="send-btn" id="sendBtn" disabled style="width: 100%; margin-top: 8px; padding: 8px; background: #8b6914; color: #ffd700; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 11px;">üì§ Send Message</button>
</div>
</div>

<!-- Stats Tab (Arena Stats) - LAZY LOADED -->
<div class="tab-content stats-content">
    <div style="padding: 8px;">
        <div style="text-align: center; color: #ffd700; font-size: 11px; margin-bottom: 8px; font-weight: bold;">
            üìä Arena Battle Stats
                </div>
<div id="stats-tab-content" style="font-size: 10px; color: #ccc;">
    <div style="text-align: center; padding: 20px 10px; color: #999;">
        Click to load stats...
            </div>
</div>
</div>
</div>
`;

            document.body.appendChild(sidebar);
            document.getElementById('refreshMembersBtn').addEventListener('click', loadGuildMembers);

            let currentTab = 'members';
            let customMessage = '';

            // Resize handling
            let isResizing = false;
            const resizeHandle = sidebar.querySelector('.resize-handle');

            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.body.style.cursor = 'ew-resize';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const newWidth = window.innerWidth - e.clientX;
                if (newWidth >= 180 && newWidth <= 400) {
                    sidebarWidth = newWidth;
                    sidebar.style.width = `${newWidth}px`;
                    sidebar.style.right = sidebar.classList.contains('collapsed') ? `-${newWidth}px` : '0';
                }
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    localStorage.setItem('hwh_chat_sidebar_width', sidebarWidth);
                }
            });

            // Toggle sidebar
            sidebar.querySelector('.toggle-btn').addEventListener('click', () => {
                sidebar.classList.toggle('collapsed');
                const btn = sidebar.querySelector('.toggle-btn');
                btn.textContent = sidebar.classList.contains('collapsed') ? '‚óÄ' : '‚ñ∂';
            });

            // Tab switching
            sidebar.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const tab = btn.dataset.tab;
                    currentTab = tab;

                    sidebar.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    sidebar.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

                    btn.classList.add('active');
                    sidebar.querySelector(`.${tab}-content`).classList.add('active');

                    // LAZY LOAD: Load stats when Stats tab is clicked
                    if (tab === 'stats') {
                        loadStatsTab();
                    }
                });
            });

            // Quick Actions
            sidebar.querySelectorAll('.action-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const action = btn.dataset.action;
                    handleQuickAction(action);
                });
            });

            function handleQuickAction(action) {
                switch(action) {
                    case 'back':
                        document.dispatchEvent(new KeyboardEvent('keydown', {
                            key: 'Escape', keyCode: 27, bubbles: true
                        }));
                        break;
                    case 'home':
                        if (window.goHome) window.goHome();
                        break;
                    case 'sync':
                        silentSync();
                        break;
                    case 'reload':
                        location.reload();
                        break;
                    case 'collect':
                        if (window.runCollectMore) {
                            window.runCollectMore();
                        } else {
                            debugLog('Collect More function not available');
                        }
                        break;
                    case 'settings':
                        if (window.showTweakerSettings) {
                            window.showTweakerSettings();
                        }
                        break;
                }
            }

            // Select All checkbox
            const selectAllCheckbox = document.getElementById('select-all-members');
            const pmAllBtn = document.getElementById('pmAllBtn');
            const selectedCountSpan = document.getElementById('selected-count');

            selectAllCheckbox.addEventListener('change', (e) => {
                const checked = e.target.checked;
                selectedMembers.clear();

                sidebar.querySelectorAll('.member-checkbox:not(#select-all-members)').forEach(cb => {
                    cb.checked = checked;
                    if (checked) {
                        selectedMembers.add(cb.dataset.userId);
                    }
                });

                updateMassPmButton();
            });

            function updateMassPmButton() {
                pmAllBtn.style.display = selectedMembers.size > 0 ? 'block' : 'none';
            }

            // Mass PM Send - FIXED with correct chatType
            pmAllBtn.addEventListener('click', () => {
                if (selectedMembers.size === 0) return;

                // NEW: Instead of prompt, switch to Chat tab and set recipient
                selectRecipient({
                    type: 'mass-pm',
                    count: selectedMembers.size,
                    members: Array.from(selectedMembers)
                });

                // Switch to Chat tab
                currentTab = 'chat';
                sidebar.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                sidebar.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                sidebar.querySelector('.chat-tab').classList.add('active');
                sidebar.querySelector('.chat-content').classList.add('active');
            });

            function sortGuildMembers(mode) {
                currentSortMode = mode;

                guildMembers.sort((a, b) => {
                    // First: Online members on top
                    if (a.online && !b.online) return -1;
                    if (!a.online && b.online) return 1;

                    // Second: Away members
                    if (a.away && !b.away && !b.online) return -1;
                    if (!a.away && b.away && !a.online) return 1;

                    // Third: Apply sort within each status group
                    switch(mode) {
                        case 'alphabetical':
                            return a.name.localeCompare(b.name);

                        case 'last-active':
                            const timeA = a.lastAction || 0;
                            const timeB = b.lastAction || 0;
                            return timeB - timeA; // Most recent first

                        default:
                            return a.name.localeCompare(b.name);
                    }
                });

                displayMembers();
            }
            // Load guild members
            async function loadGuildMembers() {
                const refreshBtn = document.getElementById('refreshMembersBtn');
                if (refreshBtn) {
                    refreshBtn.textContent = '‚è≥';
                }

                try {
                    const SendFunction = getSend();

                    const response = await SendFunction(JSON.stringify({
                        calls: [
                            {name: "clanGetInfo", args: {}, context: {actionTs: Date.now()}, ident: "group_0_body"},
                            {name: "clanGetOnline", args: {}, context: {actionTs: Date.now() + 1}, ident: "group_1_body"},
                            {name: "clanWarGetBriefInfo", args: {}, context: {actionTs: Date.now() + 2}, ident: "gw_status"},
                            {name: "crossClanWar_getBriefInfo", args: {}, context: {actionTs: Date.now() + 3}, ident: "cow_status"},
                            {name: "clanWarGetInfo", args: {}, context: {actionTs: Date.now() + 4}, ident: "gw_member_tries"}
                        ]
                    }));

                    if (response?.results?.[0]?.result?.response?.clan?.members) {
                        const members = response.results[0].result.response.clan.members;
                        const onlineData = response.results[1]?.result?.response || {};

                        const now = Math.floor(Date.now() / 1000);
                        const AWAY_THRESHOLD = 120; // 2 minutes in seconds

                        guildMembers = Object.entries(members).map(([userId, memberData]) => {
                            const lastActionTime = onlineData[userId]?.lastAction || memberData.lastLoginTime || 0;
                            const isOnlineAPI = onlineData[userId]?.online === true;
                            const isRecent = (now - lastActionTime) < AWAY_THRESHOLD;

                            return {
                                id: userId,
                                name: memberData.name,
                                online: isOnlineAPI && isRecent,
                                away: isOnlineAPI && !isRecent,
                                lastAction: lastActionTime,
                                role: memberData.clanRole === '255' ? 'owner' : ''
                            };
                        });
                        // Extract war status
                        const gwData = response.results[2]?.result?.response;
                        const cowData = response.results[3]?.result?.response;

                        if (gwData) {
                            warStatus.gw = {
                                active: gwData.hasActiveWar,  // Just check if war is active
                                tries: gwData.tries || 0,
                                targets: gwData.targets || 0
                            };
                            debugLog('‚öîÔ∏è GW Status:', warStatus.gw);
                        }
                        if (cowData) {
                            warStatus.cow = {
                                active: cowData.hasActiveWar,  // Just check if war is active
                                heroTries: cowData.heroTries || 0,
                                titanTries: cowData.titanTries || 0,
                                heroTargets: cowData.heroTargets || 0,
                                titanTargets: cowData.titanTargets || 0
                            };
                            debugLog('üåç CoW Status:', warStatus.cow);
                        }
                        // Extract per-member GW tries
                        const gwMemberData = response.results[4]?.result?.response;
                        if (gwMemberData) {
                            window.gwMemberTries = gwMemberData.clanTries || {};
                            window.gwMyTries = gwMemberData.myTries ?? 0;
                            window.gwActive = !!gwMemberData.enemyId;
                            debugLog('‚öîÔ∏è GW Member Tries:', Object.keys(window.gwMemberTries).length, 'members, active:', window.gwActive);
                        }
                        sortGuildMembers(currentSortMode);

                        displayMembers();
                    }
                } catch (error) {
                    console.error('Failed to load guild members:', error);
                } finally {
                    if (refreshBtn) {
                        refreshBtn.textContent = 'üîÑ';
                    }
                }
            }



            function displayMembers() {
                const membersList = document.getElementById('membersList');
                const onlineCount = document.getElementById('onlineCount');
                const totalCount = document.getElementById('totalCount');
                // Update war status in header
                const warDisplay = document.getElementById('warStatusDisplay');
                if (warDisplay) {
                    warDisplay.innerHTML = getWarIndicators();
                }

                onlineCount.textContent = guildMembers.filter(m => m.online).length;
                totalCount.textContent = guildMembers.length;

                // Helper function to format time
                function formatTime(timestamp) {
                    if (!timestamp) return '?';
                    const now = Date.now() / 1000;
                    const diff = now - timestamp;
                    if (diff < 60) return 'now';
                    if (diff < 3600) return Math.floor(diff / 60) + 'm';
                    if (diff < 86400) return Math.floor(diff / 3600) + 'h';
                    return Math.floor(diff / 86400) + 'd';
                }
                // Helper function to build war indicators
                function getWarIndicators() {
                    let indicators = '';

                    // GW indicator - orange/gold color
                    if (warStatus.gw.active) {
                        if (warStatus.gw.tries === 0) {
                            indicators += ' <span style="color:#4ae29a;font-size:10px;" title="GW: Done">‚úì</span>';
                        } else {
                            indicators += ` <span style="color:#ffa500;font-size:10px;font-weight:bold;" title="GW: ${warStatus.gw.tries} attacks left">${warStatus.gw.tries}</span>`;
                        }
                    }

                    // CoW indicator - cyan/blue color
                    if (warStatus.cow.active) {
                        const cowTotal = warStatus.cow.heroTries + warStatus.cow.titanTries;
                        if (cowTotal === 0) {
                            indicators += ' <span style="color:#4ae29a;font-size:10px;" title="CoW: Done">‚úì</span>';
                        } else {
                            // Show hero|titan format if both have tries
                            if (warStatus.cow.heroTries > 0 && warStatus.cow.titanTries > 0) {
                                indicators += ` <span style="color:#00bfff;font-size:10px;font-weight:bold;" title="CoW: ${warStatus.cow.heroTries}H ${warStatus.cow.titanTries}T left">${warStatus.cow.heroTries}|${warStatus.cow.titanTries}</span>`;
                            } else if (warStatus.cow.heroTries > 0) {
                                indicators += ` <span style="color:#00bfff;font-size:10px;font-weight:bold;" title="CoW: ${warStatus.cow.heroTries} hero attacks left">${warStatus.cow.heroTries}H</span>`;
                            } else {
                                indicators += ` <span style="color:#00bfff;font-size:10px;font-weight:bold;" title="CoW: ${warStatus.cow.titanTries} titan attacks left">${warStatus.cow.titanTries}T</span>`;
                            }
                        }
                    }

                    return indicators;
                }
                // Helper function to get individual member's GW tries
                function getMemberWarIndicator(memberId) {
                    if (!window.gwActive) return '';

                    const tries = window.gwMemberTries?.[memberId];
                    if (tries === undefined) return '';

                    if (tries === 0) {
                        return ' <span style="color:#4ae29a;font-size:10px;" title="GW: Done">‚úì</span>';
                    } else {
                        return ` <span style="color:#ffa500;font-size:10px;font-weight:bold;" title="GW: ${tries} attacks left">${tries}</span>`;
                    }
                }

                membersList.innerHTML = guildMembers.map(member => `
                        <div class="member-item ${member.online ? 'online' : member.away ? 'away' : ''}" data-user-id="${member.id}" data-user-name="${member.name}">
                            <input type="checkbox" class="member-checkbox" data-user-id="${member.id}">
                                <div class="member-info">
                                    <div class="status-dot ${member.online ? 'online' : member.away ? 'away' : ''}"></div>
<div class="member-name ${member.role === 'owner' ? 'owner' : ''}">${member.name}</div>
${member.role === 'owner' ? '<span style="font-size: 9px;">üëë</span>' : ''}
</div>
<div class="member-stats">
    ${formatTime(member.lastAction)}${getMemberWarIndicator(member.id)}
</div>
</div>
`).join('');
                // Restore checkbox selections
                membersList.querySelectorAll('.member-checkbox').forEach(cb => {
                    if (selectedMembers.has(cb.dataset.userId)) {
                        cb.checked = true;
                    }
                });

                membersList.querySelectorAll('.member-checkbox').forEach(cb => {
                    cb.addEventListener('change', (e) => {
                        const userId = e.target.dataset.userId;
                        if (e.target.checked) {
                            selectedMembers.add(userId);
                        } else {
                            selectedMembers.delete(userId);
                            selectAllCheckbox.checked = false;
                        }
                        updateMassPmButton();
                    });
                });

                membersList.querySelectorAll('.member-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        if (e.target.classList.contains('member-checkbox')) return;

                        const userId = item.dataset.userId;
                        const userName = item.dataset.userName;
                        selectRecipient({ id: userId, name: userName, type: 'member' });

                        currentTab = 'chat';
                        sidebar.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                        sidebar.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                        sidebar.querySelector('.chat-tab').classList.add('active');
                        sidebar.querySelector('.chat-content').classList.add('active');
                    });
                });
            }

            function initializeSortButtons() {
                const sortToggle = document.getElementById('sortToggleBtn');

                if (sortToggle) {
                    sortToggle.addEventListener('click', (e) => {
                        e.stopPropagation();

                        // Toggle between modes
                        const currentMode = sortToggle.dataset.sort;
                        const newMode = currentMode === 'alphabetical' ? 'last-active' : 'alphabetical';

                        // Update button
                        sortToggle.dataset.sort = newMode;
                        if (newMode === 'alphabetical') {
                            sortToggle.textContent = 'A';
                            sortToggle.title = 'Sort: A-Z (click to toggle to Last Active)';
                        } else {
                            sortToggle.textContent = 'üïí';
                            sortToggle.title = 'Sort: Last Active (click to toggle to A-Z)';
                        }

                        // Perform sort
                        sortGuildMembers(newMode);

                        // Save preference
                        localStorage.setItem('hwh_member_sort_mode', newMode);
                    });
                }

                // Load saved sort preference
                const savedSort = localStorage.getItem('hwh_member_sort_mode') || 'alphabetical';
                if (sortToggle) {
                    sortToggle.dataset.sort = savedSort;
                    if (savedSort === 'alphabetical') {
                        sortToggle.textContent = 'A';
                        sortToggle.title = 'Sort: A-Z (click to toggle to Last Active)';
                    } else {
                        sortToggle.textContent = 'üïí';
                        sortToggle.title = 'Sort: Last Active (click to toggle to A-Z)';
                    }
                    currentSortMode = savedSort;
                }
            }



            function selectRecipient(recipient) {
                selectedRecipient = recipient;

                const display = document.getElementById('selectedRecipientDisplay');
                const nameSpan = document.getElementById('selectedRecipientName');
                const messageInput = document.getElementById('messageInput');
                const sendBtn = document.getElementById('sendBtn');

                if (recipient) {
                    if (recipient.type === 'guild') {
                        nameSpan.textContent = 'üí¨ Guild Chat';
                        messageInput.placeholder = 'Message to guild...';
                    } else if (recipient.type === 'mass-pm') {
                        // NEW: Handle mass PM recipient type
                        nameSpan.textContent = `üì§ PM All (${recipient.count} members)`;
                        messageInput.placeholder = `Message to ${recipient.count} guild members...`;
                    } else {
                        nameSpan.textContent = `üë§ ${recipient.name}`;
                        messageInput.placeholder = `Message to ${recipient.name}...`;
                    }
                    display.style.display = 'block';
                    messageInput.disabled = false;
                    messageInput.focus(); // Auto-focus for better UX
                    updateSendButton();
                }
            }

            function clearRecipient() {
                selectedRecipient = null;
                document.getElementById('selectedRecipientDisplay').style.display = 'none';
                document.getElementById('messageInput').placeholder = 'Select recipient first...';
                document.getElementById('messageInput').disabled = true;
                document.getElementById('sendBtn').disabled = true;
            }

            sidebar.querySelector('.guild-chat-btn').addEventListener('click', () => {
                selectRecipient({ type: 'guild', name: 'Guild Chat' });
            });

            sidebar.querySelector('#openGameChatBtn').addEventListener('click', () => {
                if (window.goGuildChat) {
                    window.goGuildChat();
                } else {
                    alert('Chat function not available');
                }
            });

            sidebar.querySelector('.clear-btn').addEventListener('click', clearRecipient);

            // Direct User ID functionality
            const MAX_RECENT_USERS = 10;

            function getRecentUsers() {
                const stored = localStorage.getItem('hwh_recent_user_ids');
                return stored ? JSON.parse(stored) : [];
            }

            function saveRecentUser(userId, userName) {
                let recent = getRecentUsers();
                // Remove if already exists
                recent = recent.filter(u => u.id !== userId);
                // Add to beginning with name
                recent.unshift({ id: userId, name: userName || `User ${userId}`, timestamp: Date.now() });
                // Keep only MAX_RECENT_USERS
                recent = recent.slice(0, MAX_RECENT_USERS);
                localStorage.setItem('hwh_recent_user_ids', JSON.stringify(recent));
                displayRecentUsers();
            }

            function deleteRecentUser(userId) {
                let recent = getRecentUsers();
                recent = recent.filter(u => u.id !== userId);
                localStorage.setItem('hwh_recent_user_ids', JSON.stringify(recent));
                displayRecentUsers();
            }
            function displayRecentUsers() {
                const recent = getRecentUsers();
                const container = document.getElementById('recentUsersContainer');
                const list = document.getElementById('recentUsersList');

                if (recent.length === 0) {
                    container.style.display = 'none';
                    return;
                }

                container.style.display = 'block';
                list.innerHTML = recent.map(user => {
                    const displayName = user.name || `User ${user.id}`;
                    return `
            <div class="recent-user-item" style="padding: 4px 6px; margin-bottom: 2px; background: rgba(139,105,20,0.2); border-radius: 3px; font-size: 10px; display: flex; justify-content: space-between; align-items: center; gap: 8px;">
                <span style="color: #ffd700; cursor: pointer; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" data-userid="${user.id}" title="${displayName} (${user.id})">üë§ ${displayName}</span>
                <button class="delete-user-btn" data-userid="${user.id}" style="background: #d32f2f; color: #fff; border: none; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 9px; flex-shrink: 0;">‚úï</button>
            </div>
        `;
                }).join('');

                // Add click handlers for selecting user
                list.querySelectorAll('.recent-user-item span[data-userid]').forEach(span => {
                    span.addEventListener('click', () => {
                        const userId = span.dataset.userid;
                        const userName = span.textContent.replace('üë§ ', '').trim();
                        selectRecipient({ id: userId, name: userName, type: 'direct' });
                    });
                });

                // Add click handlers for delete buttons
                list.querySelectorAll('.delete-user-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const userId = btn.dataset.userid;
                        deleteRecentUser(userId);
                    });
                });
            }

            async function selectDirectUserId() {
                const input = document.getElementById('directUserIdInput');
                const userId = input.value.trim();

                if (!userId) {
                    alert('Please enter a user ID');
                    return;
                }

                if (!/^\d+$/.test(userId)) {
                    alert('User ID must be a number');
                    return;
                }

                const selectBtn = document.getElementById('selectUserIdBtn');
                selectBtn.disabled = true;
                selectBtn.textContent = '‚è≥';

                try {
                    const SendFunction = getSend();

                    // First get user's clan info to find their name
                    const response = await SendFunction(JSON.stringify({
                        calls: [{
                            name: "userGetInfo",
                            args: { userId: userId },
                            context: { actionTs: Math.floor(performance.now()) },
                            ident: "body"
                        }]
                    }));

                    let userName = `User ${userId}`;
                    let clanId = null;

                    if (response?.results?.[0]?.result?.response) {
                        const userInfo = response.results[0].result.response;
                        clanId = userInfo.clanId;

                        // If user has a clan, get their name from clan info
                        if (clanId) {
                            const clanResponse = await SendFunction(JSON.stringify({
                                calls: [{
                                    name: "clanGetInfo",
                                    args: { clanId: clanId },
                                    context: { actionTs: Math.floor(performance.now()) },
                                    ident: "body"
                                }]
                            }));

                            if (clanResponse?.results?.[0]?.result?.response?.clan?.members?.[userId]) {
                                const memberData = clanResponse.results[0].result.response.clan.members[userId];
                                userName = memberData.name || userName;
                            }
                        }
                    }

                    selectRecipient({ id: userId, name: userName, type: 'direct' });
                    saveRecentUser(userId, userName);
                    input.value = '';

                } catch (e) {
                    console.error('Failed to fetch user info:', e);
                    // Fallback
                    selectRecipient({ id: userId, name: `User ${userId}`, type: 'direct' });
                    saveRecentUser(userId, `User ${userId}`);
                    input.value = '';
                } finally {
                    selectBtn.disabled = false;
                    selectBtn.textContent = '‚úì Select';
                }
            }
            // Event listeners for direct user ID
            document.getElementById('selectUserIdBtn').addEventListener('click', selectDirectUserId);

            document.getElementById('directUserIdInput').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    selectDirectUserId();
                }
            });

            // Display recent users on load
            displayRecentUsers();

            const messageInput = document.getElementById('messageInput');
            messageInput.addEventListener('input', (e) => {
                customMessage = e.target.value;
                updateSendButton();
            });

            messageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (selectedRecipient && customMessage.trim()) {
                        sendMessage();
                    }
                }
            });

            function updateSendButton() {
                const sendBtn = document.getElementById('sendBtn');
                sendBtn.disabled = !selectedRecipient || !customMessage.trim();
            }

            document.getElementById('sendBtn').addEventListener('click', sendMessage);

            async function sendMessage() {
                if (!selectedRecipient || !customMessage.trim()) return;

                // NEW: Handle mass PM sending
                if (selectedRecipient.type === 'mass-pm') {
                    const total = selectedRecipient.count;
                    const confirmed = confirm(
                        `üì§ Send this message to ${total} guild members?\n\n` +
                        `"${customMessage.trim()}"\n\n` +
                        `This will send ${total} individual PMs.`
                    );

                    if (!confirmed) return;

                    // Helper to get member name from ID
                    const getMemberName = (userId) => {
                        const member = guildMembers.find(m => String(m.id) === String(userId));
                        return member ? member.name : userId;
                    };

                    // Create progress popup
                    const progressPopup = document.createElement('div');
                    progressPopup.id = 'mass-pm-progress';
                    progressPopup.style.cssText = `
                        position: fixed;
                        top: 10px;
                        right: 320px;
                        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                        border: 2px solid #8b6914;
                        border-radius: 8px;
                        padding: 12px 16px;
                        color: #fff;
                        font-size: 13px;
                        z-index: 100000;
                        min-width: 180px;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.5);
                    `;
                    document.body.appendChild(progressPopup);

                    const updateProgress = (current, total, status = 'sending') => {
                        progressPopup.innerHTML = `<span style="color: #ffd700;">üì§</span> Sending ${current} of ${total}...`;
                    };

                    // Disable send button during mass send
                    const sendBtn = document.getElementById('sendBtn');
                    sendBtn.disabled = true;
                    sendBtn.textContent = 'üì§ Sending...';

                    let successCount = 0;
                    let failCount = 0;
                    const failedUsers = [];

                    debugLog('üì§ Starting Mass PM to', total, 'members');

                    let current = 0;
                    for (const userId of selectedRecipient.members) {
                        current++;
                        updateProgress(current, total);

                        try {
                            const SendFunction = getSend();

                            const response = await SendFunction(JSON.stringify({
                                calls: [{
                                    name: "chatSendText",
                                    args: {
                                        chatType: "personal",
                                        text: customMessage.trim(),
                                        userId: userId
                                    },
                                    context: { actionTs: Math.floor(performance.now()) },
                                    ident: "body"
                                }]
                            }));

                            if (response?.results?.[0]?.result?.response) {
                                debugLog(`‚úÖ PM sent to ${getMemberName(userId)}`);
                                successCount++;
                            } else {
                                console.error(`‚ùå Failed to send to ${getMemberName(userId)}:`, response);
                                failCount++;
                                failedUsers.push(userId);
                            }

                            // Delay between messages
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        } catch (e) {
                            console.error(`‚ùå Exception sending to ${getMemberName(userId)}:`, e);
                            failCount++;
                            failedUsers.push(userId);
                        }
                    }

                    // Show results in popup
                    let resultHTML;
                    if (failCount === 0) {
                        resultHTML = `<div style="color: #4ae29a; margin-bottom: 10px;">‚úÖ All ${successCount} messages sent!</div>`;
                    } else {
                        const failedNames = failedUsers.map(id => getMemberName(id)).join(', ');
                        resultHTML = `
                            <div style="color: #4ae29a; margin-bottom: 8px;">‚úÖ Sent: ${successCount} of ${total}</div>
                            <div style="color: #ffa500; margin-bottom: 6px;">‚ö†Ô∏è Failed (${failCount}):</div>
                            <div style="color: #ff6b6b; font-size: 11px; max-width: 250px; word-wrap: break-word;">${failedNames}</div>
                        `;
                        console.warn('‚ö†Ô∏è Mass PM failed for:', failedUsers.map(id => `${getMemberName(id)} (${id})`));
                    }

                    progressPopup.innerHTML = `
                        ${resultHTML}
                        <button id="mass-pm-ok-btn" style="
                            margin-top: 10px;
                            padding: 6px 20px;
                            background: #8b6914;
                            border: none;
                            border-radius: 4px;
                            color: #fff;
                            cursor: pointer;
                            width: 100%;
                            font-weight: bold;
                        ">OK</button>
                    `;

                    document.getElementById('mass-pm-ok-btn').addEventListener('click', () => {
                        progressPopup.remove();
                    });

                    // Clear selection and reset
                    messageInput.value = '';
                    customMessage = '';
                    clearRecipient();

                    // Clear member checkboxes
                    selectedMembers.clear();
                    selectAllCheckbox.checked = false;
                    sidebar.querySelectorAll('.member-checkbox:not(#select-all-members)').forEach(cb => {
                        cb.checked = false;
                    });
                    updateMassPmButton();

                    // Re-enable send button
                    sendBtn.disabled = false;
                    sendBtn.textContent = 'üì§ Send Message';

                    return;
                }

                // Regular single message sending (guild or member)
                const data = {
                    calls: [{
                        name: "chatSendText",
                        args: selectedRecipient.type === 'guild'
                        ? { chatType: "clan", text: customMessage.trim() }
                        : { chatType: "personal", text: customMessage.trim(), userId: selectedRecipient.id },
                        context: { actionTs: Math.floor(performance.now()) },
                        ident: "body"
                    }]
                };

                try {
                    const SendFunction = getSend();
                    const response = await SendFunction(JSON.stringify(data));

                    if (response?.results?.[0]?.result?.response) {
                        messageInput.value = '';
                        customMessage = '';
                        updateSendButton();
                        alert('‚úÖ Message sent!');
                    }
                } catch (e) {
                    console.error('Failed to send message:', e);
                    alert('‚ùå Failed to send message');
                }
            }
            // Stats Tab Loader - LAZY LOADED on tab click
            function loadStatsTab() {
                const statsContent = document.getElementById('stats-tab-content');
                if (!statsContent) return;

                const totalArenaBattles = arenaHistory.reduce((sum, s) => sum + s.battles.length, 0);
                const totalGrandBattles = grandHistory.reduce((sum, s) => sum + s.battles.length, 0);

                let arenaWins = 0;
                let grandWins = 0;

                arenaHistory.forEach(session => {
                    session.battles.forEach(battle => {
                        if (battle.win) arenaWins++;
                    });
                });

                grandHistory.forEach(session => {
                    session.battles.forEach(battle => {
                        if (battle.win) grandWins++;
                    });
                });

                const arenaWinRate = totalArenaBattles > 0 ? ((arenaWins / totalArenaBattles) * 100).toFixed(1) : '0.0';
                const grandWinRate = totalGrandBattles > 0 ? ((grandWins / totalGrandBattles) * 100).toFixed(1) : '0.0';

                statsContent.innerHTML = `
            <div style="background: rgba(139,105,20,0.15); padding: 8px; border-radius: 4px; margin-bottom: 8px;">
                <div style="color: #ffd700; font-weight: bold; font-size: 10px; margin-bottom: 6px;">‚öîÔ∏è Arena</div>
<div style="font-size: 12px; line-height: 1.6;">
    Total Battles: <span class="twk-green">${totalArenaBattles}</span><br>
Wins: <span class="twk-green">${arenaWins}</span> / Losses: <span class="twk-red">${totalArenaBattles - arenaWins}</span><br>
Win Rate: <span class="twk-gold">${arenaWinRate}%</span>
</div>
</div>

<div style="background: rgba(139,105,20,0.15); padding: 8px; border-radius: 4px; margin-bottom: 8px;">
    <div style="color: #ffd700; font-weight: bold; font-size: 10px; margin-bottom: 6px;">üèÜ Grand Arena</div>
<div style="font-size: 12px; line-height: 1.6;">
    Total Battles: <span class="twk-green">${totalGrandBattles}</span><br>
Wins: <span class="twk-green">${grandWins}</span> / Losses: <span class="twk-red">${totalGrandBattles - grandWins}</span><br>
Win Rate: <span class="twk-gold">${grandWinRate}%</span>
</div>
</div>

<div style="text-align: center; margin-top: 12px;">
    <button id="clear-stats-btn" style="background: #d32f2f; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 9px; font-weight: bold;">üóëÔ∏è Clear All History</button>
</div>

<div style="font-size: 8px; color: #666; text-align: center; margin-top: 12px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 4px;">
    Stats automatically track when you battle in Arena or Grand Arena
        </div>
`;

                document.getElementById('clear-stats-btn').addEventListener('click', () => {
                    if (confirm('‚ö†Ô∏è Clear all arena battle history?\n\nThis will permanently delete all saved battle records and cannot be undone.')) {
                        arenaHistory = [];
                        grandHistory = [];
                        saveArenaHistory(STORAGE_KEY_ARENA, arenaHistory);
                        saveArenaHistory(STORAGE_KEY_GRAND, grandHistory);

                        statsContent.innerHTML = '<div style="color: #4ae29a; text-align: center; padding: 20px; font-size: 10px;">‚úÖ History cleared!</div>';

                        setTimeout(() => {
                            loadStatsTab();
                        }, 1500);
                    }
                });
            }

            initializeSortButtons();
            loadGuildMembers();
            setTimeout(loadGuildMembers, 2000);

            // Smart refresh - skip when page not visible or sidebar not showing relevant tab
            const refreshInterval = (parseInt(localStorage.getItem('hwh_autorefresh_interval')) || 60) * 1000;
            setInterval(() => {
                // Skip if browser tab is hidden/minimized
                if (document.hidden) {
                    debugLog('‚è∏Ô∏è Guild refresh skipped - tab not visible');
                    return;
                }

                const sidebar = DOMCache.get('quickChatSidebar', '#quickChatSidebar');
                if (!sidebar) return;

                // Skip if sidebar collapsed
                if (sidebar.classList.contains('collapsed')) {
                    debugLog('‚è∏Ô∏è Guild refresh skipped - sidebar collapsed');
                    return;
                }

                // Skip if not on members or stats tab
                const activeTab = sidebar.querySelector('.tab-btn.active');
                const tabName = activeTab?.dataset?.tab;
                if (tabName !== 'members' && tabName !== 'stats') {
                    debugLog('‚è∏Ô∏è Guild refresh skipped - not on members/stats tab');
                    return;
                }

                loadGuildMembers();
            }, refreshInterval);
        };

        /* KEYBOARD SHORTCUTS REMOVED
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            const key = e.key.toLowerCase();

            switch(key) {
                case 'b':
                    document.dispatchEvent(new KeyboardEvent('keydown', {
                        key: 'Escape', keyCode: 27, bubbles: true
                    }));
                    debugLog('‚å®Ô∏è Keyboard: [B] Back');
                    break;
                case 'h':
                    if (window.goHome) {
                        window.goHome();
                        debugLog('‚å®Ô∏è Keyboard: [H] Home');
                    }
                    break;
                case 's':
                    silentSync();
                    debugLog('‚å®Ô∏è Keyboard: [S] Sync');
                    break;
                case 'r':
                    location.reload();
                    debugLog('‚å®Ô∏è Keyboard: [R] Reload');
                    break;
                case 'c':
                    const collectBtn = document.querySelector('[data-custom-collect-more="true"]');
                    if (collectBtn) {
                        const mainBtn = collectBtn.querySelector('.scriptMenu_combineButtonLeft');
                        if (mainBtn && mainBtn.onclick) {
                            mainBtn.onclick({ preventDefault: () => {}, stopPropagation: () => {} });
                            debugLog('‚å®Ô∏è Keyboard: [C] Collect');
                        }
                    }
                    break;
                case 'g':
                    if (window.showTweakerSettings) {
                        window.showTweakerSettings();
                        debugLog('‚å®Ô∏è Keyboard: [G] Settings');
                    }
                    break;
            }
        });
        */
        // Auto-initialize
        // Create chat popup as soon as game is ready
        waitForGameReady().then(() => createChatPopup());

        debugLog('‚úÖ Enhanced Sidebar loaded - Compact 40px buttons, Arena Stats tab, Mass PM, Green highlights');



        debugLog(`HWH Tweaker v${TWEAKER_VERSION} initialized successfully`);
        debugLog(`Delay factor: ${getDelayFactor()}x`);
        debugLog(`Adventure extension: ${window.isUISettingEnabled('enableAdventureExtension') ? 'ENABLED' : 'DISABLED'}`);
        debugLog('Features: Collection automation, Custom navigation buttons, Button visibility control, Collect More with internal functions, Collect on load, HWH Do All integration, Config gear icon, Adventure path integration');
        // Check if AoC is active on page load and show dock
        window.checkAoCOnLoad = async function() {
            try {
                const SendFunction = getSend();
                if (!SendFunction) return;

                const response = await SendFunction(JSON.stringify({
                    calls: [{
                        name: "clanDomination_mapState",
                        args: {},
                        context: { actionTs: Date.now() },
                        ident: "body"
                    }]
                }));

                const mapState = response?.results?.[0]?.result?.response;

                // If mapState has data, AoC is active
                if (mapState && Object.keys(mapState).length > 0) {
                    debugLog('üè∞ AoC is active - showing dock');
                    const liveData = await window.fetchLiveCastleData();

                    // Also fetch guild members (needed for dock)
                    const guildResponse = await SendFunction(JSON.stringify({
                        calls: [{
                            name: "clanGetInfo",
                            args: {},
                            context: { actionTs: Date.now() },
                            ident: "body"
                        }]
                    }));
                    liveData.guildMembers = guildResponse?.results?.[0]?.result?.response?.clan?.members || {};


                    // Set up auto-refresh if not already running
                    if (!window._aocAutoRefresh) {
                        const savedInterval = parseInt(localStorage.getItem('hwh_aoc_refresh_interval')) || 15;
                        window._aocAutoRefresh = {
                            timer: null,
                            interval: savedInterval,
                            lastRefresh: null
                        };
                        const aocRefreshFn = async () => {
                            if (document.hidden) return; // Skip if tab hidden
                            window.showAoCDock(null);
                            debugLog('üè∞ AoC auto-refreshed (dock only)');
                            const idleTime = Date.now() - (window._lastActivity || Date.now());
                            if (idleTime > 60000) {
                                await sendAoCStatusNotification();
                            }
                        };
                        window._aocAutoRefresh.timer = setInterval(aocRefreshFn, savedInterval * 60 * 1000);
                        window._aocAutoRefresh.lastRefresh = Date.now();
                    }

                    window.showAoCDock(liveData);
                } else {
                    debugLog('üè∞ AoC not active');
                }
            } catch (error) {
                debugLog('üè∞ AoC check failed:', error.message);
            }
        };

        // Check AoC as soon as game is ready
        waitForGameReady().then(() => window.checkAoCOnLoad?.());


        // Check if Power Tournament is active on page load and show dock
        window.checkPowerTournamentOnLoad = async function() {
            try {
                const SendFunction = getSend();
                if (!SendFunction) return;

                const response = await SendFunction('{"calls":[{"name":"powerTournament_getState","args":{},"context":{"actionTs":' + Date.now() + '},"ident":"body"},{"name":"powerTournament_getGroupInfo","args":{},"context":{"actionTs":' + Date.now() + '},"ident":"powerTournament_getGroupInfo"}]}');

                const tournamentState = response?.results?.[0]?.result?.response;
                const groupData = response?.results?.[1]?.result?.response;

                // No data = not active
                if (!groupData?.users) {
                    debugLog('üèÜ Power Tournament not active');
                    return;
                }

                // state === 2 means ended
                window._tournamentEnded = tournamentState?.state === 2;
                if (window._tournamentEnded) {
                    window._tournamentEndTime = parseInt(localStorage.getItem('hwh_tournament_end_time')) || null;
                    debugLog('üèÜ Power Tournament ended - skipping dock');
                    return;
                }

                debugLog('üèÜ Power Tournament is active - showing dock');

                // Build user rankings (points are in groupData.points, not in users)
                const userRankings = Object.keys(groupData.users)
                .map(userId => ({
                    userId,
                    name: groupData.users[userId]?.name || 'Player',
                    points: groupData.points?.[userId] || 0
                }))
                .sort((a, b) => b.points - a.points);

                window.showTournamentDock(userRankings);

                // Initialize auto-refresh state (but don't start timer - let user control from popup)
                if (!window._tournamentAutoRefresh) {
                    window._tournamentAutoRefresh = {
                        timer: null,
                        timeout: null,
                        interval: 0,
                        startTime: null
                    };
                }
            } catch (error) {
                debugLog('üèÜ Power Tournament check failed:', error.message);
            }
        };

        // Check Tournament as soon as game is ready
        waitForGameReady().then(() => window.checkPowerTournamentOnLoad?.());
    }


    // COMPACT SIDEBAR WITH STYLE TOGGLE - GAME STYLE vs FLAT STYLE
    // ================================================================
    // Add this at the end of your script (before waitForHWH())

    (function() {
        debugLog('üé® Loading Compact Sidebar with Style Toggle...');

        // ================================================================
        // CUSTOM FUNCTIONS MANAGEMENT
        // ================================================================

        let DEFAULT_BUTTON_FUNCTIONS = null;

        function loadCustomFunctions() {
            try {
                const stored = localStorage.getItem('hwh_custom_functions');
                if (!stored) return {};

                const parsed = JSON.parse(stored);
                const customFuncs = {};

                Object.keys(parsed).forEach(name => {
                    const func = parsed[name];
                    if (func.actionCode) {
                        try {
                            customFuncs[name] = {
                                action: eval(`(${func.actionCode})`),
                                icon: func.icon,
                                color: func.color,
                                description: func.description,
                                fontSize: func.fontSize,
                                customColor: func.customColor,
                                isCustom: true
                            };
                        } catch (e) {
                            console.error(`Failed to load custom function "${name}":`, e);
                        }
                    }
                });

                return customFuncs;
            } catch (e) {
                console.error('Failed to load custom functions:', e);
                return {};
            }
        }

        function saveCustomFunctions() {
            try {
                const customFuncs = {};

                Object.keys(BUTTON_FUNCTIONS).forEach(name => {
                    const func = BUTTON_FUNCTIONS[name];
                    if (func.isCustom) {
                        customFuncs[name] = {
                            actionCode: func.action.toString(),
                            icon: func.icon,
                            color: func.color,
                            description: func.description,
                            fontSize: func.fontSize,
                            customColor: func.customColor
                        };
                    }
                });

                localStorage.setItem('hwh_custom_functions', JSON.stringify(customFuncs));
                debugLog(`üíæ Saved ${Object.keys(customFuncs).length} custom functions`);
            } catch (e) {
                console.error('Failed to save custom functions:', e);
            }
        }
        // ==================== LUCKY ROAD AUTO-ROLLER ====================
        async function openLuckyRoadPopup() {
            debugLog("üé≤ Lucky Road Auto-Roller starting...");

            if (typeof Send !== 'function') {
                alert("‚ùå Send function not found! Make sure HeroWarsHelper is loaded.");
                return;
            }

            // Auto-detect the currently active Line Gacha ID
            let lineGachaId = null;
            let eventDates = null;

            try {
                if (lib?.data?.lineGacha?.list) {
                    const today = new Date().toISOString().split('T')[0];

                    for (let [id, entry] of Object.entries(lib.data.lineGacha.list)) {
                        if (id === "1") continue;

                        let dates = entry?.requirements?.ymdDate?.value;
                        if (dates && dates.length === 2) {
                            let [start, end] = dates;
                            if (today >= start && today <= end) {
                                lineGachaId = parseInt(id);
                                eventDates = `${start} to ${end}`;
                                debugLog(`‚úÖ Found active Lucky Road: ${id} (${eventDates})`);
                                break;
                            }
                        }
                    }
                }
            } catch(e) {
                console.error("Auto-detect error:", e);
            }

            if (!lineGachaId) {
                alert("‚ùå No active Lucky Road event found!");
                return;
            }

            // Auto-detect coin balance via inventoryGet API
            let coinBalance = 0;
            try {
                const invResponse = await Send('{"calls":[{"name":"inventoryGet","args":{},"ident":"body"}]}');
                coinBalance = invResponse.results[0].result.response.coin['59'] || 0;
                debugLog(`‚úÖ Found Lucky Road coins: ${coinBalance}`);
            } catch(e) {
                console.error("Coin balance detection error:", e);
            }

            // Reward name helper
            function getRewardName(type, id) {
                try {
                    if (typeof cheats !== 'undefined' && cheats.translate) {
                        const prefixes = {
                            coin: 'LIB_COIN_NAME_',
                            consumable: 'LIB_CONSUMABLE_NAME_',
                            fragmentHero: 'LIB_HERO_NAME_',
                            gear: 'LIB_GEAR_NAME_',
                            scroll: 'LIB_SCROLL_NAME_'
                        };
                        if (prefixes[type]) {
                            let name = cheats.translate(prefixes[type] + id);
                            if (name && !name.startsWith('LIB_')) return name;
                        }
                    }
                } catch(e) {}

                const knownTypes = {
                    gold: 'Gold',
                    starmoney: 'Emeralds',
                    stamina: 'Energy',
                    experience: 'Experience',
                    vipPoints: 'VIP Points'
                };
                return knownTypes[type] || `${type}${id ? ':' + id : ''}`;
            }

            // Create popup UI
            const overlay = document.createElement('div');
            overlay.style.cssText = `
        position: fixed;
        top: 0; left: 0;
        width: 100vw; height: 100vh;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100000;
        backdrop-filter: blur(3px);
    `;

            const popup = document.createElement('div');
            popup.style.cssText = `
    background: linear-gradient(135deg, #2d2416 0%, #1a1408 100%);
    border: 3px solid #c9a227; border-radius: 12px;
    padding: 20px; max-width: 950px; max-height: 95vh;
    overflow-y: auto; color: #f4e4c1;
    font-family: Arial, sans-serif;
`;

            popup.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 12px; border-bottom: 2px solid rgba(139, 105, 20, 0.5);">
            <h2 style="color: #ffd700; margin: 0; font-size: 18px; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);">üé≤ Lucky Road Auto-Roller</h2>
            <button id="lr-close" style="background: #d32f2f; color: white; border: none; border-radius: 6px; padding: 6px 12px; font-size: 14px; cursor: pointer; font-weight: bold;">‚úñ</button>
        </div>

        <div style="color: #999; font-size: 12px; margin-bottom: 15px;">
            Event ID: <span class="twk-gold">${lineGachaId}</span><br>
            Active: <span class="twk-green">${eventDates}</span><br>
            Available Coins: <span id="lr-coin-display" style="color: #ff9800; font-weight: bold;">${coinBalance.toLocaleString()}</span>
        </div>

        <div class="twk-mb-15">
            <label style="color: #ccc; font-size: 13px;">Number of rolls:</label>
            <div style="display: flex; gap: 8px; margin-top: 5px;">
                <input type="number" id="lr-rolls" value="${coinBalance}" min="1" max="${coinBalance}" style="
                    flex: 1;
                    padding: 8px;
                    background: #1a1510;
                    border: 2px solid #8b6914;
                    border-radius: 6px;
                    color: #ffd700;
                    font-size: 16px;
                    text-align: center;
                    box-sizing: border-box;
                ">
                <button id="lr-max" style="
                    background: #ff9800;
                    color: white;
                    border: none;
                    border-radius: 6px;
                    padding: 8px 12px;
                    font-size: 12px;
                    font-weight: bold;
                    cursor: pointer;
                ">MAX</button>
            </div>
        </div>

        <div id="lr-progress-container" style="display: none; margin-bottom: 15px;">
            <div style="display: flex; justify-content: space-between; color: #ccc; font-size: 12px; margin-bottom: 5px;">
                <span id="lr-status">Rolling...</span>
                <span id="lr-count">0 / 0</span>
            </div>
            <div style="background: #1a1510; border-radius: 6px; height: 20px; border: 1px solid #8b6914; overflow: hidden;">
                <div id="lr-progress-bar" style="background: linear-gradient(90deg, #ff9800, #ffd700); height: 100%; width: 0%; transition: width 0.1s;"></div>
            </div>
        </div>

        <div id="lr-rewards" style="display: none; flex: 1; overflow-y: auto; margin-bottom: 15px; max-height: 300px;">
            <div style="color: #ffd700; font-size: 14px; margin-bottom: 10px; border-bottom: 1px solid rgba(139, 105, 20, 0.5); padding-bottom: 5px;">üì¶ Rewards Summary</div>
            <div id="lr-rewards-list" style="font-size: 12px;"></div>
        </div>

        <div class="twk-flex-gap10">
            <button id="lr-start" style="
                flex: 1;
                background: linear-gradient(135deg, #ff9800, #f57c00);
                color: white;
                border: none;
                border-radius: 6px;
                padding: 12px;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
            ">üöÄ Start Rolling</button>
            <button id="lr-stop" style="
                flex: 1;
                background: #d32f2f;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 12px;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                display: none;
            ">‚èπ Stop</button>
        </div>
    `;

            overlay.appendChild(popup);
            document.body.appendChild(overlay);

            // UI elements
            const closeBtn = document.getElementById('lr-close');
            const rollsInput = document.getElementById('lr-rolls');
            const maxBtn = document.getElementById('lr-max');
            const startBtn = document.getElementById('lr-start');
            const stopBtn = document.getElementById('lr-stop');
            const progressContainer = document.getElementById('lr-progress-container');
            const progressBar = document.getElementById('lr-progress-bar');
            const statusText = document.getElementById('lr-status');
            const countText = document.getElementById('lr-count');
            const rewardsDiv = document.getElementById('lr-rewards');
            const rewardsList = document.getElementById('lr-rewards-list');
            const coinDisplay = document.getElementById('lr-coin-display');

            let running = false;
            let purchased = 0;
            let totalRolls = 0;
            let rewards = {};

            closeBtn.onclick = () => {
                running = false;
                document.body.removeChild(overlay);
            };

            maxBtn.onclick = () => {
                rollsInput.value = coinBalance;
            };

            stopBtn.onclick = () => {
                running = false;
                stopBtn.style.display = 'none';
                startBtn.style.display = 'block';
                startBtn.textContent = 'üîÑ Resume';
                statusText.textContent = 'Stopped';
            };

            // Reward tracking
            function trackReward(rewardData) {
                for (let [type, value] of Object.entries(rewardData)) {
                    if (typeof value === 'object') {
                        for (let [id, amount] of Object.entries(value)) {
                            let key = `${type}:${id}`;
                            let name = getRewardName(type, id);
                            if (!rewards[key]) rewards[key] = { name, amount: 0 };
                            rewards[key].amount += parseInt(amount) || 0;
                        }
                    } else {
                        let name = getRewardName(type);
                        if (!rewards[type]) rewards[type] = { name, amount: 0 };
                        rewards[type].amount += parseInt(value) || 0;
                    }
                }
            }

            function updateRewardsDisplay() {
                let html = '';
                let sorted = Object.entries(rewards).sort((a, b) => b[1].amount - a[1].amount);

                for (let [key, data] of sorted) {
                    html += `
                <div style="display: flex; justify-content: space-between; padding: 4px 8px; margin: 2px 0; background: rgba(139, 105, 20, 0.2); border-radius: 4px;">
                    <span class="twk-dim">${data.name}</span>
                    <span class="twk-green-bold">${data.amount.toLocaleString()}</span>
                </div>
            `;
                }
                rewardsList.innerHTML = html || '<div style="color: #666; text-align: center;">No rewards yet</div>';
            }

            // Rolling logic
            // Rolling logic
            startBtn.onclick = async () => {
                // Check if we have coins left
                if (coinBalance <= 0) {
                    alert("No coins remaining!");
                    return;
                }

                totalRolls = parseInt(rollsInput.value) || coinBalance;
                if (totalRolls < 1) return;
                if (totalRolls > coinBalance) totalRolls = coinBalance;

                running = true;
                purchased = 0;
                rewards = {}; // Reset rewards for new session
                startBtn.style.display = 'none';
                stopBtn.style.display = 'block';
                progressContainer.style.display = 'block';
                rewardsDiv.style.display = 'block';
                rollsInput.disabled = true;
                maxBtn.disabled = true;

                for (let i = 0; i < totalRolls && running; i++) {
                    try {
                        const response = await Send(`{"calls":[{"name":"lineGacha_rollReward","args":{"id":${lineGachaId}},"context":{"actionTs":${Math.floor(performance.now())}},"ident":"body"}]}`);

                        purchased++;
                        coinBalance--;
                        coinDisplay.textContent = coinBalance.toLocaleString();

                        // Track reward from response
                        if (response?.results?.[0]?.result?.response?.reward) {
                            trackReward(response.results[0].result.response.reward);
                            updateRewardsDisplay();
                        }

                        // Update UI
                        let pct = (purchased / totalRolls) * 100;
                        progressBar.style.width = pct + '%';
                        countText.textContent = `${purchased} / ${totalRolls}`;
                        statusText.textContent = `Rolling... ${pct.toFixed(0)}%`;

                    } catch (e) {
                        console.error('Roll error:', e);
                        break;
                    }

                    await new Promise(r => setTimeout(r, 100));
                }

                running = false;
                stopBtn.style.display = 'none';
                startBtn.style.display = 'block';
                rollsInput.disabled = false;
                maxBtn.disabled = false;

                // Refresh inventory after rolling
                if (purchased > 0) {
                    try {
                        if (typeof cheats !== 'undefined' && cheats.refreshInventory) {
                            statusText.textContent = 'Refreshing...';
                            await cheats.refreshInventory();
                        }
                    } catch(e) { debugLog('Inventory refresh skipped:', e); }
                }

                // Update button based on completion and remaining coins
                if (purchased >= totalRolls) {
                    statusText.textContent = 'Complete!';
                    if (coinBalance <= 0) {
                        startBtn.textContent = '‚úÖ All Done!';
                        startBtn.disabled = true;
                        startBtn.style.opacity = '0.6';
                    } else {
                        startBtn.textContent = 'üöÄ Roll Again';
                        rollsInput.value = coinBalance;
                        rollsInput.max = coinBalance;
                    }
                } else {
                    statusText.textContent = 'Stopped';
                    startBtn.textContent = 'üîÑ Resume';
                }
            };

            // Hover effects
            startBtn.onmouseover = () => startBtn.style.filter = 'brightness(1.1)';
            startBtn.onmouseout = () => startBtn.style.filter = 'brightness(1)';
            closeBtn.onmouseover = () => closeBtn.style.background = '#b71c1c';
            closeBtn.onmouseout = () => closeBtn.style.background = '#d32f2f';
            maxBtn.onmouseover = () => maxBtn.style.filter = 'brightness(1.1)';
            maxBtn.onmouseout = () => maxBtn.style.filter = 'brightness(1)';
        }

        // Make it available globally
        window.openLuckyRoadPopup = openLuckyRoadPopup;
        if (typeof unsafeWindow !== 'undefined') unsafeWindow.openLuckyRoadPopup = openLuckyRoadPopup;
        // ==================== END LUCKY ROAD ====================


        // ============================================================================
        // CLEAN BUTTON FUNCTIONS WITH PROPER EMOJIS
        // Copy this to replace your BUTTON_FUNCTIONS section
        // ============================================================================

        const BUTTON_FUNCTIONS = {
            // Core action buttons
            'ToE': {
                action: () => {
                    const func = () => testDoYourBest();
                    if (confirm('Run Tournament of Elements script?')) func();
                },
                icon: '',
                color: '',
                description: 'Run automated ToE battles'
            },
            '>> ToE': {
                action: () => {
                    if (cheats && cheats.goOutland) cheats.goOutland();
                },
                icon: '',
                color: 'green',
                description: 'Navigate to ToE/Outland'
            },

            'Dungeon': {
                action: () => {
                    const func = () => testDungeon();
                    if (confirm('Run Dungeon script?')) func();
                },
                icon: '',
                color: '',
                description: 'Run automated Dungeon battles'
            },
            '>> Dung': {
                action: () => {
                    if (cheats && cheats.goClanIsland) cheats.goClanIsland();
                },
                icon: '',
                color: 'green',
                description: 'Navigate to Dungeon/Clan Island'
            },

            'Adv.': {
                action: () => {
                    if (testAdventure) testAdventure();
                },
                icon: '',
                color: '',
                description: 'Run Adventure script'
            },
            'Raid': {
                action: () => {
                    if (autoRaidAdventure) autoRaidAdventure();
                },
                icon: '',
                color: '',
                description: 'Auto-raid Adventure mode'
            },
            'Storm': {
                action: async () => {
                    try {
                        if (typeof HWHClasses !== 'undefined' && HWHClasses.executeAdventure) {
                            const { executeAdventure } = HWHClasses;
                            await new Promise((resolve, reject) => {
                                const stormBattle = new executeAdventure(resolve, reject);
                                stormBattle.start('solo');
                            });
                        } else {
                            console.error('HWHClasses.executeAdventure not available');
                        }
                    } catch (e) {
                        console.error('Storm error:', e);
                    }
                },
                icon: '‚õàÔ∏è',
                color: 'purple',
                description: 'Storm (Solo Adventure)'
            },
            '>> Sanct': {
                action: () => {
                    if (cheats && cheats.goSanctuary) cheats.goSanctuary();
                },
                icon: '',
                color: 'green',
                description: 'Navigate to Sanctuary'
            },

            'Actions': {
                action: async () => {
                    if (HWHData && HWHData.actionsPopupButtons) {
                        const buttons = [...HWHData.actionsPopupButtons, { result: false, isClose: true }];
                        const answer = await popup.confirm('Choose Action:', buttons);
                        if (typeof answer === 'function') answer();
                    } else {
                        debugLog('Actions menu not available');
                    }
                },
                icon: '',
                color: '',
                description: 'Open Actions menu (HWH)'
            },
            'Others': {
                action: async () => {
                    if (HWHData && HWHData.othersPopupButtons) {
                        const buttons = [...HWHData.othersPopupButtons, { result: false, isClose: true }];
                        const answer = await popup.confirm('Choose Action:', buttons);
                        if (typeof answer === 'function') answer();
                    } else {
                        debugLog('Others menu not available');
                    }
                },
                icon: '',
                color: '',
                description: 'Open Others menu (HWH)'
            },

            // Navigation buttons
            'GW': {
                action: () => {
                    if (cheats) cheats.goNavigtor('CLAN_PVP');
                },
                icon: '',
                color: '',
                description: 'Navigate to Guild War'
            },
            'CoW': {
                action: () => {
                    if (cheats) cheats.goNavigtor('CLAN_GLOBAL_PVP');
                },
                icon: '',
                color: '',
                description: 'Navigate to Clash of Worlds'
            },

            'Asgard': {
                action: () => {
                    if (cheats) cheats.goNavigtor('ASGARD');
                },
                icon: '',
                color: '',
                description: 'Navigate to Asgard'
            },
            'Spire': {
                action: () => {
                    if (cheats) cheats.goNavigtor('HERO_ASCENSION');
                },
                icon: '',
                color: '',
                description: 'Navigate to Hero Ascension Spire'
            },

            'Merch': {
                action: () => {
                    if (cheats) cheats.goNavigtor('CLAN_PVP_MERCHANT');
                },
                icon: '',
                color: '',
                description: 'Open Artifact Merchant'
            },
            'TMerch': {
                action: () => {
                    if (cheats) cheats.goNavigtor('TITAN_ARTIFACT_MERCHANT');
                },
                icon: '',
                color: '',
                description: 'Open Titan Artifact Merchant'
            },

            'Heroes': {
                action: () => {
                    if (window.goHeroes) window.goHeroes();
                },
                icon: '',
                color: '',
                description: 'Open Heroes list'
            },
            'Pets': {
                action: () => {
                    if (window.goPets) window.goPets();
                },
                icon: '',
                color: '',
                description: 'Open Pets list'
            },

            'Events': {
                action: () => {
                    if (window.goSpecialEvents) window.goSpecialEvents();
                },
                icon: '',
                color: '',
                description: 'Open Special Events'
            },
            'Inventory': {
                action: () => {
                    if (window.goConsumables) window.goConsumables();
                },
                icon: '',
                color: '',
                description: 'Open Inventory/Consumables'
            },

            'Titans': {
                action: () => {
                    if (window.goTitans) window.goTitans();
                },
                icon: '',
                color: '',
                description: 'Open Titans list'
            },
            'Totems': {
                action: () => {
                    if (window.goTitanSpiritArtifact) window.goTitanSpiritArtifact();
                },
                icon: '',
                color: '',
                description: 'Open Titan Totems/Artifacts'
            },
            '>> Titans': {
                action: () => {
                    if (cheats && cheats.goTitanValley) cheats.goTitanValley();
                },
                icon: '',
                color: 'green',
                description: 'Navigate to Titan Valley'
            },

            // Guild/Clan buttons with emojis - FIXED ENCODING
            'üõ°Ô∏è': {
                action: () => {
                    if (window.goGuildOverview) window.goGuildOverview();
                },
                icon: 'üõ°Ô∏è',
                color: '',
                description: 'Guild Overview'
            },
            'üßç‚Äç‚ôÇÔ∏èüßç‚Äç': {
                action: () => {
                    if (window.goGuildMembers) window.goGuildMembers();
                },
                icon: 'üßç‚Äç‚ôÇÔ∏èüßç‚Äç‚ôÇÔ∏è',
                color: '',
                description: 'Guild Members'
            },
            'üí¨': {
                action: () => {
                    if (window.goGuildChat) window.goGuildChat();
                },
                icon: 'üí¨',
                color: '',
                description: 'Guild Chat'
            },

            // Power Tournament and AoC - FIXED ENCODING
            'üèÜ': {
                action: () => {
                    if (window.goPowerTournament) window.goPowerTournament();
                },
                icon: 'üèÜ',
                color: '',
                description: 'Open Power Tournament'
            },
            'AoCüè∞': {
                action: () => {
                    if (window.goAoC) window.goAoC();
                },
                icon: '',
                color: '',
                description: 'Navigate to Arena of Champions'
            },

            // Statistics
            'Stats 2': {
                action: () => {
                    if (window.showArenaStatsModal) {
                        window.showArenaStatsModal();
                    } else {
                        debugLog('Stats not available');
                    }
                },
                icon: '',
                color: 'blue',
                description: 'Show Arena statistics'
            },
            'AoCüìä': {
                action: () => {
                    if (window.showAoCStatsUnified) window.showAoCStatsUnified();
                },
                icon: '',
                color: 'violet',
                description: 'Show AoC statistics'
            },

            // Utility functions - FIXED ENCODING
            'Collect +': {
                action: () => {
                    if (window.runCollectMore) {
                        window.runCollectMore();
                    } else {
                        debugLog('Collect More function not available');
                    }
                },
                icon: '',
                color: 'blue',
                description: 'Collect all rewards'
            },
            '‚öô': {
                action: () => {
                    if (window.showTweakerSettings) {
                        window.showTweakerSettings();
                    } else {
                        debugLog('Settings not available');
                    }
                },
                icon: '‚öô',
                color: '',
                description: 'Open Tweaker settings'
            },

            'Sync': {
                action: async () => {
                    await silentSync();
                },
                icon: '',
                color: '',
                description: 'Sync/refresh game data'
            },

            // Additional navigation buttons
            '>> Art Merch': {
                action: () => { if (cheats) cheats.goNavigtor('ARTIFACT_MERCHANT'); },
                icon: '', color: 'green', description: 'Artifact Merchant'
            },
            '>> Pet Merch': {
                action: () => { if (cheats) cheats.goNavigtor('PET_MERCHANT'); },
                icon: '', color: 'green', description: 'Pet Merchant'
            },
            '>> Pet Soul': {
                action: () => { openPetSoulShop(); },
                icon: '', color: 'cyan', description: 'Pet Soul Shop'
            },
            'Dungeon-actual': {
                action: () => openDungeon(),
                icon: 'üè∞',
                color: '',
                description: 'Open Dungeon'
            },
            'Outland-Auto': {
                action: () => clickOutland(),
                icon: 'üåå',
                color: '',
                description: 'Run Outland collection (HWH)'
            },
            'Tower-Auto': {
                action: () => clickTower(),
                icon: 'üóº',
                color: '',
                description: 'Run Tower auto-pass (HWH)'
            },
            'Expeditions-Auto': {
                action: () => clickExpeditions(),
                icon: 'üöÄ',
                color: '',
                description: 'Send/Collect Expeditions (HWH)'
            },
            'Minions-Auto': {
                action: () => clickMinions(),
                icon: 'üëπ',
                color: '',
                description: 'Attack Minions (HWH)'
            },
            'Inventory-Manager': {
                action: () => showInventoryManager(),
                icon: 'üì¶',
                color: '',
                description: 'Open Inventory Manager'
            },
            '>> Titan Soul': {
                action: () => { openTitanSoulShop(); },
                icon: '', color: 'cyan', description: 'Titan Soul Shop'
            },
            '>> Gold Season rewards list': {
                action: () => { openBattlePass(); },
                icon: '', color: 'cyan', description: 'Gold Season rewards list'
            },
            '>> Season Hub': {
                action: () => { openSeasonHub(); },
                icon: '', color: 'cyan', description: 'Season Hub'
            },
            '>> Mission': {
                action: () => { if (cheats) cheats.goNavigtor('MISSION'); },
                icon: '', color: 'green', description: 'Campaign Mission'
            },
            '>> Arena': {
                action: () => { if (cheats) cheats.goNavigtor('ARENA'); },
                icon: '', color: 'green', description: 'Arena'
            },
            '>> Grand': {
                action: () => { if (cheats) cheats.goNavigtor('GRAND'); },
                icon: '', color: 'green', description: 'Grand Arena'
            },
            '>> Tower': {
                action: () => { if (cheats) cheats.goNavigtor('TOWER'); },
                icon: '', color: 'green', description: 'Tower'
            },
            '>> Challenge': {
                action: () => { if (cheats) cheats.goNavigtor('CHALLENGE'); },
                icon: '', color: 'green', description: 'Challenge'
            },
            '>> Boss': {
                action: () => { if (cheats) cheats.goNavigtor('BOSS'); },
                icon: '', color: 'green', description: 'Boss'
            },
            '>> Brawl': {
                action: () => { if (cheats) cheats.goNavigtor('BRAWL'); },
                icon: '', color: 'green', description: 'Brawl'
            },
            '>> Boss Rtg': {
                action: () => { if (cheats) cheats.goNavigtor('BOSS_RATING_EVENT'); },
                icon: '', color: 'green', description: 'Boss Rating Event'
            },
            '>> Clan': {
                action: () => { if (cheats) cheats.goNavigtor('CLAN'); },
                icon: '', color: 'green', description: 'Clan/Guild'
            },
            '>> Cln Chest': {
                action: () => { if (cheats) cheats.goNavigtor('CLAN_CHEST'); },
                icon: '', color: 'green', description: 'Clan Chest'
            },
            '>> Cln Raid': {
                action: () => { if (cheats) cheats.goNavigtor('CLAN_RAID'); },
                icon: '', color: 'green', description: 'Clan Raid'
            },
            '>> GW Titan': {
                action: () => { if (cheats) cheats.goNavigtor('CLAN_GLOBAL_PVP_TITAN'); },
                icon: '', color: 'green', description: 'Guild War (Titans)'
            },
            '>> T Gift': {
                action: () => { if (cheats) cheats.goNavigtor('TITAN_GIFT'); },
                icon: '', color: 'green', description: 'Titan Gift'
            },
            '>> T Mission': {
                action: () => { if (cheats) cheats.goNavigtor('TITAN_MISSION'); },
                icon: '', color: 'green', description: 'Titan Mission'
            },
            '>> T Arena': {
                action: () => { if (cheats) cheats.goNavigtor('TITAN_ARENA'); },
                icon: '', color: 'green', description: 'Titan Arena'
            },
            '>> T Artifact': {
                action: () => { if (cheats) cheats.goNavigtor('TITAN_ARTIFACT'); },
                icon: '', color: 'green', description: 'Titan Artifact'
            },
            '>> T Art Chst': {
                action: () => { if (cheats) cheats.goNavigtor('TITAN_ARTIFACT_CHEST'); },
                icon: '', color: 'green', description: 'Titan Artifact Chest'
            },
            '>> T Spirits': {
                action: () => { if (cheats) cheats.goNavigtor('TITAN_SPIRITS'); },
                icon: '', color: 'green', description: 'Titan Spirits'
            },
            '>> T HoF': {
                action: () => { if (cheats) cheats.goNavigtor('TITAN_ARENA_HALL_OF_FAME'); },
                icon: '', color: 'green', description: 'Titan Hall of Fame'
            },
            '>> Skills': {
                action: () => { if (cheats) cheats.goNavigtor('SKILLS'); },
                icon: '', color: 'green', description: 'Hero Skills'
            },
            '>> Enchant': {
                action: () => { if (cheats) cheats.goNavigtor('ENCHANT'); },
                icon: '', color: 'green', description: 'Enchantment'
            },
            '>> Role Asc': {
                action: () => { if (cheats) cheats.goNavigtor('ROLE_ASCENSION'); },
                icon: '', color: 'green', description: 'Role Ascension'
            },
            '>> Asc Chest': {
                action: () => { if (cheats) cheats.goNavigtor('ASCENSION_CHEST'); },
                icon: '', color: 'green', description: 'Ascension Chest'
            },
            '>> Chest': {
                action: () => { if (cheats) cheats.goNavigtor('CHEST'); },
                icon: '', color: 'green', description: 'Chest'
            },
            '>> Artifact': {
                action: () => { if (cheats) cheats.goNavigtor('ARTIFACT'); },
                icon: '', color: 'green', description: 'Artifact'
            },
            '>> Art Chest': {
                action: () => { if (cheats) cheats.goNavigtor('ARTIFACT_CHEST'); },
                icon: '', color: 'green', description: 'Artifact Chest'
            },
            '>> Zeppelin': {
                action: () => { if (cheats) cheats.goNavigtor('ZEPPELIN'); },
                icon: '', color: 'green', description: 'Zeppelin/Airship'
            },
            '>> Soc Gift': {
                action: () => { if (cheats) cheats.goNavigtor('SOCIAL_GIFT'); },
                icon: '', color: 'green', description: 'Social Gift'
            },
            '>> Pet List': {
                action: () => { if (cheats) cheats.goNavigtor('PET_LIST'); },
                icon: '', color: 'green', description: 'Pet List'
            },
            '>> Pet Summon': {
                action: () => { if (cheats) cheats.goNavigtor('PET_SUMMON'); },
                icon: '', color: 'green', description: 'Pet Summon'
            },
            '>> Adventure': {
                action: () => { if (cheats) cheats.goNavigtor('ADVENTURE'); },
                icon: '', color: 'green', description: 'Adventure'
            },
            '>> Adv Solo': {
                action: () => { if (cheats) cheats.goNavigtor('ADVENTURESOLO'); },
                icon: '', color: 'green', description: 'Adventure Solo'
            },
            '>> Sanctuary': {
                action: () => { if (cheats) cheats.goNavigtor('SANCTUARY'); },
                icon: '', color: 'green', description: 'Sanctuary'
            },
            '>> Expedit': {
                action: () => { if (cheats) cheats.goNavigtor('EXPEDITIONS'); },
                icon: '', color: 'green', description: 'Expeditions'
            },
            '>> Rating': {
                action: () => { if (cheats) cheats.goNavigtor('RATING'); },
                icon: '', color: 'green', description: 'Rating'
            },
            '>> Chat': {
                action: () => { if (cheats) cheats.goNavigtor('CHAT'); },
                icon: '', color: 'green', description: 'Chat'
            },
            '>> Subscribe': {
                action: () => { if (cheats) cheats.goNavigtor('SUBSCRIPTION'); },
                icon: '', color: 'green', description: 'Subscription'
            },
            '>> NYGifts': {
                action: () => { if (cheats) cheats.goNavigtor('NY2018_GIFTS'); },
                icon: '', color: 'green', description: 'NY Gifts'
            },
            '>> NYTree': {
                action: () => { if (cheats) cheats.goNavigtor('NY2018_TREE'); },
                icon: '', color: 'green', description: 'NY Tree'
            },
            '>> NYWelcome': {
                action: () => { if (cheats) cheats.goNavigtor('NY2018_WELCOME'); },
                icon: '', color: 'green', description: 'NY Welcome'
            },



            'AG Buffs': {
                action: () => openAsgardBuffShop(),
                icon: 'üõ°Ô∏è',
                color: '',
                description: 'Asgard Buff Shop (Osh/Maestro)'
            },

            'CoW Shop': {
                action: () => openCoWShop(),
                icon: 'üè™',
                color: '',
                description: 'Clash of Worlds Shop'
            },

            'CoW Logs': {
                action: () => openCoWLogs(),
                icon: 'üìú',
                color: '',
                description: 'Clash of Worlds Battle Logs'
            },

            'CoW Def': {
                action: () => openCoWDefenders(),
                icon: 'üõ°Ô∏è',
                color: '',
                description: 'CoW Defensive Teams'
            },

            'CoW AtkSet': {
                action: () => openCoWAttackSettings(),
                icon: '‚öîÔ∏è',
                color: '',
                description: 'CoW Offensive Settings'
            },

            'CoW DefSet': {
                action: () => openCoWDefenseSettings(),
                icon: 'üõ°Ô∏è',
                color: '',
                description: 'CoW Defensive Settings'
            },

            'CoW Teams': {
                action: () => openCoWTeamList(),
                icon: 'üë•',
                color: '',
                description: 'CoW Team List / Signets'
            },

            'GW Board': {
                action: () => openGWLeaderboard(),
                icon: 'üèÜ',
                color: '',
                description: 'Guild War Leaderboard'
            },

            'AG Fame': {
                action: () => openAsgardHallOfFame(),
                icon: 'üèõÔ∏è',
                color: '',
                description: 'Asgard Hall of Fame'
            },

            'AG Stats': {
                action: () => openAsgardStats(),
                icon: 'üìä',
                color: '',
                description: 'Asgard Boss Damage Stats'
            },

            'TitanSim': {
                action: () => openTitanSim(),
                icon: 'üéÆ',
                color: '',
                description: 'Titan Battle Simulator'
            },

            'Avatars': {
                action: () => openAvatars(),
                icon: 'üë§',
                color: '',
                description: 'Select Avatar'
            },

            'Frames': {
                action: () => openFrames(),
                icon: 'üñºÔ∏è',
                color: '',
                description: 'Select Avatar Frame'
            },

            'ToE Open': {
                action: () => openToEUnfinished(),
                icon: 'üèüÔ∏è',
                color: '',
                description: 'ToE Unfinished Battles'
            },

            'Altar': {
                action: () => openAltarOfElements(),
                icon: '‚õ©Ô∏è',
                color: '',
                description: 'Altar of Elements'
            },

            'Settings': {
                action: () => openGameSettings(),
                icon: '‚öôÔ∏è',
                color: '',
                description: 'Game Settings'
            },

            'Summon': {
                action: () => openSummoningCircle(),
                icon: 'üîÆ',
                color: '',
                description: 'Summoning Circle'
            },

            'Glyphs': {
                action: () => openGlyphGifts(),
                icon: 'üíé',
                color: '',
                description: 'Glyph & Gift of Elements'
            },
            'GoE': {
                action: () => window.showGoEBuyer(),
                icon: '‚ö°',
                color: 'pink',
                description: 'Gift of Elements Buyer - Spend Sparks / Get Power / Reset'
            },



            // Utility buttons - FIXED ENCODING
            'Back': {
                action: () => {
                    if (cheats && cheats.goBack) {
                        cheats.goBack();
                    } else {
                        debugLog('Back function not available');
                    }
                },
                icon: '‚Üê',
                color: '',
                description: 'Go back (previous screen)'
            },
            'Home': {
                action: () => {
                    if (window.goHome) {
                        window.goHome();
                    } else if (cheats && cheats.goHome) {
                        cheats.goHome();
                    } else {
                        debugLog('Home function not available');
                    }
                },
                icon: 'üè†',
                color: '',
                description: 'Return to home screen (City/Guild)'
            },
            'Reload': {
                action: () => {
                    if (confirm('Reload the page? This will refresh everything.')) {
                        location.reload();
                    }
                },
                icon: 'üîÑ',
                color: 'orange',
                description: 'Reload the entire page'
            },
            'Do All': {
                action: () => {
                    if (window.clickDoAll) {
                        window.clickDoAll();
                    } else {
                        console.error('clickDoAll not loaded yet');
                    }
                },
                icon: 'üéØ',
                color: 'orange',
                description: 'Click HWH "Do All" button - runs all automated tasks'
            },

            'Actions ‚ñº': {
                action: () => {
                    if (window.clickActions) {
                        window.clickActions();
                    } else {
                        console.error('clickActions not loaded yet');
                    }
                },
                icon: '‚ö°',
                color: 'blue',
                description: 'Open HWH Actions popup menu'
            },

            'Others ‚ñº': {
                action: () => {
                    if (window.clickOthers) {
                        window.clickOthers();
                    } else {
                        console.error('clickOthers not loaded yet');
                    }
                },
                icon: 'üìã',
                color: 'violet',
                description: 'Open HWH Others popup menu'
            },

            'Others üìã': {
                action: () => {
                    if (window.showOthersPopup) {
                        window.showOthersPopup();
                    } else {
                        console.error('showOthersPopup not loaded yet');
                    }
                },
                icon: 'üìã',
                color: 'violet',
                description: 'Show custom Others popup with all options'
            },

            'Tweaker Tools': {
                action: () => {
                    if (window.showTweakerToolsPopup) {
                        window.showTweakerToolsPopup();
                    } else {
                        console.error('showTweakerToolsPopup not loaded yet');
                    }
                },
                icon: 'üîß',
                color: 'purple',
                description: 'Open Tweaker Tools popup with all functions'
            },
            '>> Titans': {
                action: () => {
                    if (cheats && cheats.goTitanValley) cheats.goTitanValley();
                },
                icon: '',
                color: 'green',
                description: 'Navigate to Titan Valley'
            },

            // In-game editor shortcuts
            '>> Hero Ed': {
                action: () => {
                    if (window.goHero) {
                        const heroId = prompt('Enter Hero ID or name:');
                        if (heroId) window.goHero(heroId);
                    }
                },
                icon: 'ü¶∏',
                color: 'orange',
                description: 'Open Hero in-game editor (prompts for ID/name)'
            },
            '>> Titan Ed': {
                action: () => {
                    if (window.goTitan) {
                        const titanId = prompt('Enter Titan ID or name:');
                        if (titanId) window.goTitan(titanId);
                    }
                },
                icon: 'üóø',
                color: 'orange',
                description: 'Open Titan in-game editor (prompts for ID/name)'
            },
            '>> Pet Ed': {
                action: () => {
                    if (window.goPet) {
                        const petId = prompt('Enter Pet ID or name:');
                        if (petId) window.goPet(petId);
                    }
                },
                icon: 'üêæ',
                color: 'orange',
                description: 'Open Pet in-game editor (prompts for ID/name)'
            },

            // Game Data Browser shortcuts
            'Hero Data': {
                action: () => {
                    if (window.showHeroBrowser) window.showHeroBrowser();
                },
                icon: 'üìä',
                color: 'blue',
                description: 'Open Hero Data Browser'
            },
            'Titan Data': {
                action: () => {
                    if (window.showTitanBrowser) window.showTitanBrowser();
                },
                icon: 'üìä',
                color: 'blue',
                description: 'Open Titan Data Browser'
            },
            'Pet Data': {
                action: () => {
                    if (window.showPetBrowser) window.showPetBrowser();
                },
                icon: 'üìä',
                color: 'blue',
                description: 'Open Pet Data Browser'
            },
            'Flag Data': {
                action: () => {
                    if (window.showFlagBrowser) window.showFlagBrowser();
                },
                icon: 'üö©',
                color: 'blue',
                description: 'Open Flag/Banner Data Browser'
            },
            'Game Data': {
                action: () => {
                    if (window.showGameDataPopup) window.showGameDataPopup();
                },
                icon: 'üìä',
                color: 'purple',
                description: 'Open Game Data Overview popup'
            },
            'Inv Manager': {
                action: () => {
                    if (window.showInventoryManager) window.showInventoryManager();
                },
                icon: 'üì¶',
                color: 'teal',
                description: 'Open Inventory Manager'
            },

            // ================================================================
            // COMBINED ACTION BUTTONS (ToE, Dungeon, Adventure)
            // ================================================================

            'ToE': {
                action: () => {
                    if (window.clickToE) {
                        window.clickToE();
                    } else {
                        console.error('clickToE not loaded yet');
                    }
                },
                icon: '‚öîÔ∏è',
                color: '',
                description: 'Click HWH ToE Auto ToE'
            },

            '>> ToE': {
                action: () => {
                    if (window.clickToENavigate) {
                        window.clickToENavigate();
                    } else {
                        console.error('clickToENavigate not loaded yet');
                    }
                },
                icon: '‚û°Ô∏è',
                color: 'green',
                description: 'Navigate to Titan Valley'
            },

            'Dungeon': {
                action: () => {
                    if (window.clickDungeon) {
                        window.clickDungeon();
                    } else {
                        console.error('clickDungeon not loaded yet');
                    }
                },
                icon: 'üè∞',
                color: '',
                description: 'Click HWH Dungeon button'
            },

            '>> Dung': {
                action: () => {
                    if (window.clickDungeonNavigate) {
                        window.clickDungeonNavigate();
                    } else {
                        console.error('clickDungeonNavigate not loaded yet');
                    }
                },
                icon: '‚û°Ô∏è',
                color: 'green',
                description: 'Navigate to Guild Island'
            },

            'Adv.': {
                action: () => {
                    if (window.clickAdventure) {
                        window.clickAdventure();
                    } else {
                        console.error('clickAdventure not loaded yet');
                    }
                },
                icon: 'üó∫Ô∏è',
                color: '',
                description: 'Click HWH Adventure button'
            },

            'Adv. Raid': {
                action: () => {
                    if (window.clickAdventureRaid) {
                        window.clickAdventureRaid();
                    } else {
                        console.error('clickAdventureRaid not loaded yet');
                    }
                },
                icon: '‚öîÔ∏è',
                color: 'orange',
                description: 'Click HWH Adventure Raid option'
            },

            '>> Sanct': {
                action: () => {
                    if (window.clickAdventureNavigate) {
                        window.clickAdventureNavigate();
                    } else {
                        console.error('clickAdventureNavigate not loaded yet');
                    }
                },
                icon: '‚û°Ô∏è',
                color: 'green',
                description: 'Navigate to Sanctuary'
            },

            // ================================================================
            // UTILITY BUTTONS
            // ================================================================

            'Rewards': {
                action: () => {
                    if (window.clickRewardsAndMail) {
                        window.clickRewardsAndMail();
                    } else {
                        console.error('clickRewardsAndMail not loaded yet');
                    }
                },
                icon: 'üéÅ',
                color: 'yellow',
                description: 'Click HWH Rewards and Mail button'
            },

            'Quests': {
                action: () => {
                    if (window.clickQuests) {
                        window.clickQuests();
                    } else {
                        console.error('clickQuests not loaded yet');
                    }
                },
                icon: 'üìú',
                color: '',
                description: 'Click HWH Daily Quests button'
            },

            'Extensions': {
                action: () => {
                    if (window.clickExtensions) {
                        window.clickExtensions();
                    } else {
                        console.error('clickExtensions not loaded yet');
                    }
                },
                icon: 'üîå',
                color: 'red',
                description: 'Click HWH Extensions button'
            },
            'Test1': {
                action: () => {
                    const valuesDetails = DOMCache.get('valuesDetails', 'details[data-name="values"]');
                    if (valuesDetails) {
                        const testBattleInput = valuesDetails.querySelector('input[data-name="countTestBattle"]');
                        if (testBattleInput) {
                            testBattleInput.value = 1;
                            testBattleInput.dispatchEvent(new Event('input', { bubbles: true }));
                            debugLog('‚úî Set Test Battle count to 1');
                            window.updateTestBattleHighlight();  // <-- ADD THIS LINE
                        }
                    }
                },
                icon: 'üéØ1',
                color: 'beige',
                description: 'Set Test Battle count to 1'
            },
            'Test10': {
                action: () => {
                    const valuesDetails = DOMCache.get('valuesDetails', 'details[data-name="values"]');
                    if (valuesDetails) {
                        const testBattleInput = valuesDetails.querySelector('input[data-name="countTestBattle"]');
                        if (testBattleInput) {
                            testBattleInput.value = 10;
                            testBattleInput.dispatchEvent(new Event('input', { bubbles: true }));
                            debugLog('‚úì Set Test Battle count to 10');
                            window.updateTestBattleHighlight();
                        }
                    }
                },
                icon: 'üéØ10',
                color: 'beige',
                description: 'Set Test Battle count to 10'
            },

            'Test20': {
                action: () => {
                    const valuesDetails = DOMCache.get('valuesDetails', 'details[data-name="values"]');
                    if (valuesDetails) {
                        const testBattleInput = valuesDetails.querySelector('input[data-name="countTestBattle"]');
                        if (testBattleInput) {
                            testBattleInput.value = 20;
                            testBattleInput.dispatchEvent(new Event('input', { bubbles: true }));
                            debugLog('‚úì Set Test Battle count to 20');
                            window.updateTestBattleHighlight();
                        }
                    }
                },
                icon: 'üéØ20',
                color: 'beige',
                description: 'Set Test Battle count to 20'
            },
            'Test50': {
                action: () => {
                    const valuesDetails = DOMCache.get('valuesDetails', 'details[data-name="values"]');
                    if (valuesDetails) {
                        const testBattleInput = valuesDetails.querySelector('input[data-name="countTestBattle"]');
                        if (testBattleInput) {
                            testBattleInput.value = 50;
                            testBattleInput.dispatchEvent(new Event('input', { bubbles: true }));
                            debugLog('‚úì Set Test Battle count to 50');
                            window.updateTestBattleHighlight();
                        }
                    }
                },
                icon: 'üéØ50',
                color: 'beige',
                description: 'Set Test Battle count to 50'
            },

            'Test100': {
                action: () => {
                    const valuesDetails = DOMCache.get('valuesDetails', 'details[data-name="values"]');
                    if (valuesDetails) {
                        const testBattleInput = valuesDetails.querySelector('input[data-name="countTestBattle"]');
                        if (testBattleInput) {
                            testBattleInput.value = 100;
                            testBattleInput.dispatchEvent(new Event('input', { bubbles: true }));
                            debugLog('‚úì Set Test Battle count to 100');
                            window.updateTestBattleHighlight();
                        }
                    }
                },
                icon: 'üéØ100',
                color: 'beige',
                description: 'Set Test Battle count to 100'
            },
            'Test200': {
                action: () => {
                    const valuesDetails = DOMCache.get('valuesDetails', 'details[data-name="values"]');
                    if (valuesDetails) {
                        const testBattleInput = valuesDetails.querySelector('input[data-name="countTestBattle"]');
                        if (testBattleInput) {
                            testBattleInput.value = 200;
                            testBattleInput.dispatchEvent(new Event('input', { bubbles: true }));
                            debugLog('‚úì Set Test Battle count to 200');
                            window.updateTestBattleHighlight();
                        }
                    }
                },
                icon: 'üéØ200',
                color: 'beige',
                description: 'Set Test Battle count to 200'
            },
            // ================================================================
            // TITANITE COUNT BUTTONS
            // ================================================================

            'Titan150': {
                action: () => {
                    const valuesDetails = DOMCache.get('valuesDetails', 'details[data-name="values"]');
                    if (valuesDetails) {
                        const titaniteInput = valuesDetails.querySelector('input[data-name="countTitanit"]');
                        if (titaniteInput) {
                            titaniteInput.value = 150;
                            titaniteInput.dispatchEvent(new Event('input', { bubbles: true }));
                            debugLog('‚úî Set Titanite count to 150');
                            window.updateTitaniteHighlight?.();
                        }
                    }
                },
                icon: '‚ö°150',
                color: 'beige',
                description: 'Set Titanite count to 150'
            },
            'Titan300': {
                action: () => {
                    const valuesDetails = DOMCache.get('valuesDetails', 'details[data-name="values"]');
                    if (valuesDetails) {
                        const titaniteInput = valuesDetails.querySelector('input[data-name="countTitanit"]');
                        if (titaniteInput) {
                            titaniteInput.value = 300;
                            titaniteInput.dispatchEvent(new Event('input', { bubbles: true }));
                            debugLog('‚úî Set Titanite count to 300');
                            window.updateTitaniteHighlight?.();
                        }
                    }
                },
                icon: '‚ö°300',
                color: 'beige',
                description: 'Set Titanite count to 300'
            },
            'Titan450': {
                action: () => {
                    const valuesDetails = DOMCache.get('valuesDetails', 'details[data-name="values"]');
                    if (valuesDetails) {
                        const titaniteInput = valuesDetails.querySelector('input[data-name="countTitanit"]');
                        if (titaniteInput) {
                            titaniteInput.value = 450;
                            titaniteInput.dispatchEvent(new Event('input', { bubbles: true }));
                            debugLog('‚úî Set Titanite count to 450');
                            window.updateTitaniteHighlight?.();
                        }
                    }
                },
                icon: '‚ö°450',
                color: 'beige',
                description: 'Set Titanite count to 450'
            },
            'Titan600': {
                action: () => {
                    const valuesDetails = DOMCache.get('valuesDetails', 'details[data-name="values"]');
                    if (valuesDetails) {
                        const titaniteInput = valuesDetails.querySelector('input[data-name="countTitanit"]');
                        if (titaniteInput) {
                            titaniteInput.value = 600;
                            titaniteInput.dispatchEvent(new Event('input', { bubbles: true }));
                            debugLog('‚úî Set Titanite count to 600');
                            window.updateTitaniteHighlight?.();
                        }
                    }
                },
                icon: '‚ö°600',
                color: 'beige',
                description: 'Set Titanite count to 600'
            },
            'Titan750': {
                action: () => {
                    const valuesDetails = DOMCache.get('valuesDetails', 'details[data-name="values"]');
                    if (valuesDetails) {
                        const titaniteInput = valuesDetails.querySelector('input[data-name="countTitanit"]');
                        if (titaniteInput) {
                            titaniteInput.value = 750;
                            titaniteInput.dispatchEvent(new Event('input', { bubbles: true }));
                            debugLog('‚úî Set Titanite count to 750');
                            window.updateTitaniteHighlight?.();
                        }
                    }
                },
                icon: '‚ö°750',
                color: 'beige',
                description: 'Set Titanite count to 750'
            },
            'Titan900': {
                action: () => {
                    const valuesDetails = DOMCache.get('valuesDetails', 'details[data-name="values"]');
                    if (valuesDetails) {
                        const titaniteInput = valuesDetails.querySelector('input[data-name="countTitanit"]');
                        if (titaniteInput) {
                            titaniteInput.value = 900;
                            titaniteInput.dispatchEvent(new Event('input', { bubbles: true }));
                            debugLog('‚úî Set Titanite count to 900');
                            window.updateTitaniteHighlight?.();
                        }
                    }
                },
                icon: '‚ö°900',
                color: 'beige',
                description: 'Set Titanite count to 900'
            },
            'Titan1500': {
                action: () => {
                    const valuesDetails = DOMCache.get('valuesDetails', 'details[data-name="values"]');
                    if (valuesDetails) {
                        const titaniteInput = valuesDetails.querySelector('input[data-name="countTitanit"]');
                        if (titaniteInput) {
                            titaniteInput.value = 1500;
                            titaniteInput.dispatchEvent(new Event('input', { bubbles: true }));
                            debugLog('‚úî Set Titanite count to 1500');
                            window.updateTitaniteHighlight?.();
                        }
                    }
                },
                icon: '‚ö°1500',
                color: 'beige',
                description: 'Set Titanite count to 1500'
            },

            'TestHeroic': {
                action: async () => {
                    debugLog('üß™ Testing Heroic Mission Selection...');

                    const PREFERRED_MISSION = 116; // Aurora Ch.9
                    const heroNames = {1:'Aurora',2:'Galahad',3:'Keira',4:'Astaroth',6:'Phobos',7:'Thea',8:'Daredevil',9:'Heidi'};

                    try {
                        const [missions, heroes, userInfo] = await Caller.send(['missionGetAll', 'heroGetAll', 'userGetInfo']);

                        // Check current HWH logic
                        const available = Object.values(missions).filter(m => m.stars === 3).map(m => m.id);
                        const heroicMissions = Object.values(lib.data.mission).filter(m => m.isHeroic && available.includes(m.id));

                        const drops = heroicMissions.map(m => {
                            const lastWave = m.normalMode.waves[m.normalMode.waves.length - 1];
                            const rewards = lastWave.enemies[lastWave.enemies.length - 1].drop.map(d => d.reward);
                            const heroFragment = rewards.find(r => r.fragmentHero);
                            const heroId = heroFragment ? +Object.keys(heroFragment.fragmentHero)[0] : 0;
                            return { missionId: m.id, heroId, chapter: m.world };
                        });

                        const heroesToUpgrade = Object.values(heroes).filter(h => h.star < 6).sort((a, b) => b.power - a.power);

                        let hwhChoice = null;
                        for (const hero of heroesToUpgrade) {
                            const match = drops.find(d => d.heroId === hero.id);
                            if (match) {
                                hwhChoice = match;
                                break;
                            }
                        }

                        // Check stamina
                        const stamina = userInfo.refillable.find(x => x.id == 1).amount;
                        const missionData = lib.data.mission[PREFERRED_MISSION];
                        const missionStatus = missions[PREFERRED_MISSION];
                        const staminaCost = 3 * missionData.normalMode.teamExp;

                        debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                        debugLog('üß™ HEROIC MISSION TEST RESULTS');
                        debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                        debugLog(`üìä Heroes under 6‚≠ê: ${heroesToUpgrade.length}`);

                        if (hwhChoice) {
                            debugLog(`üéØ HWH would pick: Mission ${hwhChoice.missionId} (${heroNames[hwhChoice.heroId] || 'Hero '+hwhChoice.heroId} Ch.${hwhChoice.chapter})`);
                        } else {
                            debugLog('‚ö†Ô∏è HWH would pick: Mission 1 (fallback - no heroes under 6‚≠ê)');
                        }

                        debugLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                        debugLog(`üéØ Override target: Mission ${PREFERRED_MISSION} (Aurora Ch.9)`);
                        debugLog(`   3-starred: ${missionStatus?.stars === 3 ? '‚úÖ Yes' : '‚ùå No'}`);
                        debugLog(`   Stamina: ${stamina} / ${staminaCost} needed ${stamina >= staminaCost ? '‚úÖ' : '‚ùå'}`);
                        debugLog(`   Override would work: ${missionStatus?.stars === 3 && stamina >= staminaCost ? '‚úÖ YES' : '‚ùå NO'}`);
                        debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

                    } catch (e) {
                        console.error('‚ùå Test failed:', e);
                    }
                },
                icon: 'üß™',
                color: 'lightgreen',
                description: 'Test Heroic Mission Override'
            },

            // ================================================================
            // AUTOMATION SEQUENCE BUTTONS
            // ================================================================

            'Quick Collect': {
                action: async () => {
                    debugLog('üéØ Starting Quick Collect sequence...');

                    if (window.clickRewardsAndMail) {
                        window.clickRewardsAndMail();
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }

                    if (window.clickQuests) {
                        window.clickQuests();
                        await new Promise(resolve => setTimeout(resolve, 1500));
                    }

                    debugLog('‚úÖ Quick Collect complete');
                },
                icon: '‚ö°',
                color: 'yellow',
                description: 'Quickly collect rewards and check quests'
            },

            'Full Auto': {
                action: async () => {
                    if (!confirm('Run full automation sequence?\n\n‚Ä¢ Rewards & Mail\n‚Ä¢ Quests\n‚Ä¢ Do All')) {
                        return;
                    }

                    debugLog('ü§ñ Starting Full Auto sequence...');

                    if (window.clickRewardsAndMail) {
                        debugLog('1/3 Collecting rewards...');
                        window.clickRewardsAndMail();
                        await new Promise(resolve => setTimeout(resolve, 3000));
                    }

                    if (window.clickQuests) {
                        debugLog('2/3 Checking quests...');
                        window.clickQuests();
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }

                    if (window.clickDoAll) {
                        debugLog('3/3 Running Do All...');
                        window.clickDoAll();
                    }

                    debugLog('‚úÖ Full Auto complete!');
                },
                icon: 'ü§ñ',
                color: 'orange',
                description: 'Run complete automation: Rewards ‚Üí Quests ‚Üí Do All'
            },
            // ================================================================
            // OTHERS MENU BUTTONS (direct access without opening menu)
            // ================================================================

            'Get Energy': {
                action: () => {
                    if (window.clickGetEnergy) {
                        window.clickGetEnergy();
                    } else {
                        console.error('clickGetEnergy not loaded yet');
                    }
                },
                icon: '‚ö°',
                color: 'yellow',
                description: 'Get Energy / Farm Stamina (Others menu)'
            },

            'Item Exchange': {
                action: () => {
                    if (window.clickItemExchange) {
                        window.clickItemExchange();
                    } else {
                        console.error('clickItemExchange not loaded yet');
                    }
                },
                icon: 'üîÑ',
                color: 'cyan',
                description: 'Item Exchange / Fill Active (Others menu)'
            },

            'Buy Souls': {
                action: () => {
                    if (window.clickBuySouls) {
                        window.clickBuySouls();
                    } else {
                        console.error('clickBuySouls not loaded yet');
                    }
                },
                icon: 'üíé',
                color: 'purple',
                description: 'Buy Hero Fragments/Souls (Others menu)'
            },

            'Buy for Gold': {
                action: () => {
                    if (window.clickBuyForGold) {
                        window.clickBuyForGold();
                    } else {
                        console.error('clickBuyForGold not loaded yet');
                    }
                },
                icon: 'ü™ô',
                color: 'gold',
                description: 'Buy in Store for Gold (Others menu)'
            },

            'Buy Outland': {
                action: () => {
                    if (window.clickBuyOutland) {
                        window.clickBuyOutland();
                    } else {
                        console.error('clickBuyOutland not loaded yet');
                    }
                },
                icon: 'üì¶',
                color: 'orange',
                description: 'Buy Outland Chests (Others menu)'
            },

            'Clan Stat': {
                action: () => {
                    if (window.clickClanStat) {
                        window.clickClanStat();
                    } else {
                        console.error('clickClanStat not loaded yet');
                    }
                },
                icon: 'üìä',
                color: 'blue',
                description: 'Clan Statistics (Others menu)'
            },

            'Epic Brawl': {
                action: () => {
                    if (window.clickEpicBrawl) {
                        window.clickEpicBrawl();
                    } else {
                        console.error('clickEpicBrawl not loaded yet');
                    }
                },
                icon: '‚öîÔ∏è',
                color: 'red',
                description: 'Epic Brawl Auto (Others menu)'
            },

            'Artifacts Up': {
                action: () => {
                    if (window.clickArtifactsUpgrade) {
                        window.clickArtifactsUpgrade();
                    } else {
                        console.error('clickArtifactsUpgrade not loaded yet');
                    }
                },
                icon: 'üì±',
                color: 'purple',
                description: 'Artifacts Upgrade (Others menu)'
            },

            'Fragment Hunter': {
                action: () => {
                    if (window.showFragmentHunter) {
                        window.showFragmentHunter();
                    } else {
                        console.error('showFragmentHunter not loaded yet');
                    }
                },
                icon: 'üéØ',
                color: 'red',
                description: 'Hunt gear/scroll fragments by category or hero needs'
            },

            'Skins Up': {
                action: () => {
                    if (window.clickSkinsUpgrade) {
                        window.clickSkinsUpgrade();
                    } else {
                        console.error('clickSkinsUpgrade not loaded yet');
                    }
                },
                icon: 'üé®',
                color: 'pink',
                description: 'Skins Upgrade (Others menu)'
            },

            'Season Reward': {
                action: () => {
                    if (window.clickSeasonReward) {
                        window.clickSeasonReward();
                    } else {
                        console.error('clickSeasonReward not loaded yet');
                    }
                },
                icon: 'üèÜ',
                color: 'gold',
                description: 'Farm Season/Battle Pass Rewards (Others menu)'
            },

            'Sell Souls': {
                action: () => {
                    if (window.clickSellHeroSouls) {
                        window.clickSellHeroSouls();
                    } else {
                        console.error('clickSellHeroSouls not loaded yet');
                    }
                },
                icon: 'üí∞',
                color: 'gold',
                description: 'Sell Hero Souls for Gold (Others menu)'
            },

            'Change Map': {
                action: () => {
                    if (window.clickChangeMap) {
                        window.clickChangeMap();
                    } else {
                        console.error('clickChangeMap not loaded yet');
                    }
                },
                icon: 'üó∫Ô∏è',
                color: 'green',
                description: 'Change Adventure Map (Others menu)'
            },

            'Hero Power': {
                action: () => {
                    if (window.clickHeroPower) {
                        window.clickHeroPower();
                    } else {
                        console.error('clickHeroPower not loaded yet');
                    }
                },
                icon: 'üí™',
                color: 'red',
                description: 'Check Hero Power Status (Others menu)'
            },
            'Winterfest25': {
                action: () => {
                    if (window.showWinterfestRankings) {
                        window.showWinterfestRankings();
                    } else {
                        console.error('showWinterfestRankings not loaded yet');
                    }
                },
                icon: 'üéÑ',
                color: 'green',
                description: 'Winterfest 2025 Rankings (Gifts & NY Tree)'
            },
            'üéÅ Gifts': {
                action: () => window.showWinterfestGifts(),
                icon: 'üéÅ',
                color: 'red',
                description: 'Winterfest Gift Tracker'
            },
            // ================================================================
            // TWEAKER-SPECIFIC BUTTONS (from extended Others menu)
            // ================================================================

            'Tweaker Settings': {
                action: () => {
                    if (window.showTweakerSettings) {
                        window.showTweakerSettings();
                    } else {
                        console.error('showTweakerSettings not loaded yet');
                    }
                },
                icon: '‚öôÔ∏è',
                color: 'gray',
                description: 'Open Tweaker Settings popup'
            },

            'Export Game Data': {
                action: () => {
                    if (window.exportGameDataWithUI) {
                        window.exportGameDataWithUI();
                    } else {
                        debugLog('Triggering export via Others menu...');
                        const btn = document.querySelector('button[title*="Export"]');
                        if (btn) btn.click();
                    }
                },
                icon: 'üì§',
                color: 'blue',
                description: 'Export Hero/Guild/Ranking Data'
            },

            'Quiz Rankings': {
                action: () => {
                    if (window.showQuizRankings) {
                        window.showQuizRankings();
                    } else {
                        console.error('showQuizRankings not loaded yet');
                    }
                },
                icon: 'üèÜ',
                color: 'gold',
                description: 'View Quiz Rankings from any server'
            },

            'Game Data': {
                action: () => {
                    if (window.showGameDataPopup) {
                        window.showGameDataPopup();
                    } else {
                        console.error('showGameDataPopup not loaded yet');
                    }
                },
                icon: 'üìä',
                color: 'cyan',
                description: 'View Hero/Titan/Pet Data Tables'
            },

            'Edit Adv Paths': {
                action: async () => {
                    if (window.editAdventurePathsStandalone) {
                        await window.editAdventurePathsStandalone();
                    } else {
                        console.error('editAdventurePathsStandalone not loaded yet');
                    }
                },
                icon: 'üó∫Ô∏è',
                color: 'green',
                description: 'Edit Adventure Paths (standalone)'
            },

            'Inv Manager': {
                action: () => {
                    if (window.showInventoryManager) {
                        window.showInventoryManager();
                    } else {
                        console.error('showInventoryManager not loaded yet');
                    }
                },
                icon: 'üì¶',
                color: 'orange',
                description: 'Open Inventory Manager popup'
            },

            'HW Settings': {
                action: () => {
                    try {
                        let settingsMediator = selfGame['game.mechanics.settings.popup.SettingsPopupMediator'];
                        new settingsMediator().open();
                        debugLog('Game Settings popup opened');
                    } catch (e) {
                        console.error('Failed to open Game Settings:', e);
                    }
                },
                icon: '‚öôÔ∏è',
                color: 'brown',
                description: 'Open Hero Wars Game Settings'
            },
            'Lucky Road': {
                action: () => {
                    openLuckyRoadPopup();
                },
                icon: 'üé≤',
                color: 'orange',
                description: 'Lucky Road Auto-Roller with reward tracking'
            },
            '>> Combat': {
                action: () => {
                    try {
                        let player = getPlayer();
                        let chatPopupMediator = selfGame['game.mediator.gui.popup.chat.ChatPopupMediator'];
                        let mediator = new chatPopupMediator(player);
                        let chatProps = chatPopupMediator.prototype.__properties__;
                        let setTabMethod = Object.entries(chatProps).find(e => e[1] === 'set_selectedTab')?.[0];
                        if (setTabMethod) mediator[setTabMethod]('DEMO_BATTLES_TAB');
                        mediator.open();
                    } catch (e) { console.error('Failed to open Combat Training:', e); }
                },
                icon: '‚öîÔ∏è', color: 'green', description: 'Combat Training tab'
            },
            '>> PM': {
                action: () => {
                    try {
                        let player = getPlayer();
                        let chatPopupMediator = selfGame['game.mediator.gui.popup.chat.ChatPopupMediator'];
                        let mediator = new chatPopupMediator(player);
                        let chatProps = chatPopupMediator.prototype.__properties__;
                        let setTabMethod = Object.entries(chatProps).find(e => e[1] === 'set_selectedTab')?.[0];
                        if (setTabMethod) mediator[setTabMethod]('PRIVATE_TAB');
                        mediator.open();
                    } catch (e) { console.error('Failed to open Private Messages:', e); }
                },
                icon: '‚úâÔ∏è', color: 'green', description: 'Private Messages tab'
            },
            'Hero Demo': {
                action: () => {
                    try {
                        let player = getPlayer();
                        new selfGame['game.view.popup.demoBattle.DemoBattleCreatePopupMediator'](player, 1, null, null, null, null).open();
                    } catch (e) { console.error('Failed to open Hero Demo Battle:', e); }
                },
                icon: 'ü¶∏', color: '#4ae29a', description: 'Create Hero Demo Battle'
            },
            'Titan Demo': {
                action: () => {
                    try {
                        let player = getPlayer();
                        new selfGame['game.view.popup.demoBattle.DemoBattleCreatePopupMediator'](player, 0, null, null, null, null).open();
                    } catch (e) { console.error('Failed to open Titan Demo Battle:', e); }
                },
                icon: 'üëπ', color: '#ff9900', description: 'Create Titan Demo Battle'
            },


            'Daily Routine': {
                action: async () => {
                    if (!confirm('Run daily routine?\n\n‚Ä¢ Rewards & Mail\n‚Ä¢ ToE\n‚Ä¢ Dungeon\n‚Ä¢ Adventure\n‚Ä¢ Quests')) {
                        return;
                    }

                    debugLog('üåÖ Starting Daily Routine...');

                    if (window.clickRewardsAndMail) {
                        debugLog('1/5 Collecting rewards...');
                        window.clickRewardsAndMail();
                        await new Promise(resolve => setTimeout(resolve, 3000));
                    }

                    if (window.clickToE) {
                        debugLog('2/5 Running ToE...');
                        window.clickToE();
                        await new Promise(resolve => setTimeout(resolve, 4000));
                    }

                    if (window.clickDungeon) {
                        debugLog('3/5 Running Dungeon...');
                        window.clickDungeon();
                        await new Promise(resolve => setTimeout(resolve, 4000));
                    }

                    if (window.clickAdventure) {
                        debugLog('4/5 Running Adventure...');
                        window.clickAdventure();
                        await new Promise(resolve => setTimeout(resolve, 3000));
                    }

                    if (window.clickQuests) {
                        debugLog('5/5 Checking quests...');
                        window.clickQuests();
                    }

                    debugLog('‚úÖ Daily Routine complete!');
                },
                icon: 'üåÖ',
                color: 'blue',
                description: 'Complete daily routine sequence'
            },
        };
        // Save defaults and load custom functions
        DEFAULT_BUTTON_FUNCTIONS = JSON.parse(JSON.stringify(
            Object.keys(BUTTON_FUNCTIONS).reduce((acc, key) => {
                acc[key] = {
                    actionCode: BUTTON_FUNCTIONS[key].action.toString(),
                    icon: BUTTON_FUNCTIONS[key].icon,
                    color: BUTTON_FUNCTIONS[key].color,
                    description: BUTTON_FUNCTIONS[key].description
                };
                return acc;
            }, {})
        ));


        const customFunctions = loadCustomFunctions();
        Object.assign(BUTTON_FUNCTIONS, customFunctions);

        debugLog(`üìö Loaded ${Object.keys(BUTTON_FUNCTIONS).length} total functions (${Object.keys(customFunctions).length} custom)`);


        // Default layout
        const DEFAULT_TABS = [
            {
                name: 'Main',
                rows: [
                    ['ToE', '>> ToE'],
                    ['Dungeon', '>> Dung'],
                    ['Adv.', 'Raid', '>> Sanct'],
                    ['Actions', 'Others'],
                    ['GW', 'CoW'],
                    ['Asgard', 'Spire'],
                    ['Merch', 'TMerch'],
                ]
            },
            {
                name: 'Heroes',
                rows: [
                    ['Heroes', 'Pets'],
                    ['Events', 'Inventory'],
                    ['Titans', 'Totems'],
                ]
            },
            {
                name: 'Utils',
                rows: [
                    ['üõ°Ô∏è', 'üßô‚Äç‚ôÇÔ∏èüßô‚Äç‚ôÇÔ∏è', 'üí¨'],
                    ['üè∞', 'Stats 2'],
                    ['Collect +', '‚öô'],
                ]
            }
        ];

        // For backward compatibility, keep the flat DEFAULT_LAYOUT
        const DEFAULT_LAYOUT = [
            ['ToE', '>> ToE'],
            ['Dungeon', '>> Dung'],
            ['Adv.', 'Raid', '>> Sanct'],
            ['Actions', 'Others'],
            ['GW', 'CoW'],
            ['Asgard', 'Spire'],
            ['Merch', 'TMerch'],
            ['Heroes', 'Pets'],
            ['Events', 'Inventory'],
            ['Titans', 'Totems'],
            ['üõ°Ô∏è', 'üßô‚Äç‚ôÇÔ∏èüßô‚Äç‚ôÇÔ∏è', 'üí¨'],
            ['üè∞', 'Stats 2'],
            ['Collect +', '‚öô'],
        ];

        // Storage for per-button customizations (icon, color, description)
        function loadButtonCustomizations() {
            try {
                const saved = GM_getValue('hwh_button_customizations');
                return saved ? JSON.parse(saved) : {};
            } catch (e) {
                console.warn('Failed to load button customizations:', e);
                return {};
            }
        }

        function saveButtonCustomizations(customizations) {
            try {
                GM_setValue('hwh_button_customizations', JSON.stringify(customizations));
                debugLog('üíæ Button customizations saved');
                return true;
            } catch (e) {
                console.error('Failed to save button customizations:', e);
                return false;
            }
        }

        // Initialize customizations on load
        if (!window.buttonCustomizations) {
            window.buttonCustomizations = loadButtonCustomizations();
            debugLog(`üìö Loaded ${Object.keys(window.buttonCustomizations).length} button customizations`);
        }

        // Helper to get effective button properties (with customizations applied)
        function getButtonConfig(buttonId) {
            const baseFunc = BUTTON_FUNCTIONS[buttonId];
            if (!baseFunc) return null;

            const custom = window.buttonCustomizations[buttonId] || {};

            return {
                action: baseFunc.action,
                icon: custom.icon !== undefined ? custom.icon : (baseFunc.icon || ''),
                color: custom.color !== undefined ? custom.color : (baseFunc.color || ''),
                description: custom.description !== undefined ? custom.description : (baseFunc.description || ''),
                fontSize: custom.fontSize !== undefined ? custom.fontSize : (baseFunc.fontSize || null),
                customColor: custom.customColor !== undefined ? custom.customColor : (baseFunc.customColor || null),
                isCustom: baseFunc.isCustom || false
            };
        }

        // ================================================================
        // STYLES WITH THEME SUPPORT
        // ================================================================

        function addCompactSidebarStyles() {
            if (document.getElementById('hwh-compact-sidebar-styles')) return;
            const TAB_STYLES = `
/* ============================================
   SIDEBAR TAB BAR - Matches chat sidebar style
   ============================================ */
.hwh-tab-bar {
    display: flex;
    background: rgba(0,0,0,0.2);
    flex-shrink: 0;
}

.hwh-tab {
    flex: 1;
    background: #4a3510;
    color: #999;
    border: none;
    padding: 6px 8px;
    cursor: pointer;
    font-size: 10px;
    font-weight: bold;
    transition: all 0.2s ease;
    white-space: nowrap;
    text-align: center;
}

.hwh-tab:hover {
    background: #5a4210;
    color: #ccc;
}

.hwh-tab.active {
    background: #8b6914;
    color: #ffd700;
}

/* ============================================
   EDITOR TAB BAR - Matches chat sidebar style
   ============================================ */
.hwh-editor-tab-bar {
    display: flex;
    background: rgba(0,0,0,0.2);
    margin-bottom: 12px;
    flex-shrink: 0;
}

.hwh-editor-tab {
    flex: 1;
    background: #4a3510;
    color: #999;
    border: none;
    padding: 8px;
    cursor: pointer;
    font-size: 10px;
    font-weight: bold;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    white-space: nowrap;
}

.hwh-editor-tab:hover {
    background: #5a4210;
    color: #ccc;
}

.hwh-editor-tab.active {
    background: #8b6914;
    color: #ffd700;
}

.hwh-editor-tab-name {
    max-width: 100px;
    overflow: hidden;
    text-overflow: ellipsis;
}

.hwh-editor-tab-actions {
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.2s;
    margin-left: 4px;
}

.hwh-editor-tab:hover .hwh-editor-tab-actions {
    opacity: 1;
}

.hwh-editor-tab-btn {
    padding: 2px 6px;
    background: rgba(0, 0, 0, 0.3);
    border: none;
    border-radius: 3px;
    color: #fff;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.1s;
}

.hwh-editor-tab-btn:hover {
    background: rgba(255, 255, 255, 0.2);
}

.hwh-editor-tab-btn.delete:hover {
    background: rgba(231, 76, 60, 0.7);
    color: #fff;
}

/* Add Tab Button */
.hwh-editor-add-tab {
    padding: 8px 14px;
    background: transparent;
    border: none;
    border-left: 1px dashed rgba(46, 204, 113, 0.4);
    color: #2ecc71;
    font-size: 12px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.15s ease;
    white-space: nowrap;
    flex-shrink: 0;
}

.hwh-editor-add-tab:hover {
    background: rgba(46, 204, 113, 0.2);
    color: #4ade80;
}

/* ============================================
   MOVE TO TAB DROPDOWN
   ============================================ */
.hwh-move-to-tab-dropdown {
    position: fixed;
    background: linear-gradient(180deg, #342111 0%, #1d140d 100%);
    border: 2px solid #8b6914;
    border-radius: 6px;
    padding: 4px;
    z-index: 1000000;
    min-width: 120px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
}

.hwh-move-to-tab-option {
    padding: 8px 12px;
    color: #ccc;
    font-size: 12px;
    cursor: pointer;
    border-radius: 4px;
    transition: all 0.1s;
}

.hwh-move-to-tab-option:hover {
    background: rgba(139, 105, 20, 0.5);
    color: #ffd700;
}

/* ============================================
   DUPLICATE BUTTON
   ============================================ */
.hwh-editor-btn-duplicate {
    background: rgba(52, 152, 219, 0.3) !important;
    border-color: rgba(52, 152, 219, 0.5) !important;
}

.hwh-editor-btn-duplicate:hover {
    background: rgba(52, 152, 219, 0.5) !important;
}
`;
            const style = document.createElement('style');
            style.id = 'hwh-compact-sidebar-styles';
            style.textContent = `
.hwh-compact-sidebar {
    position: fixed;
    top: 50px;
    left: 0;
    width: 280px;
    height: auto;                        /* ‚Üê NEW: shrink to content */
    max-height: calc(100vh - 70px);      /* ‚Üê NEW: stop at window bottom */
    background: linear-gradient(180deg, #342111 0%, #1d140d 100%);
                border-radius: 0 12px 12px 0;
                border: 3px solid #8b6914;
                border-left: none;
                box-shadow: 4px 0 10px rgba(0, 0, 0, 0.5);
                z-index: 999998;
                display: flex;
                flex-direction: column;
                font-family: Arial, sans-serif;
                overflow: visible !important;
                transition: left 0.3s ease-in-out;
            }

            .hwh-compact-sidebar .resize-handle {
                position: absolute;
                right: 0;
                top: 0;
                width: 8px;
                height: 100%;
                cursor: ew-resize;
                background: transparent;
                z-index: 10;
            }

            .hwh-compact-sidebar .resize-handle:hover {
                background: rgba(255, 215, 0, 0.2);
            }

.hwh-compact-sidebar .toggle-btn {
                position: absolute;
                right: -30px;
                top: 50%;
                transform: translateY(-50%);
                width: 30px;
                height: 50px;
                background: linear-gradient(135deg, #8b6914 0%, #6d5210 100%);
                border: 2px solid #8b6914;
                border-left: none;
                border-radius: 0 8px 8px 0;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                font-size: 16px;
                color: #ffd700;
                transition: all 0.2s ease;
                box-shadow: 2px 0 6px rgba(0,0,0,0.5);
                z-index: 999999 !important;
            }

            .hwh-compact-sidebar .toggle-btn:hover {
                background: linear-gradient(135deg, #a67c16 0%, #8b6914 100%);
                right: -32px;
            }

            .hwh-compact-sidebar.collapsed {
                left: calc(-100% - 3px);
            }

            .hwh-compact-sidebar.collapsed .toggle-btn {
                position: fixed;
                left: 0;
                right: auto;
            }

            .hwh-compact-header {
                background: transparent;
                padding: 8px 10px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                user-select: none;
                border-radius: 0;
                border-bottom: 1px solid rgba(0, 0, 0, 0.3);
            }

            .hwh-compact-title {
                color: #fff;
                font-size: 13px;
                font-weight: 700;
                text-shadow: 0px 1px 2px rgba(0, 0, 0, 0.8);
                margin: 0;
            }

            .hwh-compact-controls {
                display: flex;
                gap: 4px;
            }

            .hwh-compact-control-btn {
                width: 20px;
                height: 20px;
                border-radius: 3px;
                border: none;
                background: rgba(0, 0, 0, 0.3);
                color: #fff;
                font-size: 14px;
                font-weight: 700;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.15s;
                text-shadow: 0px 1px 1px rgba(0, 0, 0, 0.8);
            }

            .hwh-compact-control-btn:hover {
                background: rgba(0, 0, 0, 0.5);
                transform: scale(1.05);
            }

.hwh-compact-content {
    overflow-y: auto;
    overflow-x: hidden;
    padding: 4px;
    flex: 1 1 auto;      /* ‚Üê Changed: allows shrinking */
    min-height: 0;       /* ‚Üê NEW: required for flex overflow scrolling */
    scrollbar-width: thin;
    scrollbar-color: rgba(139, 105, 20, 0.6) rgba(0, 0, 0, 0.2);
}

/* Hide scrollbar for Chrome/Safari */
.hwh-compact-content::-webkit-scrollbar {
    width: 6px;
}

.hwh-compact-content::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
}

.hwh-compact-content::-webkit-scrollbar-thumb {
    background: rgba(139, 105, 20, 0.6);
    border-radius: 3px;
}

.hwh-compact-content::-webkit-scrollbar-thumb:hover {
    background: rgba(139, 105, 20, 0.8);
}
          
            .hwh-compact-sidebar.minimized .hwh-compact-content {
                display: none;
            }

            .hwh-compact-btn-row {
                display: flex;
                gap: 3px;
                margin-bottom: 3px;
                width: 100%;
                transition: opacity 0.3s ease;
}

.hwh-row-name-label {
    user-select: none;
}



            /* ================================================================ */
            /* BUTTON STYLES - FLAT/MODERN (Default) */
            /* ================================================================ */

            .hwh-compact-btn-gap {
                position: relative;
                display: flex;
                flex-direction: column;
                border-radius: 5px;
                cursor: pointer;
                flex: 1;
                padding: 0px 1px 3px 1px;
                gap: 1px;
                transition: all 0.1s ease;
                --h: 36;
                --s: 60%;
                --l: 10%;
                --pl: 50%;
                --pcl: 90%;
                --phl: 55%;
                --pal: 34%;
                --pacl: 71%;
                --sc: hsl(36, 88%, 7%);
                background: hsl(var(--h), var(--s), var(--l));
                box-shadow:
                    0px 0px 2px 0px var(--sc),
                    0px -1px 2px 0px var(--sc),
                    0px 1px 1px 0px hsl(var(--h), var(--s), 12%);
            }

            .hwh-compact-btn-gap:first-child { padding-left: 2px; }
            .hwh-compact-btn-gap:last-child { padding-right: 2px; }

            .hwh-compact-btn-plate {
                display: flex;
                height: 32px;
                padding: 0 8px;
                box-sizing: border-box;
                justify-content: center;
                align-items: center;
                border-radius: 4px;
                transition: all 0.1s ease;
                text-shadow: 0px 1px 0px rgba(0, 0, 0, 0.92);
                font-family: Arial, sans-serif;
                font-size: 14px;
                font-weight: 700;
                white-space: nowrap;
                color: hsla(var(--h), var(--s), var(--pcl), 1);
                background: hsla(var(--h), var(--s), var(--pl), 1);
                box-shadow:
                    0px 10px 12px 0px hsla(var(--h), 58%, 67%, 0.2) inset,
                    0px 2px 1px 0px hsl(var(--h), 78%, 77%) inset,
                    0px 2px 0px 0px hsl(var(--h), 78%, 37%) inset,
                    -8px 3px 15px 0px hsl(var(--h), 94%, 15%) inset,
                    8px -7px 15px 0px hsla(var(--h), 94%, 15%, 0.7) inset,
                    0px 0px 2px 0px hsl(var(--h), 68%, 23%),
                    0px -3px 8px 0px hsl(var(--h), 94%, 20%) inset;
            }

            .hwh-compact-btn-plate:hover {
                color: hsla(0, 0%, 96%, 1);
                background: hsla(var(--h), 49%, var(--phl), 1);
            }

            .hwh-compact-btn-gap:active {
                padding-top: 1px;
                padding-bottom: 2px;
            }

            .hwh-compact-btn-plate:active {
                color: hsla(var(--h), 47%, var(--pacl), 1);
                background: hsl(var(--h), 46%, var(--pal));
            }

            /* Color variants for FLAT style */
            .hwh-compact-btn-gap.green { --h: 120; }
            .hwh-compact-btn-gap.blue { --h: 207; }
            .hwh-compact-btn-gap.red { --h: 0; }
            .hwh-compact-btn-gap.violet { --h: 272; }
            .hwh-compact-btn-gap.orange { --h: 20; }
            .hwh-compact-btn-gap.yellow { --h: 45; }
            .hwh-compact-btn-gap.graphite {
                background: hsl(0, 0%, 12%);
                box-shadow:
                    0px 0px 2px 0px hsl(0, 0%, 7%),
                    0px -1px 2px 0px hsl(0, 0%, 7%),
                    0px 1px 1px 0px hsl(0, 0%, 12%);
            }
            .hwh-compact-btn-gap.graphite .hwh-compact-btn-plate {
                color: hsla(0, 0%, 85%, 1);
                background: hsla(0, 0%, 54%, 1);
                box-shadow:
                    0px 10px 12px 0px hsla(0, 0%, 67%, 0.2) inset,
                    0px 2px 1px 0px hsl(0, 0%, 67%) inset,
                    -8px 3px 15px 0px hsla(0, 0%, 15%, 0.7) inset,
                    8px -7px 15px 0px hsla(0, 0%, 15%, 0.7) inset,
                    0px 0px 2px 0px hsla(0, 0%, 23%, 0.3),
                    0px -3px 8px 0px hsla(0, 0%, 20%, 0.7) inset;
            }
            .hwh-compact-btn-gap.pink { --h: 320; }
.hwh-compact-btn-gap.cyan { --h: 180; }
.hwh-compact-btn-gap.black {
    background: hsl(0, 0%, 5%);
    box-shadow:
        0px 0px 2px 0px hsl(0, 0%, 0%),
        0px -1px 2px 0px hsl(0, 0%, 0%),
        0px 1px 1px 0px hsl(0, 0%, 8%);
}
.hwh-compact-btn-gap.black .hwh-compact-btn-plate {
    color: hsla(0, 0%, 95%, 1);
    background: hsla(0, 0%, 15%, 1);
    box-shadow:
        0px 10px 12px 0px hsla(0, 0%, 20%, 0.2) inset,
        0px 2px 1px 0px hsl(0, 0%, 25%) inset,
        -8px 3px 15px 0px hsla(0, 0%, 5%, 0.7) inset,
        8px -7px 15px 0px hsla(0, 0%, 5%, 0.7) inset,
        0px 0px 2px 0px hsla(0, 0%, 10%, 0.3),
        0px -3px 8px 0px hsla(0, 0%, 8%, 0.7) inset;
}
.hwh-compact-btn-gap.lightgrey {
    background: hsl(0, 0%, 75%);
    box-shadow:
        0px 0px 2px 0px hsl(0, 0%, 60%),
        0px -1px 2px 0px hsl(0, 0%, 60%),
        0px 1px 1px 0px hsl(0, 0%, 80%);
}
.hwh-compact-btn-gap.lightgrey .hwh-compact-btn-plate {
    color: hsla(0, 0%, 10%, 1);
    background: hsla(0, 0%, 90%, 1);
    box-shadow:
        0px 10px 12px 0px hsla(0, 0%, 95%, 0.2) inset,
        0px 2px 1px 0px hsl(0, 0%, 95%) inset,
        -8px 3px 15px 0px hsla(0, 0%, 70%, 0.4) inset,
        8px -7px 15px 0px hsla(0, 0%, 70%, 0.4) inset,
        0px 0px 2px 0px hsla(0, 0%, 60%, 0.3),
        0px -3px 8px 0px hsla(0, 0%, 75%, 0.5) inset;
}

            /* ================================================================ */
            /* BUTTON STYLES - GAME (Flat with yellow text) */
            /* ================================================================ */

            .hwh-compact-sidebar.style-game {
               background: linear-gradient(180deg, #342111 0%, #1d140d 100%);
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-gap {
                padding: 1px;
                border-radius: 4px;
                background: transparent;
                border: none;
                box-shadow: none;
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-plate {
                height: 32px;
                border-radius: 4px;
                background: linear-gradient(135deg, #8b6914 0%, #6d5210 100%);
                border: 1px solid #a67c16;
                box-shadow: none;
                text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
                color: #ffd700;
                font-weight: bold;
                font-size: 14px;
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-plate:hover {
                background: linear-gradient(135deg, #a67c16 0%, #8b6914 100%);
                transform: translateY(-1px);
                box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-gap:active {
                padding-top: 2px;
                padding-bottom: 1px;
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-plate:active {
                transform: translateY(0);
            }

            /* Game style color variants */
            .hwh-compact-sidebar.style-game .hwh-compact-btn-gap.green .hwh-compact-btn-plate {
                background: linear-gradient(135deg, #4ae29a 0%, #2d8f5f 100%);
                border-color: #5ef3a8;
                color: #ffd700;
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-gap.green .hwh-compact-btn-plate:hover {
                background: linear-gradient(135deg, #5ef3a8 0%, #4ae29a 100%);
                transform: translateY(-1px);
                box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-gap.red .hwh-compact-btn-plate {
                background: linear-gradient(180deg, rgba(166, 56, 56, 0.9) 0%, rgba(115, 40, 40, 0.9) 100%);
                border-color: rgba(217, 77, 77, 0.4);
                color: #ffd700;
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-gap.red .hwh-compact-btn-plate:hover {
                background: linear-gradient(180deg, rgba(184, 64, 64, 0.95) 0%, rgba(133, 48, 48, 0.95) 100%);
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-gap.blue .hwh-compact-btn-plate {
                background: linear-gradient(180deg, rgba(66, 120, 166, 0.9) 0%, rgba(45, 82, 115, 0.9) 100%);
                border-color: rgba(90, 158, 217, 0.4);
                color: #ffd700;
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-gap.blue .hwh-compact-btn-plate:hover {
                background: linear-gradient(180deg, rgba(82, 138, 184, 0.95) 0%, rgba(57, 98, 133, 0.95) 100%);
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-gap.violet .hwh-compact-btn-plate {
                background: linear-gradient(180deg, rgba(117, 66, 166, 0.9) 0%, rgba(82, 45, 115, 0.9) 100%);
                border-color: rgba(157, 90, 217, 0.4);
                color: #ffd700;
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-gap.violet .hwh-compact-btn-plate:hover {
                background: linear-gradient(180deg, rgba(138, 82, 184, 0.95) 0%, rgba(98, 57, 133, 0.95) 100%);
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-gap.orange .hwh-compact-btn-plate {
                background: linear-gradient(135deg, #d87e20 0%, #b85f10 100%);
                border-color: #e89030;
                color: #ffd700;
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-gap.orange .hwh-compact-btn-plate:hover {
                background: linear-gradient(135deg, #e89030 0%, #d87e20 100%);
                transform: translateY(-1px);
                box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-gap.yellow .hwh-compact-btn-plate {
                background: linear-gradient(135deg, #d4a220 0%, #b88610 100%);
                border-color: #e4b230;
                color: #ffd700;
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-gap.yellow .hwh-compact-btn-plate:hover {
                background: linear-gradient(135deg, #e4b230 0%, #d4a220 100%);
                transform: translateY(-1px);
                box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-gap.graphite .hwh-compact-btn-plate {
                background: linear-gradient(135deg, #6a6a6a 0%, #4a4a4a 100%);
                border-color: #7a7a7a;
                color: #ffd700;
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-gap.graphite .hwh-compact-btn-plate:hover {
                background: linear-gradient(135deg, #7a7a7a 0%, #6a6a6a 100%);
                transform: translateY(-1px);
                box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
            }

            .hwh-compact-sidebar.style-game .hwh-compact-btn-gap.pink .hwh-compact-btn-plate {
    background: linear-gradient(135deg, #e91e8c 0%, #b8156e 100%);
    border-color: #ff3399;
    color: #ffd700;
}

.hwh-compact-sidebar.style-game .hwh-compact-btn-gap.pink .hwh-compact-btn-plate:hover {
    background: linear-gradient(135deg, #ff3399 0%, #e91e8c 100%);
    transform: translateY(-1px);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
}

.hwh-compact-sidebar.style-game .hwh-compact-btn-gap.cyan .hwh-compact-btn-plate {
    background: linear-gradient(135deg, #00d9ff 0%, #00a8cc 100%);
    border-color: #00f0ff;
    color: #ffd700;
}

.hwh-compact-sidebar.style-game .hwh-compact-btn-gap.cyan .hwh-compact-btn-plate:hover {
    background: linear-gradient(135deg, #00f0ff 0%, #00d9ff 100%);
    transform: translateY(-1px);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
}

.hwh-compact-sidebar.style-game .hwh-compact-btn-gap.black .hwh-compact-btn-plate {
    background: linear-gradient(135deg, #2a2a2a 0%, #0a0a0a 100%);
    border-color: #3a3a3a;
    color: #ffd700;
}

.hwh-compact-sidebar.style-game .hwh-compact-btn-gap.black .hwh-compact-btn-plate:hover {
    background: linear-gradient(135deg, #3a3a3a 0%, #2a2a2a 100%);
    transform: translateY(-1px);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.5);
}

.hwh-compact-sidebar.style-game .hwh-compact-btn-gap.lightgrey .hwh-compact-btn-plate {
    background: linear-gradient(135deg, #e8e8e8 0%, #c8c8c8 100%);
    border-color: #f0f0f0;
    color: #ffd700;
}

.hwh-compact-sidebar.style-game .hwh-compact-btn-gap.lightgrey .hwh-compact-btn-plate:hover {
    background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
    transform: translateY(-1px);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
}

            /* ================================================================ */
            /* UNIFIED EDITOR - BASE */
            /* ================================================================ */

            .hwh-unified-editor {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 900px;
                max-width: 95vw;
                height: 700px;
                max-height: 90vh;
                background: linear-gradient(180deg, #342111 0%, #1d140d 100%);
                border: 3px solid #8b6914;
                border-radius: 12px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
                z-index: 1000000;
                display: flex;
                flex-direction: column;
            }
            .hwh-unified-editor * {
    color: inherit;
}

.hwh-unified-editor {
    color: #fff;
}

.hwh-editor-header,
.hwh-unified-tabs,
.hwh-tab-content,
.hwh-editor-footer {
    color: #fff;
}

.hwh-editor-select,
.hwh-editor-search {
    color: #fff !important;
}

.hwh-editor-select option {
    background: #2c3e50;
    color: #fff;
}

.hwh-func-edit-field input,
.hwh-func-edit-field select,
.hwh-func-edit-field textarea {
    color: #fff !important;
}

            .hwh-editor-header {
                padding: 15px 20px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 12px 12px 0 0;
                border-bottom: 2px solid rgba(255, 255, 255, 0.1);
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .hwh-editor-title {
                font-size: 18px;
                font-weight: 700;
                color: #fff;
            }

            .hwh-unified-tabs {
                display: flex;
                gap: 0;
                background: rgba(0,0,0,0.3);
                border-bottom: 2px solid #8b6914;
            }

            .hwh-tab-btn {
                flex: 1;
                padding: 12px;
                background: transparent;
                border: none;
                color: #999;
                cursor: pointer;
                font-size: 13px;
                font-weight: 600;
                transition: all 0.2s;
                border-bottom: 3px solid transparent;
            }

            .hwh-tab-btn:hover {
                background: rgba(255,255,255,0.05);
                color: #ccc;
            }

            .hwh-tab-btn.active {
                color: #ffd700;
                background: rgba(255,215,0,0.1);
                border-bottom-color: #ffd700;
            }

            .hwh-unified-content {
                flex: 1;
                overflow: hidden;
                position: relative;
            }

            .hwh-tab-content {
                display: none;
                height: 100%;
                flex-direction: column;
            }

            .hwh-tab-content.active {
                display: flex;
            }

.hwh-tab-scroll {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
}

            .hwh-editor-footer {
                padding: 15px 20px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 0 0 12px 12px;
                border-top: 2px solid rgba(255, 255, 255, 0.1);
                display: flex;
                justify-content: space-between;
                gap: 10px;
            }

.hwh-editor-btn-large {
    padding: 10px 20px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 700;
    transition: all 0.2s;
    background: #3498db;  /* Default blue */
    color: white;
}

.hwh-editor-btn-large:hover {
    background: #2980b9;
    transform: scale(1.02);
}

            .hwh-editor-btn-save {
                background: #2ecc71;
                color: white;
                flex: 1;
            }

            .hwh-editor-btn-save:hover {
                background: #27ae60;
                transform: scale(1.02);
            }

            .hwh-editor-btn-cancel {
                background: #95a5a6;
                color: white;
            }

            .hwh-editor-btn-cancel:hover {
                background: #7f8c8d;
            }

            .hwh-editor-btn-import {
                background: #9b59b6;
                color: white;
            }

            .hwh-editor-btn-import:hover {
                background: #8e44ad;
            }

            .hwh-editor-btn-export {
                background: #16a085;
                color: white;
            }

            .hwh-editor-btn-export:hover {
                background: #1abc9c;
            }

            /* ================================================================ */
            /* LAYOUT TAB */
            /* ================================================================ */

.hwh-editor-row {
    background: rgba(0,0,0,0.2);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 4px;
    padding: 6px 8px;
    margin-bottom: 6px;
}
.hwh-editor-row-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 4px;
}

.hwh-row-number {
    color: #ffd700;
    font-weight: bold;
    font-size: 11px;
}

            .hwh-editor-row-controls {
                display: flex;
                gap: 4px;
            }

.hwh-editor-row-buttons {
    display: flex;
    gap: 4px;
    align-items: center;
    flex-wrap: wrap;
}

            .hwh-editor-button-slot {
                flex: 1;
                min-width: 150px;
            }

.hwh-editor-select {
    width: 100%;
    padding: 5px 8px;
    background: rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 4px;
    color: #fff;
    font-size: 12px;
    cursor: pointer;
}

            .hwh-editor-select:focus {
                outline: none;
                border-color: #ffd700;
            }

            .hwh-editor-button-controls {
                display: flex;
                gap: 4px;
            }

            .hwh-empty-state {
                text-align: center;
                padding: 40px;
                color: #999;
                font-size: 14px;
            }

            /* ================================================================ */
            /* FUNCTIONS TAB */
            /* ================================================================ */

            .hwh-func-item {
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid rgba(255, 255, 255, 0.15);
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 12px;
                transition: all 0.2s;
            }

            .hwh-func-item:hover {
                background: rgba(255, 255, 255, 0.08);
                border-color: rgba(255, 215, 0, 0.3);
            }

            .hwh-func-item-custom {
                border-left: 4px solid #2ecc71;
            }

            .hwh-func-item-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
            }

            .hwh-func-item-name {
                font-size: 16px;
                font-weight: 700;
                color: #ffd700;
            }

            .hwh-func-item-buttons {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .hwh-func-badge {
                background: rgba(52, 152, 219, 0.3);
                color: #3498db;
                padding: 4px 10px;
                border-radius: 12px;
                font-size: 10px;
                font-weight: 600;
                text-transform: uppercase;
            }

            .hwh-func-badge-custom {
                background: rgba(46, 204, 113, 0.3);
                color: #2ecc71;
            }

            .hwh-func-item-desc {
                color: #ccc;
                font-size: 14px;
                margin-bottom: 8px;
                line-height: 1.4;
            }

            .hwh-func-item-meta {
                display: flex;
                gap: 20px;
                color: #999;
                font-size: 12px;
            }

            .hwh-func-item-meta-item {
                display: flex;
                align-items: center;
                gap: 5px;
            }

            .hwh-func-icon-preview {
                font-size: 18px;
            }

            .hwh-func-color-preview {
                display: inline-block;
                width: 20px;
                height: 20px;
                border-radius: 4px;
                border: 1px solid rgba(255, 255, 255, 0.3);
            }

            .hwh-func-stats {
                padding: 0;
                margin-bottom: 15px;
            }

            /* Function Detail Editor */
            .hwh-func-detail-editor {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 700px;
                max-width: 90vw;
                max-height: 90vh;
                background: linear-gradient(180deg, #2c3e50 0%, #34495e 100%);
                border: 3px solid #3498db;
                border-radius: 12px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
                z-index: 1000001;
                display: flex;
                flex-direction: column;
            }

            .hwh-func-detail-content {
                padding: 20px;
                overflow-y: auto;
                flex: 1;
            }

            .hwh-func-detail-content label {
                display: block;
                color: #3498db;
                font-weight: 600;
                font-size: 13px;
                margin-bottom: 6px;
                margin-top: 15px;
            }

            .hwh-func-detail-content label:first-child {
                margin-top: 0;
            }

            .hwh-func-detail-content input[type="text"],
            .hwh-func-detail-content select,
            .hwh-func-detail-content textarea {
                width: 100%;
                padding: 10px;
                background: rgba(0, 0, 0, 0.4);
                border: 2px solid rgba(255, 255, 255, 0.2);
                border-radius: 6px;
                color: #fff;
                font-size: 14px;
                font-family: 'Courier New', monospace;
                box-sizing: border-box;
            }

            .hwh-func-detail-content input:focus,
            .hwh-func-detail-content select:focus,
            .hwh-func-detail-content textarea:focus {
                outline: none;
                border-color: #3498db;
                background: rgba(0, 0, 0, 0.6);
            }

            .hwh-func-detail-content textarea {
                resize: vertical;
                min-height: 150px;
                font-family: 'Courier New', Consolas, monospace;
                line-height: 1.5;
            }

            .hwh-func-action-container {
                position: relative;
            }

            .hwh-func-lock-overlay {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 6px;
                cursor: not-allowed;
            }

            .hwh-func-lock-btn {
                padding: 10px 20px;
                background: #e67e22;
                color: white;
                border: none;
                border-radius: 6px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .hwh-func-lock-btn:hover {
                background: #d35400;
                transform: scale(1.05);
            }

            .hwh-func-unlock-btn {
                background: #2ecc71;
            }

            .hwh-func-unlock-btn:hover {
                background: #27ae60;
            }

            .hwh-func-help {
                background: rgba(52, 152, 219, 0.2);
                border-left: 4px solid #3498db;
                padding: 12px;
                border-radius: 4px;
                margin-top: 15px;
                color: #ccc;
                font-size: 13px;
            }

            .hwh-func-help code {
                background: rgba(0, 0, 0, 0.4);
                padding: 2px 6px;
                border-radius: 3px;
                color: #3498db;
                font-family: 'Courier New', monospace;
            }

            .hwh-func-warning {
                background: rgba(230, 126, 34, 0.2);
                border-left: 4px solid #e67e22;
                padding: 12px;
                border-radius: 4px;
                margin-top: 10px;
                color: #f39c12;
                font-size: 13px;
                font-weight: 600;
            }

            /* Color preview swatches */
            .hwh-color-swatch-green { background: #2ecc71; }
            .hwh-color-swatch-blue { background: #3498db; }
            .hwh-color-swatch-orange { background: #e67e22; }
            .hwh-color-swatch-red { background: #e74c3c; }
            .hwh-color-swatch-violet { background: #9b59b6; }
            .hwh-color-swatch-yellow { background: #f1c40f; }
            .hwh-color-swatch-graphite { background: #7f8c8d; }
            .hwh-color-swatch-pink { background: #e91e8c; }
.hwh-color-swatch-cyan { background: #00d9ff; }
.hwh-color-swatch-black { background: #1a1a1a; }
.hwh-color-swatch-lightgrey { background: #d0d0d0; }

            /* ================================================================ */
            /* STYLE TAB */
            /* ================================================================ */

            .hwh-style-section {
                margin-bottom: 25px;
            }

            .hwh-style-section h3 {
                color: #ffd700;
                margin: 0 0 15px 0;
                font-size: 16px;
            }

            .hwh-style-current {
                padding: 15px;
                background: rgba(255,215,0,0.1);
                border: 2px solid #ffd700;
                border-radius: 6px;
                color: #ffd700;
                font-size: 14px;
            }

            .hwh-style-options {
                display: flex;
                gap: 15px;
            }

            .hwh-style-option {
                flex: 1;
                padding: 15px;
                background: rgba(0,0,0,0.2);
                border: 2px solid rgba(255,255,255,0.1);
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.2s;
            }

            .hwh-style-option:hover {
                border-color: rgba(255,255,255,0.3);
                transform: translateY(-2px);
            }

            .hwh-style-option.active {
                border-color: #ffd700;
                background: rgba(255,215,0,0.1);
            }

            .hwh-style-option-preview {
                height: 80px;
                display: flex;
                align-items: center;
                justify-content: center;
                margin-bottom: 10px;
                border-radius: 4px;
            }

.hwh-style-flat-preview {
    background: linear-gradient(180deg, #342111 0%, #1d140d 100%);
    border: 2px solid #8b6914;
}

.hwh-style-game-preview {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

            .hwh-style-option-preview .sample-btn {
                padding: 8px 16px;
                background: rgba(255,255,255,0.2);
                border-radius: 4px;
                color: #fff;
                font-size: 12px;
                font-weight: 600;
            }

            .hwh-style-option-name {
                color: #ffd700;
                font-weight: bold;
                margin-bottom: 5px;
            }

            .hwh-style-option-desc {
                color: #999;
                font-size: 11px;
            }

            /* ================================================================ */
            /* IMPORT/EXPORT TAB */
            /* ================================================================ */

            .hwh-import-export-content {
                max-width: 600px;
                margin: 0 auto;
            }

            .hwh-ie-section {
                margin-bottom: 30px;
                padding: 20px;
                background: rgba(0,0,0,0.2);
                border-radius: 8px;
            }

            .hwh-ie-section h3 {
                color: #ffd700;
                margin: 0 0 10px 0;
                font-size: 16px;
            }

            .hwh-ie-section p {
                color: #ccc;
                font-size: 13px;
                margin: 0 0 15px 0;
            }

            .hwh-ie-buttons {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
            }

            .hwh-btn-danger {
                background: linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%) !important;
                border-color: #ff6b6b !important;
            }

            .hwh-btn-danger:hover {
                background: linear-gradient(135deg, #ff8787 0%, #ff6b6b 100%) !important;
            }

            /* ================================================================ */
            /* TOOLBAR (Search & Buttons) */
            /* ================================================================ */

.hwh-editor-toolbar {
    display: flex;
    gap: 10px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.3);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    align-items: center;
}

.hwh-editor-search {
    flex: 1;
    padding: 6px 10px;
    background: rgba(0, 0, 0, 0.4);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    color: #fff;
    font-size: 13px;
}

.hwh-editor-search:focus {
    outline: none;
    border-color: #ffd700;
    box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
}

.hwh-editor-search:not(:placeholder-shown) {
    border-color: #4CAF50;
}

            .hwh-editor-btn-clear {
                padding: 8px 12px;
                background: rgba(231, 76, 60, 0.3);
                border: 1px solid #e74c3c;
                border-radius: 6px;
                color: #fff;
                cursor: pointer;
                font-weight: 600;
                display: none;
            }

.hwh-editor-btn-small {
    padding: 6px 12px;
    background: #2ecc71;
    border: none;
    border-radius: 4px;
    color: white;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    font-size: 13px;
}

            .hwh-editor-btn-small:hover {
                background: #27ae60;
                transform: translateY(-1px);
            }

.hwh-editor-btn-tiny {
    padding: 3px 6px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 3px;
    color: #fff;
    cursor: pointer;
    font-size: 11px;
    transition: all 0.2s;
    min-width: 24px;
}

            .hwh-editor-btn-tiny:hover {
                background: rgba(255, 255, 255, 0.2);
                transform: scale(1.05);
            }
 /* ==== COMPACT FUNCTION LIST STYLES ==== */
.hwh-func-item-compact {
    padding: 8px 12px !important;
    margin-bottom: 4px !important;
    border-radius: 6px;
}

.hwh-func-item-header-compact {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 4px;
}

.hwh-func-fav-btn {
    background: none;
    border: none;
    font-size: 18px;
    cursor: pointer;
    padding: 0;
    line-height: 1;
    opacity: 0.5;
    transition: opacity 0.2s, transform 0.2s;
}

.hwh-func-fav-btn:hover {
    opacity: 1;
    transform: scale(1.2);
}

.hwh-func-item-favorite {
    background: rgba(255, 215, 0, 0.1) !important;
    border-left: 3px solid gold !important;
}

.hwh-func-item-name-compact {
    flex: 1;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 6px;
}

.hwh-func-item-meta-inline {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-right: 8px;
}

.hwh-func-item-buttons-compact {
    display: flex;
    gap: 4px;
}

.hwh-func-btn-icon {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    padding: 4px 8px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s;
}

.hwh-func-btn-icon:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: scale(1.05);
}

.hwh-func-item-desc-compact {
    font-size: 12px;
    color: rgba(255, 255, 255, 0.7);
    margin-left: 32px;
    font-style: italic;
}

.hwh-func-badge-compact {
    font-size: 11px;
    padding: 2px 6px;
    border-radius: 3px;
}

.hwh-func-color-none,
.hwh-func-icon-none {
    color: #666;
    font-size: 12px;
}

.hwh-func-stats-compact {
    display: flex;
    gap: 15px;
    justify-content: center;
    padding: 10px;
    background: rgba(0,0,0,0.3);
    border-radius: 6px;
    margin-bottom: 8px;
    font-size: 13px;
    flex-wrap: wrap;
}

.hwh-func-stats-compact span {
    color: #fff;
}

.hwh-func-stats-compact strong {
    color: #3498db;
    margin-left: 4px;
}

/* ==== FAVORITES SECTION IN LAYOUT TAB ==== */
.hwh-layout-favorites-section {
    background: rgba(255, 215, 0, 0.08);
    border: 2px dashed rgba(255, 215, 0, 0.3);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 16px;
}

.hwh-layout-section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    font-weight: 600;
    color: gold;
}

.hwh-layout-section-header small {
    font-size: 11px;
    color: rgba(255, 215, 0, 0.7);
    font-weight: normal;
}

.hwh-layout-favorites-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
}

.hwh-layout-fav-chip {
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 13px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    cursor: default;
    transition: all 0.2s;
    user-select: none;
}

.hwh-layout-fav-chip:hover {
    transform: translateY(-2px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

/* ==== FUNCTION EDIT DIALOG STYLES ==== */
.hwh-func-edit-dialog {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 100000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.hwh-func-edit-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(4px);
}

.hwh-func-edit-content {
    position: relative;
    background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
    border: 2px solid rgba(52, 152, 219, 0.5);
    border-radius: 12px;
    width: 90%;
    max-width: 700px;
    max-height: 90vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5);
}

.hwh-func-edit-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 20px;
    border-bottom: 2px solid rgba(255, 255, 255, 0.1);
}

.hwh-func-edit-header h3 {
    margin: 0;
    color: #3498db;
    font-size: 18px;
}

.hwh-func-edit-close {
    background: none;
    border: none;
    color: #fff;
    font-size: 24px;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: background 0.2s;
}

.hwh-func-edit-close:hover {
    background: rgba(255, 255, 255, 0.1);
}

.hwh-func-edit-body {
    padding: 20px;
    overflow-y: auto;
    flex: 1;
}

.hwh-func-edit-field {
    margin-bottom: 16px;
}

.hwh-func-edit-field label {
    display: block;
    margin-bottom: 6px;
    color: #fff;
    font-weight: 500;
    font-size: 14px;
}

.hwh-func-edit-field input,
.hwh-func-edit-field select,
.hwh-func-edit-field textarea {
    width: 100%;
    padding: 10px;
    background: rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    color: #fff;
    font-size: 14px;
    font-family: 'Consolas', 'Monaco', monospace;
    box-sizing: border-box;
}

.hwh-func-edit-field textarea {
    resize: vertical;
    min-height: 200px;
}

.hwh-func-edit-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
}

.hwh-func-edit-notice {
    background: rgba(52, 152, 219, 0.15);
    border-left: 3px solid #3498db;
    padding: 12px;
    border-radius: 4px;
    color: #fff;
    font-size: 13px;
    line-height: 1.5;
    margin-bottom: 16px;
}

.hwh-func-edit-footer {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    padding: 16px 20px;
    border-top: 2px solid rgba(255, 255, 255, 0.1);
}

/* ==== ENHANCED STYLE TOGGLE VISUAL FEEDBACK ==== */
.hwh-style-option {
    transition: all 0.3s ease;
    cursor: pointer;
    position: relative;
}

.hwh-style-option.active {
    transform: scale(1.05);
    box-shadow: 0 0 20px rgba(52, 152, 219, 0.5);
}

.hwh-style-option.active::before {
    content: '‚úî';
    position: absolute;
    top: 10px;
    right: 10px;
    background: #2ecc71;
    color: white;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 16px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    z-index: 1;
}

.hwh-style-option:hover:not(.active) {
    transform: translateY(-4px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
.hwh-editor-btn-test {
    background: #f39c12;
    color: white;
}

.hwh-editor-btn-test:hover {
    background: #e67e22;
    transform: scale(1.02);
}

#hwh-test-return-overlay {
    animation: slideIn 0.3s ease-out;
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.hwh-func-edit-dialog {
    z-index: 2147483647 !important;
    position: fixed !important;
    display: flex !important;
}

.hwh-func-edit-content {
    z-index: 2147483647 !important;
    position: relative !important;
}

.hwh-func-edit-overlay {
    z-index: 2147483646 !important;
}

/* Make sure nothing blocks the dialog
body > * {
    position: relative;
} */

.hwh-unified-editor {
    z-index: 1000000 !important;
}

/* Edit button in layout */
.hwh-editor-btn-tiny {
    min-width: 28px;
    height: 28px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}
.hwh-compact-btn-gap.test-active {
    box-shadow: 0 0 8px 2px #ffd700 !important;
    border: 2px solid #ffd700 !important;
    transform: scale(1.05);
}

.hwh-compact-btn-gap.test-inactive {
    opacity: 0.6;
}
        ` + TAB_STYLES;
            document.head.appendChild(style);
        }

        // ================================================================
        // COMPACT SIDEBAR CLASS
        // ================================================================

        class CompactSidebar {
            constructor() {
                this.sidebar = null;
                this.content = null;
                this.tabs = this.loadTabs();
                this.activeTabIndex = this.loadActiveTab();
                this.style = this.loadStyle();
            }

            // Load tabs from storage, with migration from old layout format
            loadTabs() {
                try {
                    const savedTabs = GM_getValue('hwh_sidebar_tabs');
                    if (savedTabs) {
                        const parsed = JSON.parse(savedTabs);
                        if (Array.isArray(parsed) && parsed.length > 0 && parsed[0].name !== undefined) {
                            debugLog('‚úÖ Loaded tabs structure:', parsed.length, 'tabs');
                            return parsed;
                        }
                    }

                    // Try to migrate from old layout format
                    const oldLayout = GM_getValue('hwh_sidebar_layout');
                    if (oldLayout) {
                        const parsed = JSON.parse(oldLayout);
                        if (Array.isArray(parsed) && parsed.length > 0) {
                            debugLog('üîÑ Migrating old layout to tabs format');
                            return [{
                                name: 'Main',
                                rows: parsed
                            }];
                        }
                    }

                    return JSON.parse(JSON.stringify(DEFAULT_TABS));
                } catch (e) {
                    console.warn('Failed to load tabs, using default:', e);
                    return JSON.parse(JSON.stringify(DEFAULT_TABS));
                }
            }

            loadActiveTab() {
                try {
                    const saved = GM_getValue('hwh_sidebar_active_tab', 0);
                    return parseInt(saved) || 0;
                } catch (e) {
                    return 0;
                }
            }

            loadStyle() {
                try {
                    return GM_getValue('hwh_sidebar_style', 'flat');
                } catch (e) {
                    return 'flat';
                }
            }

            saveTabs() {
                try {
                    GM_setValue('hwh_sidebar_tabs', JSON.stringify(this.tabs));
                    debugLog('üíæ Tabs saved');
                } catch (e) {
                    console.error('Failed to save tabs:', e);
                }
            }

            saveActiveTab() {
                try {
                    GM_setValue('hwh_sidebar_active_tab', this.activeTabIndex);
                } catch (e) {
                    console.error('Failed to save active tab:', e);
                }
            }

            saveStyle() {
                try {
                    GM_setValue('hwh_sidebar_style', this.style);
                    debugLog('‚úÖ Style saved:', this.style);
                } catch (e) {
                    console.error('Failed to save style:', e);
                }
            }

            // For backward compatibility - returns current tab's rows as flat layout
            get layout() {
                if (!this.tabs || this.tabs.length === 0) return [];
                const currentTab = this.tabs[this.activeTabIndex] || this.tabs[0];
                return currentTab.rows || [];
            }

            set layout(value) {
                if (!this.tabs || this.tabs.length === 0) {
                    this.tabs = [{ name: 'Main', rows: value }];
                } else {
                    this.tabs[this.activeTabIndex].rows = value;
                }
            }

            saveLayout() {
                this.saveTabs();
            }

            toggleStyle() {
                this.style = this.style === 'flat' ? 'game' : 'flat';
                this.saveStyle();
                this.applyStyle();
                debugLog('üé® Style changed to:', this.style);
            }

            applyStyle() {
                this.sidebar.classList.remove('style-game', 'style-flat');
                if (this.style === 'game') {
                    this.sidebar.classList.add('style-flat');
                } else {
                    this.sidebar.classList.add('style-game');
                }
                debugLog('üé® Applied style:', this.style);
            }

            init() {
                const existing = document.getElementById('hwh-compact-sidebar');
                if (existing) existing.remove();

                this.sidebar = document.createElement('div');
                this.sidebar.id = 'hwh-compact-sidebar';
                this.sidebar.className = 'hwh-compact-sidebar';

                this.applyStyle();

                const savedWidth = localStorage.getItem('hwh_sidebar_width');
                if (savedWidth) {
                    this.sidebar.style.width = savedWidth + 'px';
                }

                // Header
                const header = document.createElement('div');
                header.className = 'hwh-compact-header';

                const title = document.createElement('div');
                title.className = 'hwh-compact-title';
                title.textContent = 'HWH Tweaker';

                const controls = document.createElement('div');
                controls.className = 'hwh-compact-controls';

                const showHiddenBtn = document.createElement('button');
                showHiddenBtn.className = 'hwh-compact-control-btn';
                showHiddenBtn.textContent = '‚òë';
                showHiddenBtn.title = 'Show/Hide Rows';
                showHiddenBtn.onclick = () => this.showHiddenRowsMenu();

                const editBtn = document.createElement('button');
                editBtn.className = 'hwh-compact-control-btn';
                editBtn.textContent = '‚úé';
                editBtn.title = 'Edit Menu';
                editBtn.onclick = () => this.openEditor();

                controls.appendChild(showHiddenBtn);
                controls.appendChild(editBtn);

                header.appendChild(title);
                header.appendChild(controls);

                // Toggle button
                const toggleBtn = document.createElement('div');
                toggleBtn.className = 'toggle-btn';
                toggleBtn.title = 'Toggle Sidebar';
                toggleBtn.onclick = () => this.toggleCollapse();

                // Restore collapsed state
                const wasCollapsed = localStorage.getItem('hwh_sidebar_collapsed') === 'true';
                if (wasCollapsed) {
                    this.sidebar.classList.add('collapsed');
                    toggleBtn.innerHTML = '‚ñ∂';
                } else {
                    toggleBtn.innerHTML = '‚óÄ';
                }

                // Resize handle
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle';

                // Tab bar
                this.tabBar = document.createElement('div');
                this.tabBar.className = 'hwh-tab-bar';

                // Content container
                this.content = document.createElement('div');
                this.content.className = 'hwh-compact-content';

                this.sidebar.appendChild(toggleBtn);
                this.sidebar.appendChild(resizeHandle);
                this.sidebar.appendChild(header);
                this.sidebar.appendChild(this.tabBar);
                this.sidebar.appendChild(this.content);
                document.body.appendChild(this.sidebar);

                this.setupResizing(resizeHandle);
                this.renderTabs();
                this.renderButtons();

                debugLog('‚úÖ Compact sidebar initialized with', this.tabs.length, 'tabs');
                DOMCache.clear('compactBtnPlates');
                return this;
            }

            renderTabs() {
                this.tabBar.innerHTML = '';
                if (this.tabs.length <= 1) {
                    this.tabBar.style.display = 'none';
                    return;
                }
                this.tabBar.style.display = 'flex';

                // Get saved tab font size
                const tabFontSize = localStorage.getItem('hwh_tab_font_size') || '10';

                this.tabs.forEach((tab, index) => {
                    const tabEl = document.createElement('div');
                    tabEl.className = 'hwh-tab' + (index === this.activeTabIndex ? ' active' : '');
                    tabEl.textContent = tab.name || `Tab ${index + 1}`;
                    tabEl.title = `${tab.rows?.length || 0} rows`;
                    tabEl.style.fontSize = tabFontSize + 'px';  // Apply saved font size
                    tabEl.onclick = () => {
                        this.activeTabIndex = index;
                        this.saveActiveTab();
                        this.renderTabs();
                        this.renderButtons();
                    };
                    this.tabBar.appendChild(tabEl);
                });
            }

            getNormalizedLayout() {
                const currentTab = this.tabs[this.activeTabIndex] || this.tabs[0];
                const rows = currentTab?.rows || [];
                return rows.map(row => {
                    if (typeof row === 'object' && row.buttons) {
                        return row.buttons;
                    }
                    return row;
                });
            }

            renderButtons() {
                this.content.innerHTML = '';

                // Clear tracked buttons - they're about to be recreated
                window._trackedButtons = { testBattle: {}, titanite: {} };

                const normalizedLayout = this.getNormalizedLayout();
                const currentTab = this.tabs[this.activeTabIndex] || this.tabs[0];
                const rows = currentTab?.rows || [];

                normalizedLayout.forEach((row, rowIndex) => {
                    const originalRow = rows[rowIndex];
                    const isHidden = (typeof originalRow === 'object' && originalRow.hidden);

                    if (isHidden) return;

                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'hwh-compact-btn-row';
                    rowDiv.style.position = 'relative';
                    rowDiv.style.paddingTop = '2px';

                    const btnContainer = document.createElement('div');
                    btnContainer.style.cssText = 'display: flex; gap: 3px; flex-wrap: nowrap; width: 100%; overflow-x: hidden;';

                    row.forEach(buttonData => {
                        const btnName = typeof buttonData === 'string' ? buttonData : buttonData.name;
                        const btnColor = typeof buttonData === 'string' ? '' : (buttonData.color || '');

                        const btnConfig = getButtonConfig(btnName);
                        if (!btnConfig) {
                            console.warn(`Button "${btnName}" not found in BUTTON_FUNCTIONS`);
                            return;
                        }

                        const btnGap = document.createElement('div');
                        btnGap.className = 'hwh-compact-btn-gap';

                        const finalColor = btnColor || btnConfig.color;
                        const cssColor = finalColor === 'purple' ? 'violet' : finalColor;
                        if (cssColor) btnGap.classList.add(cssColor);
                        if (finalColor) btnGap.classList.add(finalColor);

                        const btnPlate = document.createElement('div');
                        btnPlate.className = 'hwh-compact-btn-plate';

                        if (finalColor === 'custom' && btnConfig.customColor) {
                            btnPlate.style.background = btnConfig.customColor;
                        }

                        const displayText = btnConfig.icon || btnName;
                        btnPlate.textContent = displayText;

                        // Track test battle and titanite buttons for efficient updates
                        if (btnName.startsWith('Test') && btnName !== 'TestBattle') {
                            const val = parseInt(btnName.replace('Test', ''));
                            if (!isNaN(val)) {
                                window._trackedButtons.testBattle[val] = btnPlate;
                            }
                        } else if (btnName.startsWith('Titan')) {
                            const val = parseInt(btnName.replace('Titan', ''));
                            if (!isNaN(val)) {
                                window._trackedButtons.titanite[val] = btnPlate;
                            }
                        }

                        const perButtonSize = btnConfig.fontSize;
                        const globalFontSize = localStorage.getItem('hwh_global_font_size') || '14';
                        btnPlate.style.fontSize = (perButtonSize || globalFontSize) + 'px';

                        if (btnConfig.description) {
                            btnPlate.title = btnConfig.description;
                        }

                        btnGap.onclick = (e) => {
                            e.preventDefault();
                            if (btnConfig.action) {
                                try {
                                    btnConfig.action();
                                } catch (err) {
                                    console.error('Button action error:', err);
                                }
                            }
                        };

                        btnGap.appendChild(btnPlate);
                        btnContainer.appendChild(btnGap);
                    });

                    rowDiv.appendChild(btnContainer);
                    this.content.appendChild(rowDiv);
                });

                debugLog('üîÑ Buttons rendered for tab:', this.tabs[this.activeTabIndex]?.name);
                setTimeout(() => {
                    window.updateTestBattleHighlight && window.updateTestBattleHighlight();
                    window.updateTitaniteHighlight && window.updateTitaniteHighlight();
                }, 2000);
            }

            toggleRowVisibility(rowIndex) {
                const currentTab = this.tabs[this.activeTabIndex];
                if (!currentTab || !currentTab.rows) return;

                const row = currentTab.rows[rowIndex];
                if (typeof row !== 'object' || !row.buttons) {
                    currentTab.rows[rowIndex] = {
                        name: `Row ${rowIndex + 1}`,
                        hidden: true,
                        buttons: Array.isArray(row) ? row : []
                    };
                } else {
                    currentTab.rows[rowIndex].hidden = !currentTab.rows[rowIndex].hidden;
                }

                this.saveTabs();
                this.renderButtons();
            }

            showHiddenRowsMenu() {
                const currentTab = this.tabs[this.activeTabIndex];
                if (!currentTab || !currentTab.rows) return;

                const hasHidden = currentTab.rows.some(row => typeof row === 'object' && row.hidden);

                if (!hasHidden) {
                    alert('‚ÑπÔ∏è No hidden rows in this tab');
                    return;
                }

                const menu = document.createElement('div');
                menu.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #342111 0%, #1d140d 100%);
            border: 3px solid #8b6914;
            border-radius: 12px;
            padding: 20px;
            z-index: 999999;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            min-width: 300px;
        `;

                const title = document.createElement('div');
                title.textContent = '‚åõ Hidden Rows';
                title.style.cssText = `
            color: #ffd700;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        `;
                menu.appendChild(title);

                currentTab.rows.forEach((row, index) => {
                    if (typeof row === 'object' && row.hidden) {
                        const rowBtn = document.createElement('button');
                        const rowName = row.name || `Row ${index + 1}`;
                        rowBtn.textContent = `‚åõ Show: ${rowName}`;
                        rowBtn.style.cssText = `
                    width: 100%;
                    padding: 10px;
                    margin-bottom: 8px;
                    background: rgba(139, 105, 20, 0.3);
                    border: 2px solid #8b6914;
                    border-radius: 6px;
                    color: #ffd700;
                    cursor: pointer;
                    font-weight: bold;
                    transition: all 0.2s;
                `;

                        rowBtn.onmouseover = () => {
                            rowBtn.style.background = 'rgba(139, 105, 20, 0.5)';
                            rowBtn.style.transform = 'translateX(5px)';
                        };

                        rowBtn.onmouseout = () => {
                            rowBtn.style.background = 'rgba(139, 105, 20, 0.3)';
                            rowBtn.style.transform = 'translateX(0)';
                        };

                        rowBtn.onclick = () => {
                            this.toggleRowVisibility(index);
                            menu.remove();
                        };

                        menu.appendChild(rowBtn);
                    }
                });

                const closeBtn = document.createElement('button');
                closeBtn.textContent = '‚úñ Close';
                closeBtn.style.cssText = `
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: rgba(231, 76, 60, 0.5);
            border: 2px solid #e74c3c;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-weight: bold;
        `;
                closeBtn.onclick = () => menu.remove();

                menu.appendChild(closeBtn);
                document.body.appendChild(menu);
            }

            toggleCollapse() {
                this.sidebar.classList.toggle('collapsed');
                const toggleBtn = this.sidebar.querySelector('.toggle-btn');
                const isCollapsed = this.sidebar.classList.contains('collapsed');
                toggleBtn.innerHTML = isCollapsed ? '‚ñ∂' : '‚óÄ';
                localStorage.setItem('hwh_sidebar_collapsed', isCollapsed);
            }

            setupResizing(handle) {
                let startX, startWidth;

                handle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    startX = e.clientX;
                    startWidth = parseInt(getComputedStyle(this.sidebar).width, 10);

                    const onMouseMove = (e) => {
                        const width = startWidth + e.clientX - startX;
                        if (width >= 150 && width <= 600) {
                            this.sidebar.style.width = width + 'px';
                            try {
                                localStorage.setItem('hwh_sidebar_width', width);
                            } catch (err) {
                                console.warn('Could not save sidebar width:', err);
                            }
                        }
                    };

                    const onMouseUp = () => {
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    };

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                });
            }

            openEditor() {
                new UnifiedSettingsEditor(this).open();
            }

            // Tab management methods
            addTab(name = 'New Tab') {
                this.tabs.push({
                    name: name,
                    rows: []
                });
                this.activeTabIndex = this.tabs.length - 1;
                this.saveTabs();
                this.saveActiveTab();
                this.renderTabs();
                this.renderButtons();
            }

            renameTab(index, newName) {
                if (this.tabs[index]) {
                    this.tabs[index].name = newName;
                    this.saveTabs();
                    this.renderTabs();
                }
            }

            deleteTab(index) {
                if (this.tabs.length <= 1) {
                    alert('Cannot delete the last tab');
                    return;
                }
                this.tabs.splice(index, 1);
                if (this.activeTabIndex >= this.tabs.length) {
                    this.activeTabIndex = this.tabs.length - 1;
                }
                this.saveTabs();
                this.saveActiveTab();
                this.renderTabs();
                this.renderButtons();
            }

            moveRowToTab(fromTabIndex, rowIndex, toTabIndex) {
                if (!this.tabs[fromTabIndex] || !this.tabs[toTabIndex]) return;

                const row = this.tabs[fromTabIndex].rows.splice(rowIndex, 1)[0];
                this.tabs[toTabIndex].rows.push(row);
                this.saveTabs();
                this.renderButtons();
            }

            duplicateRow(tabIndex, rowIndex) {
                if (!this.tabs[tabIndex] || !this.tabs[tabIndex].rows[rowIndex]) return;

                const originalRow = this.tabs[tabIndex].rows[rowIndex];
                const duplicatedRow = JSON.parse(JSON.stringify(originalRow));

                // If it's an object with a name, modify the name
                if (typeof duplicatedRow === 'object' && duplicatedRow.name) {
                    duplicatedRow.name = duplicatedRow.name + ' (copy)';
                }

                // Insert after the original row
                this.tabs[tabIndex].rows.splice(rowIndex + 1, 0, duplicatedRow);
                this.saveTabs();
                this.renderButtons();
            }
        }

        // ============================================================================
        // UNIFIED SETTINGS EDITOR - Combines Menu Editor, Function Editor, & Styles
        // ============================================================================

        class UnifiedSettingsEditor {
            constructor(sidebar) {
                this.sidebar = sidebar;
                this.currentTab = 'layout';

                // Tab support
                this.tempTabs = JSON.parse(JSON.stringify(sidebar.tabs));
                this.activeEditTabIndex = sidebar.activeTabIndex;

                // Clean up each tab's rows
                this.tempTabs = this.tempTabs.map(tab => {
                    const cleanedRows = (tab.rows || [])
                    .filter(row => {
                        if (typeof row === 'object' && row.buttons) {
                            return Array.isArray(row.buttons) && row.buttons.length > 0;
                        }
                        return Array.isArray(row) && row.length > 0;
                    })
                    .map(row => {
                        if (typeof row === 'object' && row.buttons) {
                            const cleanedButtons = row.buttons.filter(btn => {
                                const name = typeof btn === 'string' ? btn : btn.name;
                                return BUTTON_FUNCTIONS[name];
                            });
                            if (cleanedButtons.length > 0) {
                                return {
                                    name: row.name || '',
                                    hidden: row.hidden || false,
                                    buttons: cleanedButtons
                                };
                            }
                            return null;
                        }
                        const cleanedButtons = row.filter(btn => {
                            const name = typeof btn === 'string' ? btn : btn.name;
                            return BUTTON_FUNCTIONS[name];
                        });
                        return cleanedButtons.length > 0 ? cleanedButtons : null;
                    })
                    .filter(row => row !== null);

                    return { name: tab.name, rows: cleanedRows };
                });

                this.tempStyle = sidebar.style;
                this._cachedOptgroups = null;
            }
            get tempLayout() {
                if (!this.tempTabs || this.tempTabs.length === 0) return [];
                const currentTab = this.tempTabs[this.activeEditTabIndex] || this.tempTabs[0];
                return currentTab.rows || [];
            }

            set tempLayout(value) {
                if (!this.tempTabs || this.tempTabs.length === 0) {
                    this.tempTabs = [{ name: 'Main', rows: value }];
                } else {
                    this.tempTabs[this.activeEditTabIndex].rows = value;
                }
            }
            // Build and cache dropdown categories (called once, reused for all buttons)
            buildCachedOptgroups() {
                if (this._cachedOptgroups) {
                    debugLog('üì¶ Cache HIT');
                    return this._cachedOptgroups;
                }
                console.time('‚è±Ô∏è buildOptgroups');

                const favorites = JSON.parse(localStorage.getItem('hwh_favorite_functions') || '[]');
                const categories = {
                    '‚≠ê Favorites': [],
                    'üìã All Functions': [],
                };

                Object.keys(BUTTON_FUNCTIONS).forEach(name => {
                    if (favorites.includes(name)) {
                        categories['‚≠ê Favorites'].push(name);
                    } else {
                        categories['üìã All Functions'].push(name);
                    }
                });

                // Sort each category once
                Object.keys(categories).forEach(cat => categories[cat].sort());

                this._cachedOptgroups = categories;
                console.timeEnd('‚è±Ô∏è buildOptgroups');
                return categories;
            }

            invalidateCache() {
                this._cachedOptgroups = null;
            }

            open() {
                // Remove existing editor
                const existing = document.getElementById('hwh-unified-editor');
                if (existing) existing.remove();

                const editor = document.createElement('div');
                editor.className = 'hwh-unified-editor';
                editor.id = 'hwh-unified-editor';

                editor.innerHTML = `
                <div class="hwh-editor-header">
                    <div class="hwh-editor-title">‚öôÔ∏è HWH Tweaker Settings</div>
                    <button class="hwh-compact-control-btn" onclick="document.getElementById('hwh-unified-editor').remove()">√ó</button>
                </div>

                <div class="hwh-unified-tabs">
                    <button class="hwh-tab-btn active" data-tab="layout">üìê Layout</button>
                    <button class="hwh-tab-btn" data-tab="functions">üîß Functions</button>
                    <button class="hwh-tab-btn" data-tab="style">üé® Style</button>
                    <button class="hwh-tab-btn" data-tab="import-export">üíæ Import/Export</button>
                </div>

                <div class="hwh-unified-content">
                    <!-- Layout Tab -->
                    <div class="hwh-tab-content active" data-tab="layout">
                        <div class="hwh-editor-toolbar">
                            <input type="text" id="hwh-layout-search" class="hwh-editor-search" placeholder="üîç Search functions..." />
                            <button class="hwh-editor-btn-clear" id="hwh-layout-search-clear">√ó</button>
                            <button class="hwh-editor-btn-small" id="hwh-add-row">‚ûï Add Row</button>
                        </div>
                        <div class="hwh-tab-scroll">
                            <div id="hwh-layout-content"></div>
                        </div>
                    </div>

                    <!-- Functions Tab -->
                    <div class="hwh-tab-content" data-tab="functions">
                        <div class="hwh-editor-toolbar">
                            <input type="text" id="hwh-func-search" class="hwh-editor-search" placeholder="üîç Search functions..." />
                            <button class="hwh-editor-btn-clear" id="hwh-func-search-clear">√ó</button>
                            <button class="hwh-editor-btn-small" id="hwh-func-add">‚ûï Add Custom</button>
                        </div>
                        <div class="hwh-tab-scroll">
                            <div class="hwh-func-stats" id="hwh-func-stats"></div>
                            <div id="hwh-func-list"></div>
                        </div>
                    </div>

                    <!-- Style Tab -->
                    <div class="hwh-tab-content" data-tab="style">
                        <div class="hwh-tab-scroll">
                            <div class="hwh-style-content" id="hwh-style-content">
                                <div class="hwh-style-section">
                                    <h3>Current Style</h3>
                                    <div class="hwh-style-preview" id="hwh-style-preview"></div>
                                </div>
                                <div class="hwh-style-section">
                                    <h3>Choose Style</h3>
                                    <div class="hwh-style-options" id="hwh-style-options"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Import/Export Tab -->
                    <div class="hwh-tab-content" data-tab="import-export">
                        <div class="hwh-tab-scroll">
                            <div class="hwh-import-export-content">
                                <div class="hwh-ie-section">
                                    <h3>üì§ Export</h3>
                                    <p>Download your complete settings as a backup or to share with others.</p>
                                    <div class="hwh-ie-buttons">
                                        <button class="hwh-editor-btn-large" id="hwh-export-all">üì¶ Export Everything</button>
                                        <button class="hwh-editor-btn-large" id="hwh-export-layout">üìê Layout Only</button>
                                        <button class="hwh-editor-btn-large" id="hwh-export-functions">üîß Functions Only</button>
                                        <button class="hwh-editor-btn-large" id="hwh-export-style">üé® Style Only</button>
                                         </div>
                                </div>
                                <div class="hwh-ie-section">
                                    <h3>üì• Import</h3>
                                    <p>Load settings from a file. You can import complete settings or individual components.</p>
                                    <div class="hwh-ie-buttons">
                                        <button class="hwh-editor-btn-large" id="hwh-import-file">üìÅ Import from File</button>
                                        <button class="hwh-editor-btn-large" id="hwh-import-clipboard">üìã Import from Clipboard</button>
                                    </div>
                                </div>
                                <div class="hwh-ie-section">
                                    <h3>üîÑ Reset</h3>
                                    <p>Reset to default settings. This cannot be undone!</p>
                                    <div class="hwh-ie-buttons">
                                        <button class="hwh-editor-btn-large hwh-btn-danger" id="hwh-reset-layout">Reset Layout</button>
                                        <button class="hwh-editor-btn-large hwh-btn-danger" id="hwh-reset-functions">Reset Functions</button>
                                        <button class="hwh-editor-btn-large hwh-btn-danger" id="hwh-reset-all">Reset Everything</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="hwh-editor-footer">
                    <button class="hwh-editor-btn-large hwh-editor-btn-cancel">Cancel</button>
                    <button class="hwh-editor-btn-large hwh-editor-btn-save">üíæ Save & Apply</button>
                </div>
            `;

                document.body.appendChild(editor);

                // Initialize tabs
                this.initTabs();

                // Initialize each tab's functionality
                this.initLayoutTab();
                this.initFunctionsTab();
                this.initStyleTab();
                this.initImportExportTab();

                // Footer buttons
                editor.querySelector('.hwh-editor-btn-cancel').onclick = () => editor.remove();
                editor.querySelector('.hwh-editor-btn-save').onclick = () => this.saveAll();
            }

            initTabs() {
                const tabBtns = document.querySelectorAll('.hwh-tab-btn');
                const tabContents = document.querySelectorAll('.hwh-tab-content');

                tabBtns.forEach(btn => {
                    btn.onclick = () => {
                        const tab = btn.dataset.tab;

                        // Update active states
                        tabBtns.forEach(b => b.classList.remove('active'));
                        tabContents.forEach(c => c.classList.remove('active'));

                        btn.classList.add('active');
                        document.querySelector(`[data-tab="${tab}"].hwh-tab-content`).classList.add('active');

                        this.currentTab = tab;

                        // Refresh tab content when switched
                        if (tab === 'layout') this.renderLayout();
                        if (tab === 'functions') this.renderFunctions();
                        if (tab === 'style') this.renderStyle();
                    };
                });
            }

            // ========================================================================
            // LAYOUT TAB
            // ========================================================================

            initLayoutTab() {
                const searchInput = document.getElementById('hwh-layout-search');
                const clearBtn = document.getElementById('hwh-layout-search-clear');
                const addRowBtn = document.getElementById('hwh-add-row');

                // Store reference to search term
                this.currentSearchTerm = '';

                let searchDebounce;
                searchInput.addEventListener('input', (e) => {
                    this.currentSearchTerm = e.target.value.toLowerCase();
                    clearBtn.style.display = this.currentSearchTerm ? 'block' : 'none';

                    // Debounce the filter (wait 150ms after typing stops)
                    clearTimeout(searchDebounce);
                    searchDebounce = setTimeout(() => {
                        this.applySearchFilter();
                    }, 150);
                });

                clearBtn.onclick = () => {
                    searchInput.value = '';
                    this.currentSearchTerm = '';
                    this.applySearchFilter();
                    clearBtn.style.display = 'none';
                };

                addRowBtn.onclick = () => {
                    this.tempLayout.push(['ToE']);
                    this.renderLayout();
                };

                this.renderLayout();
            }
            applySearchFilter() {
                const allSelects = document.querySelectorAll('#hwh-layout-content .hwh-editor-select');

                allSelects.forEach(select => {
                    const options = Array.from(select.options);
                    options.forEach(option => {
                        if (!this.currentSearchTerm) {
                            // No search term - show everything
                            option.style.display = '';
                        } else {
                            // Check both text and title (description)
                            const text = option.textContent.toLowerCase();
                            const title = (option.title || '').toLowerCase();
                            const matches = text.includes(this.currentSearchTerm) ||
                                  title.includes(this.currentSearchTerm);
                            option.style.display = matches ? '' : 'none';
                        }
                    });
                });
            }
            renderLayout() {
                console.time('‚è±Ô∏è renderLayout');
                const content = document.getElementById('hwh-layout-content');
                if (!content) return;

                content.innerHTML = '';


                this.renderTabBar();



                // Render layout rows
                this.tempLayout.forEach((row, rowIndex) => {
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'hwh-editor-row';

                    const rowHeader = document.createElement('div');
                    rowHeader.className = 'hwh-editor-row-header';
                    const rowData = this.tempLayout[rowIndex];
                    const rowName = (typeof rowData === 'object' && rowData.name) ? rowData.name : `Row ${rowIndex + 1}`;
                    const isHidden = (typeof rowData === 'object' && rowData.hidden) || false;


                    rowHeader.innerHTML = `
    <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
        <button class="hwh-editor-btn-tiny"
            data-action="toggle-visibility"
            title="${isHidden ? 'Show row' : 'Hide row'}"
            style="font-size: 14px; min-width: 28px;">
            ${isHidden ? '‚òê' : '‚òë'}
        </button>
        <input
            type="number"
            class="hwh-row-position-input"
            value="${rowIndex + 1}"
            min="1"
            max="${this.tempLayout.length}"
            data-row="${rowIndex}"
            title="Row position (1-${this.tempLayout.length})"
            style="
                width: 60px;
                padding: 4px 8px;
                background: rgba(0,0,0,0.4);
                border: 1px solid rgba(255,255,255,0.3);
                border-radius: 4px;
                color: ${isHidden ? '#666' : '#4af'};
                font-size: 12px;
                font-weight: bold;
                text-align: center;
                opacity: ${isHidden ? '0.5' : '1'};
            "
        />
        <input
            type="text"
            class="hwh-row-name-input"
            value="${rowName}"
            placeholder="Row ${rowIndex + 1}"
            data-row="${rowIndex}"
            style="
                flex: 1;
                padding: 4px 8px;
                background: rgba(0,0,0,0.3);
                border: 1px solid rgba(255,255,255,0.2);
                border-radius: 4px;
                color: ${isHidden ? '#666' : '#ffd700'};
                font-size: 12px;
                font-weight: bold;
                opacity: ${isHidden ? '0.5' : '1'};
            "
        />
    </div>
    <div class="hwh-editor-row-actions">
                        <button class="hwh-editor-btn-tiny" data-action="move-up" ${rowIndex === 0 ? 'disabled' : ''} style="opacity: ${isHidden ? '0.5' : '1'}">‚Üë</button>
                        <button class="hwh-editor-btn-tiny" data-action="move-down" ${rowIndex === this.tempLayout.length - 1 ? 'disabled' : ''} style="opacity: ${isHidden ? '0.5' : '1'}">‚Üì</button>
                        <button class="hwh-editor-btn-tiny" data-action="add-button" style="opacity: ${isHidden ? '0.5' : '1'}">‚ûï</button>
                        <button class="hwh-editor-btn-tiny" data-action="delete-row" style="opacity: ${isHidden ? '0.5' : '1'}">üóëÔ∏è</button>
                        <button class="hwh-editor-btn-tiny" data-action="duplicate-row" title="Duplicate row" style="opacity: ${isHidden ? '0.5' : '1'}">üìã</button>
                        ${this.tempTabs.length > 1 ? `<button class="hwh-editor-btn-tiny" data-action="move-to-tab" title="Move to another tab" style="opacity: ${isHidden ? '0.5' : '1'}">üìÅ</button>` : ''}
                    </div>
                `;
                    rowHeader.onclick = (e) => {
                        const action = e.target.dataset.action;



                        if (!action) return;
                        e.stopPropagation();

                        if (action === 'toggle-visibility') {
                            debugLog('üîÑ Toggling visibility for row', rowIndex);
                            // Ensure row is an object
                            if (typeof this.tempLayout[rowIndex] !== 'object' || !this.tempLayout[rowIndex].buttons) {
                                this.tempLayout[rowIndex] = {
                                    name: rowName,
                                    hidden: true,
                                    buttons: Array.isArray(this.tempLayout[rowIndex]) ? this.tempLayout[rowIndex] : []
                                };
                            } else {
                                this.tempLayout[rowIndex].hidden = !this.tempLayout[rowIndex].hidden;
                            }
                            // Delay renderLayout slightly to let the click event finish
                            setTimeout(() => this.renderLayout(), 10);
                            return;  // DON'T FALL THROUGH - IMPORTANT!
                        } else if (action === 'move-up' && rowIndex > 0) {
                            [this.tempLayout[rowIndex], this.tempLayout[rowIndex - 1]] =
                                [this.tempLayout[rowIndex - 1], this.tempLayout[rowIndex]];
                        } else if (action === 'move-down' && rowIndex < this.tempLayout.length - 1) {
                            [this.tempLayout[rowIndex], this.tempLayout[rowIndex + 1]] =
                                [this.tempLayout[rowIndex + 1], this.tempLayout[rowIndex]];
                        } else if (action === 'add-button') {
                            const currentRow = this.tempLayout[rowIndex];
                            const rowButtons = typeof currentRow === 'object' && currentRow.buttons ? currentRow.buttons : currentRow;
                            rowButtons.push('ToE');
                        } else if (action === 'delete-row') {
                            this.tempLayout.splice(rowIndex, 1);

                        } else if (action === 'duplicate-row') {
                            const currentRow = this.tempLayout[rowIndex];
                            const duplicated = JSON.parse(JSON.stringify(currentRow));
                            if (typeof duplicated === 'object' && duplicated.name) {
                                duplicated.name += ' (copy)';
                            }
                            this.tempLayout.splice(rowIndex + 1, 0, duplicated);

                        } else if (action === 'move-to-tab') {
                            this.showMoveToTabMenu(rowIndex, e.target);
                            return; // Don't re-render yet
                        }

                        this.renderLayout();
                    };
                    // Handle row position changes
                    const positionInput = rowHeader.querySelector('.hwh-row-position-input');
                    if (positionInput) {
                        positionInput.onclick = (e) => e.stopPropagation(); // Don't trigger row actions

                        // Update on change (when user clicks away or presses Enter)
                        positionInput.onchange = (e) => {
                            let newPosition = parseInt(e.target.value);

                            // Validate input
                            if (isNaN(newPosition) || newPosition < 1 || newPosition > this.tempLayout.length) {
                                e.target.value = rowIndex + 1; // Reset to current position
                                return;
                            }

                            // Convert to 0-based index
                            newPosition = newPosition - 1;

                            // Don't do anything if position hasn't changed
                            if (newPosition === rowIndex) return;

                            // Move the row to the new position
                            const row = this.tempLayout.splice(rowIndex, 1)[0];
                            this.tempLayout.splice(newPosition, 0, row);

                            // Re-render immediately
                            this.renderLayout();
                        };

                        // Allow Enter key to trigger the change
                        positionInput.onkeydown = (e) => {
                            if (e.key === 'Enter') {
                                e.target.blur(); // Trigger onchange
                            }
                        };
                    }

                    // Handle row name changes
                    const nameInput = rowHeader.querySelector('.hwh-row-name-input');
                    if (nameInput) {
                        nameInput.onclick = (e) => e.stopPropagation(); // Don't trigger row actions
                        nameInput.onchange = (e) => {
                            // Ensure row is an object
                            if (typeof this.tempLayout[rowIndex] !== 'object') {
                                this.tempLayout[rowIndex] = {
                                    name: e.target.value || `Row ${rowIndex + 1}`,
                                    hidden: false,
                                    buttons: this.tempLayout[rowIndex]
                                };
                            } else {
                                this.tempLayout[rowIndex].name = e.target.value || `Row ${rowIndex + 1}`;
                            }
                        };
                    }

                    const buttons = document.createElement('div');
                    buttons.className = 'hwh-editor-buttons';
                    if (isHidden) {
                        buttons.style.display = 'none';
                    }

                    const rowButtons = (typeof row === 'object' && row.buttons) ? row.buttons : row;

                    // Safety check - if rowButtons is still undefined or not an array, skip
                    if (!Array.isArray(rowButtons)) {
                        console.warn('Row has no valid buttons array:', row);
                        rowDiv.appendChild(rowHeader);
                        content.appendChild(rowDiv);
                        return;
                    }

                    rowButtons.forEach((btn, btnIndex) => {
                        const btnName = typeof btn === 'string' ? btn : btn.name;
                        const btnGroup = document.createElement('div');
                        btnGroup.className = 'hwh-editor-button-group';
                        btnGroup.style.cssText = `display: flex; gap: 4px; flex: 1; align-items: center; opacity: ${isHidden ? '0.5' : '1'};`;

                        // Get button config for color
                        const btnConfig = getButtonConfig(btnName);
                        const colorMap = {
                            'green': '#2ecc71',
                            'blue': '#3498db',
                            'orange': '#e67e22',
                            'red': '#e74c3c',
                            'violet': '#9b59b6',
                            'yellow': '#f1c40f',
                            'graphite': '#7f8c8d',
                            'pink': '#e91e8c',
                            'cyan': '#00d9ff',
                            'black': '#1a1a1a',
                            'lightgrey': '#d0d0d0'
                        };
                        const buttonColor = btnConfig.color ? (colorMap[btnConfig.color] || '#ffd700') : '#ffd700';

                        // Color box (clickable to edit)
                        const colorBox = document.createElement('div');
                        colorBox.style.cssText = `
    width: 24px;
    height: 24px;
    background: ${buttonColor};
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 4px;
    cursor: pointer;
    flex-shrink: 0;
    transition: transform 0.1s;
`;
                        colorBox.title = `${btnConfig.icon || ''} ${btnName} - Click to edit`;
                        colorBox.onmouseover = () => colorBox.style.transform = 'scale(1.1)';
                        colorBox.onmouseout = () => colorBox.style.transform = 'scale(1)';
                        colorBox.onclick = () => {
                            debugLog('üé® Opening editor from color box:', btnName);
                            this.editFunction(btnName);
                        };

                        // Dropdown select - LAZY LOADED for performance
                        const select = document.createElement('select');
                        select.className = 'hwh-editor-select';
                        select.style.flex = '1';
                        select.dataset.populated = 'false';
                        select.dataset.currentValue = btnName;

                        // Only show current value initially (1 option vs 50+)
                        const currentConfig = getButtonConfig(btnName);
                        const currentOption = document.createElement('option');
                        currentOption.value = btnName;
                        currentOption.textContent = `${currentConfig?.icon || ''} ${btnName}`.trim();
                        currentOption.selected = true;
                        select.appendChild(currentOption);

                        // Populate full options on first click/focus
                        const populateSelect = () => {
                            if (select.dataset.populated === 'true') return;
                            select.dataset.populated = 'true';

                            select.innerHTML = '';

                            const emptyOpt = document.createElement('option');
                            emptyOpt.value = '';
                            emptyOpt.textContent = '-- Empty --';
                            select.appendChild(emptyOpt);

                            const categories = this.buildCachedOptgroups();
                            Object.keys(categories).forEach(catName => {
                                const funcs = categories[catName];
                                if (funcs.length === 0) return;

                                const optgroup = document.createElement('optgroup');
                                optgroup.label = catName;

                                funcs.forEach(name => {
                                    const btnConfig = getButtonConfig(name);
                                    const hasCustomization = window.buttonCustomizations && window.buttonCustomizations[name];

                                    const option = document.createElement('option');
                                    option.value = name;
                                    option.textContent = `${btnConfig.icon || ''} ${name}${hasCustomization ? ' ‚úèÔ∏è' : ''}`.trim();

                                    if (btnConfig.description) {
                                        option.title = btnConfig.description;
                                    }

                                    option.selected = name === select.dataset.currentValue;

                                    optgroup.appendChild(option);
                                });

                                select.appendChild(optgroup);
                            });
                        };

                        select.addEventListener('mousedown', populateSelect, { once: true });
                        select.addEventListener('focus', populateSelect, { once: true });
                        select.addEventListener('touchstart', populateSelect, { once: true });

                        select.onchange = (e) => {
                            rowButtons[btnIndex] = e.target.value;
                            this.renderLayout();
                        };


                        // EDIT BUTTON (pencil icon)
                        const editBtn = document.createElement('button');
                        editBtn.className = 'hwh-editor-btn-tiny';
                        editBtn.innerHTML = '‚úèÔ∏è';
                        editBtn.title = 'Edit function properties';
                        editBtn.style.cssText = 'min-width: 32px; padding: 4px 6px;';
                        editBtn.onclick = (e) => {
                            PerfLog.start('EDIT-CLICK');
                            e.stopPropagation();
                            debugLog('üñäÔ∏è Opening editor for:', btnName);
                            this.editFunction(btnName);
                            PerfLog.end('EDIT-CLICK');
                        };
                        // LEFT ARROW (move button left)
                        const moveLeftBtn = document.createElement('button');
                        moveLeftBtn.className = 'hwh-editor-btn-tiny';
                        moveLeftBtn.innerHTML = '‚Üê';
                        moveLeftBtn.title = 'Move left';
                        moveLeftBtn.style.cssText = 'min-width: 32px; padding: 4px 6px;';
                        moveLeftBtn.disabled = btnIndex === 0;
                        moveLeftBtn.onclick = () => {
                            if (btnIndex > 0) {
                                [rowButtons[btnIndex], rowButtons[btnIndex - 1]] = [rowButtons[btnIndex - 1], rowButtons[btnIndex]];
                                this.renderLayout();
                            }
                        };



                        // RIGHT ARROW (move button right)
                        const moveRightBtn = document.createElement('button');
                        moveRightBtn.className = 'hwh-editor-btn-tiny';
                        moveRightBtn.innerHTML = '‚Üí';
                        moveRightBtn.title = 'Move right';
                        moveRightBtn.style.cssText = 'min-width: 32px; padding: 4px 6px;';
                        moveRightBtn.disabled = btnIndex === rowButtons.length - 1;
                        moveRightBtn.onclick = () => {
                            if (btnIndex < rowButtons.length - 1) {
                                [rowButtons[btnIndex], rowButtons[btnIndex + 1]] = [rowButtons[btnIndex + 1], rowButtons[btnIndex]];
                                this.renderLayout();
                            }
                        };
                        // DELETE BUTTON (X)
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'hwh-editor-btn-tiny';
                        deleteBtn.textContent = '√ó';
                        deleteBtn.title = 'Remove from layout';
                        deleteBtn.onclick = () => {
                            rowButtons.splice(btnIndex, 1);
                            if (rowButtons.length === 0) {
                                this.tempLayout.splice(rowIndex, 1);
                            }
                            this.renderLayout();
                        };
                        btnGroup.appendChild(colorBox);
                        btnGroup.appendChild(select);
                        btnGroup.appendChild(moveLeftBtn);      // NEW
                        btnGroup.appendChild(moveRightBtn);     // NEW
                        btnGroup.appendChild(editBtn);
                        btnGroup.appendChild(deleteBtn);
                        buttons.appendChild(btnGroup);
                    });
                    rowDiv.appendChild(rowHeader);
                    rowDiv.appendChild(buttons);
                    content.appendChild(rowDiv);
                });

                // Add empty state if no rows
                if (this.tempLayout.length === 0) {
                    content.innerHTML = '<div class="hwh-editor-empty">No buttons yet. Click "‚ûï Add Row" to start!</div>';
                }
                this.applySearchFilter();
                console.timeEnd('‚è±Ô∏è renderLayout');
            }
            renderTabBar() {
                const container = document.getElementById('hwh-layout-content');
                if (!container) return;

                // Create tab bar container
                let tabBar = container.querySelector('.hwh-editor-tab-bar');
                if (!tabBar) {
                    tabBar = document.createElement('div');
                    tabBar.className = 'hwh-editor-tab-bar';
                    container.insertBefore(tabBar, container.firstChild);
                }
                tabBar.innerHTML = '';

                // Render each tab
                this.tempTabs.forEach((tab, index) => {
                    const tabEl = document.createElement('div');
                    tabEl.className = 'hwh-editor-tab' + (index === this.activeEditTabIndex ? ' active' : '');

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'hwh-editor-tab-name';
                    nameSpan.textContent = tab.name || `Tab ${index + 1}`;

                    const actions = document.createElement('div');
                    actions.className = 'hwh-editor-tab-actions';

                    // Rename button
                    const renameBtn = document.createElement('button');
                    renameBtn.className = 'hwh-editor-tab-btn';
                    renameBtn.innerHTML = '‚úèÔ∏è';
                    renameBtn.title = 'Rename tab';
                    renameBtn.onclick = (e) => {
                        e.stopPropagation();
                        const newName = prompt('Enter new tab name:', tab.name);
                        if (newName && newName.trim()) {
                            this.tempTabs[index].name = newName.trim();
                            this.renderTabBar();
                        }
                    };

                    // Delete button (only if more than one tab)
                    if (this.tempTabs.length > 1) {
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'hwh-editor-tab-btn delete';
                        deleteBtn.innerHTML = '√ó';
                        deleteBtn.title = 'Delete tab';
                        deleteBtn.onclick = (e) => {
                            e.stopPropagation();
                            if (confirm(`Delete tab "${tab.name}"? All rows will be lost!`)) {
                                this.tempTabs.splice(index, 1);
                                if (this.activeEditTabIndex >= this.tempTabs.length) {
                                    this.activeEditTabIndex = this.tempTabs.length - 1;
                                }
                                this.renderTabBar();
                                this.renderLayout();
                            }
                        };
                        actions.appendChild(deleteBtn);
                    }

                    actions.insertBefore(renameBtn, actions.firstChild);

                    tabEl.appendChild(nameSpan);
                    tabEl.appendChild(actions);

                    tabEl.onclick = () => {
                        this.activeEditTabIndex = index;
                        this.renderTabBar();
                        this.renderLayout();
                    };

                    tabBar.appendChild(tabEl);
                });

                // Add new tab button
                const addTabBtn = document.createElement('button');
                addTabBtn.className = 'hwh-editor-add-tab';
                addTabBtn.innerHTML = '+ Add Tab';
                addTabBtn.onclick = () => {
                    const name = prompt('Enter tab name:', `Tab ${this.tempTabs.length + 1}`);
                    if (name && name.trim()) {
                        this.tempTabs.push({
                            name: name.trim(),
                            rows: []
                        });
                        this.activeEditTabIndex = this.tempTabs.length - 1;
                        this.renderTabBar();
                        this.renderLayout();
                    }
                };
                tabBar.appendChild(addTabBtn);
            }
            showMoveToTabMenu(rowIndex, buttonEl) {
                // Remove any existing menu
                document.querySelectorAll('.hwh-move-to-tab-dropdown').forEach(m => m.remove());

                const menu = document.createElement('div');
                menu.className = 'hwh-move-to-tab-dropdown';

                this.tempTabs.forEach((tab, tabIndex) => {
                    if (tabIndex === this.activeEditTabIndex) return; // Skip current tab

                    const option = document.createElement('div');
                    option.className = 'hwh-move-to-tab-option';
                    option.textContent = tab.name || `Tab ${tabIndex + 1}`;
                    option.onclick = () => {
                        // Move the row to the other tab
                        const row = this.tempLayout.splice(rowIndex, 1)[0];
                        this.tempTabs[tabIndex].rows.push(row);
                        menu.remove();
                        this.renderLayout();
                    };
                    menu.appendChild(option);
                });

                // Position the menu near the button
                const rect = buttonEl.getBoundingClientRect();
                menu.style.position = 'fixed';
                menu.style.top = rect.bottom + 'px';
                menu.style.left = rect.left + 'px';

                document.body.appendChild(menu);

                // Close menu when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', function closeMenu(e) {
                        if (!menu.contains(e.target) && e.target !== buttonEl) {
                            menu.remove();
                            document.removeEventListener('click', closeMenu);
                        }
                    });
                }, 0);
            }



            handleLayoutClick(e) {
                const button = e.target.closest('button[data-action], button[data-row]');
                if (!button) return;

                const action = button.dataset.action;
                const rowIndex = parseInt(button.dataset.row);

                if (action === 'up' && rowIndex > 0) {
                    [this.tempLayout[rowIndex], this.tempLayout[rowIndex - 1]] =
                        [this.tempLayout[rowIndex - 1], this.tempLayout[rowIndex]];
                    this.renderLayout();
                } else if (action === 'down' && rowIndex < this.tempLayout.length - 1) {
                    [this.tempLayout[rowIndex], this.tempLayout[rowIndex + 1]] =
                        [this.tempLayout[rowIndex + 1], this.tempLayout[rowIndex]];
                    this.renderLayout();
                } else if (action === 'delete') {
                    if (confirm(`Delete row ${rowIndex + 1}?`)) {
                        this.tempLayout.splice(rowIndex, 1);
                        this.renderLayout();
                    }
                } else if (button.classList.contains('hwh-editor-btn-add')) {
                    if (this.tempLayout[rowIndex].length < 3) {
                        this.tempLayout[rowIndex].push('ToE');
                        this.renderLayout();
                    }
                } else if (button.classList.contains('hwh-editor-btn-remove')) {
                    if (this.tempLayout[rowIndex].length > 1) {
                        this.tempLayout[rowIndex].pop();
                        this.renderLayout();
                    }
                }
            }

            // ========================================================================
            // FUNCTIONS TAB
            // ========================================================================

            // ============================================================================
            // HWH TWEAKER v4.9.6 - ENHANCED FUNCTION EDITOR UPDATE
            // ============================================================================
            // This file contains the COMPLETE replacement sections
            // Follow the instructions to replace sections in your 4.9.5 file
            // ============================================================================

            // ============================================================================
            // SECTION 1: REPLACE ENTIRE "FUNCTIONS TAB" SECTION
            // ============================================================================
            // Location: Lines 16620-16850 (approximately)
            // Find the line: "// FUNCTIONS TAB"
            // Replace from that comment down through the cloneFunction method
            // ============================================================================

            // ========================================================================
            // FUNCTIONS TAB - ENHANCED WITH FAVORITES & COMPACT VIEW
            // ========================================================================
            initFunctionsTab() {
                const searchInput = document.getElementById('hwh-func-search');
                const clearBtn = document.getElementById('hwh-func-search-clear');
                const addBtn = document.getElementById('hwh-func-add');

                let funcSearchDebounce;
                searchInput.addEventListener('input', (e) => {
                    clearBtn.style.display = e.target.value ? 'block' : 'none';

                    // Debounce the render (wait 150ms after typing stops)
                    clearTimeout(funcSearchDebounce);
                    funcSearchDebounce = setTimeout(() => {
                        this.renderFunctions(e.target.value);
                    }, 150);
                });

                clearBtn.onclick = () => {
                    searchInput.value = '';
                    this.renderFunctions();
                    clearBtn.style.display = 'none';
                };

                addBtn.onclick = () => this.addFunction();

                this.renderFunctions();
            }

            renderFunctions(filter = '') {
                const list = document.getElementById('hwh-func-list');
                const stats = document.getElementById('hwh-func-stats');
                if (!list || !stats) return;

                list.innerHTML = '';
                const filterLower = filter.toLowerCase();

                // Load favorites from localStorage
                const favorites = JSON.parse(localStorage.getItem('hwh_favorite_functions') || '[]');

                let customCount = 0;
                let defaultCount = 0;
                let visibleCount = 0;

                // Sort functions: favorites first, then alphabetically
                const sortedNames = Object.keys(BUTTON_FUNCTIONS).sort((a, b) => {
                    const aFav = favorites.includes(a);
                    const bFav = favorites.includes(b);
                    if (aFav && !bFav) return -1;
                    if (!aFav && bFav) return 1;
                    return a.localeCompare(b);
                });

                sortedNames.forEach(name => {
                    const func = BUTTON_FUNCTIONS[name];
                    const hasCustomization = window.buttonCustomizations && window.buttonCustomizations[name] &&
                          (window.buttonCustomizations[name].icon ||
                           window.buttonCustomizations[name].color ||
                           window.buttonCustomizations[name].description);

                    if (func.isCustom) customCount++;
                    else defaultCount++;

                    const matchesSearch = !filter ||
                          name.toLowerCase().includes(filterLower) ||
                          func.description.toLowerCase().includes(filterLower);

                    if (!matchesSearch) return;
                    visibleCount++;

                    const isFavorite = favorites.includes(name);

                    const item = document.createElement('div');
                    item.className = 'hwh-func-item hwh-func-item-compact';
                    if (func.isCustom) item.classList.add('hwh-func-item-custom');
                    if (isFavorite) item.classList.add('hwh-func-item-favorite');

                    // Compact color preview
                    const colorSwatch = func.color ?
                          `<span class="hwh-func-color-preview hwh-color-swatch-${func.color}"></span>` :
                    '<span class="hwh-func-color-none">‚óã</span>';

                    // Compact icon preview
                    const iconPreview = func.icon ?
                          `<span class="hwh-func-icon-preview">${func.icon}</span>` :
                    '<span class="hwh-func-icon-none">‚óã</span>';

                    item.innerHTML = `
                    <div class="hwh-func-item-header-compact">
                        <button class="hwh-func-fav-btn" data-name="${name}" title="${isFavorite ? 'Remove from favorites' : 'Add to favorites'}">
                            ${isFavorite ? '‚≠ê' : '‚òÜ'}
                        </button>
<div class="hwh-func-item-name-compact">
    ${iconPreview} <strong>${name}</strong>
    ${hasCustomization ? '<span style="color: #f39c12; margin-left: 4px;" title="Has customizations">‚úèÔ∏è</span>' : ''}
</div>
                        <div class="hwh-func-item-meta-inline">
                            ${colorSwatch}
                            <span class="hwh-func-badge-compact ${func.isCustom ? 'hwh-func-badge-custom' : ''}">
                                ${func.isCustom ? 'Custom' : 'Default'}
                            </span>
                        </div>
                        <div class="hwh-func-item-buttons-compact">
                            ${func.isCustom ? `
                                <button class="hwh-func-btn-icon hwh-func-edit" data-name="${name}" title="Edit">‚úèÔ∏è</button>
                                <button class="hwh-func-btn-icon hwh-func-clone" data-name="${name}" title="Clone">üìã</button>
                                <button class="hwh-func-btn-icon hwh-func-delete" data-name="${name}" title="Delete" style="color: #e74c3c;">üóëÔ∏è</button>
                            ` : `
                                <button class="hwh-func-btn-icon hwh-func-edit" data-name="${name}" title="Edit Properties">‚úèÔ∏è</button>
                                <button class="hwh-func-btn-icon hwh-func-clone" data-name="${name}" title="Clone">üìã</button>
                            `}
                        </div>
                    </div>
                    <div class="hwh-func-item-desc-compact">${func.description || 'No description'}</div>
                `;

                    // Event handling
                    item.onclick = (e) => {
                        e.stopPropagation();

                        if (e.target.classList.contains('hwh-func-fav-btn')) {
                            this.toggleFavorite(e.target.dataset.name);
                        } else if (e.target.classList.contains('hwh-func-edit')) {
                            this.editFunction(e.target.dataset.name);
                        } else if (e.target.classList.contains('hwh-func-delete')) {
                            this.deleteFunction(e.target.dataset.name);
                        } else if (e.target.classList.contains('hwh-func-clone')) {
                            this.cloneFunction(e.target.dataset.name);
                        }
                    };

                    list.appendChild(item);
                });

                // Update stats
                const favCount = favorites.length;
                stats.innerHTML = `
                <div class="hwh-func-stats-compact">
                    <span>üìö Total: <strong>${customCount + defaultCount}</strong></span>
                    <span>‚úÖ Default: <strong>${defaultCount}</strong></span>
                    <span>üîß Custom: <strong>${customCount}</strong></span>
                    <span>‚≠ê Favorites: <strong>${favCount}</strong></span>
                    ${filter ? `<span>üîç Showing: <strong>${visibleCount}</strong></span>` : ''}
                </div>
            `;
            }

            toggleFavorite(name) {
                const favorites = JSON.parse(localStorage.getItem('hwh_favorite_functions') || '[]');
                const index = favorites.indexOf(name);

                if (index > -1) {
                    favorites.splice(index, 1);
                } else {
                    favorites.push(name);
                }

                localStorage.setItem('hwh_favorite_functions', JSON.stringify(favorites));
                this.renderFunctions();
                this.renderLayout(); // Refresh layout to show favorites section
            }

            addFunction() {
                const name = prompt('Enter function name:\n\nTip: Use ">>" prefix for navigation buttons');
                if (!name || name.trim() === '') return;

                if (BUTTON_FUNCTIONS[name]) {
                    alert('‚ùå Function already exists! Use Clone to duplicate it.');
                    return;
                }

                this.editFunction(name, true);
            }

            cloneFunction(name) {
                const func = BUTTON_FUNCTIONS[name];
                if (!func) return;

                const newName = prompt('Enter name for the cloned function:', name + ' Copy');
                if (!newName || newName.trim() === '') return;

                if (BUTTON_FUNCTIONS[newName]) {
                    alert('‚ùå A function with that name already exists!');
                    return;
                }

                BUTTON_FUNCTIONS[newName] = {
                    action: func.action,
                    icon: func.icon,
                    color: func.color,
                    description: func.description + ' (cloned)',
                    isCustom: true
                };

                saveCustomFunctions();
                this.renderFunctions();
                alert(`‚úÖ Function "${newName}" created!`);
            }


            editFunction(name, isNew = false) {
                PerfLog.start('editFunction-inner');
                const func = BUTTON_FUNCTIONS[name];
                const isCustom = func ? func.isCustom : true;
                const canEditAction = isCustom || isNew;

                // Remove any existing dialogs first
                const existingDialogs = document.querySelectorAll('.hwh-func-edit-dialog');
                existingDialogs.forEach(d => d.remove());

                const dialog = document.createElement('div');
                dialog.className = 'hwh-func-edit-dialog';

                // CRITICAL: Set inline styles to override EVERYTHING
                dialog.style.cssText = `
        display: flex !important;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 2147483647 !important;
        align-items: center !important;
        justify-content: center !important;
        pointer-events: auto !important;
        visibility: visible !important;
        opacity: 1 !important;
    `;

                // ‚úÖ FIXED: Get customized properties to populate the form
                const btnConfig = getButtonConfig(name) || {};
                const currentIcon = btnConfig.icon || '';
                const currentColor = btnConfig.color || '';
                const currentDesc = btnConfig.description || '';
                const currentAction = func ? func.action.toString() : '() => {\n    // Your code here\n    console.log("Hello from ' + name + '!");\n}';
                const currentFontSize = btnConfig.fontSize || localStorage.getItem('hwh_global_font_size') || '14';
                const currentCustomColor = btnConfig.customColor || '#ffd700';

                dialog.innerHTML = `
        <div class="hwh-func-edit-overlay" style="
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
        "></div>
        <div class="hwh-func-edit-content" style="
            position: relative;
            z-index: 2147483647;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 3px solid #3498db;
            border-radius: 12px;
            width: 95%;
            max-width: 900px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0,0,0,0.9);
        ">
            <div class="hwh-func-edit-header" style="
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 16px 20px;
                border-bottom: 2px solid rgba(255, 255, 255, 0.1);
                background: rgba(0,0,0,0.3);
            ">
                <h3 style="margin: 0; color: #3498db; font-size: 18px;">
                    ${isNew ? '‚ûï Create Function' : (canEditAction ? '‚úèÔ∏è Edit Function' : '‚úèÔ∏è Edit Properties')}
                </h3>
                <button class="hwh-func-edit-close" style="
                    background: none;
                    border: none;
                    color: #fff;
                    font-size: 28px;
                    cursor: pointer;
                    padding: 0;
                    width: 40px;
                    height: 40px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    border-radius: 4px;
                    transition: background 0.2s;
                ">√ó</button>
            </div>
                    <!-- ‚≠ê NEW SECTION: BUTTON PREVIEW - ADD THIS HERE ‚≠ê -->
        <div class="hwh-func-edit-preview" id="hwh-func-preview-section" style="
            padding: 16px 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 12px;
        ">
            <label style="color: #3498db; font-weight: 600; font-size: 14px; min-width: 80px;">
                Preview:
            </label>
            <button id="hwh-func-preview-button" style="
                padding: 8px 16px;
                background: ${currentColor ? ({'green':'#2ecc71','blue':'#3498db','orange':'#e67e22','red':'#e74c3c','violet':'#9b59b6','yellow':'#f1c40f','graphite':'#7f8c8d','pink':'#e91e8c','cyan':'#00d9ff','black':'#1a1a1a','lightgrey':'#d0d0d0'}[currentColor] || '#ffd700') : '#ffd700'};
                border: none;
                border-radius: 6px;
                color: white;
                font-weight: bold;
                font-size: 14px;
                cursor: default;
                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                pointer-events: none;
            ">${currentIcon} ${name}</button>
            <small style="color: #999; font-size: 11px;">
                Live preview updates as you edit
            </small>
        </div>
        <!-- ‚≠ê END OF NEW SECTION ‚≠ê -->

            <div class="hwh-func-edit-body" style="
                padding: 20px;
                overflow-y: auto;
                flex: 1;
                color: #fff;
            ">
                <div class="hwh-func-edit-field" style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 6px; color: #3498db; font-weight: 600; font-size: 14px;">
                        Function ID (constant) ${canEditAction ? '' : 'üîí locked'}
                    </label>
                    <input type="text" id="hwh-edit-name" value="${name}"
                        ${canEditAction ? '' : 'readonly'}
                        style="
                            width: 100%;
                            padding: 10px;
                            background: rgba(0, 0, 0, ${canEditAction ? '0.4' : '0.2'});
                            border: 2px solid rgba(255, 255, 255, 0.2);
                            border-radius: 6px;
                            color: #fff;
                            font-size: 14px;
                            font-family: 'Courier New', monospace;
                            box-sizing: border-box;
                            ${canEditAction ? '' : 'opacity: 0.6; cursor: not-allowed;'}
                        " />
                    <small style="color: #999; font-size: 11px;">
                        Static identifier - use for code references
                    </small>
                </div>

                <div class="hwh-func-edit-field" style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 6px; color: #3498db; font-weight: 600; font-size: 14px;">
                        Description
                    </label>
                    <input type="text" id="hwh-edit-desc" value="${currentDesc}"
                        placeholder="What does this function do?"
                        style="
                            width: 100%;
                            padding: 10px;
                            background: rgba(0, 0, 0, 0.4);
                            border: 2px solid rgba(255, 255, 255, 0.2);
                            border-radius: 6px;
                            color: #fff;
                            font-size: 14px;
                            box-sizing: border-box;
                        " />
                    <small style="color: #999; font-size: 11px;">
                        Shown in tooltips and function list
                    </small>
                </div>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                    <div class="hwh-func-edit-field">
                        <label style="display: block; margin-bottom: 6px; color: #3498db; font-weight: 600; font-size: 14px;">
                            Icon / Display Name
                        </label>
                        <input type="text" id="hwh-edit-icon" value="${currentIcon}"
                            placeholder="üöÄ or Text"
                            style="
                                width: 100%;
                                padding: 10px;
                                background: rgba(0, 0, 0, 0.4);
                                border: 2px solid rgba(255, 255, 255, 0.2);
                                border-radius: 6px;
                                color: #fff;
                                font-size: 14px;
                                box-sizing: border-box;
                            " />
                        <small style="color: #999; font-size: 11px;">
                            Emoji or short text
                        </small>
                    </div>

                    <div class="hwh-func-edit-field">
                        <label style="display: block; margin-bottom: 6px; color: #3498db; font-weight: 600; font-size: 14px;">
                            Button Color
                                </label>
<div class="hwh-color-picker" style="position: relative;">
    <div class="hwh-color-selected" id="hwh-edit-color-display" style="
width: 100%;
padding: 10px;
background: rgba(0, 0, 0, 0.4);
border: 2px solid rgba(255, 255, 255, 0.2);
border-radius: 6px;
color: #fff;
font-size: 14px;
cursor: pointer;
display: flex;
align-items: center;
gap: 8px;
box-sizing: border-box;
">
<span class="hwh-color-square" style="display: inline-block; width: 16px; height: 16px; background: ${currentColor ? ({'green':'#4ae29a','blue':'#4a9eff','purple':'#b84aff','orange':'#ff9d4a','red':'#ff4a4a','yellow':'#ffe44a','pink':'#ff69b4','cyan':'#4affff','graphite':'#8a8a8a','black':'#262626','lightgrey':'#e6e6e6'}[currentColor] || '#ffd700') : '#ffd700'}; border: 1px solid rgba(255,255,255,0.3); border-radius: 3px;"></span>
<span class="hwh-color-label">${currentColor ? ({'green':'Green','blue':'Blue','purple':'Purple','orange':'Orange','red':'Red','yellow':'Yellow','pink':'Pink','cyan':'Cyan','graphite':'Graphite','black':'Black','lightgrey':'Light Grey'}[currentColor] || 'Default (Gold)') : 'Default (Gold)'}</span>
</div>
<div class="hwh-color-options" id="hwh-edit-color-options" style="
display: none;
position: absolute;
bottom: 100%;
left: 0;
right: 0;
background: rgba(20, 20, 20, 0.95);
border: 2px solid rgba(255, 255, 255, 0.2);
border-radius: 6px;
margin-bottom: 4px;
max-height: 200px;
overflow-y: auto;
z-index: 1000;
">
${[
    {val: '', label: 'Default (Gold)', color: '#ffd700'},
    {val: 'green', label: 'Green', color: '#4ae29a'},
    {val: 'blue', label: 'Blue', color: '#4a9eff'},
    {val: 'purple', label: 'Purple', color: '#b84aff'},
    {val: 'orange', label: 'Orange', color: '#ff9d4a'},
    {val: 'red', label: 'Red', color: '#ff4a4a'},
    {val: 'yellow', label: 'Yellow', color: '#ffe44a'},
    {val: 'pink', label: 'Pink', color: '#ff69b4'},
    {val: 'cyan', label: 'Cyan', color: '#4affff'},
    {val: 'graphite', label: 'Graphite', color: '#8a8a8a'},
    {val: 'black', label: 'Black', color: '#262626'},
    {val: 'lightgrey', label: 'Light Grey', color: '#e6e6e6'},
    {val: 'custom', label: 'Custom Color...', color: '#ffd700'}  // ‚≠ê NEW - Add this line
].map(c => `
                                    <div class="hwh-color-option" data-value="${c.val}" data-color="${c.color}" data-label="${c.label}" style="
                                        padding: 8px 10px;
                                        cursor: pointer;
                                        display: flex;
                                        align-items: center;
                                        gap: 8px;
                                        color: #fff;
                                    ">
                                        <span style="display: inline-block; width: 16px; height: 16px; background: ${c.color}; border: 1px solid rgba(255,255,255,0.3); border-radius: 3px;"></span>
                                        ${c.label}
                                    </div>
                                `).join('')}
</div>
</div>
<input type="hidden" id="hwh-edit-color" value="${currentColor || ''}" />
    <input type="hidden" id="hwh-edit-custom-color" value="${currentCustomColor}" />


        <!-- ‚≠ê NEW: Custom Color Input Section (hidden by default) -->
        <div id="hwh-custom-color-section" style="display: none; margin-top: 8px;">
            <label style="display: block; margin-bottom: 6px; color: #3498db; font-weight: 600; font-size: 13px;">
                Custom Color (Hex)
</label>
<div style="display: flex; gap: 8px; align-items: center;">
    <input type="color" id="hwh-custom-color-picker"
value="${currentCustomColor}"
style="
width: 50px;
height: 36px;
border: 2px solid rgba(255,255,255,0.2);
border-radius: 6px;
cursor: pointer;
background: rgba(0,0,0,0.4);
" />
<input type="text" id="hwh-custom-color-input"
value="${currentCustomColor}"
placeholder="#ffd700"
maxlength="7"
style="
flex: 1;
padding: 8px;
background: rgba(0,0,0,0.4);
border: 2px solid rgba(255,255,255,0.2);
border-radius: 6px;
color: #fff;
font-family: monospace;
font-size: 13px;
" />
</div>
<small style="color: #999; font-size: 11px;">
    Enter hex color (e.g., #ff5733) or use the color picker
        </small>
</div>
</div>

<!-- ‚≠ê NEW: FONT SIZE FIELD - ADD HERE ‚≠ê -->
<div class="hwh-func-edit-field" style="margin-bottom: 16px;">
    <label style="display: block; margin-bottom: 6px; color: #3498db; font-weight: 600; font-size: 14px;">
        Text Size
            </label>
<div style="display: flex; gap: 12px; align-items: center;">
    <input type="range" id="hwh-edit-font-size" min="10" max="20"
value="${currentFontSize}"
style="flex: 1; cursor: pointer;" />
    <span id="hwh-font-size-value" style="color: #ffd700; font-weight: bold; min-width: 45px;">
        ${currentFontSize}px
            </span>
<button id="hwh-reset-button-font-size" style="
padding: 4px 12px;
background: #8b6914;
border: none;
border-radius: 4px;
color: #ffd700;
cursor: pointer;
font-size: 12px;
">Reset</button>
</div>
<small style="color: #999; font-size: 11px;">
    Individual button text size (resets to global default)
</small>
</div>
</div>


${!canEditAction ? `
                    <div style="
                        background: rgba(52, 152, 219, 0.15);
                        border-left: 4px solid #3498db;
                        padding: 12px;
                        border-radius: 4px;
                        color: #fff;
                        font-size: 13px;
                        line-height: 1.5;
                        margin-bottom: 16px;
                    ">
                        üîí <strong>Default functions</strong> cannot have their action code modified.<br>
                        You can edit icon, color, and description.<br>
                        Use <strong>Clone</strong> to create an editable copy.
                    </div>
                ` : `
                    <div class="hwh-func-edit-field">
                        <label style="display: block; margin-bottom: 6px; color: #3498db; font-weight: 600; font-size: 14px;">
                            Action Code (JavaScript function)
                        </label>
                        <textarea id="hwh-edit-action" rows="12" style="
                            width: 100%;
                            padding: 10px;
                            background: rgba(0, 0, 0, 0.4);
                            border: 2px solid rgba(255, 255, 255, 0.2);
                            border-radius: 6px;
                            color: #fff;
                            font-size: 13px;
                            font-family: 'Courier New', Consolas, monospace;
                            box-sizing: border-box;
                            resize: vertical;
                            line-height: 1.5;
                        ">${currentAction}</textarea>
                        <small style="color: #999; font-size: 11px;">
                            <strong>Example:</strong> () => { cheats.goNavigtor('ARENA'); alert('Going to Arena!'); }
                        </small>
                    </div>
                `}
</div>

<div class="hwh-func-edit-footer" style="
display: flex;
justify-content: flex-end;
gap: 10px;
padding: 16px 20px;
border-top: 2px solid rgba(255, 255, 255, 0.1);
background: rgba(0,0,0,0.3);
">
<button class="hwh-editor-btn-large hwh-editor-btn-cancel" style="
padding: 10px 20px;
border: none;
border-radius: 6px;
cursor: pointer;
font-size: 14px;
font-weight: 700;
background: #95a5a6;
color: white;
transition: all 0.2s;
">Cancel</button>
${!isNew ? `<button class="hwh-editor-btn-large hwh-editor-btn-test" style="
                    padding: 10px 20px;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 700;
                    background: #f39c12;
                    color: white;
                    transition: all 0.2s;
                ">üß™ Test</button>` : ''}
<button class="hwh-editor-btn-large hwh-editor-btn-save" style="
padding: 10px 20px;
border: none;
border-radius: 6px;
cursor: pointer;
font-size: 14px;
font-weight: 700;
background: #2ecc71;
color: white;
transition: all 0.2s;
">üíæ Save</button>
</div>
</div>
`;

                PerfLog.end('editFunction-inner');
                PerfLog.start('appendChild+events');
                document.body.appendChild(dialog);


                debugLog('‚úÖ Edit dialog created with z-index:', dialog.style.zIndex);

                // Close handlers
                const close = () => {
                    dialog.remove();
                    debugLog('‚ùå Dialog closed');
                };

                dialog.querySelector('.hwh-func-edit-close').onclick = close;
                dialog.querySelector('.hwh-func-edit-overlay').onclick = close;
                dialog.querySelector('.hwh-editor-btn-cancel').onclick = close;
                // Color picker event handlers
                const colorDisplay = dialog.querySelector('#hwh-edit-color-display');
                const colorOptions = dialog.querySelector('#hwh-edit-color-options');
                const colorInput = dialog.querySelector('#hwh-edit-color');

                colorDisplay.onclick = () => {
                    colorOptions.style.display = colorOptions.style.display === 'none' ? 'block' : 'none';
                };

                // Get references needed by handlers (declare once, use everywhere)
                const previewBtn = dialog.querySelector('#hwh-func-preview-button');
                const iconInput = dialog.querySelector('#hwh-edit-icon');
                const customColorSection = dialog.querySelector('#hwh-custom-color-section');
                const customColorHidden = dialog.querySelector('#hwh-edit-custom-color');

                // Show custom color section on load if color is 'custom'
                if (currentColor === 'custom' && customColorSection) {
                    customColorSection.style.display = 'block';
                }

                // ‚≠ê MODIFIED: Color option click handler
                dialog.querySelectorAll('.hwh-color-option').forEach(opt => {
                    opt.onmouseover = () => opt.style.background = 'rgba(255,255,255,0.1)';
                    opt.onmouseout = () => opt.style.background = 'transparent';

                    opt.onclick = () => {
                        const val = opt.dataset.value;
                        const color = opt.dataset.color;
                        const label = opt.dataset.label;

                        // Update hidden input
                        colorInput.value = val;

                        // Update color display square and label
                        colorDisplay.querySelector('.hwh-color-square').style.background = color;
                        colorDisplay.querySelector('.hwh-color-label').textContent = label;

                        // Close dropdown
                        colorOptions.style.display = 'none';

                        // ‚≠ê NEW: Show/hide custom color section based on selection
                        if (val === 'custom') {
                            // Show custom color section
                            customColorSection.style.display = 'block';

                            // Get saved custom color or default
                            const customColor = customColorHidden.value || '#ffd700';

                            // Update preview with custom color
                            if (previewBtn) {
                                previewBtn.style.background = customColor;
                            }
                        } else {
                            // Hide custom color section for preset colors
                            customColorSection.style.display = 'none';

                            // Update preview with preset color
                            if (previewBtn) {
                                previewBtn.style.background = color;
                            }
                        }
                    };
                });

                // Close color picker when clicking outside
                document.addEventListener('click', function colorPickerClose(e) {
                    if (!e.target.closest('.hwh-color-picker')) {
                        colorOptions.style.display = 'none';
                    }
                });


                // ==========================================
                // ‚≠ê NEW: CUSTOM COLOR PICKER HANDLERS
                // ==========================================
                const customColorPicker = dialog.querySelector('#hwh-custom-color-picker');
                const customColorInput = dialog.querySelector('#hwh-custom-color-input');

                if (customColorPicker && customColorInput) {
                    // HTML5 color picker handler
                    customColorPicker.oninput = () => {
                        // Sync to text input
                        customColorInput.value = customColorPicker.value;

                        // Update hidden input (for saving)
                        customColorHidden.value = customColorPicker.value;

                        // Update preview button background in real-time
                        if (previewBtn) {
                            previewBtn.style.background = customColorPicker.value;
                        }
                    };

                    // Text input handler (hex code)
                    customColorInput.oninput = () => {
                        // Validate hex format: #RRGGBB
                        if (/^#[0-9A-F]{6}$/i.test(customColorInput.value)) {
                            // Valid hex - sync to color picker
                            customColorPicker.value = customColorInput.value;

                            // Update hidden input
                            customColorHidden.value = customColorInput.value;

                            // Update preview button
                            if (previewBtn) {
                                previewBtn.style.background = customColorInput.value;
                            }
                        }
                        // If invalid hex, don't update (user is still typing)
                    };
                }

                // ==========================================
                // ‚≠ê NEW: FONT SIZE SLIDER HANDLER - ADD HERE
                // ==========================================
                const fontSizeSlider = dialog.querySelector('#hwh-edit-font-size');
                const fontSizeValue = dialog.querySelector('#hwh-font-size-value');
                const resetFontSizeBtn = dialog.querySelector('#hwh-reset-button-font-size');

                if (fontSizeSlider && fontSizeValue) {
                    fontSizeSlider.oninput = () => {
                        // Update the display value next to slider
                        fontSizeValue.textContent = fontSizeSlider.value + 'px';

                        // Update preview button font size in real-time
                        if (previewBtn) {
                            previewBtn.style.fontSize = fontSizeSlider.value + 'px';
                        }
                    };
                }

                if (resetFontSizeBtn) {
                    resetFontSizeBtn.onclick = () => {
                        // Get global font size (or default 14)
                        const globalSize = localStorage.getItem('hwh_global_font_size') || '14';

                        // Reset slider and display to global size
                        fontSizeSlider.value = globalSize;
                        fontSizeValue.textContent = globalSize + 'px';

                        // Update preview button
                        if (previewBtn) {
                            previewBtn.style.fontSize = globalSize + 'px';
                        }
                    };
                }

                // ==========================================
                // ‚≠ê NEW: ICON INPUT HANDLER - UPDATES PREVIEW
                // ==========================================


                if (iconInput && previewBtn) {
                    iconInput.oninput = () => {
                        const nameDisplay = dialog.querySelector('#hwh-edit-name') ?
                              dialog.querySelector('#hwh-edit-name').value : name;
                        previewBtn.innerHTML = `${iconInput.value} ${nameDisplay}`;
                    };
                }

                // Test button handler
                const testBtn = dialog.querySelector('.hwh-editor-btn-test');
                if (testBtn) {
                    testBtn.onclick = () => {
                        debugLog('üß™ Testing function:', name);
                        dialog.style.display = 'none';

                        const unifiedEditor = document.getElementById('hwh-unified-editor');
                        if (unifiedEditor) unifiedEditor.style.display = 'none';

                        const returnOverlay = document.createElement('div');
                        returnOverlay.style.cssText = `
                position: fixed;
top: 10px;
right: 10px;
z-index: 2147483646;
background: rgba(0, 0, 0, 0.9);
border: 2px solid #f39c12;
border-radius: 8px;
padding: 15px;
box-shadow: 0 4px 12px rgba(0,0,0,0.5);
`;
                        returnOverlay.innerHTML = `
                <div style="color: #f39c12; font-weight: bold; margin-bottom: 10px; font-size: 14px;">
                    üß™ Testing: ${name}
</div>
<button id="hwh-test-return-btn" style="
width: 100%;
padding: 10px 20px;
background: #f39c12;
border: none;
border-radius: 6px;
color: white;
font-weight: bold;
cursor: pointer;
font-size: 14px;
">‚¨ÖÔ∏è Return to Editor</button>
`;
                        document.body.appendChild(returnOverlay);

                        document.getElementById('hwh-test-return-btn').onclick = () => {
                            returnOverlay.remove();
                            dialog.style.display = 'flex';
                            if (unifiedEditor) unifiedEditor.style.display = 'flex';
                        };

                        try {
                            const testFunc = BUTTON_FUNCTIONS[name];
                            if (testFunc && testFunc.action) {
                                testFunc.action();
                            }
                        } catch (err) {
                            console.error('Test error:', err);
                            alert('‚ùå Test failed: ' + err.message);
                            returnOverlay.remove();
                            dialog.style.display = 'flex';
                            if (unifiedEditor) unifiedEditor.style.display = 'flex';
                        }
                    };
                }

                // Save handler
                dialog.querySelector('.hwh-editor-btn-save').onclick = () => {
                    const newName = document.getElementById('hwh-edit-name').value.trim();
                    const newDesc = document.getElementById('hwh-edit-desc').value.trim();
                    const newIcon = document.getElementById('hwh-edit-icon').value.trim();
                    const newColor = document.getElementById('hwh-edit-color').value;
                    const newFontSize = document.getElementById('hwh-edit-font-size').value;
                    const newCustomColor = document.getElementById('hwh-edit-custom-color').value;  // ‚≠ê NEW
                    // DEBUG: Log what we're saving
                    debugLog('====== BUTTON EDITOR SAVE ======');
                    debugLog('Button name:', name);
                    debugLog('canEditAction:', canEditAction);
                    debugLog('newColor:', newColor);
                    debugLog('newFontSize:', newFontSize);
                    debugLog('newCustomColor:', newCustomColor);
                    debugLog('================================');
                    if (!newName) {
                        alert('‚ùå Function ID is required!');
                        return;
                    }

                    if (canEditAction && newName !== name && BUTTON_FUNCTIONS[newName]) {
                        alert('‚ùå A function with that ID already exists!');
                        return;
                    }

                    try {
                        let action = func?.action;

                        if (canEditAction) {
                            const actionCode = document.getElementById('hwh-edit-action').value.trim();
                            action = eval(`(${actionCode})`);

                            if (typeof action !== 'function') {
                                alert('‚ùå Action must be a valid function!');
                                return;
                            }
                        }

                        const finalName = canEditAction ? newName : name;

                        if (!canEditAction) {
                            // Editing built-in button - save to customizations
                            if (!window.buttonCustomizations[name]) {
                                window.buttonCustomizations[name] = {};
                            }
                            window.buttonCustomizations[name].icon = newIcon;
                            window.buttonCustomizations[name].color = newColor;
                            window.buttonCustomizations[name].description = newDesc;
                            window.buttonCustomizations[name].fontSize = newFontSize;

                            // Save custom color if "custom" is selected
                            if (newColor === 'custom' && newCustomColor) {
                                window.buttonCustomizations[name].customColor = newCustomColor;
                            } else {
                                // Clear custom color if not using it
                                delete window.buttonCustomizations[name].customColor;
                            }

                            saveButtonCustomizations(window.buttonCustomizations);

                            debugLog(`Saved customization for "${name}"`);
                            // DEBUG: Show what was actually saved
                            debugLog('Saved to window.buttonCustomizations:', window.buttonCustomizations[name]);
                        } else {
                            // Creating/editing custom function
                            BUTTON_FUNCTIONS[finalName] = {
                                action,
                                icon: newIcon,
                                color: newColor,
                                description: newDesc,
                                fontSize: newFontSize,
                                customColor: newColor === 'custom' ? newCustomColor : null,
                                isCustom: true
                            };

                            if (name !== finalName && func) {
                                delete BUTTON_FUNCTIONS[name];
                            }

                            saveCustomFunctions();
                        }

                        this.renderFunctions();
                        this.renderLayout();

                        // Re-render sidebar buttons to apply customizations
                        if (this.sidebar && this.sidebar.renderButtons) {
                            this.sidebar.renderButtons();
                        }

                        close();

                    } catch (e) {
                        alert('‚ùå Invalid function code: ' + e.message);
                        console.error('Save error:', e);
                    }
                };
                PerfLog.end('appendChild+events');
            }
            // ============================================================================
            // END OF SECTION 1
            // Continue with the rest of your file (Style Tab section starts next)
            // ============================================================================

            // ========================================================================
            // STYLE TAB
            // ========================================================================

            initStyleTab() {
                this.renderStyle();
            }

            renderStyle() {
                const preview = document.getElementById('hwh-style-preview');
                const options = document.getElementById('hwh-style-options');
                if (!preview || !options) return;

                const currentFontSize = localStorage.getItem('hwh_global_font_size') || '14';
                const currentTabFontSize = localStorage.getItem('hwh_tab_font_size') || '10';

                // Preview column
                preview.innerHTML = `
                    <div class="hwh-style-current">
                        <strong>Active:</strong> ${this.tempStyle === 'flat' ? '‚¨ú Flat' : 'üéÆ Game'}
</div>

<div class="hwh-style-section" style="margin-top: 16px;">
    <label style="display: block; margin-bottom: 8px; color: #3498db; font-weight: 600; font-size: 14px;">
        üî§ Global Text Size
            </label>
<div style="display: flex; align-items: center; gap: 12px;">
    <input
type="range"
id="hwh-global-font-size"
min="10"
max="20"
value="${currentFontSize}"
style="flex: 1; cursor: pointer;" />
    <span
id="hwh-font-size-display"
style="color: #ffd700; font-weight: bold; min-width: 45px;">
    ${currentFontSize}px
        </span>
<button
id="hwh-reset-font-size"
style="padding: 4px 12px; background: #8b6914; border: none; border-radius: 4px; color: #ffd700; cursor: pointer; font-size: 12px;">
    Reset
</button>
</div>
<small style="color: #999; font-size: 11px; display: block; margin-top: 4px;">
    Adjusts text size for all buttons (including custom) by same amount
        </small>
<button
id="hwh-manage-button-sizes"
style="margin-top: 8px; padding: 6px 12px; background: #5a4a2a; border: 1px solid #8b6914; border-radius: 4px; color: #ffd700; cursor: pointer; font-size: 12px;">
    üîß Manage Button Sizes...
        </button>
</div>

<div class="hwh-style-section" style="margin-top: 16px;">
    <label style="display: block; margin-bottom: 8px; color: #3498db; font-weight: 600; font-size: 14px;">
        üìë Tab Text Size
            </label>
<div style="display: flex; align-items: center; gap: 12px;">
    <input
type="range"
id="hwh-tab-font-size"
min="8"
max="16"
value="${currentTabFontSize}"
style="flex: 1; cursor: pointer;" />
    <span
id="hwh-tab-font-display"
style="color: #ffd700; font-weight: bold; min-width: 45px;">
    ${currentTabFontSize}px
        </span>
<button
id="hwh-reset-tab-font"
style="padding: 4px 12px; background: #8b6914; border: none; border-radius: 4px; color: #ffd700; cursor: pointer; font-size: 12px;">
    Reset
</button>
</div>
<small style="color: #999; font-size: 11px; display: block; margin-top: 4px;">
    Adjusts text size for tab labels at the top of the sidebar
        </small>
</div>
`;

                // Right-side style options
                options.innerHTML = `
                    <div class="hwh-style-option ${this.tempStyle === 'flat' ? 'active' : ''}" data-style="flat">
                        <div class="hwh-style-option-preview hwh-style-flat-preview">
                            <div class="sample-btn">Button</div>
</div>
<div class="hwh-style-option-name">‚¨ú Flat Style</div>
<div class="hwh-style-option-desc">Clean, modern, minimal design</div>
</div>

<div class="hwh-style-option ${this.tempStyle === 'game' ? 'active' : ''}" data-style="game">
    <div class="hwh-style-option-preview hwh-style-game-preview">
        <div class="sample-btn">Button</div>
</div>
<div class="hwh-style-option-name">üéÆ Game Style</div>
<div class="hwh-style-option-desc">Rich, textured, game-themed design</div>
</div>
`;

                // Global font size controls
                const slider   = document.getElementById('hwh-global-font-size');
                const display  = document.getElementById('hwh-font-size-display');
                const resetBtn = document.getElementById('hwh-reset-font-size');
                const manageBtn = document.getElementById('hwh-manage-button-sizes');

                // Tab font size controls
                const tabSlider   = document.getElementById('hwh-tab-font-size');
                const tabDisplay  = document.getElementById('hwh-tab-font-display');
                const tabResetBtn = document.getElementById('hwh-reset-tab-font');


                // Store ORIGINAL values when Style tab renders (not "last" values)
                const originalGlobalFontSize = parseInt(localStorage.getItem('hwh_global_font_size') || '14');
                const originalCustomSizes = {};
                if (window.buttonCustomizations) {
                    Object.keys(window.buttonCustomizations).forEach(name => {
                        const custom = window.buttonCustomizations[name];
                        if (custom.fontSize !== undefined && custom.fontSize !== null) {
                            originalCustomSizes[name] = parseInt(custom.fontSize);  // ADD parseInt()
                        }
                    });
                }

                if (slider && display) {
                    slider.oninput = () => {
                        const newValue = parseInt(slider.value);
                        const delta = newValue - originalGlobalFontSize;

                        display.textContent = newValue + 'px';
                        localStorage.setItem('hwh_global_font_size', newValue);

                        // Apply delta from ORIGINAL sizes, not current sizes
                        Object.keys(originalCustomSizes).forEach(name => {
                            if (window.buttonCustomizations[name]) {
                                window.buttonCustomizations[name].fontSize = Math.max(8, Math.min(24, originalCustomSizes[name] + delta));
                            }
                        });

                        if (Object.keys(originalCustomSizes).length > 0) {
                            saveButtonCustomizations(window.buttonCustomizations);
                        }

                        this.applyGlobalFontSize(newValue);
                    };
                }

                if (resetBtn && slider && display) {
                    resetBtn.onclick = () => {
                        const value = '14';
                        slider.value = value;
                        display.textContent = value + 'px';
                        localStorage.setItem('hwh_global_font_size', value);
                        // DELETE: lastGlobalFontSize = 14;
                        this.applyGlobalFontSize(value);
                    };
                }
                if (manageBtn) {
                    manageBtn.onclick = () => this.showButtonSizeManager();
                }

                if (tabSlider && tabDisplay) {
                    tabSlider.oninput = () => {
                        const value = tabSlider.value;
                        tabDisplay.textContent = value + 'px';
                        localStorage.setItem('hwh_tab_font_size', value);
                        this.applyTabFontSize(value);
                    };
                }

                if (tabResetBtn && tabSlider && tabDisplay) {
                    tabResetBtn.onclick = () => {
                        const value = '10';
                        tabSlider.value = value;
                        tabDisplay.textContent = value + 'px';
                        localStorage.setItem('hwh_tab_font_size', value);
                        this.applyTabFontSize(value);
                    };
                }

                // Style option click handler
                options.onclick = (e) => {
                    const option = e.target.closest('.hwh-style-option');
                    if (!option) return;

                    this.tempStyle = option.dataset.style;

                    if (this.sidebar && this.sidebar.applyStyle) {
                        this.sidebar.style = this.tempStyle;
                        this.sidebar.applyStyle();
                    }

                    // Re-render to update which option is highlighted, etc.
                    this.renderStyle();
                };
            }

            applyGlobalFontSize(size) {
                if (this.sidebar && this.sidebar.renderButtons) {
                    this.sidebar.renderButtons();
                }
                debugLog('üî§ Applied global font size:', size + 'px');
            }

            // Line 22548-22554 - WRONG TARGET
            applyTabFontSize(size) {
                const tabs = document.querySelectorAll('.hwh-tab');
                tabs.forEach(tab => {
                    tab.style.fontSize = size + 'px';
                });
            }
            showButtonSizeManager() {
                // Get all buttons with custom font sizes
                const customizations = window.buttonCustomizations || {};
                const globalSize = parseInt(localStorage.getItem('hwh_global_font_size') || '14');

                // Build list of all buttons in current tabs
                const allButtons = new Set();
                if (this.sidebar && this.sidebar.tabs) {
                    this.sidebar.tabs.forEach(tab => {
                        if (tab.rows) {
                            tab.rows.forEach(row => {
                                const buttons = Array.isArray(row) ? row : (row.buttons || []);
                                buttons.forEach(btn => allButtons.add(btn));
                            });
                        }
                    });
                }

                // Find buttons with custom sizes
                const buttonsWithCustomSize = [];
                allButtons.forEach(name => {
                    const custom = customizations[name];
                    if (custom && custom.fontSize !== undefined && custom.fontSize !== null) {
                        buttonsWithCustomSize.push({
                            name: name,
                            size: custom.fontSize,
                            icon: custom.icon || name
                        });
                    }
                });

                // Create popup
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);z-index:1000002;display:flex;align-items:center;justify-content:center;';

                const popup = document.createElement('div');
                popup.style.cssText = 'background:#2a2a2a;border:2px solid #8b6914;border-radius:8px;padding:20px;max-width:500px;max-height:80vh;overflow-y:auto;color:#fff;';

                let html = `
        <h3 style="margin:0 0 15px 0;color:#ffd700;border-bottom:1px solid #8b6914;padding-bottom:10px;">
            üîß Manage Button Font Sizes
                </h3>
<p style="color:#999;font-size:12px;margin-bottom:15px;">
    Global size: <strong style="color:#ffd700;">${globalSize}px</strong> ‚Äî
Buttons below have custom sizes that override the global setting.
    </p>
`;

                if (buttonsWithCustomSize.length === 0) {
                    html += '<p style="color:#888;text-align:center;padding:20px;">No buttons have custom font sizes.</p>';
                } else {
                    html += `
            <div style="margin-bottom:10px;">
                <label style="display:flex;align-items:center;gap:8px;cursor:pointer;padding:8px;background:#3a3a3a;border-radius:4px;">
                    <input type="checkbox" id="hwh-size-select-all" style="width:16px;height:16px;">
                        <span style="color:#ffd700;font-weight:bold;">Select All (${buttonsWithCustomSize.length} buttons)</span>
</label>
</div>
<div style="max-height:300px;overflow-y:auto;border:1px solid #444;border-radius:4px;">
    `;

                    buttonsWithCustomSize.forEach((btn, index) => {
                        const diff = btn.size - globalSize;
                        const diffText = diff > 0 ? '+' + diff : diff.toString();
                        const diffColor = diff > 0 ? '#4a4' : (diff < 0 ? '#a44' : '#888');

                        html += '<label style="display:flex;align-items:center;gap:10px;padding:10px;border-bottom:1px solid #333;cursor:pointer;' + (index % 2 === 0 ? 'background:#2d2d2d;' : '') + '">' +
                            '<input type="checkbox" class="hwh-size-checkbox" data-button="' + btn.name + '" style="width:16px;height:16px;">' +
                            '<span style="flex:1;color:#ddd;">' + btn.icon + '</span>' +
                            '<span style="color:#ffd700;min-width:50px;text-align:right;">' + btn.size + 'px</span>' +
                            '<span style="color:' + diffColor + ';min-width:40px;text-align:right;font-size:11px;">(' + diffText + ')</span>' +
                            '</label>';
                    });

                    html += '</div>';
                }

                html += `
        <div style="display:flex;gap:10px;margin-top:15px;justify-content:flex-end;">
            <button id="hwh-size-cancel" style="padding:8px 16px;background:#555;border:none;border-radius:4px;color:#fff;cursor:pointer;">
                Cancel
</button>
${buttonsWithCustomSize.length > 0 ? '<button id="hwh-size-reset" style="padding:8px 16px;background:#8b4444;border:none;border-radius:4px;color:#fff;cursor:pointer;">Reset Selected to Global</button>' : ''}
</div>
`;

                popup.innerHTML = html;
                overlay.appendChild(popup);
                document.body.appendChild(overlay);

                // Event handlers
                overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
                document.getElementById('hwh-size-cancel').onclick = () => overlay.remove();

                const selectAll = document.getElementById('hwh-size-select-all');
                if (selectAll) {
                    selectAll.onclick = () => {
                        const checkboxes = popup.querySelectorAll('.hwh-size-checkbox');
                        checkboxes.forEach(cb => cb.checked = selectAll.checked);
                    };
                }

                const resetBtn = document.getElementById('hwh-size-reset');
                if (resetBtn) {
                    resetBtn.onclick = () => {
                        const checkboxes = popup.querySelectorAll('.hwh-size-checkbox:checked');
                        if (checkboxes.length === 0) {
                            alert('Please select at least one button to reset.');
                            return;
                        }

                        let resetCount = 0;
                        checkboxes.forEach(cb => {
                            const name = cb.dataset.button;
                            if (customizations[name]) {
                                delete customizations[name].fontSize;
                                resetCount++;
                            }
                        });

                        saveButtonCustomizations(customizations);

                        if (this.sidebar && this.sidebar.renderButtons) {
                            this.sidebar.renderButtons();
                        }

                        overlay.remove();
                        alert('‚úÖ Reset ' + resetCount + ' button(s) to global size (' + globalSize + 'px)');
                    };
                }
            }

            // ========================================================================
            // IMPORT/EXPORT TAB
            // ========================================================================

            initImportExportTab() {
                document.getElementById('hwh-export-all').onclick = () => this.exportAll();
                document.getElementById('hwh-export-layout').onclick = () => this.exportLayout();
                document.getElementById('hwh-export-functions').onclick = () => this.exportFunctions();
                document.getElementById('hwh-export-style').onclick = () => this.exportStyle();

                document.getElementById('hwh-import-file').onclick = () => this.importFile();
                document.getElementById('hwh-import-clipboard').onclick = () => this.importClipboard();

                document.getElementById('hwh-reset-layout').onclick = () => this.resetLayout();
                document.getElementById('hwh-reset-functions').onclick = () => this.resetFunctions();
                document.getElementById('hwh-reset-all').onclick = () => this.resetAll();
            }

            exportAll() {
                // Build buttonCustomizations from BUTTON_FUNCTIONS if not already populated
                const customizations = window.buttonCustomizations || {};
                Object.keys(BUTTON_FUNCTIONS).forEach(name => {
                    const func = BUTTON_FUNCTIONS[name];
                    // If this button has customization data in BUTTON_FUNCTIONS but not in buttonCustomizations, add it
                    if (!customizations[name] && (func.icon || func.color || func.description || func.fontSize || func.customColor)) {
                        customizations[name] = {
                            icon: func.icon || '',
                            color: func.color || '',
                            description: func.description || ''
                        };
                        if (func.fontSize) customizations[name].fontSize = func.fontSize;
                        if (func.customColor) customizations[name].customColor = func.customColor;
                    }
                });

                const data = {
                    version: '1.0',
                    exported: new Date().toISOString(),
                    tabs: this.tempTabs,
                    style: this.tempStyle,
                    functions: this.exportFunctionsData(),
                    buttonCustomizations: customizations,
                    globalFontSize: localStorage.getItem('hwh_global_font_size') || '14',
                };

                this.downloadJSON(data, 'hwh_complete_settings');
                alert('‚úÖ Complete settings exported!');
            }

            exportLayout() {
                const data = {
                    version: '1.0',
                    exported: new Date().toISOString(),
                    tabs: this.tempTabs,  // Changed from layout: this.tempLayout
                    style: this.tempStyle,
                    buttonCustomizations: window.buttonCustomizations || {},
                    globalFontSize: localStorage.getItem('hwh_global_font_size') || '14'
                };

                this.downloadJSON(data, 'hwh_layout');
                alert('‚úÖ Layout exported!');
            }




            exportFunctions() {
                const customOnly = confirm('Export only custom functions?\n\nOK = Custom only\nCancel = All');
                const data = this.exportFunctionsData(customOnly);

                this.downloadJSON(data, customOnly ? 'hwh_custom_functions' : 'hwh_all_functions');
                alert(`‚úÖ Exported ${Object.keys(data).length} functions!`);
            }

            exportFunctionsData(customOnly = false) {
                const toExport = {};
                Object.keys(BUTTON_FUNCTIONS).forEach(name => {
                    const func = BUTTON_FUNCTIONS[name];
                    if (!customOnly || func.isCustom) {
                        toExport[name] = {
                            actionCode: func.action.toString(),
                            icon: func.icon,
                            color: func.color,
                            description: func.description,
                            isCustom: func.isCustom || false
                        };
                    }
                });
                return toExport;
            }

            exportStyle() {
                const data = {
                    version: '1.0',
                    exported: new Date().toISOString(),
                    style: this.tempStyle
                };

                this.downloadJSON(data, 'hwh_style');
                alert('‚úÖ Style exported!');
            }

            downloadJSON(data, filename) {
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${filename}_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            importFile() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            this.processImport(data);
                        } catch (err) {
                            alert('‚ùå Import failed: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            }

            importClipboard() {
                navigator.clipboard.readText().then(text => {
                    try {
                        const data = JSON.parse(text);
                        this.processImport(data);
                    } catch (e) {
                        alert('‚ùå Invalid JSON in clipboard: ' + e.message);
                    }
                }).catch(err => {
                    alert('‚ùå Could not read clipboard: ' + err.message);
                });
            }

            processImport(data) {
                // Detect import type
                if ((data.tabs || data.layout) && data.functions) {
                    // Complete settings
                    if (confirm('Import complete settings? This will replace layout, functions, and style.')) {
                        this.importComplete(data);
                    }
                } else if (data.tabs || data.layout) {
                    // Layout only
                    if (confirm('Import layout and style?')) {
                        this.importLayoutData(data);
                    }
                } else if (Object.keys(data).some(k => data[k].actionCode)) {
                    // Functions only
                    if (confirm('Import functions?')) {
                        this.importFunctionsData(data);
                    }
                } else if (data.style) {
                    // Style only
                    if (confirm('Import style?')) {
                        this.tempStyle = data.style;
                        this.renderStyle();
                        alert('‚úÖ Style imported!');
                    }
                } else {
                    alert('‚ùå Unknown import format!');
                }
            }

            importComplete(data) {
                this.importLayoutData(data);
                this.importFunctionsData(data.functions);
                if (data.buttonCustomizations) {
                    window.buttonCustomizations = data.buttonCustomizations;
                    saveButtonCustomizations(window.buttonCustomizations);
                }
                if (data.globalFontSize) {
                    localStorage.setItem('hwh_global_font_size', data.globalFontSize);
                }
                alert('‚úÖ Complete settings imported!');
            }

            importLayoutData(data) {
                // Handle new tabs format or legacy layout format
                if (data.tabs) {
                    this.tempTabs = data.tabs;
                    this.activeEditTabIndex = 0;
                    this.renderTabBar();  // Re-render tab bar
                    this.renderLayout();
                } else if (data.layout) {
                    // Legacy format - convert to single tab
                    this.tempTabs = [{ name: 'Main', rows: data.layout }];
                    this.activeEditTabIndex = 0;
                    this.renderTabBar();
                    this.renderLayout();
                }
                if (data.style) {
                    this.tempStyle = data.style;
                    this.renderStyle();
                }
                if (data.buttonCustomizations) {
                    window.buttonCustomizations = data.buttonCustomizations;
                    saveButtonCustomizations(window.buttonCustomizations);
                }
                if (data.globalFontSize) {
                    localStorage.setItem('hwh_global_font_size', data.globalFontSize);
                }
                alert('‚úÖ Layout imported!');
            }
            importFunctionsData(data) {
                let count = 0;
                if (!window.buttonCustomizations) window.buttonCustomizations = {};

                Object.keys(data).forEach(name => {
                    const func = data[name];
                    try {
                        const action = eval(`(${func.actionCode})`);
                        BUTTON_FUNCTIONS[name] = {
                            action,
                            icon: func.icon,
                            color: func.color,
                            description: func.description,
                            isCustom: func.isCustom !== false
                        };

                        // Also update buttonCustomizations if icon/color/description/fontSize are present
                        if (func.icon || func.color || func.description || func.fontSize || func.customColor) {
                            window.buttonCustomizations[name] = {
                                icon: func.icon || '',
                                color: func.color || '',
                                description: func.description || ''
                            };
                            if (func.fontSize) {
                                window.buttonCustomizations[name].fontSize = func.fontSize;
                            }
                            if (func.customColor) {
                                window.buttonCustomizations[name].customColor = func.customColor;
                            }
                        }

                        count++;
                    } catch (e) {
                        console.error(`Failed to import "${name}":`, e);
                    }
                });

                // Save the updated customizations
                saveButtonCustomizations(window.buttonCustomizations);

                // Refresh buttons if sidebar exists
                if (this.sidebar && this.sidebar.renderButtons) {
                    this.sidebar.renderButtons();
                }

                alert(`‚úÖ Imported ${count} functions!`);
            }

            resetLayout() {
                if (!confirm('Reset layout to defaults? This cannot be undone!')) return;

                this.tempLayout = JSON.parse(JSON.stringify(DEFAULT_LAYOUT));
                this.renderLayout();
                alert('‚úÖ Layout reset!');
            }

            resetFunctions() {
                if (!confirm('Delete ALL custom functions? This cannot be undone!')) return;

                Object.keys(BUTTON_FUNCTIONS).forEach(name => {
                    if (BUTTON_FUNCTIONS[name].isCustom) {
                        delete BUTTON_FUNCTIONS[name];
                    }
                });

                localStorage.removeItem('hwh_custom_functions');
                this.renderFunctions();
                alert('‚úÖ Custom functions deleted!');
            }

            resetAll() {
                if (!confirm('Reset EVERYTHING to defaults? This cannot be undone!')) return;

                this.resetLayout();
                this.resetFunctions();
                this.tempStyle = 'game';
                this.renderStyle();
                alert('‚úÖ Everything reset!');
            }

            // ========================================================================
            // SAVE ALL
            // ========================================================================

            saveAll() {
                // Clean each tab's layout
                this.tempTabs = this.tempTabs.map(tab => {
                    const cleanedRows = (tab.rows || []).filter(row => {
                        if (typeof row === 'object' && row.buttons) {
                            return Array.isArray(row.buttons) && row.buttons.length > 0;
                        }
                        return Array.isArray(row) && row.length > 0;
                    }).map(row => {
                        if (typeof row === 'object' && row.buttons) {
                            const cleanedButtons = row.buttons.filter(btn => {
                                const name = typeof btn === 'string' ? btn : btn.name;
                                return BUTTON_FUNCTIONS[name];
                            });
                            if (cleanedButtons.length > 0) {
                                return {
                                    name: row.name || '',
                                    hidden: row.hidden || false,
                                    buttons: cleanedButtons
                                };
                            }
                            return null;
                        }
                        const cleanedButtons = row.filter(btn => {
                            const name = typeof btn === 'string' ? btn : btn.name;
                            return BUTTON_FUNCTIONS[name];
                        });
                        return cleanedButtons.length > 0 ? cleanedButtons : null;
                    }).filter(row => row !== null);

                    return {
                        name: tab.name,
                        rows: cleanedRows
                    };
                }).filter(tab => tab.rows.length > 0 || this.tempTabs.length === 1); // Keep at least one tab

                // Ensure at least one tab exists
                if (this.tempTabs.length === 0) {
                    this.tempTabs = [{ name: 'Main', rows: [] }];
                }

                // Save to sidebar
                this.sidebar.tabs = JSON.parse(JSON.stringify(this.tempTabs));
                this.sidebar.activeTabIndex = Math.min(this.activeEditTabIndex, this.tempTabs.length - 1);
                this.sidebar.style = this.tempStyle;

                this.sidebar.saveTabs();
                this.sidebar.saveActiveTab();
                this.sidebar.saveStyle();
                this.sidebar.renderTabs();
                this.sidebar.renderButtons();

                // Close editor
                document.getElementById('hwh-unified-editor').remove();

                debugLog('üíæ Settings saved and applied:', {
                    tabs: this.sidebar.tabs.length + ' tabs',
                    style: this.sidebar.style,
                    functions: Object.keys(BUTTON_FUNCTIONS).length + ' total'
                });
            }
        }

        // ================================================================
        // INITIALIZATION
        // ================================================================

        function initCompactSidebar() {
            debugLog('üé® Initializing Compact Sidebar with Unified Editor...');
            addCompactSidebarStyles();
            const sidebar = new CompactSidebar();
            sidebar.init();
            window.compactSidebar = sidebar;
            debugLog('‚úÖ Compact sidebar ready with style:', sidebar.style);
            DOMCache.clear('compactBtnPlates');
            DOMCache.clear('scriptBtnPlates');
        }

        // Initialize sidebar as soon as game is ready
        waitForGameReady().then(() => {
            debugLog('‚úÖ Game ready, initializing sidebar...');
            initCompactSidebar();
        });

        window.CompactSidebar = CompactSidebar;
        window.UnifiedSettingsEditor = UnifiedSettingsEditor;
        window.initCompactSidebar = initCompactSidebar;

        ModuleTracker.register('Sidebar Module');
    })();


    function initHWHButtonClickers(){
        debugLog('üîß Initializing HWH Button Clickers...');

        // ================================================================
        // CORE BUTTON CLICKING FUNCTIONS
        // ================================================================

        function getHWHButtonMap() {
            try {
                // Preferred: HWH exposes buttons through HWHData.buttons
                if (typeof HWHData !== 'undefined' && HWHData.buttons) {
                    return HWHData.buttons;
                }
                // Fallback: if for some reason buttons is actually global
                if (typeof buttons !== 'undefined') {
                    return buttons;
                }
            } catch (e) {
                console.error('Error accessing HWH button map:', e);
            }
            return null;
        }

        window.clickHWHButton = function(buttonName) {
            try {
                const buttonMap = getHWHButtonMap();
                if (!buttonMap || !buttonMap[buttonName]) {
                    console.error(`Button "${buttonName}" not found in HWHData.buttons`);
                    return false;
                }

                const button = buttonMap[buttonName];

                if (typeof button.onClick === 'function') {
                    debugLog(`üéØ Clicking HWH button: ${buttonName}`);
                    button.onClick();
                    return true;
                }

                console.error(`Button "${buttonName}" has no onClick handler`);
                return false;
            } catch (e) {
                console.error(`Error clicking button "${buttonName}":`, e);
                return false;
            }
        };


        window.clickHWHCombinedButton = function(buttonName, subIndex = 0) {
            try {
                const buttonMap = getHWHButtonMap();
                if (!buttonMap || !buttonMap[buttonName]) {
                    console.error(`Combined button "${buttonName}" not found in HWHData.buttons`);
                    return false;
                }

                const button = buttonMap[buttonName];

                if (!button.isCombine || !Array.isArray(button.combineList)) {
                    console.error(`Button "${buttonName}" is not a combined button`);
                    return false;
                }

                if (subIndex < 0 || subIndex >= button.combineList.length) {
                    console.error(`Sub-index ${subIndex} out of range for "${buttonName}"`);
                    return false;
                }

                const subButton = button.combineList[subIndex];

                if (typeof subButton.onClick === 'function') {
                    debugLog(`üéØ Clicking ${buttonName}[${subIndex}]`);
                    subButton.onClick();
                    return true;
                }

                console.error(`Sub-button ${buttonName}[${subIndex}] has no onClick handler`);
                return false;
            } catch (e) {
                console.error('Error clicking combined button:', e);
                return false;
            }
        };

        // ================================================================
        // INDIVIDUAL BUTTON FUNCTIONS
        // ================================================================

        // 1. Do All
        window.clickDoAll = () => clickHWHButton('getOutland');

        // 2. Actions
        window.clickActions = () => clickHWHButton('doActions');

        // 3. Others
        window.clickOthers = () => clickHWHButton('doOthers');

        // 4. ToE (Titan Arena)
        window.clickToE = () => clickHWHCombinedButton('testTitanArena', 0);
        window.clickToENavigate = () => clickHWHCombinedButton('testTitanArena', 1);

        // 5. Dungeon
        window.clickDungeon = () => clickHWHCombinedButton('testDungeon', 0);
        window.clickDungeonNavigate = () => clickHWHCombinedButton('testDungeon', 1);

        // 6. Adventure
        window.clickAdventure = () => clickHWHCombinedButton('testAdventure', 0);
        window.clickAdventureRaid = () => clickHWHCombinedButton('testAdventure', 1);
        window.clickAdventureNavigate = () => clickHWHCombinedButton('testAdventure', 2);

        // 7. Raid (if it exists as a separate button)
        // Note: Raid might be part of Adventure or other combined buttons

        // 8. Rewards and Mail
        window.clickRewardsAndMail = () => clickHWHButton('rewardsAndMailFarm');

        // 9. Quests
        window.clickQuests = () => clickHWHButton('dailyQuests');

        // 10. Extensions
        window.clickExtensions = () => clickHWHButton('extensions');

        // ================================================================
        // OTHERS POPUP (B)
        // ================================================================
        window.showTweakerToolsPopup = function() {
            try {
                const existing = document.getElementById('hwh-tweaker-tools-popup');
                if (existing) existing.remove();

                const modal = document.createElement('div');
                modal.id = 'hwh-tweaker-tools-popup';
                modal.style.cssText = `
                    position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.7);
display: flex;
justify-content: center;
align-items: center;
z-index: 999999;
`;

                const popup = document.createElement('div');
                popup.style.cssText = `
                    background: linear-gradient(135deg, #2d2416 0%, #1a1408 100%);
border: 3px solid #c9a227;
border-radius: 12px;
padding: 18px;
max-width: 700px;
box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
`;

                const title = document.createElement('div');
                title.innerHTML = '<strong>üîß Tweaker Tools</strong>';
                title.style.cssText = `
                    font-size: 18px;
color: #f4e4c1;
margin-bottom: 14px;
text-align: center;
font-weight: bold;
`;
                popup.appendChild(title);

                const sections = [
                    { name: '‚öôÔ∏è Tweaker', items: [
                        { name: 'Tweaker Settings', action: () => window.showTweakerSettings && window.showTweakerSettings() },
                        { name: 'Export Game Data', action: () => window.exportGameDataWithUI && window.exportGameDataWithUI() },
                        { name: 'üèÜ Quiz Rankings', action: () => window.showQuizRankings && window.showQuizRankings() },
                        { name: 'üéÑ Winterfest25', action: () => window.showWinterfestRankings && window.showWinterfestRankings() },
                        { name: 'üéÅ Winterfest Gifts', action: () => window.showWinterfestGifts && window.showWinterfestGifts() },
                        { name: 'üìä Game Data', action: () => window.showGameDataPopup && window.showGameDataPopup() },
                        { name: 'üó∫Ô∏è Edit Adventure Paths', action: () => window.editAdventurePathsStandalone && window.editAdventurePathsStandalone() },
                        { name: 'üì¶ Inventory Manager', action: () => window.showInventoryManager && window.showInventoryManager() },
                            { name: 'üéØ Fragment Hunter', action: () => window.showFragmentHunter && window.showFragmentHunter() },
                        { name: '‚öôÔ∏è HW Settings', action: () => { try { new (selfGame['game.mechanics.settings.popup.SettingsPopupMediator'])().open(); } catch(e){} } },
                    ]},
                    { name: 'üìã Others', items: [
                        { name: 'Get Energy', action: () => window.clickGetEnergy && window.clickGetEnergy() },
                        { name: 'Item Exchange', action: () => window.clickItemExchange && window.clickItemExchange() },
                        { name: 'Buy Souls', action: () => window.clickBuySouls && window.clickBuySouls() },
                        { name: 'Buy for Gold', action: () => window.clickBuyForGold && window.clickBuyForGold() },
                        { name: 'Buy Outland', action: () => window.clickBuyOutland && window.clickBuyOutland() },
                        { name: 'Clan Statistic', action: () => window.clickClanStat && window.clickClanStat() },
                        { name: 'Epic Brawl', action: () => window.clickEpicBrawl && window.clickEpicBrawl() },
                        { name: 'Artifacts Upgrade', action: () => window.clickArtifactsUpgrade && window.clickArtifactsUpgrade() },
                        { name: 'Skins Upgrade', action: () => window.clickSkinsUpgrade && window.clickSkinsUpgrade() },
                        { name: 'Season Reward', action: () => window.clickSeasonReward && window.clickSeasonReward() },
                        { name: 'Sell Hero Souls', action: () => window.clickSellHeroSouls && window.clickSellHeroSouls() },
                        { name: 'Change Map', action: () => window.clickChangeMap && window.clickChangeMap() },
                        { name: 'Hero Power', action: () => window.clickHeroPower && window.clickHeroPower() },
                    ]},
                ];

                const container = document.createElement('div');
                container.style.cssText = `display: flex; flex-direction: column; gap: 12px;`;

                sections.forEach(section => {
                    const sectionDiv = document.createElement('div');

                    const header = document.createElement('div');
                    header.textContent = section.name;
                    header.style.cssText = `
                        color: #c9a227;
font-size: 14px;
font-weight: bold;
margin-bottom: 8px;
padding-bottom: 4px;
border-bottom: 1px solid rgba(201, 162, 39, 0.3);
`;
                    sectionDiv.appendChild(header);

                    const grid = document.createElement('div');
                    grid.style.cssText = `display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px;`;

                    section.items.forEach(item => {
                        const btn = document.createElement('button');
                        btn.textContent = item.name;
                        btn.style.cssText = `
                            background: linear-gradient(135deg, #4a3c2a 0%, #2d2416 100%);
border: 1px solid #c9a227;
color: #f4e4c1;
padding: 8px 6px;
border-radius: 4px;
cursor: pointer;
font-size: 12px;
font-weight: 500;
transition: all 0.2s ease;
`;
                        btn.onmouseover = () => {
                            btn.style.background = 'linear-gradient(135deg, #c9a227 0%, #4a3c2a 100%)';
                            btn.style.color = '#1a1408';
                        };
                        btn.onmouseout = () => {
                            btn.style.background = 'linear-gradient(135deg, #4a3c2a 0%, #2d2416 100%)';
                            btn.style.color = '#f4e4c1';
                        };
                        btn.onclick = () => {
                            modal.remove();
                            item.action && item.action();
                        };
                        grid.appendChild(btn);
                    });

                    sectionDiv.appendChild(grid);
                    container.appendChild(sectionDiv);
                });

                popup.appendChild(container);

                const closeBtn = document.createElement('button');
                closeBtn.textContent = '‚úñ Close';
                closeBtn.style.cssText = `
                    background: #c9a227;
border: none;
color: #1a1408;
padding: 8px 20px;
border-radius: 4px;
cursor: pointer;
font-size: 12px;
font-weight: 600;
margin-top: 12px;
width: 100%;
`;
                closeBtn.onmouseover = () => closeBtn.style.background = '#d4af37';
                closeBtn.onmouseout = () => closeBtn.style.background = '#c9a227';
                closeBtn.onclick = () => modal.remove();

                popup.appendChild(closeBtn);
                modal.appendChild(popup);
                document.body.appendChild(modal);
                modal.onclick = (e) => { if (e.target === modal) modal.remove(); };

                return true;
            } catch (e) {
                console.error('Error showing Tweaker Tools popup:', e);
                return false;
            }
        };
    }

    // Export complete button configuration
    window.exportHWHButtons = function() {
        const config = {
            version: TWEAKER_VERSION,
            exported: new Date().toISOString(),
            tabs: window.compactSidebar ? window.compactSidebar.tabs : DEFAULT_TABS,
            activeTab: window.compactSidebar ? window.compactSidebar.activeTabIndex : 0,
            style: window.compactSidebar ? window.compactSidebar.style : 'flat',
            buttonCustomizations: window.buttonCustomizations || {},
            customFunctions: {}
        };

        // Export custom functions
        Object.keys(BUTTON_FUNCTIONS).forEach(name => {
            const func = BUTTON_FUNCTIONS[name];
            if (func.isCustom) {
                config.customFunctions[name] = {
                    actionCode: func.action.toString(),
                    icon: func.icon,
                    color: func.color,
                    description: func.description
                };
            }
        });

        const json = JSON.stringify(config, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `hwh_buttons_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);

        debugLog('‚úÖ Button configuration exported!');
        alert('‚úÖ Button configuration exported to downloads!');
    };


    // Import button configuration
    window.importHWHButtons = function() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const config = JSON.parse(e.target.result);

                    if (!confirm('Import button configuration? This will replace your current setup.\n\nMake sure you have exported your current config first!')) {
                        return;
                    }

                    // Import customizations
                    if (config.buttonCustomizations) {
                        window.buttonCustomizations = config.buttonCustomizations;
                        saveButtonCustomizations(config.buttonCustomizations);
                        debugLog(`‚úÖ Imported ${Object.keys(config.buttonCustomizations).length} button customizations`);
                    }

                    // Import custom functions
                    if (config.customFunctions || config.functions) {
                        const funcsToImport = config.customFunctions || config.functions;
                        let importedCount = 0;
                        Object.keys(funcsToImport).forEach(name => {
                            const func = funcsToImport[name];
                            try {
                                BUTTON_FUNCTIONS[name] = {
                                    action: eval(`(${func.actionCode})`),
                                    icon: func.icon,
                                    color: func.color,
                                    description: func.description,
                                    isCustom: true
                                };
                                importedCount++;
                            } catch (err) {
                                console.error(`Failed to import "${name}":`, err);
                            }
                        });
                        saveCustomFunctions();
                        debugLog(`‚úÖ Imported ${importedCount} custom functions`);
                    }

                    // Import tabs (new format) or layout (old format)
                    if (config.tabs && window.compactSidebar) {
                        window.compactSidebar.tabs = config.tabs;
                        window.compactSidebar.activeTabIndex = config.activeTab || 0;
                        window.compactSidebar.saveTabs();
                        window.compactSidebar.saveActiveTab();
                        debugLog('‚úÖ Imported tabs');
                    } else if (config.layout && window.compactSidebar) {
                        // Old format - convert to single tab
                        window.compactSidebar.tabs = [{
                            name: 'Main',
                            rows: config.layout
                        }];
                        window.compactSidebar.activeTabIndex = 0;
                        window.compactSidebar.saveTabs();
                        window.compactSidebar.saveActiveTab();
                        debugLog('‚úÖ Imported layout (converted to tabs)');
                    }

                    // Import style
                    if (config.style && window.compactSidebar) {
                        window.compactSidebar.style = config.style;
                        window.compactSidebar.saveStyle();
                        window.compactSidebar.applyStyle();
                        debugLog('‚úÖ Imported style');
                    }

                    // Refresh display
                    try {
                        window.compactSidebar?.renderTabs?.();
                        window.compactSidebar?.renderButtons?.();
                    } catch (e) {
                        debugLog('Refresh skipped, reload required');
                    }
                    alert('‚úÖ Configuration imported successfully!\n\nReload the page to ensure everything works correctly.');

                } catch (err) {
                    alert('‚ùå Import failed: ' + err.message);
                    console.error('Import error:', err);
                }
            };
            reader.readAsText(file);
        };
        input.click();
    };
    ModuleTracker.register('Export/Import');

    // Run cleanup after a short delay - but only once per day
    setTimeout(() => {
        try {
            const lastCleanup = GM_getValue('lastTournamentCleanup', 0);
            const now = Date.now();
            if (now - lastCleanup > 24 * 60 * 60 * 1000) { // Only once per day
                window.cleanupOldTournamentData();
                GM_setValue('lastTournamentCleanup', now);
                ModuleTracker.register('Tournament Cleanup');
            } else {
                if (DEBUG_MODE) debugLog('‚ÑπÔ∏è Tournament cleanup skipped (ran recently)');
            }
        } catch (e) {
            console.error('Error running tournament data cleanup:', e);
        }
    }, 3000);

    ModuleTracker.summary();
    // Performance report function
    window.showTweakerPerformance = function() {
        const cacheStats = DOMCache.getStats();
        const moduleStats = ModuleTracker.summary();

        debugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        debugLog('üìä HWH TWEAKER v' + TWEAKER_VERSION + ' PERFORMANCE REPORT');
        debugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
        debugLog(`‚è±Ô∏è  Load Time: ${moduleStats.elapsed}ms`);
        debugLog(`üì¶ Modules: ${moduleStats.count}`);
        debugLog(`üóÑÔ∏è  DOM Cache Hit Rate: ${cacheStats.hitRate}`);
        debugLog(`üìù Cached Elements: ${cacheStats.cacheSize}`);
        debugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');

        return {
            version: TWEAKER_VERSION,
            loadTime: moduleStats.elapsed,
            modules: moduleStats.count,
            cacheHitRate: cacheStats.hitRate,
            cachedElements: cacheStats.cacheSize
        };
    };

    debugLog('üí° Run showTweakerPerformance() for detailed stats');
    waitForHWH();
})();