// ==UserScript==
// @name         Symfony 翻译文档 service_container.html
// @namespace    fireloong
// @version      0.1.1
// @description  翻译文档 service_container.html
// @author       Itsky71
// @match        https://symfony.com/doc/5.x/service_container.html
// @match        https://symfony.com/doc/6.4/service_container.html
// @match        https://symfony.com/doc/7.1/service_container.html
// @match        https://symfony.com/doc/7.2/service_container.html
// @match        https://symfony.com/doc/current/service_container.html
// @icon         https://www.google.com/s2/favicons?sz=64&domain=symfony.com
// @require      https://unpkg.com/jquery@3.7.1/dist/jquery.min.js
// @require      https://update.greasyfork.org/scripts/503008/fanyi.js
// @grant        none
// @license      MIT
// @downloadURL https://update.greasyfork.org/scripts/496288/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20service_containerhtml.user.js
// @updateURL https://update.greasyfork.org/scripts/496288/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20service_containerhtml.meta.js
// ==/UserScript==

(function($) {
    'use strict';

    const translates = {
        '\n        \n                    Service Container\n        \n            ': '服务容器',
        'Do you prefer video tutorials? Check out the Symfony Fundamentals screencast series.': '你更喜欢视频教程吗？查看 <a href="https://symfonycasts.com/screencast/symfony-fundamentals" class="reference external" rel="external noopener noreferrer" target="_blank">Symfony Fundamentals 的屏幕录像系列</a>吧。',
        'Your application is full of useful objects: a "Mailer" object might help you\nsend emails while another object might help you save things to the database.\nAlmost everything that your app "does" is actually done by one of these objects.\nAnd each time you install a new bundle, you get access to even more!': '你的应用程序中充满了有用的对象：“Mailer”对象可能帮助你发送电子邮件，而另一个对象可能帮助你保存数据库中的事物。几乎你的应用程序所执行的每一项“操作”实际上都是由这些对象之一完成的。而且，每当你安装一个新的捆绑包时，你都可以获得更多！',
        'In Symfony, these useful objects are called services and each service lives\ninside a very special object called the service container. The container\nallows you to centralize the way objects are constructed. It makes your life\neasier, promotes a strong architecture and is super fast!': '在 Symfony 中，这些有用的对象被称为<strong>服务</strong>，每个服务都存在于一个被称为<strong>服务容器</strong>的特殊对象中。容器允许你集中化对象的构建方式。它使你的生活更加轻松，促进强大的架构，并且速度非常快！',

        'Fetching and using Services': '获取和使用服务',
        'The moment you start a Symfony app, your container already contains many services.\nThese are like tools: waiting for you to take advantage of them. In your controller,\nyou can "ask" for a service from the container by type-hinting an argument with the\nservice\'s class or interface name. Want to log something? No problem:': '当你启动一个 Symfony 应用程序时，你的容器已经包含了许多服务。这些服务就像工具一样：等待你利用它们。在你的控制器中，你可以通过类型提示参数（使用服务的类或接口名）来“请求”容器中的服务。想要记录一些内容吗？没问题：',
        'What other services are available? Find out by running:': '还有哪些其他服务可用？通过运行以下命令来查找：',
        'When you use these type-hints in your controller methods or inside your\nown services, Symfony will automatically\npass you the service object matching that type.': '当你在控制器方法或<a href="service_container.html#service-container-creating-service" class="reference internal">自己的服务</a>内部使用这些类型提示时，Symfony 将自动传递与该类型匹配的服务对象给你。',
        "Throughout the docs, you'll see how to use the many different services that live\nin the container.": '在整个文档中，你会看到如何使用容器中的许多不同的服务。',
        "There are actually many more services in the container, and each service has\na unique id in the container, like request_stack or router.default. For a full\nlist, you can run php bin/console debug:container. But most of the time,\nyou won't need to worry about this. See how to choose a specific service. See How to Debug the Service Container & List Services.": '实际上，容器中有更多的服务，并且每个服务在容器中都有一个唯一的 id，比如 <code translate="no" class="notranslate">request_stack</code> 或 <code translate="no" class="notranslate">router.default</code>。要查看完整列表，可以运行 <code translate="no" class="notranslate">php bin/console debug:container</code>。但大多数情况下，你不需要担心这个问题。了解<a href="service_container.html#services-wire-specific-service" class="reference internal">如何选择特定的服务</a>。请参阅<a href="service_container/debug.html" class="reference internal">如何调试服务容器和列出服务</a>。',

        'Creating/Configuring Services in the Container': '在容器中创建/配置服务',
        "You can also organize your own code into services. For example, suppose you need\nto show your users a random, happy message. If you put this code in your controller,\nit can't be re-used. Instead, you decide to create a new class:": '你也可以将自己的代码组织成服务。例如，假设你需要向用户显示一个随机的、快乐的信息。如果你将这段代码放在你的控制器中，它就无法被重用。相反，你决定创建一个新的类：',
        "Congratulations! You've created your first service class! You can use it immediately\ninside your controller:": '恭喜你！你创建了你的第一个服务类！你可以立即在你的控制器中使用它：',
        "When you ask for the MessageGenerator service, the container constructs a new\nMessageGenerator object and returns it (see sidebar below). But if you never ask\nfor the service, it's never constructed: saving memory and speed. As a bonus, the\nMessageGenerator service is only created once: the same instance is returned\neach time you ask for it.": '当你请求 <code translate="no" class="notranslate">MessageGenerator</code> 服务时，容器会构造一个新的 <code translate="no" class="notranslate">MessageGenerator</code> 对象并返回它（见下面的侧边栏）。但如果你从未请求过该服务，它就不会被构造：节省了内存和速度。作为额外的好处，<code translate="no" class="notranslate">MessageGenerator</code> 服务只会被创建一次：每次你请求它时，都会返回相同的实例。',
        'Automatic Service Loading in services.yaml': '在 services.yaml 中自动加载服务',
        "The documentation assumes you're using the following service configuration,\nwhich is the default config for a new project:": '文档假定你正在使用以下服务配置，这是新项目的默认配置：',
        'The value of the resource and exclude options can be any valid\nglob pattern. The value of the exclude option can also be an\narray of glob patterns.': '<code translate="no" class="notranslate">resource</code> 和 <code translate="no" class="notranslate">exclude</code> 选项的值可以是任何有效的 <a href="https://en.wikipedia.org/wiki/Glob_(programming)" class="reference external" rel="external noopener noreferrer" target="_blank">glob 模式</a>。<code translate="no" class="notranslate">exclude</code> 选项的值也可以是一个 glob 模式的数组。',
        "Thanks to this configuration, you can automatically use any classes from the\nsrc/ directory as a service, without needing to manually configure\nit. Later, you'll learn how to import many services at once with resource.": '由于这种配置，您可以自动地将 <code translate="no" class="notranslate">src/</code> 目录下的任何类用作服务，而无需手动配置。稍后，您将学习如何使用 resource <a href="service_container.html#service-psr4-loader" class="reference internal">一次性导入多个服务</a>。',
        "If you'd prefer to manually wire your service, you can\nuse explicit configuration.": '如果您想手动连接服务，可以<a href="service_container.html#services-explicitly-configure-wire-services" class="reference internal">使用显式配置</a>。',

        'Limiting Services to a specific Symfony Environment': '将服务限制在特定的 Symfony 环境中',
        'You can use the #[When] attribute to only register the class\nas a service in some environments:': '您可以使用 <code translate="no" class="notranslate">#[When]</code> 注解仅在某些环境中将类注册为服务：',

        'Injecting Services/Config into a Service': '将服务/配置注入到服务中',
        'What if you need to access the logger service from within MessageGenerator?\nNo problem! Create a __construct() method with a $logger argument that has\nthe LoggerInterface type-hint. Set this on a new $logger property\nand use it later:': '如果你需要在 <code translate="no" class="notranslate">MessageGenerator</code> 内部访问 <code translate="no" class="notranslate">logger</code> 服务怎么办？没问题！创建一个带有 <code translate="no" class="notranslate">$logger</code> 参数的 <code translate="no" class="notranslate">__construct()</code> 方法，该参数具有 <code translate="no" class="notranslate">LoggerInterface</code> 的类型提示。将这个参数设置在一个新的 <code translate="no" class="notranslate">$logger</code> 属性上，并在后面使用它：',
        "That's it! The container will automatically know to pass the logger service\nwhen instantiating the MessageGenerator. How does it know to do this?\nAutowiring. The key is the LoggerInterface\ntype-hint in your __construct() method and the autowire: true config in\nservices.yaml. When you type-hint an argument, the container will automatically\nfind the matching service. If it can't, you'll see a clear exception with a helpful\nsuggestion.": '就是这样！容器在实例化 <code translate="no" class="notranslate">MessageGenerator</code> 时会自动知道要传递 <code translate="no" class="notranslate">logger</code> 服务。它是怎么知道这样做的呢？这是因为<a href="service_container.html#services-autowire" class="reference internal">自动装配</a>。关键在于你的 <code translate="no" class="notranslate">__construct()</code> 方法中的 <code translate="no" class="notranslate">LoggerInterface</code> 类型提示以及 <code translate="no" class="notranslate">services.yaml</code> 中的 <code translate="no" class="notranslate">autowire: true</code> 配置。当你为参数提供类型提示时，容器会自动找到匹配的服务。如果找不到，你会看到一个带有有用建议的清晰异常。',
        'By the way, this method of adding dependencies to your __construct() method is\ncalled dependency injection.': '顺便说一句，这种将依赖项添加到 <code translate="no" class="notranslate">__construct()</code> 方法中的方法被称为依赖注入。',
        "How should you know to use LoggerInterface for the type-hint? You can either\nread the docs for whatever feature you're using, or get a list of autowireable\ntype-hints by running:": '你如何知道要使用 <code translate="no" class="notranslate">LoggerInterface</code> 作为类型提示呢？你可以阅读你正在使用的任何特性的文档，或者通过运行以下命令来获取可自动装配的类型提示列表：',

        'Handling Multiple Services': '处理多个服务',
        'Suppose you also want to email a site administrator each time a site update is\nmade. To do that, you create a new class:': '假设你还想在每次网站更新时向网站管理员发送电子邮件。为此，你创建了一个新的类：',
        "This needs the MessageGenerator and the Mailer service. That's no\nproblem, we ask them by type hinting their class and interface names!\nNow, this new service is ready to be used. In a controller, for example,\nyou can type-hint the new SiteUpdateManager class and use it:": '这需要使用 <code translate="no" class="notranslate">MessageGenerator</code> 和 <code translate="no" class="notranslate">Mailer</code> 服务。没问题，我们通过类型提示它们的类和接口名称来请求它们！现在，这个新服务已经可以使用了。例如，在控制器中，你可以类型提示新的 <code translate="no" class="notranslate">SiteUpdateManager</code> 类并使用它：',
        'Thanks to autowiring and your type-hints in __construct(), the container creates\nthe SiteUpdateManager object and passes it the correct argument. In most cases,\nthis works perfectly.': '由于自动装配和你在 <code translate="no" class="notranslate">__construct()</code> 方法中的类型提示，容器会创建 <code translate="no" class="notranslate">SiteUpdateManager</code> 对象，并为其传递正确的参数。在大多数情况下，这都能完美地工作。',

        'Manually Wiring Arguments': '手动连接参数',
        'But there are a few cases when an argument to a service cannot be autowired. For\nexample, suppose you want to make the admin email configurable:': '但是，在某些情况下，服务的参数无法自动装配。例如，假设你想要使管理员电子邮件可配置：',
        "If you make this change and refresh, you'll see an error:": '如果你进行这个更改并刷新，你会看到一个错误：',
        'That makes sense! There is no way that the container knows what value you want to\npass here. No problem! In your configuration, you can explicitly set this argument:': '这说得通！容器无法知道您想在这里传递什么值。没问题！在您的配置中，您可以明确设置这个参数：',
        'Thanks to this, the container will pass manager@example.com to the $adminEmail\nargument of __construct when creating the SiteUpdateManager service. The\nother arguments will still be autowired.': '由于这个设置，当创建 <code translate="no" class="notranslate">SiteUpdateManager</code> 服务时，容器将会把 <code translate="no" class="notranslate">manager@example.com</code> 传递给 <code translate="no" class="notranslate">__construct</code> 的 <code translate="no" class="notranslate">$adminEmail</code> 参数。其它参数仍然会自动装配。',
        "But, isn't this fragile? Fortunately, no! If you rename the $adminEmail argument\nto something else - e.g. $mainEmail - you will get a clear exception when you\nreload the next page (even if that page doesn't use this service).": '但是，这样不是很脆弱吗？幸运的是，不是！如果你把 <code translate="no" class="notranslate">$adminEmail</code> 参数重命名为其它名称，比如 <code translate="no" class="notranslate">$mainEmail</code>，当你重新加载下一页时（即使该页面不使用这个服务），你也会得到一个明确的异常。',

        'Service Parameters': '服务参数',
        'In addition to holding service objects, the container also holds configuration,\ncalled parameters. The main article about Symfony configuration explains the\nconfiguration parameters in detail and shows\nall their types (string, boolean, array, binary and PHP constant parameters).': '除了持有服务对象外，容器还持有配置，这些配置被称为<strong>参数</strong>。关于 Symfony 配置的主要文章详细解释了<a href="configuration.html#configuration-parameters" class="reference internal">配置参数</a>，并展示了它们的所有类型（字符串、布尔值、数组、二进制和 PHP 常量参数）。',
        'However, there is another type of parameter related to services. In YAML config,\nany string which starts with @ is considered as the ID of a service, instead\nof a regular string. In XML config, use the type="service" type for the\nparameter and in PHP config use the service() function:': '然而，还有一种与服务相关的参数类型。在 YAML 配置中，任何以 <code translate="no" class="notranslate">@</code> 开头的字符串都被视为服务的 ID，而不是普通的字符串。在 XML 配置中，使用 <code translate="no" class="notranslate">type="service"</code> 类型的参数，在 PHP 配置中使用 <code translate="no" class="notranslate">service()</code> 函数：',
        'Working with container parameters is straightforward using the container\'s\naccessor methods for parameters:': '使用容器的参数访问方法来处理容器参数是非常直接的：',
        'The used . notation is a\nSymfony convention to make parameters\neasier to read. Parameters are flat key-value elements, they can\'t\nbe organized into a nested array': '使用的 <code translate="no" class="notranslate">.</code> 符号是 <a href="contributing/code/standards.html#service-naming-conventions" class="reference internal">Symfony 的一种约定</a>，旨在使参数更易于阅读。参数是扁平的键值元素，它们不能被组织成嵌套数组。',
        'You can only set a parameter before the container is compiled, not at run-time.\nTo learn more about compiling the container see\nCompiling the Container.': '你只能在容器编译之前设置参数，而不能在运行时设置。要了解有关编译容器的更多信息，请参阅<a href="components/dependency_injection/compilation.html" class="reference internal">编译容器</a>。',

        'Choose a Specific Service': '选择特定的服务',
        'The MessageGenerator service created earlier requires a LoggerInterface argument:': '早先创建的 <code translate="no" class="notranslate">MessageGenerator</code> 服务需要一个 <code translate="no" class="notranslate">LoggerInterface</code> 参数：',
        'However, there are multiple services in the container that implement LoggerInterface,\nsuch as logger, monolog.logger.request, monolog.logger.php, etc. How\ndoes the container know which one to use?': '然而，容器中有多个实现了 <code translate="no" class="notranslate">LoggerInterface</code> 的服务，例如 <code translate="no" class="notranslate">logger</code>、<code translate="no" class="notranslate">monolog.logger.request</code>、<code translate="no" class="notranslate">monolog.logger.php</code> 等。容器如何知道应该使用哪一个呢？',
        'In these situations, the container is usually configured to automatically choose\none of the services - logger in this case (read more about why in Defining Services Dependencies Automatically (Autowiring)).\nBut, you can control this and pass in a different logger:': '在这种情况下，容器通常会被配置为自动选择其中一个服务——在这个例子中是 <code translate="no" class="notranslate">logger</code>（更多关于自动选择的原因，请参阅<a href="service_container/autowiring.html#service-autowiring-alias" class="reference internal">自动定义服务依赖（Autowiring）</a>）。但是，你可以控制这一点并传入不同的日志记录器：',
        'This tells the container that the $logger argument to __construct should use\nservice whose id is monolog.logger.request.': '这告诉容器，<code translate="no" class="notranslate">__construct</code> 方法中的 <code translate="no" class="notranslate">$logger</code> 参数应该使用服务 ID 为 <code translate="no" class="notranslate">monolog.logger.request</code> 的服务。',
        'For a list of possible logger services that can be used with autowiring, run:': '要查看可以用于自动连线（autowiring）的日志记录器服务列表，请运行：',
        'For a full list of all possible services in the container, run:': '要查看容器中所有可能的服务的完整列表，请运行：',

        'Remove Services': '删除服务',
        'A service can be removed from the service container if needed. This is useful\nfor example to make a service unavailable in some configuration environment\n(e.g. in the test environment):': '如果需要，可以从服务容器中移除一个服务。例如，在某些<a href="configuration.html#configuration-environments" class="reference internal">配置环境</a>中让一个服务不可用（比如在 <code translate="no" class="notranslate">test</code> 环境中）时，这样做很有用：',
        'Now, the container will not contain the App\\RemovedService in the test\nenvironment.': '现在，在 <code translate="no" class="notranslate">test</code> 环境中，容器将不会包含 <code translate="no" class="notranslate">App\RemovedService</code>。',

        'Injecting a Closure as an Argument': '将闭包作为参数注入',
        'It is possible to inject a callable as an argument of a service.\nLet\'s add an argument to our MessageGenerator constructor:': '可以将一个可调用的对象（callable）作为参数注入到服务中。让我们给 <code translate="no" class="notranslate">MessageGenerator</code> 构造函数添加一个参数：',
        'Now, we would add a new invokable service to generate the message hash:': '现在，我们可以添加一个新的可调用服务来生成消息哈希：',
        'Our configuration looks like this:': '我们的配置看起来像这样：',
        'Closures can be injected by using autowiring\nand its dedicated attributes.': '可以通过自动连线（autowiring）及其专用属性来注入闭包（closures）。',
        'The closure argument type was introduced in Symfony 6.1.': '<code translate="no" class="notranslate">closure</code> 参数类型是在 Symfony 6.1 中引入的。',

        'Binding Arguments by Name or Type': '通过名称或类型绑定参数',
        'You can also use the bind keyword to bind specific arguments by name or type:': '你也可以使用 <code translate="no" class="notranslate">bind</code> 关键字按名称或类型绑定特定的参数：',
        'By putting the bind key under _defaults, you can specify the value of any\nargument for any service defined in this file! You can bind arguments by name\n(e.g. $adminEmail), by type (e.g. Psr\\Log\\LoggerInterface) or both\n(e.g. Psr\\Log\\LoggerInterface $requestLogger).': '通过将 <code translate="no" class="notranslate">bind</code> 键置于 <code translate="no" class="notranslate">_defaults</code> 下，你可以为在此文件中定义的任何服务指定其任何参数的值！你可以按名称（例如 <code translate="no" class="notranslate">$adminEmail</code>）绑定参数，按类型（例如 <code translate="no" class="notranslate">Psr\Log\LoggerInterface</code>）绑定参数，或者两者同时进行（例如 <code translate="no" class="notranslate">Psr\Log\LoggerInterface $requestLogger</code>）。',
        'The bind config can also be applied to specific services or when\nloading many services at once).': '<code translate="no" class="notranslate">bind</code> 配置也可以应用于特定的服务，或者在<a href="service_container.html#service-psr4-loader" class="reference internal">一次性加载多个服务</a>时使用。',

        'Abstract Service Arguments': '抽象服务参数',
        'Sometimes, the values of some service arguments can\'t be defined in the\nconfiguration files because they are calculated at runtime using a\ncompiler pass\nor bundle extension.': '有时，某些服务参数的值无法在配置文件中定义，因为这些值是通过<a href="service_container/compiler_passes.html" class="reference internal">编译器通道</a>或<a href="bundles/extension.html" class="reference internal">捆绑扩展</a>在运行时计算得出的。',
        'In those cases, you can use the abstract argument type to define at least\nthe name of the argument and some short description about its purpose:': '在这种情况下，你可以使用 <code translate="no" class="notranslate">abstract</code> 参数类型来至少定义参数的名称及其用途的简短描述：',
        'If you don\'t replace the value of an abstract argument during runtime, a\nRuntimeException will be thrown with a message like\nArgument "$rootNamespace" of service "App\\Service\\MyService" is abstract: should be defined by Pass.': '如果你在运行时没有替换一个抽象参数的值，将会抛出一个 <code translate="no" class="notranslate">RuntimeException</code>，错误消息类似于 <code translate="no" class="notranslate">Argument "$rootNamespace" of service "App\\Service\\MyService" is abstract: should be defined by Pass.</code>',

        'The autowire Option': 'autowire 选项',
        'Above, the services.yaml file has autowire: true in the _defaults section\nso that it applies to all services defined in that file. With this setting, you\'re\nable to type-hint arguments in the __construct() method of your services and\nthe container will automatically pass you the correct arguments. This entire entry\nhas been written around autowiring.': '在上面的 <code translate="no" class="notranslate">services.yaml</code> 文件中，<code translate="no" class="notranslate">_defaults</code> 部分设置了 <code translate="no" class="notranslate">autowire: true</code>，这意味着它适用于该文件中定义的所有服务。有了这个设置，你可以在服务的 <code translate="no" class="notranslate">__construct()</code> 方法中使用类型提示，容器将自动传递正确的参数。整个条目都是围绕自动连线（autowiring）来写的。',
        'For more details about autowiring, check out Defining Services Dependencies Automatically (Autowiring).': '关于自动连线（autowiring）的更多详细信息，可以查阅相关文档中的<a href="service_container/autowiring.html" class="reference internal">自动定义服务依赖（Autowiring）</a>部分。',

        'The autoconfigure Option': 'autoconfigure 选项',
        'Above, the services.yaml file has autoconfigure: true in the _defaults\nsection so that it applies to all services defined in that file. With this setting,\nthe container will automatically apply certain configuration to your services, based\non your service\'s class. This is mostly used to auto-tag your services.': '在上面的 <code translate="no" class="notranslate">services.yaml</code> 文件中，<code translate="no" class="notranslate">_defaults</code> 部分设置了 <code translate="no" class="notranslate">autoconfigure: true</code>，这意味着它适用于该文件中定义的所有服务。有了这个设置，容器会根据你的服务类自动应用某些配置。这主要用于自动为你的服务添加标签（auto-tagging）。',
        'For example, to create a Twig extension, you need to create a class, register it\nas a service, and tag it with twig.extension.': '例如，要创建一个 Twig 扩展，你需要创建一个类，将其注册为一个服务，并用 <code translate="no" class="notranslate">twig.extension</code> 标签<a href="service_container/tags.html" class="reference internal">标记</a>它。',
        'But, with autoconfigure: true, you don\'t need the tag. In fact, if you\'re using\nthe default services.yaml config,\nyou don\'t need to do anything: the service will be automatically loaded. Then,\nautoconfigure will add the twig.extension tag for you, because your class\nimplements Twig\\Extension\\ExtensionInterface. And thanks to autowire, you can even add\nconstructor arguments without any configuration.': '但是，如果使用了 <code translate="no" class="notranslate">autoconfigure: true</code>，你就无需手动添加标签。事实上，如果你使用的是<a href="service_container.html#service-container-services-load-example" class="reference internal">默认的 <code translate="no" class="notranslate">services.yaml</code> 配置文件</a>，你不需要做任何事情：服务将自动加载。然后，<code translate="no" class="notranslate">autoconfigure</code> 会因为你类实现了 <code translate="no" class="notranslate">Twig\\Extension\\ExtensionInterface</code> 而自动为你添加 <code translate="no" class="notranslate">twig.extension</code> 标签。而且，借助 <code translate="no" class="notranslate">autowire</code>，你甚至可以在不进行任何配置的情况下添加构造函数参数。',
        'Autoconfiguration also works with attributes. Some attributes like\nAsMessageHandler,\nAsEventListener and\nAsCommand are registered\nfor autoconfiguration. Any class using these attributes will have tags applied\nto them.': '自动配置也适用于属性。像 <a href="https://github.com/symfony/symfony/blob/6.4/src/Symfony/Component/Messenger/Attribute/AsMessageHandler.php" class="reference external" title="Symfony\Component\Messenger\Attribute\AsMessageHandler" rel="external noopener noreferrer" target="_blank">AsMessageHandler</a>、<a href="https://github.com/symfony/symfony/blob/6.4/src/Symfony/Component/EventDispatcher/Attribute/AsEventListener.php" class="reference external" title="Symfony\Component\EventDispatcher\Attribute\AsEventListener" rel="external noopener noreferrer" target="_blank">AsEventListener</a> 和 <a href="https://github.com/symfony/symfony/blob/6.4/src/Symfony/Component/Console/Attribute/AsCommand.php" class="reference external" title="Symfony\Component\Console\Attribute\AsCommand" rel="external noopener noreferrer" target="_blank">AsCommand</a> 这样的属性会被注册以进行自动配置。使用这些属性的任何类都会被自动应用相应的标签。',

        'Linting Service Definitions': '检查服务定义的规范性',
        'The lint:container command checks that the arguments injected into services\nmatch their type declarations. It\'s useful to run it before deploying your\napplication to production (e.g. in your continuous integration server):': '<code translate="no" class="notranslate">lint:container</code> 命令用于检查注入到服务中的参数是否与其类型声明相匹配。在将应用程序部署到生产环境之前运行这个命令是非常有用的（例如，在持续集成服务器上）：',
        'Checking the types of all service arguments whenever the container is compiled\ncan hurt performance. That\'s why this type checking is implemented in a\ncompiler pass called\nCheckTypeDeclarationsPass which is disabled by default and enabled only when\nexecuting the lint:container command. If you don\'t mind the performance\nloss, enable the compiler pass in your application.': '在每次编译容器时检查所有服务参数的类型可能会对性能造成影响。这就是为什么这种类型检查是通过一个名为 <code translate="no" class="notranslate">CheckTypeDeclarationsPass</code> 的<a href="service_container/compiler_passes.html" class="reference internal">编译器通道</a>来实现的，该通道默认是禁用的，并且仅在执行 <code translate="no" class="notranslate">lint:container</code> 命令时启用。如果你不介意性能损失，可以在应用程序中启用这个编译器通道。',

        'Public Versus Private Services': '公共服务与私有服务',
        'Every service defined is private by default. When a service is private, you\ncannot access it directly from the container using $container->get(). As a\nbest practice, you should only create private services and you should fetch\nservices using dependency injection instead of using $container->get().': '每个定义的服务默认都是私有的。当一个服务是私有时，你不能直接使用 <code translate="no" class="notranslate">$container-&gt;get()</code> 从容器中获取它。作为最佳实践，你应该只创建私有服务，并且应该通过依赖注入来获取服务，而不是使用 <code translate="no" class="notranslate">$container-&gt;get()</code>。',
        'If you need to fetch services lazily, instead of using public services you\nshould consider using a service locator.': '如果你需要懒加载服务，而不是使用公共服务，你应该考虑使用<a href="service_container/service_subscribers_locators.html#service-locators" class="reference internal">服务定位器（service locator）</a>。',
        'But, if you do need to make a service public, override the public\nsetting:': '但是，如果你确实需要将一个服务公开，覆盖 <code translate="no" class="notranslate">public</code> 设置：',
        'It is also possible to define a service as public thanks to the #[Autoconfigure]\nattribute. This attribute must be used directly on the class of the service\nyou want to configure:': '也可以通过使用 <code translate="no" class="notranslate">#[Autoconfigure]</code> 注解将服务定义为公开。此属性必须直接用于你想配置的服务类上：',

        'Importing Many Services at once with resource': '使用资源一次导入多个服务',
        'You\'ve already seen that you can import many services at once by using the resource\nkey. For example, the default Symfony configuration contains this:': '你已经看到可以通过使用 <code translate="no" class="notranslate">resource</code> 键一次性导入许多服务。例如，默认的 Symfony 配置中包含了这样一段：',
        'The value of the resource and exclude options can be any valid\nglob pattern. If you want to exclude only a few services, you\nmay use the Exclude\nattribute directly on your class to exclude it.': '<code translate="no" class="notranslate">resource</code> 和 <code translate="no" class="notranslate">exclude</code> 选项的值可以是任何有效的通配符模式。如果你想只排除少数几个服务，可以直接在你的类上使用 <a href="https://github.com/symfony/symfony/blob/6.4/src/Symfony/Component/DependencyInjection/Attribute/Exclude.php" class="reference external" title="Symfony\Component\DependencyInjection\Attribute\Exclude" rel="external noopener noreferrer" target="_blank">Exclude</a> 属性来排除它。',
        'The Exclude\nattribute was introduced in Symfony 6.3.': '<a href="https://github.com/symfony/symfony/blob/6.4/src/Symfony/Component/DependencyInjection/Attribute/Exclude.php" class="reference external" title="Symfony\Component\DependencyInjection\Attribute\Exclude" rel="external noopener noreferrer" target="_blank">Exclude</a> 属性是在 Symfony 6.3 中引入的。',
        'This can be used to quickly make many classes available as services and apply some\ndefault configuration. The id of each service is its fully-qualified class name.\nYou can override any service that\'s imported by using its id (class name) below\n(e.g. see how to manually wire arguments).\nIf you override a service, none of the options (e.g. public) are inherited\nfrom the import (but the overridden service does still inherit from _defaults).': '这可以用来快速地让许多类作为服务可用并应用一些默认配置。每个服务的 <code translate="no" class="notranslate">id</code> 是其完整的类名。你可以通过使用其 id（即类名）来覆盖任何导入的服务（例如，参见<a href="service_container.html#services-manually-wire-args" class="reference internal">如何手动绑定参数</a>）。如果你覆盖了一个服务，那么导入的选项（例如 <code translate="no" class="notranslate">public</code>）都不会被继承（但是被覆盖的服务仍然会继承自 `_defaults`）。',
        'You can also exclude certain paths. This is optional, but will slightly increase\nperformance in the dev environment: excluded paths are not tracked and so modifying\nthem will not cause the container to be rebuilt.': '你也可以 <code translate="no" class="notranslate">exclude</code> (排除) 某些路径。这虽然是可选的，但在 <code translate="no" class="notranslate">dev</code> 环境下会略微提升性能：被排除的路径不会被追踪，因此修改这些路径不会导致容器重新构建。',
        'Wait, does this mean that every class in src/ is registered as\na service? Even model classes? Actually, no. As long as you keep your imported services as private, all\nclasses in src/ that are not explicitly used as services are\nautomatically removed from the final container. In reality, the import\nmeans that all classes are "available to be used as services" without needing\nto be manually configured.': '等等，这是否意味着 <code translate="no" class="notranslate">src/</code> 目录下的每个类都注册为了服务？甚至是模型类？实际上，并不是。只要你保持导入的服务为<a href="service_container.html#container-public" class="reference internal">私有</a>，那么 <code translate="no" class="notranslate">src/</code> 目录下所有未被明确用作服务的类都会自动从最终的容器中移除。实际上，这样的导入意味着所有类都可以“作为服务来使用”而无需手动配置。',

        'Multiple Service Definitions Using the Same Namespace': '使用相同命名空间的多个服务定义',
        'If you define services using the YAML config format, the PHP namespace is used\nas the key of each configuration, so you can\'t define different service configs\nfor classes under the same namespace:': '如果你使用 YAML 配置格式定义服务，PHP 命名空间将用作每个配置的键，因此你无法为同一命名空间下的不同类定义不同的服务配置：',
        'In order to have multiple definitions, add the namespace option and use any\nunique string as the key of each service config:': '为了拥有多个定义，添加 <code translate="no" class="notranslate">namespace</code> 选项，并使用任何唯一的字符串作为每个服务配置的键：',

        'Explicitly Configuring Services and Arguments': '显式配置服务和参数',
        'Loading services automatically\nand autowiring are optional. And even if you use them, there may be some\ncases where you want to manually wire a service. For example, suppose that you want\nto register 2 services for the SiteUpdateManager class - each with a different\nadmin email. In this case, each needs to have a unique service id:': '<a href="service_container.html#service-container-services-load-example" class="reference internal">自动加载服务</a>和<a href="service_container.html#services-autowire" class="reference internal">自动绑定</a>是可选的。即使你使用了它们，也可能会有一些情况你需要手动绑定一个服务。例如，假设你想为 <code translate="no" class="notranslate">SiteUpdateManager</code> 类注册两个服务——每个服务具有不同的管理员邮箱。在这种情况下，每个服务都需要有一个唯一的服务 id：',
        'In this case, two services are registered: site_update_manager.superadmin\nand site_update_manager.normal_users. Thanks to the alias, if you type-hint\nSiteUpdateManager the first (site_update_manager.superadmin) will be passed.': '在这种情况下，注册了两个服务：<code translate="no" class="notranslate">site_update_manager.superadmin</code> 和 <code translate="no" class="notranslate">site_update_manager.normal_users</code>。由于别名的存在，如果你对 <code translate="no" class="notranslate">SiteUpdateManager</code> 进行类型提示，将会传递第一个服务（<code translate="no" class="notranslate">site_update_manager.superadmin</code>）。',
        'If you want to pass the second, you\'ll need to manually wire the service\nor to create a named autowiring alias.': '如果你想传递第二个服务，你需要<a href="service_container.html#services-wire-specific-service" class="reference internal">手动绑定该服务</a>或者创建一个命名的<a href="service_container/autowiring.html#autowiring-alias" class="reference internal">自动绑定别名</a>。',
        'If you do not create the alias and are loading all services from src/,\nthen three services have been created (the automatic service + your two services)\nand the automatically loaded service will be passed - by default - when you type-hint\nSiteUpdateManager. That\'s why creating the alias is a good idea.': '如果你没有创建别名并且是<a href="service_container.html#service-container-services-load-example" class="reference internal">从 <code translate="no" class="notranslate">src/</code> 目录下加载所有服务</a>，则会创建三个服务（自动加载的服务加上你定义的两个服务），并且当你对 <code translate="no" class="notranslate">SiteUpdateManager</code> 进行类型提示时，默认会传递自动加载的服务。这就是为什么创建别名是一个好主意的原因。',
        'When using PHP closures to configure your services, it is possible to automatically\ninject the current environment value by adding a string argument named $env to\nthe closure:': '当使用 PHP 闭包来配置你的服务时，可以通过向闭包添加一个名为 <code translate="no" class="notranslate">$env</code> 的字符串参数来自动注入当前环境的值：',

        'Generating Adapters for Functional Interfaces': '为函数式接口生成适配器',
        'Functional interfaces are interfaces with a single method.\nThey are conceptually very similar to a closure except that their only method\nhas a name. Moreover, they can be used as type-hints across your code.': '函数式接口是指只有一个方法的接口。它们在概念上与闭包非常相似，区别在于它们的唯一方法有名称。此外，它们可以在你的代码中用作类型提示。',
        'The AutowireCallable\nattribute can be used to generate an adapter for a functional interface.\nLet\'s say you have the following functional interface:': '<a href="https://github.com/symfony/symfony/blob/6.4/src/Symfony/Component/DependencyInjection/Attribute/AutowireCallable.php" class="reference external" title="Symfony\Component\DependencyInjection\Attribute\AutowireCallable" rel="external noopener noreferrer" target="_blank">AutowireCallable</a> 属性可以用于为函数式接口生成一个适配器。假设你有如下函数式接口：',
        'You also have a service that defines many methods and one of them is the same\nformat() method of the previous interface:': '你还有一个服务，该服务定义了许多方法，其中有一个方法与上述接口中的 <code translate="no" class="notranslate">format()</code> 方法相同：',
        'Thanks to the #[AutowireCallable] attribute, you can now inject this\nMessageUtils service as a functional interface implementation:': '借助 <code translate="no" class="notranslate">#[AutowireCallable]</code> 注解，你现在可以将 <code translate="no" class="notranslate">MessageUtils</code> 服务注入为函数式接口的实现：',
        'The AutowireCallable\nattribute was introduced in Symfony 6.3.': '<a href="https://github.com/symfony/symfony/blob/6.4/src/Symfony/Component/DependencyInjection/Attribute/AutowireCallable.php" class="reference external" title="Symfony\Component\DependencyInjection\Attribute\AutowireCallable" rel="external noopener noreferrer" target="_blank">AutowireCallable</a> 注解是在 Symfony 6.3 中引入的。',
        'Instead of using the #[AutowireCallable] attribute, you can also generate\nan adapter for a functional interface through configuration:': '除了使用 <code translate="no" class="notranslate">#[AutowireCallable]</code> 注解之外，你还可以通过配置来为函数式接口生成一个适配器：',
        'By doing so, Symfony will generate a class (also called an adapter)\nimplementing MessageFormatterInterface that will forward calls of\nMessageFormatterInterface::format() to your underlying service\'s method\nMessageUtils::format(), with all its arguments.': '通过这样做，Symfony 会生成一个类（也称为适配器），该类实现了 <code translate="no" class="notranslate">MessageFormatterInterface</code>，并将 <code translate="no" class="notranslate">MessageFormatterInterface::format()</code> 的调用转发到底层服务的方法 <code translate="no" class="notranslate">MessageUtils::format()</code>，包括其所有的参数。',

        'Learn more': '了解更多',
        'How to Create Service Aliases and Mark Services as Private': '<a href="service_container/alias_private.html">如何创建服务别名和将服务标记为私有</a>',
        'Defining Services Dependencies Automatically (Autowiring)':'<a href="service_container/autowiring.html">自动定义服务依赖（自动装配，Autowiring）</a>',
        'Service Method Calls and Setter Injection': '<a href="service_container/calls.html">服务方法调用和 Setter 注入</a>',
        'How to Work with Compiler Passes': '<a href="service_container/compiler_passes.html">如何使用编译器传递（Compiler Passes）工作</a>',
        'How to Configure a Service with a Configurator': '<a href="service_container/configurators.html">如何使用配置器配置服务</a>',
        'How to Debug the Service Container & List Services': '<a href="service_container/debug.html">如何调试服务容器和列出服务</a>',
        'How to work with Service Definition Objects': '<a href="service_container/definitions.html">如何使用服务定义对象工作</a>',
        'How to Inject Values Based on Complex Expressions': '<a href="service_container/expression_language.html">如何基于复杂表达式注入值</a>',
        'Using a Factory to Create Services': '<a href="service_container/factories.html">使用工厂创建服务</a>',
        'How to Import Configuration Files/Resources': '<a href="service_container/import.html">如何导入配置文件/资源</a>',
        'Types of Injection': '<a href="service_container/injection_types.html">注入的类型</a>',
        'Lazy Services': '<a href="service_container/lazy_services.html">懒加载服务</a>',
        'How to Make Service Arguments/References Optional': '<a href="service_container/optional_dependencies.html">如何使服务参数/引用成为可选的</a>',
        'How to Manage Common Dependencies with Parent Services': '<a href="service_container/parent_services.html">如何使用父服务管理公共依赖项</a>',
        'How to Retrieve the Request from the Service Container':'<a href="service_container/request.html">如何从服务容器中获取请求（Request）</a>',
        'Service Closures': '<a href="service_container/service_closures.html">服务闭包（Service Closures）</a>',
        'How to Decorate Services': '<a href="service_container/service_decoration.html">如何装饰服务（How to Decorate Services）</a>',
        'Service Subscribers & Locators': '<a href="service_container/service_subscribers_locators.html">服务订阅者和定位器（Service Subscribers &amp; Locators）</a>',
        'How to Define Non Shared Services': '<a href="service_container/shared.html">如何定义非共享服务</a>',
        'How to Inject Instances into the Container': '<a href="service_container/synthetic_services.html">如何将实例注入到容器中</a>',
        'How to Work with Service Tags': '<a href="service_container/tags.html">如何使用服务标签（Service Tags）</a>'
    };

    fanyi(translates, 1);
})($);
