// ==UserScript==
// @name         codesign-css-transform
// @namespace    vite-plugin-monkey
// @version      0.0.5
// @author       gorvey
// @description  将css转换为tailwind代码
// @license      MIT
// @match        https://codesign.qq.com/app/design/*
// @require      https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4
// @grant        GM_addStyle
// @grant        GM_deleteValue
// @grant        GM_getValue
// @grant        GM_setValue
// @run-at       document-idle
// @downloadURL https://update.greasyfork.org/scripts/530804/codesign-css-transform.user.js
// @updateURL https://update.greasyfork.org/scripts/530804/codesign-css-transform.meta.js
// ==/UserScript==

(t => { if (typeof GM_addStyle == "function") { GM_addStyle(t); return } const o = document.createElement("style"); o.textContent = t, document.head.append(o) })(' .t-loading{font:var(--td-font-body-medium);color:var(--td-text-color-primary);box-sizing:border-box;margin:0;padding:0;list-style:none;position:relative;color:var(--td-brand-color);font-size:var(--td-comp-size-l)}.t-loading--lock{overflow:hidden}.t-loading.t-size-s{font-size:var(--td-comp-size-xxxs)}.t-loading.t-size-l{font-size:var(--td-comp-size-xxxl)}.t-loading__parent--relative{position:relative!important}.t-loading__fullscreen{position:fixed;top:0;left:0;width:100%;height:100%;z-index:3500}.t-loading--center{display:inline-flex;align-items:center;vertical-align:middle;justify-content:center}.t-loading__content{position:absolute;left:48%;top:20%}.t-loading--inherit-color{color:inherit}.t-loading__parent{position:relative}.t-loading__overlay{background-color:var(--td-mask-disabled)}.t-loading--full{position:absolute;top:0;left:0;width:100%;height:100%;z-index:3500}.t-loading--hidden{visibility:hidden}.t-loading--visible{visibility:visible}.t-loading__text{width:auto;display:inline-block;vertical-align:middle;font:var(--td-font-body-medium);margin-left:var(--td-comp-margin-xs)}.t-loading__gradient{display:inline-flex;justify-content:center;align-items:center;vertical-align:middle}.t-loading__gradient-conic{width:100%;height:100%;border-radius:var(--td-radius-circle);background:conic-gradient(from 90deg at 50% 50%,#fff 0deg,currentcolor 360deg);-webkit-mask:radial-gradient(transparent calc(50% - .5px),#fff 50%);mask:radial-gradient(transparent calc(50% - .5px),#fff 50%)}.t-button{font:var(--td-font-body-medium);color:var(--td-text-color-primary);box-sizing:border-box;margin:0;padding:0;list-style:none;position:relative;z-index:0;overflow:hidden;font-size:var(--td-font-body-medium);outline:none;border-width:1px;border-style:solid;border-color:transparent;background-color:transparent;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;vertical-align:middle;white-space:nowrap;border-radius:var(--td-radius-default);transition:all .2s linear;touch-action:manipulation;text-decoration:none}.t-button .t-button__text,.t-button .t-icon{position:relative;z-index:1;display:inline-flex}.t-button .t-icon,.t-button .t-loading{font-size:var(--td-font-size-body-large)}.t-button .t-icon+.t-button__text:not(:empty){margin-left:8px}.t-button .t-loading+.t-button__text:not(:empty){margin-left:8px}.t-button .t-button__suffix:not(:empty){display:inline-flex;margin-left:8px}.t-button--variant-base{color:var(--td-text-color-anti);height:var(--td-comp-size-m);font:var(--td-font-body-medium);padding-left:calc(var(--td-comp-paddingLR-l) - 1px);padding-right:calc(var(--td-comp-paddingLR-l) - 1px);background-color:var(--td-bg-color-component);border-color:var(--td-bg-color-component);color:var(--td-text-color-primary)}.t-button--variant-base .t-icon,.t-button--variant-base .t-loading{font-size:var(--td-font-size-body-large)}.t-button--variant-base:hover,.t-button--variant-base:focus-visible{background-color:var(--td-bg-color-component-hover)}.t-button--variant-base.t-is-loading{background-color:var(--td-bg-color-component)}.t-button--variant-base.t-is-disabled{background-color:var(--td-bg-color-component-disabled)}.t-button--variant-base:hover,.t-button--variant-base:focus-visible{border-color:var(--td-bg-color-component-hover)}.t-button--variant-base.t-is-loading{border-color:var(--td-bg-color-component)}.t-button--variant-base.t-is-disabled{border-color:var(--td-bg-color-component-disabled)}.t-button--variant-base:hover,.t-button--variant-base:focus-visible{color:var(--td-text-color-primary)}.t-button--variant-base.t-is-loading{color:var(--td-text-color-primary)}.t-button--variant-base.t-is-disabled{color:var(--td-text-color-disabled)}.t-button--variant-base.t-button--theme-primary{color:var(--td-text-color-anti);background-color:var(--td-brand-color);border-color:var(--td-brand-color)}.t-button--variant-base.t-button--theme-primary:hover,.t-button--variant-base.t-button--theme-primary:focus-visible{background-color:var(--td-brand-color-hover)}.t-button--variant-base.t-button--theme-primary.t-is-loading{background-color:var(--td-brand-color)}.t-button--variant-base.t-button--theme-primary.t-is-disabled{background-color:var(--td-brand-color-disabled)}.t-button--variant-base.t-button--theme-primary:hover,.t-button--variant-base.t-button--theme-primary:focus-visible{border-color:var(--td-brand-color-hover)}.t-button--variant-base.t-button--theme-primary.t-is-loading{border-color:var(--td-brand-color)}.t-button--variant-base.t-button--theme-primary.t-is-disabled{border-color:var(--td-brand-color-disabled)}.t-button--variant-base.t-button--theme-success{color:var(--td-text-color-anti);background-color:var(--td-success-color);border-color:var(--td-success-color)}.t-button--variant-base.t-button--theme-success:hover,.t-button--variant-base.t-button--theme-success:focus-visible{background-color:var(--td-success-color-hover)}.t-button--variant-base.t-button--theme-success.t-is-loading{background-color:var(--td-success-color)}.t-button--variant-base.t-button--theme-success.t-is-disabled{background-color:var(--td-success-color-disabled)}.t-button--variant-base.t-button--theme-success:hover,.t-button--variant-base.t-button--theme-success:focus-visible{border-color:var(--td-success-color-hover)}.t-button--variant-base.t-button--theme-success.t-is-loading{border-color:var(--td-success-color)}.t-button--variant-base.t-button--theme-success.t-is-disabled{border-color:var(--td-success-color-disabled)}.t-button--variant-base.t-button--theme-warning{color:var(--td-text-color-anti);background-color:var(--td-warning-color);border-color:var(--td-warning-color)}.t-button--variant-base.t-button--theme-warning:hover,.t-button--variant-base.t-button--theme-warning:focus-visible{background-color:var(--td-warning-color-hover)}.t-button--variant-base.t-button--theme-warning.t-is-loading{background-color:var(--td-warning-color)}.t-button--variant-base.t-button--theme-warning.t-is-disabled{background-color:var(--td-warning-color-disabled)}.t-button--variant-base.t-button--theme-warning:hover,.t-button--variant-base.t-button--theme-warning:focus-visible{border-color:var(--td-warning-color-hover)}.t-button--variant-base.t-button--theme-warning.t-is-loading{border-color:var(--td-warning-color)}.t-button--variant-base.t-button--theme-warning.t-is-disabled{border-color:var(--td-warning-color-disabled)}.t-button--variant-base.t-button--theme-danger{color:var(--td-text-color-anti);background-color:var(--td-error-color);border-color:var(--td-error-color)}.t-button--variant-base.t-button--theme-danger:hover,.t-button--variant-base.t-button--theme-danger:focus-visible{background-color:var(--td-error-color-hover)}.t-button--variant-base.t-button--theme-danger.t-is-loading{background-color:var(--td-error-color)}.t-button--variant-base.t-button--theme-danger.t-is-disabled{background-color:var(--td-error-color-disabled)}.t-button--variant-base.t-button--theme-danger:hover,.t-button--variant-base.t-button--theme-danger:focus-visible{border-color:var(--td-error-color-hover)}.t-button--variant-base.t-button--theme-danger.t-is-loading{border-color:var(--td-error-color)}.t-button--variant-base.t-button--theme-danger.t-is-disabled{border-color:var(--td-error-color-disabled)}.t-button--variant-base.t-button--ghost{background-color:transparent;color:var(--td-text-color-anti);border-color:var(--td-text-color-anti)}.t-button--variant-base.t-button--ghost:hover,.t-button--variant-base.t-button--ghost:focus-visible{background-color:transparent}.t-button--variant-base.t-button--ghost:active,.t-button--variant-base.t-button--ghost.t-is-loading{background-color:transparent}.t-button--variant-base.t-button--ghost.t-is-disabled{background-color:#ffffff38;background-color:transparent}.t-button--variant-base.t-button--ghost:hover,.t-button--variant-base.t-button--ghost:focus-visible{color:var(--td-brand-color-hover)}.t-button--variant-base.t-button--ghost:active{color:var(--td-brand-color-active)}.t-button--variant-base.t-button--ghost.t-is-loading{color:var(--td-text-color-anti)}.t-button--variant-base.t-button--ghost.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-base.t-button--ghost:hover,.t-button--variant-base.t-button--ghost:focus-visible{border-color:var(--td-brand-color-hover)}.t-button--variant-base.t-button--ghost:active{border-color:var(--td-brand-color-active)}.t-button--variant-base.t-button--ghost.t-is-loading{border-color:var(--td-text-color-anti)}.t-button--variant-base.t-button--ghost.t-is-disabled{border-color:#ffffff38;background-color:transparent}.t-button--variant-base.t-button--ghost.t-button--theme-primary{color:var(--td-brand-color);border-color:var(--td-brand-color)}.t-button--variant-base.t-button--ghost.t-button--theme-primary:hover,.t-button--variant-base.t-button--ghost.t-button--theme-primary:focus-visible{color:var(--td-brand-color-hover)}.t-button--variant-base.t-button--ghost.t-button--theme-primary:active{color:var(--td-brand-color-active)}.t-button--variant-base.t-button--ghost.t-button--theme-primary.t-is-loading{color:var(--td-brand-color)}.t-button--variant-base.t-button--ghost.t-button--theme-primary.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-base.t-button--ghost.t-button--theme-primary:hover,.t-button--variant-base.t-button--ghost.t-button--theme-primary:focus-visible{border-color:var(--td-brand-color-hover)}.t-button--variant-base.t-button--ghost.t-button--theme-primary:active{border-color:var(--td-brand-color-active)}.t-button--variant-base.t-button--ghost.t-button--theme-primary.t-is-loading{border-color:var(--td-brand-color)}.t-button--variant-base.t-button--ghost.t-button--theme-primary.t-is-disabled{border-color:#ffffff38;background-color:transparent}.t-button--variant-base.t-button--ghost.t-button--theme-success{color:var(--td-success-color);border-color:var(--td-success-color)}.t-button--variant-base.t-button--ghost.t-button--theme-success:hover,.t-button--variant-base.t-button--ghost.t-button--theme-success:focus-visible{color:var(--td-success-color-hover)}.t-button--variant-base.t-button--ghost.t-button--theme-success:active{color:var(--td-success-color-active)}.t-button--variant-base.t-button--ghost.t-button--theme-success.t-is-loading{color:var(--td-success-color)}.t-button--variant-base.t-button--ghost.t-button--theme-success.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-base.t-button--ghost.t-button--theme-success:hover,.t-button--variant-base.t-button--ghost.t-button--theme-success:focus-visible{border-color:var(--td-success-color-hover)}.t-button--variant-base.t-button--ghost.t-button--theme-success:active{border-color:var(--td-success-color-active)}.t-button--variant-base.t-button--ghost.t-button--theme-success.t-is-loading{border-color:var(--td-success-color)}.t-button--variant-base.t-button--ghost.t-button--theme-success.t-is-disabled{border-color:#ffffff38;background-color:transparent}.t-button--variant-base.t-button--ghost.t-button--theme-warning{color:var(--td-warning-color);border-color:var(--td-warning-color)}.t-button--variant-base.t-button--ghost.t-button--theme-warning:hover,.t-button--variant-base.t-button--ghost.t-button--theme-warning:focus-visible{color:var(--td-warning-color-hover)}.t-button--variant-base.t-button--ghost.t-button--theme-warning:active{color:var(--td-warning-color-active)}.t-button--variant-base.t-button--ghost.t-button--theme-warning.t-is-loading{color:var(--td-warning-color)}.t-button--variant-base.t-button--ghost.t-button--theme-warning.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-base.t-button--ghost.t-button--theme-warning:hover,.t-button--variant-base.t-button--ghost.t-button--theme-warning:focus-visible{border-color:var(--td-warning-color-hover)}.t-button--variant-base.t-button--ghost.t-button--theme-warning:active{border-color:var(--td-warning-color-active)}.t-button--variant-base.t-button--ghost.t-button--theme-warning.t-is-loading{border-color:var(--td-warning-color)}.t-button--variant-base.t-button--ghost.t-button--theme-warning.t-is-disabled{border-color:#ffffff38;background-color:transparent}.t-button--variant-base.t-button--ghost.t-button--theme-danger{color:var(--td-error-color);border-color:var(--td-error-color)}.t-button--variant-base.t-button--ghost.t-button--theme-danger:hover,.t-button--variant-base.t-button--ghost.t-button--theme-danger:focus-visible{color:var(--td-error-color-hover)}.t-button--variant-base.t-button--ghost.t-button--theme-danger:active{color:var(--td-error-color-active)}.t-button--variant-base.t-button--ghost.t-button--theme-danger.t-is-loading{color:var(--td-error-color)}.t-button--variant-base.t-button--ghost.t-button--theme-danger.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-base.t-button--ghost.t-button--theme-danger:hover,.t-button--variant-base.t-button--ghost.t-button--theme-danger:focus-visible{border-color:var(--td-error-color-hover)}.t-button--variant-base.t-button--ghost.t-button--theme-danger:active{border-color:var(--td-error-color-active)}.t-button--variant-base.t-button--ghost.t-button--theme-danger.t-is-loading{border-color:var(--td-error-color)}.t-button--variant-base.t-button--ghost.t-button--theme-danger.t-is-disabled{border-color:#ffffff38;background-color:transparent}.t-button--variant-outline{height:var(--td-comp-size-m);font:var(--td-font-body-medium);padding-left:calc(var(--td-comp-paddingLR-l) - 1px);padding-right:calc(var(--td-comp-paddingLR-l) - 1px);color:var(--td-text-color-primary);background-color:var(--td-bg-color-specialcomponent);border-color:var(--td-border-level-2-color)}.t-button--variant-outline .t-icon,.t-button--variant-outline .t-loading{font-size:var(--td-font-size-body-large)}.t-button--variant-outline:hover,.t-button--variant-outline:focus-visible{color:var(--td-brand-color-hover)}.t-button--variant-outline.t-is-loading{color:var(--td-text-color-primary)}.t-button--variant-outline.t-is-disabled{color:var(--td-text-color-disabled)}.t-button--variant-outline:hover,.t-button--variant-outline:focus-visible{background-color:var(--td-bg-color-specialcomponent)}.t-button--variant-outline.t-is-loading{background-color:var(--td-bg-color-specialcomponent)}.t-button--variant-outline.t-is-disabled{background-color:var(--td-bg-color-component-disabled)}.t-button--variant-outline:hover,.t-button--variant-outline:focus-visible{border-color:var(--td-brand-color-hover)}.t-button--variant-outline.t-is-loading,.t-button--variant-outline.t-is-disabled{border-color:var(--td-border-level-2-color)}.t-button--variant-outline.t-button--theme-primary{color:var(--td-brand-color);border-color:var(--td-brand-color)}.t-button--variant-outline.t-button--theme-primary:hover,.t-button--variant-outline.t-button--theme-primary:focus-visible{color:var(--td-brand-color-hover)}.t-button--variant-outline.t-button--theme-primary.t-is-loading{color:var(--td-brand-color)}.t-button--variant-outline.t-button--theme-primary.t-is-disabled{color:var(--td-brand-color-disabled)}.t-button--variant-outline.t-button--theme-primary:hover,.t-button--variant-outline.t-button--theme-primary:focus-visible{border-color:var(--td-brand-color-hover)}.t-button--variant-outline.t-button--theme-primary.t-is-loading{border-color:var(--td-brand-color)}.t-button--variant-outline.t-button--theme-primary.t-is-disabled{border-color:var(--td-brand-color-disabled)}.t-button--variant-outline.t-button--theme-success{color:var(--td-success-color);border-color:var(--td-success-color)}.t-button--variant-outline.t-button--theme-success:hover,.t-button--variant-outline.t-button--theme-success:focus-visible{color:var(--td-success-color-hover)}.t-button--variant-outline.t-button--theme-success.t-is-loading{color:var(--td-success-color)}.t-button--variant-outline.t-button--theme-success.t-is-disabled{color:var(--td-success-color-disabled)}.t-button--variant-outline.t-button--theme-success:hover,.t-button--variant-outline.t-button--theme-success:focus-visible{border-color:var(--td-success-color-hover)}.t-button--variant-outline.t-button--theme-success.t-is-loading{border-color:var(--td-success-color)}.t-button--variant-outline.t-button--theme-success.t-is-disabled{border-color:var(--td-success-color-disabled)}.t-button--variant-outline.t-button--theme-warning{color:var(--td-warning-color);border-color:var(--td-warning-color)}.t-button--variant-outline.t-button--theme-warning:hover,.t-button--variant-outline.t-button--theme-warning:focus-visible{color:var(--td-warning-color-hover)}.t-button--variant-outline.t-button--theme-warning.t-is-loading{color:var(--td-warning-color)}.t-button--variant-outline.t-button--theme-warning.t-is-disabled{color:var(--td-warning-color-disabled)}.t-button--variant-outline.t-button--theme-warning:hover,.t-button--variant-outline.t-button--theme-warning:focus-visible{border-color:var(--td-warning-color-hover)}.t-button--variant-outline.t-button--theme-warning.t-is-loading{border-color:var(--td-warning-color)}.t-button--variant-outline.t-button--theme-warning.t-is-disabled{border-color:var(--td-warning-color-disabled)}.t-button--variant-outline.t-button--theme-danger{color:var(--td-error-color);border-color:var(--td-error-color)}.t-button--variant-outline.t-button--theme-danger:hover,.t-button--variant-outline.t-button--theme-danger:focus-visible{color:var(--td-error-color-hover)}.t-button--variant-outline.t-button--theme-danger.t-is-loading{color:var(--td-error-color)}.t-button--variant-outline.t-button--theme-danger.t-is-disabled{color:var(--td-error-color-disabled)}.t-button--variant-outline.t-button--theme-danger:hover,.t-button--variant-outline.t-button--theme-danger:focus-visible{border-color:var(--td-error-color-hover)}.t-button--variant-outline.t-button--theme-danger.t-is-loading{border-color:var(--td-error-color)}.t-button--variant-outline.t-button--theme-danger.t-is-disabled{border-color:var(--td-error-color-disabled)}.t-button--variant-outline.t-button--ghost{background-color:transparent;color:var(--td-text-color-anti);border-color:var(--td-text-color-anti)}.t-button--variant-outline.t-button--ghost:hover,.t-button--variant-outline.t-button--ghost:focus-visible{background-color:transparent}.t-button--variant-outline.t-button--ghost:active,.t-button--variant-outline.t-button--ghost.t-is-loading{background-color:transparent}.t-button--variant-outline.t-button--ghost.t-is-disabled{background-color:#ffffff38;background-color:transparent}.t-button--variant-outline.t-button--ghost:hover,.t-button--variant-outline.t-button--ghost:focus-visible{color:var(--td-brand-color-hover)}.t-button--variant-outline.t-button--ghost:active{color:var(--td-brand-color-active)}.t-button--variant-outline.t-button--ghost.t-is-loading{color:var(--td-text-color-anti)}.t-button--variant-outline.t-button--ghost.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-outline.t-button--ghost:hover,.t-button--variant-outline.t-button--ghost:focus-visible{border-color:var(--td-brand-color-hover)}.t-button--variant-outline.t-button--ghost:active{border-color:var(--td-brand-color-active)}.t-button--variant-outline.t-button--ghost.t-is-loading{border-color:var(--td-text-color-anti)}.t-button--variant-outline.t-button--ghost.t-is-disabled{border-color:#ffffff38;background-color:transparent}.t-button--variant-outline.t-button--ghost.t-button--theme-primary{color:var(--td-brand-color);border-color:var(--td-brand-color)}.t-button--variant-outline.t-button--ghost.t-button--theme-primary:hover,.t-button--variant-outline.t-button--ghost.t-button--theme-primary:focus-visible{color:var(--td-brand-color-hover)}.t-button--variant-outline.t-button--ghost.t-button--theme-primary:active{color:var(--td-brand-color-active)}.t-button--variant-outline.t-button--ghost.t-button--theme-primary.t-is-loading{color:var(--td-brand-color)}.t-button--variant-outline.t-button--ghost.t-button--theme-primary.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-outline.t-button--ghost.t-button--theme-primary:hover,.t-button--variant-outline.t-button--ghost.t-button--theme-primary:focus-visible{border-color:var(--td-brand-color-hover)}.t-button--variant-outline.t-button--ghost.t-button--theme-primary:active{border-color:var(--td-brand-color-active)}.t-button--variant-outline.t-button--ghost.t-button--theme-primary.t-is-loading{border-color:var(--td-brand-color)}.t-button--variant-outline.t-button--ghost.t-button--theme-primary.t-is-disabled{border-color:#ffffff38;background-color:transparent}.t-button--variant-outline.t-button--ghost.t-button--theme-success{color:var(--td-success-color);border-color:var(--td-success-color)}.t-button--variant-outline.t-button--ghost.t-button--theme-success:hover,.t-button--variant-outline.t-button--ghost.t-button--theme-success:focus-visible{color:var(--td-success-color-hover)}.t-button--variant-outline.t-button--ghost.t-button--theme-success:active{color:var(--td-success-color-active)}.t-button--variant-outline.t-button--ghost.t-button--theme-success.t-is-loading{color:var(--td-success-color)}.t-button--variant-outline.t-button--ghost.t-button--theme-success.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-outline.t-button--ghost.t-button--theme-success:hover,.t-button--variant-outline.t-button--ghost.t-button--theme-success:focus-visible{border-color:var(--td-success-color-hover)}.t-button--variant-outline.t-button--ghost.t-button--theme-success:active{border-color:var(--td-success-color-active)}.t-button--variant-outline.t-button--ghost.t-button--theme-success.t-is-loading{border-color:var(--td-success-color)}.t-button--variant-outline.t-button--ghost.t-button--theme-success.t-is-disabled{border-color:#ffffff38;background-color:transparent}.t-button--variant-outline.t-button--ghost.t-button--theme-warning{color:var(--td-warning-color);border-color:var(--td-warning-color)}.t-button--variant-outline.t-button--ghost.t-button--theme-warning:hover,.t-button--variant-outline.t-button--ghost.t-button--theme-warning:focus-visible{color:var(--td-warning-color-hover)}.t-button--variant-outline.t-button--ghost.t-button--theme-warning:active{color:var(--td-warning-color-active)}.t-button--variant-outline.t-button--ghost.t-button--theme-warning.t-is-loading{color:var(--td-warning-color)}.t-button--variant-outline.t-button--ghost.t-button--theme-warning.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-outline.t-button--ghost.t-button--theme-warning:hover,.t-button--variant-outline.t-button--ghost.t-button--theme-warning:focus-visible{border-color:var(--td-warning-color-hover)}.t-button--variant-outline.t-button--ghost.t-button--theme-warning:active{border-color:var(--td-warning-color-active)}.t-button--variant-outline.t-button--ghost.t-button--theme-warning.t-is-loading{border-color:var(--td-warning-color)}.t-button--variant-outline.t-button--ghost.t-button--theme-warning.t-is-disabled{border-color:#ffffff38;background-color:transparent}.t-button--variant-outline.t-button--ghost.t-button--theme-danger{color:var(--td-error-color);border-color:var(--td-error-color)}.t-button--variant-outline.t-button--ghost.t-button--theme-danger:hover,.t-button--variant-outline.t-button--ghost.t-button--theme-danger:focus-visible{color:var(--td-error-color-hover)}.t-button--variant-outline.t-button--ghost.t-button--theme-danger:active{color:var(--td-error-color-active)}.t-button--variant-outline.t-button--ghost.t-button--theme-danger.t-is-loading{color:var(--td-error-color)}.t-button--variant-outline.t-button--ghost.t-button--theme-danger.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-outline.t-button--ghost.t-button--theme-danger:hover,.t-button--variant-outline.t-button--ghost.t-button--theme-danger:focus-visible{border-color:var(--td-error-color-hover)}.t-button--variant-outline.t-button--ghost.t-button--theme-danger:active{border-color:var(--td-error-color-active)}.t-button--variant-outline.t-button--ghost.t-button--theme-danger.t-is-loading{border-color:var(--td-error-color)}.t-button--variant-outline.t-button--ghost.t-button--theme-danger.t-is-disabled{border-color:#ffffff38;background-color:transparent}.t-button--variant-dashed{height:var(--td-comp-size-m);font:var(--td-font-body-medium);padding-left:calc(var(--td-comp-paddingLR-l) - 1px);padding-right:calc(var(--td-comp-paddingLR-l) - 1px);color:var(--td-text-color-primary);background-color:var(--td-bg-color-specialcomponent);border-color:var(--td-border-level-2-color);border-style:dashed}.t-button--variant-dashed .t-icon,.t-button--variant-dashed .t-loading{font-size:var(--td-font-size-body-large)}.t-button--variant-dashed:hover,.t-button--variant-dashed:focus-visible{color:var(--td-brand-color-hover)}.t-button--variant-dashed.t-is-loading{color:var(--td-text-color-primary)}.t-button--variant-dashed.t-is-disabled{color:var(--td-text-color-disabled)}.t-button--variant-dashed:hover,.t-button--variant-dashed:focus-visible{background-color:var(--td-bg-color-specialcomponent)}.t-button--variant-dashed.t-is-loading{background-color:var(--td-bg-color-specialcomponent)}.t-button--variant-dashed.t-is-disabled{background-color:var(--td-bg-color-component-disabled)}.t-button--variant-dashed:hover,.t-button--variant-dashed:focus-visible{border-color:var(--td-brand-color-hover)}.t-button--variant-dashed.t-is-loading,.t-button--variant-dashed.t-is-disabled{border-color:var(--td-border-level-2-color)}.t-button--variant-dashed.t-button--theme-primary{color:var(--td-brand-color);border-color:var(--td-brand-color)}.t-button--variant-dashed.t-button--theme-primary:hover,.t-button--variant-dashed.t-button--theme-primary:focus-visible{color:var(--td-brand-color-hover)}.t-button--variant-dashed.t-button--theme-primary.t-is-loading{color:var(--td-brand-color)}.t-button--variant-dashed.t-button--theme-primary.t-is-disabled{color:var(--td-brand-color-disabled)}.t-button--variant-dashed.t-button--theme-primary:hover,.t-button--variant-dashed.t-button--theme-primary:focus-visible{border-color:var(--td-brand-color-hover)}.t-button--variant-dashed.t-button--theme-primary.t-is-loading{border-color:var(--td-brand-color)}.t-button--variant-dashed.t-button--theme-primary.t-is-disabled{border-color:var(--td-brand-color-disabled)}.t-button--variant-dashed.t-button--theme-success{color:var(--td-success-color);border-color:var(--td-success-color)}.t-button--variant-dashed.t-button--theme-success:hover,.t-button--variant-dashed.t-button--theme-success:focus-visible{color:var(--td-success-color-hover)}.t-button--variant-dashed.t-button--theme-success.t-is-loading{color:var(--td-success-color)}.t-button--variant-dashed.t-button--theme-success.t-is-disabled{color:var(--td-success-color-disabled)}.t-button--variant-dashed.t-button--theme-success:hover,.t-button--variant-dashed.t-button--theme-success:focus-visible{border-color:var(--td-success-color-hover)}.t-button--variant-dashed.t-button--theme-success.t-is-loading{border-color:var(--td-success-color)}.t-button--variant-dashed.t-button--theme-success.t-is-disabled{border-color:var(--td-success-color-disabled)}.t-button--variant-dashed.t-button--theme-warning{color:var(--td-warning-color);border-color:var(--td-warning-color)}.t-button--variant-dashed.t-button--theme-warning:hover,.t-button--variant-dashed.t-button--theme-warning:focus-visible{color:var(--td-warning-color-hover)}.t-button--variant-dashed.t-button--theme-warning.t-is-loading{color:var(--td-warning-color)}.t-button--variant-dashed.t-button--theme-warning.t-is-disabled{color:var(--td-warning-color-disabled)}.t-button--variant-dashed.t-button--theme-warning:hover,.t-button--variant-dashed.t-button--theme-warning:focus-visible{border-color:var(--td-warning-color-hover)}.t-button--variant-dashed.t-button--theme-warning.t-is-loading{border-color:var(--td-warning-color)}.t-button--variant-dashed.t-button--theme-warning.t-is-disabled{border-color:var(--td-warning-color-disabled)}.t-button--variant-dashed.t-button--theme-danger{color:var(--td-error-color);border-color:var(--td-error-color)}.t-button--variant-dashed.t-button--theme-danger:hover,.t-button--variant-dashed.t-button--theme-danger:focus-visible{color:var(--td-error-color-hover)}.t-button--variant-dashed.t-button--theme-danger.t-is-loading{color:var(--td-error-color)}.t-button--variant-dashed.t-button--theme-danger.t-is-disabled{color:var(--td-error-color-disabled)}.t-button--variant-dashed.t-button--theme-danger:hover,.t-button--variant-dashed.t-button--theme-danger:focus-visible{border-color:var(--td-error-color-hover)}.t-button--variant-dashed.t-button--theme-danger.t-is-loading{border-color:var(--td-error-color)}.t-button--variant-dashed.t-button--theme-danger.t-is-disabled{border-color:var(--td-error-color-disabled)}.t-button--variant-dashed.t-button--ghost{background-color:transparent;color:var(--td-text-color-anti);border-color:var(--td-text-color-anti)}.t-button--variant-dashed.t-button--ghost:hover,.t-button--variant-dashed.t-button--ghost:focus-visible{background-color:transparent}.t-button--variant-dashed.t-button--ghost:active,.t-button--variant-dashed.t-button--ghost.t-is-loading{background-color:transparent}.t-button--variant-dashed.t-button--ghost.t-is-disabled{background-color:#ffffff38;background-color:transparent}.t-button--variant-dashed.t-button--ghost:hover,.t-button--variant-dashed.t-button--ghost:focus-visible{color:var(--td-brand-color-hover)}.t-button--variant-dashed.t-button--ghost:active{color:var(--td-brand-color-active)}.t-button--variant-dashed.t-button--ghost.t-is-loading{color:var(--td-text-color-anti)}.t-button--variant-dashed.t-button--ghost.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-dashed.t-button--ghost:hover,.t-button--variant-dashed.t-button--ghost:focus-visible{border-color:var(--td-brand-color-hover)}.t-button--variant-dashed.t-button--ghost:active{border-color:var(--td-brand-color-active)}.t-button--variant-dashed.t-button--ghost.t-is-loading{border-color:var(--td-text-color-anti)}.t-button--variant-dashed.t-button--ghost.t-is-disabled{border-color:#ffffff38;background-color:transparent}.t-button--variant-dashed.t-button--ghost.t-button--theme-primary{color:var(--td-brand-color);border-color:var(--td-brand-color)}.t-button--variant-dashed.t-button--ghost.t-button--theme-primary:hover,.t-button--variant-dashed.t-button--ghost.t-button--theme-primary:focus-visible{color:var(--td-brand-color-hover)}.t-button--variant-dashed.t-button--ghost.t-button--theme-primary:active{color:var(--td-brand-color-active)}.t-button--variant-dashed.t-button--ghost.t-button--theme-primary.t-is-loading{color:var(--td-brand-color)}.t-button--variant-dashed.t-button--ghost.t-button--theme-primary.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-dashed.t-button--ghost.t-button--theme-primary:hover,.t-button--variant-dashed.t-button--ghost.t-button--theme-primary:focus-visible{border-color:var(--td-brand-color-hover)}.t-button--variant-dashed.t-button--ghost.t-button--theme-primary:active{border-color:var(--td-brand-color-active)}.t-button--variant-dashed.t-button--ghost.t-button--theme-primary.t-is-loading{border-color:var(--td-brand-color)}.t-button--variant-dashed.t-button--ghost.t-button--theme-primary.t-is-disabled{border-color:#ffffff38;background-color:transparent}.t-button--variant-dashed.t-button--ghost.t-button--theme-success{color:var(--td-success-color);border-color:var(--td-success-color)}.t-button--variant-dashed.t-button--ghost.t-button--theme-success:hover,.t-button--variant-dashed.t-button--ghost.t-button--theme-success:focus-visible{color:var(--td-success-color-hover)}.t-button--variant-dashed.t-button--ghost.t-button--theme-success:active{color:var(--td-success-color-active)}.t-button--variant-dashed.t-button--ghost.t-button--theme-success.t-is-loading{color:var(--td-success-color)}.t-button--variant-dashed.t-button--ghost.t-button--theme-success.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-dashed.t-button--ghost.t-button--theme-success:hover,.t-button--variant-dashed.t-button--ghost.t-button--theme-success:focus-visible{border-color:var(--td-success-color-hover)}.t-button--variant-dashed.t-button--ghost.t-button--theme-success:active{border-color:var(--td-success-color-active)}.t-button--variant-dashed.t-button--ghost.t-button--theme-success.t-is-loading{border-color:var(--td-success-color)}.t-button--variant-dashed.t-button--ghost.t-button--theme-success.t-is-disabled{border-color:#ffffff38;background-color:transparent}.t-button--variant-dashed.t-button--ghost.t-button--theme-warning{color:var(--td-warning-color);border-color:var(--td-warning-color)}.t-button--variant-dashed.t-button--ghost.t-button--theme-warning:hover,.t-button--variant-dashed.t-button--ghost.t-button--theme-warning:focus-visible{color:var(--td-warning-color-hover)}.t-button--variant-dashed.t-button--ghost.t-button--theme-warning:active{color:var(--td-warning-color-active)}.t-button--variant-dashed.t-button--ghost.t-button--theme-warning.t-is-loading{color:var(--td-warning-color)}.t-button--variant-dashed.t-button--ghost.t-button--theme-warning.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-dashed.t-button--ghost.t-button--theme-warning:hover,.t-button--variant-dashed.t-button--ghost.t-button--theme-warning:focus-visible{border-color:var(--td-warning-color-hover)}.t-button--variant-dashed.t-button--ghost.t-button--theme-warning:active{border-color:var(--td-warning-color-active)}.t-button--variant-dashed.t-button--ghost.t-button--theme-warning.t-is-loading{border-color:var(--td-warning-color)}.t-button--variant-dashed.t-button--ghost.t-button--theme-warning.t-is-disabled{border-color:#ffffff38;background-color:transparent}.t-button--variant-dashed.t-button--ghost.t-button--theme-danger{color:var(--td-error-color);border-color:var(--td-error-color)}.t-button--variant-dashed.t-button--ghost.t-button--theme-danger:hover,.t-button--variant-dashed.t-button--ghost.t-button--theme-danger:focus-visible{color:var(--td-error-color-hover)}.t-button--variant-dashed.t-button--ghost.t-button--theme-danger:active{color:var(--td-error-color-active)}.t-button--variant-dashed.t-button--ghost.t-button--theme-danger.t-is-loading{color:var(--td-error-color)}.t-button--variant-dashed.t-button--ghost.t-button--theme-danger.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-dashed.t-button--ghost.t-button--theme-danger:hover,.t-button--variant-dashed.t-button--ghost.t-button--theme-danger:focus-visible{border-color:var(--td-error-color-hover)}.t-button--variant-dashed.t-button--ghost.t-button--theme-danger:active{border-color:var(--td-error-color-active)}.t-button--variant-dashed.t-button--ghost.t-button--theme-danger.t-is-loading{border-color:var(--td-error-color)}.t-button--variant-dashed.t-button--ghost.t-button--theme-danger.t-is-disabled{border-color:#ffffff38;background-color:transparent}.t-button--variant-text{height:var(--td-comp-size-m);font:var(--td-font-body-medium);padding-left:calc(var(--td-comp-paddingLR-l) - 1px);padding-right:calc(var(--td-comp-paddingLR-l) - 1px);color:var(--td-text-color-primary);background-color:transparent;border-color:transparent}.t-button--variant-text .t-icon,.t-button--variant-text .t-loading{font-size:var(--td-font-size-body-large)}.t-button--variant-text:hover,.t-button--variant-text:focus-visible{color:var(--td-text-color-primary)}.t-button--variant-text.t-is-loading{color:var(--td-text-color-primary)}.t-button--variant-text.t-is-disabled{color:var(--td-text-color-disabled)}.t-button--variant-text:hover,.t-button--variant-text:focus-visible{background-color:var(--td-bg-color-container-hover)}.t-button--variant-text.t-is-loading,.t-button--variant-text.t-is-disabled{background-color:transparent}.t-button--variant-text:hover,.t-button--variant-text:focus-visible{border-color:var(--td-bg-color-container-hover)}.t-button--variant-text.t-is-loading,.t-button--variant-text.t-is-disabled{border-color:transparent}.t-button--variant-text.t-button--theme-primary{color:var(--td-brand-color)}.t-button--variant-text.t-button--theme-primary:hover,.t-button--variant-text.t-button--theme-primary:focus-visible{color:var(--td-brand-color-hover)}.t-button--variant-text.t-button--theme-primary.t-is-loading{color:var(--td-brand-color)}.t-button--variant-text.t-button--theme-primary.t-is-disabled{color:var(--td-brand-color-disabled)}.t-button--variant-text.t-button--theme-success{color:var(--td-success-color)}.t-button--variant-text.t-button--theme-success:hover,.t-button--variant-text.t-button--theme-success:focus-visible{color:var(--td-success-color-hover)}.t-button--variant-text.t-button--theme-success.t-is-loading{color:var(--td-success-color)}.t-button--variant-text.t-button--theme-success.t-is-disabled{color:var(--td-success-color-disabled)}.t-button--variant-text.t-button--theme-warning{color:var(--td-warning-color)}.t-button--variant-text.t-button--theme-warning:hover,.t-button--variant-text.t-button--theme-warning:focus-visible{color:var(--td-warning-color-hover)}.t-button--variant-text.t-button--theme-warning.t-is-loading{color:var(--td-warning-color)}.t-button--variant-text.t-button--theme-warning.t-is-disabled{color:var(--td-warning-color-disabled)}.t-button--variant-text.t-button--theme-danger{color:var(--td-error-color)}.t-button--variant-text.t-button--theme-danger:hover,.t-button--variant-text.t-button--theme-danger:focus-visible{color:var(--td-error-color-hover)}.t-button--variant-text.t-button--theme-danger.t-is-loading{color:var(--td-error-color)}.t-button--variant-text.t-button--theme-danger.t-is-disabled{color:var(--td-error-color-disabled)}.t-button--variant-text.t-button--ghost{background:none;color:var(--td-text-color-anti)}.t-button--variant-text.t-button--ghost:hover,.t-button--variant-text.t-button--ghost:focus-visible{color:var(--td-brand-color-hover)}.t-button--variant-text.t-button--ghost:active{color:var(--td-brand-color-active)}.t-button--variant-text.t-button--ghost.t-is-loading{color:var(--td-text-color-anti)}.t-button--variant-text.t-button--ghost.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-text.t-button--ghost.t-button--theme-primary{color:var(--td-brand-color)}.t-button--variant-text.t-button--ghost.t-button--theme-primary:hover,.t-button--variant-text.t-button--ghost.t-button--theme-primary:focus-visible{color:var(--td-brand-color-hover)}.t-button--variant-text.t-button--ghost.t-button--theme-primary:active{color:var(--td-brand-color-active)}.t-button--variant-text.t-button--ghost.t-button--theme-primary.t-is-loading{color:var(--td-brand-color)}.t-button--variant-text.t-button--ghost.t-button--theme-primary.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-text.t-button--ghost.t-button--theme-success{color:var(--td-success-color)}.t-button--variant-text.t-button--ghost.t-button--theme-success:hover,.t-button--variant-text.t-button--ghost.t-button--theme-success:focus-visible{color:var(--td-success-color-hover)}.t-button--variant-text.t-button--ghost.t-button--theme-success:active{color:var(--td-success-color-active)}.t-button--variant-text.t-button--ghost.t-button--theme-success.t-is-loading{color:var(--td-success-color)}.t-button--variant-text.t-button--ghost.t-button--theme-success.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-text.t-button--ghost.t-button--theme-warning{color:var(--td-warning-color)}.t-button--variant-text.t-button--ghost.t-button--theme-warning:hover,.t-button--variant-text.t-button--ghost.t-button--theme-warning:focus-visible{color:var(--td-warning-color-hover)}.t-button--variant-text.t-button--ghost.t-button--theme-warning:active{color:var(--td-warning-color-active)}.t-button--variant-text.t-button--ghost.t-button--theme-warning.t-is-loading{color:var(--td-warning-color)}.t-button--variant-text.t-button--ghost.t-button--theme-warning.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button--variant-text.t-button--ghost.t-button--theme-danger{color:var(--td-error-color)}.t-button--variant-text.t-button--ghost.t-button--theme-danger:hover,.t-button--variant-text.t-button--ghost.t-button--theme-danger:focus-visible{color:var(--td-error-color-hover)}.t-button--variant-text.t-button--ghost.t-button--theme-danger:active{color:var(--td-error-color-active)}.t-button--variant-text.t-button--ghost.t-button--theme-danger.t-is-loading{color:var(--td-error-color)}.t-button--variant-text.t-button--ghost.t-button--theme-danger.t-is-disabled{color:#ffffff38;background-color:transparent}.t-button.t-is-loading,.t-button.t-is-disabled{cursor:not-allowed}.t-button.t-size-s{height:var(--td-comp-size-xs);font:var(--td-font-body-small);padding-left:calc(var(--td-comp-paddingLR-s) - 1px);padding-right:calc(var(--td-comp-paddingLR-s) - 1px)}.t-button.t-size-s .t-icon,.t-button.t-size-s .t-loading{font-size:var(--td-font-size-body-medium)}.t-button.t-size-l{height:var(--td-comp-size-xl);font:var(--td-font-body-large);padding-left:calc(var(--td-comp-paddingLR-xl) - 1px);padding-right:calc(var(--td-comp-paddingLR-xl) - 1px)}.t-button.t-size-l .t-icon,.t-button.t-size-l .t-loading{font-size:var(--td-font-size-title-large)}.t-button--shape-square{width:var(--td-comp-size-m);padding:0}.t-button--shape-square.t-size-s{width:var(--td-comp-size-xs);padding:0}.t-button--shape-square.t-size-l{width:var(--td-comp-size-xl);padding:0}.t-button--shape-round{border-radius:var(--td-radius-round)}.t-button--shape-round.t-size-s{border-radius:calc(var(--td-comp-size-xs) / 2)}.t-button--shape-round.t-size-l{border-radius:calc(var(--td-comp-size-xl) / 2)}.t-button--shape-circle{width:var(--td-comp-size-m);padding:0;text-align:center;border-radius:calc(var(--td-comp-size-m) / 2)}.t-button--shape-circle .t-icon,.t-button--shape-circle .t-loading{font-size:var(--td-font-size-body-large)}.t-button--shape-circle.t-size-s{width:var(--td-comp-size-xs);border-radius:calc(var(--td-comp-size-xs) / 2)}.t-button--shape-circle.t-size-l{width:var(--td-comp-size-xl);padding:0;border-radius:calc(var(--td-comp-size-xl) / 2)}.t-button.t-size-full-width{display:flex;width:100%}.t-button--ghost{--ripple-color: var(--td-gray-color-10)}.t-button:not(.t-is-disabled):not(.t-button--ghost){--ripple-color: var(--td-bg-color-container-active)}.t-button--variant-base:not(.t-is-disabled):not(.t-button--ghost){--ripple-color: var(--td-bg-color-component-active)}.t-button--variant-base.t-button--theme-primary:not(.t-is-disabled):not(.t-button--ghost){--ripple-color: var(--td-brand-color-active)}.t-button--variant-base.t-button--theme-success:not(.t-is-disabled):not(.t-button--ghost){--ripple-color: var(--td-success-color-active)}.t-button--variant-base.t-button--theme-warning:not(.t-is-disabled):not(.t-button--ghost){--ripple-color: var(--td-warning-color-active)}.t-button--variant-base.t-button--theme-danger:not(.t-is-disabled):not(.t-button--ghost){--ripple-color: var(--td-error-color-active)}.t-icon{display:inline-block;vertical-align:middle;width:1em;height:1em}.t-icon:before{font-family:unset}.t-icon{fill:currentColor}.t-icon.t-size-s,i.t-size-s{font-size:14px}.t-icon.t-size-m,i.t-size-m{font-size:16px}.t-icon.t-size-l,i.t-size-l{font-size:18px}.content-placement-top .t-popup[data-popper-placement^=top] .t-popup__content{margin-bottom:var(--td-comp-margin-s)}.content-placement-top .t-popup[data-popper-placement^=top] .t-popup__content--arrow{margin-bottom:var(--td-comp-margin-l)}.content-placement-bottom .t-popup[data-popper-placement^=bottom] .t-popup__content{margin-top:var(--td-comp-margin-s)}.content-placement-bottom .t-popup[data-popper-placement^=bottom] .t-popup__content--arrow{margin-top:var(--td-comp-margin-l)}.content-placement-left .t-popup[data-popper-placement^=left] .t-popup__content{margin-right:var(--td-comp-margin-s)}.content-placement-left .t-popup[data-popper-placement^=left] .t-popup__content--arrow{margin-right:var(--td-comp-margin-l)}.content-placement-left .t-popup[data-popper-placement^=left] .t-popup__content--text{max-width:480px}.content-placement-right .t-popup[data-popper-placement^=right] .t-popup__content{margin-left:var(--td-comp-margin-s)}.content-placement-right .t-popup[data-popper-placement^=right] .t-popup__content--arrow{margin-left:var(--td-comp-margin-l)}.content-placement-right .t-popup[data-popper-placement^=right] .t-popup__content--text{max-width:480px}.t-popup{font:var(--td-font-body-medium);box-sizing:border-box;margin:0;padding:0;list-style:none;color:var(--td-text-color-primary);display:inline-block;z-index:5500}.t-popup__content{position:relative;background:var(--td-bg-color-container);box-shadow:var(--td-shadow-2),var(--td-shadow-inset-top),var(--td-shadow-inset-right),var(--td-shadow-inset-bottom),var(--td-shadow-inset-left);border-radius:var(--td-radius-medium);padding:var(--td-comp-paddingTB-xs) var(--td-comp-paddingLR-s);font-size:var(--td-font-size-body-medium);line-height:var(--td-line-height-body-medium);box-sizing:border-box;word-break:break-all}.t-popup__arrow{position:absolute;z-index:1;width:8px;height:8px}.t-popup__arrow:before{position:absolute;content:"";width:8px;height:8px;transform:rotate(45deg);background:var(--td-bg-color-container)}.t-popup[data-popper-placement^=top] .t-popup__content{margin-bottom:var(--td-comp-margin-s)}.t-popup[data-popper-placement^=top] .t-popup__content--arrow{margin-bottom:var(--td-comp-margin-l)}.t-popup[data-popper-placement^=bottom] .t-popup__content{margin-top:var(--td-comp-margin-s)}.t-popup[data-popper-placement^=bottom] .t-popup__content--arrow{margin-top:var(--td-comp-margin-l)}.t-popup[data-popper-placement^=left] .t-popup__content{margin-right:var(--td-comp-margin-s)}.t-popup[data-popper-placement^=left] .t-popup__content--arrow{margin-right:var(--td-comp-margin-l)}.t-popup[data-popper-placement^=left] .t-popup__content--text{max-width:480px}.t-popup[data-popper-placement^=right] .t-popup__content{margin-left:var(--td-comp-margin-s)}.t-popup[data-popper-placement^=right] .t-popup__content--arrow{margin-left:var(--td-comp-margin-l)}.t-popup[data-popper-placement^=right] .t-popup__content--text{max-width:480px}.t-popup[data-popper-placement^=top] .t-popup__arrow:before{border-top-left-radius:100%;box-shadow:var(--td-shadow-inset-left),var(--td-shadow-inset-bottom)}.t-popup[data-popper-placement=top-start] .t-popup__arrow{left:8px}.t-popup[data-popper-placement=top] .t-popup__arrow{left:50%;margin-left:-4px}.t-popup[data-popper-placement=top-end] .t-popup__arrow{left:calc(100% - 16px)}.t-popup[data-popper-placement^=bottom] .t-popup__arrow{top:-4px}.t-popup[data-popper-placement^=bottom] .t-popup__arrow:before{border-bottom-right-radius:100%;box-shadow:var(--td-shadow-inset-top),var(--td-shadow-inset-right)}.t-popup[data-popper-placement=bottom-start] .t-popup__arrow{left:8px}.t-popup[data-popper-placement=bottom] .t-popup__arrow{left:50%;margin-left:-4px}.t-popup[data-popper-placement=bottom-end] .t-popup__arrow{left:calc(100% - 16px)}.t-popup[data-popper-placement^=left] .t-popup__arrow{right:-4px}.t-popup[data-popper-placement^=left] .t-popup__arrow:before{box-shadow:var(--td-shadow-inset-left),var(--td-shadow-inset-top)}.t-popup[data-popper-placement=left-start] .t-popup__arrow{top:8px}.t-popup[data-popper-placement=left] .t-popup__arrow{top:50%;margin-top:-4px}.t-popup[data-popper-placement=left-end] .t-popup__arrow{top:calc(100% - 16px)}.t-popup[data-popper-placement^=right] .t-popup__arrow{left:-4px}.t-popup[data-popper-placement^=right] .t-popup__arrow:before{box-shadow:var(--td-shadow-inset-right),var(--td-shadow-inset-bottom)}.t-popup[data-popper-placement=right-start] .t-popup__arrow{top:8px}.t-popup[data-popper-placement=right] .t-popup__arrow{top:50%;margin-top:-4px}.t-popup[data-popper-placement=right-end] .t-popup__arrow{top:calc(100% - 16px)}.t-popup--animation-enter,.t-popup--animation-enter-from,.t-popup--animation-exiting,.t-popup--animation-leave-to{opacity:0;visibility:hidden}.t-popup--animation-enter-to,.t-popup--animation-entering,.t-popup--animation-leave-from,.t-popup--animation-leave{opacity:1;visibility:visible;transform:none}.t-popup--animation-enter-active{transition:opacity .2s linear}.t-popup--animation-leave-active{transition:opacity .2s cubic-bezier(0,0,.15,1),visibility .2s cubic-bezier(.82,0,1,.9)}.t-popup--animation-expand-enter-active[data-popper-placement^=top]{animation:t-popup-animation-expand-in-top .2s cubic-bezier(.38,0,.24,1),t-fade-in .2s linear}.t-popup--animation-expand-leave-active[data-popper-placement^=top]{animation:t-popup-animation-expand-out-top .2s cubic-bezier(.38,0,.24,1),t-fade-out .2s cubic-bezier(0,0,.15,1)}@keyframes t-popup-animation-expand-in-top{0%{clip-path:polygon(-20% 120%,120% 120%,120% 120%,-20% 120%)}to{clip-path:polygon(-20% 0,120% 0,120% 120%,-20% 120%)}}@keyframes t-popup-animation-expand-out-top{0%{clip-path:polygon(-20% 0,120% 0,120% 120%,-20% 120%)}to{clip-path:polygon(-20% 120%,120% 120%,120% 120%,-20% 120%)}}.t-popup--animation-expand-enter-active[data-popper-placement^=bottom]{animation:t-popup-animation-expand-in-bottom .2s cubic-bezier(.38,0,.24,1),t-fade-in .2s linear}.t-popup--animation-expand-leave-active[data-popper-placement^=bottom]{animation:t-popup-animation-expand-out-bottom .2s cubic-bezier(.38,0,.24,1),t-fade-out .2s cubic-bezier(0,0,.15,1)}@keyframes t-popup-animation-expand-in-bottom{0%{clip-path:polygon(-20% 0,120% 0,120% 0,-20% 0)}to{clip-path:polygon(-20% 0,120% 0,120% 120%,-20% 120%)}}@keyframes t-popup-animation-expand-out-bottom{0%{clip-path:polygon(-20% 0,120% 0,120% 120%,-20% 120%)}to{clip-path:polygon(-20% 0,120% 0,120% 0,-20% 0)}}.t-tabs{font:var(--td-font-body-medium);color:var(--td-text-color-primary);box-sizing:border-box;margin:0;padding:0;list-style:none;overflow:hidden;background-color:var(--td-bg-color-container)}.t-tabs__header.t-is-left{float:left}.t-tabs__header.t-is-right{float:right}.t-tabs__header .t-icon{font-size:var(--td-font-size-body-large)}.t-tabs__nav{position:relative;overflow:hidden;-webkit-user-select:none;user-select:none}.t-tabs__operations{display:flex;flex-direction:row;position:absolute;border-bottom:1px solid var(--td-component-stroke);background-color:var(--td-bg-color-container)}.t-tabs__operations--left{left:0;z-index:2}.t-tabs__operations--right{right:0;z-index:2}.t-tabs__operations--right .t-tabs__btn:first-child{box-shadow:-10px 0 20px 5px #0000000d}.t-tabs__operations--right .t-tabs__nav-action{display:flex;align-items:center;width:100%;flex:1}.t-tabs__btn{width:40px;height:100%;display:flex;align-items:center;justify-content:center;background-color:var(--td-bg-color-secondarycontainer);border-left:1px solid var(--td-component-stroke);cursor:pointer;color:var(--td-text-color-secondary);font:var(--td-font-body-large);transition:all .24s cubic-bezier(.38,0,.24,1);z-index:1;opacity:1}.t-tabs__btn:hover{background-color:var(--td-bg-color-secondarycontainer-hover)}.t-tabs__btn.t-size-m{height:var(--td-comp-size-xxl);line-height:var(--td-comp-size-xxl)}.t-tabs__btn.t-size-l{height:var(--td-comp-size-xxxxl);line-height:var(--td-comp-size-xxxxl)}.t-tabs__btn--left{border-right:1px solid var(--td-component-stroke);box-shadow:10px 0 20px 5px #0000000d}.t-tabs__btn--left.fade-enter,.t-tabs__btn--left.fade-enter-from,.t-tabs__btn--left.fade-leave-to{transform:translate(-50px)}.t-tabs__btn--right.fade-enter,.t-tabs__btn--right.fade-enter-from,.t-tabs__btn--right.fade-leave-to{transform:translate(50px)}.t-tabs__nav-container{position:relative}.t-tabs__nav-container.t-is-top:after{content:"";width:100%;height:1px;position:absolute;top:auto;right:auto;bottom:0;left:0;background-color:var(--td-component-stroke)}.t-tabs__nav-container.t-is-bottom:after{content:"";width:100%;height:1px;position:absolute;top:0;right:auto;bottom:auto;left:0;background-color:var(--td-component-stroke)}.t-tabs__nav-container.t-is-left:after{content:"";width:1px;height:100%;position:absolute;top:0;right:0;bottom:auto;left:auto;background-color:var(--td-component-stroke)}.t-tabs__nav-container.t-is-right:after{content:"";width:1px;height:100%;position:absolute;top:0;right:auto;bottom:auto;left:0;background-color:var(--td-component-stroke)}.t-tabs__nav-container.t-is-addable{margin-right:40px}.t-tabs__nav-container.t-tabs__nav--card:after{content:"";background-color:transparent}.t-tabs__scroll-btn{position:absolute;z-index:1;width:40px;height:100%;display:block;background-color:var(--td-bg-color-secondarycontainer);text-align:center;border-bottom:1px solid var(--td-component-stroke);cursor:pointer;color:var(--td-text-color-secondary);font:var(--td-font-body-large)}.t-tabs__scroll-btn.t-size-m{height:var(--td-comp-size-xxl);line-height:var(--td-comp-size-xxl)}.t-tabs__scroll-btn.t-size-l{height:var(--td-comp-size-xxxxl);line-height:var(--td-comp-size-xxxxl)}.t-tabs__nav-scroll{position:relative;display:inline-block;display:flex;flex:auto;align-self:stretch;overflow:hidden;white-space:nowrap;transform:translate(0);z-index:1}.t-tabs__nav-wrap{position:relative;display:flex;font-size:0}.t-tabs__nav-wrap.t-is-smooth{transition:transform .24s cubic-bezier(0,0,.15,1)}.t-tabs__nav-wrap.t-is-vertical{flex-direction:column}.t-tabs__bar{position:absolute;background-color:var(--td-brand-color);z-index:1;transition:all .24s cubic-bezier(.38,0,.24,1);border-radius:var(--td-radius-small)}.t-tabs__bar.t-is-top{bottom:0;left:0;height:3px}.t-tabs__bar.t-is-bottom{top:0;left:0;height:3px}.t-tabs__bar.t-is-left{top:0;right:0;width:3px}.t-tabs__bar.t-is-right{top:0;left:0;width:3px}.t-tabs__nav-item{display:inline-flex;align-items:center;font:var(--td-font-body-medium);color:var(--td-text-color-secondary);position:relative;overflow:hidden;z-index:0;cursor:pointer;flex-shrink:0;transition:background-color cubic-bezier(.38,0,.24,1) .2s;--ripple-color: var(--td-bg-color-container-active)}.t-tabs__nav-item-wrapper{display:flex;align-items:center;height:var(--td-comp-size-m);padding:0 var(--td-comp-paddingLR-s);margin-left:var(--td-comp-margin-s);margin-right:var(--td-comp-margin-s);border-radius:var(--td-radius-default);transition:background-color cubic-bezier(.38,0,.24,1) .2s;--ripple-color: var(--td-bg-color-container-active)}.t-tabs__nav-item.t-size-l{font:var(--td-font-body-large)}.t-tabs__nav-item.t-size-l .t-tabs__nav-item-wrapper{height:var(--td-comp-size-xxl);padding:0 var(--td-comp-paddingLR-m)}.t-tabs__nav-item-text-wrapper{position:relative;display:flex;align-items:center}.t-tabs__nav-item:not(.t-is-disabled):not(.t-is-active):hover .t-tabs__nav-item-wrapper{background-color:var(--td-bg-color-container-hover)}.t-tabs__nav-item.t-is-left,.t-tabs__nav-item.t-is-right{display:flex;align-items:center}.t-tabs__nav-item.t-size-m{height:var(--td-comp-size-xxl);line-height:var(--td-comp-size-xxl)}.t-tabs__nav-item.t-size-l{height:var(--td-comp-size-xxxxl);line-height:var(--td-comp-size-xxxxl)}.t-tabs__nav-item.t-is-active{color:var(--td-brand-color);text-shadow:0 0 .3px currentcolor}.t-tabs__nav-item.t-is-disabled{color:var(--td-text-color-disabled);cursor:not-allowed}.t-tabs__nav-item>.remove-btn{margin-left:var(--td-comp-margin-s);transition:all .3s cubic-bezier(.645,.045,.355,1)}.t-tabs__nav--card{background-color:var(--td-bg-color-secondarycontainer)}.t-tabs__nav--card.t-tabs__nav-item{padding-right:var(--td-comp-paddingLR-l);padding-left:var(--td-comp-paddingLR-l);border-bottom:1px solid var(--td-component-stroke)}.t-tabs__nav--card.t-tabs__nav-item:after{display:none}.t-tabs__nav--card.t-tabs__nav-item:not(.t-is-disabled):not(.t-is-active):hover{background-color:var(--td-bg-color-secondarycontainer-hover)}.t-tabs__nav--card.t-tabs__nav-item:not(:first-of-type){border-left:1px solid var(--td-component-stroke)}.t-tabs__nav--card.t-tabs__nav-item:last-of-type{border-right:1px solid var(--td-component-stroke)}.t-tabs__nav--card.t-tabs__nav-item.t-is-active{color:var(--td-brand-color);background-color:var(--td-bg-color-container);border-bottom-color:var(--td-bg-color-container)}.t-tabs__nav--card.t-tabs__nav-item.t-size-l{padding-left:var(--td-comp-paddingLR-xl);padding-right:var(--td-comp-paddingLR-xl)}.t-tabs__nav--card .t-icon-close{color:var(--td-text-color-secondary);transition:color cubic-bezier(.38,0,.24,1) .2s}.t-tabs__nav--card .t-icon-close:hover{color:var(--td-text-color-primary)}.t-tabs__content{overflow:hidden;position:relative}.t-tab-panel.t-is-hidden{display:none}.input-readonly.t-is-readonly{color:var(--td-text-color-primary);background-color:var(--td-bg-color-specialcomponent)}.input-readonly.t-is-readonly .t-input__inner{cursor:pointer}.input-disabled.t-is-disabled{color:var(--td-text-color-disabled);background-color:var(--td-bg-color-component-disabled)}.input-disabled.t-is-disabled:hover{border-color:var(--td-border-level-2-color)}.input-disabled.t-is-disabled .t-input__inner{cursor:not-allowed;color:var(--td-text-color-disabled);text-overflow:initial}.input-disabled.t-is-disabled .t-input__inner::placeholder{color:var(--td-text-color-disabled)}.input-disabled.t-is-disabled>.t-input__prefix .t-icon,.input-disabled.t-is-disabled>.t-input__suffix .t-icon{color:var(--td-text-color-disabled)}.input-disabled.t-is-disabled>.t-input__prefix .t-icon:hover,.input-disabled.t-is-disabled>.t-input__suffix .t-icon:hover{color:var(--td-text-color-disabled)}.t-tips{font-size:var(--td-font-size-body-small)}.t-tips.t-is-default{color:var(--td-text-color-placeholder)}.t-tips.t-is-error{color:var(--td-error-color)}.t-tips.t-is-warning{color:var(--td-warning-color)}.t-tips.t-is-success{color:var(--td-success-color)}.t-input{margin:0;padding:0;list-style:none;position:relative;height:var(--td-comp-size-m);border-width:1px;border-style:solid;border-radius:var(--td-radius-default);border-color:var(--td-border-level-2-color);padding:0 var(--td-comp-paddingLR-s);background-color:var(--td-bg-color-specialcomponent);outline:none;color:var(--td-text-color-primary);font:var(--td-font-body-medium);width:100%;box-sizing:border-box;transition:border cubic-bezier(.38,0,.24,1) .2s,box-shadow cubic-bezier(.38,0,.24,1) .2s,background-color cubic-bezier(.38,0,.24,1) .2s;display:flex;align-items:center;overflow:hidden}.t-input:hover{border-color:var(--td-brand-color)}.t-input:focus{z-index:1;border-color:var(--td-brand-color);box-shadow:0 0 0 2px var(--td-brand-color-focus)}.t-input--borderless:not(.t-input--focused){border-color:transparent;transition:border cubic-bezier(.38,0,.24,1) .2s,box-shadow cubic-bezier(.38,0,.24,1) .2s,background-color cubic-bezier(.38,0,.24,1) .2s}.t-input--borderless:not(.t-input--focused):hover{border-color:var(--td-component-border);background-color:var(--td-bg-color-container-hover);cursor:pointer}.t-input--borderless:not(.t-input--focused).t-is-disabled{border:none;background-color:var(--td-bg-color-component-disabled)}.t-input--focused{border-color:var(--td-brand-color);box-shadow:0 0 0 2px var(--td-brand-color-focus);z-index:1}.t-input :focus-visible{outline:none}.t-input__inner{flex:1;border:none;outline:none;padding:0;max-width:100%;min-width:0;color:var(--td-text-color-primary);font:inherit;background-color:transparent;box-sizing:border-box;white-space:nowrap;word-wrap:normal;overflow:hidden;text-overflow:ellipsis}.t-input__inner::placeholder{color:var(--td-text-color-placeholder)}.t-input__inner:placeholder-shown{text-overflow:ellipsis;width:100%}.t-input__inner[type=password]::-ms-reveal{display:none}.t-input__inner[type=search]::-webkit-search-decoration,.t-input__inner[type=search]::-webkit-search-cancel-button,.t-input__inner[type=search]::-webkit-search-results-button,.t-input__inner[type=search]::-webkit-search-results-decoration{-webkit-appearance:none;-moz-appearance:none;appearance:none}.t-input__inner.t-input--soft-hidden{width:0}.t-input__extra{font:var(--td-font-body-small);color:var(--td-text-color-placeholder)}.t-input__status{position:absolute;right:-24px;top:0}.t-input.t-input--suffix>span.t-input__clear{opacity:0;visibility:hidden;transition:border cubic-bezier(.38,0,.24,1) .2s,box-shadow cubic-bezier(.38,0,.24,1) .2s,background-color cubic-bezier(.38,0,.24,1) .2s}.t-input.t-input--suffix:hover>span.t-input__clear{opacity:1;visibility:visible}.t-input.t-is-success{border-color:var(--td-success-color)}.t-input.t-is-success:focus{box-shadow:0 0 0 2px var(--td-success-color-focus)}.t-input.t-is-success.t-input--focused{box-shadow:0 0 0 2px var(--td-success-color-focus)}.t-input.t-is-success>.t-input__extra{color:var(--td-success-color)}.t-input.t-is-warning{border-color:var(--td-warning-color)}.t-input.t-is-warning:focus{box-shadow:0 0 0 2px var(--td-warning-color-focus)}.t-input.t-is-warning.t-input--focused{box-shadow:0 0 0 2px var(--td-warning-color-focus)}.t-input.t-is-warning>.t-input__extra{color:var(--td-warning-color)}.t-input.t-is-error{border-color:var(--td-error-color)}.t-input.t-is-error:focus{box-shadow:0 0 0 2px var(--td-error-color-focus)}.t-input.t-is-error.t-input--focused{box-shadow:0 0 0 2px var(--td-error-color-focus)}.t-input.t-is-error>.t-input__extra{color:var(--td-error-color)}.t-input.t-is-readonly{color:var(--td-text-color-primary);background-color:var(--td-bg-color-specialcomponent)}.t-input.t-is-readonly .t-input__inner{cursor:pointer}.t-input.t-is-disabled{color:var(--td-text-color-disabled);background-color:var(--td-bg-color-component-disabled)}.t-input.t-is-disabled:hover{border-color:var(--td-border-level-2-color)}.t-input.t-is-disabled .t-input__inner{cursor:not-allowed;color:var(--td-text-color-disabled);text-overflow:initial}.t-input.t-is-disabled .t-input__inner::placeholder{color:var(--td-text-color-disabled)}.t-input.t-is-disabled>.t-input__prefix .t-icon,.t-input.t-is-disabled>.t-input__suffix .t-icon{color:var(--td-text-color-disabled)}.t-input.t-is-disabled>.t-input__prefix .t-icon:hover,.t-input.t-is-disabled>.t-input__suffix .t-icon:hover{color:var(--td-text-color-disabled)}.t-input.t-input--prefix>.t-input__prefix{z-index:2;height:100%;text-align:center;display:flex;align-items:center}.t-input.t-input--prefix>.t-input__prefix-icon{font-size:var(--td-font-size-body-large)}.t-input.t-input--suffix>.t-input__suffix{z-index:2;height:100%;text-align:center;display:flex;align-items:center}.t-input.t-input--suffix>.t-input__suffix-icon{font-size:var(--td-font-size-body-large)}.t-input .t-input__suffix-clear{cursor:pointer}.t-input.t-size-l{height:var(--td-comp-size-xl);font:var(--td-font-body-large);padding:var(--td-comp-paddingTB-m) var(--td-comp-paddingLR-m)}.t-input.t-size-s{height:var(--td-comp-size-xs);font:var(--td-font-body-small)}.t-input .t-input__prefix>.t-icon,.t-input .t-input__suffix>.t-icon{font-size:inherit}.t-input .t-input__prefix>.t-icon{font-size:16px;color:var(--td-text-color-placeholder)}.t-input .t-input__prefix:not(:empty){margin-right:var(--td-comp-margin-s)}.t-input .t-input__suffix>.t-icon{color:var(--td-text-color-placeholder);transition:all .2s linear}.t-input .t-input__suffix>.t-icon:hover{color:var(--td-text-color-secondary);transition:all .2s linear}.t-input .t-input__suffix:not(:empty){margin-left:var(--td-comp-margin-s)}.t-input.t-is-focused .t-input__prefix>.t-icon{color:var(--td-brand-color)}.t-input.t-is-focused .t-input__suffix>.t-icon-time,.t-input.t-is-focused .t-input__suffix .t-icon-calendar{color:var(--td-brand-color)}.t-input-group{position:relative;display:inline-flex;align-items:stretch}.t-input-group .t-input__wrap{border-radius:0}.t-input-group .t-input__wrap:first-child{border-radius:var(--td-radius-default) 0 0 var(--td-radius-default)}.t-input-group .t-input__wrap:last-child{border-radius:0 var(--td-radius-default) var(--td-radius-default) 0}.t-input-group .t-button,.t-input-group .t-select{border-radius:0}.t-input-group .t-button:not(:first-child),.t-input-group .t-select:not(:first-child){margin-left:-1px}.t-input-group .t-input__wrap:not(:first-child) .t-input{margin-left:-1px}.t-input-group .t-input__wrap:first-child .t-input{border-radius:var(--td-radius-default) 0 0 var(--td-radius-default)}.t-input-group .t-input__wrap:last-child .t-input{border-radius:0 var(--td-radius-default) var(--td-radius-default) 0}.t-input-group .t-button:first-child,.t-input-group .t-select:first-child{border-radius:var(--td-radius-default) 0 0 var(--td-radius-default)}.t-input-group .t-button:last-child,.t-input-group .t-select:last-child{border-radius:0 var(--td-radius-default) var(--td-radius-default) 0}.t-input-group--separate .t-input__wrap+.t-input__wrap{margin-left:var(--td-comp-margin-xxxl)}.t-input-group--separate .t-button,.t-input-group--separate .t-select{border-radius:var(--td-radius-default)}.t-input-group--separate .t-button:first-child,.t-input-group--separate .t-select:first-child{border-radius:var(--td-radius-default) 0 0 var(--td-radius-default)}.t-input-group--separate .t-button:last-child,.t-input-group--separate .t-select:last-child{border-radius:0 var(--td-radius-default) var(--td-radius-default) 0}.t-input-group--separate .t-input__wrap .t-input,.t-input-group--separate .t-input__wrap .t-input:first-child{border-radius:var(--td-radius-default)}.t-input-group--separate .t-input__wrap .t-input:last-child{border-radius:var(--td-radius-default)}.t-input-group .t-input__inner,.t-input-group .t-button,.t-input-group .t-select{position:relative;z-index:0}.t-input-group .t-input__inner:hover,.t-input-group .t-button:hover,.t-input-group .t-select:hover,.t-input-group .t-input__inner:focus,.t-input-group .t-button:focus,.t-input-group .t-select:focus,.t-input-group .t-input__inner:active,.t-input-group .t-button:active,.t-input-group .t-select:active{z-index:1}.t-input__wrap{width:100%}.t-input__tips{height:auto;min-height:var(--td-line-height-body-small);font:var(--td-font-body-small);position:absolute}.t-input__tips--default{color:var(--td-text-color-placeholder)}.t-input__tips--success{color:var(--td-success-color)}.t-input__tips--warning{color:var(--td-warning-color)}.t-input__tips--error{color:var(--td-error-color)}.t-align-center>.t-input__inner{text-align:center}.t-align-right>.t-input__inner{text-align:right}.t-input__input-pre{position:absolute;visibility:hidden;white-space:pre;display:block}.t-input--auto-width{width:fit-content;min-width:60px}.t-input__limit-number{font:var(--td-font-body-medium);color:var(--td-text-color-placeholder);background:var(--td-bg-color-specialcomponent)}.t-input__limit-number.t-is-disabled{background:var(--td-bg-color-component-disabled)}.t-tag{font:var(--td-font-body-medium);color:var(--td-text-color-primary);box-sizing:border-box;margin:0;padding:0;list-style:none;display:inline-flex;align-items:center;flex-direction:row;padding:0px var(--td-comp-paddingLR-s);height:var(--td-comp-size-xs);font:var(--td-font-body-small);color:var(--td-text-color-anti);border-radius:var(--td-radius-default);border:1px solid transparent;white-space:nowrap}.t-tag .t-icon{margin-right:var(--td-comp-margin-xs);width:calc(var(--td-font-size-body-medium) + 2px);height:calc(var(--td-font-size-body-medium) + 2px);flex-shrink:0}.t-tag .t-tag__icon-close{margin-right:0;margin-left:var(--td-comp-margin-s);font:var(--td-font-body-medium);cursor:pointer;transition:color .2s cubic-bezier(.38,0,.24,1)}.t-tag--default{color:var(--td-text-color-primary);background-color:var(--td-bg-color-component)}.t-tag--default .t-tag__icon-close{color:var(--td-text-color-placeholder)}.t-tag--default .t-tag__icon-close:hover{color:var(--td-text-color-primary)}.t-tag--default:active{cursor:default}.t-tag--default.t-tag--disabled{color:var(--td-text-color-disabled);background-color:var(--td-bg-color-component-disabled);border-color:var(--td-component-border);cursor:not-allowed}.t-tag--default.t-tag--disabled:hover{cursor:not-allowed}.t-tag--default.t-tag--disabled .t-icon:hover{cursor:pointer}.t-tag--default.t-tag--outline{border-color:var(--td-component-border)}.t-tag--default.t-tag--light{background-color:var(--td-bg-color-secondarycontainer)}.t-tag--default.t-tag--light-outline{border-color:var(--td-component-border);background-color:var(--td-bg-color-secondarycontainer)}.t-tag--primary{background-color:var(--td-brand-color)}.t-tag--primary.t-tag--outline{border-color:var(--td-brand-color)}.t-tag--primary.t-tag--light{background-color:var(--td-brand-color-light)}.t-tag--primary.t-tag--light-outline{border-color:var(--td-brand-color);background-color:var(--td-brand-color-light)}.t-tag--primary.t-tag--light,.t-tag--primary.t-tag--outline,.t-tag--primary.t-tag--light-outline{color:var(--td-brand-color)}.t-tag--primary.t-tag--light .t-tag__icon-close:hover,.t-tag--primary.t-tag--outline .t-tag__icon-close:hover,.t-tag--primary.t-tag--light-outline .t-tag__icon-close:hover{color:var(--td-brand-color-hover)}.t-tag--success{background-color:var(--td-success-color)}.t-tag--success.t-tag--outline{border-color:var(--td-success-color)}.t-tag--success.t-tag--light{background-color:var(--td-success-color-light)}.t-tag--success.t-tag--light-outline{border-color:var(--td-success-color);background-color:var(--td-success-color-light)}.t-tag--success.t-tag--light,.t-tag--success.t-tag--outline,.t-tag--success.t-tag--light-outline{color:var(--td-success-color)}.t-tag--success.t-tag--light .t-tag__icon-close:hover,.t-tag--success.t-tag--outline .t-tag__icon-close:hover,.t-tag--success.t-tag--light-outline .t-tag__icon-close:hover{color:var(--td-success-color-hover)}.t-tag--warning{background-color:var(--td-warning-color)}.t-tag--warning.t-tag--outline{border-color:var(--td-warning-color)}.t-tag--warning.t-tag--light{background-color:var(--td-warning-color-light)}.t-tag--warning.t-tag--light-outline{border-color:var(--td-warning-color);background-color:var(--td-warning-color-light)}.t-tag--warning.t-tag--light,.t-tag--warning.t-tag--outline,.t-tag--warning.t-tag--light-outline{color:var(--td-warning-color)}.t-tag--warning.t-tag--light .t-tag__icon-close:hover,.t-tag--warning.t-tag--outline .t-tag__icon-close:hover,.t-tag--warning.t-tag--light-outline .t-tag__icon-close:hover{color:var(--td-warning-color-hover)}.t-tag--danger{background-color:var(--td-error-color)}.t-tag--danger.t-tag--outline{border-color:var(--td-error-color)}.t-tag--danger.t-tag--light{background-color:var(--td-error-color-light)}.t-tag--danger.t-tag--light-outline{border-color:var(--td-error-color);background-color:var(--td-error-color-light)}.t-tag--danger .t-tag__icon-close{fill:var(--td-error-color)}.t-tag--danger .t-tag__icon-close:hover{fill:var(--td-error-color-hover)}.t-tag--danger.t-tag--light,.t-tag--danger.t-tag--outline,.t-tag--danger.t-tag--light-outline{color:var(--td-error-color)}.t-tag--danger.t-tag--light .t-tag__icon-close:hover,.t-tag--danger.t-tag--outline .t-tag__icon-close:hover,.t-tag--danger.t-tag--light-outline .t-tag__icon-close:hover{color:var(--td-error-color-hover)}.t-tag--dark.t-tag:not(.t-tag--default) .t-tag__icon-close{color:var(--td-font-white-2)}.t-tag--dark.t-tag:not(.t-tag--default) .t-tag__icon-close:hover{color:var(--td-font-white-1)}.t-tag.t-tag--outline{background:transparent}.t-tag.t-size-s{padding:0px var(--td-comp-paddingLR-xs);height:var(--td-comp-size-xxs);font:var(--td-font-body-small)}.t-tag.t-size-s .t-icon{font-size:var(--td-font-body-small)}.t-tag.t-size-l{padding:0px var(--td-comp-paddingLR-m);height:var(--td-comp-size-m);font:var(--td-font-body-medium)}.t-tag.t-size-l .t-icon{font:var(--td-font-body-medium)}.t-tag.t-tag--round{border-radius:var(--td-radius-extraLarge)}.t-tag.t-tag--mark{border-radius:0 var(--td-radius-extraLarge) var(--td-radius-extraLarge) 0}.t-tag.t-tag--ellipsis .t-tag--text{display:inline-block;white-space:nowrap;word-wrap:normal;overflow:hidden;text-overflow:ellipsis}.t-tag.t-tag--check:not(.t-tag--disabled){transition:background-color .2s cubic-bezier(.38,0,.24,1);cursor:pointer}.t-tag.t-tag--check:not(.t-tag--disabled).t-tag--default.t-tag--dark:not(.t-tag--checked):hover{background-color:var(--td-bg-color-component-hover)}.t-tag.t-tag--check:not(.t-tag--disabled).t-tag--primary.t-tag--dark.t-tag--checked:hover{background-color:var(--td-brand-color-hover)}.t-tag.t-tag--check:not(.t-tag--disabled).t-tag--default.t-tag--outline:not(.t-tag--checked):hover{color:var(--td-brand-color-hover)}.t-tag--check.t-tag--disabled.t-tag--primary.t-tag--dark{background-color:var(--td-brand-color-disabled);cursor:not-allowed}.t-tag--check.t-tag--disabled.t-tag--primary.t-tag--outline{color:var(--td-text-color-disabled);background-color:var(--td-bg-color-component-disabled);border-color:var(--td-text-color-disabled);cursor:not-allowed}.t-check-tag-group .t-tag:not(:last-child){margin-right:var(--td-comp-margin-s)}a .t-tag{cursor:pointer;transition:all .2s linear}a .t-tag:hover{color:var(--td-brand-color);background-color:var(--td-bg-color-component-hover)}a .t-tag:active{color:var(--td-brand-color-active);background-color:var(--td-bg-color-component-active)}@keyframes t-fade-in{0%{opacity:0}to{opacity:1}}@keyframes t-fade-out{0%{opacity:1}to{opacity:0}}@keyframes t-spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.t-icon-loading{animation:t-spin 1s linear infinite}@keyframes t-zoom-out{0%{transform:scale(.2)}to{transform:scale(1)}}.t-tag-input{font:var(--td-font-body-medium);color:var(--td-text-color-primary);box-sizing:border-box;margin:0;padding:0;list-style:none}.t-tag-input .t-tag{vertical-align:middle;animation:t-fade-in .2s ease-in-out;margin:3px var(--td-comp-margin-xs) 3px 0}.t-tag-input .t-tag-input__drag_wrapper+.t-tag-input__drag_wrapper{margin-left:var(--td-comp-margin-xs)}.t-tag-input .t-input{overflow:hidden;min-height:var(--td-comp-size-m);height:fit-content;padding:0 var(--td-comp-paddingLR-s) 0 var(--td-comp-margin-xs)}.t-tag-input .t-input .t-input__suffix-icon{right:var(--td-comp-margin-s)}.t-tag-input .t-input.t-size-s{padding:0 var(--td-comp-paddingLR-s) 0 var(--td-comp-margin-xs);min-height:var(--td-comp-size-xs)}.t-tag-input .t-input.t-size-s .t-tag{margin:1px var(--td-comp-margin-xs) 1px 0}.t-tag-input .t-input.t-size-l{min-height:var(--td-comp-size-xl);padding:0 var(--td-comp-paddingLR-m) 0 var(--td-comp-margin-s)}.t-tag-input .t-input.t-size-l .t-input__suffix-icon{right:var(--td-comp-margin-m)}.t-tag-input.t-is-empty .t-input__inner{margin-left:var(--td-comp-margin-xs)}.t-tag-input:hover .t-input__inner:not(.t-input--soft-hidden),.t-tag-input .t-input--focused .t-input__inner:not(.t-input--soft-hidden){min-width:20px}.t-tag-input .t-tag-input__prefix{margin-left:var(--td-comp-margin-xs);line-height:1}.t-tag-input .t-tag-input__prefix>.t-icon{color:var(--td-text-color-placeholder)}.t-tag-input .t-input .t-input__prefix:not(:empty){margin-right:0}.t-tag-input.t-input--auto-width .t-input.t-input--focused{padding-right:calc(var(--td-comp-paddingLR-xxl) + var(--td-comp-paddingLR-xxs))}.t-tag-input.t-input--auto-width .t-input__prefix{white-space:nowrap}.t-tag-input .t-input__prefix--scrollable{overflow-y:hidden;overflow-x:auto}@-moz-document url-prefix(){.t-tag-input .t-input__prefix--scrollable{scrollbar-color:var(--td-scrollbar-color) transparent;scrollbar-width:thin}}.t-tag-input .t-input__prefix--scrollable::-webkit-scrollbar{width:6px;height:6px}.t-tag-input .t-input__prefix--scrollable::-webkit-scrollbar-thumb{border:0px solid transparent;background-clip:content-box;background-color:var(--td-scrollbar-color);border-radius:11px}.t-tag-input .t-input__prefix--scrollable::-webkit-scrollbar-thumb:vertical:hover,.t-tag-input .t-input__prefix--scrollable::-webkit-scrollbar-thumb:horizontal:hover{background-color:var(--td-scrollbar-hover-color)}.t-tag-input__suffix-clear{cursor:pointer}.t-tag-input--break-line:not(.t-is-empty) .t-input{display:block}.t-tag-input--break-line:not(.t-is-empty) .t-input.t-input--prefix>.t-input__prefix{display:inline;text-align:left}.t-tag-input--break-line:not(.t-is-empty) .t-input .t-input__suffix-icon{position:absolute;bottom:0}.t-tag-input--break-line:not(.t-is-empty) .t-tag-input__prefix{vertical-align:middle}.t-tag-input__prefix{width:max-content;display:inline-block;margin-right:var(--td-comp-margin-s)}.t-tag-input--break-line.t-tag-input--with-tag:not(.t-input--auto-width) .t-input,.t-tag-input.t-input--auto-width:hover .t-input{padding-right:calc(var(--td-comp-paddingLR-xxl) + var(--td-comp-paddingLR-xxs))}.t-tag-input--break-line.t-tag-input--with-tag:not(.t-input--auto-width) .t-size-l .t-input,.t-tag-input.t-input--auto-width:hover .t-size-l .t-input{padding-right:calc(var(--td-comp-paddingLR-xxl) + var(--td-comp-paddingLR-xs))}.t-tag-input.t-input--auto-width .t-input{padding-right:0}.t-tag-input--max-rows .t-input{max-height:calc(var(--max-rows, 1) * (var(--td-comp-size-m) - 2px));overflow-y:scroll}.t-tag-input--max-rows .t-input.t-size-s{max-height:calc(var(--max-rows, 1) * var(--td-comp-size-xs))}.t-tag-input--max-rows .t-input.t-size-l{max-height:calc(var(--max-rows, 1) * (var(--td-comp-size-xl) - 2px))}.t-select-input{font:var(--td-font-body-medium);color:var(--td-text-color-primary);box-sizing:border-box;margin:0;padding:0;list-style:none;width:100%;display:inline-block;vertical-align:middle}.t-select-input--multiple .t-input--auto-width.t-tag-input__with-suffix-icon.t-tag-input--with-tag .t-input{padding-right:var(--td-comp-paddingLR-xl)}.t-select-input--multiple .t-input--auto-width.t-tag-input__with-suffix-icon.t-tag-input--with-tag .t-input.t-size-l{padding-right:calc(var(--td-comp-paddingLR-xl) + var(--td-comp-paddingLR-s))}.t-select-input--multiple .t-input--auto-width.t-tag-input__with-suffix-icon.t-is-empty .t-input{padding-right:var(--td-comp-paddingLR-s)}.t-select-input--multiple .t-input--auto-width.t-tag-input__with-suffix-icon.t-is-empty .t-input.t-size-l{padding-right:var(--td-comp-paddingLR-m)}.t-select-input--borderless .t-input{box-shadow:none;border:1px solid transparent;background:transparent;transition:all .2s linear}.t-select-input--borderless .t-input:hover:not(.t-input--focused){border-color:var(--td-component-border);background-color:var(--td-bg-color-container-hover);border-radius:var(--td-radius-default)}.t-select-input--borderless .t-input--focused{border-color:var(--td-brand-color);box-shadow:0 0 0 2px var(--td-brand-color-focus);background-color:var(--td-bg-color-specialcomponent)}.t-select-input--borderless.t-select-input--multiple:not(.t-select-input--empty).t-select-input--popup-visible input{display:inline-block}.t-select-input--borderless.t-select-input--multiple:not(.t-select-input--empty).t-select-input--popup-visible .t-input{background-color:var(--td-bg-color-container-hover)}.t-select-input--borderless.t-tag-input{border:0;box-shadow:none;background:transparent;transition:background-color .2s linear}.t-select-input--borderless.t-tag-input:hover{background-color:var(--td-bg-color-container-hover);border-radius:var(--td-radius-default)}.t-checkbox-group{font:var(--td-font-body-medium);color:var(--td-text-color-primary);box-sizing:border-box;margin:0;padding:0;list-style:none;display:inline-flex;flex-wrap:wrap;gap:16px}.t-checkbox{font:var(--td-font-body-medium);box-sizing:border-box;margin:0;padding:0;list-style:none;display:inline-flex;align-items:center;position:relative;cursor:pointer;color:var(--td-text-color-primary)}.t-checkbox+.t-checkbox{margin-left:inherit}.t-checkbox__former{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;outline:0;-webkit-appearance:none;-moz-appearance:none;appearance:none}.t-checkbox__input{position:relative;display:inline-block;width:16px;height:16px;vertical-align:middle;border:1px solid var(--td-border-level-2-color);border-radius:var(--td-radius-default);background-color:var(--td-bg-color-container);box-sizing:border-box;flex-shrink:0}.t-checkbox__input:after{content:"";position:absolute;opacity:0;box-sizing:border-box}.t-checkbox__label{display:inline-block;margin-left:8px;vertical-align:middle;font:var(--td-font-body-medium)}.t-checkbox:hover .t-checkbox__input{border-color:var(--td-brand-color);transition:border-color .2s linear}.t-checkbox.t-is-checked .t-checkbox__input{border-color:var(--td-brand-color);background-color:var(--td-brand-color);transition:background-color .2s cubic-bezier(.82,0,1,.9)}.t-checkbox.t-is-checked .t-checkbox__input:after{opacity:1;top:6px;left:3px;width:5px;height:9px;border:2px solid var(--td-text-color-anti);border-radius:0 0 1px;border-top:0;border-left:0;transform:rotate(45deg) scale(1) translate(-50%,-50%);background:transparent}.t-checkbox.t-is-indeterminate .t-checkbox__input{border-color:var(--td-brand-color);background-color:var(--td-brand-color);transition:background-color .2s cubic-bezier(.82,0,1,.9)}.t-checkbox.t-is-indeterminate .t-checkbox__input:after{opacity:1;width:16px;height:4px;left:-1px;right:0;top:5px;border:unset;transform:scale(.5);background-color:var(--td-font-white-1)}.t-checkbox.t-is-disabled{cursor:not-allowed}.t-checkbox.t-is-disabled .t-checkbox__label{color:var(--td-text-color-disabled)}.t-checkbox.t-is-disabled .t-checkbox__input{background-color:var(--td-bg-color-component-disabled)}.t-checkbox.t-is-disabled:hover .t-checkbox__input,.t-checkbox.t-is-disabled.t-is-checked .t-checkbox__input{border-color:var(--td-border-level-2-color)}.t-checkbox.t-is-disabled.t-is-checked .t-checkbox__input:after{border-color:var(--td-text-color-disabled)}.t-checkbox.t-is-disabled.t-is-indeterminate .t-checkbox__input{border-color:var(--td-border-level-2-color)}.t-checkbox.t-is-disabled.t-is-indeterminate .t-checkbox__input:after{background-color:var(--td-text-color-disabled)}.t-checkbox:focus-visible:focus-visible{outline:2px solid var(--td-brand-color);outline-offset:var(--td-comp-paddingTB-xs);border-radius:0}.t-select__wrap{width:100%}.t-select__dropdown .t-popup__content{margin:var(--td-comp-paddingTB-s) 0;padding:0;max-height:300px;overflow-y:auto;overscroll-behavior:contain;box-shadow:var(--td-shadow-2)}@-moz-document url-prefix(){.t-select__dropdown .t-popup__content{scrollbar-color:var(--td-scrollbar-color) transparent;scrollbar-width:thin}}.t-select__dropdown .t-popup__content::-webkit-scrollbar{width:8px;height:8px}.t-select__dropdown .t-popup__content::-webkit-scrollbar-thumb{border:2px solid transparent;background-clip:content-box;background-color:var(--td-scrollbar-color);border-radius:15px}.t-select__dropdown .t-popup__content::-webkit-scrollbar-thumb:vertical:hover,.t-select__dropdown .t-popup__content::-webkit-scrollbar-thumb:horizontal:hover{background-color:var(--td-scrollbar-hover-color)}.t-select__dropdown-inner{min-height:var(--td-comp-size-m)}.t-select__dropdown-inner .t-select__list .t-select__list{padding:0}.t-select__dropdown-inner .t-select__list,.t-select__dropdown-inner .t-tree{padding:var(--td-pop-padding-m)}.t-select__dropdown-inner--size-s{min-height:var(--td-comp-size-xs)}.t-select__dropdown-inner--size-s .t-select__list,.t-select__dropdown-inner--size-s .t-tree{padding:var(--td-pop-padding-s)}.t-select__dropdown-inner--size-l{min-height:var(--td-comp-size-xl)}.t-select__dropdown-inner--size-l .t-select__list,.t-select__dropdown-inner--size-l .t-tree{padding:var(--td-pop-padding-l)}.t-select__list{margin:0;padding:0;list-style:none}.t-select__dropdown.t-popup{padding:0}.t-select__empty.t-size-s{line-height:var(--td-comp-size-xs)}.t-select__empty{text-align:center;color:var(--td-text-color-disabled);line-height:var(--td-comp-size-m);padding:0 var(--td-comp-paddingLR-s)}.t-select__empty.t-size-l{line-height:var(--td-comp-size-xl)}.t-select__loading-tips.t-size-s{min-height:var(--td-comp-size-xs);line-height:var(--td-comp-size-xs)}.t-select__loading-tips{position:fixed;top:var(--td-comp-paddingTB-s);left:0;bottom:var(--td-comp-paddingTB-s);right:0;display:flex;align-items:center;justify-content:center;background-color:var(--td-bg-color-container);border-radius:var(--td-radius-default);min-height:var(--td-comp-size-m);line-height:var(--td-comp-size-m);color:var(--td-text-color-disabled);z-index:1000}.t-select__loading-tips.t-size-l{min-height:var(--td-comp-size-xl);line-height:var(--td-comp-size-xl)}.t-select-option-group+.t-select-option-group{padding-top:var(--td-comp-margin-xs);margin-top:var(--td-comp-margin-xs)}.t-select-option-group__divider+.t-select-option-group__divider{position:relative}.t-select-option-group__divider+.t-select-option-group__divider:before{content:"";width:100%;height:1px;padding:0 var(--td-comp-paddingLR-s);position:absolute;top:0;left:0;box-sizing:border-box;background-color:var(--td-border-level-1-color);background-clip:content-box}ul.t-select-option-group__header,.t-select-option-group__header{color:var(--td-text-color-placeholder);display:block;height:var(--td-comp-size-s);line-height:var(--td-comp-size-s);padding:0 var(--td-comp-paddingLR-s);box-sizing:border-box;white-space:nowrap;word-wrap:normal;overflow:hidden;text-overflow:ellipsis}.t-select-option-group__header.t-size-l{height:var(--td-comp-size-l);line-height:var(--td-comp-size-l);padding:0 var(--td-comp-paddingLR-m)}.t-select-option-group__header.t-size-s{height:var(--td-comp-size-xxs);line-height:var(--td-comp-size-xxs);padding:0 var(--td-comp-paddingLR-s)}.t-select-option{display:flex;align-items:center;border-radius:var(--td-radius-default);height:var(--td-comp-size-s);font:var(--td-font-body-medium);cursor:pointer;padding:0 var(--td-comp-paddingLR-s);color:var(--td-text-color-primary);transition:background-color .2s cubic-bezier(.38,0,.24,1);box-sizing:border-box;--ripple-color: var(--td-bg-color-container-active)}.t-select-option span{position:relative;white-space:nowrap;word-wrap:normal;overflow:hidden;text-overflow:ellipsis}.t-select-option:not(.t-is-disabled):not(.t-is-selected):hover{background-color:var(--td-bg-color-container-hover)}.t-select-option:not(.t-is-disabled):not(.t-is-selected):hover .t-checkbox__label{color:inherit}.t-select-option:not(.t-is-disabled):not(.t-is-selected):hover .t-checkbox__input{border-color:var(--td-brand-color)}.t-select-option .t-checkbox__label{color:var(--td-text-color-primary);flex:1;white-space:nowrap;word-wrap:normal;overflow:hidden;text-overflow:ellipsis}.t-select-option .t-checkbox{width:100%}.t-select-option.t-is-disabled{cursor:not-allowed;color:var(--td-text-color-disabled);background:var(--td-bg-color-specialcomponent)}.t-select-option.t-is-disabled:hover,.t-select-option.t-is-disabled :active{background:var(--td-bg-color-specialcomponent)}.t-select-option.t-size-l{height:var(--td-comp-size-l);padding:0 var(--td-comp-paddingLR-m);font:var(--td-font-body-large)}.t-select-option.t-size-m{font:var(--td-font-body-medium)}.t-select-option.t-size-s{height:var(--td-comp-size-xxs);padding:0 var(--td-comp-paddingLR-s);font:var(--td-font-body-small)}.t-select-option.t-is-selected:not(.t-is-disabled){color:var(--td-brand-color);background-color:var(--td-brand-color-light);transition:all .2s linear}.t-select-option.t-is-selected:not(.t-is-disabled) .t-checkbox__label{color:var(--td-brand-color)}.t-select-option.t-is-selected:not(.t-is-disabled):hover{background-color:var(--td-brand-color-light)}.t-select-option.t-select-option__hover:not(.t-is-disabled).t-select-option.t-select-option__hover:not(.t-is-selected),.t-select-option.t-select-option__hover:not(.t-is-disabled).t-select-option.t-select-option--hover:not(.t-is-selected),.t-select-option.t-select-option--hover:not(.t-is-disabled).t-select-option.t-select-option__hover:not(.t-is-selected),.t-select-option.t-select-option--hover:not(.t-is-disabled).t-select-option.t-select-option--hover:not(.t-is-selected){background-color:var(--td-bg-color-container-hover)}.t-select-option.t-select-option__hover:not(.t-is-disabled).t-select-option.t-select-option__hover:not(.t-is-selected) .t-checkbox__input,.t-select-option.t-select-option__hover:not(.t-is-disabled).t-select-option.t-select-option--hover:not(.t-is-selected) .t-checkbox__input,.t-select-option.t-select-option--hover:not(.t-is-disabled).t-select-option.t-select-option__hover:not(.t-is-selected) .t-checkbox__input,.t-select-option.t-select-option--hover:not(.t-is-disabled).t-select-option.t-select-option--hover:not(.t-is-selected) .t-checkbox__input{border-color:var(--td-brand-color)}.t-select-option.t-select-option__hover .t-checkbox__label,.t-select-option.t-select-option--hover .t-checkbox__label{color:inherit}.t-select-option+.t-select-option{margin-top:var(--td-comp-paddingTB-xxs)}.t-select.t-select-input--borderless .t-select__right-icon{position:relative;margin:0}.t-select .t-fake-arrow{color:var(--td-text-color-placeholder)}.t-select .t-fake-arrow--active{color:var(--td-brand-color)}.t-is-selected.t-select-option__hover{background-color:var(--td-brand-color-light-hover)}.t-is-selected.t-select-option__hover .t-checkbox__label{color:var(--td-brand-color)}.t-textarea{font:var(--td-font-body-medium);color:var(--td-text-color-primary);box-sizing:border-box;margin:0;padding:0;list-style:none;position:relative;width:100%}.t-textarea__inner{display:flex;width:100%;height:var(--td-comp-size-xxxl);border:1px solid var(--td-border-level-2-color);border-radius:var(--td-radius-default);padding:calc(calc(var(--td-comp-size-m) - var(--td-line-height-body-medium)) / 2) var(--td-comp-paddingLR-s);background-color:var(--td-bg-color-specialcomponent);font:var(--td-font-body-medium);color:var(--td-text-color-primary);resize:vertical;outline:none;transition:all cubic-bezier(.38,0,.24,1) .2s,height 0s;box-sizing:border-box}.t-textarea__inner:hover{border-color:var(--td-brand-color)}.t-textarea__inner:focus{border-color:var(--td-brand-color);box-shadow:0 0 0 2px var(--td-brand-color-focus)}.t-textarea__inner::placeholder{color:var(--td-text-color-placeholder)}.t-textarea__inner.t-is-success{border-color:var(--td-success-color)}.t-textarea__inner.t-is-success:focus{box-shadow:0 0 0 2px var(--td-success-color-focus)}.t-textarea__inner.t-is-warning{border-color:var(--td-warning-color)}.t-textarea__inner.t-is-warning:focus{box-shadow:0 0 0 2px var(--td-warning-color-focus)}.t-textarea__inner.t-is-error{border-color:var(--td-error-color)}.t-textarea__inner.t-is-error:focus{box-shadow:0 0 0 2px var(--td-error-color-focus)}.t-textarea__info_wrapper{display:flex;column-gap:var(--td-comp-margin-s);justify-content:space-between}.t-textarea__info_wrapper_align{justify-content:end}.t-textarea__limit{font:var(--td-font-body-small);color:var(--td-text-color-placeholder)}.t-textarea .t-is-disabled{color:var(--td-text-color-disabled);background-color:var(--td-bg-color-component-disabled);cursor:not-allowed}.t-textarea .t-is-disabled:hover{border-color:var(--td-border-level-2-color)}.t-textarea .t-is-disabled::placeholder{color:var(--td-text-color-disabled)}.t-textarea .t-resize-none{resize:none}.t-textarea__tips{height:auto;min-height:var(--td-comp-size-xs);font:var(--td-font-body-small);display:inline-block}.t-textarea__tips--normal{color:var(--td-text-color-placeholder)}.t-textarea__tips--success{color:var(--td-success-color)}.t-textarea__tips--warning{color:var(--td-warning-color)}.t-textarea__tips--error{color:var(--td-error-color)}@keyframes tDialogZoomIn{0%{opacity:0;transform:scale(.01)}to{opacity:1}}@keyframes tDialogZoomOut{0%{opacity:1}to{opacity:0;transform:scale(.01)}}@keyframes tDialogMaskIn{0%{opacity:0}to{opacity:1}}@keyframes tDialogMaskOut{0%{opacity:1}to{opacity:0}}.t-dialog-zoom .animation-enter{animation-duration:.2s;animation-fill-mode:both;animation-timing-function:cubic-bezier(0,0,.15,1);animation-play-state:paused}.t-dialog-zoom .animation-exit{animation-duration:.2s;animation-fill-mode:both;animation-timing-function:cubic-bezier(.38,0,.24,1);animation-play-state:paused}.t-dialog-zoom .animation-active{animation-play-state:running;animation-fill-mode:both}.t-dialog-zoom-enter,.t-dialog-zoom-enter-from,.t-dialog-zoom-appear{animation-duration:.2s;animation-fill-mode:both;animation-timing-function:cubic-bezier(0,0,.15,1);animation-play-state:paused}.t-dialog-zoom-exit{animation-duration:.2s;animation-fill-mode:both;animation-timing-function:cubic-bezier(.38,0,.24,1);animation-play-state:paused}.t-dialog-zoom-enter-active,.t-dialog-zoom-appear-active{animation-name:tDialogZoomIn;animation-play-state:running;animation-fill-mode:both}.t-dialog-zoom-exit-active{animation-name:tDialogZoomOut;animation-play-state:running;animation-fill-mode:both}.t-dialog-zoom__vue-enter-active .t-dialog{animation-name:tDialogZoomIn;animation-duration:.2s;animation-fill-mode:both;animation-timing-function:cubic-bezier(0,0,.15,1);animation-play-state:paused}.t-dialog-zoom__vue-enter-active .t-dialog__mask{animation-name:tDialogMaskIn;animation-duration:.2s;animation-timing-function:linear;animation-play-state:running;animation-fill-mode:both}.t-dialog-zoom__vue-leave-active .t-dialog{animation-name:tDialogZoomOut;animation-duration:.2s;animation-fill-mode:both;animation-timing-function:cubic-bezier(.38,0,.24,1);animation-play-state:paused}.t-dialog-zoom__vue-leave-active .t-dialog__mask{animation-name:tDialogMaskOut;animation-duration:.2s;animation-timing-function:linear;animation-play-state:running;animation-fill-mode:both}.t-dialog-zoom__vue-enter-to .t-dialog,.t-dialog-zoom__vue-leave-to .t-dialog{animation-play-state:running;animation-fill-mode:both}.t-dialog-fade-enter,.t-dialog-fade-appear{opacity:0;animation-duration:.2s;animation-fill-mode:both;animation-timing-function:cubic-bezier(0,0,.15,1);animation-play-state:paused}.t-dialog-fade-exit{animation-duration:.2s;animation-fill-mode:both;animation-timing-function:cubic-bezier(0,0,.15,1);animation-play-state:paused}.t-dialog-fade-enter.t-dialog-fade-enter-active,.t-dialog-fade-appear.t-dialog-fade-appear-active{animation-name:tDialogFadeIn;animation-play-state:running}.t-dialog-fade-exit.t-dialog-fade-exit-active{animation-name:tDialogFadeOut;animation-play-state:running}@keyframes tDialogFadeIn{0%{opacity:0}to{opacity:1}}@keyframes tDialogFadeOut{0%{opacity:1}to{opacity:0}}.t-dialog{font:var(--td-font-body-medium);color:var(--td-text-color-primary);box-sizing:border-box;margin:0;padding:0;list-style:none;width:480px;background-color:var(--td-bg-color-container);position:relative;border:1px solid var(--td-border-level-1-color);border-radius:var(--td-radius-large)}.t-dialog .t-icon.t-is-info{color:var(--td-brand-color)}.t-dialog .t-icon.t-is-success{color:var(--td-success-color)}.t-dialog .t-icon.t-is-warning{color:var(--td-warning-color)}.t-dialog .t-icon.t-is-error{color:var(--td-error-color)}.t-dialog--lock{overflow:hidden}.t-dialog__header{color:var(--td-text-color-primary);font:var(--td-font-title-medium);font-weight:600;display:flex;align-items:center;word-break:break-word;gap:var(--td-comp-margin-s);box-sizing:border-box}.t-dialog__header .t-dialog__header-content{display:flex;align-items:flex-start;width:100%}.t-dialog__header .t-icon:not(.t-icon-close){font-size:calc(var(--td-font-size-body-large) + 8px);display:inline-flex;align-items:center;margin-right:var(--td-comp-margin-s);flex-shrink:0}.t-dialog__header--fullscreen{background-color:var(--td-bg-color-secondarycontainer);min-height:var(--td-comp-size-xxxl);justify-content:flex-end;display:flex;align-items:center;flex-direction:row;padding:0 var(--td-comp-paddingLR-xxl)}.t-dialog__header--fullscreen .t-dialog__header-content{box-sizing:border-box;display:flex;justify-content:center;align-items:center}.t-dialog__body{color:var(--td-text-color-secondary);font:var(--td-font-body-medium);overflow:auto;padding:var(--td-comp-paddingTB-l) 0;word-break:break-word}@-moz-document url-prefix(){.t-dialog__body{scrollbar-color:var(--td-scrollbar-color) transparent;scrollbar-width:thin}}.t-dialog__body::-webkit-scrollbar{width:6px;height:6px}.t-dialog__body::-webkit-scrollbar-thumb{border:0px solid transparent;background-clip:content-box;background-color:var(--td-scrollbar-color);border-radius:11px}.t-dialog__body::-webkit-scrollbar-thumb:vertical:hover,.t-dialog__body::-webkit-scrollbar-thumb:horizontal:hover{background-color:var(--td-scrollbar-hover-color)}.t-dialog__body__icon,.t-dialog__body--icon{padding:var(--td-comp-paddingTB-l) 0}.t-dialog__body--fullscreen{box-sizing:border-box;padding:var(--td-comp-paddingTB-xl) var(--td-comp-paddingLR-xxl);height:calc(100% - var(--td-comp-size-xxxl) - var(--td-comp-size-xxxxl));overflow:auto}@-moz-document url-prefix(){.t-dialog__body--fullscreen{scrollbar-color:var(--td-scrollbar-color) transparent;scrollbar-width:thin}}.t-dialog__body--fullscreen::-webkit-scrollbar{width:6px;height:6px}.t-dialog__body--fullscreen::-webkit-scrollbar-thumb{border:0px solid transparent;background-clip:content-box;background-color:var(--td-scrollbar-color);border-radius:11px}.t-dialog__body--fullscreen::-webkit-scrollbar-thumb:vertical:hover,.t-dialog__body--fullscreen::-webkit-scrollbar-thumb:horizontal:hover{background-color:var(--td-scrollbar-hover-color)}.t-dialog__body--fullscreen--without-footer{box-sizing:border-box;padding:var(--td-comp-paddingTB-xl) var(--td-comp-paddingLR-xxl);height:calc(100% - var(--td-comp-size-xxxl));overflow:auto}.t-dialog__footer{width:100%;text-align:right;padding:var(--td-comp-paddingTB-l) 0 0}.t-dialog__footer .t-button+.t-button{margin-left:var(--td-comp-margin-s)}.t-dialog__footer--fullscreen{min-height:var(--td-comp-size-xxxxl);padding:0 var(--td-comp-paddingLR-xxl) var(--td-comp-paddingTB-xxl);box-sizing:border-box}.t-dialog--default{padding:var(--td-comp-paddingTB-xxl) var(--td-comp-paddingLR-xxl)}.t-dialog__close{font-size:calc(var(--td-font-size-body-large) + 4px);color:var(--td-text-color-secondary);display:flex;width:calc(var(--td-font-size-body-large) + 4px);height:calc(var(--td-font-size-body-large) + 4px);align-items:center;border-radius:var(--td-radius-default);transition:all .2s linear;padding:var(--td-comp-paddingTB-xxs) var(--td-comp-paddingLR-xxs)}.t-dialog__close:hover{cursor:pointer;background:var(--td-bg-color-container-hover)}.t-dialog__close:active{background:var(--td-bg-color-container-active)}.t-dialog__close--fullscreen{display:flex;background:transparent}.t-dialog__close--fullscreen:hover{cursor:pointer;background:var(--td-bg-color-secondarycontainer-hover)}.t-dialog__close--fullscreen:active{background:var(--td-bg-color-secondarycontainer-active)}.t-dialog.t-dialog--draggable:hover{cursor:move}.t-dialog.t-dialog--draggable .t-dialog__header:hover,.t-dialog.t-dialog--draggable .t-dialog__body:hover,.t-dialog.t-dialog--draggable .t-dialog__footer:hover{cursor:auto}.t-dialog__fullscreen{width:100%;border-radius:0}.t-dialog__ctx{pointer-events:auto;outline:none;top:0;left:0;width:100%;height:100%}.t-dialog__ctx.t-dialog__ctx--modeless{pointer-events:none}.t-dialog__ctx.t-dialog__ctx--fixed{position:fixed;z-index:2500}.t-dialog__ctx.t-dialog__ctx--absolute,.t-dialog__ctx.t-dialog__ctx--absolute .t-dialog__mask,.t-dialog__ctx.t-dialog__ctx--absolute .t-dialog__wrap{position:absolute}.t-dialog__ctx.t-is-visible{visibility:visible}.t-dialog__ctx.t-is-hidden{visibility:hidden}.t-dialog__ctx.t-is-display{display:block}.t-dialog__ctx.t-not-display{display:none}.t-dialog__ctx .t-dialog__mask{position:fixed;top:0;left:0;width:100%;height:100%;z-index:1;background:var(--td-mask-active);pointer-events:auto}.t-dialog__ctx .t-dialog__wrap{position:fixed;top:0;left:0;width:100%;height:100%;z-index:1;overflow:auto}@-moz-document url-prefix(){.t-dialog__ctx .t-dialog__wrap{scrollbar-color:var(--td-scrollbar-color) transparent;scrollbar-width:thin}}.t-dialog__ctx .t-dialog__wrap::-webkit-scrollbar{width:8px;height:8px}.t-dialog__ctx .t-dialog__wrap::-webkit-scrollbar-thumb{border:2px solid transparent;background-clip:content-box;background-color:var(--td-scrollbar-color);border-radius:15px}.t-dialog__ctx .t-dialog__wrap::-webkit-scrollbar-thumb:vertical:hover,.t-dialog__ctx .t-dialog__wrap::-webkit-scrollbar-thumb:horizontal:hover{background-color:var(--td-scrollbar-hover-color)}.t-dialog__ctx .t-dialog__position{display:flex;justify-content:center;min-height:100%;width:100%;position:relative;padding:48px 0;box-sizing:border-box}.t-dialog__ctx .t-dialog__position.t-dialog--top{align-items:flex-start;padding-top:20vh}.t-dialog__ctx .t-dialog__position.t-dialog--center{align-items:center}.t-dialog__ctx .t-dialog__position_fullscreen{display:flex;justify-content:center;min-height:100%;width:100%;position:relative;box-sizing:border-box}.t-dialog__ctx .t-is-hidden{background:none}.t-dialog__ctx .t-dialog{pointer-events:auto;z-index:2500}.t-dialog__ctx.t-dialog__ctx--modeless .t-dialog{box-shadow:var(--td-shadow-3)}:root{--td-screen-xs: 320px;--td-screen-sm: 768px;--td-screen-md: 992px;--td-screen-lg: 1200px;--td-screen-xl: 1400px;--td-screen-xxl: 1880px}@-moz-document url-prefix(){.narrow-scrollbar{scrollbar-color:var(--td-scrollbar-color) transparent;scrollbar-width:thin}}.narrow-scrollbar::-webkit-scrollbar{width:8px;height:8px}.narrow-scrollbar::-webkit-scrollbar-thumb{border:2px solid transparent;background-clip:content-box;background-color:var(--td-scrollbar-color);border-radius:15px}.narrow-scrollbar::-webkit-scrollbar-thumb:vertical:hover,.narrow-scrollbar::-webkit-scrollbar-thumb:horizontal:hover{background-color:var(--td-scrollbar-hover-color)}.t-fake-arrow path{transition:d .2s;stroke:currentcolor}.t-fake-arrow--active path{d:path("M3.75 10.2002L7.99274 5.7998L12.2361 10.0425")}.t-slide-down-enter-active,.t-slide-down-leave-active{transition:height .2s cubic-bezier(.38,0,.24,1),max-height .2s cubic-bezier(.38,0,.24,1)}:root,:root[theme-mode=light]{--td-brand-color-1: #f2f3ff;--td-brand-color-2: #d9e1ff;--td-brand-color-3: #b5c7ff;--td-brand-color-4: #8eabff;--td-brand-color-5: #618dff;--td-brand-color-6: #366ef4;--td-brand-color-7: #0052d9;--td-brand-color-8: #003cab;--td-brand-color-9: #002a7c;--td-brand-color-10: #001a57;--td-warning-color-1: #fff1e9;--td-warning-color-2: #ffd9c2;--td-warning-color-3: #ffb98c;--td-warning-color-4: #fa9550;--td-warning-color-5: #e37318;--td-warning-color-6: #be5a00;--td-warning-color-7: #954500;--td-warning-color-8: #713300;--td-warning-color-9: #532300;--td-warning-color-10: #3b1700;--td-error-color-1: #fff0ed;--td-error-color-2: #ffd8d2;--td-error-color-3: #ffb9b0;--td-error-color-4: #ff9285;--td-error-color-5: #f6685d;--td-error-color-6: #d54941;--td-error-color-7: #ad352f;--td-error-color-8: #881f1c;--td-error-color-9: #68070a;--td-error-color-10: #490002;--td-success-color-1: #e3f9e9;--td-success-color-2: #c6f3d7;--td-success-color-3: #92dab2;--td-success-color-4: #56c08d;--td-success-color-5: #2ba471;--td-success-color-6: #008858;--td-success-color-7: #006c45;--td-success-color-8: #005334;--td-success-color-9: #003b23;--td-success-color-10: #002515;--td-gray-color-1: #f3f3f3;--td-gray-color-2: #eee;--td-gray-color-3: #e8e8e8;--td-gray-color-4: #ddd;--td-gray-color-5: #c6c6c6;--td-gray-color-6: #a6a6a6;--td-gray-color-7: #8b8b8b;--td-gray-color-8: #777;--td-gray-color-9: #5e5e5e;--td-gray-color-10: #4b4b4b;--td-gray-color-11: #393939;--td-gray-color-12: #2c2c2c;--td-gray-color-13: #242424;--td-gray-color-14: #181818;--td-font-white-1: #ffffff;--td-font-white-2: rgba(255, 255, 255, .55);--td-font-white-3: rgba(255, 255, 255, .35);--td-font-white-4: rgba(255, 255, 255, .22);--td-font-gray-1: rgba(0, 0, 0, .9);--td-font-gray-2: rgba(0, 0, 0, .6);--td-font-gray-3: rgba(0, 0, 0, .4);--td-font-gray-4: rgba(0, 0, 0, .26);--td-brand-color: var(--td-brand-color-7);--td-warning-color: var(--td-warning-color-5);--td-error-color: var(--td-error-color-6);--td-success-color: var(--td-success-color-5);--td-brand-color-hover: var(--td-brand-color-6);--td-brand-color-focus: var(--td-brand-color-2);--td-brand-color-active: var(--td-brand-color-8);--td-brand-color-disabled: var(--td-brand-color-3);--td-brand-color-light: var(--td-brand-color-1);--td-brand-color-light-hover: var(--td-brand-color-2);--td-warning-color-hover: var(--td-warning-color-4);--td-warning-color-focus: var(--td-warning-color-2);--td-warning-color-active: var(--td-warning-color-6);--td-warning-color-disabled: var(--td-warning-color-3);--td-warning-color-light: var(--td-warning-color-1);--td-warning-color-light-hover: var(--td-warning-color-2);--td-error-color-hover: var(--td-error-color-5);--td-error-color-focus: var(--td-error-color-2);--td-error-color-active: var(--td-error-color-7);--td-error-color-disabled: var(--td-error-color-3);--td-error-color-light: var(--td-error-color-1);--td-error-color-light-hover: var(--td-error-color-2);--td-success-color-hover: var(--td-success-color-4);--td-success-color-focus: var(--td-success-color-2);--td-success-color-active: var(--td-success-color-6);--td-success-color-disabled: var(--td-success-color-3);--td-success-color-light: var(--td-success-color-1);--td-success-color-light-hover: var(--td-success-color-2);--td-mask-active: rgba(0, 0, 0, .6);--td-mask-disabled: rgba(255, 255, 255, .6);--td-bg-color-page: var(--td-gray-color-2);--td-bg-color-container: #fff;--td-bg-color-container-hover: var(--td-gray-color-1);--td-bg-color-container-active: var(--td-gray-color-3);--td-bg-color-container-select: #fff;--td-bg-color-secondarycontainer: var(--td-gray-color-1);--td-bg-color-secondarycontainer-hover: var(--td-gray-color-2);--td-bg-color-secondarycontainer-active: var(--td-gray-color-4);--td-bg-color-component: var(--td-gray-color-3);--td-bg-color-component-hover: var(--td-gray-color-4);--td-bg-color-component-active: var(--td-gray-color-6);--td-bg-color-secondarycomponent: var(--td-gray-color-4);--td-bg-color-secondarycomponent-hover: var(--td-gray-color-5);--td-bg-color-secondarycomponent-active: var(--td-gray-color-6);--td-bg-color-component-disabled: var(--td-gray-color-2);--td-bg-color-specialcomponent: #fff;--td-text-color-primary: var(--td-font-gray-1);--td-text-color-secondary: var(--td-font-gray-2);--td-text-color-placeholder: var(--td-font-gray-3);--td-text-color-disabled: var(--td-font-gray-4);--td-text-color-anti: #fff;--td-text-color-brand: var(--td-brand-color-7);--td-text-color-link: var(--td-brand-color-8);--td-border-level-1-color: var(--td-gray-color-3);--td-component-stroke: var(--td-gray-color-3);--td-border-level-2-color: var(--td-gray-color-4);--td-component-border: var(--td-gray-color-4);--td-shadow-1: 0 1px 10px rgba(0, 0, 0, .05), 0 4px 5px rgba(0, 0, 0, .08), 0 2px 4px -1px rgba(0, 0, 0, .12);--td-shadow-2: 0 3px 14px 2px rgba(0, 0, 0, .05), 0 8px 10px 1px rgba(0, 0, 0, .06), 0 5px 5px -3px rgba(0, 0, 0, .1);--td-shadow-3: 0 6px 30px 5px rgba(0, 0, 0, .05), 0 16px 24px 2px rgba(0, 0, 0, .04), 0 8px 10px -5px rgba(0, 0, 0, .08);--td-shadow-inset-top: inset 0 .5px 0 #dcdcdc;--td-shadow-inset-right: inset .5px 0 0 #dcdcdc;--td-shadow-inset-bottom: inset 0 -.5px 0 #dcdcdc;--td-shadow-inset-left: inset -.5px 0 0 #dcdcdc;--td-table-shadow-color: rgba(0, 0, 0, .08);--td-scrollbar-color: rgba(0, 0, 0, .1);--td-scrollbar-hover-color: rgba(0, 0, 0, .3);--td-scroll-track-color: #fff}:root[theme-mode=dark]{--td-brand-color-1: #1b2f51;--td-brand-color-2: #173463;--td-brand-color-3: #143975;--td-brand-color-4: #103d88;--td-brand-color-5: #0d429a;--td-brand-color-6: #054bbe;--td-brand-color-7: #2667d4;--td-brand-color-8: #4582e6;--td-brand-color-9: #699ef5;--td-brand-color-10: #96bbf8;--td-warning-color-1: #4f2a1d;--td-warning-color-2: #582f21;--td-warning-color-3: #733c23;--td-warning-color-4: #a75d2b;--td-warning-color-5: #cf6e2d;--td-warning-color-6: #dc7633;--td-warning-color-7: #e8935c;--td-warning-color-8: #ecbf91;--td-warning-color-9: #eed7bf;--td-warning-color-10: #f3e9dc;--td-error-color-1: #472324;--td-error-color-2: #5e2a2d;--td-error-color-3: #703439;--td-error-color-4: #83383e;--td-error-color-5: #a03f46;--td-error-color-6: #c64751;--td-error-color-7: #de6670;--td-error-color-8: #ec888e;--td-error-color-9: #edb1b6;--td-error-color-10: #eeced0;--td-success-color-1: #193a2a;--td-success-color-2: #1a4230;--td-success-color-3: #17533d;--td-success-color-4: #0d7a55;--td-success-color-5: #059465;--td-success-color-6: #43af8a;--td-success-color-7: #46bf96;--td-success-color-8: #80d2b6;--td-success-color-9: #b4e1d3;--td-success-color-10: #deede8;--td-gray-color-1: #f3f3f3;--td-gray-color-2: #eee;--td-gray-color-3: #e8e8e8;--td-gray-color-4: #ddd;--td-gray-color-5: #c6c6c6;--td-gray-color-6: #a6a6a6;--td-gray-color-7: #8b8b8b;--td-gray-color-8: #777;--td-gray-color-9: #5e5e5e;--td-gray-color-10: #4b4b4b;--td-gray-color-11: #393939;--td-gray-color-12: #2c2c2c;--td-gray-color-13: #242424;--td-gray-color-14: #181818;--td-font-white-1: rgba(255, 255, 255, .9);--td-font-white-2: rgba(255, 255, 255, .55);--td-font-white-3: rgba(255, 255, 255, .35);--td-font-white-4: rgba(255, 255, 255, .22);--td-font-gray-1: rgba(0, 0, 0, .9);--td-font-gray-2: rgba(0, 0, 0, .6);--td-font-gray-3: rgba(0, 0, 0, .4);--td-font-gray-4: rgba(0, 0, 0, .26);--td-brand-color: var(--td-brand-color-8);--td-warning-color: var(--td-warning-color-5);--td-error-color: var(--td-error-color-6);--td-success-color: var(--td-success-color-5);--td-brand-color-hover: var(--td-brand-color-7);--td-brand-color-focus: var(--td-brand-color-2);--td-brand-color-active: var(--td-brand-color-9);--td-brand-color-disabled: var(--td-brand-color-3);--td-brand-color-light: var(--td-brand-color-1);--td-brand-color-light-hover: var(--td-brand-color-2);--td-warning-color-hover: var(--td-warning-color-4);--td-warning-color-focus: var(--td-warning-color-2);--td-warning-color-active: var(--td-warning-color-6);--td-warning-color-disabled: var(--td-warning-color-3);--td-warning-color-light: var(--td-warning-color-1);--td-warning-color-light-hover: var(--td-warning-color-2);--td-error-color-hover: var(--td-error-color-5);--td-error-color-focus: var(--td-error-color-2);--td-error-color-active: var(--td-error-color-7);--td-error-color-disabled: var(--td-error-color-3);--td-error-color-light: var(--td-error-color-1);--td-error-color-light-hover: var(--td-error-color-2);--td-success-color-hover: var(--td-success-color-4);--td-success-color-focus: var(--td-success-color-2);--td-success-color-active: var(--td-success-color-6);--td-success-color-disabled: var(--td-success-color-3);--td-success-color-light: var(--td-success-color-1);--td-success-color-light-hover: var(--td-success-color-2);--td-mask-active: rgba(0, 0, 0, .4);--td-mask-disabled: rgba(0, 0, 0, .6);--td-bg-color-page: var(--td-gray-color-14);--td-bg-color-container: var(--td-gray-color-13);--td-bg-color-container-hover: var(--td-gray-color-12);--td-bg-color-container-active: var(--td-gray-color-10);--td-bg-color-container-select: var(--td-gray-color-9);--td-bg-color-secondarycontainer: var(--td-gray-color-12);--td-bg-color-secondarycontainer-hover: var(--td-gray-color-11);--td-bg-color-secondarycontainer-active: var(--td-gray-color-9);--td-bg-color-component: var(--td-gray-color-11);--td-bg-color-component-hover: var(--td-gray-color-10);--td-bg-color-component-active: var(--td-gray-color-9);--td-bg-color-secondarycomponent: var(--td-gray-color-10);--td-bg-color-secondarycomponent-hover: var(--td-gray-color-9);--td-bg-color-secondarycomponent-active: var(--td-gray-color-8);--td-bg-color-component-disabled: var(--td-gray-color-12);--td-bg-color-specialcomponent: transparent;--td-text-color-primary: var(--td-font-white-1);--td-text-color-secondary: var(--td-font-white-2);--td-text-color-placeholder: var(--td-font-white-3);--td-text-color-disabled: var(--td-font-white-4);--td-text-color-anti: #fff;--td-text-color-brand: var(--td-brand-color-8);--td-text-color-link: var(--td-brand-color-8);--td-border-level-1-color: var(--td-gray-color-11);--td-component-stroke: var(--td-gray-color-11);--td-border-level-2-color: var(--td-gray-color-9);--td-component-border: var(--td-gray-color-9);--td-shadow-1: 0 4px 6px rgba(0, 0, 0, .06), 0 1px 10px rgba(0, 0, 0, .08), 0 2px 4px rgba(0, 0, 0, .12);--td-shadow-2: 0 8px 10px rgba(0, 0, 0, .12), 0 3px 14px rgba(0, 0, 0, .1), 0 5px 5px rgba(0, 0, 0, .16);--td-shadow-3: 0 16px 24px rgba(0, 0, 0, .14), 0 6px 30px rgba(0, 0, 0, .12), 0 8px 10px rgba(0, 0, 0, .2);--td-shadow-inset-top: inset 0 .5px 0 #5e5e5e;--td-shadow-inset-right: inset .5px 0 0 #5e5e5e;--td-shadow-inset-bottom: inset 0 -.5px 0 #5e5e5e;--td-shadow-inset-left: inset -.5px 0 0 #5e5e5e;--td-table-shadow-color: rgba(0, 0, 0, .55);--td-scrollbar-color: rgba(255, 255, 255, .1);--td-scrollbar-hover-color: rgba(255, 255, 255, .3);--td-scroll-track-color: #333}:root{--td-radius-small: 2px;--td-radius-default: 3px;--td-radius-medium: 6px;--td-radius-large: 9px;--td-radius-extraLarge: 12px;--td-radius-round: 999px;--td-radius-circle: 50%}:root{--td-font-family: PingFang SC, Microsoft YaHei, Arial Regular;--td-font-family-medium: PingFang SC, Microsoft YaHei, Arial Medium;--td-font-size-link-small: 12px;--td-font-size-link-medium: 14px;--td-font-size-link-large: 16px;--td-font-size-mark-small: 12px;--td-font-size-mark-medium: 14px;--td-font-size-body-small: 12px;--td-font-size-body-medium: 14px;--td-font-size-body-large: 16px;--td-font-size-title-small: 14px;--td-font-size-title-medium: 16px;--td-font-size-title-large: 20px;--td-font-size-headline-small: 24px;--td-font-size-headline-medium: 28px;--td-font-size-headline-large: 36px;--td-font-size-display-medium: 48px;--td-font-size-display-large: 64px;--td-line-height-link-small: 20px;--td-line-height-link-medium: 22px;--td-line-height-link-large: 24px;--td-line-height-mark-small: 20px;--td-line-height-mark-medium: 22px;--td-line-height-body-small: 20px;--td-line-height-body-medium: 22px;--td-line-height-body-large: 24px;--td-line-height-title-small: 22px;--td-line-height-title-medium: 24px;--td-line-height-title-large: 28px;--td-line-height-headline-small: 32px;--td-line-height-headline-medium: 36px;--td-line-height-headline-large: 44px;--td-line-height-display-medium: 56px;--td-line-height-display-large: 72px;--td-font-link-small: var(--td-font-size-link-small) / var(--td-line-height-link-small) var(--td-font-family);--td-font-link-medium: var(--td-font-size-link-medium) / var(--td-line-height-link-medium) var(--td-font-family);--td-font-link-large: var(--td-font-size-link-large) / var(--td-line-height-link-large) var(--td-font-family);--td-font-mark-small: 600 var(--td-font-size-mark-small) / var(--td-line-height-mark-small) var(--td-font-family);--td-font-mark-medium: 600 var(--td-font-size-mark-medium) / var(--td-line-height-mark-medium) var(--td-font-family);--td-font-body-small: var(--td-font-size-body-small) / var(--td-line-height-body-small) var(--td-font-family);--td-font-body-medium: var(--td-font-size-body-medium) / var(--td-line-height-body-medium) var(--td-font-family);--td-font-body-large: var(--td-font-size-body-large) / var(--td-line-height-body-large) var(--td-font-family);--td-font-title-small: 600 var(--td-font-size-title-small) / var(--td-line-height-title-small) var(--td-font-family);--td-font-title-medium: 600 var(--td-font-size-title-medium) / var(--td-line-height-title-medium) var(--td-font-family);--td-font-title-large: 600 var(--td-font-size-title-large) / var(--td-line-height-title-large) var(--td-font-family);--td-font-headline-small: 600 var(--td-font-size-headline-small) / var(--td-line-height-headline-small) var(--td-font-family);--td-font-headline-medium: 600 var(--td-font-size-headline-medium) / var(--td-line-height-headline-medium) var(--td-font-family);--td-font-headline-large: 600 var(--td-font-size-headline-large) / var(--td-line-height-headline-large) var(--td-font-family);--td-font-display-medium: 600 var(--td-font-size-display-medium) / var(--td-line-height-display-medium) var(--td-font-family);--td-font-display-large: 600 var(--td-font-size-display-large) / var(--td-line-height-display-large) var(--td-font-family)}:root{--td-size-1: 2px;--td-size-2: 4px;--td-size-3: 6px;--td-size-4: 8px;--td-size-5: 12px;--td-size-6: 16px;--td-size-7: 20px;--td-size-8: 24px;--td-size-9: 28px;--td-size-10: 32px;--td-size-11: 36px;--td-size-12: 40px;--td-size-13: 48px;--td-size-14: 56px;--td-size-15: 64px;--td-size-16: 72px;--td-comp-size-xxxs: var(--td-size-6);--td-comp-size-xxs: var(--td-size-7);--td-comp-size-xs: var(--td-size-8);--td-comp-size-s: var(--td-size-9);--td-comp-size-m: var(--td-size-10);--td-comp-size-l: var(--td-size-11);--td-comp-size-xl: var(--td-size-12);--td-comp-size-xxl: var(--td-size-13);--td-comp-size-xxxl: var(--td-size-14);--td-comp-size-xxxxl: var(--td-size-15);--td-comp-size-xxxxxl: var(--td-size-16);--td-pop-padding-s: var(--td-size-2);--td-pop-padding-m: var(--td-size-3);--td-pop-padding-l: var(--td-size-4);--td-pop-padding-xl: var(--td-size-5);--td-pop-padding-xxl: var(--td-size-6);--td-comp-paddingLR-xxs: var(--td-size-1);--td-comp-paddingLR-xs: var(--td-size-2);--td-comp-paddingLR-s: var(--td-size-4);--td-comp-paddingLR-m: var(--td-size-5);--td-comp-paddingLR-l: var(--td-size-6);--td-comp-paddingLR-xl: var(--td-size-8);--td-comp-paddingLR-xxl: var(--td-size-10);--td-comp-paddingTB-xxs: var(--td-size-1);--td-comp-paddingTB-xs: var(--td-size-2);--td-comp-paddingTB-s: var(--td-size-4);--td-comp-paddingTB-m: var(--td-size-5);--td-comp-paddingTB-l: var(--td-size-6);--td-comp-paddingTB-xl: var(--td-size-8);--td-comp-paddingTB-xxl: var(--td-size-10);--td-comp-margin-xxs: var(--td-size-1);--td-comp-margin-xs: var(--td-size-2);--td-comp-margin-s: var(--td-size-4);--td-comp-margin-m: var(--td-size-5);--td-comp-margin-l: var(--td-size-6);--td-comp-margin-xl: var(--td-size-7);--td-comp-margin-xxl: var(--td-size-8);--td-comp-margin-xxxl: var(--td-size-10);--td-comp-margin-xxxxl: var(--td-size-12)}.tailwind-setting__trigger{color:var(--td-brand-color-10);font-size:20px}.select input{-webkit-user-select:none;user-select:none}.css-node{display:flex;align-items:center;justify-content:space-between}.tailwind-code-area{padding:5px 12px;white-space:pre-wrap;word-break:break-all;min-height:32px;max-height:190px;overflow:auto;border-radius:4px;cursor:text;background:#0000000a;width:100%}.ai-glow-btn[data-v-c1a9705a]{position:relative;margin:0 10px;padding:6px 20px;font-size:14px;font-weight:500;color:#fff;background:linear-gradient(135deg,#1a1a2e,#16213e);border:none;border-radius:8px;cursor:pointer;overflow:hidden}.ai-glow-btn[data-v-c1a9705a]:before{content:"";position:absolute;top:-2px;left:-2px;right:-2px;bottom:-2px;background:conic-gradient(from 0deg,#00f5ff,#7b2cbf,#ff006e,#00f5ff);border-radius:10px;z-index:-1;animation:rotate-glow-c1a9705a 2s linear infinite}.ai-glow-btn[data-v-c1a9705a]:after{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background:linear-gradient(135deg,#1a1a2e,#16213e);border-radius:8px;z-index:-1}@keyframes rotate-glow-c1a9705a{0%{transform:rotate(0)}to{transform:rotate(360deg)}} ');

(async function () {
  'use strict';

  /**
  * @vue/shared v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function makeMap(str) {
    const map2 = /* @__PURE__ */ Object.create(null);
    for (const key2 of str.split(",")) map2[key2] = 1;
    return (val) => val in map2;
  }
  const EMPTY_OBJ = Object.freeze({});
  const EMPTY_ARR = Object.freeze([]);
  const NOOP = () => {
  };
  const NO = () => false;
  const isOn = (key2) => key2.charCodeAt(0) === 111 && key2.charCodeAt(1) === 110 && // uppercase letter
    (key2.charCodeAt(2) > 122 || key2.charCodeAt(2) < 97);
  const isModelListener = (key2) => key2.startsWith("onUpdate:");
  const extend = Object.assign;
  const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  const hasOwnProperty$f = Object.prototype.hasOwnProperty;
  const hasOwn$1 = (val, key2) => hasOwnProperty$f.call(val, key2);
  const isArray$1 = Array.isArray;
  const isMap$1 = (val) => toTypeString(val) === "[object Map]";
  const isSet$1 = (val) => toTypeString(val) === "[object Set]";
  const isFunction$1 = (val) => typeof val === "function";
  const isString$1 = (val) => typeof val === "string";
  const isSymbol$1 = (val) => typeof val === "symbol";
  const isObject$1 = (val) => val !== null && typeof val === "object";
  const isPromise = (val) => {
    return (isObject$1(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
  };
  const objectToString$1 = Object.prototype.toString;
  const toTypeString = (value) => objectToString$1.call(value);
  const toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
  const isIntegerKey = (key2) => isString$1(key2) && key2 !== "NaN" && key2[0] !== "-" && "" + parseInt(key2, 10) === key2;
  const isReservedProp = /* @__PURE__ */ makeMap(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  const isBuiltInDirective = /* @__PURE__ */ makeMap(
    "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
  );
  const cacheStringFunction = (fn2) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn2(str));
    };
  };
  const camelizeRE = /-(\w)/g;
  const camelize = cacheStringFunction(
    (str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    }
  );
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction(
    (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
  );
  const capitalize$1 = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  const toHandlerKey = cacheStringFunction(
    (str) => {
      const s = str ? `on${capitalize$1(str)}` : ``;
      return s;
    }
  );
  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  const invokeArrayFns = (fns, ...arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](...arg);
    }
  };
  const def = (obj, key2, value, writable = false) => {
    Object.defineProperty(obj, key2, {
      configurable: true,
      enumerable: false,
      writable,
      value
    });
  };
  const looseToNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  const toNumber$1 = (val) => {
    const n = isString$1(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
  };
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function normalizeStyle(value) {
    if (isArray$1(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key2 in normalized) {
            res[key2] = normalized[key2];
          }
        }
      }
      return res;
    } else if (isString$1(value) || isObject$1(value)) {
      return value;
    }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString$1(value)) {
      res = value;
    } else if (isArray$1(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject$1(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
  const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
  const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
  const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
  const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
  const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  /**
  * @vue/reactivity v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  function warn$2(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
  }
  let activeEffectScope;
  class EffectScope {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this.effects = [];
      this.cleanups = [];
      this._isPaused = false;
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
      }
    }
    get active() {
      return this._active;
    }
    pause() {
      if (this._active) {
        this._isPaused = true;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].pause();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].pause();
        }
      }
    }
    /**
     * Resumes the effect scope, including all child scopes and effects.
     */
    resume() {
      if (this._active) {
        if (this._isPaused) {
          this._isPaused = false;
          let i, l;
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].resume();
            }
          }
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].resume();
          }
        }
      }
    }
    run(fn2) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn2();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      } else {
        warn$2(`cannot run an inactive effect scope.`);
      }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
      activeEffectScope = this;
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
      activeEffectScope = this.parent;
    }
    stop(fromParent) {
      if (this._active) {
        this._active = false;
        let i, l;
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].stop();
        }
        this.effects.length = 0;
        for (i = 0, l = this.cleanups.length; i < l; i++) {
          this.cleanups[i]();
        }
        this.cleanups.length = 0;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].stop(true);
          }
          this.scopes.length = 0;
        }
        if (!this.detached && this.parent && !fromParent) {
          const last = this.parent.scopes.pop();
          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }
        this.parent = void 0;
      }
    }
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  let activeSub;
  const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
  class ReactiveEffect {
    constructor(fn2) {
      this.fn = fn2;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 1 | 4;
      this.next = void 0;
      this.cleanup = void 0;
      this.scheduler = void 0;
      if (activeEffectScope && activeEffectScope.active) {
        activeEffectScope.effects.push(this);
      }
    }
    pause() {
      this.flags |= 64;
    }
    resume() {
      if (this.flags & 64) {
        this.flags &= -65;
        if (pausedQueueEffects.has(this)) {
          pausedQueueEffects.delete(this);
          this.trigger();
        }
      }
    }
    /**
     * @internal
     */
    notify() {
      if (this.flags & 2 && !(this.flags & 32)) {
        return;
      }
      if (!(this.flags & 8)) {
        batch(this);
      }
    }
    run() {
      if (!(this.flags & 1)) {
        return this.fn();
      }
      this.flags |= 2;
      cleanupEffect(this);
      prepareDeps(this);
      const prevEffect = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = this;
      shouldTrack = true;
      try {
        return this.fn();
      } finally {
        if (activeSub !== this) {
          warn$2(
            "Active effect was not restored correctly - this is likely a Vue internal bug."
          );
        }
        cleanupDeps(this);
        activeSub = prevEffect;
        shouldTrack = prevShouldTrack;
        this.flags &= -3;
      }
    }
    stop() {
      if (this.flags & 1) {
        for (let link = this.deps; link; link = link.nextDep) {
          removeSub(link);
        }
        this.deps = this.depsTail = void 0;
        cleanupEffect(this);
        this.onStop && this.onStop();
        this.flags &= -2;
      }
    }
    trigger() {
      if (this.flags & 64) {
        pausedQueueEffects.add(this);
      } else if (this.scheduler) {
        this.scheduler();
      } else {
        this.runIfDirty();
      }
    }
    /**
     * @internal
     */
    runIfDirty() {
      if (isDirty(this)) {
        this.run();
      }
    }
    get dirty() {
      return isDirty(this);
    }
  }
  let batchDepth = 0;
  let batchedSub;
  let batchedComputed;
  function batch(sub, isComputed = false) {
    sub.flags |= 8;
    if (isComputed) {
      sub.next = batchedComputed;
      batchedComputed = sub;
      return;
    }
    sub.next = batchedSub;
    batchedSub = sub;
  }
  function startBatch() {
    batchDepth++;
  }
  function endBatch() {
    if (--batchDepth > 0) {
      return;
    }
    if (batchedComputed) {
      let e = batchedComputed;
      batchedComputed = void 0;
      while (e) {
        const next = e.next;
        e.next = void 0;
        e.flags &= -9;
        e = next;
      }
    }
    let error2;
    while (batchedSub) {
      let e = batchedSub;
      batchedSub = void 0;
      while (e) {
        const next = e.next;
        e.next = void 0;
        e.flags &= -9;
        if (e.flags & 1) {
          try {
            ;
            e.trigger();
          } catch (err) {
            if (!error2) error2 = err;
          }
        }
        e = next;
      }
    }
    if (error2) throw error2;
  }
  function prepareDeps(sub) {
    for (let link = sub.deps; link; link = link.nextDep) {
      link.version = -1;
      link.prevActiveLink = link.dep.activeLink;
      link.dep.activeLink = link;
    }
  }
  function cleanupDeps(sub) {
    let head;
    let tail = sub.depsTail;
    let link = tail;
    while (link) {
      const prev = link.prevDep;
      if (link.version === -1) {
        if (link === tail) tail = prev;
        removeSub(link);
        removeDep(link);
      } else {
        head = link;
      }
      link.dep.activeLink = link.prevActiveLink;
      link.prevActiveLink = void 0;
      link = prev;
    }
    sub.deps = head;
    sub.depsTail = tail;
  }
  function isDirty(sub) {
    for (let link = sub.deps; link; link = link.nextDep) {
      if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
        return true;
      }
    }
    if (sub._dirty) {
      return true;
    }
    return false;
  }
  function refreshComputed(computed2) {
    if (computed2.flags & 4 && !(computed2.flags & 16)) {
      return;
    }
    computed2.flags &= -17;
    if (computed2.globalVersion === globalVersion) {
      return;
    }
    computed2.globalVersion = globalVersion;
    const dep = computed2.dep;
    computed2.flags |= 2;
    if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
      computed2.flags &= -3;
      return;
    }
    const prevSub = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = computed2;
    shouldTrack = true;
    try {
      prepareDeps(computed2);
      const value = computed2.fn(computed2._value);
      if (dep.version === 0 || hasChanged(value, computed2._value)) {
        computed2._value = value;
        dep.version++;
      }
    } catch (err) {
      dep.version++;
      throw err;
    } finally {
      activeSub = prevSub;
      shouldTrack = prevShouldTrack;
      cleanupDeps(computed2);
      computed2.flags &= -3;
    }
  }
  function removeSub(link, soft = false) {
    const { dep, prevSub, nextSub } = link;
    if (prevSub) {
      prevSub.nextSub = nextSub;
      link.prevSub = void 0;
    }
    if (nextSub) {
      nextSub.prevSub = prevSub;
      link.nextSub = void 0;
    }
    if (dep.subsHead === link) {
      dep.subsHead = nextSub;
    }
    if (dep.subs === link) {
      dep.subs = prevSub;
      if (!prevSub && dep.computed) {
        dep.computed.flags &= -5;
        for (let l = dep.computed.deps; l; l = l.nextDep) {
          removeSub(l, true);
        }
      }
    }
    if (!soft && !--dep.sc && dep.map) {
      dep.map.delete(dep.key);
    }
  }
  function removeDep(link) {
    const { prevDep, nextDep } = link;
    if (prevDep) {
      prevDep.nextDep = nextDep;
      link.prevDep = void 0;
    }
    if (nextDep) {
      nextDep.prevDep = prevDep;
      link.nextDep = void 0;
    }
  }
  let shouldTrack = true;
  const trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function cleanupEffect(e) {
    const { cleanup } = e;
    e.cleanup = void 0;
    if (cleanup) {
      const prevSub = activeSub;
      activeSub = void 0;
      try {
        cleanup();
      } finally {
        activeSub = prevSub;
      }
    }
  }
  let globalVersion = 0;
  class Link {
    constructor(sub, dep) {
      this.sub = sub;
      this.dep = dep;
      this.version = dep.version;
      this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
    }
  }
  class Dep {
    constructor(computed2) {
      this.computed = computed2;
      this.version = 0;
      this.activeLink = void 0;
      this.subs = void 0;
      this.map = void 0;
      this.key = void 0;
      this.sc = 0;
      {
        this.subsHead = void 0;
      }
    }
    track(debugInfo) {
      if (!activeSub || !shouldTrack || activeSub === this.computed) {
        return;
      }
      let link = this.activeLink;
      if (link === void 0 || link.sub !== activeSub) {
        link = this.activeLink = new Link(activeSub, this);
        if (!activeSub.deps) {
          activeSub.deps = activeSub.depsTail = link;
        } else {
          link.prevDep = activeSub.depsTail;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
        }
        addSub(link);
      } else if (link.version === -1) {
        link.version = this.version;
        if (link.nextDep) {
          const next = link.nextDep;
          next.prevDep = link.prevDep;
          if (link.prevDep) {
            link.prevDep.nextDep = next;
          }
          link.prevDep = activeSub.depsTail;
          link.nextDep = void 0;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
          if (activeSub.deps === link) {
            activeSub.deps = next;
          }
        }
      }
      if (activeSub.onTrack) {
        activeSub.onTrack(
          extend(
            {
              effect: activeSub
            },
            debugInfo
          )
        );
      }
      return link;
    }
    trigger(debugInfo) {
      this.version++;
      globalVersion++;
      this.notify(debugInfo);
    }
    notify(debugInfo) {
      startBatch();
      try {
        if (true) {
          for (let head = this.subsHead; head; head = head.nextSub) {
            if (head.sub.onTrigger && !(head.sub.flags & 8)) {
              head.sub.onTrigger(
                extend(
                  {
                    effect: head.sub
                  },
                  debugInfo
                )
              );
            }
          }
        }
        for (let link = this.subs; link; link = link.prevSub) {
          if (link.sub.notify()) {
            ;
            link.sub.dep.notify();
          }
        }
      } finally {
        endBatch();
      }
    }
  }
  function addSub(link) {
    link.dep.sc++;
    if (link.sub.flags & 4) {
      const computed2 = link.dep.computed;
      if (computed2 && !link.dep.subs) {
        computed2.flags |= 4 | 16;
        for (let l = computed2.deps; l; l = l.nextDep) {
          addSub(l);
        }
      }
      const currentTail = link.dep.subs;
      if (currentTail !== link) {
        link.prevSub = currentTail;
        if (currentTail) currentTail.nextSub = link;
      }
      if (link.dep.subsHead === void 0) {
        link.dep.subsHead = link;
      }
      link.dep.subs = link;
    }
  }
  const targetMap = /* @__PURE__ */ new WeakMap();
  const ITERATE_KEY = Symbol(
    "Object iterate"
  );
  const MAP_KEY_ITERATE_KEY = Symbol(
    "Map keys iterate"
  );
  const ARRAY_ITERATE_KEY = Symbol(
    "Array iterate"
  );
  function track(target, type, key2) {
    if (shouldTrack && activeSub) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key2);
      if (!dep) {
        depsMap.set(key2, dep = new Dep());
        dep.map = depsMap;
        dep.key = key2;
      }
      {
        dep.track({
          target,
          type,
          key: key2
        });
      }
    }
  }
  function trigger(target, type, key2, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      globalVersion++;
      return;
    }
    const run = (dep) => {
      if (dep) {
        {
          dep.trigger({
            target,
            type,
            key: key2,
            newValue,
            oldValue,
            oldTarget
          });
        }
      }
    };
    startBatch();
    if (type === "clear") {
      depsMap.forEach(run);
    } else {
      const targetIsArray = isArray$1(target);
      const isArrayIndex = targetIsArray && isIntegerKey(key2);
      if (targetIsArray && key2 === "length") {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key22) => {
          if (key22 === "length" || key22 === ARRAY_ITERATE_KEY || !isSymbol$1(key22) && key22 >= newLength) {
            run(dep);
          }
        });
      } else {
        if (key2 !== void 0 || depsMap.has(void 0)) {
          run(depsMap.get(key2));
        }
        if (isArrayIndex) {
          run(depsMap.get(ARRAY_ITERATE_KEY));
        }
        switch (type) {
          case "add":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap$1(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isArrayIndex) {
              run(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap$1(target)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap$1(target)) {
              run(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
    }
    endBatch();
  }
  function getDepFromReactive(object, key2) {
    const depMap = targetMap.get(object);
    return depMap && depMap.get(key2);
  }
  function reactiveReadArray(array) {
    const raw = toRaw(array);
    if (raw === array) return raw;
    track(raw, "iterate", ARRAY_ITERATE_KEY);
    return isShallow(array) ? raw : raw.map(toReactive);
  }
  function shallowReadArray(arr) {
    track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
    return arr;
  }
  const arrayInstrumentations = {
    __proto__: null,
    [Symbol.iterator]() {
      return iterator(this, Symbol.iterator, toReactive);
    },
    concat(...args) {
      return reactiveReadArray(this).concat(
        ...args.map((x) => isArray$1(x) ? reactiveReadArray(x) : x)
      );
    },
    entries() {
      return iterator(this, "entries", (value) => {
        value[1] = toReactive(value[1]);
        return value;
      });
    },
    every(fn2, thisArg) {
      return apply$1(this, "every", fn2, thisArg, void 0, arguments);
    },
    filter(fn2, thisArg) {
      return apply$1(this, "filter", fn2, thisArg, (v) => v.map(toReactive), arguments);
    },
    find(fn2, thisArg) {
      return apply$1(this, "find", fn2, thisArg, toReactive, arguments);
    },
    findIndex(fn2, thisArg) {
      return apply$1(this, "findIndex", fn2, thisArg, void 0, arguments);
    },
    findLast(fn2, thisArg) {
      return apply$1(this, "findLast", fn2, thisArg, toReactive, arguments);
    },
    findLastIndex(fn2, thisArg) {
      return apply$1(this, "findLastIndex", fn2, thisArg, void 0, arguments);
    },
    // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
    forEach(fn2, thisArg) {
      return apply$1(this, "forEach", fn2, thisArg, void 0, arguments);
    },
    includes(...args) {
      return searchProxy(this, "includes", args);
    },
    indexOf(...args) {
      return searchProxy(this, "indexOf", args);
    },
    join(separator) {
      return reactiveReadArray(this).join(separator);
    },
    // keys() iterator only reads `length`, no optimisation required
    lastIndexOf(...args) {
      return searchProxy(this, "lastIndexOf", args);
    },
    map(fn2, thisArg) {
      return apply$1(this, "map", fn2, thisArg, void 0, arguments);
    },
    pop() {
      return noTracking(this, "pop");
    },
    push(...args) {
      return noTracking(this, "push", args);
    },
    reduce(fn2, ...args) {
      return reduce(this, "reduce", fn2, args);
    },
    reduceRight(fn2, ...args) {
      return reduce(this, "reduceRight", fn2, args);
    },
    shift() {
      return noTracking(this, "shift");
    },
    // slice could use ARRAY_ITERATE but also seems to beg for range tracking
    some(fn2, thisArg) {
      return apply$1(this, "some", fn2, thisArg, void 0, arguments);
    },
    splice(...args) {
      return noTracking(this, "splice", args);
    },
    toReversed() {
      return reactiveReadArray(this).toReversed();
    },
    toSorted(comparer) {
      return reactiveReadArray(this).toSorted(comparer);
    },
    toSpliced(...args) {
      return reactiveReadArray(this).toSpliced(...args);
    },
    unshift(...args) {
      return noTracking(this, "unshift", args);
    },
    values() {
      return iterator(this, "values", toReactive);
    }
  };
  function iterator(self2, method, wrapValue) {
    const arr = shallowReadArray(self2);
    const iter = arr[method]();
    if (arr !== self2 && !isShallow(self2)) {
      iter._next = iter.next;
      iter.next = () => {
        const result = iter._next();
        if (result.value) {
          result.value = wrapValue(result.value);
        }
        return result;
      };
    }
    return iter;
  }
  const arrayProto$1 = Array.prototype;
  function apply$1(self2, method, fn2, thisArg, wrappedRetFn, args) {
    const arr = shallowReadArray(self2);
    const needsWrap = arr !== self2 && !isShallow(self2);
    const methodFn = arr[method];
    if (methodFn !== arrayProto$1[method]) {
      const result2 = methodFn.apply(self2, args);
      return needsWrap ? toReactive(result2) : result2;
    }
    let wrappedFn = fn2;
    if (arr !== self2) {
      if (needsWrap) {
        wrappedFn = function (item, index) {
          return fn2.call(this, toReactive(item), index, self2);
        };
      } else if (fn2.length > 2) {
        wrappedFn = function (item, index) {
          return fn2.call(this, item, index, self2);
        };
      }
    }
    const result = methodFn.call(arr, wrappedFn, thisArg);
    return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
  }
  function reduce(self2, method, fn2, args) {
    const arr = shallowReadArray(self2);
    let wrappedFn = fn2;
    if (arr !== self2) {
      if (!isShallow(self2)) {
        wrappedFn = function (acc, item, index) {
          return fn2.call(this, acc, toReactive(item), index, self2);
        };
      } else if (fn2.length > 3) {
        wrappedFn = function (acc, item, index) {
          return fn2.call(this, acc, item, index, self2);
        };
      }
    }
    return arr[method](wrappedFn, ...args);
  }
  function searchProxy(self2, method, args) {
    const arr = toRaw(self2);
    track(arr, "iterate", ARRAY_ITERATE_KEY);
    const res = arr[method](...args);
    if ((res === -1 || res === false) && isProxy(args[0])) {
      args[0] = toRaw(args[0]);
      return arr[method](...args);
    }
    return res;
  }
  function noTracking(self2, method, args = []) {
    pauseTracking();
    startBatch();
    const res = toRaw(self2)[method].apply(self2, args);
    endBatch();
    resetTracking();
    return res;
  }
  const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  const builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key2) => key2 !== "arguments" && key2 !== "caller").map((key2) => Symbol[key2]).filter(isSymbol$1)
  );
  function hasOwnProperty$e(key2) {
    if (!isSymbol$1(key2)) key2 = String(key2);
    const obj = toRaw(this);
    track(obj, "has", key2);
    return obj.hasOwnProperty(key2);
  }
  class BaseReactiveHandler {
    constructor(_isReadonly = false, _isShallow = false) {
      this._isReadonly = _isReadonly;
      this._isShallow = _isShallow;
    }
    get(target, key2, receiver) {
      if (key2 === "__v_skip") return target["__v_skip"];
      const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
      if (key2 === "__v_isReactive") {
        return !isReadonly2;
      } else if (key2 === "__v_isReadonly") {
        return isReadonly2;
      } else if (key2 === "__v_isShallow") {
        return isShallow2;
      } else if (key2 === "__v_raw") {
        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
          // this means the receiver is a user proxy of the reactive proxy
          Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
          return target;
        }
        return;
      }
      const targetIsArray = isArray$1(target);
      if (!isReadonly2) {
        let fn2;
        if (targetIsArray && (fn2 = arrayInstrumentations[key2])) {
          return fn2;
        }
        if (key2 === "hasOwnProperty") {
          return hasOwnProperty$e;
        }
      }
      const res = Reflect.get(
        target,
        key2,
        // if this is a proxy wrapping a ref, return methods using the raw ref
        // as receiver so that we don't have to call `toRaw` on the ref in all
        // its class methods
        isRef(target) ? target : receiver
      );
      if (isSymbol$1(key2) ? builtInSymbols.has(key2) : isNonTrackableKeys(key2)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key2);
      }
      if (isShallow2) {
        return res;
      }
      if (isRef(res)) {
        return targetIsArray && isIntegerKey(key2) ? res : res.value;
      }
      if (isObject$1(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    }
  }
  class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(false, isShallow2);
    }
    set(target, key2, value, receiver) {
      let oldValue = target[key2];
      if (!this._isShallow) {
        const isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
          if (isOldValueReadonly) {
            return false;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      const hadKey = isArray$1(target) && isIntegerKey(key2) ? Number(key2) < target.length : hasOwn$1(target, key2);
      const result = Reflect.set(
        target,
        key2,
        value,
        isRef(target) ? target : receiver
      );
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key2, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key2, value, oldValue);
        }
      }
      return result;
    }
    deleteProperty(target, key2) {
      const hadKey = hasOwn$1(target, key2);
      const oldValue = target[key2];
      const result = Reflect.deleteProperty(target, key2);
      if (result && hadKey) {
        trigger(target, "delete", key2, void 0, oldValue);
      }
      return result;
    }
    has(target, key2) {
      const result = Reflect.has(target, key2);
      if (!isSymbol$1(key2) || !builtInSymbols.has(key2)) {
        track(target, "has", key2);
      }
      return result;
    }
    ownKeys(target) {
      track(
        target,
        "iterate",
        isArray$1(target) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target);
    }
  }
  class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(true, isShallow2);
    }
    set(target, key2) {
      {
        warn$2(
          `Set operation on key "${String(key2)}" failed: target is readonly.`,
          target
        );
      }
      return true;
    }
    deleteProperty(target, key2) {
      {
        warn$2(
          `Delete operation on key "${String(key2)}" failed: target is readonly.`,
          target
        );
      }
      return true;
    }
  }
  const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
  const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
  const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
  const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
  const toShallow = (value) => value;
  const getProto = (v) => Reflect.getPrototypeOf(v);
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function (...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap$1(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function (...args) {
      {
        const key2 = args[0] ? `on key "${args[0]}" ` : ``;
        warn$2(
          `${capitalize$1(type)} operation ${key2}failed: target is readonly.`,
          toRaw(this)
        );
      }
      return type === "delete" ? false : type === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations(readonly2, shallow) {
    const instrumentations = {
      get(key2) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key2);
        if (!readonly2) {
          if (hasChanged(key2, rawKey)) {
            track(rawTarget, "get", key2);
          }
          track(rawTarget, "get", rawKey);
        }
        const { has } = getProto(rawTarget);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        if (has.call(rawTarget, key2)) {
          return wrap(target.get(key2));
        } else if (has.call(rawTarget, rawKey)) {
          return wrap(target.get(rawKey));
        } else if (target !== rawTarget) {
          target.get(key2);
        }
      },
      get size() {
        const target = this["__v_raw"];
        !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
        return Reflect.get(target, "size", target);
      },
      has(key2) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key2);
        if (!readonly2) {
          if (hasChanged(key2, rawKey)) {
            track(rawTarget, "has", key2);
          }
          track(rawTarget, "has", rawKey);
        }
        return key2 === rawKey ? target.has(key2) : target.has(key2) || target.has(rawKey);
      },
      forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key2) => {
          return callback.call(thisArg, wrap(value), wrap(key2), observed);
        });
      }
    };
    extend(
      instrumentations,
      readonly2 ? {
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear")
      } : {
        add(value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const proto = getProto(target);
          const hadKey = proto.has.call(target, value);
          if (!hadKey) {
            target.add(value);
            trigger(target, "add", value, value);
          }
          return this;
        },
        set(key2, value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target = toRaw(this);
          const { has, get: get2 } = getProto(target);
          let hadKey = has.call(target, key2);
          if (!hadKey) {
            key2 = toRaw(key2);
            hadKey = has.call(target, key2);
          } else {
            checkIdentityKeys(target, has, key2);
          }
          const oldValue = get2.call(target, key2);
          target.set(key2, value);
          if (!hadKey) {
            trigger(target, "add", key2, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key2, value, oldValue);
          }
          return this;
        },
        delete(key2) {
          const target = toRaw(this);
          const { has, get: get2 } = getProto(target);
          let hadKey = has.call(target, key2);
          if (!hadKey) {
            key2 = toRaw(key2);
            hadKey = has.call(target, key2);
          } else {
            checkIdentityKeys(target, has, key2);
          }
          const oldValue = get2 ? get2.call(target, key2) : void 0;
          const result = target.delete(key2);
          if (hadKey) {
            trigger(target, "delete", key2, void 0, oldValue);
          }
          return result;
        },
        clear() {
          const target = toRaw(this);
          const hadItems = target.size !== 0;
          const oldTarget = isMap$1(target) ? new Map(target) : new Set(target);
          const result = target.clear();
          if (hadItems) {
            trigger(
              target,
              "clear",
              void 0,
              void 0,
              oldTarget
            );
          }
          return result;
        }
      }
    );
    const iteratorMethods = [
      "keys",
      "values",
      "entries",
      Symbol.iterator
    ];
    iteratorMethods.forEach((method) => {
      instrumentations[method] = createIterableMethod(method, readonly2, shallow);
    });
    return instrumentations;
  }
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = createInstrumentations(isReadonly2, shallow);
    return (target, key2, receiver) => {
      if (key2 === "__v_isReactive") {
        return !isReadonly2;
      } else if (key2 === "__v_isReadonly") {
        return isReadonly2;
      } else if (key2 === "__v_raw") {
        return target;
      }
      return Reflect.get(
        hasOwn$1(instrumentations, key2) && key2 in target ? instrumentations : target,
        key2,
        receiver
      );
    };
  }
  const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  function checkIdentityKeys(target, has, key2) {
    const rawKey = toRaw(key2);
    if (rawKey !== key2 && has.call(target, rawKey)) {
      const type = toRawType(target);
      warn$2(
        `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
      );
    }
  }
  const reactiveMap = /* @__PURE__ */ new WeakMap();
  const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  const readonlyMap = /* @__PURE__ */ new WeakMap();
  const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function shallowReactive(target) {
    return createReactiveObject(
      target,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
    );
  }
  function readonly(target) {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function shallowReadonly(target) {
    return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    );
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject$1(target)) {
      {
        warn$2(
          `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
            target
          )}`
        );
      }
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(
      target,
      targetType === 2 ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    if (!hasOwn$1(value, "__v_skip") && Object.isExtensible(value)) {
      def(value, "__v_skip", true);
    }
    return value;
  }
  const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
  function isRef(r) {
    return r ? r["__v_isRef"] === true : false;
  }
  function ref(value) {
    return createRef(value, false);
  }
  function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  class RefImpl {
    constructor(value, isShallow2) {
      this.dep = new Dep();
      this["__v_isRef"] = true;
      this["__v_isShallow"] = false;
      this._rawValue = isShallow2 ? value : toRaw(value);
      this._value = isShallow2 ? value : toReactive(value);
      this["__v_isShallow"] = isShallow2;
    }
    get value() {
      {
        this.dep.track({
          target: this,
          type: "get",
          key: "value"
        });
      }
      return this._value;
    }
    set value(newValue) {
      const oldValue = this._rawValue;
      const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
      newValue = useDirectValue ? newValue : toRaw(newValue);
      if (hasChanged(newValue, oldValue)) {
        this._rawValue = newValue;
        this._value = useDirectValue ? newValue : toReactive(newValue);
        {
          this.dep.trigger({
            target: this,
            type: "set",
            key: "value",
            newValue,
            oldValue
          });
        }
      }
    }
  }
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  function toValue(source) {
    return isFunction$1(source) ? source() : unref(source);
  }
  const shallowUnwrapHandlers = {
    get: (target, key2, receiver) => key2 === "__v_raw" ? target : unref(Reflect.get(target, key2, receiver)),
    set: (target, key2, value, receiver) => {
      const oldValue = target[key2];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key2, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  function toRefs(object) {
    if (!isProxy(object)) {
      warn$2(`toRefs() expects a reactive object but received a plain one.`);
    }
    const ret = isArray$1(object) ? new Array(object.length) : {};
    for (const key2 in object) {
      ret[key2] = propertyToRef(object, key2);
    }
    return ret;
  }
  class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
      this._object = _object;
      this._key = _key;
      this._defaultValue = _defaultValue;
      this["__v_isRef"] = true;
      this._value = void 0;
    }
    get value() {
      const val = this._object[this._key];
      return this._value = val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
      this._object[this._key] = newVal;
    }
    get dep() {
      return getDepFromReactive(toRaw(this._object), this._key);
    }
  }
  function propertyToRef(source, key2, defaultValue) {
    const val = source[key2];
    return isRef(val) ? val : new ObjectRefImpl(source, key2, defaultValue);
  }
  class ComputedRefImpl {
    constructor(fn2, setter, isSSR) {
      this.fn = fn2;
      this.setter = setter;
      this._value = void 0;
      this.dep = new Dep(this);
      this.__v_isRef = true;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 16;
      this.globalVersion = globalVersion - 1;
      this.next = void 0;
      this.effect = this;
      this["__v_isReadonly"] = !setter;
      this.isSSR = isSSR;
    }
    /**
     * @internal
     */
    notify() {
      this.flags |= 16;
      if (!(this.flags & 8) && // avoid infinite self recursion
        activeSub !== this) {
        batch(this, true);
        return true;
      }
    }
    get value() {
      const link = this.dep.track({
        target: this,
        type: "get",
        key: "value"
      });
      refreshComputed(this);
      if (link) {
        link.version = this.dep.version;
      }
      return this._value;
    }
    set value(newValue) {
      if (this.setter) {
        this.setter(newValue);
      } else {
        warn$2("Write operation failed: computed value is readonly");
      }
    }
  }
  function computed$1(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    if (isFunction$1(getterOrOptions)) {
      getter = getterOrOptions;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, isSSR);
    return cRef;
  }
  const INITIAL_WATCHER_VALUE = {};
  const cleanupMap = /* @__PURE__ */ new WeakMap();
  let activeWatcher = void 0;
  function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
    if (owner) {
      let cleanups = cleanupMap.get(owner);
      if (!cleanups) cleanupMap.set(owner, cleanups = []);
      cleanups.push(cleanupFn);
    } else if (!failSilently) {
      warn$2(
        `onWatcherCleanup() was called when there was no active watcher to associate with.`
      );
    }
  }
  function watch$1(source, cb, options = EMPTY_OBJ) {
    const { immediate, deep, once: once2, scheduler, augmentJob, call } = options;
    const warnInvalidSource = (s) => {
      (options.onWarn || warn$2)(
        `Invalid watch source: `,
        s,
        `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
      );
    };
    const reactiveGetter = (source2) => {
      if (deep) return source2;
      if (isShallow(source2) || deep === false || deep === 0)
        return traverse(source2, 1);
      return traverse(source2);
    };
    let effect2;
    let getter;
    let cleanup;
    let boundCleanup;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => reactiveGetter(source);
      forceTrigger = true;
    } else if (isArray$1(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
      getter = () => source.map((s) => {
        if (isRef(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return reactiveGetter(s);
        } else if (isFunction$1(s)) {
          return call ? call(s, 2) : s();
        } else {
          warnInvalidSource(s);
        }
      });
    } else if (isFunction$1(source)) {
      if (cb) {
        getter = call ? () => call(source, 2) : source;
      } else {
        getter = () => {
          if (cleanup) {
            pauseTracking();
            try {
              cleanup();
            } finally {
              resetTracking();
            }
          }
          const currentEffect = activeWatcher;
          activeWatcher = effect2;
          try {
            return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
          } finally {
            activeWatcher = currentEffect;
          }
        };
      }
    } else {
      getter = NOOP;
      warnInvalidSource(source);
    }
    if (cb && deep) {
      const baseGetter = getter;
      const depth = deep === true ? Infinity : deep;
      getter = () => traverse(baseGetter(), depth);
    }
    const scope = getCurrentScope();
    const watchHandle = () => {
      effect2.stop();
      if (scope && scope.active) {
        remove(scope.effects, effect2);
      }
    };
    if (once2 && cb) {
      const _cb = cb;
      cb = (...args) => {
        _cb(...args);
        watchHandle();
      };
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = (immediateFirstRun) => {
      if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
          if (cleanup) {
            cleanup();
          }
          const currentWatcher = activeWatcher;
          activeWatcher = effect2;
          try {
            const args = [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              boundCleanup
            ];
            call ? call(cb, 3, args) : (
              // @ts-expect-error
              cb(...args)
            );
            oldValue = newValue;
          } finally {
            activeWatcher = currentWatcher;
          }
        }
      } else {
        effect2.run();
      }
    };
    if (augmentJob) {
      augmentJob(job);
    }
    effect2 = new ReactiveEffect(getter);
    effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
    boundCleanup = (fn2) => onWatcherCleanup(fn2, false, effect2);
    cleanup = effect2.onStop = () => {
      const cleanups = cleanupMap.get(effect2);
      if (cleanups) {
        if (call) {
          call(cleanups, 4);
        } else {
          for (const cleanup2 of cleanups) cleanup2();
        }
        cleanupMap.delete(effect2);
      }
    };
    {
      effect2.onTrack = options.onTrack;
      effect2.onTrigger = options.onTrigger;
    }
    if (cb) {
      if (immediate) {
        job(true);
      } else {
        oldValue = effect2.run();
      }
    } else if (scheduler) {
      scheduler(job.bind(null, true), true);
    } else {
      effect2.run();
    }
    watchHandle.pause = effect2.pause.bind(effect2);
    watchHandle.resume = effect2.resume.bind(effect2);
    watchHandle.stop = watchHandle;
    return watchHandle;
  }
  function traverse(value, depth = Infinity, seen) {
    if (depth <= 0 || !isObject$1(value) || value["__v_skip"]) {
      return value;
    }
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    depth--;
    if (isRef(value)) {
      traverse(value.value, depth, seen);
    } else if (isArray$1(value)) {
      for (let i = 0; i < value.length; i++) {
        traverse(value[i], depth, seen);
      }
    } else if (isSet$1(value) || isMap$1(value)) {
      value.forEach((v) => {
        traverse(v, depth, seen);
      });
    } else if (isPlainObject$1(value)) {
      for (const key2 in value) {
        traverse(value[key2], depth, seen);
      }
      for (const key2 of Object.getOwnPropertySymbols(value)) {
        if (Object.prototype.propertyIsEnumerable.call(value, key2)) {
          traverse(value[key2], depth, seen);
        }
      }
    }
    return value;
  }
  /**
  * @vue/runtime-core v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const stack = [];
  function pushWarningContext(vnode) {
    stack.push(vnode);
  }
  function popWarningContext() {
    stack.pop();
  }
  let isWarning = false;
  function warn$1(msg, ...args) {
    if (isWarning) return;
    isWarning = true;
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
          // eslint-disable-next-line no-restricted-syntax
          msg + args.map((a) => {
            var _a, _b;
            return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
          }).join(""),
          instance && instance.proxy,
          trace.map(
            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
          ).join("\n"),
          trace
        ]
      );
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && // avoid spamming console during tests
        true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
    isWarning = false;
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last = normalizedStack[0];
      if (last && last.vnode === currentVNode) {
        last.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
      logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(
      vnode.component,
      vnode.type,
      isRoot
    )}`;
    const close2 = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close2] : [open + close2];
  }
  function formatProps(props2) {
    const res = [];
    const keys2 = Object.keys(props2);
    keys2.slice(0, 3).forEach((key2) => {
      res.push(...formatProp(key2, props2[key2]));
    });
    if (keys2.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key2, value, raw) {
    if (isString$1(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key2}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key2}=${value}`];
    } else if (isRef(value)) {
      value = formatProp(key2, toRaw(value.value), true);
      return raw ? value : [`${key2}=Ref<`, value, `>`];
    } else if (isFunction$1(value)) {
      return [`${key2}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key2}=`, value];
    }
  }
  function assertNumber(val, type) {
    if (val === void 0) {
      return;
    } else if (typeof val !== "number") {
      warn$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
    } else if (isNaN(val)) {
      warn$1(`${type} is NaN - the duration expression might be incorrect.`);
    }
  }
  const ErrorTypeStrings$1 = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush",
    [15]: "component update",
    [16]: "app unmount cleanup function"
  };
  function callWithErrorHandling(fn2, instance, type, args) {
    try {
      return args ? fn2(...args) : fn2();
    } catch (err) {
      handleError(err, instance, type);
    }
  }
  function callWithAsyncErrorHandling(fn2, instance, type, args) {
    if (isFunction$1(fn2)) {
      const res = callWithErrorHandling(fn2, instance, type, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type);
        });
      }
      return res;
    }
    if (isArray$1(fn2)) {
      const values = [];
      for (let i = 0; i < fn2.length; i++) {
        values.push(callWithAsyncErrorHandling(fn2[i], instance, type, args));
      }
      return values;
    } else {
      warn$1(
        `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn2}`
      );
    }
  }
  function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = ErrorTypeStrings$1[type];
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i = 0; i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      if (errorHandler) {
        pauseTracking();
        callWithErrorHandling(errorHandler, null, 10, [
          err,
          exposedInstance,
          errorInfo
        ]);
        resetTracking();
        return;
      }
    }
    logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
  }
  function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
    {
      const info2 = ErrorTypeStrings$1[type];
      if (contextVNode) {
        pushWarningContext(contextVNode);
      }
      warn$1(`Unhandled error${info2 ? ` during execution of ${info2}` : ``}`);
      if (contextVNode) {
        popWarningContext();
      }
      if (throwInDev) {
        throw err;
      } else {
        console.error(err);
      }
    }
  }
  const queue$1 = [];
  let flushIndex = -1;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = /* @__PURE__ */ Promise.resolve();
  let currentFlushPromise = null;
  const RECURSION_LIMIT = 100;
  function nextTick(fn2) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
  }
  function findInsertionIndex(id) {
    let start2 = flushIndex + 1;
    let end2 = queue$1.length;
    while (start2 < end2) {
      const middle = start2 + end2 >>> 1;
      const middleJob = queue$1[middle];
      const middleJobId = getId(middleJob);
      if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
        start2 = middle + 1;
      } else {
        end2 = middle;
      }
    }
    return start2;
  }
  function queueJob(job) {
    if (!(job.flags & 1)) {
      const jobId = getId(job);
      const lastJob = queue$1[queue$1.length - 1];
      if (!lastJob || // fast path when the job id is larger than the tail
        !(job.flags & 2) && jobId >= getId(lastJob)) {
        queue$1.push(job);
      } else {
        queue$1.splice(findInsertionIndex(jobId), 0, job);
      }
      job.flags |= 1;
      queueFlush();
    }
  }
  function queueFlush() {
    if (!currentFlushPromise) {
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray$1(cb)) {
      if (activePostFlushCbs && cb.id === -1) {
        activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
      } else if (!(cb.flags & 1)) {
        pendingPostFlushCbs.push(cb);
        cb.flags |= 1;
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    for (; i < queue$1.length; i++) {
      const cb = queue$1[i];
      if (cb && cb.flags & 2) {
        if (instance && cb.id !== instance.uid) {
          continue;
        }
        if (checkRecursiveUpdates(seen, cb)) {
          continue;
        }
        queue$1.splice(i, 1);
        i--;
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        cb();
        if (!(cb.flags & 4)) {
          cb.flags &= -2;
        }
      }
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)].sort(
        (a, b) => getId(a) - getId(b)
      );
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      {
        seen = seen || /* @__PURE__ */ new Map();
      }
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        const cb = activePostFlushCbs[postFlushIndex];
        if (checkRecursiveUpdates(seen, cb)) {
          continue;
        }
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        if (!(cb.flags & 8)) cb();
        cb.flags &= -2;
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
  function flushJobs(seen) {
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    const check = (job) => checkRecursiveUpdates(seen, job);
    try {
      for (flushIndex = 0; flushIndex < queue$1.length; flushIndex++) {
        const job = queue$1[flushIndex];
        if (job && !(job.flags & 8)) {
          if (check(job)) {
            continue;
          }
          if (job.flags & 4) {
            job.flags &= ~1;
          }
          callWithErrorHandling(
            job,
            job.i,
            job.i ? 15 : 14
          );
          if (!(job.flags & 4)) {
            job.flags &= ~1;
          }
        }
      }
    } finally {
      for (; flushIndex < queue$1.length; flushIndex++) {
        const job = queue$1[flushIndex];
        if (job) {
          job.flags &= -2;
        }
      }
      flushIndex = -1;
      queue$1.length = 0;
      flushPostFlushCbs(seen);
      currentFlushPromise = null;
      if (queue$1.length || pendingPostFlushCbs.length) {
        flushJobs(seen);
      }
    }
  }
  function checkRecursiveUpdates(seen, fn2) {
    const count = seen.get(fn2) || 0;
    if (count > RECURSION_LIMIT) {
      const instance = fn2.i;
      const componentName = instance && getComponentName(instance.type);
      handleError(
        `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
        null,
        10
      );
      return true;
    }
    seen.set(fn2, count + 1);
    return false;
  }
  let isHmrUpdating = false;
  const hmrDirtyComponents = /* @__PURE__ */ new Map();
  {
    getGlobalThis().__VUE_HMR_RUNTIME__ = {
      createRecord: tryWrap(createRecord),
      rerender: tryWrap(rerender),
      reload: tryWrap(reload)
    };
  }
  const map = /* @__PURE__ */ new Map();
  function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
      createRecord(id, instance.type);
      record = map.get(id);
    }
    record.instances.add(instance);
  }
  function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
  }
  function createRecord(id, initialDef) {
    if (map.has(id)) {
      return false;
    }
    map.set(id, {
      initialDef: normalizeClassComponent(initialDef),
      instances: /* @__PURE__ */ new Set()
    });
    return true;
  }
  function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
  }
  function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) {
      return;
    }
    record.initialDef.render = newRender;
    [...record.instances].forEach((instance) => {
      if (newRender) {
        instance.render = newRender;
        normalizeClassComponent(instance.type).render = newRender;
      }
      instance.renderCache = [];
      isHmrUpdating = true;
      instance.update();
      isHmrUpdating = false;
    });
  }
  function reload(id, newComp) {
    const record = map.get(id);
    if (!record) return;
    newComp = normalizeClassComponent(newComp);
    updateComponentDef(record.initialDef, newComp);
    const instances = [...record.instances];
    for (let i = 0; i < instances.length; i++) {
      const instance = instances[i];
      const oldComp = normalizeClassComponent(instance.type);
      let dirtyInstances = hmrDirtyComponents.get(oldComp);
      if (!dirtyInstances) {
        if (oldComp !== record.initialDef) {
          updateComponentDef(oldComp, newComp);
        }
        hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());
      }
      dirtyInstances.add(instance);
      instance.appContext.propsCache.delete(instance.type);
      instance.appContext.emitsCache.delete(instance.type);
      instance.appContext.optionsCache.delete(instance.type);
      if (instance.ceReload) {
        dirtyInstances.add(instance);
        instance.ceReload(newComp.styles);
        dirtyInstances.delete(instance);
      } else if (instance.parent) {
        queueJob(() => {
          isHmrUpdating = true;
          instance.parent.update();
          isHmrUpdating = false;
          dirtyInstances.delete(instance);
        });
      } else if (instance.appContext.reload) {
        instance.appContext.reload();
      } else if (typeof window !== "undefined") {
        window.location.reload();
      } else {
        console.warn(
          "[HMR] Root or manually mounted instance modified. Full reload required."
        );
      }
      if (instance.root.ce && instance !== instance.root) {
        instance.root.ce._removeChildStyle(oldComp);
      }
    }
    queuePostFlushCb(() => {
      hmrDirtyComponents.clear();
    });
  }
  function updateComponentDef(oldComp, newComp) {
    extend(oldComp, newComp);
    for (const key2 in oldComp) {
      if (key2 !== "__file" && !(key2 in newComp)) {
        delete oldComp[key2];
      }
    }
  }
  function tryWrap(fn2) {
    return (id, arg) => {
      try {
        return fn2(id, arg);
      } catch (e) {
        console.error(e);
        console.warn(
          `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
        );
      }
    };
  }
  let devtools$1;
  let buffer = [];
  let devtoolsNotInstalled = false;
  function emit$1(event, ...args) {
    if (devtools$1) {
      devtools$1.emit(event, ...args);
    } else if (!devtoolsNotInstalled) {
      buffer.push({ event, args });
    }
  }
  function setDevtoolsHook$1(hook, target) {
    var _a, _b;
    devtools$1 = hook;
    if (devtools$1) {
      devtools$1.enabled = true;
      buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
      buffer = [];
    } else if (
      // handle late devtools injection - only do this if we are in an actual
      // browser environment to avoid the timer handle stalling test runner exit
      // (#4815)
      typeof window !== "undefined" && // some envs mock window but not fully
      window.HTMLElement && // also exclude jsdom
      // eslint-disable-next-line no-restricted-syntax
      !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
    ) {
      const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
      replay.push((newHook) => {
        setDevtoolsHook$1(newHook, target);
      });
      setTimeout(() => {
        if (!devtools$1) {
          target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
          devtoolsNotInstalled = true;
          buffer = [];
        }
      }, 3e3);
    } else {
      devtoolsNotInstalled = true;
      buffer = [];
    }
  }
  function devtoolsInitApp(app, version2) {
    emit$1("app:init", app, version2, {
      Fragment,
      Text,
      Comment,
      Static
    });
  }
  function devtoolsUnmountApp(app) {
    emit$1("app:unmount", app);
  }
  const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:added"
    /* COMPONENT_ADDED */
  );
  const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:updated"
    /* COMPONENT_UPDATED */
  );
  const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:removed"
    /* COMPONENT_REMOVED */
  );
  const devtoolsComponentRemoved = (component) => {
    if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
      !devtools$1.cleanupBuffer(component)) {
      _devtoolsComponentRemoved(component);
    }
  };
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function createDevtoolsComponentHook(hook) {
    return (component) => {
      emit$1(
        hook,
        component.appContext.app,
        component.uid,
        component.parent ? component.parent.uid : void 0,
        component
      );
    };
  }
  const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
    "perf:start"
    /* PERFORMANCE_START */
  );
  const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
    "perf:end"
    /* PERFORMANCE_END */
  );
  function createDevtoolsPerformanceHook(hook) {
    return (component, type, time) => {
      emit$1(hook, component.appContext.app, component.uid, component, type, time);
    };
  }
  function devtoolsComponentEmit(component, event, params) {
    emit$1(
      "component:emit",
      component.appContext.app,
      component,
      event,
      params
    );
  }
  let currentRenderingInstance = null;
  let currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn2;
    if (fn2._n) {
      return fn2;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn2(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      {
        devtoolsComponentUpdated(ctx);
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function validateDirectiveName(name) {
    if (isBuiltInDirective(name)) {
      warn$1("Do not use built-in directive ids as custom directive id: " + name);
    }
  }
  function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
      warn$1(`withDirectives can only be used inside render functions.`);
      return vnode;
    }
    const instance = getComponentPublicInstance(currentRenderingInstance);
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
      if (dir) {
        if (isFunction$1(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
      const binding = bindings[i];
      if (oldBindings) {
        binding.oldValue = oldBindings[i].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  const TeleportEndKey = Symbol("_vte");
  const isTeleport = (type) => type.__isTeleport;
  const isTeleportDisabled = (props2) => props2 && (props2.disabled || props2.disabled === "");
  const isTeleportDeferred = (props2) => props2 && (props2.defer || props2.defer === "");
  const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
  const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
  const resolveTarget = (props2, select) => {
    const targetSelector = props2 && props2.to;
    if (isString$1(targetSelector)) {
      if (!select) {
        warn$1(
          `Current renderer does not support string target for Teleports. (missing querySelector renderer option)`
        );
        return null;
      } else {
        const target = select(targetSelector);
        if (!target && !isTeleportDisabled(props2)) {
          warn$1(
            `Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
          );
        }
        return target;
      }
    } else {
      if (!targetSelector && !isTeleportDisabled(props2)) {
        warn$1(`Invalid Teleport target: ${targetSelector}`);
      }
      return targetSelector;
    }
  };
  const TeleportImpl = {
    name: "Teleport",
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
      const {
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        o: { insert, querySelector, createText, createComment }
      } = internals;
      const disabled = isTeleportDisabled(n2.props);
      let { shapeFlag, children, dynamicChildren } = n2;
      if (isHmrUpdating) {
        optimized = false;
        dynamicChildren = null;
      }
      if (n1 == null) {
        const placeholder = n2.el = createComment("teleport start");
        const mainAnchor = n2.anchor = createComment("teleport end");
        insert(placeholder, container, anchor);
        insert(mainAnchor, container, anchor);
        const mount = (container2, anchor2) => {
          if (shapeFlag & 16) {
            if (parentComponent && parentComponent.isCE) {
              parentComponent.ce._teleportTarget = container2;
            }
            mountChildren(
              children,
              container2,
              anchor2,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        };
        const mountToTarget = () => {
          const target = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = prepareAnchor(target, n2, createText, insert);
          if (target) {
            if (namespace !== "svg" && isTargetSVG(target)) {
              namespace = "svg";
            } else if (namespace !== "mathml" && isTargetMathML(target)) {
              namespace = "mathml";
            }
            if (!disabled) {
              mount(target, targetAnchor);
              updateCssVars(n2, false);
            }
          } else if (!disabled) {
            warn$1(
              "Invalid Teleport target on mount:",
              target,
              `(${typeof target})`
            );
          }
        };
        if (disabled) {
          mount(container, mainAnchor);
          updateCssVars(n2, true);
        }
        if (isTeleportDeferred(n2.props)) {
          queuePostRenderEffect(() => {
            mountToTarget();
            n2.el.__isMounted = true;
          }, parentSuspense);
        } else {
          mountToTarget();
        }
      } else {
        if (isTeleportDeferred(n2.props) && !n1.el.__isMounted) {
          queuePostRenderEffect(() => {
            TeleportImpl.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
            delete n1.el.__isMounted;
          }, parentSuspense);
          return;
        }
        n2.el = n1.el;
        n2.targetStart = n1.targetStart;
        const mainAnchor = n2.anchor = n1.anchor;
        const target = n2.target = n1.target;
        const targetAnchor = n2.targetAnchor = n1.targetAnchor;
        const wasDisabled = isTeleportDisabled(n1.props);
        const currentContainer = wasDisabled ? container : target;
        const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
        if (namespace === "svg" || isTargetSVG(target)) {
          namespace = "svg";
        } else if (namespace === "mathml" || isTargetMathML(target)) {
          namespace = "mathml";
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            currentContainer,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          traverseStaticChildren(n1, n2, true);
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            currentContainer,
            currentAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            false
          );
        }
        if (disabled) {
          if (!wasDisabled) {
            moveTeleport(
              n2,
              container,
              mainAnchor,
              internals,
              1
            );
          } else {
            if (n2.props && n1.props && n2.props.to !== n1.props.to) {
              n2.props.to = n1.props.to;
            }
          }
        } else {
          if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
            const nextTarget = n2.target = resolveTarget(
              n2.props,
              querySelector
            );
            if (nextTarget) {
              moveTeleport(
                n2,
                nextTarget,
                null,
                internals,
                0
              );
            } else {
              warn$1(
                "Invalid Teleport target on update:",
                target,
                `(${typeof target})`
              );
            }
          } else if (wasDisabled) {
            moveTeleport(
              n2,
              target,
              targetAnchor,
              internals,
              1
            );
          }
        }
        updateCssVars(n2, disabled);
      }
    },
    remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
      const {
        shapeFlag,
        children,
        anchor,
        targetStart,
        targetAnchor,
        target,
        props: props2
      } = vnode;
      if (target) {
        hostRemove(targetStart);
        hostRemove(targetAnchor);
      }
      doRemove && hostRemove(anchor);
      if (shapeFlag & 16) {
        const shouldRemove = doRemove || !isTeleportDisabled(props2);
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          unmount(
            child,
            parentComponent,
            parentSuspense,
            shouldRemove,
            !!child.dynamicChildren
          );
        }
      }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
  };
  function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
    if (moveType === 0) {
      insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props: props2 } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) {
      insert(el, container, parentAnchor);
    }
    if (!isReorder || isTeleportDisabled(props2)) {
      if (shapeFlag & 16) {
        for (let i = 0; i < children.length; i++) {
          move(
            children[i],
            container,
            parentAnchor,
            2
          );
        }
      }
    }
    if (isReorder) {
      insert(anchor, container, parentAnchor);
    }
  }
  function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
    o: { nextSibling, parentNode, querySelector, insert, createText }
  }, hydrateChildren) {
    const target = vnode.target = resolveTarget(
      vnode.props,
      querySelector
    );
    if (target) {
      const disabled = isTeleportDisabled(vnode.props);
      const targetNode = target._lpa || target.firstChild;
      if (vnode.shapeFlag & 16) {
        if (disabled) {
          vnode.anchor = hydrateChildren(
            nextSibling(node),
            vnode,
            parentNode(node),
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
          vnode.targetStart = targetNode;
          vnode.targetAnchor = targetNode && nextSibling(targetNode);
        } else {
          vnode.anchor = nextSibling(node);
          let targetAnchor = targetNode;
          while (targetAnchor) {
            if (targetAnchor && targetAnchor.nodeType === 8) {
              if (targetAnchor.data === "teleport start anchor") {
                vnode.targetStart = targetAnchor;
              } else if (targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            targetAnchor = nextSibling(targetAnchor);
          }
          if (!vnode.targetAnchor) {
            prepareAnchor(target, vnode, createText, insert);
          }
          hydrateChildren(
            targetNode && nextSibling(targetNode),
            vnode,
            target,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
      }
      updateCssVars(vnode, disabled);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
  }
  const Teleport = TeleportImpl;
  function updateCssVars(vnode, isDisabled) {
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
      let node, anchor;
      if (isDisabled) {
        node = vnode.el;
        anchor = vnode.anchor;
      } else {
        node = vnode.targetStart;
        anchor = vnode.targetAnchor;
      }
      while (node && node !== anchor) {
        if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
        node = node.nextSibling;
      }
      ctx.ut();
    }
  }
  function prepareAnchor(target, vnode, createText, insert) {
    const targetStart = vnode.targetStart = createText("");
    const targetAnchor = vnode.targetAnchor = createText("");
    targetStart[TeleportEndKey] = targetAnchor;
    if (target) {
      insert(targetStart, target);
      insert(targetAnchor, target);
    }
    return targetAnchor;
  }
  const leaveCbKey = Symbol("_leaveCb");
  const enterCbKey = Symbol("_enterCb");
  function useTransitionState() {
    const state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(() => {
      state.isMounted = true;
    });
    onBeforeUnmount(() => {
      state.isUnmounting = true;
    });
    return state;
  }
  const TransitionHookValidator = [Function, Array];
  const BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  };
  const recursiveGetSubtree = (instance) => {
    const subTree = instance.subTree;
    return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
  };
  const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup(props2, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      return () => {
        const children = slots.default && getTransitionRawChildren(slots.default(), true);
        if (!children || !children.length) {
          return;
        }
        const child = findNonCommentChild(children);
        const rawProps = toRaw(props2);
        const { mode } = rawProps;
        if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
          warn$1(`invalid <transition> mode: ${mode}`);
        }
        if (state.isLeaving) {
          return emptyPlaceholder(child);
        }
        const innerChild = getInnerChild$1(child);
        if (!innerChild) {
          return emptyPlaceholder(child);
        }
        let enterHooks = resolveTransitionHooks(
          innerChild,
          rawProps,
          state,
          instance,
          // #11061, ensure enterHooks is fresh after clone
          (hooks) => enterHooks = hooks
        );
        if (innerChild.type !== Comment) {
          setTransitionHooks(innerChild, enterHooks);
        }
        let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
        if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
          let leavingHooks = resolveTransitionHooks(
            oldInnerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(oldInnerChild, leavingHooks);
          if (mode === "out-in" && innerChild.type !== Comment) {
            state.isLeaving = true;
            leavingHooks.afterLeave = () => {
              state.isLeaving = false;
              if (!(instance.job.flags & 8)) {
                instance.update();
              }
              delete leavingHooks.afterLeave;
              oldInnerChild = void 0;
            };
            return emptyPlaceholder(child);
          } else if (mode === "in-out" && innerChild.type !== Comment) {
            leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
              const leavingVNodesCache = getLeavingNodesForType(
                state,
                oldInnerChild
              );
              leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
              el[leaveCbKey] = () => {
                earlyRemove();
                el[leaveCbKey] = void 0;
                delete enterHooks.delayedLeave;
                oldInnerChild = void 0;
              };
              enterHooks.delayedLeave = () => {
                delayedLeave();
                delete enterHooks.delayedLeave;
                oldInnerChild = void 0;
              };
            };
          } else {
            oldInnerChild = void 0;
          }
        } else if (oldInnerChild) {
          oldInnerChild = void 0;
        }
        return child;
      };
    }
  };
  function findNonCommentChild(children) {
    let child = children[0];
    if (children.length > 1) {
      let hasFound = false;
      for (const c of children) {
        if (c.type !== Comment) {
          if (hasFound) {
            warn$1(
              "<transition> can only be used on a single element or component. Use <transition-group> for lists."
            );
            break;
          }
          child = c;
          hasFound = true;
        }
      }
    }
    return child;
  }
  const BaseTransition = BaseTransitionImpl;
  function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = /* @__PURE__ */ Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props2, state, instance, postClone) {
    const {
      appear,
      mode,
      persisted = false,
      onBeforeEnter,
      onEnter,
      onAfterEnter,
      onEnterCancelled,
      onBeforeLeave,
      onLeave,
      onAfterLeave,
      onLeaveCancelled,
      onBeforeAppear,
      onAppear,
      onAfterAppear,
      onAppearCancelled
    } = props2;
    const key2 = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook2 = (hook, args) => {
      hook && callWithAsyncErrorHandling(
        hook,
        instance,
        9,
        args
      );
    };
    const callAsyncHook = (hook, args) => {
      const done = args[1];
      callHook2(hook, args);
      if (isArray$1(hook)) {
        if (hook.every((hook2) => hook2.length <= 1)) done();
      } else if (hook.length <= 1) {
        done();
      }
    };
    const hooks = {
      mode,
      persisted,
      beforeEnter(el) {
        let hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el[leaveCbKey]) {
          el[leaveCbKey](
            true
            /* cancelled */
          );
        }
        const leavingVNode = leavingVNodesCache[key2];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
          leavingVNode.el[leaveCbKey]();
        }
        callHook2(hook, [el]);
      },
      enter(el) {
        let hook = onEnter;
        let afterHook = onAfterEnter;
        let cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        let called = false;
        const done = el[enterCbKey] = (cancelled) => {
          if (called) return;
          called = true;
          if (cancelled) {
            callHook2(cancelHook, [el]);
          } else {
            callHook2(afterHook, [el]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el[enterCbKey] = void 0;
        };
        if (hook) {
          callAsyncHook(hook, [el, done]);
        } else {
          done();
        }
      },
      leave(el, remove2) {
        const key22 = String(vnode.key);
        if (el[enterCbKey]) {
          el[enterCbKey](
            true
            /* cancelled */
          );
        }
        if (state.isUnmounting) {
          return remove2();
        }
        callHook2(onBeforeLeave, [el]);
        let called = false;
        const done = el[leaveCbKey] = (cancelled) => {
          if (called) return;
          called = true;
          remove2();
          if (cancelled) {
            callHook2(onLeaveCancelled, [el]);
          } else {
            callHook2(onAfterLeave, [el]);
          }
          el[leaveCbKey] = void 0;
          if (leavingVNodesCache[key22] === vnode) {
            delete leavingVNodesCache[key22];
          }
        };
        leavingVNodesCache[key22] = vnode;
        if (onLeave) {
          callAsyncHook(onLeave, [el, done]);
        } else {
          done();
        }
      },
      clone(vnode2) {
        const hooks2 = resolveTransitionHooks(
          vnode2,
          props2,
          state,
          instance,
          postClone
        );
        if (postClone) postClone(hooks2);
        return hooks2;
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getInnerChild$1(vnode) {
    if (!isKeepAlive(vnode)) {
      if (isTeleport(vnode.type) && vnode.children) {
        return findNonCommentChild(vnode.children);
      }
      return vnode;
    }
    if (vnode.component) {
      return vnode.component.subTree;
    }
    const { shapeFlag, children } = vnode;
    if (children) {
      if (shapeFlag & 16) {
        return children[0];
      }
      if (shapeFlag & 32 && isFunction$1(children.default)) {
        return children.default();
      }
    }
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      vnode.transition = hooks;
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children, keepComment = false, parentKey2) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
      let child = children[i];
      const key2 = parentKey2 == null ? child.key : String(parentKey2) + String(child.key != null ? child.key : i);
      if (child.type === Fragment) {
        if (child.patchFlag & 128) keyedFragmentCount++;
        ret = ret.concat(
          getTransitionRawChildren(child.children, keepComment, key2)
        );
      } else if (keepComment || child.type !== Comment) {
        ret.push(key2 != null ? cloneVNode(child, { key: key2 }) : child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (let i = 0; i < ret.length; i++) {
        ret[i].patchFlag = -2;
      }
    }
    return ret;
  }
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function defineComponent(options, extraOptions) {
    return isFunction$1(options) ? (
      // #8236: extend call and options.name access are considered side-effects
      // by Rollup, so we have to wrap it in a pure-annotated IIFE.
      /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
    ) : options;
  }
  function markAsyncBoundary(instance) {
    instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
  }
  const knownTemplateRefs = /* @__PURE__ */ new WeakSet();
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray$1(rawRef)) {
      rawRef.forEach(
        (r, i) => setRef(
          r,
          oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i] : oldRawRef),
          parentSuspense,
          vnode,
          isUnmount
        )
      );
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
        setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
      }
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref3 } = rawRef;
    if (!owner) {
      warn$1(
        `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
      );
      return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    const rawSetupState = toRaw(setupState);
    const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key2) => {
      {
        if (hasOwn$1(rawSetupState, key2) && !isRef(rawSetupState[key2])) {
          warn$1(
            `Template ref "${key2}" used on a non-ref value. It will not work in the production build.`
          );
        }
        if (knownTemplateRefs.has(rawSetupState[key2])) {
          return false;
        }
      }
      return hasOwn$1(rawSetupState, key2);
    };
    if (oldRef != null && oldRef !== ref3) {
      if (isString$1(oldRef)) {
        refs[oldRef] = null;
        if (canSetSetupRef(oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction$1(ref3)) {
      callWithErrorHandling(ref3, owner, 12, [value, refs]);
    } else {
      const _isString = isString$1(ref3);
      const _isRef = isRef(ref3);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
            if (isUnmount) {
              isArray$1(existing) && remove(existing, refValue);
            } else {
              if (!isArray$1(existing)) {
                if (_isString) {
                  refs[ref3] = [refValue];
                  if (canSetSetupRef(ref3)) {
                    setupState[ref3] = refs[ref3];
                  }
                } else {
                  ref3.value = [refValue];
                  if (rawRef.k) refs[rawRef.k] = ref3.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref3] = value;
            if (canSetSetupRef(ref3)) {
              setupState[ref3] = value;
            }
          } else if (_isRef) {
            ref3.value = value;
            if (rawRef.k) refs[rawRef.k] = value;
          } else {
            warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
          }
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      } else {
        warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
      }
    }
  }
  getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
  getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
  const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(
      type,
      hook,
      keepAliveRoot,
      true
      /* prepend */
    );
    onUnmounted(() => {
      remove(keepAliveRoot[type], injected);
    }, target);
  }
  function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type] || (target[type] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        pauseTracking();
        const reset = setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type, args);
        reset();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    } else {
      const apiName = toHandlerKey(ErrorTypeStrings$1[type].replace(/ hook$/, ""));
      warn$1(
        `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
      );
    }
  }
  const createHook = (lifecycle) => (hook, target = currentInstance) => {
    if (!isInSSRComponentSetup || lifecycle === "sp") {
      injectHook(lifecycle, (...args) => hook(...args), target);
    }
  };
  const onBeforeMount = createHook("bm");
  const onMounted = createHook("m");
  const onBeforeUpdate = createHook(
    "bu"
  );
  const onUpdated = createHook("u");
  const onBeforeUnmount = createHook(
    "bum"
  );
  const onUnmounted = createHook("um");
  const onServerPrefetch = createHook(
    "sp"
  );
  const onRenderTriggered = createHook("rtg");
  const onRenderTracked = createHook("rtc");
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  const DIRECTIVES = "directives";
  const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
  }
  function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component = instance.type;
      const res = (
        // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) || // global registration
        resolve(instance.appContext[type], name)
      );
      if (!res && maybeSelfReference) {
        return Component;
      }
      if (warnMissing && !res) {
        const extra = ``;
        warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
      }
      return res;
    } else {
      warn$1(
        `resolve${capitalize$1(type.slice(0, -1))} can only be used in render() or setup().`
      );
    }
  }
  function resolve(registry, name) {
    return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
  }
  function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = cache;
    const sourceIsArray = isArray$1(source);
    if (sourceIsArray || isString$1(source)) {
      const sourceIsReactiveArray = sourceIsArray && isReactive(source);
      let needsWrap = false;
      if (sourceIsReactiveArray) {
        needsWrap = !isShallow(source);
        source = shallowReadArray(source);
      }
      ret = new Array(source.length);
      for (let i = 0, l = source.length; i < l; i++) {
        ret[i] = renderItem(
          needsWrap ? toReactive(source[i]) : source[i],
          i,
          void 0,
          cached
        );
      }
    } else if (typeof source === "number") {
      if (!Number.isInteger(source)) {
        warn$1(`The v-for range expect an integer value but got ${source}.`);
      }
      ret = new Array(source);
      for (let i = 0; i < source; i++) {
        ret[i] = renderItem(i + 1, i, void 0, cached);
      }
    } else if (isObject$1(source)) {
      if (source[Symbol.iterator]) {
        ret = Array.from(
          source,
          (item, i) => renderItem(item, i, void 0, cached)
        );
      } else {
        const keys2 = Object.keys(source);
        ret = new Array(keys2.length);
        for (let i = 0, l = keys2.length; i < l; i++) {
          const key2 = keys2[i];
          ret[i] = renderItem(source[key2], key2, i, cached);
        }
      }
    } else {
      ret = [];
    }
    return ret;
  }
  const getPublicInstance = (i) => {
    if (!i) return null;
    if (isStatefulComponent(i)) return getComponentPublicInstance(i);
    return getPublicInstance(i.parent);
  };
  const publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => shallowReadonly(i.props),
    $attrs: (i) => shallowReadonly(i.attrs),
    $slots: (i) => shallowReadonly(i.slots),
    $refs: (i) => shallowReadonly(i.refs),
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
  );
  const isReservedPrefix = (key2) => key2 === "_" || key2 === "$";
  const hasSetupBinding = (state, key2) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key2);
  const PublicInstanceProxyHandlers = {
    get({ _: instance }, key2) {
      if (key2 === "__v_skip") {
        return true;
      }
      const { ctx, setupState, data, props: props2, accessCache, type, appContext } = instance;
      if (key2 === "__isVue") {
        return true;
      }
      let normalizedProps;
      if (key2[0] !== "$") {
        const n = accessCache[key2];
        if (n !== void 0) {
          switch (n) {
            case 1:
              return setupState[key2];
            case 2:
              return data[key2];
            case 4:
              return ctx[key2];
            case 3:
              return props2[key2];
          }
        } else if (hasSetupBinding(setupState, key2)) {
          accessCache[key2] = 1;
          return setupState[key2];
        } else if (data !== EMPTY_OBJ && hasOwn$1(data, key2)) {
          accessCache[key2] = 2;
          return data[key2];
        } else if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key2)
        ) {
          accessCache[key2] = 3;
          return props2[key2];
        } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key2)) {
          accessCache[key2] = 4;
          return ctx[key2];
        } else if (shouldCacheAccess) {
          accessCache[key2] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key2];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key2 === "$attrs") {
          track(instance.attrs, "get", "");
          markAttrsAccessed();
        } else if (key2 === "$slots") {
          track(instance, "get", key2);
        }
        return publicGetter(instance);
      } else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) && (cssModule = cssModule[key2])
      ) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key2)) {
        accessCache[key2] = 4;
        return ctx[key2];
      } else if (
        // global properties
        globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key2)
      ) {
        {
          return globalProperties[key2];
        }
      } else if (currentRenderingInstance && (!isString$1(key2) || // #1091 avoid internal isRef/isVNode checks on component instance leading
        // to infinite warning loop
        key2.indexOf("__v") !== 0)) {
        if (data !== EMPTY_OBJ && isReservedPrefix(key2[0]) && hasOwn$1(data, key2)) {
          warn$1(
            `Property ${JSON.stringify(
              key2
            )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
          );
        } else if (instance === currentRenderingInstance) {
          warn$1(
            `Property ${JSON.stringify(key2)} was accessed during render but is not defined on instance.`
          );
        }
      }
    },
    set({ _: instance }, key2, value) {
      const { data, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key2)) {
        setupState[key2] = value;
        return true;
      } else if (setupState.__isScriptSetup && hasOwn$1(setupState, key2)) {
        warn$1(`Cannot mutate <script setup> binding "${key2}" from Options API.`);
        return false;
      } else if (data !== EMPTY_OBJ && hasOwn$1(data, key2)) {
        data[key2] = value;
        return true;
      } else if (hasOwn$1(instance.props, key2)) {
        warn$1(`Attempting to mutate prop "${key2}". Props are readonly.`);
        return false;
      }
      if (key2[0] === "$" && key2.slice(1) in instance) {
        warn$1(
          `Attempting to mutate public property "${key2}". Properties starting with $ are reserved and readonly.`
        );
        return false;
      } else {
        if (key2 in instance.appContext.config.globalProperties) {
          Object.defineProperty(ctx, key2, {
            enumerable: true,
            configurable: true,
            value
          });
        } else {
          ctx[key2] = value;
        }
      }
      return true;
    },
    has({
      _: { data, setupState, accessCache, ctx, appContext, propsOptions }
    }, key2) {
      let normalizedProps;
      return !!accessCache[key2] || data !== EMPTY_OBJ && hasOwn$1(data, key2) || hasSetupBinding(setupState, key2) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key2) || hasOwn$1(ctx, key2) || hasOwn$1(publicPropertiesMap, key2) || hasOwn$1(appContext.config.globalProperties, key2);
    },
    defineProperty(target, key2, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key2] = 0;
      } else if (hasOwn$1(descriptor, "value")) {
        this.set(target, key2, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key2, descriptor);
    }
  };
  {
    PublicInstanceProxyHandlers.ownKeys = (target) => {
      warn$1(
        `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
      );
      return Reflect.ownKeys(target);
    };
  }
  function createDevRenderContext(instance) {
    const target = {};
    Object.defineProperty(target, `_`, {
      configurable: true,
      enumerable: false,
      get: () => instance
    });
    Object.keys(publicPropertiesMap).forEach((key2) => {
      Object.defineProperty(target, key2, {
        configurable: true,
        enumerable: false,
        get: () => publicPropertiesMap[key2](instance),
        // intercepted by the proxy so no need for implementation,
        // but needed to prevent set errors
        set: NOOP
      });
    });
    return target;
  }
  function exposePropsOnRenderContext(instance) {
    const {
      ctx,
      propsOptions: [propsOptions]
    } = instance;
    if (propsOptions) {
      Object.keys(propsOptions).forEach((key2) => {
        Object.defineProperty(ctx, key2, {
          enumerable: true,
          configurable: true,
          get: () => instance.props[key2],
          set: NOOP
        });
      });
    }
  }
  function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys(toRaw(setupState)).forEach((key2) => {
      if (!setupState.__isScriptSetup) {
        if (isReservedPrefix(key2[0])) {
          warn$1(
            `setup() return property ${JSON.stringify(
              key2
            )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
          );
          return;
        }
        Object.defineProperty(ctx, key2, {
          enumerable: true,
          configurable: true,
          get: () => setupState[key2],
          set: NOOP
        });
      }
    });
  }
  function normalizePropsOrEmits(props2) {
    return isArray$1(props2) ? props2.reduce(
      (normalized, p2) => (normalized[p2] = null, normalized),
      {}
    ) : props2;
  }
  function createDuplicateChecker() {
    const cache = /* @__PURE__ */ Object.create(null);
    return (type, key2) => {
      if (cache[key2]) {
        warn$1(`${type} property "${key2}" is already defined in ${cache[key2]}.`);
      } else {
        cache[key2] = type;
      }
    };
  }
  let shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook$1(options.beforeCreate, instance, "bc");
    }
    const {
      // state
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      // lifecycle
      created,
      beforeMount,
      mounted: mounted2,
      beforeUpdate,
      updated: updated2,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted: unmounted2,
      render: render2,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      // public API
      expose,
      inheritAttrs,
      // assets
      components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = createDuplicateChecker();
    {
      const [propsOptions] = instance.propsOptions;
      if (propsOptions) {
        for (const key2 in propsOptions) {
          checkDuplicateProperties("Props", key2);
        }
      }
    }
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key2 in methods) {
        const methodHandler = methods[key2];
        if (isFunction$1(methodHandler)) {
          {
            Object.defineProperty(ctx, key2, {
              value: methodHandler.bind(publicThis),
              configurable: true,
              enumerable: true,
              writable: true
            });
          }
          {
            checkDuplicateProperties("Methods", key2);
          }
        } else {
          warn$1(
            `Method "${key2}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
          );
        }
      }
    }
    if (dataOptions) {
      if (!isFunction$1(dataOptions)) {
        warn$1(
          `The data option must be a function. Plain object usage is no longer supported.`
        );
      }
      const data = dataOptions.call(publicThis, publicThis);
      if (isPromise(data)) {
        warn$1(
          `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
        );
      }
      if (!isObject$1(data)) {
        warn$1(`data() should return an object.`);
      } else {
        instance.data = reactive(data);
        {
          for (const key2 in data) {
            checkDuplicateProperties("Data", key2);
            if (!isReservedPrefix(key2[0])) {
              Object.defineProperty(ctx, key2, {
                configurable: true,
                enumerable: true,
                get: () => data[key2],
                set: NOOP
              });
            }
          }
        }
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key2 in computedOptions) {
        const opt = computedOptions[key2];
        const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        if (get2 === NOOP) {
          warn$1(`Computed property "${key2}" has no getter.`);
        }
        const set = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : () => {
          warn$1(
            `Write operation failed: computed property "${key2}" is readonly.`
          );
        };
        const c = computed({
          get: get2,
          set
        });
        Object.defineProperty(ctx, key2, {
          enumerable: true,
          configurable: true,
          get: () => c.value,
          set: (v) => c.value = v
        });
        {
          checkDuplicateProperties("Computed", key2);
        }
      }
    }
    if (watchOptions) {
      for (const key2 in watchOptions) {
        createWatcher(watchOptions[key2], ctx, publicThis, key2);
      }
    }
    if (provideOptions) {
      const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key2) => {
        provide(key2, provides[key2]);
      });
    }
    if (created) {
      callHook$1(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray$1(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted2);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated2);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted2);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray$1(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key2) => {
          Object.defineProperty(exposed, key2, {
            get: () => publicThis[key2],
            set: (val) => publicThis[key2] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render2 && instance.render === NOOP) {
      instance.render = render2;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
    if (serverPrefetch) {
      markAsyncBoundary(instance);
    }
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray$1(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key2 in injectOptions) {
      const opt = injectOptions[key2];
      let injected;
      if (isObject$1(opt)) {
        if ("default" in opt) {
          injected = inject(
            opt.from || key2,
            opt.default,
            true
          );
        } else {
          injected = inject(opt.from || key2);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        Object.defineProperty(ctx, key2, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key2] = injected;
      }
      {
        checkDuplicateProperties("Inject", key2);
      }
    }
  }
  function callHook$1(hook, instance, type) {
    callWithAsyncErrorHandling(
      isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
      instance,
      type
    );
  }
  function createWatcher(raw, ctx, publicThis, key2) {
    let getter = key2.includes(".") ? createPathGetter(publicThis, key2) : () => publicThis[key2];
    if (isString$1(raw)) {
      const handler = ctx[raw];
      if (isFunction$1(handler)) {
        {
          watch(getter, handler);
        }
      } else {
        warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
      }
    } else if (isFunction$1(raw)) {
      {
        watch(getter, raw.bind(publicThis));
      }
    } else if (isObject$1(raw)) {
      if (isArray$1(raw)) {
        raw.forEach((r) => createWatcher(r, ctx, publicThis, key2));
      } else {
        const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction$1(handler)) {
          watch(getter, handler, raw);
        } else {
          warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
      }
    } else {
      warn$1(`Invalid watch option: "${key2}"`, raw);
    }
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const {
      mixins: globalMixins,
      optionsCache: cache,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
        );
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    if (isObject$1(base)) {
      cache.set(base, resolved);
    }
    return resolved;
  }
  function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        (m) => mergeOptions(to, m, strats, true)
      );
    }
    for (const key2 in from) {
      if (asMixin && key2 === "expose") {
        warn$1(
          `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
        );
      } else {
        const strat = internalOptionMergeStrats[key2] || strats && strats[key2];
        to[key2] = strat ? strat(to[key2], from[key2]) : from[key2];
      }
    }
    return to;
  }
  const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return extend(
        isFunction$1(to) ? to.call(this, this) : to,
        isFunction$1(from) ? from.call(this, this) : from
      );
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray$1(raw)) {
      const res = {};
      for (let i = 0; i < raw.length; i++) {
        res[raw[i]] = raw[i];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
  }
  function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
      if (isArray$1(to) && isArray$1(from)) {
        return [.../* @__PURE__ */ new Set([...to, ...from])];
      }
      return extend(
        /* @__PURE__ */ Object.create(null),
        normalizePropsOrEmits(to),
        normalizePropsOrEmits(from != null ? from : {})
      );
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to, from) {
    if (!to) return from;
    if (!from) return to;
    const merged = extend(/* @__PURE__ */ Object.create(null), to);
    for (const key2 in from) {
      merged[key2] = mergeAsArray(to[key2], from[key2]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let uid$1 = 0;
  function createAppAPI(render2, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction$1(rootComponent)) {
        rootComponent = extend({}, rootComponent);
      }
      if (rootProps != null && !isObject$1(rootProps)) {
        warn$1(`root props passed to app.mount() must be an object.`);
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = /* @__PURE__ */ new WeakSet();
      const pluginCleanupFns = [];
      let isMounted = false;
      const app = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version,
        get config() {
          return context.config;
        },
        set config(v) {
          {
            warn$1(
              `app.config cannot be replaced. Modify individual options instead.`
            );
          }
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin)) {
            warn$1(`Plugin has already been applied to target app.`);
          } else if (plugin && isFunction$1(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app, ...options);
          } else if (isFunction$1(plugin)) {
            installedPlugins.add(plugin);
            plugin(app, ...options);
          } else {
            warn$1(
              `A plugin must either be a function or an object with an "install" function.`
            );
          }
          return app;
        },
        mixin(mixin) {
          {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            } else {
              warn$1(
                "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
              );
            }
          }
          return app;
        },
        component(name, component) {
          {
            validateComponentName(name, context.config);
          }
          if (!component) {
            return context.components[name];
          }
          if (context.components[name]) {
            warn$1(`Component "${name}" has already been registered in target app.`);
          }
          context.components[name] = component;
          return app;
        },
        directive(name, directive) {
          {
            validateDirectiveName(name);
          }
          if (!directive) {
            return context.directives[name];
          }
          if (context.directives[name]) {
            warn$1(`Directive "${name}" has already been registered in target app.`);
          }
          context.directives[name] = directive;
          return app;
        },
        mount(rootContainer, isHydrate, namespace) {
          if (!isMounted) {
            if (rootContainer.__vue_app__) {
              warn$1(
                `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
              );
            }
            const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (namespace === true) {
              namespace = "svg";
            } else if (namespace === false) {
              namespace = void 0;
            }
            {
              context.reload = () => {
                render2(
                  cloneVNode(vnode),
                  rootContainer,
                  namespace
                );
              };
            }
            {
              render2(vnode, rootContainer, namespace);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            {
              app._instance = vnode.component;
              devtoolsInitApp(app, version);
            }
            return getComponentPublicInstance(vnode.component);
          } else {
            warn$1(
              `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
            );
          }
        },
        onUnmount(cleanupFn) {
          if (typeof cleanupFn !== "function") {
            warn$1(
              `Expected function as first argument to app.onUnmount(), but got ${typeof cleanupFn}`
            );
          }
          pluginCleanupFns.push(cleanupFn);
        },
        unmount() {
          if (isMounted) {
            callWithAsyncErrorHandling(
              pluginCleanupFns,
              app._instance,
              16
            );
            render2(null, app._container);
            {
              app._instance = null;
              devtoolsUnmountApp(app);
            }
            delete app._container.__vue_app__;
          } else {
            warn$1(`Cannot unmount an app that is not mounted.`);
          }
        },
        provide(key2, value) {
          if (key2 in context.provides) {
            warn$1(
              `App already provides property with key "${String(key2)}". It will be overwritten with the new value.`
            );
          }
          context.provides[key2] = value;
          return app;
        },
        runWithContext(fn2) {
          const lastApp = currentApp;
          currentApp = app;
          try {
            return fn2();
          } finally {
            currentApp = lastApp;
          }
        }
      };
      return app;
    };
  }
  let currentApp = null;
  function provide(key2, value) {
    if (!currentInstance) {
      {
        warn$1(`provide() can only be used inside setup().`);
      }
    } else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key2] = value;
    }
  }
  function inject(key2, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
      if (provides && key2 in provides) {
        return provides[key2];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else {
        warn$1(`injection "${String(key2)}" not found.`);
      }
    } else {
      warn$1(`inject() can only be used inside setup() or functional components.`);
    }
  }
  const internalObjectProto = {};
  const createInternalObject = () => Object.create(internalObjectProto);
  const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props2 = {};
    const attrs = createInternalObject();
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props2, attrs);
    for (const key2 in instance.propsOptions[0]) {
      if (!(key2 in props2)) {
        props2[key2] = void 0;
      }
    }
    {
      validateProps(rawProps || {}, props2, instance);
    }
    if (isStateful) {
      instance.props = isSSR ? props2 : shallowReactive(props2);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props2;
      }
    }
    instance.attrs = attrs;
  }
  function isInHmrContext(instance) {
    while (instance) {
      if (instance.type.__hmrId) return true;
      instance = instance.parent;
    }
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props: props2,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props2);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
      // always force full diff in dev
      // - #1942 if hmr is enabled with sfc component
      // - vite#872 non-sfc component used by sfc component
      !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)
    ) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i = 0; i < propsToUpdate.length; i++) {
          let key2 = propsToUpdate[i];
          if (isEmitListener(instance.emitsOptions, key2)) {
            continue;
          }
          const value = rawProps[key2];
          if (options) {
            if (hasOwn$1(attrs, key2)) {
              if (value !== attrs[key2]) {
                attrs[key2] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key2);
              props2[camelizedKey] = resolvePropValue(
                options,
                rawCurrentProps,
                camelizedKey,
                value,
                instance,
                false
              );
            }
          } else {
            if (value !== attrs[key2]) {
              attrs[key2] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props2, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key2 in rawCurrentProps) {
        if (!rawProps || // for camelCase
          !hasOwn$1(rawProps, key2) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key2)) === key2 || !hasOwn$1(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && // for camelCase
              (rawPrevProps[key2] !== void 0 || // for kebab-case
                rawPrevProps[kebabKey] !== void 0)) {
              props2[key2] = resolvePropValue(
                options,
                rawCurrentProps,
                key2,
                void 0,
                instance,
                true
              );
            }
          } else {
            delete props2[key2];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key2 in attrs) {
          if (!rawProps || !hasOwn$1(rawProps, key2) && true) {
            delete attrs[key2];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance.attrs, "set", "");
    }
    {
      validateProps(rawProps || {}, props2, instance);
    }
  }
  function setFullProps(instance, rawProps, props2, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key2 in rawProps) {
        if (isReservedProp(key2)) {
          continue;
        }
        const value = rawProps[key2];
        let camelKey;
        if (options && hasOwn$1(options, camelKey = camelize(key2))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props2[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key2)) {
          if (!(key2 in attrs) || value !== attrs[key2]) {
            attrs[key2] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props2);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i = 0; i < needCastKeys.length; i++) {
        const key2 = needCastKeys[i];
        props2[key2] = resolvePropValue(
          options,
          rawCurrentProps,
          key2,
          castValues[key2],
          instance,
          !hasOwn$1(castValues, key2)
        );
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props2, key2, value, instance, isAbsent) {
    const opt = options[key2];
    if (opt != null) {
      const hasDefault = hasOwn$1(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
          const { propsDefaults } = instance;
          if (key2 in propsDefaults) {
            value = propsDefaults[key2];
          } else {
            const reset = setCurrentInstance(instance);
            value = propsDefaults[key2] = defaultValue.call(
              null,
              props2
            );
            reset();
          }
        } else {
          value = defaultValue;
        }
        if (instance.ce) {
          instance.ce._setProp(key2, value);
        }
      }
      if (opt[
        0
        /* shouldCast */
      ]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[
          1
          /* shouldCastTrue */
        ] && (value === "" || value === hyphenate(key2))) {
          value = true;
        }
      }
    }
    return value;
  }
  const mixinPropsCache = /* @__PURE__ */ new WeakMap();
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = asMixin ? mixinPropsCache : appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction$1(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props2, keys2] = normalizePropsOptions(raw2, appContext, true);
        extend(normalized, props2);
        if (keys2) needCastKeys.push(...keys2);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$1(comp)) {
        cache.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray$1(raw)) {
      for (let i = 0; i < raw.length; i++) {
        if (!isString$1(raw[i])) {
          warn$1(`props must be strings when using array syntax.`, raw[i]);
        }
        const normalizedKey = camelize(raw[i]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      if (!isObject$1(raw)) {
        warn$1(`invalid props options`, raw);
      }
      for (const key2 in raw) {
        const normalizedKey = camelize(key2);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key2];
          const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
          const propType = prop.type;
          let shouldCast = false;
          let shouldCastTrue = true;
          if (isArray$1(propType)) {
            for (let index = 0; index < propType.length; ++index) {
              const type = propType[index];
              const typeName = isFunction$1(type) && type.name;
              if (typeName === "Boolean") {
                shouldCast = true;
                break;
              } else if (typeName === "String") {
                shouldCastTrue = false;
              }
            }
          } else {
            shouldCast = isFunction$1(propType) && propType.name === "Boolean";
          }
          prop[
            0
            /* shouldCast */
          ] = shouldCast;
          prop[
            1
            /* shouldCastTrue */
          ] = shouldCastTrue;
          if (shouldCast || hasOwn$1(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject$1(comp)) {
      cache.set(comp, res);
    }
    return res;
  }
  function validatePropName(key2) {
    if (key2[0] !== "$" && !isReservedProp(key2)) {
      return true;
    } else {
      warn$1(`Invalid prop name: "${key2}" is a reserved property.`);
    }
    return false;
  }
  function getType(ctor) {
    if (ctor === null) {
      return "null";
    }
    if (typeof ctor === "function") {
      return ctor.name || "";
    } else if (typeof ctor === "object") {
      const name = ctor.constructor && ctor.constructor.name;
      return name || "";
    }
    return "";
  }
  function validateProps(rawProps, props2, instance) {
    const resolvedValues = toRaw(props2);
    const options = instance.propsOptions[0];
    const camelizePropsKey = Object.keys(rawProps).map((key2) => camelize(key2));
    for (const key2 in options) {
      let opt = options[key2];
      if (opt == null) continue;
      validateProp(
        key2,
        resolvedValues[key2],
        opt,
        shallowReadonly(resolvedValues),
        !camelizePropsKey.includes(key2)
      );
    }
  }
  function validateProp(name, value, prop, props2, isAbsent) {
    const { type, required, validator: validator34, skipCheck } = prop;
    if (required && isAbsent) {
      warn$1('Missing required prop: "' + name + '"');
      return;
    }
    if (value == null && !required) {
      return;
    }
    if (type != null && type !== true && !skipCheck) {
      let isValid2 = false;
      const types = isArray$1(type) ? type : [type];
      const expectedTypes = [];
      for (let i = 0; i < types.length && !isValid2; i++) {
        const { valid, expectedType } = assertType(value, types[i]);
        expectedTypes.push(expectedType || "");
        isValid2 = valid;
      }
      if (!isValid2) {
        warn$1(getInvalidTypeMessage(name, value, expectedTypes));
        return;
      }
    }
    if (validator34 && !validator34(value, props2)) {
      warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
  }
  const isSimpleType = /* @__PURE__ */ makeMap(
    "String,Number,Boolean,Function,Symbol,BigInt"
  );
  function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (expectedType === "null") {
      valid = value === null;
    } else if (isSimpleType(expectedType)) {
      const t = typeof value;
      valid = t === expectedType.toLowerCase();
      if (!valid && t === "object") {
        valid = value instanceof type;
      }
    } else if (expectedType === "Object") {
      valid = isObject$1(value);
    } else if (expectedType === "Array") {
      valid = isArray$1(value);
    } else {
      valid = value instanceof type;
    }
    return {
      valid,
      expectedType
    };
  }
  function getInvalidTypeMessage(name, value, expectedTypes) {
    if (expectedTypes.length === 0) {
      return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
    }
    let message2 = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize$1).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = toRawType(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean$1(expectedType, receivedType)) {
      message2 += ` with value ${expectedValue}`;
    }
    message2 += `, got ${receivedType} `;
    if (isExplicable(receivedType)) {
      message2 += `with value ${receivedValue}.`;
    }
    return message2;
  }
  function styleValue(value, type) {
    if (type === "String") {
      return `"${value}"`;
    } else if (type === "Number") {
      return `${Number(value)}`;
    } else {
      return `${value}`;
    }
  }
  function isExplicable(type) {
    const explicitTypes = ["string", "number", "boolean"];
    return explicitTypes.some((elem) => type.toLowerCase() === elem);
  }
  function isBoolean$1(...args) {
    return args.some((elem) => elem.toLowerCase() === "boolean");
  }
  const isInternalKey = (key2) => key2[0] === "_" || key2 === "$stable";
  const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  const normalizeSlot = (key2, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (currentInstance && (!ctx || ctx.root === currentInstance.root)) {
        warn$1(
          `Slot "${key2}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
        );
      }
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key2 in rawSlots) {
      if (isInternalKey(key2)) continue;
      const value = rawSlots[key2];
      if (isFunction$1(value)) {
        slots[key2] = normalizeSlot(key2, value, ctx);
      } else if (value != null) {
        {
          warn$1(
            `Non-function value encountered for slot "${key2}". Prefer function slots for better performance.`
          );
        }
        const normalized = normalizeSlotValue(value);
        slots[key2] = () => normalized;
      }
    }
  };
  const normalizeVNodeSlots = (instance, children) => {
    if (!isKeepAlive(instance.vnode) && true) {
      warn$1(
        `Non-function value encountered for default slot. Prefer function slots for better performance.`
      );
    }
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  const assignSlots = (slots, children, optimized) => {
    for (const key2 in children) {
      if (optimized || key2 !== "_") {
        slots[key2] = children[key2];
      }
    }
  };
  const initSlots = (instance, children, optimized) => {
    const slots = instance.slots = createInternalObject();
    if (instance.vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        assignSlots(slots, children, optimized);
        if (optimized) {
          def(slots, "_", type, true);
        }
      } else {
        normalizeObjectSlots(children, slots);
      }
    } else if (children) {
      normalizeVNodeSlots(instance, children);
    }
  };
  const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        if (isHmrUpdating) {
          assignSlots(slots, children, optimized);
          trigger(instance, "set", "$slots");
        } else if (optimized && type === 1) {
          needDeletionCheck = false;
        } else {
          assignSlots(slots, children, optimized);
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key2 in slots) {
        if (!isInternalKey(key2) && deletionComparisonTarget[key2] == null) {
          delete slots[key2];
        }
      }
    }
  };
  let supported;
  let perf;
  function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
      perf.mark(`vue-${type}-${instance.uid}`);
    }
    {
      devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
    }
  }
  function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
      const startTag = `vue-${type}-${instance.uid}`;
      const endTag = startTag + `:end`;
      perf.mark(endTag);
      perf.measure(
        `<${formatComponentName(instance, instance.type)}> ${type}`,
        startTag,
        endTag
      );
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
    }
    {
      devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
    }
  }
  function isSupported() {
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function initFeatureFlags() {
    const needWarn = [];
    if (needWarn.length) {
      const multi = needWarn.length > 1;
      console.warn(
        `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
      );
    }
  }
  const queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    {
      initFeatureFlags();
    }
    const target = getGlobalThis();
    target.__VUE__ = true;
    {
      setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    }
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type, ref: ref3, shapeFlag } = n2;
      switch (type) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, namespace);
          } else {
            patchStaticNode(n1, n2, container, namespace);
          }
          break;
        case Fragment:
          processFragment(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          break;
        default:
          if (shapeFlag & 1) {
            processElement(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 6) {
            processComponent(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 64) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (shapeFlag & 128) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else {
            warn$1("Invalid VNode type:", type, `(${typeof type})`);
          }
      }
      if (ref3 != null && parentComponent) {
        setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateText(n2.children),
          container,
          anchor
        );
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateComment(n2.children || ""),
          container,
          anchor
        );
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, namespace) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace,
        n2.el,
        n2.anchor
      );
    };
    const patchStaticNode = (n1, n2, container, namespace) => {
      if (n2.children !== n1.children) {
        const anchor = hostNextSibling(n1.anchor);
        removeStaticNode(n1);
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace
        );
      } else {
        n2.el = n1.el;
        n2.anchor = n1.anchor;
      }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      if (n2.type === "svg") {
        namespace = "svg";
      } else if (n2.type === "math") {
        namespace = "mathml";
      }
      if (n1 == null) {
        mountElement(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { props: props2, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(
        vnode.type,
        namespace,
        props2 && props2.is,
        props2
      );
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(vnode, namespace),
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props2) {
        for (const key2 in props2) {
          if (key2 !== "value" && !isReservedProp(key2)) {
            hostPatchProp(el, key2, null, props2[key2], namespace, parentComponent);
          }
        }
        if ("value" in props2) {
          hostPatchProp(el, "value", null, props2.value, namespace);
        }
        if (vnodeHook = props2.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      {
        def(el, "__vnode", vnode, true);
        def(el, "__vueParentComponent", parentComponent, true);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props2 && props2.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i = 0; i < slotScopeIds.length; i++) {
          hostSetScopeId(el, slotScopeIds[i]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
          subTree = filterSingleRoot(subTree.children) || subTree;
        }
        if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
          const parentVNode = parentComponent.vnode;
          setScopeId(
            el,
            parentVNode,
            parentVNode.scopeId,
            parentVNode.slotScopeIds,
            parentComponent.parent
          );
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start2 = 0) => {
      for (let i = start2; i < children.length; i++) {
        const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
        patch(
          null,
          child,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      {
        el.__vnode = n2;
      }
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (isHmrUpdating) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
        hostSetElementText(el, "");
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          el,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds
        );
        {
          traverseStaticChildren(n1, n2);
        }
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds,
          false
        );
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, oldProps, newProps, parentComponent, namespace);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, namespace);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              const key2 = propsToUpdate[i];
              const prev = oldProps[key2];
              const next = newProps[key2];
              if (next !== prev || key2 === "value") {
                hostPatchProp(el, key2, prev, next, namespace, parentComponent);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
      for (let i = 0; i < newChildren.length; i++) {
        const oldVNode = oldChildren[i];
        const newVNode = newChildren[i];
        const container = (
          // oldVNode may be an errored async setup() component inside Suspense
          // which will not have a mounted element
          oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
              // which also requires the correct parent container
              !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
              oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
            // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer
          )
        );
        patch(
          oldVNode,
          newVNode,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          true
        );
      }
    };
    const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key2 in oldProps) {
            if (!isReservedProp(key2) && !(key2 in newProps)) {
              hostPatchProp(
                el,
                key2,
                oldProps[key2],
                null,
                namespace,
                parentComponent
              );
            }
          }
        }
        for (const key2 in newProps) {
          if (isReservedProp(key2)) continue;
          const next = newProps[key2];
          const prev = oldProps[key2];
          if (next !== prev && key2 !== "value") {
            hostPatchProp(el, key2, prev, next, namespace, parentComponent);
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (
        // #5523 dev root fragment may inherit directives
        isHmrUpdating || patchFlag & 2048
      ) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(
          // #10007
          // such fragment like `<></>` will be compiled into
          // a fragment which doesn't have a children.
          // In this case fallback to an empty array
          n2.children || [],
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n1.dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            container,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          {
            traverseStaticChildren(n1, n2);
          }
        } else {
          patchChildren(
            n1,
            n2,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(
            n2,
            container,
            anchor,
            namespace,
            optimized
          );
        } else {
          mountComponent(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            optimized
          );
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
      const instance = initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      );
      if (instance.type.__hmrId) {
        registerHMR(instance);
      }
      {
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
      }
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        {
          startMeasure(instance, `init`);
        }
        setupComponent(instance, false, optimized);
        {
          endMeasure(instance, `init`);
        }
      }
      if (instance.asyncDep) {
        if (isHmrUpdating) initialVNode.el = null;
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
      } else {
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          namespace,
          optimized
        );
      }
      {
        popWarningContext();
        endMeasure(instance, `mount`);
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          {
            pushWarningContext(n2);
          }
          updateComponentPreRender(instance, n2, optimized);
          {
            popWarningContext();
          }
          return;
        } else {
          instance.next = n2;
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props: props2 } = initialVNode;
          const { bm, m, parent: parent2, root: root2, type } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent2, initialVNode);
          }
          toggleRecurse(instance, true);
          {
            if (root2.ce) {
              root2.ce._injectChildStyle(type);
            }
            {
              startMeasure(instance, `render`);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            {
              endMeasure(instance, `render`);
            }
            {
              startMeasure(instance, `patch`);
            }
            patch(
              null,
              subTree,
              container,
              anchor,
              instance,
              parentSuspense,
              namespace
            );
            {
              endMeasure(instance, `patch`);
            }
            initialVNode.el = subTree.el;
          }
          if (m) {
            queuePostRenderEffect(m, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent2, scopedInitialVNode),
              parentSuspense
            );
          }
          if (initialVNode.shapeFlag & 256 || parent2 && isAsyncWrapper(parent2.vnode) && parent2.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          {
            devtoolsComponentAdded(instance);
          }
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u, parent: parent2, vnode } = instance;
          {
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(() => {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          let originNext = next;
          let vnodeHook;
          {
            pushWarningContext(next || instance.vnode);
          }
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent2, next, vnode);
          }
          toggleRecurse(instance, true);
          {
            startMeasure(instance, `render`);
          }
          const nextTree = renderComponentRoot(instance);
          {
            endMeasure(instance, `render`);
          }
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          {
            startMeasure(instance, `patch`);
          }
          patch(
            prevTree,
            nextTree,
            // parent may have changed if it's in a teleport
            hostParentNode(prevTree.el),
            // anchor may have changed if it's in a fragment
            getNextHostNode(prevTree),
            instance,
            parentSuspense,
            namespace
          );
          {
            endMeasure(instance, `patch`);
          }
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent2, next, vnode),
              parentSuspense
            );
          }
          {
            devtoolsComponentUpdated(instance);
          }
          {
            popWarningContext();
          }
        }
      };
      instance.scope.on();
      const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
      instance.scope.off();
      const update = instance.update = effect2.run.bind(effect2);
      const job = instance.job = effect2.runIfDirty.bind(effect2);
      job.i = instance;
      job.id = instance.uid;
      effect2.scheduler = () => queueJob(job);
      toggleRecurse(instance, true);
      {
        effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
        effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
      }
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i;
      for (i = 0; i < commonLength; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        patch(
          c1[i],
          nextChild,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
      if (oldLength > newLength) {
        unmountChildren(
          c1,
          parentComponent,
          parentSuspense,
          true,
          false,
          commonLength
        );
      } else {
        mountChildren(
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized,
          commonLength
        );
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let i = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i <= e1 && i <= e2) {
        const n1 = c1[i];
        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        i++;
      }
      while (i <= e1 && i <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i > e1) {
        if (i <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i <= e2) {
            patch(
              null,
              c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            i++;
          }
        }
      } else if (i > e2) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } else {
        const s1 = i;
        const s2 = i;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i = s2; i <= e2; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (nextChild.key != null) {
            if (keyToNewIndexMap.has(nextChild.key)) {
              warn$1(
                `Duplicate keys found during update:`,
                JSON.stringify(nextChild.key),
                `Make sure keys are unique.`
              );
            }
            keyToNewIndexMap.set(nextChild.key, i);
          }
        }
        let j;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
        for (i = s1; i <= e1; i++) {
          const prevChild = c1[i];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j = s2; j <= e2; j++) {
              if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                newIndex = j;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(
              prevChild,
              c2[newIndex],
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j = increasingNewIndexSequence.length - 1;
        for (i = toBePatched - 1; i >= 0; i--) {
          const nextIndex = s2 + i;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i] === 0) {
            patch(
              null,
              nextChild,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (moved) {
            if (j < 0 || i !== increasingNewIndexSequence[j]) {
              move(nextChild, container, anchor, 2);
            } else {
              j--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type.move(vnode, container, anchor, internals);
        return;
      }
      if (type === Fragment) {
        hostInsert(el, container, anchor);
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type,
        props: props2,
        ref: ref3,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs,
        cacheIndex
      } = vnode;
      if (patchFlag === -2) {
        optimized = false;
      }
      if (ref3 != null) {
        setRef(ref3, null, parentSuspense, vnode, true);
      }
      if (cacheIndex != null) {
        parentComponent.renderCache[cacheIndex] = void 0;
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(
            vnode,
            parentComponent,
            parentSuspense,
            internals,
            doRemove
          );
        } else if (dynamicChildren && // #5154
          // when v-once is used inside a block, setBlockTracking(-1) marks the
          // parent block with hasOnce: true
          // so that it doesn't take the fast path during unmount - otherwise
          // components nested in v-once are never unmounted.
          !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(
            dynamicChildren,
            parentComponent,
            parentSuspense,
            false,
            true
          );
        } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type, el, anchor, transition } = vnode;
      if (type === Fragment) {
        if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
          vnode.children.forEach((child) => {
            if (child.type === Comment) {
              hostRemove(child.el);
            } else {
              remove2(child);
            }
          });
        } else {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end2) => {
      let next;
      while (cur !== end2) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end2);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      if (instance.type.__hmrId) {
        unregisterHMR(instance);
      }
      const { bum, scope, job, subTree, um, m, a } = instance;
      invalidateMount(m);
      invalidateMount(a);
      if (bum) {
        invokeArrayFns(bum);
      }
      scope.stop();
      if (job) {
        job.flags |= 8;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
      {
        devtoolsComponentRemoved(instance);
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
      for (let i = start2; i < children.length; i++) {
        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      const el = hostNextSibling(vnode.anchor || vnode.el);
      const teleportEnd = el && el[TeleportEndKey];
      return teleportEnd ? hostNextSibling(teleportEnd) : el;
    };
    let isFlushing = false;
    const render2 = (vnode, container, namespace) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(
          container._vnode || null,
          vnode,
          container,
          null,
          null,
          null,
          namespace
        );
      }
      container._vnode = vnode;
      if (!isFlushing) {
        isFlushing = true;
        flushPreFlushCbs();
        flushPostFlushCbs();
        isFlushing = false;
      }
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate;
    return {
      render: render2,
      hydrate,
      createApp: createAppAPI(render2)
    };
  }
  function resolveChildrenNamespace({ type, props: props2 }, currentNamespace) {
    return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props2 && props2.encoding && props2.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse({ effect: effect2, job }, allowed) {
    if (allowed) {
      effect2.flags |= 32;
      job.flags |= 4;
    } else {
      effect2.flags &= -33;
      job.flags &= -5;
    }
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray$1(ch1) && isArray$1(ch2)) {
      for (let i = 0; i < ch1.length; i++) {
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }
          if (!shallow && c2.patchFlag !== -2)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) {
          c2.el = c1.el;
        }
        if (c2.type === Comment && !c2.el) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
      const arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p2[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = u + v >> 1;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p2[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p2[v];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }
  function invalidateMount(hooks) {
    if (hooks) {
      for (let i = 0; i < hooks.length; i++)
        hooks[i].flags |= 8;
    }
  }
  const ssrContextKey = Symbol.for("v-scx");
  const useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey);
      if (!ctx) {
        warn$1(
          `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
        );
      }
      return ctx;
    }
  };
  function watchEffect(effect2, options) {
    return doWatch(effect2, null, options);
  }
  function watch(source, cb, options) {
    if (!isFunction$1(cb)) {
      warn$1(
        `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
      );
    }
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb, options = EMPTY_OBJ) {
    const { immediate, deep, flush, once: once2 } = options;
    if (!cb) {
      if (immediate !== void 0) {
        warn$1(
          `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
      if (deep !== void 0) {
        warn$1(
          `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
      if (once2 !== void 0) {
        warn$1(
          `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
    }
    const baseWatchOptions = extend({}, options);
    baseWatchOptions.onWarn = warn$1;
    const runsImmediately = cb && immediate || !cb && flush !== "post";
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else if (!runsImmediately) {
        const watchStopHandle = () => {
        };
        watchStopHandle.stop = NOOP;
        watchStopHandle.resume = NOOP;
        watchStopHandle.pause = NOOP;
        return watchStopHandle;
      }
    }
    const instance = currentInstance;
    baseWatchOptions.call = (fn2, type, args) => callWithAsyncErrorHandling(fn2, instance, type, args);
    let isPre = false;
    if (flush === "post") {
      baseWatchOptions.scheduler = (job) => {
        queuePostRenderEffect(job, instance && instance.suspense);
      };
    } else if (flush !== "sync") {
      isPre = true;
      baseWatchOptions.scheduler = (job, isFirstRun) => {
        if (isFirstRun) {
          job();
        } else {
          queueJob(job);
        }
      };
    }
    baseWatchOptions.augmentJob = (job) => {
      if (cb) {
        job.flags |= 4;
      }
      if (isPre) {
        job.flags |= 2;
        if (instance) {
          job.id = instance.uid;
          job.i = instance;
        }
      }
    };
    const watchHandle = watch$1(source, cb, baseWatchOptions);
    if (isInSSRComponentSetup) {
      if (ssrCleanup) {
        ssrCleanup.push(watchHandle);
      } else if (runsImmediately) {
        watchHandle();
      }
    }
    return watchHandle;
  }
  function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction$1(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const reset = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    reset();
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i = 0; i < segments.length && cur; i++) {
        cur = cur[segments[i]];
      }
      return cur;
    };
  }
  const getModelModifiers = (props2, modelName) => {
    return modelName === "modelValue" || modelName === "model-value" ? props2.modelModifiers : props2[`${modelName}Modifiers`] || props2[`${camelize(modelName)}Modifiers`] || props2[`${hyphenate(modelName)}Modifiers`];
  };
  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props2 = instance.vnode.props || EMPTY_OBJ;
    {
      const {
        emitsOptions,
        propsOptions: [propsOptions]
      } = instance;
      if (emitsOptions) {
        if (!(event in emitsOptions) && true) {
          if (!propsOptions || !(toHandlerKey(camelize(event)) in propsOptions)) {
            warn$1(
              `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(camelize(event))}" prop.`
            );
          }
        } else {
          const validator34 = emitsOptions[event];
          if (isFunction$1(validator34)) {
            const isValid2 = validator34(...rawArgs);
            if (!isValid2) {
              warn$1(
                `Invalid event arguments: event validation failed for event "${event}".`
              );
            }
          }
        }
      }
    }
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modifiers = isModelListener2 && getModelModifiers(props2, event.slice(7));
    if (modifiers) {
      if (modifiers.trim) {
        args = rawArgs.map((a) => isString$1(a) ? a.trim() : a);
      }
      if (modifiers.number) {
        args = rawArgs.map(looseToNumber);
      }
    }
    {
      devtoolsComponentEmit(instance, event, args);
    }
    {
      const lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && props2[toHandlerKey(lowerCaseEvent)]) {
        warn$1(
          `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
            instance,
            instance.type
          )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(
            event
          )}" instead of "${event}".`
        );
      }
    }
    let handlerName;
    let handler = props2[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props2[handlerName = toHandlerKey(camelize(event))];
    if (!handler && isModelListener2) {
      handler = props2[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(
        handler,
        instance,
        6,
        args
      );
    }
    const onceHandler = props2[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(
        onceHandler,
        instance,
        6,
        args
      );
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction$1(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$1(comp)) {
        cache.set(comp, null);
      }
      return null;
    }
    if (isArray$1(raw)) {
      raw.forEach((key2) => normalized[key2] = null);
    } else {
      extend(normalized, raw);
    }
    if (isObject$1(comp)) {
      cache.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key2) {
    if (!options || !isOn(key2)) {
      return false;
    }
    key2 = key2.slice(2).replace(/Once$/, "");
    return hasOwn$1(options, key2[0].toLowerCase() + key2.slice(1)) || hasOwn$1(options, hyphenate(key2)) || hasOwn$1(options, key2);
  }
  let accessedAttrs = false;
  function markAttrsAccessed() {
    accessedAttrs = true;
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit: emit2,
      render: render2,
      renderCache,
      props: props2,
      data,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    const prev = setCurrentRenderingInstance(instance);
    let result;
    let fallthroughAttrs;
    {
      accessedAttrs = false;
    }
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        const thisProxy = setupState.__isScriptSetup ? new Proxy(proxyToUse, {
          get(target, key2, receiver) {
            warn$1(
              `Property '${String(
                key2
              )}' was accessed via 'this'. Avoid using 'this' in templates.`
            );
            return Reflect.get(target, key2, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(
          render2.call(
            thisProxy,
            proxyToUse,
            renderCache,
            true ? shallowReadonly(props2) : props2,
            setupState,
            data,
            ctx
          )
        );
        fallthroughAttrs = attrs;
      } else {
        const render22 = Component;
        if (attrs === props2) {
          markAttrsAccessed();
        }
        result = normalizeVNode(
          render22.length > 1 ? render22(
            true ? shallowReadonly(props2) : props2,
            true ? {
              get attrs() {
                markAttrsAccessed();
                return shallowReadonly(attrs);
              },
              slots,
              emit: emit2
            } : { attrs, slots, emit: emit2 }
          ) : render22(
            true ? shallowReadonly(props2) : props2,
            null
          )
        );
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root2 = result;
    let setRoot = void 0;
    if (result.patchFlag > 0 && result.patchFlag & 2048) {
      [root2, setRoot] = getChildRoot(result);
    }
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys2 = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root2;
      if (keys2.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys2.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(
              fallthroughAttrs,
              propsOptions
            );
          }
          root2 = cloneVNode(root2, fallthroughAttrs, false, true);
        } else if (!accessedAttrs && root2.type !== Comment) {
          const allAttrs = Object.keys(attrs);
          const eventAttrs = [];
          const extraAttrs = [];
          for (let i = 0, l = allAttrs.length; i < l; i++) {
            const key2 = allAttrs[i];
            if (isOn(key2)) {
              if (!isModelListener(key2)) {
                eventAttrs.push(key2[2].toLowerCase() + key2.slice(3));
              }
            } else {
              extraAttrs.push(key2);
            }
          }
          if (extraAttrs.length) {
            warn$1(
              `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
            );
          }
          if (eventAttrs.length) {
            warn$1(
              `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
            );
          }
        }
      }
    }
    if (vnode.dirs) {
      if (!isElementRoot(root2)) {
        warn$1(
          `Runtime directive used on component with non-element root node. The directives will not function as intended.`
        );
      }
      root2 = cloneVNode(root2, null, false, true);
      root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      if (!isElementRoot(root2)) {
        warn$1(
          `Component inside <Transition> renders non-element root node that cannot be animated.`
        );
      }
      setTransitionHooks(root2, vnode.transition);
    }
    if (setRoot) {
      setRoot(root2);
    } else {
      result = root2;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  const getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren, false);
    if (!childRoot) {
      return [vnode, void 0];
    } else if (childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {
      return getChildRoot(childRoot);
    }
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
      rawChildren[index] = updatedRoot;
      if (dynamicChildren) {
        if (dynamicIndex > -1) {
          dynamicChildren[dynamicIndex] = updatedRoot;
        } else if (updatedRoot.patchFlag > 0) {
          vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
        }
      }
    };
    return [normalizeVNode(childRoot), setRoot];
  };
  function filterSingleRoot(children, recurse = true) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (isVNode(child)) {
        if (child.type !== Comment || child.children === "v-if") {
          if (singleRoot) {
            return;
          } else {
            singleRoot = child;
            if (recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {
              return filterSingleRoot(singleRoot.children);
            }
          }
        }
      } else {
        return;
      }
    }
    return singleRoot;
  }
  const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key2 in attrs) {
      if (key2 === "class" || key2 === "style" || isOn(key2)) {
        (res || (res = {}))[key2] = attrs[key2];
      }
    }
    return res;
  };
  const filterModelListeners = (attrs, props2) => {
    const res = {};
    for (const key2 in attrs) {
      if (!isModelListener(key2) || !(key2.slice(9) in props2)) {
        res[key2] = attrs[key2];
      }
    }
    return res;
  };
  const isElementRoot = (vnode) => {
    return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if ((prevChildren || nextChildren) && isHmrUpdating) {
      return true;
    }
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i = 0; i < dynamicProps.length; i++) {
          const key2 = dynamicProps[i];
          if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emits, key2)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
      const key2 = nextKeys[i];
      if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emitsOptions, key2)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent: parent2 }, el) {
    while (parent2) {
      const root2 = parent2.subTree;
      if (root2.suspense && root2.suspense.activeBranch === vnode) {
        root2.el = vnode.el;
      }
      if (root2 === vnode) {
        (vnode = parent2.vnode).el = el;
        parent2 = parent2.parent;
      } else {
        break;
      }
    }
  }
  const isSuspense = (type) => type.__isSuspense;
  function queueEffectWithSuspense(fn2, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray$1(fn2)) {
        suspense.effects.push(...fn2);
      } else {
        suspense.effects.push(fn2);
      }
    } else {
      queuePostFlushCb(fn2);
    }
  }
  const Fragment = Symbol.for("v-fgt");
  const Text = Symbol.for("v-txt");
  const Comment = Symbol.for("v-cmt");
  const Static = Symbol.for("v-stc");
  const blockStack = [];
  let currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  let isBlockTreeEnabled = 1;
  function setBlockTracking(value, inVOnce = false) {
    isBlockTreeEnabled += value;
    if (value < 0 && currentBlock && inVOnce) {
      currentBlock.hasOnce = true;
    }
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type, props2, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
      createBaseVNode(
        type,
        props2,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        true
      )
    );
  }
  function createBlock(type, props2, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type,
        props2,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 && n1.component) {
      const dirtyInstances = hmrDirtyComponents.get(n2.type);
      if (dirtyInstances && dirtyInstances.has(n1.component)) {
        n1.shapeFlag &= -257;
        n2.shapeFlag &= -513;
        return false;
      }
    }
    return n1.type === n2.type && n1.key === n2.key;
  }
  const createVNodeWithArgsTransform = (...args) => {
    return _createVNode(
      ...args
    );
  };
  const normalizeKey = ({ key: key2 }) => key2 != null ? key2 : null;
  const normalizeRef = ({
    ref: ref3,
    ref_key,
    ref_for
  }) => {
    if (typeof ref3 === "number") {
      ref3 = "" + ref3;
    }
    return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
  };
  function createBaseVNode(type, props2 = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type,
      props: props2,
      key: props2 && normalizeKey(props2),
      ref: props2 && normalizeRef(props2),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString$1(children) ? 8 : 16;
    }
    if (vnode.key !== vnode.key) {
      warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  const createVNode = createVNodeWithArgsTransform;
  function _createVNode(type, props2 = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
      if (!type) {
        warn$1(`Invalid vnode type when creating vnode: ${type}.`);
      }
      type = Comment;
    }
    if (isVNode(type)) {
      const cloned = cloneVNode(
        type,
        props2,
        true
        /* mergeRef: true */
      );
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag = -2;
      return cloned;
    }
    if (isClassComponent(type)) {
      type = type.__vccOpts;
    }
    if (props2) {
      props2 = guardReactiveProps(props2);
      let { class: klass, style } = props2;
      if (klass && !isString$1(klass)) {
        props2.class = normalizeClass(klass);
      }
      if (isObject$1(style)) {
        if (isProxy(style) && !isArray$1(style)) {
          style = extend({}, style);
        }
        props2.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$1(type) ? 2 : 0;
    if (shapeFlag & 4 && isProxy(type)) {
      type = toRaw(type);
      warn$1(
        `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
        `
Component that was made reactive: `,
        type
      );
    }
    return createBaseVNode(
      type,
      props2,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props2) {
    if (!props2) return null;
    return isProxy(props2) || isInternalObject(props2) ? extend({}, props2) : props2;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
    const { props: props2, ref: ref3, patchFlag, children, transition } = vnode;
    const mergedProps = extraProps ? mergeProps(props2 || {}, extraProps) : props2;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? (
        // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
      ) : ref3,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children: patchFlag === -1 && isArray$1(children) ? children.map(deepCloneVNode) : children,
      target: vnode.target,
      targetStart: vnode.targetStart,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: preserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition,
      // These should technically only be non-null on mounted VNodes. However,
      // they *should* be copied for kept-alive vnodes. So we just always copy
      // them since them being non-null during a mount doesn't affect the logic as
      // they will simply be overwritten.
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    if (transition && cloneTransition) {
      setTransitionHooks(
        cloned,
        transition.clone(cloned)
      );
    }
    return cloned;
  }
  function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if (isArray$1(vnode.children)) {
      cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray$1(child)) {
      return createVNode(
        Fragment,
        null,
        // #3666, avoid reference pollution when reusing vnode
        child.slice()
      );
    } else if (isVNode(child)) {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray$1(children)) {
      type = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type = 32;
        const slotFlag = children._;
        if (!slotFlag && !isInternalObject(children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction$1(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type = 16;
        children = [createTextVNode(children)];
      } else {
        type = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
      const toMerge = args[i];
      for (const key2 in toMerge) {
        if (key2 === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key2 === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key2)) {
          const existing = ret[key2];
          const incoming = toMerge[key2];
          if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
            ret[key2] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key2 !== "") {
          ret[key2] = toMerge[key2];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  const emptyAppContext = createAppContext();
  let uid = 0;
  function createComponentInstance(vnode, parent2, suspense) {
    const type = vnode.type;
    const appContext = (parent2 ? parent2.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type,
      parent: parent2,
      appContext,
      root: null,
      // to be immediately set
      next: null,
      subTree: null,
      // will be set synchronously right after creation
      effect: null,
      update: null,
      // will be set synchronously right after creation
      job: null,
      scope: new EffectScope(
        true
        /* detached */
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent2 ? parent2.provides : Object.create(appContext.provides),
      ids: parent2 ? parent2.ids : ["", 0, 0],
      accessCache: null,
      renderCache: [],
      // local resolved assets
      components: null,
      directives: null,
      // resolved props and emits options
      propsOptions: normalizePropsOptions(type, appContext),
      emitsOptions: normalizeEmitsOptions(type, appContext),
      // emit
      emit: null,
      // to be set immediately
      emitted: null,
      // props default value
      propsDefaults: EMPTY_OBJ,
      // inheritAttrs
      inheritAttrs: type.inheritAttrs,
      // state
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      // suspense related
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      // lifecycle hooks
      // not using enums here because it results in computed properties
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    {
      instance.ctx = createDevRenderContext(instance);
    }
    instance.root = parent2 ? parent2.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  let currentInstance = null;
  const getCurrentInstance = () => currentInstance || currentRenderingInstance;
  let internalSetCurrentInstance;
  let setInSSRSetupState;
  {
    const g = getGlobalThis();
    const registerGlobalSetter = (key2, setter) => {
      let setters;
      if (!(setters = g[key2])) setters = g[key2] = [];
      setters.push(setter);
      return (v) => {
        if (setters.length > 1) setters.forEach((set) => set(v));
        else setters[0](v);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      `__VUE_INSTANCE_SETTERS__`,
      (v) => currentInstance = v
    );
    setInSSRSetupState = registerGlobalSetter(
      `__VUE_SSR_SETTERS__`,
      (v) => isInSSRComponentSetup = v
    );
  }
  const setCurrentInstance = (instance) => {
    const prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return () => {
      instance.scope.off();
      internalSetCurrentInstance(prev);
    };
  };
  const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
  function validateComponentName(name, { isNativeTag }) {
    if (isBuiltInTag(name) || isNativeTag(name)) {
      warn$1(
        "Do not use built-in or reserved HTML elements as component id: " + name
      );
    }
  }
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false, optimized = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props: props2, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props2, isStateful, isSSR);
    initSlots(instance, children, optimized);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    var _a;
    const Component = instance.type;
    {
      if (Component.name) {
        validateComponentName(Component.name, instance.appContext.config);
      }
      if (Component.components) {
        const names2 = Object.keys(Component.components);
        for (let i = 0; i < names2.length; i++) {
          validateComponentName(names2[i], instance.appContext.config);
        }
      }
      if (Component.directives) {
        const names2 = Object.keys(Component.directives);
        for (let i = 0; i < names2.length; i++) {
          validateDirectiveName(names2[i]);
        }
      }
      if (Component.compilerOptions && isRuntimeOnly()) {
        warn$1(
          `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
        );
      }
    }
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    {
      exposePropsOnRenderContext(instance);
    }
    const { setup: setup30 } = Component;
    if (setup30) {
      pauseTracking();
      const setupContext = instance.setupContext = setup30.length > 1 ? createSetupContext(instance) : null;
      const reset = setCurrentInstance(instance);
      const setupResult = callWithErrorHandling(
        setup30,
        instance,
        0,
        [
          shallowReadonly(instance.props),
          setupContext
        ]
      );
      const isAsyncSetup = isPromise(setupResult);
      resetTracking();
      reset();
      if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
        markAsyncBoundary(instance);
      }
      if (isAsyncSetup) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
          if (!instance.suspense) {
            const name = (_a = Component.name) != null ? _a : "Anonymous";
            warn$1(
              `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
            );
          }
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction$1(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject$1(setupResult)) {
      if (isVNode(setupResult)) {
        warn$1(
          `setup() should not return VNodes directly - return a render function instead.`
        );
      }
      {
        instance.devtoolsRawSetupState = setupResult;
      }
      instance.setupState = proxyRefs(setupResult);
      {
        exposeSetupStateOnRenderContext(instance);
      }
    } else if (setupResult !== void 0) {
      warn$1(
        `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
      );
    }
    finishComponentSetup(instance, isSSR);
  }
  const isRuntimeOnly = () => true;
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      instance.render = Component.render || NOOP;
    }
    {
      const reset = setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        reset();
      }
    }
    if (!Component.render && instance.render === NOOP && !isSSR) {
      if (Component.template) {
        warn$1(
          `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
        );
      } else {
        warn$1(`Component is missing template or render function: `, Component);
      }
    }
  }
  const attrsProxyHandlers = {
    get(target, key2) {
      markAttrsAccessed();
      track(target, "get", "");
      return target[key2];
    },
    set() {
      warn$1(`setupContext.attrs is readonly.`);
      return false;
    },
    deleteProperty() {
      warn$1(`setupContext.attrs is readonly.`);
      return false;
    }
  };
  function getSlotsProxy(instance) {
    return new Proxy(instance.slots, {
      get(target, key2) {
        track(instance, "get", "$slots");
        return target[key2];
      }
    });
  }
  function createSetupContext(instance) {
    const expose = (exposed) => {
      {
        if (instance.exposed) {
          warn$1(`expose() should be called only once per setup().`);
        }
        if (exposed != null) {
          let exposedType = typeof exposed;
          if (exposedType === "object") {
            if (isArray$1(exposed)) {
              exposedType = "array";
            } else if (isRef(exposed)) {
              exposedType = "ref";
            }
          }
          if (exposedType !== "object") {
            warn$1(
              `expose() should be passed a plain object, received ${exposedType}.`
            );
          }
        }
      }
      instance.exposed = exposed || {};
    };
    {
      let attrsProxy;
      let slotsProxy;
      return Object.freeze({
        get attrs() {
          return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
        },
        get slots() {
          return slotsProxy || (slotsProxy = getSlotsProxy(instance));
        },
        get emit() {
          return (event, ...args) => instance.emit(event, ...args);
        },
        expose
      });
    }
  }
  function getComponentPublicInstance(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key2) {
          if (key2 in target) {
            return target[key2];
          } else if (key2 in publicPropertiesMap) {
            return publicPropertiesMap[key2](instance);
          }
        },
        has(target, key2) {
          return key2 in target || key2 in publicPropertiesMap;
        }
      }));
    } else {
      return instance.proxy;
    }
  }
  const classifyRE = /(?:^|[-_])(\w)/g;
  const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component, includeInferred = true) {
    return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
      const match = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key2 in registry) {
          if (registry[key2] === Component) {
            return key2;
          }
        }
      };
      name = inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction$1(value) && "__vccOpts" in value;
  }
  const computed = (getterOrOptions, debugOptions) => {
    const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    {
      const i = getCurrentInstance();
      if (i && i.appContext.config.warnRecursiveComputed) {
        c._warnRecursive = true;
      }
    }
    return c;
  };
  function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
      if (isObject$1(propsOrChildren) && !isArray$1(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  }
  function initCustomFormatter() {
    if (typeof window === "undefined") {
      return;
    }
    const vueStyle = { style: "color:#3ba776" };
    const numberStyle = { style: "color:#1677ff" };
    const stringStyle = { style: "color:#f5222d" };
    const keywordStyle = { style: "color:#eb2f96" };
    const formatter = {
      __vue_custom_formatter: true,
      header(obj) {
        if (!isObject$1(obj)) {
          return null;
        }
        if (obj.__isVue) {
          return ["div", vueStyle, `VueInstance`];
        } else if (isRef(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, genRefFlag(obj)],
            "<",
            // avoid debugger accessing value affecting behavior
            formatValue("_value" in obj ? obj._value : obj),
            `>`
          ];
        } else if (isReactive(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
            "<",
            formatValue(obj),
            `>${isReadonly(obj) ? ` (readonly)` : ``}`
          ];
        } else if (isReadonly(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
            "<",
            formatValue(obj),
            ">"
          ];
        }
        return null;
      },
      hasBody(obj) {
        return obj && obj.__isVue;
      },
      body(obj) {
        if (obj && obj.__isVue) {
          return [
            "div",
            {},
            ...formatInstance(obj.$)
          ];
        }
      }
    };
    function formatInstance(instance) {
      const blocks = [];
      if (instance.type.props && instance.props) {
        blocks.push(createInstanceBlock("props", toRaw(instance.props)));
      }
      if (instance.setupState !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("setup", instance.setupState));
      }
      if (instance.data !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("data", toRaw(instance.data)));
      }
      const computed2 = extractKeys(instance, "computed");
      if (computed2) {
        blocks.push(createInstanceBlock("computed", computed2));
      }
      const injected = extractKeys(instance, "inject");
      if (injected) {
        blocks.push(createInstanceBlock("injected", injected));
      }
      blocks.push([
        "div",
        {},
        [
          "span",
          {
            style: keywordStyle.style + ";opacity:0.66"
          },
          "$ (internal): "
        ],
        ["object", { object: instance }]
      ]);
      return blocks;
    }
    function createInstanceBlock(type, target) {
      target = extend({}, target);
      if (!Object.keys(target).length) {
        return ["span", {}];
      }
      return [
        "div",
        { style: "line-height:1.25em;margin-bottom:0.6em" },
        [
          "div",
          {
            style: "color:#476582"
          },
          type
        ],
        [
          "div",
          {
            style: "padding-left:1.25em"
          },
          ...Object.keys(target).map((key2) => {
            return [
              "div",
              {},
              ["span", keywordStyle, key2 + ": "],
              formatValue(target[key2], false)
            ];
          })
        ]
      ];
    }
    function formatValue(v, asRaw = true) {
      if (typeof v === "number") {
        return ["span", numberStyle, v];
      } else if (typeof v === "string") {
        return ["span", stringStyle, JSON.stringify(v)];
      } else if (typeof v === "boolean") {
        return ["span", keywordStyle, v];
      } else if (isObject$1(v)) {
        return ["object", { object: asRaw ? toRaw(v) : v }];
      } else {
        return ["span", stringStyle, String(v)];
      }
    }
    function extractKeys(instance, type) {
      const Comp = instance.type;
      if (isFunction$1(Comp)) {
        return;
      }
      const extracted = {};
      for (const key2 in instance.ctx) {
        if (isKeyOfType(Comp, key2, type)) {
          extracted[key2] = instance.ctx[key2];
        }
      }
      return extracted;
    }
    function isKeyOfType(Comp, key2, type) {
      const opts = Comp[type];
      if (isArray$1(opts) && opts.includes(key2) || isObject$1(opts) && key2 in opts) {
        return true;
      }
      if (Comp.extends && isKeyOfType(Comp.extends, key2, type)) {
        return true;
      }
      if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key2, type))) {
        return true;
      }
    }
    function genRefFlag(v) {
      if (isShallow(v)) {
        return `ShallowRef`;
      }
      if (v.effect) {
        return `ComputedRef`;
      }
      return `Ref`;
    }
    if (window.devtoolsFormatters) {
      window.devtoolsFormatters.push(formatter);
    } else {
      window.devtoolsFormatters = [formatter];
    }
  }
  const version = "3.5.13";
  const warn = warn$1;
  /**
  * @vue/runtime-dom v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  let policy = void 0;
  const tt = typeof window !== "undefined" && window.trustedTypes;
  if (tt) {
    try {
      policy = /* @__PURE__ */ tt.createPolicy("vue", {
        createHTML: (val) => val
      });
    } catch (e) {
      warn(`Error creating trusted types policy: ${e}`);
    }
  }
  const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
  const svgNS = "http://www.w3.org/2000/svg";
  const mathmlNS = "http://www.w3.org/1998/Math/MathML";
  const doc = typeof document !== "undefined" ? document : null;
  const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  const nodeOps = {
    insert: (child, parent2, anchor) => {
      parent2.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent2 = child.parentNode;
      if (parent2) {
        parent2.removeChild(child);
      }
    },
    createElement: (tag, namespace, is, props2) => {
      const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
      if (tag === "select" && props2 && props2.multiple != null) {
        el.setAttribute("multiple", props2.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
      node.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id) {
      el.setAttribute(id, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent2, anchor, namespace, start2, end2) {
      const before = anchor ? anchor.previousSibling : parent2.lastChild;
      if (start2 && (start2 === end2 || start2.nextSibling)) {
        while (true) {
          parent2.insertBefore(start2.cloneNode(true), anchor);
          if (start2 === end2 || !(start2 = start2.nextSibling)) break;
        }
      } else {
        templateContainer.innerHTML = unsafeToTrustedHTML(
          namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
        );
        const template = templateContainer.content;
        if (namespace === "svg" || namespace === "mathml") {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent2.insertBefore(template, anchor);
      }
      return [
        // first
        before ? before.nextSibling : parent2.firstChild,
        // last
        anchor ? anchor.previousSibling : parent2.lastChild
      ];
    }
  };
  const TRANSITION = "transition";
  const ANIMATION = "animation";
  const vtcKey = Symbol("_vtc");
  const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  };
  const TransitionPropsValidators = /* @__PURE__ */ extend(
    {},
    BaseTransitionPropsValidators,
    DOMTransitionPropsValidators
  );
  const decorate$1 = (t) => {
    t.displayName = "Transition";
    t.props = TransitionPropsValidators;
    return t;
  };
  const Transition = /* @__PURE__ */ decorate$1(
    (props2, { slots }) => h(BaseTransition, resolveTransitionProps(props2), slots)
  );
  const callHook = (hook, args = []) => {
    if (isArray$1(hook)) {
      hook.forEach((h2) => h2(...args));
    } else if (hook) {
      hook(...args);
    }
  };
  const hasExplicitCallback = (hook) => {
    return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
  };
  function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key2 in rawProps) {
      if (!(key2 in DOMTransitionPropsValidators)) {
        baseProps[key2] = rawProps[key2];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    const {
      name = "v",
      type,
      duration,
      enterFromClass = `${name}-enter-from`,
      enterActiveClass = `${name}-enter-active`,
      enterToClass = `${name}-enter-to`,
      appearFromClass = enterFromClass,
      appearActiveClass = enterActiveClass,
      appearToClass = enterToClass,
      leaveFromClass = `${name}-leave-from`,
      leaveActiveClass = `${name}-leave-active`,
      leaveToClass = `${name}-leave-to`
    } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const {
      onBeforeEnter,
      onEnter,
      onEnterCancelled,
      onLeave,
      onLeaveCancelled,
      onBeforeAppear = onBeforeEnter,
      onAppear = onEnter,
      onAppearCancelled = onEnterCancelled
    } = baseProps;
    const finishEnter = (el, isAppear, done, isCancelled) => {
      el._enterCancelled = isCancelled;
      removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    const finishLeave = (el, done) => {
      el._isLeaving = false;
      removeTransitionClass(el, leaveFromClass);
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
      done && done();
    };
    const makeEnterHook = (isAppear) => {
      return (el, done) => {
        const hook = isAppear ? onAppear : onEnter;
        const resolve2 = () => finishEnter(el, isAppear, done);
        callHook(hook, [el, resolve2]);
        nextFrame(() => {
          removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el, type, enterDuration, resolve2);
          }
        });
      };
    };
    return extend(baseProps, {
      onBeforeEnter(el) {
        callHook(onBeforeEnter, [el]);
        addTransitionClass(el, enterFromClass);
        addTransitionClass(el, enterActiveClass);
      },
      onBeforeAppear(el) {
        callHook(onBeforeAppear, [el]);
        addTransitionClass(el, appearFromClass);
        addTransitionClass(el, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave(el, done) {
        el._isLeaving = true;
        const resolve2 = () => finishLeave(el, done);
        addTransitionClass(el, leaveFromClass);
        if (!el._enterCancelled) {
          forceReflow();
          addTransitionClass(el, leaveActiveClass);
        } else {
          addTransitionClass(el, leaveActiveClass);
          forceReflow();
        }
        nextFrame(() => {
          if (!el._isLeaving) {
            return;
          }
          removeTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveToClass);
          if (!hasExplicitCallback(onLeave)) {
            whenTransitionEnds(el, type, leaveDuration, resolve2);
          }
        });
        callHook(onLeave, [el, resolve2]);
      },
      onEnterCancelled(el) {
        finishEnter(el, false, void 0, true);
        callHook(onEnterCancelled, [el]);
      },
      onAppearCancelled(el) {
        finishEnter(el, true, void 0, true);
        callHook(onAppearCancelled, [el]);
      },
      onLeaveCancelled(el) {
        finishLeave(el);
        callHook(onLeaveCancelled, [el]);
      }
    });
  }
  function normalizeDuration(duration) {
    if (duration == null) {
      return null;
    } else if (isObject$1(duration)) {
      return [NumberOf(duration.enter), NumberOf(duration.leave)];
    } else {
      const n = NumberOf(duration);
      return [n, n];
    }
  }
  function NumberOf(val) {
    const res = toNumber$1(val);
    {
      assertNumber(res, "<transition> explicit duration");
    }
    return res;
  }
  function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
    (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el[vtcKey] = void 0;
      }
    }
  }
  function nextFrame(cb) {
    requestAnimationFrame(() => {
      requestAnimationFrame(cb);
    });
  }
  let endId = 0;
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = () => {
      if (id === el._endId) {
        resolve2();
      }
    };
    if (explicitTimeout != null) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
      return resolve2();
    }
    const endEvent = type + "end";
    let ended = 0;
    const end2 = () => {
      el.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    const onEnd = (e) => {
      if (e.target === el && ++ended >= propCount) {
        end2();
      }
    };
    setTimeout(() => {
      if (ended < propCount) {
        end2();
      }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key2) => (styles[key2] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
      getStyleProperties(`${TRANSITION}Property`).toString()
    );
    return {
      type,
      timeout,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
  }
  function toMs(s) {
    if (s === "auto") return 0;
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow() {
    return document.body.offsetHeight;
  }
  function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  const vShowOriginalDisplay = Symbol("_vod");
  const vShowHidden = Symbol("_vsh");
  const vShow = {
    beforeMount(el, { value }, { transition }) {
      el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
      if (transition && value) {
        transition.beforeEnter(el);
      } else {
        setDisplay(el, value);
      }
    },
    mounted(el, { value }, { transition }) {
      if (transition && value) {
        transition.enter(el);
      }
    },
    updated(el, { value, oldValue }, { transition }) {
      if (!value === !oldValue) return;
      if (transition) {
        if (value) {
          transition.beforeEnter(el);
          setDisplay(el, true);
          transition.enter(el);
        } else {
          transition.leave(el, () => {
            setDisplay(el, false);
          });
        }
      } else {
        setDisplay(el, value);
      }
    },
    beforeUnmount(el, { value }) {
      setDisplay(el, value);
    }
  };
  {
    vShow.name = "show";
  }
  function setDisplay(el, value) {
    el.style.display = value ? el[vShowOriginalDisplay] : "none";
    el[vShowHidden] = !value;
  }
  const CSS_VAR_TEXT = Symbol("CSS_VAR_TEXT");
  const displayRE = /(^|;)\s*display\s*:/;
  function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString$1(next);
    let hasControlledDisplay = false;
    if (next && !isCssString) {
      if (prev) {
        if (!isString$1(prev)) {
          for (const key2 in prev) {
            if (next[key2] == null) {
              setStyle$1(style, key2, "");
            }
          }
        } else {
          for (const prevStyle of prev.split(";")) {
            const key2 = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
            if (next[key2] == null) {
              setStyle$1(style, key2, "");
            }
          }
        }
      }
      for (const key2 in next) {
        if (key2 === "display") {
          hasControlledDisplay = true;
        }
        setStyle$1(style, key2, next[key2]);
      }
    } else {
      if (isCssString) {
        if (prev !== next) {
          const cssVarText = style[CSS_VAR_TEXT];
          if (cssVarText) {
            next += ";" + cssVarText;
          }
          style.cssText = next;
          hasControlledDisplay = displayRE.test(next);
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
    }
    if (vShowOriginalDisplay in el) {
      el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
      if (el[vShowHidden]) {
        style.display = "none";
      }
    }
  }
  const semicolonRE = /[^\\];\s*$/;
  const importantRE = /\s*!important$/;
  function setStyle$1(style, name, val) {
    if (isArray$1(val)) {
      val.forEach((v) => setStyle$1(style, name, v));
    } else {
      if (val == null) val = "";
      {
        if (semicolonRE.test(val)) {
          warn(
            `Unexpected semicolon at the end of '${name}' style value: '${val}'`
          );
        }
      }
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(
            hyphenate(prefixed),
            val.replace(importantRE, ""),
            "important"
          );
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  const prefixes = ["Webkit", "Moz", "ms"];
  const prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize$1(name);
    for (let i = 0; i < prefixes.length; i++) {
      const prefixed = prefixes[i] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  const xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key2, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key2)) {
    if (isSVG && key2.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key2.slice(6, key2.length));
      } else {
        el.setAttributeNS(xlinkNS, key2, value);
      }
    } else {
      if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
        el.removeAttribute(key2);
      } else {
        el.setAttribute(
          key2,
          isBoolean2 ? "" : isSymbol$1(value) ? String(value) : value
        );
      }
    }
  }
  function patchDOMProp(el, key2, value, parentComponent, attrName) {
    if (key2 === "innerHTML" || key2 === "textContent") {
      if (value != null) {
        el[key2] = key2 === "innerHTML" ? unsafeToTrustedHTML(value) : value;
      }
      return;
    }
    const tag = el.tagName;
    if (key2 === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
      const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
      const newValue = value == null ? (
        // #11647: value should be set as empty string for null and undefined,
        // but <input type="checkbox"> should be set as 'on'.
        el.type === "checkbox" ? "on" : ""
      ) : String(value);
      if (oldValue !== newValue || !("_value" in el)) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key2);
      }
      el._value = value;
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type = typeof el[key2];
      if (type === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type === "string") {
        value = "";
        needRemove = true;
      } else if (type === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key2] = value;
    } catch (e) {
      if (!needRemove) {
        warn(
          `Failed setting prop "${key2}" on <${tag.toLowerCase()}>: value ${value} is invalid.`,
          e
        );
      }
    }
    needRemove && el.removeAttribute(attrName || key2);
  }
  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  const veiKey = Symbol("_vei");
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = sanitizeEventValue(nextValue, rawName);
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(
          sanitizeEventValue(nextValue, rawName),
          instance
        );
        addEventListener(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m;
      while (m = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m[0].length);
        options[m[0].toLowerCase()] = true;
      }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options];
  }
  let cachedNow = 0;
  const p = /* @__PURE__ */ Promise.resolve();
  const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      if (!e._vts) {
        e._vts = Date.now();
      } else if (e._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e, invoker.value),
        instance,
        5,
        [e]
      );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function sanitizeEventValue(value, propName) {
    if (isFunction$1(value) || isArray$1(value)) {
      return value;
    }
    warn(
      `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof value}.`
    );
    return NOOP;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray$1(value)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map(
        (fn2) => (e2) => !e2._stopped && fn2 && fn2(e2)
      );
    } else {
      return value;
    }
  }
  const isNativeOn = (key2) => key2.charCodeAt(0) === 111 && key2.charCodeAt(1) === 110 && // lowercase letter
    key2.charCodeAt(2) > 96 && key2.charCodeAt(2) < 123;
  const patchProp = (el, key2, prevValue, nextValue, namespace, parentComponent) => {
    const isSVG = namespace === "svg";
    if (key2 === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key2 === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key2)) {
      if (!isModelListener(key2)) {
        patchEvent(el, key2, prevValue, nextValue, parentComponent);
      }
    } else if (key2[0] === "." ? (key2 = key2.slice(1), true) : key2[0] === "^" ? (key2 = key2.slice(1), false) : shouldSetAsProp(el, key2, nextValue, isSVG)) {
      patchDOMProp(el, key2, nextValue);
      if (!el.tagName.includes("-") && (key2 === "value" || key2 === "checked" || key2 === "selected")) {
        patchAttr(el, key2, nextValue, isSVG, parentComponent, key2 !== "value");
      }
    } else if (
      // #11081 force set props for possible async custom element
      el._isVueCE && (/[A-Z]/.test(key2) || !isString$1(nextValue))
    ) {
      patchDOMProp(el, camelize(key2), nextValue, parentComponent, key2);
    } else {
      if (key2 === "true-value") {
        el._trueValue = nextValue;
      } else if (key2 === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key2, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key2, value, isSVG) {
    if (isSVG) {
      if (key2 === "innerHTML" || key2 === "textContent") {
        return true;
      }
      if (key2 in el && isNativeOn(key2) && isFunction$1(value)) {
        return true;
      }
      return false;
    }
    if (key2 === "spellcheck" || key2 === "draggable" || key2 === "translate") {
      return false;
    }
    if (key2 === "form") {
      return false;
    }
    if (key2 === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key2 === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (key2 === "width" || key2 === "height") {
      const tag = el.tagName;
      if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key2) && isString$1(value)) {
      return false;
    }
    return key2 in el;
  }
  const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
  let renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  const createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    {
      injectNativeTagCheck(app);
      injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container) return;
      const component = app._component;
      if (!isFunction$1(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      if (container.nodeType === 1) {
        container.textContent = "";
      }
      const proxy = mount(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  };
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function injectNativeTagCheck(app) {
    Object.defineProperty(app.config, "isNativeTag", {
      value: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
      writable: false
    });
  }
  function injectCompilerOptionsCheck(app) {
    {
      const isCustomElement = app.config.isCustomElement;
      Object.defineProperty(app.config, "isCustomElement", {
        get() {
          return isCustomElement;
        },
        set() {
          warn(
            `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
          );
        }
      });
      const compilerOptions = app.config.compilerOptions;
      const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
      Object.defineProperty(app.config, "compilerOptions", {
        get() {
          warn(msg);
          return compilerOptions;
        },
        set() {
          warn(msg);
        }
      });
    }
  }
  function normalizeContainer(container) {
    if (isString$1(container)) {
      const res = document.querySelector(container);
      if (!res) {
        warn(
          `Failed to mount app: mount target selector "${container}" returned null.`
        );
      }
      return res;
    }
    if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
      warn(
        `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
      );
    }
    return container;
  }
  /**
  * vue v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  function initDev() {
    {
      initCustomFormatter();
    }
  }
  {
    initDev();
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function _arrayLikeToArray$4(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _unsupportedIterableToArray$4(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray$4(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$4(r, a) : void 0;
    }
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray$4(r);
  }
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray$4(r) || _nonIterableSpread();
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function _typeof$2(o) {
    "@babel/helpers - typeof";
    return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o2) {
      return typeof o2;
    } : function (o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof$2(o);
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function toPrimitive(t, r) {
    if ("object" != _typeof$2(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r);
      if ("object" != _typeof$2(i)) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function toPropertyKey(t) {
    var i = toPrimitive(t, "string");
    return "symbol" == _typeof$2(i) ? i : i + "";
  }
  function _defineProperty$1(e, r, t) {
    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r] = t, e;
  }
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root$1 = freeGlobal || freeSelf || Function("return this")();
  var Symbol$1 = root$1.Symbol;
  var objectProto$f = Object.prototype;
  var hasOwnProperty$d = objectProto$f.hasOwnProperty;
  var nativeObjectToString$1 = objectProto$f.toString;
  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty$d.call(value, symToStringTag$1), tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }
  var objectProto$e = Object.prototype;
  var nativeObjectToString = objectProto$e.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  var symbolTag$3 = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
  }
  function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  var isArray = Array.isArray;
  var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  var reWhitespace = /\s/;
  function trimmedEndIndex(string) {
    var index = string.length;
    while (index-- && reWhitespace.test(string.charAt(index))) {
    }
    return index;
  }
  var reTrimStart = /^\s+/;
  function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
  }
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  function identity(value) {
    return value;
  }
  var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
  }
  var coreJsData = root$1["__core-js_shared__"];
  var maskSrcKey = function () {
    var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid2 ? "Symbol(src)_1." + uid2 : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var funcProto$2 = Function.prototype;
  var funcToString$2 = funcProto$2.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$2.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto$1 = Function.prototype, objectProto$d = Object.prototype;
  var funcToString$1 = funcProto$1.toString;
  var hasOwnProperty$c = objectProto$d.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString$1.call(hasOwnProperty$c).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function getValue(object, key2) {
    return object == null ? void 0 : object[key2];
  }
  function getNative(object, key2) {
    var value = getValue(object, key2);
    return baseIsNative(value) ? value : void 0;
  }
  var WeakMap$1 = getNative(root$1, "WeakMap");
  var objectCreate = Object.create;
  var baseCreate = /* @__PURE__ */ function () {
    function object() {
    }
    return function (proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function () {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  function constant(value) {
    return function () {
      return value;
    };
  }
  var defineProperty = function () {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  var baseSetToString = !defineProperty ? identity : function (func, string) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant(string),
      "writable": true
    });
  };
  var setToString = shortOut(baseSetToString);
  function arrayEach(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + -1;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function baseAssignValue(object, key2, value) {
    if (key2 == "__proto__" && defineProperty) {
      defineProperty(object, key2, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object[key2] = value;
    }
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  var objectProto$c = Object.prototype;
  var hasOwnProperty$b = objectProto$c.hasOwnProperty;
  function assignValue(object, key2, value) {
    var objValue = object[key2];
    if (!(hasOwnProperty$b.call(object, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object)) {
      baseAssignValue(object, key2, value);
    }
  }
  function copyObject(source, props2, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1, length = props2.length;
    while (++index < length) {
      var key2 = props2[index];
      var newValue = void 0;
      if (newValue === void 0) {
        newValue = source[key2];
      }
      if (isNew) {
        baseAssignValue(object, key2, newValue);
      } else {
        assignValue(object, key2, newValue);
      }
    }
    return object;
  }
  var nativeMax$1 = Math.max;
  function overRest(func, start2, transform) {
    start2 = nativeMax$1(start2 === void 0 ? func.length - 1 : start2, 0);
    return function () {
      var args = arguments, index = -1, length = nativeMax$1(args.length - start2, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start2 + index];
      }
      index = -1;
      var otherArgs = Array(start2 + 1);
      while (++index < start2) {
        otherArgs[index] = args[index];
      }
      otherArgs[start2] = transform(array);
      return apply(func, this, otherArgs);
    };
  }
  function baseRest(func, start2) {
    return setToString(overRest(func, start2, identity), func + "");
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
      return eq(object[index], value);
    }
    return false;
  }
  function createAssigner(assigner) {
    return baseRest(function (object, sources) {
      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }
  var objectProto$b = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$b;
    return value === proto;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  var argsTag$3 = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$3;
  }
  var objectProto$a = Object.prototype;
  var hasOwnProperty$a = objectProto$a.hasOwnProperty;
  var propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable;
  var isArguments = baseIsArguments(/* @__PURE__ */ function () {
    return arguments;
  }()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty$a.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
  };
  function stubFalse() {
    return false;
  }
  var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
  var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0;
  var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
  var isBuffer = nativeIsBuffer || stubFalse;
  var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$4 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$4 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$4 = "[object String]", weakMapTag$2 = "[object WeakMap]";
  var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
  typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$4] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$4] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }
  var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
  var freeProcess = moduleExports$1 && freeGlobal.process;
  var nodeUtil = function () {
    try {
      var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  var objectProto$9 = Object.prototype;
  var hasOwnProperty$9 = objectProto$9.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key2 in value) {
      if ((inherited || hasOwnProperty$9.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
          isIndex(key2, length)))) {
        result.push(key2);
      }
    }
    return result;
  }
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }
  var nativeKeys = overArg(Object.keys, Object);
  var objectProto$8 = Object.prototype;
  var hasOwnProperty$8 = objectProto$8.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key2 in Object(object)) {
      if (hasOwnProperty$8.call(object, key2) && key2 != "constructor") {
        result.push(key2);
      }
    }
    return result;
  }
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key2 in Object(object)) {
        result.push(key2);
      }
    }
    return result;
  }
  var objectProto$7 = Object.prototype;
  var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key2 in object) {
      if (!(key2 == "constructor" && (isProto || !hasOwnProperty$7.call(object, key2)))) {
        result.push(key2);
      }
    }
    return result;
  }
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  var nativeCreate = getNative(Object, "create");
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key2) {
    var result = this.has(key2) && delete this.__data__[key2];
    this.size -= result ? 1 : 0;
    return result;
  }
  var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
  var objectProto$6 = Object.prototype;
  var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
  function hashGet(key2) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key2];
      return result === HASH_UNDEFINED$2 ? void 0 : result;
    }
    return hasOwnProperty$6.call(data, key2) ? data[key2] : void 0;
  }
  var objectProto$5 = Object.prototype;
  var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
  function hashHas(key2) {
    var data = this.__data__;
    return nativeCreate ? data[key2] !== void 0 : hasOwnProperty$5.call(data, key2);
  }
  var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
  function hashSet(key2, value) {
    var data = this.__data__;
    this.size += this.has(key2) ? 0 : 1;
    data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
    return this;
  }
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function assocIndexOf(array, key2) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key2)) {
        return length;
      }
    }
    return -1;
  }
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key2) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key2) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key2) {
    return assocIndexOf(this.__data__, key2) > -1;
  }
  function listCacheSet(key2, value) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    if (index < 0) {
      ++this.size;
      data.push([key2, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  var Map$1 = getNative(root$1, "Map");
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map$1 || ListCache)(),
      "string": new Hash()
    };
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function getMapData(map2, key2) {
    var data = map2.__data__;
    return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
  }
  function mapCacheDelete(key2) {
    var result = getMapData(this, key2)["delete"](key2);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key2) {
    return getMapData(this, key2).get(key2);
  }
  function mapCacheHas(key2) {
    return getMapData(this, key2).has(key2);
  }
  function mapCacheSet(key2, value) {
    var data = getMapData(this, key2), size = data.size;
    data.set(key2, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  var FUNC_ERROR_TEXT$1 = "Expected a function";
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    var memoized = function () {
      var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key2)) {
        return cache.get(key2);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key2, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }
  memoize.Cache = MapCache;
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize(func, function (key2) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key2;
    });
    var cache = result.cache;
    return result;
  }
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function (string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function (match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  function baseGet(object, path) {
    path = castPath(path, object);
    var index = 0, length = path.length;
    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return index && index == length ? object : void 0;
  }
  function get(object, path, defaultValue) {
    var result = object == null ? void 0 : baseGet(object, path);
    return result === void 0 ? defaultValue : result;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset2 = array.length;
    while (++index < length) {
      array[offset2 + index] = values[index];
    }
    return array;
  }
  var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
      var value = array[index];
      if (predicate(value)) {
        {
          arrayPush(result, value);
        }
      } else {
        result[result.length] = value;
      }
    }
    return result;
  }
  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array) : [];
  }
  function flatRest(func) {
    return setToString(overRest(func, void 0, flatten), func + "");
  }
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  var objectTag$3 = "[object Object]";
  var funcProto = Function.prototype, objectProto$4 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty$4.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  function baseSlice(array, start2, end2) {
    var index = -1, length = array.length;
    if (start2 < 0) {
      start2 = -start2 > length ? 0 : length + start2;
    }
    end2 = end2 > length ? length : end2;
    if (end2 < 0) {
      end2 += length;
    }
    length = start2 > end2 ? 0 : end2 - start2 >>> 0;
    start2 >>>= 0;
    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start2];
    }
    return result;
  }
  function castSlice(array, start2, end2) {
    var length = array.length;
    end2 = end2 === void 0 ? length : end2;
    return baseSlice(array, start2, end2);
  }
  var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f";
  var rsZWJ$2 = "\\u200d";
  var reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }
  function asciiToArray(string) {
    return string.split("");
  }
  var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = "\\ufe0e\\ufe0f";
  var rsAstral = "[" + rsAstralRange$1 + "]", rsCombo$2 = "[" + rsComboRange$2 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d";
  var reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")";
  var reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }
  function stringToArray(string) {
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }
  function createCaseFirst(methodName) {
    return function (string) {
      string = toString(string);
      var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
      var chr = strSymbols ? strSymbols[0] : string.charAt(0);
      var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
      return chr[methodName]() + trailing;
    };
  }
  var upperFirst = createCaseFirst("toUpperCase");
  function capitalize(string) {
    return upperFirst(toString(string).toLowerCase());
  }
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function basePropertyOf(object) {
    return function (key2) {
      return object == null ? void 0 : object[key2];
    };
  }
  var deburredLetters = {
    // Latin-1 Supplement block.
    "À": "A",
    "Á": "A",
    "Â": "A",
    "Ã": "A",
    "Ä": "A",
    "Å": "A",
    "à": "a",
    "á": "a",
    "â": "a",
    "ã": "a",
    "ä": "a",
    "å": "a",
    "Ç": "C",
    "ç": "c",
    "Ð": "D",
    "ð": "d",
    "È": "E",
    "É": "E",
    "Ê": "E",
    "Ë": "E",
    "è": "e",
    "é": "e",
    "ê": "e",
    "ë": "e",
    "Ì": "I",
    "Í": "I",
    "Î": "I",
    "Ï": "I",
    "ì": "i",
    "í": "i",
    "î": "i",
    "ï": "i",
    "Ñ": "N",
    "ñ": "n",
    "Ò": "O",
    "Ó": "O",
    "Ô": "O",
    "Õ": "O",
    "Ö": "O",
    "Ø": "O",
    "ò": "o",
    "ó": "o",
    "ô": "o",
    "õ": "o",
    "ö": "o",
    "ø": "o",
    "Ù": "U",
    "Ú": "U",
    "Û": "U",
    "Ü": "U",
    "ù": "u",
    "ú": "u",
    "û": "u",
    "ü": "u",
    "Ý": "Y",
    "ý": "y",
    "ÿ": "y",
    "Æ": "Ae",
    "æ": "ae",
    "Þ": "Th",
    "þ": "th",
    "ß": "ss",
    // Latin Extended-A block.
    "Ā": "A",
    "Ă": "A",
    "Ą": "A",
    "ā": "a",
    "ă": "a",
    "ą": "a",
    "Ć": "C",
    "Ĉ": "C",
    "Ċ": "C",
    "Č": "C",
    "ć": "c",
    "ĉ": "c",
    "ċ": "c",
    "č": "c",
    "Ď": "D",
    "Đ": "D",
    "ď": "d",
    "đ": "d",
    "Ē": "E",
    "Ĕ": "E",
    "Ė": "E",
    "Ę": "E",
    "Ě": "E",
    "ē": "e",
    "ĕ": "e",
    "ė": "e",
    "ę": "e",
    "ě": "e",
    "Ĝ": "G",
    "Ğ": "G",
    "Ġ": "G",
    "Ģ": "G",
    "ĝ": "g",
    "ğ": "g",
    "ġ": "g",
    "ģ": "g",
    "Ĥ": "H",
    "Ħ": "H",
    "ĥ": "h",
    "ħ": "h",
    "Ĩ": "I",
    "Ī": "I",
    "Ĭ": "I",
    "Į": "I",
    "İ": "I",
    "ĩ": "i",
    "ī": "i",
    "ĭ": "i",
    "į": "i",
    "ı": "i",
    "Ĵ": "J",
    "ĵ": "j",
    "Ķ": "K",
    "ķ": "k",
    "ĸ": "k",
    "Ĺ": "L",
    "Ļ": "L",
    "Ľ": "L",
    "Ŀ": "L",
    "Ł": "L",
    "ĺ": "l",
    "ļ": "l",
    "ľ": "l",
    "ŀ": "l",
    "ł": "l",
    "Ń": "N",
    "Ņ": "N",
    "Ň": "N",
    "Ŋ": "N",
    "ń": "n",
    "ņ": "n",
    "ň": "n",
    "ŋ": "n",
    "Ō": "O",
    "Ŏ": "O",
    "Ő": "O",
    "ō": "o",
    "ŏ": "o",
    "ő": "o",
    "Ŕ": "R",
    "Ŗ": "R",
    "Ř": "R",
    "ŕ": "r",
    "ŗ": "r",
    "ř": "r",
    "Ś": "S",
    "Ŝ": "S",
    "Ş": "S",
    "Š": "S",
    "ś": "s",
    "ŝ": "s",
    "ş": "s",
    "š": "s",
    "Ţ": "T",
    "Ť": "T",
    "Ŧ": "T",
    "ţ": "t",
    "ť": "t",
    "ŧ": "t",
    "Ũ": "U",
    "Ū": "U",
    "Ŭ": "U",
    "Ů": "U",
    "Ű": "U",
    "Ų": "U",
    "ũ": "u",
    "ū": "u",
    "ŭ": "u",
    "ů": "u",
    "ű": "u",
    "ų": "u",
    "Ŵ": "W",
    "ŵ": "w",
    "Ŷ": "Y",
    "ŷ": "y",
    "Ÿ": "Y",
    "Ź": "Z",
    "Ż": "Z",
    "Ž": "Z",
    "ź": "z",
    "ż": "z",
    "ž": "z",
    "Ĳ": "IJ",
    "ĳ": "ij",
    "Œ": "Oe",
    "œ": "oe",
    "ŉ": "'n",
    "ſ": "s"
  };
  var deburrLetter = basePropertyOf(deburredLetters);
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
  var rsCombo$1 = "[" + rsComboRange$1 + "]";
  var reComboMark = RegExp(rsCombo$1, "g");
  function deburr(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
  }
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos$1 = "['’]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
  var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
  var reUnicodeWord = RegExp([
    rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
    rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
    rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
    rsUpper + "+" + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join("|"), "g");
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }
  function words(string, pattern, guard) {
    string = toString(string);
    pattern = pattern;
    if (pattern === void 0) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  }
  var rsApos = "['’]";
  var reApos = RegExp(rsApos, "g");
  function createCompounder(callback) {
    return function (string) {
      return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
    };
  }
  var camelCase = createCompounder(function (result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize(word) : word);
  });
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key2) {
    var data = this.__data__, result = data["delete"](key2);
    this.size = data.size;
    return result;
  }
  function stackGet(key2) {
    return this.__data__.get(key2);
  }
  function stackHas(key2) {
    return this.__data__.has(key2);
  }
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key2, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key2, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key2, value);
    this.size = data.size;
    return this;
  }
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }
  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
  function cloneBuffer(buffer2, isDeep) {
    if (isDeep) {
      return buffer2.slice();
    }
    var length = buffer2.length, result = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
    buffer2.copy(result);
    return result;
  }
  function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function stubArray() {
    return [];
  }
  var objectProto$3 = Object.prototype;
  var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
  var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols$1 ? stubArray : function (object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols$1(object), function (symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
    var result = [];
    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }
    return result;
  };
  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }
  var DataView = getNative(root$1, "DataView");
  var Promise$1 = getNative(root$1, "Promise");
  var Set$1 = getNative(root$1, "Set");
  var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
  var dataViewTag$3 = "[object DataView]";
  var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
  var getTag = baseGetTag;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
    getTag = function (value) {
      var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$3;
          case mapCtorString:
            return mapTag$4;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag$4;
          case weakMapCtorString:
            return weakMapTag$1;
        }
      }
      return result;
    };
  }
  var objectProto$2 = Object.prototype;
  var hasOwnProperty$3 = objectProto$2.hasOwnProperty;
  function initCloneArray(array) {
    var length = array.length, result = new array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty$3.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  var Uint8Array = root$1.Uint8Array;
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
  }
  var reFlags = /\w*$/;
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
  function cloneSymbol(symbol) {
    return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
  }
  var boolTag$3 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$3 = "[object String]", symbolTag$2 = "[object Symbol]";
  var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag$2:
        return cloneArrayBuffer(object);
      case boolTag$3:
      case dateTag$2:
        return new Ctor(+object);
      case dataViewTag$2:
        return cloneDataView(object, isDeep);
      case float32Tag$1:
      case float64Tag$1:
      case int8Tag$1:
      case int16Tag$1:
      case int32Tag$1:
      case uint8Tag$1:
      case uint8ClampedTag$1:
      case uint16Tag$1:
      case uint32Tag$1:
        return cloneTypedArray(object, isDeep);
      case mapTag$3:
        return new Ctor();
      case numberTag$3:
      case stringTag$3:
        return new Ctor(object);
      case regexpTag$2:
        return cloneRegExp(object);
      case setTag$3:
        return new Ctor();
      case symbolTag$2:
        return cloneSymbol(object);
    }
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  var mapTag$2 = "[object Map]";
  function baseIsMap(value) {
    return isObjectLike(value) && getTag(value) == mapTag$2;
  }
  var nodeIsMap = nodeUtil && nodeUtil.isMap;
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  var setTag$2 = "[object Set]";
  function baseIsSet(value) {
    return isObjectLike(value) && getTag(value) == setTag$2;
  }
  var nodeIsSet = nodeUtil && nodeUtil.isSet;
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  var CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4;
  var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$2 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$2 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$2] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$2] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  function baseClone(value, bitmask, customizer, key2, object, stack2) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
    if (customizer) {
      result = object ? customizer(value, key2, object, stack2) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
        result = isFlat || isFunc ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    stack2 || (stack2 = new Stack());
    var stacked = stack2.get(value);
    if (stacked) {
      return stacked;
    }
    stack2.set(value, result);
    if (isSet(value)) {
      value.forEach(function (subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
      });
    } else if (isMap(value)) {
      value.forEach(function (subValue, key3) {
        result.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
      });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
    var props2 = isArr ? void 0 : keysFunc(value);
    arrayEach(props2 || value, function (subValue, key3) {
      if (props2) {
        key3 = subValue;
        subValue = value[key3];
      }
      assignValue(result, key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
    });
    return result;
  }
  var CLONE_DEEP_FLAG$1 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
  }
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  function cacheHas(cache, key2) {
    return cache.has(key2);
  }
  var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack2.get(array);
    var othStacked = stack2.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
    stack2.set(array, other);
    stack2.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack2) : customizer(arrValue, othValue, index, array, other, stack2);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function (othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
        result = false;
        break;
      }
    }
    stack2["delete"](array);
    stack2["delete"](other);
    return result;
  }
  function mapToArray(map2) {
    var index = -1, result = Array(map2.size);
    map2.forEach(function (value, key2) {
      result[++index] = [key2, value];
    });
    return result;
  }
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }
  var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
  var boolTag$1 = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag$1 = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag$1 = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
  var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }
        return true;
      case boolTag$1:
      case dateTag:
      case numberTag$1:
        return eq(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag$1:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack2.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG$2;
        stack2.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
        stack2["delete"](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  var COMPARE_PARTIAL_FLAG$3 = 1;
  var objectProto$1 = Object.prototype;
  var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key2 = objProps[index];
      if (!(isPartial ? key2 in other : hasOwnProperty$2.call(other, key2))) {
        return false;
      }
    }
    var objStacked = stack2.get(object);
    var othStacked = stack2.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack2.set(object, other);
    stack2.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key2 = objProps[index];
      var objValue = object[key2], othValue = other[key2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack2) : customizer(objValue, othValue, key2, object, other, stack2);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key2 == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack2["delete"](object);
    stack2["delete"](other);
    return result;
  }
  var COMPARE_PARTIAL_FLAG$2 = 1;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
  var objectProto = Object.prototype;
  var hasOwnProperty$1 = objectProto.hasOwnProperty;
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack2 || (stack2 = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
      var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack2 || (stack2 = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack2 || (stack2 = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
  }
  function baseIsEqual(value, other, bitmask, customizer, stack2) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
  }
  var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length = index;
    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if (data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key2 = data[0], objValue = object[key2], srcValue = data[1];
      if (data[2]) {
        if (objValue === void 0 && !(key2 in object)) {
          return false;
        }
      } else {
        var stack2 = new Stack();
        var result;
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }
  function getMatchData(object) {
    var result = keys(object), length = result.length;
    while (length--) {
      var key2 = result[length], value = object[key2];
      result[length] = [key2, value, isStrictComparable(value)];
    }
    return result;
  }
  function matchesStrictComparable(key2, srcValue) {
    return function (object) {
      if (object == null) {
        return false;
      }
      return object[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object));
    };
  }
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function (object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }
  function baseHasIn(object, key2) {
    return object != null && key2 in Object(object);
  }
  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
    var index = -1, length = path.length, result = false;
    while (++index < length) {
      var key2 = toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key2))) {
        break;
      }
      object = object[key2];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key2, length) && (isArray(object) || isArguments(object));
  }
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function (object) {
      var objValue = get(object, path);
      return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  function baseProperty(key2) {
    return function (object) {
      return object == null ? void 0 : object[key2];
    };
  }
  function basePropertyDeep(path) {
    return function (object) {
      return baseGet(object, path);
    };
  }
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (typeof value == "object") {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
      var index = -1, iterable = Object(object), props2 = keysFunc(object), length = props2.length;
      while (length--) {
        var key2 = props2[++index];
        if (iteratee(iterable[key2], key2, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  var baseFor = createBaseFor();
  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }
  var now$1 = function () {
    return root$1.Date.now();
  };
  var FUNC_ERROR_TEXT = "Expected a function";
  var nativeMax = Math.max, nativeMin$1 = Math.min;
  function debounce$1(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now$1();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now$1());
    }
    function debounced() {
      var time = now$1(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  function assignMergeValue(object, key2, value) {
    if (value !== void 0 && !eq(object[key2], value) || value === void 0 && !(key2 in object)) {
      baseAssignValue(object, key2, value);
    }
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function safeGet(object, key2) {
    if (key2 === "constructor" && typeof object[key2] === "function") {
      return;
    }
    if (key2 == "__proto__") {
      return;
    }
    return object[key2];
  }
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  function baseMergeDeep(object, source, key2, srcIndex, mergeFunc, customizer, stack2) {
    var objValue = safeGet(object, key2), srcValue = safeGet(source, key2), stacked = stack2.get(srcValue);
    if (stacked) {
      assignMergeValue(object, key2, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source, stack2) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject(objValue) || isFunction(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack2.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
      stack2["delete"](srcValue);
    }
    assignMergeValue(object, key2, newValue);
  }
  function baseMerge(object, source, srcIndex, customizer, stack2) {
    if (object === source) {
      return;
    }
    baseFor(source, function (srcValue, key2) {
      stack2 || (stack2 = new Stack());
      if (isObject(srcValue)) {
        baseMergeDeep(object, source, key2, srcIndex, baseMerge, customizer, stack2);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source, stack2) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object, key2, newValue);
      }
    }, keysIn);
  }
  function last$1(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : void 0;
  }
  var stringTag = "[object String]";
  function isString(value) {
    return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
  }
  var nativeMin = Math.min;
  function baseIntersection(arrays, iteratee, comparator) {
    var includes = arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
    while (othIndex--) {
      var array = arrays[othIndex];
      maxLength = nativeMin(array.length, maxLength);
      caches[othIndex] = length >= 120 && array.length >= 120 ? new SetCache(othIndex && array) : void 0;
    }
    array = arrays[0];
    var index = -1, seen = caches[0];
    outer:
    while (++index < length && result.length < maxLength) {
      var value = array[index], computed2 = value;
      value = value !== 0 ? value : 0;
      if (!(seen ? cacheHas(seen, computed2) : includes(result, computed2))) {
        othIndex = othLength;
        while (--othIndex) {
          var cache = caches[othIndex];
          if (!(cache ? cacheHas(cache, computed2) : includes(arrays[othIndex], computed2))) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed2);
        }
        result.push(value);
      }
    }
    return result;
  }
  function castArrayLikeObject(value) {
    return isArrayLikeObject(value) ? value : [];
  }
  var intersection = baseRest(function (arrays) {
    var mapped = arrayMap(arrays, castArrayLikeObject);
    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
  });
  function parent(object, path) {
    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
  }
  var boolTag = "[object Boolean]";
  function isBoolean(value) {
    return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
  }
  function isEqual(value, other) {
    return baseIsEqual(value, other);
  }
  var numberTag = "[object Number]";
  function isNumber(value) {
    return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
  }
  function isNull(value) {
    return value === null;
  }
  function isUndefined(value) {
    return value === void 0;
  }
  var kebabCase = createCompounder(function (result, word, index) {
    return result + (index ? "-" : "") + word.toLowerCase();
  });
  function mapKeys(object, iteratee) {
    var result = {};
    iteratee = baseIteratee(iteratee);
    baseForOwn(object, function (value, key2, object2) {
      baseAssignValue(result, iteratee(value, key2, object2), value);
    });
    return result;
  }
  var merge = createAssigner(function (object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });
  function baseUnset(object, path) {
    path = castPath(path, object);
    object = parent(object, path);
    return object == null || delete object[toKey(last$1(path))];
  }
  function customOmitClone(value) {
    return isPlainObject(value) ? void 0 : value;
  }
  var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
  var omit = flatRest(function (object, paths) {
    var result = {};
    if (object == null) {
      return result;
    }
    var isDeep = false;
    paths = arrayMap(paths, function (path) {
      path = castPath(path, object);
      isDeep || (isDeep = path.length > 1);
      return path;
    });
    copyObject(object, getAllKeysIn(object), result);
    if (isDeep) {
      result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
    }
    var length = paths.length;
    while (length--) {
      baseUnset(result, paths[length]);
    }
    return result;
  });
  function baseSet(object, path, value, customizer) {
    if (!isObject(object)) {
      return object;
    }
    path = castPath(path, object);
    var index = -1, length = path.length, lastIndex = length - 1, nested = object;
    while (nested != null && ++index < length) {
      var key2 = toKey(path[index]), newValue = value;
      if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
        return object;
      }
      if (index != lastIndex) {
        var objValue = nested[key2];
        newValue = void 0;
        if (newValue === void 0) {
          newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
        }
      }
      assignValue(nested, key2, newValue);
      nested = nested[key2];
    }
    return object;
  }
  function basePickBy(object, paths, predicate) {
    var index = -1, length = paths.length, result = {};
    while (++index < length) {
      var path = paths[index], value = baseGet(object, path);
      if (predicate(value, path)) {
        baseSet(result, castPath(path, object), value);
      }
    }
    return result;
  }
  function basePick(object, paths) {
    return basePickBy(object, paths, function (value, path) {
      return hasIn(object, path);
    });
  }
  var pick = flatRest(function (object, paths) {
    return object == null ? {} : basePick(object, paths);
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
  }
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e, n, i, u, a = [], f = true, o = false;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t) return;
          f = false;
        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true);
      } catch (r2) {
        o = true, n = r2;
      } finally {
        try {
          if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray$4(r, e) || _nonIterableRest();
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var dayjs_min = { exports: {} };
  (function (module2, exports2) {
    !function (t, e) {
      module2.exports = e();
    }(commonjsGlobal, function () {
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h2 = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = {
        name: "en",
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        ordinal: function ordinal(t2) {
          var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
          return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
        }
      }, m = function m2(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = {
        s: m,
        z: function z(t2) {
          var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
          return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
        },
        m: function t2(e2, n2) {
          if (e2.date() < n2.date()) return -t2(n2, e2);
          var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
          return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
        },
        a: function a2(t2) {
          return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
        },
        p: function p3(t2) {
          return {
            M: c,
            y: h2,
            w: o,
            d: a,
            D: d,
            h: u,
            m: s,
            s: i,
            ms: r,
            Q: f
          }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
        },
        u: function u2(t2) {
          return void 0 === t2;
        }
      }, g = "en", D = {};
      D[g] = M;
      var p2 = "$isDayjsObject", S = function S2(t2) {
        return t2 instanceof _ || !(!t2 || !t2[p2]);
      }, w = function t2(e2, n2, r2) {
        var i2;
        if (!e2) return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1) return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O = function O2(t2, e2) {
        if (S(t2)) return t2.clone();
        var n2 = "object" == _typeof$2(e2) ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, b = v;
      b.l = w, b.i = S, b.w = function (t2, e2) {
        return O(t2, {
          locale: e2.$L,
          utc: e2.$u,
          x: e2.$x,
          $offset: e2.$offset
        });
      };
      var _ = function () {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p2] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function (t2) {
          this.$d = function (t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2) return /* @__PURE__ */ new Date(NaN);
            if (b.u(e2)) return /* @__PURE__ */ new Date();
            if (e2 instanceof Date) return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.init();
        }, m2.init = function () {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function () {
          return b;
        }, m2.isValid = function () {
          return !(this.$d.toString() === l);
        }, m2.isSame = function (t2, e2) {
          var n2 = O(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function (t2, e2) {
          return O(t2) < this.startOf(e2);
        }, m2.isBefore = function (t2, e2) {
          return this.endOf(e2) < O(t2);
        }, m2.$g = function (t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function () {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function () {
          return this.$d.getTime();
        }, m2.startOf = function (t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function l3(t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function $3(t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h2:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function (t2) {
          return this.startOf(t2, false);
        }, m2.$set = function (t2, e2) {
          var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h2] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h2) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function (t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function (t2) {
          return this[b.p(t2)]();
        }, m2.add = function (r2, f2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f2), y2 = function y3(t2) {
            var e2 = O(l2);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === c) return this.set(c, this.$M + r2);
          if ($2 === h2) return this.set(h2, this.$y + r2);
          if ($2 === a) return y2(1);
          if ($2 === o) return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function (t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function (t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid()) return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h3 = function h4(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function d3(t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, $2 = f2 || function (t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, function (t3, r3) {
            return r3 || function (t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h3(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h3(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h3(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h3(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t3) || i2.replace(":", "");
          });
        }, m2.utcOffset = function () {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function (r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function D3() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h2:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function () {
          return this.endOf(c).$D;
        }, m2.$locale = function () {
          return D[this.$L];
        }, m2.locale = function (t2, e2) {
          if (!t2) return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function () {
          return b.w(this.$d, this);
        }, m2.toDate = function () {
          return new Date(this.valueOf());
        }, m2.toJSON = function () {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function () {
          return this.$d.toISOString();
        }, m2.toString = function () {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h2], ["$D", d]].forEach(function (t2) {
        k[t2[1]] = function (e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), O.extend = function (t2, e2) {
        return t2.$i || (t2(e2, _, O), t2.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function (t2) {
        return O(1e3 * t2);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    });
  })(dayjs_min);
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var zhCn$2 = { exports: {} };
  (function (module2, exports2) {
    !function (e, _) {
      module2.exports = _(dayjs_min.exports);
    }(commonjsGlobal, function (e) {
      function _(e2) {
        return e2 && "object" == _typeof$2(e2) && "default" in e2 ? e2 : {
          "default": e2
        };
      }
      var t = _(e), d = {
        name: "zh-cn",
        weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
        weekdaysShort: "周日_周一_周二_周三_周四_周五_周六".split("_"),
        weekdaysMin: "日_一_二_三_四_五_六".split("_"),
        months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
        monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
        ordinal: function ordinal(e2, _2) {
          return "W" === _2 ? e2 + "周" : e2 + "日";
        },
        weekStart: 1,
        yearStart: 4,
        formats: {
          LT: "HH:mm",
          LTS: "HH:mm:ss",
          L: "YYYY/MM/DD",
          LL: "YYYY年M月D日",
          LLL: "YYYY年M月D日Ah点mm分",
          LLLL: "YYYY年M月D日ddddAh点mm分",
          l: "YYYY/M/D",
          ll: "YYYY年M月D日",
          lll: "YYYY年M月D日 HH:mm",
          llll: "YYYY年M月D日dddd HH:mm"
        },
        relativeTime: {
          future: "%s内",
          past: "%s前",
          s: "几秒",
          m: "1 分钟",
          mm: "%d 分钟",
          h: "1 小时",
          hh: "%d 小时",
          d: "1 天",
          dd: "%d 天",
          M: "1 个月",
          MM: "%d 个月",
          y: "1 年",
          yy: "%d 年"
        },
        meridiem: function meridiem(e2, _2) {
          var t2 = 100 * e2 + _2;
          return t2 < 600 ? "凌晨" : t2 < 900 ? "早上" : t2 < 1100 ? "上午" : t2 < 1300 ? "中午" : t2 < 1800 ? "下午" : "晚上";
        }
      };
      return t["default"].locale(d, null, true), d;
    });
  })(zhCn$2);
  var zhCn = {
    autoComplete: {
      empty: "暂无数据"
    },
    pagination: {
      itemsPerPage: "{size} 条/页",
      jumpTo: "跳至",
      page: "页",
      total: "共 {total} 条数据"
    },
    cascader: {
      empty: "暂无数据",
      loadingText: "加载中",
      placeholder: "请选择"
    },
    calendar: {
      yearSelection: "{year} 年",
      monthSelection: "{month} 月",
      yearRadio: "年",
      monthRadio: "月",
      hideWeekend: "隐藏周末",
      showWeekend: "显示周末",
      today: "今天",
      thisMonth: "本月",
      week: "一,二,三,四,五,六,日",
      cellMonth: "1 月,2 月,3 月,4 月,5 月,6 月,7 月,8 月,9 月,10 月,11 月,12 月"
    },
    transfer: {
      title: "{checked} / {total} 项",
      empty: "暂无数据",
      placeholder: "请输入关键词搜索"
    },
    timePicker: {
      dayjsLocale: "zh-cn",
      now: "此刻",
      confirm: "确定",
      anteMeridiem: "上午",
      postMeridiem: "下午",
      placeholder: "选择时间"
    },
    dialog: {
      confirm: "确认",
      cancel: "取消"
    },
    drawer: {
      confirm: "确认",
      cancel: "取消"
    },
    popconfirm: {
      confirm: {
        content: "确定"
      },
      cancel: {
        content: "取消"
      }
    },
    table: {
      empty: "暂无数据",
      loadingText: "正在加载中，请稍后",
      loadingMoreText: "点击加载更多",
      filterInputPlaceholder: "请输入内容（无默认值）",
      sortAscendingOperationText: "点击升序",
      sortCancelOperationText: "点击取消排序",
      sortDescendingOperationText: "点击降序",
      clearFilterResultButtonText: "清空筛选",
      columnConfigButtonText: "列配置",
      columnConfigTitleText: "表格列配置",
      columnConfigDescriptionText: "请选择需要在表格中显示的数据列",
      confirmText: "确认",
      cancelText: "取消",
      resetText: "重置",
      selectAllText: "全选",
      searchResultText: "搜索“{result}”，找到 {count} 条结果"
    },
    select: {
      empty: "暂无数据",
      loadingText: "加载中",
      placeholder: "请选择"
    },
    tree: {
      empty: "暂无数据"
    },
    treeSelect: {
      empty: "暂无数据",
      loadingText: "加载中",
      placeholder: "请选择"
    },
    datePicker: {
      dayjsLocale: "zh-cn",
      placeholder: {
        date: "请选择日期",
        month: "请选择月份",
        year: "请选择年份",
        quarter: "请选择季度",
        week: "请选择周"
      },
      weekdays: ["一", "二", "三", "四", "五", "六", "日"],
      months: ["1 月", "2 月", "3 月", "4 月", "5 月", "6 月", "7 月", "8 月", "9 月", "10 月", "11 月", "12 月"],
      quarters: ["一季度", "二季度", "三季度", "四季度"],
      rangeSeparator: " - ",
      direction: "ltr",
      format: "YYYY-MM-DD",
      dayAriaLabel: "日",
      weekAbbreviation: "周",
      yearAriaLabel: "年",
      monthAriaLabel: "月",
      confirm: "确定",
      selectTime: "选择时间",
      selectDate: "选择日期",
      nextYear: "下一年",
      preYear: "上一年",
      nextMonth: "下个月",
      preMonth: "上个月",
      preDecade: "上个十年",
      nextDecade: "下个十年",
      now: "当前"
    },
    upload: {
      sizeLimitMessage: "文件大小不能超过 {sizeLimit}",
      cancelUploadText: "取消上传",
      triggerUploadText: {
        fileInput: "选择文件",
        image: "点击上传图片",
        normal: "点击上传",
        reupload: "重新选择",
        continueUpload: "继续选择",
        "delete": "删除",
        uploading: "上传中"
      },
      dragger: {
        dragDropText: "释放鼠标",
        draggingText: "拖拽到此区域",
        clickAndDragText: "点击上方“选择文件”或将文件拖拽到此区域"
      },
      file: {
        fileNameText: "文件名",
        fileSizeText: "文件大小",
        fileStatusText: "状态",
        fileOperationText: "操作",
        fileOperationDateText: "上传日期"
      },
      progress: {
        uploadingText: "上传中",
        waitingText: "待上传",
        failText: "上传失败",
        successText: "上传成功"
      }
    },
    form: {
      errorMessage: {
        date: "请输入正确的${name}",
        url: "请输入正确的${name}",
        required: "${name}必填",
        whitespace: "${name}不能为空",
        max: "${name}字符长度不能超过 ${validate} 个字符，一个中文等于两个字符",
        min: "${name}字符长度不能少于 ${validate} 个字符，一个中文等于两个字符",
        len: "${name}字符长度必须是 ${validate}",
        "enum": "${name}只能是${validate}等",
        idcard: "请输入正确的${name}",
        telnumber: "请输入正确的${name}",
        pattern: "请输入正确的${name}",
        validator: "${name}不符合要求",
        "boolean": "${name}数据类型必须是布尔类型",
        number: "${name}必须是数字"
      },
      colonText: "："
    },
    input: {
      placeholder: "请输入"
    },
    list: {
      loadingText: "正在加载中，请稍等",
      loadingMoreText: "点击加载更多"
    },
    alert: {
      expandText: "展开更多",
      collapseText: "收起"
    },
    anchor: {
      copySuccessText: "链接复制成功",
      copyText: "复制链接"
    },
    colorPicker: {
      swatchColorTitle: "系统预设颜色",
      recentColorTitle: "最近使用颜色",
      clearConfirmText: "确定清空最近使用的颜色吗？",
      singleColor: "单色",
      gradientColor: "渐变"
    },
    guide: {
      finishButtonProps: {
        content: "完成",
        theme: "primary"
      },
      nextButtonProps: {
        content: "下一步",
        theme: "primary"
      },
      skipButtonProps: {
        content: "跳过",
        theme: "default"
      },
      prevButtonProps: {
        content: "上一步",
        theme: "default"
      }
    },
    image: {
      errorText: "图片无法显示",
      loadingText: "图片加载中"
    },
    imageViewer: {
      errorText: "图片加载失败，可尝试重新加载",
      mirrorTipText: "镜像",
      rotateTipText: "旋转",
      originalSizeTipText: "原始大小"
    },
    typography: {
      expandText: "展开",
      collapseText: "收起",
      copiedText: "复制成功"
    },
    rate: {
      rateText: ["极差", "失望", "一般", "满意", "惊喜"]
    },
    empty: {
      titleText: {
        maintenance: "建设中",
        success: "成功",
        fail: "失败",
        empty: "暂无数据",
        networkError: "网络错误"
      }
    },
    descriptions: {
      colonText: "："
    },
    chat: {
      placeholder: "请输入消息...",
      stopBtnText: "中止",
      refreshTipText: "重新生成",
      copyTipText: "复制",
      likeTipText: "点赞",
      dislikeTipText: "点踩",
      copyCodeBtnText: "复制代码",
      copyCodeSuccessText: "已复制",
      clearHistoryBtnText: "清空历史记录",
      copyTextSuccess: "已成功复制到剪贴板",
      copyTextFail: "复制到剪贴板失败",
      confirmClearHistory: "确定要清空所有的消息吗？"
    }
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var defaultConfig = {
    classPrefix: "t",
    animation: {
      include: ["ripple", "expand", "fade"],
      exclude: []
    },
    attach: null,
    calendar: {
      firstDayOfWeek: 1,
      fillWithZero: true,
      controllerConfig: void 0
    },
    icon: {},
    input: {
      autocomplete: ""
    },
    dialog: {
      closeOnEscKeydown: true,
      closeOnOverlayClick: true,
      confirmBtnTheme: {
        "default": "primary",
        info: "primary",
        warning: "primary",
        danger: "primary",
        success: "primary"
      }
    },
    message: {},
    popconfirm: {
      confirmBtnTheme: {
        "default": "primary",
        warning: "primary",
        danger: "primary"
      }
    },
    table: {
      expandIcon: void 0,
      sortIcon: void 0,
      filterIcon: void 0,
      treeExpandAndFoldIcon: void 0,
      hideSortTips: false,
      size: "medium"
    },
    select: {
      clearIcon: void 0,
      filterable: false
    },
    drawer: {
      closeOnEscKeydown: true,
      closeOnOverlayClick: true,
      size: "small"
    },
    tree: {
      folderIcon: void 0
    },
    datePicker: {
      firstDayOfWeek: 1
    },
    steps: {
      checkIcon: void 0,
      errorIcon: void 0
    },
    tag: {
      closeIcon: void 0
    },
    form: {
      requiredMark: void 0
    },
    empty: {
      titleText: {
        maintenance: void 0,
        success: void 0,
        fail: void 0,
        empty: void 0,
        networkError: void 0
      },
      image: {
        maintenance: void 0,
        success: void 0,
        fail: void 0,
        empty: void 0,
        networkError: void 0
      }
    }
  };
  var EAnimationType = /* @__PURE__ */ function (EAnimationType2) {
    EAnimationType2["ripple"] = "ripple";
    EAnimationType2["expand"] = "expand";
    EAnimationType2["fade"] = "fade";
    return EAnimationType2;
  }(EAnimationType || {});
  var defaultGlobalConfig = merge(defaultConfig, zhCn);
  var configProviderInjectKey = Symbol("configProvide");
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var globalConfigCopy = ref();
  function useConfig() {
    var componentName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
    var componentLocale = arguments.length > 1 ? arguments[1] : void 0;
    var injectGlobalConfig = getCurrentInstance() ? inject(configProviderInjectKey, null) : globalConfigCopy;
    var mergedGlobalConfig = computed(function () {
      return (injectGlobalConfig === null || injectGlobalConfig === void 0 ? void 0 : injectGlobalConfig.value) || defaultGlobalConfig;
    });
    var globalConfig = computed(function () {
      return Object.assign({}, mergedGlobalConfig.value[componentName], componentLocale);
    });
    var classPrefix = computed(function () {
      return mergedGlobalConfig.value.classPrefix;
    });
    var t = function t2(pattern) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var data = args[0];
      if (isString(pattern)) {
        if (!data) return pattern;
        var regular = /\{\s*([\w-]+)\s*\}/g;
        var translated = pattern.replace(regular, function (match, key2) {
          if (data) {
            return String(data[key2]);
          }
          return "";
        });
        return translated;
      }
      if (isFunction(pattern)) {
        if (!args.length) return pattern(h);
        return pattern.apply(void 0, args);
      }
      return "";
    };
    return {
      t,
      global: globalConfig,
      globalConfig,
      classPrefix
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function usePrefixClass(componentName) {
    var _useConfig = useConfig("classPrefix"), classPrefix = _useConfig.classPrefix;
    return computed(function () {
      return componentName ? "".concat(classPrefix.value, "-").concat(componentName) : classPrefix.value;
    });
  }
  function useCommonClassName$1() {
    var _useConfig2 = useConfig("classPrefix"), classPrefix = _useConfig2.classPrefix;
    return {
      SIZE: computed(function () {
        return {
          small: "".concat(classPrefix.value, "-size-s"),
          medium: "".concat(classPrefix.value, "-size-m"),
          large: "".concat(classPrefix.value, "-size-l"),
          "default": "",
          xs: "".concat(classPrefix.value, "-size-xs"),
          xl: "".concat(classPrefix.value, "-size-xl"),
          block: "".concat(classPrefix.value, "-size-full-width")
        };
      }),
      STATUS: computed(function () {
        return {
          loading: "".concat(classPrefix.value, "-is-loading"),
          loadMore: "".concat(classPrefix.value, "-is-load-more"),
          disabled: "".concat(classPrefix.value, "-is-disabled"),
          focused: "".concat(classPrefix.value, "-is-focused"),
          success: "".concat(classPrefix.value, "-is-success"),
          error: "".concat(classPrefix.value, "-is-error"),
          warning: "".concat(classPrefix.value, "-is-warning"),
          selected: "".concat(classPrefix.value, "-is-selected"),
          active: "".concat(classPrefix.value, "-is-active"),
          checked: "".concat(classPrefix.value, "-is-checked"),
          current: "".concat(classPrefix.value, "-is-current"),
          hidden: "".concat(classPrefix.value, "-is-hidden"),
          visible: "".concat(classPrefix.value, "-is-visible"),
          expanded: "".concat(classPrefix.value, "-is-expanded"),
          indeterminate: "".concat(classPrefix.value, "-is-indeterminate")
        };
      })
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function setStyle(el, styles) {
    var keys2 = Object.keys(styles);
    keys2.forEach(function (key2) {
      el.style[key2] = styles[key2];
    });
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r[n];
    }
    return t;
  }
  function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function getValidAttrs(obj) {
    var newObj = {};
    Object.keys(obj).forEach(function (key2) {
      if (!isUndefined(obj[key2]) || isNull(obj[key2])) {
        newObj[key2] = obj[key2];
      }
    });
    return newObj;
  }
  function getIEVersion() {
    if (typeof navigator === "undefined" || !navigator) return Number.MAX_SAFE_INTEGER;
    var _navigator = navigator, userAgent = _navigator.userAgent;
    var isIE = userAgent.indexOf("compatible") > -1 && userAgent.indexOf("MSIE") > -1;
    var isIE11 = userAgent.indexOf("Trident") > -1 && userAgent.indexOf("rv:11.0") > -1;
    if (isIE) {
      var reIE = new RegExp("MSIE (\\d+\\.\\d+);");
      var match = userAgent.match(reIE);
      if (!match) return -1;
      var fIEVersion = parseFloat(match[1]);
      return fIEVersion < 7 ? 6 : fIEVersion;
    }
    if (isIE11) {
      return 11;
    }
    return Number.MAX_SAFE_INTEGER;
  }
  function getCharacterLength(str, maxCharacter) {
    var hasMaxCharacter = isNumber(maxCharacter);
    if (!str || str.length === 0) {
      if (hasMaxCharacter) {
        return {
          length: 0,
          characters: str
        };
      }
      return 0;
    }
    var len = 0;
    for (var i = 0; i < str.length; i++) {
      var currentStringLength = 0;
      if (str.charCodeAt(i) > 127) {
        currentStringLength = 2;
      } else {
        currentStringLength = 1;
      }
      if (hasMaxCharacter && len + currentStringLength > maxCharacter) {
        return {
          length: len,
          characters: str.slice(0, i)
        };
      }
      len += currentStringLength;
    }
    if (hasMaxCharacter) {
      return {
        length: len,
        characters: str
      };
    }
    return len;
  }
  function getUnicodeLength(str) {
    return _toConsumableArray(str !== null && str !== void 0 ? str : "").length;
  }
  function limitUnicodeMaxLength(str, maxLength, oldStr) {
    if (_toConsumableArray("").slice().length === maxLength) return oldStr || "";
    return _toConsumableArray(str !== null && str !== void 0 ? str : "").slice(0, maxLength).join("");
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function ownKeys$u(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$u(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$u(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$u(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function circleAdapter(circleElem) {
    var _window, _window$getComputedSt2, _window2;
    var basicStyle = {};
    if (!circleElem || typeof window === "undefined") {
      return;
    }
    var _window$getComputedSt = (_window = window) === null || _window === void 0 || (_window$getComputedSt2 = _window.getComputedStyle) === null || _window$getComputedSt2 === void 0 ? void 0 : _window$getComputedSt2.call(_window, circleElem), color = _window$getComputedSt.color, fontSize = _window$getComputedSt.fontSize;
    var ua = (_window2 = window) === null || _window2 === void 0 || (_window2 = _window2.navigator) === null || _window2 === void 0 ? void 0 : _window2.userAgent;
    var isSafari = /Safari/.test(ua) && !/Chrome/.test(ua);
    var isIosWechat = /(?=.*iPhone)[?=.*MicroMessenger]/.test(ua) && !/Chrome/.test(ua);
    if (isSafari || isIosWechat) {
      basicStyle = {
        transformOrigin: "0px 0px",
        transform: "scale(".concat(parseInt(fontSize, 10) / 12, ")")
      };
    }
    if (color && getIEVersion() > 11) {
      var matched = color.match(/[\d.]+/g);
      var endColor = matched ? "rgba(".concat(matched[0], ", ").concat(matched[1], ", ").concat(matched[2], ", 0)") : "";
      setStyle(circleElem, _objectSpread$u(_objectSpread$u({}, basicStyle), {}, {
        background: "conic-gradient(from 90deg at 50% 50%,".concat(endColor, " 0deg, ").concat(color, " 360deg)")
      }));
    } else {
      setStyle(circleElem, _objectSpread$u(_objectSpread$u({}, basicStyle), {}, {
        background: ""
      }));
    }
  }
  var GradientIcon = /* @__PURE__ */ defineComponent({
    name: "TLoadingGradient",
    setup: function setup() {
      var classPrefix = usePrefixClass();
      var circleRef = ref();
      onMounted(function () {
        nextTick(function () {
          circleAdapter(circleRef.value);
        });
      });
      return function () {
        var name = "".concat(classPrefix.value, "-loading__gradient");
        var classes = [name, "".concat(classPrefix.value, "-icon-loading")];
        return createVNode("svg", {
          "class": classes,
          "viewBox": "0 0 12 12",
          "version": "1.1",
          "width": "1em",
          "height": "1em",
          "xmlns": "http://www.w3.org/2000/svg"
        }, [createVNode("foreignObject", {
          "x": "0",
          "y": "0",
          "width": "12",
          "height": "12"
        }, [createVNode("div", {
          "class": "".concat(name, "-conic"),
          "ref": circleRef
        }, null)])]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var raf$2 = { exports: {} };
  var performanceNow$1 = { exports: {} };
  (function () {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
    if (typeof performance !== "undefined" && performance !== null && performance.now) {
      performanceNow$1.exports = function () {
        return performance.now();
      };
    } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
      performanceNow$1.exports = function () {
        return (getNanoSeconds() - nodeLoadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function getNanoSeconds2() {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      moduleLoadTime = getNanoSeconds();
      upTime = process.uptime() * 1e9;
      nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
      performanceNow$1.exports = function () {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      performanceNow$1.exports = function () {
        return (/* @__PURE__ */ new Date()).getTime() - loadTime;
      };
      loadTime = (/* @__PURE__ */ new Date()).getTime();
    }
  }).call(commonjsGlobal);
  var now = performanceNow$1.exports, root = typeof window === "undefined" ? commonjsGlobal : window, vendors = ["moz", "webkit"], suffix = "AnimationFrame", raf = root["request" + suffix], caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
  for (var i = 0; !raf && i < vendors.length; i++) {
    raf = root[vendors[i] + "Request" + suffix];
    caf = root[vendors[i] + "Cancel" + suffix] || root[vendors[i] + "CancelRequest" + suffix];
  }
  if (!raf || !caf) {
    var last = 0, id = 0, queue = [], frameDuration = 1e3 / 60;
    raf = function raf2(callback) {
      if (queue.length === 0) {
        var _now = now(), next = Math.max(0, frameDuration - (_now - last));
        last = next + _now;
        setTimeout(function () {
          var cp = queue.slice(0);
          queue.length = 0;
          var _loop = function _loop2() {
            if (!cp[i].cancelled) {
              try {
                cp[i].callback(last);
              } catch (e) {
                setTimeout(function () {
                  throw e;
                }, 0);
              }
            }
          };
          for (var i = 0; i < cp.length; i++) {
            _loop();
          }
        }, Math.round(next));
      }
      queue.push({
        handle: ++id,
        callback,
        cancelled: false
      });
      return id;
    };
    caf = function caf2(handle) {
      for (var i = 0; i < queue.length; i++) {
        if (queue[i].handle === handle) {
          queue[i].cancelled = true;
        }
      }
    };
  }
  raf$2.exports = function (fn2) {
    return raf.call(root, fn2);
  };
  raf$2.exports.cancel = function () {
    caf.apply(root, arguments);
  };
  raf$2.exports.polyfill = function (object) {
    if (!object) {
      object = root;
    }
    object.requestAnimationFrame = raf;
    object.cancelAnimationFrame = caf;
  };
  var isServer = typeof window === "undefined";
  var trim = function trim2(str) {
    return (str || "").replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, "");
  };
  var on = function () {
    if (!isServer && document.addEventListener) {
      return function (element2, event, handler, options) {
        if (element2 && event && handler) {
          element2.addEventListener(event, handler, options);
        }
      };
    }
    return function (element2, event, handler) {
      if (element2 && event && handler) {
        element2.attachEvent("on".concat(event), handler);
      }
    };
  }();
  var off = function () {
    if (!isServer && document.removeEventListener) {
      return function (element2, event, handler, options) {
        if (element2 && event) {
          element2.removeEventListener(event, handler, options);
        }
      };
    }
    return function (element2, event, handler) {
      if (element2 && event) {
        element2.detachEvent("on".concat(event), handler);
      }
    };
  }();
  function once(element2, event, handler, options) {
    var handlerFn = isFunction(handler) ? handler : handler.handleEvent;
    var _callback = function callback(evt) {
      handlerFn(evt);
      off(element2, event, _callback, options);
    };
    on(element2, event, _callback, options);
  }
  function hasClass(el, cls) {
    if (!el || !cls) return false;
    if (cls.indexOf(" ") !== -1) throw new Error("className should not contain space.");
    if (el.classList) {
      return el.classList.contains(cls);
    }
    return " ".concat(el.className, " ").indexOf(" ".concat(cls, " ")) > -1;
  }
  function addClass(el, cls) {
    if (!el) return;
    var curClass = el.className;
    var classes = (cls || "").split(" ");
    for (var i = 0, j = classes.length; i < j; i++) {
      var clsName = classes[i];
      if (!clsName) continue;
      if (el.classList) {
        el.classList.add(clsName);
      } else if (!hasClass(el, clsName)) {
        curClass += " ".concat(clsName);
      }
    }
    if (!el.classList) {
      el.className = curClass;
    }
  }
  function removeClass(el, cls) {
    if (!el || !cls) return;
    var classes = cls.split(" ");
    var curClass = " ".concat(el.className, " ");
    for (var i = 0, j = classes.length; i < j; i++) {
      var clsName = classes[i];
      if (!clsName) continue;
      if (el.classList) {
        el.classList.remove(clsName);
      } else if (hasClass(el, clsName)) {
        curClass = curClass.replace(" ".concat(clsName, " "), " ");
      }
    }
    if (!el.classList) {
      el.className = trim(curClass);
    }
  }
  var getAttach = function getAttach2(node, triggerNode) {
    var attachNode = isFunction(node) ? node(triggerNode) : node;
    if (!attachNode) {
      return document.body;
    }
    if (isString(attachNode)) {
      return document.querySelector(attachNode);
    }
    if (attachNode instanceof HTMLElement) {
      return attachNode;
    }
    return document.body;
  };
  var getSSRAttach = function getSSRAttach2() {
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function getDefaultNode(options) {
    var defaultNode;
    if (isObject(options) && "defaultNode" in options) {
      defaultNode = options.defaultNode;
    } else if (isVNode(options) || isString(options)) {
      defaultNode = options;
    }
    return defaultNode;
  }
  function getChildren(content) {
    var childList = [];
    var _innerGetChildren = function innerGetChildren(content2) {
      if (!isArray(content2)) return;
      content2.forEach(function (item) {
        if (item.children && isArray(item.children)) {
          if (item.type !== Fragment) return;
          _innerGetChildren(item.children);
        } else {
          childList.push(item);
        }
      });
      return childList;
    };
    return _innerGetChildren(content);
  }
  function getParams(options) {
    return isObject(options) && "params" in options ? options.params : {};
  }
  function getSlotFirst(options) {
    return isObject(options) && "slotFirst" in options ? options.slotFirst : false;
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var hasOwn = function hasOwn2(val, key2) {
    return hasOwnProperty.call(val, key2);
  };
  var getPropertyValFromObj = function getPropertyValFromObj2(val, key2) {
    return hasOwn(val, key2) ? val[key2] : void 0;
  };
  function handleSlots(instance, name, params) {
    var _instance$slots$camel, _instance$slots, _instance$slots$kebab, _instance$slots2;
    var node = (_instance$slots$camel = (_instance$slots = instance.slots)[camelCase(name)]) === null || _instance$slots$camel === void 0 ? void 0 : _instance$slots$camel.call(_instance$slots, params);
    if (node && node.filter(function (t) {
      return t.type.toString() !== "Symbol(v-cmt)";
    }).length) return node;
    node = (_instance$slots$kebab = (_instance$slots2 = instance.slots)[kebabCase(name)]) === null || _instance$slots$kebab === void 0 ? void 0 : _instance$slots$kebab.call(_instance$slots2, params);
    if (node && node.filter(function (t) {
      return t.type.toString() !== "Symbol(v-cmt)";
    }).length) return node;
    return null;
  }
  function isEmptyNode(node) {
    if ([void 0, null, ""].includes(node)) return true;
    var innerNodes = node instanceof Array ? node : [node];
    var r = innerNodes.filter(function (node2) {
      var _node2$type;
      return (node2 === null || node2 === void 0 || (_node2$type = node2.type) === null || _node2$type === void 0 ? void 0 : _node2$type.toString()) !== "Symbol(Comment)";
    });
    return !r.length;
  }
  function isPropExplicitlySet(instance, propName) {
    var vProps = (instance === null || instance === void 0 ? void 0 : instance.vnode.props) || {};
    return hasOwn(vProps, camelCase(propName)) || hasOwn(vProps, kebabCase(propName));
  }
  var useTNodeJSX = function useTNodeJSX2() {
    var instance = getCurrentInstance();
    return function (name, options) {
      var renderParams = getParams(options);
      var defaultNode = getDefaultNode(options);
      var isSlotFirst = getSlotFirst(options);
      var renderSlot = instance.slots[camelCase(name)] || instance.slots[kebabCase(name)];
      if (isSlotFirst && renderSlot) {
        return handleSlots(instance, name, renderParams);
      } else {
        if (isPropExplicitlySet(instance, name)) {
          var propsNode2 = instance.props[camelCase(name)] || instance.props[kebabCase(name)];
          if (propsNode2 === false || propsNode2 === null) return;
          if (propsNode2 === true) {
            return handleSlots(instance, name, renderParams) || defaultNode;
          }
          if (isFunction(propsNode2)) return propsNode2(h, renderParams);
          var isPropsEmpty = [void 0, ""].includes(propsNode2);
          if (isPropsEmpty && renderSlot) {
            return handleSlots(instance, name, renderParams);
          }
          return propsNode2;
        }
        if (renderSlot) {
          return handleSlots(instance, name, renderParams);
        }
        var propsNode = instance.props[camelCase(name)] || instance.props[kebabCase(name)];
        if (propsNode === false || propsNode === null) return;
        if (propsNode === true) {
          return defaultNode;
        }
        if (isFunction(propsNode)) return propsNode(h, renderParams);
        return propsNode;
      }
    };
  };
  var useTNodeDefault = function useTNodeDefault2() {
    var renderTNodeJSX = useTNodeJSX();
    return function (name, options) {
      var defaultNode = getDefaultNode(options);
      return renderTNodeJSX(name, options) || defaultNode;
    };
  };
  var useContent = function useContent2() {
    var renderTNodeJSX = useTNodeJSX();
    return function (name1, name2, options) {
      var params = getParams(options);
      var defaultNode = getDefaultNode(options);
      var toParams = params ? {
        params
      } : void 0;
      var node1 = renderTNodeJSX(name1, toParams);
      var node2 = renderTNodeJSX(name2, toParams);
      var res = isEmptyNode(node1) ? node2 : node1;
      return isEmptyNode(res) ? defaultNode : res;
    };
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var useTeleport = function useTeleport2(attach, triggerNode) {
    var to = isFunction(attach) ? computed(attach) : ref(attach);
    var innerTriggerNode = isFunction(triggerNode) ? computed(triggerNode) : ref(triggerNode);
    var element2 = ref();
    var getElement = function getElement2() {
      element2.value = getSSRAttach() || getAttach(to.value, innerTriggerNode.value);
    };
    onMounted(function () {
      return getElement();
    });
    watch([to, innerTriggerNode], function () {
      return getElement();
    });
    return element2;
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var props$f = {
    attach: {
      type: [String, Function],
      "default": ""
    },
    content: {
      type: [String, Function]
    },
    "default": {
      type: [String, Function]
    },
    delay: {
      type: Number,
      "default": 0
    },
    fullscreen: Boolean,
    indicator: {
      type: [Boolean, Function],
      "default": true
    },
    inheritColor: Boolean,
    loading: {
      type: Boolean,
      "default": true
    },
    preventScrollThrough: {
      type: Boolean,
      "default": true
    },
    showOverlay: {
      type: Boolean,
      "default": true
    },
    size: {
      type: String,
      "default": "medium"
    },
    text: {
      type: [String, Function]
    },
    zIndex: {
      type: Number
    }
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var useComponentClassName$2 = function useComponentClassName() {
    return {
      name: usePrefixClass("loading"),
      centerClass: usePrefixClass("loading--center"),
      fullscreenClass: usePrefixClass("loading__fullscreen"),
      lockClass: usePrefixClass("loading--lock"),
      overlayClass: usePrefixClass("loading__overlay"),
      relativeClass: usePrefixClass("loading__parent"),
      fullClass: usePrefixClass("loading--full"),
      inheritColorClass: usePrefixClass("loading--inherit-color")
    };
  };
  var _Loading = /* @__PURE__ */ defineComponent({
    name: "TLoading",
    inheritAttrs: false,
    props: props$f,
    setup: function setup2(props2, _ref) {
      var slots = _ref.slots, attrs = _ref.attrs;
      var delayShowLoading = ref(false);
      var _useComponentClassNam = useComponentClassName$2(), name = _useComponentClassNam.name, centerClass = _useComponentClassNam.centerClass, fullscreenClass = _useComponentClassNam.fullscreenClass, lockClass = _useComponentClassNam.lockClass, overlayClass = _useComponentClassNam.overlayClass, relativeClass = _useComponentClassNam.relativeClass, fullClass = _useComponentClassNam.fullClass, inheritColorClass = _useComponentClassNam.inheritColorClass;
      var classPrefix = usePrefixClass();
      var renderTNodeJSX = useTNodeJSX();
      var renderContent = useContent();
      var _useCommonClassName = useCommonClassName$1(), SIZE = _useCommonClassName.SIZE;
      var countDelay = function countDelay2() {
        delayShowLoading.value = false;
        var timer = setTimeout(function () {
          delayShowLoading.value = true;
          clearTimeout(timer);
        }, props2.delay);
      };
      var teleportElement = useTeleport(function () {
        return props2.attach;
      });
      var delayCounted = computed(function () {
        return Boolean(!props2.delay || props2.delay && delayShowLoading.value);
      });
      var styles = computed(function () {
        var styles2 = {};
        if (props2.zIndex !== void 0) {
          styles2.zIndex = props2.zIndex;
        }
        if (!["small", "medium", "large"].includes(props2.size)) {
          styles2["font-size"] = props2.size;
        }
        return styles2;
      });
      var hasContent = computed(function () {
        return Boolean(props2["default"] || slots["default"] || props2.content || slots.content);
      });
      var lockFullscreen = computed(function () {
        return props2.preventScrollThrough && props2.fullscreen;
      });
      var showText = computed(function () {
        return Boolean(props2.text || slots.text);
      });
      var showWrapLoading = computed(function () {
        return hasContent.value && props2.loading && delayCounted.value;
      });
      var showFullScreenLoading = computed(function () {
        return props2.fullscreen && props2.loading && delayCounted.value;
      });
      var showAttachedLoading = computed(function () {
        return props2.attach && props2.loading && delayCounted.value;
      });
      var classes = computed(function () {
        var baseClasses = [centerClass.value, getPropertyValFromObj(SIZE.value, props2.size), _defineProperty$1({}, inheritColorClass.value, props2.inheritColor)];
        var fullScreenClasses = [name.value, fullscreenClass.value, centerClass.value, overlayClass.value];
        return {
          baseClasses,
          attachClasses: baseClasses.concat([name.value, fullClass.value, _defineProperty$1({}, overlayClass.value, props2.showOverlay)]),
          withContentClasses: baseClasses.concat([name.value, fullClass.value, _defineProperty$1({}, overlayClass.value, props2.showOverlay)]),
          fullScreenClasses,
          normalClasses: baseClasses.concat([name.value])
        };
      });
      var _toRefs = toRefs(props2), loading = _toRefs.loading;
      watch([loading], function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 1), isLoading = _ref6[0];
        if (isLoading) {
          countDelay();
          lockFullscreen.value && addClass(document.body, lockClass.value);
        } else {
          lockFullscreen.value && removeClass(document.body, lockClass.value);
        }
      });
      onMounted(function () {
        props2.delay && countDelay();
      });
      return function () {
        var _classes$value = classes.value, fullScreenClasses = _classes$value.fullScreenClasses, baseClasses = _classes$value.baseClasses, withContentClasses = _classes$value.withContentClasses, attachClasses = _classes$value.attachClasses, normalClasses = _classes$value.normalClasses;
        var defaultIndicator = createVNode(GradientIcon, {
          "size": props2.size
        }, null);
        var indicator = loading.value && renderTNodeJSX("indicator", defaultIndicator);
        var text = showText.value && createVNode("div", {
          "class": "".concat(classPrefix.value, "-loading__text")
        }, [renderTNodeJSX("text")]);
        if (props2.fullscreen) {
          if (!showFullScreenLoading.value || !props2.loading) return null;
          return createVNode(Teleport, {
            "disabled": !props2.attach || !teleportElement.value,
            "to": teleportElement.value
          }, {
            "default": function _default5() {
              return [createVNode("div", mergeProps({
                "class": fullScreenClasses,
                "style": styles.value
              }, attrs), [createVNode("div", {
                "class": baseClasses
              }, [indicator, text])])];
            }
          });
        }
        if (hasContent.value) {
          return createVNode("div", mergeProps({
            "class": relativeClass.value
          }, attrs), [renderContent("default", "content"), showWrapLoading.value && createVNode("div", {
            "class": withContentClasses,
            "style": styles.value
          }, [indicator, text])]);
        }
        if (props2.attach) {
          if (!showAttachedLoading.value || !loading.value) return null;
          return createVNode(Teleport, {
            "disabled": !props2.attach || !teleportElement.value,
            "to": teleportElement.value
          }, {
            "default": function _default5() {
              return [createVNode("div", mergeProps({
                "class": attachClasses,
                "style": styles.value
              }, attrs), [indicator, text])];
            }
          });
        }
        return loading.value ? createVNode("div", mergeProps({
          "class": normalClasses,
          "style": styles.value
        }, attrs), [indicator, text]) : null;
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function ownKeys$t(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$t(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$t(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$t(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var fullScreenLoadingInstance = null;
  function mergeDefaultProps(props2) {
    var options = merge({
      fullscreen: false,
      attach: "body",
      loading: true,
      preventScrollThrough: true
    }, props2);
    return options;
  }
  function createLoading(props2) {
    var mergedProps = mergeDefaultProps(props2);
    if (mergedProps.fullscreen && fullScreenLoadingInstance) {
      return fullScreenLoadingInstance;
    }
    var component = /* @__PURE__ */ defineComponent({
      setup: function setup30() {
        var loadingOptions = reactive(mergedProps);
        return {
          loadingOptions
        };
      },
      render: function render2() {
        return h(_Loading, _objectSpread$t({}, this.loadingOptions));
      }
    });
    var attach = getAttach(mergedProps.fullscreen ? "body" : mergedProps.attach);
    var app = createApp(component);
    var loading = app.mount(document.createElement("div"));
    var parentRelativeClass = usePrefixClass("loading__parent--relative").value;
    var lockClass = usePrefixClass("loading--lock");
    var lockFullscreen = mergedProps.preventScrollThrough && mergedProps.fullscreen;
    if (lockFullscreen) {
      addClass(document.body, lockClass.value);
    }
    if (attach) {
      addClass(attach, parentRelativeClass);
    } else {
      console.error("attach is not exist");
    }
    var loadingInstance = {
      hide: function hide2() {
        loading.loading = false;
        removeClass(attach, parentRelativeClass);
        removeClass(document.body, lockClass.value);
        app.unmount();
      }
    };
    return loadingInstance;
  }
  function produceLoading(props2) {
    if (props2 === true) {
      fullScreenLoadingInstance = createLoading({
        fullscreen: true,
        loading: true,
        attach: "body",
        preventScrollThrough: true
      });
      return fullScreenLoadingInstance;
    }
    if (props2 === false) {
      var _fullScreenLoadingIns;
      (_fullScreenLoadingIns = fullScreenLoadingInstance) === null || _fullScreenLoadingIns === void 0 || _fullScreenLoadingIns.hide();
      fullScreenLoadingInstance = null;
      return;
    }
    return createLoading(props2);
  }
  var LoadingPlugin = produceLoading;
  LoadingPlugin.install = function (app) {
    app.config.globalProperties.$loading = produceLoading;
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var INSTANCE_KEY = Symbol("TdLoading");
  var createInstance = function createInstance2(el, binding) {
    var _binding$modifiers = binding.modifiers, fullscreen = _binding$modifiers.fullscreen, inheritColor = _binding$modifiers.inheritColor;
    var options = {
      attach: function attach() {
        return el;
      },
      fullscreen: fullscreen !== null && fullscreen !== void 0 ? fullscreen : false,
      inheritColor: inheritColor !== null && inheritColor !== void 0 ? inheritColor : false,
      loading: binding.value
    };
    if (isObject(binding.value)) {
      mapKeys(binding.value, function (value, key2) {
        options[key2] = value;
      });
    }
    el[INSTANCE_KEY] = {
      options,
      instance: LoadingPlugin(options)
    };
  };
  var vLoading = {
    mounted: function mounted(el, binding) {
      if (binding.value) {
        createInstance(el, binding);
      }
    },
    updated: function updated(el, binding) {
      var instance = el[INSTANCE_KEY];
      var value = binding.value, oldValue = binding.oldValue;
      if (!isEqual(value, oldValue)) {
        var _value$loading;
        var loading = (_value$loading = value === null || value === void 0 ? void 0 : value.loading) !== null && _value$loading !== void 0 ? _value$loading : value;
        if (loading) {
          createInstance(el, binding);
        } else {
          instance === null || instance === void 0 || instance.instance.hide();
        }
      }
    },
    unmounted: function unmounted(el) {
      var _el$INSTANCE_KEY;
      (_el$INSTANCE_KEY = el[INSTANCE_KEY]) === null || _el$INSTANCE_KEY === void 0 || _el$INSTANCE_KEY.instance.hide();
    }
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function withInstall(comp, alias, directive) {
    var componentPlugin = comp;
    componentPlugin.install = function (app, name) {
      app.component(alias || name || componentPlugin.name, comp);
      directive && app.directive(directive.name, directive.comp);
    };
    return componentPlugin;
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var Loading = withInstall(_Loading, _Loading.name, {
    name: "loading",
    comp: vLoading
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var props$e = {
    block: Boolean,
    content: {
      type: [String, Function]
    },
    "default": {
      type: [String, Function]
    },
    disabled: {
      type: Boolean,
      "default": void 0
    },
    form: {
      type: String,
      "default": void 0
    },
    ghost: Boolean,
    href: {
      type: String,
      "default": ""
    },
    icon: {
      type: Function
    },
    loading: Boolean,
    loadingProps: {
      type: Object
    },
    shape: {
      type: String,
      "default": "rectangle",
      validator: function validator(val) {
        if (!val) return true;
        return ["rectangle", "square", "round", "circle"].includes(val);
      }
    },
    size: {
      type: String,
      "default": "medium",
      validator: function validator2(val) {
        if (!val) return true;
        return ["extra-small", "small", "medium", "large"].includes(val);
      }
    },
    suffix: {
      type: Function
    },
    tag: {
      type: String,
      validator: function validator3(val) {
        if (!val) return true;
        return ["button", "a", "div"].includes(val);
      }
    },
    theme: {
      type: String,
      validator: function validator4(val) {
        if (!val) return true;
        return ["default", "primary", "danger", "warning", "success"].includes(val);
      }
    },
    type: {
      type: String,
      "default": "button",
      validator: function validator5(val) {
        if (!val) return true;
        return ["submit", "reset", "button"].includes(val);
      }
    },
    variant: {
      type: String,
      "default": "base",
      validator: function validator6(val) {
        if (!val) return true;
        return ["base", "outline", "dashed", "text"].includes(val);
      }
    },
    onClick: Function
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var expand = EAnimationType.expand, ripple = EAnimationType.ripple, fade = EAnimationType.fade;
  function useKeepAnimation() {
    var _useConfig = useConfig("animation"), globalConfig = _useConfig.globalConfig;
    var keepAnimation = function keepAnimation2(type) {
      var _animationConfig$excl, _animationConfig$incl;
      var animationConfig = globalConfig.value;
      return animationConfig && !((_animationConfig$excl = animationConfig.exclude) !== null && _animationConfig$excl !== void 0 && _animationConfig$excl.includes(type)) && ((_animationConfig$incl = animationConfig.include) === null || _animationConfig$incl === void 0 ? void 0 : _animationConfig$incl.includes(type));
    };
    return {
      keepExpand: keepAnimation(expand),
      keepRipple: keepAnimation(ripple),
      keepFade: keepAnimation(fade)
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var period = 200;
  var noneRippleBg = "rgba(0, 0, 0, 0)";
  var defaultRippleColor = "rgba(0, 0, 0, 0.35)";
  var getRippleColor = function getRippleColor2(el, fixedRippleColor) {
    var _el$dataset;
    if (el !== null && el !== void 0 && (_el$dataset = el.dataset) !== null && _el$dataset !== void 0 && _el$dataset.ripple) {
      var rippleColor = el.dataset.ripple;
      return rippleColor;
    }
    var cssVariable = getComputedStyle(el).getPropertyValue("--ripple-color");
    if (cssVariable) {
      return cssVariable;
    }
    return defaultRippleColor;
  };
  function useRipple(el, fixedRippleColor) {
    var rippleContainer = ref(null);
    var classPrefix = usePrefixClass();
    var _useKeepAnimation = useKeepAnimation(), keepRipple = _useKeepAnimation.keepRipple;
    var handleAddRipple = function handleAddRipple2(e) {
      var dom = el.value;
      var rippleColor = getRippleColor(dom);
      if (e.button !== 0 || !el || !keepRipple) return;
      if (dom.classList.contains("".concat(classPrefix.value, "-is-active")) || dom.classList.contains("".concat(classPrefix.value, "-is-disabled")) || dom.classList.contains("".concat(classPrefix.value, "-is-checked")) || dom.classList.contains("".concat(classPrefix.value, "-is-loading"))) return;
      var elStyle = getComputedStyle(dom);
      var elBorder = parseInt(elStyle.borderWidth, 10);
      var border = elBorder > 0 ? elBorder : 0;
      var width = dom.offsetWidth;
      var height = dom.offsetHeight;
      if (rippleContainer.value.parentNode === null) {
        setStyle(rippleContainer.value, {
          position: "absolute",
          left: "".concat(0 - border, "px"),
          top: "".concat(0 - border, "px"),
          width: "".concat(width, "px"),
          height: "".concat(height, "px"),
          borderRadius: elStyle.borderRadius,
          pointerEvents: "none",
          overflow: "hidden"
        });
        dom.appendChild(rippleContainer.value);
      }
      var ripple2 = document.createElement("div");
      setStyle(ripple2, {
        marginTop: "0",
        marginLeft: "0",
        right: "".concat(width, "px"),
        width: "".concat(width + 20, "px"),
        height: "100%",
        transition: "transform ".concat(period, "ms cubic-bezier(.38, 0, .24, 1), background ").concat(period * 2, "ms linear"),
        transform: "skewX(-8deg)",
        pointerEvents: "none",
        position: "absolute",
        zIndex: 0,
        backgroundColor: rippleColor,
        opacity: "0.9"
      });
      var elMap = /* @__PURE__ */ new WeakMap();
      for (var n = dom.children.length, i = 0; i < n; ++i) {
        var child = dom.children[i];
        if (child.style.zIndex === "" && child !== rippleContainer.value) {
          child.style.zIndex = "1";
          elMap.set(child, true);
        }
      }
      var initPosition = dom.style.position ? dom.style.position : getComputedStyle(dom).position;
      if (initPosition === "" || initPosition === "static") {
        dom.style.position = "relative";
      }
      rippleContainer.value.insertBefore(ripple2, rippleContainer.value.firstChild);
      setTimeout(function () {
        ripple2.style.transform = "translateX(".concat(width, "px)");
      }, 0);
      var _handleClearRipple = function handleClearRipple() {
        ripple2.style.backgroundColor = noneRippleBg;
        if (!el.value) return;
        el.value.removeEventListener("pointerup", _handleClearRipple, false);
        el.value.removeEventListener("pointerleave", _handleClearRipple, false);
        setTimeout(function () {
          ripple2.remove();
          if (rippleContainer.value.children.length === 0) rippleContainer.value.remove();
        }, period * 2 + 100);
      };
      el.value.addEventListener("pointerup", _handleClearRipple, false);
      el.value.addEventListener("pointerleave", _handleClearRipple, false);
    };
    onMounted(function () {
      var dom = el === null || el === void 0 ? void 0 : el.value;
      if (!dom) return;
      rippleContainer.value = document.createElement("div");
      dom.addEventListener("pointerdown", handleAddRipple, false);
    });
    onUnmounted(function () {
      var _el$value;
      el === null || el === void 0 || (_el$value = el.value) === null || _el$value === void 0 || _el$value.removeEventListener("pointerdown", handleAddRipple, false);
    });
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function useDisabled(context) {
    var currentInstance2 = getCurrentInstance();
    var componentDisabled = computed(function () {
      return currentInstance2.props.disabled;
    });
    var formDisabled = inject("formDisabled", /* @__PURE__ */ Object.create(null));
    return computed(function () {
      var _context$beforeDisabl, _context$afterDisable, _formDisabled$disable;
      if (isBoolean(context === null || context === void 0 || (_context$beforeDisabl = context.beforeDisabled) === null || _context$beforeDisabl === void 0 ? void 0 : _context$beforeDisabl.value)) return context.beforeDisabled.value;
      if (isBoolean(componentDisabled.value)) return componentDisabled.value;
      if (isBoolean(context === null || context === void 0 || (_context$afterDisable = context.afterDisabled) === null || _context$afterDisable === void 0 ? void 0 : _context$afterDisable.value)) return context.afterDisabled.value;
      if (isBoolean((_formDisabled$disable = formDisabled.disabled) === null || _formDisabled$disable === void 0 ? void 0 : _formDisabled$disable.value)) return formDisabled.disabled.value;
      return false;
    });
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function ownKeys$s(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$s(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$s(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$s(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var TButton = /* @__PURE__ */ defineComponent({
    name: "TButton",
    props: props$e,
    setup: function setup3(props2, _ref) {
      var attrs = _ref.attrs, slots = _ref.slots;
      var renderTNodeJSX = useTNodeJSX();
      var renderContent = useContent();
      var COMPONENT_NAME = usePrefixClass("button");
      var _useCommonClassName = useCommonClassName$1(), STATUS = _useCommonClassName.STATUS, SIZE = _useCommonClassName.SIZE;
      var btnRef = ref();
      useRipple(btnRef);
      var isDisabled = useDisabled();
      var mergeTheme = computed(function () {
        var theme = props2.theme, variant = props2.variant;
        if (theme) return theme;
        if (variant === "base") return "primary";
        return "default";
      });
      var buttonClass = computed(function () {
        return ["".concat(COMPONENT_NAME.value), "".concat(COMPONENT_NAME.value, "--variant-").concat(props2.variant), "".concat(COMPONENT_NAME.value, "--theme-").concat(mergeTheme.value), "".concat(COMPONENT_NAME.value, "--shape-").concat(props2.shape), _defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1({}, SIZE.value[props2.size], props2.size !== "medium"), STATUS.value.disabled, isDisabled.value), STATUS.value.loading, props2.loading), "".concat(COMPONENT_NAME.value, "--ghost"), props2.ghost), SIZE.value.block, props2.block)];
      });
      return function () {
        var buttonContent = renderContent("default", "content");
        var icon = props2.loading ? createVNode(Loading, _objectSpread$s({
          inheritColor: true
        }, props2.loadingProps), null) : renderTNodeJSX("icon");
        var iconOnly = icon && !buttonContent;
        var suffix2 = props2.suffix || slots.suffix ? createVNode("span", {
          "class": "".concat(COMPONENT_NAME.value, "__suffix")
        }, [renderTNodeJSX("suffix")]) : null;
        buttonContent = buttonContent ? createVNode("span", {
          "class": "".concat(COMPONENT_NAME.value, "__text")
        }, [buttonContent]) : "";
        if (icon) {
          buttonContent = [icon, buttonContent];
        }
        if (suffix2) {
          buttonContent = [buttonContent].concat(suffix2);
        }
        var renderTag = function renderTag2() {
          if (!props2.tag && props2.href) return "a";
          return props2.tag || "button";
        };
        var buttonAttrs = {
          "class": [].concat(_toConsumableArray(buttonClass.value), [_defineProperty$1({}, "".concat(COMPONENT_NAME.value, "--icon-only"), iconOnly)]),
          type: props2.type,
          disabled: isDisabled.value || props2.loading,
          href: props2.href,
          tabindex: isDisabled.value ? void 0 : "0"
        };
        return h(renderTag(), _objectSpread$s(_objectSpread$s(_objectSpread$s({
          ref: btnRef
        }, attrs), buttonAttrs), {}, {
          onClick: props2.onClick
        }), [buttonContent]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var Button = withInstall(TButton);
  function _defineProperty(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function ownKeys$r(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$r(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$r(Object(source), true).forEach(function (key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$r(Object(source)).forEach(function (key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  function camel2Kebab(camelString) {
    var covertArr = ["fillOpacity", "fillRule", "clipRule"];
    if (covertArr.includes(camelString)) {
      return camelString.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase();
    }
    return camelString;
  }
  function renderFn(node, props2) {
    var kebabAttrs = Object.keys(node.attrs).reduce((result, key2) => {
      result[camel2Kebab(key2)] = node.attrs[key2];
      return result;
    }, {});
    return h(node.tag, _objectSpread$r(_objectSpread$r({}, kebabAttrs), props2), (node.children || []).map((child) => renderFn(child, {})));
  }
  var DEFAULT_CLASS_PREFIX = "t";
  var ConfigContext = {
    classPrefix: DEFAULT_CLASS_PREFIX
  };
  function useCommonClassName() {
    var {
      classPrefix
    } = ConfigContext;
    return {
      SIZE: {
        default: "",
        xs: "".concat(classPrefix, "-size-xs"),
        small: "".concat(classPrefix, "-size-s"),
        medium: "".concat(classPrefix, "-size-m"),
        large: "".concat(classPrefix, "-size-l"),
        xl: "".concat(classPrefix, "-size-xl"),
        block: "".concat(classPrefix, "-size-full-width")
      },
      STATUS: {
        loading: "".concat(classPrefix, "-is-loading"),
        disabled: "".concat(classPrefix, "-is-disabled"),
        focused: "".concat(classPrefix, "-is-focused"),
        success: "".concat(classPrefix, "-is-success"),
        error: "".concat(classPrefix, "-is-error"),
        warning: "".concat(classPrefix, "-is-warning"),
        selected: "".concat(classPrefix, "-is-selected"),
        active: "".concat(classPrefix, "-is-active"),
        checked: "".concat(classPrefix, "-is-checked"),
        current: "".concat(classPrefix, "-is-current"),
        hidden: "".concat(classPrefix, "-is-hidden"),
        visible: "".concat(classPrefix, "-is-visible"),
        expanded: "".concat(classPrefix, "-is-expanded"),
        indeterminate: "".concat(classPrefix, "-is-indeterminate")
      }
    };
  }
  function useSizeProps(size) {
    var COMMON_SIZE_CLASS_NAMES = useCommonClassName().SIZE;
    var className = computed(() => {
      if (size.value in COMMON_SIZE_CLASS_NAMES) {
        return COMMON_SIZE_CLASS_NAMES[size.value];
      }
      return "";
    });
    var style = computed(() => {
      if (size.value === void 0 || size.value in COMMON_SIZE_CLASS_NAMES) {
        return {};
      }
      return {
        fontSize: size.value
      };
    });
    return {
      style,
      className
    };
  }
  function ownKeys$q(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$q(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$q(Object(source), true).forEach(function (key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$q(Object(source)).forEach(function (key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  var element$9 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 24 24",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M13 4V11L20 11V13L13 13V20H11L11 13H4L4 11L11 11L11 4L13 4Z"
      }
    }]
  };
  var add = /* @__PURE__ */ defineComponent({
    name: "AddIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup(props2, _ref) {
      var {
        attrs
      } = _ref;
      var propsSize = computed(() => props2.size);
      var {
        className,
        style
      } = useSizeProps(propsSize);
      var finalCls = computed(() => ["t-icon", "t-icon-add", className.value]);
      var finalStyle = computed(() => _objectSpread$q(_objectSpread$q({}, style.value), attrs.style));
      var finalProps = computed(() => ({
        class: finalCls.value,
        style: finalStyle.value,
        onClick: (e) => {
          var _props$onClick;
          return (_props$onClick = props2.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props2, {
            e
          });
        }
      }));
      return () => renderFn(element$9, finalProps.value);
    }
  });
  function ownKeys$p(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$p(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$p(Object(source), true).forEach(function (key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$p(Object(source)).forEach(function (key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  var element$8 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 26 24",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M3.99999 1.58582L10.1714 7.75774L17.2425 14.8288L23.4137 21L21.9995 22.4142L19.0345 19.4492C17.2447 20.4377 15.1866 21.0001 12.9996 21.0001C7.42102 21.0001 2.69842 17.3465 1.08922 12.3042L0.992188 12.0001L1.08922 11.6961C1.85645 9.29201 3.33009 7.20571 5.26511 5.67975L2.58567 2.99993L3.99999 1.58582ZM6.69098 7.10574C5.05507 8.33729 3.79122 10.0353 3.09676 12.0001C4.53843 16.0793 8.42915 19.0001 12.9996 19.0001C14.6314 19.0001 16.1745 18.6285 17.5507 17.9655L15.7571 16.1719C14.9668 16.695 14.0185 17.0003 12.9999 17.0003C10.2385 17.0003 7.99989 14.7618 7.99989 12.0003C7.99989 10.9817 8.3052 10.0334 8.82835 9.24312L6.69098 7.10574ZM10.292 10.7068C10.1046 11.0984 9.99989 11.5368 9.99989 12.0003C9.99989 13.6572 11.343 15.0003 12.9999 15.0003C13.4634 15.0003 13.9018 14.8956 14.2934 14.7082L10.292 10.7068ZM13 5.00003C12.4234 5.00003 11.8583 5.04642 11.3081 5.13548L10.321 5.29527L10.0014 3.32097L10.9885 3.16117C11.644 3.05508 12.3159 3.00003 13 3.00003C18.5786 3.00003 23.3012 6.65367 24.9104 11.696L25.0074 12L24.9104 12.3041C24.4968 13.5999 23.878 14.8034 23.0926 15.8763L22.5019 16.6833L20.8881 15.5019L21.4788 14.695C22.0769 13.8778 22.5595 12.9715 22.9028 12C21.4612 7.92082 17.5704 5.00003 13 5.00003ZM13.5132 6.92636L14.4691 7.21985C16.0499 7.70515 17.2953 8.95049 17.7806 10.5313L18.0741 11.4873L16.1621 12.0742L15.8687 11.1183C15.578 10.1715 14.829 9.42243 13.8822 9.13178L12.9262 8.8383L13.5132 6.92636Z"
      }
    }]
  };
  var browseOff = /* @__PURE__ */ defineComponent({
    name: "BrowseOffIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup(props2, _ref) {
      var {
        attrs
      } = _ref;
      var propsSize = computed(() => props2.size);
      var {
        className,
        style
      } = useSizeProps(propsSize);
      var finalCls = computed(() => ["t-icon", "t-icon-browse-off", className.value]);
      var finalStyle = computed(() => _objectSpread$p(_objectSpread$p({}, style.value), attrs.style));
      var finalProps = computed(() => ({
        class: finalCls.value,
        style: finalStyle.value,
        onClick: (e) => {
          var _props$onClick;
          return (_props$onClick = props2.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props2, {
            e
          });
        }
      }));
      return () => renderFn(element$8, finalProps.value);
    }
  });
  function ownKeys$o(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$o(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$o(Object(source), true).forEach(function (key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$o(Object(source)).forEach(function (key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  var element$7 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 24 24",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "g",
      "attrs": {
        "clipPath": "url(#clip0_8726_7319)"
      },
      "children": [{
        "tag": "path",
        "attrs": {
          "fill": "currentColor",
          "d": "M2.09675 12C3.53842 16.0792 7.42915 19 11.9996 19C16.57 19 20.4607 16.0792 21.9024 12C20.4607 7.92079 16.57 5 11.9996 5C7.42915 5 3.53842 7.92079 2.09675 12ZM0.0892162 11.696C1.69842 6.65364 6.42102 3 11.9996 3C17.5781 3 22.3007 6.65364 23.9099 11.696L24.007 12L23.9099 12.304C22.3007 17.3464 17.5781 21 11.9996 21C6.42102 21 1.69842 17.3464 0.0892162 12.304L-0.0078125 12L0.0892162 11.696ZM11.9999 9C10.343 9 8.99989 10.3431 8.99989 12C8.99989 13.6569 10.343 15 11.9999 15C13.6567 15 14.9999 13.6569 14.9999 12C14.9999 10.3431 13.6567 9 11.9999 9ZM6.99989 12C6.99989 9.23858 9.23846 7 11.9999 7C14.7613 7 16.9999 9.23858 16.9999 12C16.9999 14.7614 14.7613 17 11.9999 17C9.23846 17 6.99989 14.7614 6.99989 12Z"
        }
      }]
    }]
  };
  var browse = /* @__PURE__ */ defineComponent({
    name: "BrowseIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup(props2, _ref) {
      var {
        attrs
      } = _ref;
      var propsSize = computed(() => props2.size);
      var {
        className,
        style
      } = useSizeProps(propsSize);
      var finalCls = computed(() => ["t-icon", "t-icon-browse", className.value]);
      var finalStyle = computed(() => _objectSpread$o(_objectSpread$o({}, style.value), attrs.style));
      var finalProps = computed(() => ({
        class: finalCls.value,
        style: finalStyle.value,
        onClick: (e) => {
          var _props$onClick;
          return (_props$onClick = props2.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props2, {
            e
          });
        }
      }));
      return () => renderFn(element$7, finalProps.value);
    }
  });
  function ownKeys$n(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$n(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$n(Object(source), true).forEach(function (key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$n(Object(source)).forEach(function (key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  var element$6 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 24 24",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23ZM7.49985 10.5858L10.4999 13.5858L16.4999 7.58578L17.9141 8.99999L10.4999 16.4142L6.08564 12L7.49985 10.5858Z"
      }
    }]
  };
  var checkCircleFilled = /* @__PURE__ */ defineComponent({
    name: "CheckCircleFilledIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup(props2, _ref) {
      var {
        attrs
      } = _ref;
      var propsSize = computed(() => props2.size);
      var {
        className,
        style
      } = useSizeProps(propsSize);
      var finalCls = computed(() => ["t-icon", "t-icon-check-circle-filled", className.value]);
      var finalStyle = computed(() => _objectSpread$n(_objectSpread$n({}, style.value), attrs.style));
      var finalProps = computed(() => ({
        class: finalCls.value,
        style: finalStyle.value,
        onClick: (e) => {
          var _props$onClick;
          return (_props$onClick = props2.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props2, {
            e
          });
        }
      }));
      return () => renderFn(element$6, finalProps.value);
    }
  });
  function ownKeys$m(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$m(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$m(Object(source), true).forEach(function (key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$m(Object(source)).forEach(function (key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  var element$5 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 24 24",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M15.9144 17.5L10.4144 12L15.9144 6.50003L14.5002 5.08582L7.58594 12L14.5002 18.9142L15.9144 17.5Z"
      }
    }]
  };
  var chevronLeft = /* @__PURE__ */ defineComponent({
    name: "ChevronLeftIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup(props2, _ref) {
      var {
        attrs
      } = _ref;
      var propsSize = computed(() => props2.size);
      var {
        className,
        style
      } = useSizeProps(propsSize);
      var finalCls = computed(() => ["t-icon", "t-icon-chevron-left", className.value]);
      var finalStyle = computed(() => _objectSpread$m(_objectSpread$m({}, style.value), attrs.style));
      var finalProps = computed(() => ({
        class: finalCls.value,
        style: finalStyle.value,
        onClick: (e) => {
          var _props$onClick;
          return (_props$onClick = props2.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props2, {
            e
          });
        }
      }));
      return () => renderFn(element$5, finalProps.value);
    }
  });
  function ownKeys$l(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$l(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$l(Object(source), true).forEach(function (key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$l(Object(source)).forEach(function (key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  var element$4 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 24 24",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8.08594 17.5L13.5859 12L8.08594 6.50003L9.50015 5.08582L16.4144 12L9.50015 18.9142L8.08594 17.5Z"
      }
    }]
  };
  var chevronRight = /* @__PURE__ */ defineComponent({
    name: "ChevronRightIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup(props2, _ref) {
      var {
        attrs
      } = _ref;
      var propsSize = computed(() => props2.size);
      var {
        className,
        style
      } = useSizeProps(propsSize);
      var finalCls = computed(() => ["t-icon", "t-icon-chevron-right", className.value]);
      var finalStyle = computed(() => _objectSpread$l(_objectSpread$l({}, style.value), attrs.style));
      var finalProps = computed(() => ({
        class: finalCls.value,
        style: finalStyle.value,
        onClick: (e) => {
          var _props$onClick;
          return (_props$onClick = props2.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props2, {
            e
          });
        }
      }));
      return () => renderFn(element$4, finalProps.value);
    }
  });
  function ownKeys$k(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$k(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$k(Object(source), true).forEach(function (key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$k(Object(source)).forEach(function (key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  var element$3 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 24 24",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23ZM8.81753 7.40346L11.9999 10.5858L15.1815 7.40414L16.5957 8.81835L13.4141 12L16.5957 15.1816L15.1815 16.5958L11.9999 13.4142L8.81753 16.5965L7.40332 15.1823L10.5856 12L7.40332 8.81767L8.81753 7.40346Z"
      }
    }]
  };
  var closeCircleFilled = /* @__PURE__ */ defineComponent({
    name: "CloseCircleFilledIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup(props2, _ref) {
      var {
        attrs
      } = _ref;
      var propsSize = computed(() => props2.size);
      var {
        className,
        style
      } = useSizeProps(propsSize);
      var finalCls = computed(() => ["t-icon", "t-icon-close-circle-filled", className.value]);
      var finalStyle = computed(() => _objectSpread$k(_objectSpread$k({}, style.value), attrs.style));
      var finalProps = computed(() => ({
        class: finalCls.value,
        style: finalStyle.value,
        onClick: (e) => {
          var _props$onClick;
          return (_props$onClick = props2.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props2, {
            e
          });
        }
      }));
      return () => renderFn(element$3, finalProps.value);
    }
  });
  function ownKeys$j(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$j(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$j(Object(source), true).forEach(function (key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$j(Object(source)).forEach(function (key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  var element$2 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 24 24",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M7.04996 5.63599L11.9997 10.5857L16.9494 5.63599L18.3637 7.0502L13.4139 11.9999L18.3637 16.9497L16.9494 18.3639L11.9997 13.4142L7.04996 18.3639L5.63574 16.9497L10.5855 11.9999L5.63574 7.0502L7.04996 5.63599Z"
      }
    }]
  };
  var close = /* @__PURE__ */ defineComponent({
    name: "CloseIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup(props2, _ref) {
      var {
        attrs
      } = _ref;
      var propsSize = computed(() => props2.size);
      var {
        className,
        style
      } = useSizeProps(propsSize);
      var finalCls = computed(() => ["t-icon", "t-icon-close", className.value]);
      var finalStyle = computed(() => _objectSpread$j(_objectSpread$j({}, style.value), attrs.style));
      var finalProps = computed(() => ({
        class: finalCls.value,
        style: finalStyle.value,
        onClick: (e) => {
          var _props$onClick;
          return (_props$onClick = props2.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props2, {
            e
          });
        }
      }));
      return () => renderFn(element$2, finalProps.value);
    }
  });
  function ownKeys$i(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$i(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$i(Object(source), true).forEach(function (key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$i(Object(source)).forEach(function (key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  var element$1 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 24 24",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M12 1C18.0751 1 23 5.92487 23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12C1 5.92487 5.92487 1 12 1ZM11.0001 14H13.0001V6.49998H11.0001V14ZM13.004 15.5H11.0001V17.5039H13.004V15.5Z"
      }
    }]
  };
  var errorCircleFilled = /* @__PURE__ */ defineComponent({
    name: "ErrorCircleFilledIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup(props2, _ref) {
      var {
        attrs
      } = _ref;
      var propsSize = computed(() => props2.size);
      var {
        className,
        style
      } = useSizeProps(propsSize);
      var finalCls = computed(() => ["t-icon", "t-icon-error-circle-filled", className.value]);
      var finalStyle = computed(() => _objectSpread$i(_objectSpread$i({}, style.value), attrs.style));
      var finalProps = computed(() => ({
        class: finalCls.value,
        style: finalStyle.value,
        onClick: (e) => {
          var _props$onClick;
          return (_props$onClick = props2.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props2, {
            e
          });
        }
      }));
      return () => renderFn(element$1, finalProps.value);
    }
  });
  function ownKeys$h(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$h(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$h(Object(source), true).forEach(function (key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$h(Object(source)).forEach(function (key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  var element = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 24 24",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23ZM10.996 8.50002V6.49611H12.9999V8.50002H10.996ZM12.9999 10L12.9999 17.5H10.9999V10L12.9999 10Z"
      }
    }]
  };
  var infoCircleFilled = /* @__PURE__ */ defineComponent({
    name: "InfoCircleFilledIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup(props2, _ref) {
      var {
        attrs
      } = _ref;
      var propsSize = computed(() => props2.size);
      var {
        className,
        style
      } = useSizeProps(propsSize);
      var finalCls = computed(() => ["t-icon", "t-icon-info-circle-filled", className.value]);
      var finalStyle = computed(() => _objectSpread$h(_objectSpread$h({}, style.value), attrs.style));
      var finalProps = computed(() => ({
        class: finalCls.value,
        style: finalStyle.value,
        onClick: (e) => {
          var _props$onClick;
          return (_props$onClick = props2.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props2, {
            e
          });
        }
      }));
      return () => renderFn(element, finalProps.value);
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function useListener(type, listener) {
    onMounted(function () {
      window.addEventListener(type, listener);
    });
    onBeforeUnmount(function () {
      window.removeEventListener(type, listener);
    });
  }
  function useResize(listener, observer) {
    useListener("resize", listener);
    var resizeObserver = null;
    onMounted(function () {
      if (!window.ResizeObserver || !observer) return;
      resizeObserver = new window.ResizeObserver(listener);
      resizeObserver.observe(observer);
    });
    onBeforeUnmount(function () {
      var _resizeObserver;
      (_resizeObserver = resizeObserver) === null || _resizeObserver === void 0 || _resizeObserver.disconnect();
    });
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function useChildComponentSlots() {
    var instance = getCurrentInstance();
    return function (childComponentName, slots) {
      var _slots, _slots$default;
      if (!slots) {
        slots = instance.slots;
      }
      var content = ((_slots = slots) === null || _slots === void 0 || (_slots$default = _slots["default"]) === null || _slots$default === void 0 ? void 0 : _slots$default.call(_slots)) || [];
      return getChildren(content).filter(function (item) {
        var _item$type$name;
        return (_item$type$name = item.type.name) === null || _item$type$name === void 0 ? void 0 : _item$type$name.endsWith(childComponentName);
      });
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function asyncGeneratorStep(n, t, e, r, o, a, c) {
    try {
      var i = n[a](c), u = i.value;
    } catch (n2) {
      return void e(n2);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
  }
  function _asyncToGenerator(n) {
    return function () {
      var t = this, e = arguments;
      return new Promise(function (r, o) {
        var a = n.apply(t, e);
        function _next(n2) {
          asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
        }
        function _throw(n2) {
          asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
        }
        _next(void 0);
      });
    };
  }
  var regeneratorRuntime$2 = { exports: {} };
  var _typeof$1 = { exports: {} };
  (function (module2) {
    function _typeof2(o) {
      "@babel/helpers - typeof";
      return module2.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o2) {
        return typeof o2;
      } : function (o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof2(o);
    }
    module2.exports = _typeof2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  })(_typeof$1);
  (function (module2) {
    var _typeof2 = _typeof$1.exports["default"];
    function _regeneratorRuntime() {
      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
      module2.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define(t2, e2, r2) {
        return Object.defineProperty(t2, e2, {
          value: r2,
          enumerable: true,
          configurable: true,
          writable: true
        }), t2[e2];
      }
      try {
        define({}, "");
      } catch (t2) {
        define = function define2(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", {
          value: makeInvokeMethod(t2, r2, c2)
        }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return {
            type: "normal",
            arg: t2.call(e2, r2)
          };
        } catch (t3) {
          return {
            type: "throw",
            arg: t3
          };
        }
      }
      e.wrap = wrap;
      var h2 = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p2 = {};
      define(p2, a, function () {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p2 = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p2);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function (e2) {
          define(t2, e2, function (t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h3 = u2.value;
            return h3 && "object" == _typeof2(h3) && n.call(h3, "__await") ? e2.resolve(h3.__await).then(function (t3) {
              invoke("next", t3, i2, a2);
            }, function (t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h3).then(function (t3) {
              u2.value = t3, i2(u2);
            }, function (t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", {
          value: function value(t3, n2) {
            function callInvokeWithMethodAndArg() {
              return new e2(function (e3, r3) {
                invoke(t3, n2, e3, r3);
              });
            }
            return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h2;
        return function (i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return {
              value: t,
              done: true
            };
          }
          for (n2.method = i2, n2.arg = a2; ;) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h2) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p3 = tryCatch(e2, r2, n2);
            if ("normal" === p3.type) {
              if (o2 = n2.done ? s : l, p3.arg === y) continue;
              return {
                value: p3.arg,
                done: n2.done
              };
            }
            "throw" === p3.type && (o2 = s, n2.method = "throw", n2.arg = p3.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = {
          tryLoc: t2[0]
        };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length;) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof2(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), o(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function (t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function (t2) {
        return {
          __await: t2
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function (t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function (t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
        return this;
      }), define(g, "toString", function () {
        return "[object Generator]";
      }), e.keys = function (t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length;) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(e2) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
        },
        stop: function stop() {
          this.done = true;
          var t2 = this.tryEntries[0].completion;
          if ("throw" === t2.type) throw t2.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(e2) {
          if (this.done) throw e2;
          var r2 = this;
          function handle(n2, o3) {
            return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
          }
          for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
            var i2 = this.tryEntries[o2], a2 = i2.completion;
            if ("root" === i2.tryLoc) return handle("end");
            if (i2.tryLoc <= this.prev) {
              var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
              if (c2 && u2) {
                if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
                if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
              } else if (c2) {
                if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              } else {
                if (!u2) throw Error("try statement without catch or finally");
                if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(t2, e2) {
          for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
            var o2 = this.tryEntries[r2];
            if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
              var i2 = o2;
              break;
            }
          }
          i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
          var a2 = i2 ? i2.completion : {};
          return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
        },
        complete: function complete(t2, e2) {
          if ("throw" === t2.type) throw t2.arg;
          return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
        },
        finish: function finish(t2) {
          for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
            var r2 = this.tryEntries[e2];
            if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
          }
        },
        "catch": function _catch(t2) {
          for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
            var r2 = this.tryEntries[e2];
            if (r2.tryLoc === t2) {
              var n2 = r2.completion;
              if ("throw" === n2.type) {
                var o2 = n2.arg;
                resetTryEntry(r2);
              }
              return o2;
            }
          }
          throw Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(e2, r2, n2) {
          return this.delegate = {
            iterator: values(e2),
            resultName: r2,
            nextLoc: n2
          }, "next" === this.method && (this.arg = t), y;
        }
      }, e;
    }
    module2.exports = _regeneratorRuntime, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
  })(regeneratorRuntime$2);
  /* @__PURE__ */ getDefaultExportFromCjs(regeneratorRuntime$2.exports);
  var runtime = regeneratorRuntime$2.exports();
  var regenerator = runtime;
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if ((typeof globalThis === "undefined" ? "undefined" : _typeof$2(globalThis)) === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function useGlobalIcon(tdIcon) {
    var _useConfig = useConfig("icon"), globalConfig = _useConfig.globalConfig;
    var resultIcon = {};
    Object.keys(tdIcon).forEach(function (key2) {
      var _globalConfig$value;
      resultIcon[key2] = ((_globalConfig$value = globalConfig.value) === null || _globalConfig$value === void 0 ? void 0 : _globalConfig$value[key2]) || tdIcon[key2];
    });
    return resultIcon;
  }
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function (acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
  function getNodeName(element2) {
    return element2 ? (element2.nodeName || "").toLowerCase() : null;
  }
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function (name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element2 = state.elements[name];
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style);
      Object.keys(attributes).forEach(function (name2) {
        var value = attributes[name2];
        if (value === false) {
          element2.removeAttribute(name2);
        } else {
          element2.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect$2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function () {
      Object.keys(state.elements).forEach(function (name) {
        var element2 = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style = styleProperties.reduce(function (style2, property2) {
          style2[property2] = "";
          return style2;
        }, {});
        if (!isHTMLElement(element2) || !getNodeName(element2)) {
          return;
        }
        Object.assign(element2.style, style);
        Object.keys(attributes).forEach(function (attribute) {
          element2.removeAttribute(attribute);
        });
      });
    };
  }
  const applyStyles$1 = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect: effect$2,
    requires: ["computeStyles"]
  };
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }
  var max = Math.max;
  var min = Math.min;
  var round = Math.round;
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function (item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }
  function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element2.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement(element2)) {
      scaleX = element2.offsetWidth > 0 ? round(clientRect.width) / element2.offsetWidth || 1 : 1;
      scaleY = element2.offsetHeight > 0 ? round(clientRect.height) / element2.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width,
      height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x,
      x,
      y
    };
  }
  function getLayoutRect(element2) {
    var clientRect = getBoundingClientRect(element2);
    var width = element2.offsetWidth;
    var height = element2.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element2.offsetLeft,
      y: element2.offsetTop,
      width,
      height
    };
  }
  function contains(parent2, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent2.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent2.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }
  function getComputedStyle$1(element2) {
    return getWindow(element2).getComputedStyle(element2);
  }
  function isTableElement(element2) {
    return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
  }
  function getDocumentElement(element2) {
    return ((isElement(element2) ? element2.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element2.document
    )) || window.document).documentElement;
  }
  function getParentNode(element2) {
    if (getNodeName(element2) === "html") {
      return element2;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element2.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element2.parentNode || // DOM Element detected
      (isShadowRoot(element2) ? element2.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element2)
    );
  }
  function getTrueOffsetParent(element2) {
    if (!isHTMLElement(element2) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element2).position === "fixed") {
      return null;
    }
    return element2.offsetParent;
  }
  function getContainingBlock(element2) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement(element2)) {
      var elementCss = getComputedStyle$1(element2);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element2);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle$1(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element2) {
    var window2 = getWindow(element2);
    var offsetParent = getTrueOffsetParent(element2);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element2) || window2;
  }
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }
  function within(min$1, value, max$1) {
    return max(min$1, min(value, max$1));
  }
  function withinMaxClamp(min2, value, max2) {
    var v = within(min2, value, max2);
    return v > max2 ? max2 : v;
  }
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }
  function expandToHashMap(value, keys2) {
    return keys2.reduce(function (hashMap, key2) {
      hashMap[key2] = value;
      return hashMap;
    }, {});
  }
  var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect$1(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }
    state.elements.arrow = arrowElement;
  }
  const arrow$1 = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect$1,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };
  function getVariation(placement) {
    return placement.split("-")[1];
  }
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref, win) {
    var x = _ref.x, y = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x,
      y
    }, getWindow(popper2)) : {
      x,
      y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  const computeStyles$1 = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };
  var passive = {
    passive: true
  };
  function effect(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function () {
      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  const eventListeners = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect,
    data: {}
  };
  var hash$1 = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash$1[matched];
    });
  }
  var hash = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function (matched) {
      return hash[matched];
    });
  }
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }
  function getWindowScrollBarX(element2) {
    return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
  }
  function getViewportRect(element2, strategy) {
    var win = getWindow(element2);
    var html = getDocumentElement(element2);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x + getWindowScrollBarX(element2),
      y
    };
  }
  function getDocumentRect(element2) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element2);
    var winScroll = getWindowScroll(element2);
    var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element2);
    var y = -winScroll.scrollTop;
    if (getComputedStyle$1(body || html).direction === "rtl") {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }
  function isScrollParent(element2) {
    var _getComputedStyle = getComputedStyle$1(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }
  function listScrollParents(element2, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element2);
    var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }
  function getInnerBoundingClientRect(element2, strategy) {
    var rect = getBoundingClientRect(element2, false, strategy === "fixed");
    rect.top = rect.top + element2.clientTop;
    rect.left = rect.left + element2.clientLeft;
    rect.bottom = rect.top + element2.clientHeight;
    rect.right = rect.left + element2.clientWidth;
    rect.width = element2.clientWidth;
    rect.height = element2.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element2, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
  }
  function getClippingParents(element2) {
    var clippingParents2 = listScrollParents(getParentNode(element2));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element2).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function (clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element2, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function (accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element2.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element2.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
          break;
      }
    }
    return offsets;
  }
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element2 = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function (key2) {
        var multiply = [right, bottom].indexOf(key2) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key2) >= 0 ? "y" : "x";
        overflowOffsets[key2] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements$1.filter(function (placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements$1;
    }
    var overflows = allowedPlacements.reduce(function (acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function (a, b) {
      return overflows[a] - overflows[b];
    });
  }
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip$1(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i = 0; i < placements2.length; i++) {
      var placement = placements2[i];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function (check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function (placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function (check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break") break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  const flip$2 = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip$1,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function (side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  const hide$1 = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function (acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
  }
  const offset$1 = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      placement: state.placement
    });
  }
  const popperOffsets$1 = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min$1 = offset2 + overflow[mainSide];
      var max$1 = offset2 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset2 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  const preventOverflow$1 = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };
  function getHTMLElementScroll(element2) {
    return {
      scrollLeft: element2.scrollLeft,
      scrollTop: element2.scrollTop
    };
  }
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }
  function isElementScaled(element2) {
    var rect = element2.getBoundingClientRect();
    var scaleX = round(rect.width) / element2.offsetWidth || 1;
    var scaleY = round(rect.height) / element2.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }
  function order(modifiers) {
    var map2 = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function (modifier) {
      map2.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function (dep) {
        if (!visited.has(dep)) {
          var depModifier = map2.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function (modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function (acc, phase) {
      return acc.concat(orderedModifiers.filter(function (modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }
  function debounce(fn2) {
    var pending;
    return function () {
      if (!pending) {
        pending = new Promise(function (resolve2) {
          Promise.resolve().then(function () {
            pending = void 0;
            resolve2(fn2());
          });
        });
      }
      return pending;
    };
  }
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function (merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function (key2) {
      return merged[key2];
    });
  }
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function (element2) {
      return !(element2 && typeof element2.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function (m) {
            return m.enabled;
          });
          runModifierEffects();
          return instance.update();
        },
        // Sync update – it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function (modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update – it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function () {
          return new Promise(function (resolve2) {
            instance.forceUpdate();
            resolve2(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        return instance;
      }
      instance.setOptions(options).then(function (state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function (_ref) {
          var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
          if (typeof effect2 === "function") {
            var cleanupFn = effect2({
              state,
              name,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function (fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }
  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$2, preventOverflow$1, arrow$1, hide$1];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function useDefaultValue(value, defaultValue, onChange, propsName) {
    var _getCurrentInstance = getCurrentInstance(), emit2 = _getCurrentInstance.emit, vnode = _getCurrentInstance.vnode;
    var internalValue = ref();
    var vProps = vnode.props || {};
    var isVMP = Object.prototype.hasOwnProperty.call(vProps, propsName) || Object.prototype.hasOwnProperty.call(vProps, kebabCase(propsName));
    if (isVMP) {
      return [value, function (newValue) {
        emit2("update:".concat(propsName), newValue);
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        onChange === null || onChange === void 0 || onChange.apply(void 0, [newValue].concat(args));
      }];
    }
    internalValue.value = defaultValue;
    return [internalValue, function (newValue) {
      internalValue.value = newValue;
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      onChange === null || onChange === void 0 || onChange.apply(void 0, [newValue].concat(args));
    }];
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var TDisplayNoneElementRefresh = "t-display-none-element-refresh";
  function useDestroyOnClose() {
    var refresh = ref(0);
    provide(TDisplayNoneElementRefresh, refresh);
    onUpdated(function () {
      refresh.value += 1;
    });
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function ownKeys$g(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$g(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$g(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$g(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var useVirtualScroll = function useVirtualScroll2(_ref) {
    var data = _ref.data, container = _ref.container, _ref$fixedHeight = _ref.fixedHeight, fixedHeight = _ref$fixedHeight === void 0 ? false : _ref$fixedHeight, _ref$lineHeight = _ref.lineHeight, lineHeight = _ref$lineHeight === void 0 ? 30 : _ref$lineHeight, _ref$bufferSize = _ref.bufferSize, bufferSize = _ref$bufferSize === void 0 ? 20 : _ref$bufferSize, _ref$threshold = _ref.threshold, threshold = _ref$threshold === void 0 ? 100 : _ref$threshold;
    var state = reactive({
      visibleData: [],
      cachedHeight: [],
      cachedScrollY: []
    });
    var isVirtual = computed(function () {
      return data.value.length > threshold;
    });
    var updateId = ref(0);
    var trs = /* @__PURE__ */ new Map();
    var visibleCount = 0;
    var beforeScrollTop = 0;
    var index = 0;
    var offset2 = 0;
    var start2 = 0;
    var last = 0;
    var reset = function reset2() {
      data.value.forEach(function (item, i) {
        item.$index = i;
        if (fixedHeight) {
          state.cachedScrollY[i] = i * lineHeight;
        }
      });
      if (!fixedHeight) {
        state.cachedScrollY[data.value.length - 1] = void 0;
      }
    };
    reset();
    var scrollHeight = computed(function () {
      var cachedHeight = state.cachedHeight;
      var length = cachedHeight.length;
      if (length) {
        var maxScrollY = cachedHeight.reduce(function (sum, v) {
          return sum + v || lineHeight;
        }, 0);
        if (cachedHeight.length === data.value.length) {
          return maxScrollY;
        }
        var average = maxScrollY / cachedHeight.length;
        return maxScrollY + (data.value.length - cachedHeight.length) * average;
      }
      return isVirtual.value ? data.value.length * lineHeight : 0;
    });
    var translateY = computed(function () {
      var visibleData = state.visibleData;
      var firstRow = visibleData[0];
      if (firstRow) {
        return visibleData.length === 1 ? 0 : state.cachedScrollY[firstRow.$index];
      }
      return 0;
    });
    var updateVisibleData = function updateVisibleData2() {
      last = Math.min(start2 + visibleCount + bufferSize * 2, data.value.length);
      state.visibleData = data.value.slice(start2, last);
    };
    var calculateScrollY = function calculateScrollY2() {
      var _anchorDom$getBoundin;
      var anchorDom = trs.get(index);
      if (!anchorDom) {
        return;
      }
      var anchorDomHeight = anchorDom === null || anchorDom === void 0 || (_anchorDom$getBoundin = anchorDom.getBoundingClientRect()) === null || _anchorDom$getBoundin === void 0 ? void 0 : _anchorDom$getBoundin.height;
      state.cachedScrollY[index] = container.value.scrollTop - offset2;
      state.cachedHeight[index] = anchorDomHeight;
      for (var i = index + 1; i <= ((_state$visibleData = state.visibleData[state.visibleData.length - 1]) === null || _state$visibleData === void 0 ? void 0 : _state$visibleData.$index); i++) {
        var _state$visibleData;
        var tr = trs.get(i);
        var _ref2 = (tr === null || tr === void 0 ? void 0 : tr.getBoundingClientRect()) || {}, height = _ref2.height;
        state.cachedHeight[i] = height;
        var scrollY = state.cachedScrollY[i - 1] + state.cachedHeight[i - 1];
        state.cachedScrollY.splice(i, 1, scrollY);
      }
      for (var _i = index - 1; _i >= ((_state$visibleData$ = state.visibleData[0]) === null || _state$visibleData$ === void 0 ? void 0 : _state$visibleData$.$index); _i--) {
        var _state$visibleData$;
        var _tr = trs.get(_i);
        var _ref3 = (_tr === null || _tr === void 0 ? void 0 : _tr.getBoundingClientRect()) || {}, _height = _ref3.height;
        state.cachedHeight[_i] = _height;
        var _scrollY = state.cachedScrollY[_i + 1] - state.cachedHeight[_i];
        state.cachedScrollY.splice(_i, 1, _scrollY);
      }
      if (state.cachedScrollY[0] > 0) {
        var distance = state.cachedScrollY[0];
        var length = Math.min(last, data.value.length);
        for (var _i2 = 0; _i2 < length; _i2++) {
          state.cachedScrollY.splice(_i2, 1, state.cachedScrollY[_i2] - distance);
        }
        var scrollTop = state.cachedScrollY[index - 1] ? state.cachedScrollY[index - 1] + offset2 : offset2;
        container.value.scrollTop = scrollTop;
        beforeScrollTop = scrollTop;
      }
      if (state.cachedScrollY[start2] < 0) {
        var s = state.cachedHeight.slice(0, Math.max(0, index)).reduce(function (sum, v) {
          return sum + v;
        }, 0) + offset2;
        container.value.scrollTop = s;
        beforeScrollTop = s;
        if (s === 0) {
          index = 0;
          offset2 = 0;
        }
      }
      nextTick(function () {
        var _container$value = container.value, scrollTop2 = _container$value.scrollTop, scrollHeight2 = _container$value.scrollHeight, clientHeight = _container$value.clientHeight;
        if (scrollTop2 + clientHeight === scrollHeight2) {
          for (var _i3 = last - 1; _i3 >= start2; _i3--) {
            if (_i3 === last - 1) {
              state.cachedScrollY.splice(_i3, 1, scrollHeight2.value - state.cachedHeight[_i3]);
            } else {
              state.cachedScrollY.splice(_i3, 1, state.cachedScrollY[_i3 + 1] - state.cachedHeight[_i3]);
            }
          }
        }
      });
    };
    var handleScroll = function handleScroll2() {
      if (!isVirtual.value) return;
      var scrollTop = container.value.scrollTop;
      var distance = scrollTop - beforeScrollTop;
      beforeScrollTop = scrollTop;
      distance += offset2;
      var lastIndex = index;
      if (!distance) return;
      if (distance >= 0) {
        while (lastIndex < data.value.length && distance > (state.cachedHeight[lastIndex] || lineHeight)) {
          if (!state.cachedHeight[lastIndex]) {
            state.cachedHeight[lastIndex] = lineHeight;
          }
          distance -= state.cachedHeight[lastIndex];
          lastIndex++;
        }
        if (lastIndex >= data.value.length) {
          index = data.value.length - 1;
          offset2 = 0;
        } else {
          index = lastIndex;
          offset2 = distance;
        }
        var _container$value2 = container.value, clientHeight = _container$value2.clientHeight, scrollHeight2 = _container$value2.scrollHeight;
        if (scrollTop + clientHeight === scrollHeight2) {
          index = data.value.length - visibleCount + 1;
        }
        if (start2 <= index - bufferSize) {
          start2 = Math.min(data.value.length - visibleCount, index - bufferSize);
          if (start2 < 0) {
            start2 = 0;
          }
        }
      } else {
        while (distance < 0) {
          lastIndex--;
          if (!state.cachedHeight[lastIndex]) {
            state.cachedHeight[lastIndex] = lineHeight;
          }
          distance += state.cachedHeight[lastIndex];
        }
        if (lastIndex < 0) {
          index = 0;
          offset2 = 0;
        } else {
          index = lastIndex;
          offset2 = distance;
        }
        calculateScrollY();
        if (start2 > index - bufferSize) {
          start2 = Math.max(0, index - bufferSize);
        }
      }
      updateVisibleData();
    };
    !fixedHeight && watch(updateId, calculateScrollY, {
      flush: "post"
    });
    var handleRowMounted = function handleRowMounted2() {
      if (!isVirtual.value) return;
      updateId.value++;
    };
    watch(data, function () {
      reset();
      state.visibleData = [];
      state.cachedScrollY = [];
      state.cachedHeight = [];
      beforeScrollTop = 0;
      index = 0;
      offset2 = 0;
      start2 = 0;
      trs.clear();
      if (data.value.length <= threshold) {
        state.visibleData = data.value;
      } else {
        updateVisibleData();
      }
      container.value && (container.value.scrollTop = 0);
    });
    var mounted2 = false;
    var refreshContainer = function refreshContainer2() {
      if (mounted2) {
        visibleCount = Math.ceil(container.value.offsetHeight / lineHeight);
        updateVisibleData();
      }
    };
    onMounted(function () {
      if (!window || !window.IntersectionObserver) {
        return;
      }
      var ob = new window.IntersectionObserver(function (entries) {
        var entry = entries[0];
        if (entry.isIntersecting || entry.intersectionRatio) {
          mounted2 = true;
          isVirtual.value && refreshContainer();
          ob.unobserve(container.value);
        }
      });
      container.value && ob.observe(container.value);
    });
    return _objectSpread$g(_objectSpread$g({
      trs,
      scrollHeight
    }, toRefs(state)), {}, {
      translateY,
      handleScroll,
      handleRowMounted,
      refreshContainer,
      fixedHeight,
      calculateScrollY
    });
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function useVModel(value, modelValue, defaultValue, onChange) {
    var propName = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "value";
    var _getCurrentInstance = getCurrentInstance(), emit2 = _getCurrentInstance.emit, vnode = _getCurrentInstance.vnode;
    var internalValue = ref();
    var vProps = vnode.props || {};
    var isVM = Object.prototype.hasOwnProperty.call(vProps, "modelValue") || Object.prototype.hasOwnProperty.call(vProps, "model-value");
    var isVMP = Object.prototype.hasOwnProperty.call(vProps, propName) || Object.prototype.hasOwnProperty.call(vProps, kebabCase(propName));
    if (isVM) {
      return [modelValue, function (newValue) {
        emit2("update:modelValue", newValue);
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        onChange === null || onChange === void 0 || onChange.apply(void 0, [newValue].concat(args));
      }];
    }
    if (isVMP) {
      return [value, function (newValue) {
        emit2("update:".concat(propName), newValue);
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        onChange === null || onChange === void 0 || onChange.apply(void 0, [newValue].concat(args));
      }];
    }
    internalValue.value = defaultValue;
    return [internalValue, function (newValue) {
      internalValue.value = newValue;
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      onChange === null || onChange === void 0 || onChange.apply(void 0, [newValue].concat(args));
    }];
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var logSet = /* @__PURE__ */ new Set();
  var log = {
    warn: function warn2(componentName, message2) {
      console.warn("TDesign ".concat(componentName, " Warn: ").concat(message2));
    },
    warnOnce: function warnOnce(componentName, message2) {
      var msgContent = "TDesign ".concat(componentName, " Warn: ").concat(message2);
      if (logSet.has(msgContent)) return;
      logSet.add(msgContent);
      console.warn(msgContent);
    },
    error: function error(componentName, message2) {
      console.error("TDesign ".concat(componentName, " Error: ").concat(message2));
    },
    errorOnce: function errorOnce(componentName, message2) {
      var msgContent = "TDesign ".concat(componentName, " Error: ").concat(message2);
      if (logSet.has(msgContent)) return;
      logSet.add(msgContent);
      console.error(msgContent);
    },
    info: function info(componentName, message2) {
      console.info("TDesign ".concat(componentName, " Info: ").concat(message2));
    }
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var popupProps = {
    attach: {
      type: [String, Function],
      "default": "body"
    },
    content: {
      type: [String, Function]
    },
    "default": {
      type: [String, Function]
    },
    delay: {
      type: [Number, Array]
    },
    destroyOnClose: Boolean,
    disabled: Boolean,
    hideEmptyPopup: Boolean,
    overlayClassName: {
      type: [String, Object, Array]
    },
    overlayInnerClassName: {
      type: [String, Object, Array]
    },
    overlayInnerStyle: {
      type: [Boolean, Object, Function]
    },
    overlayStyle: {
      type: [Boolean, Object, Function]
    },
    placement: {
      type: String,
      "default": "top"
    },
    popperOptions: {
      type: Object
    },
    showArrow: Boolean,
    trigger: {
      type: String,
      "default": "hover",
      validator: function validator7(val) {
        if (!val) return true;
        return ["hover", "click", "focus", "mousedown", "context-menu"].includes(val);
      }
    },
    triggerElement: {
      type: [String, Function]
    },
    visible: {
      type: Boolean,
      "default": void 0
    },
    modelValue: {
      type: Boolean,
      "default": void 0
    },
    defaultVisible: Boolean,
    zIndex: {
      type: Number
    },
    onOverlayClick: Function,
    onScroll: Function,
    onScrollToBottom: Function,
    onVisibleChange: Function
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function useResizeObserver(container, callback) {
    if (typeof window === "undefined") return;
    var isSupport = window && window.ResizeObserver;
    if (!isSupport) return;
    var containerObserver = null;
    var cleanupObserver = function cleanupObserver2() {
      if (!containerObserver || !container.value) return;
      containerObserver.unobserve(container.value);
      containerObserver.disconnect();
      containerObserver = null;
    };
    var addObserver = function addObserver2(el) {
      containerObserver = new ResizeObserver(callback);
      containerObserver.observe(el);
    };
    container && watch(container, function (el) {
      cleanupObserver();
      el && addObserver(el);
    }, {
      immediate: true,
      flush: "post"
    });
    onBeforeUnmount(function () {
      cleanupObserver();
    });
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function _isSlot$5(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
  }
  function filterEmpty() {
    var children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var vnodes = [];
    children.forEach(function (child) {
      if (isArray(child)) {
        vnodes.push.apply(vnodes, _toConsumableArray(child));
      } else if (child.type === Fragment) {
        vnodes.push.apply(vnodes, _toConsumableArray(filterEmpty(child.children)));
      } else {
        vnodes.push(child);
      }
    });
    return vnodes.filter(function (c) {
      return !(c && (c.type === Comment || c.type === Fragment && c.children.length === 0 || c.type === Text && c.children.trim() === ""));
    });
  }
  function isRectChanged(rect1, rect2) {
    if (!rect1 && !rect2) return false;
    if (!rect1 || !rect2) return true;
    if (["width", "height", "x", "y"].some(function (k) {
      return rect1[k] !== rect2[k];
    })) {
      return true;
    }
    return false;
  }
  function useElement(getter) {
    var instance = getCurrentInstance();
    var el = ref();
    onMounted(function () {
      el.value = getter(instance);
    });
    onUpdated(function () {
      var newEl = getter(instance);
      if (el.value !== newEl) {
        el.value = newEl;
      }
    });
    return el;
  }
  var Trigger = /* @__PURE__ */ defineComponent({
    name: "TPopupTrigger",
    props: {
      forwardRef: Function
    },
    emits: ["resize"],
    setup: function setup4(props2, _ref) {
      var emit2 = _ref.emit, slots = _ref.slots;
      var el = useElement(function (vm) {
        var containerNode = vm.parent.vnode;
        return containerNode.el.nextElementSibling;
      });
      var contentRect = ref();
      watch(el, function () {
        var _props2$forwardRef;
        (_props2$forwardRef = props2.forwardRef) === null || _props2$forwardRef === void 0 || _props2$forwardRef.call(props2, el.value);
      });
      useResizeObserver(el, function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 1), newContentRect = _ref3[0].contentRect;
        contentRect.value = newContentRect;
      });
      watch(contentRect, function (newRect, oldRect) {
        if (isRectChanged(newRect, oldRect)) {
          emit2("resize");
        }
      });
      return function () {
        var _slots$default, _children$;
        var children = filterEmpty((_slots$default = slots["default"]) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots));
        if (children.length > 1 || ((_children$ = children[0]) === null || _children$ === void 0 ? void 0 : _children$.type) === Text) {
          return createVNode("span", null, [children]);
        }
        return children[0];
      };
    }
  });
  var Content = /* @__PURE__ */ defineComponent({
    name: "TPopupContent",
    emits: ["resize"],
    setup: function setup5(props2, _ref4) {
      var emit2 = _ref4.emit, slots = _ref4.slots;
      var contentEl = useElement(function (vm) {
        return vm.vnode.el.children[0];
      });
      useResizeObserver(contentEl, function () {
        emit2("resize");
      });
      return function () {
        return createVNode("div", {
          "style": "position: absolute; top: 0px; left: 0px; width: 100%"
        }, [slots["default"]()]);
      };
    }
  });
  var Container = /* @__PURE__ */ defineComponent({
    name: "TPopupContainer",
    inheritAttrs: false,
    props: {
      parent: Object,
      visible: Boolean,
      attach: popupProps.attach,
      forwardRef: Function
    },
    emits: ["resize", "contentMounted"],
    setup: function setup6(props2, _ref5) {
      var emit2 = _ref5.emit, attrs = _ref5.attrs, slots = _ref5.slots, expose = _ref5.expose;
      var triggerEl = ref();
      var mountContent = ref(false);
      function emitResize() {
        emit2("resize");
      }
      onMounted(function () {
        requestAnimationFrame(function () {
          mountContent.value = props2.visible;
        });
      });
      watch(function () {
        return props2.visible;
      }, function (visible) {
        if (visible) {
          mountContent.value = props2.visible;
        }
      });
      expose({
        unmountContent: function unmountContent() {
          mountContent.value = false;
        }
      });
      return function () {
        var _slot;
        var getElement = function getElement2() {
          return getSSRAttach() || getAttach(props2.attach, triggerEl.value);
        };
        return createVNode(Fragment, null, [createVNode(Trigger, {
          "class": attrs["class"],
          "forwardRef": function forwardRef(el) {
            props2.forwardRef(el);
            triggerEl.value = el;
          },
          "onResize": emitResize
        }, _isSlot$5(_slot = slots["default"]()) ? _slot : {
          "default": function _default5() {
            return [_slot];
          }
        }), mountContent.value && createVNode(Teleport, {
          "disabled": !getElement(),
          "to": getElement()
        }, {
          "default": function _default5() {
            return [createVNode(Content, {
              "onResize": emitResize,
              "onVnodeMounted": function onVnodeMounted() {
                return emit2("contentMounted");
              }
            }, {
              "default": function _default6() {
                return [slots.content && slots.content()];
              }
            })];
          }
        })]);
      };
    }
  });
  var define_process_env_default = {};
  function ownKeys$f(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$f(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$f(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$f(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function _isSlot$4(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
  }
  var POPUP_ATTR_NAME = "data-td-popup";
  var POPUP_PARENT_ATTR_NAME = "data-td-popup-parent";
  function getPopperTree(id, upwards) {
    var list = [];
    var selectors = [POPUP_PARENT_ATTR_NAME, POPUP_ATTR_NAME];
    if (!id) return list;
    if (upwards) {
      selectors.unshift(selectors.pop());
    }
    recurse(id);
    return list;
    function recurse(id2) {
      var children = document.querySelectorAll("[".concat(selectors[0], '="').concat(id2, '"]'));
      children.forEach(function (el) {
        list.push(el);
        var childId = el.getAttribute(selectors[1]);
        if (childId && childId !== id2) {
          recurse(childId);
        }
      });
    }
  }
  var parentKey = Symbol();
  function getPopperPlacement(placement) {
    return placement.replace(/-(left|top)$/, "-start").replace(/-(right|bottom)$/, "-end");
  }
  function attachListeners(elm) {
    var offs = [];
    return {
      add: function add2(type, listener) {
        if (!type) return;
        on(elm.value, type, listener);
        offs.push(function () {
          off(elm.value, type, listener);
        });
      },
      clean: function clean() {
        offs.forEach(function (handler) {
          return handler === null || handler === void 0 ? void 0 : handler();
        });
        offs.length = 0;
      }
    };
  }
  var _Popup = /* @__PURE__ */ defineComponent({
    name: "TPopup",
    props: _objectSpread$f(_objectSpread$f({}, popupProps), {}, {
      expandAnimation: {
        type: Boolean
      }
    }),
    setup: function setup7(props2, _ref) {
      var _process$env;
      var expose = _ref.expose;
      var _toRefs = toRefs(props2), propVisible = _toRefs.visible, modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(propVisible, modelValue, props2.defaultVisible, props2.onVisibleChange, "visible"), _useVModel2 = _slicedToArray(_useVModel, 2), visible = _useVModel2[0], setVisible = _useVModel2[1];
      var renderTNodeJSX = useTNodeJSX();
      var renderContent = useContent();
      var popper2;
      var showTimeout;
      var hideTimeout;
      var triggerEl = ref(null);
      var overlayEl = ref(null);
      var popperEl = ref(null);
      var containerRef = ref(null);
      var isOverlayHover = ref(false);
      var id = typeof process !== "undefined" && (_process$env = define_process_env_default) !== null && _process$env !== void 0 && _process$env.TEST ? "" : Date.now().toString(36);
      var parent2 = inject(parentKey, void 0);
      provide(parentKey, {
        id,
        assertMouseLeave: onMouseLeave
      });
      var prefixCls = usePrefixClass("popup");
      var _useCommonClassName = useCommonClassName$1(), commonCls = _useCommonClassName.STATUS;
      var delay = computed(function () {
        var _props2$delay, _delay2$;
        var delay2 = props2.trigger !== "hover" ? [0, 0] : [].concat((_props2$delay = props2.delay) !== null && _props2$delay !== void 0 ? _props2$delay : [250, 150]);
        return {
          show: delay2[0],
          hide: (_delay2$ = delay2[1]) !== null && _delay2$ !== void 0 ? _delay2$ : delay2[0]
        };
      });
      var trigger2 = attachListeners(triggerEl);
      watch(function () {
        return [props2.trigger, triggerEl.value];
      }, function () {
        if (!triggerEl.value) return;
        trigger2.clean();
        trigger2.add({
          hover: "mouseenter",
          focus: "focusin",
          "context-menu": "contextmenu",
          click: "click"
        }[props2.trigger], function (ev) {
          if (props2.disabled) return;
          if (ev.type === "contextmenu") {
            ev.preventDefault();
          }
          if ((ev.type === "click" || ev.type === "contextmenu") && visible.value) {
            hide2(ev);
            return;
          }
          show(ev);
        });
        trigger2.add({
          hover: "mouseleave",
          focus: "focusout"
        }[props2.trigger], hide2);
      });
      watch(function () {
        return [props2.overlayStyle, props2.overlayInnerStyle, overlayEl.value];
      }, function () {
        updateOverlayInnerStyle();
        updatePopper();
      });
      watch(function () {
        return props2.placement;
      }, function () {
        destroyPopper();
        updatePopper();
      });
      watch(function () {
        return visible.value;
      }, function (visible2) {
        if (visible2) {
          on(document, "mousedown", onDocumentMouseDown, true);
          if (props2.trigger === "focus") {
            once(triggerEl.value, "keydown", function (ev) {
              var _process$env2;
              var code = typeof process !== "undefined" && (_process$env2 = define_process_env_default) !== null && _process$env2 !== void 0 && _process$env2.TEST ? "27" : "Escape";
              if (ev.code === code) {
                hide2(ev);
              }
            });
          }
          return;
        }
        off(document, "mousedown", onDocumentMouseDown, true);
      });
      onUnmounted(function () {
        destroyPopper();
        clearAllTimeout();
        off(document, "mousedown", onDocumentMouseDown, true);
      });
      expose({
        update: updatePopper,
        getOverlay: function getOverlay() {
          return overlayEl.value;
        },
        getOverlayState: function getOverlayState() {
          return {
            hover: isOverlayHover.value
          };
        },
        close: function close2() {
          return hide2();
        }
      });
      function getOverlayStyle() {
        var overlayStyle = props2.overlayStyle;
        if (!triggerEl.value || !overlayEl.value) return;
        if (isFunction(overlayStyle)) {
          return overlayStyle(triggerEl.value, overlayEl.value);
        }
        if (isObject(overlayStyle)) {
          return overlayStyle;
        }
      }
      function updateOverlayInnerStyle() {
        var overlayInnerStyle = props2.overlayInnerStyle;
        if (!triggerEl.value || !overlayEl.value) return;
        if (isFunction(overlayInnerStyle)) {
          setStyle(overlayEl.value, overlayInnerStyle(triggerEl.value, overlayEl.value));
        } else if (isObject(overlayInnerStyle)) {
          setStyle(overlayEl.value, overlayInnerStyle);
        }
      }
      function updatePopper() {
        if (!popperEl.value || !visible.value) return;
        if (popper2) {
          if (triggerEl.value.getRootNode() instanceof ShadowRoot) {
            popper2.state.elements.reference = triggerEl.value;
            popper2.update();
          } else {
            var rect = triggerEl.value.getBoundingClientRect();
            var parent22 = triggerEl.value;
            while (parent22 && parent22 !== document.body) {
              parent22 = parent22.parentElement;
            }
            var isHidden = parent22 !== document.body || rect.width === 0 && rect.height === 0;
            if (!isHidden) {
              popper2.state.elements.reference = triggerEl.value;
              popper2.update();
            } else {
              setVisible(false, {
                trigger: getTriggerType({
                  type: "mouseenter"
                })
              });
            }
          }
          return;
        }
        popper2 = createPopper(triggerEl.value, popperEl.value, _objectSpread$f({
          placement: getPopperPlacement(props2.placement),
          onFirstUpdate: function onFirstUpdate() {
            nextTick(updatePopper);
          }
        }, props2.popperOptions));
      }
      function destroyPopper() {
        if (popper2) {
          var _popper;
          (_popper = popper2) === null || _popper === void 0 || _popper.destroy();
          popper2 = null;
        }
        if (props2.destroyOnClose) {
          var _containerRef$value;
          (_containerRef$value = containerRef.value) === null || _containerRef$value === void 0 || _containerRef$value.unmountContent();
        }
      }
      function show(ev) {
        clearAllTimeout();
        showTimeout = setTimeout(function () {
          setVisible(true, {
            trigger: getTriggerType(ev)
          });
        }, delay.value.show);
      }
      function hide2(ev) {
        clearAllTimeout();
        hideTimeout = setTimeout(function () {
          setVisible(false, {
            trigger: getTriggerType(ev),
            e: ev
          });
        }, delay.value.hide);
      }
      function clearAllTimeout() {
        clearTimeout(showTimeout);
        clearTimeout(hideTimeout);
      }
      function getTriggerType(ev) {
        switch (ev === null || ev === void 0 ? void 0 : ev.type) {
          case "mouseenter":
            return "trigger-element-hover";
          case "mouseleave":
            return "trigger-element-hover";
          case "focusin":
            return "trigger-element-focus";
          case "focusout":
            return "trigger-element-blur";
          case "click":
            return "trigger-element-click";
          case "context-menu":
          case "keydown":
            return "keydown-esc";
          case "mousedown":
            return "document";
          default:
            return "trigger-element-close";
        }
      }
      function onDocumentMouseDown(ev) {
        var _popperEl$value, _triggerEl$value;
        if ((_popperEl$value = popperEl.value) !== null && _popperEl$value !== void 0 && _popperEl$value.contains(ev.target)) {
          return;
        }
        if ((_triggerEl$value = triggerEl.value) !== null && _triggerEl$value !== void 0 && _triggerEl$value.contains(ev.target)) {
          return;
        }
        var activedPopper = getPopperTree(id).find(function (el) {
          return el.contains(ev.target);
        });
        if (activedPopper && getPopperTree(activedPopper.getAttribute(POPUP_PARENT_ATTR_NAME), true).some(function (el) {
          return el === popperEl.value;
        })) {
          return;
        }
        hide2(ev);
      }
      function onMouseLeave(ev) {
        isOverlayHover.value = false;
        if (props2.trigger !== "hover" || triggerEl.value.contains(ev.target)) return;
        var isCursorOverlaps = getPopperTree(id).some(function (el) {
          var rect = el.getBoundingClientRect();
          return ev.x > rect.x && ev.x < rect.x + rect.width && ev.y > rect.y && ev.y < rect.y + rect.height;
        });
        if (!isCursorOverlaps) {
          hide2(ev);
          parent2 === null || parent2 === void 0 || parent2.assertMouseLeave(ev);
        }
      }
      function onMouseenter() {
        isOverlayHover.value = true;
        if (visible.value && props2.trigger === "hover") {
          clearAllTimeout();
        }
      }
      function onOverlayClick(e) {
        var _props2$onOverlayClic;
        (_props2$onOverlayClic = props2.onOverlayClick) === null || _props2$onOverlayClic === void 0 || _props2$onOverlayClic.call(props2, {
          e
        });
      }
      var updateScrollTop = inject("updateScrollTop", void 0);
      function handleOnScroll(e) {
        var _props2$onScroll;
        var _e$target = e.target, scrollTop = _e$target.scrollTop, clientHeight = _e$target.clientHeight, scrollHeight = _e$target.scrollHeight;
        var debounceOnScrollBottom = debounce$1(function (e2) {
          var _props2$onScrollToBot;
          return (_props2$onScrollToBot = props2.onScrollToBottom) === null || _props2$onScrollToBot === void 0 ? void 0 : _props2$onScrollToBot.call(props2, {
            e: e2
          });
        }, 100);
        if (clientHeight + Math.floor(scrollTop) === scrollHeight) {
          debounceOnScrollBottom(e);
        }
        (_props2$onScroll = props2.onScroll) === null || _props2$onScroll === void 0 || _props2$onScroll.call(props2, {
          e
        });
      }
      watch(function () {
        return [visible.value, overlayEl.value];
      }, function () {
        if (visible.value && overlayEl.value && updateScrollTop) {
          updateScrollTop === null || updateScrollTop === void 0 || updateScrollTop(overlayEl.value);
        }
      });
      return function () {
        var content = renderTNodeJSX("content");
        var hidePopup = props2.hideEmptyPopup && ["", void 0, null].includes(content);
        var overlay = visible.value || !props2.destroyOnClose ? withDirectives(createVNode("div", mergeProps(_defineProperty$1(_defineProperty$1({}, POPUP_ATTR_NAME, id), POPUP_PARENT_ATTR_NAME, parent2 === null || parent2 === void 0 ? void 0 : parent2.id), {
          "class": [prefixCls.value, props2.overlayClassName],
          "ref": function ref2(ref22) {
            return popperEl.value = ref22;
          },
          "style": [{
            zIndex: props2.zIndex
          }, getOverlayStyle(), hidePopup && {
            visibility: "hidden"
          }],
          "onClick": onOverlayClick,
          "onMouseenter": onMouseenter,
          "onMouseleave": onMouseLeave
        }), [createVNode("div", {
          "class": ["".concat(prefixCls.value, "__content"), _defineProperty$1(_defineProperty$1(_defineProperty$1({}, "".concat(prefixCls.value, "__content--text"), isString(props2.content)), "".concat(prefixCls.value, "__content--arrow"), props2.showArrow), commonCls.value.disabled, props2.disabled), props2.overlayInnerClassName],
          "ref": overlayEl,
          "onScroll": handleOnScroll
        }, [content, props2.showArrow && createVNode("div", {
          "class": "".concat(prefixCls.value, "__arrow")
        }, null)])]), [[vShow, visible.value]]) : null;
        return createVNode(Container, {
          "ref": function ref2(ref22) {
            return containerRef.value = ref22;
          },
          "forwardRef": function forwardRef(ref2) {
            return triggerEl.value = ref2;
          },
          "onContentMounted": function onContentMounted() {
            if (visible.value) {
              updatePopper();
              var timer = setTimeout(function () {
                updateOverlayInnerStyle();
                clearTimeout(timer);
              }, 60);
            }
          },
          "onResize": function onResize() {
            if (visible.value) {
              updatePopper();
            }
          },
          "visible": visible.value,
          "attach": props2.attach
        }, {
          content: function content2() {
            return createVNode(Transition, {
              "name": "".concat(prefixCls.value, "--animation").concat(props2.expandAnimation ? "-expand" : ""),
              "appear": true,
              "onEnter": updatePopper,
              "onAfterLeave": destroyPopper
            }, _isSlot$4(overlay) ? overlay : {
              "default": function _default5() {
                return [overlay];
              }
            });
          },
          "default": function _default5() {
            return renderContent("default", "triggerElement");
          }
        });
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var Popup = withInstall(_Popup);
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
  }
  function _createClass(e, r, t) {
    return Object.defineProperty(e, "prototype", {
      writable: false
    }), e;
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var tabPanelProps = {
    "default": {
      type: Function
    },
    destroyOnHide: {
      type: Boolean,
      "default": true
    },
    disabled: Boolean,
    draggable: {
      type: Boolean,
      "default": true
    },
    label: {
      type: [String, Function]
    },
    lazy: Boolean,
    panel: {
      type: [String, Function]
    },
    removable: Boolean,
    value: {
      type: [String, Number]
    },
    onRemove: Function
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var _TabPanel = /* @__PURE__ */ defineComponent({
    name: "TTabPanel",
    props: tabPanelProps,
    setup: function setup8(props2) {
      var COMPONENT_NAME = usePrefixClass("tab-panel");
      var _useCommonClassName = useCommonClassName$1(), STATUS = _useCommonClassName.STATUS;
      var renderTNodeContent = useContent();
      useDestroyOnClose();
      var tabs = inject("tabs");
      var isActive = computed(function () {
        return props2.value === tabs.value.value;
      });
      var isMount = ref(props2.lazy ? isActive.value : true);
      watch(isActive, function () {
        if (isActive.value) {
          if (!isMount.value) {
            isMount.value = true;
          }
        } else if (props2.destroyOnHide) {
          isMount.value = false;
        }
      }, {
        immediate: true
      });
      var tabPanelClass = computed(function () {
        return [COMPONENT_NAME.value, _defineProperty$1({}, STATUS.value.hidden, !isActive.value)];
      });
      return function () {
        if (!isMount.value) return null;
        return createVNode("div", {
          "class": tabPanelClass.value
        }, [renderTNodeContent("default", "panel")]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var props$d = {
    action: {
      type: [String, Function]
    },
    addable: Boolean,
    disabled: Boolean,
    dragSort: Boolean,
    list: {
      type: Array
    },
    placement: {
      type: String,
      "default": "top",
      validator: function validator8(val) {
        if (!val) return true;
        return ["left", "top", "bottom", "right"].includes(val);
      }
    },
    scrollPosition: {
      type: String,
      "default": "auto",
      validator: function validator9(val) {
        if (!val) return true;
        return ["auto", "start", "center", "end"].includes(val);
      }
    },
    size: {
      type: String,
      "default": "medium",
      validator: function validator10(val) {
        if (!val) return true;
        return ["medium", "large"].includes(val);
      }
    },
    theme: {
      type: String,
      "default": "normal",
      validator: function validator11(val) {
        if (!val) return true;
        return ["normal", "card"].includes(val);
      }
    },
    value: {
      type: [String, Number],
      "default": void 0
    },
    modelValue: {
      type: [String, Number],
      "default": void 0
    },
    defaultValue: {
      type: [String, Number]
    },
    onAdd: Function,
    onChange: Function,
    onDragSort: Function,
    onRemove: Function
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var TTabNavItem = /* @__PURE__ */ defineComponent({
    name: "TTabNavItem",
    props: {
      index: Number,
      active: {
        type: Boolean
      },
      theme: props$d.theme,
      size: props$d.size,
      placement: props$d.placement,
      label: {
        type: null
      },
      disabled: tabPanelProps.disabled,
      removable: tabPanelProps.removable,
      value: tabPanelProps.value,
      onClick: Function,
      onRemove: Function
    },
    setup: function setup9(props2) {
      var itemRef = ref();
      useRipple(itemRef);
      var COMPONENT_NAME = usePrefixClass("tabs__nav-item");
      var _useGlobalIcon = useGlobalIcon({
        CloseIcon: close
      }), CloseIcon$1 = _useGlobalIcon.CloseIcon;
      var classPrefix = usePrefixClass();
      var _useCommonClassName = useCommonClassName$1(), STATUS = _useCommonClassName.STATUS, SIZE = _useCommonClassName.SIZE;
      var removeBtnClick = function removeBtnClick2(_ref) {
        var e = _ref.e;
        if (e) e.stopPropagation();
        props2.onRemove({
          e,
          value: props2.value,
          index: props2.index
        });
      };
      var onClickNav = function onClickNav2(e) {
        if (props2.disabled) return;
        props2.onClick(e);
      };
      var navItemClass = computed(function () {
        return _defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1({}, COMPONENT_NAME.value, true), "".concat(classPrefix.value, "-tabs__nav--card"), props2.theme === "card"), STATUS.value.disabled, props2.disabled), STATUS.value.active, props2.active), "".concat(classPrefix.value, "-is-left"), props2.placement === "left"), "".concat(classPrefix.value, "-is-right"), props2.placement === "right"), SIZE.value.medium, props2.size === "medium"), SIZE.value.large, props2.size === "large");
      });
      var renderCardItem = function renderCardItem2() {
        return createVNode("div", {
          "class": navItemClass.value,
          "onClick": onClickNav,
          "ref": itemRef
        }, [createVNode("span", {
          "class": "".concat(COMPONENT_NAME.value, "-text-wrapper")
        }, [props2.label]), props2.removable && !props2.disabled ? createVNode(CloseIcon$1, {
          "class": "remove-btn",
          "onClick": removeBtnClick
        }, null) : null]);
      };
      var renderNormalItem = function renderNormalItem2() {
        return createVNode("div", {
          "class": navItemClass.value,
          "onClick": onClickNav
        }, [createVNode("div", {
          "class": ["".concat(COMPONENT_NAME.value, "-wrapper"), _defineProperty$1(_defineProperty$1({}, STATUS.value.disabled, props2.disabled), STATUS.value.active, props2.active)],
          "ref": itemRef
        }, [createVNode("span", {
          "class": "".concat(COMPONENT_NAME.value, "-text-wrapper")
        }, [props2.label])]), props2.removable && !props2.disabled ? createVNode(CloseIcon$1, {
          "class": "remove-btn",
          "onClick": removeBtnClick
        }, null) : null]);
      };
      return function () {
        return props2.theme === "card" ? renderCardItem() : renderNormalItem();
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var TTabNavBar = /* @__PURE__ */ defineComponent({
    props: {
      navs: {
        type: Array
      },
      placement: props$d.placement,
      value: props$d.value
    },
    setup: function setup10(props2) {
      var COMPONENT_NAME = usePrefixClass("tabs");
      var classPrefix = usePrefixClass();
      var barRef = ref();
      var navBarClass = computed(function () {
        return ["".concat(COMPONENT_NAME.value, "__bar"), "".concat(classPrefix.value, "-is-").concat(props2.placement)];
      });
      var navBarStyle = ref(null);
      var getStyle = function getStyle2() {
        var isVertical = ["left", "right"].includes(props2.placement.toLowerCase());
        var _ref = isVertical ? ["height", "top"] : ["width", "left"], _ref2 = _slicedToArray(_ref, 2), sizePropName = _ref2[0], offsetPropName = _ref2[1];
        var offset2 = 0;
        var i = 0;
        for (; i < props2.navs.length; i++) {
          var _props$navs$i;
          if (props2.navs[i].props.value === props2.value) {
            break;
          }
          if ((_props$navs$i = props2.navs[i]) !== null && _props$navs$i !== void 0 && _props$navs$i.el) {
            var sizeWithUnit = getComputedStyle(props2.navs[i].el)[sizePropName];
            var size = parseFloat(sizeWithUnit);
            offset2 += size;
          }
        }
        if (!props2.navs[i]) return {};
        return _defineProperty$1(_defineProperty$1({}, offsetPropName, "".concat(offset2, "px")), sizePropName, props2.navs[i].el ? getComputedStyle(props2.navs[i].el)[sizePropName] : "0px");
      };
      var update = function update2() {
        return navBarStyle.value = getStyle();
      };
      onMounted(function () {
        nextTick(function () {
          update();
        });
      });
      watch([function () {
        return props2.navs;
      }, function () {
        return props2.value;
      }, function () {
        return props2.placement;
      }], function () {
        nextTick(function () {
          update();
        });
      });
      useResizeObserver(barRef, debounce$1(function () {
        update();
      }, 35));
      return function () {
        return createVNode("div", {
          "class": navBarClass.value,
          "style": navBarStyle.value,
          "ref": barRef
        }, null);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function _createForOfIteratorHelper$3(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray$3(r)) || e) {
        t && (r = t);
        var _n = 0, F = function F2() {
        };
        return {
          s: F, n: function n() {
            return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
          }, e: function e2(r2) {
            throw r2;
          }, f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o, a = true, u = false;
    return {
      s: function s() {
        t = t.call(r);
      }, n: function n() {
        var r2 = t.next();
        return a = r2.done, r2;
      }, e: function e2(r2) {
        u = true, o = r2;
      }, f: function f() {
        try {
          a || null == t["return"] || t["return"]();
        } finally {
          if (u) throw o;
        }
      }
    };
  }
  function _unsupportedIterableToArray$3(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray$3(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$3(r, a) : void 0;
    }
  }
  function _arrayLikeToArray$3(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  var traversalTabNavs = function traversalTabNavs2(tabNavs, fn2) {
    var _iterator = _createForOfIteratorHelper$3(tabNavs), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var itemNode = _step.value;
        if (itemNode.getAttribute("draggable")) {
          fn2(itemNode);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  };
  var handleTarget = function handleTarget2(target, tabNavs) {
    var resultTarget;
    traversalTabNavs(tabNavs, function (itemNode) {
      if (itemNode.contains(target)) {
        resultTarget = itemNode;
      }
    });
    return resultTarget;
  };
  function useDragSort(props2) {
    var navsWrap = null;
    var dragged;
    var enterTargets = [];
    var dragstart = function dragstart2(event) {
      var target = event.target;
      dragged = target;
      target.style.opacity = "0.5";
    };
    var dragend = function dragend2(event) {
      event.target.style.opacity = "";
    };
    var dragover = function dragover2(event) {
      event.preventDefault();
    };
    var dragenter = function dragenter2(event) {
      var target = handleTarget(event.target, navsWrap.children);
      if (target && target !== dragged && target.draggable) {
        target.firstChild.style.outline = "1px dashed #0052d9";
        if (!enterTargets.includes(target)) {
          enterTargets.push(target);
        }
      }
    };
    var dragleave = function dragleave2(event) {
      var target = event.target;
      for (var _i = 0, _enterTargets = enterTargets; _i < _enterTargets.length; _i++) {
        var enterTarget = _enterTargets[_i];
        if (!enterTarget.contains(target)) {
          enterTarget.firstChild.style.outline = "none";
        }
      }
    };
    var drop = function drop2(event) {
      event.preventDefault();
      traversalTabNavs(navsWrap.children, function (tabNav) {
        tabNav.firstChild.style.outline = "none";
      });
      var target = handleTarget(event.target, navsWrap.children);
      if (target && target.parentNode !== dragged && target.draggable) {
        var _props$onDragSort;
        var dragIndex = [].indexOf.call(navsWrap.children, dragged);
        var targetIndex = [].indexOf.call(navsWrap.children, target);
        if (targetIndex > dragIndex) {
          target = navsWrap.children[targetIndex + 1];
        }
        var currentIndex = props2.theme === "card" ? dragIndex : dragIndex - 1;
        var endIndex = props2.theme === "card" ? targetIndex : targetIndex - 1;
        (_props$onDragSort = props2.onDragSort) === null || _props$onDragSort === void 0 || _props$onDragSort.call(props2, {
          currentIndex,
          current: props2.panels[currentIndex].value,
          targetIndex: endIndex,
          target: props2.panels[endIndex].value
        });
      }
    };
    function setNavsWrap(val) {
      navsWrap = val;
      navsWrap.addEventListener("dragstart", dragstart, false);
      navsWrap.addEventListener("dragend", dragend, false);
      navsWrap.addEventListener("dragover", dragover, false);
      navsWrap.addEventListener("dragenter", dragenter, false);
      document.addEventListener("dragleave", dragleave, false);
      document.addEventListener("mousemove", dragleave, false);
      navsWrap.addEventListener("drop", drop, false);
    }
    onUnmounted(function () {
      navsWrap.removeEventListener("dragstart", dragstart);
      navsWrap.removeEventListener("dragend", dragend);
      navsWrap.removeEventListener("dragover", dragover);
      navsWrap.removeEventListener("dragenter", dragenter);
      document.removeEventListener("dragleave", dragleave);
      document.removeEventListener("mousemove", dragleave);
      navsWrap.removeEventListener("drop", drop);
    });
    return {
      setNavsWrap
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var getDomWidth = function getDomWidth2(dom) {
    return (dom === null || dom === void 0 ? void 0 : dom.offsetWidth) || 0;
  };
  var getDomOffsetLeft = function getDomOffsetLeft2(dom) {
    return (dom === null || dom === void 0 ? void 0 : dom.offsetLeft) || 0;
  };
  function calculateOffset(depElement, offset2, scrollPosition) {
    var navsContainer = depElement.navsContainer, activeTab = depElement.activeTab, rightOperations = depElement.rightOperations, leftOperations = depElement.leftOperations;
    var tabWidth = getDomWidth(activeTab);
    var wrapWidth = getDomWidth(navsContainer);
    var tabOffset = getDomOffsetLeft(activeTab);
    var rightOperationsWidth = getDomWidth(rightOperations);
    var leftOperationsWidth = getDomWidth(leftOperations);
    if (scrollPosition === "auto") {
      if (tabOffset - leftOperationsWidth < offset2) {
        return tabOffset - leftOperationsWidth;
      }
      if (tabOffset + tabWidth > offset2 + wrapWidth - rightOperationsWidth) {
        return tabOffset + tabWidth - wrapWidth + rightOperationsWidth;
      }
    } else if (scrollPosition === "start") {
      return tabOffset - leftOperationsWidth;
    } else if (scrollPosition === "center") {
      return tabOffset + (tabWidth - wrapWidth) / 2;
    } else if (scrollPosition === "end") {
      return tabOffset + tabWidth - wrapWidth + rightOperationsWidth;
    }
    return offset2;
  }
  function calcPrevOrNextOffset(elements, offset2, action) {
    var navsContainer = elements.navsContainer, activeTab = elements.activeTab;
    var navsContainerWidth = getDomWidth(navsContainer);
    var activeTabWidth = getDomWidth(activeTab);
    if (action === "next") {
      return offset2 + navsContainerWidth - activeTabWidth;
    }
    return offset2 - navsContainerWidth + activeTabWidth;
  }
  function calcMaxOffset(elements) {
    var navsWrap = elements.navsWrap, navsContainer = elements.navsContainer, rightOperations = elements.rightOperations, toRightBtn = elements.toRightBtn;
    var wrapWidth = getDomWidth(navsWrap);
    var containerWidth = getDomWidth(navsContainer);
    var rightOperationsWidth = getDomWidth(rightOperations);
    var toRightBtnWidth = getDomWidth(toRightBtn);
    return wrapWidth - containerWidth + rightOperationsWidth - toRightBtnWidth;
  }
  function calcValidOffset(offset2, maxOffset) {
    return Math.max(0, Math.min(offset2, maxOffset));
  }
  function ownKeys$e(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$e(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$e(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var TTabNav = /* @__PURE__ */ defineComponent({
    name: "TTabNav",
    resizeObserver: null,
    props: {
      theme: props$d.theme,
      panels: {
        type: Array,
        "default": function _default() {
          return [];
        }
      },
      action: Array,
      value: props$d.value,
      placement: props$d.placement,
      scrollPosition: props$d.scrollPosition,
      size: props$d.size,
      disabled: props$d.disabled,
      addable: props$d.addable,
      onChange: props$d.onChange,
      onAdd: props$d.onAdd,
      onRemove: props$d.onRemove,
      dragSort: props$d.dragSort,
      onDragSort: props$d.onDragSort
    },
    setup: function setup11(props2) {
      var componentName = usePrefixClass("tabs");
      var _useGlobalIcon = useGlobalIcon({
        ChevronLeftIcon: chevronLeft,
        ChevronRightIcon: chevronRight,
        AddIcon: add
      }), ChevronLeftIcon$1 = _useGlobalIcon.ChevronLeftIcon, ChevronRightIcon$1 = _useGlobalIcon.ChevronRightIcon, AddIcon$1 = _useGlobalIcon.AddIcon;
      var classPrefix = usePrefixClass();
      var _useCommonClassName = useCommonClassName$1(), SIZE = _useCommonClassName.SIZE;
      var scrollLeft = ref(0);
      var navsContainerRef = ref();
      var navsWrapRef = ref();
      var leftOperationsRef = ref();
      var rightOperationsRef = ref();
      var toRightBtnRef = ref();
      var activeTabRef = ref();
      var maxScrollLeft = ref(0);
      var getRefs = function getRefs2() {
        return {
          navsContainer: navsContainerRef.value,
          navsWrap: navsWrapRef.value,
          leftOperations: leftOperationsRef.value,
          rightOperations: rightOperationsRef.value,
          toRightBtn: toRightBtnRef.value,
          activeTab: activeTabRef.value
        };
      };
      var isVerticalPlacement = computed(function () {
        return ["left", "right"].includes(props2.placement.toLowerCase());
      });
      var canToLeft = computed(function () {
        return scrollLeft.value > 1;
      });
      var canToRight = computed(function () {
        return scrollLeft.value < maxScrollLeft.value - 1;
      });
      var wrapTransformStyle = computed(function () {
        if (isVerticalPlacement.value) return {};
        return {
          transform: "translate3d(".concat(-scrollLeft.value, "px, 0, 0)")
        };
      });
      var navsContainerStyle = computed(function () {
        return props2.addable ? {
          "min-height": "48px"
        } : null;
      });
      var iconBaseClass = computed(function () {
        return _defineProperty$1(_defineProperty$1(_defineProperty$1({}, "".concat(componentName.value, "__btn"), true), SIZE.value.medium, props2.size === "medium"), SIZE.value.large, props2.size === "large");
      });
      var leftIconClass = computed(function () {
        return _objectSpread$e(_defineProperty$1({}, "".concat(componentName.value, "__btn--left"), true), iconBaseClass.value);
      });
      var rightIconClass = computed(function () {
        return _objectSpread$e(_defineProperty$1({}, "".concat(componentName.value, "__btn--right"), true), iconBaseClass.value);
      });
      var addIconClass = computed(function () {
        return _objectSpread$e(_defineProperty$1({}, "".concat(componentName.value, "__add-btn"), true), iconBaseClass.value);
      });
      var navContainerClass = computed(function () {
        return _defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1({}, "".concat(componentName.value, "__nav-container"), true), "".concat(componentName.value, "__nav--card"), props2.theme === "card"), "".concat(classPrefix.value, "-is-").concat(props2.placement), true), "".concat(classPrefix.value, "-is-addable"), props2.addable);
      });
      var navScrollContainerClass = computed(function () {
        return _defineProperty$1(_defineProperty$1({}, "".concat(componentName.value, "__nav-scroll"), true), "".concat(classPrefix.value, "-is-scrollable"), canToLeft.value || canToRight.value);
      });
      var navsWrapClass = computed(function () {
        return ["".concat(componentName.value, "__nav-wrap"), "".concat(classPrefix.value, "-is-smooth"), _defineProperty$1({}, "".concat(classPrefix.value, "-is-vertical"), isVerticalPlacement.value)];
      });
      var setOffset = function setOffset2(offset2) {
        scrollLeft.value = calcValidOffset(offset2, maxScrollLeft.value);
      };
      var handleScroll = function handleScroll2(action) {
        setOffset(calcPrevOrNextOffset(getRefs(), scrollLeft.value, action));
      };
      var handleWheel = function handleWheel2(event) {
        if (!canToLeft.value && !canToRight.value) return;
        event.preventDefault();
        var deltaX = event.deltaX, deltaY = event.deltaY;
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          setOffset(scrollLeft.value + deltaX);
        } else {
          setOffset(scrollLeft.value + deltaY);
        }
      };
      var handleActiveTabScroll = function handleActiveTabScroll2() {
        setTimeout(function () {
          setOffset(calculateOffset(getRefs(), scrollLeft.value, props2.scrollPosition));
        }, 0);
      };
      var getMaxScrollLeft = function getMaxScrollLeft2() {
        nextTick(function () {
          maxScrollLeft.value = calcMaxOffset(getRefs());
        });
      };
      watch([function () {
        return props2.placement;
      }, function () {
        return props2.panels;
      }], getMaxScrollLeft);
      watch([function () {
        return props2.scrollPosition;
      }], handleActiveTabScroll);
      useResize(debounce$1(getMaxScrollLeft), navsContainerRef.value);
      var handleAddTab = function handleAddTab2(e) {
        var _props$onAdd;
        (_props$onAdd = props2.onAdd) === null || _props$onAdd === void 0 || _props$onAdd.call(props2, {
          e
        });
      };
      var tabClick = function tabClick2(event, nav) {
        var value = nav.value, disabled = nav.disabled;
        if (disabled || props2.value === value) {
          return false;
        }
        props2.onChange(value);
      };
      var removeBtnClick = function removeBtnClick2(_ref5) {
        var e = _ref5.e, value = _ref5.value, index = _ref5.index;
        props2.onRemove({
          e,
          value,
          index
        });
      };
      var setActiveTab = function setActiveTab2(ref2) {
        if (!(ref2 !== null && ref2 !== void 0 && ref2.$el)) return;
        if ((ref2 === null || ref2 === void 0 ? void 0 : ref2.value) === props2.value && activeTabRef.value !== ref2.$el) {
          activeTabRef.value = ref2.$el;
          handleActiveTabScroll();
        }
      };
      var _useDragSort = useDragSort(props2), setNavsWrap = _useDragSort.setNavsWrap;
      onMounted(function () {
        setNavsWrap(navsWrapRef.value);
        getMaxScrollLeft();
        handleActiveTabScroll();
      });
      var renderNavsContent = function renderNavsContent2() {
        return props2.panels.map(function (panel, index) {
          var _panel$children;
          var label;
          if (panel !== null && panel !== void 0 && (_panel$children = panel.children) !== null && _panel$children !== void 0 && _panel$children.label) {
            label = panel.children.label();
          } else if (isFunction(panel.label)) {
            label = panel.label(h);
          } else {
            label = panel.label || "选项卡".concat(index + 1);
          }
          var draggable2 = props2.dragSort;
          if (draggable2 && panel.draggable === false) {
            draggable2 = panel.draggable;
          }
          return createVNode(TTabNavItem, {
            "ref": setActiveTab,
            "draggable": draggable2,
            "key": panel.value,
            "index": index,
            "theme": props2.theme,
            "size": props2.size,
            "placement": props2.placement,
            "label": label,
            "active": panel.value === props2.value,
            "disabled": props2.disabled || panel.disabled,
            "removable": panel.removable,
            "value": panel.value,
            "onClick": function onClick(e) {
              return tabClick(e, panel);
            },
            "onRemove": removeBtnClick
          }, null);
        });
      };
      var renderArrows = function renderArrows2() {
        return [createVNode("div", {
          "ref": leftOperationsRef,
          "class": ["".concat(componentName.value, "__operations"), "".concat(componentName.value, "__operations--left")]
        }, [createVNode(Transition, {
          "name": "fade",
          "mode": "out-in",
          "appear": true
        }, {
          "default": function _default5() {
            return [canToLeft.value ? createVNode("div", {
              "class": leftIconClass.value,
              "onClick": function onClick() {
                return handleScroll("prev");
              }
            }, [createVNode(ChevronLeftIcon$1, null, null)]) : null];
          }
        })]), createVNode("div", {
          "ref": rightOperationsRef,
          "class": ["".concat(componentName.value, "__operations"), "".concat(componentName.value, "__operations--right")]
        }, [createVNode(Transition, {
          "name": "fade",
          "mode": "out-in",
          "appear": true
        }, {
          "default": function _default5() {
            return [canToRight.value ? createVNode("div", {
              "ref": toRightBtnRef,
              "class": rightIconClass.value,
              "onClick": function onClick() {
                return handleScroll("next");
              }
            }, [createVNode(ChevronRightIcon$1, null, null)]) : null];
          }
        }), props2.addable ? createVNode("div", {
          "class": addIconClass.value,
          "onClick": handleAddTab
        }, [createVNode(AddIcon$1, null, null)]) : null, props2.action])];
      };
      var renderNavs = function renderNavs2() {
        var navContent = renderNavsContent();
        return createVNode("div", {
          "class": navContainerClass.value
        }, [createVNode("div", {
          "class": navScrollContainerClass.value,
          "onWheel": handleWheel
        }, [createVNode("div", {
          "ref": navsWrapRef,
          "class": navsWrapClass.value,
          "style": wrapTransformStyle.value
        }, [props2.theme !== "card" && createVNode(TTabNavBar, {
          "placement": props2.placement,
          "value": props2.value,
          "navs": navContent
        }, null), navContent])])]);
      };
      return function () {
        return createVNode("div", {
          "ref": navsContainerRef,
          "class": ["".concat(componentName.value, "__nav")],
          "style": navsContainerStyle.value
        }, [renderArrows(), renderNavs()]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var _Tabs = /* @__PURE__ */ defineComponent({
    name: "TTabs",
    props: props$d,
    setup: function setup12(props2) {
      var COMPONENT_NAME = usePrefixClass("tabs");
      var classPrefix = usePrefixClass();
      var renderTNodeJSX = useTNodeJSX();
      var _toRefs = toRefs(props2), value = _toRefs.value, modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props2.defaultValue || "", props2.onChange), _useVModel2 = _slicedToArray(_useVModel, 2), tabValue = _useVModel2[0], setTabValue = _useVModel2[1];
      provide("tabs", {
        value: tabValue
      });
      var onTabAdd = function onTabAdd2(context) {
        var _props2$onAdd;
        (_props2$onAdd = props2.onAdd) === null || _props2$onAdd === void 0 || _props2$onAdd.call(props2, {
          e: context.e
        });
      };
      var onTabChange = function onTabChange2(value2) {
        setTabValue(value2);
      };
      var onTabRemove = function onTabRemove2(_ref) {
        var _props2$onRemove;
        var e = _ref.e, value2 = _ref.value, index = _ref.index;
        (_props2$onRemove = props2.onRemove) === null || _props2$onRemove === void 0 || _props2$onRemove.call(props2, {
          value: value2,
          index,
          e
        });
      };
      var getSlotPanels = function getSlotPanels2() {
        var content = renderTNodeJSX("default");
        if (!content) return [];
        var _flatContent = function flatContent(ct) {
          return ct.map(function (item) {
            if (item.children && isArray(item.children)) return _flatContent(item.children);
            return item;
          }).flat().filter(function (item) {
            return item.type.name === "TTabPanel";
          });
        };
        return _flatContent(content);
      };
      var renderHeader = function renderHeader2() {
        var _props2$list;
        var panels = ((_props2$list = props2.list) !== null && _props2$list !== void 0 && _props2$list.length ? props2.list : getSlotPanels()) || [];
        var actionContent = renderTNodeJSX("action");
        var panelsData = panels.map(function (item) {
          var selfItem = item;
          if (item.props) {
            Object.keys(item.props).forEach(function (key2) {
              selfItem[key2] = item.props[key2];
            });
          }
          return selfItem;
        });
        var tabNavProps = {
          theme: props2.theme,
          value: tabValue.value,
          size: props2.size,
          disabled: props2.disabled,
          placement: props2.placement,
          scrollPosition: props2.scrollPosition,
          addable: props2.addable,
          panels: panelsData,
          dragSort: props2.dragSort,
          action: actionContent
        };
        return createVNode("div", {
          "class": _defineProperty$1(_defineProperty$1({}, "".concat(classPrefix.value, "-tabs__header"), true), "".concat(classPrefix.value, "-is-").concat(props2.placement), true)
        }, [createVNode(TTabNav, mergeProps(tabNavProps, {
          "onDragSort": props2.onDragSort,
          "onChange": onTabChange,
          "onAdd": onTabAdd,
          "onRemove": onTabRemove
        }), null)]);
      };
      var renderContent = function renderContent2() {
        var _props2$list2;
        var panels = getSlotPanels();
        if ((_props2$list2 = props2.list) !== null && _props2$list2 !== void 0 && _props2$list2.length) {
          return props2.list.map(function (item) {
            return createVNode(_TabPanel, mergeProps(item, {
              "onRemove": onTabRemove
            }), null);
          });
        }
        if (panels && panels.length) {
          return createVNode("div", {
            "class": ["".concat(classPrefix.value, "-tabs__content")]
          }, [panels]);
        }
      };
      return function () {
        return createVNode("div", {
          "class": [COMPONENT_NAME.value]
        }, [props2.placement !== "bottom" ? [renderHeader(), renderContent()] : [renderContent(), renderHeader()]]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var Tabs = withInstall(_Tabs);
  var TabPanel = withInstall(_TabPanel);
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var FakeArrow = /* @__PURE__ */ defineComponent({
    name: "TFakeArrow",
    props: {
      isActive: {
        type: Boolean
      },
      overlayClassName: {
        type: [String, Object, Array]
      },
      overlayStyle: {
        type: Object || String
      }
    },
    setup: function setup13(props2) {
      var COMPONENT_NAME = usePrefixClass("fake-arrow");
      var classes = computed(function () {
        return [COMPONENT_NAME.value, _defineProperty$1({}, "".concat(COMPONENT_NAME.value, "--active"), props2.isActive), props2.overlayClassName];
      });
      return function () {
        return createVNode("svg", {
          "class": classes.value,
          "width": "16",
          "height": "16",
          "viewBox": "0 0 16 16",
          "fill": "none",
          "xmlns": "http://www.w3.org/2000/svg",
          "style": props2.overlayStyle
        }, [createVNode("path", {
          "d": "M3.75 5.7998L7.99274 10.0425L12.2361 5.79921",
          "stroke": "black",
          "stroke-opacity": "0.9",
          "stroke-width": "1.3"
        }, null)]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var props$c = {
    align: {
      type: String,
      "default": "left",
      validator: function validator12(val) {
        if (!val) return true;
        return ["left", "center", "right"].includes(val);
      }
    },
    allowInputOverMax: Boolean,
    autoWidth: Boolean,
    autocomplete: {
      type: String,
      "default": void 0
    },
    autofocus: Boolean,
    borderless: Boolean,
    clearable: Boolean,
    disabled: {
      type: Boolean,
      "default": void 0
    },
    format: {
      type: Function
    },
    inputClass: {
      type: [String, Object, Array]
    },
    label: {
      type: [String, Function]
    },
    maxcharacter: {
      type: Number
    },
    maxlength: {
      type: [String, Number]
    },
    name: {
      type: String,
      "default": ""
    },
    placeholder: {
      type: String,
      "default": void 0
    },
    prefixIcon: {
      type: Function
    },
    readonly: {
      type: Boolean,
      "default": void 0
    },
    showClearIconOnEmpty: Boolean,
    showLimitNumber: Boolean,
    size: {
      type: String,
      "default": "medium",
      validator: function validator13(val) {
        if (!val) return true;
        return ["small", "medium", "large"].includes(val);
      }
    },
    spellCheck: Boolean,
    status: {
      type: String,
      "default": "default",
      validator: function validator14(val) {
        if (!val) return true;
        return ["default", "success", "warning", "error"].includes(val);
      }
    },
    suffix: {
      type: [String, Function]
    },
    suffixIcon: {
      type: Function
    },
    tips: {
      type: [String, Function]
    },
    type: {
      type: String,
      "default": "text",
      validator: function validator15(val) {
        if (!val) return true;
        return ["text", "number", "url", "tel", "password", "search", "submit", "hidden"].includes(val);
      }
    },
    value: {
      type: [String, Number],
      "default": void 0
    },
    modelValue: {
      type: [String, Number],
      "default": void 0
    },
    defaultValue: {
      type: [String, Number]
    },
    onBlur: Function,
    onChange: Function,
    onClear: Function,
    onClick: Function,
    onCompositionend: Function,
    onCompositionstart: Function,
    onEnter: Function,
    onFocus: Function,
    onKeydown: Function,
    onKeypress: Function,
    onKeyup: Function,
    onMouseenter: Function,
    onMouseleave: Function,
    onPaste: Function,
    onValidate: Function,
    onWheel: Function
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function useReadonly(context) {
    var currentInstance2 = getCurrentInstance();
    var componentReadonly = computed(function () {
      return currentInstance2.props.readonly;
    });
    var formReadonly = inject("formReadonly", /* @__PURE__ */ Object.create(null));
    return computed(function () {
      var _context$beforeReadon, _context$afterReadonl, _formReadonly$readonl;
      if (isBoolean(context === null || context === void 0 || (_context$beforeReadon = context.beforeReadonly) === null || _context$beforeReadon === void 0 ? void 0 : _context$beforeReadon.value)) return context.beforeReadonly.value;
      if (isBoolean(componentReadonly === null || componentReadonly === void 0 ? void 0 : componentReadonly.value)) return componentReadonly.value;
      if (isBoolean(context === null || context === void 0 || (_context$afterReadonl = context.afterReadonly) === null || _context$afterReadonl === void 0 ? void 0 : _context$afterReadonl.value)) return context.afterReadonly.value;
      if (isBoolean((_formReadonly$readonl = formReadonly.readonly) === null || _formReadonly$readonl === void 0 ? void 0 : _formReadonly$readonl.value)) return formReadonly.readonly.value;
      return false;
    });
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var FormItemInjectionKey = Symbol("FormItemProvide");
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function useLengthLimit(params) {
    var getValueByLimitNumber = function getValueByLimitNumber2(inputValue) {
      var _params$value = params.value, allowInputOverMax = _params$value.allowInputOverMax, maxlength = _params$value.maxlength, maxcharacter = _params$value.maxcharacter;
      if (!(maxlength || maxcharacter) || allowInputOverMax || !inputValue) return inputValue;
      if (maxlength) {
        return limitUnicodeMaxLength(inputValue, maxlength);
      }
      if (maxcharacter) {
        var r = getCharacterLength(inputValue, maxcharacter);
        if (isObject(r)) {
          return r.characters;
        }
      }
    };
    var limitNumber = computed(function () {
      var _params$value2 = params.value, maxlength = _params$value2.maxlength, maxcharacter = _params$value2.maxcharacter, value = _params$value2.value;
      if (isNumber(value)) return String(value);
      if (maxlength && maxcharacter) {
        log.warn("Input", "Pick one of maxlength and maxcharacter please.");
      }
      if (maxlength) {
        var length = value !== null && value !== void 0 && value.length ? getUnicodeLength(value) : 0;
        return "".concat(length, "/").concat(maxlength);
      }
      if (maxcharacter) {
        return "".concat(getCharacterLength(value || ""), "/").concat(maxcharacter);
      }
      return "";
    });
    var innerStatus = computed(function () {
      if (limitNumber.value) {
        var _limitNumber$value$sp = limitNumber.value.split("/"), _limitNumber$value$sp2 = _slicedToArray(_limitNumber$value$sp, 2), current = _limitNumber$value$sp2[0], total = _limitNumber$value$sp2[1];
        return Number(current) > Number(total) ? "error" : "";
      }
      return "";
    });
    var tStatus = computed(function () {
      var status = params.value.status;
      return status || innerStatus.value;
    });
    var onValidateChange = function onValidateChange2() {
      var _params$value$onValid, _params$value3;
      (_params$value$onValid = (_params$value3 = params.value).onValidate) === null || _params$value$onValid === void 0 || _params$value$onValid.call(_params$value3, {
        error: innerStatus.value ? "exceed-maximum" : void 0
      });
    };
    watch(innerStatus, onValidateChange);
    onMounted(function () {
      innerStatus.value && onValidateChange();
    });
    return {
      tStatus,
      limitNumber,
      getValueByLimitNumber
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function getOutputValue(val, type) {
    if (type === "number") {
      return val || val === 0 ? Number(val) : void 0;
    }
    return val;
  }
  function useInput(props2, expose) {
    var _toRefs = toRefs(props2), value = _toRefs.value, modelValue = _toRefs.modelValue;
    var inputValue = ref();
    var isComposition = ref(false);
    var compositionValue = ref();
    var clearIconRef = ref(null);
    var innerClickElement = ref();
    var disabled = useDisabled();
    var readonly2 = useReadonly();
    var _useVModel = useVModel(value, modelValue, props2.defaultValue, props2.onChange), _useVModel2 = _slicedToArray(_useVModel, 2), innerValue = _useVModel2[0], setInnerValue = _useVModel2[1];
    var isHover = ref(false);
    var focused = ref(false);
    var renderType = ref(props2.type);
    var inputRef = ref(null);
    var limitParams = computed(function () {
      return {
        value: [void 0, null].includes(innerValue.value) ? void 0 : String(innerValue.value),
        status: props2.status,
        maxlength: Number(props2.maxlength),
        maxcharacter: props2.maxcharacter,
        allowInputOverMax: props2.allowInputOverMax,
        onValidate: props2.onValidate
      };
    });
    var _useLengthLimit = useLengthLimit(limitParams), limitNumber = _useLengthLimit.limitNumber, getValueByLimitNumber = _useLengthLimit.getValueByLimitNumber, tStatus = _useLengthLimit.tStatus;
    var showClear = computed(function () {
      return (innerValue.value && !disabled.value && props2.clearable && !readonly2.value || props2.showClearIconOnEmpty) && isHover.value;
    });
    var focus = function focus2() {
      var _inputRef$value;
      focused.value = true;
      (_inputRef$value = inputRef.value) === null || _inputRef$value === void 0 || _inputRef$value.focus();
    };
    var blur = function blur2() {
      var _inputRef$value2;
      focused.value = false;
      (_inputRef$value2 = inputRef.value) === null || _inputRef$value2 === void 0 || _inputRef$value2.blur();
    };
    var emitFocus = function emitFocus2(e) {
      var _props$onFocus;
      if (isHover.value && focused.value) return;
      inputValue.value = innerValue.value;
      if (props2.disabled) return;
      focused.value = true;
      (_props$onFocus = props2.onFocus) === null || _props$onFocus === void 0 || _props$onFocus.call(props2, innerValue.value, {
        e
      });
    };
    var emitClear = function emitClear2(_ref) {
      var _props$onClear;
      var e = _ref.e;
      var val = props2.type === "number" ? void 0 : "";
      setInnerValue(val, {
        e,
        trigger: "clear"
      });
      (_props$onClear = props2.onClear) === null || _props$onClear === void 0 || _props$onClear.call(props2, {
        e
      });
    };
    var onClearIconMousedown = function onClearIconMousedown2(e) {
      innerClickElement.value = e.target;
    };
    var emitPassword = function emitPassword2() {
      if (disabled.value) return;
      var toggleType = renderType.value === "password" ? "text" : "password";
      renderType.value = toggleType;
    };
    var setInputElValue = function setInputElValue2() {
      var v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var inputEl = inputRef.value;
      if (!inputEl) return;
      var sV = String(v);
      if (!inputEl.value) {
        return;
      }
      if (inputEl.value !== sV) {
        inputEl.value = sV;
      }
    };
    var inputValueChangeHandle = function inputValueChangeHandle2(e) {
      var _innerValue$value;
      var target = e.target;
      var val = target.value;
      if (props2.type !== "number" && typeof innerValue.value === "string" && val.length > ((_innerValue$value = innerValue.value) === null || _innerValue$value === void 0 ? void 0 : _innerValue$value.length)) {
        val = getValueByLimitNumber(val);
      }
      setInnerValue(getOutputValue(val, props2.type), {
        e,
        trigger: "input"
      });
      nextTick(function () {
        if (props2.type === "number" && /\.(\d+)?0$/.test(val)) {
          setInputElValue(val);
        } else {
          setInputElValue(innerValue.value);
        }
      });
    };
    var handleInput = function handleInput2(e) {
      var checkInputType = e.inputType && e.inputType === "insertCompositionText";
      var val = e.currentTarget.value;
      if (checkInputType || isComposition.value) {
        compositionValue.value = val;
        return;
      }
      inputValueChangeHandle(e);
    };
    var isClearIcon = function isClearIcon2() {
      var _clearIconRef$value;
      var tmp = innerClickElement.value;
      if (!tmp || !tmp.tagName || !((_clearIconRef$value = clearIconRef.value) !== null && _clearIconRef$value !== void 0 && _clearIconRef$value.$el) || !["path", "svg"].includes(tmp.tagName)) return false;
      while (tmp) {
        var _clearIconRef$value2;
        if (((_clearIconRef$value2 = clearIconRef.value) === null || _clearIconRef$value2 === void 0 ? void 0 : _clearIconRef$value2.$el) === tmp) {
          return true;
        }
        tmp = tmp.parentNode;
      }
      return false;
    };
    var formItem = inject(FormItemInjectionKey, void 0);
    var formatAndEmitBlur = function formatAndEmitBlur2(e) {
      if (!isClearIcon()) {
        var _props$onBlur;
        if (props2.format) {
          inputValue.value = typeof innerValue.value === "number" || props2.type === "number" ? innerValue.value : props2.format(innerValue.value);
        }
        focused.value = false;
        (_props$onBlur = props2.onBlur) === null || _props$onBlur === void 0 || _props$onBlur.call(props2, innerValue.value, {
          e
        });
        formItem === null || formItem === void 0 || formItem.handleBlur();
      } else {
        focus();
      }
    };
    var onHandleCompositionend = function onHandleCompositionend2(e) {
      var _props$onCompositione;
      isComposition.value = false;
      compositionValue.value = "";
      inputValueChangeHandle(e);
      (_props$onCompositione = props2.onCompositionend) === null || _props$onCompositione === void 0 || _props$onCompositione.call(props2, String(innerValue.value), {
        e
      });
    };
    var onHandleCompositionstart = function onHandleCompositionstart2(e) {
      var _props$onCompositions;
      isComposition.value = true;
      var value2 = e.currentTarget.value;
      compositionValue.value = value2;
      (_props$onCompositions = props2.onCompositionstart) === null || _props$onCompositions === void 0 || _props$onCompositions.call(props2, String(innerValue.value), {
        e
      });
    };
    var onRootClick = function onRootClick2(e) {
      var _inputRef$value3, _props$onClick;
      (_inputRef$value3 = inputRef.value) === null || _inputRef$value3 === void 0 || _inputRef$value3.focus();
      (_props$onClick = props2.onClick) === null || _props$onClick === void 0 || _props$onClick.call(props2, {
        e
      });
    };
    watch(function () {
      return props2.autofocus;
    }, function (value2) {
      if (value2 === true) {
        nextTick(function () {
          var _inputRef$value4;
          (_inputRef$value4 = inputRef.value) === null || _inputRef$value4 === void 0 || _inputRef$value4.focus();
        });
      }
    }, {
      immediate: true
    });
    watch(innerValue, function (val, oldVal) {
      var isNumberType = props2.type === "number";
      if (oldVal === void 0 && props2.format && typeof val !== "number" && !isNumberType) {
        inputValue.value = props2.format(val);
      } else {
        inputValue.value = val;
      }
      var newVal = typeof val === "number" ? val : getValueByLimitNumber(val);
      if (newVal !== val && !isNumberType) {
        setInnerValue(newVal, {
          trigger: "initial"
        });
      }
    }, {
      immediate: true
    });
    watch(function () {
      return props2.type;
    }, function (v) {
      renderType.value = v;
    }, {
      immediate: true
    });
    expose({
      inputRef,
      focus,
      blur
    });
    return {
      isHover,
      focused,
      renderType,
      showClear,
      inputRef,
      clearIconRef,
      inputValue,
      isComposition,
      compositionValue,
      limitNumber,
      tStatus,
      emitFocus,
      formatAndEmitBlur,
      onHandleCompositionend,
      onHandleCompositionstart,
      onRootClick,
      emitPassword,
      handleInput,
      emitClear,
      onClearIconMousedown,
      innerValue
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function useInputEventHandler(props2, isHover) {
    var handleKeydown = function handleKeydown2(e) {
      if (props2.disabled) return;
      var code = e.code;
      var tmpValue = getOutputValue(e.currentTarget.value, props2.type);
      if (/enter/i.test(code) || /enter/i.test(e.key)) {
        var _props$onEnter;
        (_props$onEnter = props2.onEnter) === null || _props$onEnter === void 0 || _props$onEnter.call(props2, tmpValue, {
          e
        });
      } else {
        var _props$onKeydown;
        (_props$onKeydown = props2.onKeydown) === null || _props$onKeydown === void 0 || _props$onKeydown.call(props2, tmpValue, {
          e
        });
      }
    };
    var handleKeyUp = function handleKeyUp2(e) {
      var _props$onKeyup;
      if (props2.disabled) return;
      var tmpValue = getOutputValue(e.currentTarget.value, props2.type);
      (_props$onKeyup = props2.onKeyup) === null || _props$onKeyup === void 0 || _props$onKeyup.call(props2, tmpValue, {
        e
      });
    };
    var handleKeypress = function handleKeypress2(e) {
      var _props$onKeypress;
      if (props2.disabled) return;
      var tmpValue = getOutputValue(e.currentTarget.value, props2.type);
      (_props$onKeypress = props2.onKeypress) === null || _props$onKeypress === void 0 || _props$onKeypress.call(props2, tmpValue, {
        e
      });
    };
    var onHandlePaste = function onHandlePaste2(e) {
      var _props$onPaste;
      if (props2.disabled) return;
      var clipData = e.clipboardData || window.clipboardData;
      (_props$onPaste = props2.onPaste) === null || _props$onPaste === void 0 || _props$onPaste.call(props2, {
        e,
        pasteValue: clipData === null || clipData === void 0 ? void 0 : clipData.getData("text/plain")
      });
    };
    var mouseEvent = function mouseEvent2(v) {
      return isHover.value = v;
    };
    var onHandleMousewheel = function onHandleMousewheel2(e) {
      var _props$onWheel;
      return (_props$onWheel = props2.onWheel) === null || _props$onWheel === void 0 ? void 0 : _props$onWheel.call(props2, {
        e
      });
    };
    var onInputMouseenter = function onInputMouseenter2(e) {
      var _props$onMouseenter;
      mouseEvent(true);
      (_props$onMouseenter = props2.onMouseenter) === null || _props$onMouseenter === void 0 || _props$onMouseenter.call(props2, {
        e
      });
    };
    var onInputMouseleave = function onInputMouseleave2(e) {
      var _props$onMouseleave;
      mouseEvent(false);
      (_props$onMouseleave = props2.onMouseleave) === null || _props$onMouseleave === void 0 || _props$onMouseleave.call(props2, {
        e
      });
    };
    return {
      isHover,
      handleKeydown,
      handleKeyUp,
      handleKeypress,
      onHandlePaste,
      onHandleMousewheel,
      onInputMouseenter,
      onInputMouseleave
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var ANIMATION_TIME = 100;
  function useInputWidth(props2, inputRef, innerValue) {
    var _toRefs = toRefs(props2), autoWidth = _toRefs.autoWidth, placeholder = _toRefs.placeholder;
    var inputPreRef = ref(null);
    var observerTimer = ref(null);
    var updateInputWidth = function updateInputWidth2() {
      if (!inputPreRef.value || !inputRef.value) return;
      inputRef.value.style.width = getComputedStyle(inputPreRef.value).width;
    };
    useResizeObserver(inputPreRef, function () {
      if (autoWidth.value) {
        observerTimer.value = setTimeout(function () {
          updateInputWidth();
          clearTimeout(observerTimer.value);
        }, ANIMATION_TIME);
      }
    });
    onBeforeUnmount(function () {
      clearTimeout(observerTimer.value);
    });
    var addListeners = function addListeners2() {
      watch([innerValue, placeholder], function () {
        if (!autoWidth.value) return;
        nextTick(function () {
          updateInputWidth();
        });
      }, {
        immediate: true
      });
    };
    onMounted(function () {
      if (autoWidth.value) {
        addListeners();
      }
    });
    return {
      inputPreRef
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var _excluded$4 = ["isHover", "tStatus", "inputRef", "renderType", "showClear", "focused", "inputValue", "isComposition", "compositionValue", "innerValue", "limitNumber"];
  function ownKeys$d(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$d(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$d(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var _Input = /* @__PURE__ */ defineComponent({
    name: "TInput",
    props: _objectSpread$d(_objectSpread$d({}, props$c), {}, {
      showInput: {
        type: Boolean,
        "default": true
      },
      keepWrapperWidth: {
        type: Boolean,
        "default": false
      }
    }),
    setup: function setup14(props2, _ref) {
      var expose = _ref.expose;
      var _useConfig = useConfig("input"), globalConfig = _useConfig.globalConfig;
      var _useGlobalIcon = useGlobalIcon({
        BrowseIcon: browse,
        BrowseOffIcon: browseOff,
        CloseCircleFilledIcon: closeCircleFilled
      }), BrowseIcon$1 = _useGlobalIcon.BrowseIcon, BrowseOffIcon$1 = _useGlobalIcon.BrowseOffIcon, CloseCircleFilledIcon$1 = _useGlobalIcon.CloseCircleFilledIcon;
      var readonly2 = useReadonly();
      var disabled = useDisabled();
      var COMPONENT_NAME = usePrefixClass("input");
      var INPUT_WRAP_CLASS = usePrefixClass("input__wrap");
      var INPUT_TIPS_CLASS = usePrefixClass("input__tips");
      var _useCommonClassName = useCommonClassName$1(), STATUS = _useCommonClassName.STATUS, SIZE = _useCommonClassName.SIZE;
      var classPrefix = usePrefixClass();
      var renderTNodeJSX = useTNodeJSX();
      var _useInput = useInput(props2, expose), isHover = _useInput.isHover, tStatus = _useInput.tStatus, inputRef = _useInput.inputRef, renderType = _useInput.renderType, showClear = _useInput.showClear, focused = _useInput.focused, inputValue = _useInput.inputValue, isComposition = _useInput.isComposition, compositionValue = _useInput.compositionValue, innerValue = _useInput.innerValue, limitNumber = _useInput.limitNumber, inputHandle = _objectWithoutProperties(_useInput, _excluded$4);
      var _useInputWidth = useInputWidth(props2, inputRef, innerValue), inputPreRef = _useInputWidth.inputPreRef;
      var inputEventHandler = useInputEventHandler(props2, isHover);
      var tPlaceholder = computed(function () {
        var _props2$placeholder;
        return (_props2$placeholder = props2.placeholder) !== null && _props2$placeholder !== void 0 ? _props2$placeholder : globalConfig.value.placeholder;
      });
      var inputAttrs = computed(function () {
        var _props2$autocomplete;
        var value = {
          autofocus: props2.autofocus,
          disabled: disabled.value,
          readonly: readonly2.value,
          placeholder: tPlaceholder.value,
          name: props2.name || void 0,
          type: renderType.value,
          autocomplete: (_props2$autocomplete = props2.autocomplete) !== null && _props2$autocomplete !== void 0 ? _props2$autocomplete : globalConfig.value.autocomplete || void 0,
          unselectable: readonly2.value ? "on" : "off",
          spellcheck: props2.spellCheck
        };
        return getValidAttrs(value);
      });
      var wrapClasses = computed(function () {
        return [INPUT_WRAP_CLASS.value, _defineProperty$1({}, "".concat(COMPONENT_NAME.value, "--auto-width"), props2.autoWidth && !props2.keepWrapperWidth)];
      });
      var inputEvents = getValidAttrs({
        onFocus: inputHandle.emitFocus,
        onBlur: inputHandle.formatAndEmitBlur,
        onKeydown: inputEventHandler.handleKeydown,
        onKeyup: inputEventHandler.handleKeyUp,
        onKeypress: inputEventHandler.handleKeypress,
        onPaste: inputEventHandler.onHandlePaste,
        onCompositionend: inputHandle.onHandleCompositionend,
        onCompositionstart: inputHandle.onHandleCompositionstart
      });
      return function () {
        var _compositionValue$val, _inputValue$value, _compositionValue$val2;
        var prefixIcon = renderTNodeJSX("prefixIcon");
        var suffixIcon = renderTNodeJSX("suffixIcon");
        var passwordIcon = renderTNodeJSX("passwordIcon");
        var label = renderTNodeJSX("label", {
          silent: true
        });
        var suffix2 = renderTNodeJSX("suffix");
        var limitNode = limitNumber.value && props2.showLimitNumber ? createVNode("div", {
          "class": ["".concat(classPrefix.value, "-input__limit-number"), _defineProperty$1({}, "".concat(classPrefix.value, "-is-disabled"), disabled.value)]
        }, [limitNumber.value]) : null;
        var labelContent = label ? createVNode("div", {
          "class": "".concat(COMPONENT_NAME.value, "__prefix")
        }, [label]) : null;
        var suffixContent = suffix2 || limitNode ? createVNode("div", {
          "class": "".concat(COMPONENT_NAME.value, "__suffix")
        }, [suffix2, limitNode]) : null;
        if (props2.type === "password") {
          var passwordClass = [_defineProperty$1({}, "".concat(COMPONENT_NAME.value, "__suffix-clear"), !disabled.value)];
          if (renderType.value === "password") {
            suffixIcon = createVNode(BrowseOffIcon$1, {
              "class": passwordClass,
              "onClick": inputHandle.emitPassword
            }, null);
          } else if (renderType.value === "text") {
            suffixIcon = createVNode(BrowseIcon$1, {
              "class": passwordClass,
              "onClick": inputHandle.emitPassword
            }, null);
          }
        }
        if (showClear.value) {
          if (props2.type === "password") {
            passwordIcon = createVNode(CloseCircleFilledIcon$1, {
              "ref": inputHandle.clearIconRef,
              "class": "".concat(COMPONENT_NAME.value, "__suffix-clear"),
              "onClick": inputHandle.emitClear,
              "onMousedown": inputHandle.onClearIconMousedown
            }, null);
          } else {
            suffixIcon = createVNode(CloseCircleFilledIcon$1, {
              "ref": inputHandle.clearIconRef,
              "class": "".concat(COMPONENT_NAME.value, "__suffix-clear"),
              "onClick": inputHandle.emitClear,
              "onMousedown": inputHandle.onClearIconMousedown
            }, null);
          }
        }
        var classes = [COMPONENT_NAME.value, props2.inputClass, _defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1({}, SIZE.value[props2.size], props2.size !== "medium"), STATUS.value.disabled, disabled.value), STATUS.value.focused, disabled.value ? false : focused.value), "".concat(classPrefix.value, "-is-").concat(tStatus.value), tStatus.value && tStatus.value !== "default"), "".concat(classPrefix.value, "-align-").concat(props2.align), props2.align !== "left"), "".concat(classPrefix.value, "-is-readonly"), readonly2.value), "".concat(COMPONENT_NAME.value, "--prefix"), prefixIcon || labelContent), "".concat(COMPONENT_NAME.value, "--suffix"), suffixIcon || suffixContent), "".concat(COMPONENT_NAME.value, "--borderless"), props2.borderless), "".concat(COMPONENT_NAME.value, "--focused"), focused.value)];
        var tips = renderTNodeJSX("tips");
        var tipsClasses = [INPUT_TIPS_CLASS.value, "".concat(classPrefix.value, "-tips"), "".concat(classPrefix.value, "-is-").concat(tStatus.value || "default")];
        return withDirectives(createVNode("div", {
          "class": wrapClasses.value
        }, [createVNode("div", {
          "class": classes,
          "onClick": inputHandle.onRootClick,
          "onMouseenter": inputEventHandler.onInputMouseenter,
          "onMouseleave": inputEventHandler.onInputMouseleave,
          "onWheel": inputEventHandler.onHandleMousewheel
        }, [prefixIcon ? createVNode("span", {
          "class": ["".concat(COMPONENT_NAME.value, "__prefix"), "".concat(COMPONENT_NAME.value, "__prefix-icon")]
        }, [prefixIcon]) : null, labelContent, createVNode("input", mergeProps({
          "class": ["".concat(COMPONENT_NAME.value, "__inner"), _defineProperty$1({}, "".concat(COMPONENT_NAME.value, "--soft-hidden"), !props2.showInput)]
        }, inputAttrs.value, inputEvents, {
          "ref": inputRef,
          "value": isComposition.value ? (_compositionValue$val = compositionValue.value) !== null && _compositionValue$val !== void 0 ? _compositionValue$val : "" : (_inputValue$value = inputValue.value) !== null && _inputValue$value !== void 0 ? _inputValue$value : "",
          "onInput": function onInput(e) {
            return inputHandle.handleInput(e);
          }
        }), null), props2.autoWidth && createVNode("span", {
          "ref": inputPreRef,
          "class": "".concat(classPrefix.value, "-input__input-pre")
        }, [isComposition.value ? (_compositionValue$val2 = compositionValue.value) !== null && _compositionValue$val2 !== void 0 ? _compositionValue$val2 : "" : innerValue.value || tPlaceholder.value]), suffixContent, passwordIcon ? createVNode("span", {
          "class": ["".concat(COMPONENT_NAME.value, "__suffix"), "".concat(COMPONENT_NAME.value, "__suffix-icon"), "".concat(COMPONENT_NAME.value, "__clear")]
        }, [passwordIcon]) : null, suffixIcon ? createVNode("span", {
          "class": ["".concat(COMPONENT_NAME.value, "__suffix"), "".concat(COMPONENT_NAME.value, "__suffix-icon"), _defineProperty$1({}, "".concat(COMPONENT_NAME.value, "__clear"), showClear.value)]
        }, [suffixIcon]) : null]), tips && createVNode("div", {
          "class": tipsClasses
        }, [tips])]), [[vShow, props2.type !== "hidden"]]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var inputGroupProps = {
    separate: Boolean
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var _InputGroup = /* @__PURE__ */ defineComponent({
    name: "TInputGroup",
    props: inputGroupProps,
    setup: function setup15(props2) {
      var COMPONENT_NAME = usePrefixClass("input-group");
      var renderTNodeJSX = useTNodeJSX();
      var CLASS = computed(function () {
        return [COMPONENT_NAME.value, _defineProperty$1({}, "".concat(COMPONENT_NAME.value, "--separate"), props2.separate)];
      });
      return function () {
        return createVNode("div", {
          "class": CLASS.value
        }, [renderTNodeJSX("default")]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var Input = withInstall(_Input);
  withInstall(_InputGroup);
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var props$b = {
    allowInput: Boolean,
    autoWidth: Boolean,
    autofocus: Boolean,
    borderless: Boolean,
    clearable: Boolean,
    collapsedItems: {
      type: Function
    },
    disabled: {
      type: Boolean,
      "default": void 0
    },
    inputProps: {
      type: Object
    },
    inputValue: {
      type: [String, Number],
      "default": void 0
    },
    defaultInputValue: {
      type: [String, Number]
    },
    keys: {
      type: Object
    },
    label: {
      type: [String, Function]
    },
    loading: Boolean,
    minCollapsedNum: {
      type: Number,
      "default": 0
    },
    multiple: Boolean,
    panel: {
      type: [String, Function]
    },
    placeholder: {
      type: String,
      "default": ""
    },
    popupProps: {
      type: Object
    },
    popupVisible: {
      type: Boolean,
      "default": void 0
    },
    defaultPopupVisible: Boolean,
    prefixIcon: {
      type: Function
    },
    readonly: {
      type: Boolean,
      "default": void 0
    },
    reserveKeyword: Boolean,
    size: {
      type: String,
      "default": "medium",
      validator: function validator16(val) {
        if (!val) return true;
        return ["small", "medium", "large"].includes(val);
      }
    },
    status: {
      type: String,
      "default": "default",
      validator: function validator17(val) {
        if (!val) return true;
        return ["default", "success", "warning", "error"].includes(val);
      }
    },
    suffix: {
      type: [String, Function]
    },
    suffixIcon: {
      type: Function
    },
    tag: {
      type: [String, Function]
    },
    tagInputProps: {
      type: Object
    },
    tagProps: {
      type: Object
    },
    tips: {
      type: [String, Function]
    },
    value: {
      type: [String, Number, Boolean, Object, Array, Date],
      "default": void 0
    },
    valueDisplay: {
      type: [String, Function]
    },
    onBlur: Function,
    onClear: Function,
    onEnter: Function,
    onFocus: Function,
    onInputChange: Function,
    onMouseenter: Function,
    onMouseleave: Function,
    onPaste: Function,
    onPopupVisibleChange: Function,
    onTagChange: Function
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var props$a = {
    autoWidth: Boolean,
    borderless: Boolean,
    clearable: Boolean,
    collapsedItems: {
      type: Function
    },
    disabled: {
      type: Boolean,
      "default": void 0
    },
    dragSort: Boolean,
    excessTagsDisplayType: {
      type: String,
      "default": "break-line",
      validator: function validator18(val) {
        if (!val) return true;
        return ["scroll", "break-line"].includes(val);
      }
    },
    inputProps: {
      type: Object
    },
    inputValue: {
      type: [String, Number],
      "default": void 0
    },
    defaultInputValue: {
      type: [String, Number],
      "default": ""
    },
    label: {
      type: [String, Function]
    },
    max: {
      type: Number
    },
    minCollapsedNum: {
      type: Number,
      "default": 0
    },
    placeholder: {
      type: String,
      "default": void 0
    },
    prefixIcon: {
      type: Function
    },
    readonly: {
      type: Boolean,
      "default": void 0
    },
    size: {
      type: String,
      "default": "medium",
      validator: function validator19(val) {
        if (!val) return true;
        return ["small", "medium", "large"].includes(val);
      }
    },
    status: {
      type: String,
      validator: function validator20(val) {
        if (!val) return true;
        return ["default", "success", "warning", "error"].includes(val);
      }
    },
    suffix: {
      type: [String, Function]
    },
    suffixIcon: {
      type: Function
    },
    tag: {
      type: [String, Function]
    },
    tagProps: {
      type: Object
    },
    tips: {
      type: [String, Function]
    },
    value: {
      type: Array,
      "default": void 0
    },
    modelValue: {
      type: Array,
      "default": void 0
    },
    defaultValue: {
      type: Array,
      "default": function _default2() {
        return [];
      }
    },
    valueDisplay: {
      type: [String, Function]
    },
    onBlur: Function,
    onChange: Function,
    onClear: Function,
    onClick: Function,
    onDragSort: Function,
    onEnter: Function,
    onFocus: Function,
    onInputChange: Function,
    onMouseenter: Function,
    onMouseleave: Function,
    onPaste: Function,
    onRemove: Function
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function useDragSorter(props2) {
    var sortOnDraggable = props2.sortOnDraggable, onDragSort = props2.onDragSort, onDragOverCheck = props2.onDragOverCheck;
    var draggingIndex = ref(-1);
    var dragStartData = ref(null);
    var isDropped = ref(null);
    var startInfo = reactive({
      nodeX: 0,
      nodeWidth: 0,
      mouseX: 0
    });
    var onDragOver = function onDragOver2(e, index, record) {
      e.preventDefault();
      if (draggingIndex.value === index || draggingIndex.value === -1) return;
      var target = e.target;
      if (onDragOverCheck !== null && onDragOverCheck !== void 0 && onDragOverCheck.targetClassNameRegExp && !(onDragOverCheck !== null && onDragOverCheck !== void 0 && onDragOverCheck.targetClassNameRegExp.test(target.className))) {
        return;
      }
      if (onDragOverCheck !== null && onDragOverCheck !== void 0 && onDragOverCheck.x && target) {
        if (!startInfo.nodeWidth) return;
        var _target$getBoundingCl = target.getBoundingClientRect(), x = _target$getBoundingCl.x, width = _target$getBoundingCl.width;
        var targetNodeMiddleX = x + width / 2;
        var draggingNodeLeft = e.clientX - (startInfo.mouseX - startInfo.nodeX);
        var draggingNodeRight = draggingNodeLeft + startInfo.nodeWidth;
        var overlap = false;
        if (draggingNodeLeft > x && draggingNodeLeft < x + width) {
          overlap = draggingNodeLeft < targetNodeMiddleX;
        } else {
          overlap = draggingNodeRight > targetNodeMiddleX;
        }
        if (!overlap) return;
      }
      onDragSort === null || onDragSort === void 0 || onDragSort({
        currentIndex: draggingIndex.value,
        current: dragStartData,
        target: record,
        targetIndex: index
      });
      draggingIndex.value = index;
    };
    if (!sortOnDraggable) {
      return {};
    }
    function onDragStart(e, index, record) {
      draggingIndex.value = index;
      dragStartData.value = record;
      var target = e.target;
      if (onDragOverCheck && target) {
        var _target$getBoundingCl2 = target.getBoundingClientRect(), x = _target$getBoundingCl2.x, width = _target$getBoundingCl2.width;
        startInfo.nodeX = x;
        startInfo.nodeWidth = width;
        startInfo.mouseX = e.clientX;
      }
    }
    function _onDrop() {
      isDropped.value = true;
    }
    function onDragEnd() {
      if (!isDropped.value);
      isDropped.value = false;
      draggingIndex.value = -1;
      dragStartData.value = null;
    }
    function getDragProps(index, record) {
      if (sortOnDraggable) {
        return {
          draggable: true,
          onDragstart: function onDragstart(e) {
            onDragStart(e, index, record);
          },
          onDragover: function onDragover(e) {
            onDragOver(e, index, record);
          },
          onDrop: function onDrop() {
            _onDrop();
          },
          onDragend: function onDragend() {
            onDragEnd();
          }
        };
      }
      return {};
    }
    return {
      onDragStart,
      onDragOver,
      onDrop: _onDrop,
      onDragEnd,
      getDragProps,
      dragging: draggingIndex.value !== -1
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function useHover(props2) {
    var disabled = props2.disabled, readonly2 = props2.readonly, onMouseenter = props2.onMouseenter, onMouseleave = props2.onMouseleave;
    var isHover = ref(false);
    var addHover = function addHover2(context) {
      if (readonly2 || disabled) return;
      isHover.value = true;
      onMouseenter === null || onMouseenter === void 0 || onMouseenter(context);
    };
    var cancelHover = function cancelHover2(context) {
      if (readonly2 || disabled) return;
      isHover.value = false;
      onMouseleave === null || onMouseleave === void 0 || onMouseleave(context);
    };
    return {
      isHover,
      addHover,
      cancelHover
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function useTagScroll(props2) {
    var tagInputRef = ref();
    var _toRefs = toRefs(props2), excessTagsDisplayType = _toRefs.excessTagsDisplayType, readonly2 = _toRefs.readonly, disabled = _toRefs.disabled;
    var scrollDistance = ref(0);
    var scrollElement = ref();
    var mouseEnterTimer = ref();
    var isScrollable = ref(false);
    var updateScrollElement = function updateScrollElement2(element2) {
      var inputElement = element2.children[0];
      scrollElement.value = inputElement;
    };
    var updateScrollDistance = function updateScrollDistance2() {
      scrollDistance.value = scrollElement.value.scrollWidth - scrollElement.value.clientWidth;
    };
    var scrollTo = function scrollTo2(distance) {
      var _scrollElement$value;
      if (!isFunction((_scrollElement$value = scrollElement.value) === null || _scrollElement$value === void 0 ? void 0 : _scrollElement$value.scroll)) return;
      scrollElement.value.scroll({
        left: distance,
        behavior: "smooth"
      });
    };
    var scrollToRight = function scrollToRight2() {
      updateScrollDistance();
      scrollTo(scrollDistance.value);
      setTimeout(function () {
        isScrollable.value = true;
      }, 200);
    };
    var scrollToLeft = function scrollToLeft2() {
      scrollTo(0);
    };
    var onWheel = function onWheel2(_ref) {
      var e = _ref.e;
      if (readonly2.value || disabled.value) return;
      if (!scrollElement.value) return;
      if (e.deltaX > 0) {
        var distance = Math.min(scrollElement.value.scrollLeft + 120, scrollDistance.value);
        scrollTo(distance);
      } else {
        var _distance = Math.max(scrollElement.value.scrollLeft - 120, 0);
        scrollTo(_distance);
      }
    };
    var scrollToRightOnEnter = function scrollToRightOnEnter2() {
      if (excessTagsDisplayType.value !== "scroll") return;
      mouseEnterTimer.value = setTimeout(function () {
        scrollToRight();
        clearTimeout(mouseEnterTimer.value);
      }, 100);
    };
    var scrollToLeftOnLeave = function scrollToLeftOnLeave2() {
      if (excessTagsDisplayType.value !== "scroll") return;
      isScrollable.value = false;
      scrollTo(0);
      clearTimeout(mouseEnterTimer.value);
    };
    var init = function init2() {
      var _tagInputRef$value;
      var element2 = (_tagInputRef$value = tagInputRef.value) === null || _tagInputRef$value === void 0 ? void 0 : _tagInputRef$value.$el;
      if (!element2) return;
      updateScrollElement(element2);
    };
    var clear = function clear2() {
      clearTimeout(mouseEnterTimer.value);
    };
    onMounted(init);
    onUnmounted(clear);
    return {
      tagInputRef,
      scrollElement,
      scrollDistance,
      scrollTo,
      scrollToRight,
      scrollToLeft,
      updateScrollElement,
      updateScrollDistance,
      onWheel,
      scrollToRightOnEnter,
      scrollToLeftOnLeave,
      isScrollable
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj2) {
      return typeof obj2;
    } : function (obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }
  var trimLeft = /^\s+/;
  var trimRight = /\s+$/;
  function tinycolor(color, opts) {
    color = color ? color : "";
    opts = opts || {};
    if (color instanceof tinycolor) {
      return color;
    }
    if (!(this instanceof tinycolor)) {
      return new tinycolor(color, opts);
    }
    var rgb = inputToRGB(color);
    this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;
    if (this._r < 1) this._r = Math.round(this._r);
    if (this._g < 1) this._g = Math.round(this._g);
    if (this._b < 1) this._b = Math.round(this._b);
    this._ok = rgb.ok;
  }
  tinycolor.prototype = {
    isDark: function isDark() {
      return this.getBrightness() < 128;
    },
    isLight: function isLight() {
      return !this.isDark();
    },
    isValid: function isValid() {
      return this._ok;
    },
    getOriginalInput: function getOriginalInput() {
      return this._originalInput;
    },
    getFormat: function getFormat() {
      return this._format;
    },
    getAlpha: function getAlpha() {
      return this._a;
    },
    getBrightness: function getBrightness() {
      var rgb = this.toRgb();
      return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
    },
    getLuminance: function getLuminance() {
      var rgb = this.toRgb();
      var RsRGB, GsRGB, BsRGB, R, G, B;
      RsRGB = rgb.r / 255;
      GsRGB = rgb.g / 255;
      BsRGB = rgb.b / 255;
      if (RsRGB <= 0.03928) R = RsRGB / 12.92;
      else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
      if (GsRGB <= 0.03928) G = GsRGB / 12.92;
      else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
      if (BsRGB <= 0.03928) B = BsRGB / 12.92;
      else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
      return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    },
    setAlpha: function setAlpha(value) {
      this._a = boundAlpha(value);
      this._roundA = Math.round(100 * this._a) / 100;
      return this;
    },
    toHsv: function toHsv() {
      var hsv = rgbToHsv(this._r, this._g, this._b);
      return {
        h: hsv.h * 360,
        s: hsv.s,
        v: hsv.v,
        a: this._a
      };
    },
    toHsvString: function toHsvString() {
      var hsv = rgbToHsv(this._r, this._g, this._b);
      var h2 = Math.round(hsv.h * 360), s = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
      return this._a == 1 ? "hsv(" + h2 + ", " + s + "%, " + v + "%)" : "hsva(" + h2 + ", " + s + "%, " + v + "%, " + this._roundA + ")";
    },
    toHsl: function toHsl() {
      var hsl = rgbToHsl(this._r, this._g, this._b);
      return {
        h: hsl.h * 360,
        s: hsl.s,
        l: hsl.l,
        a: this._a
      };
    },
    toHslString: function toHslString() {
      var hsl = rgbToHsl(this._r, this._g, this._b);
      var h2 = Math.round(hsl.h * 360), s = Math.round(hsl.s * 100), l = Math.round(hsl.l * 100);
      return this._a == 1 ? "hsl(" + h2 + ", " + s + "%, " + l + "%)" : "hsla(" + h2 + ", " + s + "%, " + l + "%, " + this._roundA + ")";
    },
    toHex: function toHex(allow3Char) {
      return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function toHexString(allow3Char) {
      return "#" + this.toHex(allow3Char);
    },
    toHex8: function toHex8(allow4Char) {
      return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function toHex8String(allow4Char) {
      return "#" + this.toHex8(allow4Char);
    },
    toRgb: function toRgb() {
      return {
        r: Math.round(this._r),
        g: Math.round(this._g),
        b: Math.round(this._b),
        a: this._a
      };
    },
    toRgbString: function toRgbString() {
      return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function toPercentageRgb() {
      return {
        r: Math.round(bound01(this._r, 255) * 100) + "%",
        g: Math.round(bound01(this._g, 255) * 100) + "%",
        b: Math.round(bound01(this._b, 255) * 100) + "%",
        a: this._a
      };
    },
    toPercentageRgbString: function toPercentageRgbString() {
      return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function toName() {
      if (this._a === 0) {
        return "transparent";
      }
      if (this._a < 1) {
        return false;
      }
      return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function toFilter(secondColor) {
      var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
      var secondHex8String = hex8String;
      var gradientType = this._gradientType ? "GradientType = 1, " : "";
      if (secondColor) {
        var s = tinycolor(secondColor);
        secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
      }
      return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
    },
    toString: function toString2(format) {
      var formatSet = !!format;
      format = format || this._format;
      var formattedString = false;
      var hasAlpha = this._a < 1 && this._a >= 0;
      var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
      if (needsAlphaFormat) {
        if (format === "name" && this._a === 0) {
          return this.toName();
        }
        return this.toRgbString();
      }
      if (format === "rgb") {
        formattedString = this.toRgbString();
      }
      if (format === "prgb") {
        formattedString = this.toPercentageRgbString();
      }
      if (format === "hex" || format === "hex6") {
        formattedString = this.toHexString();
      }
      if (format === "hex3") {
        formattedString = this.toHexString(true);
      }
      if (format === "hex4") {
        formattedString = this.toHex8String(true);
      }
      if (format === "hex8") {
        formattedString = this.toHex8String();
      }
      if (format === "name") {
        formattedString = this.toName();
      }
      if (format === "hsl") {
        formattedString = this.toHslString();
      }
      if (format === "hsv") {
        formattedString = this.toHsvString();
      }
      return formattedString || this.toHexString();
    },
    clone: function clone() {
      return tinycolor(this.toString());
    },
    _applyModification: function _applyModification(fn2, args) {
      var color = fn2.apply(null, [this].concat([].slice.call(args)));
      this._r = color._r;
      this._g = color._g;
      this._b = color._b;
      this.setAlpha(color._a);
      return this;
    },
    lighten: function lighten() {
      return this._applyModification(_lighten, arguments);
    },
    brighten: function brighten() {
      return this._applyModification(_brighten, arguments);
    },
    darken: function darken() {
      return this._applyModification(_darken, arguments);
    },
    desaturate: function desaturate() {
      return this._applyModification(_desaturate, arguments);
    },
    saturate: function saturate() {
      return this._applyModification(_saturate, arguments);
    },
    greyscale: function greyscale() {
      return this._applyModification(_greyscale, arguments);
    },
    spin: function spin() {
      return this._applyModification(_spin, arguments);
    },
    _applyCombination: function _applyCombination(fn2, args) {
      return fn2.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function analogous() {
      return this._applyCombination(_analogous, arguments);
    },
    complement: function complement() {
      return this._applyCombination(_complement, arguments);
    },
    monochromatic: function monochromatic() {
      return this._applyCombination(_monochromatic, arguments);
    },
    splitcomplement: function splitcomplement() {
      return this._applyCombination(_splitcomplement, arguments);
    },
    // Disabled until https://github.com/bgrins/TinyColor/issues/254
    // polyad: function (number) {
    //   return this._applyCombination(polyad, [number]);
    // },
    triad: function triad() {
      return this._applyCombination(polyad, [3]);
    },
    tetrad: function tetrad() {
      return this._applyCombination(polyad, [4]);
    }
  };
  tinycolor.fromRatio = function (color, opts) {
    if (_typeof(color) == "object") {
      var newColor = {};
      for (var i in color) {
        if (color.hasOwnProperty(i)) {
          if (i === "a") {
            newColor[i] = color[i];
          } else {
            newColor[i] = convertToPercentage(color[i]);
          }
        }
      }
      color = newColor;
    }
    return tinycolor(color, opts);
  };
  function inputToRGB(color) {
    var rgb = {
      r: 0,
      g: 0,
      b: 0
    };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;
    if (typeof color == "string") {
      color = stringInputToObject(color);
    }
    if (_typeof(color) == "object") {
      if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
        rgb = rgbToRgb(color.r, color.g, color.b);
        ok = true;
        format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
        s = convertToPercentage(color.s);
        v = convertToPercentage(color.v);
        rgb = hsvToRgb(color.h, s, v);
        ok = true;
        format = "hsv";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
        s = convertToPercentage(color.s);
        l = convertToPercentage(color.l);
        rgb = hslToRgb(color.h, s, l);
        ok = true;
        format = "hsl";
      }
      if (color.hasOwnProperty("a")) {
        a = color.a;
      }
    }
    a = boundAlpha(a);
    return {
      ok,
      format: color.format || format,
      r: Math.min(255, Math.max(rgb.r, 0)),
      g: Math.min(255, Math.max(rgb.g, 0)),
      b: Math.min(255, Math.max(rgb.b, 0)),
      a
    };
  }
  function rgbToRgb(r, g, b) {
    return {
      r: bound01(r, 255) * 255,
      g: bound01(g, 255) * 255,
      b: bound01(b, 255) * 255
    };
  }
  function rgbToHsl(r, g, b) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    var max2 = Math.max(r, g, b), min2 = Math.min(r, g, b);
    var h2, s, l = (max2 + min2) / 2;
    if (max2 == min2) {
      h2 = s = 0;
    } else {
      var d = max2 - min2;
      s = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
      switch (max2) {
        case r:
          h2 = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h2 = (b - r) / d + 2;
          break;
        case b:
          h2 = (r - g) / d + 4;
          break;
      }
      h2 /= 6;
    }
    return {
      h: h2,
      s,
      l
    };
  }
  function hslToRgb(h2, s, l) {
    var r, g, b;
    h2 = bound01(h2, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);
    function hue2rgb(p3, q2, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p3 + (q2 - p3) * 6 * t;
      if (t < 1 / 2) return q2;
      if (t < 2 / 3) return p3 + (q2 - p3) * (2 / 3 - t) * 6;
      return p3;
    }
    if (s === 0) {
      r = g = b = l;
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p2 = 2 * l - q;
      r = hue2rgb(p2, q, h2 + 1 / 3);
      g = hue2rgb(p2, q, h2);
      b = hue2rgb(p2, q, h2 - 1 / 3);
    }
    return {
      r: r * 255,
      g: g * 255,
      b: b * 255
    };
  }
  function rgbToHsv(r, g, b) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    var max2 = Math.max(r, g, b), min2 = Math.min(r, g, b);
    var h2, s, v = max2;
    var d = max2 - min2;
    s = max2 === 0 ? 0 : d / max2;
    if (max2 == min2) {
      h2 = 0;
    } else {
      switch (max2) {
        case r:
          h2 = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h2 = (b - r) / d + 2;
          break;
        case b:
          h2 = (r - g) / d + 4;
          break;
      }
      h2 /= 6;
    }
    return {
      h: h2,
      s,
      v
    };
  }
  function hsvToRgb(h2, s, v) {
    h2 = bound01(h2, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);
    var i = Math.floor(h2), f = h2 - i, p2 = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [v, q, p2, p2, t, v][mod], g = [t, v, v, q, p2, p2][mod], b = [p2, p2, t, v, v, q][mod];
    return {
      r: r * 255,
      g: g * 255,
      b: b * 255
    };
  }
  function rgbToHex(r, g, b, allow3Char) {
    var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }
    return hex.join("");
  }
  function rgbaToHex(r, g, b, a, allow4Char) {
    var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];
    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }
    return hex.join("");
  }
  function rgbaToArgbHex(r, g, b, a) {
    var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
    return hex.join("");
  }
  tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) return false;
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
  };
  tinycolor.random = function () {
    return tinycolor.fromRatio({
      r: Math.random(),
      g: Math.random(),
      b: Math.random()
    });
  };
  function _desaturate(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
  }
  function _saturate(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
  }
  function _greyscale(color) {
    return tinycolor(color).desaturate(100);
  }
  function _lighten(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
  }
  function _brighten(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var rgb = tinycolor(color).toRgb();
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
    return tinycolor(rgb);
  }
  function _darken(color, amount) {
    amount = amount === 0 ? 0 : amount || 10;
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
  }
  function _spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
  }
  function _complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
  }
  function polyad(color, number) {
    if (isNaN(number) || number <= 0) {
      throw new Error("Argument to polyad must be a positive number");
    }
    var hsl = tinycolor(color).toHsl();
    var result = [tinycolor(color)];
    var step = 360 / number;
    for (var i = 1; i < number; i++) {
      result.push(tinycolor({
        h: (hsl.h + i * step) % 360,
        s: hsl.s,
        l: hsl.l
      }));
    }
    return result;
  }
  function _splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h2 = hsl.h;
    return [tinycolor(color), tinycolor({
      h: (h2 + 72) % 360,
      s: hsl.s,
      l: hsl.l
    }), tinycolor({
      h: (h2 + 216) % 360,
      s: hsl.s,
      l: hsl.l
    })];
  }
  function _analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;
    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];
    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {
      hsl.h = (hsl.h + part) % 360;
      ret.push(tinycolor(hsl));
    }
    return ret;
  }
  function _monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h2 = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;
    while (results--) {
      ret.push(tinycolor({
        h: h2,
        s,
        v
      }));
      v = (v + modification) % 1;
    }
    return ret;
  }
  tinycolor.mix = function (color1, color2, amount) {
    amount = amount === 0 ? 0 : amount || 50;
    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();
    var p2 = amount / 100;
    var rgba = {
      r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
      g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
      b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
      a: (rgb2.a - rgb1.a) * p2 + rgb1.a
    };
    return tinycolor(rgba);
  };
  tinycolor.readability = function (color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
  };
  tinycolor.isReadable = function (color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;
    out = false;
    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
      case "AAsmall":
      case "AAAlarge":
        out = readability >= 4.5;
        break;
      case "AAlarge":
        out = readability >= 3;
        break;
      case "AAAsmall":
        out = readability >= 7;
        break;
    }
    return out;
  };
  tinycolor.mostReadable = function (baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors;
    level = args.level;
    size = args.size;
    for (var i = 0; i < colorList.length; i++) {
      readability = tinycolor.readability(baseColor, colorList[i]);
      if (readability > bestScore) {
        bestScore = readability;
        bestColor = tinycolor(colorList[i]);
      }
    }
    if (tinycolor.isReadable(baseColor, bestColor, {
      level,
      size
    }) || !includeFallbackColors) {
      return bestColor;
    } else {
      args.includeFallbackColors = false;
      return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
    }
  };
  var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
  };
  var hexNames = tinycolor.hexNames = flip(names);
  function flip(o) {
    var flipped = {};
    for (var i in o) {
      if (o.hasOwnProperty(i)) {
        flipped[o[i]] = i;
      }
    }
    return flipped;
  }
  function boundAlpha(a) {
    a = parseFloat(a);
    if (isNaN(a) || a < 0 || a > 1) {
      a = 1;
    }
    return a;
  }
  function bound01(n, max2) {
    if (isOnePointZero(n)) n = "100%";
    var processPercent = isPercentage(n);
    n = Math.min(max2, Math.max(0, parseFloat(n)));
    if (processPercent) {
      n = parseInt(n * max2, 10) / 100;
    }
    if (Math.abs(n - max2) < 1e-6) {
      return 1;
    }
    return n % max2 / parseFloat(max2);
  }
  function clamp01(val) {
    return Math.min(1, Math.max(0, val));
  }
  function parseIntFromHex(val) {
    return parseInt(val, 16);
  }
  function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
  }
  function isPercentage(n) {
    return typeof n === "string" && n.indexOf("%") != -1;
  }
  function pad2(c) {
    return c.length == 1 ? "0" + c : "" + c;
  }
  function convertToPercentage(n) {
    if (n <= 1) {
      n = n * 100 + "%";
    }
    return n;
  }
  function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
  }
  function convertHexToDecimal(h2) {
    return parseIntFromHex(h2) / 255;
  }
  var matchers = function () {
    var CSS_INTEGER = "[-\\+]?\\d+%?";
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    return {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
      rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
      hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
      hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
      hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
      hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
  }();
  function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
  }
  function stringInputToObject(color) {
    color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
    var named = false;
    if (names[color]) {
      color = names[color];
      named = true;
    } else if (color == "transparent") {
      return {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        format: "name"
      };
    }
    var match;
    if (match = matchers.rgb.exec(color)) {
      return {
        r: match[1],
        g: match[2],
        b: match[3]
      };
    }
    if (match = matchers.rgba.exec(color)) {
      return {
        r: match[1],
        g: match[2],
        b: match[3],
        a: match[4]
      };
    }
    if (match = matchers.hsl.exec(color)) {
      return {
        h: match[1],
        s: match[2],
        l: match[3]
      };
    }
    if (match = matchers.hsla.exec(color)) {
      return {
        h: match[1],
        s: match[2],
        l: match[3],
        a: match[4]
      };
    }
    if (match = matchers.hsv.exec(color)) {
      return {
        h: match[1],
        s: match[2],
        v: match[3]
      };
    }
    if (match = matchers.hsva.exec(color)) {
      return {
        h: match[1],
        s: match[2],
        v: match[3],
        a: match[4]
      };
    }
    if (match = matchers.hex8.exec(color)) {
      return {
        r: parseIntFromHex(match[1]),
        g: parseIntFromHex(match[2]),
        b: parseIntFromHex(match[3]),
        a: convertHexToDecimal(match[4]),
        format: named ? "name" : "hex8"
      };
    }
    if (match = matchers.hex6.exec(color)) {
      return {
        r: parseIntFromHex(match[1]),
        g: parseIntFromHex(match[2]),
        b: parseIntFromHex(match[3]),
        format: named ? "name" : "hex"
      };
    }
    if (match = matchers.hex4.exec(color)) {
      return {
        r: parseIntFromHex(match[1] + "" + match[1]),
        g: parseIntFromHex(match[2] + "" + match[2]),
        b: parseIntFromHex(match[3] + "" + match[3]),
        a: convertHexToDecimal(match[4] + "" + match[4]),
        format: named ? "name" : "hex8"
      };
    }
    if (match = matchers.hex3.exec(color)) {
      return {
        r: parseIntFromHex(match[1] + "" + match[1]),
        g: parseIntFromHex(match[2] + "" + match[2]),
        b: parseIntFromHex(match[3] + "" + match[3]),
        format: named ? "name" : "hex"
      };
    }
    return false;
  }
  function validateWCAG2Parms(parms) {
    var level, size;
    parms = parms || {
      level: "AA",
      size: "small"
    };
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
      level = "AA";
    }
    if (size !== "small" && size !== "large") {
      size = "small";
    }
    return {
      level,
      size
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var props$9 = {
    closable: Boolean,
    color: {
      type: String,
      "default": ""
    },
    content: {
      type: [String, Function]
    },
    "default": {
      type: [String, Function]
    },
    disabled: Boolean,
    icon: {
      type: Function,
      "default": void 0
    },
    maxWidth: {
      type: [String, Number]
    },
    shape: {
      type: String,
      "default": "square",
      validator: function validator21(val) {
        if (!val) return true;
        return ["square", "round", "mark"].includes(val);
      }
    },
    size: {
      type: String,
      "default": "medium",
      validator: function validator22(val) {
        if (!val) return true;
        return ["small", "medium", "large"].includes(val);
      }
    },
    theme: {
      type: String,
      "default": "default",
      validator: function validator23(val) {
        if (!val) return true;
        return ["default", "primary", "warning", "danger", "success"].includes(val);
      }
    },
    title: {
      type: String,
      "default": ""
    },
    variant: {
      type: String,
      "default": "dark",
      validator: function validator24(val) {
        if (!val) return true;
        return ["dark", "light", "outline", "light-outline"].includes(val);
      }
    },
    onClick: Function,
    onClose: Function
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var _Tag = /* @__PURE__ */ defineComponent({
    name: "TTag",
    props: props$9,
    setup: function setup16(props2) {
      var _useConfig = useConfig("tag"), tagGlobalConfig = _useConfig.globalConfig;
      var COMPONENT_NAME = usePrefixClass("tag");
      var _useGlobalIcon = useGlobalIcon({
        CloseIcon: close
      }), CloseIcon$1 = _useGlobalIcon.CloseIcon;
      var renderTNodeJSX = useTNodeJSX();
      var renderContent = useContent();
      var _useCommonClassName = useCommonClassName$1(), SIZE = _useCommonClassName.SIZE;
      var _getCurrentInstance = getCurrentInstance(), vnode = _getCurrentInstance.vnode;
      var tagClass = computed(function () {
        return ["".concat(COMPONENT_NAME.value), "".concat(COMPONENT_NAME.value, "--").concat(props2.theme), "".concat(COMPONENT_NAME.value, "--").concat(props2.variant), _defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1({}, "".concat(COMPONENT_NAME.value, "--ellipsis"), props2.maxWidth), "".concat(COMPONENT_NAME.value, "--close"), props2.closable), "".concat(COMPONENT_NAME.value, "--disabled"), props2.disabled), SIZE.value[props2.size], props2.size !== "medium"), props2.shape !== "square" && "".concat(COMPONENT_NAME.value, "--").concat(props2.shape)];
      });
      var tagStyle = computed(function () {
        return getTagColorStyle();
      });
      var textStyle = computed(function () {
        if (!props2.maxWidth) return {};
        return {
          maxWidth: isNaN(Number(props2.maxWidth)) ? String(props2.maxWidth) : "".concat(props2.maxWidth, "px")
        };
      });
      var getTagColorStyle = function getTagColorStyle2() {
        var color = props2.color, variant = props2.variant;
        if (!color) return {};
        var luminance = tinycolor(color).getLuminance();
        var style = {
          color: luminance > 0.5 ? "black" : "white"
        };
        if (variant === "outline" || variant === "light-outline") {
          style.borderColor = color;
        }
        if (variant !== "outline") {
          var getLightestShade = function getLightestShade2() {
            var _tinycolor$toRgb = tinycolor(color).toRgb(), r = _tinycolor$toRgb.r, g = _tinycolor$toRgb.g, b = _tinycolor$toRgb.b;
            return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", 0.1)");
          };
          style.backgroundColor = variant === "dark" ? color : getLightestShade();
        }
        if (variant !== "dark") {
          style.color = color;
        }
        return style;
      };
      var handleClick = function handleClick2(e) {
        var _props2$onClick;
        if (props2.disabled) return;
        (_props2$onClick = props2.onClick) === null || _props2$onClick === void 0 || _props2$onClick.call(props2, {
          e
        });
      };
      var getCloseIcon = function getCloseIcon2() {
        if (!props2.closable) return null;
        var iconClassName = "".concat(COMPONENT_NAME.value, "__icon-close");
        if (tagGlobalConfig.value.closeIcon) {
          return h(tagGlobalConfig.value.closeIcon(h), {
            "class": iconClassName
          });
        }
        return createVNode(CloseIcon$1, {
          "onClick": function onClick(_ref2) {
            var _props2$onClose;
            var e = _ref2.e;
            if (e) e.stopPropagation();
            (_props2$onClose = props2.onClose) === null || _props2$onClose === void 0 || _props2$onClose.call(props2, {
              e
            });
          },
          "class": iconClassName
        }, null);
      };
      var renderTitle = function renderTitle2(tagContent) {
        if (!props2.maxWidth) {
          return void 0;
        }
        var vProps = vnode.props || {};
        if (Reflect.has(vProps, "title")) {
          return vProps.title || void 0;
        }
        if (tagContent) {
          return tagContent;
        }
        return void 0;
      };
      return function () {
        var closeIcon = getCloseIcon();
        var tagContent = renderContent("default", "content");
        var icon = renderTNodeJSX("icon");
        var title = renderTitle(isString(tagContent) ? tagContent : "");
        return createVNode("div", {
          "class": tagClass.value,
          "style": tagStyle.value,
          "onClick": handleClick
        }, [icon, createVNode("span", {
          "class": props2.maxWidth ? "".concat(COMPONENT_NAME.value, "--text") : void 0,
          "style": textStyle.value,
          "title": title
        }, [tagContent]), !props2.disabled && closeIcon]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var props$8 = {
    checked: {
      type: Boolean,
      "default": void 0
    },
    modelValue: {
      type: Boolean,
      "default": void 0
    },
    defaultChecked: Boolean,
    checkedProps: {
      type: Object
    },
    content: {
      type: [String, Number, Array, Function]
    },
    "default": {
      type: [String, Function]
    },
    disabled: Boolean,
    size: {
      type: String,
      "default": "medium",
      validator: function validator25(val) {
        if (!val) return true;
        return ["small", "medium", "large"].includes(val);
      }
    },
    uncheckedProps: {
      type: Object
    },
    value: {
      type: [String, Number]
    },
    onChange: Function,
    onClick: Function
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var SPACE_REG = /^Space$/i;
  var ENTER_REG = /^Enter$/i;
  var CHECKED_CODE_REG = /^(Enter|Space)$/i;
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function ownKeys$c(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$c(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$c(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function _isSlot$3(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
  }
  var _CheckTag = /* @__PURE__ */ defineComponent({
    name: "TCheckTag",
    props: props$8,
    setup: function setup17(props2) {
      var componentName = usePrefixClass("tag");
      var _useCommonClassName = useCommonClassName$1(), SIZE = _useCommonClassName.SIZE;
      var renderContent = useContent();
      var _toRefs = toRefs(props2), checked = _toRefs.checked, modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(checked, modelValue, props2.defaultChecked, props2.onChange, "checked"), _useVModel2 = _slicedToArray(_useVModel, 2), innerChecked = _useVModel2[0], setInnerChecked = _useVModel2[1];
      var tagClass = computed(function () {
        return ["".concat(componentName.value), "".concat(componentName.value, "--check"), SIZE.value[props2.size], _defineProperty$1(_defineProperty$1({}, "".concat(componentName.value, "--checked"), innerChecked.value), "".concat(componentName.value, "--disabled"), props2.disabled)];
      });
      var checkTagProps = computed(function () {
        var checkedProps = _objectSpread$c({
          theme: "primary"
        }, props2.checkedProps);
        var uncheckedProps = _objectSpread$c({}, props2.uncheckedProps);
        return innerChecked.value ? checkedProps : uncheckedProps;
      });
      var handleClick = function handleClick2(_ref2) {
        var e = _ref2.e;
        if (!props2.disabled) {
          var _props2$onClick;
          (_props2$onClick = props2.onClick) === null || _props2$onClick === void 0 || _props2$onClick.call(props2, {
            e
          });
          setInnerChecked(!innerChecked.value, {
            e,
            value: props2.value
          });
        }
      };
      var keyboardEventListener = function keyboardEventListener2(e) {
        var _e$key;
        var code = e.code || ((_e$key = e.key) === null || _e$key === void 0 ? void 0 : _e$key.trim());
        var isCheckedCode = SPACE_REG.test(code) || ENTER_REG.test(code);
        if (isCheckedCode) {
          e.preventDefault();
          setInnerChecked(!innerChecked.value, {
            e,
            value: props2.value
          });
        }
      };
      var onCheckboxFocus = function onCheckboxFocus2(e) {
        e.currentTarget.addEventListener("keydown", keyboardEventListener);
      };
      var onCheckboxBlur = function onCheckboxBlur2(e) {
        e.currentTarget.removeEventListener("keydown", keyboardEventListener);
      };
      return function () {
        var tagContent = renderContent("default", "content");
        return createVNode(_Tag, mergeProps({
          "class": tagClass.value,
          "disabled": props2.disabled,
          "tabindex": props2.disabled ? void 0 : "0",
          "onFocus": onCheckboxFocus,
          "onBlur": onCheckboxBlur
        }, checkTagProps.value, {
          "onClick": handleClick
        }), _isSlot$3(tagContent) ? tagContent : {
          "default": function _default5() {
            return [tagContent];
          }
        });
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var props$7 = {
    checkedProps: {
      type: Object
    },
    multiple: Boolean,
    options: {
      type: Array
    },
    uncheckedProps: {
      type: Object
    },
    value: {
      type: Array,
      "default": void 0
    },
    modelValue: {
      type: Array,
      "default": void 0
    },
    defaultValue: {
      type: Array,
      "default": function _default3() {
        return [];
      }
    },
    onChange: Function
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function _isSlot$2(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
  }
  var _CheckTagGroup = /* @__PURE__ */ defineComponent({
    name: "TCheckTagGroup",
    props: props$7,
    setup: function setup18(props2, context) {
      var _toRefs = toRefs(props2), value = _toRefs.value, modelValue = _toRefs.modelValue, options = _toRefs.options;
      var componentName = usePrefixClass("check-tag-group");
      var checkTagGroupClasses = computed(function () {
        return [componentName.value];
      });
      var _useVModel = useVModel(value, modelValue, props2.defaultValue, props2.onChange), _useVModel2 = _slicedToArray(_useVModel, 2), innerValue = _useVModel2[0], setInnerValue = _useVModel2[1];
      var onCheckTagChange = function onCheckTagChange2(checked, ctx) {
        var value2 = ctx.value;
        if (checked) {
          if (props2.multiple) {
            setInnerValue(innerValue.value.concat(value2), {
              e: ctx.e,
              type: "check",
              value: value2
            });
          } else {
            setInnerValue([value2], {
              e: ctx.e,
              type: "check",
              value: value2
            });
          }
        } else {
          var newValue = [];
          if (props2.multiple) {
            newValue = innerValue.value.filter(function (t) {
              return t !== value2;
            });
          }
          setInnerValue(newValue, {
            e: ctx.e,
            type: "uncheck",
            value: value2
          });
        }
      };
      var getTagContent = function getTagContent2(option) {
        if (context.slots.option) return context.slots.option(option);
        if (context.slots.label) return context.slots.label(option);
        if (option.label) {
          return isFunction(option.label) ? option.label(h) : option.label;
        }
        if (option.content && isFunction(option.content)) return option.content(h);
        if (option["default"] && isFunction(option["default"])) return option["default"](h);
        return option.value;
      };
      return function () {
        return createVNode("div", {
          "class": checkTagGroupClasses.value
        }, [(options.value || []).map(function (option) {
          var _slot;
          return createVNode(_CheckTag, {
            "key": option.value,
            "value": option.value,
            "checkedProps": props2.checkedProps,
            "uncheckedProps": props2.uncheckedProps,
            "checked": innerValue.value.includes(option.value),
            "onChange": onCheckTagChange,
            "disabled": option.disabled,
            "size": option.size,
            "data-value": option.value
          }, _isSlot$2(_slot = getTagContent(option)) ? _slot : {
            "default": function _default5() {
              return [_slot];
            }
          });
        })]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var Tag = withInstall(_Tag);
  withInstall(_CheckTag);
  withInstall(_CheckTagGroup);
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function ownKeys$b(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$b(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$b(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function useTagList(props2) {
    var renderTNode = useTNodeJSX();
    var classPrefix = usePrefixClass();
    var _toRefs = toRefs(props2), value = _toRefs.value, modelValue = _toRefs.modelValue, onRemove = _toRefs.onRemove, max2 = _toRefs.max, minCollapsedNum = _toRefs.minCollapsedNum, size = _toRefs.size, tagProps = _toRefs.tagProps, getDragProps = _toRefs.getDragProps;
    var _useVModel = useVModel(value, modelValue, props2.defaultValue || [], props2.onChange), _useVModel2 = _slicedToArray(_useVModel, 2), tagValue = _useVModel2[0], setTagValue = _useVModel2[1];
    var oldInputValue = ref();
    var isDisabled = useDisabled();
    var isReadonly2 = useReadonly();
    var _onClose = function onClose(p2) {
      var _onRemove$value;
      var arr = _toConsumableArray(tagValue.value);
      var _arr$splice = arr.splice(p2.index, 1), _arr$splice2 = _slicedToArray(_arr$splice, 1), item = _arr$splice2[0];
      setTagValue(arr, _objectSpread$b(_objectSpread$b({
        trigger: "tag-remove"
      }, p2), {}, {
        item
      }));
      (_onRemove$value = onRemove.value) === null || _onRemove$value === void 0 || _onRemove$value.call(onRemove, _objectSpread$b(_objectSpread$b({}, p2), {}, {
        item,
        trigger: "tag-remove",
        value: arr
      }));
    };
    var clearAll = function clearAll2(context) {
      setTagValue([], {
        trigger: "clear",
        e: context.e
      });
    };
    var onInnerEnter = function onInnerEnter2(value2, context) {
      var _tagValue$value, _props$onEnter;
      var valueStr = value2 ? String(value2).trim() : "";
      var isLimitExceeded = max2 && ((_tagValue$value = tagValue.value) === null || _tagValue$value === void 0 ? void 0 : _tagValue$value.length) >= max2.value;
      var newValue = tagValue.value;
      if (!isLimitExceeded && valueStr) {
        newValue = tagValue.value instanceof Array ? tagValue.value.concat(String(valueStr)) : [valueStr];
        setTagValue(newValue, {
          trigger: "enter",
          index: newValue.length - 1,
          item: valueStr,
          e: context.e
        });
      }
      props2 === null || props2 === void 0 || (_props$onEnter = props2.onEnter) === null || _props$onEnter === void 0 || _props$onEnter.call(props2, newValue, _objectSpread$b(_objectSpread$b({}, context), {}, {
        inputValue: value2
      }));
    };
    var onInputBackspaceKeyUp = function onInputBackspaceKeyUp2(value2) {
      if (!tagValue.value || !tagValue.value.length) return;
      oldInputValue.value = value2;
    };
    var onInputBackspaceKeyDown = function onInputBackspaceKeyDown2(value2, context) {
      var e = context.e;
      if (!tagValue.value || !tagValue.value.length || e.key === "Process" || isReadonly2.value) return;
      var isDelete = /(Backspace|NumpadDelete)/i.test(e.code) || /(Backspace|NumpadDelete)/i.test(e.key);
      if (!value2 && isDelete) {
        var _onRemove$value2;
        var index = tagValue.value.length - 1;
        var item = tagValue.value[index];
        var trigger2 = "backspace";
        var newValue = tagValue.value.slice(0, -1);
        setTagValue(newValue, {
          e,
          index,
          item,
          trigger: trigger2
        });
        (_onRemove$value2 = onRemove.value) === null || _onRemove$value2 === void 0 || _onRemove$value2.call(onRemove, {
          e,
          index,
          item,
          trigger: trigger2,
          value: newValue
        });
      }
      oldInputValue.value = value2;
    };
    var renderLabel = function renderLabel2(_ref) {
      var _newList$map;
      var displayNode = _ref.displayNode, label = _ref.label;
      var newList = minCollapsedNum.value ? tagValue.value.slice(0, minCollapsedNum.value) : tagValue.value;
      var list = displayNode ? [displayNode] : (newList === null || newList === void 0 || (_newList$map = newList.map) === null || _newList$map === void 0 ? void 0 : _newList$map.call(newList, function (item, index) {
        var _getDragProps$value;
        var tagContent = renderTNode("tag", {
          params: {
            value: item
          }
        });
        return createVNode(Tag, mergeProps({
          "key": "".concat(item).concat(index),
          "size": size.value,
          "disabled": isDisabled.value,
          "onClose": function onClose(context) {
            return _onClose({
              e: context.e,
              index
            });
          },
          "closable": !isReadonly2.value && !isDisabled.value
        }, (_getDragProps$value = getDragProps.value) === null || _getDragProps$value === void 0 ? void 0 : _getDragProps$value.call(getDragProps, index, item), tagProps.value), {
          "default": function _default5() {
            return [tagContent !== null && tagContent !== void 0 ? tagContent : item];
          }
        });
      })) || [];
      if (![null, void 0, ""].includes(label)) {
        list.unshift(createVNode("div", {
          "class": "".concat(classPrefix.value, "-tag-input__prefix"),
          "key": "label"
        }, [label]));
      }
      if (newList.length !== (tagValue.value || []).length) {
        var len = tagValue.value.length - newList.length;
        var more = renderTNode("collapsedItems", {
          params: {
            value: tagValue.value,
            count: tagValue.value.length - minCollapsedNum.value,
            collapsedTags: tagValue.value.slice(minCollapsedNum.value, tagValue.value.length),
            collapsedSelectedItems: tagValue.value.slice(minCollapsedNum.value, tagValue.value.length),
            onClose: _onClose
          }
        });
        list.push(more !== null && more !== void 0 ? more : createVNode(Tag, mergeProps({
          "key": "more",
          "size": size.value
        }, tagProps.value), {
          "default": function _default5() {
            return ["+", len];
          }
        }));
      }
      return list;
    };
    return {
      tagValue,
      clearAll,
      onClose: _onClose,
      onInnerEnter,
      onInputBackspaceKeyUp,
      onInputBackspaceKeyDown,
      renderLabel
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function ownKeys$a(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$a(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$a(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var useComponentClassName$1 = function useComponentClassName2() {
    return {
      NAME_CLASS: usePrefixClass("tag-input"),
      CLEAR_CLASS: usePrefixClass("tag-input__suffix-clear"),
      BREAK_LINE_CLASS: usePrefixClass("tag-input--break-line")
    };
  };
  var _TagInput = /* @__PURE__ */ defineComponent({
    name: "TTagInput",
    props: props$a,
    setup: function setup19(props2, _ref) {
      var slots = _ref.slots;
      var renderTNodeJSX = useTNodeJSX();
      var _useComponentClassNam = useComponentClassName$1(), NAME_CLASS = _useComponentClassNam.NAME_CLASS, CLEAR_CLASS = _useComponentClassNam.CLEAR_CLASS, BREAK_LINE_CLASS = _useComponentClassNam.BREAK_LINE_CLASS;
      var _useGlobalIcon = useGlobalIcon({
        CloseCircleFilledIcon: closeCircleFilled
      }), CloseCircleFilledIcon$1 = _useGlobalIcon.CloseCircleFilledIcon;
      var isDisabled = useDisabled();
      var isReadonly2 = useReadonly();
      var _toRefs = toRefs(props2), inputValue = _toRefs.inputValue, inputProps = _toRefs.inputProps, borderless = _toRefs.borderless, size = _toRefs.size, tips = _toRefs.tips, status = _toRefs.status, suffix2 = _toRefs.suffix, autoWidth = _toRefs.autoWidth, onPaste = _toRefs.onPaste;
      var _useDefault = useDefaultValue(inputValue, props2.defaultInputValue, props2.onInputChange, "inputValue"), _useDefault2 = _slicedToArray(_useDefault, 2), tInputValue = _useDefault2[0], setTInputValue = _useDefault2[1];
      var _toRefs2 = toRefs(props2), excessTagsDisplayType = _toRefs2.excessTagsDisplayType, clearable = _toRefs2.clearable, placeholder = _toRefs2.placeholder;
      var _useHover = useHover({
        readonly: isReadonly2.value,
        disabled: isDisabled.value,
        onMouseenter: props2.onMouseenter,
        onMouseleave: props2.onMouseleave
      }), isHover = _useHover.isHover, addHover = _useHover.addHover, cancelHover = _useHover.cancelHover;
      var isComposition = ref(false);
      var _useConfig = useConfig(), classPrefix = _useConfig.classPrefix;
      var isFocused = ref(false);
      var _useDragSorter = useDragSorter(_objectSpread$a(_objectSpread$a({}, props2), {}, {
        sortOnDraggable: props2.dragSort,
        onDragOverCheck: {
          x: true,
          targetClassNameRegExp: new RegExp("^".concat(classPrefix.value, "-tag"))
        }
      })), getDragProps = _useDragSorter.getDragProps;
      var _useTagScroll = useTagScroll(props2), scrollToRight = _useTagScroll.scrollToRight, onWheel = _useTagScroll.onWheel, scrollToRightOnEnter = _useTagScroll.scrollToRightOnEnter, scrollToLeftOnLeave = _useTagScroll.scrollToLeftOnLeave, tagInputRef = _useTagScroll.tagInputRef, isScrollable = _useTagScroll.isScrollable;
      var _useTagList = useTagList(reactive(_objectSpread$a(_objectSpread$a({}, toRefs(props2)), {}, {
        getDragProps
      }))), tagValue = _useTagList.tagValue, onInnerEnter = _useTagList.onInnerEnter, onInputBackspaceKeyUp = _useTagList.onInputBackspaceKeyUp, onInputBackspaceKeyDown = _useTagList.onInputBackspaceKeyDown, clearAll = _useTagList.clearAll, renderLabel = _useTagList.renderLabel, _onClose = _useTagList.onClose;
      var classes = computed(function () {
        var isEmpty = !(isArray(tagValue.value) && tagValue.value.length);
        return [NAME_CLASS.value, _defineProperty$1(_defineProperty$1(_defineProperty$1({}, BREAK_LINE_CLASS.value, excessTagsDisplayType.value === "break-line"), "".concat(classPrefix.value, "-is-empty"), isEmpty), "".concat(classPrefix.value, "-tag-input--with-tag"), !isEmpty)];
      });
      var tagInputPlaceholder = computed(function () {
        var _tagValue$value;
        return !((_tagValue$value = tagValue.value) !== null && _tagValue$value !== void 0 && _tagValue$value.length) ? placeholder.value : "";
      });
      var showClearIcon = computed(function () {
        var _tagValue$value2;
        return Boolean(!isReadonly2.value && !isDisabled.value && clearable.value && isHover.value && (((_tagValue$value2 = tagValue.value) === null || _tagValue$value2 === void 0 ? void 0 : _tagValue$value2.length) || tInputValue.value));
      });
      var onInputEnter = function onInputEnter2(value, context) {
        var _context$e, _context$e$preventDef;
        (_context$e = context.e) === null || _context$e === void 0 || (_context$e$preventDef = _context$e.preventDefault) === null || _context$e$preventDef === void 0 || _context$e$preventDef.call(_context$e);
        setTInputValue("", {
          e: context.e,
          trigger: "enter"
        });
        !isComposition.value && onInnerEnter(value, context);
        nextTick(function () {
          scrollToRight();
          isComposition.value = false;
        });
      };
      var onInputCompositionstart = function onInputCompositionstart2(value, context) {
        var _inputProps$value, _inputProps$value$onC;
        isComposition.value = true;
        (_inputProps$value = inputProps.value) === null || _inputProps$value === void 0 || (_inputProps$value$onC = _inputProps$value.onCompositionstart) === null || _inputProps$value$onC === void 0 || _inputProps$value$onC.call(_inputProps$value, value, context);
      };
      var onInputCompositionend = function onInputCompositionend2(value, context) {
        var _inputProps$value2, _inputProps$value2$on;
        isComposition.value = false;
        (_inputProps$value2 = inputProps.value) === null || _inputProps$value2 === void 0 || (_inputProps$value2$on = _inputProps$value2.onCompositionend) === null || _inputProps$value2$on === void 0 || _inputProps$value2$on.call(_inputProps$value2, value, context);
      };
      var onClick = function onClick2(ctx) {
        var _tagInputRef$value, _props2$onClick;
        if (isDisabled.value) return;
        isFocused.value = true;
        (_tagInputRef$value = tagInputRef.value) === null || _tagInputRef$value === void 0 || _tagInputRef$value.focus();
        (_props2$onClick = props2.onClick) === null || _props2$onClick === void 0 || _props2$onClick.call(props2, ctx);
      };
      var onClearClick = function onClearClick2(context) {
        var _props2$onClear;
        clearAll(context);
        setTInputValue("", {
          e: context.e,
          trigger: "clear"
        });
        (_props2$onClear = props2.onClear) === null || _props2$onClear === void 0 || _props2$onClear.call(props2, context);
      };
      var onMouseEnter = function onMouseEnter2(context) {
        addHover(context);
        scrollToRightOnEnter();
      };
      var onMouseLeave = function onMouseLeave2(context) {
        cancelHover(context);
        scrollToLeftOnLeave();
      };
      var onInnerFocus = function onInnerFocus2(inputValue2, context) {
        var _props2$onFocus;
        if (isFocused.value) return;
        isFocused.value = true;
        (_props2$onFocus = props2.onFocus) === null || _props2$onFocus === void 0 || _props2$onFocus.call(props2, tagValue.value, {
          e: context.e,
          inputValue: inputValue2
        });
      };
      var onInnerBlur = function onInnerBlur2(inputValue2, context) {
        var _props2$onBlur;
        isFocused.value = false;
        setTInputValue("", {
          e: context.e,
          trigger: "blur"
        });
        (_props2$onBlur = props2.onBlur) === null || _props2$onBlur === void 0 || _props2$onBlur.call(props2, tagValue.value, {
          e: context.e,
          inputValue: inputValue2
        });
      };
      var onInnerChange = function onInnerChange2(val, context) {
        setTInputValue(val, _objectSpread$a(_objectSpread$a({}, context), {}, {
          trigger: "input"
        }));
      };
      watch(function () {
        return isScrollable.value;
      }, function (v) {
        if (props2.excessTagsDisplayType !== "scroll") return;
        var scrollElementClass = "".concat(classPrefix.value, "-input__prefix");
        var scrollElement = tagInputRef.value.$el.querySelector(".".concat(scrollElementClass));
        if (v) scrollElement.classList.add("".concat(scrollElementClass, "--scrollable"));
        else scrollElement.classList.remove("".concat(scrollElementClass, "--scrollable"));
      });
      return function () {
        var _inputProps$value3, _tagValue$value3;
        var suffixIconNode = showClearIcon.value ? createVNode(CloseCircleFilledIcon$1, {
          "class": CLEAR_CLASS.value,
          "onClick": onClearClick
        }, null) : renderTNodeJSX("suffixIcon");
        var prefixIconNode = renderTNodeJSX("prefixIcon");
        var suffixClass = "".concat(classPrefix.value, "-tag-input__with-suffix-icon");
        if (suffixIconNode && !classes.value.includes(suffixClass)) {
          classes.value.push(suffixClass);
        }
        var displayNode = renderTNodeJSX("valueDisplay", {
          params: {
            value: tagValue.value,
            onClose: function onClose(index) {
              return _onClose({
                index
              });
            }
          }
        });
        var _label = renderTNodeJSX("label", {
          silent: true
        });
        var readonly2 = isReadonly2.value || ((_inputProps$value3 = inputProps.value) === null || _inputProps$value3 === void 0 ? void 0 : _inputProps$value3.readonly);
        return createVNode(Input, mergeProps({
          "ref": tagInputRef,
          "borderless": borderless.value,
          "readonly": readonly2,
          "showInput": !readonly2 || !tagValue.value || !((_tagValue$value3 = tagValue.value) !== null && _tagValue$value3 !== void 0 && _tagValue$value3.length),
          "value": tInputValue.value,
          "autoWidth": true,
          "size": size.value,
          "disabled": isDisabled.value,
          "label": function label() {
            return renderLabel({
              displayNode,
              label: _label
            });
          },
          "class": classes.value,
          "tips": tips.value,
          "status": status.value,
          "placeholder": tagInputPlaceholder.value,
          "suffix": suffix2.value,
          "suffixIcon": function suffixIcon() {
            return suffixIconNode;
          },
          "prefixIcon": function prefixIcon() {
            return prefixIconNode;
          },
          "keepWrapperWidth": !autoWidth.value,
          "onWheel": onWheel,
          "onChange": onInnerChange,
          "onPaste": onPaste.value,
          "onEnter": onInputEnter,
          "onKeyup": onInputBackspaceKeyUp,
          "onKeydown": onInputBackspaceKeyDown,
          "onMouseenter": onMouseEnter,
          "onMouseleave": onMouseLeave,
          "onFocus": onInnerFocus,
          "onBlur": onInnerBlur,
          "onClick": onClick,
          "onCompositionstart": onInputCompositionstart,
          "onCompositionend": onInputCompositionend
        }, inputProps.value), {
          suffix: slots.suffix
        });
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var TagInput = withInstall(_TagInput);
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var _excluded$3 = ["tips"];
  function ownKeys$9(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$9(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$9(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var DEFAULT_KEYS$1 = {
    label: "label",
    key: "key",
    children: "children"
  };
  function useMultiple(props2, context, popupRef) {
    var _toRefs = toRefs(props2), inputValue = _toRefs.inputValue;
    var classPrefix = usePrefixClass();
    var tagInputRef = ref();
    var isMultipleFocus = ref(props2.autofocus);
    var _useDefault = useDefaultValue(inputValue, props2.defaultInputValue, props2.onInputChange, "inputValue"), _useDefault2 = _slicedToArray(_useDefault, 2), tInputValue = _useDefault2[0], setTInputValue = _useDefault2[1];
    var disable = useDisabled();
    var isReadonly2 = useReadonly();
    var iKeys = computed(function () {
      return _objectSpread$9(_objectSpread$9({}, DEFAULT_KEYS$1), props2.keys);
    });
    var tags = computed(function () {
      if (!(props2.value instanceof Array)) {
        return isObject(props2.value) ? [props2.value[iKeys.value.label]] : [props2.value];
      }
      return props2.value.map(function (item) {
        return isObject(item) ? item[iKeys.value.label] : item;
      });
    });
    var tPlaceholder = computed(function () {
      return !tags.value || !tags.value.length ? props2.placeholder : "";
    });
    var onTagInputChange = function onTagInputChange2(val, context2) {
      var _props$onTagChange;
      if (context2.trigger === "tag-remove") {
        var _context2$e;
        (_context2$e = context2.e) === null || _context2$e === void 0 || _context2$e.stopPropagation();
      }
      (_props$onTagChange = props2.onTagChange) === null || _props$onTagChange === void 0 || _props$onTagChange.call(props2, val, context2);
    };
    var onInputChange = function onInputChange2(val, ctx) {
      if (ctx.trigger === "enter" || ctx.trigger === "blur") return;
      setTInputValue(val, {
        trigger: ctx.trigger,
        e: ctx.e
      });
    };
    var onBlur = function onBlur2(val, ctx) {
      var _popupRef$value, _props$onBlur;
      var overlayState = (_popupRef$value = popupRef.value) === null || _popupRef$value === void 0 ? void 0 : _popupRef$value.getOverlayState();
      if (overlayState !== null && overlayState !== void 0 && overlayState.hover) return;
      isMultipleFocus.value = false;
      (_props$onBlur = props2.onBlur) === null || _props$onBlur === void 0 || _props$onBlur.call(props2, props2.value, _objectSpread$9(_objectSpread$9({}, ctx), {}, {
        tagInputValue: val
      }));
    };
    var onFocus = function onFocus2(val, ctx) {
      var _popupRef$value2, _props$onFocus;
      var overlayState = (_popupRef$value2 = popupRef.value) === null || _popupRef$value2 === void 0 ? void 0 : _popupRef$value2.getOverlayState();
      if (isMultipleFocus.value || overlayState !== null && overlayState !== void 0 && overlayState.hover) return;
      isMultipleFocus.value = true;
      var params = _objectSpread$9(_objectSpread$9({}, ctx), {}, {
        tagInputValue: val
      });
      (_props$onFocus = props2.onFocus) === null || _props$onFocus === void 0 || _props$onFocus.call(props2, props2.value, params);
    };
    var onEnter = function onEnter2(val, ctx) {
      var _props$onEnter;
      var params = _objectSpread$9(_objectSpread$9({}, ctx), {}, {
        tagInputValue: val
      });
      (_props$onEnter = props2.onEnter) === null || _props$onEnter === void 0 || _props$onEnter.call(props2, props2.value, params);
    };
    var renderSelectMultiple = function renderSelectMultiple2(p2) {
      var tagInputProps = _objectSpread$9(_objectSpread$9({}, p2.commonInputProps), {}, {
        tagProps: props2.tagProps,
        label: props2.label,
        autoWidth: props2.autoWidth,
        readonly: isReadonly2.value,
        placeholder: tPlaceholder.value,
        minCollapsedNum: props2.minCollapsedNum,
        collapsedItems: props2.collapsedItems,
        tag: props2.tag,
        value: tags.value,
        valueDisplay: props2.valueDisplay,
        inputValue: p2.popupVisible && p2.allowInput ? tInputValue.value : "",
        inputProps: _objectSpread$9({
          readonly: !props2.allowInput || isReadonly2.value,
          inputClass: _defineProperty$1({}, "".concat(classPrefix.value, "-input--focused"), p2.popupVisible)
        }, props2.inputProps),
        suffixIcon: !disable.value && props2.loading ? function () {
          return createVNode(Loading, {
            "loading": true,
            "size": "small"
          }, null);
        } : props2.suffixIcon
      }, props2.tagInputProps);
      var _context$slots = context.slots;
      _context$slots.tips;
      var slots = _objectWithoutProperties(_context$slots, _excluded$3);
      return createVNode(TagInput, mergeProps({
        "ref": tagInputRef
      }, tagInputProps, {
        "onInputChange": onInputChange,
        "onChange": onTagInputChange,
        "onClear": p2.onInnerClear,
        "onBlur": onBlur,
        "onEnter": onEnter,
        "onFocus": onFocus
      }), slots);
    };
    return {
      tags,
      tPlaceholder,
      tagInputRef,
      isMultipleFocus,
      multipleInputValue: tInputValue,
      renderSelectMultiple
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function ownKeys$8(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$8(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$8(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var MAX_POPUP_WIDTH = 1e3;
  var RESERVE_WIDTH = 0;
  function useOverlayInnerStyle(props2) {
    var _toRefs = toRefs(props2), popupProps2 = _toRefs.popupProps, autoWidth = _toRefs.autoWidth;
    var innerPopupVisible = ref(false);
    var disable = useDisabled();
    var isReadonly2 = useReadonly();
    var matchWidthFunc = function matchWidthFunc2(triggerElement, popupElement) {
      var SCROLLBAR_WIDTH = popupElement.scrollHeight > popupElement.offsetHeight ? RESERVE_WIDTH : 0;
      var width = popupElement.offsetWidth + SCROLLBAR_WIDTH >= triggerElement.offsetWidth ? popupElement.offsetWidth : triggerElement.offsetWidth;
      var otherOverlayInnerStyle = {};
      if (popupProps2.value && _typeof$2(popupProps2.value.overlayInnerStyle) === "object" && !popupProps2.value.overlayInnerStyle.width) {
        otherOverlayInnerStyle = popupProps2.value.overlayInnerStyle;
      }
      return _objectSpread$8({
        width: "".concat(Math.min(width, MAX_POPUP_WIDTH), "px")
      }, otherOverlayInnerStyle);
    };
    var onInnerPopupVisibleChange = function onInnerPopupVisibleChange2(visible, ctx) {
      if (disable.value || isReadonly2.value) return;
      var newVisible = ctx.trigger === "trigger-element-click" && props2.allowInput ? true : visible;
      if (props2.popupVisible !== newVisible) {
        var _props$onPopupVisible;
        innerPopupVisible.value = newVisible;
        (_props$onPopupVisible = props2.onPopupVisibleChange) === null || _props$onPopupVisible === void 0 || _props$onPopupVisible.call(props2, newVisible, ctx);
      }
    };
    var getAutoWidthPopupStyleWidth = function getAutoWidthPopupStyleWidth2(triggerElement, popupElement) {
      var _popupProps$value;
      return _objectSpread$8({
        width: "".concat(Math.max(triggerElement.offsetWidth, popupElement.offsetWidth), "px")
      }, (_popupProps$value = popupProps2.value) === null || _popupProps$value === void 0 ? void 0 : _popupProps$value.overlayInnerStyle);
    };
    var tOverlayInnerStyle = computed(function () {
      var _popupProps$value2;
      var result = {};
      var overlayInnerStyle = ((_popupProps$value2 = popupProps2.value) === null || _popupProps$value2 === void 0 ? void 0 : _popupProps$value2.overlayInnerStyle) || {};
      if (isFunction(overlayInnerStyle) || isObject(overlayInnerStyle) && overlayInnerStyle.width) {
        result = overlayInnerStyle;
      } else {
        if (autoWidth.value) {
          result = getAutoWidthPopupStyleWidth;
        } else {
          result = matchWidthFunc;
        }
      }
      return result;
    });
    return {
      tOverlayInnerStyle,
      innerPopupVisible,
      onInnerPopupVisibleChange
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var _excluded$2 = ["tips"];
  function ownKeys$7(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$7(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$7(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var COMMON_PROPERTIES = ["status", "clearable", "disabled", "label", "placeholder", "readonly", "prefixIcon", "suffix", "suffixIcon", "onPaste", "onMouseenter", "onMouseleave", "size", "autofocus"];
  var DEFAULT_KEYS = {
    label: "label",
    value: "value",
    children: "children"
  };
  function getInputValue(value, keys2) {
    var iKeys = _objectSpread$7(_objectSpread$7({}, DEFAULT_KEYS), keys2);
    return isObject(value) ? value[iKeys.label] : value;
  }
  function useSingle(props2, context, popupRef) {
    var _props$defaultInputVa;
    var _toRefs = toRefs(props2), value = _toRefs.value, keys2 = _toRefs.keys, propsInputValue = _toRefs.inputValue;
    var classPrefix = usePrefixClass();
    var isSingleFocus = ref(props2.autofocus);
    var inputRef = ref();
    var _useDefaultValue = useDefaultValue(propsInputValue, (_props$defaultInputVa = props2.defaultInputValue) !== null && _props$defaultInputVa !== void 0 ? _props$defaultInputVa : "", props2.onInputChange, "inputValue"), _useDefaultValue2 = _slicedToArray(_useDefaultValue, 2), inputValue = _useDefaultValue2[0], setInputValue = _useDefaultValue2[1];
    var renderTNode = useTNodeJSX();
    var disable = useDisabled();
    var isReadonly2 = useReadonly();
    var commonInputProps = computed(function () {
      return _objectSpread$7(_objectSpread$7({}, pick(props2, COMMON_PROPERTIES)), {}, {
        disabled: disable.value,
        readonly: isReadonly2.value
      });
    });
    var onInnerClear = function onInnerClear2(context2) {
      var _context2$e, _props$onClear;
      context2 === null || context2 === void 0 || (_context2$e = context2.e) === null || _context2$e === void 0 || _context2$e.stopPropagation();
      (_props$onClear = props2.onClear) === null || _props$onClear === void 0 || _props$onClear.call(props2, context2);
      setInputValue("", {
        trigger: "clear"
      });
    };
    var onInnerInputChange = function onInnerInputChange2(value2, context2) {
      if (props2.allowInput) {
        setInputValue(value2, _objectSpread$7(_objectSpread$7({}, context2), {}, {
          trigger: context2.trigger || "input"
        }));
      }
    };
    var renderSelectSingle = function renderSelectSingle2(popupVisible) {
      var _context$attrs;
      var singleValueDisplay = renderTNode("valueDisplay");
      var displayedValue = popupVisible && props2.allowInput ? inputValue.value : getInputValue(value.value, keys2.value);
      var prefixContent = renderPrefixContent(singleValueDisplay, popupVisible);
      var inputProps = _objectSpread$7(_objectSpread$7({}, commonInputProps.value), {}, {
        value: renderInputDisplay(singleValueDisplay, displayedValue, popupVisible),
        label: prefixContent.length ? function () {
          return prefixContent;
        } : void 0,
        autoWidth: props2.autoWidth,
        readonly: !props2.allowInput || isReadonly2.value,
        placeholder: renderPlaceholder(singleValueDisplay),
        suffixIcon: !disable.value && props2.loading ? function () {
          return createVNode(Loading, {
            "loading": true,
            "size": "small"
          }, null);
        } : props2.suffixIcon,
        showClearIconOnEmpty: Boolean(props2.clearable && (inputValue.value || displayedValue) && !disable.value && !isReadonly2.value)
      }, props2.inputProps);
      var _context$slots = context.slots;
      _context$slots.tips;
      var slots = _objectWithoutProperties(_context$slots, _excluded$2);
      var inputClassProps = popupVisible ? ["".concat(classPrefix.value, "-input--focused"), "".concat(classPrefix.value, "-is-focused"), inputProps === null || inputProps === void 0 ? void 0 : inputProps.inputClass] : inputProps === null || inputProps === void 0 ? void 0 : inputProps.inputClass;
      var onEnter = function onEnter2(val, context2) {
        var _props$onEnter;
        (_props$onEnter = props2.onEnter) === null || _props$onEnter === void 0 || _props$onEnter.call(props2, value.value, _objectSpread$7(_objectSpread$7({}, context2), {}, {
          inputValue: val
        }));
      };
      var onFocus = function onFocus2(val, context2) {
        var _popupRef$value, _props$onFocus;
        var overlayState = (_popupRef$value = popupRef.value) === null || _popupRef$value === void 0 ? void 0 : _popupRef$value.getOverlayState();
        if (isSingleFocus.value || overlayState !== null && overlayState !== void 0 && overlayState.hover) return;
        isSingleFocus.value = true;
        (_props$onFocus = props2.onFocus) === null || _props$onFocus === void 0 || _props$onFocus.call(props2, value.value, _objectSpread$7(_objectSpread$7({}, context2), {}, {
          inputValue: val
        }));
      };
      var onBlur = function onBlur2(val, context2) {
        var _popupRef$value2, _props$onBlur;
        var overlayState = (_popupRef$value2 = popupRef.value) === null || _popupRef$value2 === void 0 ? void 0 : _popupRef$value2.getOverlayState();
        isSingleFocus.value = false;
        if (overlayState !== null && overlayState !== void 0 && overlayState.hover) return;
        (_props$onBlur = props2.onBlur) === null || _props$onBlur === void 0 || _props$onBlur.call(props2, value.value, _objectSpread$7(_objectSpread$7({}, context2), {}, {
          inputValue: val
        }));
      };
      return createVNode(Input, mergeProps({
        "ref": inputRef,
        "style": (_context$attrs = context.attrs) === null || _context$attrs === void 0 ? void 0 : _context$attrs.style
      }, _objectSpread$7({
        onChange: onInnerInputChange,
        onClear: onInnerClear,
        onEnter,
        onFocus,
        onBlur
      }, inputProps), {
        "inputClass": inputClassProps
      }), slots);
    };
    var renderPrefixContent = function renderPrefixContent2(singleValueDisplay, popupVisible) {
      var label = renderTNode("label");
      if (!label && !singleValueDisplay) {
        return [];
      }
      if (singleValueDisplay) {
        var _props$valueDisplayOp, _props$valueDisplayOp2;
        if ((_props$valueDisplayOp = props2.valueDisplayOptions) !== null && _props$valueDisplayOp !== void 0 && _props$valueDisplayOp.usePlaceholder && !value.value || (_props$valueDisplayOp2 = props2.valueDisplayOptions) !== null && _props$valueDisplayOp2 !== void 0 && _props$valueDisplayOp2.useInputDisplay && popupVisible) {
          return [label];
        }
      }
      return [label, singleValueDisplay];
    };
    var renderInputDisplay = function renderInputDisplay2(singleValueDisplay, displayedValue, popupVisible) {
      if (singleValueDisplay) {
        var _props$valueDisplayOp3, _props$valueDisplayOp4;
        if (!((_props$valueDisplayOp3 = props2.valueDisplayOptions) !== null && _props$valueDisplayOp3 !== void 0 && _props$valueDisplayOp3.useInputDisplay) || (_props$valueDisplayOp4 = props2.valueDisplayOptions) !== null && _props$valueDisplayOp4 !== void 0 && _props$valueDisplayOp4.useInputDisplay && !popupVisible) {
          return void 0;
        }
      }
      return displayedValue;
    };
    var renderPlaceholder = function renderPlaceholder2(singleValueDisplay) {
      if (singleValueDisplay) {
        var _props$valueDisplayOp5, _props$valueDisplayOp6;
        if (!((_props$valueDisplayOp5 = props2.valueDisplayOptions) !== null && _props$valueDisplayOp5 !== void 0 && _props$valueDisplayOp5.usePlaceholder) || (_props$valueDisplayOp6 = props2.valueDisplayOptions) !== null && _props$valueDisplayOp6 !== void 0 && _props$valueDisplayOp6.usePlaceholder && value.value) {
          return "";
        }
      }
      return props2.placeholder;
    };
    return {
      inputRef,
      isSingleFocus,
      commonInputProps,
      singleInputValue: inputValue,
      onInnerClear,
      renderSelectSingle
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function ownKeys$6(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$6(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$6(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var useComponentClassName3 = function useComponentClassName4() {
    return {
      NAME_CLASS: usePrefixClass("select-input"),
      BASE_CLASS_BORDERLESS: usePrefixClass("select-input--borderless"),
      BASE_CLASS_MULTIPLE: usePrefixClass("select-input--multiple"),
      BASE_CLASS_POPUP_VISIBLE: usePrefixClass("select-input--popup-visible"),
      BASE_CLASS_EMPTY: usePrefixClass("select-input--empty")
    };
  };
  var _SelectInput = /* @__PURE__ */ defineComponent({
    name: "TSelectInput",
    props: _objectSpread$6(_objectSpread$6({}, props$b), {}, {
      valueDisplayOptions: {
        type: Object
      }
    }),
    setup: function setup20(props2, context) {
      var _useComponentClassNam = useComponentClassName3(), NAME_CLASS = _useComponentClassNam.NAME_CLASS, BASE_CLASS_BORDERLESS = _useComponentClassNam.BASE_CLASS_BORDERLESS, BASE_CLASS_MULTIPLE = _useComponentClassNam.BASE_CLASS_MULTIPLE, BASE_CLASS_POPUP_VISIBLE = _useComponentClassNam.BASE_CLASS_POPUP_VISIBLE, BASE_CLASS_EMPTY = _useComponentClassNam.BASE_CLASS_EMPTY;
      var classPrefix = usePrefixClass();
      var renderTNodeJSX = useTNodeJSX();
      var selectInputRef = ref();
      var popupRef = ref();
      var _toRefs = toRefs(props2), multiple = _toRefs.multiple, value = _toRefs.value, popupVisible = _toRefs.popupVisible, borderless = _toRefs.borderless, popupProps2 = _toRefs.popupProps, panel = _toRefs.panel, allowInput = _toRefs.allowInput, status = _toRefs.status;
      var _useOverlayInnerStyle = useOverlayInnerStyle(props2), tOverlayInnerStyle = _useOverlayInnerStyle.tOverlayInnerStyle, innerPopupVisible = _useOverlayInnerStyle.innerPopupVisible, onInnerPopupVisibleChange = _useOverlayInnerStyle.onInnerPopupVisibleChange;
      var _useSingle = useSingle(props2, context, popupRef), isSingleFocus = _useSingle.isSingleFocus, commonInputProps = _useSingle.commonInputProps, onInnerClear = _useSingle.onInnerClear, renderSelectSingle = _useSingle.renderSelectSingle;
      var _useMultiple = useMultiple(props2, context, popupRef), isMultipleFocus = _useMultiple.isMultipleFocus, tagInputRef = _useMultiple.tagInputRef, renderSelectMultiple = _useMultiple.renderSelectMultiple;
      var isFocus = computed(function () {
        return props2.multiple ? isMultipleFocus.value : isSingleFocus.value;
      });
      var classes = computed(function () {
        var _popupVisible$value;
        return ["".concat(NAME_CLASS.value), _defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1({}, BASE_CLASS_MULTIPLE.value, multiple.value), BASE_CLASS_BORDERLESS.value, borderless.value), BASE_CLASS_POPUP_VISIBLE.value, (_popupVisible$value = popupVisible.value) !== null && _popupVisible$value !== void 0 ? _popupVisible$value : innerPopupVisible.value), BASE_CLASS_EMPTY.value, value.value instanceof Array ? !value.value.length : !value.value)];
      });
      var addKeyboardEventListener = function addKeyboardEventListener2(e) {
        var _e$key;
        var code = e.code || ((_e$key = e.key) === null || _e$key === void 0 ? void 0 : _e$key.trim());
        if (/(ArrowDown|ArrowUp)/.test(code) && !popupVisible.value) {
          var _props2$onPopupVisibl;
          var ctx = _objectSpread$6(_objectSpread$6({}, context), {}, {
            trigger: "trigger-element-focus"
          });
          (_props2$onPopupVisibl = props2.onPopupVisibleChange) === null || _props2$onPopupVisibl === void 0 || _props2$onPopupVisibl.call(props2, true, ctx);
        }
      };
      watch([isFocus], function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 1), isFocus2 = _ref3[0];
        if (popupVisible.value) return;
        if (isFocus2) {
          selectInputRef.value.addEventListener("keydown", addKeyboardEventListener);
        } else {
          selectInputRef.value.removeEventListener("keydown", addKeyboardEventListener);
        }
      });
      onMounted(function () {
        if (!popupVisible.value && isFocus) {
          selectInputRef.value.addEventListener("keydown", addKeyboardEventListener);
        }
      });
      onBeforeUnmount(function () {
        var _selectInputRef$value;
        (_selectInputRef$value = selectInputRef.value) === null || _selectInputRef$value === void 0 || _selectInputRef$value.removeEventListener("keydown", addKeyboardEventListener);
      });
      var onOverlayClick = function onOverlayClick2(ctx) {
        var _ctx$e, _tagInputRef$value, _tagInputRef$value$fo;
        (_ctx$e = ctx.e) === null || _ctx$e === void 0 || _ctx$e.stopPropagation();
        if (ctx.e.target.tabIndex >= 0) return;
        if (props2.multiple) (_tagInputRef$value = tagInputRef.value) === null || _tagInputRef$value === void 0 || (_tagInputRef$value$fo = _tagInputRef$value.focus) === null || _tagInputRef$value$fo === void 0 || _tagInputRef$value$fo.call(_tagInputRef$value);
      };
      context.expose({
        popupRef,
        allowInput
      });
      return function () {
        var _popupVisible$value2, _popupProps$value;
        var visibleProps = {
          visible: (_popupVisible$value2 = popupVisible.value) !== null && _popupVisible$value2 !== void 0 ? _popupVisible$value2 : innerPopupVisible.value
        };
        var mainContent = createVNode(Popup, mergeProps({
          "ref": popupRef,
          "trigger": ((_popupProps$value = popupProps2.value) === null || _popupProps$value === void 0 ? void 0 : _popupProps$value.trigger) || "click",
          "placement": "bottom-left"
        }, visibleProps, {
          "content": panel.value,
          "hideEmptyPopup": true
        }, _objectSpread$6(_objectSpread$6({
          onVisibleChange: onInnerPopupVisibleChange,
          onOverlayClick
        }, popupProps2.value), {}, {
          overlayInnerStyle: tOverlayInnerStyle.value
        })), _objectSpread$6({
          "default": function _default5() {
            return [multiple.value ? renderSelectMultiple({
              commonInputProps: commonInputProps.value,
              onInnerClear,
              popupVisible: visibleProps.visible,
              allowInput: allowInput.value
            }) : renderSelectSingle(visibleProps.visible)];
          }
        }, _objectSpread$6(_objectSpread$6({}, context.slots), {}, {
          content: context.slots.panel
        })));
        var tipsNode = renderTNodeJSX("tips");
        var tipsClasses = ["".concat(classPrefix.value, "-input__tips"), "".concat(classPrefix.value, "-tips"), "".concat(classPrefix.value, "-is-").concat(status.value)];
        return createVNode("div", {
          "ref": selectInputRef,
          "class": classes.value
        }, [mainContent, tipsNode && createVNode("div", {
          "class": tipsClasses
        }, [tipsNode])]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var SelectInput = withInstall(_SelectInput);
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var props$6 = {
    checkAll: Boolean,
    content: {
      type: [String, Function]
    },
    "default": {
      type: [String, Function]
    },
    disabled: Boolean,
    label: {
      type: String,
      "default": ""
    },
    title: {
      type: String,
      "default": ""
    },
    value: {
      type: [String, Number, Boolean]
    }
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var props$5 = {
    checkAll: Boolean,
    checked: {
      type: Boolean,
      "default": void 0
    },
    modelValue: {
      type: Boolean,
      "default": void 0
    },
    defaultChecked: Boolean,
    "default": {
      type: [String, Function]
    },
    disabled: {
      type: Boolean,
      "default": void 0
    },
    indeterminate: Boolean,
    label: {
      type: [String, Function]
    },
    lazyLoad: Boolean,
    name: {
      type: String,
      "default": ""
    },
    readonly: {
      type: Boolean,
      "default": void 0
    },
    title: {
      type: String,
      "default": ""
    },
    value: {
      type: [String, Number, Boolean]
    },
    onChange: Function
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var CheckboxGroupInjectionKey = Symbol("CheckboxGroupProvide");
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function observe(element2, root2, callback, marginBottom) {
    if (typeof window === "undefined") return null;
    if (!window || !window.IntersectionObserver) {
      callback();
      return null;
    }
    var io = null;
    try {
      io = new window.IntersectionObserver(function (entries) {
        var entry = entries[0];
        if (entry.isIntersecting) {
          callback();
          io.unobserve(element2);
        }
      }, {
        rootMargin: "0px 0px ".concat(marginBottom, "px 0px"),
        root: root2
      });
      io.observe(element2);
    } catch (e) {
      console.error(e);
      callback();
    }
    return io;
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function useCheckboxLazyLoad(labelRef, lazyLoad) {
    var ioObserver = ref();
    var showCheckbox = ref(true);
    var handleLazyLoad = function handleLazyLoad2() {
      if (!lazyLoad.value) return;
      showCheckbox.value = false;
      var io = observe(labelRef.value, null, function () {
        showCheckbox.value = true;
      }, 0);
      ioObserver.value = io;
    };
    onMounted(handleLazyLoad);
    watch([lazyLoad, labelRef], handleLazyLoad);
    onBeforeUnmount(function () {
      if (!lazyLoad.value) return;
      ioObserver.value.unobserve(labelRef.value);
    });
    return {
      showCheckbox
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function useKeyboardEvent(handleChange) {
    var keyboardEventListener = function keyboardEventListener2(e) {
      var isCheckedCode = CHECKED_CODE_REG.test(e.key) || CHECKED_CODE_REG.test(e.code);
      if (isCheckedCode) {
        e.preventDefault();
        var _e$currentTarget$quer = e.currentTarget.querySelector("input"), disabled = _e$currentTarget$quer.disabled;
        !disabled && handleChange(e);
      }
    };
    var onCheckboxFocus = function onCheckboxFocus2(e) {
      e.currentTarget.addEventListener("keydown", keyboardEventListener);
    };
    var onCheckboxBlur = function onCheckboxBlur2(e) {
      e.currentTarget.removeEventListener("keydown", keyboardEventListener);
    };
    return {
      onCheckboxFocus,
      onCheckboxBlur
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function ownKeys$5(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$5(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$5(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var _Checkbox = /* @__PURE__ */ defineComponent({
    name: "TCheckbox",
    props: _objectSpread$5(_objectSpread$5({}, props$5), {}, {
      needRipple: Boolean,
      stopLabelTrigger: Boolean,
      index: Number,
      data: Object
    }),
    setup: function setup21(props2) {
      var labelRef = ref();
      if (props2.needRipple) {
        useRipple(labelRef);
      }
      var _useCommonClassName = useCommonClassName$1(), STATUS = _useCommonClassName.STATUS;
      var _toRefs = toRefs(props2), checked = _toRefs.checked, modelValue = _toRefs.modelValue, lazyLoad = _toRefs.lazyLoad;
      var _useVModel = useVModel(checked, modelValue, props2.defaultChecked, props2.onChange, "checked"), _useVModel2 = _slicedToArray(_useVModel, 2), innerChecked = _useVModel2[0], setInnerChecked = _useVModel2[1];
      var checkboxGroupData = inject(CheckboxGroupInjectionKey, void 0);
      var tName = ref();
      watch(function () {
        return [props2.name, checkboxGroupData === null || checkboxGroupData === void 0 ? void 0 : checkboxGroupData.value.name].join("_");
      }, function () {
        var name = props2.name || (checkboxGroupData === null || checkboxGroupData === void 0 ? void 0 : checkboxGroupData.value.name);
        if (name) {
          tName.value = name;
        }
      }, {
        immediate: true
      });
      var tChecked = ref(false);
      var getChecked = function getChecked2() {
        var value = props2.value, checkAll = props2.checkAll;
        if (checkAll) return checkboxGroupData === null || checkboxGroupData === void 0 ? void 0 : checkboxGroupData.value.isCheckAll;
        return checkboxGroupData !== null && checkboxGroupData !== void 0 && checkboxGroupData.value ? checkboxGroupData.value.checkedValues.includes(value) : innerChecked.value;
      };
      watch(function () {
        var _checkboxGroupData$va;
        return [innerChecked.value, checkboxGroupData === null || checkboxGroupData === void 0 ? void 0 : checkboxGroupData.value.isCheckAll, checkboxGroupData === null || checkboxGroupData === void 0 || (_checkboxGroupData$va = checkboxGroupData.value.checkedValues) === null || _checkboxGroupData$va === void 0 ? void 0 : _checkboxGroupData$va.join(",")];
      }, function () {
        tChecked.value = getChecked();
      }, {
        immediate: true
      });
      var beforeDisabled = computed(function () {
        if (!props2.checkAll && !tChecked.value && checkboxGroupData !== null && checkboxGroupData !== void 0 && checkboxGroupData.value.maxExceeded) {
          return true;
        }
        return null;
      });
      var afterDisabled = computed(function () {
        return checkboxGroupData === null || checkboxGroupData === void 0 ? void 0 : checkboxGroupData.value.disabled;
      });
      var isDisabled = useDisabled({
        beforeDisabled,
        afterDisabled
      });
      var afterReadonly = computed(function () {
        return checkboxGroupData === null || checkboxGroupData === void 0 ? void 0 : checkboxGroupData.value.readonly;
      });
      var isReadonly2 = useReadonly({
        afterReadonly
      });
      var tIndeterminate = ref(false);
      watch(function () {
        return [props2.checkAll, props2.indeterminate, checkboxGroupData === null || checkboxGroupData === void 0 ? void 0 : checkboxGroupData.value.indeterminate];
      }, function () {
        tIndeterminate.value = props2.checkAll ? checkboxGroupData === null || checkboxGroupData === void 0 ? void 0 : checkboxGroupData.value.indeterminate : props2.indeterminate;
      }, {
        immediate: true
      });
      var COMPONENT_NAME = usePrefixClass("checkbox");
      var labelClasses = ref({});
      watch([tChecked, isDisabled, tIndeterminate], function () {
        labelClasses.value = ["".concat(COMPONENT_NAME.value), _defineProperty$1(_defineProperty$1(_defineProperty$1({}, STATUS.value.checked, tChecked.value), STATUS.value.disabled, isDisabled.value), STATUS.value.indeterminate, tIndeterminate.value)];
      }, {
        immediate: true
      });
      var handleChange = function handleChange2(e) {
        if (isReadonly2.value) return;
        var checked2 = !tChecked.value;
        setInnerChecked(checked2, {
          e
        });
        if (checkboxGroupData !== null && checkboxGroupData !== void 0 && checkboxGroupData.value.handleCheckboxChange) {
          checkboxGroupData.value.onCheckedChange({
            checked: checked2,
            checkAll: props2.checkAll,
            e,
            option: props2
          });
        }
      };
      var renderContent = useContent();
      var handleLabelClick = function handleLabelClick2(e) {
        if (props2.stopLabelTrigger) e.preventDefault();
      };
      var _useCheckboxLazyLoad = useCheckboxLazyLoad(labelRef, lazyLoad), showCheckbox = _useCheckboxLazyLoad.showCheckbox;
      var _useKeyboardEvent = useKeyboardEvent(handleChange), onCheckboxFocus = _useKeyboardEvent.onCheckboxFocus, onCheckboxBlur = _useKeyboardEvent.onCheckboxBlur;
      return function () {
        var titleAttr = isString(props2.title) && props2.title ? props2.title : null;
        return createVNode("label", {
          "ref": labelRef,
          "class": labelClasses.value,
          "tabindex": isDisabled.value ? void 0 : "0",
          "onFocus": onCheckboxFocus,
          "onBlur": onCheckboxBlur,
          "title": titleAttr
        }, [!showCheckbox.value ? null : [createVNode("input", {
          "type": "checkbox",
          "tabindex": "-1",
          "class": "".concat(COMPONENT_NAME.value, "__former"),
          "disabled": isDisabled.value,
          "readonly": isReadonly2.value,
          "indeterminate": tIndeterminate.value,
          "name": tName.value,
          "value": props2.value ? props2.value : void 0,
          "checked": tChecked.value,
          "onChange": handleChange,
          "key": "input"
        }, null), createVNode("span", {
          "class": "".concat(COMPONENT_NAME.value, "__input"),
          "key": "input-span"
        }, null), createVNode("span", {
          "class": "".concat(COMPONENT_NAME.value, "__label"),
          "key": "label",
          "onClick": handleLabelClick
        }, [renderContent("default", "label")])]]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var props$4 = {
    disabled: {
      type: Boolean,
      "default": void 0
    },
    lazyLoad: Boolean,
    max: {
      type: Number,
      "default": void 0
    },
    name: {
      type: String,
      "default": ""
    },
    options: {
      type: Array
    },
    readonly: {
      type: Boolean,
      "default": void 0
    },
    value: {
      type: Array,
      "default": void 0
    },
    modelValue: {
      type: Array,
      "default": void 0
    },
    defaultValue: {
      type: Array,
      "default": function _default4() {
        return [];
      }
    },
    onChange: Function
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var _Group = /* @__PURE__ */ defineComponent({
    name: "TCheckboxGroup",
    props: props$4,
    setup: function setup22(props2) {
      var COMPONENT_NAME = usePrefixClass("checkbox-group");
      var renderTNodeJSX = useTNodeJSX();
      var isArray2 = Array.isArray;
      var _toRefs = toRefs(props2), value = _toRefs.value, modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props2.defaultValue, props2.onChange), _useVModel2 = _slicedToArray(_useVModel, 2), innerValue = _useVModel2[0], setInnerValue = _useVModel2[1];
      var optionList = ref([]);
      var intersectionLen = computed(function () {
        if (!isArray2(innerValue.value)) return 0;
        var values = optionList.value.map(function (item) {
          return item.value;
        });
        var n = intersection(innerValue.value, values);
        return n.length;
      });
      var isCheckAll = computed(function () {
        var optionItems = optionList.value.filter(function (item) {
          return !item.disabled && !item.readonly && !item.checkAll;
        }).map(function (t) {
          return t.value;
        });
        var intersectionValues = intersection(optionItems, innerValue.value);
        return intersectionValues.length === optionItems.length;
      });
      var indeterminate = computed(function () {
        return !isCheckAll.value && intersectionLen.value < optionList.value.length && intersectionLen.value !== 0;
      });
      var maxExceeded = computed(function () {
        return !isUndefined(props2.max) && innerValue.value.length === props2.max;
      });
      watchEffect(function () {
        if (!props2.options) return [];
        optionList.value = props2.options.map(function (item) {
          return isObject(item) ? item : {
            label: String(item),
            value: item
          };
        });
      });
      var getAllCheckboxValue = function getAllCheckboxValue2() {
        var val = /* @__PURE__ */ new Set();
        for (var i = 0, len = optionList.value.length; i < len; i++) {
          var item = optionList.value[i];
          if (item.checkAll) continue;
          if (item.disabled) continue;
          if (item.readonly) continue;
          val.add(item.value);
          if (maxExceeded.value) break;
        }
        return _toConsumableArray(val);
      };
      var onCheckAllChange = function onCheckAllChange2(checked, context) {
        var value2 = checked ? getAllCheckboxValue() : [];
        setInnerValue(value2, {
          e: context.e,
          type: checked ? "check" : "uncheck",
          current: void 0,
          option: void 0
        });
      };
      var handleCheckboxChange = function handleCheckboxChange2(data) {
        var currentValue = data.option.value;
        if (!isArray2(innerValue.value)) {
          console.warn("TDesign CheckboxGroup Warn: `value` must be an array, instead of ".concat(_typeof$2(innerValue.value)));
          return;
        }
        var val = _toConsumableArray(innerValue.value);
        if (data.checked) {
          val.push(currentValue);
        } else {
          var i = val.indexOf(currentValue);
          val.splice(i, 1);
        }
        setInnerValue(val, {
          e: data.e,
          current: data.option.value,
          option: data.option,
          type: data.checked ? "check" : "uncheck"
        });
      };
      var onCheckedChange = function onCheckedChange2(p2) {
        var checked = p2.checked, checkAll = p2.checkAll, e = p2.e;
        if (checkAll) {
          onCheckAllChange(checked, {
            e
          });
        } else {
          handleCheckboxChange(p2);
        }
      };
      var getChildComponentSlots = useChildComponentSlots();
      var getOptionListBySlots = function getOptionListBySlots2() {
        var nodes = getChildComponentSlots("Checkbox");
        var arr = [];
        nodes === null || nodes === void 0 || nodes.forEach(function (node) {
          var option = node.props;
          if (!option) return;
          if (option["check-all"] === "" || option["check-all"] === true) {
            option.checkAll = true;
          }
          arr.push(option);
        });
        return arr;
      };
      provide(CheckboxGroupInjectionKey, computed(function () {
        return {
          name: props2.name,
          isCheckAll: isCheckAll.value,
          checkedValues: innerValue.value || [],
          maxExceeded: maxExceeded.value,
          disabled: props2.disabled,
          readonly: props2.readonly,
          indeterminate: indeterminate.value,
          handleCheckboxChange,
          onCheckedChange
        };
      }));
      return function () {
        var _props2$options;
        var children = null;
        if ((_props2$options = props2.options) !== null && _props2$options !== void 0 && _props2$options.length) {
          var _optionList$value;
          children = (_optionList$value = optionList.value) === null || _optionList$value === void 0 ? void 0 : _optionList$value.map(function (option, index) {
            var _innerValue$value;
            return createVNode(_Checkbox, mergeProps({
              "key": "".concat(option.value || "").concat(index),
              "lazyLoad": props2.lazyLoad
            }, option, {
              "index": index,
              "checked": (_innerValue$value = innerValue.value) === null || _innerValue$value === void 0 ? void 0 : _innerValue$value.includes(option.value),
              "data": option
            }), null);
          });
        } else {
          var nodes = renderTNodeJSX("default");
          optionList.value = getOptionListBySlots();
          children = nodes;
        }
        return createVNode("div", {
          "class": COMPONENT_NAME.value,
          "role": "group",
          "aria-label": "checkbox-group"
        }, [children]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var Checkbox = withInstall(_Checkbox);
  withInstall(_Group);
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function _createForOfIteratorHelper$2(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray$2(r)) || e) {
        t && (r = t);
        var _n = 0, F = function F2() {
        };
        return {
          s: F, n: function n() {
            return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
          }, e: function e2(r2) {
            throw r2;
          }, f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o, a = true, u = false;
    return {
      s: function s() {
        t = t.call(r);
      }, n: function n() {
        var r2 = t.next();
        return a = r2.done, r2;
      }, e: function e2(r2) {
        u = true, o = r2;
      }, f: function f() {
        try {
          a || null == t["return"] || t["return"]();
        } finally {
          if (u) throw o;
        }
      }
    };
  }
  function _unsupportedIterableToArray$2(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray$2(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2(r, a) : void 0;
    }
  }
  function _arrayLikeToArray$2(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  var getSingleContent = function getSingleContent2(value, optionsMap) {
    var option = optionsMap.value.get(value);
    return (option === null || option === void 0 ? void 0 : option.label) || (value === null || value === void 0 ? void 0 : value.toString());
  };
  var getMultipleContent = function getMultipleContent2(value, optionsMap) {
    var res = [];
    var _iterator = _createForOfIteratorHelper$2(value), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var iterator2 = _step.value;
        var resLabel = getSingleContent(iterator2, optionsMap);
        if (resLabel) {
          res.push(resLabel);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return res;
  };
  var getNewMultipleValue = function getNewMultipleValue2(innerValue, optionValue) {
    var value = cloneDeep(innerValue);
    var valueIndex = value.indexOf(optionValue);
    if (valueIndex < 0) {
      value.push(optionValue);
    } else {
      value.splice(valueIndex, 1);
    }
    return {
      value,
      isCheck: valueIndex < 0
    };
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var selectInjectKey = Symbol("selectProvide");
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function ownKeys$4(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$4(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$4(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function _isSlot$1(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
  }
  var _Option = /* @__PURE__ */ defineComponent({
    name: "TOption",
    props: _objectSpread$4(_objectSpread$4({}, props$6), {}, {
      createAble: Boolean,
      multiple: Boolean,
      index: Number,
      rowIndex: Number,
      trs: Map,
      scrollType: String,
      isVirtual: Boolean,
      bufferSize: Number,
      checkAll: Boolean
    }),
    emits: ["row-mounted"],
    setup: function setup23(props2, context) {
      var selectProvider = inject(selectInjectKey);
      var formDisabled = useDisabled();
      var _getCurrentInstance = getCurrentInstance(), vnode = _getCurrentInstance.vnode;
      var isReachMax = computed(function () {
        return selectProvider.value.max !== 0 && selectProvider.value.max <= selectProvider.value.selectValue.length;
      });
      var disabled = computed(function () {
        return formDisabled.value || props2.multiple && isReachMax.value && !isSelected.value && !selectProvider.value.isCheckAll;
      });
      var renderContent = useContent();
      var selectName = usePrefixClass("select");
      var _useCommonClassName = useCommonClassName$1(), STATUS = _useCommonClassName.STATUS, SIZE = _useCommonClassName.SIZE;
      var liRef = ref();
      var isHover = ref(false);
      var isSelected = computed(function () {
        if (selectProvider.value.isCheckAll && !props2.disabled) return true;
        return !props2.multiple ? selectProvider.value.selectValue === props2.value : selectProvider.value.selectValue.includes(props2.value);
      });
      var isIndeterminate = computed(function () {
        if (!props2.checkAll) return false;
        return selectProvider.value.indeterminate;
      });
      var classes = computed(function () {
        return ["".concat(selectName.value, "-option"), [SIZE.value[selectProvider.value.size]], _defineProperty$1(_defineProperty$1(_defineProperty$1({}, STATUS.value.disabled, disabled.value), STATUS.value.selected, isSelected.value), "".concat(selectName.value, "-option__hover"), (isHover.value || selectProvider.value.hoverIndex === props2.index) && !disabled.value)];
      });
      var labelText = computed(function () {
        return props2.label || props2.value;
      });
      var handleClick = function handleClick2(e) {
        if (props2.disabled || disabled.value) return;
        if (props2.multiple) {
          handleCheckboxClick(!isSelected.value, {
            e
          });
          e.preventDefault();
          return;
        }
        if (props2.createAble) {
          var _selectProvider$value, _selectProvider$value2;
          (_selectProvider$value = (_selectProvider$value2 = selectProvider.value).handleCreate) === null || _selectProvider$value === void 0 || _selectProvider$value.call(_selectProvider$value2, props2.value);
          if (selectProvider.value.multiple) {
            selectProvider.value.handleValueChange([].concat(_toConsumableArray(selectProvider.value.selectValue), [props2.value]), {
              selectedOptions: selectProvider.value.getSelectedOptions(),
              trigger: "check",
              e
            });
            return;
          }
        }
        var selectedOptions = selectProvider.value.getSelectedOptions(props2.value);
        selectProvider.value.handleValueChange(props2.value, {
          option: selectedOptions === null || selectedOptions === void 0 ? void 0 : selectedOptions[0],
          selectedOptions,
          trigger: "check",
          e
        });
        selectProvider.value.handlePopupVisibleChange(false, {
          e
        });
        selectProvider.value.emitBlur(e);
      };
      var handleCheckboxClick = function handleCheckboxClick2(val, context2) {
        if (props2.checkAll) {
          selectProvider.value.onCheckAllChange(val);
          return;
        }
        var newValue = getNewMultipleValue(selectProvider.value.selectValue, props2.value);
        var selectedOptions = selectProvider.value.getSelectedOptions(newValue.value);
        selectProvider.value.handleValueChange(newValue.value, {
          option: selectedOptions.find(function (v) {
            return v.value === props2.value;
          }),
          selectedOptions,
          trigger: val ? "check" : "uncheck",
          e: context2.e
        });
      };
      var renderTitle = function renderTitle2() {
        var vProps = vnode.props || {};
        if (Reflect.has(vProps, "title")) {
          return props2.title;
        }
        if (typeof labelText.value === "string") return labelText.value;
        return null;
      };
      onMounted(function () {
        var trs = props2.trs, rowIndex = props2.rowIndex, isVirtual = props2.isVirtual;
        if (isVirtual) {
          trs.set(rowIndex, liRef.value);
          context.emit("row-mounted");
        }
      });
      onBeforeUnmount(function () {
        if (props2.isVirtual) {
          var trs = props2.trs, rowIndex = props2.rowIndex;
          trs["delete"](rowIndex);
        }
      });
      useRipple(liRef);
      return function () {
        var optionChild = renderContent("default", "content") || labelText.value;
        return createVNode("li", {
          "ref": liRef,
          "class": classes.value,
          "title": renderTitle(),
          "onMouseenter": function onMouseenter() {
            return isHover.value = true;
          },
          "onMouseleave": function onMouseleave() {
            return isHover.value = false;
          },
          "onClick": handleClick
        }, [selectProvider && props2.multiple ? createVNode(Checkbox, {
          "checked": isSelected.value,
          "disabled": disabled.value,
          "onChange": handleCheckboxClick,
          "indeterminate": isIndeterminate.value
        }, _isSlot$1(optionChild) ? optionChild : {
          "default": function _default5() {
            return [optionChild];
          }
        }) : createVNode("span", null, [optionChild])]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var props$3 = {
    divider: {
      type: Boolean,
      "default": true
    },
    label: {
      type: String
    }
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var _OptionGroup = /* @__PURE__ */ defineComponent({
    name: "TOptionGroup",
    props: props$3,
    setup: function setup24(props2) {
      var selectProvider = inject(selectInjectKey);
      var COMPONENT_NAME = usePrefixClass("select-option-group");
      var _useCommonClassName = useCommonClassName$1(), SIZE = _useCommonClassName.SIZE;
      var renderTNodeJSX = useTNodeJSX();
      var classes = computed(function () {
        return [COMPONENT_NAME.value, SIZE.value[selectProvider.value.size], _defineProperty$1({}, "".concat(COMPONENT_NAME.value, "__divider"), props2.divider)];
      });
      return function () {
        var _props2$label;
        return createVNode("li", {
          "class": classes.value
        }, [((_props2$label = props2.label) !== null && _props2$label !== void 0 ? _props2$label : false) && createVNode("div", {
          "class": "".concat(COMPONENT_NAME.value, "__header")
        }, [props2.label]), renderTNodeJSX("default")]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var props$2 = {
    autoWidth: Boolean,
    autofocus: Boolean,
    borderless: Boolean,
    clearable: Boolean,
    collapsedItems: {
      type: Function
    },
    creatable: Boolean,
    disabled: {
      type: Boolean,
      "default": void 0
    },
    empty: {
      type: [String, Function]
    },
    filter: {
      type: Function
    },
    filterable: Boolean,
    inputProps: {
      type: Object
    },
    inputValue: {
      type: [String, Number],
      "default": void 0
    },
    defaultInputValue: {
      type: [String, Number]
    },
    keys: {
      type: Object
    },
    label: {
      type: [String, Function]
    },
    loading: Boolean,
    loadingText: {
      type: [String, Function]
    },
    max: {
      type: Number,
      "default": 0
    },
    minCollapsedNum: {
      type: Number,
      "default": 0
    },
    multiple: Boolean,
    options: {
      type: Array
    },
    panelBottomContent: {
      type: [String, Function]
    },
    panelTopContent: {
      type: [String, Function]
    },
    placeholder: {
      type: String,
      "default": void 0
    },
    popupProps: {
      type: Object
    },
    popupVisible: {
      type: Boolean,
      "default": void 0
    },
    defaultPopupVisible: Boolean,
    prefixIcon: {
      type: Function
    },
    readonly: {
      type: Boolean,
      "default": void 0
    },
    reserveKeyword: Boolean,
    scroll: {
      type: Object
    },
    selectInputProps: {
      type: Object
    },
    showArrow: {
      type: Boolean,
      "default": true
    },
    size: {
      type: String,
      "default": "medium",
      validator: function validator26(val) {
        if (!val) return true;
        return ["small", "medium", "large"].includes(val);
      }
    },
    status: {
      type: String,
      "default": "default",
      validator: function validator27(val) {
        if (!val) return true;
        return ["default", "success", "warning", "error"].includes(val);
      }
    },
    suffix: {
      type: [String, Function]
    },
    suffixIcon: {
      type: Function
    },
    tagInputProps: {
      type: Object
    },
    tagProps: {
      type: Object
    },
    tips: {
      type: [String, Function]
    },
    value: {
      type: [String, Number, Boolean, Object, Array],
      "default": void 0
    },
    modelValue: {
      type: [String, Number, Boolean, Object, Array],
      "default": void 0
    },
    defaultValue: {
      type: [String, Number, Boolean, Object, Array],
      "default": void 0
    },
    valueDisplay: {
      type: [String, Function]
    },
    valueType: {
      type: String,
      "default": "value",
      validator: function validator28(val) {
        if (!val) return true;
        return ["value", "object"].includes(val);
      }
    },
    onBlur: Function,
    onChange: Function,
    onClear: Function,
    onCreate: Function,
    onEnter: Function,
    onFocus: Function,
    onInputChange: Function,
    onPopupVisibleChange: Function,
    onRemove: Function,
    onSearch: Function
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var usePanelVirtualScroll = function usePanelVirtualScroll2(props2) {
    var _props$scroll3, _props$scroll4, _props$scroll5, _props$scroll6, _props$scroll7;
    var isVirtual = computed(function () {
      var _props$scroll, _props$options$value, _props$scroll2;
      return ((_props$scroll = props2.scroll) === null || _props$scroll === void 0 ? void 0 : _props$scroll.type) === "virtual" && ((_props$options$value = props2.options.value) === null || _props$options$value === void 0 ? void 0 : _props$options$value.length) > (((_props$scroll2 = props2.scroll) === null || _props$scroll2 === void 0 ? void 0 : _props$scroll2.threshold) || 100);
    });
    var _ref = ((_props$scroll3 = props2.scroll) === null || _props$scroll3 === void 0 ? void 0 : _props$scroll3.type) === "virtual" ? useVirtualScroll({
      container: props2.popupContentRef,
      data: props2.options,
      fixedHeight: ((_props$scroll4 = props2.scroll) === null || _props$scroll4 === void 0 ? void 0 : _props$scroll4.isFixedRowHeight) || false,
      lineHeight: ((_props$scroll5 = props2.scroll) === null || _props$scroll5 === void 0 ? void 0 : _props$scroll5.rowHeight) || 28,
      bufferSize: ((_props$scroll6 = props2.scroll) === null || _props$scroll6 === void 0 ? void 0 : _props$scroll6.bufferSize) || 20,
      threshold: ((_props$scroll7 = props2.scroll) === null || _props$scroll7 === void 0 ? void 0 : _props$scroll7.threshold) || 100
    }) : {}, _ref$trs = _ref.trs, trs = _ref$trs === void 0 ? null : _ref$trs, _ref$visibleData = _ref.visibleData, visibleData = _ref$visibleData === void 0 ? null : _ref$visibleData, _ref$handleScroll = _ref.handleScroll, handleVirtualScroll = _ref$handleScroll === void 0 ? null : _ref$handleScroll, _ref$scrollHeight = _ref.scrollHeight, scrollHeight = _ref$scrollHeight === void 0 ? null : _ref$scrollHeight, _ref$translateY = _ref.translateY, translateY = _ref$translateY === void 0 ? null : _ref$translateY, _ref$handleRowMounted = _ref.handleRowMounted, handleRowMounted = _ref$handleRowMounted === void 0 ? null : _ref$handleRowMounted;
    var lastScrollY = -1;
    var onInnerVirtualScroll = function onInnerVirtualScroll2(e) {
      if (!isVirtual.value) {
        return;
      }
      var target = e.target;
      var top2 = target.scrollTop;
      if (Math.abs(lastScrollY - top2) > 5) {
        handleVirtualScroll();
        lastScrollY = top2;
      } else {
        lastScrollY = -1;
      }
    };
    onMounted(function () {
      var _props$popupContentRe;
      (_props$popupContentRe = props2.popupContentRef.value) === null || _props$popupContentRe === void 0 || _props$popupContentRe.addEventListener("scroll", onInnerVirtualScroll);
    });
    onBeforeUnmount(function () {
      var _props$popupContentRe2;
      (_props$popupContentRe2 = props2.popupContentRef.value) === null || _props$popupContentRe2 === void 0 || _props$popupContentRe2.removeEventListener("scroll", onInnerVirtualScroll);
    });
    var cursorStyle = computed(function () {
      return {
        position: "absolute",
        width: "1px",
        height: "1px",
        transition: "transform 0.2s",
        transform: "translate(0, ".concat(scrollHeight.value, "px)"),
        "-ms-transform": "translate(0, ".concat(scrollHeight.value, "px)"),
        "-moz-transform": "translate(0, ".concat(scrollHeight.value, "px)"),
        "-webkit-transform": "translate(0, ".concat(scrollHeight.value, "px)")
      };
    });
    var panelStyle = computed(function () {
      return {
        transform: "translate(0, ".concat(translateY.value, "px)"),
        "-ms-transform": "translate(0, ".concat(translateY.value, "px)"),
        "-moz-transform": "translate(0, ".concat(translateY.value, "px)"),
        "-webkit-transform": "translate(0, ".concat(translateY.value, "px)")
      };
    });
    return {
      trs,
      scrollHeight,
      translateY,
      visibleData,
      handleRowMounted,
      isVirtual,
      cursorStyle,
      panelStyle
    };
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function _isSlot(s) {
    return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
  }
  var SelectPanel = /* @__PURE__ */ defineComponent({
    name: "TSelectPanel",
    props: {
      inputValue: props$2.inputValue,
      panelTopContent: props$2.panelTopContent,
      panelBottomContent: props$2.panelBottomContent,
      empty: props$2.empty,
      creatable: props$2.creatable,
      loading: props$2.loading,
      loadingText: props$2.loadingText,
      multiple: props$2.multiple,
      filterable: props$2.filterable,
      filter: props$2.filter,
      scroll: props$2.scroll,
      size: props$2.size
    },
    setup: function setup25(props2, _ref) {
      var expose = _ref.expose;
      var COMPONENT_NAME = usePrefixClass("select");
      var renderTNodeJSX = useTNodeJSX();
      var renderDefaultTNode = useTNodeDefault();
      var _useConfig = useConfig("select"), t = _useConfig.t, globalConfig = _useConfig.globalConfig;
      var tSelect = inject(selectInjectKey);
      var innerRef = ref(null);
      var popupContentRef = computed(function () {
        return tSelect.value.popupContentRef.value;
      });
      var showCreateOption = computed(function () {
        return props2.creatable && props2.filterable && props2.inputValue;
      });
      var displayOptions = computed(function () {
        return tSelect.value.displayOptions;
      });
      var _usePanelVirtualScrol = usePanelVirtualScroll({
        scroll: props2.scroll,
        popupContentRef,
        options: displayOptions
      }), trs = _usePanelVirtualScrol.trs, visibleData = _usePanelVirtualScrol.visibleData, handleRowMounted = _usePanelVirtualScrol.handleRowMounted, isVirtual = _usePanelVirtualScrol.isVirtual, panelStyle = _usePanelVirtualScrol.panelStyle, cursorStyle = _usePanelVirtualScrol.cursorStyle;
      var isEmpty = computed(function () {
        return !displayOptions.value.length;
      });
      var renderCreateOption = function renderCreateOption2() {
        return createVNode("ul", {
          "class": ["".concat(COMPONENT_NAME.value, "__create-option"), "".concat(COMPONENT_NAME.value, "__list")]
        }, [createVNode(_Option, {
          "value": props2.inputValue,
          "label": "".concat(props2.inputValue),
          "createAble": true,
          "class": "".concat(COMPONENT_NAME.value, "__create-option--special")
        }, null)]);
      };
      var _renderOptionsContent = function renderOptionsContent(options) {
        return createVNode("ul", {
          "class": "".concat(COMPONENT_NAME.value, "__list")
        }, [options.map(function (item, index) {
          var _props$scroll, _props$scroll2;
          if (item.children) {
            var _slot;
            return createVNode(_OptionGroup, {
              "label": item.group,
              "divider": item.divider
            }, _isSlot(_slot = _renderOptionsContent(item.children)) ? _slot : {
              "default": function _default5() {
                return [_slot];
              }
            });
          }
          return createVNode(_Option, mergeProps(omit(item, "index", "$index", "className", "tagName"), isVirtual.value ? {
            rowIndex: item.$index,
            trs,
            scrollType: (_props$scroll = props2.scroll) === null || _props$scroll === void 0 ? void 0 : _props$scroll.type,
            isVirtual: isVirtual.value,
            bufferSize: (_props$scroll2 = props2.scroll) === null || _props$scroll2 === void 0 ? void 0 : _props$scroll2.bufferSize,
            key: "".concat(item.$index || "", "_").concat(index, "_").concat(item.value)
          } : {
            key: "".concat(index, "_").concat(item.value)
          }, {
            "index": index,
            "multiple": props2.multiple,
            "onRowMounted": handleRowMounted
          }), item.slots);
        })]);
      };
      var dropdownInnerSize = computed(function () {
        return {
          small: "s",
          medium: "m",
          large: "l"
        }[tSelect.value.size];
      });
      expose({
        innerRef,
        visibleData,
        isVirtual,
        displayOptions
      });
      var renderPanel = function renderPanel2(options, extraStyle) {
        return createVNode("div", {
          "ref": innerRef,
          "class": ["".concat(COMPONENT_NAME.value, "__dropdown-inner"), "".concat(COMPONENT_NAME.value, "__dropdown-inner--size-").concat(dropdownInnerSize.value)],
          "style": extraStyle
        }, [showCreateOption.value && renderCreateOption(), props2.loading && renderDefaultTNode("loadingText", {
          defaultNode: createVNode("div", {
            "class": "".concat(COMPONENT_NAME.value, "__loading-tips")
          }, [t(globalConfig.value.loadingText)])
        }), !props2.loading && isEmpty.value && !showCreateOption.value && createVNode("div", {
          "class": "".concat(COMPONENT_NAME.value, "__empty")
        }, [renderTNodeJSX("empty") || t(globalConfig.value.empty)]), !isEmpty.value && _renderOptionsContent(options)]);
      };
      return {
        renderPanel,
        panelStyle,
        cursorStyle,
        isVirtual,
        displayOptions,
        visibleData,
        renderTNodeJSX
      };
    },
    render: function render() {
      return this.isVirtual ? createVNode(Fragment, null, [this.renderTNodeJSX("panelTopContent"), createVNode("div", null, [createVNode("div", {
        "style": this.cursorStyle
      }, null), this.renderPanel(this.visibleData, this.panelStyle)]), this.renderTNodeJSX("panelBottomContent")]) : createVNode(Fragment, null, [this.renderTNodeJSX("panelTopContent"), this.renderPanel(this.displayOptions), this.renderTNodeJSX("panelBottomContent")]);
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function useKeyboardControl(_ref) {
    var displayOptions = _ref.displayOptions, optionsList = _ref.optionsList, innerPopupVisible = _ref.innerPopupVisible, setInnerPopupVisible = _ref.setInnerPopupVisible, selectPanelRef = _ref.selectPanelRef, isFilterable = _ref.isFilterable, isRemoteSearch = _ref.isRemoteSearch, getSelectedOptions = _ref.getSelectedOptions, setInnerValue = _ref.setInnerValue, innerValue = _ref.innerValue, popupContentRef = _ref.popupContentRef, multiple = _ref.multiple, max2 = _ref.max;
    var hoverIndex = ref(-1);
    var filteredOptions = ref([]);
    var virtualFilteredOptions = ref([]);
    var classPrefix = usePrefixClass();
    var handleKeyDown = function handleKeyDown2(e) {
      var _optionsList$value$ne, _optionsList$value$ne2;
      var optionsListLength = displayOptions.value.length;
      var newIndex = hoverIndex.value;
      switch (e.code) {
        case "ArrowUp":
          e.preventDefault();
          if (hoverIndex.value === -1) {
            newIndex = 0;
          } else if (hoverIndex.value === 0 || hoverIndex.value > displayOptions.value.length - 1) {
            newIndex = optionsListLength - 1;
          } else {
            newIndex--;
          }
          if ((_optionsList$value$ne = optionsList.value[newIndex]) !== null && _optionsList$value$ne !== void 0 && _optionsList$value$ne.disabled) {
            newIndex--;
          }
          hoverIndex.value = newIndex;
          break;
        case "ArrowDown":
          e.preventDefault();
          if (hoverIndex.value === -1 || hoverIndex.value >= optionsListLength - 1) {
            newIndex = 0;
          } else {
            newIndex++;
          }
          if ((_optionsList$value$ne2 = optionsList.value[newIndex]) !== null && _optionsList$value$ne2 !== void 0 && _optionsList$value$ne2.disabled) {
            newIndex++;
          }
          hoverIndex.value = newIndex;
          break;
        case "Enter":
          if (hoverIndex.value === -1) break;
          var finalOptions = selectPanelRef.value.isVirtual && isFilterable.value && virtualFilteredOptions.value.length ? virtualFilteredOptions.value : isRemoteSearch.value ? optionsList.value : filteredOptions.value;
          if (!finalOptions.length) finalOptions = optionsList.value;
          if (!innerPopupVisible.value) {
            setInnerPopupVisible(true, {
              e
            });
            break;
          }
          if (!multiple) {
            var selectedOptions = getSelectedOptions(finalOptions[hoverIndex.value].value);
            setInnerValue(finalOptions[hoverIndex.value].value, {
              option: selectedOptions === null || selectedOptions === void 0 ? void 0 : selectedOptions[0],
              selectedOptions: getSelectedOptions(finalOptions[hoverIndex.value].value),
              trigger: "check",
              e
            });
            setInnerPopupVisible(false, {
              e
            });
          } else {
            var _finalOptions$hoverIn;
            if (hoverIndex.value === -1) return;
            var optionValue = (_finalOptions$hoverIn = finalOptions[hoverIndex.value]) === null || _finalOptions$hoverIn === void 0 ? void 0 : _finalOptions$hoverIn.value;
            if (!optionValue) return;
            var newValue = getNewMultipleValue(innerValue.value, optionValue);
            if (max2 > 0 && newValue.value.length > max2) return;
            var _selectedOptions = getSelectedOptions(newValue.value);
            setInnerValue(newValue.value, {
              option: _selectedOptions.find(function (v) {
                return v.value == optionValue;
              }),
              selectedOptions: _selectedOptions,
              trigger: newValue.isCheck ? "check" : "uncheck",
              e
            });
            filteredOptions.value = [];
          }
          break;
        case "Escape":
          setInnerPopupVisible(false, {
            e
          });
          break;
      }
    };
    watch(innerPopupVisible, function (value) {
      if (value) {
        hoverIndex.value = -1;
        virtualFilteredOptions.value = [];
        filteredOptions.value = [];
      }
    });
    watch(hoverIndex, function (index) {
      var _selectPanelRef$value;
      var optionHeight = (_selectPanelRef$value = selectPanelRef.value) === null || _selectPanelRef$value === void 0 || (_selectPanelRef$value = _selectPanelRef$value.innerRef) === null || _selectPanelRef$value === void 0 || (_selectPanelRef$value = _selectPanelRef$value.querySelector(".".concat(classPrefix.value, "-select-option"))) === null || _selectPanelRef$value === void 0 ? void 0 : _selectPanelRef$value.clientHeight;
      var scrollHeight = optionHeight * index;
      popupContentRef.value.scrollTo({
        top: scrollHeight,
        behavior: "smooth"
      });
    });
    return {
      hoverIndex,
      handleKeyDown,
      virtualFilteredOptions,
      filteredOptions
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function _createForOfIteratorHelper$1(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray$1(r)) || e) {
        t && (r = t);
        var _n = 0, F = function F2() {
        };
        return {
          s: F, n: function n() {
            return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
          }, e: function e2(r2) {
            throw r2;
          }, f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o, a = true, u = false;
    return {
      s: function s() {
        t = t.call(r);
      }, n: function n() {
        var r2 = t.next();
        return a = r2.done, r2;
      }, e: function e2(r2) {
        u = true, o = r2;
      }, f: function f() {
        try {
          a || null == t["return"] || t["return"]();
        } finally {
          if (u) throw o;
        }
      }
    };
  }
  function _unsupportedIterableToArray$1(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray$1(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0;
    }
  }
  function _arrayLikeToArray$1(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function ownKeys$3(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$3(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$3(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var useSelectOptions = function useSelectOptions2(props2, keys2, inputValue) {
    var getChildComponentSlots = useChildComponentSlots();
    var optionsCache = ref([]);
    var options = computed(function () {
      var _props$options;
      var dynamicIndex = 0;
      var innerOptions = ((_props$options = props2.options) === null || _props$options === void 0 ? void 0 : _props$options.map(function (option) {
        var getFormatOption = function getFormatOption2(option2) {
          var _keys$value = keys2.value, value = _keys$value.value, label = _keys$value.label, disabled = _keys$value.disabled;
          var res2 = _objectSpread$3(_objectSpread$3({}, option2), {}, {
            index: dynamicIndex,
            label: get(option2, label),
            value: get(option2, value),
            disabled: get(option2, disabled) || false
          });
          dynamicIndex++;
          return res2;
        };
        if (option.children) {
          return _objectSpread$3(_objectSpread$3({}, option), {}, {
            children: option.children.map(function (child2) {
              return getFormatOption(child2);
            })
          });
        }
        return getFormatOption(option);
      })) || [];
      var optionsSlots = getChildComponentSlots("Option");
      var groupSlots = getChildComponentSlots("OptionGroup");
      if (isArray(groupSlots)) {
        var _iterator = _createForOfIteratorHelper$1(groupSlots), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _group$props;
            var group = _step.value;
            var groupOption = _objectSpread$3(_objectSpread$3({
              group: (_group$props = group.props) === null || _group$props === void 0 ? void 0 : _group$props.label
            }, group.props), {}, {
              children: []
            });
            var res = getChildComponentSlots("Option", group.children);
            if (!isArray(res)) continue;
            var _iterator2 = _createForOfIteratorHelper$1(res), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var child = _step2.value;
                groupOption.children.push(_objectSpread$3(_objectSpread$3({}, child.props), {}, {
                  slots: child.children,
                  index: dynamicIndex
                }));
                dynamicIndex++;
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            innerOptions.push(groupOption);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      if (isArray(optionsSlots)) {
        var _iterator3 = _createForOfIteratorHelper$1(optionsSlots), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _child = _step3.value;
            innerOptions.push(_objectSpread$3(_objectSpread$3({}, _child.props), {}, {
              slots: _child.children,
              index: dynamicIndex
            }));
            dynamicIndex++;
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
      return innerOptions;
    });
    var optionsList = computed(function () {
      var res = [];
      var _getOptionsList = function getOptionsList(options2) {
        var _iterator4 = _createForOfIteratorHelper$1(options2), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var option = _step4.value;
            if (option.children) {
              _getOptionsList(option.children);
            } else {
              res.push(option);
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      };
      _getOptionsList(options.value);
      return res;
    });
    var optionsMap = computed(function () {
      var res = /* @__PURE__ */ new Map();
      optionsCache.value.concat(optionsList.value).forEach(function (option) {
        res.set(option.value, option);
      });
      return res;
    });
    var filterMethods = function filterMethods2(option) {
      var _option$label, _option$label$toLower;
      if (isFunction(props2.filter)) {
        return props2.filter("".concat(inputValue.value), option);
      }
      return ((_option$label = option.label) === null || _option$label === void 0 || (_option$label$toLower = _option$label.toLowerCase) === null || _option$label$toLower === void 0 ? void 0 : _option$label$toLower.call(_option$label).indexOf("".concat(inputValue.value).toLowerCase())) > -1;
    };
    var displayOptions = computed(function () {
      if (props2.onSearch && props2.filterable) return options.value;
      if (!inputValue.value || !(props2.filterable || isFunction(props2.filter))) return options.value;
      var checkAllOption;
      var res = [];
      options.value.forEach(function (option) {
        if (option.children) {
          res.push(_objectSpread$3(_objectSpread$3({}, option), {}, {
            children: option.children.filter(filterMethods)
          }));
        }
        if ((option === null || option === void 0 ? void 0 : option.checkAll) === true) checkAllOption = option;
        if (filterMethods(option)) {
          res.push(option);
        }
      });
      if (!isFunction(props2.filter)) {
        var exactMatch = res.filter(function (item) {
          return item.label === inputValue.value;
        });
        var fuzzyMatch = res.filter(function (item) {
          return item.label !== inputValue.value;
        });
        res = exactMatch.concat(fuzzyMatch);
      }
      return res.length && checkAllOption ? [checkAllOption].concat(_toConsumableArray(res)) : res;
    });
    return {
      options,
      optionsMap,
      optionsList,
      optionsCache,
      displayOptions,
      filterMethods
    };
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var _excluded$1 = ["overlayClassName"];
  function _createForOfIteratorHelper(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {
        t && (r = t);
        var _n = 0, F = function F2() {
        };
        return {
          s: F, n: function n() {
            return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
          }, e: function e2(r2) {
            throw r2;
          }, f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o, a = true, u = false;
    return {
      s: function s() {
        t = t.call(r);
      }, n: function n() {
        var r2 = t.next();
        return a = r2.done, r2;
      }, e: function e2(r2) {
        u = true, o = r2;
      }, f: function f() {
        try {
          a || null == t["return"] || t["return"]();
        } finally {
          if (u) throw o;
        }
      }
    };
  }
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }
  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function ownKeys$2(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$2(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var _Select = /* @__PURE__ */ defineComponent({
    name: "TSelect",
    props: _objectSpread$2(_objectSpread$2({}, props$2), {}, {
      valueDisplayOptions: {
        type: Object
      }
    }),
    setup: function setup26(props2, _ref) {
      var slots = _ref.slots;
      var classPrefix = usePrefixClass();
      var isDisabled = useDisabled();
      var isReadonly2 = useReadonly();
      var renderTNodeJSX = useTNodeJSX();
      var COMPONENT_NAME = usePrefixClass("select");
      var _useConfig = useConfig("select"), globalConfig = _useConfig.globalConfig, t = _useConfig.t;
      var _toRefs = toRefs(props2), popupVisible = _toRefs.popupVisible, inputValue = _toRefs.inputValue, modelValue = _toRefs.modelValue, value = _toRefs.value;
      var _useDefaultValue = useDefaultValue(inputValue, props2.defaultInputValue, props2.onInputChange, "inputValue"), _useDefaultValue2 = _slicedToArray(_useDefaultValue, 2), innerInputValue = _useDefaultValue2[0], setInputValue = _useDefaultValue2[1];
      var _useVModel = useVModel(value, modelValue, props2.defaultValue, props2.onChange), _useVModel2 = _slicedToArray(_useVModel, 2), orgValue = _useVModel2[0], setOrgValue = _useVModel2[1];
      var selectPanelRef = ref(null);
      var selectInputRef = ref(null);
      var keys2 = computed(function () {
        var _props2$keys, _props2$keys2, _props2$keys3;
        return {
          label: ((_props2$keys = props2.keys) === null || _props2$keys === void 0 ? void 0 : _props2$keys.label) || "label",
          value: ((_props2$keys2 = props2.keys) === null || _props2$keys2 === void 0 ? void 0 : _props2$keys2.value) || "value",
          disabled: ((_props2$keys3 = props2.keys) === null || _props2$keys3 === void 0 ? void 0 : _props2$keys3.disabled) || "disabled"
        };
      });
      var _useSelectOptions = useSelectOptions(props2, keys2, innerInputValue), optionsMap = _useSelectOptions.optionsMap, optionsList = _useSelectOptions.optionsList, optionsCache = _useSelectOptions.optionsCache, displayOptions = _useSelectOptions.displayOptions, filterMethods = _useSelectOptions.filterMethods;
      var innerValue = computed(function () {
        if (orgValue.value === void 0) {
          return props2.multiple ? [] : void 0;
        }
        if (props2.valueType === "object") {
          return !props2.multiple ? orgValue.value[keys2.value.value] : orgValue.value.map(function (option) {
            return option[keys2.value.value];
          });
        }
        return orgValue.value;
      });
      var setInnerValue = function setInnerValue2(newVal, context) {
        if (props2.valueType === "object") {
          var _keys$value = keys2.value, value2 = _keys$value.value, label = _keys$value.label;
          var getOption = function getOption2(val) {
            if (val === void 0) {
              return void 0;
            }
            var option = optionsMap.value.get(val);
            return _defineProperty$1(_defineProperty$1({}, value2, get(option, value2)), label, get(option, label));
          };
          newVal = props2.multiple ? newVal.map(function (val) {
            return getOption(val);
          }) : getOption(newVal);
        }
        if (newVal === orgValue.value) return;
        if (props2.multiple && !props2.reserveKeyword) setInputValue("");
        setOrgValue(newVal, _objectSpread$2({
          selectedOptions: getSelectedOptions(newVal)
        }, context));
      };
      var _useDefaultValue3 = useDefaultValue(popupVisible, false, function (visible, context) {
        var _props2$onPopupVisibl;
        (_props2$onPopupVisibl = props2.onPopupVisibleChange) === null || _props2$onPopupVisibl === void 0 || _props2$onPopupVisibl.call(props2, visible, context);
      }, "popupVisible"), _useDefaultValue4 = _slicedToArray(_useDefaultValue3, 2), innerPopupVisible = _useDefaultValue4[0], setInnerPopupVisible = _useDefaultValue4[1];
      var placeholderText = computed(function () {
        var _ref3;
        return (_ref3 = !props2.multiple && innerPopupVisible.value && getSingleContent(innerValue.value, optionsMap) || props2.placeholder) !== null && _ref3 !== void 0 ? _ref3 : t(globalConfig.value.placeholder);
      });
      var displayText = computed(function () {
        return props2.multiple ? getMultipleContent(innerValue.value, optionsMap) : getSingleContent(innerValue.value, optionsMap);
      });
      var valueDisplayParams = computed(function () {
        var val = props2.multiple && isArray(innerValue.value) ? innerValue.value.map(function (value2) {
          var _optionsMap$value$get;
          return {
            value: value2,
            label: (_optionsMap$value$get = optionsMap.value.get(value2)) === null || _optionsMap$value$get === void 0 ? void 0 : _optionsMap$value$get.label
          };
        }) : innerValue.value;
        var params = {
          value: val,
          onClose: props2.multiple ? function (index) {
            return removeTag(index);
          } : function () {
          }
        };
        if (!props2.multiple) Object.assign(params, {
          label: displayText.value
        });
        if (props2.minCollapsedNum && props2.multiple) {
          var _val$slice;
          return _objectSpread$2(_objectSpread$2({}, params), {}, {
            displayValue: val === null || val === void 0 || (_val$slice = val.slice) === null || _val$slice === void 0 ? void 0 : _val$slice.call(val, 0, props2.minCollapsedNum)
          });
        }
        return params;
      });
      var isFilterable = computed(function () {
        return Boolean(props2.filterable || globalConfig.value.filterable || isFunction(props2.filter));
      });
      var isRemoteSearch = computed(function () {
        return Boolean((props2.filterable || globalConfig.value.filterable) && isFunction(props2.onSearch));
      });
      var removeTag = function removeTag2(index, context) {
        var _props2$onRemove;
        var _ref4 = context || {}, e = _ref4.e, _ref4$trigger = _ref4.trigger, trigger2 = _ref4$trigger === void 0 ? "tag-remove" : _ref4$trigger;
        e && e.stopPropagation();
        var selectValue = cloneDeep(innerValue.value);
        var value2 = selectValue[index];
        selectValue.splice(index, 1);
        if (trigger2 !== "clear") {
          setInnerValue(selectValue, {
            selectedOptions: getSelectedOptions(selectValue),
            trigger: trigger2,
            e
          });
        }
        (_props2$onRemove = props2.onRemove) === null || _props2$onRemove === void 0 || _props2$onRemove.call(props2, {
          value: value2,
          data: optionsMap.value.get(value2),
          e
        });
      };
      var handleCreate = function handleCreate2() {
        var _props2$onCreate;
        if (!innerInputValue.value) return;
        (_props2$onCreate = props2.onCreate) === null || _props2$onCreate === void 0 || _props2$onCreate.call(props2, innerInputValue.value);
        if (!innerPopupVisible.value) setInputValue("");
      };
      var popupContentRef = computed(function () {
        var _selectInputRef$value;
        return (_selectInputRef$value = selectInputRef.value) === null || _selectInputRef$value === void 0 ? void 0 : _selectInputRef$value.popupRef.getOverlay();
      });
      var optionalList = computed(function () {
        return optionsList.value.filter(function (item) {
          return !item.disabled && !item["check-all"] && !item.checkAll && filterMethods(item);
        });
      });
      var getSelectedOptions = function getSelectedOptions2() {
        var selectValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : innerValue.value;
        return optionsList.value.filter(function (option) {
          if (option.checkAll) return;
          if (isArray(selectValue)) return selectValue.includes(option.value);
          return selectValue === option.value;
        });
      };
      var _useKeyboardControl = useKeyboardControl({
        displayOptions,
        optionsList,
        innerPopupVisible,
        setInnerPopupVisible,
        selectPanelRef,
        isFilterable,
        isRemoteSearch,
        getSelectedOptions,
        setInnerValue,
        innerValue,
        popupContentRef,
        multiple: props2.multiple,
        max: props2.max
      }), hoverIndex = _useKeyboardControl.hoverIndex, virtualFilteredOptions = _useKeyboardControl.virtualFilteredOptions, handleKeyDown = _useKeyboardControl.handleKeyDown, filteredOptions = _useKeyboardControl.filteredOptions;
      var onCheckAllChange = function onCheckAllChange2(checked) {
        if (!props2.multiple) return;
        var value2 = keys2.value.value;
        var lockedValues = innerValue.value.filter(function (value3) {
          return optionsList.value.find(function (item) {
            return item.value === value3 && item.disabled;
          });
        });
        var activeValues = optionalList.value.map(function (option) {
          return option.value;
        });
        var formattedOrgValue = props2.valueType === "object" ? orgValue.value.map(function (v) {
          return get(v, value2);
        }) : orgValue.value;
        var values = checked ? _toConsumableArray(/* @__PURE__ */ new Set([].concat(_toConsumableArray(formattedOrgValue), _toConsumableArray(activeValues), _toConsumableArray(lockedValues)))) : _toConsumableArray(lockedValues);
        setInnerValue(values, {
          selectedOptions: getSelectedOptions(values),
          trigger: checked ? "check" : "clear"
        });
      };
      var intersectionLen = computed(function () {
        var values = optionalList.value.map(function (item) {
          return item.value;
        });
        var n = intersection(innerValue.value, values);
        return n.length;
      });
      var isCheckAll = computed(function () {
        return intersectionLen.value === optionalList.value.length;
      });
      var indeterminate = computed(function () {
        return !isCheckAll.value && intersectionLen.value !== 0;
      });
      var SelectProvider = computed(function () {
        return {
          max: props2.max,
          multiple: props2.multiple,
          hoverIndex: hoverIndex.value,
          selectValue: innerValue.value,
          reserveKeyword: props2.reserveKeyword,
          handleValueChange: setInnerValue,
          handlerInputChange: setInputValue,
          handlePopupVisibleChange: setInnerPopupVisible,
          handleCreate,
          size: props2.size,
          popupContentRef,
          indeterminate: indeterminate.value,
          isCheckAll: isCheckAll.value,
          onCheckAllChange,
          getSelectedOptions,
          displayOptions: displayOptions.value,
          emitBlur: handleOptionEmitBlur
        };
      });
      provide(selectInjectKey, SelectProvider);
      var checkValueInvalid = function checkValueInvalid2() {
        if (!props2.multiple && isArray(orgValue.value)) {
          setOrgValue(void 0, {
            selectedOptions: [],
            trigger: "default"
          });
        }
        if (props2.multiple && !isArray(orgValue.value)) {
          setOrgValue([], {
            selectedOptions: [],
            trigger: "default"
          });
        }
      };
      var handleSearch = debounce$1(function (value2, _ref5) {
        var _props2$onSearch;
        var e = _ref5.e;
        (_props2$onSearch = props2.onSearch) === null || _props2$onSearch === void 0 || _props2$onSearch.call(props2, "".concat(value2), {
          e
        });
      }, 300);
      var handlerInputChange = function handlerInputChange2(value2, context) {
        if (value2) {
          !innerPopupVisible.value && setInnerPopupVisible(true, {
            e: context.e
          });
        }
        setInputValue(value2);
        handleSearch("".concat(value2), {
          e: context.e
        });
        nextTick(function () {
          var _selectPanelRef$value, _selectPanelRef$value2;
          virtualFilteredOptions.value = (_selectPanelRef$value = selectPanelRef.value) === null || _selectPanelRef$value === void 0 ? void 0 : _selectPanelRef$value.visibleData;
          filteredOptions.value = (_selectPanelRef$value2 = selectPanelRef.value) === null || _selectPanelRef$value2 === void 0 ? void 0 : _selectPanelRef$value2.displayOptions;
        });
      };
      var handleOptionEmitBlur = function handleOptionEmitBlur2(e) {
        var _props2$onBlur;
        (_props2$onBlur = props2.onBlur) === null || _props2$onBlur === void 0 || _props2$onBlur.call(props2, {
          e,
          value: innerValue.value
        });
      };
      var handlerPopupVisibleChange = function handlerPopupVisibleChange2(visible, context) {
        setInnerPopupVisible(visible, context);
        if (visible && context.trigger === "trigger-element-click") setInputValue("");
      };
      var handlerPopupScrollToBottom = /* @__PURE__ */ function () {
        var _ref6 = _asyncToGenerator(/* @__PURE__ */ regenerator.mark(function _callee(context) {
          var _popupProps$onScroll, _popupProps$onScrollT;
          var popupProps2;
          return regenerator.wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                popupProps2 = props2.popupProps;
                if (!props2.loading) {
                  _context.next = 3;
                  break;
                }
                return _context.abrupt("return");
              case 3:
                popupProps2 === null || popupProps2 === void 0 || (_popupProps$onScroll = popupProps2["on-scroll-to-bottom"]) === null || _popupProps$onScroll === void 0 || _popupProps$onScroll.call(popupProps2, context);
                popupProps2 === null || popupProps2 === void 0 || (_popupProps$onScrollT = popupProps2.onScrollToBottom) === null || _popupProps$onScrollT === void 0 || _popupProps$onScrollT.call(popupProps2, context);
              case 5:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        return function handlerPopupScrollToBottom2(_x) {
          return _ref6.apply(this, arguments);
        };
      }();
      var addCache = function addCache2(val) {
        if (props2.multiple) {
          var newCache = [];
          var _iterator = _createForOfIteratorHelper(val || []), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var item = _step.value;
              var option = optionsMap.value.get(item);
              if (option) {
                newCache.push(option);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          optionsCache.value = Array.from(/* @__PURE__ */ new Set([].concat(newCache, _toConsumableArray(optionsCache.value))));
        } else {
          var _option = optionsMap.value.get(val);
          if (_option) {
            optionsCache.value = Array.from(/* @__PURE__ */ new Set([_option].concat(_toConsumableArray(optionsCache.value))));
          }
        }
      };
      watch(orgValue, function (val) {
        checkValueInvalid();
        nextTick(function () {
          addCache(val);
        });
      }, {
        immediate: true
      });
      watch(function () {
        return props2.multiple;
      }, function () {
        checkValueInvalid();
      });
      var updateScrollTop = function updateScrollTop2(content) {
        var _selectPanelRef$value3;
        if (!selectPanelRef.value) {
          return;
        }
        var firstSelectedNode = (_selectPanelRef$value3 = selectPanelRef.value) === null || _selectPanelRef$value3 === void 0 || (_selectPanelRef$value3 = _selectPanelRef$value3.innerRef) === null || _selectPanelRef$value3 === void 0 ? void 0 : _selectPanelRef$value3.querySelector(".".concat(classPrefix.value, "-is-selected"));
        nextTick(function () {
          if (firstSelectedNode && content) {
            var _getComputedStyle = getComputedStyle(firstSelectedNode), paddingBottom = _getComputedStyle.paddingBottom;
            var _getComputedStyle2 = getComputedStyle(content), marginBottom = _getComputedStyle2.marginBottom;
            var elementBottomHeight = parseInt(paddingBottom, 10) + parseInt(marginBottom, 10);
            var updateValue = firstSelectedNode.offsetTop - content.offsetTop - (content.clientHeight - firstSelectedNode.clientHeight) + elementBottomHeight;
            content.scrollTop = updateValue;
          }
        });
      };
      provide("updateScrollTop", updateScrollTop);
      return function () {
        var _ref7 = props2.popupProps || {}, overlayClassName = _ref7.overlayClassName, restPopupProps = _objectWithoutProperties(_ref7, _excluded$1);
        return createVNode("div", {
          "class": "".concat(COMPONENT_NAME.value, "__wrap")
        }, [createVNode(SelectInput, mergeProps({
          autoWidth: props2.autoWidth,
          readonly: isReadonly2.value,
          borderless: props2.borderless,
          multiple: props2.multiple,
          clearable: props2.clearable,
          loading: props2.loading,
          status: props2.status,
          tips: props2.tips,
          minCollapsedNum: props2.minCollapsedNum,
          autofocus: props2.autofocus,
          suffix: props2.suffix,
          valueDisplayOptions: props2.valueDisplayOptions
        }, {
          "ref": selectInputRef,
          "class": COMPONENT_NAME.value,
          "value": displayText.value,
          "disabled": isDisabled.value,
          "popupVisible": innerPopupVisible.value,
          "inputValue": innerPopupVisible.value ? innerInputValue.value : "",
          "placeholder": "".concat(placeholderText.value),
          "allowInput": isFilterable.value,
          "collapsed-items": props2.collapsedItems,
          "inputProps": _objectSpread$2(_objectSpread$2({
            size: props2.size,
            autofocus: props2.autofocus
          }, props2.inputProps), {}, {
            onkeydown: handleKeyDown
          }),
          "tagInputProps": _objectSpread$2({
            size: props2.size
          }, props2.tagInputProps),
          "onTagChange": function onTagChange(val, ctx) {
            removeTag(ctx.index, ctx);
          },
          "tagProps": _objectSpread$2({}, props2.tagProps),
          "popupProps": _objectSpread$2(_objectSpread$2({
            overlayClassName: ["".concat(COMPONENT_NAME.value, "__dropdown"), overlayClassName]
          }, restPopupProps), {}, {
            onScrollToBottom: handlerPopupScrollToBottom
          }),
          "label": props2.label,
          "prefixIcon": props2.prefixIcon,
          "suffix": props2.suffix,
          "suffixIcon": function suffixIcon() {
            if (props2.suffixIcon || slots.suffixIcon) {
              return renderTNodeJSX("suffixIcon");
            }
            return props2.showArrow && createVNode(FakeArrow, {
              "overlayClassName": "".concat(COMPONENT_NAME.value, "__right-icon"),
              "isActive": innerPopupVisible.value
            }, null);
          },
          "valueDisplay": function valueDisplay() {
            return renderTNodeJSX("valueDisplay", {
              params: valueDisplayParams.value
            });
          },
          "onPopupVisibleChange": handlerPopupVisibleChange,
          "onInputChange": handlerInputChange,
          "onClear": function onClear(_ref8) {
            var _props2$onClear;
            var e = _ref8.e;
            setInnerValue(props2.multiple ? [] : void 0, {
              option: null,
              selectedOptions: getSelectedOptions(props2.multiple ? [] : void 0),
              trigger: "clear",
              e
            });
            (_props2$onClear = props2.onClear) === null || _props2$onClear === void 0 || _props2$onClear.call(props2, {
              e
            });
          },
          "onEnter": function onEnter(inputValue2, _ref9) {
            var e = _ref9.e;
            setTimeout(function () {
              var _props2$onEnter;
              (_props2$onEnter = props2.onEnter) === null || _props2$onEnter === void 0 || _props2$onEnter.call(props2, {
                inputValue: "".concat(innerInputValue.value),
                e,
                value: innerValue.value
              });
              handleCreate();
            }, 0);
          },
          "onBlur": function onBlur(inputValue2, _ref10) {
            var _props2$onBlur2;
            var e = _ref10.e;
            (_props2$onBlur2 = props2.onBlur) === null || _props2$onBlur2 === void 0 || _props2$onBlur2.call(props2, {
              e,
              value: innerValue.value
            });
          },
          "onFocus": function onFocus(inputValue2, _ref11) {
            var _props2$onFocus;
            var e = _ref11.e;
            (_props2$onFocus = props2.onFocus) === null || _props2$onFocus === void 0 || _props2$onFocus.call(props2, {
              e,
              value: innerValue.value
            });
          }
        }, props2.selectInputProps), {
          label: slots.label,
          prefixIcon: slots.prefixIcon,
          suffix: slots.suffix,
          panel: function panel() {
            return createVNode(SelectPanel, mergeProps({
              "ref": selectPanelRef
            }, pick(props2, ["size", "multiple", "empty", "loading", "loadingText", "filterable", "creatable", "panelTopContent", "panelBottomContent", "filter", "scroll"]), {
              "inputValue": innerInputValue.value
            }), slots);
          },
          collapsedItems: slots.collapsedItems
        })]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var Select = withInstall(_Select);
  withInstall(_Option);
  withInstall(_OptionGroup);
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var hiddenTextarea;
  var HIDDEN_TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow-y:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important\n";
  var SIZING_PROPS = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing"];
  function calculateNodeStyling(targetElement) {
    if (typeof window === "undefined" || !targetElement) return;
    var style = window.getComputedStyle(targetElement);
    var boxSizing = style.getPropertyValue("box-sizing") || style.getPropertyValue("-moz-box-sizing") || style.getPropertyValue("-webkit-box-sizing");
    var paddingSize = parseFloat(style.getPropertyValue("padding-bottom")) + parseFloat(style.getPropertyValue("padding-top"));
    var borderSize = parseFloat(style.getPropertyValue("border-bottom-width")) + parseFloat(style.getPropertyValue("border-top-width"));
    var sizingStyle = SIZING_PROPS.map(function (name) {
      return "".concat(name, ":").concat(style.getPropertyValue(name));
    }).join(";");
    return {
      sizingStyle,
      paddingSize,
      borderSize,
      boxSizing
    };
  }
  function calcTextareaHeight(targetElement) {
    var minRows = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    var maxRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    if (!hiddenTextarea) {
      hiddenTextarea = document.createElement("textarea");
      document.body.appendChild(hiddenTextarea);
    }
    var _calculateNodeStyling = calculateNodeStyling(targetElement), paddingSize = _calculateNodeStyling.paddingSize, borderSize = _calculateNodeStyling.borderSize, boxSizing = _calculateNodeStyling.boxSizing, sizingStyle = _calculateNodeStyling.sizingStyle;
    hiddenTextarea.setAttribute("style", "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
    hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
    var height = hiddenTextarea.scrollHeight;
    var result = {};
    if (boxSizing === "border-box") {
      height += borderSize;
    } else if (boxSizing === "content-box") {
      height -= paddingSize;
    }
    hiddenTextarea.value = "";
    var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
    if (minRows !== null) {
      var minHeight = singleRowHeight * minRows;
      if (boxSizing === "border-box") {
        minHeight = minHeight + paddingSize + borderSize;
      }
      height = Math.max(minHeight, height);
      result.minHeight = "".concat(minHeight, "px");
    }
    if (maxRows !== null) {
      var maxHeight = singleRowHeight * maxRows;
      if (boxSizing === "border-box") {
        maxHeight = maxHeight + paddingSize + borderSize;
      }
      height = Math.min(maxHeight, height);
    }
    result.height = "".concat(height, "px");
    hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);
    hiddenTextarea = null;
    return result;
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var props$1 = {
    allowInputOverMax: Boolean,
    autofocus: Boolean,
    autosize: {
      type: [Boolean, Object],
      "default": false
    },
    disabled: {
      type: Boolean,
      "default": void 0
    },
    maxcharacter: {
      type: Number
    },
    maxlength: {
      type: [String, Number]
    },
    name: {
      type: String,
      "default": ""
    },
    placeholder: {
      type: String,
      "default": void 0
    },
    readonly: {
      type: Boolean,
      "default": void 0
    },
    status: {
      type: String,
      "default": "default",
      validator: function validator29(val) {
        if (!val) return true;
        return ["default", "success", "warning", "error"].includes(val);
      }
    },
    tips: {
      type: [String, Function]
    },
    value: {
      type: [String, Number],
      "default": void 0
    },
    modelValue: {
      type: [String, Number],
      "default": void 0
    },
    defaultValue: {
      type: [String, Number]
    },
    onBlur: Function,
    onChange: Function,
    onFocus: Function,
    onKeydown: Function,
    onKeypress: Function,
    onKeyup: Function,
    onValidate: Function
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var _Textarea = /* @__PURE__ */ defineComponent({
    name: "TTextarea",
    inheritAttrs: false,
    props: props$1,
    setup: function setup27(props2, _ref) {
      var attrs = _ref.attrs, expose = _ref.expose;
      var prefix = usePrefixClass();
      var name = usePrefixClass("textarea");
      var TEXTAREA_TIPS_CLASS = computed(function () {
        return "".concat(name.value, "__tips");
      });
      var TEXTAREA_LIMIT = computed(function () {
        return "".concat(name.value, "__limit");
      });
      var _toRefs = toRefs(props2), value = _toRefs.value, modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props2.defaultValue, props2.onChange), _useVModel2 = _slicedToArray(_useVModel, 2), innerValue = _useVModel2[0], setInnerValue = _useVModel2[1];
      var disabled = useDisabled();
      var isReadonly2 = useReadonly();
      var textareaStyle = ref({});
      var refTextareaElem = ref();
      var focused = ref(false);
      var isComposing = ref(false);
      var focus = function focus2() {
        var _refTextareaElem$valu;
        return (_refTextareaElem$valu = refTextareaElem.value) === null || _refTextareaElem$valu === void 0 ? void 0 : _refTextareaElem$valu.focus();
      };
      var blur = function blur2() {
        var _refTextareaElem$valu2;
        return (_refTextareaElem$valu2 = refTextareaElem.value) === null || _refTextareaElem$valu2 === void 0 ? void 0 : _refTextareaElem$valu2.blur();
      };
      var adjustTextareaHeight = function adjustTextareaHeight2() {
        var _refTextareaElem$valu3;
        if (props2.autosize === true) {
          textareaStyle.value = calcTextareaHeight(refTextareaElem.value);
        } else if (props2.autosize && _typeof$2(props2.autosize) === "object") {
          var _props2$autosize = props2.autosize, minRows = _props2$autosize.minRows, maxRows = _props2$autosize.maxRows;
          textareaStyle.value = calcTextareaHeight(refTextareaElem.value, minRows, maxRows);
        } else if (attrs.rows) {
          textareaStyle.value = {
            height: "auto",
            minHeight: "auto"
          };
        } else if (attrs.style && (_refTextareaElem$valu3 = refTextareaElem.value) !== null && _refTextareaElem$valu3 !== void 0 && (_refTextareaElem$valu3 = _refTextareaElem$valu3.style) !== null && _refTextareaElem$valu3 !== void 0 && _refTextareaElem$valu3.height) {
          textareaStyle.value = {
            height: refTextareaElem.value.style.height
          };
        }
      };
      var setInputValue = function setInputValue2() {
        var v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        var textareaElem = refTextareaElem.value;
        var sV = String(v);
        if (!textareaElem) {
          return;
        }
        if (textareaElem.value !== sV) {
          textareaElem.value = sV;
          innerValue.value = sV;
        }
      };
      var inputValueChangeHandle = function inputValueChangeHandle2(e) {
        var target = e.target;
        var val = target.value;
        if (props2.maxcharacter && props2.maxcharacter >= 0) {
          var stringInfo = getCharacterLength(val, props2.maxcharacter);
          val = _typeof$2(stringInfo) === "object" && stringInfo.characters;
        }
        !isComposing.value && setInnerValue(val, {
          e
        });
        nextTick(function () {
          return setInputValue(val);
        });
        adjustTextareaHeight();
      };
      var handleInput = function handleInput2(e) {
        inputValueChangeHandle(e);
      };
      var onCompositionstart = function onCompositionstart2() {
        isComposing.value = true;
      };
      var onCompositionend = function onCompositionend2(e) {
        isComposing.value = false;
        inputValueChangeHandle(e);
      };
      var eventDeal = function eventDeal2(name2, e) {
        var _props2$eventName;
        if (disabled.value) return;
        var eventName = "on".concat(name2[0].toUpperCase()).concat(name2.slice(1));
        (_props2$eventName = props2[eventName]) === null || _props2$eventName === void 0 || _props2$eventName.call(props2, innerValue.value, {
          e
        });
      };
      var emitKeyDown = function emitKeyDown2(e) {
        eventDeal("keydown", e);
      };
      var emitKeyUp = function emitKeyUp2(e) {
        eventDeal("keyup", e);
      };
      var emitKeypress = function emitKeypress2(e) {
        eventDeal("keypress", e);
      };
      var emitFocus = function emitFocus2(e) {
        var _props2$onFocus;
        adjustTextareaHeight();
        if (disabled.value) return;
        focused.value = true;
        (_props2$onFocus = props2.onFocus) === null || _props2$onFocus === void 0 || _props2$onFocus.call(props2, innerValue.value, {
          e
        });
      };
      var formItem = inject(FormItemInjectionKey, void 0);
      var emitBlur = function emitBlur2(e) {
        var _props2$onBlur;
        if (!e.target) return;
        adjustTextareaHeight();
        focused.value = false;
        (_props2$onBlur = props2.onBlur) === null || _props2$onBlur === void 0 || _props2$onBlur.call(props2, innerValue.value, {
          e
        });
        formItem === null || formItem === void 0 || formItem.handleBlur();
      };
      var textareaClasses = computed(function () {
        return [name.value, _defineProperty$1(_defineProperty$1({}, "".concat(prefix.value, "-is-disabled"), disabled.value), "".concat(prefix.value, "-is-readonly"), isReadonly2.value)];
      });
      var inputAttrs = computed(function () {
        return getValidAttrs({
          autofocus: props2.autofocus,
          disabled: disabled.value,
          readonly: isReadonly2.value,
          placeholder: props2.placeholder,
          maxlength: !props2.allowInputOverMax && props2.maxlength || void 0,
          name: props2.name || void 0
        });
      });
      var characterNumber = computed(function () {
        var characterInfo = getCharacterLength(String(innerValue.value || ""));
        if (_typeof$2(characterInfo) === "object") {
          return characterInfo.length;
        }
        return characterInfo;
      });
      var limitParams = computed(function () {
        return {
          value: [void 0, null].includes(innerValue.value) ? void 0 : String(innerValue.value),
          status: props2.status,
          maxlength: Number(props2.maxlength),
          maxcharacter: props2.maxcharacter,
          allowInputOverMax: props2.allowInputOverMax,
          onValidate: props2.onValidate
        };
      });
      var _useLengthLimit = useLengthLimit(limitParams), tStatus = _useLengthLimit.tStatus;
      watch(function () {
        return innerValue.value;
      }, function () {
        return adjustTextareaHeight();
      });
      watch(refTextareaElem, function (el) {
        if (!el) return;
        adjustTextareaHeight();
      });
      watch(function () {
        return props2.autofocus;
      }, function (val) {
        if (val) {
          refTextareaElem.value.focus();
        }
      });
      watch(textareaStyle, function (val) {
        var style = attrs.style;
        if (isObject(style)) {
          setStyle(refTextareaElem.value, merge(style, val));
        } else {
          setStyle(refTextareaElem.value, val);
        }
      });
      watch(innerValue, function () {
        nextTick(function () {
          return adjustTextareaHeight();
        });
      });
      watch(function () {
        return props2.autosize;
      }, adjustTextareaHeight, {
        deep: true
      });
      expose({
        focus,
        blur
      });
      onMounted(function () {
        adjustTextareaHeight();
      });
      var renderTNodeJSX = useTNodeJSX();
      return function () {
        var _String;
        var inputEvents = getValidAttrs({
          onFocus: emitFocus,
          onBlur: emitBlur,
          onKeydown: emitKeyDown,
          onKeyup: emitKeyUp,
          onKeypress: emitKeypress
        });
        var _useCommonClassName = useCommonClassName$1(), STATUS = _useCommonClassName.STATUS;
        var classes = computed(function () {
          return ["".concat(name.value, "__inner"), _defineProperty$1(_defineProperty$1(_defineProperty$1(_defineProperty$1({}, "".concat(prefix.value, "-is-").concat(tStatus.value), tStatus.value), STATUS.value.disabled, disabled.value), STATUS.value.focused, focused.value), "".concat(prefix.value, "-resize-none"), _typeof$2(props2.autosize) === "object"), "narrow-scrollbar"];
        });
        var tips = renderTNodeJSX("tips");
        var textTips = tips && createVNode("div", {
          "class": "".concat(TEXTAREA_TIPS_CLASS.value, " ").concat(name.value, "__tips--").concat(props2.status || "normal")
        }, [tips]);
        var limitText = props2.maxcharacter && createVNode("span", {
          "class": TEXTAREA_LIMIT.value
        }, ["".concat(characterNumber.value, "/").concat(props2.maxcharacter)]) || !props2.maxcharacter && props2.maxlength && createVNode("span", {
          "class": TEXTAREA_LIMIT.value
        }, ["".concat(innerValue.value ? (_String = String(innerValue.value)) === null || _String === void 0 ? void 0 : _String.length : 0, "/").concat(props2.maxlength)]);
        return createVNode("div", mergeProps({
          "class": textareaClasses.value
        }, omit(attrs, ["style"])), [createVNode("textarea", mergeProps({
          "onInput": handleInput,
          "onCompositionstart": onCompositionstart,
          "onCompositionend": onCompositionend,
          "ref": refTextareaElem,
          "value": innerValue.value,
          "class": classes.value
        }, inputEvents, inputAttrs.value), null), textTips || limitText ? createVNode("div", {
          "class": ["".concat(name.value, "__info_wrapper"), _defineProperty$1({}, "".concat(name.value, "__info_wrapper_align"), !textTips)]
        }, [textTips, limitText]) : null]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var Textarea = withInstall(_Textarea);
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var POPUP_BASE_Z_INDEX = 1e3;
  var MESSAGE_BASE_Z_INDEX = 5e3;
  var Z_INDEX_STEP = 1;
  var PopupManager = /* @__PURE__ */ _createClass(function PopupManager2() {
    var _this = this;
    _classCallCheck(this, PopupManager2);
    _defineProperty$1(this, "popupStack", {
      popup: /* @__PURE__ */ new Set(),
      dialog: /* @__PURE__ */ new Set(),
      message: /* @__PURE__ */ new Set()
    });
    _defineProperty$1(this, "getNextZIndex", function (type) {
      var current = type === "message" ? Array.from(_this.popupStack.message).pop() || MESSAGE_BASE_Z_INDEX : Array.from(_this.popupStack.popup).pop() || POPUP_BASE_Z_INDEX;
      return current + Z_INDEX_STEP;
    });
    _defineProperty$1(this, "add", function (type) {
      var zIndex = _this.getNextZIndex(type);
      _this.popupStack[type].add(zIndex);
      if (type === "dialog") {
        _this.popupStack.popup.add(zIndex);
      }
      return zIndex;
    });
    _defineProperty$1(this, "delete", function (zIndex, type) {
      _this.popupStack[type]["delete"](zIndex);
      if (type === "dialog") {
        _this.popupStack.popup["delete"](zIndex);
      }
    });
    _defineProperty$1(this, "isLastDialog", function (zIndex) {
      if (_this.popupStack.dialog.size > 1) {
        return zIndex === Array.from(_this.popupStack.dialog).pop();
      }
      return true;
    });
  });
  var popupManager = new PopupManager();
  function usePopupManager(type) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, visible = _ref.visible, runOnMounted = _ref.runOnMounted;
    var zIndex = ref(0);
    var open = function open2() {
      zIndex.value = popupManager.add(type);
    };
    var close2 = function close3() {
      popupManager["delete"](zIndex.value, type);
    };
    var isLastDialog = function isLastDialog2() {
      {
        return popupManager.isLastDialog(zIndex.value);
      }
    };
    watch(function () {
      return visible === null || visible === void 0 ? void 0 : visible.value;
    }, function (visible2) {
      if (visible2) {
        open();
      } else {
        close2();
      }
    }, {
      immediate: true
    });
    if (runOnMounted) {
      onMounted(function () {
        open();
      });
      onBeforeUnmount(function () {
        close2();
      });
    }
    return {
      zIndex: readonly(zIndex),
      open,
      close: close2,
      isLastDialog
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var props = {
    attach: {
      type: [String, Function]
    },
    body: {
      type: [String, Function]
    },
    cancelBtn: {
      type: [String, Object, Function, null]
    },
    closeBtn: {
      type: [String, Boolean, Function],
      "default": true
    },
    closeOnEscKeydown: {
      type: Boolean,
      "default": void 0
    },
    closeOnOverlayClick: {
      type: Boolean,
      "default": void 0
    },
    confirmBtn: {
      type: [String, Object, Function, null]
    },
    confirmLoading: {
      type: Boolean,
      "default": void 0
    },
    confirmOnEnter: Boolean,
    "default": {
      type: [String, Function]
    },
    destroyOnClose: Boolean,
    dialogClassName: {
      type: String,
      "default": ""
    },
    dialogStyle: {
      type: Object
    },
    draggable: Boolean,
    footer: {
      type: [Boolean, Function],
      "default": true
    },
    header: {
      type: [String, Boolean, Function],
      "default": true
    },
    mode: {
      type: String,
      "default": "modal",
      validator: function validator30(val) {
        if (!val) return true;
        return ["modal", "modeless", "normal", "full-screen"].includes(val);
      }
    },
    placement: {
      type: String,
      "default": "top",
      validator: function validator31(val) {
        if (!val) return true;
        return ["top", "center"].includes(val);
      }
    },
    preventScrollThrough: {
      type: Boolean,
      "default": true
    },
    showInAttachedElement: Boolean,
    showOverlay: {
      type: Boolean,
      "default": true
    },
    theme: {
      type: String,
      "default": "default",
      validator: function validator32(val) {
        if (!val) return true;
        return ["default", "info", "warning", "danger", "success"].includes(val);
      }
    },
    top: {
      type: [String, Number]
    },
    visible: Boolean,
    width: {
      type: [String, Number]
    },
    zIndex: {
      type: Number
    },
    onBeforeClose: Function,
    onBeforeOpen: Function,
    onCancel: Function,
    onClose: Function,
    onCloseBtnClick: Function,
    onClosed: Function,
    onConfirm: Function,
    onEscKeydown: Function,
    onOpened: Function,
    onOverlayClick: Function
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function ownKeys$1(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread$1(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys$1(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function useAction(action) {
    var instance = getCurrentInstance();
    var renderTNodeJSX = useTNodeJSX();
    var getDefaultConfirmBtnProps = function getDefaultConfirmBtnProps2(options) {
      var globalConfirm = options.globalConfirm, theme = options.theme, globalConfirmBtnTheme = options.globalConfirmBtnTheme;
      var defaultTheme = getPropertyValFromObj(omit(globalConfirmBtnTheme, ["info"]), theme) || "primary";
      var props2 = {
        theme: defaultTheme,
        size: options.size,
        onClick: function onClick(e) {
          action.confirmBtnAction(e);
        }
      };
      if (isString(globalConfirm)) {
        props2.content = globalConfirm;
      } else if (isObject(globalConfirm)) {
        props2 = _objectSpread$1(_objectSpread$1({}, props2), globalConfirm);
      }
      return props2;
    };
    var getDefaultCancelBtnProps = function getDefaultCancelBtnProps2(options) {
      var globalCancel = options.globalCancel;
      var props2 = {
        theme: "default",
        size: options.size,
        onClick: function onClick(e) {
          action.cancelBtnAction(e);
        }
      };
      if (isString(globalCancel)) {
        props2.content = globalCancel;
      } else if (isObject(globalCancel)) {
        props2 = _objectSpread$1(_objectSpread$1({}, props2), globalCancel);
      }
      return props2;
    };
    var getButtonByProps = function getButtonByProps2(button, params) {
      var defaultButtonProps = params.defaultButtonProps, className = params.className, confirmLoading = params.confirmLoading;
      var newOptions = defaultButtonProps;
      if (isString(button)) {
        newOptions.content = button;
      } else if (isObject(button)) {
        newOptions = _objectSpread$1(_objectSpread$1({}, newOptions), button);
      }
      if (confirmLoading !== void 0) {
        newOptions.loading = confirmLoading;
      }
      return createVNode(Button, mergeProps({
        "class": className
      }, newOptions), null);
    };
    var getConfirmBtn = function getConfirmBtn2(options) {
      var confirmBtn = options.confirmBtn, className = options.className, confirmLoading = options.confirmLoading;
      if (confirmBtn === null) return null;
      if (confirmBtn && instance.slots.confirmBtn) {
        console.warn("Both $props.confirmBtn and $scopedSlots.confirmBtn exist, $props.confirmBtn is preferred.");
      }
      var defaultButtonProps = getDefaultConfirmBtnProps(options);
      if (!confirmBtn && !instance.slots.confirmBtn) {
        return createVNode(Button, mergeProps({
          "class": className,
          "loading": confirmLoading
        }, defaultButtonProps), null);
      }
      if (confirmBtn && ["string", "object"].includes(_typeof$2(confirmBtn))) {
        return getButtonByProps(confirmBtn, {
          defaultButtonProps,
          className,
          confirmLoading
        });
      }
      return renderTNodeJSX("confirmBtn");
    };
    var getCancelBtn = function getCancelBtn2(options) {
      var cancelBtn = options.cancelBtn, className = options.className;
      if (cancelBtn === null) return null;
      if (cancelBtn && instance.slots.cancelBtn) {
        console.warn("Both $props.cancelBtn and $scopedSlots.cancelBtn exist, $props.cancelBtn is preferred.");
      }
      var defaultButtonProps = getDefaultCancelBtnProps(options);
      if (!cancelBtn && !instance.slots.cancelBtn) {
        return createVNode(Button, mergeProps({
          "class": className
        }, defaultButtonProps), null);
      }
      if (cancelBtn && ["string", "object"].includes(_typeof$2(cancelBtn))) {
        return getButtonByProps(cancelBtn, {
          defaultButtonProps,
          className
        });
      }
      return renderTNodeJSX("cancelBtn");
    };
    return {
      getConfirmBtn,
      getCancelBtn
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function useSameTarget(handleClick) {
    var MOUSEDOWN_TARGET = false;
    var MOUSEUP_TARGET = false;
    var onClick = function onClick2(e) {
      if (MOUSEDOWN_TARGET && MOUSEUP_TARGET) {
        handleClick(e);
      }
      MOUSEDOWN_TARGET = false;
      MOUSEUP_TARGET = false;
    };
    var onMousedown = function onMousedown2(e) {
      MOUSEDOWN_TARGET = e.target === e.currentTarget;
    };
    var onMouseup = function onMouseup2(e) {
      MOUSEUP_TARGET = e.target === e.currentTarget;
    };
    return {
      onClick,
      onMousedown,
      onMouseup
    };
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function getScrollbarWidth() {
    var container = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document.body;
    if (container === document.body) {
      return window.innerWidth - document.documentElement.clientWidth;
    }
    return container.offsetWidth - container.clientWidth;
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function getCSSValue(v) {
    return Number.isNaN(Number(v)) ? v : "".concat(Number(v), "px");
  }
  function initDragEvent(dragBox) {
    var target = dragBox;
    var windowInnerWidth = window.innerWidth || document.documentElement.clientWidth;
    var windowInnerHeight = window.innerHeight || document.documentElement.clientHeight;
    target.addEventListener("mousedown", function (targetEvent) {
      var disX = targetEvent.clientX - target.offsetLeft;
      var disY = targetEvent.clientY - target.offsetTop;
      var dialogW = target.offsetWidth;
      var dialogH = target.offsetHeight;
      if (dialogW > windowInnerWidth || dialogH > windowInnerHeight) return;
      function mouseMoverHandler(documentEvent) {
        var left2 = documentEvent.clientX - disX;
        var top2 = documentEvent.clientY - disY;
        if (left2 < 0) left2 = 0;
        if (top2 < 0) top2 = 0;
        if (windowInnerWidth - target.offsetWidth - left2 < 0) left2 = windowInnerWidth - target.offsetWidth;
        if (windowInnerHeight - target.offsetHeight - top2 < 0) top2 = windowInnerHeight - target.offsetHeight;
        target.style.position = "absolute";
        target.style.left = "".concat(left2, "px");
        target.style.top = "".concat(top2, "px");
      }
      function mouseUpHandler() {
        document.removeEventListener("mousemove", mouseMoverHandler);
        document.removeEventListener("mouseup", mouseUpHandler);
      }
      document.addEventListener("mousemove", mouseMoverHandler);
      document.addEventListener("mouseup", mouseUpHandler);
      document.addEventListener("dragend", mouseUpHandler);
    });
  }
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var dialogCardProps = {
    body: {
      type: [String, Function]
    },
    cancelBtn: {
      type: [String, Object, Function]
    },
    closeBtn: {
      type: [String, Boolean, Function],
      "default": true
    },
    confirmBtn: {
      type: [String, Object, Function]
    },
    confirmLoading: {
      type: Boolean,
      "default": void 0
    },
    footer: {
      type: [Boolean, Function]
    },
    header: {
      type: [String, Boolean, Function],
      "default": true
    },
    theme: {
      type: String,
      "default": "default",
      validator: function validator33(val) {
        if (!val) return true;
        return ["default", "info", "warning", "danger", "success"].includes(val);
      }
    },
    onCancel: Function,
    onCloseBtnClick: Function,
    onConfirm: Function
  };
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), true).forEach(function (r2) {
        _defineProperty$1(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  var _DialogCard = /* @__PURE__ */ defineComponent({
    name: "TDialogCard",
    directives: {
      draggable: function draggable(el, binding) {
        if (el && binding && binding.value) {
          initDragEvent(el);
        }
      }
    },
    props: _objectSpread(_objectSpread({}, props), dialogCardProps),
    setup: function setup28(props2, _ref) {
      var expose = _ref.expose;
      var rootRef = ref(null);
      var COMPONENT_NAME = usePrefixClass("dialog");
      var classPrefix = usePrefixClass();
      var renderTNodeJSX = useTNodeJSX();
      var renderContent = useContent();
      var _useConfig = useConfig("dialog"), globalConfig = _useConfig.globalConfig;
      var _useGlobalIcon = useGlobalIcon({
        CloseIcon: close,
        InfoCircleFilledIcon: infoCircleFilled,
        CheckCircleFilledIcon: checkCircleFilled,
        ErrorCircleFilledIcon: errorCircleFilled
      }), CloseIcon$1 = _useGlobalIcon.CloseIcon, InfoCircleFilledIcon$1 = _useGlobalIcon.InfoCircleFilledIcon, CheckCircleFilledIcon$1 = _useGlobalIcon.CheckCircleFilledIcon, ErrorCircleFilledIcon$1 = _useGlobalIcon.ErrorCircleFilledIcon;
      var _toRefs = toRefs(props2), cancelBtn = _toRefs.cancelBtn, confirmBtn = _toRefs.confirmBtn, confirmLoading = _toRefs.confirmLoading;
      var confirmBtnAction = function confirmBtnAction2(e) {
        var _props$onConfirm;
        return (_props$onConfirm = props2.onConfirm) === null || _props$onConfirm === void 0 ? void 0 : _props$onConfirm.call(props2, {
          e
        });
      };
      var cancelBtnAction = function cancelBtnAction2(e) {
        var _props$onCancel;
        return (_props$onCancel = props2.onCancel) === null || _props$onCancel === void 0 ? void 0 : _props$onCancel.call(props2, {
          e
        });
      };
      var _useAction = useAction({
        confirmBtnAction,
        cancelBtnAction
      }), getConfirmBtn = _useAction.getConfirmBtn, getCancelBtn = _useAction.getCancelBtn;
      var isModeLess = computed(function () {
        return props2.mode === "modeless";
      });
      var isFullScreen = computed(function () {
        return props2.mode === "full-screen";
      });
      var closeBtnAction = function closeBtnAction2(e) {
        var _props$onCloseBtnClic;
        return props2 === null || props2 === void 0 || (_props$onCloseBtnClic = props2.onCloseBtnClick) === null || _props$onCloseBtnClic === void 0 ? void 0 : _props$onCloseBtnClic.call(props2, {
          e
        });
      };
      var onStopDown = function onStopDown2(e) {
        if (isModeLess.value && props2 !== null && props2 !== void 0 && props2.draggable) e.stopPropagation();
      };
      var resetPosition = function resetPosition2() {
        if (!rootRef.value && isModeLess.value && props2.draggable) return;
        rootRef.value.style.position = "relative";
        rootRef.value.style.left = "unset";
        rootRef.value.style.top = "unset";
      };
      expose({
        $el: rootRef,
        resetPosition
      });
      var dialogClass = computed(function () {
        var dialogClass2 = ["".concat(COMPONENT_NAME.value), "".concat(COMPONENT_NAME.value, "__modal-").concat(props2.theme), isModeLess.value && props2.draggable && "".concat(COMPONENT_NAME.value, "--draggable"), props2.dialogClassName];
        if (isFullScreen.value) {
          dialogClass2.push("".concat(COMPONENT_NAME.value, "__fullscreen"));
        } else {
          dialogClass2.push.apply(dialogClass2, ["".concat(COMPONENT_NAME.value, "--default"), "".concat(COMPONENT_NAME.value, "--").concat(props2.placement)]);
        }
        return dialogClass2;
      });
      var dialogStyle = computed(function () {
        return !isFullScreen.value ? _objectSpread({
          width: getCSSValue(props2.width)
        }, props2.dialogStyle) : _objectSpread({}, props2.dialogStyle);
      });
      var renderCard = function renderCard2() {
        var confirmBtnLoading = computed(function () {
          var _confirmBtn$value;
          return ((_confirmBtn$value = confirmBtn.value) === null || _confirmBtn$value === void 0 ? void 0 : _confirmBtn$value.loading) || confirmLoading.value;
        });
        var defaultFooter = createVNode("div", null, [getCancelBtn({
          cancelBtn: cancelBtn.value,
          globalCancel: globalConfig.value.cancel,
          className: "".concat(COMPONENT_NAME.value, "__cancel")
        }), getConfirmBtn({
          theme: props2 === null || props2 === void 0 ? void 0 : props2.theme,
          confirmBtn: confirmBtn.value,
          globalConfirm: globalConfig.value.confirm,
          globalConfirmBtnTheme: globalConfig.value.confirmBtnTheme,
          className: "".concat(COMPONENT_NAME.value, "__confirm"),
          confirmLoading: confirmBtnLoading.value
        })]);
        var footerContent = renderTNodeJSX("footer", defaultFooter);
        var renderHeader = function renderHeader2() {
          var _renderTNodeJSX;
          var header = (_renderTNodeJSX = renderTNodeJSX("header", createVNode("h5", {
            "class": "title"
          }, null))) !== null && _renderTNodeJSX !== void 0 ? _renderTNodeJSX : false;
          var headerClassName = isFullScreen.value ? ["".concat(COMPONENT_NAME.value, "__header"), "".concat(COMPONENT_NAME.value, "__header--fullscreen")] : "".concat(COMPONENT_NAME.value, "__header");
          var closeClassName = isFullScreen.value ? ["".concat(COMPONENT_NAME.value, "__close"), "".concat(COMPONENT_NAME.value, "__close--fullscreen")] : "".concat(COMPONENT_NAME.value, "__close");
          var getIcon = function getIcon2() {
            var icon = {
              info: createVNode(InfoCircleFilledIcon$1, {
                "class": "".concat(classPrefix.value, "-is-info")
              }, null),
              warning: createVNode(ErrorCircleFilledIcon$1, {
                "class": "".concat(classPrefix.value, "-is-warning")
              }, null),
              danger: createVNode(ErrorCircleFilledIcon$1, {
                "class": "".concat(classPrefix.value, "-is-error")
              }, null),
              success: createVNode(CheckCircleFilledIcon$1, {
                "class": "".concat(classPrefix.value, "-is-success")
              }, null)
            };
            return icon[props2 === null || props2 === void 0 ? void 0 : props2.theme];
          };
          return (header || (props2 === null || props2 === void 0 ? void 0 : props2.closeBtn)) && createVNode("div", {
            "class": headerClassName,
            "onMousedown": onStopDown
          }, [createVNode("div", {
            "class": "".concat(COMPONENT_NAME.value, "__header-content")
          }, [getIcon(), header]), props2 !== null && props2 !== void 0 && props2.closeBtn ? createVNode("span", {
            "class": closeClassName,
            "onClick": closeBtnAction
          }, [renderTNodeJSX("closeBtn", createVNode(CloseIcon$1, null, null))]) : null]);
        };
        var renderBody = function renderBody2() {
          var body = renderContent("default", "body");
          var bodyClassName = (props2 === null || props2 === void 0 ? void 0 : props2.theme) === "default" ? ["".concat(COMPONENT_NAME.value, "__body")] : ["".concat(COMPONENT_NAME.value, "__body__icon")];
          if (isFullScreen.value && footerContent) {
            bodyClassName.push("".concat(COMPONENT_NAME.value, "__body--fullscreen"));
          } else if (isFullScreen.value) {
            bodyClassName.push("".concat(COMPONENT_NAME.value, "__body--fullscreen--without-footer"));
          }
          return createVNode("div", {
            "class": bodyClassName,
            "onMousedown": onStopDown
          }, [body]);
        };
        var renderFooter = function renderFooter2() {
          var footerClassName = isFullScreen.value ? ["".concat(COMPONENT_NAME.value, "__footer"), "".concat(COMPONENT_NAME.value, "__footer--fullscreen")] : "".concat(COMPONENT_NAME.value, "__footer");
          return footerContent && createVNode("div", {
            "class": footerClassName,
            "onMousedown": onStopDown
          }, [footerContent]);
        };
        return createVNode(Fragment, null, [renderHeader(), renderBody(), !!props2.footer && renderFooter()]);
      };
      return function () {
        return withDirectives(createVNode("div", {
          "key": "dialog",
          "ref": rootRef,
          "class": dialogClass.value,
          "style": dialogStyle.value
        }, [renderCard()]), [[resolveDirective("draggable"), isModeLess.value && props2.draggable]]);
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var _excluded = ["theme", "onConfirm", "onCancel", "onCloseBtnClick"];
  var mousePosition;
  var getClickPosition = function getClickPosition2(e) {
    mousePosition = {
      x: e.clientX,
      y: e.clientY
    };
    setTimeout(function () {
      mousePosition = null;
    }, 100);
  };
  if (typeof window !== "undefined" && window.document && window.document.documentElement) {
    document.documentElement.addEventListener("click", getClickPosition, true);
  }
  var key = 1;
  var _Dialog = /* @__PURE__ */ defineComponent({
    name: "TDialog",
    inheritAttrs: false,
    props,
    emits: ["update:visible"],
    setup: function setup29(props2, context) {
      var COMPONENT_NAME = usePrefixClass("dialog");
      var classPrefix = usePrefixClass();
      var dialogCardRef = ref(null);
      var _useConfig = useConfig("dialog"), globalConfig = _useConfig.globalConfig;
      var confirmBtnAction = function confirmBtnAction2(context2) {
        var _props2$onConfirm;
        (_props2$onConfirm = props2.onConfirm) === null || _props2$onConfirm === void 0 || _props2$onConfirm.call(props2, context2);
      };
      var cancelBtnAction = function cancelBtnAction2(context2) {
        var _props2$onCancel;
        (_props2$onCancel = props2.onCancel) === null || _props2$onCancel === void 0 || _props2$onCancel.call(props2, context2);
        emitCloseEvent({
          e: context2.e,
          trigger: "cancel"
        });
      };
      var teleportElement = useTeleport(function () {
        return props2.attach;
      });
      useDestroyOnClose();
      var timer = ref();
      var styleEl = ref();
      var isModal = computed(function () {
        return props2.mode === "modal";
      });
      var isModeLess = computed(function () {
        return props2.mode === "modeless";
      });
      var isFullScreen = computed(function () {
        return props2.mode === "full-screen";
      });
      var computedVisible = computed(function () {
        return props2.visible;
      });
      var maskClass = computed(function () {
        return ["".concat(COMPONENT_NAME.value, "__mask"), !props2.showOverlay && "".concat(classPrefix.value, "-is-hidden")];
      });
      var positionClass = computed(function () {
        if (isFullScreen.value) return ["".concat(COMPONENT_NAME.value, "__position_fullscreen")];
        if (isModal.value || isModeLess.value) {
          return ["".concat(COMPONENT_NAME.value, "__position"), !!props2.top && "".concat(COMPONENT_NAME.value, "--top"), "".concat(props2.placement && !props2.top ? "".concat(COMPONENT_NAME.value, "--").concat(props2.placement) : "")];
        }
        return [];
      });
      var wrapClass = computed(function () {
        return isFullScreen.value || isModal.value || isModeLess.value ? ["".concat(COMPONENT_NAME.value, "__wrap")] : null;
      });
      var positionStyle = computed(function () {
        if (isFullScreen.value) return {};
        var top2 = props2.top;
        var topStyle = {};
        if (top2 !== void 0) {
          var topValue = getCSSValue(top2);
          topStyle = {
            paddingTop: topValue
          };
        }
        return topStyle;
      });
      var _usePopupManager = usePopupManager("dialog", {
        visible: computedVisible
      }), isLastDialog = _usePopupManager.isLastDialog;
      watch(function () {
        return props2.visible;
      }, function (value) {
        if (value) {
          var _document$activeEleme;
          if (isModal.value && !props2.showInAttachedElement || isFullScreen.value) {
            if (props2.preventScrollThrough) {
              document.body.appendChild(styleEl.value);
            }
            nextTick(function () {
              var _dialogCardRef$value;
              if (mousePosition && (_dialogCardRef$value = dialogCardRef.value) !== null && _dialogCardRef$value !== void 0 && _dialogCardRef$value.$el) {
                var el = dialogCardRef.value.$el;
                el.style.transformOrigin = "".concat(mousePosition.x - el.offsetLeft, "px ").concat(mousePosition.y - el.offsetTop, "px");
              }
            });
          }
          (_document$activeEleme = document.activeElement) === null || _document$activeEleme === void 0 || _document$activeEleme.blur();
        } else {
          clearStyleFunc();
        }
        addKeyboardEvent(value);
      });
      function destroySelf() {
        var _styleEl$value$parent, _styleEl$value$parent2;
        (_styleEl$value$parent = styleEl.value.parentNode) === null || _styleEl$value$parent === void 0 || (_styleEl$value$parent2 = _styleEl$value$parent.removeChild) === null || _styleEl$value$parent2 === void 0 || _styleEl$value$parent2.call(_styleEl$value$parent, styleEl.value);
      }
      function clearStyleFunc() {
        clearTimeout(timer.value);
        timer.value = setTimeout(function () {
          destroySelf();
        }, 150);
      }
      var addKeyboardEvent = function addKeyboardEvent2(status) {
        if (status) {
          document.addEventListener("keydown", keyboardEvent);
          props2.confirmOnEnter && document.addEventListener("keydown", keyboardEnterEvent);
        } else {
          document.removeEventListener("keydown", keyboardEvent);
          props2.confirmOnEnter && document.removeEventListener("keydown", keyboardEnterEvent);
        }
      };
      var keyboardEnterEvent = function keyboardEnterEvent2(e) {
        var eventSrc = e.target;
        if (eventSrc.tagName.toLowerCase() === "input") return;
        var code = e.code;
        if ((code === "Enter" || code === "NumpadEnter") && isLastDialog()) {
          var _props2$onConfirm2;
          (_props2$onConfirm2 = props2.onConfirm) === null || _props2$onConfirm2 === void 0 || _props2$onConfirm2.call(props2, {
            e
          });
        }
      };
      var keyboardEvent = function keyboardEvent2(e) {
        if (e.code === "Escape" && isLastDialog()) {
          var _props2$onEscKeydown, _props2$closeOnEscKey;
          (_props2$onEscKeydown = props2.onEscKeydown) === null || _props2$onEscKeydown === void 0 || _props2$onEscKeydown.call(props2, {
            e
          });
          if ((_props2$closeOnEscKey = props2.closeOnEscKeydown) !== null && _props2$closeOnEscKey !== void 0 ? _props2$closeOnEscKey : globalConfig.value.closeOnEscKeydown) {
            emitCloseEvent({
              e,
              trigger: "esc"
            });
          }
        }
      };
      var overlayAction = function overlayAction2(e) {
        var _props2$closeOnOverla;
        if (props2.showOverlay && ((_props2$closeOnOverla = props2.closeOnOverlayClick) !== null && _props2$closeOnOverla !== void 0 ? _props2$closeOnOverla : globalConfig.value.closeOnOverlayClick)) {
          var _props2$onOverlayClic;
          (_props2$onOverlayClic = props2.onOverlayClick) === null || _props2$onOverlayClic === void 0 || _props2$onOverlayClic.call(props2, {
            e
          });
          emitCloseEvent({
            e,
            trigger: "overlay"
          });
        }
      };
      var _useSameTarget = useSameTarget(overlayAction), onClick = _useSameTarget.onClick, onMousedown = _useSameTarget.onMousedown, onMouseup = _useSameTarget.onMouseup;
      var closeBtnAction = function closeBtnAction2(context2) {
        var _props2$onCloseBtnCli;
        (_props2$onCloseBtnCli = props2.onCloseBtnClick) === null || _props2$onCloseBtnCli === void 0 || _props2$onCloseBtnCli.call(props2, context2);
        emitCloseEvent({
          trigger: "close-btn",
          e: context2.e
        });
      };
      var beforeEnter = function beforeEnter2() {
        var _props2$onBeforeOpen;
        (_props2$onBeforeOpen = props2.onBeforeOpen) === null || _props2$onBeforeOpen === void 0 || _props2$onBeforeOpen.call(props2);
      };
      var afterEnter = function afterEnter2() {
        var _props2$onOpened;
        (_props2$onOpened = props2.onOpened) === null || _props2$onOpened === void 0 || _props2$onOpened.call(props2);
      };
      var beforeLeave = function beforeLeave2() {
        var _props2$onBeforeClose;
        (_props2$onBeforeClose = props2.onBeforeClose) === null || _props2$onBeforeClose === void 0 || _props2$onBeforeClose.call(props2);
      };
      var afterLeave = function afterLeave2() {
        var _dialogCardRef$value2, _dialogCardRef$value3, _props2$onClosed;
        (_dialogCardRef$value2 = dialogCardRef.value) === null || _dialogCardRef$value2 === void 0 || (_dialogCardRef$value3 = _dialogCardRef$value2.resetPosition) === null || _dialogCardRef$value3 === void 0 || _dialogCardRef$value3.call(_dialogCardRef$value2);
        (_props2$onClosed = props2.onClosed) === null || _props2$onClosed === void 0 || _props2$onClosed.call(props2);
      };
      var emitCloseEvent = function emitCloseEvent2(ctx) {
        var _props2$onClose;
        (_props2$onClose = props2.onClose) === null || _props2$onClose === void 0 || _props2$onClose.call(props2, ctx);
        context.emit("update:visible", false);
      };
      var renderDialog = function renderDialog2() {
        var theme = props2.theme;
        props2.onConfirm;
        props2.onCancel;
        props2.onCloseBtnClick;
        var otherProps = _objectWithoutProperties(props2, _excluded);
        return createVNode("div", {
          "class": wrapClass.value
        }, [createVNode("div", {
          "class": positionClass.value,
          "style": positionStyle.value,
          "onClick": onClick,
          "onMousedown": onMousedown,
          "onMouseup": onMouseup
        }, [createVNode(_DialogCard, mergeProps({
          "ref": dialogCardRef,
          "theme": theme
        }, otherProps, {
          "onConfirm": confirmBtnAction,
          "onCancel": cancelBtnAction,
          "onCloseBtnClick": closeBtnAction
        }), context.slots)])]);
      };
      onMounted(function () {
        var hasScrollBar = document.documentElement.scrollHeight > document.documentElement.clientHeight;
        var scrollWidth = hasScrollBar ? getScrollbarWidth() : 0;
        styleEl.value = document.createElement("style");
        styleEl.value.dataset.id = "td_dialog_".concat(+/* @__PURE__ */ new Date(), "_").concat(key += 1);
        styleEl.value.innerHTML = "\n        html body {\n          overflow-y: hidden;\n          width: calc(100% - ".concat(scrollWidth, "px);\n        }\n      ");
      });
      onBeforeUnmount(function () {
        addKeyboardEvent(false);
        destroySelf();
      });
      return function () {
        var maskView = (isModal.value || isFullScreen.value) && createVNode("div", {
          "key": "mask",
          "class": maskClass.value
        }, null);
        var dialogView = renderDialog();
        var view = [maskView, dialogView];
        var ctxStyle = {
          zIndex: props2.zIndex
        };
        var ctxClass = ["".concat(COMPONENT_NAME.value, "__ctx"), _defineProperty$1(_defineProperty$1(_defineProperty$1({}, "".concat(COMPONENT_NAME.value, "__ctx--fixed"), isModal.value || isFullScreen.value), "".concat(COMPONENT_NAME.value, "__ctx--absolute"), isModal.value && props2.showInAttachedElement), "".concat(COMPONENT_NAME.value, "__ctx--modeless"), isModeLess.value)];
        return createVNode(Teleport, {
          "disabled": !props2.attach || !teleportElement.value,
          "to": teleportElement.value
        }, {
          "default": function _default5() {
            return [createVNode(Transition, {
              "duration": 300,
              "name": "".concat(COMPONENT_NAME.value, "-zoom__vue"),
              "onBeforeEnter": beforeEnter,
              "onAfterEnter": afterEnter,
              "onBeforeLeave": beforeLeave,
              "onAfterLeave": afterLeave
            }, {
              "default": function _default6() {
                return [(!props2.destroyOnClose || props2.visible) && withDirectives(createVNode("div", mergeProps({
                  "class": ctxClass,
                  "style": ctxStyle
                }, context.attrs), [view]), [[vShow, props2.visible]])];
              }
            })];
          }
        });
      };
    }
  });
  /**
   * tdesign v1.11.4
   * (c) 2025 tdesign
   * @license MIT
   */
  var Dialog = withInstall(_Dialog);
  withInstall(_DialogCard);
  var _GM_addStyle = /* @__PURE__ */ (() => typeof GM_addStyle != "undefined" ? GM_addStyle : void 0)();
  var _GM_deleteValue = /* @__PURE__ */ (() => typeof GM_deleteValue != "undefined" ? GM_deleteValue : void 0)();
  var _GM_getValue = /* @__PURE__ */ (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)();
  var _GM_setValue = /* @__PURE__ */ (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)();
  const eventBus = reactive(/* @__PURE__ */ new Map());
  function useMonkeyStorage(options) {
    const { key: key2, defaultValue, autoLoad = true } = options;
    const data = ref(defaultValue);
    const isLoading = ref(false);
    const error2 = ref(null);
    const load = () => {
      try {
        isLoading.value = true;
        error2.value = null;
        if (typeof _GM_getValue === "undefined") {
          throw new Error("油猴API不可用，请确保脚本在油猴环境中运行");
        }
        const storedValue = _GM_getValue(key2);
        data.value = storedValue === void 0 ? defaultValue : storedValue;
      } catch (err) {
        error2.value = err instanceof Error ? err : new Error(String(err));
        console.error("从油猴存储加载数据失败:", err);
      } finally {
        isLoading.value = false;
      }
    };
    if (autoLoad) {
      load();
    }
    watch(
      () => eventBus.get(key2),
      () => {
        const storedValue = _GM_getValue(key2);
        if (storedValue !== void 0) {
          data.value = storedValue;
        }
      }
    );
    const save = (value) => {
      try {
        error2.value = null;
        if (typeof _GM_setValue === "undefined") {
          throw new Error("油猴API不可用，请确保脚本在油猴环境中运行");
        }
        const valueToSave = value !== void 0 ? value : data.value;
        _GM_setValue(key2, valueToSave);
        if (value !== void 0) {
          data.value = value;
        }
        eventBus.set(key2, Date.now());
      } catch (err) {
        error2.value = err instanceof Error ? err : new Error(String(err));
        console.error("保存数据到油猴存储失败:", err);
      }
    };
    const remove2 = () => {
      try {
        error2.value = null;
        if (typeof _GM_deleteValue === "undefined") {
          throw new Error("油猴API不可用，请确保脚本在油猴环境中运行");
        }
        _GM_deleteValue(key2);
        data.value = defaultValue;
      } catch (err) {
        error2.value = err instanceof Error ? err : new Error(String(err));
        console.error("从油猴存储删除数据失败:", err);
      }
    };
    return {
      data,
      isLoading,
      error: error2,
      load,
      save,
      remove: remove2
    };
  }
  const _hoisted_1$1 = { class: "flex items-center !mb-2" };
  const _sfc_main$2 = /* @__PURE__ */ defineComponent({
    __name: "settings",
    setup(__props) {
      const visible = ref(false);
      const value = ref(0);
      const { data: activePanel, save: saveActivePanel } = useMonkeyStorage({
        key: "codesign-css-to-tailwind-active-panel",
        defaultValue: ""
      });
      const { data, save: savePanelList } = useMonkeyStorage({
        key: "codesign-css-to-tailwind-panels",
        defaultValue: [
          {
            label: "示例",
            value: 0,
            code: `:root {
  --td-brand-color: #154199;
  --td-brand-color-1: #f2f3ff;
  --td-brand-color-2: #d8e1ff;
  --td-brand-color-3: #b5c8ff;
  --td-brand-color-4: #8babff;
  --td-brand-color-5: #6d8feb;
  --td-brand-color-6: #5174ce;
  --td-brand-color-7: #3459b2;
  --td-brand-color-8: #154199;
  --td-brand-color-9: #002b79;
  --td-brand-color-10: #001b54;
  --td-brand-color-11: #6e8aff;
  --td-brand-color-12: #f8f9fc;
}`
          }
        ]
      });
      const panelList = ref(data.value);
      const openDialog = () => {
        panelList.value = data.value;
        visible.value = true;
      };
      const confirmDialog = () => {
        savePanelList(panelList.value);
        visible.value = false;
      };
      const closeDialog = () => {
        visible.value = false;
      };
      const handleActivePanelChange = (value2) => {
        console.log("value", value2);
        saveActivePanel(value2);
      };
      const addPanel = () => {
        const newPanelList = [
          ...panelList.value,
          {
            label: "配置" + panelList.value.length,
            value: panelList.value.length,
            code: ""
          }
        ];
        panelList.value = newPanelList;
        value.value = panelList.value.length - 1;
      };
      const removePanel = (options) => {
        var _a;
        const index = panelList.value.findIndex((item) => item.value === options.value);
        const newPanelList = panelList.value.filter((item) => item.value !== options.value);
        panelList.value = newPanelList;
        if (options.value === value.value) {
          value.value = index > 0 ? ((_a = panelList.value[index - 1]) == null ? void 0 : _a.value) || 0 : 0;
        }
      };
      return (_ctx, _cache) => {
        const _component_t_select = Select;
        const _component_t_input = Input;
        const _component_t_textarea = Textarea;
        const _component_t_tab_panel = TabPanel;
        const _component_t_tabs = Tabs;
        const _component_t_dialog = Dialog;
        return openBlock(), createElementBlock("div", null, [
          createBaseVNode("div", _hoisted_1$1, [
            createVNode(_component_t_select, {
              onChange: handleActivePanelChange,
              class: "select",
              modelValue: unref(activePanel),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(activePanel) ? activePanel.value = $event : null),
              options: unref(data)
            }, null, 8, ["modelValue", "options"]),
            createBaseVNode("button", {
              onClick: openDialog,
              type: "button",
              class: "!ml-2 unit-setting__trigger t-button t-size-m t-button--variant-text t-button--theme-default t-button--shape-square"
            }, _cache[3] || (_cache[3] = [
              createBaseVNode("span", { class: "t-button__text" }, [
                createBaseVNode("i", {
                  "data-v-2f06d9a5": "",
                  class: "com-icon iconfont-v2 icon-v2-setting"
                })
              ], -1)
            ]))
          ]),
          createVNode(_component_t_dialog, {
            onClose: closeDialog,
            onConfirm: confirmDialog,
            width: "750px",
            header: "配置颜色变量",
            visible: unref(visible),
            "onUpdate:visible": _cache[2] || (_cache[2] = ($event) => isRef(visible) ? visible.value = $event : null)
          }, {
            default: withCtx(() => [
              createVNode(_component_t_tabs, {
                theme: "card",
                size: "medium",
                addable: true,
                modelValue: unref(value),
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(value) ? value.value = $event : null),
                onAdd: addPanel,
                onRemove: removePanel
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(panelList), (item) => {
                    return openBlock(), createBlock(_component_t_tab_panel, {
                      removable: unref(panelList).length > 1,
                      value: item.value,
                      label: item.label
                    }, {
                      label: withCtx(() => [
                        createVNode(_component_t_input, {
                          readonly: item.value === 0,
                          modelValue: item.label,
                          "onUpdate:modelValue": ($event) => item.label = $event
                        }, null, 8, ["readonly", "modelValue", "onUpdate:modelValue"])
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_t_textarea, {
                          autosize: { minRows: 10, maxRows: 19 },
                          modelValue: item.code,
                          "onUpdate:modelValue": ($event) => item.code = $event,
                          language: "css",
                          theme: "vs-dark"
                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                      ]),
                      _: 2
                    }, 1032, ["removable", "value", "label"]);
                  }), 256))
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]),
            _: 1
          }, 8, ["visible"])
        ]);
      };
    }
  });
  const rules = [
    // ['width', 'w-[#]'],
    // ['height', 'h-[#]'],
    ["font-size", "text-[#]"],
    // ['font-style', '#'],
    [
      "font-weight",
      (value) => {
        const maps = {
          "300": "font-light",
          "400": "font-normal",
          "500": "font-medium",
          "600": "font-semibold",
          "700": "font-bold",
          "800": "font-extrabold"
        };
        return maps[value];
      }
    ],
    ["color", "text-[#]"],
    ["line-height", "leading-[#]"],
    ["border-radius", "rounded-[#]"],
    // [
    //   'border',
    //   (value: string) => {
    //     const [width, style, color] = value.split(' ')
    //     return `border-[${width}] border-${style} border-[${color}]`
    //   },
    // ],
    ["letter-spacing", "tracking-[#]"],
    ["opacity", (value) => `opacity-${Math.round(parseFloat(value) * 100)}`],
    // ['text-decoration', '#'],
    // ['text-align', 'text-#'],
    ["background", "bg-[#]"]
    // ['padding', 'p-[#]'],
    // ['margin', 'm-[#]'],
    // ['display', '#'],
    // ['position', '#'],
    // ['top', 'top-[#]'],
    // ['left', 'left-[#]'],
    // ['right', 'right-[#]'],
    // ['bottom', 'bottom-[#]'],
  ];
  const cssToTailwind = (css) => {
    const cssProperties = css.map((item) => {
      const [prop, ...values] = item.split(":").map((s) => s.trim());
      return [prop, values.join(":").replace(";", "")];
    });
    const result = cssProperties.map(([prop, value]) => {
      const rule = rules.find(([cssName]) => cssName === prop);
      if (value === "") return null;
      if (!rule) return null;
      const [, template] = rule;
      if (typeof template === "function") {
        return template(value);
      }
      return template.replace("#", value);
    }).filter((item) => {
      if (!item) return false;
      const defaultValues = ["font-normal", "text-[14px]", "tracking-[0]"];
      return !defaultValues.includes(item);
    });
    return result.join(" ");
  };
  const _hoisted_1 = { class: "css-node" };
  const _hoisted_2 = ["value"];
  const _sfc_main$1 = /* @__PURE__ */ defineComponent({
    __name: "code",
    props: {
      layerData: {}
    },
    setup(__props, { expose: __expose }) {
      const props2 = __props;
      const localLayerData = ref(null);
      const { data: activePanel } = useMonkeyStorage({
        key: "codesign-css-to-tailwind-active-panel",
        defaultValue: 0
      });
      const { data: panelList } = useMonkeyStorage({
        key: "codesign-css-to-tailwind-panels",
        defaultValue: []
      });
      const activeCssVariable = computed(() => {
        var _a;
        if (!((_a = panelList.value) == null ? void 0 : _a.length)) return "";
        return panelList.value[Number(activePanel.value)].code;
      });
      watch(
        () => props2.layerData,
        (newValue) => {
          console.log("codeapp layerData change", newValue);
          localLayerData.value = toValue(newValue);
        },
        { deep: true, immediate: true }
      );
      const tailwindCode = computed(() => {
        var _a;
        return cssToTailwind(((_a = localLayerData.value) == null ? void 0 : _a.css) ?? []);
      });
      const formatedCssVariableTailwindCode = computed(() => {
        if (!activeCssVariable.value) return tailwindCode.value;
        const cssVarRegex = /--([^:]+):\s*([^;]+);/g;
        const cssVars = {};
        let match;
        while ((match = cssVarRegex.exec(activeCssVariable.value)) !== null) {
          const varName = match[1].trim();
          const varValue = match[2].trim();
          cssVars[varValue.toLowerCase()] = `var(--${varName})`;
        }
        let result = tailwindCode.value;
        const colorRegex = /\[(#[0-9a-fA-F]{3,8}|rgba?\([^)]+\))\]/g;
        result = result.replace(colorRegex, (match2) => {
          const colorValue = match2.substring(1, match2.length - 1).toLowerCase();
          if (cssVars[colorValue]) {
            return `[${cssVars[colorValue]}]`;
          }
          return match2;
        });
        return result;
      });
      __expose({
        activeCssVariable,
        tailwindCode,
        formatedCssVariableTailwindCode,
        localLayerData
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1, [
          createBaseVNode("input", {
            readonly: "",
            value: unref(formatedCssVariableTailwindCode),
            class: "tailwind-code-area"
          }, null, 8, _hoisted_2)
        ]);
      };
    }
  });
  function waitElement(selector, target = document.body) {
    return new Promise((resolve2) => {
      {
        const element2 = target.querySelector(selector);
        if (element2) {
          return resolve2(element2);
        }
      }
      const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          for (const node of mutation.addedNodes) {
            if (!(node instanceof HTMLElement)) continue;
            if (node.matches(selector)) {
              observer.disconnect();
              resolve2(node);
              return;
            }
            const childElement = node.querySelector(selector);
            if (childElement) {
              observer.disconnect();
              resolve2(childElement);
              return;
            }
          }
        }
      });
      observer.observe(target, {
        childList: true,
        subtree: true,
        attributes: false,
        characterData: false
      });
    });
  }
  function waitElementAttribute(attribute, target, timeout = 5e3) {
    return new Promise((resolve2, reject) => {
      if (target[attribute]) {
        return resolve2(target[attribute]);
      }
      const startTime = Date.now();
      const checkInterval = 100;
      let timer;
      const check = () => {
        if (Date.now() - startTime >= timeout) {
          reject(new Error(`等待属性 ${attribute} 超时`));
          return;
        }
        if (target[attribute]) {
          clearTimeout(timer);
          resolve2(target[attribute]);
          return;
        }
        timer = setTimeout(check, checkInterval);
      };
      check();
    });
  }
  const copyToClipboard = (text) => {
    const textarea = document.createElement("textarea");
    textarea.value = text;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand("copy");
    document.body.removeChild(textarea);
  };
  let messageId = 0;
  let messageList = [];
  function getMessageContainer() {
    let container = document.getElementById("global-message-container");
    if (!container) {
      container = document.createElement("div");
      container.id = "global-message-container";
      Object.assign(container.style, {
        position: "fixed",
        top: "40px",
        left: "50%",
        transform: "translateX(-50%)",
        zIndex: "9999",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        pointerEvents: "none",
        minWidth: "300px"
      });
      document.body.appendChild(container);
    }
    return container;
  }
  function renderMessages() {
    const container = getMessageContainer();
    container.innerHTML = "";
    messageList.forEach((msg) => {
      const el = document.createElement("div");
      el.textContent = msg.content;
      Object.assign(el.style, {
        margin: "8px 0",
        padding: "12px 24px",
        borderRadius: "6px",
        color: "#fff",
        fontSize: "16px",
        background: msg.type === "success" ? "#52c41a" : "#ff4d4f",
        boxShadow: "0 2px 8px rgba(0,0,0,0.15)",
        pointerEvents: "auto",
        minWidth: "200px",
        textAlign: "center",
        opacity: "0.95",
        transition: "all 0.3s"
      });
      container.appendChild(el);
    });
  }
  function addMessage(type, content, duration = 3e3) {
    const id = ++messageId;
    messageList.push({ id, type, content });
    renderMessages();
    setTimeout(() => {
      messageList = messageList.filter((msg) => msg.id !== id);
      renderMessages();
    }, duration);
  }
  const message = {
    success(content, duration) {
      addMessage("success", content, duration);
    },
    error(content, duration) {
      addMessage("error", content, duration);
    }
  };
  const _sfc_main = /* @__PURE__ */ defineComponent({
    __name: "layerData",
    setup(__props) {
      const isRectContained = (outer, inner) => {
        return outer.x <= inner.x && outer.y <= inner.y && outer.x + outer.width >= inner.x + inner.width && outer.y + outer.height >= inner.y + inner.height;
      };
      const formatLayersForHtmlGeneration = (layers) => {
        return layers.filter((layer) => {
          var _a;
          return !((_a = layer == null ? void 0 : layer.css) == null ? void 0 : _a.includes("background: transparent;"));
        }).map((layer) => ({
          type: layer.type,
          name: layer.name,
          x: layer.x,
          y: layer.y,
          width: layer.width,
          height: layer.height,
          css: layer.css,
          // fills: layer.fills?.map((fill) => ({
          //   fillType: fill.fillType,
          //   color: fill.color
          //     ? {
          //         'color-hex': fill.color['color-hex'],
          //         'css-rgba': fill.color['css-rgba'],
          //       }
          //     : undefined,
          // })),
          // borders: layer.borders,
          // shadows: layer.shadows,
          // radius: layer.radius,
          layerIndex: layer.layerIndex
        }));
      };
      const getLayerDatas = async () => {
        console.log("getLayerDatas");
        const layerData2 = await waitElement(".screen-inspect");
        let vueData = layerData2.__vue__;
        let currentLayerData = vueData.layerData;
        let allLayerData = vueData.layerMap;
        if (!currentLayerData) {
          console.warn("当前没有选中图层");
          message.error("请先选中一个图层");
          return [];
        }
        const currentLayerId = currentLayerData.id;
        const currentRect = {
          x: currentLayerData.x,
          y: currentLayerData.y,
          width: currentLayerData.width,
          height: currentLayerData.height
        };
        const containedLayers = [];
        allLayerData.forEach((layer) => {
          const layerRect = {
            x: layer.x,
            y: layer.y,
            width: layer.width,
            height: layer.height
          };
          if (layer.id === currentLayerId || isRectContained(currentRect, layerRect)) {
            containedLayers.push(layer);
          }
        });
        const filteredLayers = containedLayers.sort((a, b) => (a.layerIndex || 0) - (b.layerIndex || 0)).filter((v) => v.visible).filter((v) => v.opacity == 1);
        console.log("当前图层及其包含的图层:", filteredLayers);
        console.log("当前图层rect:", currentRect);
        let formatedData = formatLayersForHtmlGeneration(filteredLayers);
        const output = `---
layerData结构描述:
- type: 图层类型
- name: 图层名称
- x, y: 坐标位置
- width, height: 尺寸
- css: 样式信息
- layerIndex: 图层索引

layerDatas:
${JSON.stringify(formatedData, null, 2)}`;
        copyToClipboard(output);
        message.success("已复制到剪贴板");
      };
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("button", {
          class: "ai-glow-btn",
          id: "layer-data-btn",
          onClick: getLayerDatas
        }, "获取layerDatas");
      };
    }
  });
  const _export_sfc = (sfc, props2) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key2, val] of props2) {
      target[key2] = val;
    }
    return target;
  };
  const LayerDataComponent = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-c1a9705a"]]);
  _GM_addStyle(
    `
    .base-node{
      display: none;
    }
    .node-item[data-label="字体"],
    .node-item[data-label="段落对齐"],
    .node-item[data-label="垂直对齐"],
    .node-item[data-label="字号"],
    .node-item[data-label="字重"],
    .node-item[data-label="行高"],
    .node-item[data-label="颜色"],
    .node-item[data-label="宽度"]
    {
      display: none !important;
    }
    // .node-box{
    //   display: none !important;
    // }
    .node-box:last-child{
      display: block !important;
    }
    .node-item {
      margin-bottom: 2px !important;
    }
    .node-box {
      margin-bottom: 0px !important;
    }
    `
  );
  const CONFIG = {
    screenHeader: ".screen-header__section--right .screen-header__item",
    cssCodeNavs: ".css-node__codes--navs",
    screenListWrapper: "div[page-list][screen-list]",
    // 页面左侧页面list
    screenInspectorPanel: "aside.screen-inspector"
    // 页面右侧标注信息panel
  };
  let screenInspectorPanelVueInstance = null;
  let listWrapperVueInstance = null;
  let layerData = ref(null);
  let screenListWrapper = await (waitElement(CONFIG.screenListWrapper));
  listWrapperVueInstance = await (waitElementAttribute("__vue__", screenListWrapper));
  let codeAppInstance = null;
  let codeAppContainer = null;
  const handleScreenChange = async () => {
    screenInspectorPanelVueInstance = null;
    let panel = await waitElement(CONFIG.screenInspectorPanel);
    screenInspectorPanelVueInstance = panel.__vue__;
    screenInspectorPanelVueInstance.$watch(
      "layerData",
      (value) => {
        console.log("layerData change", value);
        layerData.value = toRaw(value);
        if (codeAppInstance && codeAppContainer) {
          codeAppInstance.unmount();
          codeAppContainer.remove();
          codeAppInstance = null;
          codeAppContainer = null;
        }
        const codeNavs = document.querySelector(CONFIG.cssCodeNavs);
        if (codeNavs) {
          codeAppInstance = createApp(_sfc_main$1, {
            layerData
          });
          codeAppContainer = document.createElement("div");
          codeNavs.parentNode.insertBefore(codeAppContainer, codeNavs);
          codeAppInstance.mount(codeAppContainer);
        }
      },
      { deep: true, immediate: true }
    );
    const screenHeader = await waitElement(CONFIG.screenHeader);
    if (!document.getElementById("tailwind-setting-btn")) {
      createApp(_sfc_main$2).mount(
        (() => {
          const app = document.createElement("div");
          app.setAttribute("id", "tailwind-setting-btn");
          screenHeader.parentNode.insertBefore(app, screenHeader);
          return app;
        })()
      );
    }
    if (!document.getElementById("layer-data-btn")) {
      createApp(LayerDataComponent).mount(
        (() => {
          const app = document.createElement("div");
          app.setAttribute("id", "layer-data-btn");
          screenHeader.parentNode.insertBefore(app, screenHeader);
          return app;
        })()
      );
    }
  };
  listWrapperVueInstance.$watch(
    "screen",
    (value) => {
      if (value) {
        console.log("screenChange", value);
        handleScreenChange();
      }
    },
    { immediate: true, deep: true }
  );
  window.addEventListener("codesign-css-to-tailwind-refresh", async () => {
    var _a;
    if (codeAppInstance && codeAppContainer) {
      codeAppInstance.unmount();
      codeAppContainer.remove();
      codeAppInstance = null;
      codeAppContainer = null;
    }
    const settingBtn = document.getElementById("tailwind-setting-btn");
    if (settingBtn) {
      settingBtn.remove();
    }
    const codeNavs = document.querySelector(CONFIG.cssCodeNavs);
    if (codeNavs && codeNavs.previousSibling && ((_a = codeNavs.previousSibling.classList) == null ? void 0 : _a.contains("css-node"))) {
      codeNavs.previousSibling.remove();
    }
    screenListWrapper = await waitElement(CONFIG.screenListWrapper);
    listWrapperVueInstance = await waitElementAttribute("__vue__", screenListWrapper);
    listWrapperVueInstance.$watch(
      "screen",
      (value) => {
        if (value) {
          console.log("screenChange", value);
          handleScreenChange();
        }
      },
      { immediate: true, deep: true }
    );
    handleScreenChange();
  });

})();