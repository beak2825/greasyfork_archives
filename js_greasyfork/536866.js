// ==UserScript==
// @name        ğŸ§ AIæ™ºæ…§æ ‘çŸ¥åˆ°è‡ªåŠ¨ç­”é¢˜åŠ©æ‰‹ğŸ§ 
// @namespace    https://greasyfork.org/
// @description  AIè‡ªåŠ¨ç­”é¢˜ï¼Œå¯æš‚åœ/é‡è¯•ï¼Œå¤åˆ¶é¢˜ç›®ï¼Œæ¨¡å‹è‡ªå®šä¹‰ï¼Œçª—å£ç¼©æ”¾ï¼Œæ˜¾ç¤ºå®Œæ•´AIæ€è€ƒè¿‡ç¨‹å’Œå›å¤ã€‚æ”¯æŒOpenAI, DeepSeek, Geminiç­‰APIã€‚
// @author       AI Copilot
// @match        *://*.zhihuishu.com/stuExamWeb*
// @connect      *
// @run-at       document-start
// @grant        unsafeWindow
// @grant        GM_xmlhttpRequest
// @grant        GM_addStyle
// @grant        GM_getResourceText
// @grant        GM_setClipboard
// @grant        GM_setValue
// @grant        GM_getValue
// @resource css https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css
// @license      MIT
// @version 0.0.1.20250522155626
// @downloadURL https://update.greasyfork.org/scripts/536866/%F0%9F%A7%A0AI%E6%99%BA%E6%85%A7%E6%A0%91%E7%9F%A5%E5%88%B0%E8%87%AA%E5%8A%A8%E7%AD%94%E9%A2%98%E5%8A%A9%E6%89%8B%F0%9F%A7%A0.user.js
// @updateURL https://update.greasyfork.org/scripts/536866/%F0%9F%A7%A0AI%E6%99%BA%E6%85%A7%E6%A0%91%E7%9F%A5%E5%88%B0%E8%87%AA%E5%8A%A8%E7%AD%94%E9%A2%98%E5%8A%A9%E6%89%8B%F0%9F%A7%A0.meta.js
// ==/UserScript==

enableWebpackHook();

const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

// --- å…¨å±€çŠ¶æ€å’Œé…ç½® ---
let IS_PAUSED = false;
let CURRENT_PROCESSING_QUESTIONS = []; // å­˜å‚¨å½“å‰æ‰¹æ¬¡é¢˜ç›®çš„è¯¦ç»†ä¿¡æ¯
let IS_WINDOW_MINIMIZED = false;

const MAX_AI_RETRIES = 2;
const AI_RETRY_DELAY = 2000;
const DOCUMENTATION_URL = "https://greasyfork.org/zh-CN/scripts/your-script-id-or-page"; // ã€é‡è¦ã€‘æ›¿æ¢ä¸ºä½ çš„å®é™…æ–‡æ¡£é“¾æ¥

const AI_PROVIDERS = {
    OPENAI: { name: "OpenAI", defaultUrl: "https://api.openai.com/v1/chat/completions", defaultModel: "gpt-3.5-turbo", getRequestData: (model, promptContent) => ({ model: model, messages: [{ role: "user", content: promptContent }], temperature: 0.1, max_tokens: 250 }), parseResponse: (res) => { if (res.choices && res.choices.length > 0) { const fullText = res.choices[0].message.content.trim(); const cleanAnswer = fullText.replace(/<think>[\s\S]*?<\/think>\s*/gi, "").trim(); return { fullText, cleanAnswer }; } return null; }, parseError: (res) => res.error ? res.error.message : null },
    DEEPSEEK: { name: "DeepSeek", defaultUrl: "https://api.deepseek.com/chat/completions", defaultModel: "deepseek-chat", getRequestData: (model, promptContent) => ({ model: model, messages: [{ role: "user", content: promptContent }], temperature: 0.1, max_tokens: 250 }), parseResponse: (res) => { if (res.choices && res.choices.length > 0) { const fullText = res.choices[0].message.content.trim(); const cleanAnswer = fullText.replace(/<think>[\s\S]*?<\/think>\s*/gi, "").trim(); return { fullText, cleanAnswer }; } return null; }, parseError: (res) => res.error ? res.error.message : null },
    GEMINI: { name: "Google Gemini", defaultUrl: "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.0-pro:generateContent", defaultModel: "gemini-1.0-pro", getRequestData: (model, promptContent) => ({ contents: [{ parts: [{ text: promptContent }] }], generationConfig: { temperature: 0.1, maxOutputTokens: 250, } }), parseResponse: (res) => { if (res.candidates && res.candidates.length > 0 && res.candidates[0].content && res.candidates[0].content.parts && res.candidates[0].content.parts.length > 0) { const fullText = res.candidates[0].content.parts[0].text.trim(); const cleanAnswer = fullText.replace(/<think>[\s\S]*?<\/think>\s*/gi, "").trim(); return { fullText, cleanAnswer }; } return null; }, parseError: (res) => res.error ? (res.error.message + (res.error.details ? ` Details: ${JSON.stringify(res.error.details)}` : '')) : null }
};

const config = { awaitTime: 2500, requestDelay: 3000, questionTypeMap: { 'åˆ¤æ–­é¢˜': 'TrueFalse', 'å•é€‰é¢˜': 'SingleChoice', 'å¤šé€‰é¢˜': 'MultipleChoice', }, defaultQuestionTypeForAI: 'SingleChoice' };

// --- AI è°ƒç”¨æ ¸å¿ƒå‡½æ•° (ä¸v2.9.1ä¸€è‡´) ---
async function getAiAnswer(questionTypeKey, questionDescription, optionsText, questionIndex, retryCount = 0) { const selectedProviderKey = GM_getValue('selectedAiProvider', 'OPENAI'); const provider = AI_PROVIDERS[selectedProviderKey] || AI_PROVIDERS.OPENAI; let userAiUrl = GM_getValue(`aiApiUrl_${selectedProviderKey}`, provider.defaultUrl); const userAiKey = GM_getValue(`aiApiKey_${selectedProviderKey}`, ''); const userAiModel = GM_getValue(`aiModel_${selectedProviderKey}`, provider.defaultModel); if (!userAiUrl || (!userAiKey && provider !== AI_PROVIDERS.GEMINI) || (provider === AI_PROVIDERS.GEMINI && !userAiUrl.includes('key=') && !userAiKey) ) { const errorMsg = `AIé…ç½®é”™è¯¯: ${provider.name} API URLæˆ–Keyæœªé…ç½®`; console.error(errorMsg); updateAiLog(questionIndex, errorMsg, "", {cleanAnswer: "AIé…ç½®é”™è¯¯", fullText: errorMsg}); return {cleanAnswer: "AIé…ç½®é”™è¯¯", fullText: errorMsg}; } if (provider === AI_PROVIDERS.GEMINI && userAiUrl.includes("{YOUR_API_KEY}") && userAiKey) { userAiUrl = userAiUrl.replace("{YOUR_API_KEY}", userAiKey); } else if (provider === AI_PROVIDERS.GEMINI && !userAiUrl.includes('key=') && userAiKey) { userAiUrl += (userAiUrl.includes('?') ? '&' : '?') + `key=${userAiKey}`; } let promptContent = `ä½ æ˜¯ä¸€ä¸ªåœ¨çº¿å­¦ä¹ å¹³å°çš„ç­”é¢˜åŠ©æ‰‹ã€‚è¯·æ ¹æ®ä»¥ä¸‹é¢˜ç›®ä¿¡æ¯ï¼Œç»™å‡ºæœ€å‡†ç¡®çš„ç­”æ¡ˆã€‚\n\né¢˜ç›®ç±»å‹ï¼š${questionTypeKey}\né¢˜ç›®æè¿°ï¼š\n${questionDescription}\n`; if (optionsText && optionsText.trim() !== "") { promptContent += `\né€‰é¡¹ï¼š\n${optionsText}\n`; } promptContent += `\nè¯·ä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹æ ¼å¼ä¹‹ä¸€ç»™å‡ºç­”æ¡ˆï¼š\n- å¯¹äºå•é€‰é¢˜ï¼Œè¯·ç›´æ¥ç»™å‡ºæ­£ç¡®é€‰é¡¹çš„å­—æ¯ï¼ˆä¾‹å¦‚ï¼šAï¼‰ã€‚\n- å¯¹äºå¤šé€‰é¢˜ï¼Œè¯·ç›´æ¥ç»™å‡ºæ‰€æœ‰æ­£ç¡®é€‰é¡¹çš„å­—æ¯ï¼Œç”¨é€—å·åˆ†éš”ï¼Œæ— ç©ºæ ¼ï¼ˆä¾‹å¦‚ï¼šA,C,Dï¼‰ã€‚\n- å¯¹äºåˆ¤æ–­é¢˜ï¼Œè¯·ç›´æ¥å›ç­”â€œæ­£ç¡®â€æˆ–â€œé”™è¯¯â€ã€‚\n- ä¸è¦åŒ…å«ä»»ä½•è§£é‡Šã€é¢˜ç›®å¤è¿°æˆ–å¤šä½™çš„æ–‡å­—ï¼Œåªéœ€è¦ç­”æ¡ˆæœ¬èº«ã€‚ä¾‹å¦‚ï¼Œå¦‚æœç­”æ¡ˆæ˜¯Aï¼Œå°±åªè¿”å› "A"ã€‚å¦‚æœæ˜¯å¤šé€‰ A å’Œ Cï¼Œå°±è¿”å› "A,C"ã€‚\n`; if (retryCount > 0) { console.log(`[é¢˜ç›® ${questionIndex}] (${provider.name}) AIè¯·æ±‚é‡è¯• #${retryCount}...\nPrompt:\n`, promptContent); updateAiLog(questionIndex, promptContent, `ç­‰å¾…AIå“åº” (é‡è¯• ${retryCount}/${MAX_AI_RETRIES})...`, null); } else { console.log(`[é¢˜ç›® ${questionIndex}] (${provider.name}) Prompt:\n`, promptContent); updateAiLog(questionIndex, promptContent, "ç­‰å¾…AIå“åº”...", null); } const requestData = provider.getRequestData(userAiModel, promptContent); const headers = { "Content-Type": "application/json" }; if (provider !== AI_PROVIDERS.GEMINI) { headers["Authorization"] = `Bearer ${userAiKey}`; } return new Promise((resolve) => { GM_xmlhttpRequest({ method: "POST", url: userAiUrl, headers: headers, data: JSON.stringify(requestData), timeout: 25000, onload: function(response) { try { const res = JSON.parse(response.responseText); console.log(`[é¢˜ç›® ${questionIndex}] AI Raw Rsp:\n`, res); const parsed = provider.parseResponse(res); const errorMsgFromProvider = provider.parseError(res); if (parsed && parsed.cleanAnswer !== null) { const finalCleanAnswer = parsed.cleanAnswer.replace(/^["']/, '').replace(/["']$/, '').replace(/[ã€‚ï¼›ï¼Œï¼]$/, '').trim(); updateAiLog(questionIndex, promptContent, JSON.stringify(res, null, 2), {cleanAnswer: finalCleanAnswer, fullText: parsed.fullText}); resolve({cleanAnswer: finalCleanAnswer, fullText: parsed.fullText}); } else if (errorMsgFromProvider) { const errorMsg = `AI APIé”™è¯¯: ${errorMsgFromProvider}`; console.error(`[é¢˜ç›® ${questionIndex}] ${errorMsg}`); handleAiError(errorMsg, resolve, retryCount, questionIndex, promptContent, JSON.stringify(res, null, 2), { questionTypeKey, questionDescription, optionsText }); } else { const errorMsg = "AIæœªè¿”å›æœ‰æ•ˆç­”æ¡ˆç»“æ„"; console.error(`[é¢˜ç›® ${questionIndex}] ${errorMsg}`); handleAiError(errorMsg, resolve, retryCount, questionIndex, promptContent, JSON.stringify(res, null, 2), { questionTypeKey, questionDescription, optionsText }); } } catch (e) { const errorMsg = `è§£æAIå“åº”å¤±è´¥: ${e.message}`; console.error(`[é¢˜ç›® ${questionIndex}] ${errorMsg}`, response.responseText); handleAiError(errorMsg, resolve, retryCount, questionIndex, promptContent, response.responseText, { questionTypeKey, questionDescription, optionsText }); } }, onerror: function(error) { const errorMsg = `AI APIè¯·æ±‚é”™è¯¯: ${error.statusText || 'Network Error'}`; console.error(`[é¢˜ç›® ${questionIndex}] ${errorMsg}`, error); handleAiError(errorMsg, resolve, retryCount, questionIndex, promptContent, JSON.stringify(error, null, 2), { questionTypeKey, questionDescription, optionsText }); }, ontimeout: function() { const errorMsg = "AI APIè¯·æ±‚è¶…æ—¶"; console.error(`[é¢˜ç›® ${questionIndex}] ${errorMsg}`); handleAiError(errorMsg, resolve, retryCount, questionIndex, promptContent, "è¯·æ±‚è¶…æ—¶", { questionTypeKey, questionDescription, optionsText }); } }); });}
async function handleAiError(errorMsg, resolve, currentRetryCount, questionIndex, promptContent, rawResponse, originalRequestArgs) { if (currentRetryCount < MAX_AI_RETRIES) { updateAiLog(questionIndex, promptContent, rawResponse, {cleanAnswer: `é”™è¯¯: ${errorMsg} (å‡†å¤‡é‡è¯• ${currentRetryCount + 1})`, fullText: `é”™è¯¯: ${errorMsg} (å‡†å¤‡é‡è¯• ${currentRetryCount + 1})`}); await sleep(AI_RETRY_DELAY); resolve(getAiAnswer(originalRequestArgs.questionTypeKey, originalRequestArgs.questionDescription, originalRequestArgs.optionsText, questionIndex, currentRetryCount + 1)); } else { updateAiLog(questionIndex, promptContent, rawResponse, {cleanAnswer: `é”™è¯¯: ${errorMsg} (å·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°)`, fullText: `é”™è¯¯: ${errorMsg} (å·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°)`}); resolve({cleanAnswer: `AIé”™è¯¯: ${errorMsg}`, fullText: `AIé”™è¯¯: ${errorMsg}`}); }}

// --- æ›´æ–°AIæ—¥å¿—åˆ°è¡¨æ ¼çš„è¯¦æƒ…åŒºåŸŸ (ä¸v2.9.1ä¸€è‡´) ---
function updateAiLog(questionIndex, prompt, rawResponse, aiResult = null) { const logRow = document.querySelector(`#qrow-${questionIndex}-log`); if (logRow) { const promptCell = logRow.querySelector(".ai-prompt-cell"); const responseCell = logRow.querySelector(".ai-response-cell"); if (promptCell) { promptCell.textContent = prompt; } if (responseCell) { let displayText = `åŸå§‹JSONå“åº”:\n${rawResponse}\n\n`; if (aiResult && aiResult.fullText) { displayText += `AIå®Œæ•´å›å¤ (å«æ€è€ƒè¿‡ç¨‹):\n${aiResult.fullText}\n\n`; displayText += `æå–çš„çº¯å‡€ç­”æ¡ˆ: ${aiResult.cleanAnswer !== null ? aiResult.cleanAnswer : "N/A"}`; } else if (aiResult && typeof aiResult === 'string') { displayText += `AIå›å¤/é”™è¯¯: ${aiResult}`; } else { displayText += `AIæœªæä¾›æœ‰æ•ˆå›å¤æˆ–æå–ç»“æ„ã€‚`; } responseCell.textContent = displayText; } } }

// --- ä¸»ç­”é¢˜é€»è¾‘ (ä¸v2.9.1ä¸€è‡´) ---
async function answerQuestionWithAI(questionTypeString, questionDescription, questionBody, questionIndex, isRetry = false) { if (!isRetry) { let questionTitle = questionDescription.trim().replace(/%C2%A0/g, '%20').replace(/\s+/g, ' '); appendToTable(questionTitle, "", questionIndex); } else { const answerCell = document.querySelector(`#ai-answer-${questionIndex}`); if (answerCell) answerCell.innerHTML = "æ­£åœ¨é‡è¯•AI..."; const retryButton = document.querySelector(`#retry-btn-${questionIndex}`); if (retryButton) retryButton.disabled = true; updateAiLog(questionIndex, "é‡è¯•ä¸­...", "ç­‰å¾…AIå“åº”...", null); } const extractedTypeMatch = questionTypeString.match(/ã€(.+?)ã€‘/); const extractedType = extractedTypeMatch && extractedTypeMatch[1] ? extractedTypeMatch[1] : ''; const aiQuestionTypeKey = config.questionTypeMap[extractedType] || config.defaultQuestionTypeForAI; let optionsText = ""; const optionElements = questionBody.querySelectorAll(".subject_node .nodeLab .node_detail"); if (optionElements && optionElements.length > 0) { optionElements.forEach((opt, idx) => { const optionLabel = String.fromCharCode(65 + idx); let optText = opt.innerText.trim().replace(/^[A-Z][\s.ã€]*/, ''); if (aiQuestionTypeKey === 'TrueFalse') { optionsText += `${optText}\n`; } else { optionsText += `${optionLabel}. ${optText}\n`; } }); } else { console.warn(`[é¢˜ç›® ${questionIndex}] æœªèƒ½ä½¿ç”¨é€‰æ‹©å™¨ ".subject_node .nodeLab .node_detail" æå–åˆ°é€‰é¡¹å…ƒç´ ã€‚`); } optionsText = optionsText.trim(); console.log(`[é¢˜ç›® ${questionIndex}] (${isRetry ? 'é‡è¯•' : 'é¦–æ¬¡'}): ç±»å‹=${extractedType}(${aiQuestionTypeKey}), æè¿°=${questionDescription.substring(0,30)}...`); if (!config.questionTypeMap[extractedType]) { const unsupportedMsg = "AIæš‚ä¸æ”¯æŒæ­¤é¢˜å‹"; changeAnswerInTable(unsupportedMsg, questionIndex, false, `${unsupportedMsg}ï¼Œè¯·æ‰‹åŠ¨å®Œæˆã€‚`, true); updateAiLog(questionIndex, "N/A (ä¸æ”¯æŒçš„é¢˜å‹)", "N/A", {cleanAnswer: unsupportedMsg, fullText: unsupportedMsg}); return; } if (optionsText === "" && (aiQuestionTypeKey === 'SingleChoice' || aiQuestionTypeKey === 'MultipleChoice')) { console.warn(`[é¢˜ç›® ${questionIndex}] é€‰é¡¹æå–ä¸ºç©ºï¼ŒAIå¯èƒ½æ— æ³•å‡†ç¡®å›ç­”é€‰æ‹©é¢˜ã€‚`); if (!isRetry) updateAiLog(questionIndex, "è­¦å‘Šï¼šé€‰é¡¹æå–ä¸ºç©ºã€‚", "", {cleanAnswer: "è­¦å‘Š", fullText: "è­¦å‘Šï¼šé€‰é¡¹æå–ä¸ºç©ºã€‚AIå°†ä»…åŸºäºé¢˜å¹²ä½œç­”ã€‚"}); } const aiResult = await getAiAnswer(aiQuestionTypeKey, questionDescription, optionsText, questionIndex); const cleanAiAnswer = aiResult.cleanAnswer; console.log(`[é¢˜ç›® ${questionIndex}] AIæœ€ç»ˆæå–ç­”æ¡ˆ: "${cleanAiAnswer}"`); let isSelected = false; let isError = cleanAiAnswer.startsWith("AIé…ç½®é”™è¯¯") || cleanAiAnswer.startsWith("AIé”™è¯¯") || cleanAiAnswer.startsWith("AIæœªè¿”å›") || cleanAiAnswer.startsWith("AIè¯·æ±‚"); if (!isError) { isSelected = chooseAnswerByAI(aiQuestionTypeKey, questionBody, cleanAiAnswer); } changeAnswerInTable(cleanAiAnswer, questionIndex, isSelected, isSelected ? "" : (isError ? cleanAiAnswer : "AIç­”æ¡ˆå¯èƒ½æœªæˆåŠŸåŒ¹é…é€‰é¡¹æˆ–é€‰æ‹©å¤±è´¥ï¼Œè¯·æ£€æŸ¥"), !isError || isSelected); if (!isRetry && !IS_PAUSED) { const nextButton = document.querySelector('.switch-btn-box > button:last-child'); if (nextButton && nextButton.innerText.includes('ä¸‹ä¸€é¢˜')) { setTimeout(() => nextButton.click(), 500); } else { console.log("æœªæ‰¾åˆ°æ˜ç¡®çš„'ä¸‹ä¸€é¢˜'æŒ‰é’®æˆ–å·²æ˜¯æœ€åä¸€é¢˜ã€‚"); } } else if (isRetry) { const retryButton = document.querySelector(`#retry-btn-${questionIndex}`); if (retryButton) retryButton.disabled = false; } }

// --- æ ¹æ®AIç­”æ¡ˆé€‰æ‹©é€‰é¡¹ (ä¸v2.9.1ä¸€è‡´) ---
function chooseAnswerByAI(aiQuestionTypeKey, questionBody, aiAnswerString) { let isSelectedSuccessfully = false; const cleanedAiAnswer = aiAnswerString.toUpperCase().replace(/\s+/g, ''); const clickableOptionElements = questionBody.querySelectorAll(".subject_node .nodeLab"); const optionDetailElements = questionBody.querySelectorAll(".subject_node .nodeLab .node_detail"); if (aiQuestionTypeKey === 'TrueFalse') { if (clickableOptionElements.length >= 1 && optionDetailElements.length >= 1) { let targetOptionIndex = -1; if (cleanedAiAnswer.includes("æ­£ç¡®") || cleanedAiAnswer.includes("å¯¹") || cleanedAiAnswer.includes("T") || cleanedAiAnswer.includes("RIGHT")) { for(let i=0; i < optionDetailElements.length; i++){ const text = optionDetailElements[i].innerText.trim(); if(text.includes("æ­£ç¡®") || text.includes("å¯¹")){ targetOptionIndex = i; break; } } if (targetOptionIndex === -1 && optionDetailElements.length > 0 && (optionDetailElements[0].innerText.trim().includes("æ­£ç¡®") || optionDetailElements[0].innerText.trim().includes("å¯¹"))) targetOptionIndex = 0; else if (targetOptionIndex === -1) targetOptionIndex = 0; } else if (cleanedAiAnswer.includes("é”™è¯¯") || cleanedAiAnswer.includes("é”™") || cleanedAiAnswer.includes("F") || cleanedAiAnswer.includes("WRONG")) { for(let i=0; i < optionDetailElements.length; i++){ const text = optionDetailElements[i].innerText.trim(); if(text.includes("é”™è¯¯") || text.includes("é”™")){ targetOptionIndex = i; break; } } if (targetOptionIndex === -1 && optionDetailElements.length > 1 && (optionDetailElements[1].innerText.trim().includes("é”™è¯¯") || optionDetailElements[1].innerText.trim().includes("é”™"))) targetOptionIndex = 1; else if (targetOptionIndex === -1) targetOptionIndex = clickableOptionElements.length > 1 ? 1 : 0; } if(targetOptionIndex !== -1 && clickableOptionElements[targetOptionIndex]){ clickableOptionElements[targetOptionIndex].click(); if (clickableOptionElements[targetOptionIndex].querySelector('.node_detail')?.classList.contains('onChecked') || clickableOptionElements[targetOptionIndex].classList.contains('onChecked') || clickableOptionElements[targetOptionIndex].querySelector('input')?.checked) isSelectedSuccessfully = true; else { clickableOptionElements[targetOptionIndex].click(); if (clickableOptionElements[targetOptionIndex].querySelector('.node_detail')?.classList.contains('onChecked') || clickableOptionElements[targetOptionIndex].classList.contains('onChecked')) isSelectedSuccessfully = true; else console.warn(`[åˆ¤æ–­é¢˜ ${targetOptionIndex}] ç‚¹å‡»åæœªèƒ½ç¡®è®¤é€‰ä¸­ã€‚`);} } } } else if (aiQuestionTypeKey === 'SingleChoice') { const targetOptionLetter = cleanedAiAnswer.charAt(0); if (targetOptionLetter >= 'A' && targetOptionLetter <= 'Z') { const optionIndex = targetOptionLetter.charCodeAt(0) - 'A'.charCodeAt(0); if (clickableOptionElements[optionIndex]) { clickableOptionElements[optionIndex].click(); if (clickableOptionElements[optionIndex].querySelector('.node_detail')?.classList.contains('onChecked') || clickableOptionElements[optionIndex].classList.contains('onChecked') || clickableOptionElements[optionIndex].querySelector('input')?.checked) isSelectedSuccessfully = true; else { clickableOptionElements[optionIndex].click(); if (clickableOptionElements[optionIndex].querySelector('.node_detail')?.classList.contains('onChecked') || clickableOptionElements[optionIndex].classList.contains('onChecked')) isSelectedSuccessfully = true; else console.warn(`[å•é€‰é¢˜ ${targetOptionLetter}] ç‚¹å‡»åæœªèƒ½ç¡®è®¤é€‰ä¸­ã€‚`);} } } } else if (aiQuestionTypeKey === 'MultipleChoice') { const targetOptionsLetters = cleanedAiAnswer.split(',').map(s => s.trim()).filter(Boolean); let clickedCount = 0; targetOptionsLetters.forEach(letter => { if (letter >= 'A' && letter <= 'Z') { const optionIndex = letter.charCodeAt(0) - 'A'.charCodeAt(0); if (clickableOptionElements[optionIndex]) { clickableOptionElements[optionIndex].click(); clickedCount++; } } }); if (clickedCount === targetOptionsLetters.length && clickedCount > 0) isSelectedSuccessfully = true; else if (clickedCount > 0) { console.warn("å¤šé€‰é¢˜éƒ¨åˆ†é€‰é¡¹å¯èƒ½æœªåŒ¹é…:", cleanedAiAnswer); isSelectedSuccessfully = true; } } return isSelectedSuccessfully; }

// --- UI å’Œè¾…åŠ©å‡½æ•° ---
function truncateTitle(title) { if (title.length > 15) { return title.substring(0, 15) + '...'; } return title; } // å†çŸ­ä¸€ç‚¹

function appendToTable(questionTitle, answerString, questionIndex) {
    const truncatedTitle = truncateTitle(questionTitle); const tableBody = document.querySelector("#ai-record-table tbody");
    if (tableBody) {
        const mainRow = document.createElement('tr'); mainRow.id = `qrow-${questionIndex}`;
        mainRow.innerHTML = `
            <td class="qa-actions"> ${questionIndex}
                <button class="btn btn-xs btn-default toggle-log-btn" data-q-idx="${questionIndex}" title="AIäº¤äº’è¯¦æƒ…" style="padding:1px 3px; font-size:0.75em; margin-left:1px;">è¯¦</button>
                <button class="btn btn-xs btn-info copy-qa-btn" data-q-idx="${questionIndex}" title="å¤åˆ¶é¢˜ç›®å’Œé€‰é¡¹" style="padding:1px 3px; font-size:0.75em;">å¤</button>
            </td><td>${truncatedTitle}</td>
            <td id="ai-answer-${questionIndex}" style="min-width: 70px;">è¯·æ±‚AI...</td>
            <td id="ai-action-${questionIndex}" style="width: 45px;"><button id="retry-btn-${questionIndex}" class="btn btn-xs btn-warning retry-btn" data-question-index="${questionIndex}" style="padding:1px 3px; font-size:0.75em; display:none;">é‡è¯•</button></td>`;
        tableBody.appendChild(mainRow);
        const logRow = document.createElement('tr'); logRow.id = `qrow-${questionIndex}-log`; logRow.classList.add('ai-log-details'); logRow.style.display = 'none';
        logRow.innerHTML = `<td colspan="4" style="padding: 8px; background-color: #f9f9f9;"><div style="font-weight:bold; margin-bottom:5px;">AIäº¤äº’è¯¦æƒ… (é¢˜ç›® ${questionIndex}):</div><div style="margin-bottom:8px;"><strong style="color:#007bff;">Prompt:</strong><pre class="ai-prompt-cell" style="white-space: pre-wrap; word-break: break-all; max-height: 150px; overflow-y: auto; background-color: #eef; padding: 5px; border-radius: 3px; font-size:0.9em;"></pre></div><div><strong style="color:#28a745;">AIå“åº”:</strong><pre class="ai-response-cell" style="white-space: pre-wrap; word-break: break-all; max-height: 250px; overflow-y: auto; background-color: #efe; padding: 5px; border-radius: 3px; font-size:0.9em;"></pre></div></td>`;
        tableBody.appendChild(logRow);
        mainRow.querySelector('.toggle-log-btn').addEventListener('click', function() { const logTargetId = `qrow-${this.dataset.qIdx}-log`; const targetRow = document.getElementById(logTargetId); if (targetRow) { targetRow.style.display = targetRow.style.display === 'none' ? 'table-row' : 'none'; this.textContent = targetRow.style.display === 'none' ? 'è¯¦' : 'æ”¶'; }}); // æ”¹ä¸ºå•å­—
        mainRow.querySelector('.copy-qa-btn').addEventListener('click', function() { copyQuestionAndOptionsToClipboard(parseInt(this.dataset.qIdx)); });
        mainRow.querySelector('.retry-btn').addEventListener('click', function() { const qIndex = parseInt(this.getAttribute('data-question-index')); const questionData = CURRENT_PROCESSING_QUESTIONS.find(q => q.index === qIndex); if (questionData) { updateMsg(`æ­£åœ¨é‡è¯•ç¬¬ ${qIndex} é¢˜...`, "#007bff"); answerQuestionWithAI(questionData.type, questionData.description, questionData.body, qIndex, true); } });
    }
}

function copyQuestionAndOptionsToClipboard(questionIndex, all = false) {
    let textToCopy = "";
    if (all) {
        if (CURRENT_PROCESSING_QUESTIONS.length === 0) {
            GM_setClipboard("é”™è¯¯ï¼šæ²¡æœ‰é¢˜ç›®ä¿¡æ¯å¯å¤åˆ¶ã€‚"); updateMsg("å¤åˆ¶å¤±è´¥ï¼šæ— é¢˜ç›®ä¿¡æ¯ã€‚", "red"); return;
        }
        CURRENT_PROCESSING_QUESTIONS.forEach(qData => {
            textToCopy += `é¢˜ç›® ${qData.index}: ${qData.description.trim()}\n`;
            const optionElements = qData.body.querySelectorAll(".subject_node .nodeLab .node_detail");
            if (optionElements && optionElements.length > 0) {
                textToCopy += "é€‰é¡¹ï¼š\n";
                optionElements.forEach((opt, idx) => {
                    const optionLabel = String.fromCharCode(65 + idx); const optText = opt.innerText.trim().replace(/^[A-Z][\s.ã€]*/, '');
                    const extractedTypeMatch = qData.type.match(/ã€(.+?)ã€‘/); const isTrueFalse = extractedTypeMatch && extractedTypeMatch[1] === 'åˆ¤æ–­é¢˜';
                    if (isTrueFalse) { textToCopy += `${optText}\n`; } else { textToCopy += `${optionLabel}. ${optText}\n`; }
                });
            } else { textToCopy += "(æ— é€‰é¡¹æˆ–é€‰é¡¹æå–å¤±è´¥)\n"; }
            textToCopy += "\n"; // é¢˜ç›®é—´ç©ºä¸€è¡Œ
        });
        GM_setClipboard(textToCopy.trim()); updateMsg(`å…¨éƒ¨ ${CURRENT_PROCESSING_QUESTIONS.length} é“é¢˜ç›®åŠé€‰é¡¹å·²å¤åˆ¶ï¼`, "green");
    } else {
        const questionData = CURRENT_PROCESSING_QUESTIONS.find(q => q.index === questionIndex);
        if (!questionData) { GM_setClipboard("é”™è¯¯ï¼šæœªæ‰¾åˆ°é¢˜ç›®ä¿¡æ¯ã€‚"); updateMsg("å¤åˆ¶å¤±è´¥ï¼šæœªæ‰¾åˆ°é¢˜ç›®ä¿¡æ¯ã€‚", "red"); return; }
        textToCopy = `é¢˜ç›® ${questionIndex}: ${questionData.description.trim()}\n`;
        const optionElements = questionData.body.querySelectorAll(".subject_node .nodeLab .node_detail");
        if (optionElements && optionElements.length > 0) { textToCopy += "é€‰é¡¹ï¼š\n"; optionElements.forEach((opt, idx) => { const optionLabel = String.fromCharCode(65 + idx); const optText = opt.innerText.trim().replace(/^[A-Z][\s.ã€]*/, ''); const extractedTypeMatch = questionData.type.match(/ã€(.+?)ã€‘/); const isTrueFalse = extractedTypeMatch && extractedTypeMatch[1] === 'åˆ¤æ–­é¢˜'; if (isTrueFalse) { textToCopy += `${optText}\n`; } else { textToCopy += `${optionLabel}. ${optText}\n`; } }); }
        else { textToCopy += "(æ— é€‰é¡¹æˆ–é€‰é¡¹æå–å¤±è´¥)\n"; }
        GM_setClipboard(textToCopy); updateMsg(`é¢˜ç›® ${questionIndex} åŠé€‰é¡¹å·²å¤åˆ¶ï¼`, "green");
    }
}

function changeAnswerInTable(answerString, questionIndex, isSelect, errorMessage, showRetry) { const answerCell = document.querySelector(`#ai-answer-${questionIndex}`); const retryButton = document.querySelector(`#retry-btn-${questionIndex}`); if (answerCell) { answerCell.innerHTML = answerString || "AIæ— å›å¤"; if (errorMessage) { answerCell.insertAdjacentHTML('beforeend', `<div style="color:#ff8c00; font-size:0.85em; margin-top:2px;">${errorMessage}</div>`); } else if (!isSelect && answerString && !answerString.startsWith("AI")) { answerCell.insertAdjacentHTML('beforeend', `<div style="color:#dc3545; font-size:0.85em; margin-top:2px;">æœªåŒ¹é…é€‰é¡¹</div>`); } else if (isSelect){ answerCell.style.color = "#28a745"; answerCell.style.fontWeight = "bold"; } } if (retryButton) { retryButton.style.display = showRetry ? 'inline-block' : 'none'; if (!showRetry) retryButton.disabled = false; } }
function enableWebpackHook() { const originCall = Function.prototype.call; Function.prototype.call = function (...args) { const result = originCall.apply(this, args); if (args[2]?.default?.version === '2.5.2') { args[2]?.default?.mixin({ mounted: function () { if (this.$el && typeof this.$el === 'object') { this.$el['__Ivue__'] = this; } } }); } return result; }}
function makeElementDraggable(el) { el.style.position = 'fixed'; let shiftX, shiftY; const header = el.querySelector('.panel-heading'); if (!header) { console.warn("Draggable header not found for element:", el); return; } header.style.cursor = 'grab'; header.onmousedown = function(event) { if (event.target.closest('input, button, select, .panel-body-content, .table-panel-body, .ai-log-details pre, .window-controls button')) { return; } event.preventDefault(); header.style.cursor = 'grabbing'; shiftX = event.clientX - el.getBoundingClientRect().left; shiftY = event.clientY - el.getBoundingClientRect().top; el.style.zIndex = 100000; function moveAt(pageX, pageY) { let newLeft = pageX - shiftX; let newTop = pageY - shiftY; const rightEdge = window.innerWidth - el.offsetWidth; const bottomEdge = window.innerHeight - el.offsetHeight; if (newLeft < 0) newLeft = 0; if (newTop < 0) newTop = 0; if (newLeft > rightEdge) newLeft = rightEdge; if (newTop > bottomEdge) newTop = bottomEdge; el.style.left = newLeft + 'px'; el.style.top = newTop + 'px'; } function onMouseMove(event) { moveAt(event.pageX, event.pageY); } function onMouseUp() { header.style.cursor = 'grab'; document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); } document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); }; el.ondragstart = () => false; }
function updateMsg(msg, color = '#007bff') { const displayMsgEl = document.getElementById('ai-display-msg'); if (displayMsgEl) { displayMsgEl.innerText = msg; displayMsgEl.style.color = color; } }

// --- è„šæœ¬ä¸»é€»è¾‘ ---
unsafeWindow.onload = (() => (async () => {
    console.log("AIç­”é¢˜è„šæœ¬åˆå§‹åŒ–..."); GM_addStyle(GM_getResourceText("css")); GM_addStyle(` #ai-floating-window { box-shadow: 0 4px 12px rgba(0,0,0,0.15); border-radius: 8px; border: 1px solid #dee2e6; background-color: #fff;} #ai-floating-window .panel-heading { background-color: #007bff; color: white; border-top-left-radius: 7px; border-top-right-radius: 7px; padding: 8px 10px; cursor: grab; display: flex; justify-content: space-between; align-items: center; } #ai-floating-window .panel-title { font-size: 1.0em; font-weight: 600; margin:0; } #ai-floating-window .panel-body-content { padding: 10px; background-color: #f8f9fa; border-bottom: 1px solid #dee2e6; } #ai-floating-window label { font-size: 0.8em; margin-bottom: 1px; color: #495057; display: block;} #ai-floating-window .form-control, #ai-floating-window select { font-size: 0.85em; height: calc(1.4em + .5rem + 2px); padding: .2rem .4rem; margin-bottom: 6px; border-radius: 3px; width: 100%; box-sizing: border-box;} #ai-floating-window .btn { font-size: 0.85em; padding: 4px 7px; border-radius: 3px; margin-right: 4px;} #ai-display-msg { font-size: 0.8em; min-height: 16px; margin-top: 4px; font-weight: 500; } #ai-floating-window .table-panel-body { max-height: 150px; overflow-y: auto; padding: 0px; background-color: #ffffff; border-bottom-left-radius: 7px; border-bottom-right-radius: 7px;} #ai-record-table { font-size: 0.75em; margin-bottom: 0; table-layout: fixed; width:100%;} #ai-record-table th, #ai-record-table td { padding: 3px 5px; vertical-align: middle; word-break: break-word; } #ai-record-table th { background-color: #e9ecef; border-top: none !important; text-align: center;} #ai-record-table td.qa-actions { text-align: center; } #ai-record-table td:nth-child(2) { text-align: left; } #ai-record-table tr:last-child td { border-bottom: none; } .ai-log-details td { border-top: 1px dashed #ccc !important; } .toggle-log-btn, .copy-qa-btn, .retry-btn { vertical-align: middle; } #pause-resume-btn.paused { background-color: #28a745 !important; border-color: #28a745 !important; } .window-controls button { background: transparent; border: none; color: white; font-size: 1.1em; padding: 0 5px; line-height: 1; } `);
    let providerOptionsHTML = ""; for (const key in AI_PROVIDERS) { providerOptionsHTML += `<option value="${key}">${AI_PROVIDERS[key].name}</option>`; }
    const uiHTML = `
<div class="panel" id="ai-floating-window" style="position:fixed; left:15px; top:5%; width:320px; z-index:99999;">
  <div class="panel-heading">
    <h3 class="panel-title">ğŸ§  AIç­”é¢˜åŠ©æ‰‹ ğŸ§ </h3>
    <div class="window-controls">
        <button id="minimize-btn" title="æœ€å°åŒ–/æ¢å¤çª—å£">ï¼</button>
    </div>
  </div>
  <div class="panel-content-wrapper"> <!-- æ–°å¢ä¸€ä¸ªåŒ…è£…å™¨ç”¨äºéšè—/æ˜¾ç¤º -->
    <div class="panel-body-content">
        <div><label for="ai-provider-select">AIæœåŠ¡å•†:</label><select id="ai-provider-select" class="form-control">${providerOptionsHTML}</select></div>
        <div><label for="ai-api-url-input">API URL:</label><input id="ai-api-url-input" type="text" class="form-control" title="å¯¹åº”æœåŠ¡å•†çš„APIæ¥å£åœ°å€"/></div>
        <div><label for="ai-model-input">æ¨¡å‹åç§°:</label><input id="ai-model-input" type="text" class="form-control" title="è‡ªå®šä¹‰æ¨¡å‹åç§°, å¦‚gpt-4o"/></div>
        <div><label for="ai-api-key-input">API Key (å½“å‰æœåŠ¡å•†):</label><input id="ai-api-key-input" type="password" class="form-control" placeholder="è¾“å…¥API Key"/></div>
        <div style="display:flex; justify-content: space-around; align-items: center; margin-top:6px; flex-wrap: wrap;">
            <button id="save-ai-config-btn" class="btn btn-sm btn-info">ä¿å­˜é…ç½®</button>
            <button id="start-ai-autofill-btn" class="btn btn-sm btn-success">å¼€å§‹ç­”é¢˜</button>
            <button id="docs-btn" class="btn btn-sm btn-secondary" title="æŸ¥çœ‹ä½¿ç”¨è¯´æ˜">ä½¿ç”¨æ–‡æ¡£</button>
        </div>
        <div style="display:flex; justify-content: space-around; align-items: center; margin-top:4px; flex-wrap: wrap;">
            <button id="copy-all-qa-btn" class="btn btn-sm btn-primary" title="å¤åˆ¶æ‰€æœ‰å·²å¤„ç†çš„é¢˜ç›®å’Œé€‰é¡¹" style="display:none;">å¤åˆ¶å…¨éƒ¨</button>
            <button id="pause-resume-btn" class="btn btn-sm btn-warning" style="display:none;">æš‚åœç­”é¢˜</button>
        </div>
        <div id="ai-display-msg" class="text-center">ç­‰å¾…æ“ä½œ...</div>
    </div>
    <div class="table-panel-body"><table class="table table-bordered table-condensed" id="ai-record-table">
        <thead><tr><th style="width:22%;">#</th><th style="width:38%;">é¢˜ç›®</th><th style="width:25%;">AIç­”æ¡ˆ</th><th style="width:15%;">æ“ä½œ</th></tr></thead>
        <tbody></tbody>
    </table></div>
  </div>
</div>`;
    document.body.insertAdjacentHTML('beforeend', uiHTML); makeElementDraggable(document.getElementById('ai-floating-window'));
    const providerSelect = document.getElementById('ai-provider-select'); const apiUrlInput = document.getElementById('ai-api-url-input'); const apiKeyInput = document.getElementById('ai-api-key-input'); const modelInput = document.getElementById('ai-model-input'); const pauseResumeBtn = document.getElementById('pause-resume-btn'); const docsBtn = document.getElementById('docs-btn'); const minimizeBtn = document.getElementById('minimize-btn'); const panelContentWrapper = document.querySelector('#ai-floating-window .panel-content-wrapper'); const copyAllQaBtn = document.getElementById('copy-all-qa-btn');

    minimizeBtn.onclick = () => {
        IS_WINDOW_MINIMIZED = !IS_WINDOW_MINIMIZED;
        if (IS_WINDOW_MINIMIZED) {
            panelContentWrapper.style.display = 'none';
            minimizeBtn.textContent = 'ï¼‹'; // æˆ–è€…ç”¨å›¾æ ‡
            minimizeBtn.title = 'æ¢å¤çª—å£';
        } else {
            panelContentWrapper.style.display = 'block';
            minimizeBtn.textContent = 'ï¼';
            minimizeBtn.title = 'æœ€å°åŒ–çª—å£';
        }
    };

    copyAllQaBtn.onclick = () => { copyQuestionAndOptionsToClipboard(null, true); };

    function loadProviderConfig(providerKey) { const provider = AI_PROVIDERS[providerKey]; apiUrlInput.value = GM_getValue(`aiApiUrl_${providerKey}`, provider.defaultUrl); modelInput.value = GM_getValue(`aiModel_${providerKey}`, provider.defaultModel); modelInput.placeholder = `é»˜è®¤: ${provider.defaultModel}`; apiKeyInput.value = GM_getValue(`aiApiKey_${providerKey}`, ''); apiKeyInput.placeholder = `è¯·è¾“å…¥ ${provider.name} çš„ API Key`; }
    providerSelect.addEventListener('change', function() { GM_setValue('selectedAiProvider', this.value); loadProviderConfig(this.value); });
    const lastSelectedProvider = GM_getValue('selectedAiProvider', 'OPENAI'); providerSelect.value = lastSelectedProvider; loadProviderConfig(lastSelectedProvider);

    document.getElementById('save-ai-config-btn').onclick = () => { const selectedProviderKey = providerSelect.value; const provider = AI_PROVIDERS[selectedProviderKey]; GM_setValue(`aiApiUrl_${selectedProviderKey}`, apiUrlInput.value.trim()); GM_setValue(`aiApiKey_${selectedProviderKey}`, apiKeyInput.value.trim()); GM_setValue(`aiModel_${selectedProviderKey}`, modelInput.value.trim() || provider.defaultModel); GM_setValue('selectedAiProvider', selectedProviderKey); updateMsg(`${provider.name} é…ç½®å·²ä¿å­˜ï¼`, "#28a745"); };
    docsBtn.onclick = () => { window.open(DOCUMENTATION_URL, '_blank'); };
    pauseResumeBtn.onclick = () => { IS_PAUSED = !IS_PAUSED; if (IS_PAUSED) { pauseResumeBtn.textContent = "ç»§ç»­ç­”é¢˜"; pauseResumeBtn.classList.add("paused"); updateMsg("ç­”é¢˜å·²æš‚åœã€‚", "orange"); } else { pauseResumeBtn.textContent = "æš‚åœç­”é¢˜"; pauseResumeBtn.classList.remove("paused"); updateMsg("ç­”é¢˜å·²æ¢å¤ï¼Œå¤„ç†ä¸‹ä¸€é¢˜...", "#007bff"); processNextQuestionFromQueue(); }};
    let questionQueue = []; let currentQuestionQueueIndex = 0;
    async function processNextQuestionFromQueue() { if (IS_PAUSED) return; if (currentQuestionQueueIndex < questionQueue.length) { const question = questionQueue[currentQuestionQueueIndex]; updateMsg(`å¤„ç†ä¸­: ${question.index} / ${questionQueue.length} (æ€»)`, "#007bff"); question.body.scrollIntoView({ behavior: 'smooth', block: 'center' }); await sleep(600); await answerQuestionWithAI(question.type, question.description, question.body, question.index); currentQuestionQueueIndex++; await sleep(config.requestDelay); processNextQuestionFromQueue(); } else { updateMsg(`æ‰€æœ‰ ${questionQueue.length} é¢˜å¤„ç†å®Œæ¯•ï¼`, "#28a745"); document.getElementById('start-ai-autofill-btn').disabled = false; pauseResumeBtn.style.display = 'none'; copyAllQaBtn.style.display = 'inline-block'; const submitButton = document.querySelector('button.btn-submit, button.btn-handExam, input[type="button"][value="äº¤å·"], a[onclick*="submitExam"], div.submit-btn'); if (submitButton) { alert("AIç­”é¢˜å®Œæˆï¼è¯·ä»”ç»†æ£€æŸ¥ç­”æ¡ˆåæ‰‹åŠ¨ç‚¹å‡»â€œäº¤å·â€æˆ–â€œæäº¤â€æŒ‰é’®ã€‚"); submitButton.style.outline = "3px solid red"; submitButton.style.transform = "scale(1.1)"; submitButton.scrollIntoView({ behavior: 'smooth', block: 'center' }); } else { alert("AIç­”é¢˜å®Œæˆï¼æœªæ‰¾åˆ°æ˜ç¡®çš„äº¤å·æŒ‰é’®ï¼Œè¯·æ‰‹åŠ¨æ“ä½œã€‚"); } } }
    document.getElementById('start-ai-autofill-btn').onclick = async () => { const selectedProviderKey = providerSelect.value; const currentApiUrl = GM_getValue(`aiApiUrl_${selectedProviderKey}`); const currentApiKey = GM_getValue(`aiApiKey_${selectedProviderKey}`); const provider = AI_PROVIDERS[selectedProviderKey]; let apiKeyNeeded = true; if (provider === AI_PROVIDERS.GEMINI && currentApiUrl.toLowerCase().includes('key=')) { apiKeyNeeded = false; } if (!currentApiUrl || (apiKeyNeeded && !currentApiKey)) { updateMsg(`è¯·å…ˆä¸º ${provider.name} é…ç½®API URL${apiKeyNeeded ? 'å’ŒKey':''}å¹¶ä¿å­˜ï¼`, "#dc3545"); return; } updateMsg("å¼€å§‹AIè‡ªåŠ¨ç­”é¢˜...", "#007bff"); document.getElementById('start-ai-autofill-btn').disabled = true; pauseResumeBtn.style.display = 'inline-block'; pauseResumeBtn.textContent = "æš‚åœç­”é¢˜"; pauseResumeBtn.classList.remove("paused"); IS_PAUSED = false; copyAllQaBtn.style.display = 'none'; document.querySelector("#ai-record-table tbody").innerHTML = ""; await sleep(config.awaitTime); const questionBodyAll = document.querySelectorAll(".examPaper_subject"); if (questionBodyAll.length === 0) { updateMsg("æœªæ£€æµ‹åˆ°é¢˜ç›®ã€‚", "#dc3545"); document.getElementById('start-ai-autofill-btn').disabled = false; pauseResumeBtn.style.display = 'none'; return; } CURRENT_PROCESSING_QUESTIONS = []; questionQueue = []; currentQuestionQueueIndex = 0;
        questionBodyAll.forEach((questionBody, index) => { const subjectNumElement = questionBody.querySelector(".subject_num.fl"); const questionNumberText = subjectNumElement ? subjectNumElement.textContent.trim() : `${index + 1}`; const questionTypeElement = questionBody.querySelector(".subject_type_annex") || questionBody.querySelector(".subject_type span:first-child"); const questionTypeStringFromDOM = questionTypeElement ? questionTypeElement.textContent.trim() : 'ã€æœªçŸ¥é¢˜å‹ã€‘'; let questionDescription = ''; let smallStemPElement = questionBody.querySelector(".smallStem_describe p") || questionBody.querySelector(".smallStem_describe"); if (smallStemPElement && typeof smallStemPElement.textContent === 'string') { questionDescription = smallStemPElement.textContent.trim(); } if (!questionDescription) { const descriptionDivs = questionBody.querySelectorAll(".subject_describe div"); let foundViaIvue = false; for (const div of descriptionDivs) { if (div.__Ivue__ && div.__Ivue__._data && typeof div.__Ivue__._data.shadowDom?.textContent === 'string' && div.__Ivue__._data.shadowDom.textContent.trim() !== "") { questionDescription = div.__Ivue__._data.shadowDom.textContent.trim(); foundViaIvue = true; break; } } if (!foundViaIvue && descriptionDivs.length > 0 && typeof descriptionDivs[0].textContent === 'string') { questionDescription = descriptionDivs[0].textContent.trim(); } } if (!questionDescription) { const subjectDescribeElement = questionBody.querySelector(".subject_describe"); if (subjectDescribeElement && typeof subjectDescribeElement.innerText === 'string') { questionDescription = subjectDescribeElement.innerText.trim(); }} if (questionDescription) { questionDescription = questionDescription.replace(/^\d+\s*[\.ã€ï¼]\s*/, '').trim(); if (questionTypeStringFromDOM && questionDescription.startsWith(questionTypeStringFromDOM)) { questionDescription = questionDescription.substring(questionTypeStringFromDOM.length).trim(); } const typeTextOnly = questionTypeStringFromDOM.replace(/[ã€ã€‘]/g, ""); if (typeTextOnly && questionDescription.startsWith(typeTextOnly)) { if (questionDescription.length > typeTextOnly.length && (questionDescription[typeTextOnly.length] === ' ' || !isNaN(parseInt(questionDescription[typeTextOnly.length])) ) ) { questionDescription = questionDescription.substring(typeTextOnly.length).trim(); } } questionDescription = questionDescription.replace(/^ã€.*?ã€‘\s*/, '').trim().replace(/^(é¢˜ç›®|é¢˜å¹²)[:ï¼š\s]*/, '').trim(); }
            if (questionDescription) { const questionData = { index: index + 1, type: questionTypeStringFromDOM, description: questionDescription, body: questionBody }; CURRENT_PROCESSING_QUESTIONS.push(questionData); questionQueue.push(questionData); }
            else { console.warn(`[é¢˜ç›® ${index + 1}] æè¿°æå–å¤±è´¥ã€‚`); updateMsg(`è­¦å‘Š: ç¬¬ ${index + 1} é¢˜ç›®æè¿°æå–å¤±è´¥ã€‚`, "#ffc107"); }
        });
        if (questionQueue.length === 0) { updateMsg("æœªèƒ½æˆåŠŸæå–ä»»ä½•é¢˜ç›®ä¿¡æ¯ã€‚", "#dc3545"); document.getElementById('start-ai-autofill-btn').disabled = false; pauseResumeBtn.style.display = 'none'; return; }
        updateMsg(`å…± ${questionQueue.length} é¢˜ï¼Œå¼€å§‹å¤„ç†...`, "#007bff"); processNextQuestionFromQueue();
    };
}))();