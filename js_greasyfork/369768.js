// ==UserScript==
// @name         Steam saliengame_idler Loading Helper
// @namespace    iFantz7E.sslh
// @version      0.51
// @description  load saliengame_idler
// @author       7-elephant
// @match        https://steamcommunity.com/saliengame/play
// @match        https://steamcommunity.com/saliengame/play/
// @grant        GM_addStyle
// @downloadURL https://update.greasyfork.org/scripts/369768/Steam%20saliengame_idler%20Loading%20Helper.user.js
// @updateURL https://update.greasyfork.org/scripts/369768/Steam%20saliengame_idler%20Loading%20Helper.meta.js
// ==/UserScript==

(function()
{
    'use strict';

    GM_addStyle(
        "   .sslh_freeBox { position: fixed; z-index: 999; top: 104px; right: 0px; "
        + "   line-height: 24px; text-align: center; background-color: #EEE; "
        + "   padding: 0px; color: black; font-size: 100%; } "
        + " #sslh_cur { padding: 5px 10px 5px 10px; display: inline-block; cursor: pointer; } "
        + " #salienbot_gui { position: absolute; top: -15px; padding-top: 0px !important; padding-bottom: 0px !important; } "
    );

    var eleDiv = document.createElement("div");
    eleDiv.classList.add("sslh_freeBox");

    var inner = " <span id='sslh_cur'>Load saliengame_idler</span> ";

    eleDiv.innerHTML = inner;
    document.body.appendChild(eleDiv);

    document.querySelector("#sslh_cur").addEventListener("click", function(ev)
    {
        var eleTarget = ev.target;

        var eleClientScript = document.createElement("script");
        //eleClientScript.setAttribute("src", "https://raw.githubusercontent.com/ensingm2/saliengame_idler/master/idle.js");
        eleClientScript.innerHTML = "\/\/ This is the zone you want to attack (Optional, otherwise picks one for you).\r\nvar target_zone = -1;\r\n\r\n\/\/ Variables. Don\'t change these unless you know what you\'re doing.\r\nvar real_round_length = 120; \/\/ Round Length of a real game (In Seconds, for calculating score)\r\nvar resend_frequency = 110; \/\/ Frequency at which we can say we finished a round (May be different than real length)\r\nvar update_length = 1; \/\/ How long to wait between updates (In Seconds)\r\nvar loop_rounds = true;\r\nvar language = \"english\"; \/\/ Used when POSTing scores\r\nvar access_token = \"\";\r\nvar current_game_id = undefined;\r\nvar current_game_start = undefined; \/\/ Timestamp for when the current game started\r\nvar time_passed_ms = 0;\r\nvar current_timeout = undefined;\r\nvar max_retry = 5; \/\/ Max number of retries to send requests\r\nvar auto_first_join = true; \/\/ Automatically join the best zone at first\r\nvar current_planet_id = undefined;\r\nvar auto_switch_planet = {\r\n\t\"active\": false, \/\/ Automatically switch to the best planet available (true : yes, false : no)\r\n\t\"current_difficulty\": undefined,\r\n\t\"wanted_difficulty\": 3, \/\/ Difficulty prefered. Will check planets if the current one differs\r\n\t\"rounds_before_check\": 5, \/\/ If we\'re not in a wanted difficulty zone, we start a planets check in this amount of rounds\r\n\t\"current_round\": 0,\r\n\t\"coeffScore\": {\r\n\t\t1: 1,\r\n\t\t2: 100,\r\n\t\t3: 10000\r\n\t}\r\n};\r\n\r\nvar oldTitle = document.title;\r\n\r\nvar BotGUI = class BotGUI {\r\n\tconstructor(state) {\r\n\t\tconsole.log(\'GUI Has been created\');\r\n\r\n\t\tthis.state = state;\r\n\t\t\r\n\t\tthis.createStatusWindow();\r\n\t\tthis.createProgressBar();\r\n\t}\r\n\r\n\tcreateStatusWindow() {\r\n\t\tif(document.getElementById(\'salienbot_gui\')) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar $statusWindow = $J([\r\n\t\t\t\'<div id=\"salienbot_gui\" style=\"background: #191919; z-index: 1; border: 3px solid #83d674; padding: 20px; margin: 15px; width: 300px; transform: translate(0, 0);\">\',\r\n\t\t\t\t\'<h1><a href=\"https:\/\/github.com\/ensingm2\/saliengame_idler\/\">Salien Game Idler<\/a><\/h1>\',\r\n\t\t\t\t\'<p style=\"margin-top: -.8em; font-size: .75em\"><span id=\"salienbot_status\"><\/span><\/p>\', \/\/ Running or stopped\r\n\t\t\t\t\'<p><b>Task:<\/b> <span id=\"salienbot_task\">Initializing<\/span><\/p>\', \/\/ Current task\r\n\t\t\t\t`<p><b>Target Zone:<\/b> <span id=\"salienbot_zone\">None<\/span><\/p>`,\r\n\t\t\t\t`<p style=\"display: none;\" id=\"salienbot_zone_difficulty_div\"><b>Zone Difficulty:<\/b> <span id=\"salienbot_zone_difficulty\"><\/span><\/p>`,\r\n\t\t\t\t\'<p><b>Level:<\/b> <span id=\"salienbot_level\">\' + this.state.level + \'<\/span> &nbsp;&nbsp;&nbsp;&nbsp; <b>EXP:<\/b> <span id=\"salienbot_exp\">\' + this.state.exp + \'<\/span><\/p>\',\r\n\t\t\t\t\'<p><b>Lvl Up In:<\/b> <span id=\"salienbot_esttimlvl\"><\/span><\/p>\',\r\n\t\t\t\t\/\/\'<p><input id=\"disableAnimsBtn\" type=\"button\" onclick=\"INJECT_disable_animations()\" value=\"Disable Animations\"\/><\/p>\',\r\n\t\t\t\'<\/div>\'\r\n\t\t].join(\'\'))\r\n\r\n\t\t$J(\'#salien_game_placeholder\').append( $statusWindow )\r\n\t}\r\n\r\n\tcreateProgressBar() {\r\n\t\tthis.progressbar = new CProgressBar(63);\r\n\t\tthis.progressbar.x = 2\r\n\t\tthis.progressbar.y = 48\r\n\t}\r\n\r\n\tupdateStatus(running) {\r\n\t\tconst statusTxt = running ? \'<span style=\"color: green;\">\u2713 Running<\/span>\' : \'<span style=\"color: red;\">\u2717 Stopped<\/span>\';\r\n\r\n\t\t$J(\'#salienbot_status\').html(statusTxt);\r\n\t\tif (running)\r\n\t\t{\r\n\t\t\tvar newTitle = oldTitle;\r\n\t\t\tif (newTitle !== document.title)\r\n\t\t\t{\r\n\t\t\t\tdocument.title = newTitle;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tvar newTitle = \"X \" + oldTitle;\r\n\t\t\tif (newTitle !== document.title)\r\n\t\t\t{\r\n\t\t\t\tdocument.title = newTitle;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tupdateTask(status, log_to_console) {\r\n\t\tif(log_to_console || log_to_console === undefined)\r\n\t\t\tconsole.log(status);\r\n\t\tdocument.getElementById(\'salienbot_task\').innerText = status;\r\n\t}\r\n\r\n\tupdateExp(exp) {\r\n\t\tdocument.getElementById(\'salienbot_exp\').innerText = exp;\r\n\t}\r\n\r\n\tupdateLevel(level) {\r\n\t\tdocument.getElementById(\'salienbot_level\').innerText = level;\r\n\t}\r\n\r\n\tupdateEstimatedTime(secondsLeft) {\r\n\t\tlet date = new Date(null);\r\n\t\tdate.setSeconds(secondsLeft);\r\n\t\tvar result = date.toISOString().substr(11, 8);\r\n\r\n\t\tvar timeTxt = result.replace(\/(\\d{2}):(\\d{2}):(\\d{2})\/gm, \'$1h $2m $3s\');\r\n\r\n\t\tdocument.getElementById(\'salienbot_esttimlvl\').innerText = timeTxt;\r\n\t}\r\n\r\n\tupdateZone(zone, progress, difficulty) {\r\n\t\tvar printString = zone;\r\n\t\tif(progress !== undefined)\r\n\t\t\tprintString += \" (\" + (progress * 100).toFixed(2) + \"% Complete)\"\r\n\t\tif(progress === undefined) {\r\n\t\t\t$J(\"#salienbot_zone_difficulty_div\").hide();\r\n\t\t\tdifficulty = \"\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\t$J(\"#salienbot_zone_difficulty_div\").show();\r\n\t\t\tgGame.m_State.m_Grid.m_Tiles[target_zone].addChild(this.progressbar)\r\n\t\t}\r\n\r\n\t\tdocument.getElementById(\'salienbot_zone\').innerText = printString;\r\n\t\tdocument.getElementById(\'salienbot_zone_difficulty\').innerText = difficulty;\r\n\t}\r\n};\r\n\r\nvar gui = new BotGUI({\r\n\tlevel: gPlayerInfo.level,\r\n\texp: gPlayerInfo.score\r\n});\r\n\r\nfunction calculateTimeToNextLevel() {\t\r\n\tconst nextScoreAmount = get_max_score(target_zone);\r\n\tconst missingExp = Math.ceil((gPlayerInfo.next_level_score - gPlayerInfo.score) \/ nextScoreAmount) * nextScoreAmount;\r\n\tconst roundTime = resend_frequency + update_length;\r\n\r\n\tconst secondsLeft = missingExp \/ nextScoreAmount * roundTime - time_passed_ms \/ 1000;\r\n\r\n\treturn secondsLeft;\r\n}\r\n\r\n\/\/ Grab the user\'s access token\r\nvar INJECT_get_access_token = function() {\r\n\t$J.ajax({\r\n\t\tasync: false,\r\n\t\ttype: \"GET\",\r\n\t\turl: \"https:\/\/steamcommunity.com\/saliengame\/gettoken\",\r\n\t\tsuccess: function(data) {\r\n\t\t\tif(data.token != undefined) {\r\n\t\t\t\tconsole.log(\"Got access token: \" + data.token);\r\n\t\t\t\taccess_token = data.token;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconsole.log(\"Failed to retrieve access token.\")\r\n\t\t\t\taccess_token = undefined;\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\n\r\n\/\/ Make the call to start a round, and kick-off the idle process\r\nvar INJECT_start_round = function(zone, access_token, attempt_no) {\r\n\tif(attempt_no === undefined)\r\n\t\tattempt_no = 0;\r\n\r\n\t\/\/ Leave the game if we\'re already in one.\r\n\tif(current_game_id !== undefined) {\r\n\t\tgui.updateTask(\"Previous game detected. Ending it.\", true);\r\n\t\tINJECT_leave_round();\r\n\t}\r\n\r\n\t\/\/ Send the POST to join the game.\r\n\t$J.ajax({\r\n\t\tasync: false,\r\n\t\ttype: \"POST\",\r\n\t\turl: \"https:\/\/community.steam-api.com\/ITerritoryControlMinigameService\/JoinZone\/v0001\/\",\r\n\t\tdata: { access_token: access_token, zone_position: zone },\r\n\t\tsuccess: function(data) {\r\n\t\t\tif( $J.isEmptyObject(data.response) ) {\r\n\t\t\t\t\/\/ Check if the zone is completed\r\n\t\t\t\tINJECT_update_grid();\r\n\t\t\t\tif(window.gGame.m_State.m_Grid.m_Tiles[target_zone].Info.captured || attempt_no >= max_retry) {\r\n\t\t\t\t\tif (auto_switch_planet.active == true)\r\n\t\t\t\t\t\tCheckSwitchBetterPlanet();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tSwitchNextZone();\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tconsole.log(\"Error getting zone response:\",data);\r\n\t\t\t\t\tgui.updateTask(\"Waiting 5s and re-sending join attempt(Attempt #\" + attempt_no + \").\");\r\n\t\t\t\t\tsetTimeout(function() { INJECT_start_round(zone, access_token, attempt_no+1); }, 5000);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconsole.log(\"Round successfully started in zone #\" + zone);\r\n\t\t\t\tconsole.log(data);\r\n\r\n\t\t\t\t\/\/ Set target\r\n\t\t\t\ttarget_zone = zone;\r\n\r\n\t\t\t\tif (auto_switch_planet.active == true) {\r\n\t\t\t\t\tif (auto_switch_planet.current_difficulty != data.response.zone_info.difficulty)\r\n\t\t\t\t\t\tauto_switch_planet.current_round = 0; \/\/ Difficulty changed, reset rounds counter before new planet check\r\n\t\t\t\t\tauto_switch_planet.current_difficulty = data.response.zone_info.difficulty;\r\n\t\t\t\t\tif (auto_switch_planet.current_difficulty < auto_switch_planet.wanted_difficulty) {\r\n\t\t\t\t\t\tif (auto_switch_planet.current_round >= auto_switch_planet.rounds_before_check) {\r\n\t\t\t\t\t\t\tauto_switch_planet.current_round = 0;\r\n\t\t\t\t\t\t\tCheckSwitchBetterPlanet(true);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tauto_switch_planet.current_round++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t\/\/ Update the GUI\r\n        \t\tgui.updateStatus(true);\r\n\t\t\t\tgui.updateZone(zone, data.response.zone_info.capture_progress, data.response.zone_info.difficulty);\r\n\t\t\t\tgui.updateEstimatedTime(calculateTimeToNextLevel());\r\n        \r\n\t\t\t\tcurrent_game_id = data.response.zone_info.gameid;\r\n\t\t\t\tcurrent_game_start = new Date().getTime();\r\n\t\t\t\tINJECT_wait_for_end(resend_frequency);\r\n\t\t\t}\r\n\t\t},\r\n\t\terror: function (xhr, ajaxOptions, thrownError) {\r\n\t\t\tconsole.log(\"Error starting round: \" + xhr.status + \": \" + thrownError);\r\n\t\t\tvar newTitle = \"X \" + oldTitle;\r\n\t\t\tif (newTitle !== document.title)\r\n\t\t\t{\r\n\t\t\t\tdocument.title = newTitle;\r\n\t\t\t}\t\t\t\t\t  \r\n\t\t}\r\n\t});\r\n}\r\n\r\n\/\/ Update time remaining, and wait for the round to complete.\r\nvar INJECT_wait_for_end = function() {\r\n\tvar now = new Date().getTime();\r\n\ttime_passed_ms = now - current_game_start;\r\n\tvar time_remaining_ms = (resend_frequency*1000) - time_passed_ms;\r\n\tvar time_remaining = Math.round(time_remaining_ms\/1000);\r\n\r\n\t\/\/ Update GUI\r\n\tgui.updateTask(\"Waiting \" + Math.max(time_remaining, 0) + \"s for round to end\", false);\r\n\tgui.updateStatus(true);\r\n\tgui.updateEstimatedTime(calculateTimeToNextLevel())\r\n\tgui.progressbar.SetValue(time_passed_ms\/(resend_frequency*1000))\r\n\r\n\t\/\/ Wait\r\n\tvar wait_time = update_length*1000;;\r\n\tvar callback;\r\n\t\r\n\t\/\/ use absolute timestamps to calculate if the game is over, since setTimeout timings are not always reliable\r\n\tif(time_remaining_ms <= 0) {\r\n\t\tcallback = function() { INJECT_end_round(); };\r\n\t}\r\n\telse { \r\n\t\tcallback = function() { INJECT_wait_for_end(); };\r\n\t}\r\n\t\r\n\t\/\/ Set the timeout\r\n\tcurrent_timeout = setTimeout(callback, wait_time);\r\n}\r\n\r\n\/\/ Send the call to end a round, and restart if needed.\r\nvar INJECT_end_round = function(attempt_no) {\r\n\tif(attempt_no === undefined)\r\n\t\tattempt_no = 0;\r\n\r\n\t\/\/ Grab the max score we\'re allowed to send\r\n\tvar score = get_max_score();\r\n\r\n\t\/\/ Update gui\r\n\tgui.updateTask(\"Ending Round\");\r\n\r\n\t\/\/ Post our \"Yay we beat the level\" call\r\n\t$J.ajax({\r\n\t\tasync: false,\r\n\t\ttype: \"POST\",\r\n\t\turl: \"https:\/\/community.steam-api.com\/ITerritoryControlMinigameService\/ReportScore\/v0001\/\",\r\n\t\tdata: { access_token: access_token, score: score, language: language },\r\n\t\tsuccess: function(data) {\r\n\t\t\tif( $J.isEmptyObject(data.response) ) {\r\n\t\t\t\t\/\/ Check if the zone is completed\r\n\t\t\t\tINJECT_update_grid();\r\n\t\t\t\tif(window.gGame.m_State.m_Grid.m_Tiles[target_zone].Info.captured || attempt_no >= max_retry) {\r\n\t\t\t\t\tif (auto_switch_planet.active == true)\r\n\t\t\t\t\t\tCheckSwitchBetterPlanet();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tSwitchNextZone();\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tconsole.log(\"Error getting zone response:\",data);\r\n\t\t\t\t\tgui.updateTask(\"Waiting 5s and re-sending score(Attempt #\" + attempt_no + \").\");\r\n\t\t\t\t\tsetTimeout(function() { INJECT_end_round(attempt_no+1); }, 5000);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconsole.log(\"Successfully finished the round and got expected data back:\");\r\n\t\t\t\tconsole.log(\"Level: \", data.response.new_level, \"\\nEXP:   \", data.response.new_score);\r\n\t\t\t\tconsole.log(data);\r\n\r\n\t\t\t\tgui.updateLevel(data.response.new_level);\r\n\t\t\t\tgui.updateExp(data.response.new_score);\r\n\t\t\t\t\/\/ When we get a new EXP we also want to recalculate the time for next level.\r\n\t\t\t\tgui.updateEstimatedTime(calculateTimeToNextLevel())\r\n\r\n\t\t\t\t\/\/ Update the player info in the UI\r\n\t\t\t\tINJECT_update_player_info();\r\n\r\n\t\t\t\t\/\/ Update the GUI\r\n\t\t\t\twindow.gui.updateZone(\"None\");\r\n\r\n\t\t\t\t\/\/ Restart the round if we have that variable set\r\n\t\t\t\tif(loop_rounds) {\r\n\t\t\t\t\tUpdateNotificationCounts();\r\n\t\t\t\t\tcurrent_game_id = undefined;\r\n\t\t\t\t\tINJECT_start_round(target_zone, access_token)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\n\r\n\/\/ Leave an existing game\r\nvar INJECT_leave_round = function() {\r\n\tif(current_game_id === undefined)\r\n\t\treturn;\r\n\r\n\tconsole.log(\"Leaving game: \" + current_game_id);\r\n\r\n\t\/\/ Cancel timeouts\r\n\tclearTimeout(current_timeout);\r\n\r\n\t\/\/ POST to the endpoint\r\n\t$J.ajax({\r\n\t\tasync: false,\r\n\t\ttype: \"POST\",\r\n\t\turl: \"https:\/\/community.steam-api.com\/IMiniGameService\/LeaveGame\/v0001\/\",\r\n\t\tdata: { access_token: access_token, gameid: current_game_id },\r\n\t\tsuccess: function(data) {}\r\n\t});\r\n\r\n\t\/\/ Clear the current game ID var\r\n\tcurrent_game_id = undefined;\r\n\r\n\t\/\/ Update the GUI\r\n\tgui.updateTask(\"Left Zone #\" + target_zone);\r\n\tgui.updateStatus(false);\r\n\r\n\ttarget_zone = -1;\r\n}\r\n\r\n\/\/ returns 0 for easy, 1 for medium, 2 for hard\r\nvar INJECT_get_difficulty = function(zone_id) {\r\n\treturn window.gGame.m_State.m_PlanetData.zones[zone_id].difficulty;\r\n}\r\n\r\n\/\/ Updates the player info\r\n\/\/ Currently unused. This was meant to hopefully update the UI.\r\nvar INJECT_update_player_info = function() {\r\n\tgServer.GetPlayerInfo(\r\n\t\tfunction( results ) {\r\n\t\t\tgPlayerInfo = results.response;\r\n\t\t},\r\n\t\tfunction(){}\r\n\t);\r\n}\r\n\r\n\/\/ Update the zones of the grid (map) on the current planet\r\nvar INJECT_update_grid = function() {\r\n\tif(current_planet_id === undefined)\r\n\t\treturn;\r\n\r\n\tgui.updateTask(\'Updating grid\', true);\r\n\r\n\t\/\/ GET to the endpoint\r\n\t$J.ajax({\r\n\t\tasync: false,\r\n\t\ttype: \"GET\",\r\n\t\turl: \"https:\/\/community.steam-api.com\/ITerritoryControlMinigameService\/GetPlanet\/v0001\/\",\r\n\t\tdata: { id: current_planet_id },\r\n\t\tsuccess: function(data) {\r\n\t\t\twindow.gGame.m_State.m_PlanetData = data.response.planets[0];\r\n\t\t\twindow.gGame.m_State.m_PlanetData.zones.forEach( function ( zone ) {\r\n\t\t\t\twindow.gGame.m_State.m_Grid.m_Tiles[zone.zone_position].Info.progress = zone.capture_progress; \r\n\t\t\t\twindow.gGame.m_State.m_Grid.m_Tiles[zone.zone_position].Info.captured = zone.captured; \r\n\t\t\t\twindow.gGame.m_State.m_Grid.m_Tiles[zone.zone_position].Info.difficulty = zone.difficulty; \r\n\t\t\t});\r\n\t\t\tconsole.log(\"Successfully updated map data on planet: \" + current_planet_id);\r\n\t\t}\r\n\t});\r\n}\r\n\r\n\/\/ Defaults to max score of current zone & full round duration if no params are given\r\nfunction get_max_score(zone, round_duration) {\r\n\t\/\/ defaults\r\n\tif(zone === undefined)\r\n\t\tzone = target_zone;\r\n\tif(round_duration === undefined)\r\n\t\tround_duration = real_round_length;\r\n\r\n\tvar difficulty = INJECT_get_difficulty(zone);\r\n\tvar score = 5 * round_duration * Math.pow(2, (difficulty-1));\r\n\r\n\treturn score;\r\n}\r\n\r\n\/\/ Get the best zone available\r\nfunction GetBestZone() {\r\n\tvar bestZoneIdx;\r\n\tvar highestDifficulty = -1;\r\n\r\n\tgui.updateTask(\'Getting best zone\');\r\n\r\n\tfor (var idx = 0; idx < window.gGame.m_State.m_Grid.m_Tiles.length; idx++) {\r\n\t\tvar zone = window.gGame.m_State.m_Grid.m_Tiles[idx].Info;\r\n\t\tif (!zone.captured) {\r\n\t\t\tif (zone.boss) {\r\n\t\t\t\tconsole.log(\"Zone \" + idx + \" with boss. Switching to it.\");\r\n\t\t\t\treturn idx;\r\n\t\t\t}\r\n\r\n\t\t\tif(zone.difficulty > highestDifficulty) {\r\n\t\t\t\thighestDifficulty = zone.difficulty;\r\n\t\t\t\tmaxProgress = zone.progress;\r\n\t\t\t\tbestZoneIdx = idx;\r\n\t\t\t} else if(zone.difficulty < highestDifficulty) continue;\r\n\r\n\t\t\tif(zone.progress < maxProgress) {\r\n\t\t\t\tmaxProgress = zone.progress;\r\n\t\t\t\tbestZoneIdx = idx;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif(bestZoneIdx !== undefined) {\r\n\t\tconsole.log(`${window.gGame.m_State.m_PlanetData.state.name} - Zone ${bestZoneIdx} Progress: ${window.gGame.m_State.m_Grid.m_Tiles[bestZoneIdx].Info.progress} Difficulty: ${window.gGame.m_State.m_Grid.m_Tiles[bestZoneIdx].Info.difficulty}`);\r\n\t}\r\n\r\n\treturn bestZoneIdx;\r\n}\r\n\r\n\/\/ Get the best planet available\r\nfunction GetBestPlanet() {\r\n\tvar bestPlanetId = undefined;\r\n\tvar activePlanetsScore = [];\r\n\tvar maxScore = 0;\r\n\tvar numberErrors = 0;\r\n\t\r\n\tgui.updateStatus(\'Getting best planet\');\r\n\t\r\n\t\/\/ GET to the endpoint\r\n\t$J.ajax({\r\n\t\tasync: false,\r\n\t\ttype: \"GET\",\r\n\t\turl: \"https:\/\/community.steam-api.com\/ITerritoryControlMinigameService\/GetPlanets\/v0001\/\",\r\n\t\tsuccess: function(data) {\r\n\t\t\tdata.response.planets.forEach( function(planet) {\r\n\t\t\t\tif (planet.state.active == true && planet.state.captured == false)\r\n\t\t\t\t\tactivePlanetsScore[planet.id] = 0;\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n\t\r\n\t\/\/ GET the score of each active planet\r\n\tObject.keys(activePlanetsScore).forEach ( function (planet_id) {\r\n\t\t\/\/ GET to the endpoint\r\n\t\t$J.ajax({\r\n\t\t\tasync: false,\r\n\t\t\ttype: \"GET\",\r\n\t\t\turl: \"https:\/\/community.steam-api.com\/ITerritoryControlMinigameService\/GetPlanet\/v0001\/\",\r\n\t\t\tdata: { id: planet_id },\r\n\t\t\tsuccess: function(data) {\r\n\t\t\t\tdata.response.planets[0].zones.forEach( function ( zone ) {\r\n\t\t\t\t\tif (zone.difficulty >= 1 && zone.difficulty <= 3 && zone.captured == false)\r\n\t\t\t\t\t\tactivePlanetsScore[planet_id] += Math.ceil(auto_switch_planet[\"coeffScore\"][zone.difficulty] * (1 - zone.capture_progress));\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\terror: function() {\r\n\t\t\t\tnumberErrors++;\r\n\t\t\t}\r\n\t\t});\r\n\t\tif (activePlanetsScore[planet_id] > maxScore) {\r\n\t\t\tmaxScore = activePlanetsScore[planet_id];\r\n\t\t\tbestPlanetId = planet_id;\r\n\t\t}\r\n\t});\r\n\tconsole.log(activePlanetsScore);\r\n\t\/\/ Prevent a planet switch if there were >= 2 errors while fetching planets or if there\'s an error while fetching the current planet score\r\n\tif (numberErrors >= 2 || ((current_planet_id in activePlanetsScore) && activePlanetsScore[current_planet_id] == 0))\r\n\t\treturn null;\r\n\t\r\n\treturn bestPlanetId;\r\n}\r\n\r\n\/\/ Switch to the next zone when one is completed\r\nfunction SwitchNextZone(attempt_no, planet_call) {\r\n\tif(attempt_no === undefined)\r\n\t\tattempt_no = 0;\r\n\tif (planet_call === undefined)\r\n\t\tplanet_call = false;\r\n\tINJECT_update_grid();\r\n\tvar next_zone = GetBestZone();\r\n\tif (next_zone !== undefined) {\r\n\t\tif (next_zone != target_zone) {\r\n\t\t\tconsole.log(\"Found new best zone: \" + next_zone);\r\n\t\t\tINJECT_start_round(next_zone, access_token, attempt_no);\r\n\t\t} else {\r\n\t\t\tconsole.log(\"Current zone #\" + target_zone + \" is already the best. No need to switch.\");\r\n\t\t\tif (planet_call === true)\r\n\t\t\t\tINJECT_start_round(target_zone, access_token, attempt_no);\r\n\t\t}\r\n\t} else {\r\n\t\tif (auto_switch_planet.active == true) {\r\n\t\t\tconsole.log(\"There are no more zones, the planet must be completed. Searching a new one.\");\r\n\t\t\tCheckSwitchBetterPlanet();\r\n\t\t} else {\r\n\t\t\tINJECT_leave_round();\r\n\t\t\tINJECT_update_grid();\r\n\t\t\tconsole.log(\"There are no more zones, the planet must be completed. You\'ll need to choose another planet!\");\r\n\t\t\ttarget_zone = -1;\r\n\t\t\tINJECT_leave_planet();\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\/\/ Check & switch for a potentially better planet, start to the best available zone\r\nfunction CheckSwitchBetterPlanet(difficulty_call) {\r\n\tif (difficulty_call === undefined)\r\n\t\tdifficulty_call = false;\r\n\tvar best_planet = GetBestPlanet();\r\n\tif (best_planet !== undefined && best_planet !== null && best_planet !== current_planet_id) {\r\n\t\tconsole.log(\"Planet #\" + best_planet + \" has higher XP potential. Switching to it. Bye planet #\" + current_planet_id);\r\n\t\tINJECT_switch_planet(best_planet, function() {\r\n\t\t\ttarget_zone = GetBestZone();\r\n\t\t\tINJECT_start_round(target_zone, access_token);\r\n\t\t});\r\n\t} else if (best_planet == current_planet_id) {\r\n\t\tSwitchNextZone(0, difficulty_call);\r\n\t} else if (best_planet === null) {\r\n\t\tconsole.log(\"Too many errors while searching a better planet. Let\'s continue on the current zone.\");\r\n\t\tINJECT_start_round(target_zone, access_token);\r\n\t} else {\r\n\t\tconsole.log(\"There\'s no planet better than the current one.\");\r\n\t}\r\n}\r\n\r\nvar INJECT_switch_planet = function(planet_id, callback) {\r\n\t\/\/ ONLY usable from battle selection\r\n\tif(!(gGame.m_State instanceof CBattleSelectionState))\r\n\t\treturn;\r\n\r\n\tgui.updateTask(\"Attempting to move to Planet #\" + planet_id);\r\n\r\n\tfunction wait_for_state_load() {\r\n\t\tif(gGame.m_IsStateLoading || gGame.m_State instanceof CPlanetSelectionState)\r\n\t\t\tsetTimeout(function() { wait_for_state_load(); }, 50);\r\n\t\telse\r\n\t\t\tcallback();\r\n\t}\r\n\r\n\t\/\/ Leave our current round if we haven\'t.\r\n\tINJECT_leave_round();\r\n\r\n\t\/\/ Leave the planet\r\n\tINJECT_leave_planet(function() {\r\n\r\n\t\t\/\/ Make sure the planet_id is valid (or we\'ll error out)\r\n\t\tvar valid_planets = gGame.m_State.m_rgPlanets;\r\n\t\tvar found = false;\r\n\t\tfor(var i=0; i<valid_planets.length; i++)\r\n\t\t\tif (valid_planets[i].id == planet_id)\r\n\t\t\t\t\tfound = true;\r\n\t\tif(!found) {\r\n\t\t\tgui.updateTask(\"Attempted to switch to an invalid planet. Please choose a new one.\");\r\n\t\t\tgui.updateStatus(false);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t\/\/ Join Planet\r\n\t\tINJECT_join_planet(planet_id,\r\n\t\t\tfunction ( response ) {\r\n\t\t\t\tgGame.ChangeState( new CBattleSelectionState( planet_id ) );\r\n\t\t\t\twait_for_state_load();\r\n\t\t\t},\r\n\t\t\tfunction ( response ) {\r\n\t\t\t\tShowAlertDialog( \'Join Planet Error\', \'Failed to join planet.  Please reload your game or try again shortly.\' );\r\n\t\t\t});\r\n\t});\r\n\r\n}\r\n\r\n\/\/ Leave the planet\r\nvar INJECT_leave_planet = function(callback) {\r\n\tif(typeof callback !== \'function\')\r\n\t\tcallback = function() {};\r\n\r\n\tfunction wait_for_state_load() {\r\n\t\tif(gGame.m_IsStateLoading || gGame.m_State instanceof CBattleSelectionState)\r\n\t\t\tsetTimeout(function() { wait_for_state_load(); }, 50);\r\n\t\telse {\r\n\t\t\t\/\/ Clear the current planet ID var\r\n\t\t\tcurrent_planet_id = undefined;\r\n\r\n\t\t\tINJECT_init();\r\n\t\t\tcallback();\r\n\t\t}\r\n\t}\r\n\r\n\t\/\/ Cancel timeouts\r\n\tclearTimeout(current_timeout);\r\n\r\n\t\/\/ Leave our current round if we haven\'t.\r\n\tINJECT_leave_round();\r\n\r\n\t\/\/ (Modified) Default Code\r\n\tgAudioManager.PlaySound( \'ui_select_backwards\' );\r\n\tgServer.LeaveGameInstance(\r\n\t\tgGame.m_State.m_PlanetData.id,\r\n\t\tfunction() {\r\n\t\t\tgGame.ChangeState( new CPlanetSelectionState() );\r\n\t\t\t\/\/ Wait for the new state to load, then hook in\r\n\t\t\twait_for_state_load();\r\n\t\t}\r\n\t);\r\n}\r\n\r\nvar INJECT_join_planet = function(planet_id, success_callback, error_callback) {\r\n\tif(typeof success_callback !== \'function\')\r\n\t\tsuccess_callback = function() {};\r\n\tif(typeof error_callback !== \'function\')\r\n\t\terror_callback = function() {};\r\n\tfunction wait_for_state_load() {\r\n\t\tif(gGame.m_IsStateLoading || gGame.m_State instanceof CPlanetSelectionState)\r\n\t\t\tsetTimeout(function() { wait_for_state_load(); }, 50);\r\n\t\telse {\r\n\t\t\tcurrent_planet_id = planet_id;\r\n\t\t\tINJECT_init();\r\n\t\t}\r\n\t}\r\n\r\n\t\/\/ Modified Default code\r\n\tvar rgParams = {\r\n\t\tid: planet_id,\r\n\t\taccess_token: access_token\r\n\t};\r\n\r\n\t$J.ajax({\r\n\t\tasync: false,\r\n\t\turl: window.gServer.m_WebAPI.BuildURL( \'ITerritoryControlMinigameService\', \'JoinPlanet\', true ),\r\n\t\tmethod: \'POST\',\r\n\t\tdata: rgParams\r\n\t}).success( function( results, textStatus, request ) {\r\n\t\tif ( request.getResponseHeader( \'x-eresult\' ) == 1 ) {\r\n\t\t\tsuccess_callback( results );\r\n\t\t\t\/\/ Wait for the new state to load, then hook in\r\n\t\t\twait_for_state_load();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tconsole.log(results, textStatus, request);\r\n\t\t\terror_callback();\r\n\t\t}\r\n\t}).fail( error_callback );\r\n}\r\nvar INJECT_init_battle_selection = function() {\r\n\tgui.updateStatus(true);\r\n\tgui.updateTask(\"Initializing Battle Selection Menu.\");\r\n\t\/\/ Auto join best zone at first\r\n\tif (auto_first_join == true) {\r\n\t\tfirstJoin();\r\n\t\tfunction firstJoin() {\r\n\t\t\t\/\/ Wait for state & access_token\r\n\t\t\tif(access_token === undefined || gGame === undefined || gGame.m_IsStateLoading || gGame.m_State instanceof CPlanetSelectionState) {\r\n\t\t\t\tsetTimeout(function() { firstJoin(); }, 100);\r\n\t\t\t\tconsole.log(\"waiting\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tcurrent_planet_id = window.gGame.m_State.m_PlanetData.id;\r\n\r\n\t\t\tvar first_zone;\r\n\t\t\tif(target_zone === -1)\r\n\t\t\t\tfirst_zone = GetBestZone();\r\n\t\t\telse\r\n\t\t\t\tfirst_zone = target_zone\r\n\r\n\t\t\tif(access_token === undefined)\r\n\t\t\t\tINJECT_get_access_token();\r\n\r\n\t\t\tINJECT_start_round(first_zone, access_token);\r\n\t\t}\r\n\t}\r\n\r\n\t\/\/ Overwrite join function so clicking on a grid square will run our code instead\r\n\tgServer.JoinZone = function (zone_id, callback, error_callback) {\r\n\t\tcurrent_planet_id = window.gGame.m_State.m_PlanetData.id;\r\n\t\tINJECT_start_round(zone_id, access_token);\r\n\t}\r\n\r\n\t\/\/ Hook the Grid click function\r\n\tvar grid_click_default = gGame.m_State.m_Grid.click;\r\n\tgGame.m_State.m_Grid.click = function(tileX, tileY) {\r\n\t\t\/\/ Get the selected zone ID\r\n\t\tvar zoneIdx = _GetTileIdx( tileX, tileY );\r\n\r\n\t\t\/\/ Return if it\'s the current zone (Don\'t want clicking on same zone to leave\/rejoin)\r\n\t\tif(target_zone === zoneIdx)\r\n\t\t\treturn;\r\n\r\n\t\t\/\/ Return if it\'s a completed zone\r\n\t\tif(window.gGame.m_State.m_Grid.m_Tiles[zoneIdx].Info.captured) {\r\n\t\t\tconsole.log(\"Manually selected zone already captured. Returning.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t\/\/ Update the GUI\r\n\t\tgui.updateTask(\"Attempting manual switch to Zone #\" + zoneIdx);\r\n\t\tgui.progressbar.parent.removeChild(gui.progressbar)\r\n\r\n\t\t\/\/ Leave existing round\r\n\t\tINJECT_leave_round();\r\n\r\n\t\t\/\/ Join new round\r\n\t\tINJECT_start_round(zoneIdx, access_token);\r\n\t}\r\n\r\n\t\/\/ Hook the Leave Planet Button\r\n\tgGame.m_State.m_LeaveButton.click = function(btn) {\r\n\t\tINJECT_leave_planet();\r\n\t};\r\n}\r\n\r\nvar INJECT_init_planet_selection = function() {\r\n\tgui.updateStatus(true);\r\n\tgui.updateTask(\"Initializing Planet Selection Menu.\");\r\n\r\n\t\/\/ Hook the Join Planet Function\r\n\tgServer.JoinPlanet = function(planet_id, success_callback, error_callback) {\r\n\t\tINJECT_join_planet(planet_id, success_callback, error_callback);\r\n\t}\r\n\r\n\t\/\/ Update GUI\r\n\tgui.updateStatus(false);\r\n\tgui.updateTask(\"At Planet Selection\");\r\n\tgui.updateZone(\"None\");\r\n};\r\n\r\nvar INJECT_init = function() {\r\n\tif (gGame.m_State instanceof CBattleSelectionState)\r\n\t\tINJECT_init_battle_selection();\r\n\telse if (gGame.m_State instanceof CPlanetSelectionState)\r\n\t\tINJECT_init_planet_selection();\r\n};\r\n\r\nvar INJECT_disable_animations = function() {\r\n\t\/\/var confirmed = confirm(\"Disabling animations will vastly reduce resources used, but you will no longer be able to manually swap zones until you refresh. Continue?\");\r\n\tvar confirmed = true;\t\r\n\tconsole.log(\"Disabling animations will vastly reduce resources used, but you will no longer be able to manually swap zones until you refresh. Continue?\");\r\n\r\n\tif(confirmed) {\r\n\t\trequestAnimationFrame = function(){};\r\n\t\t$J(\"#disableAnimsBtn\").prop(\"disabled\",true).prop(\"value\", \"Animations Disabled.\");\r\n\t}\r\n};\r\n\r\n\/\/ ============= CODE THAT AUTORUNS ON LOAD =============\r\n\/\/ Auto-grab the access token\r\nINJECT_get_access_token();\r\n\r\n\/\/ Run the global initializer, which will call the function for whichever screen you\'re in\r\nINJECT_init();\r\n\r\n\/\/ Force disable animations\r\nINJECT_disable_animations();\r\n";
        document.head.appendChild(eleClientScript);

        eleTarget.textContent = "saliengame_idler loaded";
    });

    // Add name to title
    {
        var eleA = document.querySelector("#global_actions > a");
        if (eleA)
        {
            var sId = eleA.href.replace("https://steamcommunity.com/id/", "").replace("/", "");
            document.title = sId + " - Salien";
        }
    }
	
	// Click play
	{
		setTimeout(function()
		{
			var eleClientScript = document.createElement("script");
			eleClientScript.innerHTML = "gGame.m_State.button.click();";
			document.head.appendChild(eleClientScript);
		}, 1000);
	}

})();
