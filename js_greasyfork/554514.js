// ==UserScript==
// @name        Crawler's Companion Advanced Roller
// @namespace   Violentmonkey Scripts
// @match       *://crawler.purplesorcerer.com/*
// @grant       none
// @version     1.2
// @author      Kanobe
// @license     MIT
// @description Adds a new sidebar for rolling and managing dice roll expressions.
// @run-at      document-idle
// @inject-into page
// @require https://cdn.jsdelivr.net/npm/fuse.js@7.1.0
// @downloadURL https://update.greasyfork.org/scripts/554514/Crawler%27s%20Companion%20Advanced%20Roller.user.js
// @updateURL https://update.greasyfork.org/scripts/554514/Crawler%27s%20Companion%20Advanced%20Roller.meta.js
// ==/UserScript==
// To use this script, install the extension named ViolentMonkey and add this file as a script
// @generated by Peggy 5.0.6.
//
// https://peggyjs.org/
(function(root) {
  "use strict";
class peg$SyntaxError extends SyntaxError {
  constructor(message, expected, found, location) {
    super(message);
    this.expected = expected;
    this.found = found;
    this.location = location;
    this.name = "SyntaxError";
  }

  format(sources) {
    let str = "Error: " + this.message;
    if (this.location) {
      let src = null;
      const st = sources.find(s => s.source === this.location.source);
      if (st) {
        src = st.text.split(/\r\n|\n|\r/g);
      }
      const s = this.location.start;
      const offset_s = (this.location.source && (typeof this.location.source.offset === "function"))
        ? this.location.source.offset(s)
        : s;
      const loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
      if (src) {
        const e = this.location.end;
        const filler = "".padEnd(offset_s.line.toString().length, " ");
        const line = src[s.line - 1];
        const last = s.line === e.line ? e.column : line.length + 1;
        const hatLen = (last - s.column) || 1;
        str += "\n --> " + loc + "\n"
            + filler + " |\n"
            + offset_s.line + " | " + line + "\n"
            + filler + " | " + "".padEnd(s.column - 1, " ")
            + "".padEnd(hatLen, "^");
      } else {
        str += "\n at " + loc;
      }
    }
    return str;
  }

  static buildMessage(expected, found) {
    function hex(ch) {
      return ch.codePointAt(0).toString(16).toUpperCase();
    }

    const nonPrintable = Object.prototype.hasOwnProperty.call(RegExp.prototype, "unicode")
      ? new RegExp("[\\p{C}\\p{Mn}\\p{Mc}]", "gu")
      : null;
    function unicodeEscape(s) {
      if (nonPrintable) {
        return s.replace(nonPrintable,  ch => "\\u{" + hex(ch) + "}");
      }
      return s;
    }

    function literalEscape(s) {
      return unicodeEscape(s
        .replace(/\\/g, "\\\\")
        .replace(/"/g,  "\\\"")
        .replace(/\0/g, "\\0")
        .replace(/\t/g, "\\t")
        .replace(/\n/g, "\\n")
        .replace(/\r/g, "\\r")
        .replace(/[\x00-\x0F]/g,          ch => "\\x0" + hex(ch))
        .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => "\\x"  + hex(ch)));
    }

    function classEscape(s) {
      return unicodeEscape(s
        .replace(/\\/g, "\\\\")
        .replace(/\]/g, "\\]")
        .replace(/\^/g, "\\^")
        .replace(/-/g,  "\\-")
        .replace(/\0/g, "\\0")
        .replace(/\t/g, "\\t")
        .replace(/\n/g, "\\n")
        .replace(/\r/g, "\\r")
        .replace(/[\x00-\x0F]/g,          ch => "\\x0" + hex(ch))
        .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => "\\x"  + hex(ch)));
    }

    const DESCRIBE_EXPECTATION_FNS = {
      literal(expectation) {
        return "\"" + literalEscape(expectation.text) + "\"";
      },

      class(expectation) {
        const escapedParts = expectation.parts.map(
          part => (Array.isArray(part)
            ? classEscape(part[0]) + "-" + classEscape(part[1])
            : classEscape(part))
        );

        return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]" + (expectation.unicode ? "u" : "");
      },

      any() {
        return "any character";
      },

      end() {
        return "end of input";
      },

      other(expectation) {
        return expectation.description;
      },
    };

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      const descriptions = expected.map(describeExpectation);
      descriptions.sort();

      if (descriptions.length > 0) {
        let j = 1;
        for (let i = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  }
}

function peg$parse(input, options) {
  options = options !== undefined ? options : {};

  const peg$FAILED = {};
  const peg$source = options.grammarSource;

  const peg$startRuleFunctions = {
    start: peg$parsestart,
  };
  let peg$startRuleFunction = peg$parsestart;

  const peg$c0 = "+";
  const peg$c1 = "-";
  const peg$c2 = "{{";
  const peg$c3 = "}}";
  const peg$c4 = "}";
  const peg$c5 = "d";
  const peg$c6 = "[";
  const peg$c7 = "]";
  const peg$c8 = " ";

  const peg$r0 = /^[^}]/;
  const peg$r1 = /^[0-9]/;
  const peg$r2 = /^[^\]]/;

  const peg$e0 = peg$otherExpectation("roll expression");
  const peg$e1 = peg$literalExpectation("+", false);
  const peg$e2 = peg$literalExpectation("-", false);
  const peg$e3 = peg$literalExpectation("{{", false);
  const peg$e4 = peg$literalExpectation("}}", false);
  const peg$e5 = peg$literalExpectation("}", false);
  const peg$e6 = peg$classExpectation(["}"], true, false, false);
  const peg$e7 = peg$literalExpectation("d", false);
  const peg$e8 = peg$classExpectation([["0", "9"]], false, false, false);
  const peg$e9 = peg$literalExpectation("[", false);
  const peg$e10 = peg$classExpectation(["]"], true, false, false);
  const peg$e11 = peg$literalExpectation("]", false);
  const peg$e12 = peg$literalExpectation(" ", false);

  function peg$f0(head, rest) {
    var expr = rest[3]	

    var result = {
    	type: "sum",
        term: head,
    	expr: expr
    }
    return result
  }
  function peg$f1(head, rest) {
    var expr = rest[3]	

    var result = {
    	type: "diff",
        term: head,
    	expr: expr
    }
    return result
  }
  function peg$f2(val, lbl, rest) {
    var codestr = null
  	  if (rest) {
    	codestr = rest[2]
    }
    return {type: "term", val: val, lbl: lbl, code: codestr} 
  }
  function peg$f3(head, rest) {
    var text = ""
    text = head
    var i,v
    for ([i, v] of rest.entries()) {
    	text = text + v[0] + v[1]
    }
  
    return text
  }
  function peg$f4(val) {
    return val.join("")
  }
  function peg$f5(v1, v2) {return {type: "roll", num: v1.val, range: v2.val}  }
  function peg$f6(val) {return {type: "int", val: parseInt(val.join(""))}  }
  function peg$f7(chars) {return chars.join("")  }
  let peg$currPos = options.peg$currPos | 0;
  let peg$savedPos = peg$currPos;
  const peg$posDetailsCache = [{ line: 1, column: 1 }];
  let peg$maxFailPos = peg$currPos;
  let peg$maxFailExpected = options.peg$maxFailExpected || [];
  let peg$silentFails = options.peg$silentFails | 0;

  let peg$result;

  if (options.startRule) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function offset() {
    return peg$savedPos;
  }

  function range() {
    return {
      source: peg$source,
      start: peg$savedPos,
      end: peg$currPos,
    };
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== undefined
      ? location
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== undefined
      ? location
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildSimpleError(message, location);
  }

  function peg$getUnicode(pos = peg$currPos) {
    const cp = input.codePointAt(pos);
    if (cp === undefined) {
      return "";
    }
    return String.fromCodePoint(cp);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text, ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase, unicode) {
    return { type: "class", parts, inverted, ignoreCase, unicode };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description };
  }

  function peg$computePosDetails(pos) {
    let details = peg$posDetailsCache[pos];
    let p;

    if (details) {
      return details;
    } else {
      if (pos >= peg$posDetailsCache.length) {
        p = peg$posDetailsCache.length - 1;
      } else {
        p = pos;
        while (!peg$posDetailsCache[--p]) {}
      }

      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column,
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;

      return details;
    }
  }

  function peg$computeLocation(startPos, endPos, offset) {
    const startPosDetails = peg$computePosDetails(startPos);
    const endPosDetails = peg$computePosDetails(endPos);

    const res = {
      source: peg$source,
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column,
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column,
      },
    };
    if (offset && peg$source && (typeof peg$source.offset === "function")) {
      res.start = peg$source.offset(res.start);
      res.end = peg$source.offset(res.end);
    }
    return res;
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parsestart() {
    let s0;

    s0 = peg$parseexpression();

    return s0;
  }

  function peg$parseexpression() {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parsesum();
    if (s0 === peg$FAILED) {
      s0 = peg$parsediff();
      if (s0 === peg$FAILED) {
        s0 = peg$parseterm();
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e0); }
    }

    return s0;
  }

  function peg$parsesum() {
    let s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$parseterm();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parse_();
      if (input.charCodeAt(peg$currPos) === 43) {
        s4 = peg$c0;
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e1); }
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parse_();
        s6 = peg$parseexpression();
        if (s6 !== peg$FAILED) {
          s3 = [s3, s4, s5, s6];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f0(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsediff() {
    let s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$parseterm();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parse_();
      if (input.charCodeAt(peg$currPos) === 45) {
        s4 = peg$c1;
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e2); }
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parse_();
        s6 = peg$parseexpression();
        if (s6 !== peg$FAILED) {
          s3 = [s3, s4, s5, s6];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f1(s1, s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseterm() {
    let s0, s1, s2, s3, s4, s5, s6, s7, s8;

    s0 = peg$currPos;
    s1 = peg$parsevalue();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      s3 = peg$parselabel();
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      s4 = peg$currPos;
      s5 = peg$parse_();
      if (input.substr(peg$currPos, 2) === peg$c2) {
        s6 = peg$c2;
        peg$currPos += 2;
      } else {
        s6 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e3); }
      }
      if (s6 !== peg$FAILED) {
        s7 = peg$parsetext_with_nonconsecutive_closebraces();
        if (s7 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c3) {
            s8 = peg$c3;
            peg$currPos += 2;
          } else {
            s8 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e4); }
          }
          if (s8 !== peg$FAILED) {
            s5 = [s5, s6, s7, s8];
            s4 = s5;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 === peg$FAILED) {
        s4 = null;
      }
      peg$savedPos = s0;
      s0 = peg$f2(s1, s3, s4);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetext_with_nonconsecutive_closebraces() {
    let s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parsenon_closebrace_text();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 125) {
        s4 = peg$c4;
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e5); }
      }
      if (s4 !== peg$FAILED) {
        s5 = peg$parsetext_with_nonconsecutive_closebraces();
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 125) {
          s4 = peg$c4;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e5); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parsetext_with_nonconsecutive_closebraces();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      peg$savedPos = s0;
      s0 = peg$f3(s1, s2);
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsenon_closebrace_text() {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = input.charAt(peg$currPos);
    if (peg$r0.test(s2)) {
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e6); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = input.charAt(peg$currPos);
        if (peg$r0.test(s2)) {
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e6); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f4(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsevalue() {
    let s0;

    s0 = peg$parseroll();
    if (s0 === peg$FAILED) {
      s0 = peg$parseinteger();
    }

    return s0;
  }

  function peg$parseroll() {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseinteger();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 100) {
        s2 = peg$c5;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e7); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseinteger();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f5(s1, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseinteger() {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = input.charAt(peg$currPos);
    if (peg$r1.test(s2)) {
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e8); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = input.charAt(peg$currPos);
        if (peg$r1.test(s2)) {
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e8); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$f6(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parselabel() {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      s1 = peg$c6;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e9); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = input.charAt(peg$currPos);
      if (peg$r2.test(s3)) {
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e10); }
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = input.charAt(peg$currPos);
        if (peg$r2.test(s3)) {
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e10); }
        }
      }
      if (input.charCodeAt(peg$currPos) === 93) {
        s3 = peg$c7;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e11); }
      }
      if (s3 !== peg$FAILED) {
        peg$savedPos = s0;
        s0 = peg$f7(s2);
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parse_() {
    let s0, s1;

    peg$silentFails++;
    s0 = [];
    if (input.charCodeAt(peg$currPos) === 32) {
      s1 = peg$c8;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$e12); }
    }
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      if (input.charCodeAt(peg$currPos) === 32) {
        s1 = peg$c8;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e12); }
      }
    }
    peg$silentFails--;

    return s0;
  }

  peg$result = peg$startRuleFunction();

  const peg$success = (peg$result !== peg$FAILED && peg$currPos === input.length);
  function peg$throw() {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? peg$getUnicode(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
  if (options.peg$library) {
    return /** @type {any} */ ({
      peg$result,
      peg$currPos,
      peg$FAILED,
      peg$maxFailExpected,
      peg$maxFailPos,
      peg$success,
      peg$throw: peg$success ? undefined : peg$throw,
    });
  }
  if (peg$success) {
    return peg$result;
  } else {
    peg$throw();
  }
}

  root.Peggy = {
    StartRules: ["start"],
    SyntaxError: peg$SyntaxError,
    parse: peg$parse,
  };
})(this);
// rollvars is a hashtable that contains variable values set by user-defined code on roll terms.
var rollvars = {}

function parseAndExecuteRoll(roll) {
	console.log("parseAndExecuteRoll: called")
	try {
		var parsed = parseRoll(roll)
		return executeRoll(parsed)
	} catch(e) {
		console.log("parseAndExecuteRoll: exception", e)
		if (typeof e.format === "function") {
			s = e.format([{source: "line and column", text: roll}])
			console.log(s)
			throw new Error(s);
		} else {
			throw e
		}
	}
}

function parseRoll(roll) {
	return Peggy.parse(roll, {grammarSource: "line and column"})
}

function executeRoll(parsed) {
	originalRollText = rollString(parsed)
	substituteDice(parsed)
	evaluateCode(parsed)
	removeLabels(parsed)
	rollWithDiceReplaced = rollString(parsed)
	finalResult = calculateSum(parsed)

	formatted = `${originalRollText} = ${rollWithDiceReplaced} = ${finalResult}`
	console.log(formatted)
	return formatted
}

// Generate a string representing the parsed roll
function rollString(parsed) {
	if (parsed.type == "term") {
		return termString(parsed)
	}
	
	if (parsed.type == "sum") {
		return termString(parsed.term) + " + " + rollString(parsed.expr)
	}

	if (parsed.type == "diff") {
		return termString(parsed.term) + " - " + rollString(parsed.expr)
	}
	
	return ""
}

function termString(term) {
	result = valueString(term.val)
	if (term.lbl) {
		result += ` [${term.lbl}]`
	}
	return result
}

function valueString(val) {
	if (val.type == "roll") {
		return `${val.num}d${val.range}`
	} else if (val.type == "int") {
		if (val.isCodeResult) {
			return `${val.val}*`
		} else {
			return `${val.val}`
		}
	} else {
		return "?"
	}
}

// Given a parsed roll, replace the dice with the outcome of the rolls of the dice
function substituteDice(parsed) {
	if (parsed.type == "term" && parsed.val.type == "roll") {
		parsed.val.type = "int"
		parsed.val.val = calculateRoll(parsed.val.num, parsed.val.range)
		return
	}
	
	if (parsed.type == "sum" || parsed.type == "diff") {
		substituteDice(parsed.term)
		substituteDice(parsed.expr)
	}
}

// Given a parsed roll, after the dice have been substituted using substituteDice, execute any code the user defined
// after each term.
function evaluateCode(parsed) {
	if (parsed.type == "term" && parsed.val.type == "int" && parsed.code != null) {
		func = new Function("set", "get", "val", parsed.code)	
		result = func(userCodeSet, userCodeGet, parsed.val.val)
		if (result !== undefined) {
			parsed.val.val = result
			parsed.val.isCodeResult = true
		}
		return
	}
	
	if (parsed.type == "sum" || parsed.type == "diff") {
		evaluateCode(parsed.term)
		evaluateCode(parsed.expr)
	}

}

function userCodeSet(name, val) {
	rollvars[name] = val
}

function userCodeGet(name) {
	return rollvars[name]
}


function removeLabels(parsed) {
	if (parsed.type == "term" && parsed.lbl ) {
		parsed.lbl = ""
		return
	}
	
	if (parsed.type == "sum" || parsed.type == "diff") {
		removeLabels(parsed.term)
		removeLabels(parsed.expr)
	}
}

function calculateRoll(num, range) {
	var sum = 0
	for (var i = 0; i < num; i++) {
		sum += randIntInRange(range)
	}
	return sum
}

function randIntInRange(range) {
	return Math.floor(Math.random() * range) + 1;
}

// calculateSum calculates the sum represented by the parsed roll. The dice in the parsed roll
// must have already been replaced with the result of the rolls, i.e. using substituteDice.
function calculateSum(parsed) {

	if (parsed.type == "term" && parsed.val.type == "int") {
		return parsed.val.val
	}
	
	if (parsed.type == "sum") {
		return calculateSum(parsed.term) + calculateSum(parsed.expr)
	}

	if (parsed.type == "diff") {
		return calculateSum(parsed.term) - calculateSum(parsed.expr)
	}
	
	return 0
}


// parseAndExecuteRoll("1") 
// parseAndExecuteRoll("1d20 [attack] + 1d3[deeds] + 1[str]") 
// parseAndExecuteRoll("1d20 [attack] + 1d3[deeds] + 1[str]") 
// parseAndExecuteRoll("1d20 [str] + 40[age] + 1d6")
// parseAndExecuteRoll("1d20 [str] + invalid")
// parseAndExecuteRoll("1d20 [str] + 1 {{return 2}}")
// parseAndExecuteRoll("1d20 [str] + 1 {{console.log('test'); return get('a')}}")
// parseAndExecuteRoll("1d20 [str] + 1d5 [deeds] {{set('deeds', val)}}")
// parseAndExecuteRoll("1d20 [str] + 0 [deeds] {{d = get('deeds', val); if (d !== undefined){return d} }}")

// Also load the code from parser.js

function showRoller() {
	navClick('dice') // On the left click the dice tab
	loadSavedRollsFromOptionsToUI()
	$('#roller').show()
}

function hideRoller() {
	$('#roller').hide()
}

function addToSavedRollUI(name, roll) {
	savedRollDiv = $(`<div rollname="${name}">
        <div class="sr-col1">${name}</div>
        <div>
            <span class="sr-col2">${roll}</span>
            <span class="sr-col3">
                <button>Edit</button>
                <button>Roll</button>
                <button>Delete</button>
            </span>
        </div>
      </div>`)

	savedRollsDiv = $('#saved-rolls')
	savedRollsDiv.append(savedRollDiv)
	savedRollDiv.find(".sr-col3").children().eq(0).on("click", function(){savedRollEdit(name)})
	savedRollDiv.find(".sr-col3").children().eq(1).on("click", function(){savedRollExecute(name)})
	savedRollDiv.find(".sr-col3").children().eq(2).on("click", function(){savedRollDelete(name)})
}

function saveRollFromUI() {
	roll = $('#roller-roll-textarea').val()
	name = $('#roller-rollname').val()
	if (roll == "" || name == "") {
		return
	}
	hideTest()
		
	result = storeRollInOptions(name, roll)
	loadSavedRollsFromOptionsToUI()
	saveOptionsToDB()
}

function executeRollBeingBuiltFromUI() {
	console.log("executeRollBeingBuiltFromUI: called")
	roll = $('#roller-roll-textarea').val()
	hideTest()
	executeRollFromUI(roll)
}

function executeRollFromUI(roll) {
	var result = ""
	try {
		result = parseAndExecuteRoll(roll)
	} catch(e) {
		console.log("executeRollBeingBuiltFromUI: exception: " + e.message)
		displayError(e.message)
		return
	}
	
	addToRollLog(result, 'rolls')
}

function testRollBeingBuiltFromUI() {
	console.log("executeRollBeingBuiltFromUI: called")
	roll = $('#roller-roll-textarea').val()
	var result = ""
	try {
		result = parseAndExecuteRoll(roll)
		displayTest(result)
	} catch(e) {
		displayError(e.message)
	}
}

function displayError(msg) {
	console.log("displayError: called")
	$('#roller-error').show()
	$('#roller-error').text(msg)
}

function hideError() {
	console.log("hideError: called")
	$('#roller-error').hide()
}

function displayTest(msg) {
	console.log("displayTest: called")
	$('#roller-test-div').show()
	$('#roller-test-div').text(msg)
}

function hideTest() {
	console.log("hideTest: called")
	$('#roller-test-div').hide()
}

function onRollEditedInUI() {
	console.log("onRollEditedInUI: called")
	hideError()
	hideTest()

	updateRollEditorUIButtonStateBasedOnRollValidity()	
}

function updateRollEditorUIButtonStateBasedOnRollValidity() {
	roll = $('#roller-roll-textarea').val()
	if (rollExpressionIsValid(roll)) {
		enableEditorSaveAndRoll()
		rollname = $('#roller-rollname').val()
		$('#roller-save').prop('disabled', rollname == "")
	} else {
		disableEditorSaveAndRoll()
	}
}

function rollExpressionIsValid(roll) {
	try {
		parseRoll(roll)
		return true
	} catch(e) {
		return false
	}
}

function onRollnameEditedInUI() {
	hideTest()
	updateRollEditorUIButtonStateBasedOnRollValidity()
}

function disableEditorSaveAndRoll() {
	$('#roller-roll').prop('disabled', true)
	$('#roller-save').prop('disabled', true)
}

function enableEditorSaveAndRoll() {
	$('#roller-roll').prop('disabled', false)
	$('#roller-save').prop('disabled', false)
}

function loadSavedRollsFromOptionsToUI() {
	$('#saved-rolls').empty()
	
	rolls = getRollsFromOptions()
	rolls = filterRolls(rolls)	
	
	for (roll of rolls) {
		addToSavedRollUI(roll.name, roll.roll)
	}
}

function savedRollEdit(rollName) {
	roll = getRollFromOptions(rollName)
	if (!roll) {
		return
	}
	$('#roller-roll-textarea').val(roll.roll)
	$('#roller-rollname').val(roll.name)
}

function savedRollDelete(rollName) {
	deleteRollFromOptions(rollName)
	savedRollDiv = $(`div[rollname="${name}"]`)
	savedRollDiv.remove()
}

function savedRollExecute(rollName) {
	roll = getRollFromOptions(rollName)
	if (!roll) {
		return
	}
	executeRollFromUI(roll.roll)
}

const StoreResult = {
	UPDATED: 'updated',
	ADDED: 'added',
}

function showSavedRollsAsRaw() {
	$("#saved-rolls").hide()
	$("#saved-rolls-raw").show()
	$("#saved-rolls-filter").hide()
	$("#show-cooked-button").show()
	$("#raw-update-button").show()
	$("#raw-update-button").prop('disabled', true)
	$("#show-raw-button").hide()
	$("#roller-roll").prop('disabled', true)
	$("#roller-test").prop('disabled', true)
	$("#roller-save").prop('disabled', true)

	var rollsAsJson = JSON.stringify(options[optionsPropertyForRolls], null, 2);
//	var formatted	= `<pre>${rollsAsJson}</pre>`
//	$("#saved-rolls-raw").html(formatted)
	$("#saved-rolls-raw").val(rollsAsJson)
}

function showSavedRollsAsCooked() {
	$("#saved-rolls").show()
	$("#saved-rolls-raw").hide()
	$("#saved-rolls-filter").show()
	$("#show-cooked-button").hide()
	$("#raw-update-button").hide()
	$("#show-raw-button").show()
	$("#roller-roll").prop('disabled', false)
	$("#roller-test").prop('disabled', false)
	$("#roller-save").prop('disabled', false)
}

function onRawRollsEdited() {
	$("#raw-update-button").prop('disabled', false)
}

function updateSavedRollsFromRaw() {
	rollsAsJson = $("#saved-rolls-raw").val()
	var parsed
	try {
		parsed = JSON.parse(rollsAsJson)
	} catch(e) {
		console.log("executeRollBeingBuiltFromUI: exception: " + e.message)
		displayError(e.message)
		return
	}

	options[optionsPropertyForRolls] = []
	for ([i, e] of parsed.entries()) {
		storeRollInOptions(e.name, e.roll)
	}
	saveOptionsToDB()
	loadSavedRollsFromOptionsToUI()
	$("#raw-update-button").prop('disabled', true)
}


// optionsPropertyForRolls is the property in the options object in which we store our saved rolls.
// The options object is saved by the companion to a browser cookie (I think) but follows a specific database schema.
// Initially I tried adding a new property to the options object named 'roller' but after saving to the database the 
// property is not loaded after browser refresh. However using an existing property seems to work.
// There are a few properties that might be suitable since they are arrays:
//
//    * batchFavesValues
//    * encounterTitles
//    * party
//    * partyTitles
//
const optionsPropertyForRolls = "encounterTitles"

function initOptions() {
	// Since we are hijacking an existing property, it might contain invalid data in some other format.
	// Let's clean it up.
	if (optionsPropertyForRolls in options) {
		arr = options[optionsPropertyForRolls]
		if (arr.length == 0) {
			return
		}
		
		// Our objects we add to the array have a string property 'name' and string property 'roll'
		if (typeof arr[0].name !== "string") {
			options[optionsPropertyForRolls] = []
			return
		}
		if (typeof arr[0].roll !== "string") {
			options[optionsPropertyForRolls] = []
			return
		}
	}
}

function storeRollInOptions(name, roll) {
	if (!(optionsPropertyForRolls in options)) {
		options[optionsPropertyForRolls] = []
	}

	for ([i, r] of options[optionsPropertyForRolls].entries()) {
		if (r.name == name) {
			options[optionsPropertyForRolls][i].roll = roll
			return StoreResult.UPDATED
		}
	}
	
	options[optionsPropertyForRolls].push({name: name, roll: roll})
	options[optionsPropertyForRolls].sort()
	return StoreResult.ADDED
}

function deleteRollFromOptions(name, roll) {
	if (!(optionsPropertyForRolls in options)) {
		return
	}

	for ([i, r] of options[optionsPropertyForRolls].entries()) {
		if (r.name == name) {
			options[optionsPropertyForRolls].splice(i,1)
			break
		}
	}
}

function getRollFromOptions(name) {
	if (!(optionsPropertyForRolls in options)) {
		return null
	}

	for ([i, r] of options[optionsPropertyForRolls].entries()) {
		if (r.name == name) {
			return r
		}
	}

	return null
}

function getRollsFromOptions() {
	if (!(optionsPropertyForRolls in options)) {
		return []
	}

	return options[optionsPropertyForRolls]
}

function saveOptionsToDB() {
	console.log("saveOptionsToDB: called")
	
	// Copied from the function setOptions
	localforage.setItem('options', options).then(function (e) {
		console.log('Data saved.')
	}).catch(function (e) {
		console.log(e)
	})
}

function filterRolls(rolls) {
	filt = $('#saved-rolls-filter').val()
	if (filt == "") {
		console.log("filterRolls: filter is empty")
		return rolls
	}

	const fuseOptions = {
		keys: ["name"]
	}
	var fuse = new Fuse(rolls, fuseOptions)

	result = fuse.search(filt)
	for ([i, r] of result.entries()) {
		result[i] = r.item
	}
	
	console.log("filterRolls: search result is ", result)
	return result
}

screenLeft = $('#screenLeft')
rollerDiv = $(`<div id="roller" style="position: relative; color: #ffffff; background-color: #808080; width:100%; height: 91%; z-index: 1000; padding: 1vh;">

  <style>
     #roller {
         scrollbar-color: white black;
     }

     #saved-rolls-header {
         width: 100%; 
         text-align: center;
         font: 3.0vh Helvetica, Arial, sans-serif;
         font-weight: bold;
         margin-bottom: 2vh;
     }

     #saved-rolls-filter-div {
         width: 100%; 
         text-align: center;
         margin-bottom: 1vh;
     }
    
     #saved-rolls > div {
         white-space: nowrap;
         width: 100%;
         border-bottom: 1px solid #606060;
     }

     #saved-rolls div span {
         font: 1.9vh Helvetica, Arial, sans-serif;
         height: 3em;
         overflow-x: scroll;
     }
     
     #roller-roll-buttons button {
         border: 1px solid #000000;
         font: 1.9vh Helvetica, Arial, sans-serif;
     }
     
     #saved-rolls button {
         border: 1px solid #000000;
         font: 1.9vh Helvetica, Arial, sans-serif;
     }

     #saved-rolls-filter-div button {
         border: 1px solid #000000;
         font: 1.9vh Helvetica, Arial, sans-serif;
     }
     
     #saved-rolls div:first-child {
         border-top: 1px solid #606060;
     }

	#saved-rolls .sr-col1 {
           font-weight: bold; 
           font-size: 2.3vh;
	}
	
	#saved-rolls-raw {
         font: 2.1vh Helvetica, Arial, sans-serif;
         /*user-select: text;*/
	}
	
	.sr-col2 {
           display: inline-block;
           width: 25vw;
	}
	.sr-col3 {
           display: inline-block;
           float: right;
           margin-right: 1vw;
	}

	#roller-error {
		background-color: #ffe0e0;
           font-size: 1.9vh;
           font-family: "Courier New", Courier, monospace;
           color: #000000;
           padding-left: 1.0vh;
           white-space: pre;
	}

	#roller-test-div {
		background-color: #ffffe0;
           font-size: 1.9vh;
           font-family: "Courier New", Courier, monospace;
           color: #000000;
           padding-left: 1.0vh;
           white-space: pre;
	}
	
	#roller-close {
		font-size: 2vh;
	}

  </style>
  
  <div id="roller-close" style="position: relative; float: right">êåó</div>
  <textarea id="roller-roll-textarea" style="font: 2.1vh Helvetica, Arial, sans-serif; width: 20em;" placeholder="1d20 [attack] + 3 [str]"></textarea>
  <div id="roller-roll-buttons">
  	<input id="roller-rollname" style="font: 1.9vh Helvetica, Arial, sans-serif; width: 22.1em;" type="text" placeholder="Roll name"/>
      <button id="roller-roll">Roll</button>
      <button id="roller-test">Test</button>
      <button id="roller-save">Save</button>
  </div>
  <div id="roller-test-div">A roll</div>
  <div id="roller-error">An error occurred</div>
  
  <hr style="border-top: 1px solid #a0a0a0;"/>

  <div id="saved-rolls-header" >
    Saved Rolls
  </div>

  <div id="saved-rolls-filter-div" >
    <input id="saved-rolls-filter" style="font: 1.9vh Helvetica, Arial, sans-serif; width: 22.1em;" type="text" placeholder="Filter"/>
    <button id="show-raw-button">Raw</button>
    <button id="show-cooked-button">Cooked</button>
    <button id="raw-update-button">Update</button>
  </div>
  
  <div id="saved-rolls" style="overflow-y: scroll; height: 62vh">
  </div>
  
  <textarea id="saved-rolls-raw" style="height: 62vh">
  </textarea>
  
<div>`)
screenLeft.append(rollerDiv)

hideRoller()
hideError()
hideTest()
$('#roller-close').on("click", hideRoller)
$('#roller-save').on("click", saveRollFromUI)
$('#roller-roll').on("click", executeRollBeingBuiltFromUI)
$('#roller-test').on("click", testRollBeingBuiltFromUI)
$("#roller-roll-textarea").on("keyup", onRollEditedInUI)
$("#roller-rollname").on("keyup", onRollnameEditedInUI)
$("#saved-rolls-filter").on("keyup", loadSavedRollsFromOptionsToUI)
$("#saved-rolls-raw").hide()
$("#show-cooked-button").hide()
$("#show-cooked-button").on("click", showSavedRollsAsCooked)
$("#raw-update-button").hide()
$("#raw-update-button").on("click", updateSavedRollsFromRaw)
$("#saved-rolls-raw").on("keyup", onRawRollsEdited)
$("#show-raw-button").on("click", showSavedRollsAsRaw)

function makeMenu() {
	menu = $('<div style="position: absolute; left: 25vh; top: 2vh"><button style="font: 2.5vh Helvetica, Arial, sans-serif; border: 1px solid #000000">Roller</button></div>	')
	$("#subMenuLeft").append(menu)
	menu.on("click", showRoller)
}
makeMenu()

initOptions()
