// ==UserScript==
// @name         hzdx-cs-ai-stage
// @namespace    npm/vite-plugin-monkey
// @version      1.1.8
// @author       zxw
// @description  杭州电信客服中心AI助手-预发版
// @icon         https://vitejs.dev/logo.svg
// @match        https://134.108.5.200:8001/*
// @match        https://134.108.5.200:8005/*
// @match        https://qxisale.zjtelecom.com.cn:8001/*
// @match        https://qxisale.zjtelecom.com.cn:8005/*
// @match        http://134.108.5.200:8001/*
// @match        http://134.108.5.200:8005/*
// @match        http://qxisale.zjtelecom.com.cn:8001/*
// @match        http://qxisale.zjtelecom.com.cn:8005/*
// @match        https://greasyfork.org/zh-CN/scripts/489609-hzdx-cs-ai
// @match        https://greasyfork.org/zh-CN/scripts/491478-hzdx-cs-ai-dev
// @grant        GM_addStyle
// @grant        GM_info
// @grant        GM_xmlhttpRequest
// @downloadURL https://update.greasyfork.org/scripts/491478/hzdx-cs-ai-stage.user.js
// @updateURL https://update.greasyfork.org/scripts/491478/hzdx-cs-ai-stage.meta.js
// ==/UserScript==

(a=>{if(typeof GM_addStyle=="function"){GM_addStyle(a);return}const t=document.createElement("style");t.textContent=a,document.head.append(t)})(' @charset "UTF-8";:root{--theme-color: #3871d0}.draggable-wrap{position:fixed;cursor:move}.chat-action-btn[data-v-11bdb9e9]{cursor:pointer;height:54px;position:relative}.chat-action-btn:hover .text[data-v-11bdb9e9]{text-decoration:underline}.chat-action-btn.active[data-v-11bdb9e9]{background:#55a5eb;color:#fff}.chat-action-btn.active .text[data-v-11bdb9e9]{color:#fff}.chat-action-btn .text[data-v-11bdb9e9]{width:32px;text-align:center;color:#666;font-size:12px;line-height:1.2}.chat-action-btn+.chat-action-btn[data-v-11bdb9e9]:before{content:"";position:absolute;top:0;left:10%;width:80%;background:#ffffffe6;height:1px;transform:translateY(-.5px)}.ai-icon-wrap[data-v-d3759f46]{width:var(--icon-width);height:var(--icon-width);border-radius:42px;position:relative;z-index:1}.ai-icon-wrap.have-bg[data-v-d3759f46]{background:linear-gradient(180deg,#f8ffff,#cee1ff);box-shadow:0 2px 6px #0000004d}.ai-icon-wrap img[data-v-d3759f46]{-webkit-user-select:none;user-select:none;pointer-events:none}.ai-icon-wrap .ai-icon-eye-right[data-v-d3759f46],.ai-icon-wrap .ai-icon-eye[data-v-d3759f46],.ai-icon-wrap .ai-icon-eye-border[data-v-d3759f46]{position:absolute}.ai-icon-wrap .ai-icon-eye[data-v-d3759f46],.ai-icon-wrap .ai-icon-eye-right[data-v-d3759f46]{width:13px;left:12px;top:13px}.ai-icon-wrap .ai-icon-eye-border[data-v-d3759f46]{width:81%;top:4px;left:4px}.ai-icon-wrap .ai-icon-eye-right[data-v-d3759f46]{transform:rotateX(90deg)}.ai-side-bar[data-v-3890fb2a]{position:relative;align-items:center;width:var(--icon-width);height:var(--icon-width);border-radius:50%;background:linear-gradient(180deg,#f8ffff,#cee1ff);box-shadow:0 2px 6px #0000004d}.ai-side-bar.isOpen[data-v-3890fb2a]{width:var(--icon-width);height:var(--right-wrap-height);background:linear-gradient(180deg,#f8ffff,#cee1ff);box-shadow:0 2px 6px #0000004d;border-radius:42px;opacity:1;z-index:9}.ai-side-bar.isOpen .ai-side-bar-tabs[data-v-3890fb2a]{display:flex;flex-direction:column;position:relative;cursor:default}.ai-side-bar.isOpen .ai-side-bar-text[data-v-3890fb2a]{display:block}.ai-side-bar .ai-side-bar-tabs[data-v-3890fb2a]{display:none}.ai-side-bar-text[data-v-3890fb2a]{display:none;text-align:center;width:100%;line-height:17px;margin-top:-5px;padding-bottom:5px;font-family:SourceHanSansSC,SourceHanSansSC;font-weight:400;font-size:10px;color:#1f8cdc;font-style:normal}.quit-btn[data-v-3890fb2a]{height:30px;display:flex;align-items:center;justify-content:center;cursor:pointer;width:30px;margin:6px auto 0}.quit-btn img[data-v-3890fb2a]{width:12px}.ai-bg-img[data-v-1b56b78d],.ai-bg-top[data-v-1b56b78d],.ai-bg-bottom[data-v-1b56b78d]{position:absolute;width:100%;height:100%;top:0;left:0}.ai-bg-bottom[data-v-1b56b78d]{background:linear-gradient(180deg,#fff0,#fff0 23%,#fff 50%,#fff,#fff)}.ai-bg-top[data-v-1b56b78d]{background:linear-gradient(90deg,#148af4,#b8ddff 51%,#22d0ff)}@keyframes blink-f564cbb2{0%{opacity:1}50%{opacity:0}to{opacity:1}}.answer-wrap.active .answer-content-text[data-v-f564cbb2]:after{margin-left:.25rem;vertical-align:baseline;content:"\u258B";animation:blink-f564cbb2 1s steps(5,start) infinite}.ai-modal-container[data-v-f564cbb2]{--header-height: 40px;--footer-height: 20px;--padding-width: 12px;--content-min-height: calc( var(--right-wrap-height) - var(--header-height) - var(--footer-height) );--content-max-height: 64vh;min-width:376px;position:absolute;top:0;right:0;cursor:default}.ai-modal-container .answer-wrap[data-v-f564cbb2]{padding-left:var(--padding-width);min-height:var(--content-min-height);overflow-y:scroll;max-height:var(--content-max-height);position:relative}.ai-modal-container .answer-grey-wrap[data-v-f564cbb2]{min-height:var(--content-min-height);background-color:#fff;border-radius:8px 0 8px 8px;position:relative;padding:var(--padding-width);padding-right:calc(var(--padding-width) + var(--209caf43) - 8px)}.ai-modal-container .answer-grey-wrap .answer-content[data-v-f564cbb2]{text-align:left;position:relative;background:#f2f2f2;border-radius:0 8px 8px;white-space:pre-wrap;padding:6px var(--padding-width);font-size:14px;line-height:1.5;word-break:break-all}.answer-content-btn-item[data-v-d1acc71d]{display:flex;align-items:center;justify-content:center;cursor:pointer}.answer-content-btn-item.action-selected[data-v-d1acc71d]{color:#55a5eb}.ai-modal-container .answer-content-btn .ant-divider{margin:0}.ai-modal-header[data-v-973baeeb]{width:100%;height:var(--header-height);position:relative}.ai-modal-header .text-header[data-v-973baeeb]{position:absolute;width:76px;height:24px;background:#00cfff;border-radius:8px 0;font-family:SourceHanSansSC,SourceHanSansSC;font-weight:400;font-size:12px;color:#fff;line-height:17px;z-index:9}.ai-modal-header .ai-modal-header-order[data-v-973baeeb]{position:absolute;z-index:5;height:40px;font-family:PingFangSC,PingFang SC;font-weight:500;font-size:14px;color:#fff;line-height:20px;left:88px}.ai-modal-header .close[data-v-973baeeb]{position:absolute;top:10px;right:calc(var(--icon-width) + 9px);width:20px;height:20px;z-index:6;cursor:pointer}.setup-drag-bar .dragBar[data-v-e877abc1]{background-color:transparent;position:absolute}.setup-drag-bar .dragBar[data-v-e877abc1]:hover{background-color:transparent}.setup-drag-bar .dragBarY[data-v-e877abc1]{cursor:ew-resize;left:0;top:0;width:2px;height:100%}.setup-drag-bar .dragBarX[data-v-e877abc1]{cursor:ns-resize;left:0;bottom:0;width:100%;height:2px}.setup-drag-bar .dragBarXY[data-v-e877abc1]{cursor:nesw-resize;left:0;bottom:0;width:8px;height:8px}.ai-detail-container[data-v-4c3b9d3c]{position:relative;--right-wrap-height: 256px;--icon-width: var(--71295dc6)}.ai-detail-container .ai-modal-footer[data-v-4c3b9d3c]{box-sizing:border-box;height:var(--footer-height);display:flex;justify-content:space-between;align-items:stretch;width:100%;position:relative;padding-right:calc(var(--71295dc6) + var(--padding-width));border-radius:0 0 18px 8px}.ai-detail-container .ai-modal-footer .statement-text[data-v-4c3b9d3c]{background:#eee;border-radius:0 8px;width:153px;font-family:SourceHanSansSC,SourceHanSansSC;font-weight:400;font-size:10px;color:#888;line-height:15px}.ai-detail-container .ai-modal-footer[data-v-4c3b9d3c] :v-deep(.answer-content-btn){height:var(--footer-height)}[data-v-4c3b9d3c] .ai-bg-img{overflow:hidden;border-radius:8px 20px 20px 8px;box-shadow:0 2px 6px #0006}.ai-login-header[data-v-4bfcae55]{width:100%;height:40px;position:relative}.ai-login-header .text-header[data-v-4bfcae55]{position:absolute;width:76px;height:24px;background:#00cfff;border-radius:8px 0;font-family:SourceHanSansSC,SourceHanSansSC;font-weight:400;font-size:12px;color:#fff;line-height:17px;z-index:9}.ai-login-header .ai-login-header-order[data-v-4bfcae55]{position:absolute;z-index:5;height:40px;font-family:PingFangSC,PingFang SC;font-weight:500;font-size:16px;color:#fff;line-height:20px;left:12px}.ai-login-header .close[data-v-4bfcae55]{position:absolute;top:10px;right:calc(var(--icon-width) + 9px);width:20px;height:20px;z-index:6;cursor:pointer}.ai-login-form[data-v-4cabc03c]{box-sizing:border-box;background:#fff;border-radius:8px;position:absolute;left:12px;height:201px;bottom:0;width:calc(100% - 24px);padding:22px 20px}.ai-login-form[data-v-4cabc03c] .ant-form-item{margin-bottom:12px}.ai-login-form[data-v-4cabc03c] .ant-form-item .ant-form-item-explain-error{position:absolute;font-size:10px;line-height:12px}.ai-login-form .check-box-text[data-v-4cabc03c]{font-weight:400;font-size:12px;transform:translateY(-10px);color:#333}.login-view-content[data-v-88231bdf]{text-align:left;width:304px;height:240px;position:absolute;top:0;right:0;box-shadow:0 2px 6px #0006;border-radius:8px 24px 8px 8px;overflow:hidden}[data-v-4de0941f] .van-icon__image{-webkit-user-select:none;user-select:none}.ai-monkey-container[data-v-4de0941f]{position:fixed;top:20vh;right:0;z-index:9999}.ai-monkey-container{--icon-width: var(--57faa4d4)}.ai-scroll::-webkit-scrollbar{width:8px;height:8px;background-color:green}.ai-scroll::-webkit-scrollbar-track-piece{background-color:#d3d3d3}.ai-scroll::-webkit-scrollbar-thumb{border:0 solid transparent;border-radius:8px;background-color:#7c7c7d}.disable-select{-webkit-user-select:none;user-select:none}.flex-c{display:flex;align-items:center;justify-content:center}.flex-c-a{display:flex;align-items:center;justify-content:space-around}.ai-monkey-container .ant-message{position:absolute}.ai-monkey-container .ant-message-notice-content{font-size:12px;transform:scale(.9)}.ai-stop-mousedown[data-v-72704d84]{cursor:default} ');

(function () {
  'use strict';

  var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __publicField = (obj, key2, value) => {
    __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
    return value;
  };
  /**
  * @vue/shared v3.4.21
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  function makeMap(str, expectsLowerCase) {
    const set2 = new Set(str.split(","));
    return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
  }
  const EMPTY_OBJ = Object.freeze({});
  const EMPTY_ARR = Object.freeze([]);
  const NOOP = () => {
  };
  const NO = () => false;
  const isOn$1 = (key2) => key2.charCodeAt(0) === 111 && key2.charCodeAt(1) === 110 && // uppercase letter
  (key2.charCodeAt(2) > 122 || key2.charCodeAt(2) < 97);
  const isModelListener = (key2) => key2.startsWith("onUpdate:");
  const extend = Object.assign;
  const remove = (arr, el) => {
    const i2 = arr.indexOf(el);
    if (i2 > -1) {
      arr.splice(i2, 1);
    }
  };
  const hasOwnProperty$g = Object.prototype.hasOwnProperty;
  const hasOwn$1 = (val, key2) => hasOwnProperty$g.call(val, key2);
  const isArray$2 = Array.isArray;
  const isMap$1 = (val) => toTypeString(val) === "[object Map]";
  const isSet$1 = (val) => toTypeString(val) === "[object Set]";
  const isFunction$2 = (val) => typeof val === "function";
  const isString$1 = (val) => typeof val === "string";
  const isSymbol$1 = (val) => typeof val === "symbol";
  const isObject$3 = (val) => val !== null && typeof val === "object";
  const isPromise = (val) => {
    return (isObject$3(val) || isFunction$2(val)) && isFunction$2(val.then) && isFunction$2(val.catch);
  };
  const objectToString$1 = Object.prototype.toString;
  const toTypeString = (value) => objectToString$1.call(value);
  const toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  const isPlainObject$2 = (val) => toTypeString(val) === "[object Object]";
  const isIntegerKey = (key2) => isString$1(key2) && key2 !== "NaN" && key2[0] !== "-" && "" + parseInt(key2, 10) === key2;
  const isReservedProp = /* @__PURE__ */ makeMap(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  const isBuiltInDirective = /* @__PURE__ */ makeMap(
    "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
  );
  const cacheStringFunction$1 = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  const camelizeRE$1 = /-(\w)/g;
  const camelize$1 = cacheStringFunction$1((str) => {
    return str.replace(camelizeRE$1, (_2, c2) => c2 ? c2.toUpperCase() : "");
  });
  const hyphenateRE$1 = /\B([A-Z])/g;
  const hyphenate$1 = cacheStringFunction$1(
    (str) => str.replace(hyphenateRE$1, "-$1").toLowerCase()
  );
  const capitalize = cacheStringFunction$1((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  const toHandlerKey = cacheStringFunction$1((str) => {
    const s2 = str ? `on${capitalize(str)}` : ``;
    return s2;
  });
  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  const invokeArrayFns = (fns, arg) => {
    for (let i2 = 0; i2 < fns.length; i2++) {
      fns[i2](arg);
    }
  };
  const def = (obj, key2, value) => {
    Object.defineProperty(obj, key2, {
      configurable: true,
      enumerable: false,
      value
    });
  };
  const looseToNumber = (val) => {
    const n2 = parseFloat(val);
    return isNaN(n2) ? val : n2;
  };
  const toNumber$1 = (val) => {
    const n2 = isString$1(val) ? Number(val) : NaN;
    return isNaN(n2) ? val : n2;
  };
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  function normalizeStyle$1(value) {
    if (isArray$2(value)) {
      const res = {};
      for (let i2 = 0; i2 < value.length; i2++) {
        const item = value[i2];
        const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle$1(item);
        if (normalized) {
          for (const key2 in normalized) {
            res[key2] = normalized[key2];
          }
        }
      }
      return res;
    } else if (isString$1(value) || isObject$3(value)) {
      return value;
    }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString$1(value)) {
      res = value;
    } else if (isArray$2(value)) {
      for (let i2 = 0; i2 < value.length; i2++) {
        const normalized = normalizeClass(value[i2]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject$3(value)) {
      for (const name2 in value) {
        if (value[name2]) {
          res += name2 + " ";
        }
      }
    }
    return res.trim();
  }
  const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
  const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
  const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
  const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
  const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
  const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  const toDisplayString = (val) => {
    return isString$1(val) ? val : val == null ? "" : isArray$2(val) || isObject$3(val) && (val.toString === objectToString$1 || !isFunction$2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
  };
  const replacer = (_key, val) => {
    if (val && val.__v_isRef) {
      return replacer(_key, val.value);
    } else if (isMap$1(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce(
          (entries, [key2, val2], i2) => {
            entries[stringifySymbol(key2, i2) + " =>"] = val2;
            return entries;
          },
          {}
        )
      };
    } else if (isSet$1(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
      };
    } else if (isSymbol$1(val)) {
      return stringifySymbol(val);
    } else if (isObject$3(val) && !isArray$2(val) && !isPlainObject$2(val)) {
      return String(val);
    }
    return val;
  };
  const stringifySymbol = (v2, i2 = "") => {
    var _a2;
    return isSymbol$1(v2) ? `Symbol(${(_a2 = v2.description) != null ? _a2 : i2})` : v2;
  };
  /**
  * @vue/reactivity v3.4.21
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  function warn$3(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
  }
  let activeEffectScope;
  class EffectScope {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this.effects = [];
      this.cleanups = [];
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
      }
    }
    get active() {
      return this._active;
    }
    run(fn) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      } else {
        warn$3(`cannot run an inactive effect scope.`);
      }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
      activeEffectScope = this;
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
      activeEffectScope = this.parent;
    }
    stop(fromParent) {
      if (this._active) {
        let i2, l2;
        for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
          this.effects[i2].stop();
        }
        for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
          this.cleanups[i2]();
        }
        if (this.scopes) {
          for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
            this.scopes[i2].stop(true);
          }
        }
        if (!this.detached && this.parent && !fromParent) {
          const last2 = this.parent.scopes.pop();
          if (last2 && last2 !== this) {
            this.parent.scopes[this.index] = last2;
            last2.index = this.index;
          }
        }
        this.parent = void 0;
        this._active = false;
      }
    }
  }
  function effectScope(detached) {
    return new EffectScope(detached);
  }
  function recordEffectScope(effect2, scope = activeEffectScope) {
    if (scope && scope.active) {
      scope.effects.push(effect2);
    }
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  function onScopeDispose(fn) {
    if (activeEffectScope) {
      activeEffectScope.cleanups.push(fn);
    } else {
      warn$3(
        `onScopeDispose() is called when there is no active effect scope to be associated with.`
      );
    }
  }
  let activeEffect;
  class ReactiveEffect {
    constructor(fn, trigger2, scheduler, scope) {
      this.fn = fn;
      this.trigger = trigger2;
      this.scheduler = scheduler;
      this.active = true;
      this.deps = [];
      this._dirtyLevel = 4;
      this._trackId = 0;
      this._runnings = 0;
      this._shouldSchedule = false;
      this._depsLength = 0;
      recordEffectScope(this, scope);
    }
    get dirty() {
      if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
        this._dirtyLevel = 1;
        pauseTracking();
        for (let i2 = 0; i2 < this._depsLength; i2++) {
          const dep = this.deps[i2];
          if (dep.computed) {
            triggerComputed(dep.computed);
            if (this._dirtyLevel >= 4) {
              break;
            }
          }
        }
        if (this._dirtyLevel === 1) {
          this._dirtyLevel = 0;
        }
        resetTracking();
      }
      return this._dirtyLevel >= 4;
    }
    set dirty(v2) {
      this._dirtyLevel = v2 ? 4 : 0;
    }
    run() {
      this._dirtyLevel = 0;
      if (!this.active) {
        return this.fn();
      }
      let lastShouldTrack = shouldTrack;
      let lastEffect = activeEffect;
      try {
        shouldTrack = true;
        activeEffect = this;
        this._runnings++;
        preCleanupEffect(this);
        return this.fn();
      } finally {
        postCleanupEffect(this);
        this._runnings--;
        activeEffect = lastEffect;
        shouldTrack = lastShouldTrack;
      }
    }
    stop() {
      var _a2;
      if (this.active) {
        preCleanupEffect(this);
        postCleanupEffect(this);
        (_a2 = this.onStop) == null ? void 0 : _a2.call(this);
        this.active = false;
      }
    }
  }
  function triggerComputed(computed2) {
    return computed2.value;
  }
  function preCleanupEffect(effect2) {
    effect2._trackId++;
    effect2._depsLength = 0;
  }
  function postCleanupEffect(effect2) {
    if (effect2.deps.length > effect2._depsLength) {
      for (let i2 = effect2._depsLength; i2 < effect2.deps.length; i2++) {
        cleanupDepEffect(effect2.deps[i2], effect2);
      }
      effect2.deps.length = effect2._depsLength;
    }
  }
  function cleanupDepEffect(dep, effect2) {
    const trackId = dep.get(effect2);
    if (trackId !== void 0 && effect2._trackId !== trackId) {
      dep.delete(effect2);
      if (dep.size === 0) {
        dep.cleanup();
      }
    }
  }
  let shouldTrack = true;
  let pauseScheduleStack = 0;
  const trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last2 = trackStack.pop();
    shouldTrack = last2 === void 0 ? true : last2;
  }
  function pauseScheduling() {
    pauseScheduleStack++;
  }
  function resetScheduling() {
    pauseScheduleStack--;
    while (!pauseScheduleStack && queueEffectSchedulers.length) {
      queueEffectSchedulers.shift()();
    }
  }
  function trackEffect(effect2, dep, debuggerEventExtraInfo) {
    var _a2;
    if (dep.get(effect2) !== effect2._trackId) {
      dep.set(effect2, effect2._trackId);
      const oldDep = effect2.deps[effect2._depsLength];
      if (oldDep !== dep) {
        if (oldDep) {
          cleanupDepEffect(oldDep, effect2);
        }
        effect2.deps[effect2._depsLength++] = dep;
      } else {
        effect2._depsLength++;
      }
      {
        (_a2 = effect2.onTrack) == null ? void 0 : _a2.call(effect2, extend({ effect: effect2 }, debuggerEventExtraInfo));
      }
    }
  }
  const queueEffectSchedulers = [];
  function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
    var _a2;
    pauseScheduling();
    for (const effect2 of dep.keys()) {
      let tracking;
      if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
        effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
        effect2._dirtyLevel = dirtyLevel;
      }
      if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
        {
          (_a2 = effect2.onTrigger) == null ? void 0 : _a2.call(effect2, extend({ effect: effect2 }, debuggerEventExtraInfo));
        }
        effect2.trigger();
        if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
          effect2._shouldSchedule = false;
          if (effect2.scheduler) {
            queueEffectSchedulers.push(effect2.scheduler);
          }
        }
      }
    }
    resetScheduling();
  }
  const createDep = (cleanup2, computed2) => {
    const dep = /* @__PURE__ */ new Map();
    dep.cleanup = cleanup2;
    dep.computed = computed2;
    return dep;
  };
  const targetMap = /* @__PURE__ */ new WeakMap();
  const ITERATE_KEY = Symbol("iterate");
  const MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
  function track(target, type4, key2) {
    if (shouldTrack && activeEffect) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key2);
      if (!dep) {
        depsMap.set(key2, dep = createDep(() => depsMap.delete(key2)));
      }
      trackEffect(
        activeEffect,
        dep,
        {
          target,
          type: type4,
          key: key2
        }
      );
    }
  }
  function trigger$1(target, type4, key2, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    let deps = [];
    if (type4 === "clear") {
      deps = [...depsMap.values()];
    } else if (key2 === "length" && isArray$2(target)) {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key22) => {
        if (key22 === "length" || !isSymbol$1(key22) && key22 >= newLength) {
          deps.push(dep);
        }
      });
    } else {
      if (key2 !== void 0) {
        deps.push(depsMap.get(key2));
      }
      switch (type4) {
        case "add":
          if (!isArray$2(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap$1(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key2)) {
            deps.push(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray$2(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap$1(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap$1(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    pauseScheduling();
    for (const dep of deps) {
      if (dep) {
        triggerEffects(
          dep,
          4,
          {
            target,
            type: type4,
            key: key2,
            newValue,
            oldValue,
            oldTarget
          }
        );
      }
    }
    resetScheduling();
  }
  function getDepFromReactive(object4, key2) {
    var _a2;
    return (_a2 = targetMap.get(object4)) == null ? void 0 : _a2.get(key2);
  }
  const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  const builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key2) => key2 !== "arguments" && key2 !== "caller").map((key2) => Symbol[key2]).filter(isSymbol$1)
  );
  const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
  function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key2) => {
      instrumentations[key2] = function(...args) {
        const arr = toRaw(this);
        for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
          track(arr, "get", i2 + "");
        }
        const res = arr[key2](...args);
        if (res === -1 || res === false) {
          return arr[key2](...args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key2) => {
      instrumentations[key2] = function(...args) {
        pauseTracking();
        pauseScheduling();
        const res = toRaw(this)[key2].apply(this, args);
        resetScheduling();
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function hasOwnProperty$f(key2) {
    const obj = toRaw(this);
    track(obj, "has", key2);
    return obj.hasOwnProperty(key2);
  }
  class BaseReactiveHandler {
    constructor(_isReadonly = false, _isShallow = false) {
      this._isReadonly = _isReadonly;
      this._isShallow = _isShallow;
    }
    get(target, key2, receiver) {
      const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
      if (key2 === "__v_isReactive") {
        return !isReadonly2;
      } else if (key2 === "__v_isReadonly") {
        return isReadonly2;
      } else if (key2 === "__v_isShallow") {
        return isShallow2;
      } else if (key2 === "__v_raw") {
        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
        // this means the reciever is a user proxy of the reactive proxy
        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
          return target;
        }
        return;
      }
      const targetIsArray = isArray$2(target);
      if (!isReadonly2) {
        if (targetIsArray && hasOwn$1(arrayInstrumentations, key2)) {
          return Reflect.get(arrayInstrumentations, key2, receiver);
        }
        if (key2 === "hasOwnProperty") {
          return hasOwnProperty$f;
        }
      }
      const res = Reflect.get(target, key2, receiver);
      if (isSymbol$1(key2) ? builtInSymbols.has(key2) : isNonTrackableKeys(key2)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key2);
      }
      if (isShallow2) {
        return res;
      }
      if (isRef(res)) {
        return targetIsArray && isIntegerKey(key2) ? res : res.value;
      }
      if (isObject$3(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    }
  }
  class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(false, isShallow2);
    }
    set(target, key2, value, receiver) {
      let oldValue = target[key2];
      if (!this._isShallow) {
        const isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
          if (isOldValueReadonly) {
            return false;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      const hadKey = isArray$2(target) && isIntegerKey(key2) ? Number(key2) < target.length : hasOwn$1(target, key2);
      const result = Reflect.set(target, key2, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger$1(target, "add", key2, value);
        } else if (hasChanged(value, oldValue)) {
          trigger$1(target, "set", key2, value, oldValue);
        }
      }
      return result;
    }
    deleteProperty(target, key2) {
      const hadKey = hasOwn$1(target, key2);
      const oldValue = target[key2];
      const result = Reflect.deleteProperty(target, key2);
      if (result && hadKey) {
        trigger$1(target, "delete", key2, void 0, oldValue);
      }
      return result;
    }
    has(target, key2) {
      const result = Reflect.has(target, key2);
      if (!isSymbol$1(key2) || !builtInSymbols.has(key2)) {
        track(target, "has", key2);
      }
      return result;
    }
    ownKeys(target) {
      track(
        target,
        "iterate",
        isArray$2(target) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target);
    }
  }
  class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(true, isShallow2);
    }
    set(target, key2) {
      {
        warn$3(
          `Set operation on key "${String(key2)}" failed: target is readonly.`,
          target
        );
      }
      return true;
    }
    deleteProperty(target, key2) {
      {
        warn$3(
          `Delete operation on key "${String(key2)}" failed: target is readonly.`,
          target
        );
      }
      return true;
    }
  }
  const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
  const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
  const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
    true
  );
  const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
  const toShallow = (value) => value;
  const getProto = (v2) => Reflect.getPrototypeOf(v2);
  function get$2(target, key2, isReadonly2 = false, isShallow2 = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key2);
    if (!isReadonly2) {
      if (hasChanged(key2, rawKey)) {
        track(rawTarget, "get", key2);
      }
      track(rawTarget, "get", rawKey);
    }
    const { has: has2 } = getProto(rawTarget);
    const wrap3 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    if (has2.call(rawTarget, key2)) {
      return wrap3(target.get(key2));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap3(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key2);
    }
  }
  function has(key2, isReadonly2 = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key2);
    if (!isReadonly2) {
      if (hasChanged(key2, rawKey)) {
        track(rawTarget, "has", key2);
      }
      track(rawTarget, "has", rawKey);
    }
    return key2 === rawKey ? target.has(key2) : target.has(key2) || target.has(rawKey);
  }
  function size(target, isReadonly2 = false) {
    target = target["__v_raw"];
    !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger$1(target, "add", value, value);
    }
    return this;
  }
  function set$2(key2, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key2);
    if (!hadKey) {
      key2 = toRaw(key2);
      hadKey = has2.call(target, key2);
    } else {
      checkIdentityKeys(target, has2, key2);
    }
    const oldValue = get2.call(target, key2);
    target.set(key2, value);
    if (!hadKey) {
      trigger$1(target, "add", key2, value);
    } else if (hasChanged(value, oldValue)) {
      trigger$1(target, "set", key2, value, oldValue);
    }
    return this;
  }
  function deleteEntry(key2) {
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key2);
    if (!hadKey) {
      key2 = toRaw(key2);
      hadKey = has2.call(target, key2);
    } else {
      checkIdentityKeys(target, has2, key2);
    }
    const oldValue = get2 ? get2.call(target, key2) : void 0;
    const result = target.delete(key2);
    if (hadKey) {
      trigger$1(target, "delete", key2, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = isMap$1(target) ? new Map(target) : new Set(target);
    const result = target.clear();
    if (hadItems) {
      trigger$1(target, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly2, isShallow2) {
    return function forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap3 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key2) => {
        return callback.call(thisArg, wrap3(value), wrap3(key2), observed);
      });
    };
  }
  function createIterableMethod(method4, isReadonly2, isShallow2) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap$1(rawTarget);
      const isPair = method4 === "entries" || method4 === Symbol.iterator && targetIsMap;
      const isKeyOnly = method4 === "keys" && targetIsMap;
      const innerIterator = target[method4](...args);
      const wrap3 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap3(value[0]), wrap3(value[1])] : wrap3(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type4) {
    return function(...args) {
      {
        const key2 = args[0] ? `on key "${args[0]}" ` : ``;
        warn$3(
          `${capitalize(type4)} operation ${key2}failed: target is readonly.`,
          toRaw(this)
        );
      }
      return type4 === "delete" ? false : type4 === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key2) {
        return get$2(this, key2);
      },
      get size() {
        return size(this);
      },
      has,
      add,
      set: set$2,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key2) {
        return get$2(this, key2, false, true);
      },
      get size() {
        return size(this);
      },
      has,
      add,
      set: set$2,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key2) {
        return get$2(this, key2, true);
      },
      get size() {
        return size(this, true);
      },
      has(key2) {
        return has.call(this, key2, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key2) {
        return get$2(this, key2, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key2) {
        return has.call(this, key2, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
    iteratorMethods.forEach((method4) => {
      mutableInstrumentations2[method4] = createIterableMethod(
        method4,
        false,
        false
      );
      readonlyInstrumentations2[method4] = createIterableMethod(
        method4,
        true,
        false
      );
      shallowInstrumentations2[method4] = createIterableMethod(
        method4,
        false,
        true
      );
      shallowReadonlyInstrumentations2[method4] = createIterableMethod(
        method4,
        true,
        true
      );
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  const [
    mutableInstrumentations,
    readonlyInstrumentations,
    shallowInstrumentations,
    shallowReadonlyInstrumentations
  ] = /* @__PURE__ */ createInstrumentations();
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key2, receiver) => {
      if (key2 === "__v_isReactive") {
        return !isReadonly2;
      } else if (key2 === "__v_isReadonly") {
        return isReadonly2;
      } else if (key2 === "__v_raw") {
        return target;
      }
      return Reflect.get(
        hasOwn$1(instrumentations, key2) && key2 in target ? instrumentations : target,
        key2,
        receiver
      );
    };
  }
  const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  function checkIdentityKeys(target, has2, key2) {
    const rawKey = toRaw(key2);
    if (rawKey !== key2 && has2.call(target, rawKey)) {
      const type4 = toRawType(target);
      warn$3(
        `Reactive ${type4} contains both the raw and reactive versions of the same object${type4 === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
      );
    }
  }
  const reactiveMap = /* @__PURE__ */ new WeakMap();
  const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  const readonlyMap = /* @__PURE__ */ new WeakMap();
  const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function shallowReactive(target) {
    return createReactiveObject(
      target,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
    );
  }
  function readonly(target) {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function shallowReadonly(target) {
    return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    );
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject$3(target)) {
      {
        warn$3(`value cannot be made reactive: ${String(target)}`);
      }
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(
      target,
      targetType === 2 ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return isReactive(value) || isReadonly(value);
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    if (Object.isExtensible(value)) {
      def(value, "__v_skip", true);
    }
    return value;
  }
  const toReactive = (value) => isObject$3(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject$3(value) ? readonly(value) : value;
  const COMPUTED_SIDE_EFFECT_WARN = `Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free`;
  class ComputedRefImpl {
    constructor(getter, _setter, isReadonly2, isSSR) {
      this.getter = getter;
      this._setter = _setter;
      this.dep = void 0;
      this.__v_isRef = true;
      this["__v_isReadonly"] = false;
      this.effect = new ReactiveEffect(
        () => getter(this._value),
        () => triggerRefValue(
          this,
          this.effect._dirtyLevel === 2 ? 2 : 3
        )
      );
      this.effect.computed = this;
      this.effect.active = this._cacheable = !isSSR;
      this["__v_isReadonly"] = isReadonly2;
    }
    get value() {
      const self2 = toRaw(this);
      if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
        triggerRefValue(self2, 4);
      }
      trackRefValue(self2);
      if (self2.effect._dirtyLevel >= 2) {
        if (this._warnRecursive) {
          warn$3(COMPUTED_SIDE_EFFECT_WARN, `

getter: `, this.getter);
        }
        triggerRefValue(self2, 2);
      }
      return self2._value;
    }
    set value(newValue) {
      this._setter(newValue);
    }
    // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
    get _dirty() {
      return this.effect.dirty;
    }
    set _dirty(v2) {
      this.effect.dirty = v2;
    }
    // #endregion
  }
  function computed$1(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = isFunction$2(getterOrOptions);
    if (onlyGetter) {
      getter = getterOrOptions;
      setter = () => {
        warn$3("Write operation failed: computed value is readonly");
      };
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    if (debugOptions && !isSSR) {
      cRef.effect.onTrack = debugOptions.onTrack;
      cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
  }
  function trackRefValue(ref2) {
    var _a2;
    if (shouldTrack && activeEffect) {
      ref2 = toRaw(ref2);
      trackEffect(
        activeEffect,
        (_a2 = ref2.dep) != null ? _a2 : ref2.dep = createDep(
          () => ref2.dep = void 0,
          ref2 instanceof ComputedRefImpl ? ref2 : void 0
        ),
        {
          target: ref2,
          type: "get",
          key: "value"
        }
      );
    }
  }
  function triggerRefValue(ref2, dirtyLevel = 4, newVal) {
    ref2 = toRaw(ref2);
    const dep = ref2.dep;
    if (dep) {
      triggerEffects(
        dep,
        dirtyLevel,
        {
          target: ref2,
          type: "set",
          key: "value",
          newValue: newVal
        }
      );
    }
  }
  function isRef(r2) {
    return !!(r2 && r2.__v_isRef === true);
  }
  function ref(value) {
    return createRef(value, false);
  }
  function shallowRef(value) {
    return createRef(value, true);
  }
  function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  class RefImpl {
    constructor(value, __v_isShallow) {
      this.__v_isShallow = __v_isShallow;
      this.dep = void 0;
      this.__v_isRef = true;
      this._rawValue = __v_isShallow ? value : toRaw(value);
      this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
      trackRefValue(this);
      return this._value;
    }
    set value(newVal) {
      const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
      newVal = useDirectValue ? newVal : toRaw(newVal);
      if (hasChanged(newVal, this._rawValue)) {
        this._rawValue = newVal;
        this._value = useDirectValue ? newVal : toReactive(newVal);
        triggerRefValue(this, 4, newVal);
      }
    }
  }
  function triggerRef(ref2) {
    triggerRefValue(ref2, 4, ref2.value);
  }
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  const shallowUnwrapHandlers = {
    get: (target, key2, receiver) => unref(Reflect.get(target, key2, receiver)),
    set: (target, key2, value, receiver) => {
      const oldValue = target[key2];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key2, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  function toRefs(object4) {
    if (!isProxy(object4)) {
      warn$3(`toRefs() expects a reactive object but received a plain one.`);
    }
    const ret = isArray$2(object4) ? new Array(object4.length) : {};
    for (const key2 in object4) {
      ret[key2] = propertyToRef(object4, key2);
    }
    return ret;
  }
  class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
      this._object = _object;
      this._key = _key;
      this._defaultValue = _defaultValue;
      this.__v_isRef = true;
    }
    get value() {
      const val = this._object[this._key];
      return val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
      this._object[this._key] = newVal;
    }
    get dep() {
      return getDepFromReactive(toRaw(this._object), this._key);
    }
  }
  class GetterRefImpl {
    constructor(_getter) {
      this._getter = _getter;
      this.__v_isRef = true;
      this.__v_isReadonly = true;
    }
    get value() {
      return this._getter();
    }
  }
  function toRef(source, key2, defaultValue) {
    if (isRef(source)) {
      return source;
    } else if (isFunction$2(source)) {
      return new GetterRefImpl(source);
    } else if (isObject$3(source) && arguments.length > 1) {
      return propertyToRef(source, key2, defaultValue);
    } else {
      return ref(source);
    }
  }
  function propertyToRef(source, key2, defaultValue) {
    const val = source[key2];
    return isRef(val) ? val : new ObjectRefImpl(source, key2, defaultValue);
  }
  /**
  * @vue/runtime-core v3.4.21
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const stack = [];
  function pushWarningContext(vnode) {
    stack.push(vnode);
  }
  function popWarningContext() {
    stack.pop();
  }
  function warn$1(msg, ...args) {
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
          msg + args.map((a2) => {
            var _a2, _b;
            return (_b = (_a2 = a2.toString) == null ? void 0 : _a2.call(a2)) != null ? _b : JSON.stringify(a2);
          }).join(""),
          instance && instance.proxy,
          trace.map(
            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
          ).join("\n"),
          trace
        ]
      );
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && // avoid spamming console during tests
      true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last2 = normalizedStack[0];
      if (last2 && last2.vnode === currentVNode) {
        last2.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i2) => {
      logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open2 = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
    const close = `>` + postfix;
    return vnode.props ? [open2, ...formatProps(vnode.props), close] : [open2 + close];
  }
  function formatProps(props) {
    const res = [];
    const keys2 = Object.keys(props);
    keys2.slice(0, 3).forEach((key2) => {
      res.push(...formatProp(key2, props[key2]));
    });
    if (keys2.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key2, value, raw) {
    if (isString$1(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key2}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key2}=${value}`];
    } else if (isRef(value)) {
      value = formatProp(key2, toRaw(value.value), true);
      return raw ? value : [`${key2}=Ref<`, value, `>`];
    } else if (isFunction$2(value)) {
      return [`${key2}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key2}=`, value];
    }
  }
  function assertNumber(val, type4) {
    if (val === void 0) {
      return;
    } else if (typeof val !== "number") {
      warn$1(`${type4} is not a valid number - got ${JSON.stringify(val)}.`);
    } else if (isNaN(val)) {
      warn$1(`${type4} is NaN - the duration expression might be incorrect.`);
    }
  }
  const ErrorTypeStrings$1 = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."
  };
  function callWithErrorHandling(fn, instance, type4, args) {
    try {
      return args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type4);
    }
  }
  function callWithAsyncErrorHandling(fn, instance, type4, args) {
    if (isFunction$2(fn)) {
      const res = callWithErrorHandling(fn, instance, type4, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type4);
        });
      }
      return res;
    }
    const values = [];
    for (let i2 = 0; i2 < fn.length; i2++) {
      values.push(callWithAsyncErrorHandling(fn[i2], instance, type4, args));
    }
    return values;
  }
  function handleError(err, instance, type4, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = ErrorTypeStrings$1[type4];
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
            if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      const appErrorHandler = instance.appContext.config.errorHandler;
      if (appErrorHandler) {
        callWithErrorHandling(
          appErrorHandler,
          null,
          10,
          [err, exposedInstance, errorInfo]
        );
        return;
      }
    }
    logError(err, type4, contextVNode, throwInDev);
  }
  function logError(err, type4, contextVNode, throwInDev = true) {
    {
      const info = ErrorTypeStrings$1[type4];
      if (contextVNode) {
        pushWarningContext(contextVNode);
      }
      warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
      if (contextVNode) {
        popWarningContext();
      }
      if (throwInDev) {
        throw err;
      } else {
        console.error(err);
      }
    }
  }
  let isFlushing = false;
  let isFlushPending = false;
  const queue = [];
  let flushIndex = 0;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = /* @__PURE__ */ Promise.resolve();
  let currentFlushPromise = null;
  const RECURSION_LIMIT = 100;
  function nextTick(fn) {
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
  }
  function findInsertionIndex(id) {
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJob = queue[middle];
      const middleJobId = getId(middleJob);
      if (middleJobId < id || middleJobId === id && middleJob.pre) {
        start = middle + 1;
      } else {
        end = middle;
      }
    }
    return start;
  }
  function queueJob(job) {
    if (!queue.length || !queue.includes(
      job,
      isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
    )) {
      if (job.id == null) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(job.id), 0, job);
      }
      queueFlush();
    }
  }
  function queueFlush() {
    if (!isFlushing && !isFlushPending) {
      isFlushPending = true;
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function invalidateJob(job) {
    const i2 = queue.indexOf(job);
    if (i2 > flushIndex) {
      queue.splice(i2, 1);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray$2(cb)) {
      if (!activePostFlushCbs || !activePostFlushCbs.includes(
        cb,
        cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
      )) {
        pendingPostFlushCbs.push(cb);
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen, i2 = isFlushing ? flushIndex + 1 : 0) {
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    for (; i2 < queue.length; i2++) {
      const cb = queue[i2];
      if (cb && cb.pre) {
        if (instance && cb.id !== instance.uid) {
          continue;
        }
        if (checkRecursiveUpdates(seen, cb)) {
          continue;
        }
        queue.splice(i2, 1);
        i2--;
        cb();
      }
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)].sort(
        (a2, b2) => getId(a2) - getId(b2)
      );
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      {
        seen = seen || /* @__PURE__ */ new Map();
      }
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
          continue;
        }
        activePostFlushCbs[postFlushIndex]();
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  const getId = (job) => job.id == null ? Infinity : job.id;
  const comparator = (a2, b2) => {
    const diff = getId(a2) - getId(b2);
    if (diff === 0) {
      if (a2.pre && !b2.pre)
        return -1;
      if (b2.pre && !a2.pre)
        return 1;
    }
    return diff;
  };
  function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    queue.sort(comparator);
    const check = (job) => checkRecursiveUpdates(seen, job);
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && job.active !== false) {
          if (check(job)) {
            continue;
          }
          callWithErrorHandling(job, null, 14);
        }
      }
    } finally {
      flushIndex = 0;
      queue.length = 0;
      flushPostFlushCbs(seen);
      isFlushing = false;
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs(seen);
      }
    }
  }
  function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) {
      seen.set(fn, 1);
    } else {
      const count = seen.get(fn);
      if (count > RECURSION_LIMIT) {
        const instance = fn.ownerInstance;
        const componentName = instance && getComponentName(instance.type);
        handleError(
          `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
          null,
          10
        );
        return true;
      } else {
        seen.set(fn, count + 1);
      }
    }
  }
  let isHmrUpdating = false;
  const hmrDirtyComponents = /* @__PURE__ */ new Set();
  {
    getGlobalThis().__VUE_HMR_RUNTIME__ = {
      createRecord: tryWrap(createRecord),
      rerender: tryWrap(rerender),
      reload: tryWrap(reload)
    };
  }
  const map = /* @__PURE__ */ new Map();
  function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
      createRecord(id, instance.type);
      record = map.get(id);
    }
    record.instances.add(instance);
  }
  function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
  }
  function createRecord(id, initialDef) {
    if (map.has(id)) {
      return false;
    }
    map.set(id, {
      initialDef: normalizeClassComponent(initialDef),
      instances: /* @__PURE__ */ new Set()
    });
    return true;
  }
  function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
  }
  function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) {
      return;
    }
    record.initialDef.render = newRender;
    [...record.instances].forEach((instance) => {
      if (newRender) {
        instance.render = newRender;
        normalizeClassComponent(instance.type).render = newRender;
      }
      instance.renderCache = [];
      isHmrUpdating = true;
      instance.effect.dirty = true;
      instance.update();
      isHmrUpdating = false;
    });
  }
  function reload(id, newComp) {
    const record = map.get(id);
    if (!record)
      return;
    newComp = normalizeClassComponent(newComp);
    updateComponentDef(record.initialDef, newComp);
    const instances = [...record.instances];
    for (const instance of instances) {
      const oldComp = normalizeClassComponent(instance.type);
      if (!hmrDirtyComponents.has(oldComp)) {
        if (oldComp !== record.initialDef) {
          updateComponentDef(oldComp, newComp);
        }
        hmrDirtyComponents.add(oldComp);
      }
      instance.appContext.propsCache.delete(instance.type);
      instance.appContext.emitsCache.delete(instance.type);
      instance.appContext.optionsCache.delete(instance.type);
      if (instance.ceReload) {
        hmrDirtyComponents.add(oldComp);
        instance.ceReload(newComp.styles);
        hmrDirtyComponents.delete(oldComp);
      } else if (instance.parent) {
        instance.parent.effect.dirty = true;
        queueJob(instance.parent.update);
      } else if (instance.appContext.reload) {
        instance.appContext.reload();
      } else if (typeof window !== "undefined") {
        window.location.reload();
      } else {
        console.warn(
          "[HMR] Root or manually mounted instance modified. Full reload required."
        );
      }
    }
    queuePostFlushCb(() => {
      for (const instance of instances) {
        hmrDirtyComponents.delete(
          normalizeClassComponent(instance.type)
        );
      }
    });
  }
  function updateComponentDef(oldComp, newComp) {
    extend(oldComp, newComp);
    for (const key2 in oldComp) {
      if (key2 !== "__file" && !(key2 in newComp)) {
        delete oldComp[key2];
      }
    }
  }
  function tryWrap(fn) {
    return (id, arg) => {
      try {
        return fn(id, arg);
      } catch (e2) {
        console.error(e2);
        console.warn(
          `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
        );
      }
    };
  }
  let devtools$1;
  let buffer = [];
  let devtoolsNotInstalled = false;
  function emit$1(event, ...args) {
    if (devtools$1) {
      devtools$1.emit(event, ...args);
    } else if (!devtoolsNotInstalled) {
      buffer.push({ event, args });
    }
  }
  function setDevtoolsHook$1(hook, target) {
    var _a2, _b;
    devtools$1 = hook;
    if (devtools$1) {
      devtools$1.enabled = true;
      buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
      buffer = [];
    } else if (
      // handle late devtools injection - only do this if we are in an actual
      // browser environment to avoid the timer handle stalling test runner exit
      // (#4815)
      typeof window !== "undefined" && // some envs mock window but not fully
      window.HTMLElement && // also exclude jsdom
      !((_b = (_a2 = window.navigator) == null ? void 0 : _a2.userAgent) == null ? void 0 : _b.includes("jsdom"))
    ) {
      const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
      replay.push((newHook) => {
        setDevtoolsHook$1(newHook, target);
      });
      setTimeout(() => {
        if (!devtools$1) {
          target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
          devtoolsNotInstalled = true;
          buffer = [];
        }
      }, 3e3);
    } else {
      devtoolsNotInstalled = true;
      buffer = [];
    }
  }
  function devtoolsInitApp(app2, version2) {
    emit$1("app:init", app2, version2, {
      Fragment,
      Text,
      Comment,
      Static
    });
  }
  function devtoolsUnmountApp(app2) {
    emit$1("app:unmount", app2);
  }
  const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:added"
    /* COMPONENT_ADDED */
  );
  const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:updated"
    /* COMPONENT_UPDATED */
  );
  const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
    "component:removed"
    /* COMPONENT_REMOVED */
  );
  const devtoolsComponentRemoved = (component) => {
    if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
    !devtools$1.cleanupBuffer(component)) {
      _devtoolsComponentRemoved(component);
    }
  };
  function createDevtoolsComponentHook(hook) {
    return (component) => {
      emit$1(
        hook,
        component.appContext.app,
        component.uid,
        component.parent ? component.parent.uid : void 0,
        component
      );
    };
  }
  const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
    "perf:start"
    /* PERFORMANCE_START */
  );
  const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
    "perf:end"
    /* PERFORMANCE_END */
  );
  function createDevtoolsPerformanceHook(hook) {
    return (component, type4, time) => {
      emit$1(hook, component.appContext.app, component.uid, component, type4, time);
    };
  }
  function devtoolsComponentEmit(component, event, params) {
    emit$1(
      "component:emit",
      component.appContext.app,
      component,
      event,
      params
    );
  }
  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted)
      return;
    const props = instance.vnode.props || EMPTY_OBJ;
    {
      const {
        emitsOptions,
        propsOptions: [propsOptions]
      } = instance;
      if (emitsOptions) {
        if (!(event in emitsOptions) && true) {
          if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
            warn$1(
              `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`
            );
          }
        } else {
          const validator = emitsOptions[event];
          if (isFunction$2(validator)) {
            const isValid2 = validator(...rawArgs);
            if (!isValid2) {
              warn$1(
                `Invalid event arguments: event validation failed for event "${event}".`
              );
            }
          }
        }
      }
    }
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modelArg = isModelListener2 && event.slice(7);
    if (modelArg && modelArg in props) {
      const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
      const { number: number4, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
      if (trim2) {
        args = rawArgs.map((a2) => isString$1(a2) ? a2.trim() : a2);
      }
      if (number4) {
        args = rawArgs.map(looseToNumber);
      }
    }
    {
      devtoolsComponentEmit(instance, event, args);
    }
    {
      const lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
        warn$1(
          `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
          instance,
          instance.type
        )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate$1(
          event
        )}" instead of "${event}".`
        );
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
    props[handlerName = toHandlerKey(camelize$1(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate$1(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(
        handler,
        instance,
        6,
        args
      );
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(
        onceHandler,
        instance,
        6,
        args
      );
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached2 = cache.get(comp);
    if (cached2 !== void 0) {
      return cached2;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction$2(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$3(comp)) {
        cache.set(comp, null);
      }
      return null;
    }
    if (isArray$2(raw)) {
      raw.forEach((key2) => normalized[key2] = null);
    } else {
      extend(normalized, raw);
    }
    if (isObject$3(comp)) {
      cache.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key2) {
    if (!options || !isOn$1(key2)) {
      return false;
    }
    key2 = key2.slice(2).replace(/Once$/, "");
    return hasOwn$1(options, key2[0].toLowerCase() + key2.slice(1)) || hasOwn$1(options, hyphenate$1(key2)) || hasOwn$1(options, key2);
  }
  let currentRenderingInstance = null;
  let currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev2 = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev2;
  }
  function pushScopeId(id) {
    currentScopeId = id;
  }
  function popScopeId() {
    currentScopeId = null;
  }
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx)
      return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      {
        devtoolsComponentUpdated(ctx);
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  let accessedAttrs = false;
  function markAttrsAccessed() {
    accessedAttrs = true;
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      props,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit: emit2,
      render: render4,
      renderCache,
      data,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    let result;
    let fallthroughAttrs;
    const prev2 = setCurrentRenderingInstance(instance);
    {
      accessedAttrs = false;
    }
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        const thisProxy = setupState.__isScriptSetup ? new Proxy(proxyToUse, {
          get(target, key2, receiver) {
            warn$1(
              `Property '${String(
              key2
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
            );
            return Reflect.get(target, key2, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(
          render4.call(
            thisProxy,
            proxyToUse,
            renderCache,
            props,
            setupState,
            data,
            ctx
          )
        );
        fallthroughAttrs = attrs;
      } else {
        const render22 = Component;
        if (attrs === props) {
          markAttrsAccessed();
        }
        result = normalizeVNode(
          render22.length > 1 ? render22(
            props,
            true ? {
              get attrs() {
                markAttrsAccessed();
                return attrs;
              },
              slots,
              emit: emit2
            } : { attrs, slots, emit: emit2 }
          ) : render22(
            props,
            null
            /* we know it doesn't need it */
          )
        );
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root2 = result;
    let setRoot = void 0;
    if (result.patchFlag > 0 && result.patchFlag & 2048) {
      [root2, setRoot] = getChildRoot(result);
    }
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys2 = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root2;
      if (keys2.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys2.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(
              fallthroughAttrs,
              propsOptions
            );
          }
          root2 = cloneVNode(root2, fallthroughAttrs);
        } else if (!accessedAttrs && root2.type !== Comment) {
          const allAttrs = Object.keys(attrs);
          const eventAttrs = [];
          const extraAttrs = [];
          for (let i2 = 0, l2 = allAttrs.length; i2 < l2; i2++) {
            const key2 = allAttrs[i2];
            if (isOn$1(key2)) {
              if (!isModelListener(key2)) {
                eventAttrs.push(key2[2].toLowerCase() + key2.slice(3));
              }
            } else {
              extraAttrs.push(key2);
            }
          }
          if (extraAttrs.length) {
            warn$1(
              `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
            );
          }
          if (eventAttrs.length) {
            warn$1(
              `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
            );
          }
        }
      }
    }
    if (vnode.dirs) {
      if (!isElementRoot(root2)) {
        warn$1(
          `Runtime directive used on component with non-element root node. The directives will not function as intended.`
        );
      }
      root2 = cloneVNode(root2);
      root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      if (!isElementRoot(root2)) {
        warn$1(
          `Component inside <Transition> renders non-element root node that cannot be animated.`
        );
      }
      root2.transition = vnode.transition;
    }
    if (setRoot) {
      setRoot(root2);
    } else {
      result = root2;
    }
    setCurrentRenderingInstance(prev2);
    return result;
  }
  const getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren, false);
    if (!childRoot) {
      return [vnode, void 0];
    } else if (childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {
      return getChildRoot(childRoot);
    }
    const index2 = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
      rawChildren[index2] = updatedRoot;
      if (dynamicChildren) {
        if (dynamicIndex > -1) {
          dynamicChildren[dynamicIndex] = updatedRoot;
        } else if (updatedRoot.patchFlag > 0) {
          vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
        }
      }
    };
    return [normalizeVNode(childRoot), setRoot];
  };
  function filterSingleRoot(children, recurse = true) {
    let singleRoot;
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children[i2];
      if (isVNode(child)) {
        if (child.type !== Comment || child.children === "v-if") {
          if (singleRoot) {
            return;
          } else {
            singleRoot = child;
            if (recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {
              return filterSingleRoot(singleRoot.children);
            }
          }
        }
      } else {
        return;
      }
    }
    return singleRoot;
  }
  const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key2 in attrs) {
      if (key2 === "class" || key2 === "style" || isOn$1(key2)) {
        (res || (res = {}))[key2] = attrs[key2];
      }
    }
    return res;
  };
  const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key2 in attrs) {
      if (!isModelListener(key2) || !(key2.slice(9) in props)) {
        res[key2] = attrs[key2];
      }
    }
    return res;
  };
  const isElementRoot = (vnode) => {
    return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if ((prevChildren || nextChildren) && isHmrUpdating) {
      return true;
    }
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i2 = 0; i2 < dynamicProps.length; i2++) {
          const key2 = dynamicProps[i2];
          if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emits, key2)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i2 = 0; i2 < nextKeys.length; i2++) {
      const key2 = nextKeys[i2];
      if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emitsOptions, key2)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent: parent2 }, el) {
    while (parent2) {
      const root2 = parent2.subTree;
      if (root2.suspense && root2.suspense.activeBranch === vnode) {
        root2.el = vnode.el;
      }
      if (root2 === vnode) {
        (vnode = parent2.vnode).el = el;
        parent2 = parent2.parent;
      } else {
        break;
      }
    }
  }
  const COMPONENTS = "components";
  const DIRECTIVES = "directives";
  function resolveComponent(name2, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name2, true, maybeSelfReference) || name2;
  }
  const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function resolveDirective(name2) {
    return resolveAsset(DIRECTIVES, name2);
  }
  function resolveAsset(type4, name2, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component = instance.type;
      if (type4 === COMPONENTS) {
        const selfName = getComponentName(
          Component,
          false
        );
        if (selfName && (selfName === name2 || selfName === camelize$1(name2) || selfName === capitalize(camelize$1(name2)))) {
          return Component;
        }
      }
      const res = (
        // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type4] || Component[type4], name2) || // global registration
        resolve(instance.appContext[type4], name2)
      );
      if (!res && maybeSelfReference) {
        return Component;
      }
      if (warnMissing && !res) {
        const extra = type4 === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
        warn$1(`Failed to resolve ${type4.slice(0, -1)}: ${name2}${extra}`);
      }
      return res;
    } else {
      warn$1(
        `resolve${capitalize(type4.slice(0, -1))} can only be used in render() or setup().`
      );
    }
  }
  function resolve(registry, name2) {
    return registry && (registry[name2] || registry[camelize$1(name2)] || registry[capitalize(camelize$1(name2))]);
  }
  const isSuspense = (type4) => type4.__isSuspense;
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray$2(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  const ssrContextKey = Symbol.for("v-scx");
  const useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey);
      if (!ctx) {
        warn$1(
          `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
        );
      }
      return ctx;
    }
  };
  function watchEffect(effect2, options) {
    return doWatch(effect2, null, options);
  }
  function watchPostEffect(effect2, options) {
    return doWatch(
      effect2,
      null,
      extend({}, options, { flush: "post" })
    );
  }
  const INITIAL_WATCHER_VALUE = {};
  function watch(source, cb, options) {
    if (!isFunction$2(cb)) {
      warn$1(
        `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
      );
    }
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb, {
    immediate,
    deep,
    flush,
    once,
    onTrack,
    onTrigger
  } = EMPTY_OBJ) {
    if (cb && once) {
      const _cb = cb;
      cb = (...args) => {
        _cb(...args);
        unwatch();
      };
    }
    if (deep !== void 0 && typeof deep === "number") {
      warn$1(
        `watch() "deep" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.`
      );
    }
    if (!cb) {
      if (immediate !== void 0) {
        warn$1(
          `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
      if (deep !== void 0) {
        warn$1(
          `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
      if (once !== void 0) {
        warn$1(
          `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
        );
      }
    }
    const warnInvalidSource = (s2) => {
      warn$1(
        `Invalid watch source: `,
        s2,
        `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
      );
    };
    const instance = currentInstance;
    const reactiveGetter = (source2) => deep === true ? source2 : (
      // for deep: false, only traverse root-level properties
      traverse(source2, deep === false ? 1 : void 0)
    );
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => reactiveGetter(source);
      forceTrigger = true;
    } else if (isArray$2(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
      getter = () => source.map((s2) => {
        if (isRef(s2)) {
          return s2.value;
        } else if (isReactive(s2)) {
          return reactiveGetter(s2);
        } else if (isFunction$2(s2)) {
          return callWithErrorHandling(s2, instance, 2);
        } else {
          warnInvalidSource(s2);
        }
      });
    } else if (isFunction$2(source)) {
      if (cb) {
        getter = () => callWithErrorHandling(source, instance, 2);
      } else {
        getter = () => {
          if (cleanup2) {
            cleanup2();
          }
          return callWithAsyncErrorHandling(
            source,
            instance,
            3,
            [onCleanup]
          );
        };
      }
    } else {
      getter = NOOP;
      warnInvalidSource(source);
    }
    if (cb && deep) {
      const baseGetter = getter;
      getter = () => traverse(baseGetter());
    }
    let cleanup2;
    let onCleanup = (fn) => {
      cleanup2 = effect2.onStop = () => {
        callWithErrorHandling(fn, instance, 4);
        cleanup2 = effect2.onStop = void 0;
      };
    };
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      onCleanup = NOOP;
      if (!cb) {
        getter();
      } else if (immediate) {
        callWithAsyncErrorHandling(cb, instance, 3, [
          getter(),
          isMultiSource ? [] : void 0,
          onCleanup
        ]);
      }
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else {
        return NOOP;
      }
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = () => {
      if (!effect2.active || !effect2.dirty) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
          if (cleanup2) {
            cleanup2();
          }
          callWithAsyncErrorHandling(cb, instance, 3, [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            onCleanup
          ]);
          oldValue = newValue;
        }
      } else {
        effect2.run();
      }
    };
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === "sync") {
      scheduler = job;
    } else if (flush === "post") {
      scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    } else {
      job.pre = true;
      if (instance)
        job.id = instance.uid;
      scheduler = () => queueJob(job);
    }
    const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
    const scope = getCurrentScope();
    const unwatch = () => {
      effect2.stop();
      if (scope) {
        remove(scope.effects, effect2);
      }
    };
    {
      effect2.onTrack = onTrack;
      effect2.onTrigger = onTrigger;
    }
    if (cb) {
      if (immediate) {
        job();
      } else {
        oldValue = effect2.run();
      }
    } else if (flush === "post") {
      queuePostRenderEffect(
        effect2.run.bind(effect2),
        instance && instance.suspense
      );
    } else {
      effect2.run();
    }
    if (ssrCleanup)
      ssrCleanup.push(unwatch);
    return unwatch;
  }
  function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction$2(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const reset = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    reset();
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i2 = 0; i2 < segments.length && cur; i2++) {
        cur = cur[segments[i2]];
      }
      return cur;
    };
  }
  function traverse(value, depth, currentDepth = 0, seen) {
    if (!isObject$3(value) || value["__v_skip"]) {
      return value;
    }
    if (depth && depth > 0) {
      if (currentDepth >= depth) {
        return value;
      }
      currentDepth++;
    }
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    if (isRef(value)) {
      traverse(value.value, depth, currentDepth, seen);
    } else if (isArray$2(value)) {
      for (let i2 = 0; i2 < value.length; i2++) {
        traverse(value[i2], depth, currentDepth, seen);
      }
    } else if (isSet$1(value) || isMap$1(value)) {
      value.forEach((v2) => {
        traverse(v2, depth, currentDepth, seen);
      });
    } else if (isPlainObject$2(value)) {
      for (const key2 in value) {
        traverse(value[key2], depth, currentDepth, seen);
      }
    }
    return value;
  }
  function validateDirectiveName(name2) {
    if (isBuiltInDirective(name2)) {
      warn$1("Do not use built-in directive ids as custom directive id: " + name2);
    }
  }
  function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
      warn$1(`withDirectives can only be used inside render functions.`);
      return vnode;
    }
    const instance = getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i2 = 0; i2 < directives.length; i2++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
      if (dir) {
        if (isFunction$2(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name2) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i2 = 0; i2 < bindings.length; i2++) {
      const binding = bindings[i2];
      if (oldBindings) {
        binding.oldValue = oldBindings[i2].value;
      }
      let hook = binding.dir[name2];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  const leaveCbKey = Symbol("_leaveCb");
  const enterCbKey$1 = Symbol("_enterCb");
  function useTransitionState() {
    const state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(() => {
      state.isMounted = true;
    });
    onBeforeUnmount(() => {
      state.isUnmounting = true;
    });
    return state;
  }
  const TransitionHookValidator = [Function, Array];
  const BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  };
  const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      return () => {
        const children = slots.default && getTransitionRawChildren(slots.default(), true);
        if (!children || !children.length) {
          return;
        }
        let child = children[0];
        if (children.length > 1) {
          let hasFound = false;
          for (const c2 of children) {
            if (c2.type !== Comment) {
              if (hasFound) {
                warn$1(
                  "<transition> can only be used on a single element or component. Use <transition-group> for lists."
                );
                break;
              }
              child = c2;
              hasFound = true;
            }
          }
        }
        const rawProps = toRaw(props);
        const { mode } = rawProps;
        if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
          warn$1(`invalid <transition> mode: ${mode}`);
        }
        if (state.isLeaving) {
          return emptyPlaceholder(child);
        }
        const innerChild = getKeepAliveChild(child);
        if (!innerChild) {
          return emptyPlaceholder(child);
        }
        const enterHooks = resolveTransitionHooks(
          innerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(innerChild, enterHooks);
        const oldChild = instance.subTree;
        const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
        if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild)) {
          const leavingHooks = resolveTransitionHooks(
            oldInnerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(oldInnerChild, leavingHooks);
          if (mode === "out-in") {
            state.isLeaving = true;
            leavingHooks.afterLeave = () => {
              state.isLeaving = false;
              if (instance.update.active !== false) {
                instance.effect.dirty = true;
                instance.update();
              }
            };
            return emptyPlaceholder(child);
          } else if (mode === "in-out" && innerChild.type !== Comment) {
            leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
              const leavingVNodesCache = getLeavingNodesForType(
                state,
                oldInnerChild
              );
              leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
              el[leaveCbKey] = () => {
                earlyRemove();
                el[leaveCbKey] = void 0;
                delete enterHooks.delayedLeave;
              };
              enterHooks.delayedLeave = delayedLeave;
            };
          }
        }
        return child;
      };
    }
  };
  const BaseTransition = BaseTransitionImpl;
  function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = /* @__PURE__ */ Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props, state, instance) {
    const {
      appear,
      mode,
      persisted = false,
      onBeforeEnter,
      onEnter,
      onAfterEnter,
      onEnterCancelled,
      onBeforeLeave,
      onLeave,
      onAfterLeave,
      onLeaveCancelled,
      onBeforeAppear,
      onAppear,
      onAfterAppear,
      onAppearCancelled
    } = props;
    const key2 = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook2 = (hook, args) => {
      hook && callWithAsyncErrorHandling(
        hook,
        instance,
        9,
        args
      );
    };
    const callAsyncHook = (hook, args) => {
      const done = args[1];
      callHook2(hook, args);
      if (isArray$2(hook)) {
        if (hook.every((hook2) => hook2.length <= 1))
          done();
      } else if (hook.length <= 1) {
        done();
      }
    };
    const hooks = {
      mode,
      persisted,
      beforeEnter(el) {
        let hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el[leaveCbKey]) {
          el[leaveCbKey](
            true
            /* cancelled */
          );
        }
        const leavingVNode = leavingVNodesCache[key2];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
          leavingVNode.el[leaveCbKey]();
        }
        callHook2(hook, [el]);
      },
      enter(el) {
        let hook = onEnter;
        let afterHook = onAfterEnter;
        let cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        let called = false;
        const done = el[enterCbKey$1] = (cancelled) => {
          if (called)
            return;
          called = true;
          if (cancelled) {
            callHook2(cancelHook, [el]);
          } else {
            callHook2(afterHook, [el]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el[enterCbKey$1] = void 0;
        };
        if (hook) {
          callAsyncHook(hook, [el, done]);
        } else {
          done();
        }
      },
      leave(el, remove2) {
        const key22 = String(vnode.key);
        if (el[enterCbKey$1]) {
          el[enterCbKey$1](
            true
            /* cancelled */
          );
        }
        if (state.isUnmounting) {
          return remove2();
        }
        callHook2(onBeforeLeave, [el]);
        let called = false;
        const done = el[leaveCbKey] = (cancelled) => {
          if (called)
            return;
          called = true;
          remove2();
          if (cancelled) {
            callHook2(onLeaveCancelled, [el]);
          } else {
            callHook2(onAfterLeave, [el]);
          }
          el[leaveCbKey] = void 0;
          if (leavingVNodesCache[key22] === vnode) {
            delete leavingVNodesCache[key22];
          }
        };
        leavingVNodesCache[key22] = vnode;
        if (onLeave) {
          callAsyncHook(onLeave, [el, done]);
        } else {
          done();
        }
      },
      clone(vnode2) {
        return resolveTransitionHooks(vnode2, props, state, instance);
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode) ? (
      // #7121 ensure get the child component subtree in case
      // it's been replaced during HMR
      vnode.component ? vnode.component.subTree : vnode.children ? vnode.children[0] : void 0
    ) : vnode;
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i2 = 0; i2 < children.length; i2++) {
      let child = children[i2];
      const key2 = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
      if (child.type === Fragment) {
        if (child.patchFlag & 128)
          keyedFragmentCount++;
        ret = ret.concat(
          getTransitionRawChildren(child.children, keepComment, key2)
        );
      } else if (keepComment || child.type !== Comment) {
        ret.push(key2 != null ? cloneVNode(child, { key: key2 }) : child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (let i2 = 0; i2 < ret.length; i2++) {
        ret[i2].patchFlag = -2;
      }
    }
    return ret;
  }
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function defineComponent(options, extraOptions) {
    return isFunction$2(options) ? (
      // #8326: extend call and options.name access are considered side-effects
      // by Rollup, so we have to wrap it in a pure-annotated IIFE.
      /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
    ) : options;
  }
  const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type4, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type4, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type4, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type4, target, keepAliveRoot) {
    const injected = injectHook(
      type4,
      hook,
      keepAliveRoot,
      true
      /* prepend */
    );
    onUnmounted(() => {
      remove(keepAliveRoot[type4], injected);
    }, target);
  }
  function injectHook(type4, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type4] || (target[type4] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        if (target.isUnmounted) {
          return;
        }
        pauseTracking();
        const reset = setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type4, args);
        reset();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    } else {
      const apiName = toHandlerKey(ErrorTypeStrings$1[type4].replace(/ hook$/, ""));
      warn$1(
        `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
      );
    }
  }
  const createHook = (lifecycle) => (hook, target = currentInstance) => (
    // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
    (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
  );
  const onBeforeMount = createHook("bm");
  const onMounted = createHook("m");
  const onBeforeUpdate = createHook("bu");
  const onUpdated = createHook("u");
  const onBeforeUnmount = createHook("bum");
  const onUnmounted = createHook("um");
  const onServerPrefetch = createHook("sp");
  const onRenderTriggered = createHook(
    "rtg"
  );
  const onRenderTracked = createHook(
    "rtc"
  );
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  function renderList(source, renderItem, cache, index2) {
    let ret;
    const cached2 = cache && cache[index2];
    if (isArray$2(source) || isString$1(source)) {
      ret = new Array(source.length);
      for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
        ret[i2] = renderItem(source[i2], i2, void 0, cached2 && cached2[i2]);
      }
    } else if (typeof source === "number") {
      if (!Number.isInteger(source)) {
        warn$1(`The v-for range expect an integer value but got ${source}.`);
      }
      ret = new Array(source);
      for (let i2 = 0; i2 < source; i2++) {
        ret[i2] = renderItem(i2 + 1, i2, void 0, cached2 && cached2[i2]);
      }
    } else if (isObject$3(source)) {
      if (source[Symbol.iterator]) {
        ret = Array.from(
          source,
          (item, i2) => renderItem(item, i2, void 0, cached2 && cached2[i2])
        );
      } else {
        const keys2 = Object.keys(source);
        ret = new Array(keys2.length);
        for (let i2 = 0, l2 = keys2.length; i2 < l2; i2++) {
          const key2 = keys2[i2];
          ret[i2] = renderItem(source[key2], key2, i2, cached2 && cached2[i2]);
        }
      }
    } else {
      ret = [];
    }
    if (cache) {
      cache[index2] = ret;
    }
    return ret;
  }
  function renderSlot(slots, name2, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
      if (name2 !== "default")
        props.name = name2;
      return createVNode("slot", props, fallback && fallback());
    }
    let slot = slots[name2];
    if (slot && slot.length > 1) {
      warn$1(
        `SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`
      );
      slot = () => [];
    }
    if (slot && slot._c) {
      slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(
      Fragment,
      {
        key: props.key || // slot content array of a dynamic conditional slot may have a branch
        // key attached in the `createSlots` helper, respect that
        validSlotContent && validSlotContent.key || `_${name2}`
      },
      validSlotContent || (fallback ? fallback() : []),
      validSlotContent && slots._ === 1 ? 64 : -2
    );
    if (!noSlotted && rendered.scopeId) {
      rendered.slotScopeIds = [rendered.scopeId + "-s"];
    }
    if (slot && slot._c) {
      slot._d = true;
    }
    return rendered;
  }
  function ensureValidVNode(vnodes) {
    return vnodes.some((child) => {
      if (!isVNode(child))
        return true;
      if (child.type === Comment)
        return false;
      if (child.type === Fragment && !ensureValidVNode(child.children))
        return false;
      return true;
    }) ? vnodes : null;
  }
  const getPublicInstance = (i2) => {
    if (!i2)
      return null;
    if (isStatefulComponent(i2))
      return getExposeProxy(i2) || i2.proxy;
    return getPublicInstance(i2.parent);
  };
  const publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
      $: (i2) => i2,
      $el: (i2) => i2.vnode.el,
      $data: (i2) => i2.data,
      $props: (i2) => shallowReadonly(i2.props),
      $attrs: (i2) => shallowReadonly(i2.attrs),
      $slots: (i2) => shallowReadonly(i2.slots),
      $refs: (i2) => shallowReadonly(i2.refs),
      $parent: (i2) => getPublicInstance(i2.parent),
      $root: (i2) => getPublicInstance(i2.root),
      $emit: (i2) => i2.emit,
      $options: (i2) => resolveMergedOptions(i2),
      $forceUpdate: (i2) => i2.f || (i2.f = () => {
        i2.effect.dirty = true;
        queueJob(i2.update);
      }),
      $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
      $watch: (i2) => instanceWatch.bind(i2)
    })
  );
  const isReservedPrefix = (key2) => key2 === "_" || key2 === "$";
  const hasSetupBinding = (state, key2) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key2);
  const PublicInstanceProxyHandlers = {
    get({ _: instance }, key2) {
      const { ctx, setupState, data, props, accessCache, type: type4, appContext } = instance;
      if (key2 === "__isVue") {
        return true;
      }
      let normalizedProps;
      if (key2[0] !== "$") {
        const n2 = accessCache[key2];
        if (n2 !== void 0) {
          switch (n2) {
            case 1:
              return setupState[key2];
            case 2:
              return data[key2];
            case 4:
              return ctx[key2];
            case 3:
              return props[key2];
          }
        } else if (hasSetupBinding(setupState, key2)) {
          accessCache[key2] = 1;
          return setupState[key2];
        } else if (data !== EMPTY_OBJ && hasOwn$1(data, key2)) {
          accessCache[key2] = 2;
          return data[key2];
        } else if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key2)
        ) {
          accessCache[key2] = 3;
          return props[key2];
        } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key2)) {
          accessCache[key2] = 4;
          return ctx[key2];
        } else if (shouldCacheAccess) {
          accessCache[key2] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key2];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key2 === "$attrs") {
          track(instance, "get", key2);
          markAttrsAccessed();
        } else if (key2 === "$slots") {
          track(instance, "get", key2);
        }
        return publicGetter(instance);
      } else if (
        // css module (injected by vue-loader)
        (cssModule = type4.__cssModules) && (cssModule = cssModule[key2])
      ) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key2)) {
        accessCache[key2] = 4;
        return ctx[key2];
      } else if (
        // global properties
        globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key2)
      ) {
        {
          return globalProperties[key2];
        }
      } else if (currentRenderingInstance && (!isString$1(key2) || // #1091 avoid internal isRef/isVNode checks on component instance leading
      // to infinite warning loop
      key2.indexOf("__v") !== 0)) {
        if (data !== EMPTY_OBJ && isReservedPrefix(key2[0]) && hasOwn$1(data, key2)) {
          warn$1(
            `Property ${JSON.stringify(
            key2
          )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
          );
        } else if (instance === currentRenderingInstance) {
          warn$1(
            `Property ${JSON.stringify(key2)} was accessed during render but is not defined on instance.`
          );
        }
      }
    },
    set({ _: instance }, key2, value) {
      const { data, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key2)) {
        setupState[key2] = value;
        return true;
      } else if (setupState.__isScriptSetup && hasOwn$1(setupState, key2)) {
        warn$1(`Cannot mutate <script setup> binding "${key2}" from Options API.`);
        return false;
      } else if (data !== EMPTY_OBJ && hasOwn$1(data, key2)) {
        data[key2] = value;
        return true;
      } else if (hasOwn$1(instance.props, key2)) {
        warn$1(`Attempting to mutate prop "${key2}". Props are readonly.`);
        return false;
      }
      if (key2[0] === "$" && key2.slice(1) in instance) {
        warn$1(
          `Attempting to mutate public property "${key2}". Properties starting with $ are reserved and readonly.`
        );
        return false;
      } else {
        if (key2 in instance.appContext.config.globalProperties) {
          Object.defineProperty(ctx, key2, {
            enumerable: true,
            configurable: true,
            value
          });
        } else {
          ctx[key2] = value;
        }
      }
      return true;
    },
    has({
      _: { data, setupState, accessCache, ctx, appContext, propsOptions }
    }, key2) {
      let normalizedProps;
      return !!accessCache[key2] || data !== EMPTY_OBJ && hasOwn$1(data, key2) || hasSetupBinding(setupState, key2) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key2) || hasOwn$1(ctx, key2) || hasOwn$1(publicPropertiesMap, key2) || hasOwn$1(appContext.config.globalProperties, key2);
    },
    defineProperty(target, key2, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key2] = 0;
      } else if (hasOwn$1(descriptor, "value")) {
        this.set(target, key2, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key2, descriptor);
    }
  };
  {
    PublicInstanceProxyHandlers.ownKeys = (target) => {
      warn$1(
        `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
      );
      return Reflect.ownKeys(target);
    };
  }
  function createDevRenderContext(instance) {
    const target = {};
    Object.defineProperty(target, `_`, {
      configurable: true,
      enumerable: false,
      get: () => instance
    });
    Object.keys(publicPropertiesMap).forEach((key2) => {
      Object.defineProperty(target, key2, {
        configurable: true,
        enumerable: false,
        get: () => publicPropertiesMap[key2](instance),
        // intercepted by the proxy so no need for implementation,
        // but needed to prevent set errors
        set: NOOP
      });
    });
    return target;
  }
  function exposePropsOnRenderContext(instance) {
    const {
      ctx,
      propsOptions: [propsOptions]
    } = instance;
    if (propsOptions) {
      Object.keys(propsOptions).forEach((key2) => {
        Object.defineProperty(ctx, key2, {
          enumerable: true,
          configurable: true,
          get: () => instance.props[key2],
          set: NOOP
        });
      });
    }
  }
  function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys(toRaw(setupState)).forEach((key2) => {
      if (!setupState.__isScriptSetup) {
        if (isReservedPrefix(key2[0])) {
          warn$1(
            `setup() return property ${JSON.stringify(
            key2
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
          );
          return;
        }
        Object.defineProperty(ctx, key2, {
          enumerable: true,
          configurable: true,
          get: () => setupState[key2],
          set: NOOP
        });
      }
    });
  }
  function normalizePropsOrEmits(props) {
    return isArray$2(props) ? props.reduce(
      (normalized, p) => (normalized[p] = null, normalized),
      {}
    ) : props;
  }
  function createDuplicateChecker() {
    const cache = /* @__PURE__ */ Object.create(null);
    return (type4, key2) => {
      if (cache[key2]) {
        warn$1(`${type4} property "${key2}" is already defined in ${cache[key2]}.`);
      } else {
        cache[key2] = type4;
      }
    };
  }
  let shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook$1(options.beforeCreate, instance, "bc");
    }
    const {
      // state
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      // lifecycle
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render: render4,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      // public API
      expose,
      inheritAttrs,
      // assets
      components: components2,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = createDuplicateChecker();
    {
      const [propsOptions] = instance.propsOptions;
      if (propsOptions) {
        for (const key2 in propsOptions) {
          checkDuplicateProperties("Props", key2);
        }
      }
    }
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key2 in methods) {
        const methodHandler = methods[key2];
        if (isFunction$2(methodHandler)) {
          {
            Object.defineProperty(ctx, key2, {
              value: methodHandler.bind(publicThis),
              configurable: true,
              enumerable: true,
              writable: true
            });
          }
          {
            checkDuplicateProperties("Methods", key2);
          }
        } else {
          warn$1(
            `Method "${key2}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
          );
        }
      }
    }
    if (dataOptions) {
      if (!isFunction$2(dataOptions)) {
        warn$1(
          `The data option must be a function. Plain object usage is no longer supported.`
        );
      }
      const data = dataOptions.call(publicThis, publicThis);
      if (isPromise(data)) {
        warn$1(
          `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
        );
      }
      if (!isObject$3(data)) {
        warn$1(`data() should return an object.`);
      } else {
        instance.data = reactive(data);
        {
          for (const key2 in data) {
            checkDuplicateProperties("Data", key2);
            if (!isReservedPrefix(key2[0])) {
              Object.defineProperty(ctx, key2, {
                configurable: true,
                enumerable: true,
                get: () => data[key2],
                set: NOOP
              });
            }
          }
        }
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key2 in computedOptions) {
        const opt = computedOptions[key2];
        const get2 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        if (get2 === NOOP) {
          warn$1(`Computed property "${key2}" has no getter.`);
        }
        const set2 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : () => {
          warn$1(
            `Write operation failed: computed property "${key2}" is readonly.`
          );
        };
        const c2 = computed({
          get: get2,
          set: set2
        });
        Object.defineProperty(ctx, key2, {
          enumerable: true,
          configurable: true,
          get: () => c2.value,
          set: (v2) => c2.value = v2
        });
        {
          checkDuplicateProperties("Computed", key2);
        }
      }
    }
    if (watchOptions) {
      for (const key2 in watchOptions) {
        createWatcher(watchOptions[key2], ctx, publicThis, key2);
      }
    }
    if (provideOptions) {
      const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key2) => {
        provide(key2, provides[key2]);
      });
    }
    if (created) {
      callHook$1(created, instance, "c");
    }
    function registerLifecycleHook(register2, hook) {
      if (isArray$2(hook)) {
        hook.forEach((_hook) => register2(_hook.bind(publicThis)));
      } else if (hook) {
        register2(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray$2(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key2) => {
          Object.defineProperty(exposed, key2, {
            get: () => publicThis[key2],
            set: (val) => publicThis[key2] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render4 && instance.render === NOOP) {
      instance.render = render4;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components2)
      instance.components = components2;
    if (directives)
      instance.directives = directives;
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray$2(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key2 in injectOptions) {
      const opt = injectOptions[key2];
      let injected;
      if (isObject$3(opt)) {
        if ("default" in opt) {
          injected = inject(
            opt.from || key2,
            opt.default,
            true
          );
        } else {
          injected = inject(opt.from || key2);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        Object.defineProperty(ctx, key2, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v2) => injected.value = v2
        });
      } else {
        ctx[key2] = injected;
      }
      {
        checkDuplicateProperties("Inject", key2);
      }
    }
  }
  function callHook$1(hook, instance, type4) {
    callWithAsyncErrorHandling(
      isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
      instance,
      type4
    );
  }
  function createWatcher(raw, ctx, publicThis, key2) {
    const getter = key2.includes(".") ? createPathGetter(publicThis, key2) : () => publicThis[key2];
    if (isString$1(raw)) {
      const handler = ctx[raw];
      if (isFunction$2(handler)) {
        watch(getter, handler);
      } else {
        warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
      }
    } else if (isFunction$2(raw)) {
      watch(getter, raw.bind(publicThis));
    } else if (isObject$3(raw)) {
      if (isArray$2(raw)) {
        raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key2));
      } else {
        const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction$2(handler)) {
          watch(getter, handler, raw);
        } else {
          warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
      }
    } else {
      warn$1(`Invalid watch option: "${key2}"`, raw);
    }
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const {
      mixins: globalMixins,
      optionsCache: cache,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached2 = cache.get(base);
    let resolved;
    if (cached2) {
      resolved = cached2;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
        );
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    if (isObject$3(base)) {
      cache.set(base, resolved);
    }
    return resolved;
  }
  function mergeOptions(to, from2, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from2;
    if (extendsOptions) {
      mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        (m2) => mergeOptions(to, m2, strats, true)
      );
    }
    for (const key2 in from2) {
      if (asMixin && key2 === "expose") {
        warn$1(
          `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
        );
      } else {
        const strat = internalOptionMergeStrats[key2] || strats && strats[key2];
        to[key2] = strat ? strat(to[key2], from2[key2]) : from2[key2];
      }
    }
    return to;
  }
  const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from2) {
    if (!from2) {
      return to;
    }
    if (!to) {
      return from2;
    }
    return function mergedDataFn() {
      return extend(
        isFunction$2(to) ? to.call(this, this) : to,
        isFunction$2(from2) ? from2.call(this, this) : from2
      );
    };
  }
  function mergeInject(to, from2) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from2));
  }
  function normalizeInject(raw) {
    if (isArray$2(raw)) {
      const res = {};
      for (let i2 = 0; i2 < raw.length; i2++) {
        res[raw[i2]] = raw[i2];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from2) {
    return to ? [...new Set([].concat(to, from2))] : from2;
  }
  function mergeObjectOptions(to, from2) {
    return to ? extend(/* @__PURE__ */ Object.create(null), to, from2) : from2;
  }
  function mergeEmitsOrPropsOptions(to, from2) {
    if (to) {
      if (isArray$2(to) && isArray$2(from2)) {
        return [.../* @__PURE__ */ new Set([...to, ...from2])];
      }
      return extend(
        /* @__PURE__ */ Object.create(null),
        normalizePropsOrEmits(to),
        normalizePropsOrEmits(from2 != null ? from2 : {})
      );
    } else {
      return from2;
    }
  }
  function mergeWatchOptions(to, from2) {
    if (!to)
      return from2;
    if (!from2)
      return to;
    const merged = extend(/* @__PURE__ */ Object.create(null), to);
    for (const key2 in from2) {
      merged[key2] = mergeAsArray(to[key2], from2[key2]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let uid$1 = 0;
  function createAppAPI(render4, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction$2(rootComponent)) {
        rootComponent = extend({}, rootComponent);
      }
      if (rootProps != null && !isObject$3(rootProps)) {
        warn$1(`root props passed to app.mount() must be an object.`);
        rootProps = null;
      }
      const context3 = createAppContext();
      const installedPlugins = /* @__PURE__ */ new WeakSet();
      let isMounted = false;
      const app2 = context3.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context3,
        _instance: null,
        version: version$1,
        get config() {
          return context3.config;
        },
        set config(v2) {
          {
            warn$1(
              `app.config cannot be replaced. Modify individual options instead.`
            );
          }
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin)) {
            warn$1(`Plugin has already been applied to target app.`);
          } else if (plugin && isFunction$2(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app2, ...options);
          } else if (isFunction$2(plugin)) {
            installedPlugins.add(plugin);
            plugin(app2, ...options);
          } else {
            warn$1(
              `A plugin must either be a function or an object with an "install" function.`
            );
          }
          return app2;
        },
        mixin(mixin) {
          {
            if (!context3.mixins.includes(mixin)) {
              context3.mixins.push(mixin);
            } else {
              warn$1(
                "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
              );
            }
          }
          return app2;
        },
        component(name2, component) {
          {
            validateComponentName(name2, context3.config);
          }
          if (!component) {
            return context3.components[name2];
          }
          if (context3.components[name2]) {
            warn$1(`Component "${name2}" has already been registered in target app.`);
          }
          context3.components[name2] = component;
          return app2;
        },
        directive(name2, directive) {
          {
            validateDirectiveName(name2);
          }
          if (!directive) {
            return context3.directives[name2];
          }
          if (context3.directives[name2]) {
            warn$1(`Directive "${name2}" has already been registered in target app.`);
          }
          context3.directives[name2] = directive;
          return app2;
        },
        mount(rootContainer, isHydrate, namespace) {
          if (!isMounted) {
            if (rootContainer.__vue_app__) {
              warn$1(
                `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
              );
            }
            const vnode = createVNode(rootComponent, rootProps);
            vnode.appContext = context3;
            if (namespace === true) {
              namespace = "svg";
            } else if (namespace === false) {
              namespace = void 0;
            }
            {
              context3.reload = () => {
                render4(
                  cloneVNode(vnode),
                  rootContainer,
                  namespace
                );
              };
            }
            if (isHydrate && hydrate) {
              hydrate(vnode, rootContainer);
            } else {
              render4(vnode, rootContainer, namespace);
            }
            isMounted = true;
            app2._container = rootContainer;
            rootContainer.__vue_app__ = app2;
            {
              app2._instance = vnode.component;
              devtoolsInitApp(app2, version$1);
            }
            return getExposeProxy(vnode.component) || vnode.component.proxy;
          } else {
            warn$1(
              `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
            );
          }
        },
        unmount() {
          if (isMounted) {
            render4(null, app2._container);
            {
              app2._instance = null;
              devtoolsUnmountApp(app2);
            }
            delete app2._container.__vue_app__;
          } else {
            warn$1(`Cannot unmount an app that is not mounted.`);
          }
        },
        provide(key2, value) {
          if (key2 in context3.provides) {
            warn$1(
              `App already provides property with key "${String(key2)}". It will be overwritten with the new value.`
            );
          }
          context3.provides[key2] = value;
          return app2;
        },
        runWithContext(fn) {
          const lastApp = currentApp;
          currentApp = app2;
          try {
            return fn();
          } finally {
            currentApp = lastApp;
          }
        }
      };
      return app2;
    };
  }
  let currentApp = null;
  function provide(key2, value) {
    if (!currentInstance) {
      {
        warn$1(`provide() can only be used inside setup().`);
      }
    } else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key2] = value;
    }
  }
  function inject(key2, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
      if (provides && key2 in provides) {
        return provides[key2];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else {
        warn$1(`injection "${String(key2)}" not found.`);
      }
    } else {
      warn$1(`inject() can only be used inside setup() or functional components.`);
    }
  }
  function hasInjectionContext() {
    return !!(currentInstance || currentRenderingInstance || currentApp);
  }
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = {};
    def(attrs, InternalObjectKey, 1);
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key2 in instance.propsOptions[0]) {
      if (!(key2 in props)) {
        props[key2] = void 0;
      }
    }
    {
      validateProps(rawProps || {}, props, instance);
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function isInHmrContext(instance) {
    while (instance) {
      if (instance.type.__hmrId)
        return true;
      instance = instance.parent;
    }
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
      // always force full diff in dev
      // - #1942 if hmr is enabled with sfc component
      // - vite#872 non-sfc component used by sfc component
      !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)
    ) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
          let key2 = propsToUpdate[i2];
          if (isEmitListener(instance.emitsOptions, key2)) {
            continue;
          }
          const value = rawProps[key2];
          if (options) {
            if (hasOwn$1(attrs, key2)) {
              if (value !== attrs[key2]) {
                attrs[key2] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize$1(key2);
              props[camelizedKey] = resolvePropValue$1(
                options,
                rawCurrentProps,
                camelizedKey,
                value,
                instance,
                false
              );
            }
          } else {
            if (value !== attrs[key2]) {
              attrs[key2] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key2 in rawCurrentProps) {
        if (!rawProps || // for camelCase
        !hasOwn$1(rawProps, key2) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = hyphenate$1(key2)) === key2 || !hasOwn$1(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && // for camelCase
            (rawPrevProps[key2] !== void 0 || // for kebab-case
            rawPrevProps[kebabKey] !== void 0)) {
              props[key2] = resolvePropValue$1(
                options,
                rawCurrentProps,
                key2,
                void 0,
                instance,
                true
              );
            }
          } else {
            delete props[key2];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key2 in attrs) {
          if (!rawProps || !hasOwn$1(rawProps, key2) && true) {
            delete attrs[key2];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger$1(instance, "set", "$attrs");
    }
    {
      validateProps(rawProps || {}, props, instance);
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key2 in rawProps) {
        if (isReservedProp(key2)) {
          continue;
        }
        const value = rawProps[key2];
        let camelKey;
        if (options && hasOwn$1(options, camelKey = camelize$1(key2))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key2)) {
          if (!(key2 in attrs) || value !== attrs[key2]) {
            attrs[key2] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i2 = 0; i2 < needCastKeys.length; i2++) {
        const key2 = needCastKeys[i2];
        props[key2] = resolvePropValue$1(
          options,
          rawCurrentProps,
          key2,
          castValues[key2],
          instance,
          !hasOwn$1(castValues, key2)
        );
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue$1(options, props, key2, value, instance, isAbsent) {
    const opt = options[key2];
    if (opt != null) {
      const hasDefault = hasOwn$1(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
          const { propsDefaults } = instance;
          if (key2 in propsDefaults) {
            value = propsDefaults[key2];
          } else {
            const reset = setCurrentInstance(instance);
            value = propsDefaults[key2] = defaultValue.call(
              null,
              props
            );
            reset();
          }
        } else {
          value = defaultValue;
        }
      }
      if (opt[
        0
        /* shouldCast */
      ]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[
          1
          /* shouldCastTrue */
        ] && (value === "" || value === hyphenate$1(key2))) {
          value = true;
        }
      }
    }
    return value;
  }
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.propsCache;
    const cached2 = cache.get(comp);
    if (cached2) {
      return cached2;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction$2(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
        extend(normalized, props);
        if (keys2)
          needCastKeys.push(...keys2);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$3(comp)) {
        cache.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray$2(raw)) {
      for (let i2 = 0; i2 < raw.length; i2++) {
        if (!isString$1(raw[i2])) {
          warn$1(`props must be strings when using array syntax.`, raw[i2]);
        }
        const normalizedKey = camelize$1(raw[i2]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      if (!isObject$3(raw)) {
        warn$1(`invalid props options`, raw);
      }
      for (const key2 in raw) {
        const normalizedKey = camelize$1(key2);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key2];
          const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$2(opt) ? { type: opt } : extend({}, opt);
          if (prop) {
            const booleanIndex = getTypeIndex(Boolean, prop.type);
            const stringIndex = getTypeIndex(String, prop.type);
            prop[
              0
              /* shouldCast */
            ] = booleanIndex > -1;
            prop[
              1
              /* shouldCastTrue */
            ] = stringIndex < 0 || booleanIndex < stringIndex;
            if (booleanIndex > -1 || hasOwn$1(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject$3(comp)) {
      cache.set(comp, res);
    }
    return res;
  }
  function validatePropName(key2) {
    if (key2[0] !== "$" && !isReservedProp(key2)) {
      return true;
    } else {
      warn$1(`Invalid prop name: "${key2}" is a reserved property.`);
    }
    return false;
  }
  function getType(ctor) {
    if (ctor === null) {
      return "null";
    }
    if (typeof ctor === "function") {
      return ctor.name || "";
    } else if (typeof ctor === "object") {
      const name2 = ctor.constructor && ctor.constructor.name;
      return name2 || "";
    }
    return "";
  }
  function isSameType(a2, b2) {
    return getType(a2) === getType(b2);
  }
  function getTypeIndex(type4, expectedTypes) {
    if (isArray$2(expectedTypes)) {
      return expectedTypes.findIndex((t2) => isSameType(t2, type4));
    } else if (isFunction$2(expectedTypes)) {
      return isSameType(expectedTypes, type4) ? 0 : -1;
    }
    return -1;
  }
  function validateProps(rawProps, props, instance) {
    const resolvedValues = toRaw(props);
    const options = instance.propsOptions[0];
    for (const key2 in options) {
      let opt = options[key2];
      if (opt == null)
        continue;
      validateProp(
        key2,
        resolvedValues[key2],
        opt,
        shallowReadonly(resolvedValues),
        !hasOwn$1(rawProps, key2) && !hasOwn$1(rawProps, hyphenate$1(key2))
      );
    }
  }
  function validateProp(name2, value, prop, props, isAbsent) {
    const { type: type4, required: required4, validator, skipCheck } = prop;
    if (required4 && isAbsent) {
      warn$1('Missing required prop: "' + name2 + '"');
      return;
    }
    if (value == null && !required4) {
      return;
    }
    if (type4 != null && type4 !== true && !skipCheck) {
      let isValid2 = false;
      const types2 = isArray$2(type4) ? type4 : [type4];
      const expectedTypes = [];
      for (let i2 = 0; i2 < types2.length && !isValid2; i2++) {
        const { valid, expectedType } = assertType(value, types2[i2]);
        expectedTypes.push(expectedType || "");
        isValid2 = valid;
      }
      if (!isValid2) {
        warn$1(getInvalidTypeMessage(name2, value, expectedTypes));
        return;
      }
    }
    if (validator && !validator(value, props)) {
      warn$1('Invalid prop: custom validator check failed for prop "' + name2 + '".');
    }
  }
  const isSimpleType = /* @__PURE__ */ makeMap(
    "String,Number,Boolean,Function,Symbol,BigInt"
  );
  function assertType(value, type4) {
    let valid;
    const expectedType = getType(type4);
    if (isSimpleType(expectedType)) {
      const t2 = typeof value;
      valid = t2 === expectedType.toLowerCase();
      if (!valid && t2 === "object") {
        valid = value instanceof type4;
      }
    } else if (expectedType === "Object") {
      valid = isObject$3(value);
    } else if (expectedType === "Array") {
      valid = isArray$2(value);
    } else if (expectedType === "null") {
      valid = value === null;
    } else {
      valid = value instanceof type4;
    }
    return {
      valid,
      expectedType
    };
  }
  function getInvalidTypeMessage(name2, value, expectedTypes) {
    if (expectedTypes.length === 0) {
      return `Prop type [] for prop "${name2}" won't match anything. Did you mean to use type Array instead?`;
    }
    let message = `Invalid prop: type check failed for prop "${name2}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = toRawType(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
      message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    if (isExplicable(receivedType)) {
      message += `with value ${receivedValue}.`;
    }
    return message;
  }
  function styleValue(value, type4) {
    if (type4 === "String") {
      return `"${value}"`;
    } else if (type4 === "Number") {
      return `${Number(value)}`;
    } else {
      return `${value}`;
    }
  }
  function isExplicable(type4) {
    const explicitTypes = ["string", "number", "boolean"];
    return explicitTypes.some((elem) => type4.toLowerCase() === elem);
  }
  function isBoolean(...args) {
    return args.some((elem) => elem.toLowerCase() === "boolean");
  }
  const isInternalKey = (key2) => key2[0] === "_" || key2 === "$stable";
  const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  const normalizeSlot = (key2, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (currentInstance && (!ctx || ctx.root === currentInstance.root)) {
        warn$1(
          `Slot "${key2}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
        );
      }
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key2 in rawSlots) {
      if (isInternalKey(key2))
        continue;
      const value = rawSlots[key2];
      if (isFunction$2(value)) {
        slots[key2] = normalizeSlot(key2, value, ctx);
      } else if (value != null) {
        {
          warn$1(
            `Non-function value encountered for slot "${key2}". Prefer function slots for better performance.`
          );
        }
        const normalized = normalizeSlotValue(value);
        slots[key2] = () => normalized;
      }
    }
  };
  const normalizeVNodeSlots = (instance, children) => {
    if (!isKeepAlive(instance.vnode) && true) {
      warn$1(
        `Non-function value encountered for default slot. Prefer function slots for better performance.`
      );
    }
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  const initSlots = (instance, children) => {
    if (instance.vnode.shapeFlag & 32) {
      const type4 = children._;
      if (type4) {
        instance.slots = toRaw(children);
        def(children, "_", type4);
      } else {
        normalizeObjectSlots(
          children,
          instance.slots = {}
        );
      }
    } else {
      instance.slots = {};
      if (children) {
        normalizeVNodeSlots(instance, children);
      }
    }
    def(instance.slots, InternalObjectKey, 1);
  };
  const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type4 = children._;
      if (type4) {
        if (isHmrUpdating) {
          extend(slots, children);
          trigger$1(instance, "set", "$slots");
        } else if (optimized && type4 === 1) {
          needDeletionCheck = false;
        } else {
          extend(slots, children);
          if (!optimized && type4 === 1) {
            delete slots._;
          }
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key2 in slots) {
        if (!isInternalKey(key2) && deletionComparisonTarget[key2] == null) {
          delete slots[key2];
        }
      }
    }
  };
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray$2(rawRef)) {
      rawRef.forEach(
        (r2, i2) => setRef(
          r2,
          oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i2] : oldRawRef),
          parentSuspense,
          vnode,
          isUnmount
        )
      );
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref3 } = rawRef;
    if (!owner) {
      warn$1(
        `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
      );
      return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref3) {
      if (isString$1(oldRef)) {
        refs[oldRef] = null;
        if (hasOwn$1(setupState, oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction$2(ref3)) {
      callWithErrorHandling(ref3, owner, 12, [value, refs]);
    } else {
      const _isString3 = isString$1(ref3);
      const _isRef = isRef(ref3);
      if (_isString3 || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString3 ? hasOwn$1(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
            if (isUnmount) {
              isArray$2(existing) && remove(existing, refValue);
            } else {
              if (!isArray$2(existing)) {
                if (_isString3) {
                  refs[ref3] = [refValue];
                  if (hasOwn$1(setupState, ref3)) {
                    setupState[ref3] = refs[ref3];
                  }
                } else {
                  ref3.value = [refValue];
                  if (rawRef.k)
                    refs[rawRef.k] = ref3.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString3) {
            refs[ref3] = value;
            if (hasOwn$1(setupState, ref3)) {
              setupState[ref3] = value;
            }
          } else if (_isRef) {
            ref3.value = value;
            if (rawRef.k)
              refs[rawRef.k] = value;
          } else {
            warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
          }
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      } else {
        warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
      }
    }
  }
  let supported$1;
  let perf$1;
  function startMeasure(instance, type4) {
    if (instance.appContext.config.performance && isSupported()) {
      perf$1.mark(`vue-${type4}-${instance.uid}`);
    }
    {
      devtoolsPerfStart(instance, type4, isSupported() ? perf$1.now() : Date.now());
    }
  }
  function endMeasure(instance, type4) {
    if (instance.appContext.config.performance && isSupported()) {
      const startTag = `vue-${type4}-${instance.uid}`;
      const endTag = startTag + `:end`;
      perf$1.mark(endTag);
      perf$1.measure(
        `<${formatComponentName(instance, instance.type)}> ${type4}`,
        startTag,
        endTag
      );
      perf$1.clearMarks(startTag);
      perf$1.clearMarks(endTag);
    }
    {
      devtoolsPerfEnd(instance, type4, isSupported() ? perf$1.now() : Date.now());
    }
  }
  function isSupported() {
    if (supported$1 !== void 0) {
      return supported$1;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported$1 = true;
      perf$1 = window.performance;
    } else {
      supported$1 = false;
    }
    return supported$1;
  }
  function initFeatureFlags() {
    const needWarn = [];
    if (needWarn.length) {
      const multi = needWarn.length > 1;
      console.warn(
        `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
      );
    }
  }
  const queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    {
      initFeatureFlags();
    }
    const target = getGlobalThis();
    target.__VUE__ = true;
    {
      setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    }
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type: type4, ref: ref3, shapeFlag } = n2;
      switch (type4) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, namespace);
          } else {
            patchStaticNode(n1, n2, container, namespace);
          }
          break;
        case Fragment:
          processFragment(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          break;
        default:
          if (shapeFlag & 1) {
            processElement(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 6) {
            processComponent(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 64) {
            type4.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (shapeFlag & 128) {
            type4.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else {
            warn$1("Invalid VNode type:", type4, `(${typeof type4})`);
          }
      }
      if (ref3 != null && parentComponent) {
        setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateText(n2.children),
          container,
          anchor
        );
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateComment(n2.children || ""),
          container,
          anchor
        );
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, namespace) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace,
        n2.el,
        n2.anchor
      );
    };
    const patchStaticNode = (n1, n2, container, namespace) => {
      if (n2.children !== n1.children) {
        const anchor = hostNextSibling(n1.anchor);
        removeStaticNode(n1);
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace
        );
      } else {
        n2.el = n1.el;
        n2.anchor = n1.anchor;
      }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next2;
      while (el && el !== anchor) {
        next2 = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next2;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next2;
      while (el && el !== anchor) {
        next2 = hostNextSibling(el);
        hostRemove(el);
        el = next2;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      if (n2.type === "svg") {
        namespace = "svg";
      } else if (n2.type === "math") {
        namespace = "mathml";
      }
      if (n1 == null) {
        mountElement(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { props, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(
        vnode.type,
        namespace,
        props && props.is,
        props
      );
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(vnode, namespace),
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (const key2 in props) {
          if (key2 !== "value" && !isReservedProp(key2)) {
            hostPatchProp(
              el,
              key2,
              null,
              props[key2],
              namespace,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value, namespace);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      {
        Object.defineProperty(el, "__vnode", {
          value: vnode,
          enumerable: false
        });
        Object.defineProperty(el, "__vueParentComponent", {
          value: parentComponent,
          enumerable: false
        });
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
          hostSetScopeId(el, slotScopeIds[i2]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
          subTree = filterSingleRoot(subTree.children) || subTree;
        }
        if (vnode === subTree) {
          const parentVNode = parentComponent.vnode;
          setScopeId(
            el,
            parentVNode,
            parentVNode.scopeId,
            parentVNode.slotScopeIds,
            parentComponent.parent
          );
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
      for (let i2 = start; i2 < children.length; i2++) {
        const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
        patch(
          null,
          child,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (isHmrUpdating) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          el,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds
        );
        {
          traverseStaticChildren(n1, n2);
        }
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds,
          false
        );
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(
            el,
            n2,
            oldProps,
            newProps,
            parentComponent,
            parentSuspense,
            namespace
          );
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, namespace);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
              const key2 = propsToUpdate[i2];
              const prev2 = oldProps[key2];
              const next2 = newProps[key2];
              if (next2 !== prev2 || key2 === "value") {
                hostPatchProp(
                  el,
                  key2,
                  prev2,
                  next2,
                  namespace,
                  n1.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          namespace
        );
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
      for (let i2 = 0; i2 < newChildren.length; i2++) {
        const oldVNode = oldChildren[i2];
        const newVNode = newChildren[i2];
        const container = (
          // oldVNode may be an errored async setup() component inside Suspense
          // which will not have a mounted element
          oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
          // of the Fragment itself so it can move its children.
          (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
          // which also requires the correct parent container
          !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
          oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
            // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer
          )
        );
        patch(
          oldVNode,
          newVNode,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          true
        );
      }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key2 in oldProps) {
            if (!isReservedProp(key2) && !(key2 in newProps)) {
              hostPatchProp(
                el,
                key2,
                oldProps[key2],
                null,
                namespace,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
        for (const key2 in newProps) {
          if (isReservedProp(key2))
            continue;
          const next2 = newProps[key2];
          const prev2 = oldProps[key2];
          if (next2 !== prev2 && key2 !== "value") {
            hostPatchProp(
              el,
              key2,
              prev2,
              next2,
              namespace,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (
        // #5523 dev root fragment may inherit directives
        isHmrUpdating || patchFlag & 2048
      ) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(
          // #10007
          // such fragment like `<></>` will be compiled into
          // a fragment which doesn't have a children.
          // In this case fallback to an empty array
          n2.children || [],
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            container,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          {
            traverseStaticChildren(n1, n2);
          }
        } else {
          patchChildren(
            n1,
            n2,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(
            n2,
            container,
            anchor,
            namespace,
            optimized
          );
        } else {
          mountComponent(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            optimized
          );
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
      const instance = initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      );
      if (instance.type.__hmrId) {
        registerHMR(instance);
      }
      {
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
      }
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        {
          startMeasure(instance, `init`);
        }
        setupComponent(instance);
        {
          endMeasure(instance, `init`);
        }
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
      } else {
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          namespace,
          optimized
        );
      }
      {
        popWarningContext();
        endMeasure(instance, `mount`);
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          {
            pushWarningContext(n2);
          }
          updateComponentPreRender(instance, n2, optimized);
          {
            popWarningContext();
          }
          return;
        } else {
          instance.next = n2;
          invalidateJob(instance.update);
          instance.effect.dirty = true;
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m: m2, parent: parent2 } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent2, initialVNode);
          }
          toggleRecurse(instance, true);
          if (el && hydrateNode) {
            const hydrateSubTree = () => {
              {
                startMeasure(instance, `render`);
              }
              instance.subTree = renderComponentRoot(instance);
              {
                endMeasure(instance, `render`);
              }
              {
                startMeasure(instance, `hydrate`);
              }
              hydrateNode(
                el,
                instance.subTree,
                instance,
                parentSuspense,
                null
              );
              {
                endMeasure(instance, `hydrate`);
              }
            };
            if (isAsyncWrapperVNode) {
              initialVNode.type.__asyncLoader().then(
                // note: we are moving the render call into an async callback,
                // which means it won't track dependencies - but it's ok because
                // a server-rendered async wrapper is already in resolved state
                // and it will never need to change.
                () => !instance.isUnmounted && hydrateSubTree()
              );
            } else {
              hydrateSubTree();
            }
          } else {
            {
              startMeasure(instance, `render`);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            {
              endMeasure(instance, `render`);
            }
            {
              startMeasure(instance, `patch`);
            }
            patch(
              null,
              subTree,
              container,
              anchor,
              instance,
              parentSuspense,
              namespace
            );
            {
              endMeasure(instance, `patch`);
            }
            initialVNode.el = subTree.el;
          }
          if (m2) {
            queuePostRenderEffect(m2, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent2, scopedInitialVNode),
              parentSuspense
            );
          }
          if (initialVNode.shapeFlag & 256 || parent2 && isAsyncWrapper(parent2.vnode) && parent2.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          {
            devtoolsComponentAdded(instance);
          }
          initialVNode = container = anchor = null;
        } else {
          let { next: next2, bu, u: u2, parent: parent2, vnode } = instance;
          {
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next2) {
                next2.el = vnode.el;
                updateComponentPreRender(instance, next2, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(() => {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          let originNext = next2;
          let vnodeHook;
          {
            pushWarningContext(next2 || instance.vnode);
          }
          toggleRecurse(instance, false);
          if (next2) {
            next2.el = vnode.el;
            updateComponentPreRender(instance, next2, optimized);
          } else {
            next2 = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next2.props && next2.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent2, next2, vnode);
          }
          toggleRecurse(instance, true);
          {
            startMeasure(instance, `render`);
          }
          const nextTree = renderComponentRoot(instance);
          {
            endMeasure(instance, `render`);
          }
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          {
            startMeasure(instance, `patch`);
          }
          patch(
            prevTree,
            nextTree,
            // parent may have changed if it's in a teleport
            hostParentNode(prevTree.el),
            // anchor may have changed if it's in a fragment
            getNextHostNode(prevTree),
            instance,
            parentSuspense,
            namespace
          );
          {
            endMeasure(instance, `patch`);
          }
          next2.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u2) {
            queuePostRenderEffect(u2, parentSuspense);
          }
          if (vnodeHook = next2.props && next2.props.onVnodeUpdated) {
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent2, next2, vnode),
              parentSuspense
            );
          }
          {
            devtoolsComponentUpdated(instance);
          }
          {
            popWarningContext();
          }
        }
      };
      const effect2 = instance.effect = new ReactiveEffect(
        componentUpdateFn,
        NOOP,
        () => queueJob(update),
        instance.scope
        // track it in component's effect scope
      );
      const update = instance.update = () => {
        if (effect2.dirty) {
          effect2.run();
        }
      };
      update.id = instance.uid;
      toggleRecurse(instance, true);
      {
        effect2.onTrack = instance.rtc ? (e2) => invokeArrayFns(instance.rtc, e2) : void 0;
        effect2.onTrigger = instance.rtg ? (e2) => invokeArrayFns(instance.rtg, e2) : void 0;
        update.ownerInstance = instance;
      }
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i2;
      for (i2 = 0; i2 < commonLength; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        patch(
          c1[i2],
          nextChild,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
      if (oldLength > newLength) {
        unmountChildren(
          c1,
          parentComponent,
          parentSuspense,
          true,
          false,
          commonLength
        );
      } else {
        mountChildren(
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized,
          commonLength
        );
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let i2 = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i2 <= e1 && i2 <= e2) {
        const n1 = c1[i2];
        const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        i2++;
      }
      while (i2 <= e1 && i2 <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i2 > e1) {
        if (i2 <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i2 <= e2) {
            patch(
              null,
              c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            i2++;
          }
        }
      } else if (i2 > e2) {
        while (i2 <= e1) {
          unmount(c1[i2], parentComponent, parentSuspense, true);
          i2++;
        }
      } else {
        const s1 = i2;
        const s2 = i2;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i2 = s2; i2 <= e2; i2++) {
          const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          if (nextChild.key != null) {
            if (keyToNewIndexMap.has(nextChild.key)) {
              warn$1(
                `Duplicate keys found during update:`,
                JSON.stringify(nextChild.key),
                `Make sure keys are unique.`
              );
            }
            keyToNewIndexMap.set(nextChild.key, i2);
          }
        }
        let j2;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i2 = 0; i2 < toBePatched; i2++)
          newIndexToOldIndexMap[i2] = 0;
        for (i2 = s1; i2 <= e1; i2++) {
          const prevChild = c1[i2];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j2 = s2; j2 <= e2; j2++) {
              if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
                newIndex = j2;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(
              prevChild,
              c2[newIndex],
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j2 = increasingNewIndexSequence.length - 1;
        for (i2 = toBePatched - 1; i2 >= 0; i2--) {
          const nextIndex = s2 + i2;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i2] === 0) {
            patch(
              null,
              nextChild,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (moved) {
            if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
              move(nextChild, container, anchor, 2);
            } else {
              j2--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type: type4, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type4.move(vnode, container, anchor, internals);
        return;
      }
      if (type4 === Fragment) {
        hostInsert(el, container, anchor);
        for (let i2 = 0; i2 < children.length; i2++) {
          move(children[i2], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type4 === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type: type4,
        props,
        ref: ref3,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs
      } = vnode;
      if (ref3 != null) {
        setRef(ref3, null, parentSuspense, vnode, true);
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(
            vnode,
            parentComponent,
            parentSuspense,
            optimized,
            internals,
            doRemove
          );
        } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
        (type4 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(
            dynamicChildren,
            parentComponent,
            parentSuspense,
            false,
            true
          );
        } else if (type4 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type: type4, el, anchor, transition } = vnode;
      if (type4 === Fragment) {
        if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
          vnode.children.forEach((child) => {
            if (child.type === Comment) {
              hostRemove(child.el);
            } else {
              remove2(child);
            }
          });
        } else {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type4 === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next2;
      while (cur !== end) {
        next2 = hostNextSibling(cur);
        hostRemove(cur);
        cur = next2;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      if (instance.type.__hmrId) {
        unregisterHMR(instance);
      }
      const { bum, scope, update, subTree, um } = instance;
      if (bum) {
        invokeArrayFns(bum);
      }
      scope.stop();
      if (update) {
        update.active = false;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
      {
        devtoolsComponentRemoved(instance);
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i2 = start; i2 < children.length; i2++) {
        unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      return hostNextSibling(vnode.anchor || vnode.el);
    };
    let isFlushing2 = false;
    const render4 = (vnode, container, namespace) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(
          container._vnode || null,
          vnode,
          container,
          null,
          null,
          null,
          namespace
        );
      }
      if (!isFlushing2) {
        isFlushing2 = true;
        flushPreFlushCbs();
        flushPostFlushCbs();
        isFlushing2 = false;
      }
      container._vnode = vnode;
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
      [hydrate, hydrateNode] = createHydrationFns(
        internals
      );
    }
    return {
      render: render4,
      hydrate,
      createApp: createAppAPI(render4, hydrate)
    };
  }
  function resolveChildrenNamespace({ type: type4, props }, currentNamespace) {
    return currentNamespace === "svg" && type4 === "foreignObject" || currentNamespace === "mathml" && type4 === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse({ effect: effect2, update }, allowed) {
    effect2.allowRecurse = update.allowRecurse = allowed;
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray$2(ch1) && isArray$2(ch2)) {
      for (let i2 = 0; i2 < ch1.length; i2++) {
        const c1 = ch1[i2];
        let c2 = ch2[i2];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
            c2.el = c1.el;
          }
          if (!shallow)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) {
          c2.el = c1.el;
        }
        if (c2.type === Comment && !c2.el) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p = arr.slice();
    const result = [0];
    let i2, j2, u2, v2, c2;
    const len = arr.length;
    for (i2 = 0; i2 < len; i2++) {
      const arrI = arr[i2];
      if (arrI !== 0) {
        j2 = result[result.length - 1];
        if (arr[j2] < arrI) {
          p[i2] = j2;
          result.push(i2);
          continue;
        }
        u2 = 0;
        v2 = result.length - 1;
        while (u2 < v2) {
          c2 = u2 + v2 >> 1;
          if (arr[result[c2]] < arrI) {
            u2 = c2 + 1;
          } else {
            v2 = c2;
          }
        }
        if (arrI < arr[result[u2]]) {
          if (u2 > 0) {
            p[i2] = result[u2 - 1];
          }
          result[u2] = i2;
        }
      }
    }
    u2 = result.length;
    v2 = result[u2 - 1];
    while (u2-- > 0) {
      result[u2] = v2;
      v2 = p[v2];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }
  const isTeleport = (type4) => type4.__isTeleport;
  const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
  const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
  const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
  const resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if (isString$1(targetSelector)) {
      if (!select) {
        warn$1(
          `Current renderer does not support string target for Teleports. (missing querySelector renderer option)`
        );
        return null;
      } else {
        const target = select(targetSelector);
        if (!target) {
          warn$1(
            `Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
          );
        }
        return target;
      }
    } else {
      if (!targetSelector && !isTeleportDisabled(props)) {
        warn$1(`Invalid Teleport target: ${targetSelector}`);
      }
      return targetSelector;
    }
  };
  const TeleportImpl = {
    name: "Teleport",
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
      const {
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        o: { insert, querySelector, createText, createComment }
      } = internals;
      const disabled = isTeleportDisabled(n2.props);
      let { shapeFlag, children, dynamicChildren } = n2;
      if (isHmrUpdating) {
        optimized = false;
        dynamicChildren = null;
      }
      if (n1 == null) {
        const placeholder = n2.el = createComment("teleport start");
        const mainAnchor = n2.anchor = createComment("teleport end");
        insert(placeholder, container, anchor);
        insert(mainAnchor, container, anchor);
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = n2.targetAnchor = createText("");
        if (target) {
          insert(targetAnchor, target);
          if (namespace === "svg" || isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace === "mathml" || isTargetMathML(target)) {
            namespace = "mathml";
          }
        } else if (!disabled) {
          warn$1("Invalid Teleport target on mount:", target, `(${typeof target})`);
        }
        const mount = (container2, anchor2) => {
          if (shapeFlag & 16) {
            mountChildren(
              children,
              container2,
              anchor2,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        };
        if (disabled) {
          mount(container, mainAnchor);
        } else if (target) {
          mount(target, targetAnchor);
        }
      } else {
        n2.el = n1.el;
        const mainAnchor = n2.anchor = n1.anchor;
        const target = n2.target = n1.target;
        const targetAnchor = n2.targetAnchor = n1.targetAnchor;
        const wasDisabled = isTeleportDisabled(n1.props);
        const currentContainer = wasDisabled ? container : target;
        const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
        if (namespace === "svg" || isTargetSVG(target)) {
          namespace = "svg";
        } else if (namespace === "mathml" || isTargetMathML(target)) {
          namespace = "mathml";
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            currentContainer,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          traverseStaticChildren(n1, n2, true);
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            currentContainer,
            currentAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            false
          );
        }
        if (disabled) {
          if (!wasDisabled) {
            moveTeleport(
              n2,
              container,
              mainAnchor,
              internals,
              1
            );
          } else {
            if (n2.props && n1.props && n2.props.to !== n1.props.to) {
              n2.props.to = n1.props.to;
            }
          }
        } else {
          if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
            const nextTarget = n2.target = resolveTarget(
              n2.props,
              querySelector
            );
            if (nextTarget) {
              moveTeleport(
                n2,
                nextTarget,
                null,
                internals,
                0
              );
            } else {
              warn$1(
                "Invalid Teleport target on update:",
                target,
                `(${typeof target})`
              );
            }
          } else if (wasDisabled) {
            moveTeleport(
              n2,
              target,
              targetAnchor,
              internals,
              1
            );
          }
        }
      }
      updateCssVars(n2);
    },
    remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
      const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
      if (target) {
        hostRemove(targetAnchor);
      }
      doRemove && hostRemove(anchor);
      if (shapeFlag & 16) {
        const shouldRemove = doRemove || !isTeleportDisabled(props);
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          unmount(
            child,
            parentComponent,
            parentSuspense,
            shouldRemove,
            !!child.dynamicChildren
          );
        }
      }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
  };
  function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
    if (moveType === 0) {
      insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) {
      insert(el, container, parentAnchor);
    }
    if (!isReorder || isTeleportDisabled(props)) {
      if (shapeFlag & 16) {
        for (let i2 = 0; i2 < children.length; i2++) {
          move(
            children[i2],
            container,
            parentAnchor,
            2
          );
        }
      }
    }
    if (isReorder) {
      insert(anchor, container, parentAnchor);
    }
  }
  function hydrateTeleport(node2, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
    o: { nextSibling, parentNode, querySelector }
  }, hydrateChildren) {
    const target = vnode.target = resolveTarget(
      vnode.props,
      querySelector
    );
    if (target) {
      const targetNode = target._lpa || target.firstChild;
      if (vnode.shapeFlag & 16) {
        if (isTeleportDisabled(vnode.props)) {
          vnode.anchor = hydrateChildren(
            nextSibling(node2),
            vnode,
            parentNode(node2),
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
          vnode.targetAnchor = targetNode;
        } else {
          vnode.anchor = nextSibling(node2);
          let targetAnchor = targetNode;
          while (targetAnchor) {
            targetAnchor = nextSibling(targetAnchor);
            if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          hydrateChildren(
            targetNode,
            vnode,
            target,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
      }
      updateCssVars(vnode);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
  }
  const Teleport = TeleportImpl;
  function updateCssVars(vnode) {
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
      let node2 = vnode.children[0].el;
      while (node2 && node2 !== vnode.targetAnchor) {
        if (node2.nodeType === 1)
          node2.setAttribute("data-v-owner", ctx.uid);
        node2 = node2.nextSibling;
      }
      ctx.ut();
    }
  }
  const Fragment = Symbol.for("v-fgt");
  const Text = Symbol.for("v-txt");
  const Comment = Symbol.for("v-cmt");
  const Static = Symbol.for("v-stc");
  const blockStack = [];
  let currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  let isBlockTreeEnabled = 1;
  function setBlockTracking(value) {
    isBlockTreeEnabled += value;
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type4, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
      createBaseVNode(
        type4,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        true
      )
    );
  }
  function createBlock(type4, props, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type4,
        props,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
      n1.shapeFlag &= ~256;
      n2.shapeFlag &= ~512;
      return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
  }
  const createVNodeWithArgsTransform = (...args) => {
    return _createVNode(
      ...args
    );
  };
  const InternalObjectKey = `__vInternal`;
  const normalizeKey = ({ key: key2 }) => key2 != null ? key2 : null;
  const normalizeRef = ({
    ref: ref3,
    ref_key,
    ref_for
  }) => {
    if (typeof ref3 === "number") {
      ref3 = "" + ref3;
    }
    return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$2(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
  };
  function createBaseVNode(type4, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type4 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type: type4,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type4.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString$1(children) ? 8 : 16;
    }
    if (vnode.key !== vnode.key) {
      warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  const createVNode = createVNodeWithArgsTransform;
  function _createVNode(type4, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type4 || type4 === NULL_DYNAMIC_COMPONENT) {
      if (!type4) {
        warn$1(`Invalid vnode type when creating vnode: ${type4}.`);
      }
      type4 = Comment;
    }
    if (isVNode(type4)) {
      const cloned = cloneVNode(
        type4,
        props,
        true
        /* mergeRef: true */
      );
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type4)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag |= -2;
      return cloned;
    }
    if (isClassComponent(type4)) {
      type4 = type4.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString$1(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject$3(style)) {
        if (isProxy(style) && !isArray$2(style)) {
          style = extend({}, style);
        }
        props.style = normalizeStyle$1(style);
      }
    }
    const shapeFlag = isString$1(type4) ? 1 : isSuspense(type4) ? 128 : isTeleport(type4) ? 64 : isObject$3(type4) ? 4 : isFunction$2(type4) ? 2 : 0;
    if (shapeFlag & 4 && isProxy(type4)) {
      type4 = toRaw(type4);
      warn$1(
        `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
        `
Component that was made reactive: `,
        type4
      );
    }
    return createBaseVNode(
      type4,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props) {
    if (!props)
      return null;
    return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false) {
    const { props, ref: ref3, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? (
        // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref3 ? isArray$2(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
      ) : ref3,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children: patchFlag === -1 && isArray$2(children) ? children.map(deepCloneVNode) : children,
      target: vnode.target,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: preserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition: vnode.transition,
      // These should technically only be non-null on mounted VNodes. However,
      // they *should* be copied for kept-alive vnodes. So we just always copy
      // them since them being non-null during a mount doesn't affect the logic as
      // they will simply be overwritten.
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    return cloned;
  }
  function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if (isArray$2(vnode.children)) {
      cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createStaticVNode(content, numberOfNodes) {
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray$2(child)) {
      return createVNode(
        Fragment,
        null,
        // #3666, avoid reference pollution when reusing vnode
        child.slice()
      );
    } else if (typeof child === "object") {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type4 = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray$2(children)) {
      type4 = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type4 = 32;
        const slotFlag = children._;
        if (!slotFlag && !(InternalObjectKey in children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction$2(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type4 = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type4 = 16;
        children = [createTextVNode(children)];
      } else {
        type4 = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type4;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i2 = 0; i2 < args.length; i2++) {
      const toMerge = args[i2];
      for (const key2 in toMerge) {
        if (key2 === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key2 === "style") {
          ret.style = normalizeStyle$1([ret.style, toMerge.style]);
        } else if (isOn$1(key2)) {
          const existing = ret[key2];
          const incoming = toMerge[key2];
          if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
            ret[key2] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key2 !== "") {
          ret[key2] = toMerge[key2];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  const emptyAppContext = createAppContext();
  let uid = 0;
  function createComponentInstance(vnode, parent2, suspense) {
    const type4 = vnode.type;
    const appContext = (parent2 ? parent2.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type: type4,
      parent: parent2,
      appContext,
      root: null,
      // to be immediately set
      next: null,
      subTree: null,
      // will be set synchronously right after creation
      effect: null,
      update: null,
      // will be set synchronously right after creation
      scope: new EffectScope(
        true
        /* detached */
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent2 ? parent2.provides : Object.create(appContext.provides),
      accessCache: null,
      renderCache: [],
      // local resolved assets
      components: null,
      directives: null,
      // resolved props and emits options
      propsOptions: normalizePropsOptions(type4, appContext),
      emitsOptions: normalizeEmitsOptions(type4, appContext),
      // emit
      emit: null,
      // to be set immediately
      emitted: null,
      // props default value
      propsDefaults: EMPTY_OBJ,
      // inheritAttrs
      inheritAttrs: type4.inheritAttrs,
      // state
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      attrsProxy: null,
      slotsProxy: null,
      // suspense related
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      // lifecycle hooks
      // not using enums here because it results in computed properties
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    {
      instance.ctx = createDevRenderContext(instance);
    }
    instance.root = parent2 ? parent2.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  let currentInstance = null;
  const getCurrentInstance = () => currentInstance || currentRenderingInstance;
  let internalSetCurrentInstance;
  let setInSSRSetupState;
  {
    const g2 = getGlobalThis();
    const registerGlobalSetter = (key2, setter) => {
      let setters;
      if (!(setters = g2[key2]))
        setters = g2[key2] = [];
      setters.push(setter);
      return (v2) => {
        if (setters.length > 1)
          setters.forEach((set2) => set2(v2));
        else
          setters[0](v2);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      `__VUE_INSTANCE_SETTERS__`,
      (v2) => currentInstance = v2
    );
    setInSSRSetupState = registerGlobalSetter(
      `__VUE_SSR_SETTERS__`,
      (v2) => isInSSRComponentSetup = v2
    );
  }
  const setCurrentInstance = (instance) => {
    const prev2 = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return () => {
      instance.scope.off();
      internalSetCurrentInstance(prev2);
    };
  };
  const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
  function validateComponentName(name2, { isNativeTag }) {
    if (isBuiltInTag(name2) || isNativeTag(name2)) {
      warn$1(
        "Do not use built-in or reserved HTML elements as component id: " + name2
      );
    }
  }
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    var _a2;
    const Component = instance.type;
    {
      if (Component.name) {
        validateComponentName(Component.name, instance.appContext.config);
      }
      if (Component.components) {
        const names2 = Object.keys(Component.components);
        for (let i2 = 0; i2 < names2.length; i2++) {
          validateComponentName(names2[i2], instance.appContext.config);
        }
      }
      if (Component.directives) {
        const names2 = Object.keys(Component.directives);
        for (let i2 = 0; i2 < names2.length; i2++) {
          validateDirectiveName(names2[i2]);
        }
      }
      if (Component.compilerOptions && isRuntimeOnly()) {
        warn$1(
          `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
        );
      }
    }
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    {
      exposePropsOnRenderContext(instance);
    }
    const { setup: setup2 } = Component;
    if (setup2) {
      const setupContext = instance.setupContext = setup2.length > 1 ? createSetupContext(instance) : null;
      const reset = setCurrentInstance(instance);
      pauseTracking();
      const setupResult = callWithErrorHandling(
        setup2,
        instance,
        0,
        [
          shallowReadonly(instance.props),
          setupContext
        ]
      );
      resetTracking();
      reset();
      if (isPromise(setupResult)) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e2) => {
            handleError(e2, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
          if (!instance.suspense) {
            const name2 = (_a2 = Component.name) != null ? _a2 : "Anonymous";
            warn$1(
              `Component <${name2}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
            );
          }
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction$2(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject$3(setupResult)) {
      if (isVNode(setupResult)) {
        warn$1(
          `setup() should not return VNodes directly - return a render function instead.`
        );
      }
      {
        instance.devtoolsRawSetupState = setupResult;
      }
      instance.setupState = proxyRefs(setupResult);
      {
        exposeSetupStateOnRenderContext(instance);
      }
    } else if (setupResult !== void 0) {
      warn$1(
        `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
      );
    }
    finishComponentSetup(instance, isSSR);
  }
  let compile$1;
  const isRuntimeOnly = () => !compile$1;
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      if (!isSSR && compile$1 && !Component.render) {
        const template = Component.template || resolveMergedOptions(instance).template;
        if (template) {
          {
            startMeasure(instance, `compile`);
          }
          const { isCustomElement, compilerOptions } = instance.appContext.config;
          const { delimiters, compilerOptions: componentCompilerOptions } = Component;
          const finalCompilerOptions = extend(
            extend(
              {
                isCustomElement,
                delimiters
              },
              compilerOptions
            ),
            componentCompilerOptions
          );
          Component.render = compile$1(template, finalCompilerOptions);
          {
            endMeasure(instance, `compile`);
          }
        }
      }
      instance.render = Component.render || NOOP;
    }
    {
      const reset = setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        reset();
      }
    }
    if (!Component.render && instance.render === NOOP && !isSSR) {
      if (Component.template) {
        warn$1(
          `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
        );
      } else {
        warn$1(`Component is missing template or render function.`);
      }
    }
  }
  function getAttrsProxy(instance) {
    return instance.attrsProxy || (instance.attrsProxy = new Proxy(
      instance.attrs,
      {
        get(target, key2) {
          markAttrsAccessed();
          track(instance, "get", "$attrs");
          return target[key2];
        },
        set() {
          warn$1(`setupContext.attrs is readonly.`);
          return false;
        },
        deleteProperty() {
          warn$1(`setupContext.attrs is readonly.`);
          return false;
        }
      }
    ));
  }
  function getSlotsProxy(instance) {
    return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
      get(target, key2) {
        track(instance, "get", "$slots");
        return target[key2];
      }
    }));
  }
  function createSetupContext(instance) {
    const expose = (exposed) => {
      {
        if (instance.exposed) {
          warn$1(`expose() should be called only once per setup().`);
        }
        if (exposed != null) {
          let exposedType = typeof exposed;
          if (exposedType === "object") {
            if (isArray$2(exposed)) {
              exposedType = "array";
            } else if (isRef(exposed)) {
              exposedType = "ref";
            }
          }
          if (exposedType !== "object") {
            warn$1(
              `expose() should be passed a plain object, received ${exposedType}.`
            );
          }
        }
      }
      instance.exposed = exposed || {};
    };
    {
      return Object.freeze({
        get attrs() {
          return getAttrsProxy(instance);
        },
        get slots() {
          return getSlotsProxy(instance);
        },
        get emit() {
          return (event, ...args) => instance.emit(event, ...args);
        },
        expose
      });
    }
  }
  function getExposeProxy(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key2) {
          if (key2 in target) {
            return target[key2];
          } else if (key2 in publicPropertiesMap) {
            return publicPropertiesMap[key2](instance);
          }
        },
        has(target, key2) {
          return key2 in target || key2 in publicPropertiesMap;
        }
      }));
    }
  }
  const classifyRE = /(?:^|[-_])(\w)/g;
  const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component, includeInferred = true) {
    return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name2 = getComponentName(Component);
    if (!name2 && Component.__file) {
      const match2 = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match2) {
        name2 = match2[1];
      }
    }
    if (!name2 && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key2 in registry) {
          if (registry[key2] === Component) {
            return key2;
          }
        }
      };
      name2 = inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name2 ? classify(name2) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction$2(value) && "__vccOpts" in value;
  }
  const computed = (getterOrOptions, debugOptions) => {
    const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    {
      const i2 = getCurrentInstance();
      if (i2 && i2.appContext.config.warnRecursiveComputed) {
        c2._warnRecursive = true;
      }
    }
    return c2;
  };
  function h$1(type4, propsOrChildren, children) {
    const l2 = arguments.length;
    if (l2 === 2) {
      if (isObject$3(propsOrChildren) && !isArray$2(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type4, null, [propsOrChildren]);
        }
        return createVNode(type4, propsOrChildren);
      } else {
        return createVNode(type4, null, propsOrChildren);
      }
    } else {
      if (l2 > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l2 === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type4, propsOrChildren, children);
    }
  }
  function initCustomFormatter() {
    if (typeof window === "undefined") {
      return;
    }
    const vueStyle = { style: "color:#3ba776" };
    const numberStyle = { style: "color:#1677ff" };
    const stringStyle = { style: "color:#f5222d" };
    const keywordStyle = { style: "color:#eb2f96" };
    const formatter = {
      header(obj) {
        if (!isObject$3(obj)) {
          return null;
        }
        if (obj.__isVue) {
          return ["div", vueStyle, `VueInstance`];
        } else if (isRef(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, genRefFlag(obj)],
            "<",
            formatValue(obj.value),
            `>`
          ];
        } else if (isReactive(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
            "<",
            formatValue(obj),
            `>${isReadonly(obj) ? ` (readonly)` : ``}`
          ];
        } else if (isReadonly(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
            "<",
            formatValue(obj),
            ">"
          ];
        }
        return null;
      },
      hasBody(obj) {
        return obj && obj.__isVue;
      },
      body(obj) {
        if (obj && obj.__isVue) {
          return [
            "div",
            {},
            ...formatInstance(obj.$)
          ];
        }
      }
    };
    function formatInstance(instance) {
      const blocks = [];
      if (instance.type.props && instance.props) {
        blocks.push(createInstanceBlock("props", toRaw(instance.props)));
      }
      if (instance.setupState !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("setup", instance.setupState));
      }
      if (instance.data !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("data", toRaw(instance.data)));
      }
      const computed2 = extractKeys(instance, "computed");
      if (computed2) {
        blocks.push(createInstanceBlock("computed", computed2));
      }
      const injected = extractKeys(instance, "inject");
      if (injected) {
        blocks.push(createInstanceBlock("injected", injected));
      }
      blocks.push([
        "div",
        {},
        [
          "span",
          {
            style: keywordStyle.style + ";opacity:0.66"
          },
          "$ (internal): "
        ],
        ["object", { object: instance }]
      ]);
      return blocks;
    }
    function createInstanceBlock(type4, target) {
      target = extend({}, target);
      if (!Object.keys(target).length) {
        return ["span", {}];
      }
      return [
        "div",
        { style: "line-height:1.25em;margin-bottom:0.6em" },
        [
          "div",
          {
            style: "color:#476582"
          },
          type4
        ],
        [
          "div",
          {
            style: "padding-left:1.25em"
          },
          ...Object.keys(target).map((key2) => {
            return [
              "div",
              {},
              ["span", keywordStyle, key2 + ": "],
              formatValue(target[key2], false)
            ];
          })
        ]
      ];
    }
    function formatValue(v2, asRaw = true) {
      if (typeof v2 === "number") {
        return ["span", numberStyle, v2];
      } else if (typeof v2 === "string") {
        return ["span", stringStyle, JSON.stringify(v2)];
      } else if (typeof v2 === "boolean") {
        return ["span", keywordStyle, v2];
      } else if (isObject$3(v2)) {
        return ["object", { object: asRaw ? toRaw(v2) : v2 }];
      } else {
        return ["span", stringStyle, String(v2)];
      }
    }
    function extractKeys(instance, type4) {
      const Comp = instance.type;
      if (isFunction$2(Comp)) {
        return;
      }
      const extracted = {};
      for (const key2 in instance.ctx) {
        if (isKeyOfType(Comp, key2, type4)) {
          extracted[key2] = instance.ctx[key2];
        }
      }
      return extracted;
    }
    function isKeyOfType(Comp, key2, type4) {
      const opts = Comp[type4];
      if (isArray$2(opts) && opts.includes(key2) || isObject$3(opts) && key2 in opts) {
        return true;
      }
      if (Comp.extends && isKeyOfType(Comp.extends, key2, type4)) {
        return true;
      }
      if (Comp.mixins && Comp.mixins.some((m2) => isKeyOfType(m2, key2, type4))) {
        return true;
      }
    }
    function genRefFlag(v2) {
      if (isShallow(v2)) {
        return `ShallowRef`;
      }
      if (v2.effect) {
        return `ComputedRef`;
      }
      return `Ref`;
    }
    if (window.devtoolsFormatters) {
      window.devtoolsFormatters.push(formatter);
    } else {
      window.devtoolsFormatters = [formatter];
    }
  }
  const version$1 = "3.4.21";
  const warn$2 = warn$1;
  /**
  * @vue/runtime-dom v3.4.21
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const svgNS = "http://www.w3.org/2000/svg";
  const mathmlNS = "http://www.w3.org/1998/Math/MathML";
  const doc = typeof document !== "undefined" ? document : null;
  const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  const nodeOps = {
    insert: (child, parent2, anchor) => {
      parent2.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent2 = child.parentNode;
      if (parent2) {
        parent2.removeChild(child);
      }
    },
    createElement: (tag, namespace, is, props) => {
      const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : doc.createElement(tag, is ? { is } : void 0);
      if (tag === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node2, text) => {
      node2.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node2) => node2.parentNode,
    nextSibling: (node2) => node2.nextSibling,
    querySelector: (selector3) => doc.querySelector(selector3),
    setScopeId(el, id) {
      el.setAttribute(id, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent2, anchor, namespace, start, end) {
      const before = anchor ? anchor.previousSibling : parent2.lastChild;
      if (start && (start === end || start.nextSibling)) {
        while (true) {
          parent2.insertBefore(start.cloneNode(true), anchor);
          if (start === end || !(start = start.nextSibling))
            break;
        }
      } else {
        templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
        const template = templateContainer.content;
        if (namespace === "svg" || namespace === "mathml") {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent2.insertBefore(template, anchor);
      }
      return [
        // first
        before ? before.nextSibling : parent2.firstChild,
        // last
        anchor ? anchor.previousSibling : parent2.lastChild
      ];
    }
  };
  const TRANSITION = "transition";
  const ANIMATION = "animation";
  const vtcKey = Symbol("_vtc");
  const Transition = (props, { slots }) => h$1(BaseTransition, resolveTransitionProps(props), slots);
  Transition.displayName = "Transition";
  const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  };
  const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(
    {},
    BaseTransitionPropsValidators,
    DOMTransitionPropsValidators
  );
  const callHook = (hook, args = []) => {
    if (isArray$2(hook)) {
      hook.forEach((h2) => h2(...args));
    } else if (hook) {
      hook(...args);
    }
  };
  const hasExplicitCallback = (hook) => {
    return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
  };
  function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key2 in rawProps) {
      if (!(key2 in DOMTransitionPropsValidators)) {
        baseProps[key2] = rawProps[key2];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    const {
      name: name2 = "v",
      type: type4,
      duration,
      enterFromClass = `${name2}-enter-from`,
      enterActiveClass = `${name2}-enter-active`,
      enterToClass = `${name2}-enter-to`,
      appearFromClass = enterFromClass,
      appearActiveClass = enterActiveClass,
      appearToClass = enterToClass,
      leaveFromClass = `${name2}-leave-from`,
      leaveActiveClass = `${name2}-leave-active`,
      leaveToClass = `${name2}-leave-to`
    } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const {
      onBeforeEnter,
      onEnter,
      onEnterCancelled,
      onLeave,
      onLeaveCancelled,
      onBeforeAppear = onBeforeEnter,
      onAppear = onEnter,
      onAppearCancelled = onEnterCancelled
    } = baseProps;
    const finishEnter = (el, isAppear, done) => {
      removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    const finishLeave = (el, done) => {
      el._isLeaving = false;
      removeTransitionClass(el, leaveFromClass);
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
      done && done();
    };
    const makeEnterHook = (isAppear) => {
      return (el, done) => {
        const hook = isAppear ? onAppear : onEnter;
        const resolve2 = () => finishEnter(el, isAppear, done);
        callHook(hook, [el, resolve2]);
        nextFrame(() => {
          removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el, type4, enterDuration, resolve2);
          }
        });
      };
    };
    return extend(baseProps, {
      onBeforeEnter(el) {
        callHook(onBeforeEnter, [el]);
        addTransitionClass(el, enterFromClass);
        addTransitionClass(el, enterActiveClass);
      },
      onBeforeAppear(el) {
        callHook(onBeforeAppear, [el]);
        addTransitionClass(el, appearFromClass);
        addTransitionClass(el, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave(el, done) {
        el._isLeaving = true;
        const resolve2 = () => finishLeave(el, done);
        addTransitionClass(el, leaveFromClass);
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
        nextFrame(() => {
          if (!el._isLeaving) {
            return;
          }
          removeTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveToClass);
          if (!hasExplicitCallback(onLeave)) {
            whenTransitionEnds(el, type4, leaveDuration, resolve2);
          }
        });
        callHook(onLeave, [el, resolve2]);
      },
      onEnterCancelled(el) {
        finishEnter(el, false);
        callHook(onEnterCancelled, [el]);
      },
      onAppearCancelled(el) {
        finishEnter(el, true);
        callHook(onAppearCancelled, [el]);
      },
      onLeaveCancelled(el) {
        finishLeave(el);
        callHook(onLeaveCancelled, [el]);
      }
    });
  }
  function normalizeDuration(duration) {
    if (duration == null) {
      return null;
    } else if (isObject$3(duration)) {
      return [NumberOf(duration.enter), NumberOf(duration.leave)];
    } else {
      const n2 = NumberOf(duration);
      return [n2, n2];
    }
  }
  function NumberOf(val) {
    const res = toNumber$1(val);
    {
      assertNumber(res, "<transition> explicit duration");
    }
    return res;
  }
  function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
    (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el[vtcKey] = void 0;
      }
    }
  }
  function nextFrame(cb) {
    requestAnimationFrame(() => {
      requestAnimationFrame(cb);
    });
  }
  let endId = 0;
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = () => {
      if (id === el._endId) {
        resolve2();
      }
    };
    if (explicitTimeout) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type: type4, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type4) {
      return resolve2();
    }
    const endEvent = type4 + "end";
    let ended = 0;
    const end = () => {
      el.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    const onEnd = (e2) => {
      if (e2.target === el && ++ended >= propCount) {
        end();
      }
    };
    setTimeout(() => {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key2) => (styles[key2] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type4 = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type4 = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type4 = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type4 = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type4 ? type4 === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type4 === TRANSITION && /\b(transform|all)(,|$)/.test(
      getStyleProperties(`${TRANSITION}Property`).toString()
    );
    return {
      type: type4,
      timeout,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d2, i2) => toMs(d2) + toMs(delays[i2])));
  }
  function toMs(s2) {
    if (s2 === "auto")
      return 0;
    return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow() {
    return document.body.offsetHeight;
  }
  function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  const vShowOriginalDisplay = Symbol("_vod");
  const vShowHidden = Symbol("_vsh");
  const vShow = {
    beforeMount(el, { value }, { transition }) {
      el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
      if (transition && value) {
        transition.beforeEnter(el);
      } else {
        setDisplay(el, value);
      }
    },
    mounted(el, { value }, { transition }) {
      if (transition && value) {
        transition.enter(el);
      }
    },
    updated(el, { value, oldValue }, { transition }) {
      if (!value === !oldValue)
        return;
      if (transition) {
        if (value) {
          transition.beforeEnter(el);
          setDisplay(el, true);
          transition.enter(el);
        } else {
          transition.leave(el, () => {
            setDisplay(el, false);
          });
        }
      } else {
        setDisplay(el, value);
      }
    },
    beforeUnmount(el, { value }) {
      setDisplay(el, value);
    }
  };
  {
    vShow.name = "show";
  }
  function setDisplay(el, value) {
    el.style.display = value ? el[vShowOriginalDisplay] : "none";
    el[vShowHidden] = !value;
  }
  const CSS_VAR_TEXT = Symbol("CSS_VAR_TEXT");
  function useCssVars(getter) {
    const instance = getCurrentInstance();
    if (!instance) {
      warn$2(`useCssVars is called without current active component instance.`);
      return;
    }
    const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
      Array.from(
        document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
      ).forEach((node2) => setVarsOnNode(node2, vars));
    };
    {
      instance.getCssVars = () => getter(instance.proxy);
    }
    const setVars = () => {
      const vars = getter(instance.proxy);
      setVarsOnVNode(instance.subTree, vars);
      updateTeleports(vars);
    };
    watchPostEffect(setVars);
    onMounted(() => {
      const ob = new MutationObserver(setVars);
      ob.observe(instance.subTree.el.parentNode, { childList: true });
      onUnmounted(() => ob.disconnect());
    });
  }
  function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128) {
      const suspense = vnode.suspense;
      vnode = suspense.activeBranch;
      if (suspense.pendingBranch && !suspense.isHydrating) {
        suspense.effects.push(() => {
          setVarsOnVNode(suspense.activeBranch, vars);
        });
      }
    }
    while (vnode.component) {
      vnode = vnode.component.subTree;
    }
    if (vnode.shapeFlag & 1 && vnode.el) {
      setVarsOnNode(vnode.el, vars);
    } else if (vnode.type === Fragment) {
      vnode.children.forEach((c2) => setVarsOnVNode(c2, vars));
    } else if (vnode.type === Static) {
      let { el, anchor } = vnode;
      while (el) {
        setVarsOnNode(el, vars);
        if (el === anchor)
          break;
        el = el.nextSibling;
      }
    }
  }
  function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
      const style = el.style;
      let cssText = "";
      for (const key2 in vars) {
        style.setProperty(`--${key2}`, vars[key2]);
        cssText += `--${key2}: ${vars[key2]};`;
      }
      style[CSS_VAR_TEXT] = cssText;
    }
  }
  const displayRE = /(^|;)\s*display\s*:/;
  function patchStyle(el, prev2, next2) {
    const style = el.style;
    const isCssString = isString$1(next2);
    let hasControlledDisplay = false;
    if (next2 && !isCssString) {
      if (prev2) {
        if (!isString$1(prev2)) {
          for (const key2 in prev2) {
            if (next2[key2] == null) {
              setStyle(style, key2, "");
            }
          }
        } else {
          for (const prevStyle of prev2.split(";")) {
            const key2 = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
            if (next2[key2] == null) {
              setStyle(style, key2, "");
            }
          }
        }
      }
      for (const key2 in next2) {
        if (key2 === "display") {
          hasControlledDisplay = true;
        }
        setStyle(style, key2, next2[key2]);
      }
    } else {
      if (isCssString) {
        if (prev2 !== next2) {
          const cssVarText = style[CSS_VAR_TEXT];
          if (cssVarText) {
            next2 += ";" + cssVarText;
          }
          style.cssText = next2;
          hasControlledDisplay = displayRE.test(next2);
        }
      } else if (prev2) {
        el.removeAttribute("style");
      }
    }
    if (vShowOriginalDisplay in el) {
      el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
      if (el[vShowHidden]) {
        style.display = "none";
      }
    }
  }
  const semicolonRE = /[^\\];\s*$/;
  const importantRE = /\s*!important$/;
  function setStyle(style, name2, val) {
    if (isArray$2(val)) {
      val.forEach((v2) => setStyle(style, name2, v2));
    } else {
      if (val == null)
        val = "";
      {
        if (semicolonRE.test(val)) {
          warn$2(
            `Unexpected semicolon at the end of '${name2}' style value: '${val}'`
          );
        }
      }
      if (name2.startsWith("--")) {
        style.setProperty(name2, val);
      } else {
        const prefixed = autoPrefix(style, name2);
        if (importantRE.test(val)) {
          style.setProperty(
            hyphenate$1(prefixed),
            val.replace(importantRE, ""),
            "important"
          );
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  const prefixes = ["Webkit", "Moz", "ms"];
  const prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached2 = prefixCache[rawName];
    if (cached2) {
      return cached2;
    }
    let name2 = camelize$1(rawName);
    if (name2 !== "filter" && name2 in style) {
      return prefixCache[rawName] = name2;
    }
    name2 = capitalize(name2);
    for (let i2 = 0; i2 < prefixes.length; i2++) {
      const prefixed = prefixes[i2] + name2;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  const xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key2, value, isSVG, instance) {
    if (isSVG && key2.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key2.slice(6, key2.length));
      } else {
        el.setAttributeNS(xlinkNS, key2, value);
      }
    } else {
      const isBoolean2 = isSpecialBooleanAttr(key2);
      if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
        el.removeAttribute(key2);
      } else {
        el.setAttribute(key2, isBoolean2 ? "" : value);
      }
    }
  }
  function patchDOMProp(el, key2, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key2 === "innerHTML" || key2 === "textContent") {
      if (prevChildren) {
        unmountChildren(prevChildren, parentComponent, parentSuspense);
      }
      el[key2] = value == null ? "" : value;
      return;
    }
    const tag = el.tagName;
    if (key2 === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
    !tag.includes("-")) {
      const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
      const newValue = value == null ? "" : value;
      if (oldValue !== newValue || !("_value" in el)) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key2);
      }
      el._value = value;
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type4 = typeof el[key2];
      if (type4 === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type4 === "string") {
        value = "";
        needRemove = true;
      } else if (type4 === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key2] = value;
    } catch (e2) {
      if (!needRemove) {
        warn$2(
          `Failed setting prop "${key2}" on <${tag.toLowerCase()}>: value ${value} is invalid.`,
          e2
        );
      }
    }
    needRemove && el.removeAttribute(key2);
  }
  function addEventListener$1(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  const veiKey = Symbol("_vei");
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = nextValue;
    } else {
      const [name2, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(nextValue, instance);
        addEventListener$1(el, name2, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name2, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name2) {
    let options;
    if (optionsModifierRE.test(name2)) {
      options = {};
      let m2;
      while (m2 = name2.match(optionsModifierRE)) {
        name2 = name2.slice(0, name2.length - m2[0].length);
        options[m2[0].toLowerCase()] = true;
      }
    }
    const event = name2[2] === ":" ? name2.slice(3) : hyphenate$1(name2.slice(2));
    return [event, options];
  }
  let cachedNow = 0;
  const p$1 = /* @__PURE__ */ Promise.resolve();
  const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e2) => {
      if (!e2._vts) {
        e2._vts = Date.now();
      } else if (e2._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e2, invoker.value),
        instance,
        5,
        [e2]
      );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function patchStopImmediatePropagation(e2, value) {
    if (isArray$2(value)) {
      const originalStop = e2.stopImmediatePropagation;
      e2.stopImmediatePropagation = () => {
        originalStop.call(e2);
        e2._stopped = true;
      };
      return value.map((fn) => (e22) => !e22._stopped && fn && fn(e22));
    } else {
      return value;
    }
  }
  const isNativeOn = (key2) => key2.charCodeAt(0) === 111 && key2.charCodeAt(1) === 110 && // lowercase letter
  key2.charCodeAt(2) > 96 && key2.charCodeAt(2) < 123;
  const patchProp = (el, key2, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
    const isSVG = namespace === "svg";
    if (key2 === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key2 === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn$1(key2)) {
      if (!isModelListener(key2)) {
        patchEvent(el, key2, prevValue, nextValue, parentComponent);
      }
    } else if (key2[0] === "." ? (key2 = key2.slice(1), true) : key2[0] === "^" ? (key2 = key2.slice(1), false) : shouldSetAsProp(el, key2, nextValue, isSVG)) {
      patchDOMProp(
        el,
        key2,
        nextValue,
        prevChildren,
        parentComponent,
        parentSuspense,
        unmountChildren
      );
    } else {
      if (key2 === "true-value") {
        el._trueValue = nextValue;
      } else if (key2 === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key2, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key2, value, isSVG) {
    if (isSVG) {
      if (key2 === "innerHTML" || key2 === "textContent") {
        return true;
      }
      if (key2 in el && isNativeOn(key2) && isFunction$2(value)) {
        return true;
      }
      return false;
    }
    if (key2 === "spellcheck" || key2 === "draggable" || key2 === "translate") {
      return false;
    }
    if (key2 === "form") {
      return false;
    }
    if (key2 === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key2 === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (key2 === "width" || key2 === "height") {
      const tag = el.tagName;
      if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key2) && isString$1(value)) {
      return false;
    }
    return key2 in el;
  }
  const positionMap = /* @__PURE__ */ new WeakMap();
  const newPositionMap = /* @__PURE__ */ new WeakMap();
  const moveCbKey = Symbol("_moveCb");
  const enterCbKey = Symbol("_enterCb");
  const TransitionGroupImpl = {
    name: "TransitionGroup",
    props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
      tag: String,
      moveClass: String
    }),
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      let prevChildren;
      let children;
      onUpdated(() => {
        if (!prevChildren.length) {
          return;
        }
        const moveClass = props.moveClass || `${props.name || "v"}-move`;
        if (!hasCSSTransform(
          prevChildren[0].el,
          instance.vnode.el,
          moveClass
        )) {
          return;
        }
        prevChildren.forEach(callPendingCbs);
        prevChildren.forEach(recordPosition);
        const movedChildren = prevChildren.filter(applyTranslation);
        forceReflow();
        movedChildren.forEach((c2) => {
          const el = c2.el;
          const style = el.style;
          addTransitionClass(el, moveClass);
          style.transform = style.webkitTransform = style.transitionDuration = "";
          const cb = el[moveCbKey] = (e2) => {
            if (e2 && e2.target !== el) {
              return;
            }
            if (!e2 || /transform$/.test(e2.propertyName)) {
              el.removeEventListener("transitionend", cb);
              el[moveCbKey] = null;
              removeTransitionClass(el, moveClass);
            }
          };
          el.addEventListener("transitionend", cb);
        });
      });
      return () => {
        const rawProps = toRaw(props);
        const cssTransitionProps = resolveTransitionProps(rawProps);
        let tag = rawProps.tag || Fragment;
        prevChildren = children;
        children = slots.default ? getTransitionRawChildren(slots.default()) : [];
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          if (child.key != null) {
            setTransitionHooks(
              child,
              resolveTransitionHooks(child, cssTransitionProps, state, instance)
            );
          } else {
            warn$2(`<TransitionGroup> children must be keyed.`);
          }
        }
        if (prevChildren) {
          for (let i2 = 0; i2 < prevChildren.length; i2++) {
            const child = prevChildren[i2];
            setTransitionHooks(
              child,
              resolveTransitionHooks(child, cssTransitionProps, state, instance)
            );
            positionMap.set(child, child.el.getBoundingClientRect());
          }
        }
        return createVNode(tag, null, children);
      };
    }
  };
  const removeMode = (props) => delete props.mode;
  /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
  const TransitionGroup = TransitionGroupImpl;
  function callPendingCbs(c2) {
    const el = c2.el;
    if (el[moveCbKey]) {
      el[moveCbKey]();
    }
    if (el[enterCbKey]) {
      el[enterCbKey]();
    }
  }
  function recordPosition(c2) {
    newPositionMap.set(c2, c2.el.getBoundingClientRect());
  }
  function applyTranslation(c2) {
    const oldPos = positionMap.get(c2);
    const newPos = newPositionMap.get(c2);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
      const s2 = c2.el.style;
      s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
      s2.transitionDuration = "0s";
      return c2;
    }
  }
  function hasCSSTransform(el, root2, moveClass) {
    const clone2 = el.cloneNode();
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.forEach((cls) => {
        cls.split(/\s+/).forEach((c2) => c2 && clone2.classList.remove(c2));
      });
    }
    moveClass.split(/\s+/).forEach((c2) => c2 && clone2.classList.add(c2));
    clone2.style.display = "none";
    const container = root2.nodeType === 1 ? root2 : root2.parentNode;
    container.appendChild(clone2);
    const { hasTransform } = getTransitionInfo(clone2);
    container.removeChild(clone2);
    return hasTransform;
  }
  const systemModifiers = ["ctrl", "shift", "alt", "meta"];
  const modifierGuards = {
    stop: (e2) => e2.stopPropagation(),
    prevent: (e2) => e2.preventDefault(),
    self: (e2) => e2.target !== e2.currentTarget,
    ctrl: (e2) => !e2.ctrlKey,
    shift: (e2) => !e2.shiftKey,
    alt: (e2) => !e2.altKey,
    meta: (e2) => !e2.metaKey,
    left: (e2) => "button" in e2 && e2.button !== 0,
    middle: (e2) => "button" in e2 && e2.button !== 1,
    right: (e2) => "button" in e2 && e2.button !== 2,
    exact: (e2, modifiers) => systemModifiers.some((m2) => e2[`${m2}Key`] && !modifiers.includes(m2))
  };
  const withModifiers = (fn, modifiers) => {
    const cache = fn._withMods || (fn._withMods = {});
    const cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
      for (let i2 = 0; i2 < modifiers.length; i2++) {
        const guard = modifierGuards[modifiers[i2]];
        if (guard && guard(event, modifiers))
          return;
      }
      return fn(event, ...args);
    });
  };
  const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
  let renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  const render = (...args) => {
    ensureRenderer().render(...args);
  };
  const createApp = (...args) => {
    const app2 = ensureRenderer().createApp(...args);
    {
      injectNativeTagCheck(app2);
      injectCompilerOptionsCheck(app2);
    }
    const { mount } = app2;
    app2.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container)
        return;
      const component = app2._component;
      if (!isFunction$2(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      container.innerHTML = "";
      const proxy = mount(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app2;
  };
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function injectNativeTagCheck(app2) {
    Object.defineProperty(app2.config, "isNativeTag", {
      value: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
      writable: false
    });
  }
  function injectCompilerOptionsCheck(app2) {
    {
      const isCustomElement = app2.config.isCustomElement;
      Object.defineProperty(app2.config, "isCustomElement", {
        get() {
          return isCustomElement;
        },
        set() {
          warn$2(
            `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
          );
        }
      });
      const compilerOptions = app2.config.compilerOptions;
      const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
      Object.defineProperty(app2.config, "compilerOptions", {
        get() {
          warn$2(msg);
          return compilerOptions;
        },
        set() {
          warn$2(msg);
        }
      });
    }
  }
  function normalizeContainer(container) {
    if (isString$1(container)) {
      const res = document.querySelector(container);
      if (!res) {
        warn$2(
          `Failed to mount app: mount target selector "${container}" returned null.`
        );
      }
      return res;
    }
    if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
      warn$2(
        `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
      );
    }
    return container;
  }
  /**
  * vue v3.4.21
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  function initDev() {
    {
      initCustomFormatter();
    }
  }
  {
    initDev();
  }
  const _sfc_main$j = /* @__PURE__ */ defineComponent({
    __name: "index",
    props: {
      containerWidth: { type: Function, default: () => window.innerWidth },
      containerHeight: { type: Function, default: () => window.innerHeight },
      x: { default: 0 },
      y: { default: 0 },
      clickBalance: { default: 50 }
    },
    emits: ["click", "change"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const emit2 = __emit;
      const props = __props;
      const { containerWidth, containerHeight, clickBalance } = props;
      const draggable = ref();
      const posX = ref(0);
      const posY = ref(0);
      const initialPosX = props.x;
      const initialPosY = props.y;
      const onMouseDown = (event) => {
        const startTime = (/* @__PURE__ */ new Date()).valueOf();
        const startX = event.clientX;
        const startY = event.clientY;
        const shiftX = event.clientX - posX.value;
        const shiftY = event.clientY - posY.value;
        const onMouseMove = (event2) => {
          let newX = event2.clientX - shiftX;
          let newY = event2.clientY - shiftY;
          const minX = 0;
          const maxX = containerWidth() - draggable.value.offsetWidth;
          const minY = 0;
          const maxY = containerHeight() - draggable.value.offsetHeight;
          newX = Math.min(Math.max(newX, minX), maxX);
          newY = Math.min(Math.max(newY, minY), maxY);
          posX.value = newX;
          posY.value = newY;
        };
        const onMouseUp = () => {
          onClick();
          if (posX.value < 100) {
            posX.value = -10;
          }
          if (props.x - posX.value < 100) {
            posX.value = props.x;
          }
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        };
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
        const onClick = () => {
          const endTime = (/* @__PURE__ */ new Date()).valueOf();
          if (endTime - startTime < 150 && Math.abs(posX.value - startX) < clickBalance && Math.abs(posY.value - startY) < clickBalance) {
            emit2("click");
          }
          emit2("change");
        };
      };
      const getPosXY = () => {
        return {
          posX: posX.value,
          posY: posY.value
        };
      };
      const setPosXY = (x2, y2) => {
        if (x2 || x2 === 0) {
          posX.value = x2;
        }
        if (y2 || y2 === 0) {
          posY.value = y2;
        }
      };
      posX.value = initialPosX;
      posY.value = initialPosY;
      __expose({
        getPosXY,
        setPosXY
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", {
          style: normalizeStyle$1({ left: posX.value + "px", top: posY.value + "px" }),
          class: "draggable-wrap",
          onMousedown: onMouseDown,
          ref_key: "draggable",
          ref: draggable
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 36);
      };
    }
  });
  const __vite_glob_0_0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD4AAAA6CAYAAADoUOpSAAAAAXNSR0IArs4c6QAAFGNJREFUaEO9W3t8FNX1P+fOzO4mQHlLkp3ZhJdBsdoK2mptq1IfgFCtiq1vrNndIGDro/bnK4D92Y9WpVUx2Q3+EOuvKrSCooLagm211Ael1gegQJKd2Q0ICvJIdndm7vl5J5lls9lkNwi//Sufueeee7/nnnvueQXhKP5GLdHHplPS6OwlkIBylyQEdL8R8lRJv5INW68cuu8obu3QgkdkESJUoztPZdwaziWyPQps3T5T+0TwrlrS5IMDUGV7fQOAUwkQlABCOxD7nMDcY+xQd8J8tARdOskmMGQDGSFD5t3QEhreekT2l8UkI+m+Mp4QeVfZDeVBG+hEc598k7e/dZbNgEoU6e2t15XvEvwCDfFzAGgiAHFgkCRgTYR8H3ClHZjZDlwpATSHAMAQibCMgBQgILsEF8evUT8TPMojzSfLyFSylR1Gbfnbfd1nT/SHBTwQiZ9BxO8FRk0SsbWc7ESsNbBOnFiXhUgoMXZT7YKbzzOvMrKrnLP0qRY39dZQ1b8K8ihA0DfgdST7y+N1jOEPGIffc2Ybx5ysrd4wEc2vupFi51c27hhpk3lyKUl//ThUsbvYebl0RQNXF+tDGMcocdgPjL8ip631TbNHtfR1YfUhvcQ3SO6fTFke2WcdHJr+7OCG0MRuglMb9ROZDZNtMNfEw6Pey10n0NByDpG3Va8t+6CvexD0RQGveqRpnO2VlyLHlSRhc3qv9MLOW8sOFlpQGCqe8nyXkM5DJB0Q42BjygbazUjeD8iHAPKnASjBiD1LAO+hbRotN1RtcnjXEVPLjfMR8RtA7A09XPG37DX90aZvIMqDjBrt9UJ76fOJBx7fMYosa7kE0sMWWvuMGnVlr/e2jmRVNaYjZ1MB6EwAKHEW5XwJMc8zBNYwiUM/5xuDoQTwa+cE0L6aAxuAhIsAsYUQ1jCbLY+Fyz9yDGWk5QzO5Ek+iT3mGk/xfUyjoSaJTjHi6vMwH3mxAuj1xAXTFKfnANkTBOxDI1j+194Yqw36FAZ4OyGMykP3jmym57a1l+52tUWoM3JcI2gJaQ4SXg4Ap2XNJSBc4bHhvm03+HWhQZTyzOYSvqXXVPzdpRvxmx39PAPs6fqQimUwA+1iwPcI3LnTNq5inD9lM2mbHvK/2hND7fHERDSpjpAm9EBjEcBqI6SGsse1R2IV4GHXAvKhejBwcyBivEkAI3N5EEAaAJ/w9fM9JBybQL1xAUlSQB9UFnGBOtfKUi6I1ah//ErAtYjxBBJtAsKmWK26rCdmlRH9eg5YBwBSNo3YLAJfwRlbZe2V3yrGJghBoMymAYNpBHBynnvZRKBcrYdGbBv56PZKS/FcrQ/23+uCH9m4c4RtJ0+MhStfKwQ+74lrUeNaILgICJ/RWyuWd3ufAUA4MJ9CmbifQj0zP0LYjwQN3AdPuk5IoU100YLHExMtbjpvv8Sl2xDgjK4CxX3AeFgYtKr6pipinktbQv7fuDSBaOt4y055ErVVG3tbtxvwkY9trzYlzzJG8CBwe1VsVuWeXAbV9+0a0DYo+SQAfqvrGK6WmXx7U82InX0Bm0s7Kmoca3KcABIaYAMC8oXCicuiE1/v0oPqE1r9jhMA7e/pYf9j7rgabf2+D+1tW2tUo6d9dAMeiBp/JJDWWpT6Z14PqY5YoCK+lAAmuUydO4h0sxHU/vRVAOfOddRZ9p5NbfxV7E/3ArFzuhg+zq7Tayteqahv+Y6EckAP+5/OnHyjcUlv970LcLVRP5NxvMNmEIn3YCS0qHEnEMzK2sBeAnmmESp760iCzvCqI1krT1yKwN7jzLoMCWsyYwgHmWlNF+++1hifKclsXfPM8mYxPrJx+wibe8fGQv438u3rEHAi1KLGGkR40SPLz2S/lRkpRoxLCeB3mZNG2C+Z1oUZh+OoIO9g6o8YZ3Fm75OITe8KnnTuxSnx7f4vNH/8l3pQ/VVmvw3xabHWitX5bFQGuD9iTJUIwiThYr3G/3w3tWvcOcLi5j8yDgmAzQGujofUdUcRbxfWWiR+rpROx2xFmQMIFx0a5Cv1UGBWxaLm0yVZ6e8+veJ99w5MnYbo3dZv4O74RzNOSLtzMsC1iPE0A3wTwPOnfPGvFjEeyLHg9+ghtf7/C/Qhw6VfBIr3A5ZKLyWEqs7vRIwmGzXafwIR/ZfMY/22eebIpBjTorHpyKUZnPEV2TbIAT66fusxafT9RZL5Xc3XB1Z2s7JL9LFmGtdm3mqED/RB/snFekkOv2UkeT/cOgnAOgcQJwJBGSCUEuBeJGpGwPUcUyvT807cXEiY4rnlPL2Roeclx/EVnh/AG0ZInRF4rGWwJSmpRKiiTXyvWvRpmaWkLkXOTtPD/szT6wAP1Bshm0E1Mnohn8MvnBkAOLdzQ9zm1rRC72T25kvu3nypzeAXCOAvBAoQ3iDG6tJ3HdsRqOT5CWtvepWRyNnFAHRxxuYwujzf/qsiiQst4L8mH5zh+hYOcC0SX80AXho2oSKSG1s7CQBIbcisj/CKHlRnFgQAAP3nvXeMid7HgOD0YuizaGzG4JF2u/qBngKPQL0xQ7ZT/04rvtdQZG7ED/lrejBwTe5aakPifAQ+jZDeNELaHxzSikiilCHfSDbcHK9VX8ydpDXEZwLSf2e+E/txbniYD5Rnwaavgw1LEbGsj6APyZhgbRIPBGHeREdtu/zqSIZ5YGtRfREAu9AZI0jZyMa7au7SC1eYeaXLOYcqPeyf7QD3P2Z8m0l0GxE0GmHt5e7AjWcB4bsOMUBTLOg/o1A6SYBGG5cBwsBuG0Z4Q7i0Xm964xf9Stq8n6EGzJoKhHMAqLS7kHB9CvZflRd8h7aeC0DiKnZgR/qpEdRW5/IJRFquIWRz9KA20cGiRYxaRKnSRFreWlNxSKVFrPvUZ19LHky+76oSB1gcD6l393aCvjs+quQyvoyIg3PoTCSqS84btzQjuIf+UQI3nd4u6Hx1m6oIcREAfDOXPwKsS1L1VfnU/vhlH3j27Rn8HwT6Wseh43Ij5L8xn7oD8vt9ijRJ+CioRWINDNgnEpQu3h4a8oWY4G8wTouH1fVafeI8YHxJIWlmFqn7oL8X5VUAUN1NOIQPpOZXPwS3vNfPN8B3B+f8h0I4RNAsESxsXzBuubAJafKsyyM0QMKG5PzqBfmErkWNpUDguLMEuNMI+bsJz7nnzA6TLd8rsrWoRfWVQPJreqhcSNv5BSL63FhIe9hJLBAyLuF0JJtLlm+eR7asnpJ83rotDwPSJXnUdVOKEucBnMm9sGUFIJySRzDzUvOroyV1my/hCA/n1Spk16Tqju0WcgYajP8ihDnuHG+qfdzWuWO7FCREqpszmooc1+th/7OoRfTXgdhSPezPnKwLPFCv13AJDInYaLSUP7LS1AAzqXjzJfi8dR9NAWSL826Y83tSC46v98zfchESZQScQ5tKtcGJMLo66W39+CMA6khPZf0IcJePzLP2zT/h8+zvaqP+I+T4KAC0A+KnhDwknJlsmvLGxASJ0zQG/HNxqKhG4hsZsHtjofLluSeuReKPA9Bk5zvCFs7hdo+kbM8XdnrqNr+J2D170jEVrkzOG7fWN3/LvUR0bV7hCE+E0cXtdx+33jtv85+/dHmOz0fHEH7XXjfuvuyxCe+S8tn7zRJPKj9gPvPPtuU9JTs1JWgrFzUfxyX5YgSwY2H116hGjGaJpFkt4XLHog9f9Gl/n8e8VK/xL9Easiw6oTB80eHYuiZfOrg44JvvIoLanoBz255q3jN+Y1+Aj3n5E+/Wt8bYI9WmoSZXJvkU+bVUik52wtVIotR92kYvimtpma4CgFI9pN7pAAdTmmXM7gAuiBWwL28JaYuFCvkA304DfNvT3v5qu7fku2UT/K/mKyAUo+q+BZu+TxwzMXMXNUbYnT7Omgh7xlNfVF0TXhkzdZlLwqh2/DibKYC7V1Z8crw9j/caBOIighN3/ENC6U4jWLEiV9UDIqwL+1eJ5F6sVn1RRD9eD9/WVDMqb4aloHGbf5blnffxQgB+WZdTR7SAs+tT88e+2lfjJoAjmgeIpCddngj2jFio8o1AVJ8TC2qPiO+BhtbjOYOrkfOYyNYI4G8DsYVdshdZVl04Na4ARFqKKz7WUlOR348u5jkTce28jy/nZF0IwCoQ8UPO+KPpu497/3CeM60x/kOwwQdIIj3l/Bhjk8Qes09crW89FdG+BgD/1mHVo/pKBPaXWNDvSMaRTlS/MRbUfifePiNcsUaEdnow8IKTYMRjJou/e7qnfXJgspgcrgOjRvWLkNN4QOZmhUjymKNNpvTDFJ1vBLX/Fcs4PonEL0ewfx8LVv5ZeG4LEbBV4e1PbKsd86lDFDF+rofUhVpD4nuSN/Uf25S+J8AKQ5I0fBcUyq0dpss6F4A6qi5d70GPLuuYhz/5WtpTKhKec92cPgI2x0L+08UJE9ksPkv9p2DnODDI59rcukNElijuAQcYxk37lcQNVSLDAmpUv8Iny69C2YF9Kb1kNhCcSgjHIvK1iGx9MUn7ox6kdIKhEv4OJvFfmQiN8yV6beCOykj8Bt9ez5Nbbhu+3znMaGw6AHsw/YX8DZHjx/LGlgmKLY3nQLvdIEWkd1MEY+Mh9SUtGl8MRFPEZCLYVzJAntK23xohXNqe1N39fjTD0g7NTFxIzGadzouzLALOEAlGLWL8Sjxb7l60xcbP0YKzY2F1Wgdd50+4p5nozEk8xm/SQ+qDgUbjEuJZLiRnIkwdJAxEIeDOOBGW1G255EgmIgRbkSewIDWOAfwMoMMFFgdjtPpPEG86t71XtYT9Il0GoxfrY0wuXQec7xfOS1fg0dbvp0xpw64bjjngGLiIPpd5rKgInOy0Itw/2ZmAsJHb0nyPZO/dHlQ/Lgq8IOqWeqJyQCw5nNSTex0ZyP8msg/57oTPiXg70KBfSehZL0pNglYkUhnQ9UDSQjeXkDlx4fZ9uiFxlpuhrFrSWsXT9imxkLpcjcTvR6ArXZAcoEYiGBoLq5m3s2gBHAFC8awmFam/QtIvieA7nSwJuHyeiCMCDfptsbCWcWu1aPzHQLSADtJJxk2aEwZ3KSi4joqolBrXa58HIvFfxEL++0Vy3uKeN4W71zmpiXHpCpIRW2rKmo4AlqJZiPj7wJ5BPyGGe4HToSxv52mrkR3fQrAHugco1Dxt07WErL8RVMW16LQFWUuKzgeUiCxZrhZdRiiTl3Mui9y5EAIBZSYSwrJsRkXv/CsSOhUTK73OYsrzCDC8826bXhvPEDV0rSF2px4OZIoKlY2JH9mc34Vcvio7quxWOxOekH59xQv+SHxBPKzepUWM2wcM3vvArl3HeLxy+k13sQ6x4U160P/MV8RS9HQ1ql+spM13LUWJAuDX3YmE2GAE/QvUqD6Z2/YONwMs0uYpKLkWGT9ND2lZBYg8PTBqZMfXEbANKTnKliSbJflmlHFqrFZrFPk5lPDZzJsJYAHy2b15ckWjKoJw1LLPB5p72oRren6Wyv6r/+C9PyrZk6TdUP6z7JKxGk2I+D9IxB/JzSfmrY8LyQrvTI3q8/vt8T3QPqjtJOH0O9besZh4f9Y+bWJ0o1GjPVfE3g+bRJSmDw5KPZ5TL2/18ORk4XFWNsRv4ab9B31OICEWEe2klsUuJqKz8xU/8gI/NpIY1sbsE8iD77N2Xpt9ZwRT4RwAwHXZKDjB4wOH7L0nuz512ChzJjogUthACMcdGqIkMbjQKRs16FeakrQpkywVfsjixLXA+S3AlcvyZYx67IERNWePzxPnKT6WM97fCGqZsBVE6dav3wfEfpK9RyTYZJF1S1+qLL0Jp7PrYjYB3IgAnsydBtwHyEKiGUk0ASDyQdmFTi0anw5AFwHn23IPLa9Vz92E8G+9pf1eT7UdvIRztinXTe2p/0VUNIg8DxihsvcP59RFEyD2x8uQQzCrMOg+Q5k+GJH+Th1svyK7eCnawpCxarLxp8xrnu0WD3P3UbDBTzz++qCK5YHPjVvQtl/IrYULiQO3I4jg5LW7aADAh4D0ogy4enuN/5NChQgxV/gQaKOwJ4O6CY3g7wqWBt00eO64eI65Ik8kxNstsK7sree1IHDRRmWZ8lQjrq4IlBu3EpPX6sHyd7IXFd1GFjdvBQCRWenS/ZRF1w4I24DjSm+67amkz3czcigt/cK3wI2gBK3TXzM4uQ4IK7LmtgLh/Z2NSHmb+Mb8T+vwdNKewiW4CQFv7a09TfAtCFwQdZZaTxNdjVokUQuE20ROK1fiwgiZabwjq7La/dAQXySeWsTQ45R5hDpzJM6AScQAOdIBmcM3OcDNBLhPAngUPenFPams4OF0NwKdyTibBUj1saD6+0JXrCjggomTfVXMC9JfSKuUgea5siJvdPtNchcR+S1EPpWIzu9qiUVtC5YhsdcBeEeXEsNa3ahYJcpDIl5IbIydKFvKMBEBKliypie1dtf0N2w/iUny8WizGxBhRUtIfbAQ6KJPPMNINNX6jR96TfaucA+LWWBUJB6wGT+HczoBiI0mRqL/7OMvz/puIGhDgKe+bOV0ojyScC/tt991A4lC/P0NxiRGoAHCzQjwm74ETUWfePYmHINGmDxqnU4FEDvtm2llGiLXbJKuIptq3RRTIWG544cFXEwWeWrb6zlFgvTfe0o3F7uJvtCJFLfMpPEg4TlENNDL8Ke9NfL1xPuwgbsMneY6WR7msdrXu8nKvgApllaLtp4CwEdzpInI4dwvnZbf6nHtyXytXMXw/MrAMwIQJyEpQzmxnUa47J1i3uxCG3Tq8wdSpzPkIwiZRuT0u6xhtnV/vlbTQvyyx48YcJepEwqi1+k6YIynfaT8u+j/HakjVqm2Vtu2PRIZyYykak7wTUB+EgF7QbFTTzTNGrWlLwCPmqr3tgknnfVe60lkwrCMUenlH+4YkM0o/Ulz7chmx9/mdAUge9qrHVy9dcrY1JEA7PL4P0BKP9EOzx1wAAAAAElFTkSuQmCC";
  const __vite_glob_0_1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAUCAYAAAB8gkaAAAAAAXNSR0IArs4c6QAAAmRJREFUSEu9lk9oE0EUxr8vSXdDGw/qQVEsoug2VSgUUdBLvHgw4sEiilDx4MmTij3Ug7NrEC1WPIlHIaAFwUs9VEEK8SIEEf9Ek629i0K9SEsmafbJpramycYkBTunZfd783v75nszQ7QaTyVsfnaTgJwAQocJ2SZEDOBPiMySzHioTJTs/lyrqfgvQdR2zwskBaC31UQApkVwpeT0fWymDYT1qNzWRUYmACTagPyVCCokbhfFUnDo1cc2wLrUl8EQQpMgtncEqhULpnRMn8bIwHzt61UwHxRG6JUQGwNA0yDHjS4v+0tH5w2WdoIyRA+jIHoa9IKMjulkLXAFZip3l0CyJDbXBZYhvKztvQ9BSvWb/bYb9oEF/9FMfd3NSuWJAAcDEnyhxUoul3QJNlbYYC7wDSj76gNEqEqOdRMqFzMZGRPBmaWEOEsgVbSttL/GZURyAYkCwnvasa7581Zhhl1IExgOKMUnjW+DQMIz4b4GcaRBQ17VyrofddxhEUkHrjPlpFbx5zRU/hTJZ8FmkBFtx8cNO3+O4OMmhilqCW8BdNFkZA7we7DBh98NYD9NVZgBsSc4Ix7Xypoy7cIDAJea9k9IEsUb8YypCu9BDATpCNxqF3YXQLXuQcMTHio7VrYlrJ0ymip/DOTLJqwfelO4F3NaWpaxLYM4RxcN231EyIU64CIEQ9rpm2zLIG1bH0BUuReFchbADgg+ePDulJ3+dx1Zv9qcnTR1ze913tR/gte0XQmuA+gO6NHm29WyeN024mXguh0xK+UQYdSZGf7vh+eq+tddC0Dxz7metVwLfgOjjkjgasCi0gAAAABJRU5ErkJggg==";
  const __vite_glob_0_2 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20width='14px'%20height='10px'%20viewBox='0%200%2014%2010'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3ctitle%3e图标_眼睛%3c/title%3e%3cg%20id='页面-1'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='AI投诉助手2'%20transform='translate(-1896,%20-197)'%20fill='%230780D8'%3e%3cg%20id='编组-2'%20transform='translate(1884,%20183)'%3e%3cg%20id='图标_AI投诉助手'%20transform='translate(3,%205)'%3e%3cpath%20d='M15.6666667,15.952381%20C16.7712,15.952381%2017.6666667,15.0569142%2017.6666667,13.952381%20C17.6666667,12.8478477%2016.7712,11.952381%2015.6666667,11.952381%20C14.5621334,11.952381%2013.6666667,12.8478477%2013.6666667,13.952381%20C13.6666667,15.0569142%2014.5621334,15.952381%2015.6666667,15.952381%20M15.6190476,11%20C13.9622723,11%2012.6190476,12.3432247%2012.6190476,14%20C12.6190476,15.6567753%2013.9622723,17%2015.6190476,17%20C17.2758229,17%2018.6190476,15.6567753%2018.6190476,14%20C18.6190476,12.3432247%2017.2758229,11%2015.6190476,11%20M15.6666593,9%20C18.1111688,9%2020.2919306,10.5426563%2022.2042964,13.5563477%20C22.3763456,13.8271094%2022.3763456,14.1728906%2022.2042964,14.4436523%20C20.2919306,17.4573437%2018.1111688,19%2015.6666593,19%20C13.2221499,19%2011.0413881,17.4573437%209.12908088,14.4436523%20C8.95697304,14.1728906%208.95697304,13.8271094%209.12908088,13.5563477%20C11.0413881,10.5426563%2013.2221499,9%2015.6666593,9'%20id='图标_眼睛'%3e%3c/path%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
  const __vite_glob_0_3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD4AAAA6CAYAAADoUOpSAAAAAXNSR0IArs4c6QAAEXdJREFUaEO9W3mcU9X1/577klkAWSwIk7yXGQTLT+Wn1qXu0lZaN1QUAcUFFyYvgEur1q0qWK1b1SofkCSjoraKohYU+3OpVvm51LrU1q1VVGbyXgKiVgaFWfLePfW+yQshEyYBZ7h/zSf3vnPP9y7nnvM9Zwh92OqbMrtKiTGbTcHM3aYkIv83Zrc9UO281nzWyHV9qBryE/bKJMxk3LX6EHLlcCnY1Uj7d0tj6F9Ktn6bVUu1PIqgDQKhHwP9CNhIjC86Bb5cnQllcA05ahz3pwOIeYgACVfDa+lG3e4V/QqEbDPwfRJvBj/n4RdKon06nKqza7XOI6VgDlLVy6sah3+m5ojE08cy+EAQJIA2MH0M4a4DBTYq0Ao8szsUwFDBCDMoCICzQe2ONWfXfe4tWMLaXxDVgymTMsMv99YCbBPwSNw+XBLmE7BSA56SBCuVDj+tdqzoWBOIuh/tctozd/su3GTrgukQZrnKNo2/lRNRrn/rgM/hgB7K3ErgCQIUZ+KWAYPXLftgytjOchP1Vr8et3YBsH81B5/9ZOaItdsqt2LgoURmqEbyEUhuheAnyOEXU7PqP93aiUOJTL9qoe3QLp1qTZPfDHc/+/otc99ssZxIU2YflvIEsFxmxSJvdutP2hPIpXTLzPDbW6uDGl8RcGNhaiyEWA7GYtbok47O4MOfz97pm3ITKkMl+onxIBzH4GYipMBol8RrNVesZ8JQJn4GgEXM9wLiTUmy2TaNdz3Zc1jodfZEkNhPMP6SioX/XDinkUztB2BHKxpRMraqlQUeTtrfF4znNWjXO3Ba7ai+uMd7q65D2J5KUkwC8REA+nVpxPMFxCKX5U4CNMD7hTAMwJ3qbwFMcMGDCPQAgE9BWCYl7k/H9H+q/vom+yeScUyAgjf7xlP9PvKuTH3WdQ+2M/pDuIaUEa2o9Qi8S6hcAUELSOKflhl+tiepetw6kYhuAPD9buMIr5DjntHGtWv905I7zt4xZubTiWgGgHEF3zIxPShYXNk8s6656wThMgjxUioafs4fN2zB2gHVWnaqvWPoXkwhtxLkWwTu3WnIVwXLpBTaR1Y0/MSWBNYn0wdJybeCcMAWxjgMLLVNfUphf2hB2hABzCKSw6yoMcNI2B8BUMaruHWok6FVZX+tHJtI3D5JEu1sDwnd6gP1FmUAnZSK6r//TsCNhP24AN5lYGXK1O/bkrBI0rqAmW4FoBWNUco+yMSPdGSrX6rEJqiF0DSeDIJaoP1LzLnSdenYzKzwh5E7W3ZmIWZaO+qX+eCNu1MhcsXeqaj+ZDnwJXfcSKZnATyNJS2yV4fu6/Y+A/AcGNTdyWB1PAtP53qAbskGtbjvhJRTorBfnR6H2LurJHEdAYcXfd8KklOVQTMSqVGAmG6Z+tX+mHDS3otcrrJnGq/3NG834JFky+7M2vNgzJUOHkmfq39ZLGD0vC8HdlRtfBJEh26OmZYi6J5rnRPJbA3Y4rGR+OrdJOSBQqAFEsTE9ygnrmCcC6LzrWj4zvqF6R+4AuNtM/xbv99IpH8W0OjDVTNCLVvSoxtwI2m/wExPAXJFSQ9pDotIOL2cGUcXCO1g5hl2zPjDdwHcbQHUcdYCRzltWB6o5fkAji08WmA6wYqFHw8n7B8T0852LHy33x9J2qf3dN83A24kU0cQixtdwm3pLRiJSMK6mUG/LFDgPxBiotUYeqk3QedlqeexLjOdwW8KwpkAfl4wzzcMPki9+3oifS40+bQ9w/hY9dcnmuuYA7ulYvrzpfTaBFxFVsn0m0R4VKPgPYVvZX4V4/YZTCgwdLyegUPyDkefIO8SqsetI1mjdUJiahH45mxQ++GalhFfRUL29SnTuCSvb8KenMqEl5ayUXngetKaJJguYqJ5VjT8UDEGZTHhiJWbHBK4zDzBjhlP9yHezUQbyfRxcN1PIbTLlfHNdxIvtqLGNH2h9SPSxED/6VXve79A5ziX+aOazvbUx+fvol4ar+WBGwnrGYJ4wRX8h1LxbySRbtrMghP90oqGb9leoP159IQ1zRW1bwdku/IrRud+ZxJiv1Rj6C0jYf+GN/B19oVGm+qLJO0pzDiTmR8stEEe8IYFq0a4geA7mpAXNDdGFheD6WJSpPKfvbeagbftIeH9KvWSentxvOdWuq+DhApPRU6n521THx+eb3/PGRho/+yMERu8K7LQCrNGZwhJ46xY+MjNdtyI2xcy0e5E7pJSDr9yZgAcl/tIsuQDy72TvQ22UJ7nvARoF2JxGgOnbTry8shS+jfE06e4xAuyQW2M71t4O24k0m8Q5GMDhrTeVhxbewSAhFVwnx63osbEvgRWiexIwp6ODvcNrtb+AUAxN6ott0zd36C8GCORmQjwZIZ8wTaNu7w7Pvz+Nf2r2rIZyXROOqY/WjypkUjPVpFV/ogw/aw4PKxE0V4fM4cDmAvXaLIfANMpOfntnbWBof4x9+dUrnAgKGdAilGpWNg7IWTEU4cBdB0Dt9sx44/dgdsqBh6f+32lFQ2P2SY6qdeRdwn0LD2zuopeY+IT7aixtDuO1ExAXG6ZeqQLeDJ9MYFGuVKq2PevhR80LFo12O0MKnrHO0rMuMOO6YUORB/BqVzs6HkrqzuqaxW5Ocj7inC/FdWndweemciQiaAI7qF8FDIS9kMk+d9geUdqVv1X6gM9aY2zo8YKI54+HsTLyq1m5Wr2zUg9bi8nwoSc9NWWqYdKAQfkRQS6XLG1CvhLzPSkHQvf5A82EvYVlqlfr4gFxW1LganEcFnyRdUIZr8LydcX0I24fT0Il/uyg+gY/Kk5qrVwLo/qJp4EphVWLLyIjIT1PiDutMzwgmLgkYT9c0ncIhhjpMTvtYA2EA7XbCvB1xegcyf0VGJSAdJGAGtIiCnKmSmcLxy3DxSEyQC+UJuqdjxDrF2WitXdXwzciKf/COITun6n95nkbNJ45XcNO3t7AXZb8l7VenuQJvrRMXIj/0kMEAcXUlPe4iSs/xWM0xnkWDH9CgW8XbCY1hILeRZ96N2f71DjdE63zfB8I1Fg0RmvEeG2YVizrBQd3NtgKpXXsGhVTXNzg1MfahnmQjsmKKqWO65zgApX1VPtP20NC1c3OEKagtA/FQ2f7wFnR0yzZ3cBV4Or27MzUlHjDj1pnRoU2suulIcFuOOJTqoaP3Bw6/LtmUAotwBGPH2K1HiVkNj0IjFNVMB9W6VkeN6eps0isFQRnAL+BUOcb5uhB0vc8ckpU39EkXupmP6oin404X7YYjasLqfQ9upXwAXxegnkeTYhcHhLo/6XSNK+PBXVFeuLcNzeUwgRY+ZPFVtDesJuBtO1hexFoVVXTk1ExbVqAZItu0sSmt1ovLO9gJWbx0imTwa4BoxF+WdX8J5Kx812PJE+hCFngujPVlS/13vOiMT/paIhb2VUMxL2ryxT/43ycS0ztEyFdqmovsQjGGnECervcgptr34VpgpgTwb5BATzBu7vDA4MCDjORDtqNHmY4unjWfAMjRFvMfU/kRG3F0HA1rLZBc2zR67JAb/KMvVrI/H0T2VAviUkjVdglSFxOgIn9Ta3tq2LtHPik0EO1xzG4CsKOP1PLFMfHVE7zK6wYpH/78KkAhV5BUs+V0WWpO4Bs9yJJT1uzzRezL2LjUGqeoIDG1udzqpLCXwIgN1A/BSBVlRK2m8roEq/U2CyQXolmHXTmyI0nm+ZxnmRuHVpVWe/hR+f/731nnHrIiTubneq6hTHT+Em+wDhYi8Gr/WDFI/eFc6udtR4zEjYjwE4MafMumAN9u/s4Drl0laqYF+NU4aNhRQ558WbhhjjFcEYSabnqWcrf32b7KtI4qiUqR/kjfM7lHuaj86YSU9mrrbN8DWKpmVG3rkB00QIHqIMRF8BqkSu4gnI5bEk6EowDvY3xsqEh6k3nVmLpWLGHPV7QyLzP0x8npTcqpyXzYArEr4tUPXXL84Z9nXunl/BG/h3GIhacklFP4GuJcXrxHQRWPwnFav7oBIl+2KMnrQaGfSGYOTz48T0gIq3I3Er6kixQqWacld3EklcQBDX+lxCfseV2/f1uiFH+gylfpc1Wjh0UCqm368n7AQBUR8AE59EkoZZMT3eF6DKyVTPqkvaDprE9Qz8ODeehaR9VBxhJOzrLFO/Mn/Mk+mzifl2B2JExgwpf37zwgDfUVGZ0owZ+sJI2tdaUf0qRc5LBBS13D8nbCU7fDQ0kB0z1O/breXi77NB9BWY88Sov9tGU+ZQsLqKXdlddcwlubOYaaBl6iohkTu4BSqrygfSVB2atruqMgKhRkoZUNy5WgQw8qv4bU7+vkJB2wu5ypgQ3KcA8YrysHPzdmpSG6Ny6JGEdVPKNC719alPZk6VLG8WkiYURpUlcmfpk63G0MN6MnO7bYYv0BPpG2o6Ns5d139wVa3ToXbXnwwgOseKhlVCb7s0PW6dJqR8lTXtEQB7F0x6q2XqF+tJ6wS4SPsMsKLNs1pwtgCPs2LGYYVKdgNen0jvnXWxIRDgXSTYlVnxXiDAk1KmfrvHz5FQlQg+q+kQ4dTt5clFHmgZwt+IewAqZHn/Vt3RNm5QdatcixHK8cqnjPVEZhqBf8EsbyjmE0vmx9XKKu/MSNi/q+6onZOtbdtXOf1qxZTFZKJEweq5TDzdjhqqdqXPmkpNt1e1LSXCTwomsTUnu5/yOCNx6xrHFXdlZoc9KlwlQQCc5kp5VKnkR0ngoxau2alT6/xBNhD8e1XWubjwznjgk+l5zHxeIUoGzavp2HhJYX6qt1Yhl8lR+bw9CmS2kRCHKqZFbYYLejdPlnp+iD2bQHOFpJ+WYoy2WAPj5Zw1toQjdpUkd7BNIx+2Yg4HjLAdB9M5ReDeYcmNvZVlUUHRWoy4DMCvAFQXzNUK0BRVjKT8D5Aq+dqU6DTi6akQ8hRifFi8aSWtevEOKf9WBLPPOh2B0yHwTrGb2kP9y3IBmttihv++LbuuigA14jPB/IuCxKAvKl8H49Hf2aoZhclLVRbG4LEs6TzewHv4ycNiPcrWuRnJ9NnW4NB9xlfpaxj8cHEu3Ftx8MMABpcQ/g8GHiXWlqbMEf+qJBGRq7ZSHteOJRbtOXLdKT4NXtzvPcdEBzHRDQw+uqea17LAVRkV+mGSvVp/0Ailf02SnkrNDKs3NN+8aiNHUwtzVonqJ3+cqlb+EKDFVWhPZlE9l5j6V3XWXOxHUGqgV19T3faeiiQLjRiYrra6CpFKFvGNbPpsuONkT4TAHBBFeypPU3LLAleDVKoVAuNUVaOezFxMjI8Up1W84jkjdGNBZrXbpjHhUZLyJpB4w1OAMVmCpSDlOpFgIdcLxv4MUgFGK4FvlBtwx5aOrJKhChE72T1CSLqEgN+mTL3w1Sl52yoCrr5U7Gut2zm5PRtcUh3oOA4aXvfrTYole/wWYRKA44sssRp6H5ieAXGXsSQ6xUqHlqidVPFCa+vgvYVLyknakaSzbEvH2p/TiKf2ZY32JA80L06ZxtxK7ErFwD1hqqg2ZJ8ckIFXlXtYyQT1TWtGsswey6C9GBhDwOtM/AExbgHoGwYlBbgryiP6ymF61Q8kysnX49bRBNHw7bGZC8bVWxM0bR3wnCaeQRPU1meVTmUQd9W00mQIbmCmGFie7FNM5RbL798m4OpjxVMjoB1M7Dy3PelmRXELQXuBcCwzBgc0cWJPhXxbWohtBu4LVI6OIBquZTtf9MnKSld9a8ZFFqYPZg1jmHAgJKuc+HX2an1hqVKuSuR+Z+D+JLmdGAbQ6lQ09Eolb3Y5Bbvy89U/AmQdg0YSWFUzLJNZXFWq1LScvML+XgPuC1WhoKMFPEJPI+oIyMAbFaeVlfHU7bFwMVoIGWDWxoLphyDe91uWdwmRuyAVrX9/awD22VHvSQn1PG1YN2RfybRTflwP/3BHzC6T+4FlRj7x/G3iGWC6R6vuXNp81sj23gDsy/gvAo+Ms0AiasEAAAAASUVORK5CYII=";
  const __vite_glob_0_4 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20width='31px'%20height='29px'%20viewBox='0%200%2031%2029'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3ctitle%3e图标_logo外框%3c/title%3e%3cg%20id='页面-1'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='AI投诉助手2'%20transform='translate(-1887,%20-188)'%20fill='%231D99E4'%3e%3cg%20id='编组-2'%20transform='translate(1884,%20183)'%3e%3cg%20id='图标_logo外框'%20transform='translate(3,%205)'%3e%3cpath%20d='M23.4377269,10.5632207%20L23.4346383,10.5569405%20C22.3943914,8.35012228%2020.4802714,6.62131935%2018.1830596,5.8145721%20L18.1751321,5.81138053%20L18.2327864,5.64634533%20L18.2407138,5.64943395%20C19.4133594,6.06063207%2020.4786241,6.69606393%2021.406857,7.53400623%20C22.3290157,8.36885991%2023.064004,9.36071838%2023.5934962,10.4806516%20L23.5966878,10.4883731%20L23.4377269,10.5632207%20Z%20M7.53638446,19.8594487%20L7.53185449,19.8531685%20C6.40893562,18.2707661%205.81386172,16.4051373%205.81386172,14.4567336%20C5.81386172,13.9054151%205.86225008,13.3540967%205.95717364,12.8167799%20L5.9588209,12.8090584%20L6.1316806,12.8401505%20L6.1316806,12.847975%20C6.0366541,13.3758199%205.989913,13.9162253%205.989913,14.4567336%20C5.989913,16.3661178%206.57242651,18.1961245%207.67351914,19.7488761%20L7.69380107,19.7488761%20L7.67969638,19.7582449%20L7.68443226,19.7645251%20L7.67197483,19.7645251%20L7.53638446,19.8594487%20Z%20M21.6888479,21.1115748%20L21.565715,20.9870005%20L21.5719952,20.9808232%20C23.3334345,19.2458431%2024.3037756,16.9299966%2024.3037756,14.4567336%20L24.3114972,14.4489091%20L24.4797239,14.4567336%20C24.4797239,15.7291416%2024.2273838,16.962633%2023.7321752,18.1230271%20C23.2525127,19.2441958%2022.5671482,20.2472762%2021.6950252,21.1068389%20L21.6888479,21.1115748%20Z'%20id='Fill-1'%3e%3c/path%3e%3cpath%20d='M18.5537248,1.5269308%20L18.5460032,1.52538649%20C16.4993814,0.988069766%2014.2941075,0.949153168%2012.2258654,1.41018101%20C12.0623745,1.44600899%2011.9018693,1.48492559%2011.7477472,1.52538649%20L11.7446586,1.5269308%20L11.7383784,1.51920926%20L11.6760912,1.27932652%20L11.6838128,1.27778222%20C11.8224917,1.24195424%2011.9626121,1.20612626%2012.1012911,1.17503416%20L12.0996438,1.17503416%20L12.1697555,1.15948811%20C14.2739285,0.690532815%2016.5228549,0.729552367%2018.611379,1.27778222%20L18.6191005,1.27932652%20L18.5537248,1.5269308%20Z%20M7.03338229,25.4008221%20L7.02720505,25.3960863%20C6.89017333,25.2948825%206.75777453,25.1935758%206.63628886,25.0940193%20L6.63000867,25.0908278%20C4.9354894,23.7312177%203.57433507,21.9666898%202.69438755,19.9887383%20L2.69129893,19.9824581%20L2.92490147,19.8781657%20L2.92799009,19.8843429%20C3.79239156,21.8249222%205.12708673,23.5568137%206.79041094,24.8898616%20C6.91199957,24.9864324%207.03801522,25.0845476%207.17669421,25.1890458%20L7.19069594,25.1890458%20L7.03338229,25.4008221%20Z'%20id='Fill-3'%3e%3c/path%3e%3cpath%20d='M0.384738957,17.8659408%20L0.383091693,17.8596606%20C0.341086477,17.6759907%200.302169879,17.4937622%200.269430519,17.3146223%20C0.0903935788,16.3786679%200,15.4176956%200,14.4568263%20C0,11.6207535%200.788112581,8.8545864%202.2801214,6.45925952%20C3.73156636,4.12941136%205.78590972,2.23557322%208.22334478,0.980358514%20L8.22952201,0.977166941%20L8.45694732,1.41791285%20L8.44901986,1.42110443%20C3.54316061,3.94872715%200.495311512,8.94343567%200.495311512,14.4568263%20C0.495311512,15.3865005%200.582513518,16.3162778%200.755373221,17.2212431%20C0.78965689,17.3971914%200.825484869,17.5716984%200.864401466,17.7413665%20L0.867593039,17.7553683%20L0.384738957,17.8659408%20Z%20M19.3963206,29%20L19.2576416,28.5234261%20L19.2638188,28.5218818%20C25.4671039,26.7090684%2029.7999214,20.924703%2029.7983771,14.4568263%20C29.7983771,12.5784312%2029.4494661,10.7516161%2028.7579243,9.02281318%20C28.6925486,8.85932229%2028.6224369,8.69263982%2028.550781,8.52914893%20L28.5476924,8.52142738%20L29.0009987,8.32046125%20L29.0039843,8.3281828%20C29.0788318,8.49795388%2029.1520321,8.67091654%2029.2189522,8.83914331%20L29.2221438,8.84686486%20C29.9337616,10.6316747%2030.29513,12.5177913%2030.29513,14.4568263%20C30.29513,16.1418738%2030.0195222,17.7973735%2029.4774696,19.3751429%20C28.9541546,20.9029797%2028.1910598,22.3310541%2027.2099086,23.6206555%20C26.2380232,24.8961521%2025.077732,26.0067165%2023.7601272,26.9177561%20C22.4238877,27.8444447%2020.9583381,28.5436051%2019.4040421,28.9985586%20L19.3963206,29%20Z'%20id='Fill-5'%3e%3c/path%3e%3cpath%20d='M26.420262,9.1598552%20L26.4172763,9.15213365%20C25.0031007,6.15102565%2022.3989832,3.80089556%2019.2748452,2.70443586%20L19.2701093,2.6949641%20L19.2701093,2.69352274%20L19.3463982,2.47536329%20L19.3542227,2.47855487%20C20.9505239,3.03913919%2022.3989832,3.90199635%2023.6588308,5.04210853%20C24.9142514,6.17748482%2025.9155817,7.52628468%2026.6336855,9.05092991%20L26.6366712,9.05875441%20L26.420262,9.1598552%20Z%20M4.79539995,21.8016752%20L4.79076702,21.795395%20C3.26282726,19.6430394%202.45453571,17.105945%202.45453571,14.4568366%20C2.45453571,13.7090819%202.52001443,12.9585475%202.65076596,12.2265449%20L2.65241322,12.2187204%20L2.88745712,12.2607256%20L2.88601576,12.2684471%20C2.7582499,12.986551%202.69441844,13.7215394%202.69441844,14.4568366%20C2.69441844,17.0514823%203.48397238,19.5386441%204.98071708,21.6504358%20L4.98854158,21.6427142%20L4.98689432,21.6599076%20L4.98998293,21.6644375%20L4.79539995,21.8016752%20Z%20M24.0467613,23.5053573%20L23.8785346,23.3356892%20L23.8847118,23.3309533%20C26.2800387,20.9715574%2027.5992908,17.81921%2027.6008351,14.4568366%20L27.6085566,14.4489091%20L27.8391735,14.4568366%20C27.8391735,16.1869779%2027.4964397,17.8644068%2026.8220913,19.4420733%20C26.1694661,20.9668215%2025.2382475,22.3326088%2024.0513943,23.5007244%20L24.0467613,23.5053573%20Z'%20id='Fill-7'%3e%3c/path%3e%3cpath%20d='M15.1470502,28.7574096%20C7.26160034,28.7574096%200.846436,22.3421423%200.846436,14.4566924%20C0.846436,6.57113959%207.26160034,0.155769345%2015.1470502,0.155769345%20C23.032603,0.155769345%2029.4478703,6.57113959%2029.4478703,14.4566924%20C29.4478703,22.3421423%2023.032603,28.7574096%2015.1470502,28.7574096%20M15.1470502,0%20C7.17573673,0%200.690563701,6.48527599%200.690563701,14.4566924%20C0.690563701,22.4280059%207.17573673,28.9132819%2015.1470502,28.9132819%20C23.1184666,28.9132819%2029.6037426,22.4280059%2029.6037426,14.4566924%20C29.6037426,6.48527599%2023.1184666,0%2015.1470502,0'%20id='Fill-9'%3e%3c/path%3e%3cpath%20d='M15.9815127,3.12014337%20L15.9312711,3.80890538%20C15.672239,3.7900648%2015.4108389,3.78007827%2015.1470708,3.78007827%20C14.5150364,3.78007827%2013.8957683,3.83557045%2013.2935906,3.94140713%20L13.1743699,3.26108734%20C13.8153613,3.14855866%2014.4743696,3.08936013%2015.1470708,3.08936013%20C15.4277233,3.08936013%2015.7059049,3.10006735%2015.9815127,3.12014337%20L15.9815127,3.12014337%20Z%20M16.1108228,25.0893864%20C17.0074489,25.0087735%2017.8722622,24.8169702%2018.6916728,24.5277725%20L18.921466,25.1788534%20C18.0486223,25.4869946%2017.1273903,25.6912553%2016.1723893,25.7771189%20L16.1108228,25.0893864%20Z%20M14.2820516,25.0982404%20C14.4967106,25.1155367%2014.7131198,25.1263469%2014.9310734,25.1306709%20L14.9181012,25.8208743%20C14.68594,25.8163443%2014.4554261,25.8048135%2014.2268683,25.7864877%20L14.2820516,25.0982404%20Z%20M4.4714656,14.5470036%20C4.47898124,15.4503217%204.59902556,16.3273865%204.81862636,17.1645052%20L4.15066105,17.3396299%20C3.91674965,16.4483574%203.78908674,15.5146679%203.78105633,14.552872%20L4.4714656,14.5470036%20Z%20M4.6116889,12.7239978%20C4.5767875,12.9365978%204.54744562,13.1510509%204.52541348,13.367666%20L3.83840169,13.2986868%20C3.86187519,13.0676581%203.89307024,12.8389974%203.93023662,12.6121898%20L4.6116889,12.7239978%20Z%20M26.5143207,14.4565071%20L25.8237055,14.4532126%20C25.8236026,14.1217008%2025.8075418,13.7938954%2025.7776851,13.4700022%20L26.4653146,13.4064796%20C26.4972304,13.752405%2026.5143207,14.1024484%2026.5143207,14.4565071%20L26.5143207,14.4565071%20Z%20M17.9033543,3.42797572%20L17.7359511,4.09810306%20C17.5266457,4.04580244%2017.3150753,3.99957611%2017.10124,3.95993884%20L17.2261231,3.2806486%20C17.454372,3.32296267%2017.6800471,3.37217467%2017.9033543,3.42797572%20L17.9033543,3.42797572%20Z%20M15.8717637,4.7150032%20C16.2253076,4.74156532%2016.5804988,4.78676211%2016.9292039,4.85049061%20L16.9371313,4.85213787%20L17.0713833,4.12240019%20C17.2818212,4.16141974%2017.4899941,4.20692539%2017.695902,4.25829942%20L17.5179976,4.97043198%20L17.5164533,4.97825648%20L17.5241748,4.97969783%20C21.5408207,5.98277829%2024.4937463,9.42617651%2024.8737493,13.5455704%20L24.8737493,13.5533949%20L25.6132676,13.4851365%20C25.6426095,13.803779%2025.6585674,14.1263337%2025.6585674,14.4523889%20L24.9220347,14.4488885%20L24.9142102,14.456816%20C24.9157545,18.5917559%2022.296091,22.2936716%2018.3979451,23.6705779%20L18.3902236,23.6735635%20L18.6366953,24.3720032%20C17.8300511,24.6566709%2016.9787247,24.8455914%2016.0962034,24.924866%20L16.0306217,24.1922456%20L16.0306217,24.1859654%20L16.0229002,24.1859654%20C15.7331877,24.2109832%2015.4388423,24.2249849%2015.1475856,24.2249849%20C15.0852984,24.2249849%2015.0230113,24.2234406%2014.9560912,24.2234406%20L14.9482667,24.2216904%20L14.934265,24.9655328%20C14.7196059,24.9612087%2014.5065942,24.9506045%2014.2953327,24.9336171%20L14.3548401,24.1922456%20L14.3471185,24.1922456%20C10.224636,23.8605279%206.74839543,20.9466219%205.69867683,16.9424335%20L5.69558821,16.9347119%20L4.97851386,17.1226029%20C4.76220759,16.2984564%204.64411939,15.4349816%204.63670671,14.5455623%20L5.37159209,14.5391791%20L5.37941659,14.5314576%20L5.37941659,14.4940853%20L5.37941659,14.456816%20C5.37941659,14.1296283%205.3966099,13.7963663%205.42924631,13.4661929%20L5.42924631,13.4584714%20L4.68983095,13.3842416%20C4.71155424,13.1710239%204.7404843,12.9600713%204.77476797,12.7507659%20L5.49935796,12.8696777%20L5.50718246,12.8696777%20L5.50862381,12.8619561%20C6.17679503,8.77674291%209.36641173,5.5529455%2013.4421532,4.83648887%20L13.4500806,4.83494456%20L13.3221089,4.10417734%20C13.9150207,3.99988498%2014.5247141,3.94521642%2015.1470708,3.94521642%20C15.4067207,3.94521642%2015.6642086,3.9551%2015.9192255,3.97363172%20L15.8656895,4.7071787%20L15.8639392,4.7150032%20L15.8717637,4.7150032%20Z%20M15.1470708,2.93359079%20C8.79326702,2.93359079%203.62394858,8.10290923%203.62394858,14.456713%20C3.62394858,20.8104138%208.79326702,25.9796293%2015.1470708,25.9796293%20C21.5008746,25.9796293%2026.670193,20.8104138%2026.670193,14.456713%20C26.670193,8.10290923%2021.5008746,2.93359079%2015.1470708,2.93359079%20L15.1470708,2.93359079%20Z'%20id='Fill-11'%3e%3c/path%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
  const __vite_glob_0_5 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20width='14px'%20height='9px'%20viewBox='0%200%2014%209'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3ctitle%3e编组%3c/title%3e%3cg%20id='页面-1'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='编组'%20fill='%230780D8'%3e%3cpath%20d='M13.6907718,1.6798683%20L6.14640051,8.71159055%20L6.14620114,8.71180291%20C5.79831049,9.03605031%205.26797304,9.08664511%204.86312117,8.86382623%20C4.78813172,8.82244255%204.71749981,8.77174156%204.65307667,8.71180291%20L4.65296275,8.71169673%20L0.309213986,4.66318327%20C-0.103071329,4.27889104%20-0.103071329,3.65579982%200.309213986,3.27142796%20C0.721527781,2.88713573%201.39002467,2.88713573%201.80233846,3.27142796%20L5.39969587,6.62427613%20L12.1976473,0.288219172%20C12.610075,-0.0960730574%2013.2785719,-0.0960730574%2013.6908857,0.288219172%20C14.1030571,0.672511402%2014.1030571,1.29557607%2013.6907718,1.6798683'%20id='Fill-1'%3e%3c/path%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
  const __vite_glob_0_6 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAaCAYAAACtv5zzAAAAAXNSR0IArs4c6QAAAbdJREFUSEvtlkFLG0EYht9vl6ghUIoxir21tAVLhUoFf4D+i9BTZmYTcittoQF7Sg/BcwrfjB4qghoFwUP/jp68CP6AkGTqhG0JLe7OkuzNPS0733zP7vu+OzMEAEKI90EQtABsAFhwzx66tNbPksb/HaMoijattRcAQp+JmQFKKdd8C8AtgC4R3SWBmPnc50X+1JBS6grAPIDvWutulsk+tQ5w4wqJ6AszH/lMylLzCBirJYR4TkTrxpjL/2I6rQe1Wu1lGIZn9wmsWGs/GWNOJiFTeyCEWAmCoAfgFQBLRF+Z+XAyplOnSCm1RESn1tq1OJG7zHwwvveRqFqtPikWi+WkeBYKhcXhcKgBrLo6a23bGPPDCyCl/EBEnSz5jyGdXAEA9rwATqJSqVRJ+oIwDJ9OSkREbWb2kyhNmmazWe73+717o8cmA/imtd73NjkJUK/Xl0ejkYvpa+ctgJbW+ufMYhr/aG4Jd1H9zMzHM/3RXLNGo/FiMBi8zWWpSPPHK0VpTZLG8wdIKa+JaC7PLfMXgHe5bfpSyh0i+ru8pumd+djiGkZRtA3go7X2TXzCeJCTFfAbk9HaXDYcIZoAAAAASUVORK5CYII=";
  const __vite_glob_0_7 = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20aria-hidden='true'%20role='img'%20class='iconify%20iconify--logos'%20width='31.88'%20height='32'%20preserveAspectRatio='xMidYMid%20meet'%20viewBox='0%200%20256%20257'%3e%3cdefs%3e%3clinearGradient%20id='IconifyId1813088fe1fbc01fb466'%20x1='-.828%25'%20x2='57.636%25'%20y1='7.652%25'%20y2='78.411%25'%3e%3cstop%20offset='0%25'%20stop-color='%2341D1FF'%3e%3c/stop%3e%3cstop%20offset='100%25'%20stop-color='%23BD34FE'%3e%3c/stop%3e%3c/linearGradient%3e%3clinearGradient%20id='IconifyId1813088fe1fbc01fb467'%20x1='43.376%25'%20x2='50.316%25'%20y1='2.242%25'%20y2='89.03%25'%3e%3cstop%20offset='0%25'%20stop-color='%23FFEA83'%3e%3c/stop%3e%3cstop%20offset='8.333%25'%20stop-color='%23FFDD35'%3e%3c/stop%3e%3cstop%20offset='100%25'%20stop-color='%23FFA800'%3e%3c/stop%3e%3c/linearGradient%3e%3c/defs%3e%3cpath%20fill='url(%23IconifyId1813088fe1fbc01fb466)'%20d='M255.153%2037.938L134.897%20252.976c-2.483%204.44-8.862%204.466-11.382.048L.875%2037.958c-2.746-4.814%201.371-10.646%206.827-9.67l120.385%2021.517a6.537%206.537%200%200%200%202.322-.004l117.867-21.483c5.438-.991%209.574%204.796%206.877%209.62Z'%3e%3c/path%3e%3cpath%20fill='url(%23IconifyId1813088fe1fbc01fb467)'%20d='M185.432.063L96.44%2017.501a3.268%203.268%200%200%200-2.634%203.014l-5.474%2092.456a3.268%203.268%200%200%200%203.997%203.378l24.777-5.718c2.318-.535%204.413%201.507%203.936%203.838l-7.361%2036.047c-.495%202.426%201.782%204.5%204.151%203.78l15.304-4.649c2.372-.72%204.652%201.36%204.15%203.788l-11.698%2056.621c-.732%203.542%203.979%205.473%205.943%202.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505%204.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z'%3e%3c/path%3e%3c/svg%3e";
  function getImageURL(image) {
    return new URL((/* @__PURE__ */ Object.assign({ "/src/assets/image/ai_icon.png": __vite_glob_0_0, "/src/assets/image/ai_icon_eye.png": __vite_glob_0_1, "/src/assets/image/ai_icon_eye.svg": __vite_glob_0_2, "/src/assets/image/ai_icon_eye_border.png": __vite_glob_0_3, "/src/assets/image/ai_icon_eye_border.svg": __vite_glob_0_4, "/src/assets/image/ai_icon_eye_right.svg": __vite_glob_0_5, "/src/assets/image/quit.png": __vite_glob_0_6, "/src/assets/image/vite.svg": __vite_glob_0_7 }))[`/src/assets/image/${image}`], (_documentCurrentScript && _documentCurrentScript.src || new URL('__entry.js', document.baseURI).href)).href;
  }
  function importImage(image) {
    return getImageURL(image);
  }
  function delay(duration = 1e3) {
    return new Promise((resolve2) => {
      setTimeout(() => {
        resolve2();
      }, duration);
    });
  }
  function countdown(start, end, callback, complete) {
    let currentPosition = start;
    function animate() {
      let step = (end - currentPosition) / end * 150;
      step = step < 1 ? 1 : step;
      if (currentPosition >= end) {
        currentPosition = end;
        callback(currentPosition);
        complete && complete();
      } else {
        currentPosition += step;
        callback(currentPosition);
        requestAnimationFrame(animate);
      }
    }
    requestAnimationFrame(animate);
  }
  function isValidPhoneNumber(str) {
    if (str.length !== 11) {
      return false;
    }
    if (str.charAt(0) !== "1") {
      return false;
    }
    const numericRegex = /^\d+$/;
    if (!numericRegex.test(str)) {
      return false;
    }
    return true;
  }
  function delayForQuery(callback, duration = 300, maxTryCount = 10) {
    let count = 0;
    return new Promise((resolve2) => {
      const step = () => {
        if (count === maxTryCount) {
          console.log("到达最大尝试次数", maxTryCount);
          resolve2();
          clearInterval(timer);
          return;
        }
        count++;
        if (callback()) {
          console.log("查询到了");
          resolve2();
          clearInterval(timer);
        } else {
          console.log(`尝试次数: (${count}/${maxTryCount})`);
        }
      };
      const timer = setInterval(step, duration);
      step();
    });
  }
  function debounce$1(fn, duration = 250) {
    let timeout;
    return function(...e2) {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        fn.apply(this, e2 || []);
      }, duration);
    };
  }
  var promptTypeEnum = /* @__PURE__ */ ((promptTypeEnum2) => {
    promptTypeEnum2[promptTypeEnum2["tsyd"] = 1] = "tsyd";
    promptTypeEnum2[promptTypeEnum2["scjd"] = 2] = "scjd";
    promptTypeEnum2[promptTypeEnum2["tsdz"] = 3] = "tsdz";
    return promptTypeEnum2;
  })(promptTypeEnum || {});
  const questionParamsMap = {
    [
      1
      /* tsyd */
    ]: {
      promptType: 1
      /* tsyd */
    },
    [
      2
      /* scjd */
    ]: {
      promptType: 2
      /* scjd */
    },
    [
      3
      /* tsdz */
    ]: {
      indexName: "tousu",
      promptType: 3
      /* tsdz */
    }
  };
  const _hoisted_1$h = { class: "chat-action-btn flex-c" };
  const _hoisted_2$f = { class: "text" };
  const _sfc_main$i = /* @__PURE__ */ defineComponent({
    __name: "ChatActionBtn",
    props: {
      text: {}
    },
    setup(__props) {
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$h, [
          createBaseVNode("div", null, [
            createBaseVNode("div", _hoisted_2$f, toDisplayString(_ctx.text), 1)
          ])
        ]);
      };
    }
  });
  const _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key2, val] of props) {
      target[key2] = val;
    }
    return target;
  };
  const ChatActionBtn = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__scopeId", "data-v-11bdb9e9"]]);
  var ScenesEnum = /* @__PURE__ */ ((ScenesEnum2) => {
    ScenesEnum2["initialValue"] = "initialValue";
    ScenesEnum2["login"] = "login";
    ScenesEnum2["chat"] = "chat";
    return ScenesEnum2;
  })(ScenesEnum || {});
  function useSceneManager(config3) {
    let currentScene = "initialValue";
    const onChangeScene = config3.onChangeScene;
    const onChangeSceneBefore = config3.onChangeSceneBefore;
    const changeScene = async (_currentScene) => {
      console.log("changeScene", _currentScene);
      const beforeScene = currentScene;
      if (beforeScene === _currentScene) {
        console.trace("A页面 => A页面 ，不允许", _currentScene);
        return;
      }
      let redirectCurrentScene;
      if (onChangeSceneBefore) {
        redirectCurrentScene = await new Promise(
          (resolve2) => {
            (async () => {
              const next2 = (scene) => {
                resolve2(scene);
              };
              onChangeSceneBefore(beforeScene, _currentScene, next2);
            })();
          }
        );
      }
      currentScene = redirectCurrentScene || _currentScene;
      onChangeScene && onChangeScene(beforeScene, currentScene);
    };
    return {
      currentScene,
      // 当前场景
      changeScene
      // 切换
    };
  }
  const _hoisted_1$g = ["src"];
  const _hoisted_2$e = ["src"];
  const _hoisted_3$d = ["src"];
  const _sfc_main$h = /* @__PURE__ */ defineComponent({
    __name: "AIIcon",
    setup(__props) {
      const getCurrentScene = inject("getCurrentScene");
      const haveBg = computed(() => {
        if (!getCurrentScene)
          return true;
        return getCurrentScene() === ScenesEnum.login;
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(["ai-icon-wrap disable-select", { "have-bg": haveBg.value }])
        }, [
          createBaseVNode("img", {
            class: "ai-icon-eye",
            src: unref(importImage)("ai_icon_eye.png")
          }, null, 8, _hoisted_1$g),
          createBaseVNode("img", {
            class: "ai-icon-eye-right",
            src: unref(importImage)("ai_icon_eye_right.svg")
          }, null, 8, _hoisted_2$e),
          createBaseVNode("img", {
            class: "ai-icon-eye-border",
            src: unref(importImage)("ai_icon_eye_border.png")
          }, null, 8, _hoisted_3$d)
        ], 2);
      };
    }
  });
  const AIIcon = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__scopeId", "data-v-d3759f46"]]);
  const _withScopeId$6 = (n2) => (pushScopeId("data-v-3890fb2a"), n2 = n2(), popScopeId(), n2);
  const _hoisted_1$f = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("span", { class: "ai-side-bar-text" }, "AI投诉", -1));
  const _hoisted_2$d = { class: "ai-side-bar-tabs" };
  const _hoisted_3$c = { class: "quit-btn" };
  const _hoisted_4$4 = ["src"];
  const _sfc_main$g = /* @__PURE__ */ defineComponent({
    __name: "SlideBar",
    props: {
      isOpen: { type: Boolean },
      promptType: {}
    },
    emits: ["action-btn", "quit"],
    setup(__props, { emit: __emit }) {
      const emit2 = __emit;
      const chatActionBtnList = [
        {
          text: "投诉要点",
          value: promptTypeEnum.tsyd
        },
        {
          text: "生成结单",
          value: promptTypeEnum.scjd
        },
        {
          text: "投诉定责",
          value: promptTypeEnum.tsdz
        }
      ];
      const handleClick = (type4) => {
        emit2("action-btn", questionParamsMap[type4]);
      };
      const handleQuit = () => emit2("quit");
      return (_ctx, _cache) => {
        const _component_a_popconfirm = resolveComponent("a-popconfirm");
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(["ai-side-bar disable-select", _ctx.isOpen ? "isOpen" : ""].join(" ")),
          onMousemove: () => ({})
        }, [
          createVNode(AIIcon),
          _hoisted_1$f,
          createBaseVNode("div", {
            onMousedown: withModifiers(() => ({}), ["stop"])
          }, [
            createBaseVNode("div", _hoisted_2$d, [
              (openBlock(), createElementBlock(Fragment, null, renderList(chatActionBtnList, (item, index2) => {
                return createVNode(ChatActionBtn, {
                  key: index2,
                  text: item.text,
                  class: normalizeClass({ active: _ctx.promptType === item.value }),
                  onClick: ($event) => handleClick(item.value)
                }, null, 8, ["text", "class", "onClick"]);
              }), 64)),
              createVNode(_component_a_popconfirm, {
                title: "确定登出吗",
                onConfirm: handleQuit,
                placement: "left"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_3$c, [
                    createBaseVNode("img", {
                      src: unref(importImage)("quit.png")
                    }, null, 8, _hoisted_4$4)
                  ])
                ]),
                _: 1
              })
            ])
          ], 32)
        ], 34);
      };
    }
  });
  const SlideBar = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__scopeId", "data-v-3890fb2a"]]);
  const _sfc_main$f = {};
  const _withScopeId$5 = (n2) => (pushScopeId("data-v-1b56b78d"), n2 = n2(), popScopeId(), n2);
  const _hoisted_1$e = { class: "ai-bg-img" };
  const _hoisted_2$c = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("div", { class: "ai-bg-top" }, null, -1));
  const _hoisted_3$b = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("div", { class: "ai-bg-bottom" }, null, -1));
  const _hoisted_4$3 = [
    _hoisted_2$c,
    _hoisted_3$b
  ];
  function _sfc_render$6(_ctx, _cache) {
    return openBlock(), createElementBlock("div", _hoisted_1$e, _hoisted_4$3);
  }
  const BackgroundImg = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$6], ["__scopeId", "data-v-1b56b78d"]]);
  var _GM_xmlhttpRequest = /* @__PURE__ */ (() => typeof GM_xmlhttpRequest != "undefined" ? GM_xmlhttpRequest : void 0)();
  function _typeof$1(o2) {
    "@babel/helpers - typeof";
    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof$1(o2);
  }
  function toPrimitive(t2, r2) {
    if ("object" != _typeof$1(t2) || !t2)
      return t2;
    var e2 = t2[Symbol.toPrimitive];
    if (void 0 !== e2) {
      var i2 = e2.call(t2, r2 || "default");
      if ("object" != _typeof$1(i2))
        return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t2);
  }
  function toPropertyKey(t2) {
    var i2 = toPrimitive(t2, "string");
    return "symbol" == _typeof$1(i2) ? i2 : String(i2);
  }
  function _defineProperty$i(obj, key2, value) {
    key2 = toPropertyKey(key2);
    if (key2 in obj) {
      Object.defineProperty(obj, key2, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function ownKeys$1(e2, r2) {
    var t2 = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e2);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
      })), t2.push.apply(t2, o2);
    }
    return t2;
  }
  function _objectSpread2$1(e2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
        _defineProperty$i(e2, r3, t2[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
        Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
      });
    }
    return e2;
  }
  function _extends$1() {
    _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key2 in source) {
          if (Object.prototype.hasOwnProperty.call(source, key2)) {
            target[key2] = source[key2];
          }
        }
      }
      return target;
    };
    return _extends$1.apply(this, arguments);
  }
  const isFunction$1 = (val) => typeof val === "function";
  const isArray$1 = Array.isArray;
  const isString = (val) => typeof val === "string";
  const isObject$2 = (val) => val !== null && typeof val === "object";
  const onRE = /^on[^a-z]/;
  const isOn = (key2) => onRE.test(key2);
  const cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  const camelizeRE = /-(\w)/g;
  const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
  });
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction((str) => {
    return str.replace(hyphenateRE, "-$1").toLowerCase();
  });
  const hasOwnProperty$e = Object.prototype.hasOwnProperty;
  const hasOwn = (val, key2) => hasOwnProperty$e.call(val, key2);
  function resolvePropValue(options, props, key2, value) {
    const opt = options[key2];
    if (opt != null) {
      const hasDefault = hasOwn(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        value = opt.type !== Function && isFunction$1(defaultValue) ? defaultValue() : defaultValue;
      }
      if (opt.type === Boolean) {
        if (!hasOwn(props, key2) && !hasDefault) {
          value = false;
        } else if (value === "") {
          value = true;
        }
      }
    }
    return value;
  }
  function renderHelper(v2) {
    let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let defaultV = arguments.length > 2 ? arguments[2] : void 0;
    if (typeof v2 === "function") {
      return v2(props);
    }
    return v2 !== null && v2 !== void 0 ? v2 : defaultV;
  }
  function wrapPromiseFn(openFn) {
    let closeFn;
    const closePromise = new Promise((resolve2) => {
      closeFn = openFn(() => {
        resolve2(true);
      });
    });
    const result = () => {
      closeFn === null || closeFn === void 0 ? void 0 : closeFn();
    };
    result.then = (filled, rejected) => closePromise.then(filled, rejected);
    result.promise = closePromise;
    return result;
  }
  function classNames() {
    const classes = [];
    for (let i2 = 0; i2 < arguments.length; i2++) {
      const value = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
      if (!value)
        continue;
      if (isString(value)) {
        classes.push(value);
      } else if (isArray$1(value)) {
        for (let i3 = 0; i3 < value.length; i3++) {
          const inner = classNames(value[i3]);
          if (inner) {
            classes.push(inner);
          }
        }
      } else if (isObject$2(value)) {
        for (const name2 in value) {
          if (value[name2]) {
            classes.push(name2);
          }
        }
      }
    }
    return classes.join(" ");
  }
  var MapShim = function() {
    if (typeof Map !== "undefined") {
      return Map;
    }
    function getIndex(arr, key2) {
      var result = -1;
      arr.some(function(entry, index2) {
        if (entry[0] === key2) {
          result = index2;
          return true;
        }
        return false;
      });
      return result;
    }
    return (
      /** @class */
      function() {
        function class_1() {
          this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
          /**
           * @returns {boolean}
           */
          get: function() {
            return this.__entries__.length;
          },
          enumerable: true,
          configurable: true
        });
        class_1.prototype.get = function(key2) {
          var index2 = getIndex(this.__entries__, key2);
          var entry = this.__entries__[index2];
          return entry && entry[1];
        };
        class_1.prototype.set = function(key2, value) {
          var index2 = getIndex(this.__entries__, key2);
          if (~index2) {
            this.__entries__[index2][1] = value;
          } else {
            this.__entries__.push([key2, value]);
          }
        };
        class_1.prototype.delete = function(key2) {
          var entries = this.__entries__;
          var index2 = getIndex(entries, key2);
          if (~index2) {
            entries.splice(index2, 1);
          }
        };
        class_1.prototype.has = function(key2) {
          return !!~getIndex(this.__entries__, key2);
        };
        class_1.prototype.clear = function() {
          this.__entries__.splice(0);
        };
        class_1.prototype.forEach = function(callback, ctx) {
          if (ctx === void 0) {
            ctx = null;
          }
          for (var _i = 0, _a2 = this.__entries__; _i < _a2.length; _i++) {
            var entry = _a2[_i];
            callback.call(ctx, entry[1], entry[0]);
          }
        };
        return class_1;
      }()
    );
  }();
  var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
  var global$1 = function() {
    if (typeof global !== "undefined" && global.Math === Math) {
      return global;
    }
    if (typeof self !== "undefined" && self.Math === Math) {
      return self;
    }
    if (typeof window !== "undefined" && window.Math === Math) {
      return window;
    }
    return Function("return this")();
  }();
  var requestAnimationFrame$1 = function() {
    if (typeof requestAnimationFrame === "function") {
      return requestAnimationFrame.bind(global$1);
    }
    return function(callback) {
      return setTimeout(function() {
        return callback(Date.now());
      }, 1e3 / 60);
    };
  }();
  var trailingTimeout = 2;
  function throttle(callback, delay2) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    function resolvePending() {
      if (leadingCall) {
        leadingCall = false;
        callback();
      }
      if (trailingCall) {
        proxy();
      }
    }
    function timeoutCallback() {
      requestAnimationFrame$1(resolvePending);
    }
    function proxy() {
      var timeStamp = Date.now();
      if (leadingCall) {
        if (timeStamp - lastCallTime < trailingTimeout) {
          return;
        }
        trailingCall = true;
      } else {
        leadingCall = true;
        trailingCall = false;
        setTimeout(timeoutCallback, delay2);
      }
      lastCallTime = timeStamp;
    }
    return proxy;
  }
  var REFRESH_DELAY = 20;
  var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
  var mutationObserverSupported = typeof MutationObserver !== "undefined";
  var ResizeObserverController = (
    /** @class */
    function() {
      function ResizeObserverController2() {
        this.connected_ = false;
        this.mutationEventsAdded_ = false;
        this.mutationsObserver_ = null;
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
      }
      ResizeObserverController2.prototype.addObserver = function(observer) {
        if (!~this.observers_.indexOf(observer)) {
          this.observers_.push(observer);
        }
        if (!this.connected_) {
          this.connect_();
        }
      };
      ResizeObserverController2.prototype.removeObserver = function(observer) {
        var observers2 = this.observers_;
        var index2 = observers2.indexOf(observer);
        if (~index2) {
          observers2.splice(index2, 1);
        }
        if (!observers2.length && this.connected_) {
          this.disconnect_();
        }
      };
      ResizeObserverController2.prototype.refresh = function() {
        var changesDetected = this.updateObservers_();
        if (changesDetected) {
          this.refresh();
        }
      };
      ResizeObserverController2.prototype.updateObservers_ = function() {
        var activeObservers = this.observers_.filter(function(observer) {
          return observer.gatherActive(), observer.hasActive();
        });
        activeObservers.forEach(function(observer) {
          return observer.broadcastActive();
        });
        return activeObservers.length > 0;
      };
      ResizeObserverController2.prototype.connect_ = function() {
        if (!isBrowser || this.connected_) {
          return;
        }
        document.addEventListener("transitionend", this.onTransitionEnd_);
        window.addEventListener("resize", this.refresh);
        if (mutationObserverSupported) {
          this.mutationsObserver_ = new MutationObserver(this.refresh);
          this.mutationsObserver_.observe(document, {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true
          });
        } else {
          document.addEventListener("DOMSubtreeModified", this.refresh);
          this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
      };
      ResizeObserverController2.prototype.disconnect_ = function() {
        if (!isBrowser || !this.connected_) {
          return;
        }
        document.removeEventListener("transitionend", this.onTransitionEnd_);
        window.removeEventListener("resize", this.refresh);
        if (this.mutationsObserver_) {
          this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
          document.removeEventListener("DOMSubtreeModified", this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
      };
      ResizeObserverController2.prototype.onTransitionEnd_ = function(_a2) {
        var _b = _a2.propertyName, propertyName = _b === void 0 ? "" : _b;
        var isReflowProperty = transitionKeys.some(function(key2) {
          return !!~propertyName.indexOf(key2);
        });
        if (isReflowProperty) {
          this.refresh();
        }
      };
      ResizeObserverController2.getInstance = function() {
        if (!this.instance_) {
          this.instance_ = new ResizeObserverController2();
        }
        return this.instance_;
      };
      ResizeObserverController2.instance_ = null;
      return ResizeObserverController2;
    }()
  );
  var defineConfigurable = function(target, props) {
    for (var _i = 0, _a2 = Object.keys(props); _i < _a2.length; _i++) {
      var key2 = _a2[_i];
      Object.defineProperty(target, key2, {
        value: props[key2],
        enumerable: false,
        writable: false,
        configurable: true
      });
    }
    return target;
  };
  var getWindowOf = function(target) {
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    return ownerGlobal || global$1;
  };
  var emptyRect = createRectInit(0, 0, 0, 0);
  function toFloat(value) {
    return parseFloat(value) || 0;
  }
  function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function(size2, position2) {
      var value = styles["border-" + position2 + "-width"];
      return size2 + toFloat(value);
    }, 0);
  }
  function getPaddings(styles) {
    var positions = ["top", "right", "bottom", "left"];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
      var position2 = positions_1[_i];
      var value = styles["padding-" + position2];
      paddings[position2] = toFloat(value);
    }
    return paddings;
  }
  function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
  }
  function getHTMLElementContentRect(target) {
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    if (!clientWidth && !clientHeight) {
      return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    var width = toFloat(styles.width), height = toFloat(styles.height);
    if (styles.boxSizing === "border-box") {
      if (Math.round(width + horizPad) !== clientWidth) {
        width -= getBordersSize(styles, "left", "right") + horizPad;
      }
      if (Math.round(height + vertPad) !== clientHeight) {
        height -= getBordersSize(styles, "top", "bottom") + vertPad;
      }
    }
    if (!isDocumentElement(target)) {
      var vertScrollbar = Math.round(width + horizPad) - clientWidth;
      var horizScrollbar = Math.round(height + vertPad) - clientHeight;
      if (Math.abs(vertScrollbar) !== 1) {
        width -= vertScrollbar;
      }
      if (Math.abs(horizScrollbar) !== 1) {
        height -= horizScrollbar;
      }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
  }
  var isSVGGraphicsElement = function() {
    if (typeof SVGGraphicsElement !== "undefined") {
      return function(target) {
        return target instanceof getWindowOf(target).SVGGraphicsElement;
      };
    }
    return function(target) {
      return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
    };
  }();
  function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
  }
  function getContentRect(target) {
    if (!isBrowser) {
      return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
      return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
  }
  function createReadOnlyRect(_a2) {
    var x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
    var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    defineConfigurable(rect, {
      x: x2,
      y: y2,
      width,
      height,
      top: y2,
      right: x2 + width,
      bottom: height + y2,
      left: x2
    });
    return rect;
  }
  function createRectInit(x2, y2, width, height) {
    return { x: x2, y: y2, width, height };
  }
  var ResizeObservation = (
    /** @class */
    function() {
      function ResizeObservation2(target) {
        this.broadcastWidth = 0;
        this.broadcastHeight = 0;
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
      }
      ResizeObservation2.prototype.isActive = function() {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
      };
      ResizeObservation2.prototype.broadcastRect = function() {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
      };
      return ResizeObservation2;
    }()
  );
  var ResizeObserverEntry = (
    /** @class */
    /* @__PURE__ */ function() {
      function ResizeObserverEntry2(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        defineConfigurable(this, { target, contentRect });
      }
      return ResizeObserverEntry2;
    }()
  );
  var ResizeObserverSPI = (
    /** @class */
    function() {
      function ResizeObserverSPI2(callback, controller, callbackCtx) {
        this.activeObservations_ = [];
        this.observations_ = new MapShim();
        if (typeof callback !== "function") {
          throw new TypeError("The callback provided as parameter 1 is not a function.");
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
      }
      ResizeObserverSPI2.prototype.observe = function(target) {
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        if (typeof Element === "undefined" || !(Element instanceof Object)) {
          return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        if (observations.has(target)) {
          return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        this.controller_.refresh();
      };
      ResizeObserverSPI2.prototype.unobserve = function(target) {
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        if (typeof Element === "undefined" || !(Element instanceof Object)) {
          return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        if (!observations.has(target)) {
          return;
        }
        observations.delete(target);
        if (!observations.size) {
          this.controller_.removeObserver(this);
        }
      };
      ResizeObserverSPI2.prototype.disconnect = function() {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
      };
      ResizeObserverSPI2.prototype.gatherActive = function() {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function(observation) {
          if (observation.isActive()) {
            _this.activeObservations_.push(observation);
          }
        });
      };
      ResizeObserverSPI2.prototype.broadcastActive = function() {
        if (!this.hasActive()) {
          return;
        }
        var ctx = this.callbackCtx_;
        var entries = this.activeObservations_.map(function(observation) {
          return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
      };
      ResizeObserverSPI2.prototype.clearActive = function() {
        this.activeObservations_.splice(0);
      };
      ResizeObserverSPI2.prototype.hasActive = function() {
        return this.activeObservations_.length > 0;
      };
      return ResizeObserverSPI2;
    }()
  );
  var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
  var ResizeObserver$2 = (
    /** @class */
    /* @__PURE__ */ function() {
      function ResizeObserver2(callback) {
        if (!(this instanceof ResizeObserver2)) {
          throw new TypeError("Cannot call a class as a function.");
        }
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
      }
      return ResizeObserver2;
    }()
  );
  [
    "observe",
    "unobserve",
    "disconnect"
  ].forEach(function(method4) {
    ResizeObserver$2.prototype[method4] = function() {
      var _a2;
      return (_a2 = observers.get(this))[method4].apply(_a2, arguments);
    };
  });
  var index = function() {
    if (typeof global$1.ResizeObserver !== "undefined") {
      return global$1.ResizeObserver;
    }
    return ResizeObserver$2;
  }();
  const isValid$2 = (value) => {
    return value !== void 0 && value !== null && value !== "";
  };
  const initDefaultProps = (types2, defaultProps) => {
    const propTypes = _extends$1({}, types2);
    Object.keys(defaultProps).forEach((k2) => {
      const prop = propTypes[k2];
      if (prop) {
        if (prop.type || prop.default) {
          prop.default = defaultProps[k2];
        } else if (prop.def) {
          prop.def(defaultProps[k2]);
        } else {
          propTypes[k2] = {
            type: prop,
            default: defaultProps[k2]
          };
        }
      } else {
        throw new Error(`not have ${k2} prop`);
      }
    });
    return propTypes;
  };
  const splitAttrs = (attrs) => {
    const allAttrs = Object.keys(attrs);
    const eventAttrs = {};
    const onEvents = {};
    const extraAttrs = {};
    for (let i2 = 0, l2 = allAttrs.length; i2 < l2; i2++) {
      const key2 = allAttrs[i2];
      if (isOn(key2)) {
        eventAttrs[key2[2].toLowerCase() + key2.slice(3)] = attrs[key2];
        onEvents[key2] = attrs[key2];
      } else {
        extraAttrs[key2] = attrs[key2];
      }
    }
    return {
      onEvents,
      events: eventAttrs,
      extraAttrs
    };
  };
  const parseStyleText = function() {
    let cssText = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    let camel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const res = {};
    const listDelimiter = /;(?![^(]*\))/g;
    const propertyDelimiter = /:(.+)/;
    if (typeof cssText === "object")
      return cssText;
    cssText.split(listDelimiter).forEach(function(item) {
      if (item) {
        const tmp = item.split(propertyDelimiter);
        if (tmp.length > 1) {
          const k2 = camel ? camelize(tmp[0].trim()) : tmp[0].trim();
          res[k2] = tmp[1].trim();
        }
      }
    });
    return res;
  };
  const hasProp = (instance, prop) => {
    return instance[prop] !== void 0;
  };
  const skipFlattenKey = Symbol("skipFlatten");
  const flattenChildren = function() {
    let children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let filterEmpty2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    const temp = Array.isArray(children) ? children : [children];
    const res = [];
    temp.forEach((child) => {
      if (Array.isArray(child)) {
        res.push(...flattenChildren(child, filterEmpty2));
      } else if (child && child.type === Fragment) {
        if (child.key === skipFlattenKey) {
          res.push(child);
        } else {
          res.push(...flattenChildren(child.children, filterEmpty2));
        }
      } else if (child && isVNode(child)) {
        if (filterEmpty2 && !isEmptyElement(child)) {
          res.push(child);
        } else if (!filterEmpty2) {
          res.push(child);
        }
      } else if (isValid$2(child)) {
        res.push(child);
      }
    });
    return res;
  };
  const getSlot = function(self2) {
    let name2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (isVNode(self2)) {
      if (self2.type === Fragment) {
        return name2 === "default" ? flattenChildren(self2.children) : [];
      } else if (self2.children && self2.children[name2]) {
        return flattenChildren(self2.children[name2](options));
      } else {
        return [];
      }
    } else {
      const res = self2.$slots[name2] && self2.$slots[name2](options);
      return flattenChildren(res);
    }
  };
  const findDOMNode = (instance) => {
    var _a2;
    let node2 = ((_a2 = instance === null || instance === void 0 ? void 0 : instance.vnode) === null || _a2 === void 0 ? void 0 : _a2.el) || instance && (instance.$el || instance);
    while (node2 && !node2.tagName) {
      node2 = node2.nextSibling;
    }
    return node2;
  };
  const getOptionProps = (instance) => {
    const res = {};
    if (instance.$ && instance.$.vnode) {
      const props = instance.$.vnode.props || {};
      Object.keys(instance.$props).forEach((k2) => {
        const v2 = instance.$props[k2];
        const hyphenateKey = hyphenate(k2);
        if (v2 !== void 0 || hyphenateKey in props) {
          res[k2] = v2;
        }
      });
    } else if (isVNode(instance) && typeof instance.type === "object") {
      const originProps = instance.props || {};
      const props = {};
      Object.keys(originProps).forEach((key2) => {
        props[camelize(key2)] = originProps[key2];
      });
      const options = instance.type.props || {};
      Object.keys(options).forEach((k2) => {
        const v2 = resolvePropValue(options, props, k2, props[k2]);
        if (v2 !== void 0 || k2 in props) {
          res[k2] = v2;
        }
      });
    }
    return res;
  };
  const getComponent = function(instance) {
    let prop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default";
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : instance;
    let execute = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
    let com = void 0;
    if (instance.$) {
      const temp = instance[prop];
      if (temp !== void 0) {
        return typeof temp === "function" && execute ? temp(options) : temp;
      } else {
        com = instance.$slots[prop];
        com = execute && com ? com(options) : com;
      }
    } else if (isVNode(instance)) {
      const temp = instance.props && instance.props[prop];
      if (temp !== void 0 && instance.props !== null) {
        return typeof temp === "function" && execute ? temp(options) : temp;
      } else if (instance.type === Fragment) {
        com = instance.children;
      } else if (instance.children && instance.children[prop]) {
        com = instance.children[prop];
        com = execute && com ? com(options) : com;
      }
    }
    if (Array.isArray(com)) {
      com = flattenChildren(com);
      com = com.length === 1 ? com[0] : com;
      com = com.length === 0 ? void 0 : com;
    }
    return com;
  };
  function getEvents() {
    let ele = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let on = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let props = {};
    if (ele.$) {
      props = _extends$1(_extends$1({}, props), ele.$attrs);
    } else {
      props = _extends$1(_extends$1({}, props), ele.props);
    }
    return splitAttrs(props)[on ? "onEvents" : "events"];
  }
  function getStyle$2(ele, camel) {
    const props = (isVNode(ele) ? ele.props : ele.$attrs) || {};
    let style = props.style || {};
    if (typeof style === "string") {
      style = parseStyleText(style, camel);
    } else if (camel && style) {
      const res = {};
      Object.keys(style).forEach((k2) => res[camelize(k2)] = style[k2]);
      return res;
    }
    return style;
  }
  function isFragment(c2) {
    return c2.length === 1 && c2[0].type === Fragment;
  }
  function isEmptyElement(c2) {
    return c2 && (c2.type === Comment || c2.type === Fragment && c2.children.length === 0 || c2.type === Text && c2.children.trim() === "");
  }
  function filterEmpty() {
    let children = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const res = [];
    children.forEach((child) => {
      if (Array.isArray(child)) {
        res.push(...child);
      } else if ((child === null || child === void 0 ? void 0 : child.type) === Fragment) {
        res.push(...filterEmpty(child.children));
      } else {
        res.push(child);
      }
    });
    return res.filter((c2) => !isEmptyElement(c2));
  }
  function isValidElement(element) {
    if (Array.isArray(element) && element.length === 1) {
      element = element[0];
    }
    return element && element.__v_isVNode && typeof element.type !== "symbol";
  }
  function getPropsSlot(slots, props) {
    let prop = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "default";
    var _a2, _b;
    return (_a2 = props[prop]) !== null && _a2 !== void 0 ? _a2 : (_b = slots[prop]) === null || _b === void 0 ? void 0 : _b.call(slots);
  }
  const ResizeObserver$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ResizeObserver",
    props: {
      disabled: Boolean,
      onResize: Function
    },
    emits: ["resize"],
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const state = reactive({
        width: 0,
        height: 0,
        offsetHeight: 0,
        offsetWidth: 0
      });
      let currentElement = null;
      let resizeObserver = null;
      const destroyObserver = () => {
        if (resizeObserver) {
          resizeObserver.disconnect();
          resizeObserver = null;
        }
      };
      const onResize = (entries) => {
        const {
          onResize: onResize2
        } = props;
        const target = entries[0].target;
        const {
          width,
          height
        } = target.getBoundingClientRect();
        const {
          offsetWidth,
          offsetHeight
        } = target;
        const fixedWidth = Math.floor(width);
        const fixedHeight = Math.floor(height);
        if (state.width !== fixedWidth || state.height !== fixedHeight || state.offsetWidth !== offsetWidth || state.offsetHeight !== offsetHeight) {
          const size2 = {
            width: fixedWidth,
            height: fixedHeight,
            offsetWidth,
            offsetHeight
          };
          _extends$1(state, size2);
          if (onResize2) {
            Promise.resolve().then(() => {
              onResize2(_extends$1(_extends$1({}, size2), {
                offsetWidth,
                offsetHeight
              }), target);
            });
          }
        }
      };
      const instance = getCurrentInstance();
      const registerObserver = () => {
        const {
          disabled
        } = props;
        if (disabled) {
          destroyObserver();
          return;
        }
        const element = findDOMNode(instance);
        const elementChanged = element !== currentElement;
        if (elementChanged) {
          destroyObserver();
          currentElement = element;
        }
        if (!resizeObserver && element) {
          resizeObserver = new index(onResize);
          resizeObserver.observe(element);
        }
      };
      onMounted(() => {
        registerObserver();
      });
      onUpdated(() => {
        registerObserver();
      });
      onUnmounted(() => {
        destroyObserver();
      });
      watch(() => props.disabled, () => {
        registerObserver();
      }, {
        flush: "post"
      });
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)[0];
      };
    }
  });
  let raf = (callback) => setTimeout(callback, 16);
  let caf = (num) => clearTimeout(num);
  if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
    raf = (callback) => window.requestAnimationFrame(callback);
    caf = (handle) => window.cancelAnimationFrame(handle);
  }
  let rafUUID = 0;
  const rafIds = /* @__PURE__ */ new Map();
  function cleanup(id) {
    rafIds.delete(id);
  }
  function wrapperRaf(callback) {
    let times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    rafUUID += 1;
    const id = rafUUID;
    function callRef(leftTimes) {
      if (leftTimes === 0) {
        cleanup(id);
        callback();
      } else {
        const realId = raf(() => {
          callRef(leftTimes - 1);
        });
        rafIds.set(id, realId);
      }
    }
    callRef(times);
    return id;
  }
  wrapperRaf.cancel = (id) => {
    const realId = rafIds.get(id);
    cleanup(realId);
    return caf(realId);
  };
  const tuple = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return args;
  };
  const withInstall = (comp) => {
    const c2 = comp;
    c2.install = function(app2) {
      app2.component(c2.displayName || c2.name, comp);
    };
    return comp;
  };
  function eventType() {
    return {
      type: [Function, Array]
    };
  }
  function objectType(defaultVal) {
    return {
      type: Object,
      default: defaultVal
    };
  }
  function booleanType(defaultVal) {
    return {
      type: Boolean,
      default: defaultVal
    };
  }
  function functionType(defaultVal) {
    return {
      type: Function,
      default: defaultVal
    };
  }
  function anyType(defaultVal, required4) {
    const type4 = {
      validator: () => true,
      default: defaultVal
    };
    return required4 ? type4 : type4;
  }
  function arrayType(defaultVal) {
    return {
      type: Array,
      default: defaultVal
    };
  }
  function stringType(defaultVal) {
    return {
      type: String,
      default: defaultVal
    };
  }
  function someType(types2, defaultVal) {
    return types2 ? {
      type: types2,
      default: defaultVal
    } : anyType(defaultVal);
  }
  let supportsPassive = false;
  try {
    const opts = Object.defineProperty({}, "passive", {
      get() {
        supportsPassive = true;
      }
    });
    window.addEventListener("testPassive", null, opts);
    window.removeEventListener("testPassive", null, opts);
  } catch (e2) {
  }
  const supportsPassive$1 = supportsPassive;
  function addEventListenerWrap(target, eventType2, cb, option) {
    if (target && target.addEventListener) {
      let opt = option;
      if (opt === void 0 && supportsPassive$1 && (eventType2 === "touchstart" || eventType2 === "touchmove" || eventType2 === "wheel")) {
        opt = {
          passive: false
        };
      }
      target.addEventListener(eventType2, cb, opt);
    }
    return {
      remove: () => {
        if (target && target.removeEventListener) {
          target.removeEventListener(eventType2, cb);
        }
      }
    };
  }
  const defaultIconPrefixCls = "anticon";
  const GlobalFormContextKey = Symbol("GlobalFormContextKey");
  const useProvideGlobalForm = (state) => {
    provide(GlobalFormContextKey, state);
  };
  const useInjectGlobalForm = () => {
    return inject(GlobalFormContextKey, {
      validateMessages: computed(() => void 0)
    });
  };
  const configProviderProps = () => ({
    iconPrefixCls: String,
    getTargetContainer: {
      type: Function
    },
    getPopupContainer: {
      type: Function
    },
    prefixCls: String,
    getPrefixCls: {
      type: Function
    },
    renderEmpty: {
      type: Function
    },
    transformCellText: {
      type: Function
    },
    csp: objectType(),
    input: objectType(),
    autoInsertSpaceInButton: {
      type: Boolean,
      default: void 0
    },
    locale: objectType(),
    pageHeader: objectType(),
    componentSize: {
      type: String
    },
    componentDisabled: {
      type: Boolean,
      default: void 0
    },
    direction: {
      type: String,
      default: "ltr"
    },
    space: objectType(),
    virtual: {
      type: Boolean,
      default: void 0
    },
    dropdownMatchSelectWidth: {
      type: [Number, Boolean],
      default: true
    },
    form: objectType(),
    pagination: objectType(),
    theme: objectType(),
    select: objectType(),
    wave: objectType()
  });
  const configProviderKey = Symbol("configProvider");
  const defaultConfigProvider = {
    getPrefixCls: (suffixCls, customizePrefixCls) => {
      if (customizePrefixCls)
        return customizePrefixCls;
      return suffixCls ? `ant-${suffixCls}` : "ant";
    },
    iconPrefixCls: computed(() => defaultIconPrefixCls),
    getPopupContainer: computed(() => () => document.body),
    direction: computed(() => "ltr")
  };
  const useConfigContextInject = () => {
    return inject(configProviderKey, defaultConfigProvider);
  };
  const useConfigContextProvider = (props) => {
    return provide(configProviderKey, props);
  };
  const DisabledContextKey = Symbol("DisabledContextKey");
  const useInjectDisabled = () => {
    return inject(DisabledContextKey, ref(void 0));
  };
  const useProviderDisabled = (disabled) => {
    const parentDisabled = useInjectDisabled();
    provide(DisabledContextKey, computed(() => {
      var _a2;
      return (_a2 = disabled.value) !== null && _a2 !== void 0 ? _a2 : parentDisabled.value;
    }));
    return disabled;
  };
  const enUS$1 = {
    // Options.jsx
    items_per_page: "/ page",
    jump_to: "Go to",
    jump_to_confirm: "confirm",
    page: "",
    // Pagination.jsx
    prev_page: "Previous Page",
    next_page: "Next Page",
    prev_5: "Previous 5 Pages",
    next_5: "Next 5 Pages",
    prev_3: "Previous 3 Pages",
    next_3: "Next 3 Pages"
  };
  const locale$6 = {
    locale: "en_US",
    today: "Today",
    now: "Now",
    backToToday: "Back to today",
    ok: "Ok",
    clear: "Clear",
    month: "Month",
    year: "Year",
    timeSelect: "select time",
    dateSelect: "select date",
    weekSelect: "Choose a week",
    monthSelect: "Choose a month",
    yearSelect: "Choose a year",
    decadeSelect: "Choose a decade",
    yearFormat: "YYYY",
    dateFormat: "M/D/YYYY",
    dayFormat: "D",
    dateTimeFormat: "M/D/YYYY HH:mm:ss",
    monthBeforeYear: true,
    previousMonth: "Previous month (PageUp)",
    nextMonth: "Next month (PageDown)",
    previousYear: "Last year (Control + left)",
    nextYear: "Next year (Control + right)",
    previousDecade: "Last decade",
    nextDecade: "Next decade",
    previousCentury: "Last century",
    nextCentury: "Next century"
  };
  const CalendarLocale$1 = locale$6;
  const locale$5 = {
    placeholder: "Select time",
    rangePlaceholder: ["Start time", "End time"]
  };
  const TimePicker$1 = locale$5;
  const locale$4 = {
    lang: _extends$1({
      placeholder: "Select date",
      yearPlaceholder: "Select year",
      quarterPlaceholder: "Select quarter",
      monthPlaceholder: "Select month",
      weekPlaceholder: "Select week",
      rangePlaceholder: ["Start date", "End date"],
      rangeYearPlaceholder: ["Start year", "End year"],
      rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
      rangeMonthPlaceholder: ["Start month", "End month"],
      rangeWeekPlaceholder: ["Start week", "End week"]
    }, CalendarLocale$1),
    timePickerLocale: _extends$1({}, TimePicker$1)
  };
  const enUS = locale$4;
  const typeTemplate$2 = "${label} is not a valid ${type}";
  const localeValues$1 = {
    locale: "en",
    Pagination: enUS$1,
    DatePicker: enUS,
    TimePicker: TimePicker$1,
    Calendar: enUS,
    global: {
      placeholder: "Please select"
    },
    Table: {
      filterTitle: "Filter menu",
      filterConfirm: "OK",
      filterReset: "Reset",
      filterEmptyText: "No filters",
      filterCheckall: "Select all items",
      filterSearchPlaceholder: "Search in filters",
      emptyText: "No data",
      selectAll: "Select current page",
      selectInvert: "Invert current page",
      selectNone: "Clear all data",
      selectionAll: "Select all data",
      sortTitle: "Sort",
      expand: "Expand row",
      collapse: "Collapse row",
      triggerDesc: "Click to sort descending",
      triggerAsc: "Click to sort ascending",
      cancelSort: "Click to cancel sorting"
    },
    Tour: {
      Next: "Next",
      Previous: "Previous",
      Finish: "Finish"
    },
    Modal: {
      okText: "OK",
      cancelText: "Cancel",
      justOkText: "OK"
    },
    Popconfirm: {
      okText: "OK",
      cancelText: "Cancel"
    },
    Transfer: {
      titles: ["", ""],
      searchPlaceholder: "Search here",
      itemUnit: "item",
      itemsUnit: "items",
      remove: "Remove",
      selectCurrent: "Select current page",
      removeCurrent: "Remove current page",
      selectAll: "Select all data",
      removeAll: "Remove all data",
      selectInvert: "Invert current page"
    },
    Upload: {
      uploading: "Uploading...",
      removeFile: "Remove file",
      uploadError: "Upload error",
      previewFile: "Preview file",
      downloadFile: "Download file"
    },
    Empty: {
      description: "No data"
    },
    Icon: {
      icon: "icon"
    },
    Text: {
      edit: "Edit",
      copy: "Copy",
      copied: "Copied",
      expand: "Expand"
    },
    PageHeader: {
      back: "Back"
    },
    Form: {
      optional: "(optional)",
      defaultValidateMessages: {
        default: "Field validation error for ${label}",
        required: "Please enter ${label}",
        enum: "${label} must be one of [${enum}]",
        whitespace: "${label} cannot be a blank character",
        date: {
          format: "${label} date format is invalid",
          parse: "${label} cannot be converted to a date",
          invalid: "${label} is an invalid date"
        },
        types: {
          string: typeTemplate$2,
          method: typeTemplate$2,
          array: typeTemplate$2,
          object: typeTemplate$2,
          number: typeTemplate$2,
          date: typeTemplate$2,
          boolean: typeTemplate$2,
          integer: typeTemplate$2,
          float: typeTemplate$2,
          regexp: typeTemplate$2,
          email: typeTemplate$2,
          url: typeTemplate$2,
          hex: typeTemplate$2
        },
        string: {
          len: "${label} must be ${len} characters",
          min: "${label} must be at least ${min} characters",
          max: "${label} must be up to ${max} characters",
          range: "${label} must be between ${min}-${max} characters"
        },
        number: {
          len: "${label} must be equal to ${len}",
          min: "${label} must be minimum ${min}",
          max: "${label} must be maximum ${max}",
          range: "${label} must be between ${min}-${max}"
        },
        array: {
          len: "Must be ${len} ${label}",
          min: "At least ${min} ${label}",
          max: "At most ${max} ${label}",
          range: "The amount of ${label} must be between ${min}-${max}"
        },
        pattern: {
          mismatch: "${label} does not match the pattern ${pattern}"
        }
      }
    },
    Image: {
      preview: "Preview"
    },
    QRCode: {
      expired: "QR code expired",
      refresh: "Refresh",
      scanned: "Scanned"
    }
  };
  const LocaleReceiver = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "LocaleReceiver",
    props: {
      componentName: String,
      defaultLocale: {
        type: [Object, Function]
      },
      children: {
        type: Function
      }
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const localeData = inject("localeData", {});
      const locale2 = computed(() => {
        const {
          componentName = "global",
          defaultLocale
        } = props;
        const locale3 = defaultLocale || localeValues$1[componentName || "global"];
        const {
          antLocale
        } = localeData;
        const localeFromContext = componentName && antLocale ? antLocale[componentName] : {};
        return _extends$1(_extends$1({}, typeof locale3 === "function" ? locale3() : locale3), localeFromContext || {});
      });
      const localeCode = computed(() => {
        const {
          antLocale
        } = localeData;
        const localeCode2 = antLocale && antLocale.locale;
        if (antLocale && antLocale.exist && !localeCode2) {
          return localeValues$1.locale;
        }
        return localeCode2;
      });
      return () => {
        const children = props.children || slots.default;
        const {
          antLocale
        } = localeData;
        return children === null || children === void 0 ? void 0 : children(locale2.value, localeCode.value, antLocale);
      };
    }
  });
  function useLocaleReceiver(componentName, defaultLocale, propsLocale) {
    const localeData = inject("localeData", {});
    const componentLocale = computed(() => {
      const {
        antLocale
      } = localeData;
      const locale2 = unref(defaultLocale) || localeValues$1[componentName || "global"];
      const localeFromContext = componentName && antLocale ? antLocale[componentName] : {};
      return _extends$1(_extends$1(_extends$1({}, typeof locale2 === "function" ? locale2() : locale2), localeFromContext || {}), unref(propsLocale) || {});
    });
    return [componentLocale];
  }
  function murmur2(str) {
    var h2 = 0;
    var k2, i2 = 0, len = str.length;
    for (; len >= 4; ++i2, len -= 4) {
      k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
      k2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
      k2 ^= /* k >>> r: */
      k2 >>> 24;
      h2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
      case 2:
        h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
      case 1:
        h2 ^= str.charCodeAt(i2) & 255;
        h2 = /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    h2 ^= h2 >>> 13;
    h2 = /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
  }
  const SPLIT = "%";
  class Entity {
    constructor(instanceId) {
      this.cache = /* @__PURE__ */ new Map();
      this.instanceId = instanceId;
    }
    get(keys2) {
      return this.cache.get(Array.isArray(keys2) ? keys2.join(SPLIT) : keys2) || null;
    }
    update(keys2, valueFn) {
      const path = Array.isArray(keys2) ? keys2.join(SPLIT) : keys2;
      const prevValue = this.cache.get(path);
      const nextValue = valueFn(prevValue);
      if (nextValue === null) {
        this.cache.delete(path);
      } else {
        this.cache.set(path, nextValue);
      }
    }
  }
  const CacheEntity = Entity;
  const ATTR_TOKEN = "data-token-hash";
  const ATTR_MARK = "data-css-hash";
  const ATTR_CACHE_PATH = "data-cache-path";
  const CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
  function createCache() {
    const cssinjsInstanceId = Math.random().toString(12).slice(2);
    if (typeof document !== "undefined" && document.head && document.body) {
      const styles = document.body.querySelectorAll(`style[${ATTR_MARK}]`) || [];
      const {
        firstChild
      } = document.head;
      Array.from(styles).forEach((style) => {
        style[CSS_IN_JS_INSTANCE] = style[CSS_IN_JS_INSTANCE] || cssinjsInstanceId;
        if (style[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
          document.head.insertBefore(style, firstChild);
        }
      });
      const styleHash = {};
      Array.from(document.querySelectorAll(`style[${ATTR_MARK}]`)).forEach((style) => {
        var _a2;
        const hash = style.getAttribute(ATTR_MARK);
        if (styleHash[hash]) {
          if (style[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
            (_a2 = style.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(style);
          }
        } else {
          styleHash[hash] = true;
        }
      });
    }
    return new CacheEntity(cssinjsInstanceId);
  }
  const StyleContextKey = Symbol("StyleContextKey");
  const getCache = () => {
    var _a2, _b, _c;
    const instance = getCurrentInstance();
    let cache;
    if (instance && instance.appContext) {
      const globalCache = (_c = (_b = (_a2 = instance.appContext) === null || _a2 === void 0 ? void 0 : _a2.config) === null || _b === void 0 ? void 0 : _b.globalProperties) === null || _c === void 0 ? void 0 : _c.__ANTDV_CSSINJS_CACHE__;
      if (globalCache) {
        cache = globalCache;
      } else {
        cache = createCache();
        if (instance.appContext.config.globalProperties) {
          instance.appContext.config.globalProperties.__ANTDV_CSSINJS_CACHE__ = cache;
        }
      }
    } else {
      cache = createCache();
    }
    return cache;
  };
  const defaultStyleContext = {
    cache: createCache(),
    defaultCache: true,
    hashPriority: "low"
  };
  const useStyleInject = () => {
    const cache = getCache();
    return inject(StyleContextKey, shallowRef(_extends$1(_extends$1({}, defaultStyleContext), {
      cache
    })));
  };
  const useStyleProvider = (props) => {
    const parentContext = useStyleInject();
    const context3 = shallowRef(_extends$1(_extends$1({}, defaultStyleContext), {
      cache: createCache()
    }));
    watch([() => unref(props), parentContext], () => {
      const mergedContext = _extends$1({}, parentContext.value);
      const propsValue = unref(props);
      Object.keys(propsValue).forEach((key2) => {
        const value = propsValue[key2];
        if (propsValue[key2] !== void 0) {
          mergedContext[key2] = value;
        }
      });
      const {
        cache
      } = propsValue;
      mergedContext.cache = mergedContext.cache || createCache();
      mergedContext.defaultCache = !cache && parentContext.value.defaultCache;
      context3.value = mergedContext;
    }, {
      immediate: true
    });
    provide(StyleContextKey, context3);
    return context3;
  };
  const styleProviderProps = () => ({
    autoClear: booleanType(),
    /** @private Test only. Not work in production. */
    mock: stringType(),
    /**
     * Only set when you need ssr to extract style on you own.
     * If not provided, it will auto create <style /> on the end of Provider in server side.
     */
    cache: objectType(),
    /** Tell children that this context is default generated context */
    defaultCache: booleanType(),
    /** Use `:where` selector to reduce hashId css selector priority */
    hashPriority: stringType(),
    /** Tell cssinjs where to inject style in */
    container: someType(),
    /** Component wil render inline  `<style />` for fallback in SSR. Not recommend. */
    ssrInline: booleanType(),
    /** Transform css before inject in document. Please note that `transformers` do not support dynamic update */
    transformers: arrayType(),
    /**
     * Linters to lint css before inject in document.
     * Styles will be linted after transforming.
     * Please note that `linters` do not support dynamic update.
     */
    linters: arrayType()
  });
  withInstall(/* @__PURE__ */ defineComponent({
    name: "AStyleProvider",
    inheritAttrs: false,
    props: styleProviderProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useStyleProvider(props);
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  }));
  let webpackHMR = false;
  function useDevHMR() {
    return webpackHMR;
  }
  const useHMR = useDevHMR;
  if (typeof module !== "undefined" && module && module.hot && typeof window !== "undefined") {
    const win = window;
    if (typeof win.webpackHotUpdate === "function") {
      const originWebpackHotUpdate = win.webpackHotUpdate;
      win.webpackHotUpdate = function() {
        webpackHMR = true;
        setTimeout(() => {
          webpackHMR = false;
        }, 0);
        return originWebpackHotUpdate(...arguments);
      };
    }
  }
  function useClientCache(prefix, keyPath, cacheFn, onCacheRemove) {
    const styleContext = useStyleInject();
    const fullPathStr = shallowRef("");
    const res = shallowRef();
    watchEffect(() => {
      fullPathStr.value = [prefix, ...keyPath.value].join("%");
    });
    const HMRUpdate = useHMR();
    const clearCache = (pathStr) => {
      styleContext.value.cache.update(pathStr, (prevCache) => {
        const [times = 0, cache] = prevCache || [];
        const nextCount = times - 1;
        if (nextCount === 0) {
          onCacheRemove === null || onCacheRemove === void 0 ? void 0 : onCacheRemove(cache, false);
          return null;
        }
        return [times - 1, cache];
      });
    };
    watch(fullPathStr, (newStr, oldStr) => {
      if (oldStr)
        clearCache(oldStr);
      styleContext.value.cache.update(newStr, (prevCache) => {
        const [times = 0, cache] = prevCache || [];
        let tmpCache = cache;
        if (cache && HMRUpdate) {
          onCacheRemove === null || onCacheRemove === void 0 ? void 0 : onCacheRemove(tmpCache, HMRUpdate);
          tmpCache = null;
        }
        const mergedCache = tmpCache || cacheFn();
        return [times + 1, mergedCache];
      });
      res.value = styleContext.value.cache.get(fullPathStr.value)[1];
    }, {
      immediate: true
    });
    onBeforeUnmount(() => {
      clearCache(fullPathStr.value);
    });
    return res;
  }
  function canUseDom$1() {
    return !!(typeof window !== "undefined" && window.document && window.document.createElement);
  }
  function contains$1(root2, n2) {
    if (!root2) {
      return false;
    }
    if (root2.contains) {
      return root2.contains(n2);
    }
    return false;
  }
  const APPEND_ORDER$1 = "data-vc-order";
  const MARK_KEY$1 = `vc-util-key`;
  const containerCache$1 = /* @__PURE__ */ new Map();
  function getMark$1() {
    let {
      mark
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (mark) {
      return mark.startsWith("data-") ? mark : `data-${mark}`;
    }
    return MARK_KEY$1;
  }
  function getContainer$2(option) {
    if (option.attachTo) {
      return option.attachTo;
    }
    const head = document.querySelector("head");
    return head || document.body;
  }
  function getOrder$1(prepend) {
    if (prepend === "queue") {
      return "prependQueue";
    }
    return prepend ? "prepend" : "append";
  }
  function findStyles$1(container) {
    return Array.from((containerCache$1.get(container) || container).children).filter((node2) => node2.tagName === "STYLE");
  }
  function injectCSS$1(css2) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!canUseDom$1()) {
      return null;
    }
    const {
      csp,
      prepend
    } = option;
    const styleNode = document.createElement("style");
    styleNode.setAttribute(APPEND_ORDER$1, getOrder$1(prepend));
    if (csp === null || csp === void 0 ? void 0 : csp.nonce) {
      styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
    }
    styleNode.innerHTML = css2;
    const container = getContainer$2(option);
    const {
      firstChild
    } = container;
    if (prepend) {
      if (prepend === "queue") {
        const existStyle = findStyles$1(container).filter((node2) => ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER$1)));
        if (existStyle.length) {
          container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
          return styleNode;
        }
      }
      container.insertBefore(styleNode, firstChild);
    } else {
      container.appendChild(styleNode);
    }
    return styleNode;
  }
  function findExistNode$1(key2) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const container = getContainer$2(option);
    return findStyles$1(container).find((node2) => node2.getAttribute(getMark$1(option)) === key2);
  }
  function removeCSS(key2) {
    let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const existNode = findExistNode$1(key2, option);
    if (existNode) {
      const container = getContainer$2(option);
      container.removeChild(existNode);
    }
  }
  function syncRealContainer$1(container, option) {
    const cachedRealContainer = containerCache$1.get(container);
    if (!cachedRealContainer || !contains$1(document, cachedRealContainer)) {
      const placeholderStyle = injectCSS$1("", option);
      const {
        parentNode
      } = placeholderStyle;
      containerCache$1.set(container, parentNode);
      container.removeChild(placeholderStyle);
    }
  }
  function updateCSS$1(css2, key2) {
    let option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var _a2, _b, _c;
    const container = getContainer$2(option);
    syncRealContainer$1(container, option);
    const existNode = findExistNode$1(key2, option);
    if (existNode) {
      if (((_a2 = option.csp) === null || _a2 === void 0 ? void 0 : _a2.nonce) && existNode.nonce !== ((_b = option.csp) === null || _b === void 0 ? void 0 : _b.nonce)) {
        existNode.nonce = (_c = option.csp) === null || _c === void 0 ? void 0 : _c.nonce;
      }
      if (existNode.innerHTML !== css2) {
        existNode.innerHTML = css2;
      }
      return existNode;
    }
    const newNode = injectCSS$1(css2, option);
    newNode.setAttribute(getMark$1(option), key2);
    return newNode;
  }
  function sameDerivativeOption(left, right) {
    if (left.length !== right.length) {
      return false;
    }
    for (let i2 = 0; i2 < left.length; i2++) {
      if (left[i2] !== right[i2]) {
        return false;
      }
    }
    return true;
  }
  class ThemeCache {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
      this.keys = [];
      this.cacheCallTimes = 0;
    }
    size() {
      return this.keys.length;
    }
    internalGet(derivativeOption) {
      let updateCallTimes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      let cache = {
        map: this.cache
      };
      derivativeOption.forEach((derivative2) => {
        var _a2;
        if (!cache) {
          cache = void 0;
        } else {
          cache = (_a2 = cache === null || cache === void 0 ? void 0 : cache.map) === null || _a2 === void 0 ? void 0 : _a2.get(derivative2);
        }
      });
      if ((cache === null || cache === void 0 ? void 0 : cache.value) && updateCallTimes) {
        cache.value[1] = this.cacheCallTimes++;
      }
      return cache === null || cache === void 0 ? void 0 : cache.value;
    }
    get(derivativeOption) {
      var _a2;
      return (_a2 = this.internalGet(derivativeOption, true)) === null || _a2 === void 0 ? void 0 : _a2[0];
    }
    has(derivativeOption) {
      return !!this.internalGet(derivativeOption);
    }
    set(derivativeOption, value) {
      if (!this.has(derivativeOption)) {
        if (this.size() + 1 > ThemeCache.MAX_CACHE_SIZE + ThemeCache.MAX_CACHE_OFFSET) {
          const [targetKey] = this.keys.reduce((result, key2) => {
            const [, callTimes] = result;
            if (this.internalGet(key2)[1] < callTimes) {
              return [key2, this.internalGet(key2)[1]];
            }
            return result;
          }, [this.keys[0], this.cacheCallTimes]);
          this.delete(targetKey);
        }
        this.keys.push(derivativeOption);
      }
      let cache = this.cache;
      derivativeOption.forEach((derivative2, index2) => {
        if (index2 === derivativeOption.length - 1) {
          cache.set(derivative2, {
            value: [value, this.cacheCallTimes++]
          });
        } else {
          const cacheValue = cache.get(derivative2);
          if (!cacheValue) {
            cache.set(derivative2, {
              map: /* @__PURE__ */ new Map()
            });
          } else if (!cacheValue.map) {
            cacheValue.map = /* @__PURE__ */ new Map();
          }
          cache = cache.get(derivative2).map;
        }
      });
    }
    deleteByPath(currentCache, derivatives) {
      var _a2;
      const cache = currentCache.get(derivatives[0]);
      if (derivatives.length === 1) {
        if (!cache.map) {
          currentCache.delete(derivatives[0]);
        } else {
          currentCache.set(derivatives[0], {
            map: cache.map
          });
        }
        return (_a2 = cache.value) === null || _a2 === void 0 ? void 0 : _a2[0];
      }
      const result = this.deleteByPath(cache.map, derivatives.slice(1));
      if ((!cache.map || cache.map.size === 0) && !cache.value) {
        currentCache.delete(derivatives[0]);
      }
      return result;
    }
    delete(derivativeOption) {
      if (this.has(derivativeOption)) {
        this.keys = this.keys.filter((item) => !sameDerivativeOption(item, derivativeOption));
        return this.deleteByPath(this.cache, derivativeOption);
      }
      return void 0;
    }
  }
  ThemeCache.MAX_CACHE_SIZE = 20;
  ThemeCache.MAX_CACHE_OFFSET = 5;
  let warned = {};
  function warning$4(valid, message) {
    if (!valid && console !== void 0) {
      console.error(`Warning: ${message}`);
    }
  }
  function call(method4, valid, message) {
    if (!valid && !warned[message]) {
      method4(false, message);
      warned[message] = true;
    }
  }
  function warningOnce(valid, message) {
    call(warning$4, valid, message);
  }
  function noop$4() {
  }
  let warning$2 = noop$4;
  {
    warning$2 = (valid, component, message) => {
      warningOnce(valid, `[ant-design-vue: ${component}] ${message}`);
    };
  }
  const warning$3 = warning$2;
  let uuid$3 = 0;
  class Theme {
    constructor(derivatives) {
      this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
      this.id = uuid$3;
      if (derivatives.length === 0) {
        warning$3(derivatives.length > 0, "[Ant Design Vue CSS-in-JS] Theme should have at least one derivative function.");
      }
      uuid$3 += 1;
    }
    getDerivativeToken(token2) {
      return this.derivatives.reduce((result, derivative2) => derivative2(token2, result), void 0);
    }
  }
  const cacheThemes = new ThemeCache();
  function createTheme(derivatives) {
    const derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
    if (!cacheThemes.has(derivativeArr)) {
      cacheThemes.set(derivativeArr, new Theme(derivativeArr));
    }
    return cacheThemes.get(derivativeArr);
  }
  const flattenTokenCache = /* @__PURE__ */ new WeakMap();
  function flattenToken(token2) {
    let str = flattenTokenCache.get(token2) || "";
    if (!str) {
      Object.keys(token2).forEach((key2) => {
        const value = token2[key2];
        str += key2;
        if (value instanceof Theme) {
          str += value.id;
        } else if (value && typeof value === "object") {
          str += flattenToken(value);
        } else {
          str += value;
        }
      });
      flattenTokenCache.set(token2, str);
    }
    return str;
  }
  function token2key(token2, salt) {
    return murmur2(`${salt}_${flattenToken(token2)}`);
  }
  const randomSelectorKey = `random-${Date.now()}-${Math.random()}`.replace(/\./g, "");
  const checkContent = "_bAmBoO_";
  function supportSelector(styleStr, handleElement, supportCheck) {
    var _a2, _b;
    if (canUseDom$1()) {
      updateCSS$1(styleStr, randomSelectorKey);
      const ele = document.createElement("div");
      ele.style.position = "fixed";
      ele.style.left = "0";
      ele.style.top = "0";
      handleElement === null || handleElement === void 0 ? void 0 : handleElement(ele);
      document.body.appendChild(ele);
      {
        ele.innerHTML = "Test";
        ele.style.zIndex = "9999999";
      }
      const support = supportCheck ? supportCheck(ele) : (_a2 = getComputedStyle(ele).content) === null || _a2 === void 0 ? void 0 : _a2.includes(checkContent);
      (_b = ele.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(ele);
      removeCSS(randomSelectorKey);
      return support;
    }
    return false;
  }
  let canLayer = void 0;
  function supportLayer() {
    if (canLayer === void 0) {
      canLayer = supportSelector(`@layer ${randomSelectorKey} { .${randomSelectorKey} { content: "${checkContent}"!important; } }`, (ele) => {
        ele.className = randomSelectorKey;
      });
    }
    return canLayer;
  }
  const EMPTY_OVERRIDE = {};
  const hashPrefix = "css-dev-only-do-not-override" ;
  const tokenKeys = /* @__PURE__ */ new Map();
  function recordCleanToken(tokenKey) {
    tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
  }
  function removeStyleTags(key2, instanceId) {
    if (typeof document !== "undefined") {
      const styles = document.querySelectorAll(`style[${ATTR_TOKEN}="${key2}"]`);
      styles.forEach((style) => {
        var _a2;
        if (style[CSS_IN_JS_INSTANCE] === instanceId) {
          (_a2 = style.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(style);
        }
      });
    }
  }
  const TOKEN_THRESHOLD = 0;
  function cleanTokenStyle(tokenKey, instanceId) {
    tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
    const tokenKeyList = Array.from(tokenKeys.keys());
    const cleanableKeyList = tokenKeyList.filter((key2) => {
      const count = tokenKeys.get(key2) || 0;
      return count <= 0;
    });
    if (tokenKeyList.length - cleanableKeyList.length > TOKEN_THRESHOLD) {
      cleanableKeyList.forEach((key2) => {
        removeStyleTags(key2, instanceId);
        tokenKeys.delete(key2);
      });
    }
  }
  const getComputedToken = (originToken, overrideToken, theme, format2) => {
    const derivativeToken = theme.getDerivativeToken(originToken);
    let mergedDerivativeToken = _extends$1(_extends$1({}, derivativeToken), overrideToken);
    if (format2) {
      mergedDerivativeToken = format2(mergedDerivativeToken);
    }
    return mergedDerivativeToken;
  };
  function useCacheToken(theme, tokens) {
    let option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ref({});
    const style = useStyleInject();
    const mergedToken = computed(() => _extends$1({}, ...tokens.value));
    const tokenStr = computed(() => flattenToken(mergedToken.value));
    const overrideTokenStr = computed(() => flattenToken(option.value.override || EMPTY_OVERRIDE));
    const cachedToken = useClientCache("token", computed(() => [option.value.salt || "", theme.value.id, tokenStr.value, overrideTokenStr.value]), () => {
      const {
        salt = "",
        override = EMPTY_OVERRIDE,
        formatToken: formatToken2,
        getComputedToken: compute
      } = option.value;
      const mergedDerivativeToken = compute ? compute(mergedToken.value, override, theme.value) : getComputedToken(mergedToken.value, override, theme.value, formatToken2);
      const tokenKey = token2key(mergedDerivativeToken, salt);
      mergedDerivativeToken._tokenKey = tokenKey;
      recordCleanToken(tokenKey);
      const hashId = `${hashPrefix}-${murmur2(tokenKey)}`;
      mergedDerivativeToken._hashId = hashId;
      return [mergedDerivativeToken, hashId];
    }, (cache) => {
      var _a2;
      cleanTokenStyle(cache[0]._tokenKey, (_a2 = style.value) === null || _a2 === void 0 ? void 0 : _a2.cache.instanceId);
    });
    return cachedToken;
  }
  var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";
  var abs = Math.abs;
  var from = String.fromCharCode;
  function trim(value) {
    return value.trim();
  }
  function replace(value, pattern4, replacement) {
    return value.replace(pattern4, replacement);
  }
  function indexof(value, search, position2) {
    return value.indexOf(search, position2);
  }
  function charat(value, index2) {
    return value.charCodeAt(index2) | 0;
  }
  function substr(value, begin, end) {
    return value.slice(begin, end);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array4) {
    return array4.push(value), value;
  }
  var line = 1;
  var column = 1;
  var length = 0;
  var position = 0;
  var character = 0;
  var characters = "";
  function node(value, root2, parent2, type4, props, children, length2, siblings) {
    return { value, root: root2, parent: parent2, type: type4, props, children, line, column, length: length2, return: "", siblings };
  }
  function char() {
    return character;
  }
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position < length ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice(begin, end) {
    return substr(characters, begin, end);
  }
  function token(type4) {
    switch (type4) {
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      case 59:
      case 123:
      case 125:
        return 4;
      case 58:
        return 3;
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type4) {
    return trim(slice(position - 1, delimiter(type4 === 91 ? type4 + 2 : type4 === 40 ? type4 + 1 : type4)));
  }
  function whitespace$1(type4) {
    while (character = peek())
      if (character < 33)
        next();
      else
        break;
    return token(type4) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index2, count) {
    while (--count && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
  }
  function delimiter(type4) {
    while (next())
      switch (character) {
        case type4:
          return position;
        case 34:
        case 39:
          if (type4 !== 34 && type4 !== 39)
            delimiter(character);
          break;
        case 40:
          if (type4 === 41)
            delimiter(type4);
          break;
        case 92:
          next();
          break;
      }
    return position;
  }
  function commenter(type4, index2) {
    while (next())
      if (type4 + character === 47 + 10)
        break;
      else if (type4 + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice(index2, position - 1) + "*" + from(type4 === 47 ? type4 : next());
  }
  function identifier(index2) {
    while (!token(peek()))
      next();
    return slice(index2, position);
  }
  function compile(value) {
    return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse(value, root2, parent2, rule, rules2, rulesets, pseudo, points, declarations) {
    var index2 = 0;
    var offset3 = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property2 = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type4 = "";
    var props = rules2;
    var children = rulesets;
    var reference = rule;
    var characters2 = type4;
    while (scanning)
      switch (previous = character2, character2 = next()) {
        case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs(index2 ? points[index2 - 1] : 0)) != -1)
              ampersand = -1;
            break;
          }
        case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
        case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace$1(previous);
          break;
        case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
        case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment(commenter(next(), caret()), root2, parent2, declarations), declarations);
              break;
            default:
              characters2 += "/";
          }
          break;
        case 123 * variable:
          points[index2++] = strlen(characters2) * ampersand;
        case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
            case 0:
            case 125:
              scanning = 0;
            case 59 + offset3:
              if (ampersand == -1)
                characters2 = replace(characters2, /\f/g, "");
              if (property2 > 0 && strlen(characters2) - length2)
                append(property2 > 32 ? declaration(characters2 + ";", rule, parent2, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent2, length2 - 2, declarations), declarations);
              break;
            case 59:
              characters2 += ";";
            default:
              append(reference = ruleset(characters2, root2, parent2, index2, offset3, rules2, points, type4, props = [], children = [], length2, rulesets), rulesets);
              if (character2 === 123)
                if (offset3 === 0)
                  parse(characters2, root2, reference, reference, props, rulesets, length2, points, children);
                else
                  switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points, type4, rules2, props = [], length2, children), children), rules2, children, length2, points, rule ? props : children);
                      break;
                    default:
                      parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                  }
          }
          index2 = offset3 = property2 = 0, variable = ampersand = 1, type4 = characters2 = "", length2 = pseudo;
          break;
        case 58:
          length2 = 1 + strlen(characters2), property2 = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
            case 38:
              ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
              break;
            case 44:
              points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
            case 64:
              if (peek() === 45)
                characters2 += delimit(next());
              atrule = peek(), offset3 = length2 = strlen(type4 = characters2 += identifier(caret())), character2++;
              break;
            case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root2, parent2, index2, offset3, rules2, points, type4, props, children, length2, siblings) {
    var post = offset3 - 1;
    var rule = offset3 === 0 ? rules2 : [""];
    var size2 = sizeof(rule);
    for (var i2 = 0, j2 = 0, k2 = 0; i2 < index2; ++i2)
      for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z2 = value; x2 < size2; ++x2)
        if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
          props[k2++] = z2;
    return node(value, root2, parent2, offset3 === 0 ? RULESET : type4, props, children, length2, siblings);
  }
  function comment(value, root2, parent2, siblings) {
    return node(value, root2, parent2, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
  }
  function declaration(value, root2, parent2, length2, siblings) {
    return node(value, root2, parent2, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
  }
  function serialize(children, callback) {
    var output = "";
    for (var i2 = 0; i2 < children.length; i2++)
      output += callback(children[i2], i2, children, callback) || "";
    return output;
  }
  function stringify(element, index2, children, callback) {
    switch (element.type) {
      case LAYER:
        if (element.children.length)
          break;
      case IMPORT:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize(element.children, callback) + "}";
      case RULESET:
        if (!strlen(element.value = element.props.join(",")))
          return "";
    }
    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }
  function lintWarning(message, info) {
    const {
      path,
      parentSelectors
    } = info;
    warningOnce(false, `[Ant Design Vue CSS-in-JS] ${path ? `Error in '${path}': ` : ""}${message}${parentSelectors.length ? ` Selector info: ${parentSelectors.join(" -> ")}` : ""}`);
  }
  const linter$1 = (key2, value, info) => {
    if (key2 === "content") {
      const contentValuePattern = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
      const contentValues = ["normal", "none", "initial", "inherit", "unset"];
      if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        lintWarning(`You seem to be using a value for 'content' without quotes, try replacing it with \`content: '"${value}"'\`.`, info);
      }
    }
  };
  const contentQuotesLinter = linter$1;
  const linter = (key2, value, info) => {
    if (key2 === "animation") {
      if (info.hashId && value !== "none") {
        lintWarning(`You seem to be using hashed animation '${value}', in which case 'animationName' with Keyframe as value is recommended.`, info);
      }
    }
  };
  const hashedAnimationLinter = linter;
  const ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path";
  const CSS_FILE_STYLE = "_FILE_STYLE__";
  let cachePathMap;
  let fromCSSFile = true;
  function prepare() {
    var _a2;
    if (!cachePathMap) {
      cachePathMap = {};
      if (canUseDom$1()) {
        const div = document.createElement("div");
        div.className = ATTR_CACHE_MAP;
        div.style.position = "fixed";
        div.style.visibility = "hidden";
        div.style.top = "-9999px";
        document.body.appendChild(div);
        let content = getComputedStyle(div).content || "";
        content = content.replace(/^"/, "").replace(/"$/, "");
        content.split(";").forEach((item) => {
          const [path, hash] = item.split(":");
          cachePathMap[path] = hash;
        });
        const inlineMapStyle = document.querySelector(`style[${ATTR_CACHE_MAP}]`);
        if (inlineMapStyle) {
          fromCSSFile = false;
          (_a2 = inlineMapStyle.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(inlineMapStyle);
        }
        document.body.removeChild(div);
      }
    }
  }
  function existPath(path) {
    prepare();
    return !!cachePathMap[path];
  }
  function getStyleAndHash(path) {
    const hash = cachePathMap[path];
    let styleStr = null;
    if (hash && canUseDom$1()) {
      if (fromCSSFile) {
        styleStr = CSS_FILE_STYLE;
      } else {
        const style = document.querySelector(`style[${ATTR_MARK}="${cachePathMap[path]}"]`);
        if (style) {
          styleStr = style.innerHTML;
        } else {
          delete cachePathMap[path];
        }
      }
    }
    return [styleStr, hash];
  }
  const isClientSide = canUseDom$1();
  const SKIP_CHECK = "_skip_check_";
  const MULTI_VALUE = "_multi_value_";
  function normalizeStyle(styleStr) {
    const serialized = serialize(compile(styleStr), stringify);
    return serialized.replace(/\{%%%\:[^;];}/g, ";");
  }
  function isCompoundCSSProperty(value) {
    return typeof value === "object" && value && (SKIP_CHECK in value || MULTI_VALUE in value);
  }
  function injectSelectorHash(key2, hashId, hashPriority) {
    if (!hashId) {
      return key2;
    }
    const hashClassName = `.${hashId}`;
    const hashSelector = hashPriority === "low" ? `:where(${hashClassName})` : hashClassName;
    const keys2 = key2.split(",").map((k2) => {
      var _a2;
      const fullPath = k2.trim().split(/\s+/);
      let firstPath = fullPath[0] || "";
      const htmlElement = ((_a2 = firstPath.match(/^\w+/)) === null || _a2 === void 0 ? void 0 : _a2[0]) || "";
      firstPath = `${htmlElement}${hashSelector}${firstPath.slice(htmlElement.length)}`;
      return [firstPath, ...fullPath.slice(1)].join(" ");
    });
    return keys2.join(",");
  }
  const globalEffectStyleKeys = /* @__PURE__ */ new Set();
  const parseStyle = function(interpolation) {
    let config3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let {
      root: root2,
      injectHash,
      parentSelectors
    } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      root: true,
      parentSelectors: []
    };
    const {
      hashId,
      layer,
      path,
      hashPriority,
      transformers = [],
      linters = []
    } = config3;
    let styleStr = "";
    let effectStyle = {};
    function parseKeyframes(keyframes) {
      const animationName = keyframes.getName(hashId);
      if (!effectStyle[animationName]) {
        const [parsedStr] = parseStyle(keyframes.style, config3, {
          root: false,
          parentSelectors
        });
        effectStyle[animationName] = `@keyframes ${keyframes.getName(hashId)}${parsedStr}`;
      }
    }
    function flattenList(list) {
      let fullList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      list.forEach((item) => {
        if (Array.isArray(item)) {
          flattenList(item, fullList);
        } else if (item) {
          fullList.push(item);
        }
      });
      return fullList;
    }
    const flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
    flattenStyleList.forEach((originStyle) => {
      const style = typeof originStyle === "string" && !root2 ? {} : originStyle;
      if (typeof style === "string") {
        styleStr += `${style}
`;
      } else if (style._keyframe) {
        parseKeyframes(style);
      } else {
        const mergedStyle = transformers.reduce((prev2, trans) => {
          var _a2;
          return ((_a2 = trans === null || trans === void 0 ? void 0 : trans.visit) === null || _a2 === void 0 ? void 0 : _a2.call(trans, prev2)) || prev2;
        }, style);
        Object.keys(mergedStyle).forEach((key2) => {
          var _a2;
          const value = mergedStyle[key2];
          if (typeof value === "object" && value && (key2 !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
            let subInjectHash = false;
            let mergedKey = key2.trim();
            let nextRoot = false;
            if ((root2 || injectHash) && hashId) {
              if (mergedKey.startsWith("@")) {
                subInjectHash = true;
              } else {
                mergedKey = injectSelectorHash(key2, hashId, hashPriority);
              }
            } else if (root2 && !hashId && (mergedKey === "&" || mergedKey === "")) {
              mergedKey = "";
              nextRoot = true;
            }
            const [parsedStr, childEffectStyle] = parseStyle(value, config3, {
              root: nextRoot,
              injectHash: subInjectHash,
              parentSelectors: [...parentSelectors, mergedKey]
            });
            effectStyle = _extends$1(_extends$1({}, effectStyle), childEffectStyle);
            styleStr += `${mergedKey}${parsedStr}`;
          } else {
            let appendStyle = function(cssKey, cssValue) {
              if (typeof value !== "object" || !(value === null || value === void 0 ? void 0 : value[SKIP_CHECK])) {
                [contentQuotesLinter, hashedAnimationLinter, ...linters].forEach((linter2) => linter2(cssKey, cssValue, {
                  path,
                  hashId,
                  parentSelectors
                }));
              }
              const styleName = cssKey.replace(/[A-Z]/g, (match2) => `-${match2.toLowerCase()}`);
              let formatValue = cssValue;
              if (!unitlessKeys[cssKey] && typeof formatValue === "number" && formatValue !== 0) {
                formatValue = `${formatValue}px`;
              }
              if (cssKey === "animationName" && (cssValue === null || cssValue === void 0 ? void 0 : cssValue._keyframe)) {
                parseKeyframes(cssValue);
                formatValue = cssValue.getName(hashId);
              }
              styleStr += `${styleName}:${formatValue};`;
            };
            const actualValue = (_a2 = value === null || value === void 0 ? void 0 : value.value) !== null && _a2 !== void 0 ? _a2 : value;
            if (typeof value === "object" && (value === null || value === void 0 ? void 0 : value[MULTI_VALUE]) && Array.isArray(actualValue)) {
              actualValue.forEach((item) => {
                appendStyle(key2, item);
              });
            } else {
              appendStyle(key2, actualValue);
            }
          }
        });
      }
    });
    if (!root2) {
      styleStr = `{${styleStr}}`;
    } else if (layer && supportLayer()) {
      const layerCells = layer.split(",");
      const layerName = layerCells[layerCells.length - 1].trim();
      styleStr = `@layer ${layerName} {${styleStr}}`;
      if (layerCells.length > 1) {
        styleStr = `@layer ${layer}{%%%:%}${styleStr}`;
      }
    }
    return [styleStr, effectStyle];
  };
  function uniqueHash(path, styleStr) {
    return murmur2(`${path.join("%")}${styleStr}`);
  }
  function useStyleRegister(info, styleFn) {
    const styleContext = useStyleInject();
    const tokenKey = computed(() => info.value.token._tokenKey);
    const fullPath = computed(() => [tokenKey.value, ...info.value.path]);
    let isMergedClientSide = isClientSide;
    if (styleContext.value.mock !== void 0) {
      isMergedClientSide = styleContext.value.mock === "client";
    }
    useClientCache(
      "style",
      fullPath,
      // Create cache if needed
      () => {
        const {
          path,
          hashId,
          layer,
          nonce,
          clientOnly,
          order = 0
        } = info.value;
        const cachePath = fullPath.value.join("|");
        if (existPath(cachePath)) {
          const [inlineCacheStyleStr, styleHash] = getStyleAndHash(cachePath);
          if (inlineCacheStyleStr) {
            return [inlineCacheStyleStr, tokenKey.value, styleHash, {}, clientOnly, order];
          }
        }
        const styleObj = styleFn();
        const {
          hashPriority,
          container,
          transformers,
          linters,
          cache
        } = styleContext.value;
        const [parsedStyle, effectStyle] = parseStyle(styleObj, {
          hashId,
          hashPriority,
          layer,
          path: path.join("-"),
          transformers,
          linters
        });
        const styleStr = normalizeStyle(parsedStyle);
        const styleId = uniqueHash(fullPath.value, styleStr);
        if (isMergedClientSide) {
          const mergedCSSConfig = {
            mark: ATTR_MARK,
            prepend: "queue",
            attachTo: container,
            priority: order
          };
          const nonceStr = typeof nonce === "function" ? nonce() : nonce;
          if (nonceStr) {
            mergedCSSConfig.csp = {
              nonce: nonceStr
            };
          }
          const style = updateCSS$1(styleStr, styleId, mergedCSSConfig);
          style[CSS_IN_JS_INSTANCE] = cache.instanceId;
          style.setAttribute(ATTR_TOKEN, tokenKey.value);
          {
            style.setAttribute(ATTR_CACHE_PATH, fullPath.value.join("|"));
          }
          Object.keys(effectStyle).forEach((effectKey) => {
            if (!globalEffectStyleKeys.has(effectKey)) {
              globalEffectStyleKeys.add(effectKey);
              updateCSS$1(normalizeStyle(effectStyle[effectKey]), `_effect-${effectKey}`, {
                mark: ATTR_MARK,
                prepend: "queue",
                attachTo: container
              });
            }
          });
        }
        return [styleStr, tokenKey.value, styleId, effectStyle, clientOnly, order];
      },
      // Remove cache if no need
      (_ref, fromHMR) => {
        let [, , styleId] = _ref;
        if ((fromHMR || styleContext.value.autoClear) && isClientSide) {
          removeCSS(styleId, {
            mark: ATTR_MARK
          });
        }
      }
    );
    return (node2) => {
      return node2;
    };
  }
  class Keyframe {
    constructor(name2, style) {
      this._keyframe = true;
      this.name = name2;
      this.style = style;
    }
    getName() {
      let hashId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      return hashId ? `${hashId}-${this.name}` : this.name;
    }
  }
  const version = "4.1.2";
  const PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
  function bound01(n2, max) {
    if (isOnePointZero(n2)) {
      n2 = "100%";
    }
    var isPercent = isPercentage(n2);
    n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
    if (isPercent) {
      n2 = parseInt(String(n2 * max), 10) / 100;
    }
    if (Math.abs(n2 - max) < 1e-6) {
      return 1;
    }
    if (max === 360) {
      n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
    } else {
      n2 = n2 % max / parseFloat(String(max));
    }
    return n2;
  }
  function clamp01(val) {
    return Math.min(1, Math.max(0, val));
  }
  function isOnePointZero(n2) {
    return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
  }
  function isPercentage(n2) {
    return typeof n2 === "string" && n2.indexOf("%") !== -1;
  }
  function boundAlpha(a2) {
    a2 = parseFloat(a2);
    if (isNaN(a2) || a2 < 0 || a2 > 1) {
      a2 = 1;
    }
    return a2;
  }
  function convertToPercentage(n2) {
    if (n2 <= 1) {
      return "".concat(Number(n2) * 100, "%");
    }
    return n2;
  }
  function pad2(c2) {
    return c2.length === 1 ? "0" + c2 : String(c2);
  }
  function rgbToRgb(r2, g2, b2) {
    return {
      r: bound01(r2, 255) * 255,
      g: bound01(g2, 255) * 255,
      b: bound01(b2, 255) * 255
    };
  }
  function rgbToHsl(r2, g2, b2) {
    r2 = bound01(r2, 255);
    g2 = bound01(g2, 255);
    b2 = bound01(b2, 255);
    var max = Math.max(r2, g2, b2);
    var min = Math.min(r2, g2, b2);
    var h2 = 0;
    var s2 = 0;
    var l2 = (max + min) / 2;
    if (max === min) {
      s2 = 0;
      h2 = 0;
    } else {
      var d2 = max - min;
      s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
      switch (max) {
        case r2:
          h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          h2 = (b2 - r2) / d2 + 2;
          break;
        case b2:
          h2 = (r2 - g2) / d2 + 4;
          break;
      }
      h2 /= 6;
    }
    return { h: h2, s: s2, l: l2 };
  }
  function hue2rgb(p, q2, t2) {
    if (t2 < 0) {
      t2 += 1;
    }
    if (t2 > 1) {
      t2 -= 1;
    }
    if (t2 < 1 / 6) {
      return p + (q2 - p) * (6 * t2);
    }
    if (t2 < 1 / 2) {
      return q2;
    }
    if (t2 < 2 / 3) {
      return p + (q2 - p) * (2 / 3 - t2) * 6;
    }
    return p;
  }
  function hslToRgb(h2, s2, l2) {
    var r2;
    var g2;
    var b2;
    h2 = bound01(h2, 360);
    s2 = bound01(s2, 100);
    l2 = bound01(l2, 100);
    if (s2 === 0) {
      g2 = l2;
      b2 = l2;
      r2 = l2;
    } else {
      var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
      var p = 2 * l2 - q2;
      r2 = hue2rgb(p, q2, h2 + 1 / 3);
      g2 = hue2rgb(p, q2, h2);
      b2 = hue2rgb(p, q2, h2 - 1 / 3);
    }
    return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
  }
  function rgbToHsv(r2, g2, b2) {
    r2 = bound01(r2, 255);
    g2 = bound01(g2, 255);
    b2 = bound01(b2, 255);
    var max = Math.max(r2, g2, b2);
    var min = Math.min(r2, g2, b2);
    var h2 = 0;
    var v2 = max;
    var d2 = max - min;
    var s2 = max === 0 ? 0 : d2 / max;
    if (max === min) {
      h2 = 0;
    } else {
      switch (max) {
        case r2:
          h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          h2 = (b2 - r2) / d2 + 2;
          break;
        case b2:
          h2 = (r2 - g2) / d2 + 4;
          break;
      }
      h2 /= 6;
    }
    return { h: h2, s: s2, v: v2 };
  }
  function hsvToRgb(h2, s2, v2) {
    h2 = bound01(h2, 360) * 6;
    s2 = bound01(s2, 100);
    v2 = bound01(v2, 100);
    var i2 = Math.floor(h2);
    var f2 = h2 - i2;
    var p = v2 * (1 - s2);
    var q2 = v2 * (1 - f2 * s2);
    var t2 = v2 * (1 - (1 - f2) * s2);
    var mod = i2 % 6;
    var r2 = [v2, q2, p, p, t2, v2][mod];
    var g2 = [t2, v2, v2, q2, p, p][mod];
    var b2 = [p, p, t2, v2, v2, q2][mod];
    return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
  }
  function rgbToHex(r2, g2, b2, allow3Char) {
    var hex2 = [
      pad2(Math.round(r2).toString(16)),
      pad2(Math.round(g2).toString(16)),
      pad2(Math.round(b2).toString(16))
    ];
    if (allow3Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1))) {
      return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
    }
    return hex2.join("");
  }
  function rgbaToHex(r2, g2, b2, a2, allow4Char) {
    var hex2 = [
      pad2(Math.round(r2).toString(16)),
      pad2(Math.round(g2).toString(16)),
      pad2(Math.round(b2).toString(16)),
      pad2(convertDecimalToHex(a2))
    ];
    if (allow4Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1)) && hex2[3].startsWith(hex2[3].charAt(1))) {
      return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
    }
    return hex2.join("");
  }
  function convertDecimalToHex(d2) {
    return Math.round(parseFloat(d2) * 255).toString(16);
  }
  function convertHexToDecimal(h2) {
    return parseIntFromHex(h2) / 255;
  }
  function parseIntFromHex(val) {
    return parseInt(val, 16);
  }
  function numberInputToObject(color) {
    return {
      r: color >> 16,
      g: (color & 65280) >> 8,
      b: color & 255
    };
  }
  var names = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    goldenrod: "#daa520",
    gold: "#ffd700",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavenderblush: "#fff0f5",
    lavender: "#e6e6fa",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };
  function inputToRGB(color) {
    var rgb = { r: 0, g: 0, b: 0 };
    var a2 = 1;
    var s2 = null;
    var v2 = null;
    var l2 = null;
    var ok = false;
    var format2 = false;
    if (typeof color === "string") {
      color = stringInputToObject(color);
    }
    if (typeof color === "object") {
      if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
        rgb = rgbToRgb(color.r, color.g, color.b);
        ok = true;
        format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
        s2 = convertToPercentage(color.s);
        v2 = convertToPercentage(color.v);
        rgb = hsvToRgb(color.h, s2, v2);
        ok = true;
        format2 = "hsv";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
        s2 = convertToPercentage(color.s);
        l2 = convertToPercentage(color.l);
        rgb = hslToRgb(color.h, s2, l2);
        ok = true;
        format2 = "hsl";
      }
      if (Object.prototype.hasOwnProperty.call(color, "a")) {
        a2 = color.a;
      }
    }
    a2 = boundAlpha(a2);
    return {
      ok,
      format: color.format || format2,
      r: Math.min(255, Math.max(rgb.r, 0)),
      g: Math.min(255, Math.max(rgb.g, 0)),
      b: Math.min(255, Math.max(rgb.b, 0)),
      a: a2
    };
  }
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
  var matchers = {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
  function stringInputToObject(color) {
    color = color.trim().toLowerCase();
    if (color.length === 0) {
      return false;
    }
    var named = false;
    if (names[color]) {
      color = names[color];
      named = true;
    } else if (color === "transparent") {
      return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }
    var match2 = matchers.rgb.exec(color);
    if (match2) {
      return { r: match2[1], g: match2[2], b: match2[3] };
    }
    match2 = matchers.rgba.exec(color);
    if (match2) {
      return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
    }
    match2 = matchers.hsl.exec(color);
    if (match2) {
      return { h: match2[1], s: match2[2], l: match2[3] };
    }
    match2 = matchers.hsla.exec(color);
    if (match2) {
      return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
    }
    match2 = matchers.hsv.exec(color);
    if (match2) {
      return { h: match2[1], s: match2[2], v: match2[3] };
    }
    match2 = matchers.hsva.exec(color);
    if (match2) {
      return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
    }
    match2 = matchers.hex8.exec(color);
    if (match2) {
      return {
        r: parseIntFromHex(match2[1]),
        g: parseIntFromHex(match2[2]),
        b: parseIntFromHex(match2[3]),
        a: convertHexToDecimal(match2[4]),
        format: named ? "name" : "hex8"
      };
    }
    match2 = matchers.hex6.exec(color);
    if (match2) {
      return {
        r: parseIntFromHex(match2[1]),
        g: parseIntFromHex(match2[2]),
        b: parseIntFromHex(match2[3]),
        format: named ? "name" : "hex"
      };
    }
    match2 = matchers.hex4.exec(color);
    if (match2) {
      return {
        r: parseIntFromHex(match2[1] + match2[1]),
        g: parseIntFromHex(match2[2] + match2[2]),
        b: parseIntFromHex(match2[3] + match2[3]),
        a: convertHexToDecimal(match2[4] + match2[4]),
        format: named ? "name" : "hex8"
      };
    }
    match2 = matchers.hex3.exec(color);
    if (match2) {
      return {
        r: parseIntFromHex(match2[1] + match2[1]),
        g: parseIntFromHex(match2[2] + match2[2]),
        b: parseIntFromHex(match2[3] + match2[3]),
        format: named ? "name" : "hex"
      };
    }
    return false;
  }
  function isValidCSSUnit(color) {
    return Boolean(matchers.CSS_UNIT.exec(String(color)));
  }
  var TinyColor = (
    /** @class */
    function() {
      function TinyColor2(color, opts) {
        if (color === void 0) {
          color = "";
        }
        if (opts === void 0) {
          opts = {};
        }
        var _a2;
        if (color instanceof TinyColor2) {
          return color;
        }
        if (typeof color === "number") {
          color = numberInputToObject(color);
        }
        this.originalInput = color;
        var rgb = inputToRGB(color);
        this.originalInput = color;
        this.r = rgb.r;
        this.g = rgb.g;
        this.b = rgb.b;
        this.a = rgb.a;
        this.roundA = Math.round(100 * this.a) / 100;
        this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
        this.gradientType = opts.gradientType;
        if (this.r < 1) {
          this.r = Math.round(this.r);
        }
        if (this.g < 1) {
          this.g = Math.round(this.g);
        }
        if (this.b < 1) {
          this.b = Math.round(this.b);
        }
        this.isValid = rgb.ok;
      }
      TinyColor2.prototype.isDark = function() {
        return this.getBrightness() < 128;
      };
      TinyColor2.prototype.isLight = function() {
        return !this.isDark();
      };
      TinyColor2.prototype.getBrightness = function() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
      };
      TinyColor2.prototype.getLuminance = function() {
        var rgb = this.toRgb();
        var R2;
        var G;
        var B2;
        var RsRGB = rgb.r / 255;
        var GsRGB = rgb.g / 255;
        var BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928) {
          R2 = RsRGB / 12.92;
        } else {
          R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
        }
        if (GsRGB <= 0.03928) {
          G = GsRGB / 12.92;
        } else {
          G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
        }
        if (BsRGB <= 0.03928) {
          B2 = BsRGB / 12.92;
        } else {
          B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * R2 + 0.7152 * G + 0.0722 * B2;
      };
      TinyColor2.prototype.getAlpha = function() {
        return this.a;
      };
      TinyColor2.prototype.setAlpha = function(alpha) {
        this.a = boundAlpha(alpha);
        this.roundA = Math.round(100 * this.a) / 100;
        return this;
      };
      TinyColor2.prototype.isMonochrome = function() {
        var s2 = this.toHsl().s;
        return s2 === 0;
      };
      TinyColor2.prototype.toHsv = function() {
        var hsv = rgbToHsv(this.r, this.g, this.b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
      };
      TinyColor2.prototype.toHsvString = function() {
        var hsv = rgbToHsv(this.r, this.g, this.b);
        var h2 = Math.round(hsv.h * 360);
        var s2 = Math.round(hsv.s * 100);
        var v2 = Math.round(hsv.v * 100);
        return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toHsl = function() {
        var hsl = rgbToHsl(this.r, this.g, this.b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
      };
      TinyColor2.prototype.toHslString = function() {
        var hsl = rgbToHsl(this.r, this.g, this.b);
        var h2 = Math.round(hsl.h * 360);
        var s2 = Math.round(hsl.s * 100);
        var l2 = Math.round(hsl.l * 100);
        return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toHex = function(allow3Char) {
        if (allow3Char === void 0) {
          allow3Char = false;
        }
        return rgbToHex(this.r, this.g, this.b, allow3Char);
      };
      TinyColor2.prototype.toHexString = function(allow3Char) {
        if (allow3Char === void 0) {
          allow3Char = false;
        }
        return "#" + this.toHex(allow3Char);
      };
      TinyColor2.prototype.toHex8 = function(allow4Char) {
        if (allow4Char === void 0) {
          allow4Char = false;
        }
        return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
      };
      TinyColor2.prototype.toHex8String = function(allow4Char) {
        if (allow4Char === void 0) {
          allow4Char = false;
        }
        return "#" + this.toHex8(allow4Char);
      };
      TinyColor2.prototype.toHexShortString = function(allowShortChar) {
        if (allowShortChar === void 0) {
          allowShortChar = false;
        }
        return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
      };
      TinyColor2.prototype.toRgb = function() {
        return {
          r: Math.round(this.r),
          g: Math.round(this.g),
          b: Math.round(this.b),
          a: this.a
        };
      };
      TinyColor2.prototype.toRgbString = function() {
        var r2 = Math.round(this.r);
        var g2 = Math.round(this.g);
        var b2 = Math.round(this.b);
        return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toPercentageRgb = function() {
        var fmt = function(x2) {
          return "".concat(Math.round(bound01(x2, 255) * 100), "%");
        };
        return {
          r: fmt(this.r),
          g: fmt(this.g),
          b: fmt(this.b),
          a: this.a
        };
      };
      TinyColor2.prototype.toPercentageRgbString = function() {
        var rnd = function(x2) {
          return Math.round(bound01(x2, 255) * 100);
        };
        return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toName = function() {
        if (this.a === 0) {
          return "transparent";
        }
        if (this.a < 1) {
          return false;
        }
        var hex2 = "#" + rgbToHex(this.r, this.g, this.b, false);
        for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
          var _b = _a2[_i], key2 = _b[0], value = _b[1];
          if (hex2 === value) {
            return key2;
          }
        }
        return false;
      };
      TinyColor2.prototype.toString = function(format2) {
        var formatSet = Boolean(format2);
        format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
        var formattedString = false;
        var hasAlpha = this.a < 1 && this.a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
        if (needsAlphaFormat) {
          if (format2 === "name" && this.a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format2 === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format2 === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format2 === "hex" || format2 === "hex6") {
          formattedString = this.toHexString();
        }
        if (format2 === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format2 === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format2 === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format2 === "name") {
          formattedString = this.toName();
        }
        if (format2 === "hsl") {
          formattedString = this.toHslString();
        }
        if (format2 === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      };
      TinyColor2.prototype.toNumber = function() {
        return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
      };
      TinyColor2.prototype.clone = function() {
        return new TinyColor2(this.toString());
      };
      TinyColor2.prototype.lighten = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.brighten = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var rgb = this.toRgb();
        rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
        rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
        rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
        return new TinyColor2(rgb);
      };
      TinyColor2.prototype.darken = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.tint = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        return this.mix("white", amount);
      };
      TinyColor2.prototype.shade = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        return this.mix("black", amount);
      };
      TinyColor2.prototype.desaturate = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.saturate = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.greyscale = function() {
        return this.desaturate(100);
      };
      TinyColor2.prototype.spin = function(amount) {
        var hsl = this.toHsl();
        var hue = (hsl.h + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.mix = function(color, amount) {
        if (amount === void 0) {
          amount = 50;
        }
        var rgb1 = this.toRgb();
        var rgb2 = new TinyColor2(color).toRgb();
        var p = amount / 100;
        var rgba = {
          r: (rgb2.r - rgb1.r) * p + rgb1.r,
          g: (rgb2.g - rgb1.g) * p + rgb1.g,
          b: (rgb2.b - rgb1.b) * p + rgb1.b,
          a: (rgb2.a - rgb1.a) * p + rgb1.a
        };
        return new TinyColor2(rgba);
      };
      TinyColor2.prototype.analogous = function(results, slices) {
        if (results === void 0) {
          results = 6;
        }
        if (slices === void 0) {
          slices = 30;
        }
        var hsl = this.toHsl();
        var part = 360 / slices;
        var ret = [this];
        for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
          hsl.h = (hsl.h + part) % 360;
          ret.push(new TinyColor2(hsl));
        }
        return ret;
      };
      TinyColor2.prototype.complement = function() {
        var hsl = this.toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.monochromatic = function(results) {
        if (results === void 0) {
          results = 6;
        }
        var hsv = this.toHsv();
        var h2 = hsv.h;
        var s2 = hsv.s;
        var v2 = hsv.v;
        var res = [];
        var modification = 1 / results;
        while (results--) {
          res.push(new TinyColor2({ h: h2, s: s2, v: v2 }));
          v2 = (v2 + modification) % 1;
        }
        return res;
      };
      TinyColor2.prototype.splitcomplement = function() {
        var hsl = this.toHsl();
        var h2 = hsl.h;
        return [
          this,
          new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
          new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
        ];
      };
      TinyColor2.prototype.onBackground = function(background) {
        var fg = this.toRgb();
        var bg = new TinyColor2(background).toRgb();
        var alpha = fg.a + bg.a * (1 - fg.a);
        return new TinyColor2({
          r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
          g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
          b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
          a: alpha
        });
      };
      TinyColor2.prototype.triad = function() {
        return this.polyad(3);
      };
      TinyColor2.prototype.tetrad = function() {
        return this.polyad(4);
      };
      TinyColor2.prototype.polyad = function(n2) {
        var hsl = this.toHsl();
        var h2 = hsl.h;
        var result = [this];
        var increment = 360 / n2;
        for (var i2 = 1; i2 < n2; i2++) {
          result.push(new TinyColor2({ h: (h2 + i2 * increment) % 360, s: hsl.s, l: hsl.l }));
        }
        return result;
      };
      TinyColor2.prototype.equals = function(color) {
        return this.toRgbString() === new TinyColor2(color).toRgbString();
      };
      return TinyColor2;
    }()
  );
  var hueStep = 2;
  var saturationStep = 0.16;
  var saturationStep2 = 0.05;
  var brightnessStep1 = 0.05;
  var brightnessStep2 = 0.15;
  var lightColorCount = 5;
  var darkColorCount = 4;
  var darkColorMap = [{
    index: 7,
    opacity: 0.15
  }, {
    index: 6,
    opacity: 0.25
  }, {
    index: 5,
    opacity: 0.3
  }, {
    index: 5,
    opacity: 0.45
  }, {
    index: 5,
    opacity: 0.65
  }, {
    index: 5,
    opacity: 0.85
  }, {
    index: 4,
    opacity: 0.9
  }, {
    index: 3,
    opacity: 0.95
  }, {
    index: 2,
    opacity: 0.97
  }, {
    index: 1,
    opacity: 0.98
  }];
  function toHsv(_ref) {
    var r2 = _ref.r, g2 = _ref.g, b2 = _ref.b;
    var hsv = rgbToHsv(r2, g2, b2);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v
    };
  }
  function toHex(_ref2) {
    var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
    return "#".concat(rgbToHex(r2, g2, b2, false));
  }
  function mix$1(rgb1, rgb2, amount) {
    var p = amount / 100;
    var rgb = {
      r: (rgb2.r - rgb1.r) * p + rgb1.r,
      g: (rgb2.g - rgb1.g) * p + rgb1.g,
      b: (rgb2.b - rgb1.b) * p + rgb1.b
    };
    return rgb;
  }
  function getHue(hsv, i2, light) {
    var hue;
    if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
      hue = light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2;
    } else {
      hue = light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2;
    }
    if (hue < 0) {
      hue += 360;
    } else if (hue >= 360) {
      hue -= 360;
    }
    return hue;
  }
  function getSaturation(hsv, i2, light) {
    if (hsv.h === 0 && hsv.s === 0) {
      return hsv.s;
    }
    var saturation;
    if (light) {
      saturation = hsv.s - saturationStep * i2;
    } else if (i2 === darkColorCount) {
      saturation = hsv.s + saturationStep;
    } else {
      saturation = hsv.s + saturationStep2 * i2;
    }
    if (saturation > 1) {
      saturation = 1;
    }
    if (light && i2 === lightColorCount && saturation > 0.1) {
      saturation = 0.1;
    }
    if (saturation < 0.06) {
      saturation = 0.06;
    }
    return Number(saturation.toFixed(2));
  }
  function getValue$3(hsv, i2, light) {
    var value;
    if (light) {
      value = hsv.v + brightnessStep1 * i2;
    } else {
      value = hsv.v - brightnessStep2 * i2;
    }
    if (value > 1) {
      value = 1;
    }
    return Number(value.toFixed(2));
  }
  function generate$1(color) {
    var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var patterns = [];
    var pColor = inputToRGB(color);
    for (var i2 = lightColorCount; i2 > 0; i2 -= 1) {
      var hsv = toHsv(pColor);
      var colorString = toHex(inputToRGB({
        h: getHue(hsv, i2, true),
        s: getSaturation(hsv, i2, true),
        v: getValue$3(hsv, i2, true)
      }));
      patterns.push(colorString);
    }
    patterns.push(toHex(pColor));
    for (var _i = 1; _i <= darkColorCount; _i += 1) {
      var _hsv = toHsv(pColor);
      var _colorString = toHex(inputToRGB({
        h: getHue(_hsv, _i),
        s: getSaturation(_hsv, _i),
        v: getValue$3(_hsv, _i)
      }));
      patterns.push(_colorString);
    }
    if (opts.theme === "dark") {
      return darkColorMap.map(function(_ref3) {
        var index2 = _ref3.index, opacity = _ref3.opacity;
        var darkColorString = toHex(mix$1(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index2]), opacity * 100));
        return darkColorString;
      });
    }
    return patterns;
  }
  var presetPrimaryColors = {
    red: "#F5222D",
    volcano: "#FA541C",
    orange: "#FA8C16",
    gold: "#FAAD14",
    yellow: "#FADB14",
    lime: "#A0D911",
    green: "#52C41A",
    cyan: "#13C2C2",
    blue: "#1890FF",
    geekblue: "#2F54EB",
    purple: "#722ED1",
    magenta: "#EB2F96",
    grey: "#666666"
  };
  var presetPalettes = {};
  var presetDarkPalettes = {};
  Object.keys(presetPrimaryColors).forEach(function(key2) {
    presetPalettes[key2] = generate$1(presetPrimaryColors[key2]);
    presetPalettes[key2].primary = presetPalettes[key2][5];
    presetDarkPalettes[key2] = generate$1(presetPrimaryColors[key2], {
      theme: "dark",
      backgroundColor: "#141414"
    });
    presetDarkPalettes[key2].primary = presetDarkPalettes[key2][5];
  });
  var blue = presetPalettes.blue;
  const genControlHeight = (token2) => {
    const {
      controlHeight
    } = token2;
    return {
      controlHeightSM: controlHeight * 0.75,
      controlHeightXS: controlHeight * 0.5,
      controlHeightLG: controlHeight * 1.25
    };
  };
  function genSizeMapToken(token2) {
    const {
      sizeUnit,
      sizeStep
    } = token2;
    return {
      sizeXXL: sizeUnit * (sizeStep + 8),
      sizeXL: sizeUnit * (sizeStep + 4),
      sizeLG: sizeUnit * (sizeStep + 2),
      sizeMD: sizeUnit * (sizeStep + 1),
      sizeMS: sizeUnit * sizeStep,
      size: sizeUnit * sizeStep,
      sizeSM: sizeUnit * (sizeStep - 1),
      sizeXS: sizeUnit * (sizeStep - 2),
      sizeXXS: sizeUnit * (sizeStep - 3)
      // 4
    };
  }
  const defaultPresetColors = {
    blue: "#1677ff",
    purple: "#722ED1",
    cyan: "#13C2C2",
    green: "#52C41A",
    magenta: "#EB2F96",
    pink: "#eb2f96",
    red: "#F5222D",
    orange: "#FA8C16",
    yellow: "#FADB14",
    volcano: "#FA541C",
    geekblue: "#2F54EB",
    gold: "#FAAD14",
    lime: "#A0D911"
  };
  const seedToken = _extends$1(_extends$1({}, defaultPresetColors), {
    // Color
    colorPrimary: "#1677ff",
    colorSuccess: "#52c41a",
    colorWarning: "#faad14",
    colorError: "#ff4d4f",
    colorInfo: "#1677ff",
    colorTextBase: "",
    colorBgBase: "",
    // Font
    fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
    fontSize: 14,
    // Line
    lineWidth: 1,
    lineType: "solid",
    // Motion
    motionUnit: 0.1,
    motionBase: 0,
    motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
    motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
    motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
    motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
    motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
    motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
    motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
    motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
    // Radius
    borderRadius: 6,
    // Size
    sizeUnit: 4,
    sizeStep: 4,
    sizePopupArrow: 16,
    // Control Base
    controlHeight: 32,
    // zIndex
    zIndexBase: 0,
    zIndexPopupBase: 1e3,
    // Image
    opacityImage: 1,
    // Wireframe
    wireframe: false
  });
  const defaultSeedToken = seedToken;
  function genColorMapToken(seed2, _ref) {
    let {
      generateColorPalettes: generateColorPalettes2,
      generateNeutralColorPalettes: generateNeutralColorPalettes2
    } = _ref;
    const {
      colorSuccess: colorSuccessBase,
      colorWarning: colorWarningBase,
      colorError: colorErrorBase,
      colorInfo: colorInfoBase,
      colorPrimary: colorPrimaryBase,
      colorBgBase,
      colorTextBase
    } = seed2;
    const primaryColors = generateColorPalettes2(colorPrimaryBase);
    const successColors = generateColorPalettes2(colorSuccessBase);
    const warningColors = generateColorPalettes2(colorWarningBase);
    const errorColors = generateColorPalettes2(colorErrorBase);
    const infoColors = generateColorPalettes2(colorInfoBase);
    const neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase);
    return _extends$1(_extends$1({}, neutralColors), {
      colorPrimaryBg: primaryColors[1],
      colorPrimaryBgHover: primaryColors[2],
      colorPrimaryBorder: primaryColors[3],
      colorPrimaryBorderHover: primaryColors[4],
      colorPrimaryHover: primaryColors[5],
      colorPrimary: primaryColors[6],
      colorPrimaryActive: primaryColors[7],
      colorPrimaryTextHover: primaryColors[8],
      colorPrimaryText: primaryColors[9],
      colorPrimaryTextActive: primaryColors[10],
      colorSuccessBg: successColors[1],
      colorSuccessBgHover: successColors[2],
      colorSuccessBorder: successColors[3],
      colorSuccessBorderHover: successColors[4],
      colorSuccessHover: successColors[4],
      colorSuccess: successColors[6],
      colorSuccessActive: successColors[7],
      colorSuccessTextHover: successColors[8],
      colorSuccessText: successColors[9],
      colorSuccessTextActive: successColors[10],
      colorErrorBg: errorColors[1],
      colorErrorBgHover: errorColors[2],
      colorErrorBorder: errorColors[3],
      colorErrorBorderHover: errorColors[4],
      colorErrorHover: errorColors[5],
      colorError: errorColors[6],
      colorErrorActive: errorColors[7],
      colorErrorTextHover: errorColors[8],
      colorErrorText: errorColors[9],
      colorErrorTextActive: errorColors[10],
      colorWarningBg: warningColors[1],
      colorWarningBgHover: warningColors[2],
      colorWarningBorder: warningColors[3],
      colorWarningBorderHover: warningColors[4],
      colorWarningHover: warningColors[4],
      colorWarning: warningColors[6],
      colorWarningActive: warningColors[7],
      colorWarningTextHover: warningColors[8],
      colorWarningText: warningColors[9],
      colorWarningTextActive: warningColors[10],
      colorInfoBg: infoColors[1],
      colorInfoBgHover: infoColors[2],
      colorInfoBorder: infoColors[3],
      colorInfoBorderHover: infoColors[4],
      colorInfoHover: infoColors[4],
      colorInfo: infoColors[6],
      colorInfoActive: infoColors[7],
      colorInfoTextHover: infoColors[8],
      colorInfoText: infoColors[9],
      colorInfoTextActive: infoColors[10],
      colorBgMask: new TinyColor("#000").setAlpha(0.45).toRgbString(),
      colorWhite: "#fff"
    });
  }
  const genRadius = (radiusBase) => {
    let radiusLG = radiusBase;
    let radiusSM = radiusBase;
    let radiusXS = radiusBase;
    let radiusOuter = radiusBase;
    if (radiusBase < 6 && radiusBase >= 5) {
      radiusLG = radiusBase + 1;
    } else if (radiusBase < 16 && radiusBase >= 6) {
      radiusLG = radiusBase + 2;
    } else if (radiusBase >= 16) {
      radiusLG = 16;
    }
    if (radiusBase < 7 && radiusBase >= 5) {
      radiusSM = 4;
    } else if (radiusBase < 8 && radiusBase >= 7) {
      radiusSM = 5;
    } else if (radiusBase < 14 && radiusBase >= 8) {
      radiusSM = 6;
    } else if (radiusBase < 16 && radiusBase >= 14) {
      radiusSM = 7;
    } else if (radiusBase >= 16) {
      radiusSM = 8;
    }
    if (radiusBase < 6 && radiusBase >= 2) {
      radiusXS = 1;
    } else if (radiusBase >= 6) {
      radiusXS = 2;
    }
    if (radiusBase > 4 && radiusBase < 8) {
      radiusOuter = 4;
    } else if (radiusBase >= 8) {
      radiusOuter = 6;
    }
    return {
      borderRadius: radiusBase > 16 ? 16 : radiusBase,
      borderRadiusXS: radiusXS,
      borderRadiusSM: radiusSM,
      borderRadiusLG: radiusLG,
      borderRadiusOuter: radiusOuter
    };
  };
  function genCommonMapToken(token2) {
    const {
      motionUnit,
      motionBase,
      borderRadius,
      lineWidth
    } = token2;
    return _extends$1({
      // motion
      motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
      motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
      motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
      // line
      lineWidthBold: lineWidth + 1
    }, genRadius(borderRadius));
  }
  const getAlphaColor$1 = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
  const getSolidColor = (baseColor, brightness) => {
    const instance = new TinyColor(baseColor);
    return instance.darken(brightness).toHexString();
  };
  const generateColorPalettes = (baseColor) => {
    const colors = generate$1(baseColor);
    return {
      1: colors[0],
      2: colors[1],
      3: colors[2],
      4: colors[3],
      5: colors[4],
      6: colors[5],
      7: colors[6],
      8: colors[4],
      9: colors[5],
      10: colors[6]
      // 8: colors[7],
      // 9: colors[8],
      // 10: colors[9],
    };
  };
  const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
    const colorBgBase = bgBaseColor || "#fff";
    const colorTextBase = textBaseColor || "#000";
    return {
      colorBgBase,
      colorTextBase,
      colorText: getAlphaColor$1(colorTextBase, 0.88),
      colorTextSecondary: getAlphaColor$1(colorTextBase, 0.65),
      colorTextTertiary: getAlphaColor$1(colorTextBase, 0.45),
      colorTextQuaternary: getAlphaColor$1(colorTextBase, 0.25),
      colorFill: getAlphaColor$1(colorTextBase, 0.15),
      colorFillSecondary: getAlphaColor$1(colorTextBase, 0.06),
      colorFillTertiary: getAlphaColor$1(colorTextBase, 0.04),
      colorFillQuaternary: getAlphaColor$1(colorTextBase, 0.02),
      colorBgLayout: getSolidColor(colorBgBase, 4),
      colorBgContainer: getSolidColor(colorBgBase, 0),
      colorBgElevated: getSolidColor(colorBgBase, 0),
      colorBgSpotlight: getAlphaColor$1(colorTextBase, 0.85),
      colorBorder: getSolidColor(colorBgBase, 15),
      colorBorderSecondary: getSolidColor(colorBgBase, 6)
    };
  };
  function getFontSizes(base) {
    const fontSizes = new Array(10).fill(null).map((_2, index2) => {
      const i2 = index2 - 1;
      const baseSize = base * Math.pow(2.71828, i2 / 5);
      const intSize = index2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
      return Math.floor(intSize / 2) * 2;
    });
    fontSizes[1] = base;
    return fontSizes.map((size2) => {
      const height = size2 + 8;
      return {
        size: size2,
        lineHeight: height / size2
      };
    });
  }
  const genFontMapToken = (fontSize) => {
    const fontSizePairs = getFontSizes(fontSize);
    const fontSizes = fontSizePairs.map((pair) => pair.size);
    const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
    return {
      fontSizeSM: fontSizes[0],
      fontSize: fontSizes[1],
      fontSizeLG: fontSizes[2],
      fontSizeXL: fontSizes[3],
      fontSizeHeading1: fontSizes[6],
      fontSizeHeading2: fontSizes[5],
      fontSizeHeading3: fontSizes[4],
      fontSizeHeading4: fontSizes[3],
      fontSizeHeading5: fontSizes[2],
      lineHeight: lineHeights[1],
      lineHeightLG: lineHeights[2],
      lineHeightSM: lineHeights[0],
      lineHeightHeading1: lineHeights[6],
      lineHeightHeading2: lineHeights[5],
      lineHeightHeading3: lineHeights[4],
      lineHeightHeading4: lineHeights[3],
      lineHeightHeading5: lineHeights[2]
    };
  };
  function derivative(token2) {
    const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
      const colors = generate$1(token2[colorKey]);
      return new Array(10).fill(1).reduce((prev2, _2, i2) => {
        prev2[`${colorKey}-${i2 + 1}`] = colors[i2];
        return prev2;
      }, {});
    }).reduce((prev2, cur) => {
      prev2 = _extends$1(_extends$1({}, prev2), cur);
      return prev2;
    }, {});
    return _extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, token2), colorPalettes), genColorMapToken(token2, {
      generateColorPalettes,
      generateNeutralColorPalettes
    })), genFontMapToken(token2.fontSize)), genSizeMapToken(token2)), genControlHeight(token2)), genCommonMapToken(token2));
  }
  function isStableColor(color) {
    return color >= 0 && color <= 255;
  }
  function getAlphaColor(frontColor, backgroundColor) {
    const {
      r: fR,
      g: fG,
      b: fB,
      a: originAlpha
    } = new TinyColor(frontColor).toRgb();
    if (originAlpha < 1) {
      return frontColor;
    }
    const {
      r: bR,
      g: bG,
      b: bB
    } = new TinyColor(backgroundColor).toRgb();
    for (let fA = 0.01; fA <= 1; fA += 0.01) {
      const r2 = Math.round((fR - bR * (1 - fA)) / fA);
      const g2 = Math.round((fG - bG * (1 - fA)) / fA);
      const b2 = Math.round((fB - bB * (1 - fA)) / fA);
      if (isStableColor(r2) && isStableColor(g2) && isStableColor(b2)) {
        return new TinyColor({
          r: r2,
          g: g2,
          b: b2,
          a: Math.round(fA * 100) / 100
        }).toRgbString();
      }
    }
    return new TinyColor({
      r: fR,
      g: fG,
      b: fB,
      a: 1
    }).toRgbString();
  }
  var __rest$h = function(s2, e2) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  function formatToken(derivativeToken) {
    const {
      override
    } = derivativeToken, restToken = __rest$h(derivativeToken, ["override"]);
    const overrideTokens = _extends$1({}, override);
    Object.keys(defaultSeedToken).forEach((token2) => {
      delete overrideTokens[token2];
    });
    const mergedToken = _extends$1(_extends$1({}, restToken), overrideTokens);
    const screenXS = 480;
    const screenSM = 576;
    const screenMD = 768;
    const screenLG = 992;
    const screenXL = 1200;
    const screenXXL = 1600;
    const screenXXXL = 2e3;
    const aliasToken = _extends$1(_extends$1(_extends$1({}, mergedToken), {
      colorLink: mergedToken.colorInfoText,
      colorLinkHover: mergedToken.colorInfoHover,
      colorLinkActive: mergedToken.colorInfoActive,
      // ============== Background ============== //
      colorFillContent: mergedToken.colorFillSecondary,
      colorFillContentHover: mergedToken.colorFill,
      colorFillAlter: mergedToken.colorFillQuaternary,
      colorBgContainerDisabled: mergedToken.colorFillTertiary,
      // ============== Split ============== //
      colorBorderBg: mergedToken.colorBgContainer,
      colorSplit: getAlphaColor(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
      // ============== Text ============== //
      colorTextPlaceholder: mergedToken.colorTextQuaternary,
      colorTextDisabled: mergedToken.colorTextQuaternary,
      colorTextHeading: mergedToken.colorText,
      colorTextLabel: mergedToken.colorTextSecondary,
      colorTextDescription: mergedToken.colorTextTertiary,
      colorTextLightSolid: mergedToken.colorWhite,
      colorHighlight: mergedToken.colorError,
      colorBgTextHover: mergedToken.colorFillSecondary,
      colorBgTextActive: mergedToken.colorFill,
      colorIcon: mergedToken.colorTextTertiary,
      colorIconHover: mergedToken.colorText,
      colorErrorOutline: getAlphaColor(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
      colorWarningOutline: getAlphaColor(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
      // Font
      fontSizeIcon: mergedToken.fontSizeSM,
      // Control
      lineWidth: mergedToken.lineWidth,
      controlOutlineWidth: mergedToken.lineWidth * 2,
      // Checkbox size and expand icon size
      controlInteractiveSize: mergedToken.controlHeight / 2,
      controlItemBgHover: mergedToken.colorFillTertiary,
      controlItemBgActive: mergedToken.colorPrimaryBg,
      controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
      controlItemBgActiveDisabled: mergedToken.colorFill,
      controlTmpOutline: mergedToken.colorFillQuaternary,
      controlOutline: getAlphaColor(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
      lineType: mergedToken.lineType,
      borderRadius: mergedToken.borderRadius,
      borderRadiusXS: mergedToken.borderRadiusXS,
      borderRadiusSM: mergedToken.borderRadiusSM,
      borderRadiusLG: mergedToken.borderRadiusLG,
      fontWeightStrong: 600,
      opacityLoading: 0.65,
      linkDecoration: "none",
      linkHoverDecoration: "none",
      linkFocusDecoration: "none",
      controlPaddingHorizontal: 12,
      controlPaddingHorizontalSM: 8,
      paddingXXS: mergedToken.sizeXXS,
      paddingXS: mergedToken.sizeXS,
      paddingSM: mergedToken.sizeSM,
      padding: mergedToken.size,
      paddingMD: mergedToken.sizeMD,
      paddingLG: mergedToken.sizeLG,
      paddingXL: mergedToken.sizeXL,
      paddingContentHorizontalLG: mergedToken.sizeLG,
      paddingContentVerticalLG: mergedToken.sizeMS,
      paddingContentHorizontal: mergedToken.sizeMS,
      paddingContentVertical: mergedToken.sizeSM,
      paddingContentHorizontalSM: mergedToken.size,
      paddingContentVerticalSM: mergedToken.sizeXS,
      marginXXS: mergedToken.sizeXXS,
      marginXS: mergedToken.sizeXS,
      marginSM: mergedToken.sizeSM,
      margin: mergedToken.size,
      marginMD: mergedToken.sizeMD,
      marginLG: mergedToken.sizeLG,
      marginXL: mergedToken.sizeXL,
      marginXXL: mergedToken.sizeXXL,
      boxShadow: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
      boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
      screenXS,
      screenXSMin: screenXS,
      screenXSMax: screenSM - 1,
      screenSM,
      screenSMMin: screenSM,
      screenSMMax: screenMD - 1,
      screenMD,
      screenMDMin: screenMD,
      screenMDMax: screenLG - 1,
      screenLG,
      screenLGMin: screenLG,
      screenLGMax: screenXL - 1,
      screenXL,
      screenXLMin: screenXL,
      screenXLMax: screenXXL - 1,
      screenXXL,
      screenXXLMin: screenXXL,
      screenXXLMax: screenXXXL - 1,
      screenXXXL,
      screenXXXLMin: screenXXXL,
      // FIXME: component box-shadow, should be removed
      boxShadowPopoverArrow: "3px 3px 7px rgba(0, 0, 0, 0.1)",
      boxShadowCard: `
      0 1px 2px -2px ${new TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
      boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
    }), overrideTokens);
    return aliasToken;
  }
  const roundedArrow = (width, innerRadius, outerRadius, bgColor, boxShadow) => {
    const unitWidth = width / 2;
    const ax = 0;
    const ay = unitWidth;
    const bx = outerRadius * 1 / Math.sqrt(2);
    const by = unitWidth - outerRadius * (1 - 1 / Math.sqrt(2));
    const cx = unitWidth - innerRadius * (1 / Math.sqrt(2));
    const cy = outerRadius * (Math.sqrt(2) - 1) + innerRadius * (1 / Math.sqrt(2));
    const dx = 2 * unitWidth - cx;
    const dy = cy;
    const ex = 2 * unitWidth - bx;
    const ey = by;
    const fx = 2 * unitWidth - ax;
    const fy = ay;
    const shadowWidth = unitWidth * Math.sqrt(2) + outerRadius * (Math.sqrt(2) - 2);
    const polygonOffset = outerRadius * (Math.sqrt(2) - 1);
    return {
      pointerEvents: "none",
      width,
      height: width,
      overflow: "hidden",
      "&::after": {
        content: '""',
        position: "absolute",
        width: shadowWidth,
        height: shadowWidth,
        bottom: 0,
        insetInline: 0,
        margin: "auto",
        borderRadius: {
          _skip_check_: true,
          value: `0 0 ${innerRadius}px 0`
        },
        transform: "translateY(50%) rotate(-135deg)",
        boxShadow,
        zIndex: 0,
        background: "transparent"
      },
      "&::before": {
        position: "absolute",
        bottom: 0,
        insetInlineStart: 0,
        width,
        height: width / 2,
        background: bgColor,
        clipPath: {
          _multi_value_: true,
          value: [`polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`, `path('M ${ax} ${ay} A ${outerRadius} ${outerRadius} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${innerRadius} ${innerRadius} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${outerRadius} ${outerRadius} 0 0 0 ${fx} ${fy} Z')`]
        },
        content: '""'
      }
    };
  };
  function genPresetColor(token2, genCss) {
    return PresetColors.reduce((prev2, colorKey) => {
      const lightColor = token2[`${colorKey}-1`];
      const lightBorderColor = token2[`${colorKey}-3`];
      const darkColor = token2[`${colorKey}-6`];
      const textColor = token2[`${colorKey}-7`];
      return _extends$1(_extends$1({}, prev2), genCss(colorKey, {
        lightColor,
        lightBorderColor,
        darkColor,
        textColor
      }));
    }, {});
  }
  const resetComponent = (token2) => ({
    boxSizing: "border-box",
    margin: 0,
    padding: 0,
    color: token2.colorText,
    fontSize: token2.fontSize,
    // font-variant: @font-variant-base;
    lineHeight: token2.lineHeight,
    listStyle: "none",
    // font-feature-settings: @font-feature-settings-base;
    fontFamily: token2.fontFamily
  });
  const resetIcon = () => ({
    display: "inline-flex",
    alignItems: "center",
    color: "inherit",
    fontStyle: "normal",
    lineHeight: 0,
    textAlign: "center",
    textTransform: "none",
    // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
    verticalAlign: "-0.125em",
    textRendering: "optimizeLegibility",
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale",
    "> *": {
      lineHeight: 1
    },
    svg: {
      display: "inline-block"
    }
  });
  const clearFix = () => ({
    // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
    "&::before": {
      display: "table",
      content: '""'
    },
    "&::after": {
      // https://github.com/ant-design/ant-design/issues/21864
      display: "table",
      clear: "both",
      content: '""'
    }
  });
  const genLinkStyle = (token2) => ({
    a: {
      color: token2.colorLink,
      textDecoration: token2.linkDecoration,
      backgroundColor: "transparent",
      outline: "none",
      cursor: "pointer",
      transition: `color ${token2.motionDurationSlow}`,
      "-webkit-text-decoration-skip": "objects",
      "&:hover": {
        color: token2.colorLinkHover
      },
      "&:active": {
        color: token2.colorLinkActive
      },
      [`&:active,
  &:hover`]: {
        textDecoration: token2.linkHoverDecoration,
        outline: 0
      },
      // https://github.com/ant-design/ant-design/issues/22503
      "&:focus": {
        textDecoration: token2.linkFocusDecoration,
        outline: 0
      },
      "&[disabled]": {
        color: token2.colorTextDisabled,
        cursor: "not-allowed"
      }
    }
  });
  const genCommonStyle = (token2, componentPrefixCls) => {
    const {
      fontFamily,
      fontSize
    } = token2;
    const rootPrefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
    return {
      [rootPrefixSelector]: {
        fontFamily,
        fontSize,
        boxSizing: "border-box",
        "&::before, &::after": {
          boxSizing: "border-box"
        },
        [rootPrefixSelector]: {
          boxSizing: "border-box",
          "&::before, &::after": {
            boxSizing: "border-box"
          }
        }
      }
    };
  };
  const genFocusOutline = (token2) => ({
    outline: `${token2.lineWidthBold}px solid ${token2.colorPrimaryBorder}`,
    outlineOffset: 1,
    transition: "outline-offset 0s, outline 0s"
  });
  const genFocusStyle = (token2) => ({
    "&:focus-visible": _extends$1({}, genFocusOutline(token2))
  });
  function genComponentStyleHook(component, styleFn, getDefaultToken) {
    return (_prefixCls) => {
      const prefixCls = computed(() => _prefixCls === null || _prefixCls === void 0 ? void 0 : _prefixCls.value);
      const [theme, token2, hashId] = useToken();
      const {
        getPrefixCls,
        iconPrefixCls
      } = useConfigContextInject();
      const rootPrefixCls = computed(() => getPrefixCls());
      const sharedInfo = computed(() => {
        return {
          theme: theme.value,
          token: token2.value,
          hashId: hashId.value,
          path: ["Shared", rootPrefixCls.value]
        };
      });
      useStyleRegister(sharedInfo, () => [{
        // Link
        "&": genLinkStyle(token2.value)
      }]);
      const componentInfo = computed(() => {
        return {
          theme: theme.value,
          token: token2.value,
          hashId: hashId.value,
          path: [component, prefixCls.value, iconPrefixCls.value]
        };
      });
      return [useStyleRegister(componentInfo, () => {
        const {
          token: proxyToken,
          flush
        } = statisticToken(token2.value);
        const defaultComponentToken = typeof getDefaultToken === "function" ? getDefaultToken(proxyToken) : getDefaultToken;
        const mergedComponentToken = _extends$1(_extends$1({}, defaultComponentToken), token2.value[component]);
        const componentCls = `.${prefixCls.value}`;
        const mergedToken = merge(proxyToken, {
          componentCls,
          prefixCls: prefixCls.value,
          iconCls: `.${iconPrefixCls.value}`,
          antCls: `.${rootPrefixCls.value}`
        }, mergedComponentToken);
        const styleInterpolation = styleFn(mergedToken, {
          hashId: hashId.value,
          prefixCls: prefixCls.value,
          rootPrefixCls: rootPrefixCls.value,
          iconPrefixCls: iconPrefixCls.value,
          overrideComponentToken: token2.value[component]
        });
        flush(component, mergedComponentToken);
        return [genCommonStyle(token2.value, prefixCls.value), styleInterpolation];
      }), hashId];
    };
  }
  let recording = true;
  function merge() {
    for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
      objs[_key] = arguments[_key];
    }
    recording = false;
    const ret = {};
    objs.forEach((obj) => {
      const keys2 = Object.keys(obj);
      keys2.forEach((key2) => {
        Object.defineProperty(ret, key2, {
          configurable: true,
          enumerable: true,
          get: () => obj[key2]
        });
      });
    });
    recording = true;
    return ret;
  }
  function noop$3() {
  }
  function statisticToken(token2) {
    let tokenKeys2;
    let proxy = token2;
    let flush = noop$3;
    {
      tokenKeys2 = /* @__PURE__ */ new Set();
      proxy = new Proxy(token2, {
        get(obj, prop) {
          if (recording) {
            tokenKeys2.add(prop);
          }
          return obj[prop];
        }
      });
      flush = (componentName, componentToken) => {
        ({
          global: Array.from(tokenKeys2),
          component: componentToken
        });
      };
    }
    return {
      token: proxy,
      keys: tokenKeys2,
      flush
    };
  }
  const defaultTheme = createTheme(derivative);
  const defaultConfig = {
    token: defaultSeedToken,
    hashed: true
  };
  const DesignTokenContextKey = Symbol("DesignTokenContext");
  const globalDesignTokenApi = shallowRef();
  const useDesignTokenProvider = (value) => {
    provide(DesignTokenContextKey, value);
    watch(value, () => {
      globalDesignTokenApi.value = unref(value);
      triggerRef(globalDesignTokenApi);
    }, {
      immediate: true,
      deep: true
    });
  };
  const DesignTokenProvider = /* @__PURE__ */ defineComponent({
    props: {
      value: objectType()
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      useDesignTokenProvider(computed(() => props.value));
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  function useToken() {
    const designTokenContext = inject(DesignTokenContextKey, computed(() => globalDesignTokenApi.value || defaultConfig));
    const salt = computed(() => `${version}-${designTokenContext.value.hashed || ""}`);
    const mergedTheme = computed(() => designTokenContext.value.theme || defaultTheme);
    const cacheToken = useCacheToken(mergedTheme, computed(() => [defaultSeedToken, designTokenContext.value.token]), computed(() => ({
      salt: salt.value,
      override: _extends$1({
        override: designTokenContext.value.token
      }, designTokenContext.value.components),
      formatToken
    })));
    return [mergedTheme, computed(() => cacheToken.value[0]), computed(() => designTokenContext.value.hashed ? cacheToken.value[1] : "")];
  }
  const Empty$2 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    setup() {
      const [, token2] = useToken();
      const themeStyle = computed(() => {
        const bgColor = new TinyColor(token2.value.colorBgBase);
        if (bgColor.toHsl().l < 0.5) {
          return {
            opacity: 0.65
          };
        }
        return {};
      });
      return () => createVNode("svg", {
        "style": themeStyle.value,
        "width": "184",
        "height": "152",
        "viewBox": "0 0 184 152",
        "xmlns": "http://www.w3.org/2000/svg"
      }, [createVNode("g", {
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("g", {
        "transform": "translate(24 31.67)"
      }, [createVNode("ellipse", {
        "fill-opacity": ".8",
        "fill": "#F5F5F7",
        "cx": "67.797",
        "cy": "106.89",
        "rx": "67.797",
        "ry": "12.668"
      }, null), createVNode("path", {
        "d": "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
        "fill": "#AEB8C2"
      }, null), createVNode("path", {
        "d": "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
        "fill": "url(#linearGradient-1)",
        "transform": "translate(13.56)"
      }, null), createVNode("path", {
        "d": "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
        "fill": "#F5F5F7"
      }, null), createVNode("path", {
        "d": "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
        "fill": "#DCE0E6"
      }, null)]), createVNode("path", {
        "d": "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
        "fill": "#DCE0E6"
      }, null), createVNode("g", {
        "transform": "translate(149.65 15.383)",
        "fill": "#FFF"
      }, [createVNode("ellipse", {
        "cx": "20.654",
        "cy": "3.167",
        "rx": "2.849",
        "ry": "2.815"
      }, null), createVNode("path", {
        "d": "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
      }, null)])])]);
    }
  });
  Empty$2.PRESENTED_IMAGE_DEFAULT = true;
  const DefaultEmptyImg = Empty$2;
  const Simple = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    setup() {
      const [, token2] = useToken();
      const color = computed(() => {
        const {
          colorFill,
          colorFillTertiary,
          colorFillQuaternary,
          colorBgContainer
        } = token2.value;
        return {
          borderColor: new TinyColor(colorFill).onBackground(colorBgContainer).toHexString(),
          shadowColor: new TinyColor(colorFillTertiary).onBackground(colorBgContainer).toHexString(),
          contentColor: new TinyColor(colorFillQuaternary).onBackground(colorBgContainer).toHexString()
        };
      });
      return () => createVNode("svg", {
        "width": "64",
        "height": "41",
        "viewBox": "0 0 64 41",
        "xmlns": "http://www.w3.org/2000/svg"
      }, [createVNode("g", {
        "transform": "translate(0 1)",
        "fill": "none",
        "fill-rule": "evenodd"
      }, [createVNode("ellipse", {
        "fill": color.value.shadowColor,
        "cx": "32",
        "cy": "33",
        "rx": "32",
        "ry": "7"
      }, null), createVNode("g", {
        "fill-rule": "nonzero",
        "stroke": color.value.borderColor
      }, [createVNode("path", {
        "d": "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
      }, null), createVNode("path", {
        "d": "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
        "fill": color.value.contentColor
      }, null)])])]);
    }
  });
  Simple.PRESENTED_IMAGE_SIMPLE = true;
  const SimpleEmptyImg = Simple;
  const genSharedEmptyStyle = (token2) => {
    const {
      componentCls,
      margin,
      marginXS,
      marginXL,
      fontSize,
      lineHeight
    } = token2;
    return {
      [componentCls]: {
        marginInline: marginXS,
        fontSize,
        lineHeight,
        textAlign: "center",
        // 原来 &-image 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
        [`${componentCls}-image`]: {
          height: token2.emptyImgHeight,
          marginBottom: marginXS,
          opacity: token2.opacityImage,
          img: {
            height: "100%"
          },
          svg: {
            height: "100%",
            margin: "auto"
          }
        },
        // 原来 &-footer 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
        [`${componentCls}-footer`]: {
          marginTop: margin
        },
        "&-normal": {
          marginBlock: marginXL,
          color: token2.colorTextDisabled,
          [`${componentCls}-image`]: {
            height: token2.emptyImgHeightMD
          }
        },
        "&-small": {
          marginBlock: marginXS,
          color: token2.colorTextDisabled,
          [`${componentCls}-image`]: {
            height: token2.emptyImgHeightSM
          }
        }
      }
    };
  };
  const useStyle$d = genComponentStyleHook("Empty", (token2) => {
    const {
      componentCls,
      controlHeightLG
    } = token2;
    const emptyToken = merge(token2, {
      emptyImgCls: `${componentCls}-img`,
      emptyImgHeight: controlHeightLG * 2.5,
      emptyImgHeightMD: controlHeightLG,
      emptyImgHeightSM: controlHeightLG * 0.875
    });
    return [genSharedEmptyStyle(emptyToken)];
  });
  var __rest$g = function(s2, e2) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  const defaultEmptyImg = createVNode(DefaultEmptyImg, null, null);
  const simpleEmptyImg = createVNode(SimpleEmptyImg, null, null);
  const emptyProps = () => ({
    prefixCls: String,
    imageStyle: objectType(),
    image: anyType(),
    description: anyType()
  });
  const Empty = /* @__PURE__ */ defineComponent({
    name: "AEmpty",
    compatConfig: {
      MODE: 3
    },
    inheritAttrs: false,
    props: emptyProps(),
    setup(props, _ref) {
      let {
        slots = {},
        attrs
      } = _ref;
      const {
        direction,
        prefixCls: prefixClsRef
      } = useConfigInject("empty", props);
      const [wrapSSR, hashId] = useStyle$d(prefixClsRef);
      return () => {
        var _a2, _b;
        const prefixCls = prefixClsRef.value;
        const _c = _extends$1(_extends$1({}, props), attrs), {
          image = ((_a2 = slots.image) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || defaultEmptyImg,
          description = ((_b = slots.description) === null || _b === void 0 ? void 0 : _b.call(slots)) || void 0,
          imageStyle,
          class: className = ""
        } = _c, restProps = __rest$g(_c, ["image", "description", "imageStyle", "class"]);
        return wrapSSR(createVNode(LocaleReceiver, {
          "componentName": "Empty",
          "children": (locale2) => {
            const des = typeof description !== "undefined" ? description : locale2.description;
            const alt = typeof des === "string" ? des : "empty";
            let imageNode = null;
            if (typeof image === "string") {
              imageNode = createVNode("img", {
                "alt": alt,
                "src": image
              }, null);
            } else {
              imageNode = image;
            }
            return createVNode("div", _objectSpread2$1({
              "class": classNames(prefixCls, className, hashId.value, {
                [`${prefixCls}-normal`]: image === simpleEmptyImg,
                [`${prefixCls}-rtl`]: direction.value === "rtl"
              })
            }, restProps), [createVNode("div", {
              "class": `${prefixCls}-image`,
              "style": imageStyle
            }, [imageNode]), des && createVNode("p", {
              "class": `${prefixCls}-description`
            }, [des]), slots.default && createVNode("div", {
              "class": `${prefixCls}-footer`
            }, [filterEmpty(slots.default())])]);
          }
        }, null));
      };
    }
  });
  Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
  Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
  const Empty$1 = withInstall(Empty);
  const DefaultRenderEmpty = (props) => {
    const {
      prefixCls
    } = useConfigInject("empty", props);
    const renderHtml = (componentName) => {
      switch (componentName) {
        case "Table":
        case "List":
          return createVNode(Empty$1, {
            "image": Empty$1.PRESENTED_IMAGE_SIMPLE
          }, null);
        case "Select":
        case "TreeSelect":
        case "Cascader":
        case "Transfer":
        case "Mentions":
          return createVNode(Empty$1, {
            "image": Empty$1.PRESENTED_IMAGE_SIMPLE,
            "class": `${prefixCls.value}-small`
          }, null);
        default:
          return createVNode(Empty$1, null, null);
      }
    };
    return renderHtml(props.componentName);
  };
  function renderEmpty(componentName) {
    return createVNode(DefaultRenderEmpty, {
      "componentName": componentName
    }, null);
  }
  const SizeContextKey = Symbol("SizeContextKey");
  const useInjectSize = () => {
    return inject(SizeContextKey, ref(void 0));
  };
  const useProviderSize = (size2) => {
    const parentSize = useInjectSize();
    provide(SizeContextKey, computed(() => size2.value || parentSize.value));
    return size2;
  };
  const useConfigInject = (name2, props) => {
    const sizeContext = useInjectSize();
    const disabledContext = useInjectDisabled();
    const configProvider = inject(configProviderKey, _extends$1(_extends$1({}, defaultConfigProvider), {
      renderEmpty: (name3) => h$1(DefaultRenderEmpty, {
        componentName: name3
      })
    }));
    const prefixCls = computed(() => configProvider.getPrefixCls(name2, props.prefixCls));
    const direction = computed(() => {
      var _a2, _b;
      return (_a2 = props.direction) !== null && _a2 !== void 0 ? _a2 : (_b = configProvider.direction) === null || _b === void 0 ? void 0 : _b.value;
    });
    const iconPrefixCls = computed(() => {
      var _a2;
      return (_a2 = props.iconPrefixCls) !== null && _a2 !== void 0 ? _a2 : configProvider.iconPrefixCls.value;
    });
    const rootPrefixCls = computed(() => configProvider.getPrefixCls());
    const autoInsertSpaceInButton = computed(() => {
      var _a2;
      return (_a2 = configProvider.autoInsertSpaceInButton) === null || _a2 === void 0 ? void 0 : _a2.value;
    });
    const renderEmpty2 = configProvider.renderEmpty;
    const space = configProvider.space;
    const pageHeader = configProvider.pageHeader;
    const form = configProvider.form;
    const getTargetContainer = computed(() => {
      var _a2, _b;
      return (_a2 = props.getTargetContainer) !== null && _a2 !== void 0 ? _a2 : (_b = configProvider.getTargetContainer) === null || _b === void 0 ? void 0 : _b.value;
    });
    const getPopupContainer = computed(() => {
      var _a2, _b, _c;
      return (_b = (_a2 = props.getContainer) !== null && _a2 !== void 0 ? _a2 : props.getPopupContainer) !== null && _b !== void 0 ? _b : (_c = configProvider.getPopupContainer) === null || _c === void 0 ? void 0 : _c.value;
    });
    const dropdownMatchSelectWidth = computed(() => {
      var _a2, _b;
      return (_a2 = props.dropdownMatchSelectWidth) !== null && _a2 !== void 0 ? _a2 : (_b = configProvider.dropdownMatchSelectWidth) === null || _b === void 0 ? void 0 : _b.value;
    });
    const virtual = computed(() => {
      var _a2;
      return (props.virtual === void 0 ? ((_a2 = configProvider.virtual) === null || _a2 === void 0 ? void 0 : _a2.value) !== false : props.virtual !== false) && dropdownMatchSelectWidth.value !== false;
    });
    const size2 = computed(() => props.size || sizeContext.value);
    const autocomplete = computed(() => {
      var _a2, _b, _c;
      return (_a2 = props.autocomplete) !== null && _a2 !== void 0 ? _a2 : (_c = (_b = configProvider.input) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.autocomplete;
    });
    const disabled = computed(() => {
      var _a2;
      return (_a2 = props.disabled) !== null && _a2 !== void 0 ? _a2 : disabledContext.value;
    });
    const csp = computed(() => {
      var _a2;
      return (_a2 = props.csp) !== null && _a2 !== void 0 ? _a2 : configProvider.csp;
    });
    const wave = computed(() => {
      var _a2, _b;
      return (_a2 = props.wave) !== null && _a2 !== void 0 ? _a2 : (_b = configProvider.wave) === null || _b === void 0 ? void 0 : _b.value;
    });
    return {
      configProvider,
      prefixCls,
      direction,
      size: size2,
      getTargetContainer,
      getPopupContainer,
      space,
      pageHeader,
      form,
      autoInsertSpaceInButton,
      renderEmpty: renderEmpty2,
      virtual,
      dropdownMatchSelectWidth,
      rootPrefixCls,
      getPrefixCls: configProvider.getPrefixCls,
      autocomplete,
      csp,
      iconPrefixCls,
      disabled,
      select: configProvider.select,
      wave
    };
  };
  function omit$1(obj, fields) {
    const shallowCopy = _extends$1({}, obj);
    for (let i2 = 0; i2 < fields.length; i2 += 1) {
      const key2 = fields[i2];
      delete shallowCopy[key2];
    }
    return shallowCopy;
  }
  function t$1(t2) {
    return "object" == typeof t2 && null != t2 && 1 === t2.nodeType;
  }
  function e$1(t2, e2) {
    return (!e2 || "hidden" !== t2) && "visible" !== t2 && "clip" !== t2;
  }
  function n$1(t2, n2) {
    if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
      var r2 = getComputedStyle(t2, null);
      return e$1(r2.overflowY, n2) || e$1(r2.overflowX, n2) || function(t3) {
        var e2 = function(t4) {
          if (!t4.ownerDocument || !t4.ownerDocument.defaultView)
            return null;
          try {
            return t4.ownerDocument.defaultView.frameElement;
          } catch (t5) {
            return null;
          }
        }(t3);
        return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
      }(t2);
    }
    return false;
  }
  function r$1(t2, e2, n2, r2, i2, o2, l2, d2) {
    return o2 < t2 && l2 > e2 || o2 > t2 && l2 < e2 ? 0 : o2 <= t2 && d2 <= n2 || l2 >= e2 && d2 >= n2 ? o2 - t2 - r2 : l2 > e2 && d2 < n2 || o2 < t2 && d2 > n2 ? l2 - e2 + i2 : 0;
  }
  var i$1 = function(e2, i2) {
    var o2 = window, l2 = i2.scrollMode, d2 = i2.block, f2 = i2.inline, h2 = i2.boundary, u2 = i2.skipOverflowHiddenElements, s2 = "function" == typeof h2 ? h2 : function(t2) {
      return t2 !== h2;
    };
    if (!t$1(e2))
      throw new TypeError("Invalid target");
    for (var a2, c2, g2 = document.scrollingElement || document.documentElement, p = [], m2 = e2; t$1(m2) && s2(m2); ) {
      if ((m2 = null == (c2 = (a2 = m2).parentElement) ? a2.getRootNode().host || null : c2) === g2) {
        p.push(m2);
        break;
      }
      null != m2 && m2 === document.body && n$1(m2) && !n$1(document.documentElement) || null != m2 && n$1(m2, u2) && p.push(m2);
    }
    for (var w2 = o2.visualViewport ? o2.visualViewport.width : innerWidth, v2 = o2.visualViewport ? o2.visualViewport.height : innerHeight, W = window.scrollX || pageXOffset, H = window.scrollY || pageYOffset, b2 = e2.getBoundingClientRect(), y2 = b2.height, E2 = b2.width, M2 = b2.top, V2 = b2.right, x2 = b2.bottom, I2 = b2.left, C = "start" === d2 || "nearest" === d2 ? M2 : "end" === d2 ? x2 : M2 + y2 / 2, R2 = "center" === f2 ? I2 + E2 / 2 : "end" === f2 ? V2 : I2, T2 = [], k2 = 0; k2 < p.length; k2++) {
      var B2 = p[k2], D2 = B2.getBoundingClientRect(), O2 = D2.height, X = D2.width, Y2 = D2.top, L2 = D2.right, S2 = D2.bottom, j2 = D2.left;
      if ("if-needed" === l2 && M2 >= 0 && I2 >= 0 && x2 <= v2 && V2 <= w2 && M2 >= Y2 && x2 <= S2 && I2 >= j2 && V2 <= L2)
        return T2;
      var N2 = getComputedStyle(B2), q2 = parseInt(N2.borderLeftWidth, 10), z2 = parseInt(N2.borderTopWidth, 10), A2 = parseInt(N2.borderRightWidth, 10), F2 = parseInt(N2.borderBottomWidth, 10), G = 0, J2 = 0, K = "offsetWidth" in B2 ? B2.offsetWidth - B2.clientWidth - q2 - A2 : 0, P2 = "offsetHeight" in B2 ? B2.offsetHeight - B2.clientHeight - z2 - F2 : 0, Q = "offsetWidth" in B2 ? 0 === B2.offsetWidth ? 0 : X / B2.offsetWidth : 0, U = "offsetHeight" in B2 ? 0 === B2.offsetHeight ? 0 : O2 / B2.offsetHeight : 0;
      if (g2 === B2)
        G = "start" === d2 ? C : "end" === d2 ? C - v2 : "nearest" === d2 ? r$1(H, H + v2, v2, z2, F2, H + C, H + C + y2, y2) : C - v2 / 2, J2 = "start" === f2 ? R2 : "center" === f2 ? R2 - w2 / 2 : "end" === f2 ? R2 - w2 : r$1(W, W + w2, w2, q2, A2, W + R2, W + R2 + E2, E2), G = Math.max(0, G + H), J2 = Math.max(0, J2 + W);
      else {
        G = "start" === d2 ? C - Y2 - z2 : "end" === d2 ? C - S2 + F2 + P2 : "nearest" === d2 ? r$1(Y2, S2, O2, z2, F2 + P2, C, C + y2, y2) : C - (Y2 + O2 / 2) + P2 / 2, J2 = "start" === f2 ? R2 - j2 - q2 : "center" === f2 ? R2 - (j2 + X / 2) + K / 2 : "end" === f2 ? R2 - L2 + A2 + K : r$1(j2, L2, X, q2, A2 + K, R2, R2 + E2, E2);
        var Z = B2.scrollLeft, $2 = B2.scrollTop;
        C += $2 - (G = Math.max(0, Math.min($2 + G / U, B2.scrollHeight - O2 / U + P2))), R2 += Z - (J2 = Math.max(0, Math.min(Z + J2 / Q, B2.scrollWidth - X / Q + K)));
      }
      T2.push({ el: B2, top: G, left: J2 });
    }
    return T2;
  };
  function isOptionsObject(options) {
    return options === Object(options) && Object.keys(options).length !== 0;
  }
  function defaultBehavior(actions, behavior) {
    if (behavior === void 0) {
      behavior = "auto";
    }
    var canSmoothScroll = "scrollBehavior" in document.body.style;
    actions.forEach(function(_ref) {
      var el = _ref.el, top = _ref.top, left = _ref.left;
      if (el.scroll && canSmoothScroll) {
        el.scroll({
          top,
          left,
          behavior
        });
      } else {
        el.scrollTop = top;
        el.scrollLeft = left;
      }
    });
  }
  function getOptions(options) {
    if (options === false) {
      return {
        block: "end",
        inline: "nearest"
      };
    }
    if (isOptionsObject(options)) {
      return options;
    }
    return {
      block: "start",
      inline: "nearest"
    };
  }
  function scrollIntoView(target, options) {
    var isTargetAttached = target.isConnected || target.ownerDocument.documentElement.contains(target);
    if (isOptionsObject(options) && typeof options.behavior === "function") {
      return options.behavior(isTargetAttached ? i$1(target, options) : []);
    }
    if (!isTargetAttached) {
      return;
    }
    var computeOptions = getOptions(options);
    return defaultBehavior(i$1(target, computeOptions), computeOptions.behavior);
  }
  function e(e2, t2) {
    for (var n2 = 0; n2 < t2.length; n2++) {
      var r2 = t2[n2];
      r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);
    }
  }
  function t(t2, n2, r2) {
    return n2 && e(t2.prototype, n2), r2 && e(t2, r2), t2;
  }
  function n() {
    return (n = Object.assign || function(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var n2 = arguments[t2];
        for (var r2 in n2)
          Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
      }
      return e2;
    }).apply(this, arguments);
  }
  function r(e2, t2) {
    e2.prototype = Object.create(t2.prototype), e2.prototype.constructor = e2, e2.__proto__ = t2;
  }
  function i(e2, t2) {
    if (null == e2)
      return {};
    var n2, r2, i2 = {}, o2 = Object.keys(e2);
    for (r2 = 0; r2 < o2.length; r2++)
      t2.indexOf(n2 = o2[r2]) >= 0 || (i2[n2] = e2[n2]);
    return i2;
  }
  function o(e2) {
    return 1 == (null != (t2 = e2) && "object" == typeof t2 && false === Array.isArray(t2)) && "[object Object]" === Object.prototype.toString.call(e2);
    var t2;
  }
  var u = Object.prototype, a = u.toString, f = u.hasOwnProperty, c = /^\s*function (\w+)/;
  function l(e2) {
    var t2, n2 = null !== (t2 = null == e2 ? void 0 : e2.type) && void 0 !== t2 ? t2 : e2;
    if (n2) {
      var r2 = n2.toString().match(c);
      return r2 ? r2[1] : "";
    }
    return "";
  }
  var s = function(e2) {
    var t2, n2;
    return false !== o(e2) && "function" == typeof (t2 = e2.constructor) && false !== o(n2 = t2.prototype) && false !== n2.hasOwnProperty("isPrototypeOf");
  }, v = function(e2) {
    return e2;
  }, y = v;
  {
    var p = "undefined" != typeof console;
    y = p ? function(e2) {
      console.warn("[VueTypes warn]: " + e2);
    } : v;
  }
  var d = function(e2, t2) {
    return f.call(e2, t2);
  }, h = Number.isInteger || function(e2) {
    return "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
  }, b = Array.isArray || function(e2) {
    return "[object Array]" === a.call(e2);
  }, O = function(e2) {
    return "[object Function]" === a.call(e2);
  }, g = function(e2) {
    return s(e2) && d(e2, "_vueTypes_name");
  }, m = function(e2) {
    return s(e2) && (d(e2, "type") || ["_vueTypes_name", "validator", "default", "required"].some(function(t2) {
      return d(e2, t2);
    }));
  };
  function j(e2, t2) {
    return Object.defineProperty(e2.bind(t2), "__original", { value: e2 });
  }
  function _(e2, t2, n2) {
    var r2;
    void 0 === n2 && (n2 = false);
    var i2 = true, o2 = "";
    r2 = s(e2) ? e2 : { type: e2 };
    var u2 = g(r2) ? r2._vueTypes_name + " - " : "";
    if (m(r2) && null !== r2.type) {
      if (void 0 === r2.type || true === r2.type)
        return i2;
      if (!r2.required && void 0 === t2)
        return i2;
      b(r2.type) ? (i2 = r2.type.some(function(e3) {
        return true === _(e3, t2, true);
      }), o2 = r2.type.map(function(e3) {
        return l(e3);
      }).join(" or ")) : i2 = "Array" === (o2 = l(r2)) ? b(t2) : "Object" === o2 ? s(t2) : "String" === o2 || "Number" === o2 || "Boolean" === o2 || "Function" === o2 ? function(e3) {
        if (null == e3)
          return "";
        var t3 = e3.constructor.toString().match(c);
        return t3 ? t3[1] : "";
      }(t2) === o2 : t2 instanceof r2.type;
    }
    if (!i2) {
      var a2 = u2 + 'value "' + t2 + '" should be of type "' + o2 + '"';
      return false === n2 ? (y(a2), false) : a2;
    }
    if (d(r2, "validator") && O(r2.validator)) {
      var f2 = y, v2 = [];
      if (y = function(e3) {
        v2.push(e3);
      }, i2 = r2.validator(t2), y = f2, !i2) {
        var p = (v2.length > 1 ? "* " : "") + v2.join("\n* ");
        return v2.length = 0, false === n2 ? (y(p), i2) : p;
      }
    }
    return i2;
  }
  function T(e2, t2) {
    var n2 = Object.defineProperties(t2, { _vueTypes_name: { value: e2, writable: true }, isRequired: { get: function() {
      return this.required = true, this;
    } }, def: { value: function(e3) {
      return void 0 !== e3 || this.default ? O(e3) || true === _(this, e3, true) ? (this.default = b(e3) ? function() {
        return [].concat(e3);
      } : s(e3) ? function() {
        return Object.assign({}, e3);
      } : e3, this) : (y(this._vueTypes_name + ' - invalid default value: "' + e3 + '"'), this) : this;
    } } }), r2 = n2.validator;
    return O(r2) && (n2.validator = j(r2, n2)), n2;
  }
  function w(e2, t2) {
    var n2 = T(e2, t2);
    return Object.defineProperty(n2, "validate", { value: function(e3) {
      return O(this.validator) && y(this._vueTypes_name + " - calling .validate() will overwrite the current custom validator function. Validator info:\n" + JSON.stringify(this)), this.validator = j(e3, this), this;
    } });
  }
  function k(e2, t2, n2) {
    var r2, o2, u2 = (r2 = t2, o2 = {}, Object.getOwnPropertyNames(r2).forEach(function(e3) {
      o2[e3] = Object.getOwnPropertyDescriptor(r2, e3);
    }), Object.defineProperties({}, o2));
    if (u2._vueTypes_name = e2, !s(n2))
      return u2;
    var a2, f2, c2 = n2.validator, l2 = i(n2, ["validator"]);
    if (O(c2)) {
      var v2 = u2.validator;
      v2 && (v2 = null !== (f2 = (a2 = v2).__original) && void 0 !== f2 ? f2 : a2), u2.validator = j(v2 ? function(e3) {
        return v2.call(this, e3) && c2.call(this, e3);
      } : c2, u2);
    }
    return Object.assign(u2, l2);
  }
  function P(e2) {
    return e2.replace(/^(?!\s*$)/gm, "  ");
  }
  var x = function() {
    return w("any", {});
  }, A = function() {
    return w("function", { type: Function });
  }, E = function() {
    return w("boolean", { type: Boolean });
  }, N = function() {
    return w("string", { type: String });
  }, q = function() {
    return w("number", { type: Number });
  }, S = function() {
    return w("array", { type: Array });
  }, V = function() {
    return w("object", { type: Object });
  }, F = function() {
    return T("integer", { type: Number, validator: function(e2) {
      return h(e2);
    } });
  }, D = function() {
    return T("symbol", { validator: function(e2) {
      return "symbol" == typeof e2;
    } });
  };
  function L(e2, t2) {
    if (void 0 === t2 && (t2 = "custom validation failed"), "function" != typeof e2)
      throw new TypeError("[VueTypes error]: You must provide a function as argument");
    return T(e2.name || "<<anonymous function>>", { validator: function(n2) {
      var r2 = e2(n2);
      return r2 || y(this._vueTypes_name + " - " + t2), r2;
    } });
  }
  function Y(e2) {
    if (!b(e2))
      throw new TypeError("[VueTypes error]: You must provide an array as argument.");
    var t2 = 'oneOf - value should be one of "' + e2.join('", "') + '".', n2 = e2.reduce(function(e3, t3) {
      if (null != t3) {
        var n3 = t3.constructor;
        -1 === e3.indexOf(n3) && e3.push(n3);
      }
      return e3;
    }, []);
    return T("oneOf", { type: n2.length > 0 ? n2 : void 0, validator: function(n3) {
      var r2 = -1 !== e2.indexOf(n3);
      return r2 || y(t2), r2;
    } });
  }
  function B(e2) {
    if (!b(e2))
      throw new TypeError("[VueTypes error]: You must provide an array as argument");
    for (var t2 = false, n2 = [], r2 = 0; r2 < e2.length; r2 += 1) {
      var i2 = e2[r2];
      if (m(i2)) {
        if (g(i2) && "oneOf" === i2._vueTypes_name) {
          n2 = n2.concat(i2.type);
          continue;
        }
        if (O(i2.validator) && (t2 = true), true !== i2.type && i2.type) {
          n2 = n2.concat(i2.type);
          continue;
        }
      }
      n2.push(i2);
    }
    return n2 = n2.filter(function(e3, t3) {
      return n2.indexOf(e3) === t3;
    }), T("oneOfType", t2 ? { type: n2, validator: function(t3) {
      var n3 = [], r3 = e2.some(function(e3) {
        var r4 = _(g(e3) && "oneOf" === e3._vueTypes_name ? e3.type || null : e3, t3, true);
        return "string" == typeof r4 && n3.push(r4), true === r4;
      });
      return r3 || y("oneOfType - provided value does not match any of the " + n3.length + " passed-in validators:\n" + P(n3.join("\n"))), r3;
    } } : { type: n2 });
  }
  function I(e2) {
    return T("arrayOf", { type: Array, validator: function(t2) {
      var n2, r2 = t2.every(function(t3) {
        return true === (n2 = _(e2, t3, true));
      });
      return r2 || y("arrayOf - value validation error:\n" + P(n2)), r2;
    } });
  }
  function J(e2) {
    return T("instanceOf", { type: e2 });
  }
  function M(e2) {
    return T("objectOf", { type: Object, validator: function(t2) {
      var n2, r2 = Object.keys(t2).every(function(r3) {
        return true === (n2 = _(e2, t2[r3], true));
      });
      return r2 || y("objectOf - value validation error:\n" + P(n2)), r2;
    } });
  }
  function R(e2) {
    var t2 = Object.keys(e2), n2 = t2.filter(function(t3) {
      var n3;
      return !!(null === (n3 = e2[t3]) || void 0 === n3 ? void 0 : n3.required);
    }), r2 = T("shape", { type: Object, validator: function(r3) {
      var i2 = this;
      if (!s(r3))
        return false;
      var o2 = Object.keys(r3);
      if (n2.length > 0 && n2.some(function(e3) {
        return -1 === o2.indexOf(e3);
      })) {
        var u2 = n2.filter(function(e3) {
          return -1 === o2.indexOf(e3);
        });
        return y(1 === u2.length ? 'shape - required property "' + u2[0] + '" is not defined.' : 'shape - required properties "' + u2.join('", "') + '" are not defined.'), false;
      }
      return o2.every(function(n3) {
        if (-1 === t2.indexOf(n3))
          return true === i2._vueTypes_isLoose || (y('shape - shape definition does not include a "' + n3 + '" property. Allowed keys: "' + t2.join('", "') + '".'), false);
        var o3 = _(e2[n3], r3[n3], true);
        return "string" == typeof o3 && y('shape - "' + n3 + '" property validation error:\n ' + P(o3)), true === o3;
      });
    } });
    return Object.defineProperty(r2, "_vueTypes_isLoose", { writable: true, value: false }), Object.defineProperty(r2, "loose", { get: function() {
      return this._vueTypes_isLoose = true, this;
    } }), r2;
  }
  var $ = function() {
    function e2() {
    }
    return e2.extend = function(e3) {
      var t2 = this;
      if (b(e3))
        return e3.forEach(function(e4) {
          return t2.extend(e4);
        }), this;
      var n2 = e3.name, r2 = e3.validate, o2 = void 0 !== r2 && r2, u2 = e3.getter, a2 = void 0 !== u2 && u2, f2 = i(e3, ["name", "validate", "getter"]);
      if (d(this, n2))
        throw new TypeError('[VueTypes error]: Type "' + n2 + '" already defined');
      var c2, l2 = f2.type;
      return g(l2) ? (delete f2.type, Object.defineProperty(this, n2, a2 ? { get: function() {
        return k(n2, l2, f2);
      } } : { value: function() {
        var e4, t3 = k(n2, l2, f2);
        return t3.validator && (t3.validator = (e4 = t3.validator).bind.apply(e4, [t3].concat([].slice.call(arguments)))), t3;
      } })) : (c2 = a2 ? { get: function() {
        var e4 = Object.assign({}, f2);
        return o2 ? w(n2, e4) : T(n2, e4);
      }, enumerable: true } : { value: function() {
        var e4, t3, r3 = Object.assign({}, f2);
        return e4 = o2 ? w(n2, r3) : T(n2, r3), r3.validator && (e4.validator = (t3 = r3.validator).bind.apply(t3, [e4].concat([].slice.call(arguments)))), e4;
      }, enumerable: true }, Object.defineProperty(this, n2, c2));
    }, t(e2, null, [{ key: "any", get: function() {
      return x();
    } }, { key: "func", get: function() {
      return A().def(this.defaults.func);
    } }, { key: "bool", get: function() {
      return E().def(this.defaults.bool);
    } }, { key: "string", get: function() {
      return N().def(this.defaults.string);
    } }, { key: "number", get: function() {
      return q().def(this.defaults.number);
    } }, { key: "array", get: function() {
      return S().def(this.defaults.array);
    } }, { key: "object", get: function() {
      return V().def(this.defaults.object);
    } }, { key: "integer", get: function() {
      return F().def(this.defaults.integer);
    } }, { key: "symbol", get: function() {
      return D();
    } }]), e2;
  }();
  function z(e2) {
    var i2;
    return void 0 === e2 && (e2 = { func: function() {
    }, bool: true, string: "", number: 0, array: function() {
      return [];
    }, object: function() {
      return {};
    }, integer: 0 }), (i2 = function(i3) {
      function o2() {
        return i3.apply(this, arguments) || this;
      }
      return r(o2, i3), t(o2, null, [{ key: "sensibleDefaults", get: function() {
        return n({}, this.defaults);
      }, set: function(t2) {
        this.defaults = false !== t2 ? n({}, true !== t2 ? t2 : e2) : {};
      } }]), o2;
    }($)).defaults = n({}, e2), i2;
  }
  $.defaults = {}, $.custom = L, $.oneOf = Y, $.instanceOf = J, $.oneOfType = B, $.arrayOf = I, $.objectOf = M, $.shape = R, $.utils = { validate: function(e2, t2) {
    return true === _(t2, e2, true);
  }, toType: function(e2, t2, n2) {
    return void 0 === n2 && (n2 = false), n2 ? w(e2, t2) : T(e2, t2);
  } };
  (function(e2) {
    function t2() {
      return e2.apply(this, arguments) || this;
    }
    return r(t2, e2), t2;
  })(z());
  const PropTypes = z({
    func: void 0,
    bool: void 0,
    string: void 0,
    number: void 0,
    array: void 0,
    object: void 0,
    integer: void 0
  });
  PropTypes.extend([{
    name: "looseBool",
    getter: true,
    type: Boolean,
    default: void 0
  }, {
    name: "style",
    getter: true,
    type: [String, Object],
    default: void 0
  }, {
    name: "VueNode",
    getter: true,
    type: null
  }]);
  const devWarning = (valid, component, message) => {
    warningOnce(valid, `[ant-design-vue: ${component}] ${message}`);
  };
  function returnEmptyString() {
    return "";
  }
  function returnDocument(element) {
    if (element) {
      return element.ownerDocument;
    }
    return window.document;
  }
  function noop$2() {
  }
  const triggerProps = () => ({
    action: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]).def([]),
    showAction: PropTypes.any.def([]),
    hideAction: PropTypes.any.def([]),
    getPopupClassNameFromAlign: PropTypes.any.def(returnEmptyString),
    onPopupVisibleChange: Function,
    afterPopupVisibleChange: PropTypes.func.def(noop$2),
    popup: PropTypes.any,
    popupStyle: {
      type: Object,
      default: void 0
    },
    prefixCls: PropTypes.string.def("rc-trigger-popup"),
    popupClassName: PropTypes.string.def(""),
    popupPlacement: String,
    builtinPlacements: PropTypes.object,
    popupTransitionName: String,
    popupAnimation: PropTypes.any,
    mouseEnterDelay: PropTypes.number.def(0),
    mouseLeaveDelay: PropTypes.number.def(0.1),
    zIndex: Number,
    focusDelay: PropTypes.number.def(0),
    blurDelay: PropTypes.number.def(0.15),
    getPopupContainer: Function,
    getDocument: PropTypes.func.def(returnDocument),
    forceRender: {
      type: Boolean,
      default: void 0
    },
    destroyPopupOnHide: {
      type: Boolean,
      default: false
    },
    mask: {
      type: Boolean,
      default: false
    },
    maskClosable: {
      type: Boolean,
      default: true
    },
    // onPopupAlign: PropTypes.func.def(noop),
    popupAlign: PropTypes.object.def(() => ({})),
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    maskTransitionName: String,
    maskAnimation: String,
    stretch: String,
    alignPoint: {
      type: Boolean,
      default: void 0
    },
    autoDestroy: {
      type: Boolean,
      default: false
    },
    mobile: Object,
    getTriggerDOMNode: Function
  });
  const innerProps = {
    visible: Boolean,
    prefixCls: String,
    zIndex: Number,
    destroyPopupOnHide: Boolean,
    forceRender: Boolean,
    // Legacy Motion
    animation: [String, Object],
    transitionName: String,
    // Measure
    stretch: {
      type: String
    },
    // Align
    align: {
      type: Object
    },
    point: {
      type: Object
    },
    getRootDomNode: {
      type: Function
    },
    getClassNameFromAlign: {
      type: Function
    },
    onAlign: {
      type: Function
    },
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onMousedown: {
      type: Function
    },
    onTouchstart: {
      type: Function
    }
  };
  const mobileProps = _extends$1(_extends$1({}, innerProps), {
    mobile: {
      type: Object
    }
  });
  const popupProps = _extends$1(_extends$1({}, innerProps), {
    mask: Boolean,
    mobile: {
      type: Object
    },
    maskAnimation: String,
    maskTransitionName: String
  });
  function getMotion$1(_ref) {
    let {
      prefixCls,
      animation,
      transitionName: transitionName2
    } = _ref;
    if (animation) {
      return {
        name: `${prefixCls}-${animation}`
      };
    }
    if (transitionName2) {
      return {
        name: transitionName2
      };
    }
    return {};
  }
  function Mask$1(props) {
    const {
      prefixCls,
      visible,
      zIndex,
      mask,
      maskAnimation,
      maskTransitionName
    } = props;
    if (!mask) {
      return null;
    }
    let motion = {};
    if (maskTransitionName || maskAnimation) {
      motion = getMotion$1({
        prefixCls,
        transitionName: maskTransitionName,
        animation: maskAnimation
      });
    }
    return createVNode(Transition, _objectSpread2$1({
      "appear": true
    }, motion), {
      default: () => [withDirectives(createVNode("div", {
        "style": {
          zIndex
        },
        "class": `${prefixCls}-mask`
      }, null), [[resolveDirective("if"), visible]])]
    });
  }
  Mask$1.displayName = "Mask";
  const MobilePopupInner = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "MobilePopupInner",
    inheritAttrs: false,
    props: mobileProps,
    emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
    setup(props, _ref) {
      let {
        expose,
        slots
      } = _ref;
      const elementRef = ref();
      expose({
        forceAlign: () => {
        },
        getElement: () => elementRef.value
      });
      return () => {
        var _a2;
        const {
          zIndex,
          visible,
          prefixCls,
          mobile: {
            popupClassName,
            popupStyle,
            popupMotion = {},
            popupRender
          } = {}
        } = props;
        const mergedStyle = _extends$1({
          zIndex
        }, popupStyle);
        let childNode = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
        if (childNode.length > 1) {
          childNode = createVNode("div", {
            "class": `${prefixCls}-content`
          }, [childNode]);
        }
        if (popupRender) {
          childNode = popupRender(childNode);
        }
        const mergedClassName = classNames(prefixCls, popupClassName);
        return createVNode(Transition, _objectSpread2$1({
          "ref": elementRef
        }, popupMotion), {
          default: () => [visible ? createVNode("div", {
            "class": mergedClassName,
            "style": mergedStyle
          }, [childNode]) : null]
        });
      };
    }
  });
  var __awaiter$1 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  const StatusQueue = ["measure", "align", null, "motion"];
  const useVisibleStatus = (visible, doMeasure) => {
    const status = shallowRef(null);
    const rafRef = shallowRef();
    const destroyRef = shallowRef(false);
    function setStatus(nextStatus) {
      if (!destroyRef.value) {
        status.value = nextStatus;
      }
    }
    function cancelRaf() {
      wrapperRaf.cancel(rafRef.value);
    }
    function goNextStatus(callback) {
      cancelRaf();
      rafRef.value = wrapperRaf(() => {
        let newStatus = status.value;
        switch (status.value) {
          case "align":
            newStatus = "motion";
            break;
          case "motion":
            newStatus = "stable";
            break;
        }
        setStatus(newStatus);
        callback === null || callback === void 0 ? void 0 : callback();
      });
    }
    watch(visible, () => {
      setStatus("measure");
    }, {
      immediate: true,
      flush: "post"
    });
    onMounted(() => {
      watch(status, () => {
        switch (status.value) {
          case "measure":
            doMeasure();
            break;
        }
        if (status.value) {
          rafRef.value = wrapperRaf(() => __awaiter$1(void 0, void 0, void 0, function* () {
            const index2 = StatusQueue.indexOf(status.value);
            const nextStatus = StatusQueue[index2 + 1];
            if (nextStatus && index2 !== -1) {
              setStatus(nextStatus);
            }
          }));
        }
      }, {
        immediate: true,
        flush: "post"
      });
    });
    onBeforeUnmount(() => {
      destroyRef.value = true;
      cancelRaf();
    });
    return [status, goNextStatus];
  };
  const useStretchStyle = (stretch) => {
    const targetSize = shallowRef({
      width: 0,
      height: 0
    });
    function measureStretch(element) {
      targetSize.value = {
        width: element.offsetWidth,
        height: element.offsetHeight
      };
    }
    const style = computed(() => {
      const sizeStyle = {};
      if (stretch.value) {
        const {
          width,
          height
        } = targetSize.value;
        if (stretch.value.indexOf("height") !== -1 && height) {
          sizeStyle.height = `${height}px`;
        } else if (stretch.value.indexOf("minHeight") !== -1 && height) {
          sizeStyle.minHeight = `${height}px`;
        }
        if (stretch.value.indexOf("width") !== -1 && width) {
          sizeStyle.width = `${width}px`;
        } else if (stretch.value.indexOf("minWidth") !== -1 && width) {
          sizeStyle.minWidth = `${width}px`;
        }
      }
      return sizeStyle;
    });
    return [style, measureStretch];
  };
  function ownKeys(object4, enumerableOnly) {
    var keys2 = Object.keys(object4);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object4);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
        _defineProperty$h(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }
  function _defineProperty$h(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var vendorPrefix;
  var jsCssMap = {
    Webkit: "-webkit-",
    Moz: "-moz-",
    // IE did it wrong again ...
    ms: "-ms-",
    O: "-o-"
  };
  function getVendorPrefix() {
    if (vendorPrefix !== void 0) {
      return vendorPrefix;
    }
    vendorPrefix = "";
    var style = document.createElement("p").style;
    var testProp = "Transform";
    for (var key2 in jsCssMap) {
      if (key2 + testProp in style) {
        vendorPrefix = key2;
      }
    }
    return vendorPrefix;
  }
  function getTransitionName$1() {
    return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : "transitionProperty";
  }
  function getTransformName() {
    return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : "transform";
  }
  function setTransitionProperty(node2, value) {
    var name2 = getTransitionName$1();
    if (name2) {
      node2.style[name2] = value;
      if (name2 !== "transitionProperty") {
        node2.style.transitionProperty = value;
      }
    }
  }
  function setTransform(node2, value) {
    var name2 = getTransformName();
    if (name2) {
      node2.style[name2] = value;
      if (name2 !== "transform") {
        node2.style.transform = value;
      }
    }
  }
  function getTransitionProperty(node2) {
    return node2.style.transitionProperty || node2.style[getTransitionName$1()];
  }
  function getTransformXY(node2) {
    var style = window.getComputedStyle(node2, null);
    var transform = style.getPropertyValue("transform") || style.getPropertyValue(getTransformName());
    if (transform && transform !== "none") {
      var matrix = transform.replace(/[^0-9\-.,]/g, "").split(",");
      return {
        x: parseFloat(matrix[12] || matrix[4], 0),
        y: parseFloat(matrix[13] || matrix[5], 0)
      };
    }
    return {
      x: 0,
      y: 0
    };
  }
  var matrix2d = /matrix\((.*)\)/;
  var matrix3d = /matrix3d\((.*)\)/;
  function setTransformXY(node2, xy) {
    var style = window.getComputedStyle(node2, null);
    var transform = style.getPropertyValue("transform") || style.getPropertyValue(getTransformName());
    if (transform && transform !== "none") {
      var arr;
      var match2d = transform.match(matrix2d);
      if (match2d) {
        match2d = match2d[1];
        arr = match2d.split(",").map(function(item) {
          return parseFloat(item, 10);
        });
        arr[4] = xy.x;
        arr[5] = xy.y;
        setTransform(node2, "matrix(".concat(arr.join(","), ")"));
      } else {
        var match3d = transform.match(matrix3d)[1];
        arr = match3d.split(",").map(function(item) {
          return parseFloat(item, 10);
        });
        arr[12] = xy.x;
        arr[13] = xy.y;
        setTransform(node2, "matrix3d(".concat(arr.join(","), ")"));
      }
    } else {
      setTransform(node2, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
    }
  }
  var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
  var getComputedStyleX;
  function forceRelayout(elem) {
    var originalStyle = elem.style.display;
    elem.style.display = "none";
    elem.offsetHeight;
    elem.style.display = originalStyle;
  }
  function css(el, name2, v2) {
    var value = v2;
    if (_typeof(name2) === "object") {
      for (var i2 in name2) {
        if (name2.hasOwnProperty(i2)) {
          css(el, i2, name2[i2]);
        }
      }
      return void 0;
    }
    if (typeof value !== "undefined") {
      if (typeof value === "number") {
        value = "".concat(value, "px");
      }
      el.style[name2] = value;
      return void 0;
    }
    return getComputedStyleX(el, name2);
  }
  function getClientPosition(elem) {
    var box2;
    var x2;
    var y2;
    var doc2 = elem.ownerDocument;
    var body = doc2.body;
    var docElem = doc2 && doc2.documentElement;
    box2 = elem.getBoundingClientRect();
    x2 = Math.floor(box2.left);
    y2 = Math.floor(box2.top);
    x2 -= docElem.clientLeft || body.clientLeft || 0;
    y2 -= docElem.clientTop || body.clientTop || 0;
    return {
      left: x2,
      top: y2
    };
  }
  function getScroll$1(w2, top) {
    var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
    var method4 = "scroll".concat(top ? "Top" : "Left");
    if (typeof ret !== "number") {
      var d2 = w2.document;
      ret = d2.documentElement[method4];
      if (typeof ret !== "number") {
        ret = d2.body[method4];
      }
    }
    return ret;
  }
  function getScrollLeft(w2) {
    return getScroll$1(w2);
  }
  function getScrollTop(w2) {
    return getScroll$1(w2, true);
  }
  function getOffset(el) {
    var pos = getClientPosition(el);
    var doc2 = el.ownerDocument;
    var w2 = doc2.defaultView || doc2.parentWindow;
    pos.left += getScrollLeft(w2);
    pos.top += getScrollTop(w2);
    return pos;
  }
  function isWindow(obj) {
    return obj !== null && obj !== void 0 && obj == obj.window;
  }
  function getDocument(node2) {
    if (isWindow(node2)) {
      return node2.document;
    }
    if (node2.nodeType === 9) {
      return node2;
    }
    return node2.ownerDocument;
  }
  function _getComputedStyle(elem, name2, cs) {
    var computedStyle = cs;
    var val = "";
    var d2 = getDocument(elem);
    computedStyle = computedStyle || d2.defaultView.getComputedStyle(elem, null);
    if (computedStyle) {
      val = computedStyle.getPropertyValue(name2) || computedStyle[name2];
    }
    return val;
  }
  var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), "i");
  var RE_POS = /^(top|right|bottom|left)$/;
  var CURRENT_STYLE = "currentStyle";
  var RUNTIME_STYLE = "runtimeStyle";
  var LEFT = "left";
  var PX = "px";
  function _getComputedStyleIE(elem, name2) {
    var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name2];
    if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name2)) {
      var style = elem.style;
      var left = style[LEFT];
      var rsLeft = elem[RUNTIME_STYLE][LEFT];
      elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];
      style[LEFT] = name2 === "fontSize" ? "1em" : ret || 0;
      ret = style.pixelLeft + PX;
      style[LEFT] = left;
      elem[RUNTIME_STYLE][LEFT] = rsLeft;
    }
    return ret === "" ? "auto" : ret;
  }
  if (typeof window !== "undefined") {
    getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
  }
  function getOffsetDirection(dir, option) {
    if (dir === "left") {
      return option.useCssRight ? "right" : dir;
    }
    return option.useCssBottom ? "bottom" : dir;
  }
  function oppositeOffsetDirection(dir) {
    if (dir === "left") {
      return "right";
    } else if (dir === "right") {
      return "left";
    } else if (dir === "top") {
      return "bottom";
    } else if (dir === "bottom") {
      return "top";
    }
  }
  function setLeftTop(elem, offset3, option) {
    if (css(elem, "position") === "static") {
      elem.style.position = "relative";
    }
    var presetH = -999;
    var presetV = -999;
    var horizontalProperty = getOffsetDirection("left", option);
    var verticalProperty = getOffsetDirection("top", option);
    var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
    var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
    if (horizontalProperty !== "left") {
      presetH = 999;
    }
    if (verticalProperty !== "top") {
      presetV = 999;
    }
    var originalTransition = "";
    var originalOffset = getOffset(elem);
    if ("left" in offset3 || "top" in offset3) {
      originalTransition = getTransitionProperty(elem) || "";
      setTransitionProperty(elem, "none");
    }
    if ("left" in offset3) {
      elem.style[oppositeHorizontalProperty] = "";
      elem.style[horizontalProperty] = "".concat(presetH, "px");
    }
    if ("top" in offset3) {
      elem.style[oppositeVerticalProperty] = "";
      elem.style[verticalProperty] = "".concat(presetV, "px");
    }
    forceRelayout(elem);
    var old = getOffset(elem);
    var originalStyle = {};
    for (var key2 in offset3) {
      if (offset3.hasOwnProperty(key2)) {
        var dir = getOffsetDirection(key2, option);
        var preset = key2 === "left" ? presetH : presetV;
        var off = originalOffset[key2] - old[key2];
        if (dir === key2) {
          originalStyle[dir] = preset + off;
        } else {
          originalStyle[dir] = preset - off;
        }
      }
    }
    css(elem, originalStyle);
    forceRelayout(elem);
    if ("left" in offset3 || "top" in offset3) {
      setTransitionProperty(elem, originalTransition);
    }
    var ret = {};
    for (var _key in offset3) {
      if (offset3.hasOwnProperty(_key)) {
        var _dir = getOffsetDirection(_key, option);
        var _off = offset3[_key] - originalOffset[_key];
        if (_key === _dir) {
          ret[_dir] = originalStyle[_dir] + _off;
        } else {
          ret[_dir] = originalStyle[_dir] - _off;
        }
      }
    }
    css(elem, ret);
  }
  function setTransform$1(elem, offset3) {
    var originalOffset = getOffset(elem);
    var originalXY = getTransformXY(elem);
    var resultXY = {
      x: originalXY.x,
      y: originalXY.y
    };
    if ("left" in offset3) {
      resultXY.x = originalXY.x + offset3.left - originalOffset.left;
    }
    if ("top" in offset3) {
      resultXY.y = originalXY.y + offset3.top - originalOffset.top;
    }
    setTransformXY(elem, resultXY);
  }
  function setOffset(elem, offset3, option) {
    if (option.ignoreShake) {
      var oriOffset = getOffset(elem);
      var oLeft = oriOffset.left.toFixed(0);
      var oTop = oriOffset.top.toFixed(0);
      var tLeft = offset3.left.toFixed(0);
      var tTop = offset3.top.toFixed(0);
      if (oLeft === tLeft && oTop === tTop) {
        return;
      }
    }
    if (option.useCssRight || option.useCssBottom) {
      setLeftTop(elem, offset3, option);
    } else if (option.useCssTransform && getTransformName() in document.body.style) {
      setTransform$1(elem, offset3);
    } else {
      setLeftTop(elem, offset3, option);
    }
  }
  function each(arr, fn) {
    for (var i2 = 0; i2 < arr.length; i2++) {
      fn(arr[i2]);
    }
  }
  function isBorderBoxFn(elem) {
    return getComputedStyleX(elem, "boxSizing") === "border-box";
  }
  var BOX_MODELS = ["margin", "border", "padding"];
  var CONTENT_INDEX = -1;
  var PADDING_INDEX = 2;
  var BORDER_INDEX = 1;
  var MARGIN_INDEX = 0;
  function swap(elem, options, callback) {
    var old = {};
    var style = elem.style;
    var name2;
    for (name2 in options) {
      if (options.hasOwnProperty(name2)) {
        old[name2] = style[name2];
        style[name2] = options[name2];
      }
    }
    callback.call(elem);
    for (name2 in options) {
      if (options.hasOwnProperty(name2)) {
        style[name2] = old[name2];
      }
    }
  }
  function getPBMWidth(elem, props, which) {
    var value = 0;
    var prop;
    var j2;
    var i2;
    for (j2 = 0; j2 < props.length; j2++) {
      prop = props[j2];
      if (prop) {
        for (i2 = 0; i2 < which.length; i2++) {
          var cssProp = void 0;
          if (prop === "border") {
            cssProp = "".concat(prop).concat(which[i2], "Width");
          } else {
            cssProp = prop + which[i2];
          }
          value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
        }
      }
    }
    return value;
  }
  var domUtils = {
    getParent: function getParent(element) {
      var parent2 = element;
      do {
        if (parent2.nodeType === 11 && parent2.host) {
          parent2 = parent2.host;
        } else {
          parent2 = parent2.parentNode;
        }
      } while (parent2 && parent2.nodeType !== 1 && parent2.nodeType !== 9);
      return parent2;
    }
  };
  each(["Width", "Height"], function(name2) {
    domUtils["doc".concat(name2)] = function(refWin) {
      var d2 = refWin.document;
      return Math.max(
        // firefox chrome documentElement.scrollHeight< body.scrollHeight
        // ie standard mode : documentElement.scrollHeight> body.scrollHeight
        d2.documentElement["scroll".concat(name2)],
        // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
        d2.body["scroll".concat(name2)],
        domUtils["viewport".concat(name2)](d2)
      );
    };
    domUtils["viewport".concat(name2)] = function(win) {
      var prop = "client".concat(name2);
      var doc2 = win.document;
      var body = doc2.body;
      var documentElement = doc2.documentElement;
      var documentElementProp = documentElement[prop];
      return doc2.compatMode === "CSS1Compat" && documentElementProp || body && body[prop] || documentElementProp;
    };
  });
  function getWH(elem, name2, ex) {
    var extra = ex;
    if (isWindow(elem)) {
      return name2 === "width" ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
    } else if (elem.nodeType === 9) {
      return name2 === "width" ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
    }
    var which = name2 === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
    var borderBoxValue = name2 === "width" ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
    var isBorderBox = isBorderBoxFn(elem);
    var cssBoxValue = 0;
    if (borderBoxValue === null || borderBoxValue === void 0 || borderBoxValue <= 0) {
      borderBoxValue = void 0;
      cssBoxValue = getComputedStyleX(elem, name2);
      if (cssBoxValue === null || cssBoxValue === void 0 || Number(cssBoxValue) < 0) {
        cssBoxValue = elem.style[name2] || 0;
      }
      cssBoxValue = Math.floor(parseFloat(cssBoxValue)) || 0;
    }
    if (extra === void 0) {
      extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
    }
    var borderBoxValueOrIsBorderBox = borderBoxValue !== void 0 || isBorderBox;
    var val = borderBoxValue || cssBoxValue;
    if (extra === CONTENT_INDEX) {
      if (borderBoxValueOrIsBorderBox) {
        return val - getPBMWidth(elem, ["border", "padding"], which);
      }
      return cssBoxValue;
    } else if (borderBoxValueOrIsBorderBox) {
      if (extra === BORDER_INDEX) {
        return val;
      }
      return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ["border"], which) : getPBMWidth(elem, ["margin"], which));
    }
    return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
  }
  var cssShow = {
    position: "absolute",
    visibility: "hidden",
    display: "block"
  };
  function getWHIgnoreDisplay() {
    for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
      args[_key2] = arguments[_key2];
    }
    var val;
    var elem = args[0];
    if (elem.offsetWidth !== 0) {
      val = getWH.apply(void 0, args);
    } else {
      swap(elem, cssShow, function() {
        val = getWH.apply(void 0, args);
      });
    }
    return val;
  }
  each(["width", "height"], function(name2) {
    var first = name2.charAt(0).toUpperCase() + name2.slice(1);
    domUtils["outer".concat(first)] = function(el, includeMargin) {
      return el && getWHIgnoreDisplay(el, name2, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
    };
    var which = name2 === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
    domUtils[name2] = function(elem, v2) {
      var val = v2;
      if (val !== void 0) {
        if (elem) {
          var isBorderBox = isBorderBoxFn(elem);
          if (isBorderBox) {
            val += getPBMWidth(elem, ["padding", "border"], which);
          }
          return css(elem, name2, val);
        }
        return void 0;
      }
      return elem && getWHIgnoreDisplay(elem, name2, CONTENT_INDEX);
    };
  });
  function mix(to, from2) {
    for (var i2 in from2) {
      if (from2.hasOwnProperty(i2)) {
        to[i2] = from2[i2];
      }
    }
    return to;
  }
  var utils = {
    getWindow: function getWindow(node2) {
      if (node2 && node2.document && node2.setTimeout) {
        return node2;
      }
      var doc2 = node2.ownerDocument || node2;
      return doc2.defaultView || doc2.parentWindow;
    },
    getDocument,
    offset: function offset(el, value, option) {
      if (typeof value !== "undefined") {
        setOffset(el, value, option || {});
      } else {
        return getOffset(el);
      }
    },
    isWindow,
    each,
    css,
    clone: function clone(obj) {
      var i2;
      var ret = {};
      for (i2 in obj) {
        if (obj.hasOwnProperty(i2)) {
          ret[i2] = obj[i2];
        }
      }
      var overflow = obj.overflow;
      if (overflow) {
        for (i2 in obj) {
          if (obj.hasOwnProperty(i2)) {
            ret.overflow[i2] = obj.overflow[i2];
          }
        }
      }
      return ret;
    },
    mix,
    getWindowScrollLeft: function getWindowScrollLeft(w2) {
      return getScrollLeft(w2);
    },
    getWindowScrollTop: function getWindowScrollTop(w2) {
      return getScrollTop(w2);
    },
    merge: function merge2() {
      var ret = {};
      for (var i2 = 0; i2 < arguments.length; i2++) {
        utils.mix(ret, i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2]);
      }
      return ret;
    },
    viewportWidth: 0,
    viewportHeight: 0
  };
  mix(utils, domUtils);
  var getParent$1 = utils.getParent;
  function getOffsetParent(element) {
    if (utils.isWindow(element) || element.nodeType === 9) {
      return null;
    }
    var doc2 = utils.getDocument(element);
    var body = doc2.body;
    var parent2;
    var positionStyle = utils.css(element, "position");
    var skipStatic = positionStyle === "fixed" || positionStyle === "absolute";
    if (!skipStatic) {
      return element.nodeName.toLowerCase() === "html" ? null : getParent$1(element);
    }
    for (parent2 = getParent$1(element); parent2 && parent2 !== body && parent2.nodeType !== 9; parent2 = getParent$1(parent2)) {
      positionStyle = utils.css(parent2, "position");
      if (positionStyle !== "static") {
        return parent2;
      }
    }
    return null;
  }
  var getParent$1$1 = utils.getParent;
  function isAncestorFixed(element) {
    if (utils.isWindow(element) || element.nodeType === 9) {
      return false;
    }
    var doc2 = utils.getDocument(element);
    var body = doc2.body;
    var parent2 = null;
    for (
      parent2 = getParent$1$1(element);
      // 修复元素位于 document.documentElement 下导致崩溃问题
      parent2 && parent2 !== body && parent2 !== doc2;
      parent2 = getParent$1$1(parent2)
    ) {
      var positionStyle = utils.css(parent2, "position");
      if (positionStyle === "fixed") {
        return true;
      }
    }
    return false;
  }
  function getVisibleRectForElement(element, alwaysByViewport) {
    var visibleRect = {
      left: 0,
      right: Infinity,
      top: 0,
      bottom: Infinity
    };
    var el = getOffsetParent(element);
    var doc2 = utils.getDocument(element);
    var win = doc2.defaultView || doc2.parentWindow;
    var body = doc2.body;
    var documentElement = doc2.documentElement;
    while (el) {
      if ((navigator.userAgent.indexOf("MSIE") === -1 || el.clientWidth !== 0) && // body may have overflow set on it, yet we still get the entire
      // viewport. In some browsers, el.offsetParent may be
      // document.documentElement, so check for that too.
      el !== body && el !== documentElement && utils.css(el, "overflow") !== "visible") {
        var pos = utils.offset(el);
        pos.left += el.clientLeft;
        pos.top += el.clientTop;
        visibleRect.top = Math.max(visibleRect.top, pos.top);
        visibleRect.right = Math.min(
          visibleRect.right,
          // consider area without scrollBar
          pos.left + el.clientWidth
        );
        visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
        visibleRect.left = Math.max(visibleRect.left, pos.left);
      } else if (el === body || el === documentElement) {
        break;
      }
      el = getOffsetParent(el);
    }
    var originalPosition = null;
    if (!utils.isWindow(element) && element.nodeType !== 9) {
      originalPosition = element.style.position;
      var position2 = utils.css(element, "position");
      if (position2 === "absolute") {
        element.style.position = "fixed";
      }
    }
    var scrollX = utils.getWindowScrollLeft(win);
    var scrollY = utils.getWindowScrollTop(win);
    var viewportWidth = utils.viewportWidth(win);
    var viewportHeight = utils.viewportHeight(win);
    var documentWidth = documentElement.scrollWidth;
    var documentHeight = documentElement.scrollHeight;
    var bodyStyle = window.getComputedStyle(body);
    if (bodyStyle.overflowX === "hidden") {
      documentWidth = win.innerWidth;
    }
    if (bodyStyle.overflowY === "hidden") {
      documentHeight = win.innerHeight;
    }
    if (element.style) {
      element.style.position = originalPosition;
    }
    if (alwaysByViewport || isAncestorFixed(element)) {
      visibleRect.left = Math.max(visibleRect.left, scrollX);
      visibleRect.top = Math.max(visibleRect.top, scrollY);
      visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
    } else {
      var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
      visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
      var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
      visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
    }
    return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
  }
  function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
    var pos = utils.clone(elFuturePos);
    var size2 = {
      width: elRegion.width,
      height: elRegion.height
    };
    if (overflow.adjustX && pos.left < visibleRect.left) {
      pos.left = visibleRect.left;
    }
    if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size2.width > visibleRect.right) {
      size2.width -= pos.left + size2.width - visibleRect.right;
    }
    if (overflow.adjustX && pos.left + size2.width > visibleRect.right) {
      pos.left = Math.max(visibleRect.right - size2.width, visibleRect.left);
    }
    if (overflow.adjustY && pos.top < visibleRect.top) {
      pos.top = visibleRect.top;
    }
    if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size2.height > visibleRect.bottom) {
      size2.height -= pos.top + size2.height - visibleRect.bottom;
    }
    if (overflow.adjustY && pos.top + size2.height > visibleRect.bottom) {
      pos.top = Math.max(visibleRect.bottom - size2.height, visibleRect.top);
    }
    return utils.mix(pos, size2);
  }
  function getRegion(node2) {
    var offset3;
    var w2;
    var h2;
    if (!utils.isWindow(node2) && node2.nodeType !== 9) {
      offset3 = utils.offset(node2);
      w2 = utils.outerWidth(node2);
      h2 = utils.outerHeight(node2);
    } else {
      var win = utils.getWindow(node2);
      offset3 = {
        left: utils.getWindowScrollLeft(win),
        top: utils.getWindowScrollTop(win)
      };
      w2 = utils.viewportWidth(win);
      h2 = utils.viewportHeight(win);
    }
    offset3.width = w2;
    offset3.height = h2;
    return offset3;
  }
  function getAlignOffset(region, align) {
    var V2 = align.charAt(0);
    var H = align.charAt(1);
    var w2 = region.width;
    var h2 = region.height;
    var x2 = region.left;
    var y2 = region.top;
    if (V2 === "c") {
      y2 += h2 / 2;
    } else if (V2 === "b") {
      y2 += h2;
    }
    if (H === "c") {
      x2 += w2 / 2;
    } else if (H === "r") {
      x2 += w2;
    }
    return {
      left: x2,
      top: y2
    };
  }
  function getElFuturePos(elRegion, refNodeRegion, points, offset3, targetOffset2) {
    var p1 = getAlignOffset(refNodeRegion, points[1]);
    var p2 = getAlignOffset(elRegion, points[0]);
    var diff = [p2.left - p1.left, p2.top - p1.top];
    return {
      left: Math.round(elRegion.left - diff[0] + offset3[0] - targetOffset2[0]),
      top: Math.round(elRegion.top - diff[1] + offset3[1] - targetOffset2[1])
    };
  }
  function isFailX(elFuturePos, elRegion, visibleRect) {
    return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
  }
  function isFailY(elFuturePos, elRegion, visibleRect) {
    return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
  }
  function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
    return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
  }
  function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
    return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
  }
  function flip(points, reg, map2) {
    var ret = [];
    utils.each(points, function(p) {
      ret.push(p.replace(reg, function(m2) {
        return map2[m2];
      }));
    });
    return ret;
  }
  function flipOffset(offset3, index2) {
    offset3[index2] = -offset3[index2];
    return offset3;
  }
  function convertOffset(str, offsetLen) {
    var n2;
    if (/%$/.test(str)) {
      n2 = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
    } else {
      n2 = parseInt(str, 10);
    }
    return n2 || 0;
  }
  function normalizeOffset(offset3, el) {
    offset3[0] = convertOffset(offset3[0], el.width);
    offset3[1] = convertOffset(offset3[1], el.height);
  }
  function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
    var points = align.points;
    var offset3 = align.offset || [0, 0];
    var targetOffset2 = align.targetOffset || [0, 0];
    var overflow = align.overflow;
    var source = align.source || el;
    offset3 = [].concat(offset3);
    targetOffset2 = [].concat(targetOffset2);
    overflow = overflow || {};
    var newOverflowCfg = {};
    var fail = 0;
    var alwaysByViewport = !!(overflow && overflow.alwaysByViewport);
    var visibleRect = getVisibleRectForElement(source, alwaysByViewport);
    var elRegion = getRegion(source);
    normalizeOffset(offset3, elRegion);
    normalizeOffset(targetOffset2, tgtRegion);
    var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset3, targetOffset2);
    var newElRegion = utils.merge(elRegion, elFuturePos);
    if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
      if (overflow.adjustX) {
        if (isFailX(elFuturePos, elRegion, visibleRect)) {
          var newPoints = flip(points, /[lr]/gi, {
            l: "r",
            r: "l"
          });
          var newOffset = flipOffset(offset3, 0);
          var newTargetOffset = flipOffset(targetOffset2, 0);
          var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);
          if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
            fail = 1;
            points = newPoints;
            offset3 = newOffset;
            targetOffset2 = newTargetOffset;
          }
        }
      }
      if (overflow.adjustY) {
        if (isFailY(elFuturePos, elRegion, visibleRect)) {
          var _newPoints = flip(points, /[tb]/gi, {
            t: "b",
            b: "t"
          });
          var _newOffset = flipOffset(offset3, 1);
          var _newTargetOffset = flipOffset(targetOffset2, 1);
          var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);
          if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
            fail = 1;
            points = _newPoints;
            offset3 = _newOffset;
            targetOffset2 = _newTargetOffset;
          }
        }
      }
      if (fail) {
        elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset3, targetOffset2);
        utils.mix(newElRegion, elFuturePos);
      }
      var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
      var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);
      if (isStillFailX || isStillFailY) {
        var _newPoints2 = points;
        if (isStillFailX) {
          _newPoints2 = flip(points, /[lr]/gi, {
            l: "r",
            r: "l"
          });
        }
        if (isStillFailY) {
          _newPoints2 = flip(points, /[tb]/gi, {
            t: "b",
            b: "t"
          });
        }
        points = _newPoints2;
        offset3 = align.offset || [0, 0];
        targetOffset2 = align.targetOffset || [0, 0];
      }
      newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
      newOverflowCfg.adjustY = overflow.adjustY && isStillFailY;
      if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
        newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
      }
    }
    if (newElRegion.width !== elRegion.width) {
      utils.css(source, "width", utils.width(source) + newElRegion.width - elRegion.width);
    }
    if (newElRegion.height !== elRegion.height) {
      utils.css(source, "height", utils.height(source) + newElRegion.height - elRegion.height);
    }
    utils.offset(source, {
      left: newElRegion.left,
      top: newElRegion.top
    }, {
      useCssRight: align.useCssRight,
      useCssBottom: align.useCssBottom,
      useCssTransform: align.useCssTransform,
      ignoreShake: align.ignoreShake
    });
    return {
      points,
      offset: offset3,
      targetOffset: targetOffset2,
      overflow: newOverflowCfg
    };
  }
  function isOutOfVisibleRect(target, alwaysByViewport) {
    var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
    var targetRegion = getRegion(target);
    return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
  }
  function alignElement(el, refNode, align) {
    var target = align.target || refNode;
    var refNodeRegion = getRegion(target);
    var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);
    return doAlign(el, refNodeRegion, align, isTargetNotOutOfVisible);
  }
  alignElement.__getOffsetParent = getOffsetParent;
  alignElement.__getVisibleRectForElement = getVisibleRectForElement;
  function alignPoint(el, tgtPoint, align) {
    var pageX;
    var pageY;
    var doc2 = utils.getDocument(el);
    var win = doc2.defaultView || doc2.parentWindow;
    var scrollX = utils.getWindowScrollLeft(win);
    var scrollY = utils.getWindowScrollTop(win);
    var viewportWidth = utils.viewportWidth(win);
    var viewportHeight = utils.viewportHeight(win);
    if ("pageX" in tgtPoint) {
      pageX = tgtPoint.pageX;
    } else {
      pageX = scrollX + tgtPoint.clientX;
    }
    if ("pageY" in tgtPoint) {
      pageY = tgtPoint.pageY;
    } else {
      pageY = scrollY + tgtPoint.clientY;
    }
    var tgtRegion = {
      left: pageX,
      top: pageY,
      width: 0,
      height: 0
    };
    var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight;
    var points = [align.points[0], "cc"];
    return doAlign(el, tgtRegion, _objectSpread2(_objectSpread2({}, align), {}, {
      points
    }), pointInView);
  }
  function cloneElement(vnode) {
    let nodeProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let override = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    let mergeRef = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    let ele = vnode;
    if (Array.isArray(vnode)) {
      ele = filterEmpty(vnode)[0];
    }
    if (!ele) {
      return null;
    }
    const node2 = cloneVNode(ele, nodeProps, mergeRef);
    node2.props = override ? _extends$1(_extends$1({}, node2.props), nodeProps) : node2.props;
    warning$3(typeof node2.props.class !== "object", "class must be string");
    return node2;
  }
  function cloneVNodes(vnodes) {
    let nodeProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let override = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    return vnodes.map((vnode) => cloneElement(vnode, nodeProps, override));
  }
  function triggerVNodeUpdate(vm, attrs, dom) {
    render(cloneVNode(vm, _extends$1({}, attrs)), dom);
  }
  const isVisible = (element) => {
    if (!element) {
      return false;
    }
    if (element.offsetParent) {
      return true;
    }
    if (element.getBBox) {
      const box2 = element.getBBox();
      if (box2.width || box2.height) {
        return true;
      }
    }
    if (element.getBoundingClientRect) {
      const box2 = element.getBoundingClientRect();
      if (box2.width || box2.height) {
        return true;
      }
    }
    return false;
  };
  function isSamePoint(prev2, next2) {
    if (prev2 === next2)
      return true;
    if (!prev2 || !next2)
      return false;
    if ("pageX" in next2 && "pageY" in next2) {
      return prev2.pageX === next2.pageX && prev2.pageY === next2.pageY;
    }
    if ("clientX" in next2 && "clientY" in next2) {
      return prev2.clientX === next2.clientX && prev2.clientY === next2.clientY;
    }
    return false;
  }
  function restoreFocus(activeElement, container) {
    if (activeElement !== document.activeElement && contains$1(container, activeElement) && typeof activeElement.focus === "function") {
      activeElement.focus();
    }
  }
  function monitorResize(element, callback) {
    let prevWidth = null;
    let prevHeight = null;
    function onResize(_ref) {
      let [{
        target
      }] = _ref;
      if (!document.documentElement.contains(target))
        return;
      const {
        width,
        height
      } = target.getBoundingClientRect();
      const fixedWidth = Math.floor(width);
      const fixedHeight = Math.floor(height);
      if (prevWidth !== fixedWidth || prevHeight !== fixedHeight) {
        Promise.resolve().then(() => {
          callback({
            width: fixedWidth,
            height: fixedHeight
          });
        });
      }
      prevWidth = fixedWidth;
      prevHeight = fixedHeight;
    }
    const resizeObserver = new index(onResize);
    if (element) {
      resizeObserver.observe(element);
    }
    return () => {
      resizeObserver.disconnect();
    };
  }
  const useBuffer = (callback, buffer2) => {
    let called = false;
    let timeout = null;
    function cancelTrigger() {
      clearTimeout(timeout);
    }
    function trigger2(force) {
      if (!called || force === true) {
        if (callback() === false) {
          return;
        }
        called = true;
        cancelTrigger();
        timeout = setTimeout(() => {
          called = false;
        }, buffer2.value);
      } else {
        cancelTrigger();
        timeout = setTimeout(() => {
          called = false;
          trigger2();
        }, buffer2.value);
      }
    }
    return [trigger2, () => {
      called = false;
      cancelTrigger();
    }];
  };
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function assocIndexOf(array4, key2) {
    var length2 = array4.length;
    while (length2--) {
      if (eq(array4[length2][0], key2)) {
        return length2;
      }
    }
    return -1;
  }
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key2) {
    var data = this.__data__, index2 = assocIndexOf(data, key2);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key2) {
    var data = this.__data__, index2 = assocIndexOf(data, key2);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas(key2) {
    return assocIndexOf(this.__data__, key2) > -1;
  }
  function listCacheSet(key2, value) {
    var data = this.__data__, index2 = assocIndexOf(data, key2);
    if (index2 < 0) {
      ++this.size;
      data.push([key2, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  function ListCache(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key2) {
    var data = this.__data__, result = data["delete"](key2);
    this.size = data.size;
    return result;
  }
  function stackGet(key2) {
    return this.__data__.get(key2);
  }
  function stackHas(key2) {
    return this.__data__.has(key2);
  }
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var Symbol$1 = root.Symbol;
  var objectProto$g = Object.prototype;
  var hasOwnProperty$d = objectProto$g.hasOwnProperty;
  var nativeObjectToString$1 = objectProto$g.toString;
  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty$d.call(value, symToStringTag$1), tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = void 0;
      var unmasked = true;
    } catch (e2) {
    }
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }
  var objectProto$f = Object.prototype;
  var nativeObjectToString = objectProto$f.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function isObject$1(value) {
    var type4 = typeof value;
    return value != null && (type4 == "object" || type4 == "function");
  }
  var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject$1(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
  }
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid2 ? "Symbol(src)_1." + uid2 : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var funcProto$2 = Function.prototype;
  var funcToString$2 = funcProto$2.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$2.call(func);
      } catch (e2) {
      }
      try {
        return func + "";
      } catch (e2) {
      }
    }
    return "";
  }
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto$1 = Function.prototype, objectProto$e = Object.prototype;
  var funcToString$1 = funcProto$1.toString;
  var hasOwnProperty$c = objectProto$e.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString$1.call(hasOwnProperty$c).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject$1(value) || isMasked(value)) {
      return false;
    }
    var pattern4 = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern4.test(toSource(value));
  }
  function getValue$2(object4, key2) {
    return object4 == null ? void 0 : object4[key2];
  }
  function getNative(object4, key2) {
    var value = getValue$2(object4, key2);
    return baseIsNative(value) ? value : void 0;
  }
  var Map$1 = getNative(root, "Map");
  var nativeCreate = getNative(Object, "create");
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key2) {
    var result = this.has(key2) && delete this.__data__[key2];
    this.size -= result ? 1 : 0;
    return result;
  }
  var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
  var objectProto$d = Object.prototype;
  var hasOwnProperty$b = objectProto$d.hasOwnProperty;
  function hashGet(key2) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key2];
      return result === HASH_UNDEFINED$2 ? void 0 : result;
    }
    return hasOwnProperty$b.call(data, key2) ? data[key2] : void 0;
  }
  var objectProto$c = Object.prototype;
  var hasOwnProperty$a = objectProto$c.hasOwnProperty;
  function hashHas(key2) {
    var data = this.__data__;
    return nativeCreate ? data[key2] !== void 0 : hasOwnProperty$a.call(data, key2);
  }
  var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
  function hashSet(key2, value) {
    var data = this.__data__;
    this.size += this.has(key2) ? 0 : 1;
    data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
    return this;
  }
  function Hash(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map$1 || ListCache)(),
      "string": new Hash()
    };
  }
  function isKeyable(value) {
    var type4 = typeof value;
    return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
  }
  function getMapData(map2, key2) {
    var data = map2.__data__;
    return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
  }
  function mapCacheDelete(key2) {
    var result = getMapData(this, key2)["delete"](key2);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key2) {
    return getMapData(this, key2).get(key2);
  }
  function mapCacheHas(key2) {
    return getMapData(this, key2).has(key2);
  }
  function mapCacheSet(key2, value) {
    var data = getMapData(this, key2), size2 = data.size;
    data.set(key2, value);
    this.size += data.size == size2 ? 0 : 1;
    return this;
  }
  function MapCache(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key2, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key2, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key2, value);
    this.size = data.size;
    return this;
  }
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  function SetCache(values) {
    var index2 = -1, length2 = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index2 < length2) {
      this.add(values[index2]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function arraySome(array4, predicate) {
    var index2 = -1, length2 = array4 == null ? 0 : array4.length;
    while (++index2 < length2) {
      if (predicate(array4[index2], index2, array4)) {
        return true;
      }
    }
    return false;
  }
  function cacheHas(cache, key2) {
    return cache.has(key2);
  }
  var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
  function equalArrays(array4, other, bitmask, customizer, equalFunc, stack2) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array4.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack2.get(array4);
    var othStacked = stack2.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array4;
    }
    var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
    stack2.set(array4, other);
    stack2.set(other, array4);
    while (++index2 < arrLength) {
      var arrValue = array4[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array4, stack2) : customizer(arrValue, othValue, index2, array4, other, stack2);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
        result = false;
        break;
      }
    }
    stack2["delete"](array4);
    stack2["delete"](other);
    return result;
  }
  var Uint8Array$1 = root.Uint8Array;
  function mapToArray(map2) {
    var index2 = -1, result = Array(map2.size);
    map2.forEach(function(value, key2) {
      result[++index2] = [key2, value];
    });
    return result;
  }
  function setToArray(set2) {
    var index2 = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
  var boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", mapTag$6 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$3 = "[object RegExp]", setTag$6 = "[object Set]", stringTag$3 = "[object String]", symbolTag$3 = "[object Symbol]";
  var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]";
  var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
  function equalByTag(object4, other, tag, bitmask, customizer, equalFunc, stack2) {
    switch (tag) {
      case dataViewTag$4:
        if (object4.byteLength != other.byteLength || object4.byteOffset != other.byteOffset) {
          return false;
        }
        object4 = object4.buffer;
        other = other.buffer;
      case arrayBufferTag$3:
        if (object4.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object4), new Uint8Array$1(other))) {
          return false;
        }
        return true;
      case boolTag$3:
      case dateTag$3:
      case numberTag$3:
        return eq(+object4, +other);
      case errorTag$2:
        return object4.name == other.name && object4.message == other.message;
      case regexpTag$3:
      case stringTag$3:
        return object4 == other + "";
      case mapTag$6:
        var convert = mapToArray;
      case setTag$6:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
        convert || (convert = setToArray);
        if (object4.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack2.get(object4);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG$2;
        stack2.set(object4, other);
        var result = equalArrays(convert(object4), convert(other), bitmask, customizer, equalFunc, stack2);
        stack2["delete"](object4);
        return result;
      case symbolTag$3:
        if (symbolValueOf$1) {
          return symbolValueOf$1.call(object4) == symbolValueOf$1.call(other);
        }
    }
    return false;
  }
  function arrayPush(array4, values) {
    var index2 = -1, length2 = values.length, offset3 = array4.length;
    while (++index2 < length2) {
      array4[offset3 + index2] = values[index2];
    }
    return array4;
  }
  var isArray = Array.isArray;
  function baseGetAllKeys(object4, keysFunc, symbolsFunc) {
    var result = keysFunc(object4);
    return isArray(object4) ? result : arrayPush(result, symbolsFunc(object4));
  }
  function arrayFilter(array4, predicate) {
    var index2 = -1, length2 = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
    while (++index2 < length2) {
      var value = array4[index2];
      if (predicate(value, index2, array4)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function stubArray() {
    return [];
  }
  var objectProto$b = Object.prototype;
  var propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable;
  var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object4) {
    if (object4 == null) {
      return [];
    }
    object4 = Object(object4);
    return arrayFilter(nativeGetSymbols$1(object4), function(symbol) {
      return propertyIsEnumerable$1.call(object4, symbol);
    });
  };
  function baseTimes(n2, iteratee) {
    var index2 = -1, result = Array(n2);
    while (++index2 < n2) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  var argsTag$3 = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$3;
  }
  var objectProto$a = Object.prototype;
  var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
  var propertyIsEnumerable = objectProto$a.propertyIsEnumerable;
  var isArguments = baseIsArguments(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty$9.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  const isArguments$1 = isArguments;
  function stubFalse() {
    return false;
  }
  var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
  var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
  var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
  var isBuffer = nativeIsBuffer || stubFalse;
  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length2) {
    var type4 = typeof value;
    length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
    return !!length2 && (type4 == "number" || type4 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$2 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
  var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
  typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
  var freeProcess = moduleExports$1 && freeGlobal.process;
  var nodeUtil = function() {
    try {
      var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  const isTypedArray$1 = isTypedArray;
  var objectProto$9 = Object.prototype;
  var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
    for (var key2 in value) {
      if ((inherited || hasOwnProperty$8.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
      isIndex(key2, length2)))) {
        result.push(key2);
      }
    }
    return result;
  }
  var objectProto$8 = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$8;
    return value === proto;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var nativeKeys = overArg(Object.keys, Object);
  var objectProto$7 = Object.prototype;
  var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
  function baseKeys(object4) {
    if (!isPrototype(object4)) {
      return nativeKeys(object4);
    }
    var result = [];
    for (var key2 in Object(object4)) {
      if (hasOwnProperty$7.call(object4, key2) && key2 != "constructor") {
        result.push(key2);
      }
    }
    return result;
  }
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function keys(object4) {
    return isArrayLike(object4) ? arrayLikeKeys(object4) : baseKeys(object4);
  }
  function getAllKeys(object4) {
    return baseGetAllKeys(object4, keys, getSymbols);
  }
  var COMPARE_PARTIAL_FLAG$3 = 1;
  var objectProto$6 = Object.prototype;
  var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
  function equalObjects(object4, other, bitmask, customizer, equalFunc, stack2) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object4), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key2 = objProps[index2];
      if (!(isPartial ? key2 in other : hasOwnProperty$6.call(other, key2))) {
        return false;
      }
    }
    var objStacked = stack2.get(object4);
    var othStacked = stack2.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object4;
    }
    var result = true;
    stack2.set(object4, other);
    stack2.set(other, object4);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key2 = objProps[index2];
      var objValue = object4[key2], othValue = other[key2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key2, other, object4, stack2) : customizer(objValue, othValue, key2, object4, other, stack2);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key2 == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object4.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object4 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack2["delete"](object4);
    stack2["delete"](other);
    return result;
  }
  var DataView = getNative(root, "DataView");
  var Promise$1 = getNative(root, "Promise");
  var Set$1 = getNative(root, "Set");
  var WeakMap$1 = getNative(root, "WeakMap");
  var mapTag$4 = "[object Map]", objectTag$3 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
  var dataViewTag$2 = "[object DataView]";
  var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
  var getTag = baseGetTag;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag$3 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$2;
          case mapCtorString:
            return mapTag$4;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag$4;
          case weakMapCtorString:
            return weakMapTag$1;
        }
      }
      return result;
    };
  }
  const getTag$1 = getTag;
  var COMPARE_PARTIAL_FLAG$2 = 1;
  var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", objectTag$2 = "[object Object]";
  var objectProto$5 = Object.prototype;
  var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
  function baseIsEqualDeep(object4, other, bitmask, customizer, equalFunc, stack2) {
    var objIsArr = isArray(object4), othIsArr = isArray(other), objTag = objIsArr ? arrayTag$1 : getTag$1(object4), othTag = othIsArr ? arrayTag$1 : getTag$1(other);
    objTag = objTag == argsTag$1 ? objectTag$2 : objTag;
    othTag = othTag == argsTag$1 ? objectTag$2 : othTag;
    var objIsObj = objTag == objectTag$2, othIsObj = othTag == objectTag$2, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object4)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack2 || (stack2 = new Stack());
      return objIsArr || isTypedArray$1(object4) ? equalArrays(object4, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object4, other, objTag, bitmask, customizer, equalFunc, stack2);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
      var objIsWrapped = objIsObj && hasOwnProperty$5.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$5.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other.value() : other;
        stack2 || (stack2 = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack2 || (stack2 = new Stack());
    return equalObjects(object4, other, bitmask, customizer, equalFunc, stack2);
  }
  function baseIsEqual(value, other, bitmask, customizer, stack2) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
  }
  function isEqual(value, other) {
    return baseIsEqual(value, other);
  }
  const alignProps = {
    align: Object,
    target: [Object, Function],
    onAlign: Function,
    monitorBufferTime: Number,
    monitorWindowResize: Boolean,
    disabled: Boolean
  };
  function getElement(func) {
    if (typeof func !== "function")
      return null;
    return func();
  }
  function getPoint(point) {
    if (typeof point !== "object" || !point)
      return null;
    return point;
  }
  const Align = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Align",
    props: alignProps,
    emits: ["align"],
    setup(props, _ref) {
      let {
        expose,
        slots
      } = _ref;
      const cacheRef = ref({});
      const nodeRef = ref();
      const [forceAlign, cancelForceAlign] = useBuffer(() => {
        const {
          disabled: latestDisabled,
          target: latestTarget,
          align: latestAlign,
          onAlign: latestOnAlign
        } = props;
        if (!latestDisabled && latestTarget && nodeRef.value) {
          const source = nodeRef.value;
          let result;
          const element = getElement(latestTarget);
          const point = getPoint(latestTarget);
          cacheRef.value.element = element;
          cacheRef.value.point = point;
          cacheRef.value.align = latestAlign;
          const {
            activeElement
          } = document;
          if (element && isVisible(element)) {
            result = alignElement(source, element, latestAlign);
          } else if (point) {
            result = alignPoint(source, point, latestAlign);
          }
          restoreFocus(activeElement, source);
          if (latestOnAlign && result) {
            latestOnAlign(source, result);
          }
          return true;
        }
        return false;
      }, computed(() => props.monitorBufferTime));
      const resizeMonitor = ref({
        cancel: () => {
        }
      });
      const sourceResizeMonitor = ref({
        cancel: () => {
        }
      });
      const goAlign = () => {
        const target = props.target;
        const element = getElement(target);
        const point = getPoint(target);
        if (nodeRef.value !== sourceResizeMonitor.value.element) {
          sourceResizeMonitor.value.cancel();
          sourceResizeMonitor.value.element = nodeRef.value;
          sourceResizeMonitor.value.cancel = monitorResize(nodeRef.value, forceAlign);
        }
        if (cacheRef.value.element !== element || !isSamePoint(cacheRef.value.point, point) || !isEqual(cacheRef.value.align, props.align)) {
          forceAlign();
          if (resizeMonitor.value.element !== element) {
            resizeMonitor.value.cancel();
            resizeMonitor.value.element = element;
            resizeMonitor.value.cancel = monitorResize(element, forceAlign);
          }
        }
      };
      onMounted(() => {
        nextTick(() => {
          goAlign();
        });
      });
      onUpdated(() => {
        nextTick(() => {
          goAlign();
        });
      });
      watch(() => props.disabled, (disabled) => {
        if (!disabled) {
          forceAlign();
        } else {
          cancelForceAlign();
        }
      }, {
        immediate: true,
        flush: "post"
      });
      const winResizeRef = ref(null);
      watch(() => props.monitorWindowResize, (monitorWindowResize) => {
        if (monitorWindowResize) {
          if (!winResizeRef.value) {
            winResizeRef.value = addEventListenerWrap(window, "resize", forceAlign);
          }
        } else if (winResizeRef.value) {
          winResizeRef.value.remove();
          winResizeRef.value = null;
        }
      }, {
        flush: "post"
      });
      onUnmounted(() => {
        resizeMonitor.value.cancel();
        sourceResizeMonitor.value.cancel();
        if (winResizeRef.value)
          winResizeRef.value.remove();
        cancelForceAlign();
      });
      expose({
        forceAlign: () => forceAlign(true)
      });
      return () => {
        const child = slots === null || slots === void 0 ? void 0 : slots.default();
        if (child) {
          return cloneElement(child[0], {
            ref: nodeRef
          }, true, true);
        }
        return null;
      };
    }
  });
  tuple("bottomLeft", "bottomRight", "topLeft", "topRight");
  const getTransitionProps = function(transitionName2) {
    let opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const transitionProps = transitionName2 ? _extends$1({
      name: transitionName2,
      appear: true,
      // type: 'animation',
      // appearFromClass: `${transitionName}-appear ${transitionName}-appear-prepare`,
      // appearActiveClass: `antdv-base-transtion`,
      // appearToClass: `${transitionName}-appear ${transitionName}-appear-active`,
      enterFromClass: `${transitionName2}-enter ${transitionName2}-enter-prepare ${transitionName2}-enter-start`,
      enterActiveClass: `${transitionName2}-enter ${transitionName2}-enter-prepare`,
      enterToClass: `${transitionName2}-enter ${transitionName2}-enter-active`,
      leaveFromClass: ` ${transitionName2}-leave`,
      leaveActiveClass: `${transitionName2}-leave ${transitionName2}-leave-active`,
      leaveToClass: `${transitionName2}-leave ${transitionName2}-leave-active`
    }, opt) : _extends$1({
      css: false
    }, opt);
    return transitionProps;
  };
  const getTransitionGroupProps = function(transitionName2) {
    let opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const transitionProps = transitionName2 ? _extends$1({
      name: transitionName2,
      appear: true,
      // appearFromClass: `${transitionName}-appear ${transitionName}-appear-prepare`,
      appearActiveClass: `${transitionName2}`,
      appearToClass: `${transitionName2}-appear ${transitionName2}-appear-active`,
      enterFromClass: `${transitionName2}-appear ${transitionName2}-enter ${transitionName2}-appear-prepare ${transitionName2}-enter-prepare`,
      enterActiveClass: `${transitionName2}`,
      enterToClass: `${transitionName2}-enter ${transitionName2}-appear ${transitionName2}-appear-active ${transitionName2}-enter-active`,
      leaveActiveClass: `${transitionName2} ${transitionName2}-leave`,
      leaveToClass: `${transitionName2}-leave-active`
    }, opt) : _extends$1({
      css: false
    }, opt);
    return transitionProps;
  };
  const getTransitionName = (rootPrefixCls, motion, transitionName2) => {
    if (transitionName2 !== void 0) {
      return transitionName2;
    }
    return `${rootPrefixCls}-${motion}`;
  };
  const PopupInner = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "PopupInner",
    inheritAttrs: false,
    props: innerProps,
    emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
    setup(props, _ref) {
      let {
        expose,
        attrs,
        slots
      } = _ref;
      const alignRef = shallowRef();
      const elementRef = shallowRef();
      const alignedClassName = shallowRef();
      const [stretchStyle, measureStretchStyle] = useStretchStyle(toRef(props, "stretch"));
      const doMeasure = () => {
        if (props.stretch) {
          measureStretchStyle(props.getRootDomNode());
        }
      };
      const visible = shallowRef(false);
      let timeoutId;
      watch(() => props.visible, (val) => {
        clearTimeout(timeoutId);
        if (val) {
          timeoutId = setTimeout(() => {
            visible.value = props.visible;
          });
        } else {
          visible.value = false;
        }
      }, {
        immediate: true
      });
      const [status, goNextStatus] = useVisibleStatus(visible, doMeasure);
      const prepareResolveRef = shallowRef();
      const getAlignTarget = () => {
        if (props.point) {
          return props.point;
        }
        return props.getRootDomNode;
      };
      const forceAlign = () => {
        var _a2;
        (_a2 = alignRef.value) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
      };
      const onInternalAlign = (popupDomNode, matchAlign) => {
        var _a2;
        const nextAlignedClassName = props.getClassNameFromAlign(matchAlign);
        const preAlignedClassName = alignedClassName.value;
        if (alignedClassName.value !== nextAlignedClassName) {
          alignedClassName.value = nextAlignedClassName;
        }
        if (status.value === "align") {
          if (preAlignedClassName !== nextAlignedClassName) {
            Promise.resolve().then(() => {
              forceAlign();
            });
          } else {
            goNextStatus(() => {
              var _a3;
              (_a3 = prepareResolveRef.value) === null || _a3 === void 0 ? void 0 : _a3.call(prepareResolveRef);
            });
          }
          (_a2 = props.onAlign) === null || _a2 === void 0 ? void 0 : _a2.call(props, popupDomNode, matchAlign);
        }
      };
      const motion = computed(() => {
        const m2 = typeof props.animation === "object" ? props.animation : getMotion$1(props);
        ["onAfterEnter", "onAfterLeave"].forEach((eventName) => {
          const originFn = m2[eventName];
          m2[eventName] = (node2) => {
            goNextStatus();
            status.value = "stable";
            originFn === null || originFn === void 0 ? void 0 : originFn(node2);
          };
        });
        return m2;
      });
      const onShowPrepare = () => {
        return new Promise((resolve2) => {
          prepareResolveRef.value = resolve2;
        });
      };
      watch([motion, status], () => {
        if (!motion.value && status.value === "motion") {
          goNextStatus();
        }
      }, {
        immediate: true
      });
      expose({
        forceAlign,
        getElement: () => {
          return elementRef.value.$el || elementRef.value;
        }
      });
      const alignDisabled = computed(() => {
        var _a2;
        if (((_a2 = props.align) === null || _a2 === void 0 ? void 0 : _a2.points) && (status.value === "align" || status.value === "stable")) {
          return false;
        }
        return true;
      });
      return () => {
        var _a2;
        const {
          zIndex,
          align,
          prefixCls,
          destroyPopupOnHide,
          onMouseenter,
          onMouseleave,
          onTouchstart = () => {
          },
          onMousedown
        } = props;
        const statusValue = status.value;
        const mergedStyle = [_extends$1(_extends$1({}, stretchStyle.value), {
          zIndex,
          opacity: statusValue === "motion" || statusValue === "stable" || !visible.value ? null : 0,
          // pointerEvents: statusValue === 'stable' ? null : 'none',
          pointerEvents: !visible.value && statusValue !== "stable" ? "none" : null
        }), attrs.style];
        let childNode = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots, {
          visible: props.visible
        }));
        if (childNode.length > 1) {
          childNode = createVNode("div", {
            "class": `${prefixCls}-content`
          }, [childNode]);
        }
        const mergedClassName = classNames(prefixCls, attrs.class, alignedClassName.value);
        const hasAnimate = visible.value || !props.visible;
        const transitionProps = hasAnimate ? getTransitionProps(motion.value.name, motion.value) : {};
        return createVNode(Transition, _objectSpread2$1(_objectSpread2$1({
          "ref": elementRef
        }, transitionProps), {}, {
          "onBeforeEnter": onShowPrepare
        }), {
          default: () => {
            return !destroyPopupOnHide || props.visible ? withDirectives(createVNode(Align, {
              "target": getAlignTarget(),
              "key": "popup",
              "ref": alignRef,
              "monitorWindowResize": true,
              "disabled": alignDisabled.value,
              "align": align,
              "onAlign": onInternalAlign
            }, {
              default: () => createVNode("div", {
                "class": mergedClassName,
                "onMouseenter": onMouseenter,
                "onMouseleave": onMouseleave,
                "onMousedown": withModifiers(onMousedown, ["capture"]),
                [supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"]: withModifiers(onTouchstart, ["capture"]),
                "style": mergedStyle
              }, [childNode])
            }), [[vShow, visible.value]]) : null;
          }
        });
      };
    }
  });
  const Popup = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Popup",
    inheritAttrs: false,
    props: popupProps,
    setup(props, _ref) {
      let {
        attrs,
        slots,
        expose
      } = _ref;
      const innerVisible = shallowRef(false);
      const inMobile = shallowRef(false);
      const popupRef = shallowRef();
      const rootRef = shallowRef();
      watch([() => props.visible, () => props.mobile], () => {
        innerVisible.value = props.visible;
        if (props.visible && props.mobile) {
          inMobile.value = true;
        }
      }, {
        immediate: true,
        flush: "post"
      });
      expose({
        forceAlign: () => {
          var _a2;
          (_a2 = popupRef.value) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
        },
        getElement: () => {
          var _a2;
          return (_a2 = popupRef.value) === null || _a2 === void 0 ? void 0 : _a2.getElement();
        }
      });
      return () => {
        const cloneProps = _extends$1(_extends$1(_extends$1({}, props), attrs), {
          visible: innerVisible.value
        });
        const popupNode = inMobile.value ? createVNode(MobilePopupInner, _objectSpread2$1(_objectSpread2$1({}, cloneProps), {}, {
          "mobile": props.mobile,
          "ref": popupRef
        }), {
          default: slots.default
        }) : createVNode(PopupInner, _objectSpread2$1(_objectSpread2$1({}, cloneProps), {}, {
          "ref": popupRef
        }), {
          default: slots.default
        });
        return createVNode("div", {
          "ref": rootRef
        }, [createVNode(Mask$1, cloneProps, null), popupNode]);
      };
    }
  });
  function isPointsEq(a1, a2, isAlignPoint) {
    if (isAlignPoint) {
      return a1[0] === a2[0];
    }
    return a1[0] === a2[0] && a1[1] === a2[1];
  }
  function getAlignFromPlacement(builtinPlacements, placementStr, align) {
    const baseAlign = builtinPlacements[placementStr] || {};
    return _extends$1(_extends$1({}, baseAlign), align);
  }
  function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
    const {
      points
    } = align;
    const placements2 = Object.keys(builtinPlacements);
    for (let i2 = 0; i2 < placements2.length; i2 += 1) {
      const placement = placements2[i2];
      if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) {
        return `${prefixCls}-placement-${placement}`;
      }
    }
    return "";
  }
  const BaseMixin = {
    methods: {
      setState() {
        let state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let callback = arguments.length > 1 ? arguments[1] : void 0;
        let newState = typeof state === "function" ? state(this.$data, this.$props) : state;
        if (this.getDerivedStateFromProps) {
          const s2 = this.getDerivedStateFromProps(getOptionProps(this), _extends$1(_extends$1({}, this.$data), newState));
          if (s2 === null) {
            return;
          } else {
            newState = _extends$1(_extends$1({}, newState), s2 || {});
          }
        }
        _extends$1(this.$data, newState);
        if (this._.isMounted) {
          this.$forceUpdate();
        }
        nextTick(() => {
          callback && callback();
        });
      },
      __emit() {
        const args = [].slice.call(arguments, 0);
        let eventName = args[0];
        eventName = `on${eventName[0].toUpperCase()}${eventName.substring(1)}`;
        const event = this.$props[eventName] || this.$attrs[eventName];
        if (args.length && event) {
          if (Array.isArray(event)) {
            for (let i2 = 0, l2 = event.length; i2 < l2; i2++) {
              event[i2](...args.slice(1));
            }
          } else {
            event(...args.slice(1));
          }
        }
      }
    }
  };
  const PortalContextKey = Symbol("PortalContextKey");
  const useProvidePortal = function(instance) {
    let config3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      inTriggerContext: true
    };
    provide(PortalContextKey, {
      inTriggerContext: config3.inTriggerContext,
      shouldRender: computed(() => {
        const {
          sPopupVisible,
          popupRef,
          forceRender,
          autoDestroy
        } = instance || {};
        let shouldRender = false;
        if (sPopupVisible || popupRef || forceRender) {
          shouldRender = true;
        }
        if (!sPopupVisible && autoDestroy) {
          shouldRender = false;
        }
        return shouldRender;
      })
    });
  };
  const useInjectPortal = () => {
    useProvidePortal({}, {
      inTriggerContext: false
    });
    const portalContext = inject(PortalContextKey, {
      shouldRender: computed(() => false),
      inTriggerContext: false
    });
    return {
      shouldRender: computed(() => portalContext.shouldRender.value || portalContext.inTriggerContext === false)
    };
  };
  const Portal$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Portal",
    inheritAttrs: false,
    props: {
      getContainer: PropTypes.func.isRequired,
      didUpdate: Function
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      let isSSR = true;
      let container;
      const {
        shouldRender
      } = useInjectPortal();
      function setContainer() {
        if (shouldRender.value) {
          container = props.getContainer();
        }
      }
      onBeforeMount(() => {
        isSSR = false;
        setContainer();
      });
      onMounted(() => {
        if (container)
          return;
        setContainer();
      });
      const stopWatch = watch(shouldRender, () => {
        if (shouldRender.value && !container) {
          container = props.getContainer();
        }
        if (container) {
          stopWatch();
        }
      });
      onUpdated(() => {
        nextTick(() => {
          var _a2;
          if (shouldRender.value) {
            (_a2 = props.didUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(props, props);
          }
        });
      });
      return () => {
        var _a2;
        if (!shouldRender.value)
          return null;
        if (isSSR) {
          return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
        }
        return container ? createVNode(Teleport, {
          "to": container
        }, slots) : null;
      };
    }
  });
  let cached;
  function getScrollBarSize(fresh) {
    if (typeof document === "undefined") {
      return 0;
    }
    if (fresh || cached === void 0) {
      const inner = document.createElement("div");
      inner.style.width = "100%";
      inner.style.height = "200px";
      const outer = document.createElement("div");
      const outerStyle = outer.style;
      outerStyle.position = "absolute";
      outerStyle.top = "0";
      outerStyle.left = "0";
      outerStyle.pointerEvents = "none";
      outerStyle.visibility = "hidden";
      outerStyle.width = "200px";
      outerStyle.height = "150px";
      outerStyle.overflow = "hidden";
      outer.appendChild(inner);
      document.body.appendChild(outer);
      const widthContained = inner.offsetWidth;
      outer.style.overflow = "scroll";
      let widthScroll = inner.offsetWidth;
      if (widthContained === widthScroll) {
        widthScroll = outer.clientWidth;
      }
      document.body.removeChild(outer);
      cached = widthContained - widthScroll;
    }
    return cached;
  }
  const UNIQUE_ID = `vc-util-locker-${Date.now()}`;
  let uuid$2 = 0;
  function isBodyOverflowing() {
    return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
  }
  function useScrollLocker(lock) {
    const mergedLock = computed(() => !!lock && !!lock.value);
    uuid$2 += 1;
    const id = `${UNIQUE_ID}_${uuid$2}`;
    watchEffect((onClear) => {
      if (!canUseDom$1()) {
        return;
      }
      if (mergedLock.value) {
        const scrollbarSize = getScrollBarSize();
        const isOverflow = isBodyOverflowing();
        updateCSS$1(`
html body {
  overflow-y: hidden;
  ${isOverflow ? `width: calc(100% - ${scrollbarSize}px);` : ""}
}`, id);
      } else {
        removeCSS(id);
      }
      onClear(() => {
        removeCSS(id);
      });
    }, {
      flush: "post"
    });
  }
  let openCount = 0;
  const supportDom = canUseDom$1();
  const getParent2 = (getContainer2) => {
    if (!supportDom) {
      return null;
    }
    if (getContainer2) {
      if (typeof getContainer2 === "string") {
        return document.querySelectorAll(getContainer2)[0];
      }
      if (typeof getContainer2 === "function") {
        return getContainer2();
      }
      if (typeof getContainer2 === "object" && getContainer2 instanceof window.HTMLElement) {
        return getContainer2;
      }
    }
    return document.body;
  };
  const Portal = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "PortalWrapper",
    inheritAttrs: false,
    props: {
      wrapperClassName: String,
      forceRender: {
        type: Boolean,
        default: void 0
      },
      getContainer: PropTypes.any,
      visible: {
        type: Boolean,
        default: void 0
      },
      autoLock: booleanType(),
      didUpdate: Function
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const container = shallowRef();
      const componentRef = shallowRef();
      const rafId = shallowRef();
      const triggerUpdate = shallowRef(1);
      const defaultContainer = canUseDom$1() && document.createElement("div");
      const removeCurrentContainer = () => {
        var _a2, _b;
        if (container.value === defaultContainer) {
          (_b = (_a2 = container.value) === null || _a2 === void 0 ? void 0 : _a2.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(container.value);
        }
        container.value = null;
      };
      let parent2 = null;
      const attachToParent = function() {
        let force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        if (force || container.value && !container.value.parentNode) {
          parent2 = getParent2(props.getContainer);
          if (parent2) {
            parent2.appendChild(container.value);
            return true;
          }
          return false;
        }
        return true;
      };
      const getContainer2 = () => {
        if (!supportDom) {
          return null;
        }
        if (!container.value) {
          container.value = defaultContainer;
          attachToParent(true);
        }
        setWrapperClassName();
        return container.value;
      };
      const setWrapperClassName = () => {
        const {
          wrapperClassName
        } = props;
        if (container.value && wrapperClassName && wrapperClassName !== container.value.className) {
          container.value.className = wrapperClassName;
        }
      };
      onUpdated(() => {
        setWrapperClassName();
        attachToParent();
      });
      useScrollLocker(computed(() => {
        return props.autoLock && props.visible && canUseDom$1() && (container.value === document.body || container.value === defaultContainer);
      }));
      onMounted(() => {
        let init4 = false;
        watch([() => props.visible, () => props.getContainer], (_ref2, _ref3) => {
          let [visible, getContainer22] = _ref2;
          let [prevVisible, prevGetContainer] = _ref3;
          if (supportDom) {
            parent2 = getParent2(props.getContainer);
            if (parent2 === document.body) {
              if (visible && !prevVisible) {
                openCount += 1;
              } else if (init4) {
                openCount -= 1;
              }
            }
          }
          if (init4) {
            const getContainerIsFunc = typeof getContainer22 === "function" && typeof prevGetContainer === "function";
            if (getContainerIsFunc ? getContainer22.toString() !== prevGetContainer.toString() : getContainer22 !== prevGetContainer) {
              removeCurrentContainer();
            }
          }
          init4 = true;
        }, {
          immediate: true,
          flush: "post"
        });
        nextTick(() => {
          if (!attachToParent()) {
            rafId.value = wrapperRaf(() => {
              triggerUpdate.value += 1;
            });
          }
        });
      });
      onBeforeUnmount(() => {
        const {
          visible
        } = props;
        if (supportDom && parent2 === document.body) {
          openCount = visible && openCount ? openCount - 1 : openCount;
        }
        removeCurrentContainer();
        wrapperRaf.cancel(rafId.value);
      });
      return () => {
        const {
          forceRender,
          visible
        } = props;
        let portal = null;
        const childProps = {
          getOpenCount: () => openCount,
          getContainer: getContainer2
        };
        if (triggerUpdate.value && (forceRender || visible || componentRef.value)) {
          portal = createVNode(Portal$1, {
            "getContainer": getContainer2,
            "ref": componentRef,
            "didUpdate": props.didUpdate
          }, {
            default: () => {
              var _a2;
              return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots, childProps);
            }
          });
        }
        return portal;
      };
    }
  });
  const ALL_HANDLERS = ["onClick", "onMousedown", "onTouchstart", "onMouseenter", "onMouseleave", "onFocus", "onBlur", "onContextmenu"];
  const Trigger = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Trigger",
    mixins: [BaseMixin],
    inheritAttrs: false,
    props: triggerProps(),
    setup(props) {
      const align = computed(() => {
        const {
          popupPlacement,
          popupAlign,
          builtinPlacements
        } = props;
        if (popupPlacement && builtinPlacements) {
          return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
        }
        return popupAlign;
      });
      const popupRef = shallowRef(null);
      const setPopupRef = (val) => {
        popupRef.value = val;
      };
      return {
        vcTriggerContext: inject("vcTriggerContext", {}),
        popupRef,
        setPopupRef,
        triggerRef: shallowRef(null),
        align,
        focusTime: null,
        clickOutsideHandler: null,
        contextmenuOutsideHandler1: null,
        contextmenuOutsideHandler2: null,
        touchOutsideHandler: null,
        attachId: null,
        delayTimer: null,
        hasPopupMouseDown: false,
        preClickTime: null,
        preTouchTime: null,
        mouseDownTimeout: null,
        childOriginEvents: {}
      };
    },
    data() {
      const props = this.$props;
      let popupVisible;
      if (this.popupVisible !== void 0) {
        popupVisible = !!props.popupVisible;
      } else {
        popupVisible = !!props.defaultPopupVisible;
      }
      ALL_HANDLERS.forEach((h2) => {
        this[`fire${h2}`] = (e2) => {
          this.fireEvents(h2, e2);
        };
      });
      return {
        prevPopupVisible: popupVisible,
        sPopupVisible: popupVisible,
        point: null
      };
    },
    watch: {
      popupVisible(val) {
        if (val !== void 0) {
          this.prevPopupVisible = this.sPopupVisible;
          this.sPopupVisible = val;
        }
      }
    },
    created() {
      provide("vcTriggerContext", {
        onPopupMouseDown: this.onPopupMouseDown,
        onPopupMouseenter: this.onPopupMouseenter,
        onPopupMouseleave: this.onPopupMouseleave
      });
      useProvidePortal(this);
    },
    deactivated() {
      this.setPopupVisible(false);
    },
    mounted() {
      this.$nextTick(() => {
        this.updatedCal();
      });
    },
    updated() {
      this.$nextTick(() => {
        this.updatedCal();
      });
    },
    beforeUnmount() {
      this.clearDelayTimer();
      this.clearOutsideHandler();
      clearTimeout(this.mouseDownTimeout);
      wrapperRaf.cancel(this.attachId);
    },
    methods: {
      updatedCal() {
        const props = this.$props;
        const state = this.$data;
        if (state.sPopupVisible) {
          let currentDocument;
          if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextmenuToShow())) {
            currentDocument = props.getDocument(this.getRootDomNode());
            this.clickOutsideHandler = addEventListenerWrap(currentDocument, "mousedown", this.onDocumentClick);
          }
          if (!this.touchOutsideHandler) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.touchOutsideHandler = addEventListenerWrap(currentDocument, "touchstart", this.onDocumentClick, supportsPassive$1 ? {
              passive: false
            } : false);
          }
          if (!this.contextmenuOutsideHandler1 && this.isContextmenuToShow()) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.contextmenuOutsideHandler1 = addEventListenerWrap(currentDocument, "scroll", this.onContextmenuClose);
          }
          if (!this.contextmenuOutsideHandler2 && this.isContextmenuToShow()) {
            this.contextmenuOutsideHandler2 = addEventListenerWrap(window, "blur", this.onContextmenuClose);
          }
        } else {
          this.clearOutsideHandler();
        }
      },
      onMouseenter(e2) {
        const {
          mouseEnterDelay
        } = this.$props;
        this.fireEvents("onMouseenter", e2);
        this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e2);
      },
      onMouseMove(e2) {
        this.fireEvents("onMousemove", e2);
        this.setPoint(e2);
      },
      onMouseleave(e2) {
        this.fireEvents("onMouseleave", e2);
        this.delaySetPopupVisible(false, this.$props.mouseLeaveDelay);
      },
      onPopupMouseenter() {
        const {
          vcTriggerContext = {}
        } = this;
        if (vcTriggerContext.onPopupMouseenter) {
          vcTriggerContext.onPopupMouseenter();
        }
        this.clearDelayTimer();
      },
      onPopupMouseleave(e2) {
        var _a2;
        if (e2 && e2.relatedTarget && !e2.relatedTarget.setTimeout && contains$1((_a2 = this.popupRef) === null || _a2 === void 0 ? void 0 : _a2.getElement(), e2.relatedTarget)) {
          return;
        }
        if (this.isMouseLeaveToHide()) {
          this.delaySetPopupVisible(false, this.$props.mouseLeaveDelay);
        }
        const {
          vcTriggerContext = {}
        } = this;
        if (vcTriggerContext.onPopupMouseleave) {
          vcTriggerContext.onPopupMouseleave(e2);
        }
      },
      onFocus(e2) {
        this.fireEvents("onFocus", e2);
        this.clearDelayTimer();
        if (this.isFocusToShow()) {
          this.focusTime = Date.now();
          this.delaySetPopupVisible(true, this.$props.focusDelay);
        }
      },
      onMousedown(e2) {
        this.fireEvents("onMousedown", e2);
        this.preClickTime = Date.now();
      },
      onTouchstart(e2) {
        this.fireEvents("onTouchstart", e2);
        this.preTouchTime = Date.now();
      },
      onBlur(e2) {
        if (!contains$1(e2.target, e2.relatedTarget || document.activeElement)) {
          this.fireEvents("onBlur", e2);
          this.clearDelayTimer();
          if (this.isBlurToHide()) {
            this.delaySetPopupVisible(false, this.$props.blurDelay);
          }
        }
      },
      onContextmenu(e2) {
        e2.preventDefault();
        this.fireEvents("onContextmenu", e2);
        this.setPopupVisible(true, e2);
      },
      onContextmenuClose() {
        if (this.isContextmenuToShow()) {
          this.close();
        }
      },
      onClick(event) {
        this.fireEvents("onClick", event);
        if (this.focusTime) {
          let preTime;
          if (this.preClickTime && this.preTouchTime) {
            preTime = Math.min(this.preClickTime, this.preTouchTime);
          } else if (this.preClickTime) {
            preTime = this.preClickTime;
          } else if (this.preTouchTime) {
            preTime = this.preTouchTime;
          }
          if (Math.abs(preTime - this.focusTime) < 20) {
            return;
          }
          this.focusTime = 0;
        }
        this.preClickTime = 0;
        this.preTouchTime = 0;
        if (this.isClickToShow() && (this.isClickToHide() || this.isBlurToHide()) && event && event.preventDefault) {
          event.preventDefault();
        }
        if (event && event.domEvent) {
          event.domEvent.preventDefault();
        }
        const nextVisible = !this.$data.sPopupVisible;
        if (this.isClickToHide() && !nextVisible || nextVisible && this.isClickToShow()) {
          this.setPopupVisible(!this.$data.sPopupVisible, event);
        }
      },
      onPopupMouseDown() {
        const {
          vcTriggerContext = {}
        } = this;
        this.hasPopupMouseDown = true;
        clearTimeout(this.mouseDownTimeout);
        this.mouseDownTimeout = setTimeout(() => {
          this.hasPopupMouseDown = false;
        }, 0);
        if (vcTriggerContext.onPopupMouseDown) {
          vcTriggerContext.onPopupMouseDown(...arguments);
        }
      },
      onDocumentClick(event) {
        if (this.$props.mask && !this.$props.maskClosable) {
          return;
        }
        const target = event.target;
        const root2 = this.getRootDomNode();
        const popupNode = this.getPopupDomNode();
        if (
          // mousedown on the target should also close popup when action is contextMenu.
          // https://github.com/ant-design/ant-design/issues/29853
          (!contains$1(root2, target) || this.isContextMenuOnly()) && !contains$1(popupNode, target) && !this.hasPopupMouseDown
        ) {
          this.delaySetPopupVisible(false, 0.1);
        }
      },
      getPopupDomNode() {
        var _a2;
        return ((_a2 = this.popupRef) === null || _a2 === void 0 ? void 0 : _a2.getElement()) || null;
      },
      getRootDomNode() {
        var _a2, _b, _c, _d;
        const {
          getTriggerDOMNode
        } = this.$props;
        if (getTriggerDOMNode) {
          const domNode = ((_b = (_a2 = this.triggerRef) === null || _a2 === void 0 ? void 0 : _a2.$el) === null || _b === void 0 ? void 0 : _b.nodeName) === "#comment" ? null : findDOMNode(this.triggerRef);
          return findDOMNode(getTriggerDOMNode(domNode));
        }
        try {
          const domNode = ((_d = (_c = this.triggerRef) === null || _c === void 0 ? void 0 : _c.$el) === null || _d === void 0 ? void 0 : _d.nodeName) === "#comment" ? null : findDOMNode(this.triggerRef);
          if (domNode) {
            return domNode;
          }
        } catch (err) {
        }
        return findDOMNode(this);
      },
      handleGetPopupClassFromAlign(align) {
        const className = [];
        const props = this.$props;
        const {
          popupPlacement,
          builtinPlacements,
          prefixCls,
          alignPoint: alignPoint2,
          getPopupClassNameFromAlign
        } = props;
        if (popupPlacement && builtinPlacements) {
          className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint2));
        }
        if (getPopupClassNameFromAlign) {
          className.push(getPopupClassNameFromAlign(align));
        }
        return className.join(" ");
      },
      getPopupAlign() {
        const props = this.$props;
        const {
          popupPlacement,
          popupAlign,
          builtinPlacements
        } = props;
        if (popupPlacement && builtinPlacements) {
          return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
        }
        return popupAlign;
      },
      getComponent() {
        const mouseProps = {};
        if (this.isMouseEnterToShow()) {
          mouseProps.onMouseenter = this.onPopupMouseenter;
        }
        if (this.isMouseLeaveToHide()) {
          mouseProps.onMouseleave = this.onPopupMouseleave;
        }
        mouseProps.onMousedown = this.onPopupMouseDown;
        mouseProps[supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"] = this.onPopupMouseDown;
        const {
          handleGetPopupClassFromAlign,
          getRootDomNode,
          $attrs
        } = this;
        const {
          prefixCls,
          destroyPopupOnHide,
          popupClassName,
          popupAnimation,
          popupTransitionName,
          popupStyle,
          mask,
          maskAnimation,
          maskTransitionName,
          zIndex,
          stretch,
          alignPoint: alignPoint2,
          mobile,
          forceRender
        } = this.$props;
        const {
          sPopupVisible,
          point
        } = this.$data;
        const popupProps2 = _extends$1(_extends$1({
          prefixCls,
          destroyPopupOnHide,
          visible: sPopupVisible,
          point: alignPoint2 ? point : null,
          align: this.align,
          animation: popupAnimation,
          getClassNameFromAlign: handleGetPopupClassFromAlign,
          stretch,
          getRootDomNode,
          mask,
          zIndex,
          transitionName: popupTransitionName,
          maskAnimation,
          maskTransitionName,
          class: popupClassName,
          style: popupStyle,
          onAlign: $attrs.onPopupAlign || noop$2
        }, mouseProps), {
          ref: this.setPopupRef,
          mobile,
          forceRender
        });
        return createVNode(Popup, popupProps2, {
          default: this.$slots.popup || (() => getComponent(this, "popup"))
        });
      },
      attachParent(popupContainer) {
        wrapperRaf.cancel(this.attachId);
        const {
          getPopupContainer,
          getDocument: getDocument2
        } = this.$props;
        const domNode = this.getRootDomNode();
        let mountNode;
        if (!getPopupContainer) {
          mountNode = getDocument2(this.getRootDomNode()).body;
        } else if (domNode || getPopupContainer.length === 0) {
          mountNode = getPopupContainer(domNode);
        }
        if (mountNode) {
          mountNode.appendChild(popupContainer);
        } else {
          this.attachId = wrapperRaf(() => {
            this.attachParent(popupContainer);
          });
        }
      },
      getContainer() {
        const {
          $props: props
        } = this;
        const {
          getDocument: getDocument2
        } = props;
        const popupContainer = getDocument2(this.getRootDomNode()).createElement("div");
        popupContainer.style.position = "absolute";
        popupContainer.style.top = "0";
        popupContainer.style.left = "0";
        popupContainer.style.width = "100%";
        this.attachParent(popupContainer);
        return popupContainer;
      },
      setPopupVisible(sPopupVisible, event) {
        const {
          alignPoint: alignPoint2,
          sPopupVisible: prevPopupVisible,
          onPopupVisibleChange
        } = this;
        this.clearDelayTimer();
        if (prevPopupVisible !== sPopupVisible) {
          if (!hasProp(this, "popupVisible")) {
            this.setState({
              sPopupVisible,
              prevPopupVisible
            });
          }
          onPopupVisibleChange && onPopupVisibleChange(sPopupVisible);
        }
        if (alignPoint2 && event && sPopupVisible) {
          this.setPoint(event);
        }
      },
      setPoint(point) {
        const {
          alignPoint: alignPoint2
        } = this.$props;
        if (!alignPoint2 || !point)
          return;
        this.setState({
          point: {
            pageX: point.pageX,
            pageY: point.pageY
          }
        });
      },
      handlePortalUpdate() {
        if (this.prevPopupVisible !== this.sPopupVisible) {
          this.afterPopupVisibleChange(this.sPopupVisible);
        }
      },
      delaySetPopupVisible(visible, delayS, event) {
        const delay2 = delayS * 1e3;
        this.clearDelayTimer();
        if (delay2) {
          const point = event ? {
            pageX: event.pageX,
            pageY: event.pageY
          } : null;
          this.delayTimer = setTimeout(() => {
            this.setPopupVisible(visible, point);
            this.clearDelayTimer();
          }, delay2);
        } else {
          this.setPopupVisible(visible, event);
        }
      },
      clearDelayTimer() {
        if (this.delayTimer) {
          clearTimeout(this.delayTimer);
          this.delayTimer = null;
        }
      },
      clearOutsideHandler() {
        if (this.clickOutsideHandler) {
          this.clickOutsideHandler.remove();
          this.clickOutsideHandler = null;
        }
        if (this.contextmenuOutsideHandler1) {
          this.contextmenuOutsideHandler1.remove();
          this.contextmenuOutsideHandler1 = null;
        }
        if (this.contextmenuOutsideHandler2) {
          this.contextmenuOutsideHandler2.remove();
          this.contextmenuOutsideHandler2 = null;
        }
        if (this.touchOutsideHandler) {
          this.touchOutsideHandler.remove();
          this.touchOutsideHandler = null;
        }
      },
      createTwoChains(event) {
        let fn = () => {
        };
        const events = getEvents(this);
        if (this.childOriginEvents[event] && events[event]) {
          return this[`fire${event}`];
        }
        fn = this.childOriginEvents[event] || events[event] || fn;
        return fn;
      },
      isClickToShow() {
        const {
          action,
          showAction
        } = this.$props;
        return action.indexOf("click") !== -1 || showAction.indexOf("click") !== -1;
      },
      isContextMenuOnly() {
        const {
          action
        } = this.$props;
        return action === "contextmenu" || action.length === 1 && action[0] === "contextmenu";
      },
      isContextmenuToShow() {
        const {
          action,
          showAction
        } = this.$props;
        return action.indexOf("contextmenu") !== -1 || showAction.indexOf("contextmenu") !== -1;
      },
      isClickToHide() {
        const {
          action,
          hideAction
        } = this.$props;
        return action.indexOf("click") !== -1 || hideAction.indexOf("click") !== -1;
      },
      isMouseEnterToShow() {
        const {
          action,
          showAction
        } = this.$props;
        return action.indexOf("hover") !== -1 || showAction.indexOf("mouseenter") !== -1;
      },
      isMouseLeaveToHide() {
        const {
          action,
          hideAction
        } = this.$props;
        return action.indexOf("hover") !== -1 || hideAction.indexOf("mouseleave") !== -1;
      },
      isFocusToShow() {
        const {
          action,
          showAction
        } = this.$props;
        return action.indexOf("focus") !== -1 || showAction.indexOf("focus") !== -1;
      },
      isBlurToHide() {
        const {
          action,
          hideAction
        } = this.$props;
        return action.indexOf("focus") !== -1 || hideAction.indexOf("blur") !== -1;
      },
      forcePopupAlign() {
        var _a2;
        if (this.$data.sPopupVisible) {
          (_a2 = this.popupRef) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
        }
      },
      fireEvents(type4, e2) {
        if (this.childOriginEvents[type4]) {
          this.childOriginEvents[type4](e2);
        }
        const event = this.$props[type4] || this.$attrs[type4];
        if (event) {
          event(e2);
        }
      },
      close() {
        this.setPopupVisible(false);
      }
    },
    render() {
      const {
        $attrs
      } = this;
      const children = filterEmpty(getSlot(this));
      const {
        alignPoint: alignPoint2,
        getPopupContainer
      } = this.$props;
      const child = children[0];
      this.childOriginEvents = getEvents(child);
      const newChildProps = {
        key: "trigger"
      };
      if (this.isContextmenuToShow()) {
        newChildProps.onContextmenu = this.onContextmenu;
      } else {
        newChildProps.onContextmenu = this.createTwoChains("onContextmenu");
      }
      if (this.isClickToHide() || this.isClickToShow()) {
        newChildProps.onClick = this.onClick;
        newChildProps.onMousedown = this.onMousedown;
        newChildProps[supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"] = this.onTouchstart;
      } else {
        newChildProps.onClick = this.createTwoChains("onClick");
        newChildProps.onMousedown = this.createTwoChains("onMousedown");
        newChildProps[supportsPassive$1 ? "onTouchstartPassive" : "onTouchstart"] = this.createTwoChains("onTouchstart");
      }
      if (this.isMouseEnterToShow()) {
        newChildProps.onMouseenter = this.onMouseenter;
        if (alignPoint2) {
          newChildProps.onMousemove = this.onMouseMove;
        }
      } else {
        newChildProps.onMouseenter = this.createTwoChains("onMouseenter");
      }
      if (this.isMouseLeaveToHide()) {
        newChildProps.onMouseleave = this.onMouseleave;
      } else {
        newChildProps.onMouseleave = this.createTwoChains("onMouseleave");
      }
      if (this.isFocusToShow() || this.isBlurToHide()) {
        newChildProps.onFocus = this.onFocus;
        newChildProps.onBlur = this.onBlur;
      } else {
        newChildProps.onFocus = this.createTwoChains("onFocus");
        newChildProps.onBlur = (e2) => {
          if (e2 && (!e2.relatedTarget || !contains$1(e2.target, e2.relatedTarget))) {
            this.createTwoChains("onBlur")(e2);
          }
        };
      }
      const childrenClassName = classNames(child && child.props && child.props.class, $attrs.class);
      if (childrenClassName) {
        newChildProps.class = childrenClassName;
      }
      const trigger2 = cloneElement(child, _extends$1(_extends$1({}, newChildProps), {
        ref: "triggerRef"
      }), true, true);
      const portal = createVNode(Portal, {
        "key": "portal",
        "getContainer": getPopupContainer && (() => getPopupContainer(this.getRootDomNode())),
        "didUpdate": this.handlePortalUpdate,
        "visible": this.$data.sPopupVisible
      }, {
        default: this.getComponent
      });
      return createVNode(Fragment, null, [trigger2, portal]);
    }
  });
  const KeyCode = {
    /**
     * MAC_ENTER
     */
    MAC_ENTER: 3,
    /**
     * BACKSPACE
     */
    BACKSPACE: 8,
    /**
     * TAB
     */
    TAB: 9,
    /**
     * NUMLOCK on FF/Safari Mac
     */
    NUM_CENTER: 12,
    /**
     * ENTER
     */
    ENTER: 13,
    /**
     * SHIFT
     */
    SHIFT: 16,
    /**
     * CTRL
     */
    CTRL: 17,
    /**
     * ALT
     */
    ALT: 18,
    /**
     * PAUSE
     */
    PAUSE: 19,
    /**
     * CAPS_LOCK
     */
    CAPS_LOCK: 20,
    /**
     * ESC
     */
    ESC: 27,
    /**
     * SPACE
     */
    SPACE: 32,
    /**
     * PAGE_UP
     */
    PAGE_UP: 33,
    /**
     * PAGE_DOWN
     */
    PAGE_DOWN: 34,
    /**
     * END
     */
    END: 35,
    /**
     * HOME
     */
    HOME: 36,
    /**
     * LEFT
     */
    LEFT: 37,
    /**
     * UP
     */
    UP: 38,
    /**
     * RIGHT
     */
    RIGHT: 39,
    /**
     * DOWN
     */
    DOWN: 40,
    /**
     * PRINT_SCREEN
     */
    PRINT_SCREEN: 44,
    /**
     * INSERT
     */
    INSERT: 45,
    /**
     * DELETE
     */
    DELETE: 46,
    /**
     * ZERO
     */
    ZERO: 48,
    /**
     * ONE
     */
    ONE: 49,
    /**
     * TWO
     */
    TWO: 50,
    /**
     * THREE
     */
    THREE: 51,
    /**
     * FOUR
     */
    FOUR: 52,
    /**
     * FIVE
     */
    FIVE: 53,
    /**
     * SIX
     */
    SIX: 54,
    /**
     * SEVEN
     */
    SEVEN: 55,
    /**
     * EIGHT
     */
    EIGHT: 56,
    /**
     * NINE
     */
    NINE: 57,
    /**
     * QUESTION_MARK
     */
    QUESTION_MARK: 63,
    /**
     * A
     */
    A: 65,
    /**
     * B
     */
    B: 66,
    /**
     * C
     */
    C: 67,
    /**
     * D
     */
    D: 68,
    /**
     * E
     */
    E: 69,
    /**
     * F
     */
    F: 70,
    /**
     * G
     */
    G: 71,
    /**
     * H
     */
    H: 72,
    /**
     * I
     */
    I: 73,
    /**
     * J
     */
    J: 74,
    /**
     * K
     */
    K: 75,
    /**
     * L
     */
    L: 76,
    /**
     * M
     */
    M: 77,
    /**
     * N
     */
    N: 78,
    /**
     * O
     */
    O: 79,
    /**
     * P
     */
    P: 80,
    /**
     * Q
     */
    Q: 81,
    /**
     * R
     */
    R: 82,
    /**
     * S
     */
    S: 83,
    /**
     * T
     */
    T: 84,
    /**
     * U
     */
    U: 85,
    /**
     * V
     */
    V: 86,
    /**
     * W
     */
    W: 87,
    /**
     * X
     */
    X: 88,
    /**
     * Y
     */
    Y: 89,
    /**
     * Z
     */
    Z: 90,
    /**
     * META
     */
    META: 91,
    /**
     * WIN_KEY_RIGHT
     */
    WIN_KEY_RIGHT: 92,
    /**
     * CONTEXT_MENU
     */
    CONTEXT_MENU: 93,
    /**
     * NUM_ZERO
     */
    NUM_ZERO: 96,
    /**
     * NUM_ONE
     */
    NUM_ONE: 97,
    /**
     * NUM_TWO
     */
    NUM_TWO: 98,
    /**
     * NUM_THREE
     */
    NUM_THREE: 99,
    /**
     * NUM_FOUR
     */
    NUM_FOUR: 100,
    /**
     * NUM_FIVE
     */
    NUM_FIVE: 101,
    /**
     * NUM_SIX
     */
    NUM_SIX: 102,
    /**
     * NUM_SEVEN
     */
    NUM_SEVEN: 103,
    /**
     * NUM_EIGHT
     */
    NUM_EIGHT: 104,
    /**
     * NUM_NINE
     */
    NUM_NINE: 105,
    /**
     * NUM_MULTIPLY
     */
    NUM_MULTIPLY: 106,
    /**
     * NUM_PLUS
     */
    NUM_PLUS: 107,
    /**
     * NUM_MINUS
     */
    NUM_MINUS: 109,
    /**
     * NUM_PERIOD
     */
    NUM_PERIOD: 110,
    /**
     * NUM_DIVISION
     */
    NUM_DIVISION: 111,
    /**
     * F1
     */
    F1: 112,
    /**
     * F2
     */
    F2: 113,
    /**
     * F3
     */
    F3: 114,
    /**
     * F4
     */
    F4: 115,
    /**
     * F5
     */
    F5: 116,
    /**
     * F6
     */
    F6: 117,
    /**
     * F7
     */
    F7: 118,
    /**
     * F8
     */
    F8: 119,
    /**
     * F9
     */
    F9: 120,
    /**
     * F10
     */
    F10: 121,
    /**
     * F11
     */
    F11: 122,
    /**
     * F12
     */
    F12: 123,
    /**
     * NUMLOCK
     */
    NUMLOCK: 144,
    /**
     * SEMICOLON
     */
    SEMICOLON: 186,
    /**
     * DASH
     */
    DASH: 189,
    /**
     * EQUALS
     */
    EQUALS: 187,
    /**
     * COMMA
     */
    COMMA: 188,
    /**
     * PERIOD
     */
    PERIOD: 190,
    /**
     * SLASH
     */
    SLASH: 191,
    /**
     * APOSTROPHE
     */
    APOSTROPHE: 192,
    /**
     * SINGLE_QUOTE
     */
    SINGLE_QUOTE: 222,
    /**
     * OPEN_SQUARE_BRACKET
     */
    OPEN_SQUARE_BRACKET: 219,
    /**
     * BACKSLASH
     */
    BACKSLASH: 220,
    /**
     * CLOSE_SQUARE_BRACKET
     */
    CLOSE_SQUARE_BRACKET: 221,
    /**
     * WIN_KEY
     */
    WIN_KEY: 224,
    /**
     * MAC_FF_META
     */
    MAC_FF_META: 224,
    /**
     * WIN_IME
     */
    WIN_IME: 229,
    // ======================== Function ========================
    /**
     * whether text and modified key is entered at the same time.
     */
    isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e2) {
      const {
        keyCode
      } = e2;
      if (e2.altKey && !e2.ctrlKey || e2.metaKey || // Function keys don't generate text
      keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
        return false;
      }
      switch (keyCode) {
        case KeyCode.ALT:
        case KeyCode.CAPS_LOCK:
        case KeyCode.CONTEXT_MENU:
        case KeyCode.CTRL:
        case KeyCode.DOWN:
        case KeyCode.END:
        case KeyCode.ESC:
        case KeyCode.HOME:
        case KeyCode.INSERT:
        case KeyCode.LEFT:
        case KeyCode.MAC_FF_META:
        case KeyCode.META:
        case KeyCode.NUMLOCK:
        case KeyCode.NUM_CENTER:
        case KeyCode.PAGE_DOWN:
        case KeyCode.PAGE_UP:
        case KeyCode.PAUSE:
        case KeyCode.PRINT_SCREEN:
        case KeyCode.RIGHT:
        case KeyCode.SHIFT:
        case KeyCode.UP:
        case KeyCode.WIN_KEY:
        case KeyCode.WIN_KEY_RIGHT:
          return false;
        default:
          return true;
      }
    },
    /**
     * whether character is entered.
     */
    isCharacterKey: function isCharacterKey(keyCode) {
      if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
        return true;
      }
      if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
        return true;
      }
      if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
        return true;
      }
      if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
        return true;
      }
      switch (keyCode) {
        case KeyCode.SPACE:
        case KeyCode.QUESTION_MARK:
        case KeyCode.NUM_PLUS:
        case KeyCode.NUM_MINUS:
        case KeyCode.NUM_PERIOD:
        case KeyCode.NUM_DIVISION:
        case KeyCode.SEMICOLON:
        case KeyCode.DASH:
        case KeyCode.EQUALS:
        case KeyCode.COMMA:
        case KeyCode.PERIOD:
        case KeyCode.SLASH:
        case KeyCode.APOSTROPHE:
        case KeyCode.SINGLE_QUOTE:
        case KeyCode.OPEN_SQUARE_BRACKET:
        case KeyCode.BACKSLASH:
        case KeyCode.CLOSE_SQUARE_BRACKET:
          return true;
        default:
          return false;
      }
    }
  };
  const KeyCode$1 = KeyCode;
  function onCompositionStart(e2) {
    e2.target.composing = true;
  }
  function onCompositionEnd(e2) {
    if (!e2.target.composing)
      return;
    e2.target.composing = false;
    trigger(e2.target, "input");
  }
  function trigger(el, type4) {
    const e2 = document.createEvent("HTMLEvents");
    e2.initEvent(type4, true, true);
    el.dispatchEvent(e2);
  }
  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  const antInput = {
    created(el, binding) {
      if (!binding.modifiers || !binding.modifiers.lazy) {
        addEventListener(el, "compositionstart", onCompositionStart);
        addEventListener(el, "compositionend", onCompositionEnd);
        addEventListener(el, "change", onCompositionEnd);
      }
    }
  };
  const antInputDirective = antInput;
  const attributes = `accept acceptcharset accesskey action allowfullscreen allowtransparency
alt async autocomplete autofocus autoplay capture cellpadding cellspacing challenge
charset checked classid classname colspan cols content contenteditable contextmenu
controls coords crossorigin data datetime default defer dir disabled download draggable
enctype form formaction formenctype formmethod formnovalidate formtarget frameborder
headers height hidden high href hreflang htmlfor for httpequiv icon id inputmode integrity
is keyparams keytype kind label lang list loop low manifest marginheight marginwidth max maxlength media
mediagroup method min minlength multiple muted name novalidate nonce open
optimum pattern placeholder poster preload radiogroup readonly rel required
reversed role rowspan rows sandbox scope scoped scrolling seamless selected
shape size sizes span spellcheck src srcdoc srclang srcset start step style
summary tabindex target title type usemap value width wmode wrap`;
  const eventsName = `onCopy onCut onPaste onCompositionend onCompositionstart onCompositionupdate onKeydown
    onKeypress onKeyup onFocus onBlur onChange onInput onSubmit onClick onContextmenu onDoubleclick onDblclick
    onDrag onDragend onDragenter onDragexit onDragleave onDragover onDragstart onDrop onMousedown
    onMouseenter onMouseleave onMousemove onMouseout onMouseover onMouseup onSelect onTouchcancel
    onTouchend onTouchmove onTouchstart onTouchstartPassive onTouchmovePassive onScroll onWheel onAbort onCanplay onCanplaythrough
    onDurationchange onEmptied onEncrypted onEnded onError onLoadeddata onLoadedmetadata
    onLoadstart onPause onPlay onPlaying onProgress onRatechange onSeeked onSeeking onStalled onSuspend onTimeupdate onVolumechange onWaiting onLoad onError`;
  const propList = `${attributes} ${eventsName}`.split(/[\s\n]+/);
  const ariaPrefix = "aria-";
  const dataPrefix = "data-";
  function match(key2, prefix) {
    return key2.indexOf(prefix) === 0;
  }
  function pickAttrs(props) {
    let ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    let mergedConfig;
    if (ariaOnly === false) {
      mergedConfig = {
        aria: true,
        data: true,
        attr: true
      };
    } else if (ariaOnly === true) {
      mergedConfig = {
        aria: true
      };
    } else {
      mergedConfig = _extends$1({}, ariaOnly);
    }
    const attrs = {};
    Object.keys(props).forEach((key2) => {
      if (
        // Aria
        mergedConfig.aria && (key2 === "role" || match(key2, ariaPrefix)) || // Data
        mergedConfig.data && match(key2, dataPrefix) || // Attr
        mergedConfig.attr && (propList.includes(key2) || propList.includes(key2.toLowerCase()))
      ) {
        attrs[key2] = props[key2];
      }
    });
    return attrs;
  }
  function useMergedState(defaultStateValue, option) {
    const {
      defaultValue,
      value = ref()
    } = option || {};
    let initValue = typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
    if (value.value !== void 0) {
      initValue = unref(value);
    }
    if (defaultValue !== void 0) {
      initValue = typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
    const innerValue = ref(initValue);
    const mergedValue = ref(initValue);
    watchEffect(() => {
      let val = value.value !== void 0 ? value.value : innerValue.value;
      if (option.postState) {
        val = option.postState(val);
      }
      mergedValue.value = val;
    });
    function triggerChange(newValue) {
      const preVal = mergedValue.value;
      innerValue.value = newValue;
      if (toRaw(mergedValue.value) !== newValue && option.onChange) {
        option.onChange(newValue, preVal);
      }
    }
    watch(value, () => {
      innerValue.value = value.value;
    });
    return [mergedValue, triggerChange];
  }
  function useState(defaultStateValue) {
    const initValue = typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
    const innerValue = ref(initValue);
    function triggerChange(newValue) {
      innerValue.value = newValue;
    }
    return [innerValue, triggerChange];
  }
  var contextKey = Symbol("iconContext");
  var useInjectIconContext = function useInjectIconContext2() {
    return inject(contextKey, {
      prefixCls: ref("anticon"),
      rootClassName: ref(""),
      csp: ref()
    });
  };
  function canUseDom() {
    return !!(typeof window !== "undefined" && window.document && window.document.createElement);
  }
  function contains(root2, n2) {
    if (!root2) {
      return false;
    }
    if (root2.contains) {
      return root2.contains(n2);
    }
    return false;
  }
  var APPEND_ORDER = "data-vc-order";
  var MARK_KEY = "vc-icon-key";
  var containerCache = /* @__PURE__ */ new Map();
  function getMark() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
    if (mark) {
      return mark.startsWith("data-") ? mark : "data-".concat(mark);
    }
    return MARK_KEY;
  }
  function getContainer$1(option) {
    if (option.attachTo) {
      return option.attachTo;
    }
    var head = document.querySelector("head");
    return head || document.body;
  }
  function getOrder(prepend) {
    if (prepend === "queue") {
      return "prependQueue";
    }
    return prepend ? "prepend" : "append";
  }
  function findStyles(container) {
    return Array.from((containerCache.get(container) || container).children).filter(function(node2) {
      return node2.tagName === "STYLE";
    });
  }
  function injectCSS(css2) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!canUseDom()) {
      return null;
    }
    var csp = option.csp, prepend = option.prepend;
    var styleNode = document.createElement("style");
    styleNode.setAttribute(APPEND_ORDER, getOrder(prepend));
    if (csp && csp.nonce) {
      styleNode.nonce = csp.nonce;
    }
    styleNode.innerHTML = css2;
    var container = getContainer$1(option);
    var firstChild = container.firstChild;
    if (prepend) {
      if (prepend === "queue") {
        var existStyle = findStyles(container).filter(function(node2) {
          return ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER));
        });
        if (existStyle.length) {
          container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
          return styleNode;
        }
      }
      container.insertBefore(styleNode, firstChild);
    } else {
      container.appendChild(styleNode);
    }
    return styleNode;
  }
  function findExistNode(key2) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var container = getContainer$1(option);
    return findStyles(container).find(function(node2) {
      return node2.getAttribute(getMark(option)) === key2;
    });
  }
  function syncRealContainer(container, option) {
    var cachedRealContainer = containerCache.get(container);
    if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
      var placeholderStyle = injectCSS("", option);
      var parentNode = placeholderStyle.parentNode;
      containerCache.set(container, parentNode);
      container.removeChild(placeholderStyle);
    }
  }
  function updateCSS(css2, key2) {
    var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var container = getContainer$1(option);
    syncRealContainer(container, option);
    var existNode = findExistNode(key2, option);
    if (existNode) {
      if (option.csp && option.csp.nonce && existNode.nonce !== option.csp.nonce) {
        existNode.nonce = option.csp.nonce;
      }
      if (existNode.innerHTML !== css2) {
        existNode.innerHTML = css2;
      }
      return existNode;
    }
    var newNode = injectCSS(css2, option);
    newNode.setAttribute(getMark(option), key2);
    return newNode;
  }
  function _objectSpread$g(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$g(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$g(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function warn(valid, message) {
    if (!valid && console !== void 0) {
      console.error("Warning: ".concat(message));
    }
  }
  function warning$1(valid, message) {
    warn(valid, "[@ant-design/icons-vue] ".concat(message));
  }
  function isIconDefinition(target) {
    return typeof target === "object" && typeof target.name === "string" && typeof target.theme === "string" && (typeof target.icon === "object" || typeof target.icon === "function");
  }
  function generate(node2, key2, rootProps) {
    if (!rootProps) {
      return h$1(node2.tag, _objectSpread$g({
        key: key2
      }, node2.attrs), (node2.children || []).map(function(child, index2) {
        return generate(child, "".concat(key2, "-").concat(node2.tag, "-").concat(index2));
      }));
    }
    return h$1(node2.tag, _objectSpread$g({
      key: key2
    }, rootProps, node2.attrs), (node2.children || []).map(function(child, index2) {
      return generate(child, "".concat(key2, "-").concat(node2.tag, "-").concat(index2));
    }));
  }
  function getSecondaryColor(primaryColor) {
    return generate$1(primaryColor)[0];
  }
  function normalizeTwoToneColors(twoToneColor) {
    if (!twoToneColor) {
      return [];
    }
    return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
  }
  var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
  function getRoot(ele) {
    return ele && ele.getRootNode && ele.getRootNode();
  }
  function inShadow(ele) {
    if (!canUseDom()) {
      return false;
    }
    return getRoot(ele) instanceof ShadowRoot;
  }
  function getShadowRoot(ele) {
    return inShadow(ele) ? getRoot(ele) : null;
  }
  var useInsertStyles = function useInsertStyles2() {
    var _useInjectIconContext = useInjectIconContext(), prefixCls = _useInjectIconContext.prefixCls, csp = _useInjectIconContext.csp;
    var instance = getCurrentInstance();
    var mergedStyleStr = iconStyles;
    if (prefixCls) {
      mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls.value);
    }
    nextTick(function() {
      if (!canUseDom()) {
        return;
      }
      var ele = instance.vnode.el;
      var shadowRoot = getShadowRoot(ele);
      updateCSS(mergedStyleStr, "@ant-design-vue-icons", {
        prepend: true,
        csp: csp.value,
        attachTo: shadowRoot
      });
    });
  };
  var _excluded$1 = ["icon", "primaryColor", "secondaryColor"];
  function _objectWithoutProperties$1(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose$1(source, excluded);
    var key2, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key2 = sourceSymbolKeys[i2];
        if (excluded.indexOf(key2) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key2))
          continue;
        target[key2] = source[key2];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key2, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key2 = sourceKeys[i2];
      if (excluded.indexOf(key2) >= 0)
        continue;
      target[key2] = source[key2];
    }
    return target;
  }
  function _objectSpread$f(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$f(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$f(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var twoToneColorPalette = reactive({
    primaryColor: "#333",
    secondaryColor: "#E6E6E6",
    calculated: false
  });
  function setTwoToneColors(_ref) {
    var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
    twoToneColorPalette.primaryColor = primaryColor;
    twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
    twoToneColorPalette.calculated = !!secondaryColor;
  }
  function getTwoToneColors() {
    return _objectSpread$f({}, twoToneColorPalette);
  }
  var IconBase = function IconBase2(props, context3) {
    var _props$context$attrs = _objectSpread$f({}, props, context3.attrs), icon = _props$context$attrs.icon, primaryColor = _props$context$attrs.primaryColor, secondaryColor = _props$context$attrs.secondaryColor, restProps = _objectWithoutProperties$1(_props$context$attrs, _excluded$1);
    var colors = twoToneColorPalette;
    if (primaryColor) {
      colors = {
        primaryColor,
        secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
      };
    }
    warning$1(isIconDefinition(icon), "icon should be icon definiton, but got ".concat(icon));
    if (!isIconDefinition(icon)) {
      return null;
    }
    var target = icon;
    if (target && typeof target.icon === "function") {
      target = _objectSpread$f({}, target, {
        icon: target.icon(colors.primaryColor, colors.secondaryColor)
      });
    }
    return generate(target.icon, "svg-".concat(target.name), _objectSpread$f({}, restProps, {
      "data-icon": target.name,
      width: "1em",
      height: "1em",
      fill: "currentColor",
      "aria-hidden": "true"
    }));
  };
  IconBase.props = {
    icon: Object,
    primaryColor: String,
    secondaryColor: String,
    focusable: String
  };
  IconBase.inheritAttrs = false;
  IconBase.displayName = "IconBase";
  IconBase.getTwoToneColors = getTwoToneColors;
  IconBase.setTwoToneColors = setTwoToneColors;
  const VueIcon = IconBase;
  function _slicedToArray$1(arr, i2) {
    return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i2) || _unsupportedIterableToArray$1(arr, i2) || _nonIterableRest$1();
  }
  function _nonIterableRest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray$1(o2, minLen) {
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray$1(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray$1(o2, minLen);
  }
  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function _iterableToArrayLimit$1(arr, i2) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles$1(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function setTwoToneColor(twoToneColor) {
    var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray$1(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
    return VueIcon.setTwoToneColors({
      primaryColor,
      secondaryColor
    });
  }
  function getTwoToneColor() {
    var colors = VueIcon.getTwoToneColors();
    if (!colors.calculated) {
      return colors.primaryColor;
    }
    return [colors.primaryColor, colors.secondaryColor];
  }
  var InsertStyles = /* @__PURE__ */ defineComponent({
    name: "InsertStyles",
    setup: function setup() {
      useInsertStyles();
      return function() {
        return null;
      };
    }
  });
  var _excluded = ["class", "icon", "spin", "rotate", "tabindex", "twoToneColor", "onClick"];
  function _slicedToArray(arr, i2) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o2, minLen) {
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o2, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function _iterableToArrayLimit(arr, i2) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _objectSpread$e(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$e(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$e(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key2, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key2 = sourceSymbolKeys[i2];
        if (excluded.indexOf(key2) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key2))
          continue;
        target[key2] = source[key2];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key2, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key2 = sourceKeys[i2];
      if (excluded.indexOf(key2) >= 0)
        continue;
      target[key2] = source[key2];
    }
    return target;
  }
  setTwoToneColor(blue.primary);
  var Icon = function Icon2(props, context3) {
    var _classObj;
    var _props$context$attrs = _objectSpread$e({}, props, context3.attrs), cls = _props$context$attrs["class"], icon = _props$context$attrs.icon, spin = _props$context$attrs.spin, rotate = _props$context$attrs.rotate, tabindex = _props$context$attrs.tabindex, twoToneColor = _props$context$attrs.twoToneColor, onClick = _props$context$attrs.onClick, restProps = _objectWithoutProperties(_props$context$attrs, _excluded);
    var _useInjectIconContext = useInjectIconContext(), prefixCls = _useInjectIconContext.prefixCls, rootClassName = _useInjectIconContext.rootClassName;
    var classObj = (_classObj = {}, _defineProperty$e(_classObj, rootClassName.value, !!rootClassName.value), _defineProperty$e(_classObj, prefixCls.value, true), _defineProperty$e(_classObj, "".concat(prefixCls.value, "-").concat(icon.name), Boolean(icon.name)), _defineProperty$e(_classObj, "".concat(prefixCls.value, "-spin"), !!spin || icon.name === "loading"), _classObj);
    var iconTabIndex = tabindex;
    if (iconTabIndex === void 0 && onClick) {
      iconTabIndex = -1;
    }
    var svgStyle = rotate ? {
      msTransform: "rotate(".concat(rotate, "deg)"),
      transform: "rotate(".concat(rotate, "deg)")
    } : void 0;
    var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
    return createVNode("span", _objectSpread$e({
      "role": "img",
      "aria-label": icon.name
    }, restProps, {
      "onClick": onClick,
      "class": [classObj, cls],
      "tabindex": iconTabIndex
    }), [createVNode(VueIcon, {
      "icon": icon,
      "primaryColor": primaryColor,
      "secondaryColor": secondaryColor,
      "style": svgStyle
    }, null), createVNode(InsertStyles, null, null)]);
  };
  Icon.props = {
    spin: Boolean,
    rotate: Number,
    icon: Object,
    twoToneColor: [String, Array]
  };
  Icon.displayName = "AntdIcon";
  Icon.inheritAttrs = false;
  Icon.getTwoToneColor = getTwoToneColor;
  Icon.setTwoToneColor = setTwoToneColor;
  const AntdIcon = Icon;
  var LoadingOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
  const LoadingOutlinedSvg = LoadingOutlined$2;
  function _objectSpread$d(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$d(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$d(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var LoadingOutlined = function LoadingOutlined2(props, context3) {
    var p = _objectSpread$d({}, props, context3.attrs);
    return createVNode(AntdIcon, _objectSpread$d({}, p, {
      "icon": LoadingOutlinedSvg
    }), null);
  };
  LoadingOutlined.displayName = "LoadingOutlined";
  LoadingOutlined.inheritAttrs = false;
  const LoadingOutlined$1 = LoadingOutlined;
  var CloseOutlined$2 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, "name": "close", "theme": "outlined" };
  const CloseOutlinedSvg = CloseOutlined$2;
  function _objectSpread$c(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$c(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$c(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var CloseOutlined = function CloseOutlined2(props, context3) {
    var p = _objectSpread$c({}, props, context3.attrs);
    return createVNode(AntdIcon, _objectSpread$c({}, p, {
      "icon": CloseOutlinedSvg
    }), null);
  };
  CloseOutlined.displayName = "CloseOutlined";
  CloseOutlined.inheritAttrs = false;
  const CloseOutlined$1 = CloseOutlined;
  var CloseCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, "name": "close-circle", "theme": "filled" };
  const CloseCircleFilledSvg = CloseCircleFilled$2;
  function _objectSpread$b(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$b(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$b(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var CloseCircleFilled = function CloseCircleFilled2(props, context3) {
    var p = _objectSpread$b({}, props, context3.attrs);
    return createVNode(AntdIcon, _objectSpread$b({}, p, {
      "icon": CloseCircleFilledSvg
    }), null);
  };
  CloseCircleFilled.displayName = "CloseCircleFilled";
  CloseCircleFilled.inheritAttrs = false;
  const CloseCircleFilled$1 = CloseCircleFilled;
  var SearchOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
  const SearchOutlinedSvg = SearchOutlined$2;
  function _objectSpread$a(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$a(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$a(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var SearchOutlined = function SearchOutlined2(props, context3) {
    var p = _objectSpread$a({}, props, context3.attrs);
    return createVNode(AntdIcon, _objectSpread$a({}, p, {
      "icon": SearchOutlinedSvg
    }), null);
  };
  SearchOutlined.displayName = "SearchOutlined";
  SearchOutlined.inheritAttrs = false;
  const SearchOutlined$1 = SearchOutlined;
  function createContext(defaultValue) {
    const contextKey2 = Symbol("contextKey");
    const useProvide = (props, newProps) => {
      const mergedProps = reactive({});
      provide(contextKey2, mergedProps);
      watchEffect(() => {
        _extends$1(mergedProps, props, newProps || {});
      });
      return mergedProps;
    };
    const useInject = () => {
      return inject(contextKey2, defaultValue) || {};
    };
    return {
      useProvide,
      useInject
    };
  }
  const ContextKey = Symbol("ContextProps");
  const InternalContextKey = Symbol("InternalContextProps");
  const useProvideFormItemContext = function(props) {
    let useValidation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : computed(() => true);
    const formItemFields = ref(/* @__PURE__ */ new Map());
    const addFormItemField = (key2, type4) => {
      formItemFields.value.set(key2, type4);
      formItemFields.value = new Map(formItemFields.value);
    };
    const removeFormItemField = (key2) => {
      formItemFields.value.delete(key2);
      formItemFields.value = new Map(formItemFields.value);
    };
    const instance = getCurrentInstance();
    watch([useValidation, formItemFields], () => {
      {
        if (useValidation.value && formItemFields.value.size > 1) {
          devWarning(false, "Form.Item", `FormItem can only collect one field item, you haved set ${[...formItemFields.value.values()].map((v2) => `\`${v2.name}\``).join(", ")} ${formItemFields.value.size} field items.
        You can set not need to be collected fields into \`a-form-item-rest\``);
          let cur = instance;
          while (cur.parent) {
            console.warn("at", cur.type);
            cur = cur.parent;
          }
        }
      }
    });
    provide(ContextKey, props);
    provide(InternalContextKey, {
      addFormItemField,
      removeFormItemField
    });
  };
  const defaultContext = {
    id: computed(() => void 0),
    onFieldBlur: () => {
    },
    onFieldChange: () => {
    },
    clearValidate: () => {
    }
  };
  const defaultInternalContext = {
    addFormItemField: () => {
    },
    removeFormItemField: () => {
    }
  };
  const useInjectFormItemContext = () => {
    const internalContext = inject(InternalContextKey, defaultInternalContext);
    const formItemFieldKey = Symbol("FormItemFieldKey");
    const instance = getCurrentInstance();
    internalContext.addFormItemField(formItemFieldKey, instance.type);
    onBeforeUnmount(() => {
      internalContext.removeFormItemField(formItemFieldKey);
    });
    provide(InternalContextKey, defaultInternalContext);
    provide(ContextKey, defaultContext);
    return inject(ContextKey, defaultContext);
  };
  const FormItemRest = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AFormItemRest",
    setup(_2, _ref) {
      let {
        slots
      } = _ref;
      provide(InternalContextKey, defaultInternalContext);
      provide(ContextKey, defaultContext);
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  const FormItemInputContext = createContext({});
  const NoFormStatus = /* @__PURE__ */ defineComponent({
    name: "NoFormStatus",
    setup(_2, _ref2) {
      let {
        slots
      } = _ref2;
      FormItemInputContext.useProvide({});
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  function getStatusClassNames(prefixCls, status, hasFeedback) {
    return classNames({
      [`${prefixCls}-status-success`]: status === "success",
      [`${prefixCls}-status-warning`]: status === "warning",
      [`${prefixCls}-status-error`]: status === "error",
      [`${prefixCls}-status-validating`]: status === "validating",
      [`${prefixCls}-has-feedback`]: hasFeedback
    });
  }
  const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;
  const genSpaceCompactStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: {
        display: "inline-flex",
        "&-block": {
          display: "flex",
          width: "100%"
        },
        "&-vertical": {
          flexDirection: "column"
        }
      }
    };
  };
  const genSpaceCompactStyle$1 = genSpaceCompactStyle;
  const genSpaceStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: {
        display: "inline-flex",
        "&-rtl": {
          direction: "rtl"
        },
        "&-vertical": {
          flexDirection: "column"
        },
        "&-align": {
          flexDirection: "column",
          "&-center": {
            alignItems: "center"
          },
          "&-start": {
            alignItems: "flex-start"
          },
          "&-end": {
            alignItems: "flex-end"
          },
          "&-baseline": {
            alignItems: "baseline"
          }
        },
        [`${componentCls}-space-item`]: {
          "&:empty": {
            display: "none"
          }
        }
      }
    };
  };
  const useStyle$c = genComponentStyleHook("Space", (token2) => [genSpaceStyle(token2), genSpaceCompactStyle$1(token2)]);
  var symbolTag$2 = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$2;
  }
  function arrayMap(array4, iteratee) {
    var index2 = -1, length2 = array4 == null ? 0 : array4.length, result = Array(length2);
    while (++index2 < length2) {
      result[index2] = iteratee(array4[index2], index2, array4);
    }
    return result;
  }
  var INFINITY$2 = 1 / 0;
  var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
  }
  var reWhitespace = /\s/;
  function trimmedEndIndex(string3) {
    var index2 = string3.length;
    while (index2-- && reWhitespace.test(string3.charAt(index2))) {
    }
    return index2;
  }
  var reTrimStart = /^\s+/;
  function baseTrim(string3) {
    return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
  }
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject$1(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject$1(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  var INFINITY$1 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY$1 || value === -INFINITY$1) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function identity(value) {
    return value;
  }
  var objectCreate = Object.create;
  var baseCreate = /* @__PURE__ */ function() {
    function object4() {
    }
    return function(proto) {
      if (!isObject$1(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object4.prototype = proto;
      var result = new object4();
      object4.prototype = void 0;
      return result;
    };
  }();
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function copyArray(source, array4) {
    var index2 = -1, length2 = source.length;
    array4 || (array4 = Array(length2));
    while (++index2 < length2) {
      array4[index2] = source[index2];
    }
    return array4;
  }
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  function constant(value) {
    return function() {
      return value;
    };
  }
  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e2) {
    }
  }();
  var baseSetToString = !defineProperty ? identity : function(func, string3) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant(string3),
      "writable": true
    });
  };
  const baseSetToString$1 = baseSetToString;
  var setToString = shortOut(baseSetToString$1);
  function arrayEach(array4, iteratee) {
    var index2 = -1, length2 = array4 == null ? 0 : array4.length;
    while (++index2 < length2) {
      if (iteratee(array4[index2], index2, array4) === false) {
        break;
      }
    }
    return array4;
  }
  function baseFindIndex(array4, predicate, fromIndex, fromRight) {
    var length2 = array4.length, index2 = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index2-- : ++index2 < length2) {
      if (predicate(array4[index2], index2, array4)) {
        return index2;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function strictIndexOf(array4, value, fromIndex) {
    var index2 = fromIndex - 1, length2 = array4.length;
    while (++index2 < length2) {
      if (array4[index2] === value) {
        return index2;
      }
    }
    return -1;
  }
  function baseIndexOf(array4, value, fromIndex) {
    return value === value ? strictIndexOf(array4, value, fromIndex) : baseFindIndex(array4, baseIsNaN, fromIndex);
  }
  function arrayIncludes(array4, value) {
    var length2 = array4 == null ? 0 : array4.length;
    return !!length2 && baseIndexOf(array4, value, 0) > -1;
  }
  function baseAssignValue(object4, key2, value) {
    if (key2 == "__proto__" && defineProperty) {
      defineProperty(object4, key2, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object4[key2] = value;
    }
  }
  var objectProto$4 = Object.prototype;
  var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
  function assignValue(object4, key2, value) {
    var objValue = object4[key2];
    if (!(hasOwnProperty$4.call(object4, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object4)) {
      baseAssignValue(object4, key2, value);
    }
  }
  function copyObject(source, props, object4, customizer) {
    var isNew = !object4;
    object4 || (object4 = {});
    var index2 = -1, length2 = props.length;
    while (++index2 < length2) {
      var key2 = props[index2];
      var newValue = customizer ? customizer(object4[key2], source[key2], key2, object4, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key2];
      }
      if (isNew) {
        baseAssignValue(object4, key2, newValue);
      } else {
        assignValue(object4, key2, newValue);
      }
    }
    return object4;
  }
  var nativeMax$2 = Math.max;
  function overRest(func, start, transform) {
    start = nativeMax$2(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index2 = -1, length2 = nativeMax$2(args.length - start, 0), array4 = Array(length2);
      while (++index2 < length2) {
        array4[index2] = args[start + index2];
      }
      index2 = -1;
      var otherArgs = Array(start + 1);
      while (++index2 < start) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start] = transform(array4);
      return apply(func, this, otherArgs);
    };
  }
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + "");
  }
  function nativeKeysIn(object4) {
    var result = [];
    if (object4 != null) {
      for (var key2 in Object(object4)) {
        result.push(key2);
      }
    }
    return result;
  }
  var objectProto$3 = Object.prototype;
  var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
  function baseKeysIn(object4) {
    if (!isObject$1(object4)) {
      return nativeKeysIn(object4);
    }
    var isProto = isPrototype(object4), result = [];
    for (var key2 in object4) {
      if (!(key2 == "constructor" && (isProto || !hasOwnProperty$3.call(object4, key2)))) {
        result.push(key2);
      }
    }
    return result;
  }
  function keysIn(object4) {
    return isArrayLike(object4) ? arrayLikeKeys(object4, true) : baseKeysIn(object4);
  }
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey(value, object4) {
    if (isArray(value)) {
      return false;
    }
    var type4 = typeof value;
    if (type4 == "number" || type4 == "symbol" || type4 == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object4 != null && value in Object(object4);
  }
  var FUNC_ERROR_TEXT$1 = "Expected a function";
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    var memoized = function() {
      var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key2)) {
        return cache.get(key2);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key2, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }
  memoize.Cache = MapCache;
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize(func, function(key2) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key2;
    });
    var cache = result.cache;
    return result;
  }
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string3) {
    var result = [];
    if (string3.charCodeAt(0) === 46) {
      result.push("");
    }
    string3.replace(rePropName, function(match2, number4, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match2);
    });
    return result;
  });
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function castPath(value, object4) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object4) ? [value] : stringToPath(toString(value));
  }
  var INFINITY = 1 / 0;
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function baseGet(object4, path) {
    path = castPath(path, object4);
    var index2 = 0, length2 = path.length;
    while (object4 != null && index2 < length2) {
      object4 = object4[toKey(path[index2++])];
    }
    return index2 && index2 == length2 ? object4 : void 0;
  }
  function get$1(object4, path, defaultValue) {
    var result = object4 == null ? void 0 : baseGet(object4, path);
    return result === void 0 ? defaultValue : result;
  }
  var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  function baseFlatten(array4, depth, predicate, isStrict, result) {
    var index2 = -1, length2 = array4.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index2 < length2) {
      var value = array4[index2];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  function flatten(array4) {
    var length2 = array4 == null ? 0 : array4.length;
    return length2 ? baseFlatten(array4, 1) : [];
  }
  function flatRest(func) {
    return setToString(overRest(func, void 0, flatten), func + "");
  }
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  var objectTag$1 = "[object Object]";
  var funcProto = Function.prototype, objectProto$2 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject$1(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty$2.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  function baseSlice(array4, start, end) {
    var index2 = -1, length2 = array4.length;
    if (start < 0) {
      start = -start > length2 ? 0 : length2 + start;
    }
    end = end > length2 ? length2 : end;
    if (end < 0) {
      end += length2;
    }
    length2 = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length2);
    while (++index2 < length2) {
      result[index2] = array4[index2 + start];
    }
    return result;
  }
  function baseAssign(object4, source) {
    return object4 && copyObject(source, keys(source), object4);
  }
  function baseAssignIn(object4, source) {
    return object4 && copyObject(source, keysIn(source), object4);
  }
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer(buffer2, isDeep) {
    if (isDeep) {
      return buffer2.slice();
    }
    var length2 = buffer2.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer2.constructor(length2);
    buffer2.copy(result);
    return result;
  }
  function copySymbols(source, object4) {
    return copyObject(source, getSymbols(source), object4);
  }
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object4) {
    var result = [];
    while (object4) {
      arrayPush(result, getSymbols(object4));
      object4 = getPrototype(object4);
    }
    return result;
  };
  function copySymbolsIn(source, object4) {
    return copyObject(source, getSymbolsIn(source), object4);
  }
  function getAllKeysIn(object4) {
    return baseGetAllKeys(object4, keysIn, getSymbolsIn);
  }
  var objectProto$1 = Object.prototype;
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
  function initCloneArray(array4) {
    var length2 = array4.length, result = new array4.constructor(length2);
    if (length2 && typeof array4[0] == "string" && hasOwnProperty$1.call(array4, "index")) {
      result.index = array4.index;
      result.input = array4.input;
    }
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
    return result;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
  }
  var reFlags = /\w*$/;
  function cloneRegExp(regexp4) {
    var result = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
    result.lastIndex = regexp4.lastIndex;
    return result;
  }
  var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
  }
  var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$3 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
  var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
  function initCloneByTag(object4, tag, isDeep) {
    var Ctor = object4.constructor;
    switch (tag) {
      case arrayBufferTag$1:
        return cloneArrayBuffer(object4);
      case boolTag$1:
      case dateTag$1:
        return new Ctor(+object4);
      case dataViewTag$1:
        return cloneDataView(object4, isDeep);
      case float32Tag$1:
      case float64Tag$1:
      case int8Tag$1:
      case int16Tag$1:
      case int32Tag$1:
      case uint8Tag$1:
      case uint8ClampedTag$1:
      case uint16Tag$1:
      case uint32Tag$1:
        return cloneTypedArray(object4, isDeep);
      case mapTag$3:
        return new Ctor();
      case numberTag$1:
      case stringTag$1:
        return new Ctor(object4);
      case regexpTag$1:
        return cloneRegExp(object4);
      case setTag$3:
        return new Ctor();
      case symbolTag$1:
        return cloneSymbol(object4);
    }
  }
  function initCloneObject(object4) {
    return typeof object4.constructor == "function" && !isPrototype(object4) ? baseCreate(getPrototype(object4)) : {};
  }
  var mapTag$2 = "[object Map]";
  function baseIsMap(value) {
    return isObjectLike(value) && getTag$1(value) == mapTag$2;
  }
  var nodeIsMap = nodeUtil && nodeUtil.isMap;
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  var setTag$2 = "[object Set]";
  function baseIsSet(value) {
    return isObjectLike(value) && getTag$1(value) == setTag$2;
  }
  var nodeIsSet = nodeUtil && nodeUtil.isSet;
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  var CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag$1] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  function baseClone(value, bitmask, customizer, key2, object4, stack2) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
    if (customizer) {
      result = object4 ? customizer(value, key2, object4, stack2) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject$1(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object4) {
        result = isFlat || isFunc ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object4 ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    stack2 || (stack2 = new Stack());
    var stacked = stack2.get(value);
    if (stacked) {
      return stacked;
    }
    stack2.set(value, result);
    if (isSet(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
      });
    } else if (isMap(value)) {
      value.forEach(function(subValue, key3) {
        result.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
      });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
    var props = isArr ? void 0 : keysFunc(value);
    arrayEach(props || value, function(subValue, key3) {
      if (props) {
        key3 = subValue;
        subValue = value[key3];
      }
      assignValue(result, key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
    });
    return result;
  }
  var CLONE_DEEP_FLAG$1 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
  }
  var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
  function baseIsMatch(object4, source, matchData, customizer) {
    var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
    if (object4 == null) {
      return !length2;
    }
    object4 = Object(object4);
    while (index2--) {
      var data = matchData[index2];
      if (noCustomizer && data[2] ? data[1] !== object4[data[0]] : !(data[0] in object4)) {
        return false;
      }
    }
    while (++index2 < length2) {
      data = matchData[index2];
      var key2 = data[0], objValue = object4[key2], srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === void 0 && !(key2 in object4)) {
          return false;
        }
      } else {
        var stack2 = new Stack();
        if (customizer) {
          var result = customizer(objValue, srcValue, key2, object4, source, stack2);
        }
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  function isStrictComparable(value) {
    return value === value && !isObject$1(value);
  }
  function getMatchData(object4) {
    var result = keys(object4), length2 = result.length;
    while (length2--) {
      var key2 = result[length2], value = object4[key2];
      result[length2] = [key2, value, isStrictComparable(value)];
    }
    return result;
  }
  function matchesStrictComparable(key2, srcValue) {
    return function(object4) {
      if (object4 == null) {
        return false;
      }
      return object4[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object4));
    };
  }
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object4) {
      return object4 === source || baseIsMatch(object4, source, matchData);
    };
  }
  function baseHasIn(object4, key2) {
    return object4 != null && key2 in Object(object4);
  }
  function hasPath(object4, path, hasFunc) {
    path = castPath(path, object4);
    var index2 = -1, length2 = path.length, result = false;
    while (++index2 < length2) {
      var key2 = toKey(path[index2]);
      if (!(result = object4 != null && hasFunc(object4, key2))) {
        break;
      }
      object4 = object4[key2];
    }
    if (result || ++index2 != length2) {
      return result;
    }
    length2 = object4 == null ? 0 : object4.length;
    return !!length2 && isLength(length2) && isIndex(key2, length2) && (isArray(object4) || isArguments$1(object4));
  }
  function hasIn(object4, path) {
    return object4 != null && hasPath(object4, path, baseHasIn);
  }
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object4) {
      var objValue = get$1(object4, path);
      return objValue === void 0 && objValue === srcValue ? hasIn(object4, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  function baseProperty(key2) {
    return function(object4) {
      return object4 == null ? void 0 : object4[key2];
    };
  }
  function basePropertyDeep(path) {
    return function(object4) {
      return baseGet(object4, path);
    };
  }
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (typeof value == "object") {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  var now$3 = function() {
    return root.Date.now();
  };
  var FUNC_ERROR_TEXT = "Expected a function";
  var nativeMax$1 = Math.max, nativeMin$1 = Math.min;
  function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject$1(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax$1(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now$3();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now$3());
    }
    function debounced() {
      var time = now$3(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function arrayIncludesWith(array4, value, comparator2) {
    var index2 = -1, length2 = array4 == null ? 0 : array4.length;
    while (++index2 < length2) {
      if (comparator2(value, array4[index2])) {
        return true;
      }
    }
    return false;
  }
  function last(array4) {
    var length2 = array4 == null ? 0 : array4.length;
    return length2 ? array4[length2 - 1] : void 0;
  }
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike(collection)) {
        var iteratee = baseIteratee(predicate);
        collection = keys(collection);
        predicate = function(key2) {
          return iteratee(iterable[key2], key2, iterable);
        };
      }
      var index2 = findIndexFunc(collection, predicate, fromIndex);
      return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
    };
  }
  var nativeMax = Math.max;
  function findIndex(array4, predicate, fromIndex) {
    var length2 = array4 == null ? 0 : array4.length;
    if (!length2) {
      return -1;
    }
    var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index2 < 0) {
      index2 = nativeMax(length2 + index2, 0);
    }
    return baseFindIndex(array4, baseIteratee(predicate), index2);
  }
  var find = createFind(findIndex);
  var nativeMin = Math.min;
  function baseIntersection(arrays, iteratee, comparator2) {
    var includes = comparator2 ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
    while (othIndex--) {
      var array4 = arrays[othIndex];
      if (othIndex && iteratee) {
        array4 = arrayMap(array4, baseUnary(iteratee));
      }
      maxLength = nativeMin(array4.length, maxLength);
      caches[othIndex] = !comparator2 && (iteratee || length2 >= 120 && array4.length >= 120) ? new SetCache(othIndex && array4) : void 0;
    }
    array4 = arrays[0];
    var index2 = -1, seen = caches[0];
    outer:
      while (++index2 < length2 && result.length < maxLength) {
        var value = array4[index2], computed2 = iteratee ? iteratee(value) : value;
        value = comparator2 || value !== 0 ? value : 0;
        if (!(seen ? cacheHas(seen, computed2) : includes(result, computed2, comparator2))) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache ? cacheHas(cache, computed2) : includes(arrays[othIndex], computed2, comparator2))) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed2);
          }
          result.push(value);
        }
      }
    return result;
  }
  function castArrayLikeObject(value) {
    return isArrayLikeObject(value) ? value : [];
  }
  var intersection = baseRest(function(arrays) {
    var mapped = arrayMap(arrays, castArrayLikeObject);
    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
  });
  function parent(object4, path) {
    return path.length < 2 ? object4 : baseGet(object4, baseSlice(path, 0, -1));
  }
  var mapTag = "[object Map]", setTag = "[object Set]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function isEmpty(value) {
    if (value == null) {
      return true;
    }
    if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray$1(value) || isArguments$1(value))) {
      return !value.length;
    }
    var tag = getTag$1(value);
    if (tag == mapTag || tag == setTag) {
      return !value.size;
    }
    if (isPrototype(value)) {
      return !baseKeys(value).length;
    }
    for (var key2 in value) {
      if (hasOwnProperty.call(value, key2)) {
        return false;
      }
    }
    return true;
  }
  function baseUnset(object4, path) {
    path = castPath(path, object4);
    object4 = parent(object4, path);
    return object4 == null || delete object4[toKey(last(path))];
  }
  function customOmitClone(value) {
    return isPlainObject$1(value) ? void 0 : value;
  }
  var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
  var omit = flatRest(function(object4, paths) {
    var result = {};
    if (object4 == null) {
      return result;
    }
    var isDeep = false;
    paths = arrayMap(paths, function(path) {
      path = castPath(path, object4);
      isDeep || (isDeep = path.length > 1);
      return path;
    });
    copyObject(object4, getAllKeysIn(object4), result);
    if (isDeep) {
      result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
    }
    var length2 = paths.length;
    while (length2--) {
      baseUnset(result, paths[length2]);
    }
    return result;
  });
  const spaceCompactItemProps = () => ({
    compactSize: String,
    compactDirection: PropTypes.oneOf(tuple("horizontal", "vertical")).def("horizontal"),
    isFirstItem: booleanType(),
    isLastItem: booleanType()
  });
  const SpaceCompactItemContext = createContext(null);
  const useCompactItemContext = (prefixCls, direction) => {
    const compactItemContext = SpaceCompactItemContext.useInject();
    const compactItemClassnames = computed(() => {
      if (!compactItemContext || isEmpty(compactItemContext))
        return "";
      const {
        compactDirection,
        isFirstItem,
        isLastItem
      } = compactItemContext;
      const separator = compactDirection === "vertical" ? "-vertical-" : "-";
      return classNames({
        [`${prefixCls.value}-compact${separator}item`]: true,
        [`${prefixCls.value}-compact${separator}first-item`]: isFirstItem,
        [`${prefixCls.value}-compact${separator}last-item`]: isLastItem,
        [`${prefixCls.value}-compact${separator}item-rtl`]: direction.value === "rtl"
      });
    });
    return {
      compactSize: computed(() => compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize),
      compactDirection: computed(() => compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection),
      compactItemClassnames
    };
  };
  const NoCompactStyle = /* @__PURE__ */ defineComponent({
    name: "NoCompactStyle",
    setup(_2, _ref) {
      let {
        slots
      } = _ref;
      SpaceCompactItemContext.useProvide(null);
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  const spaceCompactProps = () => ({
    prefixCls: String,
    size: {
      type: String
    },
    direction: PropTypes.oneOf(tuple("horizontal", "vertical")).def("horizontal"),
    align: PropTypes.oneOf(tuple("start", "end", "center", "baseline")),
    block: {
      type: Boolean,
      default: void 0
    }
  });
  const CompactItem = /* @__PURE__ */ defineComponent({
    name: "CompactItem",
    props: spaceCompactItemProps(),
    setup(props, _ref2) {
      let {
        slots
      } = _ref2;
      SpaceCompactItemContext.useProvide(props);
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  const Compact = /* @__PURE__ */ defineComponent({
    name: "ASpaceCompact",
    inheritAttrs: false,
    props: spaceCompactProps(),
    setup(props, _ref3) {
      let {
        attrs,
        slots
      } = _ref3;
      const {
        prefixCls,
        direction: directionConfig
      } = useConfigInject("space-compact", props);
      const compactItemContext = SpaceCompactItemContext.useInject();
      const [wrapSSR, hashId] = useStyle$c(prefixCls);
      const clx = computed(() => {
        return classNames(prefixCls.value, hashId.value, {
          [`${prefixCls.value}-rtl`]: directionConfig.value === "rtl",
          [`${prefixCls.value}-block`]: props.block,
          [`${prefixCls.value}-vertical`]: props.direction === "vertical"
        });
      });
      return () => {
        var _a2;
        const childNodes = flattenChildren(((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || []);
        if (childNodes.length === 0) {
          return null;
        }
        return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": [clx.value, attrs.class]
        }), [childNodes.map((child, i2) => {
          var _a3;
          const key2 = child && child.key || `${prefixCls.value}-item-${i2}`;
          const noCompactItemContext = !compactItemContext || isEmpty(compactItemContext);
          return createVNode(CompactItem, {
            "key": key2,
            "compactSize": (_a3 = props.size) !== null && _a3 !== void 0 ? _a3 : "middle",
            "compactDirection": props.direction,
            "isFirstItem": i2 === 0 && (noCompactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isFirstItem)),
            "isLastItem": i2 === childNodes.length - 1 && (noCompactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isLastItem))
          }, {
            default: () => [child]
          });
        })]));
      };
    }
  });
  const initMotionCommon = (duration) => ({
    animationDuration: duration,
    animationFillMode: "both"
  });
  const initMotionCommonLeave = (duration) => ({
    animationDuration: duration,
    animationFillMode: "both"
  });
  const initMotion = function(motionCls, inKeyframes, outKeyframes, duration) {
    let sameLevel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
    const sameLevelPrefix = sameLevel ? "&" : "";
    return {
      [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: _extends$1(_extends$1({}, initMotionCommon(duration)), {
        animationPlayState: "paused"
      }),
      [`${sameLevelPrefix}${motionCls}-leave`]: _extends$1(_extends$1({}, initMotionCommonLeave(duration)), {
        animationPlayState: "paused"
      }),
      [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
        animationName: inKeyframes,
        animationPlayState: "running"
      },
      [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
        animationName: outKeyframes,
        animationPlayState: "running",
        pointerEvents: "none"
      }
    };
  };
  const fadeIn = new Keyframe("antFadeIn", {
    "0%": {
      opacity: 0
    },
    "100%": {
      opacity: 1
    }
  });
  const fadeOut = new Keyframe("antFadeOut", {
    "0%": {
      opacity: 1
    },
    "100%": {
      opacity: 0
    }
  });
  const initFadeMotion = function(token2) {
    let sameLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-fade`;
    const sameLevelPrefix = sameLevel ? "&" : "";
    return [initMotion(motionCls, fadeIn, fadeOut, token2.motionDurationMid, sameLevel), {
      [`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
        opacity: 0,
        animationTimingFunction: "linear"
      },
      [`${sameLevelPrefix}${motionCls}-leave`]: {
        animationTimingFunction: "linear"
      }
    }];
  };
  const zoomIn = new Keyframe("antZoomIn", {
    "0%": {
      transform: "scale(0.2)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      opacity: 1
    }
  });
  const zoomOut = new Keyframe("antZoomOut", {
    "0%": {
      transform: "scale(1)"
    },
    "100%": {
      transform: "scale(0.2)",
      opacity: 0
    }
  });
  const zoomBigIn = new Keyframe("antZoomBigIn", {
    "0%": {
      transform: "scale(0.8)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      opacity: 1
    }
  });
  const zoomBigOut = new Keyframe("antZoomBigOut", {
    "0%": {
      transform: "scale(1)"
    },
    "100%": {
      transform: "scale(0.8)",
      opacity: 0
    }
  });
  const zoomUpIn = new Keyframe("antZoomUpIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "50% 0%"
    }
  });
  const zoomUpOut = new Keyframe("antZoomUpOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "50% 0%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 0%",
      opacity: 0
    }
  });
  const zoomLeftIn = new Keyframe("antZoomLeftIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "0% 50%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "0% 50%"
    }
  });
  const zoomLeftOut = new Keyframe("antZoomLeftOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "0% 50%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "0% 50%",
      opacity: 0
    }
  });
  const zoomRightIn = new Keyframe("antZoomRightIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "100% 50%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "100% 50%"
    }
  });
  const zoomRightOut = new Keyframe("antZoomRightOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "100% 50%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "100% 50%",
      opacity: 0
    }
  });
  const zoomDownIn = new Keyframe("antZoomDownIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 100%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "50% 100%"
    }
  });
  const zoomDownOut = new Keyframe("antZoomDownOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "50% 100%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 100%",
      opacity: 0
    }
  });
  const zoomMotion = {
    zoom: {
      inKeyframes: zoomIn,
      outKeyframes: zoomOut
    },
    "zoom-big": {
      inKeyframes: zoomBigIn,
      outKeyframes: zoomBigOut
    },
    "zoom-big-fast": {
      inKeyframes: zoomBigIn,
      outKeyframes: zoomBigOut
    },
    "zoom-left": {
      inKeyframes: zoomLeftIn,
      outKeyframes: zoomLeftOut
    },
    "zoom-right": {
      inKeyframes: zoomRightIn,
      outKeyframes: zoomRightOut
    },
    "zoom-up": {
      inKeyframes: zoomUpIn,
      outKeyframes: zoomUpOut
    },
    "zoom-down": {
      inKeyframes: zoomDownIn,
      outKeyframes: zoomDownOut
    }
  };
  const initZoomMotion = (token2, motionName) => {
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-${motionName}`;
    const {
      inKeyframes,
      outKeyframes
    } = zoomMotion[motionName];
    return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
      [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
        transform: "scale(0)",
        opacity: 0,
        animationTimingFunction: token2.motionEaseOutCirc,
        "&-prepare": {
          transform: "none"
        }
      },
      [`${motionCls}-leave`]: {
        animationTimingFunction: token2.motionEaseInOutCirc
      }
    }];
  };
  const genCollapseMotion = (token2) => ({
    [token2.componentCls]: {
      // For common/openAnimation
      [`${token2.antCls}-motion-collapse-legacy`]: {
        overflow: "hidden",
        "&-active": {
          transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
        }
      },
      [`${token2.antCls}-motion-collapse`]: {
        overflow: "hidden",
        transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
      }
    }
  });
  const genCollapseMotion$1 = genCollapseMotion;
  function compactItemBorder(token2, parentCls, options) {
    const {
      focusElCls,
      focus,
      borderElCls
    } = options;
    const childCombinator = borderElCls ? "> *" : "";
    const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
    return {
      [`&-item:not(${parentCls}-last-item)`]: {
        marginInlineEnd: -token2.lineWidth
      },
      "&-item": _extends$1(_extends$1({
        [hoverEffects]: {
          zIndex: 2
        }
      }, focusElCls ? {
        [`&${focusElCls}`]: {
          zIndex: 2
        }
      } : {}), {
        [`&[disabled] ${childCombinator}`]: {
          zIndex: 0
        }
      })
    };
  }
  function compactItemBorderRadius(prefixCls, parentCls, options) {
    const {
      borderElCls
    } = options;
    const childCombinator = borderElCls ? `> ${borderElCls}` : "";
    return {
      [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
        borderRadius: 0
      },
      [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
        [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        }
      },
      [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
        [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        }
      }
    };
  }
  function genCompactItemStyle(token2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      focus: true
    };
    const {
      componentCls
    } = token2;
    const compactCls = `${componentCls}-compact`;
    return {
      [compactCls]: _extends$1(_extends$1({}, compactItemBorder(token2, compactCls, options)), compactItemBorderRadius(componentCls, compactCls, options))
    };
  }
  var CheckCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z" } }, { "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, "name": "check-circle", "theme": "outlined" };
  const CheckCircleOutlinedSvg = CheckCircleOutlined$2;
  function _objectSpread$9(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$9(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$9(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var CheckCircleOutlined = function CheckCircleOutlined2(props, context3) {
    var p = _objectSpread$9({}, props, context3.attrs);
    return createVNode(AntdIcon, _objectSpread$9({}, p, {
      "icon": CheckCircleOutlinedSvg
    }), null);
  };
  CheckCircleOutlined.displayName = "CheckCircleOutlined";
  CheckCircleOutlined.inheritAttrs = false;
  const CheckCircleOutlined$1 = CheckCircleOutlined;
  var ExclamationCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z" } }] }, "name": "exclamation-circle", "theme": "outlined" };
  const ExclamationCircleOutlinedSvg = ExclamationCircleOutlined$2;
  function _objectSpread$8(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$8(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$8(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var ExclamationCircleOutlined = function ExclamationCircleOutlined2(props, context3) {
    var p = _objectSpread$8({}, props, context3.attrs);
    return createVNode(AntdIcon, _objectSpread$8({}, p, {
      "icon": ExclamationCircleOutlinedSvg
    }), null);
  };
  ExclamationCircleOutlined.displayName = "ExclamationCircleOutlined";
  ExclamationCircleOutlined.inheritAttrs = false;
  const ExclamationCircleOutlined$1 = ExclamationCircleOutlined;
  var InfoCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z" } }] }, "name": "info-circle", "theme": "outlined" };
  const InfoCircleOutlinedSvg = InfoCircleOutlined$2;
  function _objectSpread$7(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$7(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$7(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var InfoCircleOutlined = function InfoCircleOutlined2(props, context3) {
    var p = _objectSpread$7({}, props, context3.attrs);
    return createVNode(AntdIcon, _objectSpread$7({}, p, {
      "icon": InfoCircleOutlinedSvg
    }), null);
  };
  InfoCircleOutlined.displayName = "InfoCircleOutlined";
  InfoCircleOutlined.inheritAttrs = false;
  const InfoCircleOutlined$1 = InfoCircleOutlined;
  var CloseCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm0 76c-205.4 0-372 166.6-372 372s166.6 372 372 372 372-166.6 372-372-166.6-372-372-372zm128.01 198.83c.03 0 .05.01.09.06l45.02 45.01a.2.2 0 01.05.09.12.12 0 010 .07c0 .02-.01.04-.05.08L557.25 512l127.87 127.86a.27.27 0 01.05.06v.02a.12.12 0 010 .07c0 .03-.01.05-.05.09l-45.02 45.02a.2.2 0 01-.09.05.12.12 0 01-.07 0c-.02 0-.04-.01-.08-.05L512 557.25 384.14 685.12c-.04.04-.06.05-.08.05a.12.12 0 01-.07 0c-.03 0-.05-.01-.09-.05l-45.02-45.02a.2.2 0 01-.05-.09.12.12 0 010-.07c0-.02.01-.04.06-.08L466.75 512 338.88 384.14a.27.27 0 01-.05-.06l-.01-.02a.12.12 0 010-.07c0-.03.01-.05.05-.09l45.02-45.02a.2.2 0 01.09-.05.12.12 0 01.07 0c.02 0 .04.01.08.06L512 466.75l127.86-127.86c.04-.05.06-.06.08-.06a.12.12 0 01.07 0z" } }] }, "name": "close-circle", "theme": "outlined" };
  const CloseCircleOutlinedSvg = CloseCircleOutlined$2;
  function _objectSpread$6(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$6(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$6(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var CloseCircleOutlined = function CloseCircleOutlined2(props, context3) {
    var p = _objectSpread$6({}, props, context3.attrs);
    return createVNode(AntdIcon, _objectSpread$6({}, p, {
      "icon": CloseCircleOutlinedSvg
    }), null);
  };
  CloseCircleOutlined.displayName = "CloseCircleOutlined";
  CloseCircleOutlined.inheritAttrs = false;
  const CloseCircleOutlined$1 = CloseCircleOutlined;
  var CheckCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
  const CheckCircleFilledSvg = CheckCircleFilled$2;
  function _objectSpread$5(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$5(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$5(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var CheckCircleFilled = function CheckCircleFilled2(props, context3) {
    var p = _objectSpread$5({}, props, context3.attrs);
    return createVNode(AntdIcon, _objectSpread$5({}, p, {
      "icon": CheckCircleFilledSvg
    }), null);
  };
  CheckCircleFilled.displayName = "CheckCircleFilled";
  CheckCircleFilled.inheritAttrs = false;
  const CheckCircleFilled$1 = CheckCircleFilled;
  var ExclamationCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
  const ExclamationCircleFilledSvg = ExclamationCircleFilled$2;
  function _objectSpread$4(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$4(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$4(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var ExclamationCircleFilled = function ExclamationCircleFilled2(props, context3) {
    var p = _objectSpread$4({}, props, context3.attrs);
    return createVNode(AntdIcon, _objectSpread$4({}, p, {
      "icon": ExclamationCircleFilledSvg
    }), null);
  };
  ExclamationCircleFilled.displayName = "ExclamationCircleFilled";
  ExclamationCircleFilled.inheritAttrs = false;
  const ExclamationCircleFilled$1 = ExclamationCircleFilled;
  var InfoCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };
  const InfoCircleFilledSvg = InfoCircleFilled$2;
  function _objectSpread$3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$3(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$3(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var InfoCircleFilled = function InfoCircleFilled2(props, context3) {
    var p = _objectSpread$3({}, props, context3.attrs);
    return createVNode(AntdIcon, _objectSpread$3({}, p, {
      "icon": InfoCircleFilledSvg
    }), null);
  };
  InfoCircleFilled.displayName = "InfoCircleFilled";
  InfoCircleFilled.inheritAttrs = false;
  const InfoCircleFilled$1 = InfoCircleFilled;
  const responsiveArray = ["xxxl", "xxl", "xl", "lg", "md", "sm", "xs"];
  const getResponsiveMap = (token2) => ({
    xs: `(max-width: ${token2.screenXSMax}px)`,
    sm: `(min-width: ${token2.screenSM}px)`,
    md: `(min-width: ${token2.screenMD}px)`,
    lg: `(min-width: ${token2.screenLG}px)`,
    xl: `(min-width: ${token2.screenXL}px)`,
    xxl: `(min-width: ${token2.screenXXL}px)`,
    xxxl: `{min-width: ${token2.screenXXXL}px}`
  });
  function useResponsiveObserver() {
    const [, token2] = useToken();
    return computed(() => {
      const responsiveMap = getResponsiveMap(token2.value);
      const subscribers = /* @__PURE__ */ new Map();
      let subUid = -1;
      let screens = {};
      return {
        matchHandlers: {},
        dispatch(pointMap) {
          screens = pointMap;
          subscribers.forEach((func) => func(screens));
          return subscribers.size >= 1;
        },
        subscribe(func) {
          if (!subscribers.size)
            this.register();
          subUid += 1;
          subscribers.set(subUid, func);
          func(screens);
          return subUid;
        },
        unsubscribe(paramToken) {
          subscribers.delete(paramToken);
          if (!subscribers.size)
            this.unregister();
        },
        unregister() {
          Object.keys(responsiveMap).forEach((screen) => {
            const matchMediaQuery = responsiveMap[screen];
            const handler = this.matchHandlers[matchMediaQuery];
            handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);
          });
          subscribers.clear();
        },
        register() {
          Object.keys(responsiveMap).forEach((screen) => {
            const matchMediaQuery = responsiveMap[screen];
            const listener = (_ref) => {
              let {
                matches
              } = _ref;
              this.dispatch(_extends$1(_extends$1({}, screens), {
                [screen]: matches
              }));
            };
            const mql = window.matchMedia(matchMediaQuery);
            mql.addListener(listener);
            this.matchHandlers[matchMediaQuery] = {
              mql,
              listener
            };
            listener(mql);
          });
        },
        responsiveMap
      };
    });
  }
  const autoAdjustOverflow = {
    adjustX: 1,
    adjustY: 1
  };
  const targetOffset$1 = [0, 0];
  const placements = {
    left: {
      points: ["cr", "cl"],
      overflow: autoAdjustOverflow,
      offset: [-4, 0],
      targetOffset: targetOffset$1
    },
    right: {
      points: ["cl", "cr"],
      overflow: autoAdjustOverflow,
      offset: [4, 0],
      targetOffset: targetOffset$1
    },
    top: {
      points: ["bc", "tc"],
      overflow: autoAdjustOverflow,
      offset: [0, -4],
      targetOffset: targetOffset$1
    },
    bottom: {
      points: ["tc", "bc"],
      overflow: autoAdjustOverflow,
      offset: [0, 4],
      targetOffset: targetOffset$1
    },
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflow,
      offset: [0, -4],
      targetOffset: targetOffset$1
    },
    leftTop: {
      points: ["tr", "tl"],
      overflow: autoAdjustOverflow,
      offset: [-4, 0],
      targetOffset: targetOffset$1
    },
    topRight: {
      points: ["br", "tr"],
      overflow: autoAdjustOverflow,
      offset: [0, -4],
      targetOffset: targetOffset$1
    },
    rightTop: {
      points: ["tl", "tr"],
      overflow: autoAdjustOverflow,
      offset: [4, 0],
      targetOffset: targetOffset$1
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: autoAdjustOverflow,
      offset: [0, 4],
      targetOffset: targetOffset$1
    },
    rightBottom: {
      points: ["bl", "br"],
      overflow: autoAdjustOverflow,
      offset: [4, 0],
      targetOffset: targetOffset$1
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflow,
      offset: [0, 4],
      targetOffset: targetOffset$1
    },
    leftBottom: {
      points: ["br", "bl"],
      overflow: autoAdjustOverflow,
      offset: [-4, 0],
      targetOffset: targetOffset$1
    }
  };
  const tooltipContentProps = {
    prefixCls: String,
    id: String,
    overlayInnerStyle: PropTypes.any
  };
  const Content$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "TooltipContent",
    props: tooltipContentProps,
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      return () => {
        var _a2;
        return createVNode("div", {
          "class": `${props.prefixCls}-inner`,
          "id": props.id,
          "role": "tooltip",
          "style": props.overlayInnerStyle
        }, [(_a2 = slots.overlay) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
      };
    }
  });
  var __rest$f = function(s2, e2) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  function noop$1() {
  }
  const Tooltip$1 = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Tooltip",
    inheritAttrs: false,
    props: {
      trigger: PropTypes.any.def(["hover"]),
      defaultVisible: {
        type: Boolean,
        default: void 0
      },
      visible: {
        type: Boolean,
        default: void 0
      },
      placement: PropTypes.string.def("right"),
      transitionName: String,
      animation: PropTypes.any,
      afterVisibleChange: PropTypes.func.def(() => {
      }),
      overlayStyle: {
        type: Object,
        default: void 0
      },
      overlayClassName: String,
      prefixCls: PropTypes.string.def("rc-tooltip"),
      mouseEnterDelay: PropTypes.number.def(0.1),
      mouseLeaveDelay: PropTypes.number.def(0.1),
      getPopupContainer: Function,
      destroyTooltipOnHide: {
        type: Boolean,
        default: false
      },
      align: PropTypes.object.def(() => ({})),
      arrowContent: PropTypes.any.def(null),
      tipId: String,
      builtinPlacements: PropTypes.object,
      overlayInnerStyle: {
        type: Object,
        default: void 0
      },
      popupVisible: {
        type: Boolean,
        default: void 0
      },
      onVisibleChange: Function,
      onPopupAlign: Function
    },
    setup(props, _ref) {
      let {
        slots,
        attrs,
        expose
      } = _ref;
      const triggerDOM = shallowRef();
      const getPopupElement = () => {
        const {
          prefixCls,
          tipId,
          overlayInnerStyle
        } = props;
        return [createVNode("div", {
          "class": `${prefixCls}-arrow`,
          "key": "arrow"
        }, [getPropsSlot(slots, props, "arrowContent")]), createVNode(Content$1, {
          "key": "content",
          "prefixCls": prefixCls,
          "id": tipId,
          "overlayInnerStyle": overlayInnerStyle
        }, {
          overlay: slots.overlay
        })];
      };
      const getPopupDomNode = () => {
        return triggerDOM.value.getPopupDomNode();
      };
      expose({
        getPopupDomNode,
        triggerDOM,
        forcePopupAlign: () => {
          var _a2;
          return (_a2 = triggerDOM.value) === null || _a2 === void 0 ? void 0 : _a2.forcePopupAlign();
        }
      });
      const destroyTooltip = shallowRef(false);
      const autoDestroy = shallowRef(false);
      watchEffect(() => {
        const {
          destroyTooltipOnHide
        } = props;
        if (typeof destroyTooltipOnHide === "boolean") {
          destroyTooltip.value = destroyTooltipOnHide;
        } else if (destroyTooltipOnHide && typeof destroyTooltipOnHide === "object") {
          const {
            keepParent
          } = destroyTooltipOnHide;
          destroyTooltip.value = keepParent === true;
          autoDestroy.value = keepParent === false;
        }
      });
      return () => {
        const {
          overlayClassName,
          trigger: trigger2,
          mouseEnterDelay,
          mouseLeaveDelay,
          overlayStyle,
          prefixCls,
          afterVisibleChange,
          transitionName: transitionName2,
          animation,
          placement,
          align,
          destroyTooltipOnHide,
          defaultVisible
        } = props, restProps = __rest$f(props, ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "afterVisibleChange", "transitionName", "animation", "placement", "align", "destroyTooltipOnHide", "defaultVisible"]);
        const extraProps = _extends$1({}, restProps);
        if (props.visible !== void 0) {
          extraProps.popupVisible = props.visible;
        }
        const triggerProps2 = _extends$1(_extends$1(_extends$1({
          popupClassName: overlayClassName,
          prefixCls,
          action: trigger2,
          builtinPlacements: placements,
          popupPlacement: placement,
          popupAlign: align,
          afterPopupVisibleChange: afterVisibleChange,
          popupTransitionName: transitionName2,
          popupAnimation: animation,
          defaultPopupVisible: defaultVisible,
          destroyPopupOnHide: destroyTooltip.value,
          autoDestroy: autoDestroy.value,
          mouseLeaveDelay,
          popupStyle: overlayStyle,
          mouseEnterDelay
        }, extraProps), attrs), {
          onPopupVisibleChange: props.onVisibleChange || noop$1,
          onPopupAlign: props.onPopupAlign || noop$1,
          ref: triggerDOM,
          popup: getPopupElement()
        });
        return createVNode(Trigger, triggerProps2, {
          default: slots.default
        });
      };
    }
  });
  const abstractTooltipProps = () => ({
    trigger: [String, Array],
    open: {
      type: Boolean,
      default: void 0
    },
    /** @deprecated Please use `open` instead. */
    visible: {
      type: Boolean,
      default: void 0
    },
    placement: String,
    color: String,
    transitionName: String,
    overlayStyle: objectType(),
    overlayInnerStyle: objectType(),
    overlayClassName: String,
    openClassName: String,
    prefixCls: String,
    mouseEnterDelay: Number,
    mouseLeaveDelay: Number,
    getPopupContainer: Function,
    arrowPointAtCenter: {
      type: Boolean,
      default: void 0
    },
    autoAdjustOverflow: {
      type: [Boolean, Object],
      default: void 0
    },
    destroyTooltipOnHide: {
      type: Boolean,
      default: void 0
    },
    align: objectType(),
    builtinPlacements: objectType(),
    children: Array,
    /** @deprecated Please use `onOpenChange` instead. */
    onVisibleChange: Function,
    /** @deprecated Please use `onUpdate:open` instead. */
    "onUpdate:visible": Function,
    onOpenChange: Function,
    "onUpdate:open": Function
  });
  const autoAdjustOverflowEnabled = {
    adjustX: 1,
    adjustY: 1
  };
  const autoAdjustOverflowDisabled = {
    adjustX: 0,
    adjustY: 0
  };
  const targetOffset = [0, 0];
  function getOverflowOptions(autoAdjustOverflow2) {
    if (typeof autoAdjustOverflow2 === "boolean") {
      return autoAdjustOverflow2 ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled;
    }
    return _extends$1(_extends$1({}, autoAdjustOverflowDisabled), autoAdjustOverflow2);
  }
  function getPlacements(config3) {
    const {
      arrowWidth = 4,
      horizontalArrowShift = 16,
      verticalArrowShift = 8,
      autoAdjustOverflow: autoAdjustOverflow2,
      arrowPointAtCenter
    } = config3;
    const placementMap = {
      left: {
        points: ["cr", "cl"],
        offset: [-4, 0]
      },
      right: {
        points: ["cl", "cr"],
        offset: [4, 0]
      },
      top: {
        points: ["bc", "tc"],
        offset: [0, -4]
      },
      bottom: {
        points: ["tc", "bc"],
        offset: [0, 4]
      },
      topLeft: {
        points: ["bl", "tc"],
        offset: [-(horizontalArrowShift + arrowWidth), -4]
      },
      leftTop: {
        points: ["tr", "cl"],
        offset: [-4, -(verticalArrowShift + arrowWidth)]
      },
      topRight: {
        points: ["br", "tc"],
        offset: [horizontalArrowShift + arrowWidth, -4]
      },
      rightTop: {
        points: ["tl", "cr"],
        offset: [4, -(verticalArrowShift + arrowWidth)]
      },
      bottomRight: {
        points: ["tr", "bc"],
        offset: [horizontalArrowShift + arrowWidth, 4]
      },
      rightBottom: {
        points: ["bl", "cr"],
        offset: [4, verticalArrowShift + arrowWidth]
      },
      bottomLeft: {
        points: ["tl", "bc"],
        offset: [-(horizontalArrowShift + arrowWidth), 4]
      },
      leftBottom: {
        points: ["br", "cl"],
        offset: [-4, verticalArrowShift + arrowWidth]
      }
    };
    Object.keys(placementMap).forEach((key2) => {
      placementMap[key2] = arrowPointAtCenter ? _extends$1(_extends$1({}, placementMap[key2]), {
        overflow: getOverflowOptions(autoAdjustOverflow2),
        targetOffset
      }) : _extends$1(_extends$1({}, placements[key2]), {
        overflow: getOverflowOptions(autoAdjustOverflow2)
      });
      placementMap[key2].ignoreShake = true;
    });
    return placementMap;
  }
  function firstNotUndefined() {
    let arr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    for (let i2 = 0, len = arr.length; i2 < len; i2++) {
      if (arr[i2] !== void 0) {
        return arr[i2];
      }
    }
    return void 0;
  }
  const inverseColors = PresetColors.map((color) => `${color}-inverse`);
  function isPresetColor(color) {
    let includeInverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (includeInverse) {
      return [...inverseColors, ...PresetColors].includes(color);
    }
    return PresetColors.includes(color);
  }
  function parseColor(prefixCls, color) {
    const isInternalColor = isPresetColor(color);
    const className = classNames({
      [`${prefixCls}-${color}`]: color && isInternalColor
    });
    const overlayStyle = {};
    const arrowStyle = {};
    if (color && !isInternalColor) {
      overlayStyle.background = color;
      arrowStyle["--antd-arrow-background-color"] = color;
    }
    return {
      className,
      overlayStyle,
      arrowStyle
    };
  }
  function connectArrowCls(classList) {
    let showArrowCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return classList.map((cls) => `${showArrowCls}${cls}`).join(",");
  }
  const MAX_VERTICAL_CONTENT_RADIUS = 8;
  function getArrowOffset(options) {
    const maxVerticalContentRadius = MAX_VERTICAL_CONTENT_RADIUS;
    const {
      sizePopupArrow,
      contentRadius,
      borderRadiusOuter,
      limitVerticalRadius
    } = options;
    const arrowInnerOffset = sizePopupArrow / 2 - Math.ceil(borderRadiusOuter * (Math.sqrt(2) - 1));
    const dropdownArrowOffset = (contentRadius > 12 ? contentRadius + 2 : 12) - arrowInnerOffset;
    const dropdownArrowOffsetVertical = limitVerticalRadius ? maxVerticalContentRadius - arrowInnerOffset : dropdownArrowOffset;
    return {
      dropdownArrowOffset,
      dropdownArrowOffsetVertical
    };
  }
  function getArrowStyle(token2, options) {
    const {
      componentCls,
      sizePopupArrow,
      marginXXS,
      borderRadiusXS,
      borderRadiusOuter,
      boxShadowPopoverArrow
    } = token2;
    const {
      colorBg,
      showArrowCls,
      contentRadius = token2.borderRadiusLG,
      limitVerticalRadius
    } = options;
    const {
      dropdownArrowOffsetVertical,
      dropdownArrowOffset
    } = getArrowOffset({
      sizePopupArrow,
      contentRadius,
      borderRadiusOuter,
      limitVerticalRadius
    });
    const dropdownArrowDistance = sizePopupArrow / 2 + marginXXS;
    return {
      [componentCls]: {
        // ============================ Basic ============================
        [`${componentCls}-arrow`]: [_extends$1(_extends$1({
          position: "absolute",
          zIndex: 1,
          display: "block"
        }, roundedArrow(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBg, boxShadowPopoverArrow)), {
          "&:before": {
            background: colorBg
          }
        })],
        // ========================== Placement ==========================
        // Here handle the arrow position and rotate stuff
        // >>>>> Top
        [[`&-placement-top ${componentCls}-arrow`, `&-placement-topLeft ${componentCls}-arrow`, `&-placement-topRight ${componentCls}-arrow`].join(",")]: {
          bottom: 0,
          transform: "translateY(100%) rotate(180deg)"
        },
        [`&-placement-top ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateX(-50%) translateY(100%) rotate(180deg)"
        },
        [`&-placement-topLeft ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        },
        [`&-placement-topRight ${componentCls}-arrow`]: {
          right: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        },
        // >>>>> Bottom
        [[`&-placement-bottom ${componentCls}-arrow`, `&-placement-bottomLeft ${componentCls}-arrow`, `&-placement-bottomRight ${componentCls}-arrow`].join(",")]: {
          top: 0,
          transform: `translateY(-100%)`
        },
        [`&-placement-bottom ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: `translateX(-50%) translateY(-100%)`
        },
        [`&-placement-bottomLeft ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        },
        [`&-placement-bottomRight ${componentCls}-arrow`]: {
          right: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        },
        // >>>>> Left
        [[`&-placement-left ${componentCls}-arrow`, `&-placement-leftTop ${componentCls}-arrow`, `&-placement-leftBottom ${componentCls}-arrow`].join(",")]: {
          right: {
            _skip_check_: true,
            value: 0
          },
          transform: "translateX(100%) rotate(90deg)"
        },
        [`&-placement-left ${componentCls}-arrow`]: {
          top: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateY(-50%) translateX(100%) rotate(90deg)"
        },
        [`&-placement-leftTop ${componentCls}-arrow`]: {
          top: dropdownArrowOffsetVertical
        },
        [`&-placement-leftBottom ${componentCls}-arrow`]: {
          bottom: dropdownArrowOffsetVertical
        },
        // >>>>> Right
        [[`&-placement-right ${componentCls}-arrow`, `&-placement-rightTop ${componentCls}-arrow`, `&-placement-rightBottom ${componentCls}-arrow`].join(",")]: {
          left: {
            _skip_check_: true,
            value: 0
          },
          transform: "translateX(-100%) rotate(-90deg)"
        },
        [`&-placement-right ${componentCls}-arrow`]: {
          top: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
        },
        [`&-placement-rightTop ${componentCls}-arrow`]: {
          top: dropdownArrowOffsetVertical
        },
        [`&-placement-rightBottom ${componentCls}-arrow`]: {
          bottom: dropdownArrowOffsetVertical
        },
        // =========================== Offset ============================
        // Offset the popover to account for the dropdown arrow
        // >>>>> Top
        [connectArrowCls([`&-placement-topLeft`, `&-placement-top`, `&-placement-topRight`], showArrowCls)]: {
          paddingBottom: dropdownArrowDistance
        },
        // >>>>> Bottom
        [connectArrowCls([`&-placement-bottomLeft`, `&-placement-bottom`, `&-placement-bottomRight`], showArrowCls)]: {
          paddingTop: dropdownArrowDistance
        },
        // >>>>> Left
        [connectArrowCls([`&-placement-leftTop`, `&-placement-left`, `&-placement-leftBottom`], showArrowCls)]: {
          paddingRight: {
            _skip_check_: true,
            value: dropdownArrowDistance
          }
        },
        // >>>>> Right
        [connectArrowCls([`&-placement-rightTop`, `&-placement-right`, `&-placement-rightBottom`], showArrowCls)]: {
          paddingLeft: {
            _skip_check_: true,
            value: dropdownArrowDistance
          }
        }
      }
    };
  }
  const genTooltipStyle = (token2) => {
    const {
      componentCls,
      // ant-tooltip
      tooltipMaxWidth,
      tooltipColor,
      tooltipBg,
      tooltipBorderRadius,
      zIndexPopup,
      controlHeight,
      boxShadowSecondary,
      paddingSM,
      paddingXS,
      tooltipRadiusOuter
    } = token2;
    return [
      {
        [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
          position: "absolute",
          zIndex: zIndexPopup,
          display: "block",
          "&": [{
            width: "max-content"
          }, {
            width: "intrinsic"
          }],
          maxWidth: tooltipMaxWidth,
          visibility: "visible",
          "&-hidden": {
            display: "none"
          },
          "--antd-arrow-background-color": tooltipBg,
          // Wrapper for the tooltip content
          [`${componentCls}-inner`]: {
            minWidth: controlHeight,
            minHeight: controlHeight,
            padding: `${paddingSM / 2}px ${paddingXS}px`,
            color: tooltipColor,
            textAlign: "start",
            textDecoration: "none",
            wordWrap: "break-word",
            backgroundColor: tooltipBg,
            borderRadius: tooltipBorderRadius,
            boxShadow: boxShadowSecondary
          },
          // Limit left and right placement radius
          [[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(",")]: {
            [`${componentCls}-inner`]: {
              borderRadius: Math.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
            }
          },
          [`${componentCls}-content`]: {
            position: "relative"
          }
        }), genPresetColor(token2, (colorKey, _ref) => {
          let {
            darkColor
          } = _ref;
          return {
            [`&${componentCls}-${colorKey}`]: {
              [`${componentCls}-inner`]: {
                backgroundColor: darkColor
              },
              [`${componentCls}-arrow`]: {
                "--antd-arrow-background-color": darkColor
              }
            }
          };
        })), {
          // RTL
          "&-rtl": {
            direction: "rtl"
          }
        })
      },
      // Arrow Style
      getArrowStyle(merge(token2, {
        borderRadiusOuter: tooltipRadiusOuter
      }), {
        colorBg: "var(--antd-arrow-background-color)",
        showArrowCls: "",
        contentRadius: tooltipBorderRadius,
        limitVerticalRadius: true
      }),
      // Pure Render
      {
        [`${componentCls}-pure`]: {
          position: "relative",
          maxWidth: "none"
        }
      }
    ];
  };
  const useStyle$b = (prefixCls, injectStyle) => {
    const useOriginHook = genComponentStyleHook("Tooltip", (token2) => {
      if ((injectStyle === null || injectStyle === void 0 ? void 0 : injectStyle.value) === false) {
        return [];
      }
      const {
        borderRadius,
        colorTextLightSolid,
        colorBgDefault,
        borderRadiusOuter
      } = token2;
      const TooltipToken = merge(token2, {
        // default variables
        tooltipMaxWidth: 250,
        tooltipColor: colorTextLightSolid,
        tooltipBorderRadius: borderRadius,
        tooltipBg: colorBgDefault,
        tooltipRadiusOuter: borderRadiusOuter > 4 ? 4 : borderRadiusOuter
      });
      return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
    }, (_ref2) => {
      let {
        zIndexPopupBase,
        colorBgSpotlight
      } = _ref2;
      return {
        zIndexPopup: zIndexPopupBase + 70,
        colorBgDefault: colorBgSpotlight
      };
    });
    return useOriginHook(prefixCls);
  };
  const splitObject = (obj, keys2) => {
    const picked = {};
    const omitted = _extends$1({}, obj);
    keys2.forEach((key2) => {
      if (obj && key2 in obj) {
        picked[key2] = obj[key2];
        delete omitted[key2];
      }
    });
    return {
      picked,
      omitted
    };
  };
  const tooltipProps = () => _extends$1(_extends$1({}, abstractTooltipProps()), {
    title: PropTypes.any
  });
  const tooltipDefaultProps = () => ({
    trigger: "hover",
    align: {},
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: false,
    autoAdjustOverflow: true
  });
  const ToolTip = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ATooltip",
    inheritAttrs: false,
    props: initDefaultProps(tooltipProps(), {
      trigger: "hover",
      align: {},
      placement: "top",
      mouseEnterDelay: 0.1,
      mouseLeaveDelay: 0.1,
      arrowPointAtCenter: false,
      autoAdjustOverflow: true
    }),
    slots: Object,
    // emits: ['update:visible', 'visibleChange'],
    setup(props, _ref) {
      let {
        slots,
        emit: emit2,
        attrs,
        expose
      } = _ref;
      {
        [["visible", "open"], ["onVisibleChange", "onOpenChange"]].forEach((_ref2) => {
          let [deprecatedName, newName] = _ref2;
          warning$3(props[deprecatedName] === void 0, "Tooltip", `\`${deprecatedName}\` is deprecated, please use \`${newName}\` instead.`);
        });
      }
      const {
        prefixCls,
        getPopupContainer,
        direction,
        rootPrefixCls
      } = useConfigInject("tooltip", props);
      const mergedOpen = computed(() => {
        var _a2;
        return (_a2 = props.open) !== null && _a2 !== void 0 ? _a2 : props.visible;
      });
      const innerOpen = ref(firstNotUndefined([props.open, props.visible]));
      const tooltip = ref();
      let rafId;
      watch(mergedOpen, (val) => {
        wrapperRaf.cancel(rafId);
        rafId = wrapperRaf(() => {
          innerOpen.value = !!val;
        });
      });
      const isNoTitle = () => {
        var _a2;
        const title = (_a2 = props.title) !== null && _a2 !== void 0 ? _a2 : slots.title;
        return !title && title !== 0;
      };
      const handleVisibleChange = (val) => {
        const noTitle = isNoTitle();
        if (mergedOpen.value === void 0) {
          innerOpen.value = noTitle ? false : val;
        }
        if (!noTitle) {
          emit2("update:visible", val);
          emit2("visibleChange", val);
          emit2("update:open", val);
          emit2("openChange", val);
        }
      };
      const getPopupDomNode = () => {
        return tooltip.value.getPopupDomNode();
      };
      expose({
        getPopupDomNode,
        open: innerOpen,
        forcePopupAlign: () => {
          var _a2;
          return (_a2 = tooltip.value) === null || _a2 === void 0 ? void 0 : _a2.forcePopupAlign();
        }
      });
      const tooltipPlacements = computed(() => {
        const {
          builtinPlacements,
          arrowPointAtCenter,
          autoAdjustOverflow: autoAdjustOverflow2
        } = props;
        return builtinPlacements || getPlacements({
          arrowPointAtCenter,
          autoAdjustOverflow: autoAdjustOverflow2
        });
      });
      const isTrueProps = (val) => {
        return val || val === "";
      };
      const getDisabledCompatibleChildren = (ele) => {
        const elementType = ele.type;
        if (typeof elementType === "object" && ele.props) {
          if ((elementType.__ANT_BUTTON === true || elementType === "button") && isTrueProps(ele.props.disabled) || elementType.__ANT_SWITCH === true && (isTrueProps(ele.props.disabled) || isTrueProps(ele.props.loading)) || elementType.__ANT_RADIO === true && isTrueProps(ele.props.disabled)) {
            const {
              picked,
              omitted
            } = splitObject(getStyle$2(ele), ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]);
            const spanStyle = _extends$1(_extends$1({
              display: "inline-block"
            }, picked), {
              cursor: "not-allowed",
              lineHeight: 1,
              width: ele.props && ele.props.block ? "100%" : void 0
            });
            const buttonStyle = _extends$1(_extends$1({}, omitted), {
              pointerEvents: "none"
            });
            const child = cloneElement(ele, {
              style: buttonStyle
            }, true);
            return createVNode("span", {
              "style": spanStyle,
              "class": `${prefixCls.value}-disabled-compatible-wrapper`
            }, [child]);
          }
        }
        return ele;
      };
      const getOverlay = () => {
        var _a2, _b;
        return (_a2 = props.title) !== null && _a2 !== void 0 ? _a2 : (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots);
      };
      const onPopupAlign = (domNode, align) => {
        const placements2 = tooltipPlacements.value;
        const placement = Object.keys(placements2).find((key2) => {
          var _a2, _b;
          return placements2[key2].points[0] === ((_a2 = align.points) === null || _a2 === void 0 ? void 0 : _a2[0]) && placements2[key2].points[1] === ((_b = align.points) === null || _b === void 0 ? void 0 : _b[1]);
        });
        if (placement) {
          const rect = domNode.getBoundingClientRect();
          const transformOrigin = {
            top: "50%",
            left: "50%"
          };
          if (placement.indexOf("top") >= 0 || placement.indexOf("Bottom") >= 0) {
            transformOrigin.top = `${rect.height - align.offset[1]}px`;
          } else if (placement.indexOf("Top") >= 0 || placement.indexOf("bottom") >= 0) {
            transformOrigin.top = `${-align.offset[1]}px`;
          }
          if (placement.indexOf("left") >= 0 || placement.indexOf("Right") >= 0) {
            transformOrigin.left = `${rect.width - align.offset[0]}px`;
          } else if (placement.indexOf("right") >= 0 || placement.indexOf("Left") >= 0) {
            transformOrigin.left = `${-align.offset[0]}px`;
          }
          domNode.style.transformOrigin = `${transformOrigin.left} ${transformOrigin.top}`;
        }
      };
      const colorInfo = computed(() => parseColor(prefixCls.value, props.color));
      const injectFromPopover = computed(() => attrs["data-popover-inject"]);
      const [wrapSSR, hashId] = useStyle$b(prefixCls, computed(() => !injectFromPopover.value));
      return () => {
        var _a2, _b;
        const {
          openClassName,
          overlayClassName,
          overlayStyle,
          overlayInnerStyle
        } = props;
        let children = (_b = filterEmpty((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots))) !== null && _b !== void 0 ? _b : null;
        children = children.length === 1 ? children[0] : children;
        let tempVisible = innerOpen.value;
        if (mergedOpen.value === void 0 && isNoTitle()) {
          tempVisible = false;
        }
        if (!children) {
          return null;
        }
        const child = getDisabledCompatibleChildren(isValidElement(children) && !isFragment(children) ? children : createVNode("span", null, [children]));
        const childCls = classNames({
          [openClassName || `${prefixCls.value}-open`]: true,
          [child.props && child.props.class]: child.props && child.props.class
        });
        const customOverlayClassName = classNames(overlayClassName, {
          [`${prefixCls.value}-rtl`]: direction.value === "rtl"
        }, colorInfo.value.className, hashId.value);
        const formattedOverlayInnerStyle = _extends$1(_extends$1({}, colorInfo.value.overlayStyle), overlayInnerStyle);
        const arrowContentStyle = colorInfo.value.arrowStyle;
        const vcTooltipProps = _extends$1(_extends$1(_extends$1({}, attrs), props), {
          prefixCls: prefixCls.value,
          getPopupContainer: getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value,
          builtinPlacements: tooltipPlacements.value,
          visible: tempVisible,
          ref: tooltip,
          overlayClassName: customOverlayClassName,
          overlayStyle: _extends$1(_extends$1({}, arrowContentStyle), overlayStyle),
          overlayInnerStyle: formattedOverlayInnerStyle,
          onVisibleChange: handleVisibleChange,
          onPopupAlign,
          transitionName: getTransitionName(rootPrefixCls.value, "zoom-big-fast", props.transitionName)
        });
        return wrapSSR(createVNode(Tooltip$1, vcTooltipProps, {
          default: () => [innerOpen.value ? cloneElement(child, {
            class: childCls
          }) : child],
          arrowContent: () => createVNode("span", {
            "class": `${prefixCls.value}-arrow-content`
          }, null),
          overlay: getOverlay
        }));
      };
    }
  });
  const Tooltip = withInstall(ToolTip);
  const genBaseStyle$1 = (token2) => {
    const {
      componentCls,
      popoverBg,
      popoverColor,
      width,
      fontWeightStrong,
      popoverPadding,
      boxShadowSecondary,
      colorTextHeading,
      borderRadiusLG: borderRadius,
      zIndexPopup,
      marginXS,
      colorBgElevated
    } = token2;
    return [
      {
        [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
          position: "absolute",
          top: 0,
          // use `left` to fix https://github.com/ant-design/ant-design/issues/39195
          left: {
            _skip_check_: true,
            value: 0
          },
          zIndex: zIndexPopup,
          fontWeight: "normal",
          whiteSpace: "normal",
          textAlign: "start",
          cursor: "auto",
          userSelect: "text",
          "--antd-arrow-background-color": colorBgElevated,
          "&-rtl": {
            direction: "rtl"
          },
          "&-hidden": {
            display: "none"
          },
          [`${componentCls}-content`]: {
            position: "relative"
          },
          [`${componentCls}-inner`]: {
            backgroundColor: popoverBg,
            backgroundClip: "padding-box",
            borderRadius,
            boxShadow: boxShadowSecondary,
            padding: popoverPadding
          },
          [`${componentCls}-title`]: {
            minWidth: width,
            marginBottom: marginXS,
            color: colorTextHeading,
            fontWeight: fontWeightStrong
          },
          [`${componentCls}-inner-content`]: {
            color: popoverColor
          }
        })
      },
      // Arrow Style
      getArrowStyle(token2, {
        colorBg: "var(--antd-arrow-background-color)"
      }),
      // Pure Render
      {
        [`${componentCls}-pure`]: {
          position: "relative",
          maxWidth: "none",
          [`${componentCls}-content`]: {
            display: "inline-block"
          }
        }
      }
    ];
  };
  const genColorStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: PresetColors.map((colorKey) => {
        const lightColor = token2[`${colorKey}-6`];
        return {
          [`&${componentCls}-${colorKey}`]: {
            "--antd-arrow-background-color": lightColor,
            [`${componentCls}-inner`]: {
              backgroundColor: lightColor
            },
            [`${componentCls}-arrow`]: {
              background: "transparent"
            }
          }
        };
      })
    };
  };
  const genWireframeStyle$1 = (token2) => {
    const {
      componentCls,
      lineWidth,
      lineType,
      colorSplit,
      paddingSM,
      controlHeight,
      fontSize,
      lineHeight,
      padding
    } = token2;
    const titlePaddingBlockDist = controlHeight - Math.round(fontSize * lineHeight);
    const popoverTitlePaddingBlockTop = titlePaddingBlockDist / 2;
    const popoverTitlePaddingBlockBottom = titlePaddingBlockDist / 2 - lineWidth;
    const popoverPaddingHorizontal = padding;
    return {
      [componentCls]: {
        [`${componentCls}-inner`]: {
          padding: 0
        },
        [`${componentCls}-title`]: {
          margin: 0,
          padding: `${popoverTitlePaddingBlockTop}px ${popoverPaddingHorizontal}px ${popoverTitlePaddingBlockBottom}px`,
          borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`
        },
        [`${componentCls}-inner-content`]: {
          padding: `${paddingSM}px ${popoverPaddingHorizontal}px`
        }
      }
    };
  };
  const useStyle$a = genComponentStyleHook("Popover", (token2) => {
    const {
      colorBgElevated,
      colorText,
      wireframe
    } = token2;
    const popoverToken = merge(token2, {
      popoverBg: colorBgElevated,
      popoverColor: colorText,
      popoverPadding: 12
      // Fixed Value
    });
    return [genBaseStyle$1(popoverToken), genColorStyle(popoverToken), wireframe && genWireframeStyle$1(popoverToken), initZoomMotion(popoverToken, "zoom-big")];
  }, (_ref) => {
    let {
      zIndexPopupBase
    } = _ref;
    return {
      zIndexPopup: zIndexPopupBase + 30,
      width: 177
    };
  });
  const popoverProps = () => _extends$1(_extends$1({}, abstractTooltipProps()), {
    content: anyType(),
    title: anyType()
  });
  const Popover = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "APopover",
    inheritAttrs: false,
    props: initDefaultProps(popoverProps(), _extends$1(_extends$1({}, tooltipDefaultProps()), {
      trigger: "hover",
      placement: "top",
      mouseEnterDelay: 0.1,
      mouseLeaveDelay: 0.1
    })),
    setup(props, _ref) {
      let {
        expose,
        slots,
        attrs
      } = _ref;
      const tooltipRef = ref();
      warning$3(props.visible === void 0, "popover", `\`visible\` will be removed in next major version, please use \`open\` instead.`);
      expose({
        getPopupDomNode: () => {
          var _a2, _b;
          return (_b = (_a2 = tooltipRef.value) === null || _a2 === void 0 ? void 0 : _a2.getPopupDomNode) === null || _b === void 0 ? void 0 : _b.call(_a2);
        }
      });
      const {
        prefixCls,
        configProvider
      } = useConfigInject("popover", props);
      const [wrapSSR, hashId] = useStyle$a(prefixCls);
      const rootPrefixCls = computed(() => configProvider.getPrefixCls());
      const getOverlay = () => {
        var _a2, _b;
        const {
          title = filterEmpty((_a2 = slots.title) === null || _a2 === void 0 ? void 0 : _a2.call(slots)),
          content = filterEmpty((_b = slots.content) === null || _b === void 0 ? void 0 : _b.call(slots))
        } = props;
        const hasTitle = !!(Array.isArray(title) ? title.length : title);
        const hasContent = !!(Array.isArray(content) ? content.length : title);
        if (!hasTitle && !hasContent)
          return null;
        return createVNode(Fragment, null, [hasTitle && createVNode("div", {
          "class": `${prefixCls.value}-title`
        }, [title]), createVNode("div", {
          "class": `${prefixCls.value}-inner-content`
        }, [content])]);
      };
      return () => {
        const overlayCls = classNames(props.overlayClassName, hashId.value);
        return wrapSSR(createVNode(Tooltip, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, omit$1(props, ["title", "content"])), attrs), {}, {
          "prefixCls": prefixCls.value,
          "ref": tooltipRef,
          "overlayClassName": overlayCls,
          "transitionName": getTransitionName(rootPrefixCls.value, "zoom-big", props.transitionName),
          "data-popover-inject": true
        }), {
          title: getOverlay,
          default: slots.default
        }));
      };
    }
  });
  const Popover$1 = withInstall(Popover);
  const genWaveStyle = (token2) => {
    const {
      componentCls,
      colorPrimary
    } = token2;
    return {
      [componentCls]: {
        position: "absolute",
        background: "transparent",
        pointerEvents: "none",
        boxSizing: "border-box",
        color: `var(--wave-color, ${colorPrimary})`,
        boxShadow: `0 0 0 0 currentcolor`,
        opacity: 0.2,
        // =================== Motion ===================
        "&.wave-motion-appear": {
          transition: [`box-shadow 0.4s ${token2.motionEaseOutCirc}`, `opacity 2s ${token2.motionEaseOutCirc}`].join(","),
          "&-active": {
            boxShadow: `0 0 0 6px currentcolor`,
            opacity: 0
          }
        }
      }
    };
  };
  const useStyle$9 = genComponentStyleHook("Wave", (token2) => [genWaveStyle(token2)]);
  function isNotGrey(color) {
    const match2 = (color || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
    if (match2 && match2[1] && match2[2] && match2[3]) {
      return !(match2[1] === match2[2] && match2[2] === match2[3]);
    }
    return true;
  }
  function isValidWaveColor(color) {
    return color && color !== "#fff" && color !== "#ffffff" && color !== "rgb(255, 255, 255)" && color !== "rgba(255, 255, 255, 1)" && isNotGrey(color) && !/rgba\((?:\d*, ){3}0\)/.test(color) && // any transparent rgba color
    color !== "transparent";
  }
  function getTargetWaveColor(node2) {
    const {
      borderTopColor,
      borderColor,
      backgroundColor
    } = getComputedStyle(node2);
    if (isValidWaveColor(borderTopColor)) {
      return borderTopColor;
    }
    if (isValidWaveColor(borderColor)) {
      return borderColor;
    }
    if (isValidWaveColor(backgroundColor)) {
      return backgroundColor;
    }
    return null;
  }
  function validateNum(value) {
    return Number.isNaN(value) ? 0 : value;
  }
  const WaveEffect = /* @__PURE__ */ defineComponent({
    props: {
      target: objectType(),
      className: String
    },
    setup(props) {
      const divRef = shallowRef(null);
      const [color, setWaveColor] = useState(null);
      const [borderRadius, setBorderRadius] = useState([]);
      const [left, setLeft] = useState(0);
      const [top, setTop] = useState(0);
      const [width, setWidth] = useState(0);
      const [height, setHeight] = useState(0);
      const [enabled, setEnabled] = useState(false);
      function syncPos() {
        const {
          target
        } = props;
        const nodeStyle = getComputedStyle(target);
        setWaveColor(getTargetWaveColor(target));
        const isStatic = nodeStyle.position === "static";
        const {
          borderLeftWidth,
          borderTopWidth
        } = nodeStyle;
        setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth)));
        setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth)));
        setWidth(target.offsetWidth);
        setHeight(target.offsetHeight);
        const {
          borderTopLeftRadius,
          borderTopRightRadius,
          borderBottomLeftRadius,
          borderBottomRightRadius
        } = nodeStyle;
        setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius) => validateNum(parseFloat(radius))));
      }
      let resizeObserver;
      let rafId;
      let timeoutId;
      const clear2 = () => {
        clearTimeout(timeoutId);
        wrapperRaf.cancel(rafId);
        resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect();
      };
      const removeDom = () => {
        var _a2;
        const holder = (_a2 = divRef.value) === null || _a2 === void 0 ? void 0 : _a2.parentElement;
        if (holder) {
          render(null, holder);
          if (holder.parentElement) {
            holder.parentElement.removeChild(holder);
          }
        }
      };
      onMounted(() => {
        clear2();
        timeoutId = setTimeout(() => {
          removeDom();
        }, 5e3);
        const {
          target
        } = props;
        if (target) {
          rafId = wrapperRaf(() => {
            syncPos();
            setEnabled(true);
          });
          if (typeof ResizeObserver !== "undefined") {
            resizeObserver = new ResizeObserver(syncPos);
            resizeObserver.observe(target);
          }
        }
      });
      onBeforeUnmount(() => {
        clear2();
      });
      const onTransitionend = (e2) => {
        if (e2.propertyName === "opacity") {
          removeDom();
        }
      };
      return () => {
        if (!enabled.value) {
          return null;
        }
        const waveStyle = {
          left: `${left.value}px`,
          top: `${top.value}px`,
          width: `${width.value}px`,
          height: `${height.value}px`,
          borderRadius: borderRadius.value.map((radius) => `${radius}px`).join(" ")
        };
        if (color) {
          waveStyle["--wave-color"] = color.value;
        }
        return createVNode(Transition, {
          "appear": true,
          "name": "wave-motion",
          "appearFromClass": "wave-motion-appear",
          "appearActiveClass": "wave-motion-appear",
          "appearToClass": "wave-motion-appear wave-motion-appear-active"
        }, {
          default: () => [createVNode("div", {
            "ref": divRef,
            "class": props.className,
            "style": waveStyle,
            "onTransitionend": onTransitionend
          }, null)]
        });
      };
    }
  });
  function showWaveEffect(node2, className) {
    const holder = document.createElement("div");
    holder.style.position = "absolute";
    holder.style.left = `0px`;
    holder.style.top = `0px`;
    node2 === null || node2 === void 0 ? void 0 : node2.insertBefore(holder, node2 === null || node2 === void 0 ? void 0 : node2.firstChild);
    render(createVNode(WaveEffect, {
      "target": node2,
      "className": className
    }, null), holder);
  }
  function useWave(instance, className, wave) {
    function showWave() {
      var _a2;
      const node2 = findDOMNode(instance);
      if (((_a2 = wave === null || wave === void 0 ? void 0 : wave.value) === null || _a2 === void 0 ? void 0 : _a2.disabled) || !node2) {
        return;
      }
      showWaveEffect(node2, className.value);
    }
    return showWave;
  }
  const Wave = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Wave",
    props: {
      disabled: Boolean
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const instance = getCurrentInstance();
      const {
        prefixCls,
        wave
      } = useConfigInject("wave", props);
      const [, hashId] = useStyle$9(prefixCls);
      const showWave = useWave(instance, computed(() => classNames(prefixCls.value, hashId.value)), wave);
      let onClick;
      const clear2 = () => {
        const node2 = findDOMNode(instance);
        node2.removeEventListener("click", onClick, true);
      };
      onMounted(() => {
        watch(() => props.disabled, () => {
          clear2();
          nextTick(() => {
            const node2 = findDOMNode(instance);
            node2 === null || node2 === void 0 ? void 0 : node2.removeEventListener("click", onClick, true);
            if (!node2 || node2.nodeType !== 1 || props.disabled) {
              return;
            }
            onClick = (e2) => {
              if (e2.target.tagName === "INPUT" || !isVisible(e2.target) || // No need wave
              !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") || node2.className.includes("-leave")) {
                return;
              }
              showWave();
            };
            node2.addEventListener("click", onClick, true);
          });
        }, {
          immediate: true,
          flush: "post"
        });
      });
      onBeforeUnmount(() => {
        clear2();
      });
      return () => {
        var _a2;
        const children = (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)[0];
        return children;
      };
    }
  });
  function convertLegacyProps(type4) {
    if (type4 === "danger") {
      return {
        danger: true
      };
    }
    return {
      type: type4
    };
  }
  const buttonProps = () => ({
    prefixCls: String,
    type: String,
    htmlType: {
      type: String,
      default: "button"
    },
    shape: {
      type: String
    },
    size: {
      type: String
    },
    loading: {
      type: [Boolean, Object],
      default: () => false
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    ghost: {
      type: Boolean,
      default: void 0
    },
    block: {
      type: Boolean,
      default: void 0
    },
    danger: {
      type: Boolean,
      default: void 0
    },
    icon: PropTypes.any,
    href: String,
    target: String,
    title: String,
    onClick: eventType(),
    onMousedown: eventType()
  });
  const getCollapsedWidth = (node2) => {
    if (node2) {
      node2.style.width = "0px";
      node2.style.opacity = "0";
      node2.style.transform = "scale(0)";
    }
  };
  const getRealWidth = (node2) => {
    nextTick(() => {
      if (node2) {
        node2.style.width = `${node2.scrollWidth}px`;
        node2.style.opacity = "1";
        node2.style.transform = "scale(1)";
      }
    });
  };
  const resetStyle = (node2) => {
    if (node2 && node2.style) {
      node2.style.width = null;
      node2.style.opacity = null;
      node2.style.transform = null;
    }
  };
  const LoadingIcon = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "LoadingIcon",
    props: {
      prefixCls: String,
      loading: [Boolean, Object],
      existIcon: Boolean
    },
    setup(props) {
      return () => {
        const {
          existIcon,
          prefixCls,
          loading
        } = props;
        if (existIcon) {
          return createVNode("span", {
            "class": `${prefixCls}-loading-icon`
          }, [createVNode(LoadingOutlined$1, null, null)]);
        }
        const visible = !!loading;
        return createVNode(Transition, {
          "name": `${prefixCls}-loading-icon-motion`,
          "onBeforeEnter": getCollapsedWidth,
          "onEnter": getRealWidth,
          "onAfterEnter": resetStyle,
          "onBeforeLeave": getRealWidth,
          "onLeave": (node2) => {
            setTimeout(() => {
              getCollapsedWidth(node2);
            });
          },
          "onAfterLeave": resetStyle
        }, {
          default: () => [visible ? createVNode("span", {
            "class": `${prefixCls}-loading-icon`
          }, [createVNode(LoadingOutlined$1, null, null)]) : null]
        });
      };
    }
  });
  const genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
    // Border
    [`> span, > ${buttonTypeCls}`]: {
      "&:not(:last-child)": {
        [`&, & > ${buttonTypeCls}`]: {
          "&:not(:disabled)": {
            borderInlineEndColor: borderColor
          }
        }
      },
      "&:not(:first-child)": {
        [`&, & > ${buttonTypeCls}`]: {
          "&:not(:disabled)": {
            borderInlineStartColor: borderColor
          }
        }
      }
    }
  });
  const genGroupStyle$1 = (token2) => {
    const {
      componentCls,
      fontSize,
      lineWidth,
      colorPrimaryHover,
      colorErrorHover
    } = token2;
    return {
      [`${componentCls}-group`]: [
        {
          position: "relative",
          display: "inline-flex",
          // Border
          [`> span, > ${componentCls}`]: {
            "&:not(:last-child)": {
              [`&, & > ${componentCls}`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
              }
            },
            "&:not(:first-child)": {
              marginInlineStart: -lineWidth,
              [`&, & > ${componentCls}`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0
              }
            }
          },
          [componentCls]: {
            position: "relative",
            zIndex: 1,
            [`&:hover,
          &:focus,
          &:active`]: {
              zIndex: 2
            },
            "&[disabled]": {
              zIndex: 0
            }
          },
          [`${componentCls}-icon-only`]: {
            fontSize
          }
        },
        // Border Color
        genButtonBorderStyle(`${componentCls}-primary`, colorPrimaryHover),
        genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
      ]
    };
  };
  const genGroupStyle$2 = genGroupStyle$1;
  function compactItemVerticalBorder(token2, parentCls) {
    return {
      // border collapse
      [`&-item:not(${parentCls}-last-item)`]: {
        marginBottom: -token2.lineWidth
      },
      "&-item": {
        "&:hover,&:focus,&:active": {
          zIndex: 2
        },
        "&[disabled]": {
          zIndex: 0
        }
      }
    };
  }
  function compactItemBorderVerticalRadius(prefixCls, parentCls) {
    return {
      [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
        borderRadius: 0
      },
      [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
        [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
          borderEndEndRadius: 0,
          borderEndStartRadius: 0
        }
      },
      [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
        [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
          borderStartStartRadius: 0,
          borderStartEndRadius: 0
        }
      }
    };
  }
  function genCompactItemVerticalStyle(token2) {
    const compactCls = `${token2.componentCls}-compact-vertical`;
    return {
      [compactCls]: _extends$1(_extends$1({}, compactItemVerticalBorder(token2, compactCls)), compactItemBorderVerticalRadius(token2.componentCls, compactCls))
    };
  }
  const genSharedButtonStyle = (token2) => {
    const {
      componentCls,
      iconCls
    } = token2;
    return {
      [componentCls]: {
        outline: "none",
        position: "relative",
        display: "inline-block",
        fontWeight: 400,
        whiteSpace: "nowrap",
        textAlign: "center",
        backgroundImage: "none",
        backgroundColor: "transparent",
        border: `${token2.lineWidth}px ${token2.lineType} transparent`,
        cursor: "pointer",
        transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
        userSelect: "none",
        touchAction: "manipulation",
        lineHeight: token2.lineHeight,
        color: token2.colorText,
        "> span": {
          display: "inline-block"
        },
        // Leave a space between icon and text.
        [`> ${iconCls} + span, > span + ${iconCls}`]: {
          marginInlineStart: token2.marginXS
        },
        "> a": {
          color: "currentColor"
        },
        "&:not(:disabled)": _extends$1({}, genFocusStyle(token2)),
        // make `btn-icon-only` not too narrow
        [`&-icon-only${componentCls}-compact-item`]: {
          flex: "none"
        },
        // Special styles for Primary Button
        [`&-compact-item${componentCls}-primary`]: {
          [`&:not([disabled]) + ${componentCls}-compact-item${componentCls}-primary:not([disabled])`]: {
            position: "relative",
            "&:before": {
              position: "absolute",
              top: -token2.lineWidth,
              insetInlineStart: -token2.lineWidth,
              display: "inline-block",
              width: token2.lineWidth,
              height: `calc(100% + ${token2.lineWidth * 2}px)`,
              backgroundColor: token2.colorPrimaryHover,
              content: '""'
            }
          }
        },
        // Special styles for Primary Button
        "&-compact-vertical-item": {
          [`&${componentCls}-primary`]: {
            [`&:not([disabled]) + ${componentCls}-compact-vertical-item${componentCls}-primary:not([disabled])`]: {
              position: "relative",
              "&:before": {
                position: "absolute",
                top: -token2.lineWidth,
                insetInlineStart: -token2.lineWidth,
                display: "inline-block",
                width: `calc(100% + ${token2.lineWidth * 2}px)`,
                height: token2.lineWidth,
                backgroundColor: token2.colorPrimaryHover,
                content: '""'
              }
            }
          }
        }
      }
    };
  };
  const genHoverActiveButtonStyle = (hoverStyle, activeStyle) => ({
    "&:not(:disabled)": {
      "&:hover": hoverStyle,
      "&:active": activeStyle
    }
  });
  const genCircleButtonStyle = (token2) => ({
    minWidth: token2.controlHeight,
    paddingInlineStart: 0,
    paddingInlineEnd: 0,
    borderRadius: "50%"
  });
  const genRoundButtonStyle = (token2) => ({
    borderRadius: token2.controlHeight,
    paddingInlineStart: token2.controlHeight / 2,
    paddingInlineEnd: token2.controlHeight / 2
  });
  const genDisabledStyle$1 = (token2) => ({
    cursor: "not-allowed",
    borderColor: token2.colorBorder,
    color: token2.colorTextDisabled,
    backgroundColor: token2.colorBgContainerDisabled,
    boxShadow: "none"
  });
  const genGhostButtonStyle = (btnCls, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
    [`&${btnCls}-background-ghost`]: _extends$1(_extends$1({
      color: textColor || void 0,
      backgroundColor: "transparent",
      borderColor: borderColor || void 0,
      boxShadow: "none"
    }, genHoverActiveButtonStyle(_extends$1({
      backgroundColor: "transparent"
    }, hoverStyle), _extends$1({
      backgroundColor: "transparent"
    }, activeStyle))), {
      "&:disabled": {
        cursor: "not-allowed",
        color: textColorDisabled || void 0,
        borderColor: borderColorDisabled || void 0
      }
    })
  });
  const genSolidDisabledButtonStyle = (token2) => ({
    "&:disabled": _extends$1({}, genDisabledStyle$1(token2))
  });
  const genSolidButtonStyle = (token2) => _extends$1({}, genSolidDisabledButtonStyle(token2));
  const genPureDisabledButtonStyle = (token2) => ({
    "&:disabled": {
      cursor: "not-allowed",
      color: token2.colorTextDisabled
    }
  });
  const genDefaultButtonStyle = (token2) => _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, genSolidButtonStyle(token2)), {
    backgroundColor: token2.colorBgContainer,
    borderColor: token2.colorBorder,
    boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`
  }), genHoverActiveButtonStyle({
    color: token2.colorPrimaryHover,
    borderColor: token2.colorPrimaryHover
  }, {
    color: token2.colorPrimaryActive,
    borderColor: token2.colorPrimaryActive
  })), genGhostButtonStyle(token2.componentCls, token2.colorBgContainer, token2.colorBgContainer, token2.colorTextDisabled, token2.colorBorder)), {
    [`&${token2.componentCls}-dangerous`]: _extends$1(_extends$1(_extends$1({
      color: token2.colorError,
      borderColor: token2.colorError
    }, genHoverActiveButtonStyle({
      color: token2.colorErrorHover,
      borderColor: token2.colorErrorBorderHover
    }, {
      color: token2.colorErrorActive,
      borderColor: token2.colorErrorActive
    })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder)), genSolidDisabledButtonStyle(token2))
  });
  const genPrimaryButtonStyle = (token2) => _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, genSolidButtonStyle(token2)), {
    color: token2.colorTextLightSolid,
    backgroundColor: token2.colorPrimary,
    boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`
  }), genHoverActiveButtonStyle({
    color: token2.colorTextLightSolid,
    backgroundColor: token2.colorPrimaryHover
  }, {
    color: token2.colorTextLightSolid,
    backgroundColor: token2.colorPrimaryActive
  })), genGhostButtonStyle(token2.componentCls, token2.colorPrimary, token2.colorPrimary, token2.colorTextDisabled, token2.colorBorder, {
    color: token2.colorPrimaryHover,
    borderColor: token2.colorPrimaryHover
  }, {
    color: token2.colorPrimaryActive,
    borderColor: token2.colorPrimaryActive
  })), {
    [`&${token2.componentCls}-dangerous`]: _extends$1(_extends$1(_extends$1({
      backgroundColor: token2.colorError,
      boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`
    }, genHoverActiveButtonStyle({
      backgroundColor: token2.colorErrorHover
    }, {
      backgroundColor: token2.colorErrorActive
    })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder, {
      color: token2.colorErrorHover,
      borderColor: token2.colorErrorHover
    }, {
      color: token2.colorErrorActive,
      borderColor: token2.colorErrorActive
    })), genSolidDisabledButtonStyle(token2))
  });
  const genDashedButtonStyle = (token2) => _extends$1(_extends$1({}, genDefaultButtonStyle(token2)), {
    borderStyle: "dashed"
  });
  const genLinkButtonStyle = (token2) => _extends$1(_extends$1(_extends$1({
    color: token2.colorLink
  }, genHoverActiveButtonStyle({
    color: token2.colorLinkHover
  }, {
    color: token2.colorLinkActive
  })), genPureDisabledButtonStyle(token2)), {
    [`&${token2.componentCls}-dangerous`]: _extends$1(_extends$1({
      color: token2.colorError
    }, genHoverActiveButtonStyle({
      color: token2.colorErrorHover
    }, {
      color: token2.colorErrorActive
    })), genPureDisabledButtonStyle(token2))
  });
  const genTextButtonStyle = (token2) => _extends$1(_extends$1(_extends$1({}, genHoverActiveButtonStyle({
    color: token2.colorText,
    backgroundColor: token2.colorBgTextHover
  }, {
    color: token2.colorText,
    backgroundColor: token2.colorBgTextActive
  })), genPureDisabledButtonStyle(token2)), {
    [`&${token2.componentCls}-dangerous`]: _extends$1(_extends$1({
      color: token2.colorError
    }, genPureDisabledButtonStyle(token2)), genHoverActiveButtonStyle({
      color: token2.colorErrorHover,
      backgroundColor: token2.colorErrorBg
    }, {
      color: token2.colorErrorHover,
      backgroundColor: token2.colorErrorBg
    }))
  });
  const genDisabledButtonStyle = (token2) => _extends$1(_extends$1({}, genDisabledStyle$1(token2)), {
    [`&${token2.componentCls}:hover`]: _extends$1({}, genDisabledStyle$1(token2))
  });
  const genTypeButtonStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-default`]: genDefaultButtonStyle(token2),
      [`${componentCls}-primary`]: genPrimaryButtonStyle(token2),
      [`${componentCls}-dashed`]: genDashedButtonStyle(token2),
      [`${componentCls}-link`]: genLinkButtonStyle(token2),
      [`${componentCls}-text`]: genTextButtonStyle(token2),
      [`${componentCls}-disabled`]: genDisabledButtonStyle(token2)
    };
  };
  const genSizeButtonStyle = function(token2) {
    let sizePrefixCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const {
      componentCls,
      iconCls,
      controlHeight,
      fontSize,
      lineHeight,
      lineWidth,
      borderRadius,
      buttonPaddingHorizontal
    } = token2;
    const paddingVertical = Math.max(0, (controlHeight - fontSize * lineHeight) / 2 - lineWidth);
    const paddingHorizontal = buttonPaddingHorizontal - lineWidth;
    const iconOnlyCls = `${componentCls}-icon-only`;
    return [
      // Size
      {
        [`${componentCls}${sizePrefixCls}`]: {
          fontSize,
          height: controlHeight,
          padding: `${paddingVertical}px ${paddingHorizontal}px`,
          borderRadius,
          [`&${iconOnlyCls}`]: {
            width: controlHeight,
            paddingInlineStart: 0,
            paddingInlineEnd: 0,
            [`&${componentCls}-round`]: {
              width: "auto"
            },
            "> span": {
              transform: "scale(1.143)"
              // 14px -> 16px
            }
          },
          // Loading
          [`&${componentCls}-loading`]: {
            opacity: token2.opacityLoading,
            cursor: "default"
          },
          [`${componentCls}-loading-icon`]: {
            transition: `width ${token2.motionDurationSlow} ${token2.motionEaseInOut}, opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
          },
          [`&:not(${iconOnlyCls}) ${componentCls}-loading-icon > ${iconCls}`]: {
            marginInlineEnd: token2.marginXS
          }
        }
      },
      // Shape - patch prefixCls again to override solid border radius style
      {
        [`${componentCls}${componentCls}-circle${sizePrefixCls}`]: genCircleButtonStyle(token2)
      },
      {
        [`${componentCls}${componentCls}-round${sizePrefixCls}`]: genRoundButtonStyle(token2)
      }
    ];
  };
  const genSizeBaseButtonStyle = (token2) => genSizeButtonStyle(token2);
  const genSizeSmallButtonStyle = (token2) => {
    const smallToken = merge(token2, {
      controlHeight: token2.controlHeightSM,
      padding: token2.paddingXS,
      buttonPaddingHorizontal: 8,
      borderRadius: token2.borderRadiusSM
    });
    return genSizeButtonStyle(smallToken, `${token2.componentCls}-sm`);
  };
  const genSizeLargeButtonStyle = (token2) => {
    const largeToken = merge(token2, {
      controlHeight: token2.controlHeightLG,
      fontSize: token2.fontSizeLG,
      borderRadius: token2.borderRadiusLG
    });
    return genSizeButtonStyle(largeToken, `${token2.componentCls}-lg`);
  };
  const genBlockButtonStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: {
        [`&${componentCls}-block`]: {
          width: "100%"
        }
      }
    };
  };
  const useStyle$8 = genComponentStyleHook("Button", (token2) => {
    const {
      controlTmpOutline,
      paddingContentHorizontal
    } = token2;
    const buttonToken = merge(token2, {
      colorOutlineDefault: controlTmpOutline,
      buttonPaddingHorizontal: paddingContentHorizontal
    });
    return [
      // Shared
      genSharedButtonStyle(buttonToken),
      // Size
      genSizeSmallButtonStyle(buttonToken),
      genSizeBaseButtonStyle(buttonToken),
      genSizeLargeButtonStyle(buttonToken),
      // Block
      genBlockButtonStyle(buttonToken),
      // Group (type, ghost, danger, disabled, loading)
      genTypeButtonStyle(buttonToken),
      // Button Group
      genGroupStyle$2(buttonToken),
      // Space Compact
      genCompactItemStyle(token2, {
        focus: false
      }),
      genCompactItemVerticalStyle(token2)
    ];
  });
  const buttonGroupProps = () => ({
    prefixCls: String,
    size: {
      type: String
    }
  });
  const GroupSizeContext = createContext();
  const ButtonGroup = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AButtonGroup",
    props: buttonGroupProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const {
        prefixCls,
        direction
      } = useConfigInject("btn-group", props);
      const [, , hashId] = useToken();
      GroupSizeContext.useProvide(reactive({
        size: computed(() => props.size)
      }));
      const classes = computed(() => {
        const {
          size: size2
        } = props;
        let sizeCls = "";
        switch (size2) {
          case "large":
            sizeCls = "lg";
            break;
          case "small":
            sizeCls = "sm";
            break;
          case "middle":
          case void 0:
            break;
          default:
            devWarning(!size2, "Button.Group", "Invalid prop `size`.");
        }
        return {
          [`${prefixCls.value}`]: true,
          [`${prefixCls.value}-${sizeCls}`]: sizeCls,
          [`${prefixCls.value}-rtl`]: direction.value === "rtl",
          [hashId.value]: true
        };
      });
      return () => {
        var _a2;
        return createVNode("div", {
          "class": classes.value
        }, [flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots))]);
      };
    }
  });
  const rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
  const isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
  function isUnBorderedButtonType(type4) {
    return type4 === "text" || type4 === "link";
  }
  const Button = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AButton",
    inheritAttrs: false,
    __ANT_BUTTON: true,
    props: initDefaultProps(buttonProps(), {
      type: "default"
    }),
    slots: Object,
    // emits: ['click', 'mousedown'],
    setup(props, _ref) {
      let {
        slots,
        attrs,
        emit: emit2,
        expose
      } = _ref;
      const {
        prefixCls,
        autoInsertSpaceInButton,
        direction,
        size: size2
      } = useConfigInject("btn", props);
      const [wrapSSR, hashId] = useStyle$8(prefixCls);
      const groupSizeContext = GroupSizeContext.useInject();
      const disabledContext = useInjectDisabled();
      const mergedDisabled = computed(() => {
        var _a2;
        return (_a2 = props.disabled) !== null && _a2 !== void 0 ? _a2 : disabledContext.value;
      });
      const buttonNodeRef = shallowRef(null);
      const delayTimeoutRef = shallowRef(void 0);
      let isNeedInserted = false;
      const innerLoading = shallowRef(false);
      const hasTwoCNChar = shallowRef(false);
      const autoInsertSpace = computed(() => autoInsertSpaceInButton.value !== false);
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const loadingOrDelay = computed(() => typeof props.loading === "object" && props.loading.delay ? props.loading.delay || true : !!props.loading);
      watch(loadingOrDelay, (val) => {
        clearTimeout(delayTimeoutRef.value);
        if (typeof loadingOrDelay.value === "number") {
          delayTimeoutRef.value = setTimeout(() => {
            innerLoading.value = val;
          }, loadingOrDelay.value);
        } else {
          innerLoading.value = val;
        }
      }, {
        immediate: true
      });
      const classes = computed(() => {
        const {
          type: type4,
          shape = "default",
          ghost,
          block,
          danger
        } = props;
        const pre = prefixCls.value;
        const sizeClassNameMap = {
          large: "lg",
          small: "sm",
          middle: void 0
        };
        const sizeFullname = compactSize.value || (groupSizeContext === null || groupSizeContext === void 0 ? void 0 : groupSizeContext.size) || size2.value;
        const sizeCls = sizeFullname ? sizeClassNameMap[sizeFullname] || "" : "";
        return [compactItemClassnames.value, {
          [hashId.value]: true,
          [`${pre}`]: true,
          [`${pre}-${shape}`]: shape !== "default" && shape,
          [`${pre}-${type4}`]: type4,
          [`${pre}-${sizeCls}`]: sizeCls,
          [`${pre}-loading`]: innerLoading.value,
          [`${pre}-background-ghost`]: ghost && !isUnBorderedButtonType(type4),
          [`${pre}-two-chinese-chars`]: hasTwoCNChar.value && autoInsertSpace.value,
          [`${pre}-block`]: block,
          [`${pre}-dangerous`]: !!danger,
          [`${pre}-rtl`]: direction.value === "rtl"
        }];
      });
      const fixTwoCNChar = () => {
        const node2 = buttonNodeRef.value;
        if (!node2 || autoInsertSpaceInButton.value === false) {
          return;
        }
        const buttonText = node2.textContent;
        if (isNeedInserted && isTwoCNChar(buttonText)) {
          if (!hasTwoCNChar.value) {
            hasTwoCNChar.value = true;
          }
        } else if (hasTwoCNChar.value) {
          hasTwoCNChar.value = false;
        }
      };
      const handleClick = (event) => {
        if (innerLoading.value || mergedDisabled.value) {
          event.preventDefault();
          return;
        }
        emit2("click", event);
      };
      const handleMousedown = (event) => {
        emit2("mousedown", event);
      };
      const insertSpace = (child, needInserted) => {
        const SPACE = needInserted ? " " : "";
        if (child.type === Text) {
          let text = child.children.trim();
          if (isTwoCNChar(text)) {
            text = text.split("").join(SPACE);
          }
          return createVNode("span", null, [text]);
        }
        return child;
      };
      watchEffect(() => {
        devWarning(!(props.ghost && isUnBorderedButtonType(props.type)), "Button", "`link` or `text` button can't be a `ghost` button.");
      });
      onMounted(fixTwoCNChar);
      onUpdated(fixTwoCNChar);
      onBeforeUnmount(() => {
        delayTimeoutRef.value && clearTimeout(delayTimeoutRef.value);
      });
      const focus = () => {
        var _a2;
        (_a2 = buttonNodeRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      };
      const blur = () => {
        var _a2;
        (_a2 = buttonNodeRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      };
      expose({
        focus,
        blur
      });
      return () => {
        var _a2, _b;
        const {
          icon = (_a2 = slots.icon) === null || _a2 === void 0 ? void 0 : _a2.call(slots)
        } = props;
        const children = flattenChildren((_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots));
        isNeedInserted = children.length === 1 && !icon && !isUnBorderedButtonType(props.type);
        const {
          type: type4,
          htmlType,
          href,
          title,
          target
        } = props;
        const iconType = innerLoading.value ? "loading" : icon;
        const buttonProps2 = _extends$1(_extends$1({}, attrs), {
          title,
          disabled: mergedDisabled.value,
          class: [classes.value, attrs.class, {
            [`${prefixCls.value}-icon-only`]: children.length === 0 && !!iconType
          }],
          onClick: handleClick,
          onMousedown: handleMousedown
        });
        if (!mergedDisabled.value) {
          delete buttonProps2.disabled;
        }
        const iconNode = icon && !innerLoading.value ? icon : createVNode(LoadingIcon, {
          "existIcon": !!icon,
          "prefixCls": prefixCls.value,
          "loading": !!innerLoading.value
        }, null);
        const kids = children.map((child) => insertSpace(child, isNeedInserted && autoInsertSpace.value));
        if (href !== void 0) {
          return wrapSSR(createVNode("a", _objectSpread2$1(_objectSpread2$1({}, buttonProps2), {}, {
            "href": href,
            "target": target,
            "ref": buttonNodeRef
          }), [iconNode, kids]));
        }
        let buttonNode = createVNode("button", _objectSpread2$1(_objectSpread2$1({}, buttonProps2), {}, {
          "ref": buttonNodeRef,
          "type": htmlType
        }), [iconNode, kids]);
        if (!isUnBorderedButtonType(type4)) {
          const _buttonNode = /* @__PURE__ */ function() {
            return buttonNode;
          }();
          buttonNode = createVNode(Wave, {
            "ref": "wave",
            "disabled": !!innerLoading.value
          }, {
            default: () => [_buttonNode]
          });
        }
        return wrapSSR(buttonNode);
      };
    }
  });
  Button.Group = ButtonGroup;
  Button.install = function(app2) {
    app2.component(Button.name, Button);
    app2.component(ButtonGroup.name, ButtonGroup);
    return app2;
  };
  function hasClass(node2, className) {
    if (node2.classList) {
      return node2.classList.contains(className);
    }
    const originClass = node2.className;
    return ` ${originClass} `.indexOf(` ${className} `) > -1;
  }
  function addClass(node2, className) {
    if (node2.classList) {
      node2.classList.add(className);
    } else {
      if (!hasClass(node2, className)) {
        node2.className = `${node2.className} ${className}`;
      }
    }
  }
  function removeClass(node2, className) {
    if (node2.classList) {
      node2.classList.remove(className);
    } else {
      if (hasClass(node2, className)) {
        const originClass = node2.className;
        node2.className = ` ${originClass} `.replace(` ${className} `, " ");
      }
    }
  }
  const collapseMotion = function() {
    let name2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant-motion-collapse";
    let appear = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    return {
      name: name2,
      appear,
      css: true,
      onBeforeEnter: (node2) => {
        node2.style.height = "0px";
        node2.style.opacity = "0";
        addClass(node2, name2);
      },
      onEnter: (node2) => {
        nextTick(() => {
          node2.style.height = `${node2.scrollHeight}px`;
          node2.style.opacity = "1";
        });
      },
      onAfterEnter: (node2) => {
        if (node2) {
          removeClass(node2, name2);
          node2.style.height = null;
          node2.style.opacity = null;
        }
      },
      onBeforeLeave: (node2) => {
        addClass(node2, name2);
        node2.style.height = `${node2.offsetHeight}px`;
        node2.style.opacity = null;
      },
      onLeave: (node2) => {
        setTimeout(() => {
          node2.style.height = "0px";
          node2.style.opacity = "0";
        });
      },
      onAfterLeave: (node2) => {
        if (node2) {
          removeClass(node2, name2);
          if (node2.style) {
            node2.style.height = null;
            node2.style.opacity = null;
          }
        }
      }
    };
  };
  const collapseMotion$1 = collapseMotion;
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  function tryOnScopeDispose(fn) {
    if (getCurrentScope()) {
      onScopeDispose(fn);
      return true;
    }
    return false;
  }
  function resolveUnref(r2) {
    return typeof r2 === "function" ? r2() : unref(r2);
  }
  function unrefElement(elRef) {
    var _a2;
    const plain = resolveUnref(elRef);
    return (_a2 = plain === null || plain === void 0 ? void 0 : plain.$el) !== null && _a2 !== void 0 ? _a2 : plain;
  }
  function tryOnMounted(fn) {
    let sync = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (getCurrentInstance())
      onMounted(fn);
    else if (sync)
      fn();
    else
      nextTick(fn);
  }
  function useSupported(callback) {
    let sync = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const isSupported2 = shallowRef();
    const update = () => isSupported2.value = Boolean(callback());
    update();
    tryOnMounted(update, sync);
    return isSupported2;
  }
  var _a;
  const isClient = typeof window !== "undefined";
  isClient && ((_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
  const defaultWindow = isClient ? window : void 0;
  var __rest$e = function(s2, e2) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  const checkboxProps$1 = {
    prefixCls: String,
    name: String,
    id: String,
    type: String,
    defaultChecked: {
      type: [Boolean, Number],
      default: void 0
    },
    checked: {
      type: [Boolean, Number],
      default: void 0
    },
    disabled: Boolean,
    tabindex: {
      type: [Number, String]
    },
    readonly: Boolean,
    autofocus: Boolean,
    value: PropTypes.any,
    required: Boolean
  };
  const VcCheckbox = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "Checkbox",
    inheritAttrs: false,
    props: initDefaultProps(checkboxProps$1, {
      prefixCls: "rc-checkbox",
      type: "checkbox",
      defaultChecked: false
    }),
    emits: ["click", "change"],
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        expose
      } = _ref;
      const checked = ref(props.checked === void 0 ? props.defaultChecked : props.checked);
      const inputRef = ref();
      watch(() => props.checked, () => {
        checked.value = props.checked;
      });
      expose({
        focus() {
          var _a2;
          (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
        },
        blur() {
          var _a2;
          (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
        }
      });
      const eventShiftKey = ref();
      const handleChange = (e2) => {
        if (props.disabled) {
          return;
        }
        if (props.checked === void 0) {
          checked.value = e2.target.checked;
        }
        e2.shiftKey = eventShiftKey.value;
        const eventObj = {
          target: _extends$1(_extends$1({}, props), {
            checked: e2.target.checked
          }),
          stopPropagation() {
            e2.stopPropagation();
          },
          preventDefault() {
            e2.preventDefault();
          },
          nativeEvent: e2
        };
        if (props.checked !== void 0) {
          inputRef.value.checked = !!props.checked;
        }
        emit2("change", eventObj);
        eventShiftKey.value = false;
      };
      const onClick = (e2) => {
        emit2("click", e2);
        eventShiftKey.value = e2.shiftKey;
      };
      return () => {
        const {
          prefixCls,
          name: name2,
          id,
          type: type4,
          disabled,
          readonly: readonly2,
          tabindex,
          autofocus,
          value,
          required: required4
        } = props, others = __rest$e(props, ["prefixCls", "name", "id", "type", "disabled", "readonly", "tabindex", "autofocus", "value", "required"]);
        const {
          class: className,
          onFocus,
          onBlur,
          onKeydown,
          onKeypress,
          onKeyup
        } = attrs;
        const othersAndAttrs = _extends$1(_extends$1({}, others), attrs);
        const globalProps = Object.keys(othersAndAttrs).reduce((prev2, key2) => {
          if (key2.startsWith("data-") || key2.startsWith("aria-") || key2 === "role") {
            prev2[key2] = othersAndAttrs[key2];
          }
          return prev2;
        }, {});
        const classString = classNames(prefixCls, className, {
          [`${prefixCls}-checked`]: checked.value,
          [`${prefixCls}-disabled`]: disabled
        });
        const inputProps2 = _extends$1(_extends$1({
          name: name2,
          id,
          type: type4,
          readonly: readonly2,
          disabled,
          tabindex,
          class: `${prefixCls}-input`,
          checked: !!checked.value,
          autofocus,
          value
        }, globalProps), {
          onChange: handleChange,
          onClick,
          onFocus,
          onBlur,
          onKeydown,
          onKeypress,
          onKeyup,
          required: required4
        });
        return createVNode("span", {
          "class": classString
        }, [createVNode("input", _objectSpread2$1({
          "ref": inputRef
        }, inputProps2), null), createVNode("span", {
          "class": `${prefixCls}-inner`
        }, null)]);
      };
    }
  });
  const genPlaceholderStyle = (color) => ({
    // Firefox
    "&::-moz-placeholder": {
      opacity: 1
    },
    "&::placeholder": {
      color,
      userSelect: "none"
      // https://github.com/ant-design/ant-design/pull/32639
    },
    "&:placeholder-shown": {
      textOverflow: "ellipsis"
    }
  });
  const genHoverStyle = (token2) => ({
    borderColor: token2.inputBorderHoverColor,
    borderInlineEndWidth: token2.lineWidth
  });
  const genActiveStyle = (token2) => ({
    borderColor: token2.inputBorderHoverColor,
    boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`,
    borderInlineEndWidth: token2.lineWidth,
    outline: 0
  });
  const genDisabledStyle = (token2) => ({
    color: token2.colorTextDisabled,
    backgroundColor: token2.colorBgContainerDisabled,
    borderColor: token2.colorBorder,
    boxShadow: "none",
    cursor: "not-allowed",
    opacity: 1,
    "&:hover": _extends$1({}, genHoverStyle(merge(token2, {
      inputBorderHoverColor: token2.colorBorder
    })))
  });
  const genInputLargeStyle = (token2) => {
    const {
      inputPaddingVerticalLG,
      fontSizeLG,
      lineHeightLG,
      borderRadiusLG,
      inputPaddingHorizontalLG
    } = token2;
    return {
      padding: `${inputPaddingVerticalLG}px ${inputPaddingHorizontalLG}px`,
      fontSize: fontSizeLG,
      lineHeight: lineHeightLG,
      borderRadius: borderRadiusLG
    };
  };
  const genInputSmallStyle = (token2) => ({
    padding: `${token2.inputPaddingVerticalSM}px ${token2.controlPaddingHorizontalSM - 1}px`,
    borderRadius: token2.borderRadiusSM
  });
  const genStatusStyle = (token2, parentCls) => {
    const {
      componentCls,
      colorError,
      colorWarning,
      colorErrorOutline,
      colorWarningOutline,
      colorErrorBorderHover,
      colorWarningBorderHover
    } = token2;
    return {
      [`&-status-error:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
        borderColor: colorError,
        "&:hover": {
          borderColor: colorErrorBorderHover
        },
        "&:focus, &-focused": _extends$1({}, genActiveStyle(merge(token2, {
          inputBorderActiveColor: colorError,
          inputBorderHoverColor: colorError,
          controlOutline: colorErrorOutline
        }))),
        [`${componentCls}-prefix`]: {
          color: colorError
        }
      },
      [`&-status-warning:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
        borderColor: colorWarning,
        "&:hover": {
          borderColor: colorWarningBorderHover
        },
        "&:focus, &-focused": _extends$1({}, genActiveStyle(merge(token2, {
          inputBorderActiveColor: colorWarning,
          inputBorderHoverColor: colorWarning,
          controlOutline: colorWarningOutline
        }))),
        [`${componentCls}-prefix`]: {
          color: colorWarning
        }
      }
    };
  };
  const genBasicInputStyle = (token2) => _extends$1(_extends$1({
    position: "relative",
    display: "inline-block",
    width: "100%",
    minWidth: 0,
    padding: `${token2.inputPaddingVertical}px ${token2.inputPaddingHorizontal}px`,
    color: token2.colorText,
    fontSize: token2.fontSize,
    lineHeight: token2.lineHeight,
    backgroundColor: token2.colorBgContainer,
    backgroundImage: "none",
    borderWidth: token2.lineWidth,
    borderStyle: token2.lineType,
    borderColor: token2.colorBorder,
    borderRadius: token2.borderRadius,
    transition: `all ${token2.motionDurationMid}`
  }, genPlaceholderStyle(token2.colorTextPlaceholder)), {
    "&:hover": _extends$1({}, genHoverStyle(token2)),
    "&:focus, &-focused": _extends$1({}, genActiveStyle(token2)),
    "&-disabled, &[disabled]": _extends$1({}, genDisabledStyle(token2)),
    "&-borderless": {
      "&, &:hover, &:focus, &-focused, &-disabled, &[disabled]": {
        backgroundColor: "transparent",
        border: "none",
        boxShadow: "none"
      }
    },
    // Reset height for `textarea`s
    "textarea&": {
      maxWidth: "100%",
      height: "auto",
      minHeight: token2.controlHeight,
      lineHeight: token2.lineHeight,
      verticalAlign: "bottom",
      transition: `all ${token2.motionDurationSlow}, height 0s`,
      resize: "vertical"
    },
    // Size
    "&-lg": _extends$1({}, genInputLargeStyle(token2)),
    "&-sm": _extends$1({}, genInputSmallStyle(token2)),
    // RTL
    "&-rtl": {
      direction: "rtl"
    },
    "&-textarea-rtl": {
      direction: "rtl"
    }
  });
  const genInputGroupStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    return {
      position: "relative",
      display: "table",
      width: "100%",
      borderCollapse: "separate",
      borderSpacing: 0,
      // Undo padding and float of grid classes
      [`&[class*='col-']`]: {
        paddingInlineEnd: token2.paddingXS,
        "&:last-child": {
          paddingInlineEnd: 0
        }
      },
      // Sizing options
      [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: _extends$1({}, genInputLargeStyle(token2)),
      [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: _extends$1({}, genInputSmallStyle(token2)),
      [`> ${componentCls}`]: {
        display: "table-cell",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      [`${componentCls}-group`]: {
        [`&-addon, &-wrap`]: {
          display: "table-cell",
          width: 1,
          whiteSpace: "nowrap",
          verticalAlign: "middle",
          "&:not(:first-child):not(:last-child)": {
            borderRadius: 0
          }
        },
        "&-wrap > *": {
          display: "block !important"
        },
        "&-addon": {
          position: "relative",
          padding: `0 ${token2.inputPaddingHorizontal}px`,
          color: token2.colorText,
          fontWeight: "normal",
          fontSize: token2.fontSize,
          textAlign: "center",
          backgroundColor: token2.colorFillAlter,
          border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadius,
          transition: `all ${token2.motionDurationSlow}`,
          lineHeight: 1,
          // Reset Select's style in addon
          [`${antCls}-select`]: {
            margin: `-${token2.inputPaddingVertical + 1}px -${token2.inputPaddingHorizontal}px`,
            [`&${antCls}-select-single:not(${antCls}-select-customize-input)`]: {
              [`${antCls}-select-selector`]: {
                backgroundColor: "inherit",
                border: `${token2.lineWidth}px ${token2.lineType} transparent`,
                boxShadow: "none"
              }
            },
            "&-open, &-focused": {
              [`${antCls}-select-selector`]: {
                color: token2.colorPrimary
              }
            }
          },
          // https://github.com/ant-design/ant-design/issues/31333
          [`${antCls}-cascader-picker`]: {
            margin: `-9px -${token2.inputPaddingHorizontal}px`,
            backgroundColor: "transparent",
            [`${antCls}-cascader-input`]: {
              textAlign: "start",
              border: 0,
              boxShadow: "none"
            }
          }
        },
        "&-addon:first-child": {
          borderInlineEnd: 0
        },
        "&-addon:last-child": {
          borderInlineStart: 0
        }
      },
      [`${componentCls}`]: {
        float: "inline-start",
        width: "100%",
        marginBottom: 0,
        textAlign: "inherit",
        "&:focus": {
          zIndex: 1,
          borderInlineEndWidth: 1
        },
        "&:hover": {
          zIndex: 1,
          borderInlineEndWidth: 1,
          [`${componentCls}-search-with-button &`]: {
            zIndex: 0
          }
        }
      },
      // Reset rounded corners
      [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        // Reset Select's style in addon
        [`${antCls}-select ${antCls}-select-selector`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        }
      },
      [`> ${componentCls}-affix-wrapper`]: {
        [`&:not(:first-child) ${componentCls}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        },
        [`&:not(:last-child) ${componentCls}`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        }
      },
      [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0,
        // Reset Select's style in addon
        [`${antCls}-select ${antCls}-select-selector`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        }
      },
      [`${componentCls}-affix-wrapper`]: {
        "&:not(:last-child)": {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
          [`${componentCls}-search &`]: {
            borderStartStartRadius: token2.borderRadius,
            borderEndStartRadius: token2.borderRadius
          }
        },
        [`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        }
      },
      [`&${componentCls}-group-compact`]: _extends$1(_extends$1({
        display: "block"
      }, clearFix()), {
        [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
          "&:not(:first-child):not(:last-child)": {
            borderInlineEndWidth: token2.lineWidth,
            "&:hover": {
              zIndex: 1
            },
            "&:focus": {
              zIndex: 1
            }
          }
        },
        "& > *": {
          display: "inline-block",
          float: "none",
          verticalAlign: "top",
          borderRadius: 0
        },
        [`& > ${componentCls}-affix-wrapper`]: {
          display: "inline-flex"
        },
        [`& > ${antCls}-picker-range`]: {
          display: "inline-flex"
        },
        "& > *:not(:last-child)": {
          marginInlineEnd: -token2.lineWidth,
          borderInlineEndWidth: token2.lineWidth
        },
        // Undo float for .ant-input-group .ant-input
        [`${componentCls}`]: {
          float: "none"
        },
        // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
        [`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
          borderInlineEndWidth: token2.lineWidth,
          borderRadius: 0,
          "&:hover": {
            zIndex: 1
          },
          "&:focus": {
            zIndex: 1
          }
        },
        [`& > ${antCls}-select-focused`]: {
          zIndex: 1
        },
        // update z-index for arrow icon
        [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
          zIndex: 1
          // https://github.com/ant-design/ant-design/issues/20371
        },
        [`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
          borderStartStartRadius: token2.borderRadius,
          borderEndStartRadius: token2.borderRadius
        },
        [`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
          borderInlineEndWidth: token2.lineWidth,
          borderStartEndRadius: token2.borderRadius,
          borderEndEndRadius: token2.borderRadius
        },
        // https://github.com/ant-design/ant-design/issues/12493
        [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
          verticalAlign: "top"
        },
        [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
          marginInlineStart: -token2.lineWidth,
          [`${componentCls}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`${componentCls}-group-wrapper:not(:last-child)`]: {
          [`&${componentCls}-search > ${componentCls}-group`]: {
            [`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: {
              borderRadius: 0
            },
            [`& > ${componentCls}`]: {
              borderStartStartRadius: token2.borderRadius,
              borderStartEndRadius: 0,
              borderEndEndRadius: 0,
              borderEndStartRadius: token2.borderRadius
            }
          }
        }
      }),
      [`&&-sm ${antCls}-btn`]: {
        fontSize: token2.fontSizeSM,
        height: token2.controlHeightSM,
        lineHeight: "normal"
      },
      [`&&-lg ${antCls}-btn`]: {
        fontSize: token2.fontSizeLG,
        height: token2.controlHeightLG,
        lineHeight: "normal"
      },
      // Fix https://github.com/ant-design/ant-design/issues/5754
      [`&&-lg ${antCls}-select-single ${antCls}-select-selector`]: {
        height: `${token2.controlHeightLG}px`,
        [`${antCls}-select-selection-item, ${antCls}-select-selection-placeholder`]: {
          // -2 is for the border size & override default
          lineHeight: `${token2.controlHeightLG - 2}px`
        },
        [`${antCls}-select-selection-search-input`]: {
          height: `${token2.controlHeightLG}px`
        }
      },
      [`&&-sm ${antCls}-select-single ${antCls}-select-selector`]: {
        height: `${token2.controlHeightSM}px`,
        [`${antCls}-select-selection-item, ${antCls}-select-selection-placeholder`]: {
          // -2 is for the border size & override default
          lineHeight: `${token2.controlHeightSM - 2}px`
        },
        [`${antCls}-select-selection-search-input`]: {
          height: `${token2.controlHeightSM}px`
        }
      }
    };
  };
  const genInputStyle = (token2) => {
    const {
      componentCls,
      controlHeightSM,
      lineWidth
    } = token2;
    const FIXED_CHROME_COLOR_HEIGHT = 16;
    const colorSmallPadding = (controlHeightSM - lineWidth * 2 - FIXED_CHROME_COLOR_HEIGHT) / 2;
    return {
      [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), genBasicInputStyle(token2)), genStatusStyle(token2, componentCls)), {
        '&[type="color"]': {
          height: token2.controlHeight,
          [`&${componentCls}-lg`]: {
            height: token2.controlHeightLG
          },
          [`&${componentCls}-sm`]: {
            height: controlHeightSM,
            paddingTop: colorSmallPadding,
            paddingBottom: colorSmallPadding
          }
        }
      })
    };
  };
  const genAllowClearStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      // ========================= Input =========================
      [`${componentCls}-clear-icon`]: {
        margin: 0,
        color: token2.colorTextQuaternary,
        fontSize: token2.fontSizeIcon,
        verticalAlign: -1,
        // https://github.com/ant-design/ant-design/pull/18151
        // https://codesandbox.io/s/wizardly-sun-u10br
        cursor: "pointer",
        transition: `color ${token2.motionDurationSlow}`,
        "&:hover": {
          color: token2.colorTextTertiary
        },
        "&:active": {
          color: token2.colorText
        },
        "&-hidden": {
          visibility: "hidden"
        },
        "&-has-suffix": {
          margin: `0 ${token2.inputAffixPadding}px`
        }
      },
      // ======================= TextArea ========================
      "&-textarea-with-clear-btn": {
        padding: "0 !important",
        border: "0 !important",
        [`${componentCls}-clear-icon`]: {
          position: "absolute",
          insetBlockStart: token2.paddingXS,
          insetInlineEnd: token2.paddingXS,
          zIndex: 1
        }
      }
    };
  };
  const genAffixStyle = (token2) => {
    const {
      componentCls,
      inputAffixPadding,
      colorTextDescription,
      motionDurationSlow,
      colorIcon,
      colorIconHover,
      iconCls
    } = token2;
    return {
      [`${componentCls}-affix-wrapper`]: _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, genBasicInputStyle(token2)), {
        display: "inline-flex",
        [`&:not(${componentCls}-affix-wrapper-disabled):hover`]: _extends$1(_extends$1({}, genHoverStyle(token2)), {
          zIndex: 1,
          [`${componentCls}-search-with-button &`]: {
            zIndex: 0
          }
        }),
        "&-focused, &:focus": {
          zIndex: 1
        },
        "&-disabled": {
          [`${componentCls}[disabled]`]: {
            background: "transparent"
          }
        },
        [`> input${componentCls}`]: {
          padding: 0,
          fontSize: "inherit",
          border: "none",
          borderRadius: 0,
          outline: "none",
          "&:focus": {
            boxShadow: "none !important"
          }
        },
        "&::before": {
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        },
        [`${componentCls}`]: {
          "&-prefix, &-suffix": {
            display: "flex",
            flex: "none",
            alignItems: "center",
            "> *:not(:last-child)": {
              marginInlineEnd: token2.paddingXS
            }
          },
          "&-show-count-suffix": {
            color: colorTextDescription
          },
          "&-show-count-has-suffix": {
            marginInlineEnd: token2.paddingXXS
          },
          "&-prefix": {
            marginInlineEnd: inputAffixPadding
          },
          "&-suffix": {
            marginInlineStart: inputAffixPadding
          }
        }
      }), genAllowClearStyle(token2)), {
        // password
        [`${iconCls}${componentCls}-password-icon`]: {
          color: colorIcon,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}`,
          "&:hover": {
            color: colorIconHover
          }
        }
      }), genStatusStyle(token2, `${componentCls}-affix-wrapper`))
    };
  };
  const genGroupStyle = (token2) => {
    const {
      componentCls,
      colorError,
      colorSuccess,
      borderRadiusLG,
      borderRadiusSM
    } = token2;
    return {
      [`${componentCls}-group`]: _extends$1(_extends$1(_extends$1({}, resetComponent(token2)), genInputGroupStyle(token2)), {
        "&-rtl": {
          direction: "rtl"
        },
        "&-wrapper": {
          display: "inline-block",
          width: "100%",
          textAlign: "start",
          verticalAlign: "top",
          "&-rtl": {
            direction: "rtl"
          },
          // Size
          "&-lg": {
            [`${componentCls}-group-addon`]: {
              borderRadius: borderRadiusLG
            }
          },
          "&-sm": {
            [`${componentCls}-group-addon`]: {
              borderRadius: borderRadiusSM
            }
          },
          // Status
          "&-status-error": {
            [`${componentCls}-group-addon`]: {
              color: colorError,
              borderColor: colorError
            }
          },
          "&-status-warning": {
            [`${componentCls}-group-addon:last-child`]: {
              color: colorSuccess,
              borderColor: colorSuccess
            }
          }
        }
      })
    };
  };
  const genSearchInputStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    const searchPrefixCls = `${componentCls}-search`;
    return {
      [searchPrefixCls]: {
        [`${componentCls}`]: {
          "&:hover, &:focus": {
            borderColor: token2.colorPrimaryHover,
            [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
              borderInlineStartColor: token2.colorPrimaryHover
            }
          }
        },
        [`${componentCls}-affix-wrapper`]: {
          borderRadius: 0
        },
        // fix slight height diff in Firefox:
        // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
        [`${componentCls}-lg`]: {
          lineHeight: token2.lineHeightLG - 2e-4
        },
        [`> ${componentCls}-group`]: {
          [`> ${componentCls}-group-addon:last-child`]: {
            insetInlineStart: -1,
            padding: 0,
            border: 0,
            [`${searchPrefixCls}-button`]: {
              paddingTop: 0,
              paddingBottom: 0,
              borderStartStartRadius: 0,
              borderStartEndRadius: token2.borderRadius,
              borderEndEndRadius: token2.borderRadius,
              borderEndStartRadius: 0
            },
            [`${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
              color: token2.colorTextDescription,
              "&:hover": {
                color: token2.colorPrimaryHover
              },
              "&:active": {
                color: token2.colorPrimaryActive
              },
              [`&${antCls}-btn-loading::before`]: {
                insetInlineStart: 0,
                insetInlineEnd: 0,
                insetBlockStart: 0,
                insetBlockEnd: 0
              }
            }
          }
        },
        [`${searchPrefixCls}-button`]: {
          height: token2.controlHeight,
          "&:hover, &:focus": {
            zIndex: 1
          }
        },
        [`&-large ${searchPrefixCls}-button`]: {
          height: token2.controlHeightLG
        },
        [`&-small ${searchPrefixCls}-button`]: {
          height: token2.controlHeightSM
        },
        "&-rtl": {
          direction: "rtl"
        },
        // ===================== Compact Item Customized Styles =====================
        [`&${componentCls}-compact-item`]: {
          [`&:not(${componentCls}-compact-last-item)`]: {
            [`${componentCls}-group-addon`]: {
              [`${componentCls}-search-button`]: {
                marginInlineEnd: -token2.lineWidth,
                borderRadius: 0
              }
            }
          },
          [`&:not(${componentCls}-compact-first-item)`]: {
            [`${componentCls},${componentCls}-affix-wrapper`]: {
              borderRadius: 0
            }
          },
          [`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: {
            "&:hover,&:focus,&:active": {
              zIndex: 2
            }
          },
          [`> ${componentCls}-affix-wrapper-focused`]: {
            zIndex: 2
          }
        }
      }
    };
  };
  function initInputToken(token2) {
    return merge(token2, {
      inputAffixPadding: token2.paddingXXS,
      inputPaddingVertical: Math.max(Math.round((token2.controlHeight - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 3),
      inputPaddingVerticalLG: Math.ceil((token2.controlHeightLG - token2.fontSizeLG * token2.lineHeightLG) / 2 * 10) / 10 - token2.lineWidth,
      inputPaddingVerticalSM: Math.max(Math.round((token2.controlHeightSM - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 0),
      inputPaddingHorizontal: token2.paddingSM - token2.lineWidth,
      inputPaddingHorizontalSM: token2.paddingXS - token2.lineWidth,
      inputPaddingHorizontalLG: token2.controlPaddingHorizontal - token2.lineWidth,
      inputBorderHoverColor: token2.colorPrimaryHover,
      inputBorderActiveColor: token2.colorPrimaryHover
    });
  }
  const genTextAreaStyle = (token2) => {
    const {
      componentCls,
      inputPaddingHorizontal,
      paddingLG
    } = token2;
    const textareaPrefixCls = `${componentCls}-textarea`;
    return {
      [textareaPrefixCls]: {
        position: "relative",
        [`${textareaPrefixCls}-suffix`]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: inputPaddingHorizontal,
          bottom: 0,
          zIndex: 1,
          display: "inline-flex",
          alignItems: "center",
          margin: "auto"
        },
        [`&-status-error,
        &-status-warning,
        &-status-success,
        &-status-validating`]: {
          [`&${textareaPrefixCls}-has-feedback`]: {
            [`${componentCls}`]: {
              paddingInlineEnd: paddingLG
            }
          }
        },
        "&-show-count": {
          // https://github.com/ant-design/ant-design/issues/33049
          [`> ${componentCls}`]: {
            height: "100%"
          },
          "&::after": {
            color: token2.colorTextDescription,
            whiteSpace: "nowrap",
            content: "attr(data-count)",
            pointerEvents: "none",
            float: "right"
          }
        },
        "&-rtl": {
          "&::after": {
            float: "left"
          }
        }
      }
    };
  };
  const useStyle$7 = genComponentStyleHook("Input", (token2) => {
    const inputToken = initInputToken(token2);
    return [
      genInputStyle(inputToken),
      genTextAreaStyle(inputToken),
      genAffixStyle(inputToken),
      genGroupStyle(inputToken),
      genSearchInputStyle(inputToken),
      // =====================================================
      // ==             Space Compact                       ==
      // =====================================================
      genCompactItemStyle(inputToken)
    ];
  });
  const canUseDocElement = () => canUseDom$1() && window.document.documentElement;
  let flexGapSupported;
  const detectFlexGapSupported = () => {
    if (!canUseDocElement()) {
      return false;
    }
    if (flexGapSupported !== void 0) {
      return flexGapSupported;
    }
    const flex = document.createElement("div");
    flex.style.display = "flex";
    flex.style.flexDirection = "column";
    flex.style.rowGap = "1px";
    flex.appendChild(document.createElement("div"));
    flex.appendChild(document.createElement("div"));
    document.body.appendChild(flex);
    flexGapSupported = flex.scrollHeight === 1;
    document.body.removeChild(flex);
    return flexGapSupported;
  };
  const useFlexGapSupport = () => {
    const flexible = shallowRef(false);
    onMounted(() => {
      flexible.value = detectFlexGapSupported();
    });
    return flexible;
  };
  const RowContextKey = Symbol("rowContextKey");
  const useProvideRow = (state) => {
    provide(RowContextKey, state);
  };
  const useInjectRow = () => {
    return inject(RowContextKey, {
      gutter: computed(() => void 0),
      wrap: computed(() => void 0),
      supportFlexGap: computed(() => void 0)
    });
  };
  const useProvideRow$1 = useProvideRow;
  const genGridRowStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      // Grid system
      [componentCls]: {
        display: "flex",
        flexFlow: "row wrap",
        minWidth: 0,
        "&::before, &::after": {
          display: "flex"
        },
        "&-no-wrap": {
          flexWrap: "nowrap"
        },
        // The origin of the X-axis
        "&-start": {
          justifyContent: "flex-start"
        },
        // The center of the X-axis
        "&-center": {
          justifyContent: "center"
        },
        // The opposite of the X-axis
        "&-end": {
          justifyContent: "flex-end"
        },
        "&-space-between": {
          justifyContent: "space-between"
        },
        "&-space-around ": {
          justifyContent: "space-around"
        },
        // Align at the top
        "&-top": {
          alignItems: "flex-start"
        },
        // Align at the center
        "&-middle": {
          alignItems: "center"
        },
        "&-bottom": {
          alignItems: "flex-end"
        }
      }
    };
  };
  const genGridColStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      // Grid system
      [componentCls]: {
        position: "relative",
        maxWidth: "100%",
        // Prevent columns from collapsing when empty
        minHeight: 1
      }
    };
  };
  const genLoopGridColumnsStyle = (token2, sizeCls) => {
    const {
      componentCls,
      gridColumns
    } = token2;
    const gridColumnsStyle = {};
    for (let i2 = gridColumns; i2 >= 0; i2--) {
      if (i2 === 0) {
        gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = {
          display: "none"
        };
        gridColumnsStyle[`${componentCls}-push-${i2}`] = {
          insetInlineStart: "auto"
        };
        gridColumnsStyle[`${componentCls}-pull-${i2}`] = {
          insetInlineEnd: "auto"
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
          insetInlineStart: "auto"
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
          insetInlineEnd: "auto"
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
          marginInlineEnd: 0
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
          order: 0
        };
      } else {
        gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = {
          display: "block",
          flex: `0 0 ${i2 / gridColumns * 100}%`,
          maxWidth: `${i2 / gridColumns * 100}%`
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
          insetInlineStart: `${i2 / gridColumns * 100}%`
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
          insetInlineEnd: `${i2 / gridColumns * 100}%`
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
          marginInlineStart: `${i2 / gridColumns * 100}%`
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
          order: i2
        };
      }
    }
    return gridColumnsStyle;
  };
  const genGridStyle = (token2, sizeCls) => genLoopGridColumnsStyle(token2, sizeCls);
  const genGridMediaStyle = (token2, screenSize, sizeCls) => ({
    [`@media (min-width: ${screenSize}px)`]: _extends$1({}, genGridStyle(token2, sizeCls))
  });
  const useRowStyle = genComponentStyleHook("Grid", (token2) => [genGridRowStyle(token2)]);
  const useColStyle = genComponentStyleHook("Grid", (token2) => {
    const gridToken = merge(token2, {
      gridColumns: 24
      // Row is divided into 24 parts in Grid
    });
    const gridMediaSizesMap = {
      "-sm": gridToken.screenSMMin,
      "-md": gridToken.screenMDMin,
      "-lg": gridToken.screenLGMin,
      "-xl": gridToken.screenXLMin,
      "-xxl": gridToken.screenXXLMin
    };
    return [genGridColStyle(gridToken), genGridStyle(gridToken, ""), genGridStyle(gridToken, "-xs"), Object.keys(gridMediaSizesMap).map((key2) => genGridMediaStyle(gridToken, gridMediaSizesMap[key2], key2)).reduce((pre, cur) => _extends$1(_extends$1({}, pre), cur), {})];
  });
  const rowProps = () => ({
    align: someType([String, Object]),
    justify: someType([String, Object]),
    prefixCls: String,
    gutter: someType([Number, Array, Object], 0),
    wrap: {
      type: Boolean,
      default: void 0
    }
  });
  const ARow = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ARow",
    inheritAttrs: false,
    props: rowProps(),
    setup(props, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const {
        prefixCls,
        direction
      } = useConfigInject("row", props);
      const [wrapSSR, hashId] = useRowStyle(prefixCls);
      let token2;
      const responsiveObserve = useResponsiveObserver();
      const screens = ref({
        xs: true,
        sm: true,
        md: true,
        lg: true,
        xl: true,
        xxl: true
      });
      const curScreens = ref({
        xs: false,
        sm: false,
        md: false,
        lg: false,
        xl: false,
        xxl: false
      });
      const mergePropsByScreen = (oriProp) => {
        return computed(() => {
          if (typeof props[oriProp] === "string") {
            return props[oriProp];
          }
          if (typeof props[oriProp] !== "object") {
            return "";
          }
          for (let i2 = 0; i2 < responsiveArray.length; i2++) {
            const breakpoint = responsiveArray[i2];
            if (!curScreens.value[breakpoint])
              continue;
            const curVal = props[oriProp][breakpoint];
            if (curVal !== void 0) {
              return curVal;
            }
          }
          return "";
        });
      };
      const mergeAlign = mergePropsByScreen("align");
      const mergeJustify = mergePropsByScreen("justify");
      const supportFlexGap = useFlexGapSupport();
      onMounted(() => {
        token2 = responsiveObserve.value.subscribe((screen) => {
          curScreens.value = screen;
          const currentGutter = props.gutter || 0;
          if (!Array.isArray(currentGutter) && typeof currentGutter === "object" || Array.isArray(currentGutter) && (typeof currentGutter[0] === "object" || typeof currentGutter[1] === "object")) {
            screens.value = screen;
          }
        });
      });
      onBeforeUnmount(() => {
        responsiveObserve.value.unsubscribe(token2);
      });
      const gutter = computed(() => {
        const results = [void 0, void 0];
        const {
          gutter: gutter2 = 0
        } = props;
        const normalizedGutter = Array.isArray(gutter2) ? gutter2 : [gutter2, void 0];
        normalizedGutter.forEach((g2, index2) => {
          if (typeof g2 === "object") {
            for (let i2 = 0; i2 < responsiveArray.length; i2++) {
              const breakpoint = responsiveArray[i2];
              if (screens.value[breakpoint] && g2[breakpoint] !== void 0) {
                results[index2] = g2[breakpoint];
                break;
              }
            }
          } else {
            results[index2] = g2;
          }
        });
        return results;
      });
      useProvideRow$1({
        gutter,
        supportFlexGap,
        wrap: computed(() => props.wrap)
      });
      const classes = computed(() => classNames(prefixCls.value, {
        [`${prefixCls.value}-no-wrap`]: props.wrap === false,
        [`${prefixCls.value}-${mergeJustify.value}`]: mergeJustify.value,
        [`${prefixCls.value}-${mergeAlign.value}`]: mergeAlign.value,
        [`${prefixCls.value}-rtl`]: direction.value === "rtl"
      }, attrs.class, hashId.value));
      const rowStyle = computed(() => {
        const gt = gutter.value;
        const style = {};
        const horizontalGutter = gt[0] != null && gt[0] > 0 ? `${gt[0] / -2}px` : void 0;
        const verticalGutter = gt[1] != null && gt[1] > 0 ? `${gt[1] / -2}px` : void 0;
        if (horizontalGutter) {
          style.marginLeft = horizontalGutter;
          style.marginRight = horizontalGutter;
        }
        if (supportFlexGap.value) {
          style.rowGap = `${gt[1]}px`;
        } else if (verticalGutter) {
          style.marginTop = verticalGutter;
          style.marginBottom = verticalGutter;
        }
        return style;
      });
      return () => {
        var _a2;
        return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": classes.value,
          "style": _extends$1(_extends$1({}, rowStyle.value), attrs.style)
        }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]));
      };
    }
  });
  const Row = ARow;
  var define_process_env_default = {};
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key2 in source) {
          if (Object.prototype.hasOwnProperty.call(source, key2)) {
            target[key2] = source[key2];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _inheritsLoose$1(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o2) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o22) {
      return o22.__proto__ || Object.getPrototypeOf(o22);
    };
    return _getPrototypeOf(o2);
  }
  function _setPrototypeOf(o2, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o22, p2) {
      o22.__proto__ = p2;
      return o22;
    };
    return _setPrototypeOf(o2, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a2 = [null];
        a2.push.apply(a2, args2);
        var Constructor = Function.bind.apply(Parent2, a2);
        var instance = new Constructor();
        if (Class2)
          _setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
      if (Class2 === null || !_isNativeFunction(Class2))
        return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2))
          return _cache.get(Class2);
        _cache.set(Class2, Wrapper);
      }
      function Wrapper() {
        return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class2.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class2);
    };
    return _wrapNativeSuper(Class);
  }
  var formatRegExp = /%[sdj%]/g;
  var warning = function warning2() {
  };
  if (typeof process !== "undefined" && define_process_env_default && true && typeof window !== "undefined" && typeof document !== "undefined") {
    warning = function warning3(type4, errors) {
      if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
        if (errors.every(function(e2) {
          return typeof e2 === "string";
        })) {
          console.warn(type4, errors);
        }
      }
    };
  }
  function convertFieldsError(errors) {
    if (!errors || !errors.length)
      return null;
    var fields = {};
    errors.forEach(function(error) {
      var field = error.field;
      fields[field] = fields[field] || [];
      fields[field].push(error);
    });
    return fields;
  }
  function format(template) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var i2 = 0;
    var len = args.length;
    if (typeof template === "function") {
      return template.apply(null, args);
    }
    if (typeof template === "string") {
      var str = template.replace(formatRegExp, function(x2) {
        if (x2 === "%%") {
          return "%";
        }
        if (i2 >= len) {
          return x2;
        }
        switch (x2) {
          case "%s":
            return String(args[i2++]);
          case "%d":
            return Number(args[i2++]);
          case "%j":
            try {
              return JSON.stringify(args[i2++]);
            } catch (_2) {
              return "[Circular]";
            }
            break;
          default:
            return x2;
        }
      });
      return str;
    }
    return template;
  }
  function isNativeStringType(type4) {
    return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
  }
  function isEmptyValue(value, type4) {
    if (value === void 0 || value === null) {
      return true;
    }
    if (type4 === "array" && Array.isArray(value) && !value.length) {
      return true;
    }
    if (isNativeStringType(type4) && typeof value === "string" && !value) {
      return true;
    }
    return false;
  }
  function asyncParallelArray(arr, func, callback) {
    var results = [];
    var total = 0;
    var arrLength = arr.length;
    function count(errors) {
      results.push.apply(results, errors || []);
      total++;
      if (total === arrLength) {
        callback(results);
      }
    }
    arr.forEach(function(a2) {
      func(a2, count);
    });
  }
  function asyncSerialArray(arr, func, callback) {
    var index2 = 0;
    var arrLength = arr.length;
    function next2(errors) {
      if (errors && errors.length) {
        callback(errors);
        return;
      }
      var original = index2;
      index2 = index2 + 1;
      if (original < arrLength) {
        func(arr[original], next2);
      } else {
        callback([]);
      }
    }
    next2([]);
  }
  function flattenObjArr(objArr) {
    var ret = [];
    Object.keys(objArr).forEach(function(k2) {
      ret.push.apply(ret, objArr[k2] || []);
    });
    return ret;
  }
  var AsyncValidationError = /* @__PURE__ */ function(_Error) {
    _inheritsLoose$1(AsyncValidationError2, _Error);
    function AsyncValidationError2(errors, fields) {
      var _this;
      _this = _Error.call(this, "Async Validation Error") || this;
      _this.errors = errors;
      _this.fields = fields;
      return _this;
    }
    return AsyncValidationError2;
  }(/* @__PURE__ */ _wrapNativeSuper(Error));
  function asyncMap(objArr, option, func, callback, source) {
    if (option.first) {
      var _pending = new Promise(function(resolve2, reject) {
        var next2 = function next22(errors) {
          callback(errors);
          return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source);
        };
        var flattenArr = flattenObjArr(objArr);
        asyncSerialArray(flattenArr, func, next2);
      });
      _pending["catch"](function(e2) {
        return e2;
      });
      return _pending;
    }
    var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
    var objArrKeys = Object.keys(objArr);
    var objArrLength = objArrKeys.length;
    var total = 0;
    var results = [];
    var pending = new Promise(function(resolve2, reject) {
      var next2 = function next22(errors) {
        results.push.apply(results, errors);
        total++;
        if (total === objArrLength) {
          callback(results);
          return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source);
        }
      };
      if (!objArrKeys.length) {
        callback(results);
        resolve2(source);
      }
      objArrKeys.forEach(function(key2) {
        var arr = objArr[key2];
        if (firstFields.indexOf(key2) !== -1) {
          asyncSerialArray(arr, func, next2);
        } else {
          asyncParallelArray(arr, func, next2);
        }
      });
    });
    pending["catch"](function(e2) {
      return e2;
    });
    return pending;
  }
  function isErrorObj(obj) {
    return !!(obj && obj.message !== void 0);
  }
  function getValue$1(value, path) {
    var v2 = value;
    for (var i2 = 0; i2 < path.length; i2++) {
      if (v2 == void 0) {
        return v2;
      }
      v2 = v2[path[i2]];
    }
    return v2;
  }
  function complementError(rule, source) {
    return function(oe) {
      var fieldValue;
      if (rule.fullFields) {
        fieldValue = getValue$1(source, rule.fullFields);
      } else {
        fieldValue = source[oe.field || rule.fullField];
      }
      if (isErrorObj(oe)) {
        oe.field = oe.field || rule.fullField;
        oe.fieldValue = fieldValue;
        return oe;
      }
      return {
        message: typeof oe === "function" ? oe() : oe,
        fieldValue,
        field: oe.field || rule.fullField
      };
    };
  }
  function deepMerge(target, source) {
    if (source) {
      for (var s2 in source) {
        if (source.hasOwnProperty(s2)) {
          var value = source[s2];
          if (typeof value === "object" && typeof target[s2] === "object") {
            target[s2] = _extends({}, target[s2], value);
          } else {
            target[s2] = value;
          }
        }
      }
    }
    return target;
  }
  var required$1 = function required(rule, value, source, errors, options, type4) {
    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
      errors.push(format(options.messages.required, rule.fullField));
    }
  };
  var whitespace = function whitespace2(rule, value, source, errors, options) {
    if (/^\s+$/.test(value) || value === "") {
      errors.push(format(options.messages.whitespace, rule.fullField));
    }
  };
  var urlReg;
  var getUrlRegex = function() {
    if (urlReg) {
      return urlReg;
    }
    var word = "[a-fA-F\\d:]";
    var b2 = function b22(options) {
      return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
    };
    var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
    var v6seg = "[a-fA-F\\d]{1,4}";
    var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
    var v4exact = new RegExp("^" + v4 + "$");
    var v6exact = new RegExp("^" + v6 + "$");
    var ip = function ip2(options) {
      return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
    };
    ip.v4 = function(options) {
      return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
    };
    ip.v6 = function(options) {
      return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
    };
    var protocol = "(?:(?:[a-z]+:)?//)";
    var auth = "(?:\\S+(?::\\S*)?@)?";
    var ipv4 = ip.v4().source;
    var ipv6 = ip.v6().source;
    var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
    var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
    var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
    var port = "(?::\\d{2,5})?";
    var path = '(?:[/?#][^\\s"]*)?';
    var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
    urlReg = new RegExp("(?:^" + regex + "$)", "i");
    return urlReg;
  };
  var pattern$2 = {
    // http://emailregex.com/
    email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    // url: new RegExp(
    //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
    //   'i',
    // ),
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
  };
  var types = {
    integer: function integer(value) {
      return types.number(value) && parseInt(value, 10) === value;
    },
    "float": function float(value) {
      return types.number(value) && !types.integer(value);
    },
    array: function array(value) {
      return Array.isArray(value);
    },
    regexp: function regexp(value) {
      if (value instanceof RegExp) {
        return true;
      }
      try {
        return !!new RegExp(value);
      } catch (e2) {
        return false;
      }
    },
    date: function date(value) {
      return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
    },
    number: function number(value) {
      if (isNaN(value)) {
        return false;
      }
      return typeof value === "number";
    },
    object: function object(value) {
      return typeof value === "object" && !types.array(value);
    },
    method: function method(value) {
      return typeof value === "function";
    },
    email: function email(value) {
      return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
    },
    url: function url(value) {
      return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
    },
    hex: function hex(value) {
      return typeof value === "string" && !!value.match(pattern$2.hex);
    }
  };
  var type$1 = function type(rule, value, source, errors, options) {
    if (rule.required && value === void 0) {
      required$1(rule, value, source, errors, options);
      return;
    }
    var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
    var ruleType = rule.type;
    if (custom.indexOf(ruleType) > -1) {
      if (!types[ruleType](value)) {
        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    } else if (ruleType && typeof value !== rule.type) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  };
  var range = function range2(rule, value, source, errors, options) {
    var len = typeof rule.len === "number";
    var min = typeof rule.min === "number";
    var max = typeof rule.max === "number";
    var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var val = value;
    var key2 = null;
    var num = typeof value === "number";
    var str = typeof value === "string";
    var arr = Array.isArray(value);
    if (num) {
      key2 = "number";
    } else if (str) {
      key2 = "string";
    } else if (arr) {
      key2 = "array";
    }
    if (!key2) {
      return false;
    }
    if (arr) {
      val = value.length;
    }
    if (str) {
      val = value.replace(spRegexp, "_").length;
    }
    if (len) {
      if (val !== rule.len) {
        errors.push(format(options.messages[key2].len, rule.fullField, rule.len));
      }
    } else if (min && !max && val < rule.min) {
      errors.push(format(options.messages[key2].min, rule.fullField, rule.min));
    } else if (max && !min && val > rule.max) {
      errors.push(format(options.messages[key2].max, rule.fullField, rule.max));
    } else if (min && max && (val < rule.min || val > rule.max)) {
      errors.push(format(options.messages[key2].range, rule.fullField, rule.min, rule.max));
    }
  };
  var ENUM$1 = "enum";
  var enumerable$1 = function enumerable(rule, value, source, errors, options) {
    rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
    if (rule[ENUM$1].indexOf(value) === -1) {
      errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
    }
  };
  var pattern$1 = function pattern(rule, value, source, errors, options) {
    if (rule.pattern) {
      if (rule.pattern instanceof RegExp) {
        rule.pattern.lastIndex = 0;
        if (!rule.pattern.test(value)) {
          errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      } else if (typeof rule.pattern === "string") {
        var _pattern = new RegExp(rule.pattern);
        if (!_pattern.test(value)) {
          errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      }
    }
  };
  var rules = {
    required: required$1,
    whitespace,
    type: type$1,
    range,
    "enum": enumerable$1,
    pattern: pattern$1
  };
  var string = function string2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, "string");
      if (!isEmptyValue(value, "string")) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
        rules.pattern(rule, value, source, errors, options);
        if (rule.whitespace === true) {
          rules.whitespace(rule, value, source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var method2 = function method3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var number2 = function number3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (value === "") {
        value = void 0;
      }
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var _boolean = function _boolean2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var regexp2 = function regexp3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var integer2 = function integer3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var floatFn = function floatFn2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var array2 = function array3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if ((value === void 0 || value === null) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, "array");
      if (value !== void 0 && value !== null) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var object2 = function object3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var ENUM = "enum";
  var enumerable2 = function enumerable3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules[ENUM](rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var pattern2 = function pattern3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value, "string")) {
        rules.pattern(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var date2 = function date3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "date") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value, "date")) {
        var dateObject;
        if (value instanceof Date) {
          dateObject = value;
        } else {
          dateObject = new Date(value);
        }
        rules.type(rule, dateObject, source, errors, options);
        if (dateObject) {
          rules.range(rule, dateObject.getTime(), source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var required2 = function required3(rule, value, callback, source, options) {
    var errors = [];
    var type4 = Array.isArray(value) ? "array" : typeof value;
    rules.required(rule, value, source, errors, options, type4);
    callback(errors);
  };
  var type2 = function type3(rule, value, callback, source, options) {
    var ruleType = rule.type;
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, ruleType) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, ruleType);
      if (!isEmptyValue(value, ruleType)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var any = function any2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
    }
    callback(errors);
  };
  var validators = {
    string,
    method: method2,
    number: number2,
    "boolean": _boolean,
    regexp: regexp2,
    integer: integer2,
    "float": floatFn,
    array: array2,
    object: object2,
    "enum": enumerable2,
    pattern: pattern2,
    date: date2,
    url: type2,
    hex: type2,
    email: type2,
    required: required2,
    any
  };
  function newMessages() {
    return {
      "default": "Validation error on field %s",
      required: "%s is required",
      "enum": "%s must be one of %s",
      whitespace: "%s cannot be empty",
      date: {
        format: "%s date %s is invalid for format %s",
        parse: "%s date could not be parsed, %s is invalid ",
        invalid: "%s date %s is invalid"
      },
      types: {
        string: "%s is not a %s",
        method: "%s is not a %s (function)",
        array: "%s is not an %s",
        object: "%s is not an %s",
        number: "%s is not a %s",
        date: "%s is not a %s",
        "boolean": "%s is not a %s",
        integer: "%s is not an %s",
        "float": "%s is not a %s",
        regexp: "%s is not a valid %s",
        email: "%s is not a valid %s",
        url: "%s is not a valid %s",
        hex: "%s is not a valid %s"
      },
      string: {
        len: "%s must be exactly %s characters",
        min: "%s must be at least %s characters",
        max: "%s cannot be longer than %s characters",
        range: "%s must be between %s and %s characters"
      },
      number: {
        len: "%s must equal %s",
        min: "%s cannot be less than %s",
        max: "%s cannot be greater than %s",
        range: "%s must be between %s and %s"
      },
      array: {
        len: "%s must be exactly %s in length",
        min: "%s cannot be less than %s in length",
        max: "%s cannot be greater than %s in length",
        range: "%s must be between %s and %s in length"
      },
      pattern: {
        mismatch: "%s value %s does not match pattern %s"
      },
      clone: function clone2() {
        var cloned = JSON.parse(JSON.stringify(this));
        cloned.clone = this.clone;
        return cloned;
      }
    };
  }
  var messages = newMessages();
  var Schema = /* @__PURE__ */ function() {
    function Schema2(descriptor) {
      this.rules = null;
      this._messages = messages;
      this.define(descriptor);
    }
    var _proto = Schema2.prototype;
    _proto.define = function define(rules2) {
      var _this = this;
      if (!rules2) {
        throw new Error("Cannot configure a schema with no rules");
      }
      if (typeof rules2 !== "object" || Array.isArray(rules2)) {
        throw new Error("Rules must be an object");
      }
      this.rules = {};
      Object.keys(rules2).forEach(function(name2) {
        var item = rules2[name2];
        _this.rules[name2] = Array.isArray(item) ? item : [item];
      });
    };
    _proto.messages = function messages2(_messages) {
      if (_messages) {
        this._messages = deepMerge(newMessages(), _messages);
      }
      return this._messages;
    };
    _proto.validate = function validate(source_, o2, oc) {
      var _this2 = this;
      if (o2 === void 0) {
        o2 = {};
      }
      if (oc === void 0) {
        oc = function oc2() {
        };
      }
      var source = source_;
      var options = o2;
      var callback = oc;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!this.rules || Object.keys(this.rules).length === 0) {
        if (callback) {
          callback(null, source);
        }
        return Promise.resolve(source);
      }
      function complete(results) {
        var errors = [];
        var fields = {};
        function add2(e2) {
          if (Array.isArray(e2)) {
            var _errors;
            errors = (_errors = errors).concat.apply(_errors, e2);
          } else {
            errors.push(e2);
          }
        }
        for (var i2 = 0; i2 < results.length; i2++) {
          add2(results[i2]);
        }
        if (!errors.length) {
          callback(null, source);
        } else {
          fields = convertFieldsError(errors);
          callback(errors, fields);
        }
      }
      if (options.messages) {
        var messages$1 = this.messages();
        if (messages$1 === messages) {
          messages$1 = newMessages();
        }
        deepMerge(messages$1, options.messages);
        options.messages = messages$1;
      } else {
        options.messages = this.messages();
      }
      var series = {};
      var keys2 = options.keys || Object.keys(this.rules);
      keys2.forEach(function(z2) {
        var arr = _this2.rules[z2];
        var value = source[z2];
        arr.forEach(function(r2) {
          var rule = r2;
          if (typeof rule.transform === "function") {
            if (source === source_) {
              source = _extends({}, source);
            }
            value = source[z2] = rule.transform(value);
          }
          if (typeof rule === "function") {
            rule = {
              validator: rule
            };
          } else {
            rule = _extends({}, rule);
          }
          rule.validator = _this2.getValidationMethod(rule);
          if (!rule.validator) {
            return;
          }
          rule.field = z2;
          rule.fullField = rule.fullField || z2;
          rule.type = _this2.getType(rule);
          series[z2] = series[z2] || [];
          series[z2].push({
            rule,
            value,
            source,
            field: z2
          });
        });
      });
      var errorFields = {};
      return asyncMap(series, options, function(data, doIt) {
        var rule = data.rule;
        var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
        deep = deep && (rule.required || !rule.required && data.value);
        rule.field = data.field;
        function addFullField(key2, schema) {
          return _extends({}, schema, {
            fullField: rule.fullField + "." + key2,
            fullFields: rule.fullFields ? [].concat(rule.fullFields, [key2]) : [key2]
          });
        }
        function cb(e2) {
          if (e2 === void 0) {
            e2 = [];
          }
          var errorList = Array.isArray(e2) ? e2 : [e2];
          if (!options.suppressWarning && errorList.length) {
            Schema2.warning("async-validator:", errorList);
          }
          if (errorList.length && rule.message !== void 0) {
            errorList = [].concat(rule.message);
          }
          var filledErrors = errorList.map(complementError(rule, source));
          if (options.first && filledErrors.length) {
            errorFields[rule.field] = 1;
            return doIt(filledErrors);
          }
          if (!deep) {
            doIt(filledErrors);
          } else {
            if (rule.required && !data.value) {
              if (rule.message !== void 0) {
                filledErrors = [].concat(rule.message).map(complementError(rule, source));
              } else if (options.error) {
                filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
              }
              return doIt(filledErrors);
            }
            var fieldsSchema = {};
            if (rule.defaultField) {
              Object.keys(data.value).map(function(key2) {
                fieldsSchema[key2] = rule.defaultField;
              });
            }
            fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
            var paredFieldsSchema = {};
            Object.keys(fieldsSchema).forEach(function(field) {
              var fieldSchema = fieldsSchema[field];
              var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
              paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
            });
            var schema = new Schema2(paredFieldsSchema);
            schema.messages(options.messages);
            if (data.rule.options) {
              data.rule.options.messages = options.messages;
              data.rule.options.error = options.error;
            }
            schema.validate(data.value, data.rule.options || options, function(errs) {
              var finalErrors = [];
              if (filledErrors && filledErrors.length) {
                finalErrors.push.apply(finalErrors, filledErrors);
              }
              if (errs && errs.length) {
                finalErrors.push.apply(finalErrors, errs);
              }
              doIt(finalErrors.length ? finalErrors : null);
            });
          }
        }
        var res;
        if (rule.asyncValidator) {
          res = rule.asyncValidator(rule, data.value, cb, data.source, options);
        } else if (rule.validator) {
          try {
            res = rule.validator(rule, data.value, cb, data.source, options);
          } catch (error) {
            console.error == null ? void 0 : console.error(error);
            if (!options.suppressValidatorError) {
              setTimeout(function() {
                throw error;
              }, 0);
            }
            cb(error.message);
          }
          if (res === true) {
            cb();
          } else if (res === false) {
            cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
          } else if (res instanceof Array) {
            cb(res);
          } else if (res instanceof Error) {
            cb(res.message);
          }
        }
        if (res && res.then) {
          res.then(function() {
            return cb();
          }, function(e2) {
            return cb(e2);
          });
        }
      }, function(results) {
        complete(results);
      }, source);
    };
    _proto.getType = function getType2(rule) {
      if (rule.type === void 0 && rule.pattern instanceof RegExp) {
        rule.type = "pattern";
      }
      if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
        throw new Error(format("Unknown rule type %s", rule.type));
      }
      return rule.type || "string";
    };
    _proto.getValidationMethod = function getValidationMethod(rule) {
      if (typeof rule.validator === "function") {
        return rule.validator;
      }
      var keys2 = Object.keys(rule);
      var messageIndex = keys2.indexOf("message");
      if (messageIndex !== -1) {
        keys2.splice(messageIndex, 1);
      }
      if (keys2.length === 1 && keys2[0] === "required") {
        return validators.required;
      }
      return validators[this.getType(rule)] || void 0;
    };
    return Schema2;
  }();
  Schema.register = function register(type4, validator) {
    if (typeof validator !== "function") {
      throw new Error("Cannot register a validator by type, validator is not a function");
    }
    validators[type4] = validator;
  };
  Schema.warning = warning;
  Schema.messages = messages;
  Schema.validators = validators;
  function toArray$2(value) {
    if (value === void 0 || value === null) {
      return [];
    }
    return Array.isArray(value) ? value : [value];
  }
  function get(entity, path) {
    let current = entity;
    for (let i2 = 0; i2 < path.length; i2 += 1) {
      if (current === null || current === void 0) {
        return void 0;
      }
      current = current[path[i2]];
    }
    return current;
  }
  function internalSet(entity, paths, value, removeIfUndefined) {
    if (!paths.length) {
      return value;
    }
    const [path, ...restPath] = paths;
    let clone2;
    if (!entity && typeof path === "number") {
      clone2 = [];
    } else if (Array.isArray(entity)) {
      clone2 = [...entity];
    } else {
      clone2 = _extends$1({}, entity);
    }
    if (removeIfUndefined && value === void 0 && restPath.length === 1) {
      delete clone2[path][restPath[0]];
    } else {
      clone2[path] = internalSet(clone2[path], restPath, value, removeIfUndefined);
    }
    return clone2;
  }
  function set$1(entity, paths, value) {
    let removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1))) {
      return entity;
    }
    return internalSet(entity, paths, value, removeIfUndefined);
  }
  function getNamePath(path) {
    return toArray$2(path);
  }
  function getValue(store, namePath) {
    const value = get(store, namePath);
    return value;
  }
  function setValue(store, namePath, value) {
    let removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    const newStore = set$1(store, namePath, value, removeIfUndefined);
    return newStore;
  }
  function containsNamePath(namePathList, namePath) {
    return namePathList && namePathList.some((path) => matchNamePath(path, namePath));
  }
  function isObject(obj) {
    return typeof obj === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
  }
  function internalSetValues(store, values) {
    const newStore = Array.isArray(store) ? [...store] : _extends$1({}, store);
    if (!values) {
      return newStore;
    }
    Object.keys(values).forEach((key2) => {
      const prevValue = newStore[key2];
      const value = values[key2];
      const recursive = isObject(prevValue) && isObject(value);
      newStore[key2] = recursive ? internalSetValues(prevValue, value || {}) : value;
    });
    return newStore;
  }
  function setValues(store) {
    for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      restValues[_key - 1] = arguments[_key];
    }
    return restValues.reduce((current, newStore) => internalSetValues(current, newStore), store);
  }
  function cloneByNamePathList(store, namePathList) {
    let newStore = {};
    namePathList.forEach((namePath) => {
      const value = getValue(store, namePath);
      newStore = setValue(newStore, namePath, value);
    });
    return newStore;
  }
  function matchNamePath(namePath, changedNamePath) {
    if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {
      return false;
    }
    return namePath.every((nameUnit, i2) => changedNamePath[i2] === nameUnit);
  }
  const typeTemplate$1 = "'${name}' is not a valid ${type}";
  const defaultValidateMessages = {
    default: "Validation error on field '${name}'",
    required: "'${name}' is required",
    enum: "'${name}' must be one of [${enum}]",
    whitespace: "'${name}' cannot be empty",
    date: {
      format: "'${name}' is invalid for format date",
      parse: "'${name}' could not be parsed as date",
      invalid: "'${name}' is invalid date"
    },
    types: {
      string: typeTemplate$1,
      method: typeTemplate$1,
      array: typeTemplate$1,
      object: typeTemplate$1,
      number: typeTemplate$1,
      date: typeTemplate$1,
      boolean: typeTemplate$1,
      integer: typeTemplate$1,
      float: typeTemplate$1,
      regexp: typeTemplate$1,
      email: typeTemplate$1,
      url: typeTemplate$1,
      hex: typeTemplate$1
    },
    string: {
      len: "'${name}' must be exactly ${len} characters",
      min: "'${name}' must be at least ${min} characters",
      max: "'${name}' cannot be longer than ${max} characters",
      range: "'${name}' must be between ${min} and ${max} characters"
    },
    number: {
      len: "'${name}' must equal ${len}",
      min: "'${name}' cannot be less than ${min}",
      max: "'${name}' cannot be greater than ${max}",
      range: "'${name}' must be between ${min} and ${max}"
    },
    array: {
      len: "'${name}' must be exactly ${len} in length",
      min: "'${name}' cannot be less than ${min} in length",
      max: "'${name}' cannot be greater than ${max} in length",
      range: "'${name}' must be between ${min} and ${max} in length"
    },
    pattern: {
      mismatch: "'${name}' does not match pattern ${pattern}"
    }
  };
  var __awaiter = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve2) {
        resolve2(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  const AsyncValidator = Schema;
  function replaceMessage(template, kv) {
    return template.replace(/\$\{\w+\}/g, (str) => {
      const key2 = str.slice(2, -1);
      return kv[key2];
    });
  }
  function validateRule(name2, value, rule, options, messageVariables) {
    return __awaiter(this, void 0, void 0, function* () {
      const cloneRule = _extends$1({}, rule);
      delete cloneRule.ruleIndex;
      delete cloneRule.trigger;
      let subRuleField = null;
      if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
        subRuleField = cloneRule.defaultField;
        delete cloneRule.defaultField;
      }
      const validator = new AsyncValidator({
        [name2]: [cloneRule]
      });
      const messages2 = setValues({}, defaultValidateMessages, options.validateMessages);
      validator.messages(messages2);
      let result = [];
      try {
        yield Promise.resolve(validator.validate({
          [name2]: value
        }, _extends$1({}, options)));
      } catch (errObj) {
        if (errObj.errors) {
          result = errObj.errors.map((_ref, index2) => {
            let {
              message
            } = _ref;
            return (
              // Wrap VueNode with `key`
              isValidElement(message) ? cloneVNode(message, {
                key: `error_${index2}`
              }) : message
            );
          });
        } else {
          console.error(errObj);
          result = [messages2.default()];
        }
      }
      if (!result.length && subRuleField) {
        const subResults = yield Promise.all(value.map((subValue, i2) => validateRule(`${name2}.${i2}`, subValue, subRuleField, options, messageVariables)));
        return subResults.reduce((prev2, errors) => [...prev2, ...errors], []);
      }
      const kv = _extends$1(_extends$1(_extends$1({}, rule), {
        name: name2,
        enum: (rule.enum || []).join(", ")
      }), messageVariables);
      const fillVariableResult = result.map((error) => {
        if (typeof error === "string") {
          return replaceMessage(error, kv);
        }
        return error;
      });
      return fillVariableResult;
    });
  }
  function validateRules(namePath, value, rules2, options, validateFirst, messageVariables) {
    const name2 = namePath.join(".");
    const filledRules = rules2.map((currentRule, ruleIndex) => {
      const originValidatorFunc = currentRule.validator;
      const cloneRule = _extends$1(_extends$1({}, currentRule), {
        ruleIndex
      });
      if (originValidatorFunc) {
        cloneRule.validator = (rule, val, callback) => {
          let hasPromise = false;
          const wrappedCallback = function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            Promise.resolve().then(() => {
              warning$4(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
              if (!hasPromise) {
                callback(...args);
              }
            });
          };
          const promise = originValidatorFunc(rule, val, wrappedCallback);
          hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
          warning$4(hasPromise, "`callback` is deprecated. Please return a promise instead.");
          if (hasPromise) {
            promise.then(() => {
              callback();
            }).catch((err) => {
              callback(err || " ");
            });
          }
        };
      }
      return cloneRule;
    }).sort((_ref2, _ref3) => {
      let {
        warningOnly: w1,
        ruleIndex: i1
      } = _ref2;
      let {
        warningOnly: w2,
        ruleIndex: i2
      } = _ref3;
      if (!!w1 === !!w2) {
        return i1 - i2;
      }
      if (w1) {
        return 1;
      }
      return -1;
    });
    let summaryPromise;
    if (validateFirst === true) {
      summaryPromise = new Promise((resolve2, reject) => __awaiter(this, void 0, void 0, function* () {
        for (let i2 = 0; i2 < filledRules.length; i2 += 1) {
          const rule = filledRules[i2];
          const errors = yield validateRule(name2, value, rule, options, messageVariables);
          if (errors.length) {
            reject([{
              errors,
              rule
            }]);
            return;
          }
        }
        resolve2([]);
      }));
    } else {
      const rulePromises = filledRules.map((rule) => validateRule(name2, value, rule, options, messageVariables).then((errors) => ({
        errors,
        rule
      })));
      summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then((errors) => {
        return Promise.reject(errors);
      });
    }
    summaryPromise.catch((e2) => e2);
    return summaryPromise;
  }
  function finishOnAllFailed(rulePromises) {
    return __awaiter(this, void 0, void 0, function* () {
      return Promise.all(rulePromises).then((errorsList) => {
        const errors = [].concat(...errorsList);
        return errors;
      });
    });
  }
  function finishOnFirstFailed(rulePromises) {
    return __awaiter(this, void 0, void 0, function* () {
      let count = 0;
      return new Promise((resolve2) => {
        rulePromises.forEach((promise) => {
          promise.then((ruleError) => {
            if (ruleError.errors.length) {
              resolve2([ruleError]);
            }
            count += 1;
            if (count === rulePromises.length) {
              resolve2([]);
            }
          });
        });
      });
    });
  }
  const FormContextKey = Symbol("formContextKey");
  const useProvideForm = (state) => {
    provide(FormContextKey, state);
  };
  const useInjectForm = () => {
    return inject(FormContextKey, {
      name: computed(() => void 0),
      labelAlign: computed(() => "right"),
      vertical: computed(() => false),
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      addField: (_eventKey, _field) => {
      },
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      removeField: (_eventKey) => {
      },
      model: computed(() => void 0),
      rules: computed(() => void 0),
      colon: computed(() => void 0),
      labelWrap: computed(() => void 0),
      labelCol: computed(() => void 0),
      requiredMark: computed(() => false),
      validateTrigger: computed(() => void 0),
      onValidate: () => {
      },
      validateMessages: computed(() => defaultValidateMessages)
    });
  };
  const FormItemPrefixContextKey = Symbol("formItemPrefixContextKey");
  const useProvideFormItemPrefix = (state) => {
    provide(FormItemPrefixContextKey, state);
  };
  const useInjectFormItemPrefix = () => {
    return inject(FormItemPrefixContextKey, {
      prefixCls: computed(() => "")
    });
  };
  function parseFlex(flex) {
    if (typeof flex === "number") {
      return `${flex} ${flex} auto`;
    }
    if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
      return `0 0 ${flex}`;
    }
    return flex;
  }
  const colProps = () => ({
    span: [String, Number],
    order: [String, Number],
    offset: [String, Number],
    push: [String, Number],
    pull: [String, Number],
    xs: {
      type: [String, Number, Object],
      default: void 0
    },
    sm: {
      type: [String, Number, Object],
      default: void 0
    },
    md: {
      type: [String, Number, Object],
      default: void 0
    },
    lg: {
      type: [String, Number, Object],
      default: void 0
    },
    xl: {
      type: [String, Number, Object],
      default: void 0
    },
    xxl: {
      type: [String, Number, Object],
      default: void 0
    },
    prefixCls: String,
    flex: [String, Number]
  });
  const sizes = ["xs", "sm", "md", "lg", "xl", "xxl"];
  const Col = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ACol",
    inheritAttrs: false,
    props: colProps(),
    setup(props, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const {
        gutter,
        supportFlexGap,
        wrap: wrap3
      } = useInjectRow();
      const {
        prefixCls,
        direction
      } = useConfigInject("col", props);
      const [wrapSSR, hashId] = useColStyle(prefixCls);
      const classes = computed(() => {
        const {
          span,
          order,
          offset: offset3,
          push,
          pull
        } = props;
        const pre = prefixCls.value;
        let sizeClassObj = {};
        sizes.forEach((size2) => {
          let sizeProps = {};
          const propSize = props[size2];
          if (typeof propSize === "number") {
            sizeProps.span = propSize;
          } else if (typeof propSize === "object") {
            sizeProps = propSize || {};
          }
          sizeClassObj = _extends$1(_extends$1({}, sizeClassObj), {
            [`${pre}-${size2}-${sizeProps.span}`]: sizeProps.span !== void 0,
            [`${pre}-${size2}-order-${sizeProps.order}`]: sizeProps.order || sizeProps.order === 0,
            [`${pre}-${size2}-offset-${sizeProps.offset}`]: sizeProps.offset || sizeProps.offset === 0,
            [`${pre}-${size2}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,
            [`${pre}-${size2}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0,
            [`${pre}-rtl`]: direction.value === "rtl"
          });
        });
        return classNames(pre, {
          [`${pre}-${span}`]: span !== void 0,
          [`${pre}-order-${order}`]: order,
          [`${pre}-offset-${offset3}`]: offset3,
          [`${pre}-push-${push}`]: push,
          [`${pre}-pull-${pull}`]: pull
        }, sizeClassObj, attrs.class, hashId.value);
      });
      const mergedStyle = computed(() => {
        const {
          flex
        } = props;
        const gutterVal = gutter.value;
        const style = {};
        if (gutterVal && gutterVal[0] > 0) {
          const horizontalGutter = `${gutterVal[0] / 2}px`;
          style.paddingLeft = horizontalGutter;
          style.paddingRight = horizontalGutter;
        }
        if (gutterVal && gutterVal[1] > 0 && !supportFlexGap.value) {
          const verticalGutter = `${gutterVal[1] / 2}px`;
          style.paddingTop = verticalGutter;
          style.paddingBottom = verticalGutter;
        }
        if (flex) {
          style.flex = parseFlex(flex);
          if (wrap3.value === false && !style.minWidth) {
            style.minWidth = 0;
          }
        }
        return style;
      });
      return () => {
        var _a2;
        return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": classes.value,
          "style": [mergedStyle.value, attrs.style]
        }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]));
      };
    }
  });
  var QuestionCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, "name": "question-circle", "theme": "outlined" };
  const QuestionCircleOutlinedSvg = QuestionCircleOutlined$2;
  function _objectSpread$2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$2(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$2(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var QuestionCircleOutlined = function QuestionCircleOutlined2(props, context3) {
    var p = _objectSpread$2({}, props, context3.attrs);
    return createVNode(AntdIcon, _objectSpread$2({}, p, {
      "icon": QuestionCircleOutlinedSvg
    }), null);
  };
  QuestionCircleOutlined.displayName = "QuestionCircleOutlined";
  QuestionCircleOutlined.inheritAttrs = false;
  const QuestionCircleOutlined$1 = QuestionCircleOutlined;
  const FormItemLabel = (props, _ref) => {
    let {
      slots,
      emit: emit2,
      attrs
    } = _ref;
    var _a2, _b, _c, _d, _e;
    const {
      prefixCls,
      htmlFor,
      labelCol,
      labelAlign,
      colon,
      required: required4,
      requiredMark
    } = _extends$1(_extends$1({}, props), attrs);
    const [formLocale] = useLocaleReceiver("Form");
    const label = (_a2 = props.label) !== null && _a2 !== void 0 ? _a2 : (_b = slots.label) === null || _b === void 0 ? void 0 : _b.call(slots);
    if (!label)
      return null;
    const {
      vertical,
      labelAlign: contextLabelAlign,
      labelCol: contextLabelCol,
      labelWrap,
      colon: contextColon
    } = useInjectForm();
    const mergedLabelCol = labelCol || (contextLabelCol === null || contextLabelCol === void 0 ? void 0 : contextLabelCol.value) || {};
    const mergedLabelAlign = labelAlign || (contextLabelAlign === null || contextLabelAlign === void 0 ? void 0 : contextLabelAlign.value);
    const labelClsBasic = `${prefixCls}-item-label`;
    const labelColClassName = classNames(labelClsBasic, mergedLabelAlign === "left" && `${labelClsBasic}-left`, mergedLabelCol.class, {
      [`${labelClsBasic}-wrap`]: !!labelWrap.value
    });
    let labelChildren = label;
    const computedColon = colon === true || (contextColon === null || contextColon === void 0 ? void 0 : contextColon.value) !== false && colon !== false;
    const haveColon = computedColon && !vertical.value;
    if (haveColon && typeof label === "string" && label.trim() !== "") {
      labelChildren = label.replace(/[:|：]\s*$/, "");
    }
    if (props.tooltip || slots.tooltip) {
      const tooltipNode = createVNode("span", {
        "class": `${prefixCls}-item-tooltip`
      }, [createVNode(Tooltip, {
        "title": props.tooltip
      }, {
        default: () => [createVNode(QuestionCircleOutlined$1, null, null)]
      })]);
      labelChildren = createVNode(Fragment, null, [labelChildren, slots.tooltip ? (_c = slots.tooltip) === null || _c === void 0 ? void 0 : _c.call(slots, {
        class: `${prefixCls}-item-tooltip`
      }) : tooltipNode]);
    }
    if (requiredMark === "optional" && !required4) {
      labelChildren = createVNode(Fragment, null, [labelChildren, createVNode("span", {
        "class": `${prefixCls}-item-optional`
      }, [((_d = formLocale.value) === null || _d === void 0 ? void 0 : _d.optional) || ((_e = localeValues$1.Form) === null || _e === void 0 ? void 0 : _e.optional)])]);
    }
    const labelClassName = classNames({
      [`${prefixCls}-item-required`]: required4,
      [`${prefixCls}-item-required-mark-optional`]: requiredMark === "optional",
      [`${prefixCls}-item-no-colon`]: !computedColon
    });
    return createVNode(Col, _objectSpread2$1(_objectSpread2$1({}, mergedLabelCol), {}, {
      "class": labelColClassName
    }), {
      default: () => [createVNode("label", {
        "for": htmlFor,
        "class": labelClassName,
        "title": typeof label === "string" ? label : "",
        "onClick": (e2) => emit2("click", e2)
      }, [labelChildren])]
    });
  };
  FormItemLabel.displayName = "FormItemLabel";
  FormItemLabel.inheritAttrs = false;
  const FormItemLabel$1 = FormItemLabel;
  const genFormValidateMotionStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const helpCls = `${componentCls}-show-help`;
    const helpItemCls = `${componentCls}-show-help-item`;
    return {
      [helpCls]: {
        // Explain holder
        transition: `opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
        "&-appear, &-enter": {
          opacity: 0,
          "&-active": {
            opacity: 1
          }
        },
        "&-leave": {
          opacity: 1,
          "&-active": {
            opacity: 0
          }
        },
        // Explain
        [helpItemCls]: {
          overflow: "hidden",
          transition: `height ${token2.motionDurationSlow} ${token2.motionEaseInOut},
                     opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut},
                     transform ${token2.motionDurationSlow} ${token2.motionEaseInOut} !important`,
          [`&${helpItemCls}-appear, &${helpItemCls}-enter`]: {
            transform: `translateY(-5px)`,
            opacity: 0,
            [`&-active`]: {
              transform: "translateY(0)",
              opacity: 1
            }
          },
          [`&${helpItemCls}-leave-active`]: {
            transform: `translateY(-5px)`
          }
        }
      }
    };
  };
  const genFormValidateMotionStyle$1 = genFormValidateMotionStyle;
  const resetForm = (token2) => ({
    legend: {
      display: "block",
      width: "100%",
      marginBottom: token2.marginLG,
      padding: 0,
      color: token2.colorTextDescription,
      fontSize: token2.fontSizeLG,
      lineHeight: "inherit",
      border: 0,
      borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`
    },
    label: {
      fontSize: token2.fontSize
    },
    'input[type="search"]': {
      boxSizing: "border-box"
    },
    // Position radios and checkboxes better
    'input[type="radio"], input[type="checkbox"]': {
      lineHeight: "normal"
    },
    'input[type="file"]': {
      display: "block"
    },
    // Make range inputs behave like textual form controls
    'input[type="range"]': {
      display: "block",
      width: "100%"
    },
    // Make multiple select elements height not fixed
    "select[multiple], select[size]": {
      height: "auto"
    },
    // Focus for file, radio, and checkbox
    [`input[type='file']:focus,
  input[type='radio']:focus,
  input[type='checkbox']:focus`]: {
      outline: 0,
      boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`
    },
    // Adjust output element
    output: {
      display: "block",
      paddingTop: 15,
      color: token2.colorText,
      fontSize: token2.fontSize,
      lineHeight: token2.lineHeight
    }
  });
  const genFormSize = (token2, height) => {
    const {
      formItemCls
    } = token2;
    return {
      [formItemCls]: {
        [`${formItemCls}-label > label`]: {
          height
        },
        [`${formItemCls}-control-input`]: {
          minHeight: height
        }
      }
    };
  };
  const genFormStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [token2.componentCls]: _extends$1(_extends$1(_extends$1({}, resetComponent(token2)), resetForm(token2)), {
        [`${componentCls}-text`]: {
          display: "inline-block",
          paddingInlineEnd: token2.paddingSM
        },
        // ================================================================
        // =                             Size                             =
        // ================================================================
        "&-small": _extends$1({}, genFormSize(token2, token2.controlHeightSM)),
        "&-large": _extends$1({}, genFormSize(token2, token2.controlHeightLG))
      })
    };
  };
  const genFormItemStyle = (token2) => {
    const {
      formItemCls,
      iconCls,
      componentCls,
      rootPrefixCls
    } = token2;
    return {
      [formItemCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
        marginBottom: token2.marginLG,
        verticalAlign: "top",
        "&-with-help": {
          transition: "none"
        },
        [`&-hidden,
        &-hidden.${rootPrefixCls}-row`]: {
          // https://github.com/ant-design/ant-design/issues/26141
          display: "none"
        },
        "&-has-warning": {
          [`${formItemCls}-split`]: {
            color: token2.colorError
          }
        },
        "&-has-error": {
          [`${formItemCls}-split`]: {
            color: token2.colorWarning
          }
        },
        // ==============================================================
        // =                            Label                           =
        // ==============================================================
        [`${formItemCls}-label`]: {
          display: "inline-block",
          flexGrow: 0,
          overflow: "hidden",
          whiteSpace: "nowrap",
          textAlign: "end",
          verticalAlign: "middle",
          "&-left": {
            textAlign: "start"
          },
          "&-wrap": {
            overflow: "unset",
            lineHeight: `${token2.lineHeight} - 0.25em`,
            whiteSpace: "unset"
          },
          "> label": {
            position: "relative",
            display: "inline-flex",
            alignItems: "center",
            maxWidth: "100%",
            height: token2.controlHeight,
            color: token2.colorTextHeading,
            fontSize: token2.fontSize,
            [`> ${iconCls}`]: {
              fontSize: token2.fontSize,
              verticalAlign: "top"
            },
            // Required mark
            [`&${formItemCls}-required:not(${formItemCls}-required-mark-optional)::before`]: {
              display: "inline-block",
              marginInlineEnd: token2.marginXXS,
              color: token2.colorError,
              fontSize: token2.fontSize,
              fontFamily: "SimSun, sans-serif",
              lineHeight: 1,
              content: '"*"',
              [`${componentCls}-hide-required-mark &`]: {
                display: "none"
              }
            },
            // Optional mark
            [`${formItemCls}-optional`]: {
              display: "inline-block",
              marginInlineStart: token2.marginXXS,
              color: token2.colorTextDescription,
              [`${componentCls}-hide-required-mark &`]: {
                display: "none"
              }
            },
            // Optional mark
            [`${formItemCls}-tooltip`]: {
              color: token2.colorTextDescription,
              cursor: "help",
              writingMode: "horizontal-tb",
              marginInlineStart: token2.marginXXS
            },
            "&::after": {
              content: '":"',
              position: "relative",
              marginBlock: 0,
              marginInlineStart: token2.marginXXS / 2,
              marginInlineEnd: token2.marginXS
            },
            [`&${formItemCls}-no-colon::after`]: {
              content: '" "'
            }
          }
        },
        // ==============================================================
        // =                            Input                           =
        // ==============================================================
        [`${formItemCls}-control`]: {
          display: "flex",
          flexDirection: "column",
          flexGrow: 1,
          [`&:first-child:not([class^="'${rootPrefixCls}-col-'"]):not([class*="' ${rootPrefixCls}-col-'"])`]: {
            width: "100%"
          },
          "&-input": {
            position: "relative",
            display: "flex",
            alignItems: "center",
            minHeight: token2.controlHeight,
            "&-content": {
              flex: "auto",
              maxWidth: "100%"
            }
          }
        },
        // ==============================================================
        // =                           Explain                          =
        // ==============================================================
        [formItemCls]: {
          "&-explain, &-extra": {
            clear: "both",
            color: token2.colorTextDescription,
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight
          },
          "&-explain-connected": {
            width: "100%"
          },
          "&-extra": {
            minHeight: token2.controlHeightSM,
            transition: `color ${token2.motionDurationMid} ${token2.motionEaseOut}`
            // sync input color transition
          },
          "&-explain": {
            "&-error": {
              color: token2.colorError
            },
            "&-warning": {
              color: token2.colorWarning
            }
          }
        },
        [`&-with-help ${formItemCls}-explain`]: {
          height: "auto",
          opacity: 1
        },
        // ==============================================================
        // =                        Feedback Icon                       =
        // ==============================================================
        [`${formItemCls}-feedback-icon`]: {
          fontSize: token2.fontSize,
          textAlign: "center",
          visibility: "visible",
          animationName: zoomIn,
          animationDuration: token2.motionDurationMid,
          animationTimingFunction: token2.motionEaseOutBack,
          pointerEvents: "none",
          "&-success": {
            color: token2.colorSuccess
          },
          "&-error": {
            color: token2.colorError
          },
          "&-warning": {
            color: token2.colorWarning
          },
          "&-validating": {
            color: token2.colorPrimary
          }
        }
      })
    };
  };
  const genHorizontalStyle = (token2) => {
    const {
      componentCls,
      formItemCls,
      rootPrefixCls
    } = token2;
    return {
      [`${componentCls}-horizontal`]: {
        [`${formItemCls}-label`]: {
          flexGrow: 0
        },
        [`${formItemCls}-control`]: {
          flex: "1 1 0",
          // https://github.com/ant-design/ant-design/issues/32777
          // https://github.com/ant-design/ant-design/issues/33773
          minWidth: 0
        },
        // https://github.com/ant-design/ant-design/issues/32980
        [`${formItemCls}-label.${rootPrefixCls}-col-24 + ${formItemCls}-control`]: {
          minWidth: "unset"
        }
      }
    };
  };
  const genInlineStyle = (token2) => {
    const {
      componentCls,
      formItemCls
    } = token2;
    return {
      [`${componentCls}-inline`]: {
        display: "flex",
        flexWrap: "wrap",
        [formItemCls]: {
          flex: "none",
          flexWrap: "nowrap",
          marginInlineEnd: token2.margin,
          marginBottom: 0,
          "&-with-help": {
            marginBottom: token2.marginLG
          },
          [`> ${formItemCls}-label,
        > ${formItemCls}-control`]: {
            display: "inline-block",
            verticalAlign: "top"
          },
          [`> ${formItemCls}-label`]: {
            flex: "none"
          },
          [`${componentCls}-text`]: {
            display: "inline-block"
          },
          [`${formItemCls}-has-feedback`]: {
            display: "inline-block"
          }
        }
      }
    };
  };
  const makeVerticalLayoutLabel = (token2) => ({
    margin: 0,
    padding: `0 0 ${token2.paddingXS}px`,
    whiteSpace: "initial",
    textAlign: "start",
    "> label": {
      margin: 0,
      "&::after": {
        display: "none"
      }
    }
  });
  const makeVerticalLayout = (token2) => {
    const {
      componentCls,
      formItemCls
    } = token2;
    return {
      [`${formItemCls} ${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
      [componentCls]: {
        [formItemCls]: {
          flexWrap: "wrap",
          [`${formItemCls}-label,
          ${formItemCls}-control`]: {
            flex: "0 0 100%",
            maxWidth: "100%"
          }
        }
      }
    };
  };
  const genVerticalStyle = (token2) => {
    const {
      componentCls,
      formItemCls,
      rootPrefixCls
    } = token2;
    return {
      [`${componentCls}-vertical`]: {
        [formItemCls]: {
          "&-row": {
            flexDirection: "column"
          },
          "&-label > label": {
            height: "auto"
          },
          [`${componentCls}-item-control`]: {
            width: "100%"
          }
        }
      },
      [`${componentCls}-vertical ${formItemCls}-label,
      .${rootPrefixCls}-col-24${formItemCls}-label,
      .${rootPrefixCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
      [`@media (max-width: ${token2.screenXSMax}px)`]: [makeVerticalLayout(token2), {
        [componentCls]: {
          [`.${rootPrefixCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      }],
      [`@media (max-width: ${token2.screenSMMax}px)`]: {
        [componentCls]: {
          [`.${rootPrefixCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      },
      [`@media (max-width: ${token2.screenMDMax}px)`]: {
        [componentCls]: {
          [`.${rootPrefixCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      },
      [`@media (max-width: ${token2.screenLGMax}px)`]: {
        [componentCls]: {
          [`.${rootPrefixCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
        }
      }
    };
  };
  const useStyle$6 = genComponentStyleHook("Form", (token2, _ref) => {
    let {
      rootPrefixCls
    } = _ref;
    const formToken = merge(token2, {
      formItemCls: `${token2.componentCls}-item`,
      rootPrefixCls
    });
    return [genFormStyle(formToken), genFormItemStyle(formToken), genFormValidateMotionStyle$1(formToken), genHorizontalStyle(formToken), genInlineStyle(formToken), genVerticalStyle(formToken), genCollapseMotion$1(formToken), zoomIn];
  });
  const ErrorList = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ErrorList",
    inheritAttrs: false,
    props: ["errors", "help", "onErrorVisibleChanged", "helpStatus", "warnings"],
    setup(props, _ref) {
      let {
        attrs
      } = _ref;
      const {
        prefixCls,
        status
      } = useInjectFormItemPrefix();
      const baseClassName = computed(() => `${prefixCls.value}-item-explain`);
      const visible = computed(() => !!(props.errors && props.errors.length));
      const innerStatus = ref(status.value);
      const [, hashId] = useStyle$6(prefixCls);
      watch([visible, status], () => {
        if (visible.value) {
          innerStatus.value = status.value;
        }
      });
      return () => {
        var _a2, _b;
        const colMItem = collapseMotion$1(`${prefixCls.value}-show-help-item`);
        const transitionGroupProps = getTransitionGroupProps(`${prefixCls.value}-show-help-item`, colMItem);
        transitionGroupProps.role = "alert";
        transitionGroupProps.class = [hashId.value, baseClassName.value, attrs.class, `${prefixCls.value}-show-help`];
        return createVNode(Transition, _objectSpread2$1(_objectSpread2$1({}, getTransitionProps(`${prefixCls.value}-show-help`)), {}, {
          "onAfterEnter": () => props.onErrorVisibleChanged(true),
          "onAfterLeave": () => props.onErrorVisibleChanged(false)
        }), {
          default: () => [withDirectives(createVNode(TransitionGroup, _objectSpread2$1(_objectSpread2$1({}, transitionGroupProps), {}, {
            "tag": "div"
          }), {
            default: () => [(_b = props.errors) === null || _b === void 0 ? void 0 : _b.map((error, index2) => createVNode("div", {
              "key": index2,
              "class": innerStatus.value ? `${baseClassName.value}-${innerStatus.value}` : ""
            }, [error]))]
          }), [[vShow, !!((_a2 = props.errors) === null || _a2 === void 0 ? void 0 : _a2.length)]])]
        });
      };
    }
  });
  const FormItemInput = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    slots: Object,
    inheritAttrs: false,
    props: ["prefixCls", "errors", "hasFeedback", "onDomErrorVisibleChange", "wrapperCol", "help", "extra", "status", "marginBottom", "onErrorVisibleChanged"],
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const formContext = useInjectForm();
      const {
        wrapperCol: contextWrapperCol
      } = formContext;
      const subFormContext = _extends$1({}, formContext);
      delete subFormContext.labelCol;
      delete subFormContext.wrapperCol;
      useProvideForm(subFormContext);
      useProvideFormItemPrefix({
        prefixCls: computed(() => props.prefixCls),
        status: computed(() => props.status)
      });
      return () => {
        var _a2, _b, _c;
        const {
          prefixCls,
          wrapperCol,
          marginBottom,
          onErrorVisibleChanged,
          help = (_a2 = slots.help) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          errors = filterEmpty((_b = slots.errors) === null || _b === void 0 ? void 0 : _b.call(slots)),
          // hasFeedback,
          // status,
          extra = (_c = slots.extra) === null || _c === void 0 ? void 0 : _c.call(slots)
        } = props;
        const baseClassName = `${prefixCls}-item`;
        const mergedWrapperCol = wrapperCol || (contextWrapperCol === null || contextWrapperCol === void 0 ? void 0 : contextWrapperCol.value) || {};
        const className = classNames(`${baseClassName}-control`, mergedWrapperCol.class);
        return createVNode(Col, _objectSpread2$1(_objectSpread2$1({}, mergedWrapperCol), {}, {
          "class": className
        }), {
          default: () => {
            var _a3;
            return createVNode(Fragment, null, [createVNode("div", {
              "class": `${baseClassName}-control-input`
            }, [createVNode("div", {
              "class": `${baseClassName}-control-input-content`
            }, [(_a3 = slots.default) === null || _a3 === void 0 ? void 0 : _a3.call(slots)])]), marginBottom !== null || errors.length ? createVNode("div", {
              "style": {
                display: "flex",
                flexWrap: "nowrap"
              }
            }, [createVNode(ErrorList, {
              "errors": errors,
              "help": help,
              "class": `${baseClassName}-explain-connected`,
              "onErrorVisibleChanged": onErrorVisibleChanged
            }, null), !!marginBottom && createVNode("div", {
              "style": {
                width: 0,
                height: `${marginBottom}px`
              }
            }, null)]) : null, extra ? createVNode("div", {
              "class": `${baseClassName}-extra`
            }, [extra]) : null]);
          }
        });
      };
    }
  });
  const FormItemInput$1 = FormItemInput;
  function useDebounce(value) {
    const cacheValue = shallowRef(value.value.slice());
    let timeout = null;
    watchEffect(() => {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        cacheValue.value = value.value;
      }, value.value.length ? 0 : 10);
    });
    return cacheValue;
  }
  tuple("success", "warning", "error", "validating", "");
  const iconMap = {
    success: CheckCircleFilled$1,
    warning: ExclamationCircleFilled$1,
    error: CloseCircleFilled$1,
    validating: LoadingOutlined$1
  };
  function getPropByPath$1(obj, namePathList, strict) {
    let tempObj = obj;
    const keyArr = namePathList;
    let i2 = 0;
    try {
      for (let len = keyArr.length; i2 < len - 1; ++i2) {
        if (!tempObj && !strict)
          break;
        const key2 = keyArr[i2];
        if (key2 in tempObj) {
          tempObj = tempObj[key2];
        } else {
          if (strict) {
            throw Error("please transfer a valid name path to form item!");
          }
          break;
        }
      }
      if (strict && !tempObj) {
        throw Error("please transfer a valid name path to form item!");
      }
    } catch (error) {
      console.error("please transfer a valid name path to form item!");
    }
    return {
      o: tempObj,
      k: keyArr[i2],
      v: tempObj ? tempObj[keyArr[i2]] : void 0
    };
  }
  const formItemProps = () => ({
    htmlFor: String,
    prefixCls: String,
    label: PropTypes.any,
    help: PropTypes.any,
    extra: PropTypes.any,
    labelCol: {
      type: Object
    },
    wrapperCol: {
      type: Object
    },
    hasFeedback: {
      type: Boolean,
      default: false
    },
    colon: {
      type: Boolean,
      default: void 0
    },
    labelAlign: String,
    prop: {
      type: [String, Number, Array]
    },
    name: {
      type: [String, Number, Array]
    },
    rules: [Array, Object],
    autoLink: {
      type: Boolean,
      default: true
    },
    required: {
      type: Boolean,
      default: void 0
    },
    validateFirst: {
      type: Boolean,
      default: void 0
    },
    validateStatus: PropTypes.oneOf(tuple("", "success", "warning", "error", "validating")),
    validateTrigger: {
      type: [String, Array]
    },
    messageVariables: {
      type: Object
    },
    hidden: Boolean,
    noStyle: Boolean,
    tooltip: String
  });
  let indexGuid = 0;
  const defaultItemNamePrefixCls = "form_item";
  const FormItem = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AFormItem",
    inheritAttrs: false,
    __ANT_NEW_FORM_ITEM: true,
    props: formItemProps(),
    slots: Object,
    setup(props, _ref) {
      let {
        slots,
        attrs,
        expose
      } = _ref;
      warning$4(props.prop === void 0, `\`prop\` is deprecated. Please use \`name\` instead.`);
      const eventKey = `form-item-${++indexGuid}`;
      const {
        prefixCls
      } = useConfigInject("form", props);
      const [wrapSSR, hashId] = useStyle$6(prefixCls);
      const itemRef = shallowRef();
      const formContext = useInjectForm();
      const fieldName = computed(() => props.name || props.prop);
      const errors = shallowRef([]);
      const validateDisabled = shallowRef(false);
      const inputRef = shallowRef();
      const namePath = computed(() => {
        const val = fieldName.value;
        return getNamePath(val);
      });
      const fieldId = computed(() => {
        if (!namePath.value.length) {
          return void 0;
        } else {
          const formName = formContext.name.value;
          const mergedId = namePath.value.join("_");
          return formName ? `${formName}_${mergedId}` : `${defaultItemNamePrefixCls}_${mergedId}`;
        }
      });
      const getNewFieldValue = () => {
        const model = formContext.model.value;
        if (!model || !fieldName.value) {
          return;
        } else {
          return getPropByPath$1(model, namePath.value, true).v;
        }
      };
      const fieldValue = computed(() => getNewFieldValue());
      const initialValue = shallowRef(cloneDeep(fieldValue.value));
      const mergedValidateTrigger = computed(() => {
        let validateTrigger = props.validateTrigger !== void 0 ? props.validateTrigger : formContext.validateTrigger.value;
        validateTrigger = validateTrigger === void 0 ? "change" : validateTrigger;
        return toArray$2(validateTrigger);
      });
      const rulesRef = computed(() => {
        let formRules = formContext.rules.value;
        const selfRules = props.rules;
        const requiredRule = props.required !== void 0 ? {
          required: !!props.required,
          trigger: mergedValidateTrigger.value
        } : [];
        const prop = getPropByPath$1(formRules, namePath.value);
        formRules = formRules ? prop.o[prop.k] || prop.v : [];
        const rules2 = [].concat(selfRules || formRules || []);
        if (find(rules2, (rule) => rule.required)) {
          return rules2;
        } else {
          return rules2.concat(requiredRule);
        }
      });
      const isRequired2 = computed(() => {
        const rules2 = rulesRef.value;
        let isRequired3 = false;
        if (rules2 && rules2.length) {
          rules2.every((rule) => {
            if (rule.required) {
              isRequired3 = true;
              return false;
            }
            return true;
          });
        }
        return isRequired3 || props.required;
      });
      const validateState = shallowRef();
      watchEffect(() => {
        validateState.value = props.validateStatus;
      });
      const messageVariables = computed(() => {
        let variables = {};
        if (typeof props.label === "string") {
          variables.label = props.label;
        } else if (props.name) {
          variables.label = String(props.name);
        }
        if (props.messageVariables) {
          variables = _extends$1(_extends$1({}, variables), props.messageVariables);
        }
        return variables;
      });
      const validateRules$1 = (options) => {
        if (namePath.value.length === 0) {
          return;
        }
        const {
          validateFirst = false
        } = props;
        const {
          triggerName
        } = options || {};
        let filteredRules = rulesRef.value;
        if (triggerName) {
          filteredRules = filteredRules.filter((rule) => {
            const {
              trigger: trigger2
            } = rule;
            if (!trigger2 && !mergedValidateTrigger.value.length) {
              return true;
            }
            const triggerList = toArray$2(trigger2 || mergedValidateTrigger.value);
            return triggerList.includes(triggerName);
          });
        }
        if (!filteredRules.length) {
          return Promise.resolve();
        }
        const promise = validateRules(namePath.value, fieldValue.value, filteredRules, _extends$1({
          validateMessages: formContext.validateMessages.value
        }, options), validateFirst, messageVariables.value);
        validateState.value = "validating";
        errors.value = [];
        promise.catch((e2) => e2).then(function() {
          let results = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          if (validateState.value === "validating") {
            const res = results.filter((result) => result && result.errors.length);
            validateState.value = res.length ? "error" : "success";
            errors.value = res.map((r2) => r2.errors);
            formContext.onValidate(fieldName.value, !errors.value.length, errors.value.length ? toRaw(errors.value[0]) : null);
          }
        });
        return promise;
      };
      const onFieldBlur = () => {
        validateRules$1({
          triggerName: "blur"
        });
      };
      const onFieldChange = () => {
        if (validateDisabled.value) {
          validateDisabled.value = false;
          return;
        }
        validateRules$1({
          triggerName: "change"
        });
      };
      const clearValidate = () => {
        validateState.value = props.validateStatus;
        validateDisabled.value = false;
        errors.value = [];
      };
      const resetField = () => {
        var _a2;
        validateState.value = props.validateStatus;
        validateDisabled.value = true;
        errors.value = [];
        const model = formContext.model.value || {};
        const value = fieldValue.value;
        const prop = getPropByPath$1(model, namePath.value, true);
        if (Array.isArray(value)) {
          prop.o[prop.k] = [].concat((_a2 = initialValue.value) !== null && _a2 !== void 0 ? _a2 : []);
        } else {
          prop.o[prop.k] = initialValue.value;
        }
        nextTick(() => {
          validateDisabled.value = false;
        });
      };
      const htmlFor = computed(() => {
        return props.htmlFor === void 0 ? fieldId.value : props.htmlFor;
      });
      const onLabelClick = () => {
        const id = htmlFor.value;
        if (!id || !inputRef.value) {
          return;
        }
        const control = inputRef.value.$el.querySelector(`[id="${id}"]`);
        if (control && control.focus) {
          control.focus();
        }
      };
      expose({
        onFieldBlur,
        onFieldChange,
        clearValidate,
        resetField
      });
      useProvideFormItemContext({
        id: fieldId,
        onFieldBlur: () => {
          if (props.autoLink) {
            onFieldBlur();
          }
        },
        onFieldChange: () => {
          if (props.autoLink) {
            onFieldChange();
          }
        },
        clearValidate
      }, computed(() => {
        return !!(props.autoLink && formContext.model.value && fieldName.value);
      }));
      let registered = false;
      watch(fieldName, (val) => {
        if (val) {
          if (!registered) {
            registered = true;
            formContext.addField(eventKey, {
              fieldValue,
              fieldId,
              fieldName,
              resetField,
              clearValidate,
              namePath,
              validateRules: validateRules$1,
              rules: rulesRef
            });
          }
        } else {
          registered = false;
          formContext.removeField(eventKey);
        }
      }, {
        immediate: true
      });
      onBeforeUnmount(() => {
        formContext.removeField(eventKey);
      });
      const debounceErrors = useDebounce(errors);
      const mergedValidateStatus = computed(() => {
        if (props.validateStatus !== void 0) {
          return props.validateStatus;
        } else if (debounceErrors.value.length) {
          return "error";
        }
        return validateState.value;
      });
      const itemClassName = computed(() => ({
        [`${prefixCls.value}-item`]: true,
        [hashId.value]: true,
        // Status
        [`${prefixCls.value}-item-has-feedback`]: mergedValidateStatus.value && props.hasFeedback,
        [`${prefixCls.value}-item-has-success`]: mergedValidateStatus.value === "success",
        [`${prefixCls.value}-item-has-warning`]: mergedValidateStatus.value === "warning",
        [`${prefixCls.value}-item-has-error`]: mergedValidateStatus.value === "error",
        [`${prefixCls.value}-item-is-validating`]: mergedValidateStatus.value === "validating",
        [`${prefixCls.value}-item-hidden`]: props.hidden
      }));
      const formItemInputContext = reactive({});
      FormItemInputContext.useProvide(formItemInputContext);
      watchEffect(() => {
        let feedbackIcon;
        if (props.hasFeedback) {
          const IconNode = mergedValidateStatus.value && iconMap[mergedValidateStatus.value];
          feedbackIcon = IconNode ? createVNode("span", {
            "class": classNames(`${prefixCls.value}-item-feedback-icon`, `${prefixCls.value}-item-feedback-icon-${mergedValidateStatus.value}`)
          }, [createVNode(IconNode, null, null)]) : null;
        }
        _extends$1(formItemInputContext, {
          status: mergedValidateStatus.value,
          hasFeedback: props.hasFeedback,
          feedbackIcon,
          isFormItemInput: true
        });
      });
      const marginBottom = shallowRef(null);
      const showMarginOffset = shallowRef(false);
      const updateMarginBottom = () => {
        if (itemRef.value) {
          const itemStyle = getComputedStyle(itemRef.value);
          marginBottom.value = parseInt(itemStyle.marginBottom, 10);
        }
      };
      onMounted(() => {
        watch(showMarginOffset, () => {
          if (showMarginOffset.value) {
            updateMarginBottom();
          }
        }, {
          flush: "post",
          immediate: true
        });
      });
      const onErrorVisibleChanged = (nextVisible) => {
        if (!nextVisible) {
          marginBottom.value = null;
        }
      };
      return () => {
        var _a2, _b;
        if (props.noStyle)
          return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
        const help = (_b = props.help) !== null && _b !== void 0 ? _b : slots.help ? filterEmpty(slots.help()) : null;
        const withHelp = !!(help !== void 0 && help !== null && Array.isArray(help) && help.length || debounceErrors.value.length);
        showMarginOffset.value = withHelp;
        return wrapSSR(createVNode("div", {
          "class": [itemClassName.value, withHelp ? `${prefixCls.value}-item-with-help` : "", attrs.class],
          "ref": itemRef
        }, [createVNode(Row, _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": `${prefixCls.value}-row`,
          "key": "row"
        }), {
          default: () => {
            var _a3, _b2;
            return createVNode(Fragment, null, [createVNode(FormItemLabel$1, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
              "htmlFor": htmlFor.value,
              "required": isRequired2.value,
              "requiredMark": formContext.requiredMark.value,
              "prefixCls": prefixCls.value,
              "onClick": onLabelClick,
              "label": props.label
            }), {
              label: slots.label,
              tooltip: slots.tooltip
            }), createVNode(FormItemInput$1, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
              "errors": help !== void 0 && help !== null ? toArray$2(help) : debounceErrors.value,
              "marginBottom": marginBottom.value,
              "prefixCls": prefixCls.value,
              "status": mergedValidateStatus.value,
              "ref": inputRef,
              "help": help,
              "extra": (_a3 = props.extra) !== null && _a3 !== void 0 ? _a3 : (_b2 = slots.extra) === null || _b2 === void 0 ? void 0 : _b2.call(slots),
              "onErrorVisibleChanged": onErrorVisibleChanged
            }), {
              default: slots.default
            })]);
          }
        }), !!marginBottom.value && createVNode("div", {
          "class": `${prefixCls.value}-margin-offset`,
          "style": {
            marginBottom: `-${marginBottom.value}px`
          }
        }, null)]));
      };
    }
  });
  function allPromiseFinish(promiseList) {
    let hasError = false;
    let count = promiseList.length;
    const results = [];
    if (!promiseList.length) {
      return Promise.resolve([]);
    }
    return new Promise((resolve2, reject) => {
      promiseList.forEach((promise, index2) => {
        promise.catch((e2) => {
          hasError = true;
          return e2;
        }).then((result) => {
          count -= 1;
          results[index2] = result;
          if (count > 0) {
            return;
          }
          if (hasError) {
            reject(results);
          }
          resolve2(results);
        });
      });
    });
  }
  function isRequired(rules2) {
    let isRequired2 = false;
    if (rules2 && rules2.length) {
      rules2.every((rule) => {
        if (rule.required) {
          isRequired2 = true;
          return false;
        }
        return true;
      });
    }
    return isRequired2;
  }
  function toArray$1(value) {
    if (value === void 0 || value === null) {
      return [];
    }
    return Array.isArray(value) ? value : [value];
  }
  function getPropByPath(obj, path, strict) {
    let tempObj = obj;
    path = path.replace(/\[(\w+)\]/g, ".$1");
    path = path.replace(/^\./, "");
    const keyArr = path.split(".");
    let i2 = 0;
    for (let len = keyArr.length; i2 < len - 1; ++i2) {
      if (!tempObj && !strict)
        break;
      const key2 = keyArr[i2];
      if (key2 in tempObj) {
        tempObj = tempObj[key2];
      } else {
        if (strict) {
          throw new Error("please transfer a valid name path to validate!");
        }
        break;
      }
    }
    return {
      o: tempObj,
      k: keyArr[i2],
      v: tempObj ? tempObj[keyArr[i2]] : null,
      isValid: tempObj && keyArr[i2] in tempObj
    };
  }
  function useForm(modelRef) {
    let rulesRef = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ref({});
    let options = arguments.length > 2 ? arguments[2] : void 0;
    const initialModel = cloneDeep(unref(modelRef));
    const validateInfos = reactive({});
    const rulesKeys = shallowRef([]);
    const resetFields = (newValues) => {
      _extends$1(unref(modelRef), _extends$1(_extends$1({}, cloneDeep(initialModel)), newValues));
      nextTick(() => {
        Object.keys(validateInfos).forEach((key2) => {
          validateInfos[key2] = {
            autoLink: false,
            required: isRequired(unref(rulesRef)[key2])
          };
        });
      });
    };
    const filterRules = function() {
      let rules2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      let trigger2 = arguments.length > 1 ? arguments[1] : void 0;
      if (!trigger2.length) {
        return rules2;
      } else {
        return rules2.filter((rule) => {
          const triggerList = toArray$1(rule.trigger || "change");
          return intersection(triggerList, trigger2).length;
        });
      }
    };
    let lastValidatePromise = null;
    const validateFields = function(names2) {
      let option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let strict = arguments.length > 2 ? arguments[2] : void 0;
      const promiseList = [];
      const values = {};
      for (let i2 = 0; i2 < names2.length; i2++) {
        const name2 = names2[i2];
        const prop = getPropByPath(unref(modelRef), name2, strict);
        if (!prop.isValid)
          continue;
        values[name2] = prop.v;
        const rules2 = filterRules(unref(rulesRef)[name2], toArray$1(option && option.trigger));
        if (rules2.length) {
          promiseList.push(validateField(name2, prop.v, rules2, option || {}).then(() => ({
            name: name2,
            errors: [],
            warnings: []
          })).catch((ruleErrors) => {
            const mergedErrors = [];
            const mergedWarnings = [];
            ruleErrors.forEach((_ref) => {
              let {
                rule: {
                  warningOnly
                },
                errors
              } = _ref;
              if (warningOnly) {
                mergedWarnings.push(...errors);
              } else {
                mergedErrors.push(...errors);
              }
            });
            if (mergedErrors.length) {
              return Promise.reject({
                name: name2,
                errors: mergedErrors,
                warnings: mergedWarnings
              });
            }
            return {
              name: name2,
              errors: mergedErrors,
              warnings: mergedWarnings
            };
          }));
        }
      }
      const summaryPromise = allPromiseFinish(promiseList);
      lastValidatePromise = summaryPromise;
      const returnPromise = summaryPromise.then(() => {
        if (lastValidatePromise === summaryPromise) {
          return Promise.resolve(values);
        }
        return Promise.reject([]);
      }).catch((results) => {
        const errorList = results.filter((result) => result && result.errors.length);
        return Promise.reject({
          values,
          errorFields: errorList,
          outOfDate: lastValidatePromise !== summaryPromise
        });
      });
      returnPromise.catch((e2) => e2);
      return returnPromise;
    };
    const validateField = function(name2, value, rules2) {
      let option = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      const promise = validateRules([name2], value, rules2, _extends$1({
        validateMessages: defaultValidateMessages
      }, option), !!option.validateFirst);
      if (!validateInfos[name2]) {
        return promise.catch((e2) => e2);
      }
      validateInfos[name2].validateStatus = "validating";
      promise.catch((e2) => e2).then(function() {
        let results = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        var _a2;
        if (validateInfos[name2].validateStatus === "validating") {
          const res = results.filter((result) => result && result.errors.length);
          validateInfos[name2].validateStatus = res.length ? "error" : "success";
          validateInfos[name2].help = res.length ? res.map((r2) => r2.errors) : null;
          (_a2 = options === null || options === void 0 ? void 0 : options.onValidate) === null || _a2 === void 0 ? void 0 : _a2.call(options, name2, !res.length, res.length ? toRaw(validateInfos[name2].help[0]) : null);
        }
      });
      return promise;
    };
    const validate = (names2, option) => {
      let keys2 = [];
      let strict = true;
      if (!names2) {
        strict = false;
        keys2 = rulesKeys.value;
      } else if (Array.isArray(names2)) {
        keys2 = names2;
      } else {
        keys2 = [names2];
      }
      const promises = validateFields(keys2, option || {}, strict);
      promises.catch((e2) => e2);
      return promises;
    };
    const clearValidate = (names2) => {
      let keys2 = [];
      if (!names2) {
        keys2 = rulesKeys.value;
      } else if (Array.isArray(names2)) {
        keys2 = names2;
      } else {
        keys2 = [names2];
      }
      keys2.forEach((key2) => {
        validateInfos[key2] && _extends$1(validateInfos[key2], {
          validateStatus: "",
          help: null
        });
      });
    };
    const mergeValidateInfo = (items) => {
      const info = {
        autoLink: false
      };
      const help = [];
      const infos = Array.isArray(items) ? items : [items];
      for (let i2 = 0; i2 < infos.length; i2++) {
        const arg = infos[i2];
        if ((arg === null || arg === void 0 ? void 0 : arg.validateStatus) === "error") {
          info.validateStatus = "error";
          arg.help && help.push(arg.help);
        }
        info.required = info.required || (arg === null || arg === void 0 ? void 0 : arg.required);
      }
      info.help = help;
      return info;
    };
    let oldModel = initialModel;
    let isFirstTime = true;
    const modelFn = (model) => {
      const names2 = [];
      rulesKeys.value.forEach((key2) => {
        const prop = getPropByPath(model, key2, false);
        const oldProp = getPropByPath(oldModel, key2, false);
        const isFirstValidation = isFirstTime && (options === null || options === void 0 ? void 0 : options.immediate) && prop.isValid;
        if (isFirstValidation || !isEqual(prop.v, oldProp.v)) {
          names2.push(key2);
        }
      });
      validate(names2, {
        trigger: "change"
      });
      isFirstTime = false;
      oldModel = cloneDeep(toRaw(model));
    };
    const debounceOptions = options === null || options === void 0 ? void 0 : options.debounce;
    let first = true;
    watch(rulesRef, () => {
      rulesKeys.value = rulesRef ? Object.keys(unref(rulesRef)) : [];
      if (!first && options && options.validateOnRuleChange) {
        validate();
      }
      first = false;
    }, {
      deep: true,
      immediate: true
    });
    watch(rulesKeys, () => {
      const newValidateInfos = {};
      rulesKeys.value.forEach((key2) => {
        newValidateInfos[key2] = _extends$1({}, validateInfos[key2], {
          autoLink: false,
          required: isRequired(unref(rulesRef)[key2])
        });
        delete validateInfos[key2];
      });
      for (const key2 in validateInfos) {
        if (Object.prototype.hasOwnProperty.call(validateInfos, key2)) {
          delete validateInfos[key2];
        }
      }
      _extends$1(validateInfos, newValidateInfos);
    }, {
      immediate: true
    });
    watch(modelRef, debounceOptions && debounceOptions.wait ? debounce(modelFn, debounceOptions.wait, omit(debounceOptions, ["wait"])) : modelFn, {
      immediate: options && !!options.immediate,
      deep: true
    });
    return {
      modelRef,
      rulesRef,
      initialModel,
      validateInfos,
      resetFields,
      validate,
      validateField,
      mergeValidateInfo,
      clearValidate
    };
  }
  const formProps = () => ({
    layout: PropTypes.oneOf(tuple("horizontal", "inline", "vertical")),
    labelCol: objectType(),
    wrapperCol: objectType(),
    colon: booleanType(),
    labelAlign: stringType(),
    labelWrap: booleanType(),
    prefixCls: String,
    requiredMark: someType([String, Boolean]),
    /** @deprecated Will warning in future branch. Pls use `requiredMark` instead. */
    hideRequiredMark: booleanType(),
    model: PropTypes.object,
    rules: objectType(),
    validateMessages: objectType(),
    validateOnRuleChange: booleanType(),
    // 提交失败自动滚动到第一个错误字段
    scrollToFirstError: anyType(),
    onSubmit: functionType(),
    name: String,
    validateTrigger: someType([String, Array]),
    size: stringType(),
    disabled: booleanType(),
    onValuesChange: functionType(),
    onFieldsChange: functionType(),
    onFinish: functionType(),
    onFinishFailed: functionType(),
    onValidate: functionType()
  });
  function isEqualName(name1, name2) {
    return isEqual(toArray$2(name1), toArray$2(name2));
  }
  const Form = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AForm",
    inheritAttrs: false,
    props: initDefaultProps(formProps(), {
      layout: "horizontal",
      hideRequiredMark: false,
      colon: true
    }),
    Item: FormItem,
    useForm,
    // emits: ['finishFailed', 'submit', 'finish', 'validate'],
    setup(props, _ref) {
      let {
        emit: emit2,
        slots,
        expose,
        attrs
      } = _ref;
      const {
        prefixCls,
        direction,
        form: contextForm,
        size: size2,
        disabled
      } = useConfigInject("form", props);
      const requiredMark = computed(() => props.requiredMark === "" || props.requiredMark);
      const mergedRequiredMark = computed(() => {
        var _a2;
        if (requiredMark.value !== void 0) {
          return requiredMark.value;
        }
        if (contextForm && ((_a2 = contextForm.value) === null || _a2 === void 0 ? void 0 : _a2.requiredMark) !== void 0) {
          return contextForm.value.requiredMark;
        }
        if (props.hideRequiredMark) {
          return false;
        }
        return true;
      });
      useProviderSize(size2);
      useProviderDisabled(disabled);
      const mergedColon = computed(() => {
        var _a2, _b;
        return (_a2 = props.colon) !== null && _a2 !== void 0 ? _a2 : (_b = contextForm.value) === null || _b === void 0 ? void 0 : _b.colon;
      });
      const {
        validateMessages: globalValidateMessages
      } = useInjectGlobalForm();
      const validateMessages = computed(() => {
        return _extends$1(_extends$1(_extends$1({}, defaultValidateMessages), globalValidateMessages.value), props.validateMessages);
      });
      const [wrapSSR, hashId] = useStyle$6(prefixCls);
      const formClassName = computed(() => classNames(prefixCls.value, {
        [`${prefixCls.value}-${props.layout}`]: true,
        [`${prefixCls.value}-hide-required-mark`]: mergedRequiredMark.value === false,
        [`${prefixCls.value}-rtl`]: direction.value === "rtl",
        [`${prefixCls.value}-${size2.value}`]: size2.value
      }, hashId.value));
      const lastValidatePromise = ref();
      const fields = {};
      const addField = (eventKey, field) => {
        fields[eventKey] = field;
      };
      const removeField = (eventKey) => {
        delete fields[eventKey];
      };
      const getFieldsByNameList = (nameList) => {
        const provideNameList = !!nameList;
        const namePathList = provideNameList ? toArray$2(nameList).map(getNamePath) : [];
        if (!provideNameList) {
          return Object.values(fields);
        } else {
          return Object.values(fields).filter((field) => namePathList.findIndex((namePath) => isEqualName(namePath, field.fieldName.value)) > -1);
        }
      };
      const resetFields = (name2) => {
        if (!props.model) {
          warning$3(false, "Form", "model is required for resetFields to work.");
          return;
        }
        getFieldsByNameList(name2).forEach((field) => {
          field.resetField();
        });
      };
      const clearValidate = (name2) => {
        getFieldsByNameList(name2).forEach((field) => {
          field.clearValidate();
        });
      };
      const handleFinishFailed = (errorInfo) => {
        const {
          scrollToFirstError
        } = props;
        emit2("finishFailed", errorInfo);
        if (scrollToFirstError && errorInfo.errorFields.length) {
          let scrollToFieldOptions = {};
          if (typeof scrollToFirstError === "object") {
            scrollToFieldOptions = scrollToFirstError;
          }
          scrollToField(errorInfo.errorFields[0].name, scrollToFieldOptions);
        }
      };
      const validate = function() {
        return validateField(...arguments);
      };
      const scrollToField = function(name2) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const fields2 = getFieldsByNameList(name2 ? [name2] : void 0);
        if (fields2.length) {
          const fieldId = fields2[0].fieldId.value;
          const node2 = fieldId ? document.getElementById(fieldId) : null;
          if (node2) {
            scrollIntoView(node2, _extends$1({
              scrollMode: "if-needed",
              block: "nearest"
            }, options));
          }
        }
      };
      const getFieldsValue = function() {
        let nameList = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        if (nameList === true) {
          const allNameList = [];
          Object.values(fields).forEach((_ref2) => {
            let {
              namePath
            } = _ref2;
            allNameList.push(namePath.value);
          });
          return cloneByNamePathList(props.model, allNameList);
        } else {
          return cloneByNamePathList(props.model, nameList);
        }
      };
      const validateFields = (nameList, options) => {
        warning$3(!(nameList instanceof Function), "Form", "validateFields/validateField/validate not support callback, please use promise instead");
        if (!props.model) {
          warning$3(false, "Form", "model is required for validateFields to work.");
          return Promise.reject("Form `model` is required for validateFields to work.");
        }
        const provideNameList = !!nameList;
        const namePathList = provideNameList ? toArray$2(nameList).map(getNamePath) : [];
        const promiseList = [];
        Object.values(fields).forEach((field) => {
          var _a2;
          if (!provideNameList) {
            namePathList.push(field.namePath.value);
          }
          if (!((_a2 = field.rules) === null || _a2 === void 0 ? void 0 : _a2.value.length)) {
            return;
          }
          const fieldNamePath = field.namePath.value;
          if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {
            const promise = field.validateRules(_extends$1({
              validateMessages: validateMessages.value
            }, options));
            promiseList.push(promise.then(() => ({
              name: fieldNamePath,
              errors: [],
              warnings: []
            })).catch((ruleErrors) => {
              const mergedErrors = [];
              const mergedWarnings = [];
              ruleErrors.forEach((_ref3) => {
                let {
                  rule: {
                    warningOnly
                  },
                  errors
                } = _ref3;
                if (warningOnly) {
                  mergedWarnings.push(...errors);
                } else {
                  mergedErrors.push(...errors);
                }
              });
              if (mergedErrors.length) {
                return Promise.reject({
                  name: fieldNamePath,
                  errors: mergedErrors,
                  warnings: mergedWarnings
                });
              }
              return {
                name: fieldNamePath,
                errors: mergedErrors,
                warnings: mergedWarnings
              };
            }));
          }
        });
        const summaryPromise = allPromiseFinish(promiseList);
        lastValidatePromise.value = summaryPromise;
        const returnPromise = summaryPromise.then(() => {
          if (lastValidatePromise.value === summaryPromise) {
            return Promise.resolve(getFieldsValue(namePathList));
          }
          return Promise.reject([]);
        }).catch((results) => {
          const errorList = results.filter((result) => result && result.errors.length);
          return Promise.reject({
            values: getFieldsValue(namePathList),
            errorFields: errorList,
            outOfDate: lastValidatePromise.value !== summaryPromise
          });
        });
        returnPromise.catch((e2) => e2);
        return returnPromise;
      };
      const validateField = function() {
        return validateFields(...arguments);
      };
      const handleSubmit = (e2) => {
        e2.preventDefault();
        e2.stopPropagation();
        emit2("submit", e2);
        if (props.model) {
          const res = validateFields();
          res.then((values) => {
            emit2("finish", values);
          }).catch((errors) => {
            handleFinishFailed(errors);
          });
        }
      };
      expose({
        resetFields,
        clearValidate,
        validateFields,
        getFieldsValue,
        validate,
        scrollToField
      });
      useProvideForm({
        model: computed(() => props.model),
        name: computed(() => props.name),
        labelAlign: computed(() => props.labelAlign),
        labelCol: computed(() => props.labelCol),
        labelWrap: computed(() => props.labelWrap),
        wrapperCol: computed(() => props.wrapperCol),
        vertical: computed(() => props.layout === "vertical"),
        colon: mergedColon,
        requiredMark: mergedRequiredMark,
        validateTrigger: computed(() => props.validateTrigger),
        rules: computed(() => props.rules),
        addField,
        removeField,
        onValidate: (name2, status, errors) => {
          emit2("validate", name2, status, errors);
        },
        validateMessages
      });
      watch(() => props.rules, () => {
        if (props.validateOnRuleChange) {
          validateFields();
        }
      });
      return () => {
        var _a2;
        return wrapSSR(createVNode("form", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "onSubmit": handleSubmit,
          "class": [formClassName.value, attrs.class]
        }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]));
      };
    }
  });
  const Form$1 = Form;
  Form$1.useInjectFormItemContext = useInjectFormItemContext;
  Form$1.ItemRest = FormItemRest;
  Form$1.install = function(app2) {
    app2.component(Form$1.name, Form$1);
    app2.component(Form$1.Item.name, Form$1.Item);
    app2.component(FormItemRest.name, FormItemRest);
    return app2;
  };
  const antCheckboxEffect = new Keyframe("antCheckboxEffect", {
    "0%": {
      transform: "scale(1)",
      opacity: 0.5
    },
    "100%": {
      transform: "scale(1.6)",
      opacity: 0
    }
  });
  const genCheckboxStyle = (token2) => {
    const {
      checkboxCls
    } = token2;
    const wrapperCls = `${checkboxCls}-wrapper`;
    return [
      // ===================== Basic =====================
      {
        // Group
        [`${checkboxCls}-group`]: _extends$1(_extends$1({}, resetComponent(token2)), {
          display: "inline-flex",
          flexWrap: "wrap",
          columnGap: token2.marginXS,
          // Group > Grid
          [`> ${token2.antCls}-row`]: {
            flex: 1
          }
        }),
        // Wrapper
        [wrapperCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
          display: "inline-flex",
          alignItems: "baseline",
          cursor: "pointer",
          // Fix checkbox & radio in flex align #30260
          "&:after": {
            display: "inline-block",
            width: 0,
            overflow: "hidden",
            content: "'\\a0'"
          },
          // Checkbox near checkbox
          [`& + ${wrapperCls}`]: {
            marginInlineStart: 0
          },
          [`&${wrapperCls}-in-form-item`]: {
            'input[type="checkbox"]': {
              width: 14,
              height: 14
              // FIXME: magic
            }
          }
        }),
        // Wrapper > Checkbox
        [checkboxCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
          position: "relative",
          whiteSpace: "nowrap",
          lineHeight: 1,
          cursor: "pointer",
          // To make alignment right when `controlHeight` is changed
          // Ref: https://github.com/ant-design/ant-design/issues/41564
          alignSelf: "center",
          // Wrapper > Checkbox > input
          [`${checkboxCls}-input`]: {
            position: "absolute",
            // Since baseline align will get additional space offset,
            // we need to move input to top to make it align with text.
            // Ref: https://github.com/ant-design/ant-design/issues/38926#issuecomment-1486137799
            inset: 0,
            zIndex: 1,
            cursor: "pointer",
            opacity: 0,
            margin: 0,
            [`&:focus-visible + ${checkboxCls}-inner`]: _extends$1({}, genFocusOutline(token2))
          },
          // Wrapper > Checkbox > inner
          [`${checkboxCls}-inner`]: {
            boxSizing: "border-box",
            position: "relative",
            top: 0,
            insetInlineStart: 0,
            display: "block",
            width: token2.checkboxSize,
            height: token2.checkboxSize,
            direction: "ltr",
            backgroundColor: token2.colorBgContainer,
            border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
            borderRadius: token2.borderRadiusSM,
            borderCollapse: "separate",
            transition: `all ${token2.motionDurationSlow}`,
            "&:after": {
              boxSizing: "border-box",
              position: "absolute",
              top: "50%",
              insetInlineStart: "21.5%",
              display: "table",
              width: token2.checkboxSize / 14 * 5,
              height: token2.checkboxSize / 14 * 8,
              border: `${token2.lineWidthBold}px solid ${token2.colorWhite}`,
              borderTop: 0,
              borderInlineStart: 0,
              transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
              opacity: 0,
              content: '""',
              transition: `all ${token2.motionDurationFast} ${token2.motionEaseInBack}, opacity ${token2.motionDurationFast}`
            }
          },
          // Wrapper > Checkbox + Text
          "& + span": {
            paddingInlineStart: token2.paddingXS,
            paddingInlineEnd: token2.paddingXS
          }
        })
      },
      // ================= Indeterminate =================
      {
        [checkboxCls]: {
          "&-indeterminate": {
            // Wrapper > Checkbox > inner
            [`${checkboxCls}-inner`]: {
              "&:after": {
                top: "50%",
                insetInlineStart: "50%",
                width: token2.fontSizeLG / 2,
                height: token2.fontSizeLG / 2,
                backgroundColor: token2.colorPrimary,
                border: 0,
                transform: "translate(-50%, -50%) scale(1)",
                opacity: 1,
                content: '""'
              }
            }
          }
        }
      },
      // ===================== Hover =====================
      {
        // Wrapper
        [`${wrapperCls}:hover ${checkboxCls}:after`]: {
          visibility: "visible"
        },
        // Wrapper & Wrapper > Checkbox
        [`
        ${wrapperCls}:not(${wrapperCls}-disabled),
        ${checkboxCls}:not(${checkboxCls}-disabled)
      `]: {
          [`&:hover ${checkboxCls}-inner`]: {
            borderColor: token2.colorPrimary
          }
        },
        [`${wrapperCls}:not(${wrapperCls}-disabled)`]: {
          [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled) ${checkboxCls}-inner`]: {
            backgroundColor: token2.colorPrimaryHover,
            borderColor: "transparent"
          },
          [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled):after`]: {
            borderColor: token2.colorPrimaryHover
          }
        }
      },
      // ==================== Checked ====================
      {
        // Wrapper > Checkbox
        [`${checkboxCls}-checked`]: {
          [`${checkboxCls}-inner`]: {
            backgroundColor: token2.colorPrimary,
            borderColor: token2.colorPrimary,
            "&:after": {
              opacity: 1,
              transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
              transition: `all ${token2.motionDurationMid} ${token2.motionEaseOutBack} ${token2.motionDurationFast}`
            }
          },
          // Checked Effect
          "&:after": {
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            width: "100%",
            height: "100%",
            borderRadius: token2.borderRadiusSM,
            visibility: "hidden",
            border: `${token2.lineWidthBold}px solid ${token2.colorPrimary}`,
            animationName: antCheckboxEffect,
            animationDuration: token2.motionDurationSlow,
            animationTimingFunction: "ease-in-out",
            animationFillMode: "backwards",
            content: '""',
            transition: `all ${token2.motionDurationSlow}`
          }
        },
        [`
        ${wrapperCls}-checked:not(${wrapperCls}-disabled),
        ${checkboxCls}-checked:not(${checkboxCls}-disabled)
      `]: {
          [`&:hover ${checkboxCls}-inner`]: {
            backgroundColor: token2.colorPrimaryHover,
            borderColor: "transparent"
          },
          [`&:hover ${checkboxCls}:after`]: {
            borderColor: token2.colorPrimaryHover
          }
        }
      },
      // ==================== Disable ====================
      {
        // Wrapper
        [`${wrapperCls}-disabled`]: {
          cursor: "not-allowed"
        },
        // Wrapper > Checkbox
        [`${checkboxCls}-disabled`]: {
          // Wrapper > Checkbox > input
          [`&, ${checkboxCls}-input`]: {
            cursor: "not-allowed",
            // Disabled for native input to enable Tooltip event handler
            // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-1365075901
            pointerEvents: "none"
          },
          // Wrapper > Checkbox > inner
          [`${checkboxCls}-inner`]: {
            background: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder,
            "&:after": {
              borderColor: token2.colorTextDisabled
            }
          },
          "&:after": {
            display: "none"
          },
          "& + span": {
            color: token2.colorTextDisabled
          },
          [`&${checkboxCls}-indeterminate ${checkboxCls}-inner::after`]: {
            background: token2.colorTextDisabled
          }
        }
      }
    ];
  };
  function getStyle$1(prefixCls, token2) {
    const checkboxToken = merge(token2, {
      checkboxCls: `.${prefixCls}`,
      checkboxSize: token2.controlInteractiveSize
    });
    return [genCheckboxStyle(checkboxToken)];
  }
  const useStyle$5 = genComponentStyleHook("Checkbox", (token2, _ref) => {
    let {
      prefixCls
    } = _ref;
    return [getStyle$1(prefixCls, token2)];
  });
  const abstractCheckboxGroupProps = () => {
    return {
      name: String,
      prefixCls: String,
      options: arrayType([]),
      disabled: Boolean,
      id: String
    };
  };
  const checkboxGroupProps = () => {
    return _extends$1(_extends$1({}, abstractCheckboxGroupProps()), {
      defaultValue: arrayType(),
      value: arrayType(),
      onChange: functionType(),
      "onUpdate:value": functionType()
    });
  };
  const abstractCheckboxProps = () => {
    return {
      prefixCls: String,
      defaultChecked: booleanType(),
      checked: booleanType(),
      disabled: booleanType(),
      isGroup: booleanType(),
      value: PropTypes.any,
      name: String,
      id: String,
      indeterminate: booleanType(),
      type: stringType("checkbox"),
      autofocus: booleanType(),
      onChange: functionType(),
      "onUpdate:checked": functionType(),
      onClick: functionType(),
      skipGroup: booleanType(false)
    };
  };
  const checkboxProps = () => {
    return _extends$1(_extends$1({}, abstractCheckboxProps()), {
      indeterminate: booleanType(false)
    });
  };
  const CheckboxGroupContextKey = Symbol("CheckboxGroupContext");
  var __rest$d = function(s2, e2) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  const Checkbox = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ACheckbox",
    inheritAttrs: false,
    __ANT_CHECKBOX: true,
    props: checkboxProps(),
    // emits: ['change', 'update:checked'],
    setup(props, _ref) {
      let {
        emit: emit2,
        attrs,
        slots,
        expose
      } = _ref;
      const formItemContext = useInjectFormItemContext();
      const formItemInputContext = FormItemInputContext.useInject();
      const {
        prefixCls,
        direction,
        disabled
      } = useConfigInject("checkbox", props);
      const contextDisabled = useInjectDisabled();
      const [wrapSSR, hashId] = useStyle$5(prefixCls);
      const checkboxGroup = inject(CheckboxGroupContextKey, void 0);
      const uniId = Symbol("checkboxUniId");
      const mergedDisabled = computed(() => {
        return (checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.disabled.value) || disabled.value;
      });
      watchEffect(() => {
        if (!props.skipGroup && checkboxGroup) {
          checkboxGroup.registerValue(uniId, props.value);
        }
      });
      onBeforeUnmount(() => {
        if (checkboxGroup) {
          checkboxGroup.cancelValue(uniId);
        }
      });
      onMounted(() => {
        warning$3(!!(props.checked !== void 0 || checkboxGroup || props.value === void 0), "Checkbox", "`value` is not validate prop, do you mean `checked`?");
      });
      const handleChange = (event) => {
        const targetChecked = event.target.checked;
        emit2("update:checked", targetChecked);
        emit2("change", event);
        formItemContext.onFieldChange();
      };
      const checkboxRef = ref();
      const focus = () => {
        var _a2;
        (_a2 = checkboxRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      };
      const blur = () => {
        var _a2;
        (_a2 = checkboxRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      };
      expose({
        focus,
        blur
      });
      return () => {
        var _a2;
        const children = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
        const {
          indeterminate,
          skipGroup,
          id = formItemContext.id.value
        } = props, restProps = __rest$d(props, ["indeterminate", "skipGroup", "id"]);
        const {
          onMouseenter,
          onMouseleave,
          onInput,
          class: className,
          style
        } = attrs, restAttrs = __rest$d(attrs, ["onMouseenter", "onMouseleave", "onInput", "class", "style"]);
        const checkboxProps2 = _extends$1(_extends$1(_extends$1(_extends$1({}, restProps), {
          id,
          prefixCls: prefixCls.value
        }), restAttrs), {
          disabled: mergedDisabled.value
        });
        if (checkboxGroup && !skipGroup) {
          checkboxProps2.onChange = function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            emit2("change", ...args);
            checkboxGroup.toggleOption({
              label: children,
              value: props.value
            });
          };
          checkboxProps2.name = checkboxGroup.name.value;
          checkboxProps2.checked = checkboxGroup.mergedValue.value.includes(props.value);
          checkboxProps2.disabled = mergedDisabled.value || contextDisabled.value;
          checkboxProps2.indeterminate = indeterminate;
        } else {
          checkboxProps2.onChange = handleChange;
        }
        const classString = classNames({
          [`${prefixCls.value}-wrapper`]: true,
          [`${prefixCls.value}-rtl`]: direction.value === "rtl",
          [`${prefixCls.value}-wrapper-checked`]: checkboxProps2.checked,
          [`${prefixCls.value}-wrapper-disabled`]: checkboxProps2.disabled,
          [`${prefixCls.value}-wrapper-in-form-item`]: formItemInputContext.isFormItemInput
        }, className, hashId.value);
        const checkboxClass = classNames({
          [`${prefixCls.value}-indeterminate`]: indeterminate
        }, hashId.value);
        const ariaChecked = indeterminate ? "mixed" : void 0;
        return wrapSSR(createVNode("label", {
          "class": classString,
          "style": style,
          "onMouseenter": onMouseenter,
          "onMouseleave": onMouseleave
        }, [createVNode(VcCheckbox, _objectSpread2$1(_objectSpread2$1({
          "aria-checked": ariaChecked
        }, checkboxProps2), {}, {
          "class": checkboxClass,
          "ref": checkboxRef
        }), null), children.length ? createVNode("span", null, [children]) : null]));
      };
    }
  });
  const CheckboxGroup = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ACheckboxGroup",
    inheritAttrs: false,
    props: checkboxGroupProps(),
    // emits: ['change', 'update:value'],
    setup(props, _ref) {
      let {
        slots,
        attrs,
        emit: emit2,
        expose
      } = _ref;
      const formItemContext = useInjectFormItemContext();
      const {
        prefixCls,
        direction
      } = useConfigInject("checkbox", props);
      const groupPrefixCls = computed(() => `${prefixCls.value}-group`);
      const [wrapSSR, hashId] = useStyle$5(groupPrefixCls);
      const mergedValue = ref((props.value === void 0 ? props.defaultValue : props.value) || []);
      watch(() => props.value, () => {
        mergedValue.value = props.value || [];
      });
      const options = computed(() => {
        return props.options.map((option) => {
          if (typeof option === "string" || typeof option === "number") {
            return {
              label: option,
              value: option
            };
          }
          return option;
        });
      });
      const triggerUpdate = ref(Symbol());
      const registeredValuesMap = ref(/* @__PURE__ */ new Map());
      const cancelValue = (id) => {
        registeredValuesMap.value.delete(id);
        triggerUpdate.value = Symbol();
      };
      const registerValue = (id, value) => {
        registeredValuesMap.value.set(id, value);
        triggerUpdate.value = Symbol();
      };
      const registeredValues = ref(/* @__PURE__ */ new Map());
      watch(triggerUpdate, () => {
        const valuseMap = /* @__PURE__ */ new Map();
        for (const value of registeredValuesMap.value.values()) {
          valuseMap.set(value, true);
        }
        registeredValues.value = valuseMap;
      });
      const toggleOption = (option) => {
        const optionIndex = mergedValue.value.indexOf(option.value);
        const value = [...mergedValue.value];
        if (optionIndex === -1) {
          value.push(option.value);
        } else {
          value.splice(optionIndex, 1);
        }
        if (props.value === void 0) {
          mergedValue.value = value;
        }
        const val = value.filter((val2) => registeredValues.value.has(val2)).sort((a2, b2) => {
          const indexA = options.value.findIndex((opt) => opt.value === a2);
          const indexB = options.value.findIndex((opt) => opt.value === b2);
          return indexA - indexB;
        });
        emit2("update:value", val);
        emit2("change", val);
        formItemContext.onFieldChange();
      };
      provide(CheckboxGroupContextKey, {
        cancelValue,
        registerValue,
        toggleOption,
        mergedValue,
        name: computed(() => props.name),
        disabled: computed(() => props.disabled)
      });
      expose({
        mergedValue
      });
      return () => {
        var _a2;
        const {
          id = formItemContext.id.value
        } = props;
        let children = null;
        if (options.value && options.value.length > 0) {
          children = options.value.map((option) => {
            var _a3;
            return createVNode(Checkbox, {
              "prefixCls": prefixCls.value,
              "key": option.value.toString(),
              "disabled": "disabled" in option ? option.disabled : props.disabled,
              "indeterminate": option.indeterminate,
              "value": option.value,
              "checked": mergedValue.value.indexOf(option.value) !== -1,
              "onChange": option.onChange,
              "class": `${groupPrefixCls.value}-item`
            }, {
              default: () => [slots.label !== void 0 ? (_a3 = slots.label) === null || _a3 === void 0 ? void 0 : _a3.call(slots, option) : option.label]
            });
          });
        }
        return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": [groupPrefixCls.value, {
            [`${groupPrefixCls.value}-rtl`]: direction.value === "rtl"
          }, attrs.class, hashId.value],
          "id": id
        }), [children || ((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots))]));
      };
    }
  });
  Checkbox.Group = CheckboxGroup;
  Checkbox.install = function(app2) {
    app2.component(Checkbox.name, Checkbox);
    app2.component(CheckboxGroup.name, CheckboxGroup);
    return app2;
  };
  let runtimeLocale = _extends$1({}, localeValues$1.Modal);
  function changeConfirmLocale(newLocale) {
    if (newLocale) {
      runtimeLocale = _extends$1(_extends$1({}, runtimeLocale), newLocale);
    } else {
      runtimeLocale = _extends$1({}, localeValues$1.Modal);
    }
  }
  function getConfirmLocale() {
    return runtimeLocale;
  }
  const ANT_MARK = "internalMark";
  const LocaleProvider = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ALocaleProvider",
    props: {
      locale: {
        type: Object
      },
      ANT_MARK__: String
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      warning$3(props.ANT_MARK__ === ANT_MARK, "LocaleProvider", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead");
      const state = reactive({
        antLocale: _extends$1(_extends$1({}, props.locale), {
          exist: true
        }),
        ANT_MARK__: ANT_MARK
      });
      provide("localeData", state);
      watch(() => props.locale, (locale2) => {
        changeConfirmLocale(locale2 && locale2.Modal);
        state.antLocale = _extends$1(_extends$1({}, locale2), {
          exist: true
        });
      }, {
        immediate: true
      });
      return () => {
        var _a2;
        return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
      };
    }
  });
  LocaleProvider.install = function(app2) {
    app2.component(LocaleProvider.name, LocaleProvider);
    return app2;
  };
  const locale$3 = withInstall(LocaleProvider);
  const Notice = /* @__PURE__ */ defineComponent({
    name: "Notice",
    inheritAttrs: false,
    props: ["prefixCls", "duration", "updateMark", "noticeKey", "closeIcon", "closable", "props", "onClick", "onClose", "holder", "visible"],
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      let closeTimer;
      let isUnMounted = false;
      const duration = computed(() => props.duration === void 0 ? 4.5 : props.duration);
      const startCloseTimer = () => {
        if (duration.value && !isUnMounted) {
          closeTimer = setTimeout(() => {
            close();
          }, duration.value * 1e3);
        }
      };
      const clearCloseTimer = () => {
        if (closeTimer) {
          clearTimeout(closeTimer);
          closeTimer = null;
        }
      };
      const close = (e2) => {
        if (e2) {
          e2.stopPropagation();
        }
        clearCloseTimer();
        const {
          onClose,
          noticeKey
        } = props;
        if (onClose) {
          onClose(noticeKey);
        }
      };
      const restartCloseTimer = () => {
        clearCloseTimer();
        startCloseTimer();
      };
      onMounted(() => {
        startCloseTimer();
      });
      onUnmounted(() => {
        isUnMounted = true;
        clearCloseTimer();
      });
      watch([duration, () => props.updateMark, () => props.visible], (_ref2, _ref3) => {
        let [preDuration, preUpdateMark, preVisible] = _ref2;
        let [newDuration, newUpdateMark, newVisible] = _ref3;
        if (preDuration !== newDuration || preUpdateMark !== newUpdateMark || preVisible !== newVisible && newVisible) {
          restartCloseTimer();
        }
      }, {
        flush: "post"
      });
      return () => {
        var _a2, _b;
        const {
          prefixCls,
          closable,
          closeIcon = (_a2 = slots.closeIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          onClick,
          holder
        } = props;
        const {
          class: className,
          style
        } = attrs;
        const componentClass = `${prefixCls}-notice`;
        const dataOrAriaAttributeProps = Object.keys(attrs).reduce((acc, key2) => {
          if (key2.startsWith("data-") || key2.startsWith("aria-") || key2 === "role") {
            acc[key2] = attrs[key2];
          }
          return acc;
        }, {});
        const node2 = createVNode("div", _objectSpread2$1({
          "class": classNames(componentClass, className, {
            [`${componentClass}-closable`]: closable
          }),
          "style": style,
          "onMouseenter": clearCloseTimer,
          "onMouseleave": startCloseTimer,
          "onClick": onClick
        }, dataOrAriaAttributeProps), [createVNode("div", {
          "class": `${componentClass}-content`
        }, [(_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots)]), closable ? createVNode("a", {
          "tabindex": 0,
          "onClick": close,
          "class": `${componentClass}-close`
        }, [closeIcon || createVNode("span", {
          "class": `${componentClass}-close-x`
        }, null)]) : null]);
        if (holder) {
          return createVNode(Teleport, {
            "to": holder
          }, {
            default: () => node2
          });
        }
        return node2;
      };
    }
  });
  var __rest$c = function(s2, e2) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  let seed$1 = 0;
  const now$2 = Date.now();
  function getUuid$1() {
    const id = seed$1;
    seed$1 += 1;
    return `rcNotification_${now$2}_${id}`;
  }
  const Notification$1 = /* @__PURE__ */ defineComponent({
    name: "Notification",
    inheritAttrs: false,
    props: ["prefixCls", "transitionName", "animation", "maxCount", "closeIcon", "hashId"],
    setup(props, _ref) {
      let {
        attrs,
        expose,
        slots
      } = _ref;
      const hookRefs = /* @__PURE__ */ new Map();
      const notices = ref([]);
      const transitionProps = computed(() => {
        const {
          prefixCls,
          animation = "fade"
        } = props;
        let name2 = props.transitionName;
        if (!name2 && animation) {
          name2 = `${prefixCls}-${animation}`;
        }
        return getTransitionGroupProps(name2);
      });
      const add2 = (originNotice, holderCallback) => {
        const key2 = originNotice.key || getUuid$1();
        const notice2 = _extends$1(_extends$1({}, originNotice), {
          key: key2
        });
        const {
          maxCount: maxCount2
        } = props;
        const noticeIndex = notices.value.map((v2) => v2.notice.key).indexOf(key2);
        const updatedNotices = notices.value.concat();
        if (noticeIndex !== -1) {
          updatedNotices.splice(noticeIndex, 1, {
            notice: notice2,
            holderCallback
          });
        } else {
          if (maxCount2 && notices.value.length >= maxCount2) {
            notice2.key = updatedNotices[0].notice.key;
            notice2.updateMark = getUuid$1();
            notice2.userPassKey = key2;
            updatedNotices.shift();
          }
          updatedNotices.push({
            notice: notice2,
            holderCallback
          });
        }
        notices.value = updatedNotices;
      };
      const remove2 = (removeKey) => {
        notices.value = notices.value.filter((_ref2) => {
          let {
            notice: {
              key: key2,
              userPassKey
            }
          } = _ref2;
          const mergedKey = userPassKey || key2;
          return mergedKey !== removeKey;
        });
      };
      expose({
        add: add2,
        remove: remove2,
        notices
      });
      return () => {
        var _a2;
        const {
          prefixCls,
          closeIcon = (_a2 = slots.closeIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots, {
            prefixCls
          })
        } = props;
        const noticeNodes = notices.value.map((_ref3, index2) => {
          let {
            notice: notice2,
            holderCallback
          } = _ref3;
          const updateMark = index2 === notices.value.length - 1 ? notice2.updateMark : void 0;
          const {
            key: key2,
            userPassKey
          } = notice2;
          const {
            content
          } = notice2;
          const noticeProps = _extends$1(_extends$1(_extends$1({
            prefixCls,
            closeIcon: typeof closeIcon === "function" ? closeIcon({
              prefixCls
            }) : closeIcon
          }, notice2), notice2.props), {
            key: key2,
            noticeKey: userPassKey || key2,
            updateMark,
            onClose: (noticeKey) => {
              var _a3;
              remove2(noticeKey);
              (_a3 = notice2.onClose) === null || _a3 === void 0 ? void 0 : _a3.call(notice2);
            },
            onClick: notice2.onClick
          });
          if (holderCallback) {
            return createVNode("div", {
              "key": key2,
              "class": `${prefixCls}-hook-holder`,
              "ref": (div) => {
                if (typeof key2 === "undefined") {
                  return;
                }
                if (div) {
                  hookRefs.set(key2, div);
                  holderCallback(div, noticeProps);
                } else {
                  hookRefs.delete(key2);
                }
              }
            }, null);
          }
          return createVNode(Notice, _objectSpread2$1(_objectSpread2$1({}, noticeProps), {}, {
            "class": classNames(noticeProps.class, props.hashId)
          }), {
            default: () => [typeof content === "function" ? content({
              prefixCls
            }) : content]
          });
        });
        const className = {
          [prefixCls]: 1,
          [attrs.class]: !!attrs.class,
          [props.hashId]: true
        };
        return createVNode("div", {
          "class": className,
          "style": attrs.style || {
            top: "65px",
            left: "50%"
          }
        }, [createVNode(TransitionGroup, _objectSpread2$1({
          "tag": "div"
        }, transitionProps.value), {
          default: () => [noticeNodes]
        })]);
      };
    }
  });
  Notification$1.newInstance = function newNotificationInstance(properties, callback) {
    const _a2 = properties || {}, {
      name: name2 = "notification",
      getContainer: getContainer2,
      appContext,
      prefixCls: customizePrefixCls,
      rootPrefixCls: customRootPrefixCls,
      transitionName: customTransitionName,
      hasTransitionName: hasTransitionName2,
      useStyle: useStyle2
    } = _a2, props = __rest$c(_a2, ["name", "getContainer", "appContext", "prefixCls", "rootPrefixCls", "transitionName", "hasTransitionName", "useStyle"]);
    const div = document.createElement("div");
    if (getContainer2) {
      const root2 = getContainer2();
      root2.appendChild(div);
    } else {
      document.body.appendChild(div);
    }
    const Wrapper = /* @__PURE__ */ defineComponent({
      compatConfig: {
        MODE: 3
      },
      name: "NotificationWrapper",
      setup(_props, _ref4) {
        let {
          attrs
        } = _ref4;
        const notiRef = shallowRef();
        const prefixCls = computed(() => globalConfigForApi.getPrefixCls(name2, customizePrefixCls));
        const [, hashId] = useStyle2(prefixCls);
        onMounted(() => {
          callback({
            notice(noticeProps) {
              var _a3;
              (_a3 = notiRef.value) === null || _a3 === void 0 ? void 0 : _a3.add(noticeProps);
            },
            removeNotice(key2) {
              var _a3;
              (_a3 = notiRef.value) === null || _a3 === void 0 ? void 0 : _a3.remove(key2);
            },
            destroy() {
              render(null, div);
              if (div.parentNode) {
                div.parentNode.removeChild(div);
              }
            },
            component: notiRef
          });
        });
        return () => {
          const global2 = globalConfigForApi;
          const rootPrefixCls = global2.getRootPrefixCls(customRootPrefixCls, prefixCls.value);
          const transitionName2 = hasTransitionName2 ? customTransitionName : `${prefixCls.value}-${customTransitionName}`;
          return createVNode(ConfigProvider$1, _objectSpread2$1(_objectSpread2$1({}, global2), {}, {
            "prefixCls": rootPrefixCls
          }), {
            default: () => [createVNode(Notification$1, _objectSpread2$1(_objectSpread2$1({
              "ref": notiRef
            }, attrs), {}, {
              "prefixCls": prefixCls.value,
              "transitionName": transitionName2,
              "hashId": hashId.value
            }), null)]
          });
        };
      }
    });
    const vm = createVNode(Wrapper, props);
    vm.appContext = appContext || vm.appContext;
    render(vm, div);
  };
  const Notification$2 = Notification$1;
  let seed = 0;
  const now$1 = Date.now();
  function getUuid() {
    const id = seed;
    seed += 1;
    return `rcNotification_${now$1}_${id}`;
  }
  const Notification = /* @__PURE__ */ defineComponent({
    name: "HookNotification",
    inheritAttrs: false,
    props: ["prefixCls", "transitionName", "animation", "maxCount", "closeIcon", "hashId", "remove", "notices", "getStyles", "getClassName", "onAllRemoved", "getContainer"],
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const hookRefs = /* @__PURE__ */ new Map();
      const notices = computed(() => props.notices);
      const transitionProps = computed(() => {
        let name2 = props.transitionName;
        if (!name2 && props.animation) {
          switch (typeof props.animation) {
            case "string":
              name2 = props.animation;
              break;
            case "function":
              name2 = props.animation().name;
              break;
            case "object":
              name2 = props.animation.name;
              break;
            default:
              name2 = `${props.prefixCls}-fade`;
              break;
          }
        }
        return getTransitionGroupProps(name2);
      });
      const remove2 = (key2) => props.remove(key2);
      const placements2 = ref({});
      watch(notices, () => {
        const nextPlacements = {};
        Object.keys(placements2.value).forEach((placement) => {
          nextPlacements[placement] = [];
        });
        props.notices.forEach((config3) => {
          const {
            placement = "topRight"
          } = config3.notice;
          if (placement) {
            nextPlacements[placement] = nextPlacements[placement] || [];
            nextPlacements[placement].push(config3);
          }
        });
        placements2.value = nextPlacements;
      });
      const placementList = computed(() => Object.keys(placements2.value));
      return () => {
        var _a2;
        const {
          prefixCls,
          closeIcon = (_a2 = slots.closeIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots, {
            prefixCls
          })
        } = props;
        const noticeNodes = placementList.value.map((placement) => {
          var _a3, _b;
          const noticesForPlacement = placements2.value[placement];
          const classes = (_a3 = props.getClassName) === null || _a3 === void 0 ? void 0 : _a3.call(props, placement);
          const styles = (_b = props.getStyles) === null || _b === void 0 ? void 0 : _b.call(props, placement);
          const noticeNodesForPlacement = noticesForPlacement.map((_ref2, index2) => {
            let {
              notice: notice2,
              holderCallback
            } = _ref2;
            const updateMark = index2 === notices.value.length - 1 ? notice2.updateMark : void 0;
            const {
              key: key2,
              userPassKey
            } = notice2;
            const {
              content
            } = notice2;
            const noticeProps = _extends$1(_extends$1(_extends$1({
              prefixCls,
              closeIcon: typeof closeIcon === "function" ? closeIcon({
                prefixCls
              }) : closeIcon
            }, notice2), notice2.props), {
              key: key2,
              noticeKey: userPassKey || key2,
              updateMark,
              onClose: (noticeKey) => {
                var _a4;
                remove2(noticeKey);
                (_a4 = notice2.onClose) === null || _a4 === void 0 ? void 0 : _a4.call(notice2);
              },
              onClick: notice2.onClick
            });
            if (holderCallback) {
              return createVNode("div", {
                "key": key2,
                "class": `${prefixCls}-hook-holder`,
                "ref": (div) => {
                  if (typeof key2 === "undefined") {
                    return;
                  }
                  if (div) {
                    hookRefs.set(key2, div);
                    holderCallback(div, noticeProps);
                  } else {
                    hookRefs.delete(key2);
                  }
                }
              }, null);
            }
            return createVNode(Notice, _objectSpread2$1(_objectSpread2$1({}, noticeProps), {}, {
              "class": classNames(noticeProps.class, props.hashId)
            }), {
              default: () => [typeof content === "function" ? content({
                prefixCls
              }) : content]
            });
          });
          const className = {
            [prefixCls]: 1,
            [`${prefixCls}-${placement}`]: 1,
            [attrs.class]: !!attrs.class,
            [props.hashId]: true,
            [classes]: !!classes
          };
          function onAfterLeave() {
            var _a4;
            if (noticesForPlacement.length > 0) {
              return;
            }
            Reflect.deleteProperty(placements2.value, placement);
            (_a4 = props.onAllRemoved) === null || _a4 === void 0 ? void 0 : _a4.call(props);
          }
          return createVNode("div", {
            "key": placement,
            "class": className,
            "style": attrs.style || styles || {
              top: "65px",
              left: "50%"
            }
          }, [createVNode(TransitionGroup, _objectSpread2$1(_objectSpread2$1({
            "tag": "div"
          }, transitionProps.value), {}, {
            "onAfterLeave": onAfterLeave
          }), {
            default: () => [noticeNodesForPlacement]
          })]);
        });
        return createVNode(Portal$1, {
          "getContainer": props.getContainer
        }, {
          default: () => [noticeNodes]
        });
      };
    }
  });
  const HookNotification = Notification;
  var __rest$b = function(s2, e2) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  const defaultGetContainer$1 = () => document.body;
  let uniqueKey = 0;
  function mergeConfig() {
    const clone2 = {};
    for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) {
      objList[_key] = arguments[_key];
    }
    objList.forEach((obj) => {
      if (obj) {
        Object.keys(obj).forEach((key2) => {
          const val = obj[key2];
          if (val !== void 0) {
            clone2[key2] = val;
          }
        });
      }
    });
    return clone2;
  }
  function useNotification$1() {
    let rootConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      getContainer: getContainer2 = defaultGetContainer$1,
      motion,
      prefixCls,
      maxCount: maxCount2,
      getClassName,
      getStyles,
      onAllRemoved
    } = rootConfig, shareConfig = __rest$b(rootConfig, ["getContainer", "motion", "prefixCls", "maxCount", "getClassName", "getStyles", "onAllRemoved"]);
    const notices = shallowRef([]);
    const notificationsRef = shallowRef();
    const add2 = (originNotice, holderCallback) => {
      const key2 = originNotice.key || getUuid();
      const notice2 = _extends$1(_extends$1({}, originNotice), {
        key: key2
      });
      const noticeIndex = notices.value.map((v2) => v2.notice.key).indexOf(key2);
      const updatedNotices = notices.value.concat();
      if (noticeIndex !== -1) {
        updatedNotices.splice(noticeIndex, 1, {
          notice: notice2,
          holderCallback
        });
      } else {
        if (maxCount2 && notices.value.length >= maxCount2) {
          notice2.key = updatedNotices[0].notice.key;
          notice2.updateMark = getUuid();
          notice2.userPassKey = key2;
          updatedNotices.shift();
        }
        updatedNotices.push({
          notice: notice2,
          holderCallback
        });
      }
      notices.value = updatedNotices;
    };
    const removeNotice = (removeKey) => {
      notices.value = notices.value.filter((_ref) => {
        let {
          notice: {
            key: key2,
            userPassKey
          }
        } = _ref;
        const mergedKey = userPassKey || key2;
        return mergedKey !== removeKey;
      });
    };
    const destroy = () => {
      notices.value = [];
    };
    const contextHolder = () => createVNode(HookNotification, {
      "ref": notificationsRef,
      "prefixCls": prefixCls,
      "maxCount": maxCount2,
      "notices": notices.value,
      "remove": removeNotice,
      "getClassName": getClassName,
      "getStyles": getStyles,
      "animation": motion,
      "hashId": rootConfig.hashId,
      "onAllRemoved": onAllRemoved,
      "getContainer": getContainer2
    }, null);
    const taskQueue = shallowRef([]);
    const api2 = {
      open: (config3) => {
        const mergedConfig = mergeConfig(shareConfig, config3);
        if (mergedConfig.key === null || mergedConfig.key === void 0) {
          mergedConfig.key = `vc-notification-${uniqueKey}`;
          uniqueKey += 1;
        }
        taskQueue.value = [...taskQueue.value, {
          type: "open",
          config: mergedConfig
        }];
      },
      close: (key2) => {
        taskQueue.value = [...taskQueue.value, {
          type: "close",
          key: key2
        }];
      },
      destroy: () => {
        taskQueue.value = [...taskQueue.value, {
          type: "destroy"
        }];
      }
    };
    watch(taskQueue, () => {
      if (taskQueue.value.length) {
        taskQueue.value.forEach((task) => {
          switch (task.type) {
            case "open":
              add2(task.config);
              break;
            case "close":
              removeNotice(task.key);
              break;
            case "destroy":
              destroy();
              break;
          }
        });
        taskQueue.value = [];
      }
    });
    return [api2, contextHolder];
  }
  const genMessageStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      boxShadowSecondary,
      colorBgElevated,
      colorSuccess,
      colorError,
      colorWarning,
      colorInfo,
      fontSizeLG,
      motionEaseInOutCirc,
      motionDurationSlow,
      marginXS,
      paddingXS,
      borderRadiusLG,
      zIndexPopup,
      // Custom token
      messageNoticeContentPadding
    } = token2;
    const messageMoveIn = new Keyframe("MessageMoveIn", {
      "0%": {
        padding: 0,
        transform: "translateY(-100%)",
        opacity: 0
      },
      "100%": {
        padding: paddingXS,
        transform: "translateY(0)",
        opacity: 1
      }
    });
    const messageMoveOut = new Keyframe("MessageMoveOut", {
      "0%": {
        maxHeight: token2.height,
        padding: paddingXS,
        opacity: 1
      },
      "100%": {
        maxHeight: 0,
        padding: 0,
        opacity: 0
      }
    });
    return [
      // ============================ Holder ============================
      {
        [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
          position: "fixed",
          top: marginXS,
          left: "50%",
          transform: "translateX(-50%)",
          width: "100%",
          pointerEvents: "none",
          zIndex: zIndexPopup,
          [`${componentCls}-move-up`]: {
            animationFillMode: "forwards"
          },
          [`
        ${componentCls}-move-up-appear,
        ${componentCls}-move-up-enter
      `]: {
            animationName: messageMoveIn,
            animationDuration: motionDurationSlow,
            animationPlayState: "paused",
            animationTimingFunction: motionEaseInOutCirc
          },
          [`
        ${componentCls}-move-up-appear${componentCls}-move-up-appear-active,
        ${componentCls}-move-up-enter${componentCls}-move-up-enter-active
      `]: {
            animationPlayState: "running"
          },
          [`${componentCls}-move-up-leave`]: {
            animationName: messageMoveOut,
            animationDuration: motionDurationSlow,
            animationPlayState: "paused",
            animationTimingFunction: motionEaseInOutCirc
          },
          [`${componentCls}-move-up-leave${componentCls}-move-up-leave-active`]: {
            animationPlayState: "running"
          },
          "&-rtl": {
            direction: "rtl",
            span: {
              direction: "rtl"
            }
          }
        })
      },
      // ============================ Notice ============================
      {
        [`${componentCls}-notice`]: {
          padding: paddingXS,
          textAlign: "center",
          [iconCls]: {
            verticalAlign: "text-bottom",
            marginInlineEnd: marginXS,
            fontSize: fontSizeLG
          },
          [`${componentCls}-notice-content`]: {
            display: "inline-block",
            padding: messageNoticeContentPadding,
            background: colorBgElevated,
            borderRadius: borderRadiusLG,
            boxShadow: boxShadowSecondary,
            pointerEvents: "all"
          },
          [`${componentCls}-success ${iconCls}`]: {
            color: colorSuccess
          },
          [`${componentCls}-error ${iconCls}`]: {
            color: colorError
          },
          [`${componentCls}-warning ${iconCls}`]: {
            color: colorWarning
          },
          [`
        ${componentCls}-info ${iconCls},
        ${componentCls}-loading ${iconCls}`]: {
            color: colorInfo
          }
        }
      },
      // ============================= Pure =============================
      {
        [`${componentCls}-notice-pure-panel`]: {
          padding: 0,
          textAlign: "start"
        }
      }
    ];
  };
  const useStyle$4 = genComponentStyleHook("Message", (token2) => {
    const combinedToken = merge(token2, {
      messageNoticeContentPadding: `${(token2.controlHeightLG - token2.fontSize * token2.lineHeight) / 2}px ${token2.paddingSM}px`
    });
    return [genMessageStyle(combinedToken)];
  }, (token2) => ({
    height: 150,
    zIndexPopup: token2.zIndexPopupBase + 10
  }));
  const TypeIcon = {
    info: createVNode(InfoCircleFilled$1, null, null),
    success: createVNode(CheckCircleFilled$1, null, null),
    error: createVNode(CloseCircleFilled$1, null, null),
    warning: createVNode(ExclamationCircleFilled$1, null, null),
    loading: createVNode(LoadingOutlined$1, null, null)
  };
  const PureContent$1 = /* @__PURE__ */ defineComponent({
    name: "PureContent",
    inheritAttrs: false,
    props: ["prefixCls", "type", "icon"],
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      return () => {
        var _a2;
        return createVNode("div", {
          "class": classNames(`${props.prefixCls}-custom-content`, `${props.prefixCls}-${props.type}`)
        }, [props.icon || TypeIcon[props.type], createVNode("span", null, [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)])]);
      };
    }
  });
  var __rest$a = function(s2, e2) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  const DEFAULT_OFFSET$1 = 8;
  const DEFAULT_DURATION$1 = 3;
  const Holder$1 = /* @__PURE__ */ defineComponent({
    name: "Holder",
    inheritAttrs: false,
    props: ["top", "prefixCls", "getContainer", "maxCount", "duration", "rtl", "transitionName", "onAllRemoved"],
    setup(props, _ref) {
      let {
        expose
      } = _ref;
      var _a2, _b;
      const {
        getPrefixCls,
        getPopupContainer
      } = useConfigInject("message", props);
      const prefixCls = computed(() => getPrefixCls("message", props.prefixCls));
      const [, hashId] = useStyle$4(prefixCls);
      const getStyles = () => {
        var _a3;
        const top = (_a3 = props.top) !== null && _a3 !== void 0 ? _a3 : DEFAULT_OFFSET$1;
        return {
          left: "50%",
          transform: "translateX(-50%)",
          top: typeof top === "number" ? `${top}px` : top
        };
      };
      const getClassName = () => classNames(hashId.value, props.rtl ? `${prefixCls.value}-rtl` : "");
      const getNotificationMotion = () => {
        var _a3;
        return getMotion$1({
          prefixCls: prefixCls.value,
          animation: (_a3 = props.animation) !== null && _a3 !== void 0 ? _a3 : `move-up`,
          transitionName: props.transitionName
        });
      };
      const mergedCloseIcon = createVNode("span", {
        "class": `${prefixCls.value}-close-x`
      }, [createVNode(CloseOutlined$1, {
        "class": `${prefixCls.value}-close-icon`
      }, null)]);
      const [api2, holder] = useNotification$1({
        //@ts-ignore
        getStyles,
        prefixCls: prefixCls.value,
        getClassName,
        motion: getNotificationMotion,
        closable: false,
        closeIcon: mergedCloseIcon,
        duration: (_a2 = props.duration) !== null && _a2 !== void 0 ? _a2 : DEFAULT_DURATION$1,
        getContainer: (_b = props.staticGetContainer) !== null && _b !== void 0 ? _b : getPopupContainer.value,
        maxCount: props.maxCount,
        onAllRemoved: props.onAllRemoved
      });
      expose(_extends$1(_extends$1({}, api2), {
        prefixCls,
        hashId
      }));
      return holder;
    }
  });
  let keyIndex = 0;
  function useInternalMessage(messageConfig) {
    const holderRef = shallowRef(null);
    const holderKey = Symbol("messageHolderKey");
    const close = (key2) => {
      var _a2;
      (_a2 = holderRef.value) === null || _a2 === void 0 ? void 0 : _a2.close(key2);
    };
    const open2 = (config3) => {
      if (!holderRef.value) {
        const fakeResult = () => {
        };
        fakeResult.then = () => {
        };
        return fakeResult;
      }
      const {
        open: originOpen,
        prefixCls,
        hashId
      } = holderRef.value;
      const noticePrefixCls = `${prefixCls}-notice`;
      const {
        content,
        icon,
        type: type4,
        key: key2,
        class: className,
        onClose
      } = config3, restConfig = __rest$a(config3, ["content", "icon", "type", "key", "class", "onClose"]);
      let mergedKey = key2;
      if (mergedKey === void 0 || mergedKey === null) {
        keyIndex += 1;
        mergedKey = `antd-message-${keyIndex}`;
      }
      return wrapPromiseFn((resolve2) => {
        originOpen(_extends$1(_extends$1({}, restConfig), {
          key: mergedKey,
          content: () => createVNode(PureContent$1, {
            "prefixCls": prefixCls,
            "type": type4,
            "icon": typeof icon === "function" ? icon() : icon
          }, {
            default: () => [typeof content === "function" ? content() : content]
          }),
          placement: "top",
          // @ts-ignore
          class: classNames(type4 && `${noticePrefixCls}-${type4}`, hashId, className),
          onClose: () => {
            onClose === null || onClose === void 0 ? void 0 : onClose();
            resolve2();
          }
        }));
        return () => {
          close(mergedKey);
        };
      });
    };
    const destroy = (key2) => {
      var _a2;
      if (key2 !== void 0) {
        close(key2);
      } else {
        (_a2 = holderRef.value) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      }
    };
    const wrapAPI = {
      open: open2,
      destroy
    };
    const keys2 = ["info", "success", "warning", "error", "loading"];
    keys2.forEach((type4) => {
      const typeOpen = (jointContent, duration, onClose) => {
        let config3;
        if (jointContent && typeof jointContent === "object" && "content" in jointContent) {
          config3 = jointContent;
        } else {
          config3 = {
            content: jointContent
          };
        }
        let mergedDuration;
        let mergedOnClose;
        if (typeof duration === "function") {
          mergedOnClose = duration;
        } else {
          mergedDuration = duration;
          mergedOnClose = onClose;
        }
        const mergedConfig = _extends$1(_extends$1({
          onClose: mergedOnClose,
          duration: mergedDuration
        }, config3), {
          type: type4
        });
        return open2(mergedConfig);
      };
      wrapAPI[type4] = typeOpen;
    });
    return [wrapAPI, () => createVNode(Holder$1, _objectSpread2$1(_objectSpread2$1({
      "key": holderKey
    }, messageConfig), {}, {
      "ref": holderRef
    }), null)];
  }
  function useMessage(messageConfig) {
    return useInternalMessage(messageConfig);
  }
  let defaultDuration$1 = 3;
  let defaultTop$1;
  let messageInstance;
  let key$1 = 1;
  let localPrefixCls = "";
  let transitionName = "move-up";
  let hasTransitionName = false;
  let getContainer = () => document.body;
  let maxCount$1;
  let rtl$1 = false;
  function getKeyThenIncreaseKey() {
    return key$1++;
  }
  function setMessageConfig(options) {
    if (options.top !== void 0) {
      defaultTop$1 = options.top;
      messageInstance = null;
    }
    if (options.duration !== void 0) {
      defaultDuration$1 = options.duration;
    }
    if (options.prefixCls !== void 0) {
      localPrefixCls = options.prefixCls;
    }
    if (options.getContainer !== void 0) {
      getContainer = options.getContainer;
      messageInstance = null;
    }
    if (options.transitionName !== void 0) {
      transitionName = options.transitionName;
      messageInstance = null;
      hasTransitionName = true;
    }
    if (options.maxCount !== void 0) {
      maxCount$1 = options.maxCount;
      messageInstance = null;
    }
    if (options.rtl !== void 0) {
      rtl$1 = options.rtl;
    }
  }
  function getMessageInstance(args, callback) {
    if (messageInstance) {
      callback(messageInstance);
      return;
    }
    Notification$2.newInstance({
      appContext: args.appContext,
      prefixCls: args.prefixCls || localPrefixCls,
      rootPrefixCls: args.rootPrefixCls,
      transitionName,
      hasTransitionName,
      style: {
        top: defaultTop$1
      },
      getContainer: getContainer || args.getPopupContainer,
      maxCount: maxCount$1,
      name: "message",
      useStyle: useStyle$4
    }, (instance) => {
      if (messageInstance) {
        callback(messageInstance);
        return;
      }
      messageInstance = instance;
      callback(instance);
    });
  }
  const typeToIcon$2 = {
    info: InfoCircleFilled$1,
    success: CheckCircleFilled$1,
    error: CloseCircleFilled$1,
    warning: ExclamationCircleFilled$1,
    loading: LoadingOutlined$1
  };
  const typeList = Object.keys(typeToIcon$2);
  function notice$1(args) {
    const duration = args.duration !== void 0 ? args.duration : defaultDuration$1;
    const target = args.key || getKeyThenIncreaseKey();
    const closePromise = new Promise((resolve2) => {
      const callback = () => {
        if (typeof args.onClose === "function") {
          args.onClose();
        }
        return resolve2(true);
      };
      getMessageInstance(args, (instance) => {
        instance.notice({
          key: target,
          duration,
          style: args.style || {},
          class: args.class,
          content: (_ref) => {
            let {
              prefixCls
            } = _ref;
            const Icon3 = typeToIcon$2[args.type];
            const iconNode = Icon3 ? createVNode(Icon3, null, null) : "";
            const messageClass = classNames(`${prefixCls}-custom-content`, {
              [`${prefixCls}-${args.type}`]: args.type,
              [`${prefixCls}-rtl`]: rtl$1 === true
            });
            return createVNode("div", {
              "class": messageClass
            }, [typeof args.icon === "function" ? args.icon() : args.icon || iconNode, createVNode("span", null, [typeof args.content === "function" ? args.content() : args.content])]);
          },
          onClose: callback,
          onClick: args.onClick
        });
      });
    });
    const result = () => {
      if (messageInstance) {
        messageInstance.removeNotice(target);
      }
    };
    result.then = (filled, rejected) => closePromise.then(filled, rejected);
    result.promise = closePromise;
    return result;
  }
  function isArgsProps(content) {
    return Object.prototype.toString.call(content) === "[object Object]" && !!content.content;
  }
  const api$1 = {
    open: notice$1,
    config: setMessageConfig,
    destroy(messageKey) {
      if (messageInstance) {
        if (messageKey) {
          const {
            removeNotice
          } = messageInstance;
          removeNotice(messageKey);
        } else {
          const {
            destroy
          } = messageInstance;
          destroy();
          messageInstance = null;
        }
      }
    }
  };
  function attachTypeApi(originalApi, type4) {
    originalApi[type4] = (content, duration, onClose) => {
      if (isArgsProps(content)) {
        return originalApi.open(_extends$1(_extends$1({}, content), {
          type: type4
        }));
      }
      if (typeof duration === "function") {
        onClose = duration;
        duration = void 0;
      }
      return originalApi.open({
        content,
        duration,
        type: type4,
        onClose
      });
    };
  }
  typeList.forEach((type4) => attachTypeApi(api$1, type4));
  api$1.warn = api$1.warning;
  api$1.useMessage = useMessage;
  const genNotificationPlacementStyle = (token2) => {
    const {
      componentCls,
      width,
      notificationMarginEdge
    } = token2;
    const notificationTopFadeIn = new Keyframe("antNotificationTopFadeIn", {
      "0%": {
        marginTop: "-100%",
        opacity: 0
      },
      "100%": {
        marginTop: 0,
        opacity: 1
      }
    });
    const notificationBottomFadeIn = new Keyframe("antNotificationBottomFadeIn", {
      "0%": {
        marginBottom: "-100%",
        opacity: 0
      },
      "100%": {
        marginBottom: 0,
        opacity: 1
      }
    });
    const notificationLeftFadeIn = new Keyframe("antNotificationLeftFadeIn", {
      "0%": {
        right: {
          _skip_check_: true,
          value: width
        },
        opacity: 0
      },
      "100%": {
        right: {
          _skip_check_: true,
          value: 0
        },
        opacity: 1
      }
    });
    return {
      [`&${componentCls}-top, &${componentCls}-bottom`]: {
        marginInline: 0
      },
      [`&${componentCls}-top`]: {
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: notificationTopFadeIn
        }
      },
      [`&${componentCls}-bottom`]: {
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: notificationBottomFadeIn
        }
      },
      [`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
        marginInlineEnd: 0,
        marginInlineStart: notificationMarginEdge,
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: notificationLeftFadeIn
        }
      }
    };
  };
  const genNotificationStyle = (token2) => {
    const {
      iconCls,
      componentCls,
      // .ant-notification
      boxShadowSecondary,
      fontSizeLG,
      notificationMarginBottom,
      borderRadiusLG,
      colorSuccess,
      colorInfo,
      colorWarning,
      colorError,
      colorTextHeading,
      notificationBg,
      notificationPadding,
      notificationMarginEdge,
      motionDurationMid,
      motionEaseInOut,
      fontSize,
      lineHeight,
      width,
      notificationIconSize
    } = token2;
    const noticeCls = `${componentCls}-notice`;
    const notificationFadeIn = new Keyframe("antNotificationFadeIn", {
      "0%": {
        left: {
          _skip_check_: true,
          value: width
        },
        opacity: 0
      },
      "100%": {
        left: {
          _skip_check_: true,
          value: 0
        },
        opacity: 1
      }
    });
    const notificationFadeOut = new Keyframe("antNotificationFadeOut", {
      "0%": {
        maxHeight: token2.animationMaxHeight,
        marginBottom: notificationMarginBottom,
        opacity: 1
      },
      "100%": {
        maxHeight: 0,
        marginBottom: 0,
        paddingTop: 0,
        paddingBottom: 0,
        opacity: 0
      }
    });
    return [
      // ============================ Holder ============================
      {
        [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
          position: "fixed",
          zIndex: token2.zIndexPopup,
          marginInlineEnd: notificationMarginEdge,
          [`${componentCls}-hook-holder`]: {
            position: "relative"
          },
          [`&${componentCls}-top, &${componentCls}-bottom`]: {
            [`${componentCls}-notice`]: {
              marginInline: "auto auto"
            }
          },
          [`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
            [`${componentCls}-notice`]: {
              marginInlineEnd: "auto",
              marginInlineStart: 0
            }
          },
          //  animation
          [`${componentCls}-fade-enter, ${componentCls}-fade-appear`]: {
            animationDuration: token2.motionDurationMid,
            animationTimingFunction: motionEaseInOut,
            animationFillMode: "both",
            opacity: 0,
            animationPlayState: "paused"
          },
          [`${componentCls}-fade-leave`]: {
            animationTimingFunction: motionEaseInOut,
            animationFillMode: "both",
            animationDuration: motionDurationMid,
            animationPlayState: "paused"
          },
          [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
            animationName: notificationFadeIn,
            animationPlayState: "running"
          },
          [`${componentCls}-fade-leave${componentCls}-fade-leave-active`]: {
            animationName: notificationFadeOut,
            animationPlayState: "running"
          }
        }), genNotificationPlacementStyle(token2)), {
          // RTL
          "&-rtl": {
            direction: "rtl",
            [`${componentCls}-notice-btn`]: {
              float: "left"
            }
          }
        })
      },
      // ============================ Notice ============================
      {
        [noticeCls]: {
          position: "relative",
          width,
          maxWidth: `calc(100vw - ${notificationMarginEdge * 2}px)`,
          marginBottom: notificationMarginBottom,
          marginInlineStart: "auto",
          padding: notificationPadding,
          overflow: "hidden",
          lineHeight,
          wordWrap: "break-word",
          background: notificationBg,
          borderRadius: borderRadiusLG,
          boxShadow: boxShadowSecondary,
          [`${componentCls}-close-icon`]: {
            fontSize,
            cursor: "pointer"
          },
          [`${noticeCls}-message`]: {
            marginBottom: token2.marginXS,
            color: colorTextHeading,
            fontSize: fontSizeLG,
            lineHeight: token2.lineHeightLG
          },
          [`${noticeCls}-description`]: {
            fontSize
          },
          [`&${noticeCls}-closable ${noticeCls}-message`]: {
            paddingInlineEnd: token2.paddingLG
          },
          [`${noticeCls}-with-icon ${noticeCls}-message`]: {
            marginBottom: token2.marginXS,
            marginInlineStart: token2.marginSM + notificationIconSize,
            fontSize: fontSizeLG
          },
          [`${noticeCls}-with-icon ${noticeCls}-description`]: {
            marginInlineStart: token2.marginSM + notificationIconSize,
            fontSize
          },
          // Icon & color style in different selector level
          // https://github.com/ant-design/ant-design/issues/16503
          // https://github.com/ant-design/ant-design/issues/15512
          [`${noticeCls}-icon`]: {
            position: "absolute",
            fontSize: notificationIconSize,
            lineHeight: 0,
            // icon-font
            [`&-success${iconCls}`]: {
              color: colorSuccess
            },
            [`&-info${iconCls}`]: {
              color: colorInfo
            },
            [`&-warning${iconCls}`]: {
              color: colorWarning
            },
            [`&-error${iconCls}`]: {
              color: colorError
            }
          },
          [`${noticeCls}-close`]: {
            position: "absolute",
            top: token2.notificationPaddingVertical,
            insetInlineEnd: token2.notificationPaddingHorizontal,
            color: token2.colorIcon,
            outline: "none",
            width: token2.notificationCloseButtonSize,
            height: token2.notificationCloseButtonSize,
            borderRadius: token2.borderRadiusSM,
            transition: `background-color ${token2.motionDurationMid}, color ${token2.motionDurationMid}`,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            "&:hover": {
              color: token2.colorIconHover,
              backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContent
            }
          },
          [`${noticeCls}-btn`]: {
            float: "right",
            marginTop: token2.marginSM
          }
        }
      },
      // ============================= Pure =============================
      {
        [`${noticeCls}-pure-panel`]: {
          margin: 0
        }
      }
    ];
  };
  const useStyle$3 = genComponentStyleHook("Notification", (token2) => {
    const notificationPaddingVertical = token2.paddingMD;
    const notificationPaddingHorizontal = token2.paddingLG;
    const notificationToken = merge(token2, {
      // default.less variables
      notificationBg: token2.colorBgElevated,
      notificationPaddingVertical,
      notificationPaddingHorizontal,
      // index.less variables
      notificationPadding: `${token2.paddingMD}px ${token2.paddingContentHorizontalLG}px`,
      notificationMarginBottom: token2.margin,
      notificationMarginEdge: token2.marginLG,
      animationMaxHeight: 150,
      notificationIconSize: token2.fontSizeLG * token2.lineHeightLG,
      notificationCloseButtonSize: token2.controlHeightLG * 0.55
    });
    return [genNotificationStyle(notificationToken)];
  }, (token2) => ({
    zIndexPopup: token2.zIndexPopupBase + 50,
    width: 384
  }));
  function getCloseIcon(prefixCls, closeIcon) {
    return closeIcon || createVNode("span", {
      "class": `${prefixCls}-close-x`
    }, [createVNode(CloseOutlined$1, {
      "class": `${prefixCls}-close-icon`
    }, null)]);
  }
  ({
    info: createVNode(InfoCircleFilled$1, null, null),
    success: createVNode(CheckCircleFilled$1, null, null),
    error: createVNode(CloseCircleFilled$1, null, null),
    warning: createVNode(ExclamationCircleFilled$1, null, null),
    loading: createVNode(LoadingOutlined$1, null, null)
  });
  const typeToIcon$1 = {
    success: CheckCircleFilled$1,
    info: InfoCircleFilled$1,
    error: CloseCircleFilled$1,
    warning: ExclamationCircleFilled$1
  };
  function PureContent(_ref) {
    let {
      prefixCls,
      icon,
      type: type4,
      message,
      description,
      btn
    } = _ref;
    let iconNode = null;
    if (icon) {
      iconNode = createVNode("span", {
        "class": `${prefixCls}-icon`
      }, [renderHelper(icon)]);
    } else if (type4) {
      const Icon3 = typeToIcon$1[type4];
      iconNode = createVNode(Icon3, {
        "class": `${prefixCls}-icon ${prefixCls}-icon-${type4}`
      }, null);
    }
    return createVNode("div", {
      "class": classNames({
        [`${prefixCls}-with-icon`]: iconNode
      }),
      "role": "alert"
    }, [iconNode, createVNode("div", {
      "class": `${prefixCls}-message`
    }, [message]), createVNode("div", {
      "class": `${prefixCls}-description`
    }, [description]), btn && createVNode("div", {
      "class": `${prefixCls}-btn`
    }, [btn])]);
  }
  function getPlacementStyle(placement, top, bottom) {
    let style;
    top = typeof top === "number" ? `${top}px` : top;
    bottom = typeof bottom === "number" ? `${bottom}px` : bottom;
    switch (placement) {
      case "top":
        style = {
          left: "50%",
          transform: "translateX(-50%)",
          right: "auto",
          top,
          bottom: "auto"
        };
        break;
      case "topLeft":
        style = {
          left: 0,
          top,
          bottom: "auto"
        };
        break;
      case "topRight":
        style = {
          right: 0,
          top,
          bottom: "auto"
        };
        break;
      case "bottom":
        style = {
          left: "50%",
          transform: "translateX(-50%)",
          right: "auto",
          top: "auto",
          bottom
        };
        break;
      case "bottomLeft":
        style = {
          left: 0,
          top: "auto",
          bottom
        };
        break;
      default:
        style = {
          right: 0,
          top: "auto",
          bottom
        };
        break;
    }
    return style;
  }
  function getMotion(prefixCls) {
    return {
      name: `${prefixCls}-fade`
    };
  }
  var __rest$9 = function(s2, e2) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  const DEFAULT_OFFSET = 24;
  const DEFAULT_DURATION = 4.5;
  const Holder = /* @__PURE__ */ defineComponent({
    name: "Holder",
    inheritAttrs: false,
    props: ["prefixCls", "class", "type", "icon", "content", "onAllRemoved"],
    setup(props, _ref) {
      let {
        expose
      } = _ref;
      const {
        getPrefixCls,
        getPopupContainer
      } = useConfigInject("notification", props);
      const prefixCls = computed(() => props.prefixCls || getPrefixCls("notification"));
      const getStyles = (placement) => {
        var _a2, _b;
        return getPlacementStyle(placement, (_a2 = props.top) !== null && _a2 !== void 0 ? _a2 : DEFAULT_OFFSET, (_b = props.bottom) !== null && _b !== void 0 ? _b : DEFAULT_OFFSET);
      };
      const [, hashId] = useStyle$3(prefixCls);
      const getClassName = () => classNames(hashId.value, {
        [`${prefixCls.value}-rtl`]: props.rtl
      });
      const getNotificationMotion = () => getMotion(prefixCls.value);
      const [api2, holder] = useNotification$1({
        prefixCls: prefixCls.value,
        getStyles,
        getClassName,
        motion: getNotificationMotion,
        closable: true,
        closeIcon: getCloseIcon(prefixCls.value),
        duration: DEFAULT_DURATION,
        getContainer: () => {
          var _a2, _b;
          return ((_a2 = props.getPopupContainer) === null || _a2 === void 0 ? void 0 : _a2.call(props)) || ((_b = getPopupContainer.value) === null || _b === void 0 ? void 0 : _b.call(getPopupContainer)) || document.body;
        },
        maxCount: props.maxCount,
        hashId: hashId.value,
        onAllRemoved: props.onAllRemoved
      });
      expose(_extends$1(_extends$1({}, api2), {
        prefixCls: prefixCls.value,
        hashId
      }));
      return holder;
    }
  });
  function useInternalNotification(notificationConfig) {
    const holderRef = shallowRef(null);
    const holderKey = Symbol("notificationHolderKey");
    const open2 = (config3) => {
      if (!holderRef.value) {
        return;
      }
      const {
        open: originOpen,
        prefixCls,
        hashId
      } = holderRef.value;
      const noticePrefixCls = `${prefixCls}-notice`;
      const {
        message,
        description,
        icon,
        type: type4,
        btn,
        class: className
      } = config3, restConfig = __rest$9(config3, ["message", "description", "icon", "type", "btn", "class"]);
      return originOpen(_extends$1(_extends$1({
        placement: "topRight"
      }, restConfig), {
        content: () => createVNode(PureContent, {
          "prefixCls": noticePrefixCls,
          "icon": typeof icon === "function" ? icon() : icon,
          "type": type4,
          "message": typeof message === "function" ? message() : message,
          "description": typeof description === "function" ? description() : description,
          "btn": typeof btn === "function" ? btn() : btn
        }, null),
        // @ts-ignore
        class: classNames(type4 && `${noticePrefixCls}-${type4}`, hashId, className)
      }));
    };
    const destroy = (key2) => {
      var _a2, _b;
      if (key2 !== void 0) {
        (_a2 = holderRef.value) === null || _a2 === void 0 ? void 0 : _a2.close(key2);
      } else {
        (_b = holderRef.value) === null || _b === void 0 ? void 0 : _b.destroy();
      }
    };
    const wrapAPI = {
      open: open2,
      destroy
    };
    const keys2 = ["success", "info", "warning", "error"];
    keys2.forEach((type4) => {
      wrapAPI[type4] = (config3) => open2(_extends$1(_extends$1({}, config3), {
        type: type4
      }));
    });
    return [wrapAPI, () => createVNode(Holder, _objectSpread2$1(_objectSpread2$1({
      "key": holderKey
    }, notificationConfig), {}, {
      "ref": holderRef
    }), null)];
  }
  function useNotification(notificationConfig) {
    return useInternalNotification(notificationConfig);
  }
  const notificationInstance = {};
  let defaultDuration = 4.5;
  let defaultTop = "24px";
  let defaultBottom = "24px";
  let defaultPrefixCls$1 = "";
  let defaultPlacement = "topRight";
  let defaultGetContainer = () => document.body;
  let defaultCloseIcon = null;
  let rtl = false;
  let maxCount;
  function setNotificationConfig(options) {
    const {
      duration,
      placement,
      bottom,
      top,
      getContainer: getContainer2,
      closeIcon,
      prefixCls
    } = options;
    if (prefixCls !== void 0) {
      defaultPrefixCls$1 = prefixCls;
    }
    if (duration !== void 0) {
      defaultDuration = duration;
    }
    if (placement !== void 0) {
      defaultPlacement = placement;
    }
    if (bottom !== void 0) {
      defaultBottom = typeof bottom === "number" ? `${bottom}px` : bottom;
    }
    if (top !== void 0) {
      defaultTop = typeof top === "number" ? `${top}px` : top;
    }
    if (getContainer2 !== void 0) {
      defaultGetContainer = getContainer2;
    }
    if (closeIcon !== void 0) {
      defaultCloseIcon = closeIcon;
    }
    if (options.rtl !== void 0) {
      rtl = options.rtl;
    }
    if (options.maxCount !== void 0) {
      maxCount = options.maxCount;
    }
  }
  function getNotificationInstance(_ref, callback) {
    let {
      prefixCls: customizePrefixCls,
      placement = defaultPlacement,
      getContainer: getContainer2 = defaultGetContainer,
      top,
      bottom,
      closeIcon = defaultCloseIcon,
      appContext
    } = _ref;
    const {
      getPrefixCls
    } = globalConfig();
    const prefixCls = getPrefixCls("notification", customizePrefixCls || defaultPrefixCls$1);
    const cacheKey = `${prefixCls}-${placement}-${rtl}`;
    const cacheInstance = notificationInstance[cacheKey];
    if (cacheInstance) {
      Promise.resolve(cacheInstance).then((instance) => {
        callback(instance);
      });
      return;
    }
    const notificationClass = classNames(`${prefixCls}-${placement}`, {
      [`${prefixCls}-rtl`]: rtl === true
    });
    Notification$2.newInstance({
      name: "notification",
      prefixCls: customizePrefixCls || defaultPrefixCls$1,
      useStyle: useStyle$3,
      class: notificationClass,
      style: getPlacementStyle(placement, top !== null && top !== void 0 ? top : defaultTop, bottom !== null && bottom !== void 0 ? bottom : defaultBottom),
      appContext,
      getContainer: getContainer2,
      closeIcon: (_ref2) => {
        let {
          prefixCls: prefixCls2
        } = _ref2;
        const closeIconToRender = createVNode("span", {
          "class": `${prefixCls2}-close-x`
        }, [renderHelper(closeIcon, {}, createVNode(CloseOutlined$1, {
          "class": `${prefixCls2}-close-icon`
        }, null))]);
        return closeIconToRender;
      },
      maxCount,
      hasTransitionName: true
    }, (notification2) => {
      notificationInstance[cacheKey] = notification2;
      callback(notification2);
    });
  }
  const typeToIcon = {
    success: CheckCircleOutlined$1,
    info: InfoCircleOutlined$1,
    error: CloseCircleOutlined$1,
    warning: ExclamationCircleOutlined$1
  };
  function notice(args) {
    const {
      icon,
      type: type4,
      description,
      message,
      btn
    } = args;
    const duration = args.duration === void 0 ? defaultDuration : args.duration;
    getNotificationInstance(args, (notification2) => {
      notification2.notice({
        content: (_ref3) => {
          let {
            prefixCls: outerPrefixCls
          } = _ref3;
          const prefixCls = `${outerPrefixCls}-notice`;
          let iconNode = null;
          if (icon) {
            iconNode = () => createVNode("span", {
              "class": `${prefixCls}-icon`
            }, [renderHelper(icon)]);
          } else if (type4) {
            const Icon3 = typeToIcon[type4];
            iconNode = () => createVNode(Icon3, {
              "class": `${prefixCls}-icon ${prefixCls}-icon-${type4}`
            }, null);
          }
          return createVNode("div", {
            "class": iconNode ? `${prefixCls}-with-icon` : ""
          }, [iconNode && iconNode(), createVNode("div", {
            "class": `${prefixCls}-message`
          }, [!description && iconNode ? createVNode("span", {
            "class": `${prefixCls}-message-single-line-auto-margin`
          }, null) : null, renderHelper(message)]), createVNode("div", {
            "class": `${prefixCls}-description`
          }, [renderHelper(description)]), btn ? createVNode("span", {
            "class": `${prefixCls}-btn`
          }, [renderHelper(btn)]) : null]);
        },
        duration,
        closable: true,
        onClose: args.onClose,
        onClick: args.onClick,
        key: args.key,
        style: args.style || {},
        class: args.class
      });
    });
  }
  const api = {
    open: notice,
    close(key2) {
      Object.keys(notificationInstance).forEach((cacheKey) => Promise.resolve(notificationInstance[cacheKey]).then((instance) => {
        instance.removeNotice(key2);
      }));
    },
    config: setNotificationConfig,
    destroy() {
      Object.keys(notificationInstance).forEach((cacheKey) => {
        Promise.resolve(notificationInstance[cacheKey]).then((instance) => {
          instance.destroy();
        });
        delete notificationInstance[cacheKey];
      });
    }
  };
  const iconTypes = ["success", "info", "warning", "error"];
  iconTypes.forEach((type4) => {
    api[type4] = (args) => api.open(_extends$1(_extends$1({}, args), {
      type: type4
    }));
  });
  api.warn = api.warning;
  api.useNotification = useNotification;
  const notification = api;
  const dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
  function getStyle(globalPrefixCls, theme) {
    const variables = {};
    const formatColor = (color, updater) => {
      let clone2 = color.clone();
      clone2 = (updater === null || updater === void 0 ? void 0 : updater(clone2)) || clone2;
      return clone2.toRgbString();
    };
    const fillColor = (colorVal, type4) => {
      const baseColor = new TinyColor(colorVal);
      const colorPalettes = generate$1(baseColor.toRgbString());
      variables[`${type4}-color`] = formatColor(baseColor);
      variables[`${type4}-color-disabled`] = colorPalettes[1];
      variables[`${type4}-color-hover`] = colorPalettes[4];
      variables[`${type4}-color-active`] = colorPalettes[6];
      variables[`${type4}-color-outline`] = baseColor.clone().setAlpha(0.2).toRgbString();
      variables[`${type4}-color-deprecated-bg`] = colorPalettes[0];
      variables[`${type4}-color-deprecated-border`] = colorPalettes[2];
    };
    if (theme.primaryColor) {
      fillColor(theme.primaryColor, "primary");
      const primaryColor = new TinyColor(theme.primaryColor);
      const primaryColors = generate$1(primaryColor.toRgbString());
      primaryColors.forEach((color, index2) => {
        variables[`primary-${index2 + 1}`] = color;
      });
      variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c2) => c2.lighten(35));
      variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c2) => c2.lighten(20));
      variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c2) => c2.tint(20));
      variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c2) => c2.tint(50));
      variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.12));
      const primaryActiveColor = new TinyColor(primaryColors[0]);
      variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.3));
      variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c2) => c2.darken(2));
    }
    if (theme.successColor) {
      fillColor(theme.successColor, "success");
    }
    if (theme.warningColor) {
      fillColor(theme.warningColor, "warning");
    }
    if (theme.errorColor) {
      fillColor(theme.errorColor, "error");
    }
    if (theme.infoColor) {
      fillColor(theme.infoColor, "info");
    }
    const cssList = Object.keys(variables).map((key2) => `--${globalPrefixCls}-${key2}: ${variables[key2]};`);
    return `
  :root {
    ${cssList.join("\n")}
  }
  `.trim();
  }
  function registerTheme(globalPrefixCls, theme) {
    const style = getStyle(globalPrefixCls, theme);
    if (canUseDom$1()) {
      updateCSS$1(style, `${dynamicStyleMark}-dynamic-theme`);
    } else {
      warning$3(false, "ConfigProvider", "SSR do not support dynamic theme with css variables.");
    }
  }
  const useStyle$2 = (iconPrefixCls) => {
    const [theme, token2] = useToken();
    return useStyleRegister(computed(() => ({
      theme: theme.value,
      token: token2.value,
      hashId: "",
      path: ["ant-design-icons", iconPrefixCls.value]
    })), () => [{
      [`.${iconPrefixCls.value}`]: _extends$1(_extends$1({}, resetIcon()), {
        [`.${iconPrefixCls.value} .${iconPrefixCls.value}-icon`]: {
          display: "block"
        }
      })
    }]);
  };
  function useTheme(theme, parentTheme) {
    const themeConfig = computed(() => (theme === null || theme === void 0 ? void 0 : theme.value) || {});
    const parentThemeConfig = computed(() => themeConfig.value.inherit === false || !(parentTheme === null || parentTheme === void 0 ? void 0 : parentTheme.value) ? defaultConfig : parentTheme.value);
    const mergedTheme = computed(() => {
      if (!(theme === null || theme === void 0 ? void 0 : theme.value)) {
        return parentTheme === null || parentTheme === void 0 ? void 0 : parentTheme.value;
      }
      const mergedComponents = _extends$1({}, parentThemeConfig.value.components);
      Object.keys(theme.value.components || {}).forEach((componentName) => {
        mergedComponents[componentName] = _extends$1(_extends$1({}, mergedComponents[componentName]), theme.value.components[componentName]);
      });
      return _extends$1(_extends$1(_extends$1({}, parentThemeConfig.value), themeConfig.value), {
        token: _extends$1(_extends$1({}, parentThemeConfig.value.token), themeConfig.value.token),
        components: mergedComponents
      });
    });
    return mergedTheme;
  }
  var __rest$8 = function(s2, e2) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  const defaultPrefixCls = "ant";
  function getGlobalPrefixCls() {
    return globalConfigForApi.prefixCls || defaultPrefixCls;
  }
  function getGlobalIconPrefixCls() {
    return globalConfigForApi.iconPrefixCls || defaultIconPrefixCls;
  }
  const globalConfigBySet = reactive({});
  const globalConfigForApi = reactive({});
  watchEffect(() => {
    _extends$1(globalConfigForApi, globalConfigBySet);
    globalConfigForApi.prefixCls = getGlobalPrefixCls();
    globalConfigForApi.iconPrefixCls = getGlobalIconPrefixCls();
    globalConfigForApi.getPrefixCls = (suffixCls, customizePrefixCls) => {
      if (customizePrefixCls)
        return customizePrefixCls;
      return suffixCls ? `${globalConfigForApi.prefixCls}-${suffixCls}` : globalConfigForApi.prefixCls;
    };
    globalConfigForApi.getRootPrefixCls = () => {
      if (globalConfigForApi.prefixCls) {
        return globalConfigForApi.prefixCls;
      }
      return getGlobalPrefixCls();
    };
  });
  let stopWatchEffect;
  const setGlobalConfig = (params) => {
    if (stopWatchEffect) {
      stopWatchEffect();
    }
    stopWatchEffect = watchEffect(() => {
      _extends$1(globalConfigBySet, reactive(params));
      _extends$1(globalConfigForApi, reactive(params));
    });
    if (params.theme) {
      registerTheme(getGlobalPrefixCls(), params.theme);
    }
  };
  const globalConfig = () => ({
    getPrefixCls: (suffixCls, customizePrefixCls) => {
      if (customizePrefixCls)
        return customizePrefixCls;
      return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
    },
    getIconPrefixCls: getGlobalIconPrefixCls,
    getRootPrefixCls: () => {
      if (globalConfigForApi.prefixCls) {
        return globalConfigForApi.prefixCls;
      }
      return getGlobalPrefixCls();
    }
  });
  const ConfigProvider = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AConfigProvider",
    inheritAttrs: false,
    props: configProviderProps(),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const parentContext = useConfigContextInject();
      const getPrefixCls = (suffixCls, customizePrefixCls) => {
        const {
          prefixCls = "ant"
        } = props;
        if (customizePrefixCls)
          return customizePrefixCls;
        const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
        return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
      };
      const iconPrefixCls = computed(() => props.iconPrefixCls || parentContext.iconPrefixCls.value || defaultIconPrefixCls);
      const shouldWrapSSR = computed(() => iconPrefixCls.value !== parentContext.iconPrefixCls.value);
      const csp = computed(() => {
        var _a2;
        return props.csp || ((_a2 = parentContext.csp) === null || _a2 === void 0 ? void 0 : _a2.value);
      });
      const wrapSSR = useStyle$2(iconPrefixCls);
      const mergedTheme = useTheme(computed(() => props.theme), computed(() => {
        var _a2;
        return (_a2 = parentContext.theme) === null || _a2 === void 0 ? void 0 : _a2.value;
      }));
      const renderEmptyComponent = (name2) => {
        const renderEmpty$1 = props.renderEmpty || slots.renderEmpty || parentContext.renderEmpty || renderEmpty;
        return renderEmpty$1(name2);
      };
      const autoInsertSpaceInButton = computed(() => {
        var _a2, _b;
        return (_a2 = props.autoInsertSpaceInButton) !== null && _a2 !== void 0 ? _a2 : (_b = parentContext.autoInsertSpaceInButton) === null || _b === void 0 ? void 0 : _b.value;
      });
      const locale2 = computed(() => {
        var _a2;
        return props.locale || ((_a2 = parentContext.locale) === null || _a2 === void 0 ? void 0 : _a2.value);
      });
      watch(locale2, () => {
        globalConfigBySet.locale = locale2.value;
      }, {
        immediate: true
      });
      const direction = computed(() => {
        var _a2;
        return props.direction || ((_a2 = parentContext.direction) === null || _a2 === void 0 ? void 0 : _a2.value);
      });
      const space = computed(() => {
        var _a2, _b;
        return (_a2 = props.space) !== null && _a2 !== void 0 ? _a2 : (_b = parentContext.space) === null || _b === void 0 ? void 0 : _b.value;
      });
      const virtual = computed(() => {
        var _a2, _b;
        return (_a2 = props.virtual) !== null && _a2 !== void 0 ? _a2 : (_b = parentContext.virtual) === null || _b === void 0 ? void 0 : _b.value;
      });
      const dropdownMatchSelectWidth = computed(() => {
        var _a2, _b;
        return (_a2 = props.dropdownMatchSelectWidth) !== null && _a2 !== void 0 ? _a2 : (_b = parentContext.dropdownMatchSelectWidth) === null || _b === void 0 ? void 0 : _b.value;
      });
      const getTargetContainer = computed(() => {
        var _a2;
        return props.getTargetContainer !== void 0 ? props.getTargetContainer : (_a2 = parentContext.getTargetContainer) === null || _a2 === void 0 ? void 0 : _a2.value;
      });
      const getPopupContainer = computed(() => {
        var _a2;
        return props.getPopupContainer !== void 0 ? props.getPopupContainer : (_a2 = parentContext.getPopupContainer) === null || _a2 === void 0 ? void 0 : _a2.value;
      });
      const pageHeader = computed(() => {
        var _a2;
        return props.pageHeader !== void 0 ? props.pageHeader : (_a2 = parentContext.pageHeader) === null || _a2 === void 0 ? void 0 : _a2.value;
      });
      const input = computed(() => {
        var _a2;
        return props.input !== void 0 ? props.input : (_a2 = parentContext.input) === null || _a2 === void 0 ? void 0 : _a2.value;
      });
      const pagination = computed(() => {
        var _a2;
        return props.pagination !== void 0 ? props.pagination : (_a2 = parentContext.pagination) === null || _a2 === void 0 ? void 0 : _a2.value;
      });
      const form = computed(() => {
        var _a2;
        return props.form !== void 0 ? props.form : (_a2 = parentContext.form) === null || _a2 === void 0 ? void 0 : _a2.value;
      });
      const select = computed(() => {
        var _a2;
        return props.select !== void 0 ? props.select : (_a2 = parentContext.select) === null || _a2 === void 0 ? void 0 : _a2.value;
      });
      const componentSize = computed(() => props.componentSize);
      const componentDisabled = computed(() => props.componentDisabled);
      const wave = computed(() => {
        var _a2, _b;
        return (_a2 = props.wave) !== null && _a2 !== void 0 ? _a2 : (_b = parentContext.wave) === null || _b === void 0 ? void 0 : _b.value;
      });
      const configProvider = {
        csp,
        autoInsertSpaceInButton,
        locale: locale2,
        direction,
        space,
        virtual,
        dropdownMatchSelectWidth,
        getPrefixCls,
        iconPrefixCls,
        theme: computed(() => {
          var _a2, _b;
          return (_a2 = mergedTheme.value) !== null && _a2 !== void 0 ? _a2 : (_b = parentContext.theme) === null || _b === void 0 ? void 0 : _b.value;
        }),
        renderEmpty: renderEmptyComponent,
        getTargetContainer,
        getPopupContainer,
        pageHeader,
        input,
        pagination,
        form,
        select,
        componentSize,
        componentDisabled,
        transformCellText: computed(() => props.transformCellText),
        wave
      };
      const memoTheme = computed(() => {
        const _a2 = mergedTheme.value || {}, {
          algorithm,
          token: token2
        } = _a2, rest = __rest$8(_a2, ["algorithm", "token"]);
        const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : void 0;
        return _extends$1(_extends$1({}, rest), {
          theme: themeObj,
          token: _extends$1(_extends$1({}, defaultSeedToken), token2)
        });
      });
      const validateMessagesRef = computed(() => {
        var _a2, _b;
        let validateMessages = {};
        if (locale2.value) {
          validateMessages = ((_a2 = locale2.value.Form) === null || _a2 === void 0 ? void 0 : _a2.defaultValidateMessages) || ((_b = localeValues$1.Form) === null || _b === void 0 ? void 0 : _b.defaultValidateMessages) || {};
        }
        if (props.form && props.form.validateMessages) {
          validateMessages = _extends$1(_extends$1({}, validateMessages), props.form.validateMessages);
        }
        return validateMessages;
      });
      useConfigContextProvider(configProvider);
      useProvideGlobalForm({
        validateMessages: validateMessagesRef
      });
      useProviderSize(componentSize);
      useProviderDisabled(componentDisabled);
      const renderProvider = (legacyLocale) => {
        var _a2, _b;
        let childNode = shouldWrapSSR.value ? wrapSSR((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) : (_b = slots.default) === null || _b === void 0 ? void 0 : _b.call(slots);
        if (props.theme) {
          const _childNode = /* @__PURE__ */ function() {
            return childNode;
          }();
          childNode = createVNode(DesignTokenProvider, {
            "value": memoTheme.value
          }, {
            default: () => [_childNode]
          });
        }
        return createVNode(locale$3, {
          "locale": locale2.value || legacyLocale,
          "ANT_MARK__": ANT_MARK
        }, {
          default: () => [childNode]
        });
      };
      watchEffect(() => {
        if (direction.value) {
          api$1.config({
            rtl: direction.value === "rtl"
          });
          notification.config({
            rtl: direction.value === "rtl"
          });
        }
      });
      return () => createVNode(LocaleReceiver, {
        "children": (_2, __, legacyLocale) => renderProvider(legacyLocale)
      }, null);
    }
  });
  ConfigProvider.config = setGlobalConfig;
  ConfigProvider.install = function(app2) {
    app2.component(ConfigProvider.name, ConfigProvider);
  };
  const ConfigProvider$1 = ConfigProvider;
  const genSharedDividerStyle = (token2) => {
    const {
      componentCls,
      sizePaddingEdgeHorizontal,
      colorSplit,
      lineWidth
    } = token2;
    return {
      [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
        borderBlockStart: `${lineWidth}px solid ${colorSplit}`,
        // vertical
        "&-vertical": {
          position: "relative",
          top: "-0.06em",
          display: "inline-block",
          height: "0.9em",
          margin: `0 ${token2.dividerVerticalGutterMargin}px`,
          verticalAlign: "middle",
          borderTop: 0,
          borderInlineStart: `${lineWidth}px solid ${colorSplit}`
        },
        "&-horizontal": {
          display: "flex",
          clear: "both",
          width: "100%",
          minWidth: "100%",
          margin: `${token2.dividerHorizontalGutterMargin}px 0`
        },
        [`&-horizontal${componentCls}-with-text`]: {
          display: "flex",
          alignItems: "center",
          margin: `${token2.dividerHorizontalWithTextGutterMargin}px 0`,
          color: token2.colorTextHeading,
          fontWeight: 500,
          fontSize: token2.fontSizeLG,
          whiteSpace: "nowrap",
          textAlign: "center",
          borderBlockStart: `0 ${colorSplit}`,
          "&::before, &::after": {
            position: "relative",
            width: "50%",
            borderBlockStart: `${lineWidth}px solid transparent`,
            // Chrome not accept `inherit` in `border-top`
            borderBlockStartColor: "inherit",
            borderBlockEnd: 0,
            transform: "translateY(50%)",
            content: "''"
          }
        },
        [`&-horizontal${componentCls}-with-text-left`]: {
          "&::before": {
            width: "5%"
          },
          "&::after": {
            width: "95%"
          }
        },
        [`&-horizontal${componentCls}-with-text-right`]: {
          "&::before": {
            width: "95%"
          },
          "&::after": {
            width: "5%"
          }
        },
        [`${componentCls}-inner-text`]: {
          display: "inline-block",
          padding: "0 1em"
        },
        "&-dashed": {
          background: "none",
          borderColor: colorSplit,
          borderStyle: "dashed",
          borderWidth: `${lineWidth}px 0 0`
        },
        [`&-horizontal${componentCls}-with-text${componentCls}-dashed`]: {
          "&::before, &::after": {
            borderStyle: "dashed none none"
          }
        },
        [`&-vertical${componentCls}-dashed`]: {
          borderInlineStartWidth: lineWidth,
          borderInlineEnd: 0,
          borderBlockStart: 0,
          borderBlockEnd: 0
        },
        [`&-plain${componentCls}-with-text`]: {
          color: token2.colorText,
          fontWeight: "normal",
          fontSize: token2.fontSize
        },
        [`&-horizontal${componentCls}-with-text-left${componentCls}-no-default-orientation-margin-left`]: {
          "&::before": {
            width: 0
          },
          "&::after": {
            width: "100%"
          },
          [`${componentCls}-inner-text`]: {
            paddingInlineStart: sizePaddingEdgeHorizontal
          }
        },
        [`&-horizontal${componentCls}-with-text-right${componentCls}-no-default-orientation-margin-right`]: {
          "&::before": {
            width: "100%"
          },
          "&::after": {
            width: 0
          },
          [`${componentCls}-inner-text`]: {
            paddingInlineEnd: sizePaddingEdgeHorizontal
          }
        }
      })
    };
  };
  const useStyle$1 = genComponentStyleHook("Divider", (token2) => {
    const dividerToken = merge(token2, {
      dividerVerticalGutterMargin: token2.marginXS,
      dividerHorizontalWithTextGutterMargin: token2.margin,
      dividerHorizontalGutterMargin: token2.marginLG
    });
    return [genSharedDividerStyle(dividerToken)];
  }, {
    sizePaddingEdgeHorizontal: 0
  });
  const dividerProps = () => ({
    prefixCls: String,
    type: {
      type: String,
      default: "horizontal"
    },
    dashed: {
      type: Boolean,
      default: false
    },
    orientation: {
      type: String,
      default: "center"
    },
    plain: {
      type: Boolean,
      default: false
    },
    orientationMargin: [String, Number]
  });
  const Divider = /* @__PURE__ */ defineComponent({
    name: "ADivider",
    inheritAttrs: false,
    compatConfig: {
      MODE: 3
    },
    props: dividerProps(),
    setup(props, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const {
        prefixCls: prefixClsRef,
        direction
      } = useConfigInject("divider", props);
      const [wrapSSR, hashId] = useStyle$1(prefixClsRef);
      const hasCustomMarginLeft = computed(() => props.orientation === "left" && props.orientationMargin != null);
      const hasCustomMarginRight = computed(() => props.orientation === "right" && props.orientationMargin != null);
      const classString = computed(() => {
        const {
          type: type4,
          dashed,
          plain
        } = props;
        const prefixCls = prefixClsRef.value;
        return {
          [prefixCls]: true,
          [hashId.value]: !!hashId.value,
          [`${prefixCls}-${type4}`]: true,
          [`${prefixCls}-dashed`]: !!dashed,
          [`${prefixCls}-plain`]: !!plain,
          [`${prefixCls}-rtl`]: direction.value === "rtl",
          [`${prefixCls}-no-default-orientation-margin-left`]: hasCustomMarginLeft.value,
          [`${prefixCls}-no-default-orientation-margin-right`]: hasCustomMarginRight.value
        };
      });
      const innerStyle = computed(() => {
        const marginValue = typeof props.orientationMargin === "number" ? `${props.orientationMargin}px` : props.orientationMargin;
        return _extends$1(_extends$1({}, hasCustomMarginLeft.value && {
          marginLeft: marginValue
        }), hasCustomMarginRight.value && {
          marginRight: marginValue
        });
      });
      const orientationPrefix = computed(() => props.orientation.length > 0 ? "-" + props.orientation : props.orientation);
      return () => {
        var _a2;
        const children = flattenChildren((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots));
        return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": [classString.value, children.length ? `${prefixClsRef.value}-with-text ${prefixClsRef.value}-with-text${orientationPrefix.value}` : "", attrs.class],
          "role": "separator"
        }), [children.length ? createVNode("span", {
          "class": `${prefixClsRef.value}-inner-text`,
          "style": innerStyle.value
        }, [children]) : null]));
      };
    }
  });
  const Divider$1 = withInstall(Divider);
  const isValid$1 = (value) => {
    return value !== void 0 && value !== null && (Array.isArray(value) ? filterEmpty(value).length : true);
  };
  function hasPrefixSuffix(propsAndSlots) {
    return isValid$1(propsAndSlots.prefix) || isValid$1(propsAndSlots.suffix) || isValid$1(propsAndSlots.allowClear);
  }
  function hasAddon$1(propsAndSlots) {
    return isValid$1(propsAndSlots.addonBefore) || isValid$1(propsAndSlots.addonAfter);
  }
  function fixControlledValue(value) {
    if (typeof value === "undefined" || value === null) {
      return "";
    }
    return String(value);
  }
  function resolveOnChange(target, e2, onChange, targetValue) {
    if (!onChange) {
      return;
    }
    const event = e2;
    if (e2.type === "click") {
      Object.defineProperty(event, "target", {
        writable: true
      });
      Object.defineProperty(event, "currentTarget", {
        writable: true
      });
      const currentTarget = target.cloneNode(true);
      event.target = currentTarget;
      event.currentTarget = currentTarget;
      currentTarget.value = "";
      onChange(event);
      return;
    }
    if (targetValue !== void 0) {
      Object.defineProperty(event, "target", {
        writable: true
      });
      Object.defineProperty(event, "currentTarget", {
        writable: true
      });
      event.target = target;
      event.currentTarget = target;
      target.value = targetValue;
      onChange(event);
      return;
    }
    onChange(event);
  }
  function triggerFocus(element, option) {
    if (!element)
      return;
    element.focus(option);
    const {
      cursor
    } = option || {};
    if (cursor) {
      const len = element.value.length;
      switch (cursor) {
        case "start":
          element.setSelectionRange(0, 0);
          break;
        case "end":
          element.setSelectionRange(len, len);
          break;
        default:
          element.setSelectionRange(0, len);
      }
    }
  }
  const commonInputProps = () => {
    return {
      addonBefore: PropTypes.any,
      addonAfter: PropTypes.any,
      prefix: PropTypes.any,
      suffix: PropTypes.any,
      clearIcon: PropTypes.any,
      affixWrapperClassName: String,
      groupClassName: String,
      wrapperClassName: String,
      inputClassName: String,
      allowClear: {
        type: Boolean,
        default: void 0
      }
    };
  };
  const baseInputProps = () => {
    return _extends$1(_extends$1({}, commonInputProps()), {
      value: {
        type: [String, Number, Symbol],
        default: void 0
      },
      defaultValue: {
        type: [String, Number, Symbol],
        default: void 0
      },
      inputElement: PropTypes.any,
      prefixCls: String,
      disabled: {
        type: Boolean,
        default: void 0
      },
      focused: {
        type: Boolean,
        default: void 0
      },
      triggerFocus: Function,
      readonly: {
        type: Boolean,
        default: void 0
      },
      handleReset: Function,
      hidden: {
        type: Boolean,
        default: void 0
      }
    });
  };
  const inputProps$1 = () => _extends$1(_extends$1({}, baseInputProps()), {
    id: String,
    placeholder: {
      type: [String, Number]
    },
    autocomplete: String,
    type: stringType("text"),
    name: String,
    size: {
      type: String
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    lazy: {
      type: Boolean,
      default: true
    },
    maxlength: Number,
    loading: {
      type: Boolean,
      default: void 0
    },
    bordered: {
      type: Boolean,
      default: void 0
    },
    showCount: {
      type: [Boolean, Object]
    },
    htmlSize: Number,
    onPressEnter: Function,
    onKeydown: Function,
    onKeyup: Function,
    onFocus: Function,
    onBlur: Function,
    onChange: Function,
    onInput: Function,
    "onUpdate:value": Function,
    onCompositionstart: Function,
    onCompositionend: Function,
    valueModifiers: Object,
    hidden: {
      type: Boolean,
      default: void 0
    },
    status: String
  });
  const BaseInput = /* @__PURE__ */ defineComponent({
    name: "BaseInput",
    inheritAttrs: false,
    props: baseInputProps(),
    setup(props, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const containerRef = ref();
      const onInputMouseDown = (e2) => {
        var _a2;
        if ((_a2 = containerRef.value) === null || _a2 === void 0 ? void 0 : _a2.contains(e2.target)) {
          const {
            triggerFocus: triggerFocus2
          } = props;
          triggerFocus2 === null || triggerFocus2 === void 0 ? void 0 : triggerFocus2();
        }
      };
      const getClearIcon = () => {
        var _a2;
        const {
          allowClear,
          value,
          disabled,
          readonly: readonly2,
          handleReset,
          suffix = slots.suffix,
          prefixCls
        } = props;
        if (!allowClear) {
          return null;
        }
        const needClear = !disabled && !readonly2 && value;
        const className = `${prefixCls}-clear-icon`;
        const iconNode = ((_a2 = slots.clearIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || "*";
        return createVNode("span", {
          "onClick": handleReset,
          "onMousedown": (e2) => e2.preventDefault(),
          "class": classNames({
            [`${className}-hidden`]: !needClear,
            [`${className}-has-suffix`]: !!suffix
          }, className),
          "role": "button",
          "tabindex": -1
        }, [iconNode]);
      };
      return () => {
        var _a2, _b;
        const {
          focused,
          value,
          disabled,
          allowClear,
          readonly: readonly2,
          hidden,
          prefixCls,
          prefix = (_a2 = slots.prefix) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          suffix = (_b = slots.suffix) === null || _b === void 0 ? void 0 : _b.call(slots),
          addonAfter = slots.addonAfter,
          addonBefore = slots.addonBefore,
          inputElement,
          affixWrapperClassName,
          wrapperClassName,
          groupClassName
        } = props;
        let element = cloneElement(inputElement, {
          value,
          hidden
        });
        if (hasPrefixSuffix({
          prefix,
          suffix,
          allowClear
        })) {
          const affixWrapperPrefixCls = `${prefixCls}-affix-wrapper`;
          const affixWrapperCls = classNames(affixWrapperPrefixCls, {
            [`${affixWrapperPrefixCls}-disabled`]: disabled,
            [`${affixWrapperPrefixCls}-focused`]: focused,
            [`${affixWrapperPrefixCls}-readonly`]: readonly2,
            [`${affixWrapperPrefixCls}-input-with-clear-btn`]: suffix && allowClear && value
          }, !hasAddon$1({
            addonAfter,
            addonBefore
          }) && attrs.class, affixWrapperClassName);
          const suffixNode = (suffix || allowClear) && createVNode("span", {
            "class": `${prefixCls}-suffix`
          }, [getClearIcon(), suffix]);
          element = createVNode("span", {
            "class": affixWrapperCls,
            "style": attrs.style,
            "hidden": !hasAddon$1({
              addonAfter,
              addonBefore
            }) && hidden,
            "onMousedown": onInputMouseDown,
            "ref": containerRef
          }, [prefix && createVNode("span", {
            "class": `${prefixCls}-prefix`
          }, [prefix]), cloneElement(inputElement, {
            style: null,
            value,
            hidden: null
          }), suffixNode]);
        }
        if (hasAddon$1({
          addonAfter,
          addonBefore
        })) {
          const wrapperCls = `${prefixCls}-group`;
          const addonCls = `${wrapperCls}-addon`;
          const mergedWrapperClassName = classNames(`${prefixCls}-wrapper`, wrapperCls, wrapperClassName);
          const mergedGroupClassName = classNames(`${prefixCls}-group-wrapper`, attrs.class, groupClassName);
          return createVNode("span", {
            "class": mergedGroupClassName,
            "style": attrs.style,
            "hidden": hidden
          }, [createVNode("span", {
            "class": mergedWrapperClassName
          }, [addonBefore && createVNode("span", {
            "class": addonCls
          }, [addonBefore]), cloneElement(element, {
            style: null,
            hidden: null
          }), addonAfter && createVNode("span", {
            "class": addonCls
          }, [addonAfter])])]);
        }
        return element;
      };
    }
  });
  var __rest$7 = function(s2, e2) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  const VcInput = /* @__PURE__ */ defineComponent({
    name: "VCInput",
    inheritAttrs: false,
    props: inputProps$1(),
    setup(props, _ref) {
      let {
        slots,
        attrs,
        expose,
        emit: emit2
      } = _ref;
      const stateValue = shallowRef(props.value === void 0 ? props.defaultValue : props.value);
      const focused = shallowRef(false);
      const inputRef = shallowRef();
      const rootRef = shallowRef();
      watch(() => props.value, () => {
        stateValue.value = props.value;
      });
      watch(() => props.disabled, () => {
        if (props.disabled) {
          focused.value = false;
        }
      });
      const focus = (option) => {
        if (inputRef.value) {
          triggerFocus(inputRef.value, option);
        }
      };
      const blur = () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      };
      const setSelectionRange = (start, end, direction) => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.setSelectionRange(start, end, direction);
      };
      const select = () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.select();
      };
      expose({
        focus,
        blur,
        input: inputRef,
        stateValue,
        setSelectionRange,
        select
      });
      const triggerChange = (e2) => {
        emit2("change", e2);
      };
      const setValue2 = (value, callback) => {
        if (stateValue.value === value) {
          return;
        }
        if (props.value === void 0) {
          stateValue.value = value;
        } else {
          nextTick(() => {
            var _a2;
            if (inputRef.value.value !== stateValue.value) {
              (_a2 = rootRef.value) === null || _a2 === void 0 ? void 0 : _a2.$forceUpdate();
            }
          });
        }
        nextTick(() => {
          callback && callback();
        });
      };
      const handleChange = (e2) => {
        const {
          value,
          composing
        } = e2.target;
        if ((e2.isComposing || composing) && props.lazy || stateValue.value === value)
          return;
        const newVal = e2.target.value;
        resolveOnChange(inputRef.value, e2, triggerChange);
        setValue2(newVal);
      };
      const handleKeyDown = (e2) => {
        if (e2.keyCode === 13) {
          emit2("pressEnter", e2);
        }
        emit2("keydown", e2);
      };
      const handleFocus = (e2) => {
        focused.value = true;
        emit2("focus", e2);
      };
      const handleBlur = (e2) => {
        focused.value = false;
        emit2("blur", e2);
      };
      const handleReset = (e2) => {
        resolveOnChange(inputRef.value, e2, triggerChange);
        setValue2("", () => {
          focus();
        });
      };
      const getInputElement = () => {
        var _a2, _b;
        const {
          addonBefore = slots.addonBefore,
          addonAfter = slots.addonAfter,
          disabled,
          valueModifiers = {},
          htmlSize,
          autocomplete,
          prefixCls,
          inputClassName,
          prefix = (_a2 = slots.prefix) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          suffix = (_b = slots.suffix) === null || _b === void 0 ? void 0 : _b.call(slots),
          allowClear,
          type: type4 = "text"
        } = props;
        const otherProps = omit$1(props, [
          "prefixCls",
          "onPressEnter",
          "addonBefore",
          "addonAfter",
          "prefix",
          "suffix",
          "allowClear",
          // Input elements must be either controlled or uncontrolled,
          // specify either the value prop, or the defaultValue prop, but not both.
          "defaultValue",
          "size",
          "bordered",
          "htmlSize",
          "lazy",
          "showCount",
          "valueModifiers",
          "showCount",
          "affixWrapperClassName",
          "groupClassName",
          "inputClassName",
          "wrapperClassName"
        ]);
        const inputProps2 = _extends$1(_extends$1(_extends$1({}, otherProps), attrs), {
          autocomplete,
          onChange: handleChange,
          onInput: handleChange,
          onFocus: handleFocus,
          onBlur: handleBlur,
          onKeydown: handleKeyDown,
          class: classNames(prefixCls, {
            [`${prefixCls}-disabled`]: disabled
          }, inputClassName, !hasAddon$1({
            addonAfter,
            addonBefore
          }) && !hasPrefixSuffix({
            prefix,
            suffix,
            allowClear
          }) && attrs.class),
          ref: inputRef,
          key: "ant-input",
          size: htmlSize,
          type: type4
        });
        if (valueModifiers.lazy) {
          delete inputProps2.onInput;
        }
        if (!inputProps2.autofocus) {
          delete inputProps2.autofocus;
        }
        const inputNode = createVNode("input", omit$1(inputProps2, ["size"]), null);
        return withDirectives(inputNode, [[antInputDirective]]);
      };
      const getSuffix = () => {
        var _a2;
        const {
          maxlength,
          suffix = (_a2 = slots.suffix) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          showCount,
          prefixCls
        } = props;
        const hasMaxLength = Number(maxlength) > 0;
        if (suffix || showCount) {
          const valueLength = [...fixControlledValue(stateValue.value)].length;
          const dataCount = typeof showCount === "object" ? showCount.formatter({
            count: valueLength,
            maxlength
          }) : `${valueLength}${hasMaxLength ? ` / ${maxlength}` : ""}`;
          return createVNode(Fragment, null, [!!showCount && createVNode("span", {
            "class": classNames(`${prefixCls}-show-count-suffix`, {
              [`${prefixCls}-show-count-has-suffix`]: !!suffix
            })
          }, [dataCount]), suffix]);
        }
        return null;
      };
      onMounted(() => {
      });
      return () => {
        const {
          prefixCls,
          disabled
        } = props, rest = __rest$7(props, ["prefixCls", "disabled"]);
        return createVNode(BaseInput, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, rest), attrs), {}, {
          "ref": rootRef,
          "prefixCls": prefixCls,
          "inputElement": getInputElement(),
          "handleReset": handleReset,
          "value": fixControlledValue(stateValue.value),
          "focused": focused.value,
          "triggerFocus": focus,
          "suffix": getSuffix(),
          "disabled": disabled
        }), slots);
      };
    }
  });
  const inputProps = () => {
    return omit$1(inputProps$1(), ["wrapperClassName", "groupClassName", "inputClassName", "affixWrapperClassName"]);
  };
  const textAreaProps = () => _extends$1(_extends$1({}, omit$1(inputProps(), ["prefix", "addonBefore", "addonAfter", "suffix"])), {
    rows: Number,
    autosize: {
      type: [Boolean, Object],
      default: void 0
    },
    autoSize: {
      type: [Boolean, Object],
      default: void 0
    },
    onResize: {
      type: Function
    },
    onCompositionstart: eventType(),
    onCompositionend: eventType(),
    valueModifiers: Object
  });
  var __rest$6 = function(s2, e2) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  const Input = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AInput",
    inheritAttrs: false,
    props: inputProps(),
    setup(props, _ref) {
      let {
        slots,
        attrs,
        expose,
        emit: emit2
      } = _ref;
      const inputRef = ref();
      const formItemContext = useInjectFormItemContext();
      const formItemInputContext = FormItemInputContext.useInject();
      const mergedStatus = computed(() => getMergedStatus(formItemInputContext.status, props.status));
      const {
        direction,
        prefixCls,
        size: size2,
        autocomplete
      } = useConfigInject("input", props);
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const mergedSize = computed(() => {
        return compactSize.value || size2.value;
      });
      const [wrapSSR, hashId] = useStyle$7(prefixCls);
      const disabled = useInjectDisabled();
      const focus = (option) => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus(option);
      };
      const blur = () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      };
      const setSelectionRange = (start, end, direction2) => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.setSelectionRange(start, end, direction2);
      };
      const select = () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.select();
      };
      expose({
        focus,
        blur,
        input: inputRef,
        setSelectionRange,
        select
      });
      const removePasswordTimeoutRef = ref([]);
      const removePasswordTimeout = () => {
        removePasswordTimeoutRef.value.push(setTimeout(() => {
          var _a2, _b, _c, _d;
          if (((_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.input) && ((_b = inputRef.value) === null || _b === void 0 ? void 0 : _b.input.getAttribute("type")) === "password" && ((_c = inputRef.value) === null || _c === void 0 ? void 0 : _c.input.hasAttribute("value"))) {
            (_d = inputRef.value) === null || _d === void 0 ? void 0 : _d.input.removeAttribute("value");
          }
        }));
      };
      onMounted(() => {
        removePasswordTimeout();
      });
      onBeforeUpdate(() => {
        removePasswordTimeoutRef.value.forEach((item) => clearTimeout(item));
      });
      onBeforeUnmount(() => {
        removePasswordTimeoutRef.value.forEach((item) => clearTimeout(item));
      });
      const handleBlur = (e2) => {
        removePasswordTimeout();
        emit2("blur", e2);
        formItemContext.onFieldBlur();
      };
      const handleFocus = (e2) => {
        removePasswordTimeout();
        emit2("focus", e2);
      };
      const triggerChange = (e2) => {
        emit2("update:value", e2.target.value);
        emit2("change", e2);
        emit2("input", e2);
        formItemContext.onFieldChange();
      };
      return () => {
        var _a2, _b, _c, _d, _e, _f;
        const {
          hasFeedback,
          feedbackIcon
        } = formItemInputContext;
        const {
          allowClear,
          bordered = true,
          prefix = (_a2 = slots.prefix) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          suffix = (_b = slots.suffix) === null || _b === void 0 ? void 0 : _b.call(slots),
          addonAfter = (_c = slots.addonAfter) === null || _c === void 0 ? void 0 : _c.call(slots),
          addonBefore = (_d = slots.addonBefore) === null || _d === void 0 ? void 0 : _d.call(slots),
          id = (_e = formItemContext.id) === null || _e === void 0 ? void 0 : _e.value
        } = props, rest = __rest$6(props, ["allowClear", "bordered", "prefix", "suffix", "addonAfter", "addonBefore", "id"]);
        const suffixNode = (hasFeedback || suffix) && createVNode(Fragment, null, [suffix, hasFeedback && feedbackIcon]);
        const prefixClsValue = prefixCls.value;
        const inputHasPrefixSuffix = hasPrefixSuffix({
          prefix,
          suffix
        }) || !!hasFeedback;
        const clearIcon = slots.clearIcon || (() => createVNode(CloseCircleFilled$1, null, null));
        return wrapSSR(createVNode(VcInput, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), omit$1(rest, ["onUpdate:value", "onChange", "onInput"])), {}, {
          "onChange": triggerChange,
          "id": id,
          "disabled": (_f = props.disabled) !== null && _f !== void 0 ? _f : disabled.value,
          "ref": inputRef,
          "prefixCls": prefixClsValue,
          "autocomplete": autocomplete.value,
          "onBlur": handleBlur,
          "onFocus": handleFocus,
          "prefix": prefix,
          "suffix": suffixNode,
          "allowClear": allowClear,
          "addonAfter": addonAfter && createVNode(NoCompactStyle, null, {
            default: () => [createVNode(NoFormStatus, null, {
              default: () => [addonAfter]
            })]
          }),
          "addonBefore": addonBefore && createVNode(NoCompactStyle, null, {
            default: () => [createVNode(NoFormStatus, null, {
              default: () => [addonBefore]
            })]
          }),
          "class": [attrs.class, compactItemClassnames.value],
          "inputClassName": classNames({
            [`${prefixClsValue}-sm`]: mergedSize.value === "small",
            [`${prefixClsValue}-lg`]: mergedSize.value === "large",
            [`${prefixClsValue}-rtl`]: direction.value === "rtl",
            [`${prefixClsValue}-borderless`]: !bordered
          }, !inputHasPrefixSuffix && getStatusClassNames(prefixClsValue, mergedStatus.value), hashId.value),
          "affixWrapperClassName": classNames({
            [`${prefixClsValue}-affix-wrapper-sm`]: mergedSize.value === "small",
            [`${prefixClsValue}-affix-wrapper-lg`]: mergedSize.value === "large",
            [`${prefixClsValue}-affix-wrapper-rtl`]: direction.value === "rtl",
            [`${prefixClsValue}-affix-wrapper-borderless`]: !bordered
          }, getStatusClassNames(`${prefixClsValue}-affix-wrapper`, mergedStatus.value, hasFeedback), hashId.value),
          "wrapperClassName": classNames({
            [`${prefixClsValue}-group-rtl`]: direction.value === "rtl"
          }, hashId.value),
          "groupClassName": classNames({
            [`${prefixClsValue}-group-wrapper-sm`]: mergedSize.value === "small",
            [`${prefixClsValue}-group-wrapper-lg`]: mergedSize.value === "large",
            [`${prefixClsValue}-group-wrapper-rtl`]: direction.value === "rtl"
          }, getStatusClassNames(`${prefixClsValue}-group-wrapper`, mergedStatus.value, hasFeedback), hashId.value)
        }), _extends$1(_extends$1({}, slots), {
          clearIcon
        })));
      };
    }
  });
  const Group = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AInputGroup",
    inheritAttrs: false,
    props: {
      prefixCls: String,
      size: {
        type: String
      },
      compact: {
        type: Boolean,
        default: void 0
      }
    },
    setup(props, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const {
        prefixCls,
        direction,
        getPrefixCls
      } = useConfigInject("input-group", props);
      const formItemInputContext = FormItemInputContext.useInject();
      FormItemInputContext.useProvide(formItemInputContext, {
        isFormItemInput: false
      });
      const inputPrefixCls = computed(() => getPrefixCls("input"));
      const [wrapSSR, hashId] = useStyle$7(inputPrefixCls);
      const cls = computed(() => {
        const pre = prefixCls.value;
        return {
          [`${pre}`]: true,
          [hashId.value]: true,
          [`${pre}-lg`]: props.size === "large",
          [`${pre}-sm`]: props.size === "small",
          [`${pre}-compact`]: props.compact,
          [`${pre}-rtl`]: direction.value === "rtl"
        };
      });
      return () => {
        var _a2;
        return wrapSSR(createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": classNames(cls.value, attrs.class)
        }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]));
      };
    }
  });
  var __rest$5 = function(s2, e2) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  const Search = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AInputSearch",
    inheritAttrs: false,
    props: _extends$1(_extends$1({}, inputProps()), {
      inputPrefixCls: String,
      // 不能设置默认值 https://github.com/vueComponent/ant-design-vue/issues/1916
      enterButton: PropTypes.any,
      onSearch: {
        type: Function
      }
    }),
    setup(props, _ref) {
      let {
        slots,
        attrs,
        expose,
        emit: emit2
      } = _ref;
      const inputRef = shallowRef();
      const composedRef = shallowRef(false);
      const focus = () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      };
      const blur = () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      };
      expose({
        focus,
        blur
      });
      const onChange = (e2) => {
        emit2("update:value", e2.target.value);
        if (e2 && e2.target && e2.type === "click") {
          emit2("search", e2.target.value, e2);
        }
        emit2("change", e2);
      };
      const onMousedown = (e2) => {
        var _a2;
        if (document.activeElement === ((_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.input)) {
          e2.preventDefault();
        }
      };
      const onSearch = (e2) => {
        var _a2, _b;
        emit2("search", (_b = (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.input) === null || _b === void 0 ? void 0 : _b.stateValue, e2);
      };
      const onPressEnter = (e2) => {
        if (composedRef.value || props.loading) {
          return;
        }
        onSearch(e2);
      };
      const handleOnCompositionStart = (e2) => {
        composedRef.value = true;
        emit2("compositionstart", e2);
      };
      const handleOnCompositionEnd = (e2) => {
        composedRef.value = false;
        emit2("compositionend", e2);
      };
      const {
        prefixCls,
        getPrefixCls,
        direction,
        size: size2
      } = useConfigInject("input-search", props);
      const inputPrefixCls = computed(() => getPrefixCls("input", props.inputPrefixCls));
      return () => {
        var _a2, _b, _c, _d;
        const {
          disabled,
          loading,
          addonAfter = (_a2 = slots.addonAfter) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          suffix = (_b = slots.suffix) === null || _b === void 0 ? void 0 : _b.call(slots)
        } = props, restProps = __rest$5(props, ["disabled", "loading", "addonAfter", "suffix"]);
        let {
          enterButton = (_d = (_c = slots.enterButton) === null || _c === void 0 ? void 0 : _c.call(slots)) !== null && _d !== void 0 ? _d : false
        } = props;
        enterButton = enterButton || enterButton === "";
        const searchIcon = typeof enterButton === "boolean" ? createVNode(SearchOutlined$1, null, null) : null;
        const btnClassName = `${prefixCls.value}-button`;
        const enterButtonAsElement = Array.isArray(enterButton) ? enterButton[0] : enterButton;
        let button;
        const isAntdButton = enterButtonAsElement.type && isPlainObject$1(enterButtonAsElement.type) && enterButtonAsElement.type.__ANT_BUTTON;
        if (isAntdButton || enterButtonAsElement.tagName === "button") {
          button = cloneElement(enterButtonAsElement, _extends$1({
            onMousedown,
            onClick: onSearch,
            key: "enterButton"
          }, isAntdButton ? {
            class: btnClassName,
            size: size2.value
          } : {}), false);
        } else {
          const iconOnly = searchIcon && !enterButton;
          button = createVNode(Button, {
            "class": btnClassName,
            "type": enterButton ? "primary" : void 0,
            "size": size2.value,
            "disabled": disabled,
            "key": "enterButton",
            "onMousedown": onMousedown,
            "onClick": onSearch,
            "loading": loading,
            "icon": iconOnly ? searchIcon : null
          }, {
            default: () => [iconOnly ? null : searchIcon || enterButton]
          });
        }
        if (addonAfter) {
          button = [button, addonAfter];
        }
        const cls = classNames(prefixCls.value, {
          [`${prefixCls.value}-rtl`]: direction.value === "rtl",
          [`${prefixCls.value}-${size2.value}`]: !!size2.value,
          [`${prefixCls.value}-with-button`]: !!enterButton
        }, attrs.class);
        return createVNode(Input, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          "ref": inputRef
        }, omit$1(restProps, ["onUpdate:value", "onSearch", "enterButton"])), attrs), {}, {
          "onPressEnter": onPressEnter,
          "onCompositionstart": handleOnCompositionStart,
          "onCompositionend": handleOnCompositionEnd,
          "size": size2.value,
          "prefixCls": inputPrefixCls.value,
          "addonAfter": button,
          "suffix": suffix,
          "onChange": onChange,
          "class": cls,
          "disabled": disabled
        }), slots);
      };
    }
  });
  const isValid = (value) => {
    return value !== void 0 && value !== null && (Array.isArray(value) ? filterEmpty(value).length : true);
  };
  function hasAddon(propsAndSlots) {
    return isValid(propsAndSlots.addonBefore) || isValid(propsAndSlots.addonAfter);
  }
  const ClearableInputType = ["text", "input"];
  const ClearableLabeledInput = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ClearableLabeledInput",
    inheritAttrs: false,
    props: {
      prefixCls: String,
      inputType: PropTypes.oneOf(tuple("text", "input")),
      value: anyType(),
      defaultValue: anyType(),
      allowClear: {
        type: Boolean,
        default: void 0
      },
      element: anyType(),
      handleReset: Function,
      disabled: {
        type: Boolean,
        default: void 0
      },
      direction: {
        type: String
      },
      size: {
        type: String
      },
      suffix: anyType(),
      prefix: anyType(),
      addonBefore: anyType(),
      addonAfter: anyType(),
      readonly: {
        type: Boolean,
        default: void 0
      },
      focused: {
        type: Boolean,
        default: void 0
      },
      bordered: {
        type: Boolean,
        default: true
      },
      triggerFocus: {
        type: Function
      },
      hidden: Boolean,
      status: String,
      hashId: String
    },
    setup(props, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const statusContext = FormItemInputContext.useInject();
      const renderClearIcon = (prefixCls) => {
        const {
          value,
          disabled,
          readonly: readonly2,
          handleReset,
          suffix = slots.suffix
        } = props;
        const needClear = !disabled && !readonly2 && value;
        const className = `${prefixCls}-clear-icon`;
        return createVNode(CloseCircleFilled$1, {
          "onClick": handleReset,
          "onMousedown": (e2) => e2.preventDefault(),
          "class": classNames({
            [`${className}-hidden`]: !needClear,
            [`${className}-has-suffix`]: !!suffix
          }, className),
          "role": "button"
        }, null);
      };
      const renderTextAreaWithClearIcon = (prefixCls, element) => {
        const {
          value,
          allowClear,
          direction,
          bordered,
          hidden,
          status: customStatus,
          addonAfter = slots.addonAfter,
          addonBefore = slots.addonBefore,
          hashId
        } = props;
        const {
          status: contextStatus,
          hasFeedback
        } = statusContext;
        if (!allowClear) {
          return cloneElement(element, {
            value,
            disabled: props.disabled
          });
        }
        const affixWrapperCls = classNames(`${prefixCls}-affix-wrapper`, `${prefixCls}-affix-wrapper-textarea-with-clear-btn`, getStatusClassNames(`${prefixCls}-affix-wrapper`, getMergedStatus(contextStatus, customStatus), hasFeedback), {
          [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
          [`${prefixCls}-affix-wrapper-borderless`]: !bordered,
          // className will go to addon wrapper
          [`${attrs.class}`]: !hasAddon({
            addonAfter,
            addonBefore
          }) && attrs.class
        }, hashId);
        return createVNode("span", {
          "class": affixWrapperCls,
          "style": attrs.style,
          "hidden": hidden
        }, [cloneElement(element, {
          style: null,
          value,
          disabled: props.disabled
        }), renderClearIcon(prefixCls)]);
      };
      return () => {
        var _a2;
        const {
          prefixCls,
          inputType,
          element = (_a2 = slots.element) === null || _a2 === void 0 ? void 0 : _a2.call(slots)
        } = props;
        if (inputType === ClearableInputType[0]) {
          return renderTextAreaWithClearIcon(prefixCls, element);
        }
        return null;
      };
    }
  });
  const HIDDEN_TEXTAREA_STYLE = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`;
  const SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"];
  const computedStyleCache = {};
  let hiddenTextarea;
  function calculateNodeStyling(node2) {
    let useCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const nodeRef = node2.getAttribute("id") || node2.getAttribute("data-reactid") || node2.getAttribute("name");
    if (useCache && computedStyleCache[nodeRef]) {
      return computedStyleCache[nodeRef];
    }
    const style = window.getComputedStyle(node2);
    const boxSizing = style.getPropertyValue("box-sizing") || style.getPropertyValue("-moz-box-sizing") || style.getPropertyValue("-webkit-box-sizing");
    const paddingSize = parseFloat(style.getPropertyValue("padding-bottom")) + parseFloat(style.getPropertyValue("padding-top"));
    const borderSize = parseFloat(style.getPropertyValue("border-bottom-width")) + parseFloat(style.getPropertyValue("border-top-width"));
    const sizingStyle = SIZING_STYLE.map((name2) => `${name2}:${style.getPropertyValue(name2)}`).join(";");
    const nodeInfo = {
      sizingStyle,
      paddingSize,
      borderSize,
      boxSizing
    };
    if (useCache && nodeRef) {
      computedStyleCache[nodeRef] = nodeInfo;
    }
    return nodeInfo;
  }
  function calculateAutoSizeStyle(uiTextNode) {
    let useCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    let minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    let maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    if (!hiddenTextarea) {
      hiddenTextarea = document.createElement("textarea");
      hiddenTextarea.setAttribute("tab-index", "-1");
      hiddenTextarea.setAttribute("aria-hidden", "true");
      document.body.appendChild(hiddenTextarea);
    }
    if (uiTextNode.getAttribute("wrap")) {
      hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
    } else {
      hiddenTextarea.removeAttribute("wrap");
    }
    const {
      paddingSize,
      borderSize,
      boxSizing,
      sizingStyle
    } = calculateNodeStyling(uiTextNode, useCache);
    hiddenTextarea.setAttribute("style", `${sizingStyle};${HIDDEN_TEXTAREA_STYLE}`);
    hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
    let minHeight = void 0;
    let maxHeight = void 0;
    let overflowY;
    let height = hiddenTextarea.scrollHeight;
    if (boxSizing === "border-box") {
      height += borderSize;
    } else if (boxSizing === "content-box") {
      height -= paddingSize;
    }
    if (minRows !== null || maxRows !== null) {
      hiddenTextarea.value = " ";
      const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
      if (minRows !== null) {
        minHeight = singleRowHeight * minRows;
        if (boxSizing === "border-box") {
          minHeight = minHeight + paddingSize + borderSize;
        }
        height = Math.max(minHeight, height);
      }
      if (maxRows !== null) {
        maxHeight = singleRowHeight * maxRows;
        if (boxSizing === "border-box") {
          maxHeight = maxHeight + paddingSize + borderSize;
        }
        overflowY = height > maxHeight ? "" : "hidden";
        height = Math.min(maxHeight, height);
      }
    }
    const style = {
      height: `${height}px`,
      overflowY,
      resize: "none"
    };
    if (minHeight) {
      style.minHeight = `${minHeight}px`;
    }
    if (maxHeight) {
      style.maxHeight = `${maxHeight}px`;
    }
    return style;
  }
  const RESIZE_START = 0;
  const RESIZE_MEASURING = 1;
  const RESIZE_STABLE = 2;
  const ResizableTextArea = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ResizableTextArea",
    inheritAttrs: false,
    props: textAreaProps(),
    setup(props, _ref) {
      let {
        attrs,
        emit: emit2,
        expose
      } = _ref;
      let nextFrameActionId;
      let resizeFrameId;
      const textAreaRef = ref();
      const textareaStyles = ref({});
      const resizeStatus = ref(RESIZE_STABLE);
      onBeforeUnmount(() => {
        wrapperRaf.cancel(nextFrameActionId);
        wrapperRaf.cancel(resizeFrameId);
      });
      const fixFirefoxAutoScroll = () => {
        try {
          if (document.activeElement === textAreaRef.value) {
            const currentStart = textAreaRef.value.selectionStart;
            const currentEnd = textAreaRef.value.selectionEnd;
            const scrollTop = textAreaRef.value.scrollTop;
            textAreaRef.value.setSelectionRange(currentStart, currentEnd);
            textAreaRef.value.scrollTop = scrollTop;
          }
        } catch (e2) {
        }
      };
      const minRows = ref();
      const maxRows = ref();
      watchEffect(() => {
        const autoSize = props.autoSize || props.autosize;
        if (autoSize) {
          minRows.value = autoSize.minRows;
          maxRows.value = autoSize.maxRows;
        } else {
          minRows.value = void 0;
          maxRows.value = void 0;
        }
      });
      const needAutoSize = computed(() => !!(props.autoSize || props.autosize));
      const startResize = () => {
        resizeStatus.value = RESIZE_START;
      };
      watch([() => props.value, minRows, maxRows, needAutoSize], () => {
        if (needAutoSize.value) {
          startResize();
        }
      }, {
        immediate: true,
        flush: "post"
      });
      const autoSizeStyle = ref();
      watch([resizeStatus, textAreaRef], () => {
        if (!textAreaRef.value)
          return;
        if (resizeStatus.value === RESIZE_START) {
          resizeStatus.value = RESIZE_MEASURING;
        } else if (resizeStatus.value === RESIZE_MEASURING) {
          const textareaStyles2 = calculateAutoSizeStyle(textAreaRef.value, false, minRows.value, maxRows.value);
          resizeStatus.value = RESIZE_STABLE;
          autoSizeStyle.value = textareaStyles2;
        } else {
          fixFirefoxAutoScroll();
        }
      }, {
        immediate: true,
        flush: "post"
      });
      const instance = getCurrentInstance();
      const resizeRafRef = ref();
      const cleanRaf = () => {
        wrapperRaf.cancel(resizeRafRef.value);
      };
      const onInternalResize = (size2) => {
        if (resizeStatus.value === RESIZE_STABLE) {
          emit2("resize", size2);
          if (needAutoSize.value) {
            cleanRaf();
            resizeRafRef.value = wrapperRaf(() => {
              startResize();
            });
          }
        }
      };
      onBeforeUnmount(() => {
        cleanRaf();
      });
      const resizeTextarea = () => {
        startResize();
      };
      expose({
        resizeTextarea,
        textArea: textAreaRef,
        instance
      });
      warning$3(props.autosize === void 0, "Input.TextArea", "autosize is deprecated, please use autoSize instead.");
      const renderTextArea = () => {
        const {
          prefixCls,
          disabled
        } = props;
        const otherProps = omit$1(props, ["prefixCls", "onPressEnter", "autoSize", "autosize", "defaultValue", "allowClear", "type", "lazy", "maxlength", "valueModifiers"]);
        const cls = classNames(prefixCls, attrs.class, {
          [`${prefixCls}-disabled`]: disabled
        });
        const mergedAutoSizeStyle = needAutoSize.value ? autoSizeStyle.value : null;
        const style = [attrs.style, textareaStyles.value, mergedAutoSizeStyle];
        const textareaProps = _extends$1(_extends$1(_extends$1({}, otherProps), attrs), {
          style,
          class: cls
        });
        if (resizeStatus.value === RESIZE_START || resizeStatus.value === RESIZE_MEASURING) {
          style.push({
            overflowX: "hidden",
            overflowY: "hidden"
          });
        }
        if (!textareaProps.autofocus) {
          delete textareaProps.autofocus;
        }
        if (textareaProps.rows === 0) {
          delete textareaProps.rows;
        }
        return createVNode(ResizeObserver$1, {
          "onResize": onInternalResize,
          "disabled": !needAutoSize.value
        }, {
          default: () => [withDirectives(createVNode("textarea", _objectSpread2$1(_objectSpread2$1({}, textareaProps), {}, {
            "ref": textAreaRef
          }), null), [[antInputDirective]])]
        });
      };
      return () => {
        return renderTextArea();
      };
    }
  });
  const ResizableTextArea$1 = ResizableTextArea;
  function fixEmojiLength(value, maxLength) {
    return [...value || ""].slice(0, maxLength).join("");
  }
  function setTriggerValue(isCursorInEnd, preValue, triggerValue, maxLength) {
    let newTriggerValue = triggerValue;
    if (isCursorInEnd) {
      newTriggerValue = fixEmojiLength(triggerValue, maxLength);
    } else if ([...preValue || ""].length < triggerValue.length && [...triggerValue || ""].length > maxLength) {
      newTriggerValue = preValue;
    }
    return newTriggerValue;
  }
  const TextArea = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ATextarea",
    inheritAttrs: false,
    props: textAreaProps(),
    setup(props, _ref) {
      let {
        attrs,
        expose,
        emit: emit2
      } = _ref;
      const formItemContext = useInjectFormItemContext();
      const formItemInputContext = FormItemInputContext.useInject();
      const mergedStatus = computed(() => getMergedStatus(formItemInputContext.status, props.status));
      const stateValue = shallowRef(props.value === void 0 ? props.defaultValue : props.value);
      const resizableTextArea = shallowRef();
      const mergedValue = shallowRef("");
      const {
        prefixCls,
        size: size2,
        direction
      } = useConfigInject("input", props);
      const [wrapSSR, hashId] = useStyle$7(prefixCls);
      const disabled = useInjectDisabled();
      const showCount = computed(() => {
        return props.showCount === "" || props.showCount || false;
      });
      const hasMaxLength = computed(() => Number(props.maxlength) > 0);
      const compositing = shallowRef(false);
      const oldCompositionValueRef = shallowRef();
      const oldSelectionStartRef = shallowRef(0);
      const onInternalCompositionStart = (e2) => {
        compositing.value = true;
        oldCompositionValueRef.value = mergedValue.value;
        oldSelectionStartRef.value = e2.currentTarget.selectionStart;
        emit2("compositionstart", e2);
      };
      const onInternalCompositionEnd = (e2) => {
        var _a2;
        compositing.value = false;
        let triggerValue = e2.currentTarget.value;
        if (hasMaxLength.value) {
          const isCursorInEnd = oldSelectionStartRef.value >= props.maxlength + 1 || oldSelectionStartRef.value === ((_a2 = oldCompositionValueRef.value) === null || _a2 === void 0 ? void 0 : _a2.length);
          triggerValue = setTriggerValue(isCursorInEnd, oldCompositionValueRef.value, triggerValue, props.maxlength);
        }
        if (triggerValue !== mergedValue.value) {
          setValue2(triggerValue);
          resolveOnChange(e2.currentTarget, e2, triggerChange, triggerValue);
        }
        emit2("compositionend", e2);
      };
      const instance = getCurrentInstance();
      watch(() => props.value, () => {
        var _a2;
        if ("value" in instance.vnode.props || {}) {
          stateValue.value = (_a2 = props.value) !== null && _a2 !== void 0 ? _a2 : "";
        }
      });
      const focus = (option) => {
        var _a2;
        triggerFocus((_a2 = resizableTextArea.value) === null || _a2 === void 0 ? void 0 : _a2.textArea, option);
      };
      const blur = () => {
        var _a2, _b;
        (_b = (_a2 = resizableTextArea.value) === null || _a2 === void 0 ? void 0 : _a2.textArea) === null || _b === void 0 ? void 0 : _b.blur();
      };
      const setValue2 = (value, callback) => {
        if (stateValue.value === value) {
          return;
        }
        if (props.value === void 0) {
          stateValue.value = value;
        } else {
          nextTick(() => {
            var _a2, _b, _c;
            if (resizableTextArea.value.textArea.value !== mergedValue.value) {
              (_c = (_a2 = resizableTextArea.value) === null || _a2 === void 0 ? void 0 : (_b = _a2.instance).update) === null || _c === void 0 ? void 0 : _c.call(_b);
            }
          });
        }
        nextTick(() => {
          callback && callback();
        });
      };
      const handleKeyDown = (e2) => {
        if (e2.keyCode === 13) {
          emit2("pressEnter", e2);
        }
        emit2("keydown", e2);
      };
      const onBlur = (e2) => {
        const {
          onBlur: onBlur2
        } = props;
        onBlur2 === null || onBlur2 === void 0 ? void 0 : onBlur2(e2);
        formItemContext.onFieldBlur();
      };
      const triggerChange = (e2) => {
        emit2("update:value", e2.target.value);
        emit2("change", e2);
        emit2("input", e2);
        formItemContext.onFieldChange();
      };
      const handleReset = (e2) => {
        resolveOnChange(resizableTextArea.value.textArea, e2, triggerChange);
        setValue2("", () => {
          focus();
        });
      };
      const handleChange = (e2) => {
        const {
          composing
        } = e2.target;
        let triggerValue = e2.target.value;
        compositing.value = !!(e2.isComposing || composing);
        if (compositing.value && props.lazy || stateValue.value === triggerValue)
          return;
        if (hasMaxLength.value) {
          const target = e2.target;
          const isCursorInEnd = target.selectionStart >= props.maxlength + 1 || target.selectionStart === triggerValue.length || !target.selectionStart;
          triggerValue = setTriggerValue(isCursorInEnd, mergedValue.value, triggerValue, props.maxlength);
        }
        resolveOnChange(e2.currentTarget, e2, triggerChange, triggerValue);
        setValue2(triggerValue);
      };
      const renderTextArea = () => {
        var _a2, _b;
        const {
          class: customClass
        } = attrs;
        const {
          bordered = true
        } = props;
        const resizeProps = _extends$1(_extends$1(_extends$1({}, omit$1(props, ["allowClear"])), attrs), {
          class: [{
            [`${prefixCls.value}-borderless`]: !bordered,
            [`${customClass}`]: customClass && !showCount.value,
            [`${prefixCls.value}-sm`]: size2.value === "small",
            [`${prefixCls.value}-lg`]: size2.value === "large"
          }, getStatusClassNames(prefixCls.value, mergedStatus.value), hashId.value],
          disabled: disabled.value,
          showCount: null,
          prefixCls: prefixCls.value,
          onInput: handleChange,
          onChange: handleChange,
          onBlur,
          onKeydown: handleKeyDown,
          onCompositionstart: onInternalCompositionStart,
          onCompositionend: onInternalCompositionEnd
        });
        if ((_a2 = props.valueModifiers) === null || _a2 === void 0 ? void 0 : _a2.lazy) {
          delete resizeProps.onInput;
        }
        return createVNode(ResizableTextArea$1, _objectSpread2$1(_objectSpread2$1({}, resizeProps), {}, {
          "id": (_b = resizeProps === null || resizeProps === void 0 ? void 0 : resizeProps.id) !== null && _b !== void 0 ? _b : formItemContext.id.value,
          "ref": resizableTextArea,
          "maxlength": props.maxlength
        }), null);
      };
      expose({
        focus,
        blur,
        resizableTextArea
      });
      watchEffect(() => {
        let val = fixControlledValue(stateValue.value);
        if (!compositing.value && hasMaxLength.value && (props.value === null || props.value === void 0)) {
          val = fixEmojiLength(val, props.maxlength);
        }
        mergedValue.value = val;
      });
      return () => {
        var _a2;
        const {
          maxlength,
          bordered = true,
          hidden
        } = props;
        const {
          style,
          class: customClass
        } = attrs;
        const inputProps2 = _extends$1(_extends$1(_extends$1({}, props), attrs), {
          prefixCls: prefixCls.value,
          inputType: "text",
          handleReset,
          direction: direction.value,
          bordered,
          style: showCount.value ? void 0 : style,
          hashId: hashId.value,
          disabled: (_a2 = props.disabled) !== null && _a2 !== void 0 ? _a2 : disabled.value
        });
        let textareaNode = createVNode(ClearableLabeledInput, _objectSpread2$1(_objectSpread2$1({}, inputProps2), {}, {
          "value": mergedValue.value,
          "status": props.status
        }), {
          element: renderTextArea
        });
        if (showCount.value || formItemInputContext.hasFeedback) {
          const valueLength = [...mergedValue.value].length;
          let dataCount = "";
          if (typeof showCount.value === "object") {
            dataCount = showCount.value.formatter({
              value: mergedValue.value,
              count: valueLength,
              maxlength
            });
          } else {
            dataCount = `${valueLength}${hasMaxLength.value ? ` / ${maxlength}` : ""}`;
          }
          textareaNode = createVNode("div", {
            "hidden": hidden,
            "class": classNames(`${prefixCls.value}-textarea`, {
              [`${prefixCls.value}-textarea-rtl`]: direction.value === "rtl",
              [`${prefixCls.value}-textarea-show-count`]: showCount.value,
              [`${prefixCls.value}-textarea-in-form-item`]: formItemInputContext.isFormItemInput
            }, `${prefixCls.value}-textarea-show-count`, customClass, hashId.value),
            "style": style,
            "data-count": typeof dataCount !== "object" ? dataCount : void 0
          }, [textareaNode, formItemInputContext.hasFeedback && createVNode("span", {
            "class": `${prefixCls.value}-textarea-suffix`
          }, [formItemInputContext.feedbackIcon])]);
        }
        return wrapSSR(textareaNode);
      };
    }
  });
  var EyeOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
  const EyeOutlinedSvg = EyeOutlined$2;
  function _objectSpread$1(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty$1(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty$1(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var EyeOutlined = function EyeOutlined2(props, context3) {
    var p = _objectSpread$1({}, props, context3.attrs);
    return createVNode(AntdIcon, _objectSpread$1({}, p, {
      "icon": EyeOutlinedSvg
    }), null);
  };
  EyeOutlined.displayName = "EyeOutlined";
  EyeOutlined.inheritAttrs = false;
  const EyeOutlined$1 = EyeOutlined;
  var EyeInvisibleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };
  const EyeInvisibleOutlinedSvg = EyeInvisibleOutlined$2;
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? Object(arguments[i2]) : {};
      var ownKeys2 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys2.forEach(function(key2) {
        _defineProperty(target, key2, source[key2]);
      });
    }
    return target;
  }
  function _defineProperty(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var EyeInvisibleOutlined = function EyeInvisibleOutlined2(props, context3) {
    var p = _objectSpread({}, props, context3.attrs);
    return createVNode(AntdIcon, _objectSpread({}, p, {
      "icon": EyeInvisibleOutlinedSvg
    }), null);
  };
  EyeInvisibleOutlined.displayName = "EyeInvisibleOutlined";
  EyeInvisibleOutlined.inheritAttrs = false;
  const EyeInvisibleOutlined$1 = EyeInvisibleOutlined;
  var __rest$4 = function(s2, e2) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  const ActionMap = {
    click: "onClick",
    hover: "onMouseover"
  };
  const defaultIconRender = (visible) => visible ? createVNode(EyeOutlined$1, null, null) : createVNode(EyeInvisibleOutlined$1, null, null);
  const Password = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AInputPassword",
    inheritAttrs: false,
    props: _extends$1(_extends$1({}, inputProps()), {
      prefixCls: String,
      inputPrefixCls: String,
      action: {
        type: String,
        default: "click"
      },
      visibilityToggle: {
        type: Boolean,
        default: true
      },
      visible: {
        type: Boolean,
        default: void 0
      },
      "onUpdate:visible": Function,
      iconRender: Function
    }),
    setup(props, _ref) {
      let {
        slots,
        attrs,
        expose,
        emit: emit2
      } = _ref;
      const visible = shallowRef(false);
      const onVisibleChange = () => {
        const {
          disabled
        } = props;
        if (disabled) {
          return;
        }
        visible.value = !visible.value;
        emit2("update:visible", visible.value);
      };
      watchEffect(() => {
        if (props.visible !== void 0) {
          visible.value = !!props.visible;
        }
      });
      const inputRef = shallowRef();
      const focus = () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
      };
      const blur = () => {
        var _a2;
        (_a2 = inputRef.value) === null || _a2 === void 0 ? void 0 : _a2.blur();
      };
      expose({
        focus,
        blur
      });
      const getIcon = (prefixCls2) => {
        const {
          action,
          iconRender = slots.iconRender || defaultIconRender
        } = props;
        const iconTrigger = ActionMap[action] || "";
        const icon = iconRender(visible.value);
        const iconProps = {
          [iconTrigger]: onVisibleChange,
          class: `${prefixCls2}-icon`,
          key: "passwordIcon",
          onMousedown: (e2) => {
            e2.preventDefault();
          },
          onMouseup: (e2) => {
            e2.preventDefault();
          }
        };
        return cloneElement(isValidElement(icon) ? icon : createVNode("span", null, [icon]), iconProps);
      };
      const {
        prefixCls,
        getPrefixCls
      } = useConfigInject("input-password", props);
      const inputPrefixCls = computed(() => getPrefixCls("input", props.inputPrefixCls));
      const renderPassword = () => {
        const {
          size: size2,
          visibilityToggle
        } = props, restProps = __rest$4(props, ["size", "visibilityToggle"]);
        const suffixIcon = visibilityToggle && getIcon(prefixCls.value);
        const inputClassName = classNames(prefixCls.value, attrs.class, {
          [`${prefixCls.value}-${size2}`]: !!size2
        });
        const omittedProps = _extends$1(_extends$1(_extends$1({}, omit$1(restProps, ["suffix", "iconRender", "action"])), attrs), {
          type: visible.value ? "text" : "password",
          class: inputClassName,
          prefixCls: inputPrefixCls.value,
          suffix: suffixIcon
        });
        if (size2) {
          omittedProps.size = size2;
        }
        return createVNode(Input, _objectSpread2$1({
          "ref": inputRef
        }, omittedProps), slots);
      };
      return () => {
        return renderPassword();
      };
    }
  });
  Input.Group = Group;
  Input.Search = Search;
  Input.TextArea = TextArea;
  Input.Password = Password;
  Input.install = function(app2) {
    app2.component(Input.name, Input);
    app2.component(Input.Group.name, Input.Group);
    app2.component(Input.Search.name, Input.Search);
    app2.component(Input.TextArea.name, Input.TextArea);
    app2.component(Input.Password.name, Input.Password);
    return app2;
  };
  function dialogPropTypes() {
    return {
      keyboard: {
        type: Boolean,
        default: void 0
      },
      mask: {
        type: Boolean,
        default: void 0
      },
      afterClose: Function,
      closable: {
        type: Boolean,
        default: void 0
      },
      maskClosable: {
        type: Boolean,
        default: void 0
      },
      visible: {
        type: Boolean,
        default: void 0
      },
      destroyOnClose: {
        type: Boolean,
        default: void 0
      },
      mousePosition: PropTypes.shape({
        x: Number,
        y: Number
      }).loose,
      title: PropTypes.any,
      footer: PropTypes.any,
      transitionName: String,
      maskTransitionName: String,
      animation: PropTypes.any,
      maskAnimation: PropTypes.any,
      wrapStyle: {
        type: Object,
        default: void 0
      },
      bodyStyle: {
        type: Object,
        default: void 0
      },
      maskStyle: {
        type: Object,
        default: void 0
      },
      prefixCls: String,
      wrapClassName: String,
      rootClassName: String,
      width: [String, Number],
      height: [String, Number],
      zIndex: Number,
      bodyProps: PropTypes.any,
      maskProps: PropTypes.any,
      wrapProps: PropTypes.any,
      getContainer: PropTypes.any,
      dialogStyle: {
        type: Object,
        default: void 0
      },
      dialogClass: String,
      closeIcon: PropTypes.any,
      forceRender: {
        type: Boolean,
        default: void 0
      },
      getOpenCount: Function,
      // https://github.com/ant-design/ant-design/issues/19771
      // https://github.com/react-component/dialog/issues/95
      focusTriggerAfterClose: {
        type: Boolean,
        default: void 0
      },
      onClose: Function,
      modalRender: Function
    };
  }
  function getMotionName(prefixCls, transitionName2, animationName) {
    let motionName = transitionName2;
    if (!motionName && animationName) {
      motionName = `${prefixCls}-${animationName}`;
    }
    return motionName;
  }
  let uuid$1 = -1;
  function getUUID() {
    uuid$1 += 1;
    return uuid$1;
  }
  function getScroll(w2, top) {
    let ret = w2[`page${top ? "Y" : "X"}Offset`];
    const method4 = `scroll${top ? "Top" : "Left"}`;
    if (typeof ret !== "number") {
      const d2 = w2.document;
      ret = d2.documentElement[method4];
      if (typeof ret !== "number") {
        ret = d2.body[method4];
      }
    }
    return ret;
  }
  function offset2(el) {
    const rect = el.getBoundingClientRect();
    const pos = {
      left: rect.left,
      top: rect.top
    };
    const doc2 = el.ownerDocument;
    const w2 = doc2.defaultView || doc2.parentWindow;
    pos.left += getScroll(w2);
    pos.top += getScroll(w2, true);
    return pos;
  }
  const sentinelStyle = {
    width: 0,
    height: 0,
    overflow: "hidden",
    outline: "none"
  };
  const Content = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "DialogContent",
    inheritAttrs: false,
    props: _extends$1(_extends$1({}, dialogPropTypes()), {
      motionName: String,
      ariaId: String,
      onVisibleChanged: Function,
      onMousedown: Function,
      onMouseup: Function
    }),
    setup(props, _ref) {
      let {
        expose,
        slots,
        attrs
      } = _ref;
      const sentinelStartRef = ref();
      const sentinelEndRef = ref();
      const dialogRef = ref();
      expose({
        focus: () => {
          var _a2;
          (_a2 = sentinelStartRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
        },
        changeActive: (next2) => {
          const {
            activeElement
          } = document;
          if (next2 && activeElement === sentinelEndRef.value) {
            sentinelStartRef.value.focus();
          } else if (!next2 && activeElement === sentinelStartRef.value) {
            sentinelEndRef.value.focus();
          }
        }
      });
      const transformOrigin = ref();
      const contentStyleRef = computed(() => {
        const {
          width,
          height
        } = props;
        const contentStyle = {};
        if (width !== void 0) {
          contentStyle.width = typeof width === "number" ? `${width}px` : width;
        }
        if (height !== void 0) {
          contentStyle.height = typeof height === "number" ? `${height}px` : height;
        }
        if (transformOrigin.value) {
          contentStyle.transformOrigin = transformOrigin.value;
        }
        return contentStyle;
      });
      const onPrepare = () => {
        nextTick(() => {
          if (dialogRef.value) {
            const elementOffset = offset2(dialogRef.value);
            transformOrigin.value = props.mousePosition ? `${props.mousePosition.x - elementOffset.left}px ${props.mousePosition.y - elementOffset.top}px` : "";
          }
        });
      };
      const onVisibleChanged = (visible) => {
        props.onVisibleChanged(visible);
      };
      return () => {
        var _a2, _b, _c, _d;
        const {
          prefixCls,
          footer = (_a2 = slots.footer) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          title = (_b = slots.title) === null || _b === void 0 ? void 0 : _b.call(slots),
          ariaId,
          closable,
          closeIcon = (_c = slots.closeIcon) === null || _c === void 0 ? void 0 : _c.call(slots),
          onClose,
          bodyStyle,
          bodyProps,
          onMousedown,
          onMouseup,
          visible,
          modalRender = slots.modalRender,
          destroyOnClose,
          motionName
        } = props;
        let footerNode;
        if (footer) {
          footerNode = createVNode("div", {
            "class": `${prefixCls}-footer`
          }, [footer]);
        }
        let headerNode;
        if (title) {
          headerNode = createVNode("div", {
            "class": `${prefixCls}-header`
          }, [createVNode("div", {
            "class": `${prefixCls}-title`,
            "id": ariaId
          }, [title])]);
        }
        let closer;
        if (closable) {
          closer = createVNode("button", {
            "type": "button",
            "onClick": onClose,
            "aria-label": "Close",
            "class": `${prefixCls}-close`
          }, [closeIcon || createVNode("span", {
            "class": `${prefixCls}-close-x`
          }, null)]);
        }
        const content = createVNode("div", {
          "class": `${prefixCls}-content`
        }, [closer, headerNode, createVNode("div", _objectSpread2$1({
          "class": `${prefixCls}-body`,
          "style": bodyStyle
        }, bodyProps), [(_d = slots.default) === null || _d === void 0 ? void 0 : _d.call(slots)]), footerNode]);
        const transitionProps = getTransitionProps(motionName);
        return createVNode(Transition, _objectSpread2$1(_objectSpread2$1({}, transitionProps), {}, {
          "onBeforeEnter": onPrepare,
          "onAfterEnter": () => onVisibleChanged(true),
          "onAfterLeave": () => onVisibleChanged(false)
        }), {
          default: () => [visible || !destroyOnClose ? withDirectives(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
            "ref": dialogRef,
            "key": "dialog-element",
            "role": "document",
            "style": [contentStyleRef.value, attrs.style],
            "class": [prefixCls, attrs.class],
            "onMousedown": onMousedown,
            "onMouseup": onMouseup
          }), [createVNode("div", {
            "tabindex": 0,
            "ref": sentinelStartRef,
            "style": sentinelStyle,
            "aria-hidden": "true"
          }, null), modalRender ? modalRender({
            originVNode: content
          }) : content, createVNode("div", {
            "tabindex": 0,
            "ref": sentinelEndRef,
            "style": sentinelStyle,
            "aria-hidden": "true"
          }, null)]), [[vShow, visible]]) : null]
        });
      };
    }
  });
  const Mask = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "DialogMask",
    props: {
      prefixCls: String,
      visible: Boolean,
      motionName: String,
      maskProps: Object
    },
    setup(props, _ref) {
      return () => {
        const {
          prefixCls,
          visible,
          maskProps,
          motionName
        } = props;
        const transitionProps = getTransitionProps(motionName);
        return createVNode(Transition, transitionProps, {
          default: () => [withDirectives(createVNode("div", _objectSpread2$1({
            "class": `${prefixCls}-mask`
          }, maskProps), null), [[vShow, visible]])]
        });
      };
    }
  });
  const Dialog = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "VcDialog",
    inheritAttrs: false,
    props: initDefaultProps(_extends$1(_extends$1({}, dialogPropTypes()), {
      getOpenCount: Function,
      scrollLocker: Object
    }), {
      mask: true,
      visible: false,
      keyboard: true,
      closable: true,
      maskClosable: true,
      destroyOnClose: false,
      prefixCls: "rc-dialog",
      getOpenCount: () => null,
      focusTriggerAfterClose: true
    }),
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const lastOutSideActiveElementRef = shallowRef();
      const wrapperRef = shallowRef();
      const contentRef = shallowRef();
      const animatedVisible = shallowRef(props.visible);
      const ariaIdRef = shallowRef(`vcDialogTitle${getUUID()}`);
      const onDialogVisibleChanged = (newVisible) => {
        var _a2, _b;
        if (newVisible) {
          if (!contains$1(wrapperRef.value, document.activeElement)) {
            lastOutSideActiveElementRef.value = document.activeElement;
            (_a2 = contentRef.value) === null || _a2 === void 0 ? void 0 : _a2.focus();
          }
        } else {
          const preAnimatedVisible = animatedVisible.value;
          animatedVisible.value = false;
          if (props.mask && lastOutSideActiveElementRef.value && props.focusTriggerAfterClose) {
            try {
              lastOutSideActiveElementRef.value.focus({
                preventScroll: true
              });
            } catch (e2) {
            }
            lastOutSideActiveElementRef.value = null;
          }
          if (preAnimatedVisible) {
            (_b = props.afterClose) === null || _b === void 0 ? void 0 : _b.call(props);
          }
        }
      };
      const onInternalClose = (e2) => {
        var _a2;
        (_a2 = props.onClose) === null || _a2 === void 0 ? void 0 : _a2.call(props, e2);
      };
      const contentClickRef = shallowRef(false);
      const contentTimeoutRef = shallowRef();
      const onContentMouseDown = () => {
        clearTimeout(contentTimeoutRef.value);
        contentClickRef.value = true;
      };
      const onContentMouseUp = () => {
        contentTimeoutRef.value = setTimeout(() => {
          contentClickRef.value = false;
        });
      };
      const onWrapperClick = (e2) => {
        if (!props.maskClosable)
          return null;
        if (contentClickRef.value) {
          contentClickRef.value = false;
        } else if (wrapperRef.value === e2.target) {
          onInternalClose(e2);
        }
      };
      const onWrapperKeyDown = (e2) => {
        if (props.keyboard && e2.keyCode === KeyCode$1.ESC) {
          e2.stopPropagation();
          onInternalClose(e2);
          return;
        }
        if (props.visible) {
          if (e2.keyCode === KeyCode$1.TAB) {
            contentRef.value.changeActive(!e2.shiftKey);
          }
        }
      };
      watch(() => props.visible, () => {
        if (props.visible) {
          animatedVisible.value = true;
        }
      }, {
        flush: "post"
      });
      onBeforeUnmount(() => {
        var _a2;
        clearTimeout(contentTimeoutRef.value);
        (_a2 = props.scrollLocker) === null || _a2 === void 0 ? void 0 : _a2.unLock();
      });
      watchEffect(() => {
        var _a2, _b;
        (_a2 = props.scrollLocker) === null || _a2 === void 0 ? void 0 : _a2.unLock();
        if (animatedVisible.value) {
          (_b = props.scrollLocker) === null || _b === void 0 ? void 0 : _b.lock();
        }
      });
      return () => {
        const {
          prefixCls,
          mask,
          visible,
          maskTransitionName,
          maskAnimation,
          zIndex,
          wrapClassName,
          rootClassName,
          wrapStyle,
          closable,
          maskProps,
          maskStyle,
          transitionName: transitionName2,
          animation,
          wrapProps,
          title = slots.title
        } = props;
        const {
          style,
          class: className
        } = attrs;
        return createVNode("div", _objectSpread2$1({
          "class": [`${prefixCls}-root`, rootClassName]
        }, pickAttrs(props, {
          data: true
        })), [createVNode(Mask, {
          "prefixCls": prefixCls,
          "visible": mask && visible,
          "motionName": getMotionName(prefixCls, maskTransitionName, maskAnimation),
          "style": _extends$1({
            zIndex
          }, maskStyle),
          "maskProps": maskProps
        }, null), createVNode("div", _objectSpread2$1({
          "tabIndex": -1,
          "onKeydown": onWrapperKeyDown,
          "class": classNames(`${prefixCls}-wrap`, wrapClassName),
          "ref": wrapperRef,
          "onClick": onWrapperClick,
          "role": "dialog",
          "aria-labelledby": title ? ariaIdRef.value : null,
          "style": _extends$1(_extends$1({
            zIndex
          }, wrapStyle), {
            display: !animatedVisible.value ? "none" : null
          })
        }, wrapProps), [createVNode(Content, _objectSpread2$1(_objectSpread2$1({}, omit$1(props, ["scrollLocker"])), {}, {
          "style": style,
          "class": className,
          "onMousedown": onContentMouseDown,
          "onMouseup": onContentMouseUp,
          "ref": contentRef,
          "closable": closable,
          "ariaId": ariaIdRef.value,
          "prefixCls": prefixCls,
          "visible": visible,
          "onClose": onInternalClose,
          "onVisibleChanged": onDialogVisibleChanged,
          "motionName": getMotionName(prefixCls, transitionName2, animation)
        }), slots)])]);
      };
    }
  });
  const IDialogPropTypes = dialogPropTypes();
  const DialogWrap = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "DialogWrap",
    inheritAttrs: false,
    props: initDefaultProps(IDialogPropTypes, {
      visible: false
    }),
    setup(props, _ref) {
      let {
        attrs,
        slots
      } = _ref;
      const animatedVisible = ref(props.visible);
      useProvidePortal({}, {
        inTriggerContext: false
      });
      watch(() => props.visible, () => {
        if (props.visible) {
          animatedVisible.value = true;
        }
      }, {
        flush: "post"
      });
      return () => {
        const {
          visible,
          getContainer: getContainer2,
          forceRender,
          destroyOnClose = false,
          afterClose
        } = props;
        let dialogProps = _extends$1(_extends$1(_extends$1({}, props), attrs), {
          ref: "_component",
          key: "dialog"
        });
        if (getContainer2 === false) {
          return createVNode(Dialog, _objectSpread2$1(_objectSpread2$1({}, dialogProps), {}, {
            "getOpenCount": () => 2
          }), slots);
        }
        if (!forceRender && destroyOnClose && !animatedVisible.value) {
          return null;
        }
        return createVNode(Portal, {
          "autoLock": true,
          "visible": visible,
          "forceRender": forceRender,
          "getContainer": getContainer2
        }, {
          default: (childProps) => {
            dialogProps = _extends$1(_extends$1(_extends$1({}, dialogProps), childProps), {
              afterClose: () => {
                afterClose === null || afterClose === void 0 ? void 0 : afterClose();
                animatedVisible.value = false;
              }
            });
            return createVNode(Dialog, dialogProps, slots);
          }
        });
      };
    }
  });
  const DialogWrap$1 = DialogWrap;
  function box(position2) {
    return {
      position: position2,
      top: 0,
      insetInlineEnd: 0,
      bottom: 0,
      insetInlineStart: 0
    };
  }
  const genModalMaskStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return [{
      [`${componentCls}-root`]: {
        [`${componentCls}${token2.antCls}-zoom-enter, ${componentCls}${token2.antCls}-zoom-appear`]: {
          // reset scale avoid mousePosition bug
          transform: "none",
          opacity: 0,
          animationDuration: token2.motionDurationSlow,
          // https://github.com/ant-design/ant-design/issues/11777
          userSelect: "none"
        },
        [`${componentCls}${token2.antCls}-zoom-leave ${componentCls}-content`]: {
          pointerEvents: "none"
        },
        [`${componentCls}-mask`]: _extends$1(_extends$1({}, box("fixed")), {
          zIndex: token2.zIndexPopupBase,
          height: "100%",
          backgroundColor: token2.colorBgMask,
          [`${componentCls}-hidden`]: {
            display: "none"
          }
        }),
        [`${componentCls}-wrap`]: _extends$1(_extends$1({}, box("fixed")), {
          overflow: "auto",
          outline: 0,
          WebkitOverflowScrolling: "touch"
        })
      }
    }, {
      [`${componentCls}-root`]: initFadeMotion(token2)
    }];
  };
  const genModalStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return [
      // ======================== Root =========================
      {
        [`${componentCls}-root`]: {
          [`${componentCls}-wrap`]: {
            zIndex: token2.zIndexPopupBase,
            position: "fixed",
            inset: 0,
            overflow: "auto",
            outline: 0,
            WebkitOverflowScrolling: "touch"
          },
          [`${componentCls}-wrap-rtl`]: {
            direction: "rtl"
          },
          [`${componentCls}-centered`]: {
            textAlign: "center",
            "&::before": {
              display: "inline-block",
              width: 0,
              height: "100%",
              verticalAlign: "middle",
              content: '""'
            },
            [componentCls]: {
              top: 0,
              display: "inline-block",
              paddingBottom: 0,
              textAlign: "start",
              verticalAlign: "middle"
            }
          },
          [`@media (max-width: ${token2.screenSMMax})`]: {
            [componentCls]: {
              maxWidth: "calc(100vw - 16px)",
              margin: `${token2.marginXS} auto`
            },
            [`${componentCls}-centered`]: {
              [componentCls]: {
                flex: 1
              }
            }
          }
        }
      },
      // ======================== Modal ========================
      {
        [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
          pointerEvents: "none",
          position: "relative",
          top: 100,
          width: "auto",
          maxWidth: `calc(100vw - ${token2.margin * 2}px)`,
          margin: "0 auto",
          paddingBottom: token2.paddingLG,
          [`${componentCls}-title`]: {
            margin: 0,
            color: token2.modalHeadingColor,
            fontWeight: token2.fontWeightStrong,
            fontSize: token2.modalHeaderTitleFontSize,
            lineHeight: token2.modalHeaderTitleLineHeight,
            wordWrap: "break-word"
          },
          [`${componentCls}-content`]: {
            position: "relative",
            backgroundColor: token2.modalContentBg,
            backgroundClip: "padding-box",
            border: 0,
            borderRadius: token2.borderRadiusLG,
            boxShadow: token2.boxShadowSecondary,
            pointerEvents: "auto",
            padding: `${token2.paddingMD}px ${token2.paddingContentHorizontalLG}px`
          },
          [`${componentCls}-close`]: _extends$1({
            position: "absolute",
            top: (token2.modalHeaderCloseSize - token2.modalCloseBtnSize) / 2,
            insetInlineEnd: (token2.modalHeaderCloseSize - token2.modalCloseBtnSize) / 2,
            zIndex: token2.zIndexPopupBase + 10,
            padding: 0,
            color: token2.modalCloseColor,
            fontWeight: token2.fontWeightStrong,
            lineHeight: 1,
            textDecoration: "none",
            background: "transparent",
            borderRadius: token2.borderRadiusSM,
            width: token2.modalConfirmIconSize,
            height: token2.modalConfirmIconSize,
            border: 0,
            outline: 0,
            cursor: "pointer",
            transition: `color ${token2.motionDurationMid}, background-color ${token2.motionDurationMid}`,
            "&-x": {
              display: "block",
              fontSize: token2.fontSizeLG,
              fontStyle: "normal",
              lineHeight: `${token2.modalCloseBtnSize}px`,
              textAlign: "center",
              textTransform: "none",
              textRendering: "auto"
            },
            "&:hover": {
              color: token2.modalIconHoverColor,
              backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContent,
              textDecoration: "none"
            },
            "&:active": {
              backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContentHover
            }
          }, genFocusStyle(token2)),
          [`${componentCls}-header`]: {
            color: token2.colorText,
            background: token2.modalHeaderBg,
            borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`,
            marginBottom: token2.marginXS
          },
          [`${componentCls}-body`]: {
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            wordWrap: "break-word"
          },
          [`${componentCls}-footer`]: {
            textAlign: "end",
            background: token2.modalFooterBg,
            marginTop: token2.marginSM,
            [`${token2.antCls}-btn + ${token2.antCls}-btn:not(${token2.antCls}-dropdown-trigger)`]: {
              marginBottom: 0,
              marginInlineStart: token2.marginXS
            }
          },
          [`${componentCls}-open`]: {
            overflow: "hidden"
          }
        })
      },
      // ======================== Pure =========================
      {
        [`${componentCls}-pure-panel`]: {
          top: "auto",
          padding: 0,
          display: "flex",
          flexDirection: "column",
          [`${componentCls}-content,
          ${componentCls}-body,
          ${componentCls}-confirm-body-wrapper`]: {
            display: "flex",
            flexDirection: "column",
            flex: "auto"
          },
          [`${componentCls}-confirm-body`]: {
            marginBottom: "auto"
          }
        }
      }
    ];
  };
  const genModalConfirmStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const confirmComponentCls = `${componentCls}-confirm`;
    return {
      [confirmComponentCls]: {
        "&-rtl": {
          direction: "rtl"
        },
        [`${token2.antCls}-modal-header`]: {
          display: "none"
        },
        [`${confirmComponentCls}-body-wrapper`]: _extends$1({}, clearFix()),
        [`${confirmComponentCls}-body`]: {
          display: "flex",
          flexWrap: "wrap",
          alignItems: "center",
          [`${confirmComponentCls}-title`]: {
            flex: "0 0 100%",
            display: "block",
            // create BFC to avoid
            // https://user-images.githubusercontent.com/507615/37702510-ba844e06-2d2d-11e8-9b67-8e19be57f445.png
            overflow: "hidden",
            color: token2.colorTextHeading,
            fontWeight: token2.fontWeightStrong,
            fontSize: token2.modalHeaderTitleFontSize,
            lineHeight: token2.modalHeaderTitleLineHeight,
            [`+ ${confirmComponentCls}-content`]: {
              marginBlockStart: token2.marginXS,
              flexBasis: "100%",
              maxWidth: `calc(100% - ${token2.modalConfirmIconSize + token2.marginSM}px)`
            }
          },
          [`${confirmComponentCls}-content`]: {
            color: token2.colorText,
            fontSize: token2.fontSize
          },
          [`> ${token2.iconCls}`]: {
            flex: "none",
            marginInlineEnd: token2.marginSM,
            fontSize: token2.modalConfirmIconSize,
            [`+ ${confirmComponentCls}-title`]: {
              flex: 1
            },
            // `content` after `icon` should set marginLeft
            [`+ ${confirmComponentCls}-title + ${confirmComponentCls}-content`]: {
              marginInlineStart: token2.modalConfirmIconSize + token2.marginSM
            }
          }
        },
        [`${confirmComponentCls}-btns`]: {
          textAlign: "end",
          marginTop: token2.marginSM,
          [`${token2.antCls}-btn + ${token2.antCls}-btn`]: {
            marginBottom: 0,
            marginInlineStart: token2.marginXS
          }
        }
      },
      [`${confirmComponentCls}-error ${confirmComponentCls}-body > ${token2.iconCls}`]: {
        color: token2.colorError
      },
      [`${confirmComponentCls}-warning ${confirmComponentCls}-body > ${token2.iconCls},
        ${confirmComponentCls}-confirm ${confirmComponentCls}-body > ${token2.iconCls}`]: {
        color: token2.colorWarning
      },
      [`${confirmComponentCls}-info ${confirmComponentCls}-body > ${token2.iconCls}`]: {
        color: token2.colorInfo
      },
      [`${confirmComponentCls}-success ${confirmComponentCls}-body > ${token2.iconCls}`]: {
        color: token2.colorSuccess
      },
      // https://github.com/ant-design/ant-design/issues/37329
      [`${componentCls}-zoom-leave ${componentCls}-btns`]: {
        pointerEvents: "none"
      }
    };
  };
  const genRTLStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-root`]: {
        [`${componentCls}-wrap-rtl`]: {
          direction: "rtl",
          [`${componentCls}-confirm-body`]: {
            direction: "rtl"
          }
        }
      }
    };
  };
  const genWireframeStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    const confirmComponentCls = `${componentCls}-confirm`;
    return {
      [componentCls]: {
        [`${componentCls}-content`]: {
          padding: 0
        },
        [`${componentCls}-header`]: {
          padding: token2.modalHeaderPadding,
          borderBottom: `${token2.modalHeaderBorderWidth}px ${token2.modalHeaderBorderStyle} ${token2.modalHeaderBorderColorSplit}`,
          marginBottom: 0
        },
        [`${componentCls}-body`]: {
          padding: token2.modalBodyPadding
        },
        [`${componentCls}-footer`]: {
          padding: `${token2.modalFooterPaddingVertical}px ${token2.modalFooterPaddingHorizontal}px`,
          borderTop: `${token2.modalFooterBorderWidth}px ${token2.modalFooterBorderStyle} ${token2.modalFooterBorderColorSplit}`,
          borderRadius: `0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px`,
          marginTop: 0
        }
      },
      [confirmComponentCls]: {
        [`${antCls}-modal-body`]: {
          padding: `${token2.padding * 2}px ${token2.padding * 2}px ${token2.paddingLG}px`
        },
        [`${confirmComponentCls}-body`]: {
          [`> ${token2.iconCls}`]: {
            marginInlineEnd: token2.margin,
            // `content` after `icon` should set marginLeft
            [`+ ${confirmComponentCls}-title + ${confirmComponentCls}-content`]: {
              marginInlineStart: token2.modalConfirmIconSize + token2.margin
            }
          }
        },
        [`${confirmComponentCls}-btns`]: {
          marginTop: token2.marginLG
        }
      }
    };
  };
  const useStyle = genComponentStyleHook("Modal", (token2) => {
    const headerPaddingVertical = token2.padding;
    const headerFontSize = token2.fontSizeHeading5;
    const headerLineHeight = token2.lineHeightHeading5;
    const modalToken = merge(token2, {
      modalBodyPadding: token2.paddingLG,
      modalHeaderBg: token2.colorBgElevated,
      modalHeaderPadding: `${headerPaddingVertical}px ${token2.paddingLG}px`,
      modalHeaderBorderWidth: token2.lineWidth,
      modalHeaderBorderStyle: token2.lineType,
      modalHeaderTitleLineHeight: headerLineHeight,
      modalHeaderTitleFontSize: headerFontSize,
      modalHeaderBorderColorSplit: token2.colorSplit,
      modalHeaderCloseSize: headerLineHeight * headerFontSize + headerPaddingVertical * 2,
      modalContentBg: token2.colorBgElevated,
      modalHeadingColor: token2.colorTextHeading,
      modalCloseColor: token2.colorTextDescription,
      modalFooterBg: "transparent",
      modalFooterBorderColorSplit: token2.colorSplit,
      modalFooterBorderStyle: token2.lineType,
      modalFooterPaddingVertical: token2.paddingXS,
      modalFooterPaddingHorizontal: token2.padding,
      modalFooterBorderWidth: token2.lineWidth,
      modalConfirmTitleFontSize: token2.fontSizeLG,
      modalIconHoverColor: token2.colorIconHover,
      modalConfirmIconSize: token2.fontSize * token2.lineHeight,
      modalCloseBtnSize: token2.controlHeightLG * 0.55
    });
    return [genModalStyle(modalToken), genModalConfirmStyle(modalToken), genRTLStyle(modalToken), genModalMaskStyle(modalToken), token2.wireframe && genWireframeStyle(modalToken), initZoomMotion(modalToken, "zoom")];
  });
  const Pagination = {
    // Options.jsx
    items_per_page: "条/页",
    jump_to: "跳至",
    jump_to_confirm: "确定",
    page: "页",
    // Pagination.jsx
    prev_page: "上一页",
    next_page: "下一页",
    prev_5: "向前 5 页",
    next_5: "向后 5 页",
    prev_3: "向前 3 页",
    next_3: "向后 3 页"
  };
  var __rest$3 = function(s2, e2) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  let mousePosition;
  const getClickPosition = (e2) => {
    mousePosition = {
      x: e2.pageX,
      y: e2.pageY
    };
    setTimeout(() => mousePosition = null, 100);
  };
  if (canUseDocElement()) {
    addEventListenerWrap(document.documentElement, "click", getClickPosition, true);
  }
  const modalProps = () => ({
    prefixCls: String,
    /** @deprecated Please use `open` instead. */
    visible: {
      type: Boolean,
      default: void 0
    },
    open: {
      type: Boolean,
      default: void 0
    },
    confirmLoading: {
      type: Boolean,
      default: void 0
    },
    title: PropTypes.any,
    closable: {
      type: Boolean,
      default: void 0
    },
    closeIcon: PropTypes.any,
    onOk: Function,
    onCancel: Function,
    "onUpdate:visible": Function,
    "onUpdate:open": Function,
    onChange: Function,
    afterClose: Function,
    centered: {
      type: Boolean,
      default: void 0
    },
    width: [String, Number],
    footer: PropTypes.any,
    okText: PropTypes.any,
    okType: String,
    cancelText: PropTypes.any,
    icon: PropTypes.any,
    maskClosable: {
      type: Boolean,
      default: void 0
    },
    forceRender: {
      type: Boolean,
      default: void 0
    },
    okButtonProps: objectType(),
    cancelButtonProps: objectType(),
    destroyOnClose: {
      type: Boolean,
      default: void 0
    },
    wrapClassName: String,
    maskTransitionName: String,
    transitionName: String,
    getContainer: {
      type: [String, Function, Boolean, Object],
      default: void 0
    },
    zIndex: Number,
    bodyStyle: objectType(),
    maskStyle: objectType(),
    mask: {
      type: Boolean,
      default: void 0
    },
    keyboard: {
      type: Boolean,
      default: void 0
    },
    wrapProps: Object,
    focusTriggerAfterClose: {
      type: Boolean,
      default: void 0
    },
    modalRender: Function,
    mousePosition: objectType()
  });
  const Modal = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "AModal",
    inheritAttrs: false,
    props: initDefaultProps(modalProps(), {
      width: 520,
      confirmLoading: false,
      okType: "primary"
    }),
    setup(props, _ref) {
      let {
        emit: emit2,
        slots,
        attrs
      } = _ref;
      const [locale2] = useLocaleReceiver("Modal");
      const {
        prefixCls,
        rootPrefixCls,
        direction,
        getPopupContainer
      } = useConfigInject("modal", props);
      const [wrapSSR, hashId] = useStyle(prefixCls);
      warning$3(props.visible === void 0, "Modal", `\`visible\` will be removed in next major version, please use \`open\` instead.`);
      const handleCancel = (e2) => {
        emit2("update:visible", false);
        emit2("update:open", false);
        emit2("cancel", e2);
        emit2("change", false);
      };
      const handleOk = (e2) => {
        emit2("ok", e2);
      };
      const renderFooter = () => {
        var _a2, _b;
        const {
          okText = (_a2 = slots.okText) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          okType,
          cancelText = (_b = slots.cancelText) === null || _b === void 0 ? void 0 : _b.call(slots),
          confirmLoading
        } = props;
        return createVNode(Fragment, null, [createVNode(Button, _objectSpread2$1({
          "onClick": handleCancel
        }, props.cancelButtonProps), {
          default: () => [cancelText || locale2.value.cancelText]
        }), createVNode(Button, _objectSpread2$1(_objectSpread2$1({}, convertLegacyProps(okType)), {}, {
          "loading": confirmLoading,
          "onClick": handleOk
        }, props.okButtonProps), {
          default: () => [okText || locale2.value.okText]
        })]);
      };
      return () => {
        var _a2, _b;
        const {
          prefixCls: customizePrefixCls,
          visible,
          open: open2,
          wrapClassName,
          centered,
          getContainer: getContainer2,
          closeIcon = (_a2 = slots.closeIcon) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          focusTriggerAfterClose = true
        } = props, restProps = __rest$3(props, ["prefixCls", "visible", "open", "wrapClassName", "centered", "getContainer", "closeIcon", "focusTriggerAfterClose"]);
        const wrapClassNameExtended = classNames(wrapClassName, {
          [`${prefixCls.value}-centered`]: !!centered,
          [`${prefixCls.value}-wrap-rtl`]: direction.value === "rtl"
        });
        return wrapSSR(createVNode(DialogWrap$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, restProps), attrs), {}, {
          "rootClassName": hashId.value,
          "class": classNames(hashId.value, attrs.class),
          "getContainer": getContainer2 || (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.value),
          "prefixCls": prefixCls.value,
          "wrapClassName": wrapClassNameExtended,
          "visible": open2 !== null && open2 !== void 0 ? open2 : visible,
          "onClose": handleCancel,
          "focusTriggerAfterClose": focusTriggerAfterClose,
          "transitionName": getTransitionName(rootPrefixCls.value, "zoom", props.transitionName),
          "maskTransitionName": getTransitionName(rootPrefixCls.value, "fade", props.maskTransitionName),
          "mousePosition": (_b = restProps.mousePosition) !== null && _b !== void 0 ? _b : mousePosition
        }), _extends$1(_extends$1({}, slots), {
          footer: slots.footer || renderFooter,
          closeIcon: () => {
            return createVNode("span", {
              "class": `${prefixCls.value}-close-x`
            }, [closeIcon || createVNode(CloseOutlined$1, {
              "class": `${prefixCls.value}-close-icon`
            }, null)]);
          }
        })));
      };
    }
  });
  const useDestroyed = () => {
    const destroyed = shallowRef(false);
    onBeforeUnmount(() => {
      destroyed.value = true;
    });
    return destroyed;
  };
  const actionButtonProps = {
    type: {
      type: String
    },
    actionFn: Function,
    close: Function,
    autofocus: Boolean,
    prefixCls: String,
    buttonProps: objectType(),
    emitEvent: Boolean,
    quitOnNullishReturnValue: Boolean
  };
  function isThenable(thing) {
    return !!(thing && thing.then);
  }
  const ActionButton = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ActionButton",
    props: actionButtonProps,
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const clickedRef = shallowRef(false);
      const buttonRef = shallowRef();
      const loading = shallowRef(false);
      let timeoutId;
      const isDestroyed = useDestroyed();
      onMounted(() => {
        if (props.autofocus) {
          timeoutId = setTimeout(() => {
            var _a2, _b;
            return (_b = (_a2 = findDOMNode(buttonRef.value)) === null || _a2 === void 0 ? void 0 : _a2.focus) === null || _b === void 0 ? void 0 : _b.call(_a2);
          });
        }
      });
      onBeforeUnmount(() => {
        clearTimeout(timeoutId);
      });
      const onInternalClose = function() {
        var _a2;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        (_a2 = props.close) === null || _a2 === void 0 ? void 0 : _a2.call(props, ...args);
      };
      const handlePromiseOnOk = (returnValueOfOnOk) => {
        if (!isThenable(returnValueOfOnOk)) {
          return;
        }
        loading.value = true;
        returnValueOfOnOk.then(function() {
          if (!isDestroyed.value) {
            loading.value = false;
          }
          onInternalClose(...arguments);
          clickedRef.value = false;
        }, (e2) => {
          if (!isDestroyed.value) {
            loading.value = false;
          }
          clickedRef.value = false;
          return Promise.reject(e2);
        });
      };
      const onClick = (e2) => {
        const {
          actionFn
        } = props;
        if (clickedRef.value) {
          return;
        }
        clickedRef.value = true;
        if (!actionFn) {
          onInternalClose();
          return;
        }
        let returnValueOfOnOk;
        if (props.emitEvent) {
          returnValueOfOnOk = actionFn(e2);
          if (props.quitOnNullishReturnValue && !isThenable(returnValueOfOnOk)) {
            clickedRef.value = false;
            onInternalClose(e2);
            return;
          }
        } else if (actionFn.length) {
          returnValueOfOnOk = actionFn(props.close);
          clickedRef.value = false;
        } else {
          returnValueOfOnOk = actionFn();
          if (!returnValueOfOnOk) {
            onInternalClose();
            return;
          }
        }
        handlePromiseOnOk(returnValueOfOnOk);
      };
      return () => {
        const {
          type: type4,
          prefixCls,
          buttonProps: buttonProps2
        } = props;
        return createVNode(Button, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, convertLegacyProps(type4)), {}, {
          "onClick": onClick,
          "loading": loading.value,
          "prefixCls": prefixCls
        }, buttonProps2), {}, {
          "ref": buttonRef
        }), slots);
      };
    }
  });
  function renderSomeContent(someContent) {
    if (typeof someContent === "function") {
      return someContent();
    }
    return someContent;
  }
  const ConfirmDialog = /* @__PURE__ */ defineComponent({
    name: "ConfirmDialog",
    inheritAttrs: false,
    props: ["icon", "onCancel", "onOk", "close", "closable", "zIndex", "afterClose", "visible", "open", "keyboard", "centered", "getContainer", "maskStyle", "okButtonProps", "cancelButtonProps", "okType", "prefixCls", "okCancel", "width", "mask", "maskClosable", "okText", "cancelText", "autoFocusButton", "transitionName", "maskTransitionName", "type", "title", "content", "direction", "rootPrefixCls", "bodyStyle", "closeIcon", "modalRender", "focusTriggerAfterClose", "wrapClassName", "confirmPrefixCls", "footer"],
    setup(props, _ref) {
      let {
        attrs
      } = _ref;
      const [locale2] = useLocaleReceiver("Modal");
      {
        warning$3(props.visible === void 0, "Modal", `\`visible\` is deprecated, please use \`open\` instead.`);
      }
      return () => {
        const {
          icon,
          onCancel,
          onOk,
          close,
          okText,
          closable = false,
          zIndex,
          afterClose,
          keyboard,
          centered,
          getContainer: getContainer2,
          maskStyle,
          okButtonProps,
          cancelButtonProps,
          okCancel,
          width = 416,
          mask = true,
          maskClosable = false,
          type: type4,
          open: open2,
          title,
          content,
          direction,
          closeIcon,
          modalRender,
          focusTriggerAfterClose,
          rootPrefixCls,
          bodyStyle,
          wrapClassName,
          footer
        } = props;
        let mergedIcon = icon;
        if (!icon && icon !== null) {
          switch (type4) {
            case "info":
              mergedIcon = createVNode(InfoCircleFilled$1, null, null);
              break;
            case "success":
              mergedIcon = createVNode(CheckCircleFilled$1, null, null);
              break;
            case "error":
              mergedIcon = createVNode(CloseCircleFilled$1, null, null);
              break;
            default:
              mergedIcon = createVNode(ExclamationCircleFilled$1, null, null);
          }
        }
        const okType = props.okType || "primary";
        const prefixCls = props.prefixCls || "ant-modal";
        const contentPrefixCls = `${prefixCls}-confirm`;
        const style = attrs.style || {};
        const mergedOkCancel = okCancel !== null && okCancel !== void 0 ? okCancel : type4 === "confirm";
        const autoFocusButton = props.autoFocusButton === null ? false : props.autoFocusButton || "ok";
        const confirmPrefixCls = `${prefixCls}-confirm`;
        const classString = classNames(confirmPrefixCls, `${confirmPrefixCls}-${props.type}`, {
          [`${confirmPrefixCls}-rtl`]: direction === "rtl"
        }, attrs.class);
        const mergedLocal = locale2.value;
        const cancelButton = mergedOkCancel && createVNode(ActionButton, {
          "actionFn": onCancel,
          "close": close,
          "autofocus": autoFocusButton === "cancel",
          "buttonProps": cancelButtonProps,
          "prefixCls": `${rootPrefixCls}-btn`
        }, {
          default: () => [renderSomeContent(props.cancelText) || mergedLocal.cancelText]
        });
        return createVNode(Modal, {
          "prefixCls": prefixCls,
          "class": classString,
          "wrapClassName": classNames({
            [`${confirmPrefixCls}-centered`]: !!centered
          }, wrapClassName),
          "onCancel": (e2) => close === null || close === void 0 ? void 0 : close({
            triggerCancel: true
          }, e2),
          "open": open2,
          "title": "",
          "footer": "",
          "transitionName": getTransitionName(rootPrefixCls, "zoom", props.transitionName),
          "maskTransitionName": getTransitionName(rootPrefixCls, "fade", props.maskTransitionName),
          "mask": mask,
          "maskClosable": maskClosable,
          "maskStyle": maskStyle,
          "style": style,
          "bodyStyle": bodyStyle,
          "width": width,
          "zIndex": zIndex,
          "afterClose": afterClose,
          "keyboard": keyboard,
          "centered": centered,
          "getContainer": getContainer2,
          "closable": closable,
          "closeIcon": closeIcon,
          "modalRender": modalRender,
          "focusTriggerAfterClose": focusTriggerAfterClose
        }, {
          default: () => [createVNode("div", {
            "class": `${contentPrefixCls}-body-wrapper`
          }, [createVNode("div", {
            "class": `${contentPrefixCls}-body`
          }, [renderSomeContent(mergedIcon), title === void 0 ? null : createVNode("span", {
            "class": `${contentPrefixCls}-title`
          }, [renderSomeContent(title)]), createVNode("div", {
            "class": `${contentPrefixCls}-content`
          }, [renderSomeContent(content)])]), footer !== void 0 ? renderSomeContent(footer) : createVNode("div", {
            "class": `${contentPrefixCls}-btns`
          }, [cancelButton, createVNode(ActionButton, {
            "type": okType,
            "actionFn": onOk,
            "close": close,
            "autofocus": autoFocusButton === "ok",
            "buttonProps": okButtonProps,
            "prefixCls": `${rootPrefixCls}-btn`
          }, {
            default: () => [renderSomeContent(okText) || (mergedOkCancel ? mergedLocal.okText : mergedLocal.justOkText)]
          })])])]
        });
      };
    }
  });
  const destroyFns = [];
  const confirm = (config3) => {
    const container = document.createDocumentFragment();
    let currentConfig = _extends$1(_extends$1({}, omit$1(config3, ["parentContext", "appContext"])), {
      close,
      open: true
    });
    let confirmDialogInstance = null;
    function destroy() {
      if (confirmDialogInstance) {
        render(null, container);
        confirmDialogInstance = null;
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const triggerCancel = args.some((param) => param && param.triggerCancel);
      if (config3.onCancel && triggerCancel) {
        config3.onCancel(() => {
        }, ...args.slice(1));
      }
      for (let i2 = 0; i2 < destroyFns.length; i2++) {
        const fn = destroyFns[i2];
        if (fn === close) {
          destroyFns.splice(i2, 1);
          break;
        }
      }
    }
    function close() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      currentConfig = _extends$1(_extends$1({}, currentConfig), {
        open: false,
        afterClose: () => {
          if (typeof config3.afterClose === "function") {
            config3.afterClose();
          }
          destroy.apply(this, args);
        }
      });
      if (currentConfig.visible) {
        delete currentConfig.visible;
      }
      update(currentConfig);
    }
    function update(configUpdate) {
      if (typeof configUpdate === "function") {
        currentConfig = configUpdate(currentConfig);
      } else {
        currentConfig = _extends$1(_extends$1({}, currentConfig), configUpdate);
      }
      if (confirmDialogInstance) {
        triggerVNodeUpdate(confirmDialogInstance, currentConfig, container);
      }
    }
    const Wrapper = (p) => {
      const global2 = globalConfigForApi;
      const rootPrefixCls = global2.prefixCls;
      const prefixCls = p.prefixCls || `${rootPrefixCls}-modal`;
      const iconPrefixCls = global2.iconPrefixCls;
      const runtimeLocale2 = getConfirmLocale();
      return createVNode(ConfigProvider$1, _objectSpread2$1(_objectSpread2$1({}, global2), {}, {
        "prefixCls": rootPrefixCls
      }), {
        default: () => [createVNode(ConfirmDialog, _objectSpread2$1(_objectSpread2$1({}, p), {}, {
          "rootPrefixCls": rootPrefixCls,
          "prefixCls": prefixCls,
          "iconPrefixCls": iconPrefixCls,
          "locale": runtimeLocale2,
          "cancelText": p.cancelText || runtimeLocale2.cancelText
        }), null)]
      });
    };
    function render$1(props) {
      const vm = createVNode(Wrapper, _extends$1({}, props));
      vm.appContext = config3.parentContext || config3.appContext || vm.appContext;
      render(vm, container);
      return vm;
    }
    confirmDialogInstance = render$1(currentConfig);
    destroyFns.push(close);
    return {
      destroy: close,
      update
    };
  };
  function withWarn(props) {
    return _extends$1(_extends$1({}, props), {
      type: "warning"
    });
  }
  function withInfo(props) {
    return _extends$1(_extends$1({}, props), {
      type: "info"
    });
  }
  function withSuccess(props) {
    return _extends$1(_extends$1({}, props), {
      type: "success"
    });
  }
  function withError(props) {
    return _extends$1(_extends$1({}, props), {
      type: "error"
    });
  }
  function withConfirm(props) {
    return _extends$1(_extends$1({}, props), {
      type: "confirm"
    });
  }
  const comfirmFuncProps = () => ({
    config: Object,
    afterClose: Function,
    destroyAction: Function,
    open: Boolean
  });
  const HookModal = /* @__PURE__ */ defineComponent({
    name: "HookModal",
    inheritAttrs: false,
    props: initDefaultProps(comfirmFuncProps(), {
      config: {
        width: 520,
        okType: "primary"
      }
    }),
    setup(props, _ref) {
      let {
        expose
      } = _ref;
      var _a2;
      const open2 = computed(() => props.open);
      const innerConfig = computed(() => props.config);
      const {
        direction,
        getPrefixCls
      } = useConfigContextInject();
      const prefixCls = getPrefixCls("modal");
      const rootPrefixCls = getPrefixCls();
      const afterClose = () => {
        var _a3, _b;
        props === null || props === void 0 ? void 0 : props.afterClose();
        (_b = (_a3 = innerConfig.value).afterClose) === null || _b === void 0 ? void 0 : _b.call(_a3);
      };
      const close = function() {
        props.destroyAction(...arguments);
      };
      expose({
        destroy: close
      });
      const mergedOkCancel = (_a2 = innerConfig.value.okCancel) !== null && _a2 !== void 0 ? _a2 : innerConfig.value.type === "confirm";
      const [contextLocale] = useLocaleReceiver("Modal", localeValues$1.Modal);
      return () => createVNode(ConfirmDialog, _objectSpread2$1(_objectSpread2$1({
        "prefixCls": prefixCls,
        "rootPrefixCls": rootPrefixCls
      }, innerConfig.value), {}, {
        "close": close,
        "open": open2.value,
        "afterClose": afterClose,
        "okText": innerConfig.value.okText || (mergedOkCancel ? contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.value.okText : contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.value.justOkText),
        "direction": innerConfig.value.direction || direction.value,
        "cancelText": innerConfig.value.cancelText || (contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.value.cancelText)
      }), null);
    }
  });
  let uuid = 0;
  const ElementsHolder = /* @__PURE__ */ defineComponent({
    name: "ElementsHolder",
    inheritAttrs: false,
    setup(_2, _ref) {
      let {
        expose
      } = _ref;
      const modals = shallowRef([]);
      const addModal = (modal) => {
        modals.value.push(modal);
        modals.value = modals.value.slice();
        return () => {
          modals.value = modals.value.filter((currentModal) => currentModal !== modal);
        };
      };
      expose({
        addModal
      });
      return () => {
        return modals.value.map((modal) => modal());
      };
    }
  });
  function useModal() {
    const holderRef = shallowRef(null);
    const actionQueue = shallowRef([]);
    watch(actionQueue, () => {
      if (actionQueue.value.length) {
        const cloneQueue = [...actionQueue.value];
        cloneQueue.forEach((action) => {
          action();
        });
        actionQueue.value = [];
      }
    }, {
      immediate: true
    });
    const getConfirmFunc = (withFunc) => function hookConfirm(config3) {
      var _a2;
      uuid += 1;
      const open2 = shallowRef(true);
      const modalRef = shallowRef(null);
      const configRef = shallowRef(unref(config3));
      const updateConfig = shallowRef({});
      watch(() => config3, (val) => {
        updateAction(_extends$1(_extends$1({}, isRef(val) ? val.value : val), updateConfig.value));
      });
      const destroyAction = function() {
        open2.value = false;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        const triggerCancel = args.some((param) => param && param.triggerCancel);
        if (configRef.value.onCancel && triggerCancel) {
          configRef.value.onCancel(() => {
          }, ...args.slice(1));
        }
      };
      let closeFunc;
      const modal = () => createVNode(HookModal, {
        "key": `modal-${uuid}`,
        "config": withFunc(configRef.value),
        "ref": modalRef,
        "open": open2.value,
        "destroyAction": destroyAction,
        "afterClose": () => {
          closeFunc === null || closeFunc === void 0 ? void 0 : closeFunc();
        }
      }, null);
      closeFunc = (_a2 = holderRef.value) === null || _a2 === void 0 ? void 0 : _a2.addModal(modal);
      if (closeFunc) {
        destroyFns.push(closeFunc);
      }
      const updateAction = (newConfig) => {
        configRef.value = _extends$1(_extends$1({}, configRef.value), newConfig);
      };
      const destroy = () => {
        if (modalRef.value) {
          destroyAction();
        } else {
          actionQueue.value = [...actionQueue.value, destroyAction];
        }
      };
      const update = (newConfig) => {
        updateConfig.value = newConfig;
        if (modalRef.value) {
          updateAction(newConfig);
        } else {
          actionQueue.value = [...actionQueue.value, () => updateAction(newConfig)];
        }
      };
      return {
        destroy,
        update
      };
    };
    const fns = computed(() => ({
      info: getConfirmFunc(withInfo),
      success: getConfirmFunc(withSuccess),
      error: getConfirmFunc(withError),
      warning: getConfirmFunc(withWarn),
      confirm: getConfirmFunc(withConfirm)
    }));
    const holderKey = Symbol("modalHolderKey");
    return [fns.value, () => createVNode(ElementsHolder, {
      "key": holderKey,
      "ref": holderRef
    }, null)];
  }
  function modalWarn(props) {
    return confirm(withWarn(props));
  }
  Modal.useModal = useModal;
  Modal.info = function infoFn(props) {
    return confirm(withInfo(props));
  };
  Modal.success = function successFn(props) {
    return confirm(withSuccess(props));
  };
  Modal.error = function errorFn(props) {
    return confirm(withError(props));
  };
  Modal.warning = modalWarn;
  Modal.warn = modalWarn;
  Modal.confirm = function confirmFn(props) {
    return confirm(withConfirm(props));
  };
  Modal.destroyAll = function destroyAllFn() {
    while (destroyFns.length) {
      const close = destroyFns.pop();
      if (close) {
        close();
      }
    }
  };
  Modal.install = function(app2) {
    app2.component(Modal.name, Modal);
    return app2;
  };
  const spaceSize = {
    small: 8,
    middle: 16,
    large: 24
  };
  const spaceProps = () => ({
    prefixCls: String,
    size: {
      type: [String, Number, Array]
    },
    direction: PropTypes.oneOf(tuple("horizontal", "vertical")).def("horizontal"),
    align: PropTypes.oneOf(tuple("start", "end", "center", "baseline")),
    wrap: booleanType()
  });
  function getNumberSize(size2) {
    return typeof size2 === "string" ? spaceSize[size2] : size2 || 0;
  }
  const Space = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "ASpace",
    inheritAttrs: false,
    props: spaceProps(),
    slots: Object,
    setup(props, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const {
        prefixCls,
        space,
        direction: directionConfig
      } = useConfigInject("space", props);
      const [wrapSSR, hashId] = useStyle$c(prefixCls);
      const supportFlexGap = useFlexGapSupport();
      const size2 = computed(() => {
        var _a2, _b, _c;
        return (_c = (_a2 = props.size) !== null && _a2 !== void 0 ? _a2 : (_b = space === null || space === void 0 ? void 0 : space.value) === null || _b === void 0 ? void 0 : _b.size) !== null && _c !== void 0 ? _c : "small";
      });
      const horizontalSize = ref();
      const verticalSize = ref();
      watch(size2, () => {
        [horizontalSize.value, verticalSize.value] = (Array.isArray(size2.value) ? size2.value : [size2.value, size2.value]).map((item) => getNumberSize(item));
      }, {
        immediate: true
      });
      const mergedAlign = computed(() => props.align === void 0 && props.direction === "horizontal" ? "center" : props.align);
      const cn = computed(() => {
        return classNames(prefixCls.value, hashId.value, `${prefixCls.value}-${props.direction}`, {
          [`${prefixCls.value}-rtl`]: directionConfig.value === "rtl",
          [`${prefixCls.value}-align-${mergedAlign.value}`]: mergedAlign.value
        });
      });
      const marginDirection = computed(() => directionConfig.value === "rtl" ? "marginLeft" : "marginRight");
      const style = computed(() => {
        const gapStyle = {};
        if (supportFlexGap.value) {
          gapStyle.columnGap = `${horizontalSize.value}px`;
          gapStyle.rowGap = `${verticalSize.value}px`;
        }
        return _extends$1(_extends$1({}, gapStyle), props.wrap && {
          flexWrap: "wrap",
          marginBottom: `${-verticalSize.value}px`
        });
      });
      return () => {
        var _a2, _b;
        const {
          wrap: wrap3,
          direction = "horizontal"
        } = props;
        const children = (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
        const items = filterEmpty(children);
        const len = items.length;
        if (len === 0) {
          return null;
        }
        const split = (_b = slots.split) === null || _b === void 0 ? void 0 : _b.call(slots);
        const itemClassName = `${prefixCls.value}-item`;
        const horizontalSizeVal = horizontalSize.value;
        const latestIndex = len - 1;
        return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "class": [cn.value, attrs.class],
          "style": [style.value, attrs.style]
        }), [items.map((child, index2) => {
          let originIndex = children.indexOf(child);
          if (originIndex === -1) {
            originIndex = `$$space-${index2}`;
          }
          let itemStyle = {};
          if (!supportFlexGap.value) {
            if (direction === "vertical") {
              if (index2 < latestIndex) {
                itemStyle = {
                  marginBottom: `${horizontalSizeVal / (split ? 2 : 1)}px`
                };
              }
            } else {
              itemStyle = _extends$1(_extends$1({}, index2 < latestIndex && {
                [marginDirection.value]: `${horizontalSizeVal / (split ? 2 : 1)}px`
              }), wrap3 && {
                paddingBottom: `${verticalSize.value}px`
              });
            }
          }
          return wrapSSR(createVNode(Fragment, {
            "key": originIndex
          }, [createVNode("div", {
            "class": itemClassName,
            "style": itemStyle
          }, [child]), index2 < latestIndex && split && createVNode("span", {
            "class": `${itemClassName}-split`,
            "style": itemStyle
          }, [split])]));
        })]);
      };
    }
  });
  Space.Compact = Compact;
  Space.install = function(app2) {
    app2.component(Space.name, Space);
    app2.component(Compact.name, Compact);
    return app2;
  };
  const Space$1 = Space;
  const genBaseStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      zIndexPopup,
      colorText,
      colorWarning,
      marginXS,
      fontSize,
      fontWeightStrong,
      lineHeight
    } = token2;
    return {
      [componentCls]: {
        zIndex: zIndexPopup,
        [`${componentCls}-inner-content`]: {
          color: colorText
        },
        [`${componentCls}-message`]: {
          position: "relative",
          marginBottom: marginXS,
          color: colorText,
          fontSize,
          display: "flex",
          flexWrap: "nowrap",
          alignItems: "start",
          [`> ${componentCls}-message-icon ${iconCls}`]: {
            color: colorWarning,
            fontSize,
            flex: "none",
            lineHeight: 1,
            paddingTop: (Math.round(fontSize * lineHeight) - fontSize) / 2
          },
          "&-title": {
            flex: "auto",
            marginInlineStart: marginXS
          },
          "&-title-only": {
            fontWeight: fontWeightStrong
          }
        },
        [`${componentCls}-description`]: {
          position: "relative",
          marginInlineStart: fontSize + marginXS,
          marginBottom: marginXS,
          color: colorText,
          fontSize
        },
        [`${componentCls}-buttons`]: {
          textAlign: "end",
          button: {
            marginInlineStart: marginXS
          }
        }
      }
    };
  };
  const usePopconfirmStyle = genComponentStyleHook("Popconfirm", (token2) => genBaseStyle(token2), (token2) => {
    const {
      zIndexPopupBase
    } = token2;
    return {
      zIndexPopup: zIndexPopupBase + 60
    };
  });
  var __rest$2 = function(s2, e2) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  const popconfirmProps = () => _extends$1(_extends$1({}, abstractTooltipProps()), {
    prefixCls: String,
    content: anyType(),
    title: anyType(),
    description: anyType(),
    okType: stringType("primary"),
    disabled: {
      type: Boolean,
      default: false
    },
    okText: anyType(),
    cancelText: anyType(),
    icon: anyType(),
    okButtonProps: objectType(),
    cancelButtonProps: objectType(),
    showCancel: {
      type: Boolean,
      default: true
    },
    onConfirm: Function,
    onCancel: Function
  });
  const Popconfirm = /* @__PURE__ */ defineComponent({
    compatConfig: {
      MODE: 3
    },
    name: "APopconfirm",
    inheritAttrs: false,
    props: initDefaultProps(popconfirmProps(), _extends$1(_extends$1({}, tooltipDefaultProps()), {
      trigger: "click",
      placement: "top",
      mouseEnterDelay: 0.1,
      mouseLeaveDelay: 0.1,
      arrowPointAtCenter: false,
      autoAdjustOverflow: true,
      okType: "primary",
      disabled: false
    })),
    slots: Object,
    // emits: ['update:open', 'visibleChange'],
    setup(props, _ref) {
      let {
        slots,
        emit: emit2,
        expose,
        attrs
      } = _ref;
      const rootRef = ref();
      warning$3(props.visible === void 0, "Popconfirm", `\`visible\` will be removed in next major version, please use \`open\` instead.`);
      expose({
        getPopupDomNode: () => {
          var _a2, _b;
          return (_b = (_a2 = rootRef.value) === null || _a2 === void 0 ? void 0 : _a2.getPopupDomNode) === null || _b === void 0 ? void 0 : _b.call(_a2);
        }
      });
      const [open2, setOpen] = useMergedState(false, {
        value: toRef(props, "open")
      });
      const settingOpen = (value, e2) => {
        if (props.open === void 0) {
          setOpen(value);
        }
        emit2("update:open", value);
        emit2("openChange", value, e2);
      };
      const close = (e2) => {
        settingOpen(false, e2);
      };
      const onConfirm = (e2) => {
        var _a2;
        return (_a2 = props.onConfirm) === null || _a2 === void 0 ? void 0 : _a2.call(props, e2);
      };
      const onCancel = (e2) => {
        var _a2;
        settingOpen(false, e2);
        (_a2 = props.onCancel) === null || _a2 === void 0 ? void 0 : _a2.call(props, e2);
      };
      const onKeyDown = (e2) => {
        if (e2.keyCode === KeyCode$1.ESC && open2) {
          settingOpen(false, e2);
        }
      };
      const onOpenChange = (value) => {
        const {
          disabled
        } = props;
        if (disabled) {
          return;
        }
        settingOpen(value);
      };
      const {
        prefixCls: prefixClsConfirm,
        getPrefixCls
      } = useConfigInject("popconfirm", props);
      const rootPrefixCls = computed(() => getPrefixCls());
      const btnPrefixCls = computed(() => getPrefixCls("btn"));
      const [wrapSSR] = usePopconfirmStyle(prefixClsConfirm);
      const [popconfirmLocale] = useLocaleReceiver("Popconfirm", localeValues$1.Popconfirm);
      const renderOverlay = () => {
        var _a2, _b, _c, _d, _e;
        const {
          okButtonProps,
          cancelButtonProps,
          title = (_a2 = slots.title) === null || _a2 === void 0 ? void 0 : _a2.call(slots),
          description = (_b = slots.description) === null || _b === void 0 ? void 0 : _b.call(slots),
          cancelText = (_c = slots.cancel) === null || _c === void 0 ? void 0 : _c.call(slots),
          okText = (_d = slots.okText) === null || _d === void 0 ? void 0 : _d.call(slots),
          okType,
          icon = ((_e = slots.icon) === null || _e === void 0 ? void 0 : _e.call(slots)) || createVNode(ExclamationCircleFilled$1, null, null),
          showCancel = true
        } = props;
        const {
          cancelButton,
          okButton
        } = slots;
        const cancelProps = _extends$1({
          onClick: onCancel,
          size: "small"
        }, cancelButtonProps);
        const okProps = _extends$1(_extends$1(_extends$1({
          onClick: onConfirm
        }, convertLegacyProps(okType)), {
          size: "small"
        }), okButtonProps);
        return createVNode("div", {
          "class": `${prefixClsConfirm.value}-inner-content`
        }, [createVNode("div", {
          "class": `${prefixClsConfirm.value}-message`
        }, [icon && createVNode("span", {
          "class": `${prefixClsConfirm.value}-message-icon`
        }, [icon]), createVNode("div", {
          "class": [`${prefixClsConfirm.value}-message-title`, {
            [`${prefixClsConfirm.value}-message-title-only`]: !!description
          }]
        }, [title])]), description && createVNode("div", {
          "class": `${prefixClsConfirm.value}-description`
        }, [description]), createVNode("div", {
          "class": `${prefixClsConfirm.value}-buttons`
        }, [showCancel ? cancelButton ? cancelButton(cancelProps) : createVNode(Button, cancelProps, {
          default: () => [cancelText || popconfirmLocale.value.cancelText]
        }) : null, okButton ? okButton(okProps) : createVNode(ActionButton, {
          "buttonProps": _extends$1(_extends$1({
            size: "small"
          }, convertLegacyProps(okType)), okButtonProps),
          "actionFn": onConfirm,
          "close": close,
          "prefixCls": btnPrefixCls.value,
          "quitOnNullishReturnValue": true,
          "emitEvent": true
        }, {
          default: () => [okText || popconfirmLocale.value.okText]
        })])]);
      };
      return () => {
        var _a2;
        const {
          placement,
          overlayClassName,
          trigger: trigger2 = "click"
        } = props, restProps = __rest$2(props, ["placement", "overlayClassName", "trigger"]);
        const otherProps = omit$1(restProps, ["title", "content", "cancelText", "okText", "onUpdate:open", "onConfirm", "onCancel", "prefixCls"]);
        const overlayClassNames = classNames(prefixClsConfirm.value, overlayClassName);
        return wrapSSR(createVNode(Popover$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, otherProps), attrs), {}, {
          "trigger": trigger2,
          "placement": placement,
          "onOpenChange": onOpenChange,
          "open": open2.value,
          "overlayClassName": overlayClassNames,
          "transitionName": getTransitionName(rootPrefixCls.value, "zoom-big", props.transitionName),
          "ref": rootRef,
          "data-popover-inject": true
        }), {
          default: () => [cloneVNodes(((_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)) || [], {
            onKeydown: (e2) => {
              onKeyDown(e2);
            }
          }, false)],
          content: renderOverlay
        }));
      };
    }
  });
  const Popconfirm$1 = withInstall(Popconfirm);
  function toLowercaseSeparator(key2) {
    return key2.replace(/([A-Z])/g, "-$1").toLowerCase();
  }
  function getStyleStr(style) {
    return Object.keys(style).map((key2) => `${toLowercaseSeparator(key2)}: ${style[key2]};`).join(" ");
  }
  function getPixelRatio() {
    return window.devicePixelRatio || 1;
  }
  function rotateWatermark(ctx, rotateX, rotateY, rotate) {
    ctx.translate(rotateX, rotateY);
    ctx.rotate(Math.PI / 180 * Number(rotate));
    ctx.translate(-rotateX, -rotateY);
  }
  const reRendering = (mutation, watermarkElement) => {
    let flag = false;
    if (mutation.removedNodes.length) {
      flag = Array.from(mutation.removedNodes).some((node2) => node2 === watermarkElement);
    }
    if (mutation.type === "attributes" && mutation.target === watermarkElement) {
      flag = true;
    }
    return flag;
  };
  var __rest$1 = function(s2, e2) {
    var t2 = {};
    for (var p in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
        t2[p] = s2[p];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
        if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
          t2[p[i2]] = s2[p[i2]];
      }
    return t2;
  };
  function useMutationObserver(target, callback) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const {
      window: window2 = defaultWindow
    } = options, mutationOptions = __rest$1(options, ["window"]);
    let observer;
    const isSupported2 = useSupported(() => window2 && "MutationObserver" in window2);
    const cleanup2 = () => {
      if (observer) {
        observer.disconnect();
        observer = void 0;
      }
    };
    const stopWatch = watch(() => unrefElement(target), (el) => {
      cleanup2();
      if (isSupported2.value && window2 && el) {
        observer = new MutationObserver(callback);
        observer.observe(el, mutationOptions);
      }
    }, {
      immediate: true
    });
    const stop = () => {
      cleanup2();
      stopWatch();
    };
    tryOnScopeDispose(stop);
    return {
      isSupported: isSupported2,
      stop
    };
  }
  const BaseSize = 2;
  const FontGap = 3;
  const watermarkProps = () => ({
    zIndex: Number,
    rotate: Number,
    width: Number,
    height: Number,
    image: String,
    content: someType([String, Array]),
    font: objectType(),
    rootClassName: String,
    gap: arrayType(),
    offset: arrayType()
  });
  const Watermark = /* @__PURE__ */ defineComponent({
    name: "AWatermark",
    inheritAttrs: false,
    props: initDefaultProps(watermarkProps(), {
      zIndex: 9,
      rotate: -22,
      font: {},
      gap: [100, 100]
    }),
    setup(props, _ref) {
      let {
        slots,
        attrs
      } = _ref;
      const [, token2] = useToken();
      const containerRef = shallowRef();
      const watermarkRef = shallowRef();
      const stopObservation = shallowRef(false);
      const gapX = computed(() => {
        var _a2, _b;
        return (_b = (_a2 = props.gap) === null || _a2 === void 0 ? void 0 : _a2[0]) !== null && _b !== void 0 ? _b : 100;
      });
      const gapY = computed(() => {
        var _a2, _b;
        return (_b = (_a2 = props.gap) === null || _a2 === void 0 ? void 0 : _a2[1]) !== null && _b !== void 0 ? _b : 100;
      });
      const gapXCenter = computed(() => gapX.value / 2);
      const gapYCenter = computed(() => gapY.value / 2);
      const offsetLeft = computed(() => {
        var _a2, _b;
        return (_b = (_a2 = props.offset) === null || _a2 === void 0 ? void 0 : _a2[0]) !== null && _b !== void 0 ? _b : gapXCenter.value;
      });
      const offsetTop = computed(() => {
        var _a2, _b;
        return (_b = (_a2 = props.offset) === null || _a2 === void 0 ? void 0 : _a2[1]) !== null && _b !== void 0 ? _b : gapYCenter.value;
      });
      const fontSize = computed(() => {
        var _a2, _b;
        return (_b = (_a2 = props.font) === null || _a2 === void 0 ? void 0 : _a2.fontSize) !== null && _b !== void 0 ? _b : token2.value.fontSizeLG;
      });
      const fontWeight = computed(() => {
        var _a2, _b;
        return (_b = (_a2 = props.font) === null || _a2 === void 0 ? void 0 : _a2.fontWeight) !== null && _b !== void 0 ? _b : "normal";
      });
      const fontStyle = computed(() => {
        var _a2, _b;
        return (_b = (_a2 = props.font) === null || _a2 === void 0 ? void 0 : _a2.fontStyle) !== null && _b !== void 0 ? _b : "normal";
      });
      const fontFamily = computed(() => {
        var _a2, _b;
        return (_b = (_a2 = props.font) === null || _a2 === void 0 ? void 0 : _a2.fontFamily) !== null && _b !== void 0 ? _b : "sans-serif";
      });
      const color = computed(() => {
        var _a2, _b;
        return (_b = (_a2 = props.font) === null || _a2 === void 0 ? void 0 : _a2.color) !== null && _b !== void 0 ? _b : token2.value.colorFill;
      });
      const markStyle = computed(() => {
        var _a2;
        const markStyle2 = {
          zIndex: (_a2 = props.zIndex) !== null && _a2 !== void 0 ? _a2 : 9,
          position: "absolute",
          left: 0,
          top: 0,
          width: "100%",
          height: "100%",
          pointerEvents: "none",
          backgroundRepeat: "repeat"
        };
        let positionLeft = offsetLeft.value - gapXCenter.value;
        let positionTop = offsetTop.value - gapYCenter.value;
        if (positionLeft > 0) {
          markStyle2.left = `${positionLeft}px`;
          markStyle2.width = `calc(100% - ${positionLeft}px)`;
          positionLeft = 0;
        }
        if (positionTop > 0) {
          markStyle2.top = `${positionTop}px`;
          markStyle2.height = `calc(100% - ${positionTop}px)`;
          positionTop = 0;
        }
        markStyle2.backgroundPosition = `${positionLeft}px ${positionTop}px`;
        return markStyle2;
      });
      const destroyWatermark = () => {
        if (watermarkRef.value) {
          watermarkRef.value.remove();
          watermarkRef.value = void 0;
        }
      };
      const appendWatermark = (base64Url, markWidth) => {
        var _a2;
        if (containerRef.value && watermarkRef.value) {
          stopObservation.value = true;
          watermarkRef.value.setAttribute("style", getStyleStr(_extends$1(_extends$1({}, markStyle.value), {
            backgroundImage: `url('${base64Url}')`,
            backgroundSize: `${(gapX.value + markWidth) * BaseSize}px`
          })));
          (_a2 = containerRef.value) === null || _a2 === void 0 ? void 0 : _a2.append(watermarkRef.value);
          setTimeout(() => {
            stopObservation.value = false;
          });
        }
      };
      const getMarkSize = (ctx) => {
        let defaultWidth = 120;
        let defaultHeight = 64;
        const content = props.content;
        const image = props.image;
        const width = props.width;
        const height = props.height;
        if (!image && ctx.measureText) {
          ctx.font = `${Number(fontSize.value)}px ${fontFamily.value}`;
          const contents = Array.isArray(content) ? content : [content];
          const widths = contents.map((item) => ctx.measureText(item).width);
          defaultWidth = Math.ceil(Math.max(...widths));
          defaultHeight = Number(fontSize.value) * contents.length + (contents.length - 1) * FontGap;
        }
        return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];
      };
      const fillTexts = (ctx, drawX, drawY, drawWidth, drawHeight) => {
        const ratio = getPixelRatio();
        const content = props.content;
        const mergedFontSize = Number(fontSize.value) * ratio;
        ctx.font = `${fontStyle.value} normal ${fontWeight.value} ${mergedFontSize}px/${drawHeight}px ${fontFamily.value}`;
        ctx.fillStyle = color.value;
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.translate(drawWidth / 2, 0);
        const contents = Array.isArray(content) ? content : [content];
        contents === null || contents === void 0 ? void 0 : contents.forEach((item, index2) => {
          ctx.fillText(item !== null && item !== void 0 ? item : "", drawX, drawY + index2 * (mergedFontSize + FontGap * ratio));
        });
      };
      const renderWatermark = () => {
        var _a2;
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const image = props.image;
        const rotate = (_a2 = props.rotate) !== null && _a2 !== void 0 ? _a2 : -22;
        if (ctx) {
          if (!watermarkRef.value) {
            watermarkRef.value = document.createElement("div");
          }
          const ratio = getPixelRatio();
          const [markWidth, markHeight] = getMarkSize(ctx);
          const canvasWidth = (gapX.value + markWidth) * ratio;
          const canvasHeight = (gapY.value + markHeight) * ratio;
          canvas.setAttribute("width", `${canvasWidth * BaseSize}px`);
          canvas.setAttribute("height", `${canvasHeight * BaseSize}px`);
          const drawX = gapX.value * ratio / 2;
          const drawY = gapY.value * ratio / 2;
          const drawWidth = markWidth * ratio;
          const drawHeight = markHeight * ratio;
          const rotateX = (drawWidth + gapX.value * ratio) / 2;
          const rotateY = (drawHeight + gapY.value * ratio) / 2;
          const alternateDrawX = drawX + canvasWidth;
          const alternateDrawY = drawY + canvasHeight;
          const alternateRotateX = rotateX + canvasWidth;
          const alternateRotateY = rotateY + canvasHeight;
          ctx.save();
          rotateWatermark(ctx, rotateX, rotateY, rotate);
          if (image) {
            const img = new Image();
            img.onload = () => {
              ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
              ctx.restore();
              rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);
              ctx.drawImage(img, alternateDrawX, alternateDrawY, drawWidth, drawHeight);
              appendWatermark(canvas.toDataURL(), markWidth);
            };
            img.crossOrigin = "anonymous";
            img.referrerPolicy = "no-referrer";
            img.src = image;
          } else {
            fillTexts(ctx, drawX, drawY, drawWidth, drawHeight);
            ctx.restore();
            rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);
            fillTexts(ctx, alternateDrawX, alternateDrawY, drawWidth, drawHeight);
            appendWatermark(canvas.toDataURL(), markWidth);
          }
        }
      };
      onMounted(() => {
        renderWatermark();
      });
      watch(() => [props, token2.value.colorFill, token2.value.fontSizeLG], () => {
        renderWatermark();
      }, {
        deep: true,
        flush: "post"
      });
      onBeforeUnmount(() => {
        destroyWatermark();
      });
      const onMutate = (mutations) => {
        if (stopObservation.value) {
          return;
        }
        mutations.forEach((mutation) => {
          if (reRendering(mutation, watermarkRef.value)) {
            destroyWatermark();
            renderWatermark();
          }
        });
      };
      useMutationObserver(containerRef, onMutate, {
        attributes: true,
        subtree: true,
        childList: true,
        attributeFilter: ["style", "class"]
      });
      return () => {
        var _a2;
        return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
          "ref": containerRef,
          "class": [attrs.class, props.rootClassName],
          "style": [{
            position: "relative"
          }, attrs.style]
        }), [(_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots)]);
      };
    }
  });
  const Watermark$1 = withInstall(Watermark);
  const name = "hzdx-cs-ai";
  const localStorage$1 = window.localStorage;
  class StorageAction {
    constructor(key2 = "") {
      this.key = key2;
    }
    set(v2) {
      localStorage$1.setItem(this.key, v2);
    }
    get() {
      return localStorage$1.getItem(this.key) || "";
    }
    get value() {
      return this.get();
    }
    remove() {
      localStorage$1.removeItem(this.key);
    }
  }
  class AccessToken extends StorageAction {
    constructor(key2) {
      super(key2);
    }
    set(v2) {
      super.set(v2);
    }
    get() {
      return super.get() || "";
    }
    get value() {
      return this.get();
    }
    remove() {
      localStorage$1.removeItem(this.key);
    }
  }
  class RefreshToken extends StorageAction {
    constructor(key2) {
      super(key2);
    }
  }
  const addPreStr = (key2) => [name, key2].join("_");
  const accessToken = new AccessToken(addPreStr("access-token"));
  const refreshToken = new RefreshToken(addPreStr("refresh-token"));
  const clearStorageHelper = () => {
    for (const key2 in storageHelper) {
      storageHelper[key2].remove();
    }
  };
  const storageHelper = {
    accessToken,
    refreshToken
  };
  const refreshTokenFunc = () => {
    let requestList = [];
    let isRefreshToken = false;
    return async (callback) => {
      const refreshToken2 = storageHelper.refreshToken.value;
      if (!refreshToken2) {
        return {
          fail: true
        };
      }
      if (!isRefreshToken) {
        isRefreshToken = true;
        try {
          const res = await refreshTokenApi({ refreshToken: refreshToken2 });
          storageHelper.accessToken.set(res.data.accessToken);
          storageHelper.refreshToken.set(res.data.refreshToken);
          requestList.forEach((cb) => {
            cb();
          });
          requestList = [];
          return callback();
        } catch (e2) {
          console.error("refreshToken error", e2);
          return {
            fail: true
          };
        } finally {
          requestList = [];
          isRefreshToken = false;
        }
      } else {
        return new Promise((resolve2) => {
          requestList.push(() => {
            resolve2(callback());
          });
        });
      }
    };
  };
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  /*!
   * GSAP 3.12.5
   * https://gsap.com
   *
   * @license Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  var _config = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
      lineHeight: ""
    }
  }, _defaults = {
    duration: 0.5,
    overwrite: false,
    delay: 0
  }, _suppressOverwrites, _reverting$1, _context, _bigNum$1 = 1e8, _tinyNum = 1 / _bigNum$1, _2PI = Math.PI * 2, _HALF_PI = _2PI / 4, _gsID = 0, _sqrt = Math.sqrt, _cos = Math.cos, _sin = Math.sin, _isString = function _isString2(value) {
    return typeof value === "string";
  }, _isFunction = function _isFunction2(value) {
    return typeof value === "function";
  }, _isNumber = function _isNumber2(value) {
    return typeof value === "number";
  }, _isUndefined = function _isUndefined2(value) {
    return typeof value === "undefined";
  }, _isObject = function _isObject2(value) {
    return typeof value === "object";
  }, _isNotFalse = function _isNotFalse2(value) {
    return value !== false;
  }, _windowExists$1 = function _windowExists() {
    return typeof window !== "undefined";
  }, _isFuncOrString = function _isFuncOrString2(value) {
    return _isFunction(value) || _isString(value);
  }, _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {
  }, _isArray = Array.isArray, _strictNumExp = /(?:-?\.?\d|\.)+/gi, _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, _relExp = /[+-]=-?[.\d]+/, _delimitedValueExp = /[^,'"\[\]\s]+/gi, _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, _globalTimeline, _win$1, _coreInitted, _doc$1, _globals = {}, _installScope = {}, _coreReady, _install = function _install2(scope) {
    return (_installScope = _merge(scope, _globals)) && gsap;
  }, _missingPlugin = function _missingPlugin2(property2, value) {
    return console.warn("Invalid property", property2, "set to", value, "Missing plugin? gsap.registerPlugin()");
  }, _warn = function _warn2(message, suppress) {
    return !suppress && console.warn(message);
  }, _addGlobal = function _addGlobal2(name2, obj) {
    return name2 && (_globals[name2] = obj) && _installScope && (_installScope[name2] = obj) || _globals;
  }, _emptyFunc = function _emptyFunc2() {
    return 0;
  }, _startAtRevertConfig = {
    suppressEvents: true,
    isStart: true,
    kill: false
  }, _revertConfigNoKill = {
    suppressEvents: true,
    kill: false
  }, _revertConfig = {
    suppressEvents: true
  }, _reservedProps = {}, _lazyTweens = [], _lazyLookup = {}, _lastRenderedFrame, _plugins = {}, _effects = {}, _nextGCFrame = 30, _harnessPlugins = [], _callbackNames = "", _harness = function _harness2(targets) {
    var target = targets[0], harnessPlugin, i2;
    _isObject(target) || _isFunction(target) || (targets = [targets]);
    if (!(harnessPlugin = (target._gsap || {}).harness)) {
      i2 = _harnessPlugins.length;
      while (i2-- && !_harnessPlugins[i2].targetTest(target)) {
      }
      harnessPlugin = _harnessPlugins[i2];
    }
    i2 = targets.length;
    while (i2--) {
      targets[i2] && (targets[i2]._gsap || (targets[i2]._gsap = new GSCache(targets[i2], harnessPlugin))) || targets.splice(i2, 1);
    }
    return targets;
  }, _getCache = function _getCache2(target) {
    return target._gsap || _harness(toArray(target))[0]._gsap;
  }, _getProperty = function _getProperty2(target, property2, v2) {
    return (v2 = target[property2]) && _isFunction(v2) ? target[property2]() : _isUndefined(v2) && target.getAttribute && target.getAttribute(property2) || v2;
  }, _forEachName = function _forEachName2(names2, func) {
    return (names2 = names2.split(",")).forEach(func) || names2;
  }, _round = function _round2(value) {
    return Math.round(value * 1e5) / 1e5 || 0;
  }, _roundPrecise = function _roundPrecise2(value) {
    return Math.round(value * 1e7) / 1e7 || 0;
  }, _parseRelative = function _parseRelative2(start, value) {
    var operator = value.charAt(0), end = parseFloat(value.substr(2));
    start = parseFloat(start);
    return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
  }, _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {
    var l2 = toFind.length, i2 = 0;
    for (; toSearch.indexOf(toFind[i2]) < 0 && ++i2 < l2; ) {
    }
    return i2 < l2;
  }, _lazyRender = function _lazyRender2() {
    var l2 = _lazyTweens.length, a2 = _lazyTweens.slice(0), i2, tween;
    _lazyLookup = {};
    _lazyTweens.length = 0;
    for (i2 = 0; i2 < l2; i2++) {
      tween = a2[i2];
      tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
    }
  }, _lazySafeRender = function _lazySafeRender2(animation, time, suppressEvents, force) {
    _lazyTweens.length && !_reverting$1 && _lazyRender();
    animation.render(time, suppressEvents, force || _reverting$1 && time < 0 && (animation._initted || animation._startAt));
    _lazyTweens.length && !_reverting$1 && _lazyRender();
  }, _numericIfPossible = function _numericIfPossible2(value) {
    var n2 = parseFloat(value);
    return (n2 || n2 === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n2 : _isString(value) ? value.trim() : value;
  }, _passThrough = function _passThrough2(p) {
    return p;
  }, _setDefaults = function _setDefaults2(obj, defaults2) {
    for (var p in defaults2) {
      p in obj || (obj[p] = defaults2[p]);
    }
    return obj;
  }, _setKeyframeDefaults = function _setKeyframeDefaults2(excludeDuration) {
    return function(obj, defaults2) {
      for (var p in defaults2) {
        p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults2[p]);
      }
    };
  }, _merge = function _merge2(base, toMerge) {
    for (var p in toMerge) {
      base[p] = toMerge[p];
    }
    return base;
  }, _mergeDeep = function _mergeDeep2(base, toMerge) {
    for (var p in toMerge) {
      p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep2(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
    }
    return base;
  }, _copyExcluding = function _copyExcluding2(obj, excluding) {
    var copy = {}, p;
    for (p in obj) {
      p in excluding || (copy[p] = obj[p]);
    }
    return copy;
  }, _inheritDefaults = function _inheritDefaults2(vars) {
    var parent2 = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
    if (_isNotFalse(vars.inherit)) {
      while (parent2) {
        func(vars, parent2.vars.defaults);
        parent2 = parent2.parent || parent2._dp;
      }
    }
    return vars;
  }, _arraysMatch = function _arraysMatch2(a1, a2) {
    var i2 = a1.length, match2 = i2 === a2.length;
    while (match2 && i2-- && a1[i2] === a2[i2]) {
    }
    return i2 < 0;
  }, _addLinkedListItem = function _addLinkedListItem2(parent2, child, firstProp, lastProp, sortBy) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev2 = parent2[lastProp], t2;
    if (sortBy) {
      t2 = child[sortBy];
      while (prev2 && prev2[sortBy] > t2) {
        prev2 = prev2._prev;
      }
    }
    if (prev2) {
      child._next = prev2._next;
      prev2._next = child;
    } else {
      child._next = parent2[firstProp];
      parent2[firstProp] = child;
    }
    if (child._next) {
      child._next._prev = child;
    } else {
      parent2[lastProp] = child;
    }
    child._prev = prev2;
    child.parent = child._dp = parent2;
    return child;
  }, _removeLinkedListItem = function _removeLinkedListItem2(parent2, child, firstProp, lastProp) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev2 = child._prev, next2 = child._next;
    if (prev2) {
      prev2._next = next2;
    } else if (parent2[firstProp] === child) {
      parent2[firstProp] = next2;
    }
    if (next2) {
      next2._prev = prev2;
    } else if (parent2[lastProp] === child) {
      parent2[lastProp] = prev2;
    }
    child._next = child._prev = child.parent = null;
  }, _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {
    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
    child._act = 0;
  }, _uncache = function _uncache2(animation, child) {
    if (animation && (!child || child._end > animation._dur || child._start < 0)) {
      var a2 = animation;
      while (a2) {
        a2._dirty = 1;
        a2 = a2.parent;
      }
    }
    return animation;
  }, _recacheAncestors = function _recacheAncestors2(animation) {
    var parent2 = animation.parent;
    while (parent2 && parent2.parent) {
      parent2._dirty = 1;
      parent2.totalDuration();
      parent2 = parent2.parent;
    }
    return animation;
  }, _rewindStartAt = function _rewindStartAt2(tween, totalTime, suppressEvents, force) {
    return tween._startAt && (_reverting$1 ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
  }, _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {
    return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
  }, _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {
    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
  }, _animationCycle = function _animationCycle2(tTime, cycleDuration) {
    var whole = Math.floor(tTime /= cycleDuration);
    return tTime && whole === tTime ? whole - 1 : whole;
  }, _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {
    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
  }, _setEnd = function _setEnd2(animation) {
    return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
  }, _alignPlayhead = function _alignPlayhead2(animation, totalTime) {
    var parent2 = animation._dp;
    if (parent2 && parent2.smoothChildTiming && animation._ts) {
      animation._start = _roundPrecise(parent2._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
      _setEnd(animation);
      parent2._dirty || _uncache(parent2, animation);
    }
    return animation;
  }, _postAddChecks = function _postAddChecks2(timeline2, child) {
    var t2;
    if (child._time || !child._dur && child._initted || child._start < timeline2._time && (child._dur || !child.add)) {
      t2 = _parentToChildTotalTime(timeline2.rawTime(), child);
      if (!child._dur || _clamp(0, child.totalDuration(), t2) - child._tTime > _tinyNum) {
        child.render(t2, true);
      }
    }
    if (_uncache(timeline2, child)._dp && timeline2._initted && timeline2._time >= timeline2._dur && timeline2._ts) {
      if (timeline2._dur < timeline2.duration()) {
        t2 = timeline2;
        while (t2._dp) {
          t2.rawTime() >= 0 && t2.totalTime(t2._tTime);
          t2 = t2._dp;
        }
      }
      timeline2._zTime = -_tinyNum;
    }
  }, _addToTimeline = function _addToTimeline2(timeline2, child, position2, skipChecks) {
    child.parent && _removeFromParent(child);
    child._start = _roundPrecise((_isNumber(position2) ? position2 : position2 || timeline2 !== _globalTimeline ? _parsePosition(timeline2, position2, child) : timeline2._time) + child._delay);
    child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
    _addLinkedListItem(timeline2, child, "_first", "_last", timeline2._sort ? "_start" : 0);
    _isFromOrFromStart(child) || (timeline2._recent = child);
    skipChecks || _postAddChecks(timeline2, child);
    timeline2._ts < 0 && _alignPlayhead(timeline2, timeline2._tTime);
    return timeline2;
  }, _scrollTrigger = function _scrollTrigger2(animation, trigger2) {
    return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger2)) && _globals.ScrollTrigger.create(trigger2, animation);
  }, _attemptInitTween = function _attemptInitTween2(tween, time, force, suppressEvents, tTime) {
    _initTween(tween, time, tTime);
    if (!tween._initted) {
      return 1;
    }
    if (!force && tween._pt && !_reverting$1 && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
      _lazyTweens.push(tween);
      tween._lazy = [tTime, suppressEvents];
      return 1;
    }
  }, _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {
    var parent2 = _ref.parent;
    return parent2 && parent2._ts && parent2._initted && !parent2._lock && (parent2.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent2));
  }, _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {
    var data = _ref2.data;
    return data === "isFromStart" || data === "isStart";
  }, _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {
    var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;
    if (repeatDelay && tween._repeat) {
      tTime = _clamp(0, tween._tDur, totalTime);
      iteration = _animationCycle(tTime, repeatDelay);
      tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
      if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
        prevRatio = 1 - ratio;
        tween.vars.repeatRefresh && tween._initted && tween.invalidate();
      }
    }
    if (ratio !== prevRatio || _reverting$1 || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
      if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
        return;
      }
      prevIteration = tween._zTime;
      tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
      suppressEvents || (suppressEvents = totalTime && !prevIteration);
      tween.ratio = ratio;
      tween._from && (ratio = 1 - ratio);
      tween._time = 0;
      tween._tTime = tTime;
      pt = tween._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
      tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
      tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
      if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
        ratio && _removeFromParent(tween, 1);
        if (!suppressEvents && !_reverting$1) {
          _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
          tween._prom && tween._prom();
        }
      }
    } else if (!tween._zTime) {
      tween._zTime = totalTime;
    }
  }, _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time) {
    var child;
    if (time > prevTime) {
      child = animation._first;
      while (child && child._start <= time) {
        if (child.data === "isPause" && child._start > prevTime) {
          return child;
        }
        child = child._next;
      }
    } else {
      child = animation._last;
      while (child && child._start >= time) {
        if (child.data === "isPause" && child._start < prevTime) {
          return child;
        }
        child = child._prev;
      }
    }
  }, _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {
    var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
    animation._dur = dur;
    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
    totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
    animation.parent && _setEnd(animation);
    skipUncache || _uncache(animation.parent, animation);
    return animation;
  }, _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {
    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
  }, _zeroPosition = {
    _start: 0,
    endTime: _emptyFunc,
    totalDuration: _emptyFunc
  }, _parsePosition = function _parsePosition2(animation, position2, percentAnimation) {
    var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum$1 ? recent.endTime(false) : animation._dur, i2, offset3, isPercent;
    if (_isString(position2) && (isNaN(position2) || position2 in labels)) {
      offset3 = position2.charAt(0);
      isPercent = position2.substr(-1) === "%";
      i2 = position2.indexOf("=");
      if (offset3 === "<" || offset3 === ">") {
        i2 >= 0 && (position2 = position2.replace(/=/, ""));
        return (offset3 === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position2.substr(1)) || 0) * (isPercent ? (i2 < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
      }
      if (i2 < 0) {
        position2 in labels || (labels[position2] = clippedDuration);
        return labels[position2];
      }
      offset3 = parseFloat(position2.charAt(i2 - 1) + position2.substr(i2 + 1));
      if (isPercent && percentAnimation) {
        offset3 = offset3 / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
      }
      return i2 > 1 ? _parsePosition2(animation, position2.substr(0, i2 - 1), percentAnimation) + offset3 : clippedDuration + offset3;
    }
    return position2 == null ? clippedDuration : +position2;
  }, _createTweenType = function _createTweenType2(type4, params, timeline2) {
    var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type4 < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent2;
    isLegacy && (vars.duration = params[1]);
    vars.parent = timeline2;
    if (type4) {
      irVars = vars;
      parent2 = timeline2;
      while (parent2 && !("immediateRender" in irVars)) {
        irVars = parent2.vars.defaults || {};
        parent2 = _isNotFalse(parent2.vars.inherit) && parent2.parent;
      }
      vars.immediateRender = _isNotFalse(irVars.immediateRender);
      type4 < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
    }
    return new Tween(params[0], vars, params[varsIndex + 1]);
  }, _conditionalReturn = function _conditionalReturn2(value, func) {
    return value || value === 0 ? func(value) : func;
  }, _clamp = function _clamp2(min, max, value) {
    return value < min ? min : value > max ? max : value;
  }, getUnit = function getUnit2(value, v2) {
    return !_isString(value) || !(v2 = _unitExp.exec(value)) ? "" : v2[1];
  }, clamp = function clamp2(min, max, value) {
    return _conditionalReturn(value, function(v2) {
      return _clamp(min, max, v2);
    });
  }, _slice = [].slice, _isArrayLike = function _isArrayLike2(value, nonEmpty) {
    return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win$1;
  }, _flatten = function _flatten2(ar, leaveStrings, accumulator) {
    if (accumulator === void 0) {
      accumulator = [];
    }
    return ar.forEach(function(value) {
      var _accumulator;
      return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
    }) || accumulator;
  }, toArray = function toArray2(value, scope, leaveStrings) {
    return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc$1).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
  }, selector = function selector2(value) {
    value = toArray(value)[0] || _warn("Invalid scope") || {};
    return function(v2) {
      var el = value.current || value.nativeElement || value;
      return toArray(v2, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc$1.createElement("div") : value);
    };
  }, shuffle = function shuffle2(a2) {
    return a2.sort(function() {
      return 0.5 - Math.random();
    });
  }, distribute = function distribute2(v2) {
    if (_isFunction(v2)) {
      return v2;
    }
    var vars = _isObject(v2) ? v2 : {
      each: v2
    }, ease = _parseEase(vars.ease), from2 = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from2 > 0 && from2 < 1, ratios = isNaN(from2) || isDecimal, axis = vars.axis, ratioX = from2, ratioY = from2;
    if (_isString(from2)) {
      ratioX = ratioY = {
        center: 0.5,
        edges: 0.5,
        end: 1
      }[from2] || 0;
    } else if (!isDecimal && ratios) {
      ratioX = from2[0];
      ratioY = from2[1];
    }
    return function(i2, target, a2) {
      var l2 = (a2 || vars).length, distances = cache[l2], originX, originY, x2, y2, d2, j2, max, min, wrapAt;
      if (!distances) {
        wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum$1])[1];
        if (!wrapAt) {
          max = -_bigNum$1;
          while (max < (max = a2[wrapAt++].getBoundingClientRect().left) && wrapAt < l2) {
          }
          wrapAt < l2 && wrapAt--;
        }
        distances = cache[l2] = [];
        originX = ratios ? Math.min(wrapAt, l2) * ratioX - 0.5 : from2 % wrapAt;
        originY = wrapAt === _bigNum$1 ? 0 : ratios ? l2 * ratioY / wrapAt - 0.5 : from2 / wrapAt | 0;
        max = 0;
        min = _bigNum$1;
        for (j2 = 0; j2 < l2; j2++) {
          x2 = j2 % wrapAt - originX;
          y2 = originY - (j2 / wrapAt | 0);
          distances[j2] = d2 = !axis ? _sqrt(x2 * x2 + y2 * y2) : Math.abs(axis === "y" ? y2 : x2);
          d2 > max && (max = d2);
          d2 < min && (min = d2);
        }
        from2 === "random" && shuffle(distances);
        distances.max = max - min;
        distances.min = min;
        distances.v = l2 = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l2 ? l2 - 1 : !axis ? Math.max(wrapAt, l2 / wrapAt) : axis === "y" ? l2 / wrapAt : wrapAt) || 0) * (from2 === "edges" ? -1 : 1);
        distances.b = l2 < 0 ? base - l2 : base;
        distances.u = getUnit(vars.amount || vars.each) || 0;
        ease = ease && l2 < 0 ? _invertEase(ease) : ease;
      }
      l2 = (distances[i2] - distances.min) / distances.max || 0;
      return _roundPrecise(distances.b + (ease ? ease(l2) : l2) * distances.v) + distances.u;
    };
  }, _roundModifier = function _roundModifier2(v2) {
    var p = Math.pow(10, ((v2 + "").split(".")[1] || "").length);
    return function(raw) {
      var n2 = _roundPrecise(Math.round(parseFloat(raw) / v2) * v2 * p);
      return (n2 - n2 % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw));
    };
  }, snap = function snap2(snapTo, value) {
    var isArray2 = _isArray(snapTo), radius, is2D;
    if (!isArray2 && _isObject(snapTo)) {
      radius = isArray2 = snapTo.radius || _bigNum$1;
      if (snapTo.values) {
        snapTo = toArray(snapTo.values);
        if (is2D = !_isNumber(snapTo[0])) {
          radius *= radius;
        }
      } else {
        snapTo = _roundModifier(snapTo.increment);
      }
    }
    return _conditionalReturn(value, !isArray2 ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
      is2D = snapTo(raw);
      return Math.abs(is2D - raw) <= radius ? is2D : raw;
    } : function(raw) {
      var x2 = parseFloat(is2D ? raw.x : raw), y2 = parseFloat(is2D ? raw.y : 0), min = _bigNum$1, closest = 0, i2 = snapTo.length, dx, dy;
      while (i2--) {
        if (is2D) {
          dx = snapTo[i2].x - x2;
          dy = snapTo[i2].y - y2;
          dx = dx * dx + dy * dy;
        } else {
          dx = Math.abs(snapTo[i2] - x2);
        }
        if (dx < min) {
          min = dx;
          closest = i2;
        }
      }
      closest = !radius || min <= radius ? snapTo[closest] : raw;
      return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
    });
  }, random = function random2(min, max, roundingIncrement, returnFunction) {
    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
      return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
    });
  }, pipe = function pipe2() {
    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
      functions[_key] = arguments[_key];
    }
    return function(value) {
      return functions.reduce(function(v2, f2) {
        return f2(v2);
      }, value);
    };
  }, unitize = function unitize2(func, unit) {
    return function(value) {
      return func(parseFloat(value)) + (unit || getUnit(value));
    };
  }, normalize = function normalize2(min, max, value) {
    return mapRange(min, max, 0, 1, value);
  }, _wrapArray = function _wrapArray2(a2, wrapper, value) {
    return _conditionalReturn(value, function(index2) {
      return a2[~~wrapper(index2)];
    });
  }, wrap = function wrap2(min, max, value) {
    var range3 = max - min;
    return _isArray(min) ? _wrapArray(min, wrap2(0, min.length), max) : _conditionalReturn(value, function(value2) {
      return (range3 + (value2 - min) % range3) % range3 + min;
    });
  }, wrapYoyo = function wrapYoyo2(min, max, value) {
    var range3 = max - min, total = range3 * 2;
    return _isArray(min) ? _wrapArray(min, wrapYoyo2(0, min.length - 1), max) : _conditionalReturn(value, function(value2) {
      value2 = (total + (value2 - min) % total) % total || 0;
      return min + (value2 > range3 ? total - value2 : value2);
    });
  }, _replaceRandom = function _replaceRandom2(value) {
    var prev2 = 0, s2 = "", i2, nums, end, isArray2;
    while (~(i2 = value.indexOf("random(", prev2))) {
      end = value.indexOf(")", i2);
      isArray2 = value.charAt(i2 + 7) === "[";
      nums = value.substr(i2 + 7, end - i2 - 7).match(isArray2 ? _delimitedValueExp : _strictNumExp);
      s2 += value.substr(prev2, i2 - prev2) + random(isArray2 ? nums : +nums[0], isArray2 ? 0 : +nums[1], +nums[2] || 1e-5);
      prev2 = end + 1;
    }
    return s2 + value.substr(prev2, value.length - prev2);
  }, mapRange = function mapRange2(inMin, inMax, outMin, outMax, value) {
    var inRange = inMax - inMin, outRange = outMax - outMin;
    return _conditionalReturn(value, function(value2) {
      return outMin + ((value2 - inMin) / inRange * outRange || 0);
    });
  }, interpolate = function interpolate2(start, end, progress, mutate) {
    var func = isNaN(start + end) ? 0 : function(p2) {
      return (1 - p2) * start + p2 * end;
    };
    if (!func) {
      var isString2 = _isString(start), master = {}, p, i2, interpolators, l2, il;
      progress === true && (mutate = 1) && (progress = null);
      if (isString2) {
        start = {
          p: start
        };
        end = {
          p: end
        };
      } else if (_isArray(start) && !_isArray(end)) {
        interpolators = [];
        l2 = start.length;
        il = l2 - 2;
        for (i2 = 1; i2 < l2; i2++) {
          interpolators.push(interpolate2(start[i2 - 1], start[i2]));
        }
        l2--;
        func = function func2(p2) {
          p2 *= l2;
          var i3 = Math.min(il, ~~p2);
          return interpolators[i3](p2 - i3);
        };
        progress = end;
      } else if (!mutate) {
        start = _merge(_isArray(start) ? [] : {}, start);
      }
      if (!interpolators) {
        for (p in end) {
          _addPropTween.call(master, start, p, "get", end[p]);
        }
        func = function func2(p2) {
          return _renderPropTweens(p2, master) || (isString2 ? start.p : start);
        };
      }
    }
    return _conditionalReturn(progress, func);
  }, _getLabelInDirection = function _getLabelInDirection2(timeline2, fromTime, backward) {
    var labels = timeline2.labels, min = _bigNum$1, p, distance, label;
    for (p in labels) {
      distance = labels[p] - fromTime;
      if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
        label = p;
        min = distance;
      }
    }
    return label;
  }, _callback = function _callback2(animation, type4, executeLazyFirst) {
    var v2 = animation.vars, callback = v2[type4], prevContext = _context, context3 = animation._ctx, params, scope, result;
    if (!callback) {
      return;
    }
    params = v2[type4 + "Params"];
    scope = v2.callbackScope || animation;
    executeLazyFirst && _lazyTweens.length && _lazyRender();
    context3 && (_context = context3);
    result = params ? callback.apply(scope, params) : callback.call(scope);
    _context = prevContext;
    return result;
  }, _interrupt = function _interrupt2(animation) {
    _removeFromParent(animation);
    animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting$1);
    animation.progress() < 1 && _callback(animation, "onInterrupt");
    return animation;
  }, _quickTween, _registerPluginQueue = [], _createPlugin = function _createPlugin2(config3) {
    if (!config3)
      return;
    config3 = !config3.name && config3["default"] || config3;
    if (_windowExists$1() || config3.headless) {
      var name2 = config3.name, isFunc = _isFunction(config3), Plugin = name2 && !isFunc && config3.init ? function() {
        this._props = [];
      } : config3, instanceDefaults = {
        init: _emptyFunc,
        render: _renderPropTweens,
        add: _addPropTween,
        kill: _killPropTweensOf,
        modifier: _addPluginModifier,
        rawVars: 0
      }, statics = {
        targetTest: 0,
        get: 0,
        getSetter: _getSetter,
        aliases: {},
        register: 0
      };
      _wake();
      if (config3 !== Plugin) {
        if (_plugins[name2]) {
          return;
        }
        _setDefaults(Plugin, _setDefaults(_copyExcluding(config3, instanceDefaults), statics));
        _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config3, statics)));
        _plugins[Plugin.prop = name2] = Plugin;
        if (config3.targetTest) {
          _harnessPlugins.push(Plugin);
          _reservedProps[name2] = 1;
        }
        name2 = (name2 === "css" ? "CSS" : name2.charAt(0).toUpperCase() + name2.substr(1)) + "Plugin";
      }
      _addGlobal(name2, Plugin);
      config3.register && config3.register(gsap, Plugin, PropTween);
    } else {
      _registerPluginQueue.push(config3);
    }
  }, _255 = 255, _colorLookup = {
    aqua: [0, _255, _255],
    lime: [0, _255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _255],
    navy: [0, 0, 128],
    white: [_255, _255, _255],
    olive: [128, 128, 0],
    yellow: [_255, _255, 0],
    orange: [_255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_255, 0, 0],
    pink: [_255, 192, 203],
    cyan: [0, _255, _255],
    transparent: [_255, _255, _255, 0]
  }, _hue = function _hue2(h2, m1, m2) {
    h2 += h2 < 0 ? 1 : h2 > 1 ? -1 : 0;
    return (h2 * 6 < 1 ? m1 + (m2 - m1) * h2 * 6 : h2 < 0.5 ? m2 : h2 * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h2) * 6 : m1) * _255 + 0.5 | 0;
  }, splitColor = function splitColor2(v2, toHSL, forceAlpha) {
    var a2 = !v2 ? _colorLookup.black : _isNumber(v2) ? [v2 >> 16, v2 >> 8 & _255, v2 & _255] : 0, r2, g2, b2, h2, s2, l2, max, min, d2, wasHSL;
    if (!a2) {
      if (v2.substr(-1) === ",") {
        v2 = v2.substr(0, v2.length - 1);
      }
      if (_colorLookup[v2]) {
        a2 = _colorLookup[v2];
      } else if (v2.charAt(0) === "#") {
        if (v2.length < 6) {
          r2 = v2.charAt(1);
          g2 = v2.charAt(2);
          b2 = v2.charAt(3);
          v2 = "#" + r2 + r2 + g2 + g2 + b2 + b2 + (v2.length === 5 ? v2.charAt(4) + v2.charAt(4) : "");
        }
        if (v2.length === 9) {
          a2 = parseInt(v2.substr(1, 6), 16);
          return [a2 >> 16, a2 >> 8 & _255, a2 & _255, parseInt(v2.substr(7), 16) / 255];
        }
        v2 = parseInt(v2.substr(1), 16);
        a2 = [v2 >> 16, v2 >> 8 & _255, v2 & _255];
      } else if (v2.substr(0, 3) === "hsl") {
        a2 = wasHSL = v2.match(_strictNumExp);
        if (!toHSL) {
          h2 = +a2[0] % 360 / 360;
          s2 = +a2[1] / 100;
          l2 = +a2[2] / 100;
          g2 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2;
          r2 = l2 * 2 - g2;
          a2.length > 3 && (a2[3] *= 1);
          a2[0] = _hue(h2 + 1 / 3, r2, g2);
          a2[1] = _hue(h2, r2, g2);
          a2[2] = _hue(h2 - 1 / 3, r2, g2);
        } else if (~v2.indexOf("=")) {
          a2 = v2.match(_numExp);
          forceAlpha && a2.length < 4 && (a2[3] = 1);
          return a2;
        }
      } else {
        a2 = v2.match(_strictNumExp) || _colorLookup.transparent;
      }
      a2 = a2.map(Number);
    }
    if (toHSL && !wasHSL) {
      r2 = a2[0] / _255;
      g2 = a2[1] / _255;
      b2 = a2[2] / _255;
      max = Math.max(r2, g2, b2);
      min = Math.min(r2, g2, b2);
      l2 = (max + min) / 2;
      if (max === min) {
        h2 = s2 = 0;
      } else {
        d2 = max - min;
        s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
        h2 = max === r2 ? (g2 - b2) / d2 + (g2 < b2 ? 6 : 0) : max === g2 ? (b2 - r2) / d2 + 2 : (r2 - g2) / d2 + 4;
        h2 *= 60;
      }
      a2[0] = ~~(h2 + 0.5);
      a2[1] = ~~(s2 * 100 + 0.5);
      a2[2] = ~~(l2 * 100 + 0.5);
    }
    forceAlpha && a2.length < 4 && (a2[3] = 1);
    return a2;
  }, _colorOrderData = function _colorOrderData2(v2) {
    var values = [], c2 = [], i2 = -1;
    v2.split(_colorExp).forEach(function(v3) {
      var a2 = v3.match(_numWithUnitExp) || [];
      values.push.apply(values, a2);
      c2.push(i2 += a2.length + 1);
    });
    values.c = c2;
    return values;
  }, _formatColors = function _formatColors2(s2, toHSL, orderMatchData) {
    var result = "", colors = (s2 + result).match(_colorExp), type4 = toHSL ? "hsla(" : "rgba(", i2 = 0, c2, shell, d2, l2;
    if (!colors) {
      return s2;
    }
    colors = colors.map(function(color) {
      return (color = splitColor(color, toHSL, 1)) && type4 + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
    });
    if (orderMatchData) {
      d2 = _colorOrderData(s2);
      c2 = orderMatchData.c;
      if (c2.join(result) !== d2.c.join(result)) {
        shell = s2.replace(_colorExp, "1").split(_numWithUnitExp);
        l2 = shell.length - 1;
        for (; i2 < l2; i2++) {
          result += shell[i2] + (~c2.indexOf(i2) ? colors.shift() || type4 + "0,0,0,0)" : (d2.length ? d2 : colors.length ? colors : orderMatchData).shift());
        }
      }
    }
    if (!shell) {
      shell = s2.split(_colorExp);
      l2 = shell.length - 1;
      for (; i2 < l2; i2++) {
        result += shell[i2] + colors[i2];
      }
    }
    return result + shell[l2];
  }, _colorExp = function() {
    var s2 = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", p;
    for (p in _colorLookup) {
      s2 += "|" + p + "\\b";
    }
    return new RegExp(s2 + ")", "gi");
  }(), _hslExp = /hsl[a]?\(/, _colorStringFilter = function _colorStringFilter2(a2) {
    var combined = a2.join(" "), toHSL;
    _colorExp.lastIndex = 0;
    if (_colorExp.test(combined)) {
      toHSL = _hslExp.test(combined);
      a2[1] = _formatColors(a2[1], toHSL);
      a2[0] = _formatColors(a2[0], toHSL, _colorOrderData(a2[1]));
      return true;
    }
  }, _tickerActive, _ticker = function() {
    var _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners2 = [], _id, _req, _raf, _self, _delta, _i, _tick = function _tick2(v2) {
      var elapsed = _getTime() - _lastUpdate, manual = v2 === true, overlap, dispatch, time, frame;
      (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);
      _lastUpdate += elapsed;
      time = _lastUpdate - _startTime;
      overlap = time - _nextTime;
      if (overlap > 0 || manual) {
        frame = ++_self.frame;
        _delta = time - _self.time * 1e3;
        _self.time = time = time / 1e3;
        _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
        dispatch = 1;
      }
      manual || (_id = _req(_tick2));
      if (dispatch) {
        for (_i = 0; _i < _listeners2.length; _i++) {
          _listeners2[_i](time, _delta, frame, v2);
        }
      }
    };
    _self = {
      time: 0,
      frame: 0,
      tick: function tick() {
        _tick(true);
      },
      deltaRatio: function deltaRatio(fps) {
        return _delta / (1e3 / (fps || 60));
      },
      wake: function wake() {
        if (_coreReady) {
          if (!_coreInitted && _windowExists$1()) {
            _win$1 = _coreInitted = window;
            _doc$1 = _win$1.document || {};
            _globals.gsap = gsap;
            (_win$1.gsapVersions || (_win$1.gsapVersions = [])).push(gsap.version);
            _install(_installScope || _win$1.GreenSockGlobals || !_win$1.gsap && _win$1 || {});
            _registerPluginQueue.forEach(_createPlugin);
          }
          _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame;
          _id && _self.sleep();
          _req = _raf || function(f2) {
            return setTimeout(f2, _nextTime - _self.time * 1e3 + 1 | 0);
          };
          _tickerActive = 1;
          _tick(2);
        }
      },
      sleep: function sleep() {
        (_raf ? cancelAnimationFrame : clearTimeout)(_id);
        _tickerActive = 0;
        _req = _emptyFunc;
      },
      lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
        _lagThreshold = threshold || Infinity;
        _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
      },
      fps: function fps(_fps) {
        _gap = 1e3 / (_fps || 240);
        _nextTime = _self.time * 1e3 + _gap;
      },
      add: function add2(callback, once, prioritize) {
        var func = once ? function(t2, d2, f2, v2) {
          callback(t2, d2, f2, v2);
          _self.remove(func);
        } : callback;
        _self.remove(callback);
        _listeners2[prioritize ? "unshift" : "push"](func);
        _wake();
        return func;
      },
      remove: function remove2(callback, i2) {
        ~(i2 = _listeners2.indexOf(callback)) && _listeners2.splice(i2, 1) && _i >= i2 && _i--;
      },
      _listeners: _listeners2
    };
    return _self;
  }(), _wake = function _wake2() {
    return !_tickerActive && _ticker.wake();
  }, _easeMap = {}, _customEaseExp = /^[\d.\-M][\d.\-,\s]/, _quotesExp = /["']/g, _parseObjectInString = function _parseObjectInString2(value) {
    var obj = {}, split = value.substr(1, value.length - 3).split(":"), key2 = split[0], i2 = 1, l2 = split.length, index2, val, parsedVal;
    for (; i2 < l2; i2++) {
      val = split[i2];
      index2 = i2 !== l2 - 1 ? val.lastIndexOf(",") : val.length;
      parsedVal = val.substr(0, index2);
      obj[key2] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
      key2 = val.substr(index2 + 1).trim();
    }
    return obj;
  }, _valueInParentheses = function _valueInParentheses2(value) {
    var open2 = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open2);
    return value.substring(open2, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
  }, _configEaseFromString = function _configEaseFromString2(name2) {
    var split = (name2 + "").split("("), ease = _easeMap[split[0]];
    return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name2.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name2).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name2) ? _easeMap._CE("", name2) : ease;
  }, _invertEase = function _invertEase2(ease) {
    return function(p) {
      return 1 - ease(1 - p);
    };
  }, _propagateYoyoEase = function _propagateYoyoEase2(timeline2, isYoyo) {
    var child = timeline2._first, ease;
    while (child) {
      if (child instanceof Timeline) {
        _propagateYoyoEase2(child, isYoyo);
      } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
        if (child.timeline) {
          _propagateYoyoEase2(child.timeline, isYoyo);
        } else {
          ease = child._ease;
          child._ease = child._yEase;
          child._yEase = ease;
          child._yoyo = isYoyo;
        }
      }
      child = child._next;
    }
  }, _parseEase = function _parseEase2(ease, defaultEase) {
    return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
  }, _insertEase = function _insertEase2(names2, easeIn, easeOut, easeInOut) {
    if (easeOut === void 0) {
      easeOut = function easeOut2(p) {
        return 1 - easeIn(1 - p);
      };
    }
    if (easeInOut === void 0) {
      easeInOut = function easeInOut2(p) {
        return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
      };
    }
    var ease = {
      easeIn,
      easeOut,
      easeInOut
    }, lowercaseName;
    _forEachName(names2, function(name2) {
      _easeMap[name2] = _globals[name2] = ease;
      _easeMap[lowercaseName = name2.toLowerCase()] = easeOut;
      for (var p in ease) {
        _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name2 + "." + p] = ease[p];
      }
    });
    return ease;
  }, _easeInOutFromOut = function _easeInOutFromOut2(easeOut) {
    return function(p) {
      return p < 0.5 ? (1 - easeOut(1 - p * 2)) / 2 : 0.5 + easeOut((p - 0.5) * 2) / 2;
    };
  }, _configElastic = function _configElastic2(type4, amplitude, period) {
    var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type4 ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut2(p) {
      return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
    }, ease = type4 === "out" ? easeOut : type4 === "in" ? function(p) {
      return 1 - easeOut(1 - p);
    } : _easeInOutFromOut(easeOut);
    p2 = _2PI / p2;
    ease.config = function(amplitude2, period2) {
      return _configElastic2(type4, amplitude2, period2);
    };
    return ease;
  }, _configBack = function _configBack2(type4, overshoot) {
    if (overshoot === void 0) {
      overshoot = 1.70158;
    }
    var easeOut = function easeOut2(p) {
      return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
    }, ease = type4 === "out" ? easeOut : type4 === "in" ? function(p) {
      return 1 - easeOut(1 - p);
    } : _easeInOutFromOut(easeOut);
    ease.config = function(overshoot2) {
      return _configBack2(type4, overshoot2);
    };
    return ease;
  };
  _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name2, i2) {
    var power = i2 < 5 ? i2 + 1 : i2;
    _insertEase(name2 + ",Power" + (power - 1), i2 ? function(p) {
      return Math.pow(p, power);
    } : function(p) {
      return p;
    }, function(p) {
      return 1 - Math.pow(1 - p, power);
    }, function(p) {
      return p < 0.5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
    });
  });
  _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
  _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
  (function(n2, c2) {
    var n1 = 1 / c2, n22 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut2(p) {
      return p < n1 ? n2 * p * p : p < n22 ? n2 * Math.pow(p - 1.5 / c2, 2) + 0.75 : p < n3 ? n2 * (p -= 2.25 / c2) * p + 0.9375 : n2 * Math.pow(p - 2.625 / c2, 2) + 0.984375;
    };
    _insertEase("Bounce", function(p) {
      return 1 - easeOut(1 - p);
    }, easeOut);
  })(7.5625, 2.75);
  _insertEase("Expo", function(p) {
    return p ? Math.pow(2, 10 * (p - 1)) : 0;
  });
  _insertEase("Circ", function(p) {
    return -(_sqrt(1 - p * p) - 1);
  });
  _insertEase("Sine", function(p) {
    return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
  });
  _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
  _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
    config: function config(steps, immediateStart) {
      if (steps === void 0) {
        steps = 1;
      }
      var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;
      return function(p) {
        return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
      };
    }
  };
  _defaults.ease = _easeMap["quad.out"];
  _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name2) {
    return _callbackNames += name2 + "," + name2 + "Params,";
  });
  var GSCache = function GSCache2(target, harness) {
    this.id = _gsID++;
    target._gsap = this;
    this.target = target;
    this.harness = harness;
    this.get = harness ? harness.get : _getProperty;
    this.set = harness ? harness.getSetter : _getSetter;
  };
  var Animation = /* @__PURE__ */ function() {
    function Animation2(vars) {
      this.vars = vars;
      this._delay = +vars.delay || 0;
      if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
        this._rDelay = vars.repeatDelay || 0;
        this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
      }
      this._ts = 1;
      _setDuration(this, +vars.duration, 1, 1);
      this.data = vars.data;
      if (_context) {
        this._ctx = _context;
        _context.data.push(this);
      }
      _tickerActive || _ticker.wake();
    }
    var _proto = Animation2.prototype;
    _proto.delay = function delay2(value) {
      if (value || value === 0) {
        this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
        this._delay = value;
        return this;
      }
      return this._delay;
    };
    _proto.duration = function duration(value) {
      return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
    };
    _proto.totalDuration = function totalDuration(value) {
      if (!arguments.length) {
        return this._tDur;
      }
      this._dirty = 0;
      return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
    };
    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
      _wake();
      if (!arguments.length) {
        return this._tTime;
      }
      var parent2 = this._dp;
      if (parent2 && parent2.smoothChildTiming && this._ts) {
        _alignPlayhead(this, _totalTime);
        !parent2._dp || parent2.parent || _postAddChecks(parent2, this);
        while (parent2 && parent2.parent) {
          if (parent2.parent._time !== parent2._start + (parent2._ts >= 0 ? parent2._tTime / parent2._ts : (parent2.totalDuration() - parent2._tTime) / -parent2._ts)) {
            parent2.totalTime(parent2._tTime, true);
          }
          parent2 = parent2.parent;
        }
        if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
          _addToTimeline(this._dp, this, this._start - this._delay);
        }
      }
      if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
        this._ts || (this._pTime = _totalTime);
        _lazySafeRender(this, _totalTime, suppressEvents);
      }
      return this;
    };
    _proto.time = function time(value, suppressEvents) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
    };
    _proto.totalProgress = function totalProgress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;
    };
    _proto.progress = function progress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
    };
    _proto.iteration = function iteration(value, suppressEvents) {
      var cycleDuration = this.duration() + this._rDelay;
      return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
    };
    _proto.timeScale = function timeScale(value, suppressEvents) {
      if (!arguments.length) {
        return this._rts === -_tinyNum ? 0 : this._rts;
      }
      if (this._rts === value) {
        return this;
      }
      var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
      this._rts = +value || 0;
      this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
      this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), suppressEvents !== false);
      _setEnd(this);
      return _recacheAncestors(this);
    };
    _proto.paused = function paused(value) {
      if (!arguments.length) {
        return this._ps;
      }
      if (this._ps !== value) {
        this._ps = value;
        if (value) {
          this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
          this._ts = this._act = 0;
        } else {
          _wake();
          this._ts = this._rts;
          this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
        }
      }
      return this;
    };
    _proto.startTime = function startTime(value) {
      if (arguments.length) {
        this._start = value;
        var parent2 = this.parent || this._dp;
        parent2 && (parent2._sort || !this.parent) && _addToTimeline(parent2, this, value - this._delay);
        return this;
      }
      return this._start;
    };
    _proto.endTime = function endTime(includeRepeats) {
      return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
    };
    _proto.rawTime = function rawTime(wrapRepeats) {
      var parent2 = this.parent || this._dp;
      return !parent2 ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent2.rawTime(wrapRepeats), this);
    };
    _proto.revert = function revert(config3) {
      if (config3 === void 0) {
        config3 = _revertConfig;
      }
      var prevIsReverting = _reverting$1;
      _reverting$1 = config3;
      if (this._initted || this._startAt) {
        this.timeline && this.timeline.revert(config3);
        this.totalTime(-0.01, config3.suppressEvents);
      }
      this.data !== "nested" && config3.kill !== false && this.kill();
      _reverting$1 = prevIsReverting;
      return this;
    };
    _proto.globalTime = function globalTime(rawTime) {
      var animation = this, time = arguments.length ? rawTime : animation.rawTime();
      while (animation) {
        time = animation._start + time / (Math.abs(animation._ts) || 1);
        animation = animation._dp;
      }
      return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time;
    };
    _proto.repeat = function repeat(value) {
      if (arguments.length) {
        this._repeat = value === Infinity ? -2 : value;
        return _onUpdateTotalDuration(this);
      }
      return this._repeat === -2 ? Infinity : this._repeat;
    };
    _proto.repeatDelay = function repeatDelay(value) {
      if (arguments.length) {
        var time = this._time;
        this._rDelay = value;
        _onUpdateTotalDuration(this);
        return time ? this.time(time) : this;
      }
      return this._rDelay;
    };
    _proto.yoyo = function yoyo(value) {
      if (arguments.length) {
        this._yoyo = value;
        return this;
      }
      return this._yoyo;
    };
    _proto.seek = function seek(position2, suppressEvents) {
      return this.totalTime(_parsePosition(this, position2), _isNotFalse(suppressEvents));
    };
    _proto.restart = function restart(includeDelay, suppressEvents) {
      return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
    };
    _proto.play = function play(from2, suppressEvents) {
      from2 != null && this.seek(from2, suppressEvents);
      return this.reversed(false).paused(false);
    };
    _proto.reverse = function reverse(from2, suppressEvents) {
      from2 != null && this.seek(from2 || this.totalDuration(), suppressEvents);
      return this.reversed(true).paused(false);
    };
    _proto.pause = function pause(atTime, suppressEvents) {
      atTime != null && this.seek(atTime, suppressEvents);
      return this.paused(true);
    };
    _proto.resume = function resume() {
      return this.paused(false);
    };
    _proto.reversed = function reversed(value) {
      if (arguments.length) {
        !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
        return this;
      }
      return this._rts < 0;
    };
    _proto.invalidate = function invalidate() {
      this._initted = this._act = 0;
      this._zTime = -_tinyNum;
      return this;
    };
    _proto.isActive = function isActive() {
      var parent2 = this.parent || this._dp, start = this._start, rawTime;
      return !!(!parent2 || this._ts && this._initted && parent2.isActive() && (rawTime = parent2.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
    };
    _proto.eventCallback = function eventCallback(type4, callback, params) {
      var vars = this.vars;
      if (arguments.length > 1) {
        if (!callback) {
          delete vars[type4];
        } else {
          vars[type4] = callback;
          params && (vars[type4 + "Params"] = params);
          type4 === "onUpdate" && (this._onUpdate = callback);
        }
        return this;
      }
      return vars[type4];
    };
    _proto.then = function then(onFulfilled) {
      var self2 = this;
      return new Promise(function(resolve2) {
        var f2 = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {
          var _then = self2.then;
          self2.then = null;
          _isFunction(f2) && (f2 = f2(self2)) && (f2.then || f2 === self2) && (self2.then = _then);
          resolve2(f2);
          self2.then = _then;
        };
        if (self2._initted && self2.totalProgress() === 1 && self2._ts >= 0 || !self2._tTime && self2._ts < 0) {
          _resolve();
        } else {
          self2._prom = _resolve;
        }
      });
    };
    _proto.kill = function kill() {
      _interrupt(this);
    };
    return Animation2;
  }();
  _setDefaults(Animation.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: false,
    parent: null,
    _initted: false,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -_tinyNum,
    _prom: 0,
    _ps: false,
    _rts: 1
  });
  var Timeline = /* @__PURE__ */ function(_Animation) {
    _inheritsLoose(Timeline2, _Animation);
    function Timeline2(vars, position2) {
      var _this;
      if (vars === void 0) {
        vars = {};
      }
      _this = _Animation.call(this, vars) || this;
      _this.labels = {};
      _this.smoothChildTiming = !!vars.smoothChildTiming;
      _this.autoRemoveChildren = !!vars.autoRemoveChildren;
      _this._sort = _isNotFalse(vars.sortChildren);
      _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position2);
      vars.reversed && _this.reverse();
      vars.paused && _this.paused(true);
      vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
      return _this;
    }
    var _proto2 = Timeline2.prototype;
    _proto2.to = function to(targets, vars, position2) {
      _createTweenType(0, arguments, this);
      return this;
    };
    _proto2.from = function from2(targets, vars, position2) {
      _createTweenType(1, arguments, this);
      return this;
    };
    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position2) {
      _createTweenType(2, arguments, this);
      return this;
    };
    _proto2.set = function set2(targets, vars, position2) {
      vars.duration = 0;
      vars.parent = this;
      _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
      vars.immediateRender = !!vars.immediateRender;
      new Tween(targets, vars, _parsePosition(this, position2), 1);
      return this;
    };
    _proto2.call = function call2(callback, params, position2) {
      return _addToTimeline(this, Tween.delayedCall(0, callback, params), position2);
    };
    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position2, onCompleteAll, onCompleteAllParams) {
      vars.duration = duration;
      vars.stagger = vars.stagger || stagger;
      vars.onComplete = onCompleteAll;
      vars.onCompleteParams = onCompleteAllParams;
      vars.parent = this;
      new Tween(targets, vars, _parsePosition(this, position2));
      return this;
    };
    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position2, onCompleteAll, onCompleteAllParams) {
      vars.runBackwards = 1;
      _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
      return this.staggerTo(targets, duration, vars, stagger, position2, onCompleteAll, onCompleteAllParams);
    };
    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position2, onCompleteAll, onCompleteAllParams) {
      toVars.startAt = fromVars;
      _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
      return this.staggerTo(targets, duration, toVars, stagger, position2, onCompleteAll, onCompleteAllParams);
    };
    _proto2.render = function render4(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next2, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
      this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
      if (tTime !== this._tTime || force || crossingStart) {
        if (prevTime !== this._time && dur) {
          tTime += this._time - prevTime;
          totalTime += this._time - prevTime;
        }
        time = tTime;
        prevStart = this._start;
        timeScale = this._ts;
        prevPaused = !timeScale;
        if (crossingStart) {
          dur || (prevTime = this._zTime);
          (totalTime || !suppressEvents) && (this._zTime = totalTime);
        }
        if (this._repeat) {
          yoyo = this._yoyo;
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && totalTime < 0) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time = dur;
          } else {
            iteration = ~~(tTime / cycleDuration);
            if (iteration && iteration === tTime / cycleDuration) {
              time = dur;
              iteration--;
            }
            time > dur && (time = dur);
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
          if (yoyo && iteration & 1) {
            time = dur - time;
            isYoyo = 1;
          }
          if (iteration !== prevIteration && !this._lock) {
            var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
            iteration < prevIteration && (rewinding = !rewinding);
            prevTime = rewinding ? 0 : tTime % dur ? dur : tTime;
            this._lock = 1;
            this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
            this._tTime = tTime;
            !suppressEvents && this.parent && _callback(this, "onRepeat");
            this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
            if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
              return this;
            }
            dur = this._dur;
            tDur = this._tDur;
            if (doesWrap) {
              this._lock = 2;
              prevTime = rewinding ? dur : -1e-4;
              this.render(prevTime, true);
              this.vars.repeatRefresh && !isYoyo && this.invalidate();
            }
            this._lock = 0;
            if (!this._ts && !prevPaused) {
              return this;
            }
            _propagateYoyoEase(this, isYoyo);
          }
        }
        if (this._hasPause && !this._forcing && this._lock < 2) {
          pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
          if (pauseTween) {
            tTime -= time - (time = pauseTween._start);
          }
        }
        this._tTime = tTime;
        this._time = time;
        this._act = !timeScale;
        if (!this._initted) {
          this._onUpdate = this.vars.onUpdate;
          this._initted = 1;
          this._zTime = totalTime;
          prevTime = 0;
        }
        if (!prevTime && time && !suppressEvents && !iteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        if (time >= prevTime && totalTime >= 0) {
          child = this._first;
          while (child) {
            next2 = child._next;
            if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
              if (time !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next2 && (tTime += this._zTime = -_tinyNum);
                break;
              }
            }
            child = next2;
          }
        } else {
          child = this._last;
          var adjustedTime = totalTime < 0 ? totalTime : time;
          while (child) {
            next2 = child._prev;
            if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting$1 && (child._initted || child._startAt));
              if (time !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next2 && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                break;
              }
            }
            child = next2;
          }
        }
        if (pauseTween && !suppressEvents) {
          this.pause();
          pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
          if (this._ts) {
            this._start = prevStart;
            _setEnd(this);
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
        if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {
          if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {
            if (!this._lock) {
              (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
              if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
              }
            }
          }
        }
      }
      return this;
    };
    _proto2.add = function add2(child, position2) {
      var _this2 = this;
      _isNumber(position2) || (position2 = _parsePosition(this, position2, child));
      if (!(child instanceof Animation)) {
        if (_isArray(child)) {
          child.forEach(function(obj) {
            return _this2.add(obj, position2);
          });
          return this;
        }
        if (_isString(child)) {
          return this.addLabel(child, position2);
        }
        if (_isFunction(child)) {
          child = Tween.delayedCall(0, child);
        } else {
          return this;
        }
      }
      return this !== child ? _addToTimeline(this, child, position2) : this;
    };
    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
      if (nested === void 0) {
        nested = true;
      }
      if (tweens === void 0) {
        tweens = true;
      }
      if (timelines === void 0) {
        timelines = true;
      }
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = -_bigNum$1;
      }
      var a2 = [], child = this._first;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          if (child instanceof Tween) {
            tweens && a2.push(child);
          } else {
            timelines && a2.push(child);
            nested && a2.push.apply(a2, child.getChildren(true, tweens, timelines));
          }
        }
        child = child._next;
      }
      return a2;
    };
    _proto2.getById = function getById2(id) {
      var animations = this.getChildren(1, 1, 1), i2 = animations.length;
      while (i2--) {
        if (animations[i2].vars.id === id) {
          return animations[i2];
        }
      }
    };
    _proto2.remove = function remove2(child) {
      if (_isString(child)) {
        return this.removeLabel(child);
      }
      if (_isFunction(child)) {
        return this.killTweensOf(child);
      }
      _removeLinkedListItem(this, child);
      if (child === this._recent) {
        this._recent = this._last;
      }
      return _uncache(this);
    };
    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
      if (!arguments.length) {
        return this._tTime;
      }
      this._forcing = 1;
      if (!this._dp && this._ts) {
        this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
      }
      _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
      this._forcing = 0;
      return this;
    };
    _proto2.addLabel = function addLabel(label, position2) {
      this.labels[label] = _parsePosition(this, position2);
      return this;
    };
    _proto2.removeLabel = function removeLabel(label) {
      delete this.labels[label];
      return this;
    };
    _proto2.addPause = function addPause(position2, callback, params) {
      var t2 = Tween.delayedCall(0, callback || _emptyFunc, params);
      t2.data = "isPause";
      this._hasPause = 1;
      return _addToTimeline(this, t2, _parsePosition(this, position2));
    };
    _proto2.removePause = function removePause(position2) {
      var child = this._first;
      position2 = _parsePosition(this, position2);
      while (child) {
        if (child._start === position2 && child.data === "isPause") {
          _removeFromParent(child);
        }
        child = child._next;
      }
    };
    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      var tweens = this.getTweensOf(targets, onlyActive), i2 = tweens.length;
      while (i2--) {
        _overwritingTween !== tweens[i2] && tweens[i2].kill(targets, props);
      }
      return this;
    };
    _proto2.getTweensOf = function getTweensOf2(targets, onlyActive) {
      var a2 = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children;
      while (child) {
        if (child instanceof Tween) {
          if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
            a2.push(child);
          }
        } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
          a2.push.apply(a2, children);
        }
        child = child._next;
      }
      return a2;
    };
    _proto2.tweenTo = function tweenTo(position2, vars) {
      vars = vars || {};
      var tl = this, endTime = _parsePosition(tl, position2), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({
        ease: vars.ease || "none",
        lazy: false,
        immediateRender: false,
        time: endTime,
        overwrite: "auto",
        duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
        onStart: function onStart() {
          tl.pause();
          if (!initted) {
            var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
            tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
            initted = 1;
          }
          _onStart && _onStart.apply(tween, onStartParams || []);
        }
      }, vars));
      return immediateRender ? tween.render(0) : tween;
    };
    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
      return this.tweenTo(toPosition, _setDefaults({
        startAt: {
          time: _parsePosition(this, fromPosition)
        }
      }, vars));
    };
    _proto2.recent = function recent() {
      return this._recent;
    };
    _proto2.nextLabel = function nextLabel(afterTime) {
      if (afterTime === void 0) {
        afterTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, afterTime));
    };
    _proto2.previousLabel = function previousLabel(beforeTime) {
      if (beforeTime === void 0) {
        beforeTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
    };
    _proto2.currentLabel = function currentLabel(value) {
      return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
    };
    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = 0;
      }
      var child = this._first, labels = this.labels, p;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          child._start += amount;
          child._end += amount;
        }
        child = child._next;
      }
      if (adjustLabels) {
        for (p in labels) {
          if (labels[p] >= ignoreBeforeTime) {
            labels[p] += amount;
          }
        }
      }
      return _uncache(this);
    };
    _proto2.invalidate = function invalidate(soft) {
      var child = this._first;
      this._lock = 0;
      while (child) {
        child.invalidate(soft);
        child = child._next;
      }
      return _Animation.prototype.invalidate.call(this, soft);
    };
    _proto2.clear = function clear2(includeLabels) {
      if (includeLabels === void 0) {
        includeLabels = true;
      }
      var child = this._first, next2;
      while (child) {
        next2 = child._next;
        this.remove(child);
        child = next2;
      }
      this._dp && (this._time = this._tTime = this._pTime = 0);
      includeLabels && (this.labels = {});
      return _uncache(this);
    };
    _proto2.totalDuration = function totalDuration(value) {
      var max = 0, self2 = this, child = self2._last, prevStart = _bigNum$1, prev2, start, parent2;
      if (arguments.length) {
        return self2.timeScale((self2._repeat < 0 ? self2.duration() : self2.totalDuration()) / (self2.reversed() ? -value : value));
      }
      if (self2._dirty) {
        parent2 = self2.parent;
        while (child) {
          prev2 = child._prev;
          child._dirty && child.totalDuration();
          start = child._start;
          if (start > prevStart && self2._sort && child._ts && !self2._lock) {
            self2._lock = 1;
            _addToTimeline(self2, child, start - child._delay, 1)._lock = 0;
          } else {
            prevStart = start;
          }
          if (start < 0 && child._ts) {
            max -= start;
            if (!parent2 && !self2._dp || parent2 && parent2.smoothChildTiming) {
              self2._start += start / self2._ts;
              self2._time -= start;
              self2._tTime -= start;
            }
            self2.shiftChildren(-start, false, -Infinity);
            prevStart = 0;
          }
          child._end > max && child._ts && (max = child._end);
          child = prev2;
        }
        _setDuration(self2, self2 === _globalTimeline && self2._time > max ? self2._time : max, 1, 1);
        self2._dirty = 0;
      }
      return self2._tDur;
    };
    Timeline2.updateRoot = function updateRoot(time) {
      if (_globalTimeline._ts) {
        _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
        _lastRenderedFrame = _ticker.frame;
      }
      if (_ticker.frame >= _nextGCFrame) {
        _nextGCFrame += _config.autoSleep || 120;
        var child = _globalTimeline._first;
        if (!child || !child._ts) {
          if (_config.autoSleep && _ticker._listeners.length < 2) {
            while (child && !child._ts) {
              child = child._next;
            }
            child || _ticker.sleep();
          }
        }
      }
    };
    return Timeline2;
  }(Animation);
  _setDefaults(Timeline.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
  });
  var _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop, start, end, setter, stringFilter, funcParam) {
    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index2 = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a2;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (hasRandom = ~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }
    if (stringFilter) {
      a2 = [start, end];
      stringFilter(a2, target, prop);
      start = a2[0];
      end = a2[1];
    }
    startNums = start.match(_complexStringNumExp) || [];
    while (result = _complexStringNumExp.exec(end)) {
      endNum = result[0];
      chunk = end.substring(index2, result.index);
      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(") {
        color = 1;
      }
      if (endNum !== startNums[matchIndex++]) {
        startNum = parseFloat(startNums[matchIndex - 1]) || 0;
        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
          m: color && color < 4 ? Math.round : 0
        };
        index2 = _complexStringNumExp.lastIndex;
      }
    }
    pt.c = index2 < end.length ? end.substring(index2, end.length) : "";
    pt.fp = funcParam;
    if (_relExp.test(end) || hasRandom) {
      pt.e = 0;
    }
    this._pt = pt;
    return pt;
  }, _addPropTween = function _addPropTween2(target, prop, start, end, index2, targets, modifier, stringFilter, funcParam, optional) {
    _isFunction(end) && (end = end(index2 || 0, target, targets));
    var currentValue = target[prop], parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;
    if (_isString(end)) {
      if (~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }
      if (end.charAt(1) === "=") {
        pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
        if (pt || pt === 0) {
          end = pt;
        }
      }
    }
    if (!optional || parsedStart !== end || _forceAllPropTweens) {
      if (!isNaN(parsedStart * end) && end !== "") {
        pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
        funcParam && (pt.fp = funcParam);
        modifier && pt.modifier(modifier, this, target);
        return this._pt = pt;
      }
      !currentValue && !(prop in target) && _missingPlugin(prop, end);
      return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
    }
  }, _processVars = function _processVars2(vars, index2, target, targets, tween) {
    _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index2, target, targets));
    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
      return _isString(vars) ? _parseFuncOrString(vars, tween, index2, target, targets) : vars;
    }
    var copy = {}, p;
    for (p in vars) {
      copy[p] = _parseFuncOrString(vars[p], tween, index2, target, targets);
    }
    return copy;
  }, _checkPlugin = function _checkPlugin2(property2, vars, tween, index2, target, targets) {
    var plugin, pt, ptLookup, i2;
    if (_plugins[property2] && (plugin = new _plugins[property2]()).init(target, plugin.rawVars ? vars[property2] : _processVars(vars[property2], index2, target, targets, tween), tween, index2, targets) !== false) {
      tween._pt = pt = new PropTween(tween._pt, target, property2, 0, 1, plugin.render, plugin, 0, plugin.priority);
      if (tween !== _quickTween) {
        ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
        i2 = plugin._props.length;
        while (i2--) {
          ptLookup[plugin._props[i2]] = pt;
        }
      }
    }
    return plugin;
  }, _overwritingTween, _forceAllPropTweens, _initTween = function _initTween2(tween, time, tTime) {
    var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent2 = tween.parent, fullTargets = parent2 && parent2.data === "nested" ? parent2.vars.targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i2, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index2, harnessVars, overwritten;
    tl && (!keyframes || !ease) && (ease = "none");
    tween._ease = _parseEase(ease, _defaults.ease);
    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
    if (yoyoEase && tween._yoyo && !tween._repeat) {
      yoyoEase = tween._yEase;
      tween._yEase = tween._ease;
      tween._ease = yoyoEase;
    }
    tween._from = !tl && !!vars.runBackwards;
    if (!tl || keyframes && !vars.stagger) {
      harness = targets[0] ? _getCache(targets[0]).harness : 0;
      harnessVars = harness && vars[harness.prop];
      cleanVars = _copyExcluding(vars, _reservedProps);
      if (prevStartAt) {
        prevStartAt._zTime < 0 && prevStartAt.progress(1);
        time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
        prevStartAt._lazy = 0;
      }
      if (startAt) {
        _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
          data: "isStart",
          overwrite: false,
          parent: parent2,
          immediateRender: true,
          lazy: !prevStartAt && _isNotFalse(lazy),
          startAt: null,
          delay: 0,
          onUpdate: onUpdate && function() {
            return _callback(tween, "onUpdate");
          },
          stagger: 0
        }, startAt)));
        tween._startAt._dp = 0;
        tween._startAt._sat = tween;
        time < 0 && (_reverting$1 || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
        if (immediateRender) {
          if (dur && time <= 0 && tTime <= 0) {
            time && (tween._zTime = time);
            return;
          }
        }
      } else if (runBackwards && dur) {
        if (!prevStartAt) {
          time && (immediateRender = false);
          p = _setDefaults({
            overwrite: false,
            data: "isFromStart",
            //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
            lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
            immediateRender,
            //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
            stagger: 0,
            parent: parent2
            //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
          }, cleanVars);
          harnessVars && (p[harness.prop] = harnessVars);
          _removeFromParent(tween._startAt = Tween.set(targets, p));
          tween._startAt._dp = 0;
          tween._startAt._sat = tween;
          time < 0 && (_reverting$1 ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
          tween._zTime = time;
          if (!immediateRender) {
            _initTween2(tween._startAt, _tinyNum, _tinyNum);
          } else if (!time) {
            return;
          }
        }
      }
      tween._pt = tween._ptCache = 0;
      lazy = dur && _isNotFalse(lazy) || lazy && !dur;
      for (i2 = 0; i2 < targets.length; i2++) {
        target = targets[i2];
        gsData = target._gsap || _harness(targets)[i2]._gsap;
        tween._ptLookup[i2] = ptLookup = {};
        _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
        index2 = fullTargets === targets ? i2 : fullTargets.indexOf(target);
        if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index2, fullTargets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
          plugin._props.forEach(function(name2) {
            ptLookup[name2] = pt;
          });
          plugin.priority && (hasPriority = 1);
        }
        if (!harness || harnessVars) {
          for (p in cleanVars) {
            if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index2, target, fullTargets))) {
              plugin.priority && (hasPriority = 1);
            } else {
              ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index2, fullTargets, 0, vars.stringFilter);
            }
          }
        }
        tween._op && tween._op[i2] && tween.kill(target, tween._op[i2]);
        if (autoOverwrite && tween._pt) {
          _overwritingTween = tween;
          _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
          overwritten = !tween.parent;
          _overwritingTween = 0;
        }
        tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
      }
      hasPriority && _sortPropTweensByPriority(tween);
      tween._onInit && tween._onInit(tween);
    }
    tween._onUpdate = onUpdate;
    tween._initted = (!tween._op || tween._pt) && !overwritten;
    keyframes && time <= 0 && tl.render(_bigNum$1, true, true);
  }, _updatePropTweens = function _updatePropTweens2(tween, property2, value, start, startIsRelative, ratio, time, skipRecursion) {
    var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property2], pt, rootPT, lookup, i2;
    if (!ptCache) {
      ptCache = tween._ptCache[property2] = [];
      lookup = tween._ptLookup;
      i2 = tween._targets.length;
      while (i2--) {
        pt = lookup[i2][property2];
        if (pt && pt.d && pt.d._pt) {
          pt = pt.d._pt;
          while (pt && pt.p !== property2 && pt.fp !== property2) {
            pt = pt._next;
          }
        }
        if (!pt) {
          _forceAllPropTweens = 1;
          tween.vars[property2] = "+=0";
          _initTween(tween, time);
          _forceAllPropTweens = 0;
          return skipRecursion ? _warn(property2 + " not eligible for reset") : 1;
        }
        ptCache.push(pt);
      }
    }
    i2 = ptCache.length;
    while (i2--) {
      rootPT = ptCache[i2];
      pt = rootPT._pt || rootPT;
      pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
      pt.c = value - pt.s;
      rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
      rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
    }
  }, _addAliasesToVars = function _addAliasesToVars2(targets, vars) {
    var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p, i2, aliases;
    if (!propertyAliases) {
      return vars;
    }
    copy = _merge({}, vars);
    for (p in propertyAliases) {
      if (p in copy) {
        aliases = propertyAliases[p].split(",");
        i2 = aliases.length;
        while (i2--) {
          copy[aliases[i2]] = copy[p];
        }
      }
    }
    return copy;
  }, _parseKeyframe = function _parseKeyframe2(prop, obj, allProps, easeEach) {
    var ease = obj.ease || easeEach || "power1.inOut", p, a2;
    if (_isArray(obj)) {
      a2 = allProps[prop] || (allProps[prop] = []);
      obj.forEach(function(value, i2) {
        return a2.push({
          t: i2 / (obj.length - 1) * 100,
          v: value,
          e: ease
        });
      });
    } else {
      for (p in obj) {
        a2 = allProps[p] || (allProps[p] = []);
        p === "ease" || a2.push({
          t: parseFloat(prop),
          v: obj[p],
          e: ease
        });
      }
    }
  }, _parseFuncOrString = function _parseFuncOrString2(value, tween, i2, target, targets) {
    return _isFunction(value) ? value.call(tween, i2, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
  }, _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", _staggerPropsToSkip = {};
  _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name2) {
    return _staggerPropsToSkip[name2] = 1;
  });
  var Tween = /* @__PURE__ */ function(_Animation2) {
    _inheritsLoose(Tween2, _Animation2);
    function Tween2(targets, vars, position2, skipInherit) {
      var _this3;
      if (typeof vars === "number") {
        position2.duration = vars;
        vars = position2;
        position2 = null;
      }
      _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
      var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay2 = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults2 = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent2 = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets), tl, i2, copy, l2, p, curTarget, staggerFunc, staggerVarsToMerge;
      _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://gsap.com", !_config.nullTargetWarn) || [];
      _this3._ptLookup = [];
      _this3._overwrite = overwrite;
      if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay2)) {
        vars = _this3.vars;
        tl = _this3.timeline = new Timeline({
          data: "nested",
          defaults: defaults2 || {},
          targets: parent2 && parent2.data === "nested" ? parent2.vars.targets : parsedTargets
        });
        tl.kill();
        tl.parent = tl._dp = _assertThisInitialized(_this3);
        tl._start = 0;
        if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay2)) {
          l2 = parsedTargets.length;
          staggerFunc = stagger && distribute(stagger);
          if (_isObject(stagger)) {
            for (p in stagger) {
              if (~_staggerTweenProps.indexOf(p)) {
                staggerVarsToMerge || (staggerVarsToMerge = {});
                staggerVarsToMerge[p] = stagger[p];
              }
            }
          }
          for (i2 = 0; i2 < l2; i2++) {
            copy = _copyExcluding(vars, _staggerPropsToSkip);
            copy.stagger = 0;
            yoyoEase && (copy.yoyoEase = yoyoEase);
            staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
            curTarget = parsedTargets[i2];
            copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i2, curTarget, parsedTargets);
            copy.delay = (+_parseFuncOrString(delay2, _assertThisInitialized(_this3), i2, curTarget, parsedTargets) || 0) - _this3._delay;
            if (!stagger && l2 === 1 && copy.delay) {
              _this3._delay = delay2 = copy.delay;
              _this3._start += delay2;
              copy.delay = 0;
            }
            tl.to(curTarget, copy, staggerFunc ? staggerFunc(i2, curTarget, parsedTargets) : 0);
            tl._ease = _easeMap.none;
          }
          tl.duration() ? duration = delay2 = 0 : _this3.timeline = 0;
        } else if (keyframes) {
          _inheritDefaults(_setDefaults(tl.vars.defaults, {
            ease: "none"
          }));
          tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
          var time = 0, a2, kf, v2;
          if (_isArray(keyframes)) {
            keyframes.forEach(function(frame) {
              return tl.to(parsedTargets, frame, ">");
            });
            tl.duration();
          } else {
            copy = {};
            for (p in keyframes) {
              p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
            }
            for (p in copy) {
              a2 = copy[p].sort(function(a3, b2) {
                return a3.t - b2.t;
              });
              time = 0;
              for (i2 = 0; i2 < a2.length; i2++) {
                kf = a2[i2];
                v2 = {
                  ease: kf.e,
                  duration: (kf.t - (i2 ? a2[i2 - 1].t : 0)) / 100 * duration
                };
                v2[p] = kf.v;
                tl.to(parsedTargets, v2, time);
                time += v2.duration;
              }
            }
            tl.duration() < duration && tl.to({}, {
              duration: duration - tl.duration()
            });
          }
        }
        duration || _this3.duration(duration = tl.duration());
      } else {
        _this3.timeline = 0;
      }
      if (overwrite === true && !_suppressOverwrites) {
        _overwritingTween = _assertThisInitialized(_this3);
        _globalTimeline.killTweensOf(parsedTargets);
        _overwritingTween = 0;
      }
      _addToTimeline(parent2, _assertThisInitialized(_this3), position2);
      vars.reversed && _this3.reverse();
      vars.paused && _this3.paused(true);
      if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent2._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent2.data !== "nested") {
        _this3._tTime = -_tinyNum;
        _this3.render(Math.max(0, -delay2) || 0);
      }
      scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
      return _this3;
    }
    var _proto3 = Tween2.prototype;
    _proto3.render = function render4(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline2, yoyoEase;
      if (!dur) {
        _renderZeroDurationTween(this, totalTime, suppressEvents, force);
      } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
        time = tTime;
        timeline2 = this.timeline;
        if (this._repeat) {
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && isNegative) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time = dur;
          } else {
            iteration = ~~(tTime / cycleDuration);
            if (iteration && iteration === _roundPrecise(tTime / cycleDuration)) {
              time = dur;
              iteration--;
            }
            time > dur && (time = dur);
          }
          isYoyo = this._yoyo && iteration & 1;
          if (isYoyo) {
            yoyoEase = this._yEase;
            time = dur - time;
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          if (time === prevTime && !force && this._initted && iteration === prevIteration) {
            this._tTime = tTime;
            return this;
          }
          if (iteration !== prevIteration) {
            timeline2 && this._yEase && _propagateYoyoEase(timeline2, isYoyo);
            if (this.vars.repeatRefresh && !isYoyo && !this._lock && this._time !== cycleDuration && this._initted) {
              this._lock = force = 1;
              this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
            }
          }
        }
        if (!this._initted) {
          if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
            this._tTime = 0;
            return this;
          }
          if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
            return this;
          }
          if (dur !== this._dur) {
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._tTime = tTime;
        this._time = time;
        if (!this._act && this._ts) {
          this._act = 1;
          this._lazy = 0;
        }
        this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
        if (this._from) {
          this.ratio = ratio = 1 - ratio;
        }
        if (time && !prevTime && !suppressEvents && !iteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        pt = this._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
        timeline2 && timeline2.render(totalTime < 0 ? totalTime : timeline2._dur * timeline2._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
        if (this._onUpdate && !suppressEvents) {
          isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
          _callback(this, "onUpdate");
        }
        this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
        if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
          isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
          (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
          if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
            _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }
      return this;
    };
    _proto3.targets = function targets() {
      return this._targets;
    };
    _proto3.invalidate = function invalidate(soft) {
      (!soft || !this.vars.runBackwards) && (this._startAt = 0);
      this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
      this._ptLookup = [];
      this.timeline && this.timeline.invalidate(soft);
      return _Animation2.prototype.invalidate.call(this, soft);
    };
    _proto3.resetTo = function resetTo(property2, value, start, startIsRelative, skipRecursion) {
      _tickerActive || _ticker.wake();
      this._ts || this.play();
      var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;
      this._initted || _initTween(this, time);
      ratio = this._ease(time / this._dur);
      if (_updatePropTweens(this, property2, value, start, startIsRelative, ratio, time, skipRecursion)) {
        return this.resetTo(property2, value, start, startIsRelative, 1);
      }
      _alignPlayhead(this, 0);
      this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
      return this.render(0);
    };
    _proto3.kill = function kill(targets, vars) {
      if (vars === void 0) {
        vars = "all";
      }
      if (!targets && (!vars || vars === "all")) {
        this._lazy = this._pt = 0;
        return this.parent ? _interrupt(this) : this;
      }
      if (this.timeline) {
        var tDur = this.timeline.totalDuration();
        this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
        this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
        return this;
      }
      var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i2;
      if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
        vars === "all" && (this._pt = 0);
        return _interrupt(this);
      }
      overwrittenProps = this._op = this._op || [];
      if (vars !== "all") {
        if (_isString(vars)) {
          p = {};
          _forEachName(vars, function(name2) {
            return p[name2] = 1;
          });
          vars = p;
        }
        vars = _addAliasesToVars(parsedTargets, vars);
      }
      i2 = parsedTargets.length;
      while (i2--) {
        if (~killingTargets.indexOf(parsedTargets[i2])) {
          curLookup = propTweenLookup[i2];
          if (vars === "all") {
            overwrittenProps[i2] = vars;
            props = curLookup;
            curOverwriteProps = {};
          } else {
            curOverwriteProps = overwrittenProps[i2] = overwrittenProps[i2] || {};
            props = vars;
          }
          for (p in props) {
            pt = curLookup && curLookup[p];
            if (pt) {
              if (!("kill" in pt.d) || pt.d.kill(p) === true) {
                _removeLinkedListItem(this, pt, "_pt");
              }
              delete curLookup[p];
            }
            if (curOverwriteProps !== "all") {
              curOverwriteProps[p] = 1;
            }
          }
        }
      }
      this._initted && !this._pt && firstPT && _interrupt(this);
      return this;
    };
    Tween2.to = function to(targets, vars) {
      return new Tween2(targets, vars, arguments[2]);
    };
    Tween2.from = function from2(targets, vars) {
      return _createTweenType(1, arguments);
    };
    Tween2.delayedCall = function delayedCall(delay2, callback, params, scope) {
      return new Tween2(callback, 0, {
        immediateRender: false,
        lazy: false,
        overwrite: false,
        delay: delay2,
        onComplete: callback,
        onReverseComplete: callback,
        onCompleteParams: params,
        onReverseCompleteParams: params,
        callbackScope: scope
      });
    };
    Tween2.fromTo = function fromTo(targets, fromVars, toVars) {
      return _createTweenType(2, arguments);
    };
    Tween2.set = function set2(targets, vars) {
      vars.duration = 0;
      vars.repeatDelay || (vars.repeat = 0);
      return new Tween2(targets, vars);
    };
    Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      return _globalTimeline.killTweensOf(targets, props, onlyActive);
    };
    return Tween2;
  }(Animation);
  _setDefaults(Tween.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
  });
  _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name2) {
    Tween[name2] = function() {
      var tl = new Timeline(), params = _slice.call(arguments, 0);
      params.splice(name2 === "staggerFromTo" ? 5 : 4, 0, 0);
      return tl[name2].apply(tl, params);
    };
  });
  var _setterPlain = function _setterPlain2(target, property2, value) {
    return target[property2] = value;
  }, _setterFunc = function _setterFunc2(target, property2, value) {
    return target[property2](value);
  }, _setterFuncWithParam = function _setterFuncWithParam2(target, property2, value, data) {
    return target[property2](data.fp, value);
  }, _setterAttribute = function _setterAttribute2(target, property2, value) {
    return target.setAttribute(property2, value);
  }, _getSetter = function _getSetter2(target, property2) {
    return _isFunction(target[property2]) ? _setterFunc : _isUndefined(target[property2]) && target.setAttribute ? _setterAttribute : _setterPlain;
  }, _renderPlain = function _renderPlain2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
  }, _renderBoolean = function _renderBoolean2(ratio, data) {
    return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
  }, _renderComplexString = function _renderComplexString2(ratio, data) {
    var pt = data._pt, s2 = "";
    if (!ratio && data.b) {
      s2 = data.b;
    } else if (ratio === 1 && data.e) {
      s2 = data.e;
    } else {
      while (pt) {
        s2 = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s2;
        pt = pt._next;
      }
      s2 += data.c;
    }
    data.set(data.t, data.p, s2, data);
  }, _renderPropTweens = function _renderPropTweens2(ratio, data) {
    var pt = data._pt;
    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
  }, _addPluginModifier = function _addPluginModifier2(modifier, tween, target, property2) {
    var pt = this._pt, next2;
    while (pt) {
      next2 = pt._next;
      pt.p === property2 && pt.modifier(modifier, tween, target);
      pt = next2;
    }
  }, _killPropTweensOf = function _killPropTweensOf2(property2) {
    var pt = this._pt, hasNonDependentRemaining, next2;
    while (pt) {
      next2 = pt._next;
      if (pt.p === property2 && !pt.op || pt.op === property2) {
        _removeLinkedListItem(this, pt, "_pt");
      } else if (!pt.dep) {
        hasNonDependentRemaining = 1;
      }
      pt = next2;
    }
    return !hasNonDependentRemaining;
  }, _setterWithModifier = function _setterWithModifier2(target, property2, value, data) {
    data.mSet(target, property2, data.m.call(data.tween, value, data.mt), data);
  }, _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent2) {
    var pt = parent2._pt, next2, pt2, first, last2;
    while (pt) {
      next2 = pt._next;
      pt2 = first;
      while (pt2 && pt2.pr > pt.pr) {
        pt2 = pt2._next;
      }
      if (pt._prev = pt2 ? pt2._prev : last2) {
        pt._prev._next = pt;
      } else {
        first = pt;
      }
      if (pt._next = pt2) {
        pt2._prev = pt;
      } else {
        last2 = pt;
      }
      pt = next2;
    }
    parent2._pt = first;
  };
  var PropTween = /* @__PURE__ */ function() {
    function PropTween2(next2, target, prop, start, change, renderer2, data, setter, priority) {
      this.t = target;
      this.s = start;
      this.c = change;
      this.p = prop;
      this.r = renderer2 || _renderPlain;
      this.d = data || this;
      this.set = setter || _setterPlain;
      this.pr = priority || 0;
      this._next = next2;
      if (next2) {
        next2._prev = this;
      }
    }
    var _proto4 = PropTween2.prototype;
    _proto4.modifier = function modifier(func, tween, target) {
      this.mSet = this.mSet || this.set;
      this.set = _setterWithModifier;
      this.m = func;
      this.mt = target;
      this.tween = tween;
    };
    return PropTween2;
  }();
  _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name2) {
    return _reservedProps[name2] = 1;
  });
  _globals.TweenMax = _globals.TweenLite = Tween;
  _globals.TimelineLite = _globals.TimelineMax = Timeline;
  _globalTimeline = new Timeline({
    sortChildren: false,
    defaults: _defaults,
    autoRemoveChildren: true,
    id: "root",
    smoothChildTiming: true
  });
  _config.stringFilter = _colorStringFilter;
  var _media = [], _listeners = {}, _emptyArray = [], _lastMediaTime = 0, _contextID = 0, _dispatch = function _dispatch2(type4) {
    return (_listeners[type4] || _emptyArray).map(function(f2) {
      return f2();
    });
  }, _onMediaChange = function _onMediaChange2() {
    var time = Date.now(), matches = [];
    if (time - _lastMediaTime > 2) {
      _dispatch("matchMediaInit");
      _media.forEach(function(c2) {
        var queries = c2.queries, conditions = c2.conditions, match2, p, anyMatch, toggled;
        for (p in queries) {
          match2 = _win$1.matchMedia(queries[p]).matches;
          match2 && (anyMatch = 1);
          if (match2 !== conditions[p]) {
            conditions[p] = match2;
            toggled = 1;
          }
        }
        if (toggled) {
          c2.revert();
          anyMatch && matches.push(c2);
        }
      });
      _dispatch("matchMediaRevert");
      matches.forEach(function(c2) {
        return c2.onMatch(c2, function(func) {
          return c2.add(null, func);
        });
      });
      _lastMediaTime = time;
      _dispatch("matchMedia");
    }
  };
  var Context = /* @__PURE__ */ function() {
    function Context2(func, scope) {
      this.selector = scope && selector(scope);
      this.data = [];
      this._r = [];
      this.isReverted = false;
      this.id = _contextID++;
      func && this.add(func);
    }
    var _proto5 = Context2.prototype;
    _proto5.add = function add2(name2, func, scope) {
      if (_isFunction(name2)) {
        scope = func;
        func = name2;
        name2 = _isFunction;
      }
      var self2 = this, f2 = function f3() {
        var prev2 = _context, prevSelector = self2.selector, result;
        prev2 && prev2 !== self2 && prev2.data.push(self2);
        scope && (self2.selector = selector(scope));
        _context = self2;
        result = func.apply(self2, arguments);
        _isFunction(result) && self2._r.push(result);
        _context = prev2;
        self2.selector = prevSelector;
        self2.isReverted = false;
        return result;
      };
      self2.last = f2;
      return name2 === _isFunction ? f2(self2, function(func2) {
        return self2.add(null, func2);
      }) : name2 ? self2[name2] = f2 : f2;
    };
    _proto5.ignore = function ignore(func) {
      var prev2 = _context;
      _context = null;
      func(this);
      _context = prev2;
    };
    _proto5.getTweens = function getTweens() {
      var a2 = [];
      this.data.forEach(function(e2) {
        return e2 instanceof Context2 ? a2.push.apply(a2, e2.getTweens()) : e2 instanceof Tween && !(e2.parent && e2.parent.data === "nested") && a2.push(e2);
      });
      return a2;
    };
    _proto5.clear = function clear2() {
      this._r.length = this.data.length = 0;
    };
    _proto5.kill = function kill(revert, matchMedia2) {
      var _this4 = this;
      if (revert) {
        (function() {
          var tweens = _this4.getTweens(), i3 = _this4.data.length, t2;
          while (i3--) {
            t2 = _this4.data[i3];
            if (t2.data === "isFlip") {
              t2.revert();
              t2.getChildren(true, true, false).forEach(function(tween) {
                return tweens.splice(tweens.indexOf(tween), 1);
              });
            }
          }
          tweens.map(function(t3) {
            return {
              g: t3._dur || t3._delay || t3._sat && !t3._sat.vars.immediateRender ? t3.globalTime(0) : -Infinity,
              t: t3
            };
          }).sort(function(a2, b2) {
            return b2.g - a2.g || -Infinity;
          }).forEach(function(o2) {
            return o2.t.revert(revert);
          });
          i3 = _this4.data.length;
          while (i3--) {
            t2 = _this4.data[i3];
            if (t2 instanceof Timeline) {
              if (t2.data !== "nested") {
                t2.scrollTrigger && t2.scrollTrigger.revert();
                t2.kill();
              }
            } else {
              !(t2 instanceof Tween) && t2.revert && t2.revert(revert);
            }
          }
          _this4._r.forEach(function(f2) {
            return f2(revert, _this4);
          });
          _this4.isReverted = true;
        })();
      } else {
        this.data.forEach(function(e2) {
          return e2.kill && e2.kill();
        });
      }
      this.clear();
      if (matchMedia2) {
        var i2 = _media.length;
        while (i2--) {
          _media[i2].id === this.id && _media.splice(i2, 1);
        }
      }
    };
    _proto5.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    return Context2;
  }();
  var MatchMedia = /* @__PURE__ */ function() {
    function MatchMedia2(scope) {
      this.contexts = [];
      this.scope = scope;
      _context && _context.data.push(this);
    }
    var _proto6 = MatchMedia2.prototype;
    _proto6.add = function add2(conditions, func, scope) {
      _isObject(conditions) || (conditions = {
        matches: conditions
      });
      var context3 = new Context(0, scope || this.scope), cond = context3.conditions = {}, mq, p, active;
      _context && !context3.selector && (context3.selector = _context.selector);
      this.contexts.push(context3);
      func = context3.add("onMatch", func);
      context3.queries = conditions;
      for (p in conditions) {
        if (p === "all") {
          active = 1;
        } else {
          mq = _win$1.matchMedia(conditions[p]);
          if (mq) {
            _media.indexOf(context3) < 0 && _media.push(context3);
            (cond[p] = mq.matches) && (active = 1);
            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
          }
        }
      }
      active && func(context3, function(f2) {
        return context3.add(null, f2);
      });
      return this;
    };
    _proto6.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    _proto6.kill = function kill(revert) {
      this.contexts.forEach(function(c2) {
        return c2.kill(revert, true);
      });
    };
    return MatchMedia2;
  }();
  var _gsap = {
    registerPlugin: function registerPlugin() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      args.forEach(function(config3) {
        return _createPlugin(config3);
      });
    },
    timeline: function timeline(vars) {
      return new Timeline(vars);
    },
    getTweensOf: function getTweensOf(targets, onlyActive) {
      return _globalTimeline.getTweensOf(targets, onlyActive);
    },
    getProperty: function getProperty(target, property2, unit, uncache) {
      _isString(target) && (target = toArray(target)[0]);
      var getter = _getCache(target || {}).get, format2 = unit ? _passThrough : _numericIfPossible;
      unit === "native" && (unit = "");
      return !target ? target : !property2 ? function(property3, unit2, uncache2) {
        return format2((_plugins[property3] && _plugins[property3].get || getter)(target, property3, unit2, uncache2));
      } : format2((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit, uncache));
    },
    quickSetter: function quickSetter(target, property2, unit) {
      target = toArray(target);
      if (target.length > 1) {
        var setters = target.map(function(t2) {
          return gsap.quickSetter(t2, property2, unit);
        }), l2 = setters.length;
        return function(value) {
          var i2 = l2;
          while (i2--) {
            setters[i2](value);
          }
        };
      }
      target = target[0] || {};
      var Plugin = _plugins[property2], cache = _getCache(target), p = cache.harness && (cache.harness.aliases || {})[property2] || property2, setter = Plugin ? function(value) {
        var p2 = new Plugin();
        _quickTween._pt = 0;
        p2.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
        p2.render(1, p2);
        _quickTween._pt && _renderPropTweens(1, _quickTween);
      } : cache.set(target, p);
      return Plugin ? setter : function(value) {
        return setter(target, p, unit ? value + unit : value, cache, 1);
      };
    },
    quickTo: function quickTo(target, property2, vars) {
      var _merge22;
      var tween = gsap.to(target, _merge((_merge22 = {}, _merge22[property2] = "+=0.1", _merge22.paused = true, _merge22), vars || {})), func = function func2(value, start, startIsRelative) {
        return tween.resetTo(property2, value, start, startIsRelative);
      };
      func.tween = tween;
      return func;
    },
    isTweening: function isTweening(targets) {
      return _globalTimeline.getTweensOf(targets, true).length > 0;
    },
    defaults: function defaults(value) {
      value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
      return _mergeDeep(_defaults, value || {});
    },
    config: function config2(value) {
      return _mergeDeep(_config, value || {});
    },
    registerEffect: function registerEffect(_ref3) {
      var name2 = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults2 = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
      (plugins || "").split(",").forEach(function(pluginName) {
        return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name2 + " effect requires " + pluginName + " plugin.");
      });
      _effects[name2] = function(targets, vars, tl) {
        return effect(toArray(targets), _setDefaults(vars || {}, defaults2), tl);
      };
      if (extendTimeline) {
        Timeline.prototype[name2] = function(targets, vars, position2) {
          return this.add(_effects[name2](targets, _isObject(vars) ? vars : (position2 = vars) && {}, this), position2);
        };
      }
    },
    registerEase: function registerEase(name2, ease) {
      _easeMap[name2] = _parseEase(ease);
    },
    parseEase: function parseEase(ease, defaultEase) {
      return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
    },
    getById: function getById(id) {
      return _globalTimeline.getById(id);
    },
    exportRoot: function exportRoot(vars, includeDelayedCalls) {
      if (vars === void 0) {
        vars = {};
      }
      var tl = new Timeline(vars), child, next2;
      tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
      _globalTimeline.remove(tl);
      tl._dp = 0;
      tl._time = tl._tTime = _globalTimeline._time;
      child = _globalTimeline._first;
      while (child) {
        next2 = child._next;
        if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
          _addToTimeline(tl, child, child._start - child._delay);
        }
        child = next2;
      }
      _addToTimeline(_globalTimeline, tl, 0);
      return tl;
    },
    context: function context(func, scope) {
      return func ? new Context(func, scope) : _context;
    },
    matchMedia: function matchMedia(scope) {
      return new MatchMedia(scope);
    },
    matchMediaRefresh: function matchMediaRefresh() {
      return _media.forEach(function(c2) {
        var cond = c2.conditions, found, p;
        for (p in cond) {
          if (cond[p]) {
            cond[p] = false;
            found = 1;
          }
        }
        found && c2.revert();
      }) || _onMediaChange();
    },
    addEventListener: function addEventListener2(type4, callback) {
      var a2 = _listeners[type4] || (_listeners[type4] = []);
      ~a2.indexOf(callback) || a2.push(callback);
    },
    removeEventListener: function removeEventListener2(type4, callback) {
      var a2 = _listeners[type4], i2 = a2 && a2.indexOf(callback);
      i2 >= 0 && a2.splice(i2, 1);
    },
    utils: {
      wrap,
      wrapYoyo,
      distribute,
      random,
      snap,
      normalize,
      getUnit,
      clamp,
      splitColor,
      toArray,
      selector,
      mapRange,
      pipe,
      unitize,
      interpolate,
      shuffle
    },
    install: _install,
    effects: _effects,
    ticker: _ticker,
    updateRoot: Timeline.updateRoot,
    plugins: _plugins,
    globalTimeline: _globalTimeline,
    core: {
      PropTween,
      globals: _addGlobal,
      Tween,
      Timeline,
      Animation,
      getCache: _getCache,
      _removeLinkedListItem,
      reverting: function reverting() {
        return _reverting$1;
      },
      context: function context2(toAdd) {
        if (toAdd && _context) {
          _context.data.push(toAdd);
          toAdd._ctx = _context;
        }
        return _context;
      },
      suppressOverwrites: function suppressOverwrites(value) {
        return _suppressOverwrites = value;
      }
    }
  };
  _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name2) {
    return _gsap[name2] = Tween[name2];
  });
  _ticker.add(Timeline.updateRoot);
  _quickTween = _gsap.to({}, {
    duration: 0
  });
  var _getPluginPropTween = function _getPluginPropTween2(plugin, prop) {
    var pt = plugin._pt;
    while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
      pt = pt._next;
    }
    return pt;
  }, _addModifiers = function _addModifiers2(tween, modifiers) {
    var targets = tween._targets, p, i2, pt;
    for (p in modifiers) {
      i2 = targets.length;
      while (i2--) {
        pt = tween._ptLookup[i2][p];
        if (pt && (pt = pt.d)) {
          if (pt._pt) {
            pt = _getPluginPropTween(pt, p);
          }
          pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i2], p);
        }
      }
    }
  }, _buildModifierPlugin = function _buildModifierPlugin2(name2, modifier) {
    return {
      name: name2,
      rawVars: 1,
      //don't pre-process function-based values or "random()" strings.
      init: function init4(target, vars, tween) {
        tween._onInit = function(tween2) {
          var temp, p;
          if (_isString(vars)) {
            temp = {};
            _forEachName(vars, function(name3) {
              return temp[name3] = 1;
            });
            vars = temp;
          }
          if (modifier) {
            temp = {};
            for (p in vars) {
              temp[p] = modifier(vars[p]);
            }
            vars = temp;
          }
          _addModifiers(tween2, vars);
        };
      }
    };
  };
  var gsap = _gsap.registerPlugin({
    name: "attr",
    init: function init(target, vars, tween, index2, targets) {
      var p, pt, v2;
      this.tween = tween;
      for (p in vars) {
        v2 = target.getAttribute(p) || "";
        pt = this.add(target, "setAttribute", (v2 || 0) + "", vars[p], index2, targets, 0, 0, p);
        pt.op = p;
        pt.b = v2;
        this._props.push(p);
      }
    },
    render: function render2(ratio, data) {
      var pt = data._pt;
      while (pt) {
        _reverting$1 ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
        pt = pt._next;
      }
    }
  }, {
    name: "endArray",
    init: function init2(target, value) {
      var i2 = value.length;
      while (i2--) {
        this.add(target, i2, target[i2] || 0, value[i2], 0, 0, 0, 0, 0, 1);
      }
    }
  }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
  Tween.version = Timeline.version = gsap.version = "3.12.5";
  _coreReady = 1;
  _windowExists$1() && _wake();
  _easeMap.Power0;
  _easeMap.Power1;
  _easeMap.Power2;
  _easeMap.Power3;
  _easeMap.Power4;
  _easeMap.Linear;
  _easeMap.Quad;
  _easeMap.Cubic;
  _easeMap.Quart;
  _easeMap.Quint;
  _easeMap.Strong;
  _easeMap.Elastic;
  _easeMap.Back;
  _easeMap.SteppedEase;
  _easeMap.Bounce;
  _easeMap.Sine;
  _easeMap.Expo;
  _easeMap.Circ;
  /*!
   * CSSPlugin 3.12.5
   * https://gsap.com
   *
   * Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  var _win, _doc, _docElement, _pluginInitted, _tempDiv, _recentSetterPlugin, _reverting, _windowExists2 = function _windowExists3() {
    return typeof window !== "undefined";
  }, _transformProps = {}, _RAD2DEG = 180 / Math.PI, _DEG2RAD = Math.PI / 180, _atan2 = Math.atan2, _bigNum = 1e8, _capsExp = /([A-Z])/g, _horizontalExp = /(left|right|width|margin|padding|x)/i, _complexExp = /[\s,\(]\S/, _propertyAliases = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
  }, _renderCSSProp = function _renderCSSProp2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  }, _renderPropWithEnd = function _renderPropWithEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  }, _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data) {
    return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
  }, _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data) {
    var value = data.s + data.c * ratio;
    data.set(data.t, data.p, ~~(value + (value < 0 ? -0.5 : 0.5)) + data.u, data);
  }, _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data) {
    return data.set(data.t, data.p, ratio ? data.e : data.b, data);
  }, _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
  }, _setterCSSStyle = function _setterCSSStyle2(target, property2, value) {
    return target.style[property2] = value;
  }, _setterCSSProp = function _setterCSSProp2(target, property2, value) {
    return target.style.setProperty(property2, value);
  }, _setterTransform = function _setterTransform2(target, property2, value) {
    return target._gsap[property2] = value;
  }, _setterScale = function _setterScale2(target, property2, value) {
    return target._gsap.scaleX = target._gsap.scaleY = value;
  }, _setterScaleWithRender = function _setterScaleWithRender2(target, property2, value, data, ratio) {
    var cache = target._gsap;
    cache.scaleX = cache.scaleY = value;
    cache.renderTransform(ratio, cache);
  }, _setterTransformWithRender = function _setterTransformWithRender2(target, property2, value, data, ratio) {
    var cache = target._gsap;
    cache[property2] = value;
    cache.renderTransform(ratio, cache);
  }, _transformProp = "transform", _transformOriginProp = _transformProp + "Origin", _saveStyle = function _saveStyle2(property2, isNotCSS) {
    var _this = this;
    var target = this.target, style = target.style, cache = target._gsap;
    if (property2 in _transformProps && style) {
      this.tfm = this.tfm || {};
      if (property2 !== "transform") {
        property2 = _propertyAliases[property2] || property2;
        ~property2.indexOf(",") ? property2.split(",").forEach(function(a2) {
          return _this.tfm[a2] = _get(target, a2);
        }) : this.tfm[property2] = cache.x ? cache[property2] : _get(target, property2);
        property2 === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);
      } else {
        return _propertyAliases.transform.split(",").forEach(function(p) {
          return _saveStyle2.call(_this, p, isNotCSS);
        });
      }
      if (this.props.indexOf(_transformProp) >= 0) {
        return;
      }
      if (cache.svg) {
        this.svgo = target.getAttribute("data-svg-origin");
        this.props.push(_transformOriginProp, isNotCSS, "");
      }
      property2 = _transformProp;
    }
    (style || isNotCSS) && this.props.push(property2, isNotCSS, style[property2]);
  }, _removeIndependentTransforms = function _removeIndependentTransforms2(style) {
    if (style.translate) {
      style.removeProperty("translate");
      style.removeProperty("scale");
      style.removeProperty("rotate");
    }
  }, _revertStyle = function _revertStyle2() {
    var props = this.props, target = this.target, style = target.style, cache = target._gsap, i2, p;
    for (i2 = 0; i2 < props.length; i2 += 3) {
      props[i2 + 1] ? target[props[i2]] = props[i2 + 2] : props[i2 + 2] ? style[props[i2]] = props[i2 + 2] : style.removeProperty(props[i2].substr(0, 2) === "--" ? props[i2] : props[i2].replace(_capsExp, "-$1").toLowerCase());
    }
    if (this.tfm) {
      for (p in this.tfm) {
        cache[p] = this.tfm[p];
      }
      if (cache.svg) {
        cache.renderTransform();
        target.setAttribute("data-svg-origin", this.svgo || "");
      }
      i2 = _reverting();
      if ((!i2 || !i2.isStart) && !style[_transformProp]) {
        _removeIndependentTransforms(style);
        if (cache.zOrigin && style[_transformOriginProp]) {
          style[_transformOriginProp] += " " + cache.zOrigin + "px";
          cache.zOrigin = 0;
          cache.renderTransform();
        }
        cache.uncache = 1;
      }
    }
  }, _getStyleSaver = function _getStyleSaver2(target, properties) {
    var saver = {
      target,
      props: [],
      revert: _revertStyle,
      save: _saveStyle
    };
    target._gsap || gsap.core.getCache(target);
    properties && properties.split(",").forEach(function(p) {
      return saver.save(p);
    });
    return saver;
  }, _supports3D, _createElement = function _createElement2(type4, ns) {
    var e2 = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type4) : _doc.createElement(type4);
    return e2 && e2.style ? e2 : _doc.createElement(type4);
  }, _getComputedProperty = function _getComputedProperty2(target, property2, skipPrefixFallback) {
    var cs = getComputedStyle(target);
    return cs[property2] || cs.getPropertyValue(property2.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property2) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property2) || property2, 1) || "";
  }, _prefixes = "O,Moz,ms,Ms,Webkit".split(","), _checkPropPrefix = function _checkPropPrefix2(property2, element, preferPrefix) {
    var e2 = element || _tempDiv, s2 = e2.style, i2 = 5;
    if (property2 in s2 && !preferPrefix) {
      return property2;
    }
    property2 = property2.charAt(0).toUpperCase() + property2.substr(1);
    while (i2-- && !(_prefixes[i2] + property2 in s2)) {
    }
    return i2 < 0 ? null : (i2 === 3 ? "ms" : i2 >= 0 ? _prefixes[i2] : "") + property2;
  }, _initCore = function _initCore2() {
    if (_windowExists2() && window.document) {
      _win = window;
      _doc = _win.document;
      _docElement = _doc.documentElement;
      _tempDiv = _createElement("div") || {
        style: {}
      };
      _createElement("div");
      _transformProp = _checkPropPrefix(_transformProp);
      _transformOriginProp = _transformProp + "Origin";
      _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
      _supports3D = !!_checkPropPrefix("perspective");
      _reverting = gsap.core.reverting;
      _pluginInitted = 1;
    }
  }, _getBBoxHack = function _getBBoxHack2(swapIfPossible) {
    var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), oldParent = this.parentNode, oldSibling = this.nextSibling, oldCSS = this.style.cssText, bbox;
    _docElement.appendChild(svg);
    svg.appendChild(this);
    this.style.display = "block";
    if (swapIfPossible) {
      try {
        bbox = this.getBBox();
        this._gsapBBox = this.getBBox;
        this.getBBox = _getBBoxHack2;
      } catch (e2) {
      }
    } else if (this._gsapBBox) {
      bbox = this._gsapBBox();
    }
    if (oldParent) {
      if (oldSibling) {
        oldParent.insertBefore(this, oldSibling);
      } else {
        oldParent.appendChild(this);
      }
    }
    _docElement.removeChild(svg);
    this.style.cssText = oldCSS;
    return bbox;
  }, _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {
    var i2 = attributesArray.length;
    while (i2--) {
      if (target.hasAttribute(attributesArray[i2])) {
        return target.getAttribute(attributesArray[i2]);
      }
    }
  }, _getBBox = function _getBBox2(target) {
    var bounds;
    try {
      bounds = target.getBBox();
    } catch (error) {
      bounds = _getBBoxHack.call(target, true);
    }
    bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
    return bounds && !bounds.width && !bounds.x && !bounds.y ? {
      x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
      y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
      width: 0,
      height: 0
    } : bounds;
  }, _isSVG = function _isSVG2(e2) {
    return !!(e2.getCTM && (!e2.parentNode || e2.ownerSVGElement) && _getBBox(e2));
  }, _removeProperty = function _removeProperty2(target, property2) {
    if (property2) {
      var style = target.style, first2Chars;
      if (property2 in _transformProps && property2 !== _transformOriginProp) {
        property2 = _transformProp;
      }
      if (style.removeProperty) {
        first2Chars = property2.substr(0, 2);
        if (first2Chars === "ms" || property2.substr(0, 6) === "webkit") {
          property2 = "-" + property2;
        }
        style.removeProperty(first2Chars === "--" ? property2 : property2.replace(_capsExp, "-$1").toLowerCase());
      } else {
        style.removeAttribute(property2);
      }
    }
  }, _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property2, beginning, end, onlySetAtEnd) {
    var pt = new PropTween(plugin._pt, target, property2, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
    plugin._pt = pt;
    pt.b = beginning;
    pt.e = end;
    plugin._props.push(property2);
    return pt;
  }, _nonConvertibleUnits = {
    deg: 1,
    rad: 1,
    turn: 1
  }, _nonStandardLayouts = {
    grid: 1,
    flex: 1
  }, _convertToUnit = function _convertToUnit2(target, property2, value, unit) {
    var curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property2), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%", px, parent2, cache, isSVG;
    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
      return curValue;
    }
    curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property2, value, "px"));
    isSVG = target.getCTM && _isSVG(target);
    if ((toPercent || curUnit === "%") && (_transformProps[property2] || ~property2.indexOf("adius"))) {
      px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
      return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
    }
    style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
    parent2 = ~property2.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
    if (isSVG) {
      parent2 = (target.ownerSVGElement || {}).parentNode;
    }
    if (!parent2 || parent2 === _doc || !parent2.appendChild) {
      parent2 = _doc.body;
    }
    cache = parent2._gsap;
    if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
      return _round(curValue / cache.width * amount);
    } else {
      if (toPercent && (property2 === "height" || property2 === "width")) {
        var v2 = target.style[property2];
        target.style[property2] = amount + unit;
        px = target[measureProperty];
        v2 ? target.style[property2] = v2 : _removeProperty(target, property2);
      } else {
        (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent2, "display")] && (style.position = _getComputedProperty(target, "position"));
        parent2 === target && (style.position = "static");
        parent2.appendChild(_tempDiv);
        px = _tempDiv[measureProperty];
        parent2.removeChild(_tempDiv);
        style.position = "absolute";
      }
      if (horizontal && toPercent) {
        cache = _getCache(parent2);
        cache.time = _ticker.time;
        cache.width = parent2[measureProperty];
      }
    }
    return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
  }, _get = function _get2(target, property2, unit, uncache) {
    var value;
    _pluginInitted || _initCore();
    if (property2 in _propertyAliases && property2 !== "transform") {
      property2 = _propertyAliases[property2];
      if (~property2.indexOf(",")) {
        property2 = property2.split(",")[0];
      }
    }
    if (_transformProps[property2] && property2 !== "transform") {
      value = _parseTransform(target, uncache);
      value = property2 !== "transformOrigin" ? value[property2] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
    } else {
      value = target.style[property2];
      if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
        value = _specialProps[property2] && _specialProps[property2](target, property2, unit) || _getComputedProperty(target, property2) || _getProperty(target, property2) || (property2 === "opacity" ? 1 : 0);
      }
    }
    return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property2, value, unit) + unit : value;
  }, _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop, start, end) {
    if (!start || start === "none") {
      var p = _checkPropPrefix(prop, target, 1), s2 = p && _getComputedProperty(target, p, 1);
      if (s2 && s2 !== start) {
        prop = p;
        start = s2;
      } else if (prop === "borderColor") {
        start = _getComputedProperty(target, "borderTopColor");
      }
    }
    var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index2 = 0, matchIndex = 0, a2, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (end === "auto") {
      startValue = target.style[prop];
      target.style[prop] = end;
      end = _getComputedProperty(target, prop) || end;
      startValue ? target.style[prop] = startValue : _removeProperty(target, prop);
    }
    a2 = [start, end];
    _colorStringFilter(a2);
    start = a2[0];
    end = a2[1];
    startValues = start.match(_numWithUnitExp) || [];
    endValues = end.match(_numWithUnitExp) || [];
    if (endValues.length) {
      while (result = _numWithUnitExp.exec(end)) {
        endValue = result[0];
        chunk = end.substring(index2, result.index);
        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
          color = 1;
        }
        if (endValue !== (startValue = startValues[matchIndex++] || "")) {
          startNum = parseFloat(startValue) || 0;
          startUnit = startValue.substr((startNum + "").length);
          endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
          endNum = parseFloat(endValue);
          endUnit = endValue.substr((endNum + "").length);
          index2 = _numWithUnitExp.lastIndex - endUnit.length;
          if (!endUnit) {
            endUnit = endUnit || _config.units[prop] || startUnit;
            if (index2 === end.length) {
              end += endUnit;
              pt.e += endUnit;
            }
          }
          if (startUnit !== endUnit) {
            startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
          }
          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
            s: startNum,
            c: endNum - startNum,
            m: color && color < 4 || prop === "zIndex" ? Math.round : 0
          };
        }
      }
      pt.c = index2 < end.length ? end.substring(index2, end.length) : "";
    } else {
      pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
    }
    _relExp.test(end) && (pt.e = 0);
    this._pt = pt;
    return pt;
  }, _keywordToPercent = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
  }, _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value) {
    var split = value.split(" "), x2 = split[0], y2 = split[1] || "50%";
    if (x2 === "top" || x2 === "bottom" || y2 === "left" || y2 === "right") {
      value = x2;
      x2 = y2;
      y2 = value;
    }
    split[0] = _keywordToPercent[x2] || x2;
    split[1] = _keywordToPercent[y2] || y2;
    return split.join(" ");
  }, _renderClearProps = function _renderClearProps2(ratio, data) {
    if (data.tween && data.tween._time === data.tween._dur) {
      var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i2;
      if (props === "all" || props === true) {
        style.cssText = "";
        clearTransforms = 1;
      } else {
        props = props.split(",");
        i2 = props.length;
        while (--i2 > -1) {
          prop = props[i2];
          if (_transformProps[prop]) {
            clearTransforms = 1;
            prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
          }
          _removeProperty(target, prop);
        }
      }
      if (clearTransforms) {
        _removeProperty(target, _transformProp);
        if (cache) {
          cache.svg && target.removeAttribute("transform");
          _parseTransform(target, 1);
          cache.uncache = 1;
          _removeIndependentTransforms(style);
        }
      }
    }
  }, _specialProps = {
    clearProps: function clearProps(plugin, target, property2, endValue, tween) {
      if (tween.data !== "isFromStart") {
        var pt = plugin._pt = new PropTween(plugin._pt, target, property2, 0, 0, _renderClearProps);
        pt.u = endValue;
        pt.pr = -10;
        pt.tween = tween;
        plugin._props.push(property2);
        return 1;
      }
    }
    /* className feature (about 0.4kb gzipped).
    , className(plugin, target, property, endValue, tween) {
    	let _renderClassName = (ratio, data) => {
    			data.css.render(ratio, data.css);
    			if (!ratio || ratio === 1) {
    				let inline = data.rmv,
    					target = data.t,
    					p;
    				target.setAttribute("class", ratio ? data.e : data.b);
    				for (p in inline) {
    					_removeProperty(target, p);
    				}
    			}
    		},
    		_getAllStyles = (target) => {
    			let styles = {},
    				computed = getComputedStyle(target),
    				p;
    			for (p in computed) {
    				if (isNaN(p) && p !== "cssText" && p !== "length") {
    					styles[p] = computed[p];
    				}
    			}
    			_setDefaults(styles, _parseTransform(target, 1));
    			return styles;
    		},
    		startClassList = target.getAttribute("class"),
    		style = target.style,
    		cssText = style.cssText,
    		cache = target._gsap,
    		classPT = cache.classPT,
    		inlineToRemoveAtEnd = {},
    		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
    		changingVars = {},
    		startVars = _getAllStyles(target),
    		transformRelated = /(transform|perspective)/i,
    		endVars, p;
    	if (classPT) {
    		classPT.r(1, classPT.d);
    		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
    	}
    	target.setAttribute("class", data.e);
    	endVars = _getAllStyles(target, true);
    	target.setAttribute("class", startClassList);
    	for (p in endVars) {
    		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
    			changingVars[p] = endVars[p];
    			if (!style[p] && style[p] !== "0") {
    				inlineToRemoveAtEnd[p] = 1;
    			}
    		}
    	}
    	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
    	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
    		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
    	}
    	_parseTransform(target, true); //to clear the caching of transforms
    	data.css = new gsap.plugins.css();
    	data.css.init(target, changingVars, tween);
    	plugin._props.push(...data.css._props);
    	return 1;
    }
    */
  }, _identity2DMatrix = [1, 0, 0, 1, 0, 0], _rotationalProperties = {}, _isNullTransform = function _isNullTransform2(value) {
    return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
  }, _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {
    var matrixString = _getComputedProperty(target, _transformProp);
    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
  }, _getMatrix = function _getMatrix2(target, force2D) {
    var cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent2, nextSibling, temp, addedToDOM;
    if (cache.svg && target.getAttribute("transform")) {
      temp = target.transform.baseVal.consolidate().matrix;
      matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
      return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
      temp = style.display;
      style.display = "block";
      parent2 = target.parentNode;
      if (!parent2 || !target.offsetParent) {
        addedToDOM = 1;
        nextSibling = target.nextElementSibling;
        _docElement.appendChild(target);
      }
      matrix = _getComputedTransformMatrixAsArray(target);
      temp ? style.display = temp : _removeProperty(target, "display");
      if (addedToDOM) {
        nextSibling ? parent2.insertBefore(target, nextSibling) : parent2 ? parent2.appendChild(target) : _docElement.removeChild(target);
      }
    }
    return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
  }, _applySVGOrigin = function _applySVGOrigin2(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
    var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a2 = matrix[0], b2 = matrix[1], c2 = matrix[2], d2 = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x2, y2;
    if (!originIsAbsolute) {
      bounds = _getBBox(target);
      xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
      yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
    } else if (matrix !== _identity2DMatrix && (determinant = a2 * d2 - b2 * c2)) {
      x2 = xOrigin * (d2 / determinant) + yOrigin * (-c2 / determinant) + (c2 * ty - d2 * tx) / determinant;
      y2 = xOrigin * (-b2 / determinant) + yOrigin * (a2 / determinant) - (a2 * ty - b2 * tx) / determinant;
      xOrigin = x2;
      yOrigin = y2;
    }
    if (smooth || smooth !== false && cache.smooth) {
      tx = xOrigin - xOriginOld;
      ty = yOrigin - yOriginOld;
      cache.xOffset = xOffsetOld + (tx * a2 + ty * c2) - tx;
      cache.yOffset = yOffsetOld + (tx * b2 + ty * d2) - ty;
    } else {
      cache.xOffset = cache.yOffset = 0;
    }
    cache.xOrigin = xOrigin;
    cache.yOrigin = yOrigin;
    cache.smooth = !!smooth;
    cache.origin = origin;
    cache.originIsAbsolute = !!originIsAbsolute;
    target.style[_transformOriginProp] = "0px 0px";
    if (pluginToAddPropTweensTo) {
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
    }
    target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
  }, _parseTransform = function _parseTransform2(target, uncache) {
    var cache = target._gsap || new GSCache(target);
    if ("x" in cache && !uncache && !cache.uncache) {
      return cache;
    }
    var style = target.style, invertedScaleX = cache.scaleX < 0, px = "px", deg = "deg", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || "0", x2, y2, z2, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a2, b2, c2, d2, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
    x2 = y2 = z2 = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
    scaleX = scaleY = 1;
    cache.svg = !!(target.getCTM && _isSVG(target));
    if (cs.translate) {
      if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
        style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
      }
      style.scale = style.rotate = style.translate = "none";
    }
    matrix = _getMatrix(target, cache.svg);
    if (cache.svg) {
      if (cache.uncache) {
        t2 = target.getBBox();
        origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
        t1 = "";
      } else {
        t1 = !uncache && target.getAttribute("data-svg-origin");
      }
      _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
    }
    xOrigin = cache.xOrigin || 0;
    yOrigin = cache.yOrigin || 0;
    if (matrix !== _identity2DMatrix) {
      a2 = matrix[0];
      b2 = matrix[1];
      c2 = matrix[2];
      d2 = matrix[3];
      x2 = a12 = matrix[4];
      y2 = a22 = matrix[5];
      if (matrix.length === 6) {
        scaleX = Math.sqrt(a2 * a2 + b2 * b2);
        scaleY = Math.sqrt(d2 * d2 + c2 * c2);
        rotation = a2 || b2 ? _atan2(b2, a2) * _RAD2DEG : 0;
        skewX = c2 || d2 ? _atan2(c2, d2) * _RAD2DEG + rotation : 0;
        skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
        if (cache.svg) {
          x2 -= xOrigin - (xOrigin * a2 + yOrigin * c2);
          y2 -= yOrigin - (xOrigin * b2 + yOrigin * d2);
        }
      } else {
        a32 = matrix[6];
        a42 = matrix[7];
        a13 = matrix[8];
        a23 = matrix[9];
        a33 = matrix[10];
        a43 = matrix[11];
        x2 = matrix[12];
        y2 = matrix[13];
        z2 = matrix[14];
        angle = _atan2(a32, a33);
        rotationX = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a12 * cos + a13 * sin;
          t2 = a22 * cos + a23 * sin;
          t3 = a32 * cos + a33 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a32 * -sin + a33 * cos;
          a43 = a42 * -sin + a43 * cos;
          a12 = t1;
          a22 = t2;
          a32 = t3;
        }
        angle = _atan2(-c2, a33);
        rotationY = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a2 * cos - a13 * sin;
          t2 = b2 * cos - a23 * sin;
          t3 = c2 * cos - a33 * sin;
          a43 = d2 * sin + a43 * cos;
          a2 = t1;
          b2 = t2;
          c2 = t3;
        }
        angle = _atan2(b2, a2);
        rotation = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a2 * cos + b2 * sin;
          t2 = a12 * cos + a22 * sin;
          b2 = b2 * cos - a2 * sin;
          a22 = a22 * cos - a12 * sin;
          a2 = t1;
          a12 = t2;
        }
        if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
          rotationX = rotation = 0;
          rotationY = 180 - rotationY;
        }
        scaleX = _round(Math.sqrt(a2 * a2 + b2 * b2 + c2 * c2));
        scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
        angle = _atan2(a12, a22);
        skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
        perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
      }
      if (cache.svg) {
        t1 = target.getAttribute("transform");
        cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
        t1 && target.setAttribute("transform", t1);
      }
    }
    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
      if (invertedScaleX) {
        scaleX *= -1;
        skewX += rotation <= 0 ? 180 : -180;
        rotation += rotation <= 0 ? 180 : -180;
      } else {
        scaleY *= -1;
        skewX += skewX <= 0 ? 180 : -180;
      }
    }
    uncache = uncache || cache.uncache;
    cache.x = x2 - ((cache.xPercent = x2 && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x2) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
    cache.y = y2 - ((cache.yPercent = y2 && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y2) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
    cache.z = z2 + px;
    cache.scaleX = _round(scaleX);
    cache.scaleY = _round(scaleY);
    cache.rotation = _round(rotation) + deg;
    cache.rotationX = _round(rotationX) + deg;
    cache.rotationY = _round(rotationY) + deg;
    cache.skewX = skewX + deg;
    cache.skewY = skewY + deg;
    cache.transformPerspective = perspective + px;
    if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
      style[_transformOriginProp] = _firstTwoOnly(origin);
    }
    cache.xOffset = cache.yOffset = 0;
    cache.force3D = _config.force3D;
    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
    cache.uncache = 0;
    return cache;
  }, _firstTwoOnly = function _firstTwoOnly2(value) {
    return (value = value.split(" "))[0] + " " + value[1];
  }, _addPxTranslate = function _addPxTranslate2(target, start, value) {
    var unit = getUnit(start);
    return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
  }, _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache) {
    cache.z = "0px";
    cache.rotationY = cache.rotationX = "0deg";
    cache.force3D = 0;
    _renderCSSTransforms(ratio, cache);
  }, _zeroDeg = "0deg", _zeroPx = "0px", _endParenthesis = ") ", _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache) {
    var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x2 = _ref.x, y2 = _ref.y, z2 = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
      var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;
      angle = parseFloat(rotationX) * _DEG2RAD;
      cos = Math.cos(angle);
      x2 = _addPxTranslate(target, x2, a13 * cos * -zOrigin);
      y2 = _addPxTranslate(target, y2, -Math.sin(angle) * -zOrigin);
      z2 = _addPxTranslate(target, z2, a33 * cos * -zOrigin + zOrigin);
    }
    if (transformPerspective !== _zeroPx) {
      transforms += "perspective(" + transformPerspective + _endParenthesis;
    }
    if (xPercent || yPercent) {
      transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
    }
    if (use3D || x2 !== _zeroPx || y2 !== _zeroPx || z2 !== _zeroPx) {
      transforms += z2 !== _zeroPx || use3D ? "translate3d(" + x2 + ", " + y2 + ", " + z2 + ") " : "translate(" + x2 + ", " + y2 + _endParenthesis;
    }
    if (rotation !== _zeroDeg) {
      transforms += "rotate(" + rotation + _endParenthesis;
    }
    if (rotationY !== _zeroDeg) {
      transforms += "rotateY(" + rotationY + _endParenthesis;
    }
    if (rotationX !== _zeroDeg) {
      transforms += "rotateX(" + rotationX + _endParenthesis;
    }
    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
      transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
    }
    if (scaleX !== 1 || scaleY !== 1) {
      transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
    }
    target.style[_transformProp] = transforms || "translate(0, 0)";
  }, _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache) {
    var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x2 = _ref2.x, y2 = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x2), ty = parseFloat(y2), a11, a21, a12, a22, temp;
    rotation = parseFloat(rotation);
    skewX = parseFloat(skewX);
    skewY = parseFloat(skewY);
    if (skewY) {
      skewY = parseFloat(skewY);
      skewX += skewY;
      rotation += skewY;
    }
    if (rotation || skewX) {
      rotation *= _DEG2RAD;
      skewX *= _DEG2RAD;
      a11 = Math.cos(rotation) * scaleX;
      a21 = Math.sin(rotation) * scaleX;
      a12 = Math.sin(rotation - skewX) * -scaleY;
      a22 = Math.cos(rotation - skewX) * scaleY;
      if (skewX) {
        skewY *= _DEG2RAD;
        temp = Math.tan(skewX - skewY);
        temp = Math.sqrt(1 + temp * temp);
        a12 *= temp;
        a22 *= temp;
        if (skewY) {
          temp = Math.tan(skewY);
          temp = Math.sqrt(1 + temp * temp);
          a11 *= temp;
          a21 *= temp;
        }
      }
      a11 = _round(a11);
      a21 = _round(a21);
      a12 = _round(a12);
      a22 = _round(a22);
    } else {
      a11 = scaleX;
      a22 = scaleY;
      a21 = a12 = 0;
    }
    if (tx && !~(x2 + "").indexOf("px") || ty && !~(y2 + "").indexOf("px")) {
      tx = _convertToUnit(target, "x", x2, "px");
      ty = _convertToUnit(target, "y", y2, "px");
    }
    if (xOrigin || yOrigin || xOffset || yOffset) {
      tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
      ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
    }
    if (xPercent || yPercent) {
      temp = target.getBBox();
      tx = _round(tx + xPercent / 100 * temp.width);
      ty = _round(ty + yPercent / 100 * temp.height);
    }
    temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
    target.setAttribute("transform", temp);
    forceCSS && (target.style[_transformProp] = temp);
  }, _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property2, startNum, endValue) {
    var cap = 360, isString2 = _isString(endValue), endNum = parseFloat(endValue) * (isString2 && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + "deg", direction, pt;
    if (isString2) {
      direction = endValue.split("_")[1];
      if (direction === "short") {
        change %= cap;
        if (change !== change % (cap / 2)) {
          change += change < 0 ? cap : -cap;
        }
      }
      if (direction === "cw" && change < 0) {
        change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
      } else if (direction === "ccw" && change > 0) {
        change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
      }
    }
    plugin._pt = pt = new PropTween(plugin._pt, target, property2, startNum, change, _renderPropWithEnd);
    pt.e = finalValue;
    pt.u = "deg";
    plugin._props.push(property2);
    return pt;
  }, _assign = function _assign2(target, source) {
    for (var p in source) {
      target[p] = source[p];
    }
    return target;
  }, _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {
    var startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style, endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;
    if (startCache.svg) {
      startValue = target.getAttribute("transform");
      target.setAttribute("transform", "");
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      _removeProperty(target, _transformProp);
      target.setAttribute("transform", startValue);
    } else {
      startValue = getComputedStyle(target)[_transformProp];
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      style[_transformProp] = startValue;
    }
    for (p in _transformProps) {
      startValue = startCache[p];
      endValue = endCache[p];
      if (startValue !== endValue && exclude.indexOf(p) < 0) {
        startUnit = getUnit(startValue);
        endUnit = getUnit(endValue);
        startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
        endNum = parseFloat(endValue);
        plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
        plugin._pt.u = endUnit || 0;
        plugin._props.push(p);
      }
    }
    _assign(endCache, startCache);
  };
  _forEachName("padding,margin,Width,Radius", function(name2, index2) {
    var t2 = "Top", r2 = "Right", b2 = "Bottom", l2 = "Left", props = (index2 < 3 ? [t2, r2, b2, l2] : [t2 + l2, t2 + r2, b2 + r2, b2 + l2]).map(function(side) {
      return index2 < 2 ? name2 + side : "border" + side + name2;
    });
    _specialProps[index2 > 1 ? "border" + name2 : name2] = function(plugin, target, property2, endValue, tween) {
      var a2, vars;
      if (arguments.length < 4) {
        a2 = props.map(function(prop) {
          return _get(plugin, prop, property2);
        });
        vars = a2.join(" ");
        return vars.split(a2[0]).length === 5 ? a2[0] : vars;
      }
      a2 = (endValue + "").split(" ");
      vars = {};
      props.forEach(function(prop, i2) {
        return vars[prop] = a2[i2] = a2[i2] || a2[(i2 - 1) / 2 | 0];
      });
      plugin.init(target, vars, tween);
    };
  });
  var CSSPlugin = {
    name: "css",
    register: _initCore,
    targetTest: function targetTest(target) {
      return target.style && target.nodeType;
    },
    init: function init3(target, vars, tween, index2, targets) {
      var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type4, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;
      _pluginInitted || _initCore();
      this.styles = this.styles || _getStyleSaver(target);
      inlineProps = this.styles.props;
      this.tween = tween;
      for (p in vars) {
        if (p === "autoRound") {
          continue;
        }
        endValue = vars[p];
        if (_plugins[p] && _checkPlugin(p, vars, tween, index2, target, targets)) {
          continue;
        }
        type4 = typeof endValue;
        specialProp = _specialProps[p];
        if (type4 === "function") {
          endValue = endValue.call(tween, index2, target, targets);
          type4 = typeof endValue;
        }
        if (type4 === "string" && ~endValue.indexOf("random(")) {
          endValue = _replaceRandom(endValue);
        }
        if (specialProp) {
          specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
        } else if (p.substr(0, 2) === "--") {
          startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
          endValue += "";
          _colorExp.lastIndex = 0;
          if (!_colorExp.test(startValue)) {
            startUnit = getUnit(startValue);
            endUnit = getUnit(endValue);
          }
          endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
          this.add(style, "setProperty", startValue, endValue, index2, targets, 0, 0, p);
          props.push(p);
          inlineProps.push(p, 0, style[p]);
        } else if (type4 !== "undefined") {
          if (startAt && p in startAt) {
            startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index2, target, targets) : startAt[p];
            _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
            getUnit(startValue + "") || startValue === "auto" || (startValue += _config.units[p] || getUnit(_get(target, p)) || "");
            (startValue + "").charAt(1) === "=" && (startValue = _get(target, p));
          } else {
            startValue = _get(target, p);
          }
          startNum = parseFloat(startValue);
          relative = type4 === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
          relative && (endValue = endValue.substr(2));
          endNum = parseFloat(endValue);
          if (p in _propertyAliases) {
            if (p === "autoAlpha") {
              if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                startNum = 0;
              }
              inlineProps.push("visibility", 0, style.visibility);
              _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
            }
            if (p !== "scale" && p !== "transform") {
              p = _propertyAliases[p];
              ~p.indexOf(",") && (p = p.split(",")[0]);
            }
          }
          isTransformRelated = p in _transformProps;
          if (isTransformRelated) {
            this.styles.save(p);
            if (!transformPropTween) {
              cache = target._gsap;
              cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
              smooth = vars.smoothOrigin !== false && cache.smooth;
              transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
              transformPropTween.dep = 1;
            }
            if (p === "scale") {
              this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
              this._pt.u = 0;
              props.push("scaleY", p);
              p += "X";
            } else if (p === "transformOrigin") {
              inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
              endValue = _convertKeywordsToPercentages(endValue);
              if (cache.svg) {
                _applySVGOrigin(target, endValue, 0, smooth, 0, this);
              } else {
                endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
              }
              continue;
            } else if (p === "svgOrigin") {
              _applySVGOrigin(target, endValue, 1, smooth, 0, this);
              continue;
            } else if (p in _rotationalProperties) {
              _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
              continue;
            } else if (p === "smoothOrigin") {
              _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
              continue;
            } else if (p === "force3D") {
              cache[p] = endValue;
              continue;
            } else if (p === "transform") {
              _addRawTransformPTs(this, endValue, target);
              continue;
            }
          } else if (!(p in style)) {
            p = _checkPropPrefix(p) || p;
          }
          if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
            startUnit = (startValue + "").substr((startNum + "").length);
            endNum || (endNum = 0);
            endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
            startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
            this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
            this._pt.u = endUnit || 0;
            if (startUnit !== endUnit && endUnit !== "%") {
              this._pt.b = startValue;
              this._pt.r = _renderCSSPropWithBeginning;
            }
          } else if (!(p in style)) {
            if (p in target) {
              this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index2, targets);
            } else if (p !== "parseTransform") {
              _missingPlugin(p, endValue);
              continue;
            }
          } else {
            _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
          }
          isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));
          props.push(p);
        }
      }
      hasPriority && _sortPropTweensByPriority(this);
    },
    render: function render3(ratio, data) {
      if (data.tween._time || !_reverting()) {
        var pt = data._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
      } else {
        data.styles.revert();
      }
    },
    get: _get,
    aliases: _propertyAliases,
    getSetter: function getSetter(target, property2, plugin) {
      var p = _propertyAliases[property2];
      p && p.indexOf(",") < 0 && (property2 = p);
      return property2 in _transformProps && property2 !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property2 === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property2 === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property2]) ? _setterCSSStyle : ~property2.indexOf("-") ? _setterCSSProp : _getSetter(target, property2);
    },
    core: {
      _removeProperty,
      _getMatrix
    }
  };
  gsap.utils.checkPrefix = _checkPropPrefix;
  gsap.core.getStyleSaver = _getStyleSaver;
  (function(positionAndScale, rotation, others, aliases) {
    var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name2) {
      _transformProps[name2] = 1;
    });
    _forEachName(rotation, function(name2) {
      _config.units[name2] = "deg";
      _rotationalProperties[name2] = 1;
    });
    _propertyAliases[all[13]] = positionAndScale + "," + rotation;
    _forEachName(aliases, function(name2) {
      var split = name2.split(":");
      _propertyAliases[split[1]] = all[split[0]];
    });
  })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
  _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name2) {
    _config.units[name2] = "px";
  });
  gsap.registerPlugin(CSSPlugin);
  var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;
  gsapWithCSS.core.Tween;
  function loginFormLeave(cb) {
    return new Promise((resolve2, reject) => {
      try {
        const multiple = 0.8;
        gsapWithCSS.timeline().set(".login-view-content", { transformOrigin: "99% 1%" }).to(".login-view-content", { scale: 0, opacity: 0 }).to(".ai-icon-eye-border", {
          duration: 0.5 * multiple,
          rotation: 180,
          transformOrigin: "48.5% 50.1%"
        }).to(".ai-icon-eye", { duration: 0.5 * multiple, rotateX: 90 }).to(".ai-icon-eye-right", { duration: 0.5 * multiple, rotateX: 0 }).add(() => {
          gsapWithCSS.timeline().to(".ai-icon-eye-right", {
            duration: 0.5 * multiple,
            rotateX: 90,
            delay: 0.3 * multiple
          }).to(
            ".ai-icon-eye-border",
            {
              duration: 0.8 * multiple,
              rotation: 360,
              delay: 0.3 * multiple
            },
            "<"
          ).to(".ai-icon-eye", { duration: 0.5 * multiple, rotateX: 0 }, "<").to(".ai-icon-eye-border", { duration: 0, rotation: 0 }).eventCallback("onComplete", () => {
            cb && cb();
            resolve2();
          });
        });
      } catch (error) {
        console.error(error);
        reject(error);
      }
    });
  }
  function loginFormEnter() {
    gsapWithCSS.timeline().set(".login-view-content", { transformOrigin: "99% 1%" }).to(".login-view-content", { duration: 0, scale: 0, opacity: 0 }).to(".login-view-content", { duration: 0.5, scale: 1, opacity: 1 });
  }
  const viewAnimations = {
    loginFormEnter,
    loginFormLeave
    // 登录页离开动效
  };
  var isVue2 = false;
  function set(target, key2, val) {
    if (Array.isArray(target)) {
      target.length = Math.max(target.length, key2);
      target.splice(key2, 1, val);
      return val;
    }
    target[key2] = val;
    return val;
  }
  function del(target, key2) {
    if (Array.isArray(target)) {
      target.splice(key2, 1);
      return;
    }
    delete target[key2];
  }
  function getDevtoolsGlobalHook() {
    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
  }
  function getTarget() {
    return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {};
  }
  const isProxyAvailable = typeof Proxy === "function";
  const HOOK_SETUP = "devtools-plugin:setup";
  const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
  let supported;
  let perf;
  function isPerformanceSupported() {
    var _a2;
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else if (typeof globalThis !== "undefined" && ((_a2 = globalThis.perf_hooks) === null || _a2 === void 0 ? void 0 : _a2.performance)) {
      supported = true;
      perf = globalThis.perf_hooks.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function now() {
    return isPerformanceSupported() ? perf.now() : Date.now();
  }
  class ApiProxy {
    constructor(plugin, hook) {
      this.target = null;
      this.targetQueue = [];
      this.onQueue = [];
      this.plugin = plugin;
      this.hook = hook;
      const defaultSettings = {};
      if (plugin.settings) {
        for (const id in plugin.settings) {
          const item = plugin.settings[id];
          defaultSettings[id] = item.defaultValue;
        }
      }
      const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
      let currentSettings = Object.assign({}, defaultSettings);
      try {
        const raw = localStorage.getItem(localSettingsSaveId);
        const data = JSON.parse(raw);
        Object.assign(currentSettings, data);
      } catch (e2) {
      }
      this.fallbacks = {
        getSettings() {
          return currentSettings;
        },
        setSettings(value) {
          try {
            localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
          } catch (e2) {
          }
          currentSettings = value;
        },
        now() {
          return now();
        }
      };
      if (hook) {
        hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
          if (pluginId === this.plugin.id) {
            this.fallbacks.setSettings(value);
          }
        });
      }
      this.proxiedOn = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target.on[prop];
          } else {
            return (...args) => {
              this.onQueue.push({
                method: prop,
                args
              });
            };
          }
        }
      });
      this.proxiedTarget = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target[prop];
          } else if (prop === "on") {
            return this.proxiedOn;
          } else if (Object.keys(this.fallbacks).includes(prop)) {
            return (...args) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve: () => {
                }
              });
              return this.fallbacks[prop](...args);
            };
          } else {
            return (...args) => {
              return new Promise((resolve2) => {
                this.targetQueue.push({
                  method: prop,
                  args,
                  resolve: resolve2
                });
              });
            };
          }
        }
      });
    }
    async setRealTarget(target) {
      this.target = target;
      for (const item of this.onQueue) {
        this.target.on[item.method](...item.args);
      }
      for (const item of this.targetQueue) {
        item.resolve(await this.target[item.method](...item.args));
      }
    }
  }
  function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
    const descriptor = pluginDescriptor;
    const target = getTarget();
    const hook = getDevtoolsGlobalHook();
    const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
      hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
    } else {
      const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
      const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
      list.push({
        pluginDescriptor: descriptor,
        setupFn,
        proxy
      });
      if (proxy) {
        setupFn(proxy.proxiedTarget);
      }
    }
  }
  /*!
   * pinia v2.1.7
   * (c) 2023 Eduardo San Martin Morote
   * @license MIT
   */
  let activePinia;
  const setActivePinia = (pinia2) => activePinia = pinia2;
  const piniaSymbol = Symbol("pinia");
  function isPlainObject(o2) {
    return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
  }
  var MutationType;
  (function(MutationType2) {
    MutationType2["direct"] = "direct";
    MutationType2["patchObject"] = "patch object";
    MutationType2["patchFunction"] = "patch function";
  })(MutationType || (MutationType = {}));
  const IS_CLIENT = typeof window !== "undefined";
  const USE_DEVTOOLS = IS_CLIENT;
  const _global = /* @__PURE__ */ (() => typeof window === "object" && window.window === window ? window : typeof self === "object" && self.self === self ? self : typeof global === "object" && global.global === global ? global : typeof globalThis === "object" ? globalThis : { HTMLElement: null })();
  function bom(blob, { autoBom = false } = {}) {
    if (autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
      return new Blob([String.fromCharCode(65279), blob], { type: blob.type });
    }
    return blob;
  }
  function download(url2, name2, opts) {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url2);
    xhr.responseType = "blob";
    xhr.onload = function() {
      saveAs(xhr.response, name2, opts);
    };
    xhr.onerror = function() {
      console.error("could not download file");
    };
    xhr.send();
  }
  function corsEnabled(url2) {
    const xhr = new XMLHttpRequest();
    xhr.open("HEAD", url2, false);
    try {
      xhr.send();
    } catch (e2) {
    }
    return xhr.status >= 200 && xhr.status <= 299;
  }
  function click(node2) {
    try {
      node2.dispatchEvent(new MouseEvent("click"));
    } catch (e2) {
      const evt = document.createEvent("MouseEvents");
      evt.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
      node2.dispatchEvent(evt);
    }
  }
  const _navigator = typeof navigator === "object" ? navigator : { userAgent: "" };
  const isMacOSWebView = /* @__PURE__ */ (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))();
  const saveAs = !IS_CLIENT ? () => {
  } : (
    // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program
    typeof HTMLAnchorElement !== "undefined" && "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : (
      // Use msSaveOrOpenBlob as a second approach
      "msSaveOrOpenBlob" in _navigator ? msSaveAs : (
        // Fallback to using FileReader and a popup
        fileSaverSaveAs
      )
    )
  );
  function downloadSaveAs(blob, name2 = "download", opts) {
    const a2 = document.createElement("a");
    a2.download = name2;
    a2.rel = "noopener";
    if (typeof blob === "string") {
      a2.href = blob;
      if (a2.origin !== location.origin) {
        if (corsEnabled(a2.href)) {
          download(blob, name2, opts);
        } else {
          a2.target = "_blank";
          click(a2);
        }
      } else {
        click(a2);
      }
    } else {
      a2.href = URL.createObjectURL(blob);
      setTimeout(function() {
        URL.revokeObjectURL(a2.href);
      }, 4e4);
      setTimeout(function() {
        click(a2);
      }, 0);
    }
  }
  function msSaveAs(blob, name2 = "download", opts) {
    if (typeof blob === "string") {
      if (corsEnabled(blob)) {
        download(blob, name2, opts);
      } else {
        const a2 = document.createElement("a");
        a2.href = blob;
        a2.target = "_blank";
        setTimeout(function() {
          click(a2);
        });
      }
    } else {
      navigator.msSaveOrOpenBlob(bom(blob, opts), name2);
    }
  }
  function fileSaverSaveAs(blob, name2, opts, popup) {
    popup = popup || open("", "_blank");
    if (popup) {
      popup.document.title = popup.document.body.innerText = "downloading...";
    }
    if (typeof blob === "string")
      return download(blob, name2, opts);
    const force = blob.type === "application/octet-stream";
    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || "safari" in _global;
    const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
    if ((isChromeIOS || force && isSafari || isMacOSWebView) && typeof FileReader !== "undefined") {
      const reader = new FileReader();
      reader.onloadend = function() {
        let url2 = reader.result;
        if (typeof url2 !== "string") {
          popup = null;
          throw new Error("Wrong reader.result type");
        }
        url2 = isChromeIOS ? url2 : url2.replace(/^data:[^;]*;/, "data:attachment/file;");
        if (popup) {
          popup.location.href = url2;
        } else {
          location.assign(url2);
        }
        popup = null;
      };
      reader.readAsDataURL(blob);
    } else {
      const url2 = URL.createObjectURL(blob);
      if (popup)
        popup.location.assign(url2);
      else
        location.href = url2;
      popup = null;
      setTimeout(function() {
        URL.revokeObjectURL(url2);
      }, 4e4);
    }
  }
  function toastMessage(message, type4) {
    const piniaMessage = "🍍 " + message;
    if (typeof __VUE_DEVTOOLS_TOAST__ === "function") {
      __VUE_DEVTOOLS_TOAST__(piniaMessage, type4);
    } else if (type4 === "error") {
      console.error(piniaMessage);
    } else if (type4 === "warn") {
      console.warn(piniaMessage);
    } else {
      console.log(piniaMessage);
    }
  }
  function isPinia(o2) {
    return "_a" in o2 && "install" in o2;
  }
  function checkClipboardAccess() {
    if (!("clipboard" in navigator)) {
      toastMessage(`Your browser doesn't support the Clipboard API`, "error");
      return true;
    }
  }
  function checkNotFocusedError(error) {
    if (error instanceof Error && error.message.toLowerCase().includes("document is not focused")) {
      toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn");
      return true;
    }
    return false;
  }
  async function actionGlobalCopyState(pinia2) {
    if (checkClipboardAccess())
      return;
    try {
      await navigator.clipboard.writeText(JSON.stringify(pinia2.state.value));
      toastMessage("Global state copied to clipboard.");
    } catch (error) {
      if (checkNotFocusedError(error))
        return;
      toastMessage(`Failed to serialize the state. Check the console for more details.`, "error");
      console.error(error);
    }
  }
  async function actionGlobalPasteState(pinia2) {
    if (checkClipboardAccess())
      return;
    try {
      loadStoresState(pinia2, JSON.parse(await navigator.clipboard.readText()));
      toastMessage("Global state pasted from clipboard.");
    } catch (error) {
      if (checkNotFocusedError(error))
        return;
      toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, "error");
      console.error(error);
    }
  }
  async function actionGlobalSaveState(pinia2) {
    try {
      saveAs(new Blob([JSON.stringify(pinia2.state.value)], {
        type: "text/plain;charset=utf-8"
      }), "pinia-state.json");
    } catch (error) {
      toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
      console.error(error);
    }
  }
  let fileInput;
  function getFileOpener() {
    if (!fileInput) {
      fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = ".json";
    }
    function openFile() {
      return new Promise((resolve2, reject) => {
        fileInput.onchange = async () => {
          const files = fileInput.files;
          if (!files)
            return resolve2(null);
          const file = files.item(0);
          if (!file)
            return resolve2(null);
          return resolve2({ text: await file.text(), file });
        };
        fileInput.oncancel = () => resolve2(null);
        fileInput.onerror = reject;
        fileInput.click();
      });
    }
    return openFile;
  }
  async function actionGlobalOpenStateFile(pinia2) {
    try {
      const open2 = getFileOpener();
      const result = await open2();
      if (!result)
        return;
      const { text, file } = result;
      loadStoresState(pinia2, JSON.parse(text));
      toastMessage(`Global state imported from "${file.name}".`);
    } catch (error) {
      toastMessage(`Failed to import the state from JSON. Check the console for more details.`, "error");
      console.error(error);
    }
  }
  function loadStoresState(pinia2, state) {
    for (const key2 in state) {
      const storeState = pinia2.state.value[key2];
      if (storeState) {
        Object.assign(storeState, state[key2]);
      } else {
        pinia2.state.value[key2] = state[key2];
      }
    }
  }
  function formatDisplay(display) {
    return {
      _custom: {
        display
      }
    };
  }
  const PINIA_ROOT_LABEL = "🍍 Pinia (root)";
  const PINIA_ROOT_ID = "_root";
  function formatStoreForInspectorTree(store) {
    return isPinia(store) ? {
      id: PINIA_ROOT_ID,
      label: PINIA_ROOT_LABEL
    } : {
      id: store.$id,
      label: store.$id
    };
  }
  function formatStoreForInspectorState(store) {
    if (isPinia(store)) {
      const storeNames = Array.from(store._s.keys());
      const storeMap = store._s;
      const state2 = {
        state: storeNames.map((storeId) => ({
          editable: true,
          key: storeId,
          value: store.state.value[storeId]
        })),
        getters: storeNames.filter((id) => storeMap.get(id)._getters).map((id) => {
          const store2 = storeMap.get(id);
          return {
            editable: false,
            key: id,
            value: store2._getters.reduce((getters, key2) => {
              getters[key2] = store2[key2];
              return getters;
            }, {})
          };
        })
      };
      return state2;
    }
    const state = {
      state: Object.keys(store.$state).map((key2) => ({
        editable: true,
        key: key2,
        value: store.$state[key2]
      }))
    };
    if (store._getters && store._getters.length) {
      state.getters = store._getters.map((getterName) => ({
        editable: false,
        key: getterName,
        value: store[getterName]
      }));
    }
    if (store._customProperties.size) {
      state.customProperties = Array.from(store._customProperties).map((key2) => ({
        editable: true,
        key: key2,
        value: store[key2]
      }));
    }
    return state;
  }
  function formatEventData(events) {
    if (!events)
      return {};
    if (Array.isArray(events)) {
      return events.reduce((data, event) => {
        data.keys.push(event.key);
        data.operations.push(event.type);
        data.oldValue[event.key] = event.oldValue;
        data.newValue[event.key] = event.newValue;
        return data;
      }, {
        oldValue: {},
        keys: [],
        operations: [],
        newValue: {}
      });
    } else {
      return {
        operation: formatDisplay(events.type),
        key: formatDisplay(events.key),
        oldValue: events.oldValue,
        newValue: events.newValue
      };
    }
  }
  function formatMutationType(type4) {
    switch (type4) {
      case MutationType.direct:
        return "mutation";
      case MutationType.patchFunction:
        return "$patch";
      case MutationType.patchObject:
        return "$patch";
      default:
        return "unknown";
    }
  }
  let isTimelineActive = true;
  const componentStateTypes = [];
  const MUTATIONS_LAYER_ID = "pinia:mutations";
  const INSPECTOR_ID = "pinia";
  const { assign: assign$1 } = Object;
  const getStoreType = (id) => "🍍 " + id;
  function registerPiniaDevtools(app2, pinia2) {
    setupDevtoolsPlugin({
      id: "dev.esm.pinia",
      label: "Pinia 🍍",
      logo: "https://pinia.vuejs.org/logo.svg",
      packageName: "pinia",
      homepage: "https://pinia.vuejs.org",
      componentStateTypes,
      app: app2
    }, (api2) => {
      if (typeof api2.now !== "function") {
        toastMessage("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
      }
      api2.addTimelineLayer({
        id: MUTATIONS_LAYER_ID,
        label: `Pinia 🍍`,
        color: 15064968
      });
      api2.addInspector({
        id: INSPECTOR_ID,
        label: "Pinia 🍍",
        icon: "storage",
        treeFilterPlaceholder: "Search stores",
        actions: [
          {
            icon: "content_copy",
            action: () => {
              actionGlobalCopyState(pinia2);
            },
            tooltip: "Serialize and copy the state"
          },
          {
            icon: "content_paste",
            action: async () => {
              await actionGlobalPasteState(pinia2);
              api2.sendInspectorTree(INSPECTOR_ID);
              api2.sendInspectorState(INSPECTOR_ID);
            },
            tooltip: "Replace the state with the content of your clipboard"
          },
          {
            icon: "save",
            action: () => {
              actionGlobalSaveState(pinia2);
            },
            tooltip: "Save the state as a JSON file"
          },
          {
            icon: "folder_open",
            action: async () => {
              await actionGlobalOpenStateFile(pinia2);
              api2.sendInspectorTree(INSPECTOR_ID);
              api2.sendInspectorState(INSPECTOR_ID);
            },
            tooltip: "Import the state from a JSON file"
          }
        ],
        nodeActions: [
          {
            icon: "restore",
            tooltip: 'Reset the state (with "$reset")',
            action: (nodeId) => {
              const store = pinia2._s.get(nodeId);
              if (!store) {
                toastMessage(`Cannot reset "${nodeId}" store because it wasn't found.`, "warn");
              } else if (typeof store.$reset !== "function") {
                toastMessage(`Cannot reset "${nodeId}" store because it doesn't have a "$reset" method implemented.`, "warn");
              } else {
                store.$reset();
                toastMessage(`Store "${nodeId}" reset.`);
              }
            }
          }
        ]
      });
      api2.on.inspectComponent((payload, ctx) => {
        const proxy = payload.componentInstance && payload.componentInstance.proxy;
        if (proxy && proxy._pStores) {
          const piniaStores = payload.componentInstance.proxy._pStores;
          Object.values(piniaStores).forEach((store) => {
            payload.instanceData.state.push({
              type: getStoreType(store.$id),
              key: "state",
              editable: true,
              value: store._isOptionsAPI ? {
                _custom: {
                  value: toRaw(store.$state),
                  actions: [
                    {
                      icon: "restore",
                      tooltip: "Reset the state of this store",
                      action: () => store.$reset()
                    }
                  ]
                }
              } : (
                // NOTE: workaround to unwrap transferred refs
                Object.keys(store.$state).reduce((state, key2) => {
                  state[key2] = store.$state[key2];
                  return state;
                }, {})
              )
            });
            if (store._getters && store._getters.length) {
              payload.instanceData.state.push({
                type: getStoreType(store.$id),
                key: "getters",
                editable: false,
                value: store._getters.reduce((getters, key2) => {
                  try {
                    getters[key2] = store[key2];
                  } catch (error) {
                    getters[key2] = error;
                  }
                  return getters;
                }, {})
              });
            }
          });
        }
      });
      api2.on.getInspectorTree((payload) => {
        if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
          let stores = [pinia2];
          stores = stores.concat(Array.from(pinia2._s.values()));
          payload.rootNodes = (payload.filter ? stores.filter((store) => "$id" in store ? store.$id.toLowerCase().includes(payload.filter.toLowerCase()) : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase())) : stores).map(formatStoreForInspectorTree);
        }
      });
      api2.on.getInspectorState((payload) => {
        if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
          const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia2 : pinia2._s.get(payload.nodeId);
          if (!inspectedStore) {
            return;
          }
          if (inspectedStore) {
            payload.state = formatStoreForInspectorState(inspectedStore);
          }
        }
      });
      api2.on.editInspectorState((payload, ctx) => {
        if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
          const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia2 : pinia2._s.get(payload.nodeId);
          if (!inspectedStore) {
            return toastMessage(`store "${payload.nodeId}" not found`, "error");
          }
          const { path } = payload;
          if (!isPinia(inspectedStore)) {
            if (path.length !== 1 || !inspectedStore._customProperties.has(path[0]) || path[0] in inspectedStore.$state) {
              path.unshift("$state");
            }
          } else {
            path.unshift("state");
          }
          isTimelineActive = false;
          payload.set(inspectedStore, path, payload.state.value);
          isTimelineActive = true;
        }
      });
      api2.on.editComponentState((payload) => {
        if (payload.type.startsWith("🍍")) {
          const storeId = payload.type.replace(/^🍍\s*/, "");
          const store = pinia2._s.get(storeId);
          if (!store) {
            return toastMessage(`store "${storeId}" not found`, "error");
          }
          const { path } = payload;
          if (path[0] !== "state") {
            return toastMessage(`Invalid path for store "${storeId}":
${path}
Only state can be modified.`);
          }
          path[0] = "$state";
          isTimelineActive = false;
          payload.set(store, path, payload.state.value);
          isTimelineActive = true;
        }
      });
    });
  }
  function addStoreToDevtools(app2, store) {
    if (!componentStateTypes.includes(getStoreType(store.$id))) {
      componentStateTypes.push(getStoreType(store.$id));
    }
    setupDevtoolsPlugin({
      id: "dev.esm.pinia",
      label: "Pinia 🍍",
      logo: "https://pinia.vuejs.org/logo.svg",
      packageName: "pinia",
      homepage: "https://pinia.vuejs.org",
      componentStateTypes,
      app: app2,
      settings: {
        logStoreChanges: {
          label: "Notify about new/deleted stores",
          type: "boolean",
          defaultValue: true
        }
        // useEmojis: {
        //   label: 'Use emojis in messages ⚡️',
        //   type: 'boolean',
        //   defaultValue: true,
        // },
      }
    }, (api2) => {
      const now2 = typeof api2.now === "function" ? api2.now.bind(api2) : Date.now;
      store.$onAction(({ after, onError, name: name2, args }) => {
        const groupId = runningActionId++;
        api2.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            title: "🛫 " + name2,
            subtitle: "start",
            data: {
              store: formatDisplay(store.$id),
              action: formatDisplay(name2),
              args
            },
            groupId
          }
        });
        after((result) => {
          activeAction = void 0;
          api2.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              title: "🛬 " + name2,
              subtitle: "end",
              data: {
                store: formatDisplay(store.$id),
                action: formatDisplay(name2),
                args,
                result
              },
              groupId
            }
          });
        });
        onError((error) => {
          activeAction = void 0;
          api2.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              logType: "error",
              title: "💥 " + name2,
              subtitle: "end",
              data: {
                store: formatDisplay(store.$id),
                action: formatDisplay(name2),
                args,
                error
              },
              groupId
            }
          });
        });
      }, true);
      store._customProperties.forEach((name2) => {
        watch(() => unref(store[name2]), (newValue, oldValue) => {
          api2.notifyComponentUpdate();
          api2.sendInspectorState(INSPECTOR_ID);
          if (isTimelineActive) {
            api2.addTimelineEvent({
              layerId: MUTATIONS_LAYER_ID,
              event: {
                time: now2(),
                title: "Change",
                subtitle: name2,
                data: {
                  newValue,
                  oldValue
                },
                groupId: activeAction
              }
            });
          }
        }, { deep: true });
      });
      store.$subscribe(({ events, type: type4 }, state) => {
        api2.notifyComponentUpdate();
        api2.sendInspectorState(INSPECTOR_ID);
        if (!isTimelineActive)
          return;
        const eventData = {
          time: now2(),
          title: formatMutationType(type4),
          data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),
          groupId: activeAction
        };
        if (type4 === MutationType.patchFunction) {
          eventData.subtitle = "⤵️";
        } else if (type4 === MutationType.patchObject) {
          eventData.subtitle = "🧩";
        } else if (events && !Array.isArray(events)) {
          eventData.subtitle = events.type;
        }
        if (events) {
          eventData.data["rawEvent(s)"] = {
            _custom: {
              display: "DebuggerEvent",
              type: "object",
              tooltip: "raw DebuggerEvent[]",
              value: events
            }
          };
        }
        api2.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: eventData
        });
      }, { detached: true, flush: "sync" });
      const hotUpdate = store._hotUpdate;
      store._hotUpdate = markRaw((newStore) => {
        hotUpdate(newStore);
        api2.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: now2(),
            title: "🔥 " + store.$id,
            subtitle: "HMR update",
            data: {
              store: formatDisplay(store.$id),
              info: formatDisplay(`HMR update`)
            }
          }
        });
        api2.notifyComponentUpdate();
        api2.sendInspectorTree(INSPECTOR_ID);
        api2.sendInspectorState(INSPECTOR_ID);
      });
      const { $dispose } = store;
      store.$dispose = () => {
        $dispose();
        api2.notifyComponentUpdate();
        api2.sendInspectorTree(INSPECTOR_ID);
        api2.sendInspectorState(INSPECTOR_ID);
        api2.getSettings().logStoreChanges && toastMessage(`Disposed "${store.$id}" store 🗑`);
      };
      api2.notifyComponentUpdate();
      api2.sendInspectorTree(INSPECTOR_ID);
      api2.sendInspectorState(INSPECTOR_ID);
      api2.getSettings().logStoreChanges && toastMessage(`"${store.$id}" store installed 🆕`);
    });
  }
  let runningActionId = 0;
  let activeAction;
  function patchActionForGrouping(store, actionNames, wrapWithProxy) {
    const actions = actionNames.reduce((storeActions, actionName) => {
      storeActions[actionName] = toRaw(store)[actionName];
      return storeActions;
    }, {});
    for (const actionName in actions) {
      store[actionName] = function() {
        const _actionId = runningActionId;
        const trackedStore = wrapWithProxy ? new Proxy(store, {
          get(...args) {
            activeAction = _actionId;
            return Reflect.get(...args);
          },
          set(...args) {
            activeAction = _actionId;
            return Reflect.set(...args);
          }
        }) : store;
        activeAction = _actionId;
        const retValue = actions[actionName].apply(trackedStore, arguments);
        activeAction = void 0;
        return retValue;
      };
    }
  }
  function devtoolsPlugin({ app: app2, store, options }) {
    if (store.$id.startsWith("__hot:")) {
      return;
    }
    store._isOptionsAPI = !!options.state;
    patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);
    const originalHotUpdate = store._hotUpdate;
    toRaw(store)._hotUpdate = function(newStore) {
      originalHotUpdate.apply(this, arguments);
      patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);
    };
    addStoreToDevtools(
      app2,
      // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
      store
    );
  }
  function createPinia() {
    const scope = effectScope(true);
    const state = scope.run(() => ref({}));
    let _p = [];
    let toBeInstalled = [];
    const pinia2 = markRaw({
      install(app2) {
        setActivePinia(pinia2);
        {
          pinia2._a = app2;
          app2.provide(piniaSymbol, pinia2);
          app2.config.globalProperties.$pinia = pinia2;
          if (USE_DEVTOOLS) {
            registerPiniaDevtools(app2, pinia2);
          }
          toBeInstalled.forEach((plugin) => _p.push(plugin));
          toBeInstalled = [];
        }
      },
      use(plugin) {
        if (!this._a && !isVue2) {
          toBeInstalled.push(plugin);
        } else {
          _p.push(plugin);
        }
        return this;
      },
      _p,
      // it's actually undefined here
      // @ts-expect-error
      _a: null,
      _e: scope,
      _s: /* @__PURE__ */ new Map(),
      state
    });
    if (USE_DEVTOOLS && typeof Proxy !== "undefined") {
      pinia2.use(devtoolsPlugin);
    }
    return pinia2;
  }
  function patchObject(newState, oldState) {
    for (const key2 in oldState) {
      const subPatch = oldState[key2];
      if (!(key2 in newState)) {
        continue;
      }
      const targetValue = newState[key2];
      if (isPlainObject(targetValue) && isPlainObject(subPatch) && !isRef(subPatch) && !isReactive(subPatch)) {
        newState[key2] = patchObject(targetValue, subPatch);
      } else {
        {
          newState[key2] = subPatch;
        }
      }
    }
    return newState;
  }
  const noop = () => {
  };
  function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
    subscriptions.push(callback);
    const removeSubscription = () => {
      const idx = subscriptions.indexOf(callback);
      if (idx > -1) {
        subscriptions.splice(idx, 1);
        onCleanup();
      }
    };
    if (!detached && getCurrentScope()) {
      onScopeDispose(removeSubscription);
    }
    return removeSubscription;
  }
  function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.slice().forEach((callback) => {
      callback(...args);
    });
  }
  const fallbackRunWithContext = (fn) => fn();
  function mergeReactiveObjects(target, patchToApply) {
    if (target instanceof Map && patchToApply instanceof Map) {
      patchToApply.forEach((value, key2) => target.set(key2, value));
    }
    if (target instanceof Set && patchToApply instanceof Set) {
      patchToApply.forEach(target.add, target);
    }
    for (const key2 in patchToApply) {
      if (!patchToApply.hasOwnProperty(key2))
        continue;
      const subPatch = patchToApply[key2];
      const targetValue = target[key2];
      if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key2) && !isRef(subPatch) && !isReactive(subPatch)) {
        target[key2] = mergeReactiveObjects(targetValue, subPatch);
      } else {
        target[key2] = subPatch;
      }
    }
    return target;
  }
  const skipHydrateSymbol = Symbol("pinia:skipHydration");
  function shouldHydrate(obj) {
    return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
  }
  const { assign } = Object;
  function isComputed(o2) {
    return !!(isRef(o2) && o2.effect);
  }
  function createOptionsStore(id, options, pinia2, hot) {
    const { state, actions, getters } = options;
    const initialState = pinia2.state.value[id];
    let store;
    function setup2() {
      if (!initialState && !hot) {
        {
          pinia2.state.value[id] = state ? state() : {};
        }
      }
      const localState = hot ? (
        // use ref() to unwrap refs inside state TODO: check if this is still necessary
        toRefs(ref(state ? state() : {}).value)
      ) : toRefs(pinia2.state.value[id]);
      return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name2) => {
        if (name2 in localState) {
          console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with "${name2}" in store "${id}".`);
        }
        computedGetters[name2] = markRaw(computed(() => {
          setActivePinia(pinia2);
          const store2 = pinia2._s.get(id);
          return getters[name2].call(store2, store2);
        }));
        return computedGetters;
      }, {}));
    }
    store = createSetupStore(id, setup2, options, pinia2, hot, true);
    return store;
  }
  function createSetupStore($id, setup2, options = {}, pinia2, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign({ actions: {} }, options);
    if (!pinia2._e.active) {
      throw new Error("Pinia destroyed");
    }
    const $subscribeOptions = {
      deep: true
      // flush: 'post',
    };
    {
      $subscribeOptions.onTrigger = (event) => {
        if (isListening) {
          debuggerEvents = event;
        } else if (isListening == false && !store._hotUpdating) {
          if (Array.isArray(debuggerEvents)) {
            debuggerEvents.push(event);
          } else {
            console.error("🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug.");
          }
        }
      };
    }
    let isListening;
    let isSyncListening;
    let subscriptions = [];
    let actionSubscriptions = [];
    let debuggerEvents;
    const initialState = pinia2.state.value[$id];
    if (!isOptionsStore && !initialState && !hot) {
      {
        pinia2.state.value[$id] = {};
      }
    }
    const hotState = ref({});
    let activeListener;
    function $patch(partialStateOrMutator) {
      let subscriptionMutation;
      isListening = isSyncListening = false;
      {
        debuggerEvents = [];
      }
      if (typeof partialStateOrMutator === "function") {
        partialStateOrMutator(pinia2.state.value[$id]);
        subscriptionMutation = {
          type: MutationType.patchFunction,
          storeId: $id,
          events: debuggerEvents
        };
      } else {
        mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
        subscriptionMutation = {
          type: MutationType.patchObject,
          payload: partialStateOrMutator,
          storeId: $id,
          events: debuggerEvents
        };
      }
      const myListenerId = activeListener = Symbol();
      nextTick().then(() => {
        if (activeListener === myListenerId) {
          isListening = true;
        }
      });
      isSyncListening = true;
      triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
    }
    const $reset = isOptionsStore ? function $reset2() {
      const { state } = options;
      const newState = state ? state() : {};
      this.$patch(($state) => {
        assign($state, newState);
      });
    } : (
      /* istanbul ignore next */
      () => {
        throw new Error(`🍍: Store "${$id}" is built using the setup syntax and does not implement $reset().`);
      }
    );
    function $dispose() {
      scope.stop();
      subscriptions = [];
      actionSubscriptions = [];
      pinia2._s.delete($id);
    }
    function wrapAction(name2, action) {
      return function() {
        setActivePinia(pinia2);
        const args = Array.from(arguments);
        const afterCallbackList = [];
        const onErrorCallbackList = [];
        function after(callback) {
          afterCallbackList.push(callback);
        }
        function onError(callback) {
          onErrorCallbackList.push(callback);
        }
        triggerSubscriptions(actionSubscriptions, {
          args,
          name: name2,
          store,
          after,
          onError
        });
        let ret;
        try {
          ret = action.apply(this && this.$id === $id ? this : store, args);
        } catch (error) {
          triggerSubscriptions(onErrorCallbackList, error);
          throw error;
        }
        if (ret instanceof Promise) {
          return ret.then((value) => {
            triggerSubscriptions(afterCallbackList, value);
            return value;
          }).catch((error) => {
            triggerSubscriptions(onErrorCallbackList, error);
            return Promise.reject(error);
          });
        }
        triggerSubscriptions(afterCallbackList, ret);
        return ret;
      };
    }
    const _hmrPayload = /* @__PURE__ */ markRaw({
      actions: {},
      getters: {},
      state: [],
      hotState
    });
    const partialStore = {
      _p: pinia2,
      // _s: scope,
      $id,
      $onAction: addSubscription.bind(null, actionSubscriptions),
      $patch,
      $reset,
      $subscribe(callback, options2 = {}) {
        const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
        const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state) => {
          if (options2.flush === "sync" ? isSyncListening : isListening) {
            callback({
              storeId: $id,
              type: MutationType.direct,
              events: debuggerEvents
            }, state);
          }
        }, assign({}, $subscribeOptions, options2)));
        return removeSubscription;
      },
      $dispose
    };
    const store = reactive(assign(
      {
        _hmrPayload,
        _customProperties: markRaw(/* @__PURE__ */ new Set())
        // devtools custom properties
      },
      partialStore
      // must be added later
      // setupStore
    ));
    pinia2._s.set($id, store);
    const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
    const setupStore = runWithContext(() => pinia2._e.run(() => (scope = effectScope()).run(setup2)));
    for (const key2 in setupStore) {
      const prop = setupStore[key2];
      if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
        if (hot) {
          set(hotState.value, key2, toRef(setupStore, key2));
        } else if (!isOptionsStore) {
          if (initialState && shouldHydrate(prop)) {
            if (isRef(prop)) {
              prop.value = initialState[key2];
            } else {
              mergeReactiveObjects(prop, initialState[key2]);
            }
          }
          {
            pinia2.state.value[$id][key2] = prop;
          }
        }
        {
          _hmrPayload.state.push(key2);
        }
      } else if (typeof prop === "function") {
        const actionValue = hot ? prop : wrapAction(key2, prop);
        {
          setupStore[key2] = actionValue;
        }
        {
          _hmrPayload.actions[key2] = prop;
        }
        optionsForPlugin.actions[key2] = prop;
      } else {
        if (isComputed(prop)) {
          _hmrPayload.getters[key2] = isOptionsStore ? (
            // @ts-expect-error
            options.getters[key2]
          ) : prop;
          if (IS_CLIENT) {
            const getters = setupStore._getters || // @ts-expect-error: same
            (setupStore._getters = markRaw([]));
            getters.push(key2);
          }
        }
      }
    }
    {
      assign(store, setupStore);
      assign(toRaw(store), setupStore);
    }
    Object.defineProperty(store, "$state", {
      get: () => hot ? hotState.value : pinia2.state.value[$id],
      set: (state) => {
        if (hot) {
          throw new Error("cannot set hotState");
        }
        $patch(($state) => {
          assign($state, state);
        });
      }
    });
    {
      store._hotUpdate = markRaw((newStore) => {
        store._hotUpdating = true;
        newStore._hmrPayload.state.forEach((stateKey) => {
          if (stateKey in store.$state) {
            const newStateTarget = newStore.$state[stateKey];
            const oldStateSource = store.$state[stateKey];
            if (typeof newStateTarget === "object" && isPlainObject(newStateTarget) && isPlainObject(oldStateSource)) {
              patchObject(newStateTarget, oldStateSource);
            } else {
              newStore.$state[stateKey] = oldStateSource;
            }
          }
          set(store, stateKey, toRef(newStore.$state, stateKey));
        });
        Object.keys(store.$state).forEach((stateKey) => {
          if (!(stateKey in newStore.$state)) {
            del(store, stateKey);
          }
        });
        isListening = false;
        isSyncListening = false;
        pinia2.state.value[$id] = toRef(newStore._hmrPayload, "hotState");
        isSyncListening = true;
        nextTick().then(() => {
          isListening = true;
        });
        for (const actionName in newStore._hmrPayload.actions) {
          const action = newStore[actionName];
          set(store, actionName, wrapAction(actionName, action));
        }
        for (const getterName in newStore._hmrPayload.getters) {
          const getter = newStore._hmrPayload.getters[getterName];
          const getterValue = isOptionsStore ? (
            // special handling of options api
            computed(() => {
              setActivePinia(pinia2);
              return getter.call(store, store);
            })
          ) : getter;
          set(store, getterName, getterValue);
        }
        Object.keys(store._hmrPayload.getters).forEach((key2) => {
          if (!(key2 in newStore._hmrPayload.getters)) {
            del(store, key2);
          }
        });
        Object.keys(store._hmrPayload.actions).forEach((key2) => {
          if (!(key2 in newStore._hmrPayload.actions)) {
            del(store, key2);
          }
        });
        store._hmrPayload = newStore._hmrPayload;
        store._getters = newStore._getters;
        store._hotUpdating = false;
      });
    }
    if (USE_DEVTOOLS) {
      const nonEnumerable = {
        writable: true,
        configurable: true,
        // avoid warning on devtools trying to display this property
        enumerable: false
      };
      ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((p) => {
        Object.defineProperty(store, p, assign({ value: store[p] }, nonEnumerable));
      });
    }
    pinia2._p.forEach((extender) => {
      if (USE_DEVTOOLS) {
        const extensions = scope.run(() => extender({
          store,
          app: pinia2._a,
          pinia: pinia2,
          options: optionsForPlugin
        }));
        Object.keys(extensions || {}).forEach((key2) => store._customProperties.add(key2));
        assign(store, extensions);
      } else {
        assign(store, scope.run(() => extender({
          store,
          app: pinia2._a,
          pinia: pinia2,
          options: optionsForPlugin
        })));
      }
    });
    if (store.$state && typeof store.$state === "object" && typeof store.$state.constructor === "function" && !store.$state.constructor.toString().includes("[native code]")) {
      console.warn(`[🍍]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${store.$id}".`);
    }
    if (initialState && isOptionsStore && options.hydrate) {
      options.hydrate(store.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store;
  }
  function defineStore(idOrOptions, setup2, setupOptions) {
    let id;
    let options;
    const isSetupStore = typeof setup2 === "function";
    if (typeof idOrOptions === "string") {
      id = idOrOptions;
      options = isSetupStore ? setupOptions : setup2;
    } else {
      options = idOrOptions;
      id = idOrOptions.id;
      if (typeof id !== "string") {
        throw new Error(`[🍍]: "defineStore()" must be passed a store id as its first argument.`);
      }
    }
    function useStore(pinia2, hot) {
      const hasContext = hasInjectionContext();
      pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
      // pinia instance with getActivePinia()
      pinia2 || (hasContext ? inject(piniaSymbol, null) : null);
      if (pinia2)
        setActivePinia(pinia2);
      if (!activePinia) {
        throw new Error(`[🍍]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?
See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.
This will fail in production.`);
      }
      pinia2 = activePinia;
      if (!pinia2._s.has(id)) {
        if (isSetupStore) {
          createSetupStore(id, setup2, options, pinia2);
        } else {
          createOptionsStore(id, options, pinia2);
        }
        {
          useStore._pinia = pinia2;
        }
      }
      const store = pinia2._s.get(id);
      if (hot) {
        const hotId = "__hot:" + id;
        const newStore = isSetupStore ? createSetupStore(hotId, setup2, options, pinia2, true) : createOptionsStore(hotId, assign({}, options), pinia2, true);
        hot._hotUpdate(newStore);
        delete pinia2.state.value[hotId];
        pinia2._s.delete(hotId);
      }
      if (IS_CLIENT) {
        const currentInstance2 = getCurrentInstance();
        if (currentInstance2 && currentInstance2.proxy && // avoid adding stores that are just built for hot module replacement
        !hot) {
          const vm = currentInstance2.proxy;
          const cache = "_pStores" in vm ? vm._pStores : vm._pStores = {};
          cache[id] = store;
        }
      }
      return store;
    }
    useStore.$id = id;
    return useStore;
  }
  const whiteScene = [ScenesEnum.login];
  const useSceneStore = defineStore("scene", {
    state: () => ({
      disableIconClick: false,
      sceneManager: void 0,
      isReady: false
    }),
    getters: {},
    actions: {
      ready(callback) {
        if (!this.isReady) {
          this.isReady = true;
          const userStore = useUserStore();
          this.sceneManager = useSceneManager({
            onChangeSceneBefore: async (from2, to, next2) => {
              if (from2 === ScenesEnum.login) {
                this.disableIconClick = true;
                await viewAnimations.loginFormLeave();
                this.disableIconClick = false;
              }
              const token2 = storageHelper.accessToken.value;
              if (!token2) {
                if (whiteScene.includes(to)) {
                  next2();
                } else {
                  next2(ScenesEnum.login);
                }
              } else {
                if (to === ScenesEnum.login) {
                  next2();
                } else if (userStore.isLogon) {
                  next2();
                } else {
                  try {
                    await userStore.getUserInfo();
                    next2();
                  } catch (error) {
                    console.error("一般是token过期了", error);
                  }
                }
              }
            },
            onChangeScene: (from2, to) => {
              console.log("onChangeScene", from2, "=>", to);
              this.sceneManager.currentScene = to;
              if (to === ScenesEnum.login) {
                viewAnimations.loginFormEnter();
              }
              api$1.config({
                top: "2px",
                getContainer() {
                  const sceneWrapClassNames = {
                    [ScenesEnum.initialValue]: ".ai-initial-container",
                    [ScenesEnum.login]: ".login-view-content",
                    [ScenesEnum.chat]: "#aiModalContainer"
                  };
                  return document.querySelector(sceneWrapClassNames[to]) || document.querySelector("body");
                }
              });
            }
          });
        }
        callback();
      }
    }
  });
  const apiWhiteMap = {
    sendCode: "/admin-api/system/auth/sendRandomCode",
    logout: "/admin-api/system/auth/logout4A",
    refreshToken: "/admin-api/system/auth/refresh-token"
  };
  function mergeParamsToUrl(baseUrl2, params) {
    const url2 = new URL(baseUrl2);
    for (const key2 in params) {
      url2.searchParams.append(key2, params[key2]);
    }
    return url2.toString();
  }
  const showSysError = (str) => {
    api$1.error(str);
  };
  const baseUrl = "http://134.98.6.18:9507";
  const apiWhiteList = Object.values(apiWhiteMap);
  const refreshTokenFuncCall = refreshTokenFunc();
  const toLoginView = () => {
    const { sceneManager } = useSceneStore();
    const userStore = useUserStore();
    userStore.logOut();
    sceneManager == null ? void 0 : sceneManager.changeScene(ScenesEnum.login);
  };
  function request(config3) {
    return new Promise((resolve2, reject) => {
      const headers = {
        "Content-Type": "application/json",
        "tenant-id": "121",
        ...(config3 == null ? void 0 : config3.headers) || {}
      };
      if (!apiWhiteList.includes(config3.url) && storageHelper.accessToken.value) {
        headers["Authorization"] = "Bearer " + storageHelper.accessToken.value;
      }
      let url2 = config3.url.startsWith("http") ? config3.url : baseUrl + config3.url;
      url2 = mergeParamsToUrl(url2, config3.params || {});
      _GM_xmlhttpRequest({
        method: config3.method,
        url: url2,
        headers: {
          ...headers
        },
        data: config3.data ? JSON.stringify(config3.data) : "",
        responseType: config3.responseType || "json",
        onload: async (res) => {
          console.log("GM_xmlhttpRequest onload res", res);
          const response = res == null ? void 0 : res.response;
          if (!response) {
            console.error(res);
            showSysError(res.status + " " + res.statusText || "出错了!");
            reject(res);
            return;
          }
          response.success = response.code === 0;
          response.message = response.msg;
          if (response.success) {
            resolve2(response);
            return;
          }
          if (response.code === 401 || response.msg === "无效的刷新令牌") {
            if (config3.url === apiWhiteMap.refreshToken) {
              toLoginView();
              return reject(response);
            } else if (config3.url === apiWhiteMap.logout) {
              resolve2(response);
            } else {
              const callVals = await refreshTokenFuncCall(() => request(config3));
              if (callVals && callVals.fail) {
                reject(response);
              } else {
                resolve2(callVals);
              }
            }
          } else {
            console.error(response);
            showSysError(`${response.msg || "未知原因"}`);
            reject(response);
          }
        },
        onerror(err) {
          console.error(err);
          showSysError("服务器维护中!");
          reject(err);
        }
      });
    });
  }
  request.get = (config3) => request({
    ...config3,
    method: "get"
  });
  request.post = (config3) => request({
    ...config3,
    method: "post"
  });
  const sendRandomCode = (data) => {
    return request.post({
      url: apiWhiteMap.sendCode,
      data
    });
  };
  const loginBy4A = (data) => {
    return request.post({
      url: "/admin-api/system/auth/loginBy4A",
      data
    });
  };
  const logout4A = () => {
    return request.post({
      url: apiWhiteMap.logout
    });
  };
  const refreshTokenApi = async (params) => {
    const res = await request.post({
      url: apiWhiteMap.refreshToken,
      params
    });
    return res;
  };
  const get4AUserInfo = () => {
    return request.get({
      url: "/admin-api/system/auth/get4AUserInfo"
    });
  };
  const useUserStore = defineStore("user", {
    state: () => ({
      userInfo: void 0
    }),
    getters: {
      isLogon(state) {
        return !!state.userInfo;
      }
    },
    actions: {
      /**
       * 获取用户信息
       */
      async getUserInfo() {
        const res = await get4AUserInfo();
        this.userInfo = res.data;
        return;
      },
      /**
       * 登出
       */
      logOut() {
        logout4A();
        this.$reset();
        clearStorageHelper();
      }
    }
  });
  const _hoisted_1$d = { class: "answer-grey-wrap" };
  const _hoisted_2$b = { class: "answer-content" };
  const _hoisted_3$a = { class: "answer-content-text" };
  const _sfc_main$e = /* @__PURE__ */ defineComponent({
    __name: "ChatModalDetail",
    props: {
      content: { default: "" },
      isQuerying: { type: Boolean }
    },
    setup(__props, { expose: __expose }) {
      useCssVars((_ctx) => ({
        "209caf43": unref(iconImgWidthStr2)
      }));
      const iconImgWidthStr2 = inject("iconImgWidthStr");
      const userStore = useUserStore();
      const watermarkContent = computed(() => {
        var _a2, _b;
        if (!userStore.isLogon) {
          return "";
        }
        return [(_a2 = userStore.userInfo) == null ? void 0 : _a2.realName, (_b = userStore.userInfo) == null ? void 0 : _b.mobile].filter(Boolean).join(" ");
      });
      const answerWrapRef = ref();
      const scrollToBottom = () => {
        var _a2, _b;
        (_b = answerWrapRef.value) == null ? void 0 : _b.scrollTo({
          top: (_a2 = answerWrapRef.value) == null ? void 0 : _a2.scrollHeight
          // behavior: "smooth",
        });
      };
      __expose({
        scrollToBottom
      });
      return (_ctx, _cache) => {
        const _component_a_watermark = resolveComponent("a-watermark");
        return openBlock(), createElementBlock("div", {
          class: "ai-modal-container",
          id: "aiModalContainer",
          onMousedown: withModifiers(() => ({}), ["stop"])
        }, [
          createVNode(_component_a_watermark, {
            content: watermarkContent.value,
            gap: [50, 50]
          }, {
            default: withCtx(() => [
              createVNode(BackgroundImg),
              renderSlot(_ctx.$slots, "header", {}, void 0, true),
              createBaseVNode("div", {
                class: normalizeClass(["answer-wrap ai-scroll", { active: _ctx.isQuerying }]),
                id: "aiAnswerWrap",
                ref_key: "answerWrapRef",
                ref: answerWrapRef
              }, [
                createBaseVNode("div", _hoisted_1$d, [
                  createBaseVNode("div", _hoisted_2$b, [
                    createBaseVNode("span", _hoisted_3$a, toDisplayString(_ctx.content), 1)
                  ])
                ])
              ], 2),
              renderSlot(_ctx.$slots, "footer", {}, void 0, true),
              renderSlot(_ctx.$slots, "drag-bar", {}, void 0, true)
            ]),
            _: 3
          }, 8, ["content"])
        ], 32);
      };
    }
  });
  const ChatModalDetail = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-f564cbb2"]]);
  const _sfc_main$d = {};
  const _hoisted_1$c = {
    width: "12px",
    height: "13px",
    viewBox: "0 0 12 13",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink"
  };
  const _hoisted_2$a = /* @__PURE__ */ createStaticVNode('<g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="AI投诉助手3" transform="translate(-1802, -380)" fill="currentColor"><g id="编组-5" transform="translate(1544, 183)"><g id="编组-7" transform="translate(221, 193)"><path d="M43.4797495,4.94791667 C44.0636007,4.94791667 44.364776,5.50296818 44.2217647,6.24013318 C44.1091331,6.82053793 43.8948206,7.82909484 43.5789576,9.26300802 C43.5118583,9.56768438 43.7359874,9.85788675 44.0386872,9.85788675 L47.2910784,9.85788675 C47.3818641,9.85788675 47.4719992,9.87407251 47.5574862,9.90610166 C47.9657153,10.0579548 48.1773319,10.5231193 48.0301187,10.9448238 L46.7574261,14.5900798 C46.4653239,15.426946 45.6966662,15.984375 44.8354564,15.984375 L38.7088953,15.984375 C38.2748044,15.984375 37.9230769,15.6210039 37.9230769,15.1729191 L37.9230769,10.3368025 C37.9230769,10.0649541 38.133485,9.84310846 38.3965276,9.83738353 L38.7217425,9.83025115 C39.6921816,9.807884 40.60333,9.34814014 41.2113511,8.57405792 C41.7222093,7.92582897 42.0910787,7.06303893 42.3249316,5.9892445 C42.5553076,5.20660342 42.8148735,4.94791667 43.4798983,4.94791667 L43.4797495,4.94791667 Z M44.6235012,8.91598991 C44.8694653,7.78493499 45.0412683,6.96690778 45.1391322,6.46027059 C45.3854664,5.18460364 44.7458634,4 43.4780924,4 C42.334941,4 41.7608395,4.58467513 41.422285,5.75337792 L41.4136069,5.7875219 C41.2104409,6.73288919 40.8997152,7.46581354 40.4883687,7.99016066 C40.0551328,8.54391007 39.4065742,8.87261011 38.7160316,8.88845383 L38.3916505,8.89559493 C37.6183428,8.91271453 37,9.56790563 37,10.37047 L37,15.2124971 C37,16.1996827 37.7712909,17 38.7229703,17 L44.8293502,17 C46.0836694,17 47.2033401,16.1839152 47.6288416,14.9598165 L48.8973898,11.3098959 C49.2201241,10.3811721 48.7562282,9.35679569 47.8610578,9.0219067 C47.6737121,8.95177158 47.4758935,8.91591374 47.2765576,8.91598991 L44.6235012,8.91598991 Z" id="图标_有帮助"></path></g></g></g></g>', 1);
  const _hoisted_3$9 = [
    _hoisted_2$a
  ];
  function _sfc_render$5(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$c, _hoisted_3$9);
  }
  const Help = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$5]]);
  const _sfc_main$c = {};
  const _hoisted_1$b = {
    width: "12px",
    height: "13px",
    viewBox: "0 0 12 13",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink"
  };
  const _hoisted_2$9 = /* @__PURE__ */ createStaticVNode('<g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="AI投诉助手3" transform="translate(-1825, -380)" fill="currentColor"><g id="编组-5" transform="translate(1544, 183)"><g id="编组-7" transform="translate(221, 193)"><path d="M66.4797495,4.94791667 C67.0636007,4.94791667 67.364776,5.50296818 67.2217647,6.24013318 C67.1091331,6.82053793 66.8948206,7.82909484 66.5789576,9.26300802 C66.5118583,9.56768438 66.7359874,9.85788675 67.0386872,9.85788675 L70.2910784,9.85788675 C70.3818641,9.85788675 70.4719992,9.87407251 70.5574862,9.90610166 C70.9657153,10.0579548 71.1773319,10.5231193 71.0301187,10.9448238 L69.7574261,14.5900798 C69.4653239,15.426946 68.6966662,15.984375 67.8354564,15.984375 L61.7088953,15.984375 C61.2748044,15.984375 60.9230769,15.6210039 60.9230769,15.1729191 L60.9230769,10.3368025 C60.9230769,10.0649541 61.133485,9.84310846 61.3965276,9.83738353 L61.7217425,9.83025115 C62.6921816,9.807884 63.60333,9.34814014 64.2113511,8.57405792 C64.7222093,7.92582897 65.0910787,7.06303893 65.3249316,5.9892445 C65.5553076,5.20660342 65.8148735,4.94791667 66.4798983,4.94791667 L66.4797495,4.94791667 Z M67.6235012,8.91598991 C67.8694653,7.78493499 68.0412683,6.96690778 68.1391322,6.46027059 C68.3854664,5.18460364 67.7458634,4 66.4780924,4 C65.334941,4 64.7608395,4.58467513 64.422285,5.75337792 L64.4136069,5.7875219 C64.2104409,6.73288919 63.8997152,7.46581354 63.4883687,7.99016066 C63.0551328,8.54391007 62.4065742,8.87261011 61.7160316,8.88845383 L61.3916505,8.89559493 C60.6183428,8.91271453 60,9.56790563 60,10.37047 L60,15.2124971 C60,16.1996827 60.7712909,17 61.7229703,17 L67.8293502,17 C69.0836694,17 70.2033401,16.1839152 70.6288416,14.9598165 L71.8973898,11.3098959 C72.2201241,10.3811721 71.7562282,9.35679569 70.8610578,9.0219067 C70.6737121,8.95177158 70.4758935,8.91591374 70.2765576,8.91598991 L67.6235012,8.91598991 Z" id="图标_无帮助" transform="translate(66, 10.5) scale(1, -1) translate(-66, -10.5)"></path></g></g></g></g>', 1);
  const _hoisted_3$8 = [
    _hoisted_2$9
  ];
  function _sfc_render$4(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$b, _hoisted_3$8);
  }
  const NotHelp = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$4]]);
  const _sfc_main$b = {};
  const _hoisted_1$a = {
    width: "15px",
    height: "13px",
    viewBox: "0 0 15 13",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink"
  };
  const _hoisted_2$8 = /* @__PURE__ */ createStaticVNode('<g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="AI投诉助手3" transform="translate(-1848, -380)" fill="#333333"><g id="编组-5" transform="translate(1544, 183)"><g id="编组-7" transform="translate(221, 193)"><path d="M90.4990555,15.9720779 C87.5959126,15.9720779 85.2361427,13.5164632 85.2361427,10.5000086 L85.2361427,10.4938753 L86.4856704,10.4796101 L85.000802,7.37949383 L83,10.4979756 L84.2495278,10.4979756 C84.2475228,14.1446321 87.2310624,17 90.4990555,17 C91.9702042,17 93.3256295,16.467725 94.3947122,15.5805254 C94.6241541,15.3887893 94.6418341,15.0318317 94.4339329,14.8156827 C94.25541,14.6300627 93.9729614,14.6137818 93.7767751,14.7769186 C92.8764391,15.5254114 91.7367525,15.9720779 90.4990555,15.9720779 M90.4990555,4 C89.0808473,4 87.7724802,4.49357973 86.7210774,5.325717 C86.4837318,5.51335276 86.4621082,5.87635757 86.6740192,6.09664137 C86.8485985,6.27814377 87.1251649,6.29852511 87.3212849,6.14152165 C88.2040072,5.44397353 89.3064284,5.02792212 90.4970506,5.02792212 C93.2432445,5.02792212 95.506893,7.22860649 95.7402951,10.0206941 C95.7619021,10.2878739 95.7364012,10.5 95.7364012,10.5 L94.5005932,10.5102251 L96.001203,13.6184904 C96.1306462,13.6184904 98,10.4979756 98,10.4979756 L96.748517,10.4979756 C96.7544158,10.1594009 96.7328586,10.0044132 96.7269763,9.93913431 C96.452332,6.61671855 93.7630553,4.00201574 90.4990555,4" id="Fill-1"></path></g></g></g></g>', 1);
  const _hoisted_3$7 = [
    _hoisted_2$8
  ];
  function _sfc_render$3(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$a, _hoisted_3$7);
  }
  const Refresh = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$3]]);
  const _sfc_main$a = {};
  const _hoisted_1$9 = {
    width: "11px",
    height: "12px",
    viewBox: "0 0 11 12",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink"
  };
  const _hoisted_2$7 = /* @__PURE__ */ createStaticVNode('<g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="AI投诉助手3" transform="translate(-1779, -380)" fill="#231916"><g id="编组-5" transform="translate(1544, 183)"><g id="编组-7" transform="translate(221, 193)"><path d="M14.9166517,15.0768537 L21.333393,15.0768537 L21.333393,7.69231463 L14.9166517,7.69231463 L14.9166517,15.0768537 Z M22.2500448,7.69231463 L22.2500448,15.0768537 C22.2500448,15.5866719 21.8395844,16 21.333393,16 L14.9166517,16 C14.4104603,16 14,15.5866719 14,15.0768537 L14,7.69231463 C14,7.18249645 14.4104603,6.76925851 14.9166517,6.76925851 L21.333393,6.76925851 C21.8395844,6.76925851 22.2500448,7.18249645 22.2500448,7.69231463 L22.2500448,7.69231463 Z M24.5417189,13.2307415 C24.2886858,13.2307415 24.0833483,13.0239693 24.0833483,12.7691684 L24.0833483,4.92305612 L17.2083259,4.92305612 C16.9550959,4.92305612 16.7500448,4.71628391 16.7500448,4.46157313 C16.7500448,4.20677222 16.9550959,4 17.2083259,4 L24.0833483,4 C24.5896292,4 25,4.41332808 25,4.92305612 L25,12.7691684 C25,13.0239693 24.7949489,13.2307415 24.5417189,13.2307415 L24.5417189,13.2307415 Z" id="图标_复制"></path></g></g></g></g>', 1);
  const _hoisted_3$6 = [
    _hoisted_2$7
  ];
  function _sfc_render$2(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$9, _hoisted_3$6);
  }
  const Copy = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$2]]);
  var clipboard = { exports: {} };
  /*!
   * clipboard.js v2.0.11
   * https://clipboardjs.com/
   *
   * Licensed MIT © Zeno Rocha
   */
  (function(module2, exports2) {
    (function webpackUniversalModuleDefinition(root2, factory) {
      module2.exports = factory();
    })(commonjsGlobal, function() {
      return (
        /******/
        function() {
          var __webpack_modules__ = {
            /***/
            686: (
              /***/
              function(__unused_webpack_module, __webpack_exports__, __webpack_require__2) {
                __webpack_require__2.d(__webpack_exports__, {
                  "default": function() {
                    return (
                      /* binding */
                      clipboard2
                    );
                  }
                });
                var tiny_emitter = __webpack_require__2(279);
                var tiny_emitter_default = /* @__PURE__ */ __webpack_require__2.n(tiny_emitter);
                var listen = __webpack_require__2(370);
                var listen_default = /* @__PURE__ */ __webpack_require__2.n(listen);
                var src_select = __webpack_require__2(817);
                var select_default = /* @__PURE__ */ __webpack_require__2.n(src_select);
                function command(type4) {
                  try {
                    return document.execCommand(type4);
                  } catch (err) {
                    return false;
                  }
                }
                var ClipboardActionCut = function ClipboardActionCut2(target) {
                  var selectedText = select_default()(target);
                  command("cut");
                  return selectedText;
                };
                var actions_cut = ClipboardActionCut;
                function createFakeElement(value) {
                  var isRTL = document.documentElement.getAttribute("dir") === "rtl";
                  var fakeElement = document.createElement("textarea");
                  fakeElement.style.fontSize = "12pt";
                  fakeElement.style.border = "0";
                  fakeElement.style.padding = "0";
                  fakeElement.style.margin = "0";
                  fakeElement.style.position = "absolute";
                  fakeElement.style[isRTL ? "right" : "left"] = "-9999px";
                  var yPosition = window.pageYOffset || document.documentElement.scrollTop;
                  fakeElement.style.top = "".concat(yPosition, "px");
                  fakeElement.setAttribute("readonly", "");
                  fakeElement.value = value;
                  return fakeElement;
                }
                var fakeCopyAction = function fakeCopyAction2(value, options) {
                  var fakeElement = createFakeElement(value);
                  options.container.appendChild(fakeElement);
                  var selectedText = select_default()(fakeElement);
                  command("copy");
                  fakeElement.remove();
                  return selectedText;
                };
                var ClipboardActionCopy = function ClipboardActionCopy2(target) {
                  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                    container: document.body
                  };
                  var selectedText = "";
                  if (typeof target === "string") {
                    selectedText = fakeCopyAction(target, options);
                  } else if (target instanceof HTMLInputElement && !["text", "search", "url", "tel", "password"].includes(target === null || target === void 0 ? void 0 : target.type)) {
                    selectedText = fakeCopyAction(target.value, options);
                  } else {
                    selectedText = select_default()(target);
                    command("copy");
                  }
                  return selectedText;
                };
                var actions_copy = ClipboardActionCopy;
                function _typeof2(obj) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    _typeof2 = function _typeof3(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    _typeof2 = function _typeof3(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return _typeof2(obj);
                }
                var ClipboardActionDefault = function ClipboardActionDefault2() {
                  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  var _options$action = options.action, action = _options$action === void 0 ? "copy" : _options$action, container = options.container, target = options.target, text = options.text;
                  if (action !== "copy" && action !== "cut") {
                    throw new Error('Invalid "action" value, use either "copy" or "cut"');
                  }
                  if (target !== void 0) {
                    if (target && _typeof2(target) === "object" && target.nodeType === 1) {
                      if (action === "copy" && target.hasAttribute("disabled")) {
                        throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                      }
                      if (action === "cut" && (target.hasAttribute("readonly") || target.hasAttribute("disabled"))) {
                        throw new Error(`Invalid "target" attribute. You can't cut text from elements with "readonly" or "disabled" attributes`);
                      }
                    } else {
                      throw new Error('Invalid "target" value, use a valid Element');
                    }
                  }
                  if (text) {
                    return actions_copy(text, {
                      container
                    });
                  }
                  if (target) {
                    return action === "cut" ? actions_cut(target) : actions_copy(target, {
                      container
                    });
                  }
                };
                var actions_default = ClipboardActionDefault;
                function clipboard_typeof(obj) {
                  "@babel/helpers - typeof";
                  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    clipboard_typeof = function _typeof3(obj2) {
                      return typeof obj2;
                    };
                  } else {
                    clipboard_typeof = function _typeof3(obj2) {
                      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    };
                  }
                  return clipboard_typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties(target, props) {
                  for (var i2 = 0; i2 < props.length; i2++) {
                    var descriptor = props[i2];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  return Constructor;
                }
                function _inherits(subClass, superClass) {
                  if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                  }
                  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
                  if (superClass)
                    _setPrototypeOf2(subClass, superClass);
                }
                function _setPrototypeOf2(o2, p) {
                  _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p2) {
                    o3.__proto__ = p2;
                    return o3;
                  };
                  return _setPrototypeOf2(o2, p);
                }
                function _createSuper(Derived) {
                  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
                  return function _createSuperInternal() {
                    var Super = _getPrototypeOf2(Derived), result;
                    if (hasNativeReflectConstruct) {
                      var NewTarget = _getPrototypeOf2(this).constructor;
                      result = Reflect.construct(Super, arguments, NewTarget);
                    } else {
                      result = Super.apply(this, arguments);
                    }
                    return _possibleConstructorReturn(this, result);
                  };
                }
                function _possibleConstructorReturn(self2, call2) {
                  if (call2 && (clipboard_typeof(call2) === "object" || typeof call2 === "function")) {
                    return call2;
                  }
                  return _assertThisInitialized2(self2);
                }
                function _assertThisInitialized2(self2) {
                  if (self2 === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  }
                  return self2;
                }
                function _isNativeReflectConstruct2() {
                  if (typeof Reflect === "undefined" || !Reflect.construct)
                    return false;
                  if (Reflect.construct.sham)
                    return false;
                  if (typeof Proxy === "function")
                    return true;
                  try {
                    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                    }));
                    return true;
                  } catch (e2) {
                    return false;
                  }
                }
                function _getPrototypeOf2(o2) {
                  _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o3) {
                    return o3.__proto__ || Object.getPrototypeOf(o3);
                  };
                  return _getPrototypeOf2(o2);
                }
                function getAttributeValue(suffix, element) {
                  var attribute = "data-clipboard-".concat(suffix);
                  if (!element.hasAttribute(attribute)) {
                    return;
                  }
                  return element.getAttribute(attribute);
                }
                var Clipboard2 = /* @__PURE__ */ function(_Emitter) {
                  _inherits(Clipboard3, _Emitter);
                  var _super = _createSuper(Clipboard3);
                  function Clipboard3(trigger2, options) {
                    var _this;
                    _classCallCheck(this, Clipboard3);
                    _this = _super.call(this);
                    _this.resolveOptions(options);
                    _this.listenClick(trigger2);
                    return _this;
                  }
                  _createClass(Clipboard3, [{
                    key: "resolveOptions",
                    value: function resolveOptions() {
                      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                      this.action = typeof options.action === "function" ? options.action : this.defaultAction;
                      this.target = typeof options.target === "function" ? options.target : this.defaultTarget;
                      this.text = typeof options.text === "function" ? options.text : this.defaultText;
                      this.container = clipboard_typeof(options.container) === "object" ? options.container : document.body;
                    }
                    /**
                     * Adds a click event listener to the passed trigger.
                     * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
                     */
                  }, {
                    key: "listenClick",
                    value: function listenClick(trigger2) {
                      var _this2 = this;
                      this.listener = listen_default()(trigger2, "click", function(e2) {
                        return _this2.onClick(e2);
                      });
                    }
                    /**
                     * Defines a new `ClipboardAction` on each click event.
                     * @param {Event} e
                     */
                  }, {
                    key: "onClick",
                    value: function onClick(e2) {
                      var trigger2 = e2.delegateTarget || e2.currentTarget;
                      var action = this.action(trigger2) || "copy";
                      var text = actions_default({
                        action,
                        container: this.container,
                        target: this.target(trigger2),
                        text: this.text(trigger2)
                      });
                      this.emit(text ? "success" : "error", {
                        action,
                        text,
                        trigger: trigger2,
                        clearSelection: function clearSelection() {
                          if (trigger2) {
                            trigger2.focus();
                          }
                          window.getSelection().removeAllRanges();
                        }
                      });
                    }
                    /**
                     * Default `action` lookup function.
                     * @param {Element} trigger
                     */
                  }, {
                    key: "defaultAction",
                    value: function defaultAction(trigger2) {
                      return getAttributeValue("action", trigger2);
                    }
                    /**
                     * Default `target` lookup function.
                     * @param {Element} trigger
                     */
                  }, {
                    key: "defaultTarget",
                    value: function defaultTarget(trigger2) {
                      var selector3 = getAttributeValue("target", trigger2);
                      if (selector3) {
                        return document.querySelector(selector3);
                      }
                    }
                    /**
                     * Allow fire programmatically a copy action
                     * @param {String|HTMLElement} target
                     * @param {Object} options
                     * @returns Text copied.
                     */
                  }, {
                    key: "defaultText",
                    /**
                     * Default `text` lookup function.
                     * @param {Element} trigger
                     */
                    value: function defaultText(trigger2) {
                      return getAttributeValue("text", trigger2);
                    }
                    /**
                     * Destroy lifecycle.
                     */
                  }, {
                    key: "destroy",
                    value: function destroy() {
                      this.listener.destroy();
                    }
                  }], [{
                    key: "copy",
                    value: function copy(target) {
                      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                        container: document.body
                      };
                      return actions_copy(target, options);
                    }
                    /**
                     * Allow fire programmatically a cut action
                     * @param {String|HTMLElement} target
                     * @returns Text cutted.
                     */
                  }, {
                    key: "cut",
                    value: function cut(target) {
                      return actions_cut(target);
                    }
                    /**
                     * Returns the support of the given action, or all actions if no action is
                     * given.
                     * @param {String} [action]
                     */
                  }, {
                    key: "isSupported",
                    value: function isSupported2() {
                      var action = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ["copy", "cut"];
                      var actions = typeof action === "string" ? [action] : action;
                      var support = !!document.queryCommandSupported;
                      actions.forEach(function(action2) {
                        support = support && !!document.queryCommandSupported(action2);
                      });
                      return support;
                    }
                  }]);
                  return Clipboard3;
                }(tiny_emitter_default());
                var clipboard2 = Clipboard2;
              }
            ),
            /***/
            828: (
              /***/
              function(module3) {
                var DOCUMENT_NODE_TYPE = 9;
                if (typeof Element !== "undefined" && !Element.prototype.matches) {
                  var proto = Element.prototype;
                  proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
                }
                function closest(element, selector3) {
                  while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
                    if (typeof element.matches === "function" && element.matches(selector3)) {
                      return element;
                    }
                    element = element.parentNode;
                  }
                }
                module3.exports = closest;
              }
            ),
            /***/
            438: (
              /***/
              function(module3, __unused_webpack_exports, __webpack_require__2) {
                var closest = __webpack_require__2(828);
                function _delegate(element, selector3, type4, callback, useCapture) {
                  var listenerFn = listener.apply(this, arguments);
                  element.addEventListener(type4, listenerFn, useCapture);
                  return {
                    destroy: function() {
                      element.removeEventListener(type4, listenerFn, useCapture);
                    }
                  };
                }
                function delegate(elements, selector3, type4, callback, useCapture) {
                  if (typeof elements.addEventListener === "function") {
                    return _delegate.apply(null, arguments);
                  }
                  if (typeof type4 === "function") {
                    return _delegate.bind(null, document).apply(null, arguments);
                  }
                  if (typeof elements === "string") {
                    elements = document.querySelectorAll(elements);
                  }
                  return Array.prototype.map.call(elements, function(element) {
                    return _delegate(element, selector3, type4, callback, useCapture);
                  });
                }
                function listener(element, selector3, type4, callback) {
                  return function(e2) {
                    e2.delegateTarget = closest(e2.target, selector3);
                    if (e2.delegateTarget) {
                      callback.call(element, e2);
                    }
                  };
                }
                module3.exports = delegate;
              }
            ),
            /***/
            879: (
              /***/
              function(__unused_webpack_module, exports3) {
                exports3.node = function(value) {
                  return value !== void 0 && value instanceof HTMLElement && value.nodeType === 1;
                };
                exports3.nodeList = function(value) {
                  var type4 = Object.prototype.toString.call(value);
                  return value !== void 0 && (type4 === "[object NodeList]" || type4 === "[object HTMLCollection]") && "length" in value && (value.length === 0 || exports3.node(value[0]));
                };
                exports3.string = function(value) {
                  return typeof value === "string" || value instanceof String;
                };
                exports3.fn = function(value) {
                  var type4 = Object.prototype.toString.call(value);
                  return type4 === "[object Function]";
                };
              }
            ),
            /***/
            370: (
              /***/
              function(module3, __unused_webpack_exports, __webpack_require__2) {
                var is = __webpack_require__2(879);
                var delegate = __webpack_require__2(438);
                function listen(target, type4, callback) {
                  if (!target && !type4 && !callback) {
                    throw new Error("Missing required arguments");
                  }
                  if (!is.string(type4)) {
                    throw new TypeError("Second argument must be a String");
                  }
                  if (!is.fn(callback)) {
                    throw new TypeError("Third argument must be a Function");
                  }
                  if (is.node(target)) {
                    return listenNode(target, type4, callback);
                  } else if (is.nodeList(target)) {
                    return listenNodeList(target, type4, callback);
                  } else if (is.string(target)) {
                    return listenSelector(target, type4, callback);
                  } else {
                    throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
                  }
                }
                function listenNode(node2, type4, callback) {
                  node2.addEventListener(type4, callback);
                  return {
                    destroy: function() {
                      node2.removeEventListener(type4, callback);
                    }
                  };
                }
                function listenNodeList(nodeList, type4, callback) {
                  Array.prototype.forEach.call(nodeList, function(node2) {
                    node2.addEventListener(type4, callback);
                  });
                  return {
                    destroy: function() {
                      Array.prototype.forEach.call(nodeList, function(node2) {
                        node2.removeEventListener(type4, callback);
                      });
                    }
                  };
                }
                function listenSelector(selector3, type4, callback) {
                  return delegate(document.body, selector3, type4, callback);
                }
                module3.exports = listen;
              }
            ),
            /***/
            817: (
              /***/
              function(module3) {
                function select(element) {
                  var selectedText;
                  if (element.nodeName === "SELECT") {
                    element.focus();
                    selectedText = element.value;
                  } else if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {
                    var isReadOnly = element.hasAttribute("readonly");
                    if (!isReadOnly) {
                      element.setAttribute("readonly", "");
                    }
                    element.select();
                    element.setSelectionRange(0, element.value.length);
                    if (!isReadOnly) {
                      element.removeAttribute("readonly");
                    }
                    selectedText = element.value;
                  } else {
                    if (element.hasAttribute("contenteditable")) {
                      element.focus();
                    }
                    var selection = window.getSelection();
                    var range3 = document.createRange();
                    range3.selectNodeContents(element);
                    selection.removeAllRanges();
                    selection.addRange(range3);
                    selectedText = selection.toString();
                  }
                  return selectedText;
                }
                module3.exports = select;
              }
            ),
            /***/
            279: (
              /***/
              function(module3) {
                function E2() {
                }
                E2.prototype = {
                  on: function(name2, callback, ctx) {
                    var e2 = this.e || (this.e = {});
                    (e2[name2] || (e2[name2] = [])).push({
                      fn: callback,
                      ctx
                    });
                    return this;
                  },
                  once: function(name2, callback, ctx) {
                    var self2 = this;
                    function listener() {
                      self2.off(name2, listener);
                      callback.apply(ctx, arguments);
                    }
                    listener._ = callback;
                    return this.on(name2, listener, ctx);
                  },
                  emit: function(name2) {
                    var data = [].slice.call(arguments, 1);
                    var evtArr = ((this.e || (this.e = {}))[name2] || []).slice();
                    var i2 = 0;
                    var len = evtArr.length;
                    for (i2; i2 < len; i2++) {
                      evtArr[i2].fn.apply(evtArr[i2].ctx, data);
                    }
                    return this;
                  },
                  off: function(name2, callback) {
                    var e2 = this.e || (this.e = {});
                    var evts = e2[name2];
                    var liveEvents = [];
                    if (evts && callback) {
                      for (var i2 = 0, len = evts.length; i2 < len; i2++) {
                        if (evts[i2].fn !== callback && evts[i2].fn._ !== callback)
                          liveEvents.push(evts[i2]);
                      }
                    }
                    liveEvents.length ? e2[name2] = liveEvents : delete e2[name2];
                    return this;
                  }
                };
                module3.exports = E2;
                module3.exports.TinyEmitter = E2;
              }
            )
            /******/
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            if (__webpack_module_cache__[moduleId]) {
              return __webpack_module_cache__[moduleId].exports;
            }
            var module3 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId](module3, module3.exports, __webpack_require__);
            return module3.exports;
          }
          !function() {
            __webpack_require__.n = function(module3) {
              var getter = module3 && module3.__esModule ? (
                /******/
                function() {
                  return module3["default"];
                }
              ) : (
                /******/
                function() {
                  return module3;
                }
              );
              __webpack_require__.d(getter, { a: getter });
              return getter;
            };
          }();
          !function() {
            __webpack_require__.d = function(exports3, definition) {
              for (var key2 in definition) {
                if (__webpack_require__.o(definition, key2) && !__webpack_require__.o(exports3, key2)) {
                  Object.defineProperty(exports3, key2, { enumerable: true, get: definition[key2] });
                }
              }
            };
          }();
          !function() {
            __webpack_require__.o = function(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            };
          }();
          return __webpack_require__(686);
        }().default
      );
    });
  })(clipboard);
  var clipboardExports = clipboard.exports;
  const Clipboard = /* @__PURE__ */ getDefaultExportFromCjs(clipboardExports);
  const clipboard3 = (opts) => {
    const appendToBody = (opts === null || opts === void 0 ? void 0 : opts.appendToBody) === void 0 ? true : opts.appendToBody;
    return {
      toClipboard(text, container) {
        return new Promise((resolve2, reject) => {
          const fakeEl = document.createElement("button");
          const clipboard2 = new Clipboard(fakeEl, {
            text: () => text,
            action: () => "copy",
            container: container !== void 0 ? container : document.body
          });
          clipboard2.on("success", (e2) => {
            clipboard2.destroy();
            resolve2(e2);
          });
          clipboard2.on("error", (e2) => {
            clipboard2.destroy();
            reject(e2);
          });
          if (appendToBody)
            document.body.appendChild(fakeEl);
          fakeEl.click();
          if (appendToBody)
            document.body.removeChild(fakeEl);
        });
      }
    };
  };
  const questionFeed = (params) => {
    return request.get({
      url: "/admin-api/business/temporary-question-log/feed",
      params
    });
  };
  const sendQuestionApi = (data) => {
    return request.post({
      url: "/admin-api/business/temporary-question-log/create",
      data
    });
  };
  var FeedCodeEnum = /* @__PURE__ */ ((FeedCodeEnum2) => {
    FeedCodeEnum2[FeedCodeEnum2["like"] = 1] = "like";
    FeedCodeEnum2[FeedCodeEnum2["unlike"] = 2] = "unlike";
    return FeedCodeEnum2;
  })(FeedCodeEnum || {});
  const _withScopeId$4 = (n2) => (pushScopeId("data-v-d1acc71d"), n2 = n2(), popScopeId(), n2);
  const _hoisted_1$8 = { class: "answer-content-btn flex-c-a" };
  const _hoisted_2$6 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("span", null, "复制", -1));
  const _hoisted_3$5 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("span", null, "有用", -1));
  const _hoisted_4$2 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("span", null, "无用", -1));
  const _hoisted_5$1 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("span", null, "重新生成", -1));
  const _sfc_main$9 = /* @__PURE__ */ defineComponent({
    __name: "AnswerActionBar",
    props: {
      content: {},
      answerId: {}
    },
    emits: ["refresh"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const props = __props;
      const emit2 = __emit;
      const { toClipboard } = clipboard3();
      const handleCopy = async () => {
        try {
          await toClipboard(props.content);
          api$1.success("已复制到剪贴板");
        } catch (err) {
          api$1.error("复制失败，请手动复制");
          console.error(err);
        }
      };
      const activeBtn = ref();
      const handleLike = async () => {
        activeBtn.value = FeedCodeEnum.like;
        debounceQuestionFeed(FeedCodeEnum.like);
      };
      const handleUnLike = async () => {
        activeBtn.value = FeedCodeEnum.unlike;
        debounceQuestionFeed(FeedCodeEnum.unlike);
      };
      const handleQuestionFeed = async (feedCode) => {
        await questionFeed({ feedCode, id: props.answerId });
      };
      const debounceQuestionFeed = debounce$1(handleQuestionFeed, 250);
      const handleRefresh = () => {
        gsapWithCSS.to(".ai-refresh-icon", 1, { rotation: "+=360" });
        emit2("refresh");
      };
      const resetActiveValue = () => {
        activeBtn.value = void 0;
      };
      __expose({
        resetActiveValue
      });
      return (_ctx, _cache) => {
        const _component_a_divider = resolveComponent("a-divider");
        const _component_a_tooltip = resolveComponent("a-tooltip");
        const _component_a_space = resolveComponent("a-space");
        return openBlock(), createElementBlock("div", _hoisted_1$8, [
          createVNode(_component_a_space, null, {
            split: withCtx(() => [
              createVNode(_component_a_divider, { type: "vertical" })
            ]),
            default: withCtx(() => [
              _ctx.content ? (openBlock(), createBlock(_component_a_tooltip, {
                key: 0,
                placement: "bottom"
              }, {
                title: withCtx(() => [
                  _hoisted_2$6
                ]),
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: "answer-content-btn-item",
                    onClick: handleCopy
                  }, [
                    createVNode(Copy)
                  ])
                ]),
                _: 1
              })) : createCommentVNode("", true),
              _ctx.answerId && _ctx.content ? (openBlock(), createBlock(_component_a_tooltip, {
                key: 1,
                placement: "bottom"
              }, {
                title: withCtx(() => [
                  _hoisted_3$5
                ]),
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: normalizeClass(["answer-content-btn-item", { "action-selected": activeBtn.value === unref(FeedCodeEnum).like }]),
                    onClick: handleLike
                  }, [
                    createVNode(Help)
                  ], 2)
                ]),
                _: 1
              })) : createCommentVNode("", true),
              _ctx.answerId && _ctx.content ? (openBlock(), createBlock(_component_a_tooltip, {
                key: 2,
                placement: "bottom"
              }, {
                title: withCtx(() => [
                  _hoisted_4$2
                ]),
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: normalizeClass(["answer-content-btn-item", { "action-selected": activeBtn.value === unref(FeedCodeEnum).unlike }]),
                    onClick: handleUnLike
                  }, [
                    createVNode(NotHelp)
                  ], 2)
                ]),
                _: 1
              })) : createCommentVNode("", true),
              createVNode(_component_a_tooltip, { placement: "bottom" }, {
                title: withCtx(() => [
                  _hoisted_5$1
                ]),
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: "answer-content-btn-item",
                    onClick: handleRefresh
                  }, [
                    createVNode(Refresh, { class: "ai-refresh-icon" })
                  ])
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]);
      };
    }
  });
  const AnswerActionBar = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__scopeId", "data-v-d1acc71d"]]);
  const _sfc_main$8 = {};
  const _hoisted_1$7 = {
    width: "12px",
    height: "12px",
    viewBox: "0 0 12 12",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    "xmlns:xlink": "http://www.w3.org/1999/xlink"
  };
  const _hoisted_2$5 = /* @__PURE__ */ createStaticVNode('<g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="AI投诉助手3" transform="translate(-1863, -197)"><g id="编组-5" transform="translate(1544, 183)"><g id="按钮_收起" transform="translate(325, 20) rotate(-90) translate(-325, -20)translate(319, 14)"><rect id="矩形" stroke="#FFFFFF" x="0.5" y="0.5" width="11" height="11" rx="2"></rect><path d="M6.53667084,7.14282974 L4.12547748,4.73164112 C3.95817417,4.56433217 3.95817417,4.29276276 4.12547748,4.12548171 C4.29261337,3.95817276 4.56433337,3.95817276 4.731486,4.12548171 L7.14283004,6.53682101 L7.14283004,4.70763939 C7.14283004,4.47463122 7.33169081,4.28561414 7.56485514,4.28561414 L7.57813115,4.28561414 C7.81113923,4.28561414 8,4.47463122 8,4.70763939 L8,7.57084845 C8,7.63770841 7.9850052,7.70042206 7.95814627,7.75642237 C7.9371357,7.80000049 7.90942853,7.83956065 7.87441649,7.8745727 C7.8349847,7.91400451 7.78971012,7.94413362 7.7412714,7.96499353 C7.68812833,7.98770616 7.63112355,8 7.57141223,8 L4.70764054,8 C4.47463245,8 4.2857661,7.81113916 4.2857661,7.578131 L4.2857661,7.56470432 C4.2857661,7.33169615 4.47463245,7.14282974 4.70764054,7.14282974 L6.53667084,7.14282974 Z" id="Fill-1" fill="#FFFFFF"></path></g></g></g></g>', 1);
  const _hoisted_3$4 = [
    _hoisted_2$5
  ];
  function _sfc_render$1(_ctx, _cache) {
    return openBlock(), createElementBlock("svg", _hoisted_1$7, _hoisted_3$4);
  }
  const Close = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$1]]);
  const _withScopeId$3 = (n2) => (pushScopeId("data-v-973baeeb"), n2 = n2(), popScopeId(), n2);
  const _hoisted_1$6 = { class: "ai-modal-header" };
  const _hoisted_2$4 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "text-header flex-c disable-select" }, "AI投诉助手", -1));
  const _hoisted_3$3 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("span", null, "收起", -1));
  const _hoisted_4$1 = { class: "ai-modal-header-order flex-c" };
  const _sfc_main$7 = /* @__PURE__ */ defineComponent({
    __name: "ChatDetailHeader",
    props: {
      closeVisible: { type: Boolean },
      orderNo: {}
    },
    emits: ["close"],
    setup(__props, { emit: __emit }) {
      const emit2 = __emit;
      return (_ctx, _cache) => {
        const _component_a_tooltip = resolveComponent("a-tooltip");
        return openBlock(), createElementBlock("div", _hoisted_1$6, [
          _hoisted_2$4,
          createVNode(_component_a_tooltip, { placement: "left" }, {
            title: withCtx(() => [
              _hoisted_3$3
            ]),
            default: withCtx(() => [
              withDirectives(createBaseVNode("div", {
                class: "close flex-c",
                onClick: _cache[0] || (_cache[0] = ($event) => emit2("close"))
              }, [
                createVNode(Close)
              ], 512), [
                [vShow, _ctx.closeVisible]
              ])
            ]),
            _: 1
          }),
          createBaseVNode("div", _hoisted_4$1, "工单编号：" + toDisplayString(_ctx.orderNo), 1)
        ]);
      };
    }
  });
  const ChatDetailHeader = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-973baeeb"]]);
  function setupDragBar(config3) {
    const dragEl = config3.dragEl;
    const parentSize = {
      width: (config3.parentSize.width || 0) - (window.innerWidth - config3.el.getBoundingClientRect().right),
      height: (config3.parentSize.height || 0) - config3.el.getBoundingClientRect().top
    };
    dragEl.onmousedown = function(e2) {
      const dragElStartValue = {
        x: e2.clientX,
        y: e2.clientY
      };
      const startValue = {
        x: parentSize.width - config3.el.offsetWidth,
        y: parentSize.height - config3.el.offsetHeight
      };
      document.onmousemove = function(e22) {
        const dragElEndValue = {
          x: e22.clientX,
          y: e22.clientY
        };
        if (config3.enableX) {
          const flagValue = 1;
          let endValue = startValue.x + (dragElEndValue.x - dragElStartValue.x) * flagValue;
          if (config3.minValue.x && endValue < config3.minValue.x) {
            endValue = config3.minValue.x;
          }
          if (config3.maxValue.x && endValue > config3.maxValue.x) {
            endValue = config3.maxValue.x;
          }
          const newValue = parentSize.width - endValue;
          if (typeof config3.callback === "function") {
            config3.callback({ x: newValue, el: config3.el });
          } else {
            config3.el.style.setProperty("width", newValue + "px");
          }
        }
        if (config3.enableY) {
          const flagValue = -1;
          let endValue = startValue.y + (dragElEndValue.y - dragElStartValue.y) * flagValue;
          if (config3.minValue.y && endValue < config3.minValue.y) {
            endValue = config3.minValue.y;
          }
          if (config3.maxValue.y && endValue > config3.maxValue.y) {
            endValue = config3.maxValue.y;
          }
          const newValue = parentSize.height - endValue;
          if (typeof config3.callback === "function") {
            config3.callback({ y: newValue, el: config3.el });
          } else {
            config3.el.style.setProperty("height", newValue + "px");
          }
        }
      };
      document.onmouseup = function() {
        document.onmousemove = null;
        document.onmouseup = null;
        dragEl.releaseCapture && dragEl.releaseCapture();
      };
      dragEl.setCapture && dragEl.setCapture();
      return false;
    };
  }
  const _withScopeId$2 = (n2) => (pushScopeId("data-v-e877abc1"), n2 = n2(), popScopeId(), n2);
  const _hoisted_1$5 = { class: "setup-drag-bar" };
  const _hoisted_2$3 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", {
    id: "dragBarX",
    class: "dragBar dragBarX"
  }, null, -1));
  const _hoisted_3$2 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", {
    id: "dragBarY",
    class: "dragBar dragBarY"
  }, null, -1));
  const _hoisted_4 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", {
    id: "dragBarXY",
    class: "dragBar dragBarXY"
  }, null, -1));
  const _hoisted_5 = [
    _hoisted_2$3,
    _hoisted_3$2,
    _hoisted_4
  ];
  const _sfc_main$6 = /* @__PURE__ */ defineComponent({
    __name: "SetupDragBar",
    setup(__props, { expose: __expose }) {
      let setupDragIsInited = false;
      const setupDrag = async () => {
        if (setupDragIsInited)
          return;
        await nextTick();
        setupDragIsInited = true;
        const rightWrapMinValue = {
          width: 376,
          height: 40 + 180 + 20
        };
        const dragBarY = document.querySelector("#dragBarY");
        const dragBarX = document.querySelector("#dragBarX");
        const dragBarXY = document.querySelector("#dragBarXY");
        const rightWrap = document.querySelector("#aiModalContainer");
        const callback = ({ x: x2, y: y2, el }) => {
          if (y2 || y2 === 0) {
            rightWrap.querySelector("#aiAnswerWrap").style.setProperty("height", y2 - 40 - 20 + "px");
          }
          if (x2 || x2 === 0) {
            el.style.setProperty("width", x2 + "px");
          }
        };
        setupDragBar({
          enableX: true,
          dragEl: dragBarY,
          // 拖动条
          el: rightWrap,
          // 可以拖动放大/缩小的容器
          parentSize: {
            width: window.innerWidth
          },
          // 父级宽度
          minValue: { x: 10 },
          maxValue: { x: window.innerWidth - 10 - rightWrapMinValue.width },
          callback
        });
        setupDragBar({
          enableY: true,
          dragEl: dragBarX,
          // 拖动条
          el: rightWrap,
          // 可以拖动放大/缩小的容器
          parentSize: {
            height: window.innerHeight
          },
          // 父级高度
          minValue: { y: 10 },
          maxValue: { y: window.innerHeight - 10 - rightWrapMinValue.height },
          callback
        });
        setupDragBar({
          enableX: true,
          enableY: true,
          dragEl: dragBarXY,
          // 拖动条
          el: rightWrap,
          // 可以拖动放大/缩小的容器
          parentSize: {
            width: window.innerWidth,
            height: window.innerHeight
          },
          // 父级高度
          minValue: { x: 10, y: 10 },
          // 最小y
          maxValue: {
            x: window.innerWidth - 10 - rightWrapMinValue.width,
            y: window.innerHeight - 10 - rightWrapMinValue.height
          },
          callback
        });
      };
      __expose({
        setupDrag
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$5, _hoisted_5);
      };
    }
  });
  const SetupDragBar = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-e877abc1"]]);
  var define_import_meta_env_default$3 = { VITE_BASE_URL: "http://134.98.6.18:9507", VITE_TENANT_ID: "121", VITE_IS_STAGE: "1", BASE_URL: "/", MODE: "stage", DEV: false, PROD: true, SSR: false };
  const checkIsInDetail = () => {
    if (define_import_meta_env_default$3.VITE_NO_SEND_QUESTION)
      return;
    const activeTabEl = getActiveTabEl();
    if (!activeTabEl) {
      throw Error("未在详情页，请在工单详情页后点击此按钮");
    }
  };
  const getOrderNo = () => {
    if (define_import_meta_env_default$3.VITE_NO_SEND_QUESTION)
      return "";
    const activeTabEl = getActiveTabEl();
    return activeTabEl.innerText;
  };
  const checkActionBtnText = (el, btnText, parentClass) => {
    const parentEl = el.querySelector(parentClass);
    if ((parentEl == null ? void 0 : parentEl.style.display) === "none")
      return;
    const list = Array.from(
      parentEl.querySelectorAll("button")
    );
    let btnEl;
    for (let i2 = 0; i2 < list.length; i2++) {
      const e2 = list[i2];
      const text = e2.innerText;
      if (text.trim().endsWith(btnText)) {
        btnEl = e2;
        break;
      }
    }
    return btnEl;
  };
  const getActiveTabEl = () => {
    return document.querySelector(".el-tabs__item.is-active.is-closable");
  };
  const getActivePanEl = (activePaneName) => {
    return document.querySelector("#" + activePaneName);
  };
  const getFlowTableTexts = (parentEl) => {
    return Array.from(
      parentEl.querySelector(".el-table__body-wrapper").querySelectorAll("tr")
    ).map((e2) => ({
      action: e2.children[3].innerText,
      // 动作
      description: e2.children[6].innerText
      // 处理描述
    }));
  };
  const getRecordsContent = async () => {
    var _a2, _b, _c, _d;
    const { activePaneEl } = getParentInfo();
    let recordsParent;
    if (((_a2 = activePaneEl.querySelector(".info-title>span")) == null ? void 0 : _a2.innerText) === "子单信息" || ((_d = (_c = (_b = activePaneEl.querySelector(".whole-btn")) == null ? void 0 : _b.parentElement) == null ? void 0 : _c.querySelector("span")) == null ? void 0 : _d.innerText) === "子单信息") {
      const allProcessBtn = await checkActionBtnText(
        activePaneEl,
        "全流程",
        ".whole-btn"
      );
      recordsParent = activePaneEl.querySelector(".t-table.son-list");
      await allProcessBtnClick(activePaneEl, allProcessBtn);
    } else {
      const allProcessBtn = await checkActionBtnText(
        activePaneEl,
        "全流程",
        ".whole-btn"
      );
      if (allProcessBtn) {
        recordsParent = activePaneEl.querySelector(".t-table.c-flow");
        await allProcessBtnClick(activePaneEl, allProcessBtn);
      } else {
        const processListBtn = await checkActionBtnText(
          activePaneEl,
          "流程列表",
          ".whole-new-btn"
        );
        if (processListBtn) {
          await processListBtnClick(processListBtn);
          recordsParent = getAllDragDialogEl()[0].querySelector(
            ".t-table.c-flow"
          );
        } else {
          throw Error(
            `只有在处理流程中有 “全流程” 或 “流程列表” 的按钮的情况下，才可以采集`
          );
        }
      }
    }
    const records = getFlowTableTexts(recordsParent);
    return records;
  };
  const allProcessBtnClick = async (el, btn) => {
    if (el.querySelector(".son-list.t-table").style.display === "none") {
      btn.click();
      await delay(1e3);
    }
  };
  const getAllDragDialogEl = (text = "流程列表") => {
    return Array.from(
      document.querySelectorAll("#dragDialog")
    ).filter((e2) => {
      return e2.querySelector(".el-dialog__header>div>span").innerText === text;
    });
  };
  const processListBtnClick = async (el) => {
    return new Promise((resolve2, reject) => {
      try {
        const click2 = async () => {
          await nextTick();
          el.click();
          await delay(1e3);
          resolve2();
        };
        const list = getAllDragDialogEl();
        list.length ? list.forEach((e2, i2, arr) => {
          e2.querySelector(".el-dialog__headerbtn").click();
          if (i2 === arr.length - 1) {
            click2();
          }
        }) : click2();
      } catch (err) {
        reject(err);
      }
    });
  };
  async function getTextsInfo(promptType) {
    if (promptType === promptTypeEnum.tsdz) {
      const closedContent = await getClosedContent();
      return { closedContent };
    }
    const complaint = getComplaintContent();
    if (promptType === promptTypeEnum.tsyd) {
      return { complaint };
    }
    const records = await getRecordsContent();
    await nextTick();
    return { complaint, records };
  }
  function getParentInfo() {
    const activeTabEl = getActiveTabEl();
    const activePaneName = activeTabEl.getAttribute("aria-controls");
    const activePaneEl = getActivePanEl(activePaneName);
    return {
      activeTabEl,
      activePaneEl
    };
  }
  function getComplaintContent() {
    const { activePaneEl } = getParentInfo();
    const complaintContent = activePaneEl.querySelector(".complaint").innerText;
    const complaint = "投诉内容：" + complaintContent;
    return complaint;
  }
  async function getClosedContent() {
    const { activePaneEl } = getParentInfo();
    let type4;
    const urlInfo = new URL(window.location.href);
    if (urlInfo.hash === "#/complaintHandling/handle") {
      type4 = 1;
    } else if (urlInfo.hash === "#/leapfrogComplaint/handle") {
      type4 = 2;
    } else {
      throw Error(
        "未知页面，无法确定用 省内投诉处理 还是 越级/跨省跨域处理 采集方式"
      );
    }
    const getPaneElByTabText = (text) => {
      const tabs = activePaneEl.querySelectorAll('div[role="tab"]');
      const tab = Array.from(tabs).find((el) => el.innerText.trim() === text);
      const paneId = tab.getAttribute("aria-controls");
      const paneEl = activePaneEl.querySelector("#" + paneId);
      return paneEl;
    };
    const clickJieDanBtn = (btnText, wrapClassName) => {
      const paneEl = getPaneElByTabText("工单详情");
      Array.from(
        paneEl.querySelectorAll(wrapClassName + ">p>button>span")
      ).find((el) => el.innerText.trim() === btnText).click();
    };
    if (type4 === 1) {
      clickJieDanBtn("结单", ".flow-btns-bottom");
    } else if (type4 === 2) {
      clickJieDanBtn("答复", ".flow-btns-right");
    }
    await delay(300);
    let closedContentEl;
    if (type4 === 1) {
      const jdPaneEl = getPaneElByTabText("结单");
      closedContentEl = jdPaneEl.querySelector(
        'label[for="strictClosedContent"]'
      ).nextSibling.querySelector(
        "textarea"
      );
    } else if (type4 === 2) {
      const jdPaneEl = document.querySelector(
        "#dragDialog.replyDialog"
      );
      await delayForQuery(
        () => !!jdPaneEl.querySelector(
          'label[for="complaintDealResult"]'
        )
      );
      closedContentEl = jdPaneEl.querySelector(
        'label[for="complaintDealResult"]'
      ).nextSibling.querySelector("textarea");
    }
    return closedContentEl.value;
  }
  class SessionStorageManager {
    static getCachedItems() {
      const cachedItemsString = sessionStorage.getItem(this.storageKey) || "{}";
      return JSON.parse(cachedItemsString);
    }
    static setCachedItems(items) {
      sessionStorage.setItem(this.storageKey, JSON.stringify(items));
    }
    static setStorageKey(value) {
      this.storageKey = "hzdx-cs-ai_" + value;
    }
    static get(key2) {
      const cachedItems = this.getCachedItems();
      const cachedData = cachedItems[key2];
      if (cachedData) {
        const parsedCachedData = JSON.parse(cachedData);
        return parsedCachedData.data;
      }
      return void 0;
    }
    static set(key2, data) {
      const cachedItems = this.getCachedItems();
      cachedItems[key2] = JSON.stringify({ data });
      this.setCachedItems(cachedItems);
    }
    static clear() {
      sessionStorage.removeItem(this.storageKey);
    }
  }
  __publicField(SessionStorageManager, "storageKey", "hzdx-cs-ai_answers");
  async function sendQuestion(data, orderNo, useCache) {
    var _a2, _b;
    SessionStorageManager.setStorageKey("answers");
    const getKey = () => orderNo + "-" + data.promptType;
    if (useCache) {
      const cacheData = SessionStorageManager.get(getKey());
      if (cacheData) {
        return {
          data: {
            answer: cacheData.answer,
            id: cacheData.id,
            inCache: true
          },
          success: true,
          code: 0
        };
      }
    }
    const res = await sendQuestionApi(data);
    if ((_a2 = res.data) == null ? void 0 : _a2.id) {
      SessionStorageManager.set(getKey(), {
        id: res.data.id,
        answer: (_b = res.data) == null ? void 0 : _b.answer
      });
    }
    return res;
  }
  function hashObserver(hashArr, onChange, autoRun) {
    let preValue;
    const res = {
      run: () => setInterval(function() {
        const currentHash = window.location.hash;
        if (preValue === currentHash)
          return;
        preValue = currentHash;
        onChange(hashArr.includes(currentHash));
      }, 500)
    };
    if (typeof autoRun !== "boolean" || autoRun) {
      res.run();
    }
    return res;
  }
  function storageObserver(storageName, onChange, autoRun) {
    let preValue;
    const res = {
      run: () => {
        const storage = window.sessionStorage;
        setInterval(function() {
          const isExist = !!storage.getItem(storageName);
          if (preValue === isExist)
            return;
          onChange(preValue, isExist);
          preValue = isExist;
        }, 500);
      }
    };
    if (typeof autoRun !== "boolean" || autoRun) {
      res.run();
    }
    return res;
  }
  function useDisplayMessages(params) {
    const initialMessages = params.initialMessages || [];
    const duration = params.duration || 100;
    const callback = params.callback;
    const onStop = params.onStop;
    const onConsumedOneRecord = params.onConsumedOneRecord || (() => {
    });
    let messagesQueue = initialMessages.slice();
    let isDisplaying = false;
    let isStop = false;
    function displayMessage(message) {
      isDisplaying = true;
      let index2 = 0;
      function displayChar() {
        if (isStop)
          return;
        if (index2 < message.length) {
          callback(message[index2]);
          index2++;
          setTimeout(displayChar, duration);
        } else {
          onConsumedOneRecord && onConsumedOneRecord(messagesQueue);
          isDisplaying = false;
          processQueue();
        }
      }
      displayChar();
    }
    function processQueue() {
      if (messagesQueue.length > 0 && !isDisplaying) {
        const nextMessage = messagesQueue.shift();
        displayMessage(nextMessage);
      }
    }
    return {
      // 往队列最后一位加一条消息
      pushMessage: (message) => {
        messagesQueue.push(message);
        processQueue();
      },
      start() {
        processQueue();
      },
      stop() {
        isStop = true;
        this.onStop();
      },
      onStop() {
        onStop();
      },
      $reset() {
        messagesQueue = [];
        isDisplaying = false;
      }
    };
  }
  function useMonitorMouse(callback, options) {
    let { el, duration } = options || {};
    if (!el) {
      el = document.body;
    }
    if (!duration) {
      duration = 1e4;
    }
    let timer = null;
    el.addEventListener("mousemove", () => {
      if (timer !== null) {
        clearTimeout(timer);
      }
      timer = window.setTimeout(() => {
        callback();
      }, duration);
    });
    onUnmounted(() => {
      timer && clearTimeout(timer);
    });
  }
  const useAppStore = defineStore("app", {
    state: () => ({
      versionInfo: void 0
    }),
    getters: {},
    actions: {
      setVersionInfo(v2) {
        this.$state.versionInfo = v2;
      }
    }
  });
  var define_import_meta_env_default$2 = { VITE_BASE_URL: "http://134.98.6.18:9507", VITE_TENANT_ID: "121", VITE_IS_STAGE: "1", BASE_URL: "/", MODE: "stage", DEV: false, PROD: true, SSR: false };
  const _withScopeId$1 = (n2) => (pushScopeId("data-v-4c3b9d3c"), n2 = n2(), popScopeId(), n2);
  const _hoisted_1$4 = { class: "ai-detail-container" };
  const _hoisted_2$2 = { class: "ai-modal-footer" };
  const _hoisted_3$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "statement-text flex-c disable-select" }, " 以上内容由AI生成，仅供参考 ", -1));
  const _sfc_main$5 = /* @__PURE__ */ defineComponent({
    __name: "ChatModal",
    setup(__props, { expose: __expose }) {
      useCssVars((_ctx) => ({
        "71295dc6": unref(iconImgWidthStr2)
      }));
      const iconImgWidthStr2 = inject("iconImgWidthStr");
      const slidePromptType = ref();
      const isOpen = ref(false);
      const orderNo = ref("");
      const isQuerying = ref(false);
      const isQueryInLocal = ref(false);
      const content = ref("");
      const answerInfo = reactive({});
      const toggleVisible = () => {
        isOpen.value = !isOpen.value;
      };
      const updateOrderNo = () => {
        orderNo.value = getOrderNo();
        return orderNo.value;
      };
      const ChatModalDetailRef = ref();
      const scrollToBottom = () => {
        var _a2;
        (_a2 = ChatModalDetailRef.value) == null ? void 0 : _a2.scrollToBottom();
      };
      const resetChatRectangle = () => {
        nextTick(() => {
          var _a2, _b;
          (_a2 = document.querySelector("#aiModalContainer")) == null ? void 0 : _a2.style.removeProperty("width");
          (_b = document.querySelector("#aiAnswerWrap")) == null ? void 0 : _b.style.removeProperty("height");
        });
      };
      const SetupDragBarRef = ref();
      const AnswerActionBarRef = ref();
      useAppStore();
      const handleClickActionBtn = async (params, useCache = true) => {
        var _a2, _b, _c, _d;
        (_a2 = AnswerActionBarRef.value) == null ? void 0 : _a2.resetActiveValue();
        if (isQuerying.value || isQueryInLocal.value) {
          api$1.warn("正在生成中，请勿重复点击");
          return;
        }
        const promptType = params.promptType;
        slidePromptType.value = promptType;
        content.value = "";
        try {
          isQuerying.value = true;
          if (false)
            ;
          await checkIsInDetail();
          const getQuestion = async () => {
            if (define_import_meta_env_default$2.VITE_NO_SEND_QUESTION)
              return "";
            const { complaint, records, closedContent } = await getTextsInfo(promptType);
            console.log("从页面中获取了这些问题：", {
              complaint,
              records,
              closedContent
            });
            if (promptType === promptTypeEnum.tsyd) {
              return complaint;
            }
            if (promptType === promptTypeEnum.scjd) {
              const descriptions = records.map((e2) => e2.description);
              return [complaint, ...descriptions].join("；");
            }
            if (promptType === promptTypeEnum.tsdz) {
              return closedContent;
            }
            throw Error("未知类型: " + promptType);
          };
          const question = await getQuestion();
          const orderNo2 = updateOrderNo();
          isOpen.value = true;
          (_b = SetupDragBarRef.value) == null ? void 0 : _b.setupDrag();
          resetChatRectangle();
          const displayMessages = useDisplayMessages({
            duration: 20,
            callback: (word) => {
              content.value += word;
              scrollToBottom();
            },
            /**
             * 当消费完一条记录（一段话）时
             */
            onConsumedOneRecord: (messagesQueue) => {
              if (!isQuerying.value && messagesQueue.length === 0) {
                displayMessages.stop();
              }
            },
            onStop: () => {
              isQueryInLocal.value = false;
              scrollToBottom();
            }
          });
          isQueryInLocal.value = true;
          const isEventSource = false;
          if (isEventSource)
            ;
          else {
            const sendQuestionParams = {
              question,
              indexName: params.indexName,
              promptType: params.promptType
            };
            console.log("发送地址及参数", sendQuestionParams);
            const res = await sendQuestion(sendQuestionParams, orderNo2, useCache);
            console.log("收到回复：", res.data.answer);
            answerInfo.answer = res.data.answer;
            answerInfo.id = (_c = res.data) == null ? void 0 : _c.id;
            if ((_d = res.data) == null ? void 0 : _d.inCache) {
              content.value = res.data.answer;
              displayMessages.stop();
            } else {
              displayMessages.pushMessage(res.data.answer);
            }
          }
          console.log("over~");
        } catch (error) {
          console.error(error);
          api$1.error((error == null ? void 0 : error.message) || "插件运行失败");
          isQueryInLocal.value = false;
        } finally {
          isQuerying.value = false;
        }
      };
      const changeScene = inject("changeScene");
      const handleQuit = async () => {
        const userStore = useUserStore();
        userStore.logOut();
        changeScene(ScenesEnum.login);
      };
      useMonitorMouse(
        () => {
          api$1.error(`因长时间未活跃，自动退出`);
          handleQuit();
        },
        {
          duration: 1e3 * 60 * 60 * 8,
          // TODO 目前8个小时
          el: document.querySelector("body")
        }
      );
      __expose({
        toggleVisible
      });
      return (_ctx, _cache) => {
        return openBlock(), createElementBlock("div", _hoisted_1$4, [
          withDirectives(createVNode(ChatModalDetail, {
            ref_key: "ChatModalDetailRef",
            ref: ChatModalDetailRef,
            isQuerying: isQuerying.value,
            content: content.value
          }, {
            header: withCtx(() => [
              createVNode(ChatDetailHeader, {
                onClose: _cache[0] || (_cache[0] = ($event) => isOpen.value = false),
                closeVisible: !isQueryInLocal.value,
                orderNo: orderNo.value
              }, null, 8, ["closeVisible", "orderNo"])
            ]),
            footer: withCtx(() => [
              createBaseVNode("div", _hoisted_2$2, [
                _hoisted_3$1,
                withDirectives(createVNode(AnswerActionBar, {
                  ref_key: "AnswerActionBarRef",
                  ref: AnswerActionBarRef,
                  content: content.value,
                  answerId: answerInfo.id,
                  onRefresh: _cache[1] || (_cache[1] = () => handleClickActionBtn(unref(questionParamsMap)[slidePromptType.value], false))
                }, null, 8, ["content", "answerId"]), [
                  [vShow, !(isQueryInLocal.value || isQuerying.value)]
                ])
              ])
            ]),
            "drag-bar": withCtx(() => [
              createVNode(SetupDragBar, {
                ref_key: "SetupDragBarRef",
                ref: SetupDragBarRef
              }, null, 512)
            ]),
            _: 1
          }, 8, ["isQuerying", "content"]), [
            [vShow, isOpen.value && slidePromptType.value]
          ]),
          createVNode(SlideBar, {
            promptType: slidePromptType.value,
            isOpen: isOpen.value,
            onActionBtn: handleClickActionBtn,
            onQuit: handleQuit
          }, null, 8, ["promptType", "isOpen"])
        ]);
      };
    }
  });
  const ChatModal = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-4c3b9d3c"]]);
  const _withScopeId = (n2) => (pushScopeId("data-v-4bfcae55"), n2 = n2(), popScopeId(), n2);
  const _hoisted_1$3 = { class: "ai-login-header" };
  const _hoisted_2$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", null, "收起", -1));
  const _hoisted_3 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { class: "ai-login-header-order flex-c" }, "欢迎登录AI投诉助手", -1));
  const _sfc_main$4 = /* @__PURE__ */ defineComponent({
    __name: "LoginHeader",
    emits: ["close"],
    setup(__props, { emit: __emit }) {
      const emit2 = __emit;
      return (_ctx, _cache) => {
        const _component_a_tooltip = resolveComponent("a-tooltip");
        return openBlock(), createElementBlock("div", _hoisted_1$3, [
          createVNode(_component_a_tooltip, { placement: "left" }, {
            title: withCtx(() => [
              _hoisted_2$1
            ]),
            default: withCtx(() => [
              createBaseVNode("div", {
                class: "close flex-c",
                onClick: _cache[0] || (_cache[0] = ($event) => emit2("close"))
              }, [
                createVNode(Close)
              ])
            ]),
            _: 1
          }),
          _hoisted_3
        ]);
      };
    }
  });
  const LoginHeader = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-4bfcae55"]]);
  const useSendCode = (config3) => {
    const isTriggered = ref(false);
    const countDown = ref(0);
    let timer;
    const disabled = computed(() => countDown.value > 0);
    const sendBtnText = computed(() => {
      if (disabled.value)
        return `${countDown.value}s`;
      if (isTriggered.value)
        return "再次发送";
      return "发送验证码";
    });
    const send = async (mobile) => {
      if (disabled.value)
        return;
      if (!isValidPhoneNumber(mobile)) {
        console.error("手机号格式错误");
        config3.fail && config3.fail("手机号格式错误");
        return;
      }
      await config3.request(mobile);
      isTriggered.value = true;
      countDown.value = config3.countDownCount || 60;
      if (timer)
        clearInterval(timer);
      timer = setInterval(() => {
        countDown.value--;
        if (countDown.value === 0)
          clearInterval(timer);
      }, 1e3);
    };
    onUnmounted(() => {
      clearInterval(timer);
    });
    return { countDown, send, disabled, sendBtnText };
  };
  var define_import_meta_env_default$1 = { VITE_BASE_URL: "http://134.98.6.18:9507", VITE_TENANT_ID: "121", VITE_IS_STAGE: "1", BASE_URL: "/", MODE: "stage", DEV: false, PROD: true, SSR: false };
  const _hoisted_1$2 = { class: "ai-login-form" };
  const key = "hzdx-cs-ai_login-tel";
  const _sfc_main$3 = /* @__PURE__ */ defineComponent({
    __name: "LoginForm",
    setup(__props) {
      const formRef = ref();
      const formState = reactive({
        tel: "",
        code: "",
        remember: true
      });
      const validatePhone = async (_rule, value) => {
        if (formState.tel === "") {
          return Promise.reject("请输入手机号");
        } else if (!isValidPhoneNumber(value)) {
          return Promise.reject("无效的手机号格式");
        } else {
          return Promise.resolve();
        }
      };
      const validateCode = async (_rule, value) => {
        if (value === "") {
          return Promise.reject("请输入验证码");
        } else {
          return Promise.resolve();
        }
      };
      const rules2 = {
        tel: [{ validator: validatePhone, trigger: "change" }],
        code: [{ validator: validateCode, trigger: "change" }]
      };
      const changeScene = inject("changeScene");
      const codeValidateInfo = reactive({});
      const resetErrorMsg = () => {
        codeValidateInfo.validateStatus = void 0;
        codeValidateInfo.help = void 0;
      };
      const showMessageError = (str) => {
        codeValidateInfo.validateStatus = "error";
        codeValidateInfo.help = str;
      };
      const submiting = ref(false);
      const onSubmit = async () => {
        resetErrorMsg();
        const form = await formRef.value.validateFields();
        try {
          submiting.value = true;
          const res = await loginBy4A({
            partySubAccount: form.tel,
            // 手机号
            accountType: "01",
            authType: "02",
            randomCode: form.code,
            // 验证码
            mock: !!define_import_meta_env_default$1.VITE_IS_LOCAL_TEST
          });
          console.log("res", res);
          if (!res.success) {
            showMessageError(res.msg);
            return;
          }
          if (!res.data) {
            showMessageError(`/loginBy4A返回的data为空`);
            return;
          }
          updateTelInStorage(form);
          storageHelper.accessToken.set(res.data.accessToken);
          storageHelper.refreshToken.set(res.data.refreshToken);
          changeScene(ScenesEnum.chat);
        } catch (errorInfo) {
          console.log("Failed:", errorInfo);
        } finally {
          setTimeout(() => {
            submiting.value = false;
          }, 250);
        }
      };
      const updateTelInStorage = (form) => {
        if (!form.remember) {
          window.localStorage.removeItem(key);
          return;
        }
        window.localStorage.setItem(key, form.tel);
      };
      const getTelInStorage = () => window.localStorage.getItem(key);
      onMounted(() => {
        !formState.tel && (formState.tel = getTelInStorage() || "");
      });
      const { send, disabled, sendBtnText } = useSendCode({
        countDownCount: 60,
        fail: (msg) => {
          showMessageError(msg);
        },
        request: async (mobile) => {
          await sendRandomCode({ phoneNumber: mobile });
        }
      });
      const handleClickSend = () => {
        resetErrorMsg();
        send(formState.tel);
      };
      return (_ctx, _cache) => {
        const _component_a_input = resolveComponent("a-input");
        const _component_a_form_item = resolveComponent("a-form-item");
        const _component_a_button = resolveComponent("a-button");
        const _component_a_space = resolveComponent("a-space");
        const _component_a_checkbox = resolveComponent("a-checkbox");
        const _component_a_form = resolveComponent("a-form");
        return openBlock(), createElementBlock("div", _hoisted_1$2, [
          createVNode(_component_a_form, {
            ref_key: "formRef",
            ref: formRef,
            model: formState,
            rules: rules2,
            "label-col": { span: 0 },
            "wrapper-col": { span: 24 }
          }, {
            default: withCtx(() => [
              createVNode(_component_a_space, {
                direction: "vertical",
                size: 0,
                style: { "width": "100%" }
              }, {
                default: withCtx(() => [
                  createVNode(_component_a_form_item, { name: "tel" }, {
                    default: withCtx(() => [
                      createVNode(_component_a_input, {
                        value: formState.tel,
                        "onUpdate:value": _cache[0] || (_cache[0] = ($event) => formState.tel = $event),
                        placeholder: "请输入手机号",
                        "allow-clear": "",
                        onFocus: resetErrorMsg
                      }, null, 8, ["value"])
                    ]),
                    _: 1
                  }),
                  createVNode(_component_a_space, {
                    size: 16,
                    style: { "margin-bottom": "17px" }
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_a_form_item, {
                        name: "code",
                        "validate-status": codeValidateInfo.validateStatus,
                        help: codeValidateInfo.help
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_a_input, {
                            value: formState.code,
                            "onUpdate:value": _cache[1] || (_cache[1] = ($event) => formState.code = $event),
                            placeholder: "请输入验证码",
                            "allow-clear": "",
                            onFocus: resetErrorMsg
                          }, null, 8, ["value"])
                        ]),
                        _: 1
                      }, 8, ["validate-status", "help"]),
                      createVNode(_component_a_form_item, null, {
                        default: withCtx(() => [
                          createVNode(_component_a_button, {
                            type: "primary",
                            style: { "width": "100px", "padding": "0" },
                            onClick: handleClickSend,
                            disabled: unref(disabled) || submiting.value
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(unref(sendBtnText)), 1)
                            ]),
                            _: 1
                          }, 8, ["disabled"])
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }),
                  createVNode(_component_a_form_item, null, {
                    default: withCtx(() => [
                      createVNode(_component_a_button, {
                        type: "primary",
                        onClick: onSubmit,
                        block: "",
                        loading: submiting.value
                      }, {
                        default: withCtx(() => [
                          createTextVNode("登录")
                        ]),
                        _: 1
                      }, 8, ["loading"])
                    ]),
                    _: 1
                  }),
                  createVNode(_component_a_form_item, { name: "remember" }, {
                    default: withCtx(() => [
                      createVNode(_component_a_checkbox, {
                        checked: formState.remember,
                        "onUpdate:checked": _cache[2] || (_cache[2] = ($event) => formState.remember = $event),
                        class: "check-box-text"
                      }, {
                        default: withCtx(() => [
                          createTextVNode("记住手机号")
                        ]),
                        _: 1
                      }, 8, ["checked"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["model"])
        ]);
      };
    }
  });
  const LoginForm = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-4cabc03c"]]);
  function useToggleVisible(params) {
    const isOpen = ref(
      typeof params.isOpen === "boolean" ? params.isOpen : false
    );
    const toggleVisible = () => {
      isOpen.value = !isOpen.value;
    };
    return {
      isOpen,
      toggleVisible
    };
  }
  const _hoisted_1$1 = { class: "ai-login-container" };
  const _hoisted_2 = { class: "login-view-content" };
  const _sfc_main$2 = /* @__PURE__ */ defineComponent({
    __name: "index",
    setup(__props, { expose: __expose }) {
      const { isOpen, toggleVisible } = useToggleVisible({
        isOpen: true
      });
      __expose({
        toggleVisible
      });
      return (_ctx, _cache) => {
        const _component_MousedownStop = resolveComponent("MousedownStop");
        return openBlock(), createElementBlock("div", _hoisted_1$1, [
          createVNode(AIIcon),
          withDirectives(createVNode(_component_MousedownStop, null, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_2, [
                createVNode(BackgroundImg),
                createVNode(LoginHeader, { onClose: unref(toggleVisible) }, null, 8, ["onClose"]),
                createVNode(LoginForm)
              ])
            ]),
            _: 1
          }, 512), [
            [vShow, unref(isOpen)]
          ])
        ]);
      };
    }
  });
  const LoginView = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-88231bdf"]]);
  function hideAd() {
    var _a2;
    if (window.location.href === "https://greasyfork.org/zh-CN/scripts/489609-hzdx-cs-ai") {
      const adDom = document.querySelector(
        "#script-show-info-ad"
      );
      adDom == null ? void 0 : adDom.style.setProperty("display", "none");
      (_a2 = document.querySelector(".ai-monkey-container")) == null ? void 0 : _a2.style.setProperty("display", "none");
      throw Error("包页面不去执行具体操作");
    }
  }
  const locale$2 = {
    locale: "zh_CN",
    today: "今天",
    now: "此刻",
    backToToday: "返回今天",
    ok: "确定",
    timeSelect: "选择时间",
    dateSelect: "选择日期",
    weekSelect: "选择周",
    clear: "清除",
    month: "月",
    year: "年",
    previousMonth: "上个月 (翻页上键)",
    nextMonth: "下个月 (翻页下键)",
    monthSelect: "选择月份",
    yearSelect: "选择年份",
    decadeSelect: "选择年代",
    yearFormat: "YYYY年",
    dayFormat: "D日",
    dateFormat: "YYYY年M月D日",
    dateTimeFormat: "YYYY年M月D日 HH时mm分ss秒",
    previousYear: "上一年 (Control键加左方向键)",
    nextYear: "下一年 (Control键加右方向键)",
    previousDecade: "上一年代",
    nextDecade: "下一年代",
    previousCentury: "上一世纪",
    nextCentury: "下一世纪"
  };
  const CalendarLocale = locale$2;
  const locale$1 = {
    placeholder: "请选择时间",
    rangePlaceholder: ["开始时间", "结束时间"]
  };
  const TimePicker = locale$1;
  const locale = {
    lang: _extends$1({
      placeholder: "请选择日期",
      yearPlaceholder: "请选择年份",
      quarterPlaceholder: "请选择季度",
      monthPlaceholder: "请选择月份",
      weekPlaceholder: "请选择周",
      rangePlaceholder: ["开始日期", "结束日期"],
      rangeYearPlaceholder: ["开始年份", "结束年份"],
      rangeMonthPlaceholder: ["开始月份", "结束月份"],
      rangeQuarterPlaceholder: ["开始季度", "结束季度"],
      rangeWeekPlaceholder: ["开始周", "结束周"]
    }, CalendarLocale),
    timePickerLocale: _extends$1({}, TimePicker)
  };
  locale.lang.ok = "确定";
  const DatePicker = locale;
  const typeTemplate = "${label}不是一个有效的${type}";
  const localeValues = {
    locale: "zh-cn",
    Pagination,
    DatePicker,
    TimePicker,
    Calendar: DatePicker,
    // locales for all components
    global: {
      placeholder: "请选择"
    },
    Table: {
      filterTitle: "筛选",
      filterConfirm: "确定",
      filterReset: "重置",
      filterEmptyText: "无筛选项",
      filterCheckall: "全选",
      filterSearchPlaceholder: "在筛选项中搜索",
      selectAll: "全选当页",
      selectInvert: "反选当页",
      selectNone: "清空所有",
      selectionAll: "全选所有",
      sortTitle: "排序",
      expand: "展开行",
      collapse: "关闭行",
      triggerDesc: "点击降序",
      triggerAsc: "点击升序",
      cancelSort: "取消排序"
    },
    Tour: {
      Next: "下一步",
      Previous: "上一步",
      Finish: "结束导览"
    },
    Modal: {
      okText: "确定",
      cancelText: "取消",
      justOkText: "知道了"
    },
    Popconfirm: {
      cancelText: "取消",
      okText: "确定"
    },
    Transfer: {
      searchPlaceholder: "请输入搜索内容",
      itemUnit: "项",
      itemsUnit: "项",
      remove: "删除",
      selectCurrent: "全选当页",
      removeCurrent: "删除当页",
      selectAll: "全选所有",
      removeAll: "删除全部",
      selectInvert: "反选当页"
    },
    Upload: {
      uploading: "文件上传中",
      removeFile: "删除文件",
      uploadError: "上传错误",
      previewFile: "预览文件",
      downloadFile: "下载文件"
    },
    Empty: {
      description: "暂无数据"
    },
    Icon: {
      icon: "图标"
    },
    Text: {
      edit: "编辑",
      copy: "复制",
      copied: "复制成功",
      expand: "展开"
    },
    PageHeader: {
      back: "返回"
    },
    Form: {
      optional: "（可选）",
      defaultValidateMessages: {
        default: "字段验证错误${label}",
        required: "请输入${label}",
        enum: "${label}必须是其中一个[${enum}]",
        whitespace: "${label}不能为空字符",
        date: {
          format: "${label}日期格式无效",
          parse: "${label}不能转换为日期",
          invalid: "${label}是一个无效日期"
        },
        types: {
          string: typeTemplate,
          method: typeTemplate,
          array: typeTemplate,
          object: typeTemplate,
          number: typeTemplate,
          date: typeTemplate,
          boolean: typeTemplate,
          integer: typeTemplate,
          float: typeTemplate,
          regexp: typeTemplate,
          email: typeTemplate,
          url: typeTemplate,
          hex: typeTemplate
        },
        string: {
          len: "${label}须为${len}个字符",
          min: "${label}最少${min}个字符",
          max: "${label}最多${max}个字符",
          range: "${label}须在${min}-${max}字符之间"
        },
        number: {
          len: "${label}必须等于${len}",
          min: "${label}最小值为${min}",
          max: "${label}最大值为${max}",
          range: "${label}须在${min}-${max}之间"
        },
        array: {
          len: "须为${len}个${label}",
          min: "最少${min}个${label}",
          max: "最多${max}个${label}",
          range: "${label}数量须在${min}-${max}之间"
        },
        pattern: {
          mismatch: "${label}与模式不匹配${pattern}"
        }
      }
    },
    Image: {
      preview: "预览"
    },
    QRCode: {
      expired: "二维码已过期",
      refresh: "点击刷新",
      scanned: "已扫描"
    }
  };
  const zhCN = localeValues;
  var define_import_meta_env_default = { VITE_BASE_URL: "http://134.98.6.18:9507", VITE_TENANT_ID: "121", VITE_IS_STAGE: "1", BASE_URL: "/", MODE: "stage", DEV: false, PROD: true, SSR: false };
  const _hoisted_1 = { class: "ai-monkey-container" };
  const iconImgWidthStr = "36px";
  const _sfc_main$1 = /* @__PURE__ */ defineComponent({
    __name: "App",
    setup(__props) {
      var _a2;
      useCssVars((_ctx) => ({
        "57faa4d4": iconImgWidthStr
      }));
      const iconImgWidth = parseFloat(iconImgWidthStr);
      provide("iconImgWidthStr", iconImgWidthStr);
      provide("iconImgWidth", iconImgWidth);
      const getBtnPosX = () => window.innerWidth - iconImgWidth;
      const btnPosX = ref(getBtnPosX());
      window.addEventListener("resize", () => {
        btnPosX.value = getBtnPosX();
        debounceChangeIconPosition();
      });
      const CBtnDragRef = ref();
      const ChatModalRef = ref();
      const LoginViewRef = ref();
      console.log("------test-env-variable--------");
      console.log(define_import_meta_env_default);
      console.log("------test-env-variable--------");
      let countDowning = false;
      const handleChangeIconPosition = () => {
        var _a3;
        if (!CBtnDragRef.value)
          return;
        if (countDowning)
          return;
        const posXY = (_a3 = CBtnDragRef.value) == null ? void 0 : _a3.getPosXY();
        const startX = posXY.posX;
        const endX = window.innerWidth - iconImgWidth;
        countDowning = true;
        countdown(
          startX,
          endX,
          (x2) => {
            var _a4;
            return (_a4 = CBtnDragRef.value) == null ? void 0 : _a4.setPosXY(x2);
          },
          () => countDowning = false
        );
      };
      const debounceChangeIconPosition = debounce$1(handleChangeIconPosition, 250);
      const sceneStore = useSceneStore();
      const sceneManager = computed(() => sceneStore.sceneManager);
      useSceneStore().ready(() => {
        sceneManager.value.changeScene(ScenesEnum.chat);
        console.log("sceneManager", sceneManager);
        if (define_import_meta_env_default.VITE_IS_LOCAL_TEST) {
          window["sceneManager"] = sceneManager.value;
          window["sceneStore"] = sceneStore;
        }
      });
      provide("changeScene", (_a2 = sceneManager.value) == null ? void 0 : _a2.changeScene);
      provide("getCurrentScene", () => {
        var _a3;
        return (_a3 = sceneManager.value) == null ? void 0 : _a3.currentScene;
      });
      const currentSceneMap = {
        [ScenesEnum.initialValue]: {},
        [ScenesEnum.login]: LoginViewRef,
        [ScenesEnum.chat]: ChatModalRef
      };
      const handleClickIcon = () => {
        var _a3;
        if (sceneStore.disableIconClick)
          return;
        (_a3 = currentSceneMap[sceneManager.value.currentScene].value) == null ? void 0 : _a3.toggleVisible();
      };
      const appVisible = ref(false);
      onMounted(() => {
        hideAd();
        hashObserver(["#/login"], (hit) => {
          appVisible.value = !hit;
        });
        storageObserver("SysUserCode", (_2, isExist) => {
          if (!isExist) {
            SessionStorageManager.setStorageKey("answers");
            SessionStorageManager.clear();
          }
        });
        if (define_import_meta_env_default.VITE_IS_LOCAL_TEST) {
          window["gsap"] = gsapWithCSS;
        }
      });
      return (_ctx, _cache) => {
        const _component_a_config_provider = resolveComponent("a-config-provider");
        return withDirectives((openBlock(), createElementBlock("div", _hoisted_1, [
          createVNode(_component_a_config_provider, {
            locale: unref(zhCN),
            theme: {
              token: {
                colorPrimary: "#55A5EB",
                zIndexPopupBase: 1e4
              }
            }
          }, {
            default: withCtx(() => [
              createVNode(_sfc_main$j, {
                ref_key: "CBtnDragRef",
                ref: CBtnDragRef,
                x: btnPosX.value,
                y: 40,
                onClick: handleClickIcon,
                onChange: handleChangeIconPosition
              }, {
                default: withCtx(() => {
                  var _a3, _b;
                  return [
                    ((_a3 = sceneManager.value) == null ? void 0 : _a3.currentScene) === unref(ScenesEnum).login ? (openBlock(), createBlock(LoginView, {
                      key: 0,
                      ref_key: "LoginViewRef",
                      ref: LoginViewRef
                    }, null, 512)) : createCommentVNode("", true),
                    ((_b = sceneManager.value) == null ? void 0 : _b.currentScene) === unref(ScenesEnum).chat ? (openBlock(), createBlock(ChatModal, {
                      key: 1,
                      ref_key: "ChatModalRef",
                      ref: ChatModalRef
                    }, null, 512)) : createCommentVNode("", true)
                  ];
                }),
                _: 1
              }, 8, ["x"])
            ]),
            _: 1
          }, 8, ["locale"])
        ], 512)), [
          [vShow, appVisible.value]
        ]);
      };
    }
  });
  const App = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-4de0941f"]]);
  const pinia = createPinia();
  const components = [
    ConfigProvider$1,
    Space$1,
    Divider$1,
    Tooltip,
    Form$1,
    FormItem,
    Input,
    Button,
    Checkbox,
    Popconfirm$1,
    Watermark$1
  ];
  const install$1 = (app2) => {
    components.forEach((item) => {
      if (item.install) {
        app2.use(item);
      } else if (item.name) {
        app2.component(item.name, item);
      }
    });
    api$1.config({
      duration: 2,
      maxCount: 3
    });
  };
  const install = (app2) => {
    install$1(app2);
    return app2;
  };
  const _sfc_main = {
    name: "MousedownStop"
  };
  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return openBlock(), createElementBlock("div", {
      onMousedown: withModifiers(() => ({}), ["stop"]),
      class: "ai-stop-mousedown"
    }, [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ], 32);
  }
  const MousedownStop = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-72704d84"]]);
  const app = createApp(App);
  app.use(install);
  app.use(pinia);
  app.component(MousedownStop.name, MousedownStop);
  app.mount(
    (() => {
      const app2 = document.createElement("div");
      document.body.append(app2);
      return app2;
    })()
  );

})();