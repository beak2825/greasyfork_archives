// ==UserScript==
// @name         Symfony 翻译文档 components/http_kernel.html
// @namespace    fireloong
// @version      0.1.1
// @description  翻译文档 components/http_kernel.html
// @author       Itsky71
// @match        https://symfony.com/doc/5.x/components/http_kernel.html
// @match        https://symfony.com/doc/6.4/components/http_kernel.html
// @match        https://symfony.com/doc/7.1/components/http_kernel.html
// @match        https://symfony.com/doc/7.2/components/http_kernel.html
// @match        https://symfony.com/doc/current/components/http_kernel.html
// @icon         https://www.google.com/s2/favicons?sz=64&domain=symfony.com
// @require      https://unpkg.com/jquery@3.7.1/dist/jquery.min.js
// @require      https://update.greasyfork.org/scripts/503008/fanyi.js
// @grant        none
// @license      MIT
// @downloadURL https://update.greasyfork.org/scripts/496286/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20componentshttp_kernelhtml.user.js
// @updateURL https://update.greasyfork.org/scripts/496286/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20componentshttp_kernelhtml.meta.js
// ==/UserScript==

(function($) {
    'use strict';

    const translates = {
        '\n        \n                    The HttpKernel Component\n        \n            ': 'HttpKernel 组件',
        'The HttpKernel component provides a structured process for converting\na Request into a Response by making use of the EventDispatcher\ncomponent. It\'s flexible enough to create a full-stack framework (Symfony)\nor an advanced CMS (Drupal).': 'HTTP 内核组件通过利用事件分发器（EventDispatcher）组件提供了一个将 <code translate="no" class="notranslate">Request</code> 转化为 <code translate="no" class="notranslate">Response</code> 的结构化流程。它足够灵活，可以用来创建全栈框架（如 Symfony）或高级内容管理系统（如 Drupal）。',

        'Installation': '安装',
        'If you install this component outside of a Symfony application, you must\nrequire the vendor/autoload.php file in your code to enable the class\nautoloading mechanism provided by Composer. Read\nthis article for more details.': '如果你在非 Symfony 应用程序外部安装此组件，你必须在代码中引入 <code translate="no" class="notranslate">vendor/autoload.php</code> 文件，以启用 Composer 提供的类自动加载机制。阅读<a href="using_components.html" class="reference internal">这篇文章</a>以获取更多详细信息。',

        'The Request-Response Lifecycle': '请求-响应生命周期',
        'This article explains how to use the HttpKernel features as an independent\ncomponent in any PHP application. In Symfony applications everything is\nalready configured and ready to use. Read the Controller and\nEvents and Event Listeners articles to learn about how to use it to create\ncontrollers and define events in Symfony applications.': '本文介绍了如何在任何 PHP 应用程序中作为独立组件使用 HttpKernel 功能。在 Symfony 应用程序中，所有内容都已配置好并可以使用。阅读 <a href="../controller.html" class="reference internal">控制器</a> 和 <a href="../event_dispatcher.html" class="reference internal">事件和事件侦听器</a> 文章，了解如何在 Symfony 应用程序中使用它来创建控制器和定义事件。',
        'Every HTTP web interaction begins with a request and ends with a response.\nYour job as a developer is to create PHP code that reads the request information\n(e.g. the URL) and creates and returns a response (e.g. an HTML page or JSON string).\nThis is a simplified overview of the request-response lifecycle in Symfony applications:': '每次 HTTP Web 交互都以请求开始并以响应结束。作为开发人员，你的工作是创建 PHP 代码来读取请求信息（例如 URL），并创建和返回响应（例如 HTML 页面或 JSON 字符串）。这是 Symfony 应用程序中请求-响应生命周期的简化概述：',
        'The user asks for a resource in a browser;': '<strong>用户</strong>在<strong>浏览器</strong>中请求一个<strong>资源</strong>；',
        'The browser sends a request to the server;': '<strong>浏览器</strong>向<strong>服务器</strong>发送<strong>请求</strong>；',
        'Symfony gives the application a Request object;': '<strong>Symfony</strong> 向<strong>应用程序</strong>提供一个 <strong>Request</strong> 对象；',
        'The application generates a Response object using the data of the Request object;': '<strong>应用程序</strong>使用 <strong>Request</strong> 对象的数据生成一个 <strong>Response</strong> 对象；',
        'The server sends back the response to the browser;': '<strong>服务器</strong>将<strong>响应</strong>发送回<strong>浏览器</strong>；',
        'The browser displays the resource to the user.': '<strong>浏览器</strong>向<strong>用户</strong>显示<strong>资源</strong>。',
        'Typically, some sort of framework or system is built to handle all the repetitive\ntasks (e.g. routing, security, etc) so that a developer can build each page of\nthe application. Exactly how these systems are built varies greatly. The HttpKernel\ncomponent provides an interface that formalizes the process of starting with a\nrequest and creating the appropriate response. The component is meant to be the\nheart of any application or framework, no matter how varied the architecture of\nthat system:': '通常，会构建某种框架或系统来处理所有重复性的任务（例如路由、安全性等），以便开发人员可以构建应用程序的每个页面。这些系统的构建方式差异很大。HttpKernel 组件提供了一个接口，用于正式化从请求开始并创建适当响应的过程。该组件旨在成为任何应用程序或框架的核心，无论该系统的架构如何变化：',
        'Internally, HttpKernel::handle() -\nthe concrete implementation of HttpKernelInterface::handle() -\ndefines a lifecycle that starts with a Request\nand ends with a Response.': '在内部，<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/HttpKernel.php#:~:text=function%20handle" class="reference external" title="Symfony\Component\HttpKernel\HttpKernel::handle()" rel="external noopener noreferrer" target="_blank">HttpKernel::handle()</a>（即 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/HttpKernelInterface.php#:~:text=function%20handle" class="reference external" title="Symfony\Component\HttpKernel\HttpKernelInterface::handle()" rel="external noopener noreferrer" target="_blank">HttpKernelInterface::handle()</a> 的具体实现）定义了一个生命周期，该生命周期以 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpFoundation/Request.php" class="reference external" title="Symfony\Component\HttpFoundation\Request" rel="external noopener noreferrer" target="_blank">Request</a> 开始，以 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpFoundation/Response.php" class="reference external" title="Symfony\Component\HttpFoundation\Response" rel="external noopener noreferrer" target="_blank">Response</a> 结束。',
        'The exact details of this lifecycle are the key to understanding how the kernel\n(and the Symfony Framework or any other library that uses the kernel) works.': '理解这个生命周期的确切细节是了解内核（以及 Symfony 框架或任何其它使用内核的库）如何工作的关键。',

        'HttpKernel: Driven by Events': 'HttpKernel：由事件驱动',
        'The HttpKernel::handle() method works internally by dispatching events.\nThis makes the method both flexible, but also a bit abstract, since all the\n"work" of a framework/application built with HttpKernel is actually done\nin event listeners.': '<code translate="no" class="notranslate">HttpKernel::handle()</code> 方法内部通过分发事件来工作。这使得该方法既灵活又有点抽象，因为使用 HttpKernel 构建的所有框架/应用程序的“工作”实际上都是在事件监听器中完成的。',
        'To help explain this process, this document looks at each step of the process\nand talks about how one specific implementation of the HttpKernel - the Symfony\nFramework - works.': '为了有助于解释这个过程，本文会查看这个过程的每一步，并讨论 HttpKernel 的一个具体实现（Symfony 框架）是如何工作的。',
        "Initially, using the HttpKernel does\nnot take many steps. You create an\nevent dispatcher and a\ncontroller and argument resolver\n(explained below). To complete your working kernel, you'll add more event\nlisteners to the events discussed below:": '最初，使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/HttpKernel.php" class="reference external" title="Symfony\Component\HttpKernel\HttpKernel" rel="external noopener noreferrer" target="_blank">HttpKernel</a> 并不需要很多步骤。您需要创建一个<a href="event_dispatcher.html" class="reference internal">事件分发器</a>、一个<a href="http_kernel.html#component-http-kernel-resolve-controller" class="reference internal">控制器以及参数解析器</a>（下面会解释）。为了完成您的工作内核，您需要将更多的事件监听器添加到下面讨论的事件中：',
        'See "A full working example" for a more concrete implementation.': '请参阅“<a href="http_kernel.html#http-kernel-working-example" class="reference internal">一个完整的工作示例</a>”，以获取更具体的实现方式。',
        'For general information on adding listeners to the events below, see\nCreating an Event Listener.': '关于将监听器添加到以下事件的通用信息，请参阅“<a href="http_kernel.html#http-kernel-creating-listener" class="reference internal">创建事件监听器</a>”。',
        'There is a wonderful tutorial series on using the HttpKernel component and\nother Symfony components to create your own framework. See\nIntroduction.': '有一个精彩的教程系列，它介绍了如何使用 HttpKernel 组件和其它 Symfony 组件来创建您自己的框架。请参阅“<a href="../create_framework/introduction.html" class="reference internal">介绍</a>”。',
        '1) The kernel.request Event': '1) <code translate="no" class="notranslate">kernel.request</code> 事件',
        'Typical Purposes: To add more information to the Request, initialize\nparts of the system, or return a Response if possible (e.g. a security\nlayer that denies access).': '<strong>典型用途</strong>：向 <code translate="no" class="notranslate">Request</code> 添加更多信息，初始化系统的部分组件，或者在可能的情况下返回 <code translate="no" class="notranslate">Response</code>（例如，拒绝访问的安全层）。',
        'Kernel Events Information Table': '<a href="http_kernel.html#component-http-kernel-event-table" class="reference internal">内核事件信息表</a>',
        'The first event that is dispatched inside HttpKernel::handle\nis kernel.request, which may have a variety of different listeners.': '在 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/HttpKernel.php#:~:text=function%20handle" class="reference external" title="Symfony\Component\HttpKernel\HttpKernel::handle()" rel="external noopener noreferrer" target="_blank">HttpKernel::handle</a> 内部分发的第一个事件是 <code translate="no" class="notranslate">kernel.request</code>，它可能具有许多不同的监听器。',
        "Listeners of this event can be quite varied. Some listeners - such as a security\nlistener - might have enough information to create a Response object immediately.\nFor example, if a security listener determined that a user doesn't have access,\nthat listener may return a RedirectResponse\nto the login page or a 403 Access Denied response.": '这个事件的监听器可能差异很大。一些监听器（例如安全监听器）可能拥有足够的信息来立即创建 <code translate="no" class="notranslate">Response</code> 对象。例如，如果安全监听器确定用户没有访问权限，那么该监听器可能会返回一个重定向到登录页面的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpFoundation/RedirectResponse.php" class="reference external" title="Symfony\Component\HttpFoundation\RedirectResponse" rel="external noopener noreferrer" target="_blank">RedirectResponse</a> 或一个 403 Access Denied 响应。',
        'If a Response is returned at this stage, the process skips directly to\nthe kernel.response event.': '如果在此阶段返回了 <code translate="no" class="notranslate">Response</code>，则流程会直接跳过，直接触发 <a href="http_kernel.html#component-http-kernel-kernel-response" class="reference internal">kernel.response</a> 事件。',
        'Other listeners initialize things or add more information to the request.\nFor example, a listener might determine and set the locale on the Request\nobject.': '其它监听器会初始化事物或将更多信息添加到请求中。例如，监听器可能会确定并设置 <code translate="no" class="notranslate">Request</code> 对象上的区域设置。',
        'Another common listener is routing. A router listener may process the Request\nand determine the controller that should be rendered (see the next section).\nIn fact, the Request object has an "attributes"\nbag which is a perfect spot to store this extra, application-specific data\nabout the request. This means that if your router listener somehow determines\nthe controller, it can store it on the Request attributes (which can be used\nby your controller resolver).': '另一个常见的监听器是路由。路由器监听器可能会处理 <code translate="no" class="notranslate">Request</code> 并确定应呈现哪个控制器（请参阅下一节）。实际上，<code translate="no" class="notranslate">Request</code> 对象有一个“<a href="http_foundation.html#component-foundation-attributes" class="reference internal">attributes</a>”包，它是存储此额外、特定于应用程序的请求数据的完美位置。这意味着，如果您的路由器监听器以某种方式确定了控制器，它可以将控制器存储在 <code translate="no" class="notranslate">Request</code 属性上（这可以由您的控制器解析器使用）。',
        'Overall, the purpose of the kernel.request event is either to create and\nreturn a Response directly, or to add information to the Request\n(e.g. setting the locale or setting some other information on the Request\nattributes).': '总体而言，<code translate="no" class="notranslate">kernel.request</code> 事件的目的是创建并直接返回一个 <code translate="no" class="notranslate">Response</code>，或者向 <code translate="no" class="notranslate">Request</code> 添加信息（例如设置区域设置或在 <code translate="no" class="notranslate">Request</code> 属性上设置其它信息）。',
        "When setting a response for the kernel.request event, the propagation\nis stopped. This means listeners with lower priority won't be executed.": '在为 <code translate="no" class="notranslate">kernel.request</code> 事件设置响应时，传播会停止。这意味着优先级较低的监听器将不会被执行。',
        'kernel.request in the Symfony Framework': 'Symfony 框架中的 <code translate="no" class="notranslate">kernel.request</code>',
        "The most important listener to kernel.request in the Symfony Framework\nis the RouterListener.\nThis class executes the routing layer, which returns an array of information\nabout the matched request, including the _controller and any placeholders\nthat are in the route's pattern (e.g. {slug}). See the\nRouting documentation.": '在 Symfony 框架中，对 <code translate="no" class="notranslate">kernel.request</code> 事件最重要的监听器是 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/EventListener/RouterListener.php" class="reference external" title="Symfony\Component\HttpKernel\EventListener\RouterListener" rel="external noopener noreferrer" target="_blank">RouterListener</a>。这个类执行路由层，返回一个关于匹配请求的信息数组，包括 <code translate="no" class="notranslate">_controller</code> 和路由模式中的任何占位符（例如 <code translate="no" class="notranslate">{slug}</code>）。请参阅<a href="../routing.html" class="reference internal">路由文档</a>。',
        "This array of information is stored in the Request\nobject's attributes array. Adding the routing information here doesn't\ndo anything yet, but is used next when resolving the controller.": '这个信息数组被存储在 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpFoundation/Request.php" class="reference external" title="Symfony\Component\HttpFoundation\Request" rel="external noopener noreferrer" target="_blank">Request</a> 对象的 <code translate="no" class="notranslate">attributes</code> 数组中。在这里添加路由信息目前还不起作用，但在解析控制器时会用到它。',
        '2) Resolve the Controller': '2) 解析控制器',
        "Assuming that no kernel.request listener was able to create a Response,\nthe next step in HttpKernel is to determine and prepare (i.e. resolve) the\ncontroller. The controller is the part of the end-application's code that\nis responsible for creating and returning the Response for a specific page.\nThe only requirement is that it is a PHP callable - i.e. a function, method\non an object or a Closure.": '假设没有 <code translate="no" class="notranslate">kernel.request</code> 监听器能够创建一个 <code translate="no" class="notranslate">Response</code>，HttpKernel 的下一步就是确定并准备（即解析）控制器。控制器是最终应用程序代码的一部分，负责为特定页面创建和返回 <code translate="no" class="notranslate">Response</code>。唯一的要求是它是一个 PHP 可调用对象，即一个函数、对象上的方法或 <code translate="no" class="notranslate">Closure</code>。',
        'But how you determine the exact controller for a request is entirely up\nto your application. This is the job of the "controller resolver" - a class\nthat implements ControllerResolverInterface\nand is one of the constructor arguments to HttpKernel.': '但是如何确定请求的精确控制器完全取决于您的应用程序。这是“控制器解析器”的工作——一个实现了 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Controller/ControllerResolverInterface.php" class="reference external" title="Symfony\Component\HttpKernel\Controller\ControllerResolverInterface" rel="external noopener noreferrer" target="_blank">ControllerResolverInterface</a> 的类，并且是 <code translate="no" class="notranslate">HttpKernel</code> 的构造函数参数之一。',
        'Your job is to create a class that implements the interface and fill in its\nmethod: getController(). In fact, one default implementation already\nexists, which you can use directly or learn from:\nControllerResolver.\nThis implementation is explained more in the sidebar below:': '您的工作是创建一个实现该接口的类，并填写其方法：<code translate="no" class="notranslate">getController()</code>。事实上，已经存在一个默认实现，您可以直接使用或从中学习：<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Controller/ControllerResolver.php" class="reference external" title="Symfony\Component\HttpKernel\Controller\ControllerResolver" rel="external noopener noreferrer" target="_blank">ControllerResolver</a>。这个实现在下面的侧边栏中有更详细的解释：',
        "Internally, the HttpKernel::handle() method first calls\ngetController()\non the controller resolver. This method is passed the Request and is responsible\nfor somehow determining and returning a PHP callable (the controller) based\non the request's information.": '在内部，<code translate="no" class="notranslate">HttpKernel::handle()</code> 方法首先调用控制器解析器上的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Controller/ControllerResolverInterface.php#:~:text=function%20getController" class="reference external" title="Symfony\Component\HttpKernel\Controller\ControllerResolverInterface::getController()" rel="external noopener noreferrer" target="_blank">getController()</a> 方法。该方法将 <code translate="no" class="notranslate">Request</code> 作为参数传递，并负责根据请求的信息以某种方式确定并返回一个 PHP 可调用对象（控制器）。',
        'Resolving the Controller in the Symfony Framework': '解析 Symfony 框架中的控制器',
        "The Symfony Framework uses the built-in\nControllerResolver\nclass (actually, it uses a subclass with some extra functionality\nmentioned below). This class leverages the information that was placed\non the Request object's attributes property during the RouterListener.": 'Symfony 框架使用内置的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Controller/ControllerResolver.php" class="reference external" title="Symfony\Component\HttpKernel\Controller\ControllerResolver" rel="external noopener noreferrer" target="_blank">ControllerResolver</a> 类（实际上，它使用了一个具有一些额外功能的子类，下面会提到）。这个类利用了 <code translate="no" class="notranslate">RouterListener</code> 在 <code translate="no" class="notranslate">Request</code> 对象的 <code translate="no" class="notranslate">attributes</code> 属性上放置的信息。',
        "The ControllerResolver looks for a _controller\nkey on the Request object's attributes property (recall that this\ninformation is typically placed on the Request via the RouterListener).\nThis string is then transformed into a PHP callable by doing the following:": '<code translate="no" class="notranslate">ControllerResolver</code> 在 <code translate="no" class="notranslate">Request</code> 对象的 attributes 属性上查找 <code translate="no" class="notranslate">_controller</code> 键（请记住，这些信息通常是通过 <code translate="no" class="notranslate">RouterListener</code> 放置在 <code translate="no" class="notranslate">Request</code> 上的）。然后，通过执行以下操作，将这个字符串转换为 PHP 可调用对象：',
        "a) If the _controller key doesn't follow the recommended PHP namespace": '如果 <code translate="no" class="notranslate">_controller</code> 键不遵循推荐的 PHP 命名空间',
        '\n                            format (e.g. App\\Controller\\DefaultController::index) its format is\ntransformed into it. For example, the legacy FooBundle:Default:index\nformat would be changed to Acme\\FooBundle\\Controller\\DefaultController::indexAction.\nThis transformation is specific to the ControllerResolver\nsub-class used by the Symfony Framework.\n                    ': '其格式（例如 <code translate="no" class="notranslate">App\\Controller\\DefaultController::index</code>）会被转换成它本身。例如，旧的 <code translate="no" class="notranslate">FooBundle:Default:index</code> 格式会被更改为 <code translate="no" class="notranslate">Acme\\FooBundle\\Controller\\DefaultController::indexAction</code>。这种转换特定于 Symfony 框架使用的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/FrameworkBundle/Controller/ControllerResolver.php" class="reference external" title="Symfony\Bundle\FrameworkBundle\Controller\ControllerResolver" rel="external noopener noreferrer" target="_blank">ControllerResolver</a> 子类。',
        'b) A new instance of your controller class is instantiated with no': 'b) 你的控制器类的一个新实例被实例化，没有任何（参数或依赖）',
        '\n                            constructor arguments.\n                    ': '构造函数参数。',
         'c) If the controller implements ContainerAwareInterface,': '如果控制器实现了 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/DependencyInjection/ContainerAwareInterface.php" class="reference external" title="Symfony\Component\DependencyInjection\ContainerAwareInterface" rel="external noopener noreferrer" target="_blank">ContainerAwareInterface</a> 接口，',
        '\n                            setContainer() is called on the controller object and the container\nis passed to it. This step is also specific to the  ControllerResolver\nsub-class used by the Symfony Framework.\n                    ': '则会在控制器对象上调用 <code translate="no" class="notranslate">setContainer()</code> 方法，并将容器传递给它。这一步也特定于 Symfony 框架使用的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/FrameworkBundle/Controller/ControllerResolver.php" class="reference external" title="Symfony\Bundle\FrameworkBundle\Controller\ControllerResolver" rel="external noopener noreferrer" target="_blank">ControllerResolver</a> 子类。',
        'ContainerAwareInterface and\nContainerAwareTrait are\ndeprecated since Symfony 6.4. Dependency injection should be used instead to\naccess the service container.': '从 Symfony 6.4 版本开始，<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/DependencyInjection/ContainerAwareInterface.php" class="reference external" title="Symfony\Component\DependencyInjection\ContainerAwareInterface" rel="external noopener noreferrer" target="_blank">ContainerAwareInterface</a> 和 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/DependencyInjection/ContainerAwareTrait.php" class="reference external" title="Symfony\Component\DependencyInjection\ContainerAwareTrait" rel="external noopener noreferrer" target="_blank">ContainerAwareTrait</a> 已被弃用。应该使用依赖注入来访问服务容器。',
        '3) The kernel.controller Event': '3) <code translate="no" class="notranslate">kernel.controller</code> 事件',
        'Typical Purposes: Initialize things or change the controller just before\nthe controller is executed.': '<strong>典型用途</strong>：在控制器执行之前初始化事物或更改控制器。',
        'After the controller callable has been determined, HttpKernel::handle()\ndispatches the kernel.controller event. Listeners to this event might initialize\nsome part of the system that needs to be initialized after certain things\nhave been determined (e.g. the controller, routing information) but before\nthe controller is executed.': '在确定了控制器的可调用之后，<code translate="no" class="notranslate">HttpKernel::handle()</code> 会分派 <code translate="no" class="notranslate">kernel.controller</code> 事件。监听此事件的监听器可能会初始化系统的某些部分，这些部分需要在某些事情确定后（例如控制器、路由信息）但在控制器执行之前进行初始化。',
        'Another typical use-case for this event is to retrieve the attributes from\nthe controller using the getAttributes()\nmethod. See the Symfony section below for some examples.': '这个事件的另一个典型用例是使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Event/ControllerEvent.php#:~:text=function%20getAttributes" class="reference external" title="Symfony\Component\HttpKernel\Event\ControllerEvent::getAttributes()" rel="external noopener noreferrer" target="_blank">getAttributes()</a> 方法从控制器中获取属性。请参阅下面的 Symfony 部分，其中有一些示例。',
        'The ControllerEvent::getAttributes() method was introduced in Symfony 6.2.': '<code translate="no" class="notranslate">ControllerEvent::getAttributes()</code> 方法是在 Symfony 6.2 中引入的。',
        "Listeners to this event can also change the controller callable completely\nby calling ControllerEvent::setController\non the event object that's passed to listeners on this event.":'该事件的监听器还可以通过在传递给该事件监听器的事件对象上调用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Event/ControllerEvent.php#:~:text=function%20setController" class="reference external" title="Symfony\Component\HttpKernel\Event\ControllerEvent::setController()" rel="external noopener noreferrer" target="_blank">ControllerEvent::setController</a> 方法来完全更改控制器可调用项。',
        'kernel.controller in the Symfony Framework': 'Symfony 框架中的 kernel.controller',
        'An interesting listener to kernel.controller in the Symfony\nFramework is CacheAttributeListener.\nThis class fetches #[Cache] attribute configuration from the\ncontroller and uses it to configure HTTP caching\non the response.': '在 Symfony 框架中，一个有趣的 <code translate="no" class="notranslate">kernel.controller</code> 事件监听器是 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/EventListener/CacheAttributeListener.php" class="reference external" title="Symfony\Component\HttpKernel\EventListener\CacheAttributeListener" rel="external noopener noreferrer" target="_blank">CacheAttributeListener</a>。这个类从控制器中获取 <code translate="no" class="notranslate">#[Cache]</code> 属性配置，并使用它来配置响应的 <a href="../http_cache.html" class="reference internal">HTTP 缓存</a>。',
        'There are a few other minor listeners to the kernel.controller event in\nthe Symfony Framework that deal with collecting profiler data when the\nprofiler is enabled.': '在 Symfony 框架中，还有少数其它次要的 <code translate="no" class="notranslate">kernel.controller</code> 事件监听器，它们用于在启用 Profiler 时收集 Profiler 数据。',
        '4) Getting the Controller Arguments': '4) 获取控制器参数',
        'Next, HttpKernel::handle() calls\nArgumentResolverInterface::getArguments().\nRemember that the controller returned in getController() is a callable.\nThe purpose of getArguments() is to return the array of arguments that\nshould be passed to that controller. Exactly how this is done is completely\nup to your design, though the built-in ArgumentResolver\nis a good example.': '接下来，<code translate="no" class="notranslate">HttpKernel::handle()</code> 会调用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Controller/ArgumentResolverInterface.php#:~:text=function%20getArguments" class="reference external" title="Symfony\Component\HttpKernel\Controller\ArgumentResolverInterface::getArguments()" rel="external noopener noreferrer" target="_blank">ArgumentResolverInterface::getArguments()</a>。请记住， <code translate="no" class="notranslate">getController()</code> 返回的控制器是一个可调用的对象。<code translate="no" class="notranslate">getArguments()</code> 的目的是返回应该传递给该控制器的参数数组。具体如何做到这一点完全取决于你的设计，尽管内置的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Controller/ArgumentResolver.php" class="reference external" title="Symfony\Component\HttpKernel\Controller\ArgumentResolver" rel="external noopener noreferrer" target="_blank">ArgumentResolver</a> 是一个很好的例子。',
        'At this point the kernel has a PHP callable (the controller) and an array\nof arguments that should be passed when executing that callable.': '此时，内核已经有一个 PHP 可调用对象（即控制器）以及一个参数数组，这些参数应该在执行该可调用对象时传递。',
        'Getting the Controller Arguments in the Symfony Framework': '在 Symfony 框架中获取控制器参数',
        'Now that you know exactly what the controller callable (usually a method\ninside a controller object) is, the ArgumentResolver uses reflection\non the callable to return an array of the names of each of the arguments.\nIt then iterates over each of these arguments and uses the following tricks\nto determine which value should be passed for each argument:': '既然你已经确切地知道了控制器可调用对象（通常是控制器对象内部的一个方法）是什么，<code translate="no" class="notranslate">ArgumentResolver</code> 就会对这个可调用对象进行<a href="https://www.php.net/manual/zh/book.reflection.php" class="reference external" rel="external noopener noreferrer" target="_blank">反射</a>，以返回一个数组，其中包含了每个参数的名称。然后，它会对这些参数进行迭代，并使用以下技巧来确定应该为每个参数传递哪个值：',
        'a) If the Request attributes bag contains a key that matches the name': 'a) 如果 <code translate="no" class="notranslate">Request</code> 属性包含一个与参数名称匹配的键，则该值会被使用。',
        '\n                            of the argument, that value is used. For example, if the first argument\nto a controller is $slug and there is a slug key in the Request\nattributes bag, that value is used (and typically this value came\nfrom the RouterListener).\n                    ': '例如，如果控制器的第一个参数是 <code translate="no" class="notranslate">$slug</code>，并且在 <code translate="no" class="notranslate">Request</code> <code translate="no" class="notranslate">attributes</code> 包中有一个 <code translate="no" class="notranslate">slug</code> 键，那么就会使用该值（通常这个值来自 <code translate="no" class="notranslate">RouterListener</code>）。',
        "b) If the argument in the controller is type-hinted with Symfony's": 'b) 如果控制器中的参数被类型提示为 Symfony 的',
        '\n                            Request object, the\nRequest is passed in as the value.\n                    ': '<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpFoundation/Request.php" class="reference external" title="Symfony\Component\HttpFoundation\Request" rel="external noopener noreferrer" target="_blank">Request</a> 对象，那么会将 <code translate="no" class="notranslate">Request</code> 作为值传递进去。',
        'c) If the function or method argument is variadic and the Request': 'c) 如果函数或方法参数是可变数量的（<a href="https://www.php.net/manual/zh/functions.arguments.php#functions.variable-arg-list" class="reference external" rel="external noopener noreferrer" target="_blank">variadic</a>），并且 <code translate="no" class="notranslate">Request</code>',
        '\n                            attributes bag contains an array for that argument, they will all be\navailable through the variadic argument.\n                    ': '<code translate="no" class="notranslate">attributes</code> 包包含该参数的数组，那么这些值都将通过 <a href="https://www.php.net/manual/zh/functions.arguments.php#functions.variable-arg-list" class="reference external" rel="external noopener noreferrer" target="_blank">variadic</a> 参数获得。',
        'This functionality is provided by resolvers implementing the\nValueResolverInterface.\nThere are four implementations which provide the default behavior of\nSymfony but customization is the key here. By implementing the\nValueResolverInterface yourself and passing this to the\nArgumentResolver, you can extend this functionality.': '这种功能是由实现 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Controller/ValueResolverInterface.php" class="reference external" title="Symfony\Component\HttpKernel\Controller\ValueResolverInterface" rel="external noopener noreferrer" target="_blank">ValueResolverInterface</a> 接口的解析器提供的。Symfony 提供了四种实现作为默认行为，但自定义是关键。你可以通过自己实现 <code translate="no" class="notranslate">ValueResolverInterface</code> 并将其传递给 <code translate="no" class="notranslate">ArgumentResolver</code>，来扩展这种功能。',
        'The ValueResolverInterface was introduced in Symfony 6.2. Prior to\n6.2, you had to use the\nArgumentValueResolverInterface,\nwhich defines different methods.': '<code translate="no" class="notranslate">ValueResolverInterface</code> 是在 Symfony 6.2 中引入的。在 6.2 之前，你需要使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Controller/ArgumentValueResolverInterface.php" class="reference external" title="Symfony\Component\HttpKernel\Controller\ArgumentValueResolverInterface" rel="external noopener noreferrer" target="_blank">ArgumentValueResolverInterface</a>，它定义了不同的方法。',
        '5) Calling the Controller': '5) 调用控制器',
        'The next step of HttpKernel::handle() is executing the controller.': '<code translate="no" class="notranslate">HttpKernel::handle()</code> 的下一步是执行控制器。',
        'The job of the controller is to build the response for the given resource.\nThis could be an HTML page, a JSON string or anything else. Unlike every\nother part of the process so far, this step is implemented by the "end-developer",\nfor each page that is built.': '控制器的任务是为给定的资源构建响应。这可能是一个 HTML 页面、一个 JSON 字符串或任何其它东西。与到目前为止流程中的其它部分不同，这一步是由“终端开发人员”针对每个构建的页面来实现的。',
        'Usually, the controller will return a Response object. If this is true,\nthen the work of the kernel is just about done! In this case, the next step\nis the kernel.response event.': '通常，控制器会返回一个 <code translate="no" class="notranslate">Response</code> 对象。如果确实如此，那么内核的工作就基本完成了！在这种情况下，下一步是 <a href="http_kernel.html#component-http-kernel-kernel-response" class="reference internal">kernel.response</a> 事件。',
        'But if the controller returns anything besides a Response, then the kernel\nhas a little bit more work to do - kernel.view\n(since the end goal is always to generate a Response object).': '但如果控制器返回的不是 <code translate="no" class="notranslate">Response</code> 对象，那么内核还有更多的工作要做——即 <a href="http_kernel.html#component-http-kernel-kernel-view" class="reference internal">kernel.view</a>（因为最终的目标始终是生成一个 <code translate="no" class="notranslate">Response</code> 对象）。',
        'A controller must return something. If a controller returns null,\nan exception will be thrown immediately.': '控制器必须返回一些东西。如果控制器返回 <code translate="no" class="notranslate">null</code>，则会立即抛出一个异常。',
        '6) The kernel.view Event': '6) <code translate="no" class="notranslate">kernel.view</code> 事件',
        'Typical Purposes: Transform a non-Response return value from a controller\ninto a Response': '<strong>典型用途</strong>：将控制器返回的非 <code translate="no" class="notranslate">Response</code> 值转换为 <code translate="no" class="notranslate">Response</code>',
        "If the controller doesn't return a Response object, then the kernel dispatches\nanother event - kernel.view. The job of a listener to this event is to\nuse the return value of the controller (e.g. an array of data or an object)\nto create a Response.": '如果控制器没有返回 <code translate="no" class="notranslate">Response</code> 对象，那么内核会触发另一个事件——即 <code translate="no" class="notranslate">kernel.view</code>。监听这个事件的监听器的任务是使用控制器的返回值（例如，一个数据数组或一个对象）来创建一个 <code translate="no" class="notranslate">Response</code>。',
        'This can be useful if you want to use a "view" layer: instead of returning\na Response from the controller, you return data that represents the page.\nA listener to this event could then use this data to create a Response that\nis in the correct format (e.g HTML, JSON, etc).': '如果你想使用“视图”层，这可能会很有用：控制器不返回 <code translate="no" class="notranslate">Response</code>，而是返回表示页面的数据。监听这个事件的监听器可以使用这些数据来创建格式正确的 <code translate="no" class="notranslate">Response</code>（例如 HTML、JSON 等）。',
        'At this stage, if no listener sets a response on the event, then an exception\nis thrown: either the controller or one of the view listeners must always\nreturn a Response.': '在这个阶段，如果没有任何监听器在事件上设置响应，则会抛出一个异常：控制器或其中一个视图监听器必须始终返回一个 <code translate="no" class="notranslate">Response</code>。',
        "When setting a response for the kernel.view event, the propagation\nis stopped. This means listeners with lower priority won't be executed.": '在为 <code translate="no" class="notranslate">kernel.view</code> 事件设置响应时，会停止事件的传播。这意味着优先级较低的监听器将不会被执行。',
        'kernel.view in the Symfony Framework': 'Symfony 框架中的 <code translate="no" class="notranslate">kernel.view</code>',
        'There is a default listener inside the Symfony Framework for the kernel.view\nevent. If your controller action returns an array, and you apply the\n#[Template] attribute to that\ncontroller action, then this listener renders a template, passes the array\nyou returned from your controller to that template, and creates a Response\ncontaining the returned content from that template.': '在 Symfony 框架内部有一个默认的监听器用于处理 <code translate="no" class="notranslate">kernel.view</code> 事件。如果你的控制器方法返回一个数组，并且你在该控制器方法上应用了 <a href="../templates.html#templates-template-attribute" class="reference internal"><code translate="no" class="notranslate">#[Template]</code> 注解</a> ，那么这个监听器会渲染一个模板，将控制器返回的数组传递给该模板，并创建一个包含模板返回内容的 <code translate="no" class="notranslate">Response</code>。',
        'Additionally, a popular community bundle FOSRestBundle implements\na listener on this event which aims to give you a robust view layer\ncapable of using a single controller to return many different content-type\nresponses (e.g. HTML, JSON, XML, etc).': '此外，一个受欢迎的社区捆绑包 <a href="https://github.com/friendsofsymfony/FOSRestBundle" class="reference external" rel="external noopener noreferrer" target="_blank">FOSRestBundle</a> 在此事件上实现了一个监听器，旨在为你提供一个强大的视图层，使得单个控制器能够返回多种不同内容类型的响应（例如 HTML、JSON、XML 等）。',
        '7) The kernel.response Event': '7) <code translate="no" class="notranslate">kernel.response</code> 事件',
        'Typical Purposes: Modify the Response object just before it is sent': '<strong>典型用途</strong>：在 <code translate="no" class="notranslate">Response</code> 对象发送之前对其进行修改。',
        'The end goal of the kernel is to transform a Request into a Response. The\nResponse might be created during the kernel.request\nevent, returned from the controller,\nor returned by one of the listeners to the kernel.view\nevent.': '内核的最终目标是将一个 <code translate="no" class="notranslate">Request</code> 转化为一个 <code translate="no" class="notranslate">Response</code>。这个 <code translate="no" class="notranslate">Response</code> 可能在 <a href="http_kernel.html#component-http-kernel-kernel-request" class="reference internal">kernel.request</a> 事件期间创建，由<a href="http_kernel.html#component-http-kernel-calling-controller" class="reference internal">控制器</a>返回，或者由 <a href="http_kernel.html#component-http-kernel-kernel-view" class="reference internal">kernel.view</a> 事件的某个监听器返回。',
        'Regardless of who creates the Response, another event - kernel.response\nis dispatched directly afterwards. A typical listener to this event will modify\nthe Response object in some way, such as modifying headers, adding cookies,\nor even changing the content of the Response itself (e.g. injecting some\nJavaScript before the end </body> tag of an HTML response).': '无论谁创建了 <code translate="no" class="notranslate">Response</code>，之后都会触发另一个事件 —— <code translate="no" class="notranslate">kernel.response</code>。此事件的一个典型监听器会对 <code translate="no" class="notranslate">Response</code> 对象进行某种方式的修改，例如修改头部信息、添加 Cookie，甚至更改  <code translate="no" class="notranslate">Response</code> 的内容（例如，在 HTML 响应的结束 <code translate="no" class="notranslate">&lt;/body&gt;</code> 标签前注入一些 JavaScript）。',
        'After this event is dispatched, the final Response object is returned\nfrom handle(). In the\nmost typical use-case, you can then call the send()\nmethod, which sends the headers and prints the Response content.': '在这个事件触发之后，最终的 <code translate="no" class="notranslate">Response</code> 对象会从 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/HttpKernel.php#:~:text=function%20handle" class="reference external" title="Symfony\Component\HttpKernel\HttpKernel::handle()" rel="external noopener noreferrer" target="_blank">handle()</a> 方法中返回。在最常见的用例中，你可以调用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpFoundation/Response.php#:~:text=function%20send" class="reference external" title="Symfony\Component\HttpFoundation\Response::send()" rel="external noopener noreferrer" target="_blank">send()</a> 方法，该方法会发送头部信息并打印 <code translate="no" class="notranslate">Response</code> 的内容。',
        'kernel.response in the Symfony Framework': '在 Symfony 框架中的 <code translate="no" class="notranslate">kernel.response</code> 事件',
        'There are several minor listeners on this event inside the Symfony Framework,\nand most modify the response in some way. For example, the\nWebDebugToolbarListener\ninjects some JavaScript at the bottom of your page in the dev environment\nwhich causes the web debug toolbar to be displayed. Another listener,\nContextListener\nserializes the current user\'s information into the\nsession so that it can be reloaded on the next request.': '在 Symfony 框架中，这个事件有几个次要的监听器，大多数都会以某种方式修改响应。例如，<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/WebProfilerBundle/EventListener/WebDebugToolbarListener.php" class="reference external" title="Symfony\\Bundle\\WebProfilerBundle\\EventListener\\WebDebugToolbarListener" rel="external noopener noreferrer" target="_blank">WebDebugToolbarListener</a> 会在 <code translate="no" class="notranslate">dev</code> 环境中的页面底部注入一些 JavaScript，从而显示网络调试工具栏。另一个监听器 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Http/Firewall/ContextListener.php" class="reference external" title="Symfony\\Component\\Security\\Http\\Firewall\\ContextListener" rel="external noopener noreferrer" target="_blank">ContextListener</a> 会将当前用户的信息序列化到会话中，以便在下次请求时重新加载。',
        '8) The kernel.terminate Event': '8) <code translate="no" class="notranslate">kernel.terminate</code> 事件',
        'Typical Purposes: To perform some "heavy" action after the response has\nbeen streamed to the user': '<strong>典型用途</strong>：在响应已流式传输给用户后执行某些“耗时”的操作',
        'The final event of the HttpKernel process is kernel.terminate and is unique\nbecause it occurs after the HttpKernel::handle() method, and after the\nresponse is sent to the user. Recall from above, then the code that uses\nthe kernel, ends like this:': 'HttpKernel 流程的最后一个事件是 <code translate="no" class="notranslate">kernel.terminate</code>，它很特别，因为它发生在 <code translate="no" class="notranslate">HttpKernel::handle()</code> 方法之后，并且在响应已经发送给用户之后。回想一下上面的内容，使用内核的代码通常以如下方式结束：',
        'As you can see, by calling $kernel->terminate after sending the response,\nyou will trigger the kernel.terminate event where you can perform certain\nactions that you may have delayed in order to return the response as quickly\nas possible to the client (e.g. sending emails).': '如你所见，通过在发送响应之后调用 <code translate="no" class="notranslate">$kernel-&gt;terminate</code>，你会触发 <code translate="no" class="notranslate">kernel.terminate</code> 事件，在这里可以执行某些你可能延迟的操作，以便尽快将响应返回给客户端（例如发送电子邮件）。',
        'Internally, the HttpKernel makes use of the fastcgi_finish_request\nPHP function. This means that at the moment, only the PHP FPM server\nAPI is able to send a response to the client while the server\'s PHP process\nstill performs some tasks. With all other server APIs, listeners to kernel.terminate\nare still executed, but the response is not sent to the client until they\nare all completed.': '在内部，HttpKernel 使用了 PHP 的 <a href="https://secure.php.net/manual/zh/function.fastcgi-finish-request.php" class="reference external" title="fastcgi_finish_request" rel="external noopener noreferrer" target="_blank">fastcgi_finish_request</a> 函数。这意味着目前只有 <a href="https://www.php.net/manual/zh/install.fpm.php" class="reference external" rel="external noopener noreferrer" target="_blank">PHP FPM</a> 服务器 API 能够在服务器的 PHP 进程仍然执行某些任务的同时将响应发送给客户端。对于所有其它服务器 API，<code translate="no" class="notranslate">kernel.terminate</code> 的监听器仍然会被执行，但在所有监听器完成之前，响应不会发送给客户端。',
        'Using the kernel.terminate event is optional, and should only be\ncalled if your kernel implements TerminableInterface.': '使用 <code translate="no" class="notranslate">kernel.terminate</code> 事件是可选的，仅当你的内核实现了 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/TerminableInterface.php" class="reference external" title="Symfony\Component\HttpKernel\TerminableInterface" rel="external noopener noreferrer" target="_blank">TerminableInterface</a> 时才应调用它。',
        '9) Handling Exceptions: the kernel.exception Event': '9) 处理异常：<code translate="no" class="notranslate">kernel.exception</code> 事件',
        'Typical Purposes: Handle some type of exception and create an appropriate\nResponse to return for the exception': '<strong>典型用途</strong>：处理某种类型的异常并创建一个适当的 <code translate="no" class="notranslate">Response</code> 来作为异常的响应返回',
        'If an exception is thrown at any point inside HttpKernel::handle(), another\nevent - kernel.exception is dispatched. Internally, the body of the handle()\nmethod is wrapped in a try-catch block. When any exception is thrown, the\nkernel.exception event is dispatched so that your system can somehow respond\nto the exception.': '如果在 <code translate="no" class="notranslate">HttpKernel::handle()</code> 方法的任何位置抛出异常，另一个事件 —— <code translate="no" class="notranslate">kernel.exception</code> 会被触发。在内部，<code translate="no" class="notranslate">handle()</code> 方法的主体被封装在一个 try-catch 块中。当任何异常被抛出时，<code translate="no" class="notranslate">kernel.exception</code> 事件会被触发，以便系统能够以某种方式响应异常。',
        'Each listener to this event is passed a ExceptionEvent\nobject, which you can use to access the original exception via the\ngetThrowable()\nmethod. A typical listener on this event will check for a certain type of\nexception and create an appropriate error Response.': '每个监听这个事件的监听器都会接收到一个 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Event/ExceptionEvent.php" class="reference external" title="Symfony\Component\HttpKernel\Event\ExceptionEvent" rel="external noopener noreferrer" target="_blank">ExceptionEvent</a> 对象，你可以通过 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Event/ExceptionEvent.php#:~:text=function%20getThrowable" class="reference external" title="Symfony\Component\HttpKernel\Event\ExceptionEvent::getThrowable()" rel="external noopener noreferrer" target="_blank">getThrowable()</a> 方法访问原始异常。一个典型的监听器会检查特定类型的异常，并创建一个合适的错误 <code translate="no" class="notranslate">Response</code>。',
        'For example, to generate a 404 page, you might throw a special type of exception\nand then add a listener on this event that looks for this exception and\ncreates and returns a 404 Response. In fact, the HttpKernel component\ncomes with an ErrorListener,\nwhich if you choose to use, will do this and more by default (see the sidebar\nbelow for more details).': '例如，为了生成一个 404 页面，你可以抛出一个特殊的异常类型，然后为此事件添加一个监听器，该监听器会查找这种异常并创建并返回一个 404 <code translate="no" class="notranslate">Response</code>。事实上，HttpKernel 组件自带了一个 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/EventListener/ErrorListener.php" class="reference external" title="Symfony\Component\HttpKernel\EventListener\ErrorListener" rel="external noopener noreferrer" target="_blank">ErrorListener</a>，如果你选择使用它，默认情况下会做更多事情（详见下面的侧边栏以获取更多详细信息）。',
        'When setting a response for the kernel.exception event, the propagation\nis stopped. This means listeners with lower priority won\'t be executed.': '在设置 <code translate="no" class="notranslate">kernel.exception</code> 事件的响应时，传播会被停止。这意味着优先级较低的监听器将不会被执行。',
        'kernel.exception in the Symfony Framework': '在 Symfony 框架中的 <code translate="no" class="notranslate">kernel.exception</code> 事件',
        'There are two main listeners to kernel.exception when using the\nSymfony Framework.': '在使用 Symfony 框架时，<code translate="no" class="notranslate">kernel.exception</code> 事件主要有两个监听器。',
        'ErrorListener in the HttpKernel Component': '<strong>HttpKernel 组件中的 ErrorListener</strong>',
        'The first comes core to the HttpKernel component\nand is called ErrorListener.\nThe listener has several goals:': '第一个是 HttpKernel 组件的核心部分，称为 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/EventListener/ErrorListener.php" class="reference external" title="Symfony\Component\HttpKernel\EventListener\ErrorListener" rel="external noopener noreferrer" target="_blank">ErrorListener</a>。该监听器有多个目标：',
        'The thrown exception is converted into a\nFlattenException\nobject, which contains all the information about the request, but which\ncan be printed and serialized.': '抛出的异常会被转换为一个 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/ErrorHandler/Exception/FlattenException.php" class="reference external" title="Symfony\Component\ErrorHandler\Exception\FlattenException" rel="external noopener noreferrer" target="_blank">FlattenException</a> 对象，该对象包含了关于请求的所有信息，但可以被打印和序列化。',
        'If the original exception implements\nHttpExceptionInterface,\nthen getStatusCode() and getHeaders() are called on the exception\nand used to populate the headers and status code of the FlattenException\nobject. The idea is that these are used in the next step when creating\nthe final response. If you want to set custom HTTP headers, you can always\nuse the setHeaders() method on exceptions derived from the\nHttpException class.': '如果原始异常实现了 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Exception/HttpExceptionInterface.php" class="reference external" title="Symfony\Component\HttpKernel\Exception\HttpExceptionInterface" rel="external noopener noreferrer" target="_blank">HttpExceptionInterface</a>，则会调用 <code translate="no" class="notranslate">getStatusCode()</code> 和 <code translate="no" class="notranslate">getHeaders()</code> 方法来填充 <code translate="no" class="notranslate">FlattenException</code> 对象的头部信息和状态码。这样做的目的是在创建最终响应时使用这些信息。如果你想设置自定义的 HTTP 头部，可以始终使用继承自 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Exception/HttpException.php" class="reference external" title="Symfony\Component\HttpKernel\Exception\HttpException" rel="external noopener noreferrer" target="_blank">HttpException</a> 类的异常中的 <code translate="no" class="notranslate">setHeaders()</code> 方法。',
        'If the original exception implements\nRequestExceptionInterface,\nthen the status code of the FlattenException object is populated with\n400 and no other headers are modified.': '如果原始异常实现了 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpFoundation/Exception/RequestExceptionInterface.php" class="reference external" title="Symfony\Component\HttpFoundation\Exception\RequestExceptionInterface" rel="external noopener noreferrer" target="_blank">RequestExceptionInterface</a>，则 <code translate="no" class="notranslate">FlattenException</code> 对象的状态码会被设置为 <code translate="no" class="notranslate">400</code>，并且不会修改其它头部信息。',
        'A controller is executed and passed the flattened exception. The exact\ncontroller to render is passed as a constructor argument to this listener.\nThis controller will return the final Response for this error page.': '一个控制器会被执行，并传入扁平化的异常。确切要渲染的控制器作为构造函数参数传递给这个监听器。该控制器将返回此错误页面的最终 <code translate="no" class="notranslate">Response</code>。',
        'ExceptionListener in the Security Component': '<strong>Security 组件中的 ExceptionListener</strong>',
        'The other important listener is the\nExceptionListener.\nThe goal of this listener is to handle security exceptions and, when\nappropriate, help the user to authenticate (e.g. redirect to the login\npage).': '另一个重要的监听器是 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/Security/Http/Firewall/ExceptionListener.php" class="reference external" title="Symfony\Component\Security\Http\Firewall\ExceptionListener" rel="external noopener noreferrer" target="_blank">ExceptionListener</a>。这个监听器的目标是处理安全相关的异常，并在适当的情况下帮助用户进行身份验证（例如重定向到登录页面）。',

        'Creating an Event Listener': '创建事件侦听器',
        'As you\'ve seen, you can create and attach event listeners to any of the events\ndispatched during the HttpKernel::handle() cycle. Typically a listener is a PHP\nclass with a method that\'s executed, but it can be anything. For more information\non creating and attaching event listeners, see The EventDispatcher Component.': '正如你所见，你可以创建并附加事件监听器到 <code translate="no" class="notranslate">HttpKernel::handle()</code> 周期中触发的任何事件。通常，监听器是一个具有某个方法的PHP类，但也可以是其他形式。有关创建和附加事件监听器的更多信息，请参阅<a href="event_dispatcher.html" class="reference internal">事件分发器组件</a>。',
        'The name of each of the "kernel" events is defined as a constant on the\nKernelEvents class. Additionally, each\nevent listener is passed a single argument, which is some subclass of KernelEvent.\nThis object contains information about the current state of the system and\neach event has their own event object:': '每个“kernel”事件的名称都定义在 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/KernelEvents.php" class="reference external" title="Symfony\Component\HttpKernel\KernelEvents" rel="external noopener noreferrer" target="_blank">KernelEvents</a> 类的常量中。此外，每个事件监听器都会接收一个参数，这是一个 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Event/KernelEvent.php" class="reference external" title="Symfony\Component\HttpKernel\Event\KernelEvent" rel="external noopener noreferrer" target="_blank">KernelEvent</a> 的子类。这个对象包含了系统当前状态的信息，每个事件都有自己的事件对象：',

        'A full Working Example': '一个完整的工作示例',
        'When using the HttpKernel component, you\'re free to attach any listeners\nto the core events, use any controller resolver that implements the\nControllerResolverInterface and\nuse any argument resolver that implements the\nArgumentResolverInterface.\nHowever, the HttpKernel component comes with some built-in listeners and everything\nelse that can be used to create a working example:': '在使用 HttpKernel 组件时，你可以自由地将任何监听器附加到核心事件上，使用任何实现了 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Controller/ControllerResolverInterface.php" class="reference external" title="Symfony\Component\HttpKernel\Controller\ControllerResolverInterface" rel="external noopener noreferrer" target="_blank">ControllerResolverInterface</a> 的控制器解析器，以及使用任何实现了 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Controller/ArgumentResolverInterface.php" class="reference external" title="Symfony\Component\HttpKernel\Controller\ArgumentResolverInterface" rel="external noopener noreferrer" target="_blank">ArgumentResolverInterface</a> 的参数解析器。然而，HttpKernel 组件自带了一些内置的监听器和其它一切可用于创建一个可工作的示例的组件。',

        'Sub Requests': '子请求',
        'In addition to the "main" request that\'s sent into HttpKernel::handle(),\nyou can also send a so-called "sub request". A sub request looks and acts like\nany other request, but typically serves to render just one small portion of\na page instead of a full page. You\'ll most commonly make sub-requests from\nyour controller (or perhaps from inside a template, that\'s being rendered by\nyour controller).': '除了发送到 <code translate="no" class="notranslate">HttpKernel::handle()</code> 的“主请求”之外，你还可以发送所谓的“子请求”。子请求看起来和行为与普通请求相同，但通常只用于渲染页面的一小部分而不是整个页面。你最常见的是在控制器中（或者在控制器渲染的模板中）发起子请求。',
        'To execute a sub request, use HttpKernel::handle(), but change the second\nargument as follows:': '要执行一个子请求，可以使用 <code translate="no" class="notranslate">HttpKernel::handle()</code> 方法，但需要将第二个参数改为如下形式：',
        'This creates another full request-response cycle where this new Request is\ntransformed into a Response. The only difference internally is that some\nlisteners (e.g. security) may only act upon the main request. Each listener\nis passed some subclass of KernelEvent,\nwhose isMainRequest()\nmethod can be used to check if the current request is a "main" or "sub" request.': '这会创建一个新的完整的请求-响应周期，其中这个新的 <code translate="no" class="notranslate">Request</code> 会被转换为一个 <code translate="no" class="notranslate">Response</code>。内部唯一的区别是一些监听器（例如 安全监听器）可能只对主请求生效。每个监听器都会接收 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Event/KernelEvent.php" class="reference external" title="Symfony\Component\HttpKernel\Event\KernelEvent" rel="external noopener noreferrer" target="_blank">KernelEvent</a> 的一个子类，其 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Event/KernelEvent.php#:~:text=function%20isMainRequest" class="reference external" title="Symfony\Component\HttpKernel\Event\KernelEvent::isMainRequest()" rel="external noopener noreferrer" target="_blank">isMainRequest()</a> 方法可以用来检查当前请求是否是“主请求”或“子请求”。',
        'For example, a listener that only needs to act on the main request may\nlook like this:': '例如，一个只需要对主请求生效的监听器可能如下所示：',
        'The default value of the _format request attribute is html. If your\nsub request returns a different format (e.g. json) you can set it by\ndefining the _format attribute explicitly on the request:': '<code translate="no" class="notranslate">_format</code> 请求属性的默认值是 <code translate="no" class="notranslate">html</code>。如果你的子请求需要返回不同的格式（例如 <code translate="no" class="notranslate">json</code>），可以通过在请求中显式定义 <code translate="no" class="notranslate">_format</code> 属性来设置它：',

        'Locating Resources': '定位资源',
        'The HttpKernel component is responsible of the bundle mechanism used in Symfony\napplications. One of the key features of the bundles is that you can use logic\npaths instead of physical paths to refer to any of their resources (config files,\ntemplates, controllers, translation files, etc.)': 'HttpKernel 组件负责 Symfony 应用程序中使用的捆绑（bundle）机制。捆绑的一个关键特性是，你可以使用逻辑路径而不是物理路径来引用它们的任何资源（配置文件、模板、控制器、翻译文件等）。',
        'This allows to import resources even if you don\'t know where in the filesystem a\nbundle will be installed. For example, the services.xml file stored in the\nResources/config/ directory of a bundle called FooBundle can be referenced as\n@FooBundle/Resources/config/services.xml instead of __DIR__/Resources/config/services.xml.': '这允许即使不知道捆绑在文件系统中的安装位置，也能导入资源。例如，名为 FooBundle 的捆绑中 <code translate="no" class="notranslate">Resources/config/</code> 目录下的 <code translate="no" class="notranslate">services.xml</code> 文件可以引用为 <code translate="no" class="notranslate">@FooBundle/Resources/config/services.xml</code>，而不是 <code translate="no" class="notranslate">__DIR__/Resources/config/services.xml</code>。',
        'This is possible thanks to the locateResource()\nmethod provided by the kernel, which transforms logical paths into physical paths:': '这得益于内核提供的 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Kernel.php#:~:text=function%20locateResource" class="reference external" title="Symfony\Component\HttpKernel\Kernel::locateResource()" rel="external noopener noreferrer" target="_blank">locateResource()</a> 方法，该方法将逻辑路径转换为物理路径：',

        'Learn more': '了解更多',
        'Built-in Symfony Events': '<a href="../reference/events.html">Symfony 内置事件</a>',
    };


    fanyi(translates, 1);
})($);
