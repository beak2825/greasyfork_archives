// ==UserScript==
// @name         Symfony 翻译文档 service_container/autowiring.html
// @namespace    fireloong
// @version      0.1.2
// @description  翻译文档 service_container/autowiring.html
// @author       Itsky71
// @match        https://symfony.com/doc/5.x/service_container/autowiring.html
// @match        https://symfony.com/doc/6.4/service_container/autowiring.html
// @match        https://symfony.com/doc/7.1/service_container/autowiring.html
// @match        https://symfony.com/doc/7.2/service_container/autowiring.html
// @match        https://symfony.com/doc/current/service_container/autowiring.html
// @icon         https://www.google.com/s2/favicons?sz=64&domain=symfony.com
// @require      https://unpkg.com/jquery@3.7.1/dist/jquery.min.js
// @require      https://update.greasyfork.org/scripts/503008/fanyi.js
// @grant        none
// @license      MIT
// @downloadURL https://update.greasyfork.org/scripts/507816/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20service_containerautowiringhtml.user.js
// @updateURL https://update.greasyfork.org/scripts/507816/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20service_containerautowiringhtml.meta.js
// ==/UserScript==

(function($) {
    'use strict';

    const translates = {
        '\n        \n                    Defining Services Dependencies Automatically (Autowiring)\n        \n            ': '自动定义服务依赖（自动装配）',
        'Autowiring allows you to manage services in the container with minimal\nconfiguration. It reads the type-hints on your constructor (or other methods)\nand automatically passes the correct services to each method. Symfony\'s\nautowiring is designed to be predictable: if it is not absolutely clear which\ndependency should be passed, you\'ll see an actionable exception.': '自动装配（Autowiring）允许您以最小的配置来管理容器中的服务。它会读取构造函数（或其他方法）上的类型提示，并自动将正确的服务传递给每个方法。Symfony 的自动布线设计得非常可靠：如果无法明确确定应传递哪个依赖项，您将会看到一个可操作的异常。',
        'Thanks to Symfony\'s compiled container, there is no runtime overhead for using\nautowiring.': '由于 Symfony 的编译容器，使用自动装配在运行时没有任何额外开销。',
        'An Autowiring Example': '一个自动装配示例',
        'Imagine you\'re building an API to publish statuses on a Twitter feed, obfuscated\nwith ROT13, a fun encoder that shifts all characters 13 letters forward in\nthe alphabet.': '想象一下，你正在构建一个 API 用于在 Twitter 上发布状态，这些状态经过 ROT13 编码进行了混淆，这是一种有趣的编码方式，它将所有字符向前移动 13 个字母。',
        'Start by creating a ROT13 transformer class:': '首先创建一个 ROT13 转换类：',
        'And now a Twitter client using this transformer:': '现在创建一个使用这个转换器的 Twitter 客户端：',
        'If you\'re using the default services.yaml configuration,\nboth classes are automatically registered as services and configured to be autowired.\nThis means you can use them immediately without any configuration.': '如果您使用的是<a href="../service_container.html#service-container-services-load-example" class="reference internal">默认的 <code translate="no" class="notranslate">services.yaml</code> 配置</a>，<strong>这两个类将自动注册为服务并配置为自动装配</strong>。这意味着您可以立即使用它们而无需任何额外配置。',
        'However, to understand autowiring better, the following examples explicitly configure\nboth services:': '然而，为了更好地理解自动布线，以下示例将显式地配置这两个服务：',
        'Now, you can use the TwitterClient service immediately in a controller:': '现在，您可以在控制器中立即使用 <code translate="no" class="notranslate">TwitterClient</code> 服务：',
        'This works automatically! The container knows to pass the Rot13Transformer service\nas the first argument when creating the TwitterClient service.': '这可以自动工作！容器知道在创建 <code translate="no" class="notranslate">TwitterClient</code> 服务时将 <code translate="no" class="notranslate">Rot13Transformer</code> 服务作为第一个参数传递。',
        'Autowiring Logic Explained': '自动装配逻辑解释',
        'Autowiring works by reading the Rot13Transformer type-hint in TwitterClient:': '自动装配通过读取 <code translate="no" class="notranslate">TwitterClient</code> 中的 <code translate="no" class="notranslate">Rot13Transformer</code> 类型提示来工作：',
        'The autowiring system looks for a service whose id exactly matches the type-hint:\nso App\\Util\\Rot13Transformer. In this case, that exists! When you configured\nthe Rot13Transformer service, you used its fully-qualified class name as its\nid. Autowiring isn\'t magic: it looks for a service whose id matches the type-hint.\nIf you load services automatically,\neach service\'s id is its class name.': '自动装配系统会<strong>查找与类型提示完全匹配的服务 ID</strong>：即 <code translate="no" class="notranslate">App\Util\Rot13Transformer</code>。在这种情况下，这个服务确实存在！当您配置 <code translate="no" class="notranslate">Rot13Transformer</code> 服务时，您使用了其完全限定的类名作为服务 ID。自动装配并不是魔法：它查找与类型提示匹配的服务 ID。如果您<a href="../service_container.html#service-container-services-load-example" class="reference internal">自动加载服务</a>，每个服务的 ID 就是其类名。',
        'If there is not a service whose id exactly matches the type, a clear exception\nwill be thrown.': '如果没有找到与类型提示完全匹配的服务 ID，将会抛出一个清晰的异常。',
        'Autowiring is a great way to automate configuration, and Symfony tries to be as\npredictable and as clear as possible.': '自动装配是一种自动化配置的好方法，Symfony 力求做到尽可能的可预测和清晰。',
        'Using Aliases to Enable Autowiring': '使用别名来启用自动装配',
        'The main way to configure autowiring is to create a service whose id exactly matches\nits class. In the previous example, the service\'s id is App\\Util\\Rot13Transformer,\nwhich allows us to autowire this type automatically.': '配置自动装配的主要方法是创建一个服务 ID 与其类名完全匹配的服务。在之前的例子中，服务的 ID 是 <code translate="no" class="notranslate">App\\Util\\Rot13Transformer</code>，这使得我们可以自动装配这种类型。',
        'This can also be accomplished using an alias. Suppose that\nfor some reason, the id of the service was instead app.rot13.transformer. In\nthis case, any arguments type-hinted with the class name (App\\Util\\Rot13Transformer)\ncan no longer be autowired.': '这也可以通过使用<a href="alias_private.html#services-alias" class="reference internal">别名</a>来实现。假设由于某种原因，服务的 ID 被设置为 <code translate="no" class="notranslate">app.rot13.transformer</code>。在这种情况下，任何类型提示为类名 (<code translate="no" class="notranslate">App\\Util\\Rot13Transformer</code>) 的参数将无法再自动装配。',
        'No problem! To fix this, you can create a service whose id matches the class by\nadding a service alias:': '没问题！要解决这个问题，可以通过添加一个服务别名来创建一个 ID 与类名匹配的服务：',
        'This creates a service "alias", whose id is App\\Util\\Rot13Transformer.\nThanks to this, autowiring sees this and uses it whenever the Rot13Transformer\nclass is type-hinted.': '这创建了一个服务别名，其 ID 为 <code translate="no" class="notranslate">App\\Util\\Rot13Transformer</code>。由于这个别名，自动装配能够识别它，并在类型提示为 <code translate="no" class="notranslate">Rot13Transformer</code> 类时使用它。',
        'Aliases are used by the core bundles to allow services to be autowired. For\nexample, MonologBundle creates a service whose id is logger. But it also\nadds an alias: Psr\\Log\\LoggerInterface that points to the logger service.\nThis is why arguments type-hinted with Psr\\Log\\LoggerInterface can be autowired.': '别名被核心捆绑包用于允许服务自动装配。例如，MonologBundle 创建了一个 ID 为 <code translate="no" class="notranslate">logger</code> 的服务。但它还添加了一个别名：<code translate="no" class="notranslate">Psr\\Log\\LoggerInterface</code>，该别名指向 <code translate="no" class="notranslate">logger</code> 服务。这就是为什么类型提示为 <code translate="no" class="notranslate">Psr\\Log\\LoggerInterface</code> 的参数可以自动装配的原因。',
        'Working with Interfaces': '处理接口',
        'You might also find yourself type-hinting abstractions (e.g. interfaces) instead\nof concrete classes as it replaces your dependencies with other objects.': '您也可能发现自己在类型提示中使用抽象（例如接口）而不是具体类，因为这样可以将您的依赖替换为其它对象。',
        'To follow this best practice, suppose you decide to create a TransformerInterface:': '为了遵循这一最佳实践，假设您决定创建一个 <code translate="no" class="notranslate">TransformerInterface</code>：',
        'Then, you update Rot13Transformer to implement it:': '然后，您更新 <code translate="no" class="notranslate">Rot13Transformer</code> 以实现该接口：',
        'Now that you have an interface, you should use this as your type-hint:': '现在您有了一个接口，应该使用这个接口作为类型提示：',
        'But now, the type-hint (App\\Util\\TransformerInterface) no longer matches\nthe id of the service (App\\Util\\Rot13Transformer). This means that the\nargument can no longer be autowired.': '但现在，类型提示 (<code translate="no" class="notranslate">App\\Util\\TransformerInterface</code>) 不再与服务的 ID (<code translate="no" class="notranslate">App\\Util\\Rot13Transformer</code>) 匹配。这意味着该参数无法再自动装配。',
        'To fix that, add an alias:': '要解决这个问题，添加一个<a href="autowiring.html#service-autowiring-alias" class="reference internal">别名</a>：',
        'Thanks to the App\\Util\\TransformerInterface alias, the autowiring subsystem\nknows that the App\\Util\\Rot13Transformer service should be injected when\ndealing with the TransformerInterface.': '由于 <code translate="no" class="notranslate">App\\Util\\TransformerInterface</code> 别名，自动装配子系统知道在处理 <code translate="no" class="notranslate">TransformerInterface</code> 时应注入 <code translate="no" class="notranslate">App\\Util\\Rot13Transformer</code> 服务。',
        'When using a service definition prototype, if only one service is\ndiscovered that implements an interface, configuring the alias is not mandatory\nand Symfony will automatically create one.': '当使用<a href="https://symfony.com/blog/new-in-symfony-3-3-psr-4-based-service-discovery" class="reference external">服务定义原型</a>时，如果只发现了一个实现某个接口的服务，那么配置别名不是必需的，Symfony 会自动创建一个别名。',
        'Autowiring is powerful enough to guess which service to inject even when using\nunion and intersection types. This means you\'re able to type-hint argument with\ncomplex types like this:': '自动装配功能强大，即使使用联合类型和交叉类型，也能猜出应注入哪个服务。这意味着您可以使用复杂的类型来类型提示参数，如下所示：',
        'Dealing with Multiple Implementations of the Same Type': '处理同一类型的多个实现',
        'Suppose you create a second class - UppercaseTransformer that implements\nTransformerInterface:': '假设你创建了一个第二个类 —— <code translate="no" class="notranslate">UppercaseTransformer</code>，它实现了 <code translate="no" class="notranslate">TransformerInterface</code> 接口：',
        'If you register this as a service, you now have two services that implement the\nApp\\Util\\TransformerInterface type. Autowiring subsystem can not decide\nwhich one to use. Remember, autowiring isn\'t magic; it looks for a service\nwhose id matches the type-hint. So you need to choose one by creating an alias\nfrom the type to the correct service id (see Defining Services Dependencies Automatically (Autowiring)).\nAdditionally, you can define several named autowiring aliases if you want to use\none implementation in some cases, and another implementation in some\nother cases.': '如果你将此作为一项服务进行注册，那么现在你就有了两个实现 <code translate="no" class="notranslate">App\\Util\\TransformerInterface</code> 类型的服务。自动装配子系统无法决定使用哪一个。记住，自动装配并不是魔法；它会寻找与类型提示相匹配的服务 ID。因此，你需要通过从类型到正确的服务 ID 创建别名来选择其中一个（详见<a href="autowiring.html#autowiring-interface-alias" class="reference internal">自动定义服务依赖（自动装配）</a>）。此外，如果你想在某些情况下使用一个实现，在其它情况下使用另一个实现，你可以定义多个命名的自动装配别名。',
        'For instance, you may want to use the Rot13Transformer\nimplementation by default when the TransformerInterface interface is\ntype hinted, but use the UppercaseTransformer implementation in some\nspecific cases. To do so, you can create a normal alias from the\nTransformerInterface interface to Rot13Transformer, and then\ncreate a named autowiring alias from a special string containing the\ninterface followed by an argument name matching the one you use when doing\nthe injection:': '例如，你可能希望在类型提示为 <code translate="no" class="notranslate">TransformerInterface</code> 接口时默认使用 <code translate="no" class="notranslate">Rot13Transformer</code> 实现，但在某些特定情况下使用 <code translate="no" class="notranslate">UppercaseTransformer</code> 实现。为此，你可以从 <code translate="no" class="notranslate">TransformerInterface</code> 接口到 <code translate="no" class="notranslate">Rot13Transformer</code> 创建一个普通别名，并然后从一个特殊字符串创建一个命名的自动装配别名，该字符串包含接口后面跟着一个与你在进行注入时使用的参数名称相匹配的参数名。',
        'Thanks to the App\\Util\\TransformerInterface alias, any argument type-hinted\nwith this interface will be passed the App\\Util\\Rot13Transformer service.\nIf the argument is named $shoutyTransformer,\nApp\\Util\\UppercaseTransformer will be used instead.\nBut, you can also manually wire any other service by specifying the argument\nunder the arguments key.': '由于 <code translate="no" class="notranslate">App\Util\TransformerInterface</code> 别名，任何使用此接口类型提示的参数都将传递 <code translate="no" class="notranslate">App\Util\Rot13Transformer</code> 服务。如果参数名为 <code translate="no" class="notranslate">$shoutyTransformer</code>，则将使用 <code translate="no" class="notranslate">App\Util\UppercaseTransformer</code>。但是，你也可以通过在参数键下指定参数来手动绑定任何其它服务。',
        'Another option is to use the #[Target] attribute. By adding this attribute\nto the argument you want to autowire, you can specify which service to inject by\npassing the name of the argument used in the named alias. This way, you can have\nmultiple services implementing the same interface and keep the argument name\nseparate from any implementation name (like shown in the example above). In addition,\nyou\'ll get an exception in case you make any typo in the target name.': '另一种选项是使用 <code translate="no" class="notranslate">#[Target]</code> 注解。通过将此属性添加到你想自动装配的参数上，你可以通过传递在命名别名中使用的参数名称来指定要注入哪个服务。这样，你可以有多个服务实现同一个接口，并且将参数名称与任何实现名称分开（如上面的例子所示）。此外，如果目标名称中有任何拼写错误，你会收到一个异常。',
        'The #[Target] attribute only accepts the name of the argument used in the\nnamed alias; it does not accept service ids or service aliases.': '<code translate="no" class="notranslate">#[Target]</code> 注解只接受在命名别名中使用的参数名称；它不接受服务 ID 或服务别名。',
        'You can get a list of named autowiring aliases by running the debug:autowiring command:': '你可以通过运行 <code translate="no" class="notranslate">debug:autowiring</code> 命令来获取命名的自动装配别名列表：',
        'Suppose you want to inject the App\\Util\\UppercaseTransformer service. You would use\nthe #[Target] attribute by passing the name of the $shoutyTransformer argument:': '假设你想注入 <code translate="no" class="notranslate">App\\Util\\UppercaseTransformer</code> 服务。你可以通过传递 <code translate="no" class="notranslate">$shoutyTransformer</code> 参数的名称来使用 <code translate="no" class="notranslate">#[Target]</code> 注解：',
        'Since the #[Target] attribute normalizes the string passed to it to its\ncamelCased form, name variations (e.g. shouty.transformer) also work.': '由于 <code translate="no" class="notranslate">#[Target]</code> 注解会将其接收到的字符串规范化为其驼峰式形式，因此名称变体（例如 <code translate="no" class="notranslate">shouty.transformer</code>）也能生效。',
        'Some IDEs will show an error when using #[Target] as in the previous example:\n"Attribute cannot be applied to a property because it does not contain the \'Attribute::TARGET_PROPERTY\' flag".\nThe reason is that thanks to PHP constructor promotion this constructor\nargument is both a parameter and a class property. You can safely ignore this error message.': '某些集成开发环境（IDE）在使用 <code translate="no" class="notranslate">#[Target]</code> 注解时会显示错误，就像前一个例子中的那样：<em>“注解不能应用于属性，因为它不包含‘Attribute::TARGET_PROPERTY’标志”</em>。原因是由于 <a href="https://www.php.net/manual/zh/language.oop5.decon.php#language.oop5.decon.constructor.promotion" class="reference external" rel="external noopener noreferrer" target="_blank">PHP 构造器属性提升</a>机制，这个构造函数参数同时是一个类属性。你可以安全地忽略这个错误消息。',
        'Fixing Non-Autowireable Arguments': '修复无法自动装配的参数',
        'Autowiring only works when your argument is an object. But if you have a scalar\nargument (e.g. a string), this cannot be autowired: Symfony will throw a clear\nexception.': '自动装配仅在你的参数是对象时才有效。但如果参数是标量类型（例如字符串），则无法自动装配：Symfony 会抛出一个明确的异常。',
        'To fix this, you can manually wire the problematic argument\nin the service configuration. You wire up only the difficult arguments,\nSymfony takes care of the rest.': '要解决这个问题，你可以在服务配置中<a href="../service_container.html#services-manually-wire-args" class="reference internal">手动绑定有问题的参数</a>。只需手动绑定那些难以自动装配的参数，剩下的工作由 Symfony 负责。',
        'You can also use the #[Autowire] parameter attribute to instruct the autowiring\nlogic about those arguments:': '你也可以使用 <code translate="no" class="notranslate">#[Autowire]</code> 参数注解来指导自动装配逻辑处理这些参数：',
        'The #[Autowire] attribute was introduced in Symfony 6.1.': '<code translate="no" class="notranslate">#[Autowire]</code> 注解是在 Symfony 6.1 中引入的。',
        'The #[Autowire] attribute can also be used for parameters,\ncomplex expressions and even\nenvironment variables ,\nincluding env variable processors:': '<code translate="no" class="notranslate">#[Autowire]</code> 注解也可以用于<a href="../service_container.html#service-parameters" class="reference internal">参数</a>、<a href="expression_language.html" class="reference internal">复杂表达式</a>，甚至<a href="../configuration.html#config-env-vars" class="reference internal">环境变量</a>，<a href="../configuration/env_var_processors.html" class="reference internal">包括环境变量处理器</a>：',
        'The param and env arguments were introduced in Symfony 6.3.': '<code translate="no" class="notranslate">param</code> 和 <code translate="no" class="notranslate">env</code> 参数是在 Symfony 6.3 中引入的。',
        'Generate Closures With Autowiring': '使用自动装配生成闭包（Closures）',
        'A service closure is an anonymous function that returns a service. This type\nof instantiation is handy when you are dealing with lazy-loading.  It is also\nuseful for non-shared service dependencies.': '<strong>服务闭包</strong>是一个返回服务的匿名函数。这种实例化方式在处理懒加载时非常方便。它也适用于非共享的服务依赖项。',
        'Automatically creating a closure encapsulating the service instantiation can be\ndone with the\nAutowireServiceClosure\nattribute:': '自动创建封装服务实例化的闭包可以通过 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/DependencyInjection/Attribute/AutowireServiceClosure.php" class="reference external" title="Symfony\Component\DependencyInjection\Attribute\AutowireServiceClosure" rel="external noopener noreferrer" target="_blank">AutowireServiceClosure</a> 属性来实现：',
        'The AutowireServiceClosure\nattribute was introduced in Symfony 6.3.': '<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/DependencyInjection/Attribute/AutowireServiceClosure.php" class="reference external" title="Symfony\Component\DependencyInjection\Attribute\AutowireServiceClosure" rel="external noopener noreferrer" target="_blank">AutowireServiceClosure</a> 属性是在 Symfony 6.3 中引入的。',
        'It is common that a service accepts a closure with a specific signature.\nIn this case, you can use the\nAutowireCallable attribute\nto generate a closure with the same signature as a specific method of a service. When\nthis closure is called, it will pass all its arguments to the underlying service\nfunction.  If the closure needs to be called more than once, the service instance\nis reused for repeated calls.  Unlike a service closure, this will not\ncreate extra instances of a non-shared service:': '通常，一个服务会接受一个具有特定签名的闭包。在这种情况下，你可以使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/DependencyInjection/Attribute/AutowireCallable.php" class="reference external" title="Symfony\Component\DependencyInjection\Attribute\AutowireCallable" rel="external noopener noreferrer" target="_blank">AutowireCallable</a> 属性来生成一个与服务中某个特定方法具有相同签名的闭包。当这个闭包被调用时，它会将其所有参数传递给底层的服务函数。如果闭包需要被多次调用，服务实例将在重复调用中被重用。与服务闭包不同的是，这不会为非共享服务创建额外的实例：',
        'Finally, you can pass the lazy: true option to the\nAutowireCallable\nattribute. By doing so, the callable will automatically be lazy, which means\nthat the encapsulated service will be instantiated only at the\nclosure\'s first call.': '最后，你可以向 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/DependencyInjection/Attribute/AutowireCallable.php" class="reference external" title="Symfony\Component\DependencyInjection\Attribute\AutowireCallable" rel="external noopener noreferrer" target="_blank">AutowireCallable</a> 属性传递 <code translate="no" class="notranslate">lazy: true</code> 选项。这样做会使该可调用对象自动变为懒加载模式，这意味着封装的服务仅在闭包首次调用时才会被实例化。',
        'The AutowireCallable\nattribute was introduced in Symfony 6.3.': '<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/DependencyInjection/Attribute/AutowireCallable.php" class="reference external" title="Symfony\Component\DependencyInjection\Attribute\AutowireCallable" rel="external noopener noreferrer" target="_blank">AutowireCallable</a> 属性是在 Symfony 6.3 中引入的。',
        'Autowiring other Methods (e.g. Setters and Public Typed Properties)': '自动装配其它方法（例如 Setter 和公共类型属性）',
        'When autowiring is enabled for a service, you can also configure the container\nto call methods on your class when it\'s instantiated. For example, suppose you want\nto inject the logger service, and decide to use setter-injection:': '当为一个服务启用了自动装配时，你还可以配置容器在实例化类时调用其方法。例如，假设你想注入 <code translate="no" class="notranslate">logger</code> 服务，并决定使用 setter 注入：',
        'Autowiring will automatically call any method with the #[Required] attribute\nabove it, autowiring each argument. If you need to manually wire some of the arguments\nto a method, you can always explicitly configure the method call.': '自动装配会自动调用带有 <code translate="no" class="notranslate">#[Required]</code> 注解的方法，并自动装配每个参数。如果你需要手动绑定方法的一些参数，可以始终显式<a href="calls.html" class="reference internal">配置方法调用</a>。',
        'Despite property injection having some drawbacks,\nautowiring with #[Required] can also be applied to public\ntyped properties:': '尽管属性注入有一些<a href="injection_types.html#property-injection" class="reference internal">缺点</a>，但使用 <code translate="no" class="notranslate">#[Required]</code> 进行自动装配也可以应用于公共类型属性：',
        'Autowiring Controller Action Methods': '自动装配控制器操作方法',
        'If you\'re using the Symfony Framework, you can also autowire arguments to your controller\naction methods. This is a special case for autowiring, which exists for convenience.\nSee Controller for more details.': '如果你使用的是Symfony框架，你还可以自动装配控制器操作方法的参数。这是自动装配的一种特殊情况，旨在提供便利。更多详细信息，请参见<a href="../controller.html#controller-accessing-services" class="reference internal">控制器文档</a>。',
        'Performance Consequences': '性能影响',
        'Thanks to Symfony\'s compiled container, there is no performance penalty for using\nautowiring. However, there is a small performance penalty in the dev environment,\nas the container may be rebuilt more often as you modify classes. If rebuilding\nyour container is slow (possible on very large projects), you may not be able to\nuse autowiring.': '得益于 Symfony 的编译容器，使用自动装配在生产环境中不会带来性能损失。然而，在 <code translate="no" class="notranslate">dev</code>（开发）环境中，由于容器可能在你修改类时更频繁地重建，会有轻微的性能影响。如果重建容器的过程较慢（在非常大的项目中有可能出现这种情况），你可能无法使用自动装配。',
        'Public and Reusable Bundles': '公共和可重用的 Bundle',
        'Public bundles should explicitly configure their services and not rely on autowiring.\nAutowiring depends on the services that are available in the container and bundles have\nno control over the service container of applications they are included in. You can use\nautowiring when building reusable bundles within your company, as you have full control\nover all code.': '公共 bundle 应显式配置其服务，而不应依赖自动装配。自动装配依赖于容器中可用的服务，而 bundle 对其所包含的应用程序的服务容器没有控制权。在公司内部构建可重用的 bundle 时，你可以使用自动装配，因为你对所有代码都有完全控制权。',
    };

    fanyi(translates, 1);
})($);
