// ==UserScript==
// @name         Symfony 翻译文档 configuration/front_controllers_and_kernel.html
// @namespace    fireloong
// @version      0.1.1
// @description  翻译文档 configuration/front_controllers_and_kernel.html
// @author       Itsky71
// @match        https://symfony.com/doc/5.x/configuration/front_controllers_and_kernel.html
// @match        https://symfony.com/doc/6.4/configuration/front_controllers_and_kernel.html
// @match        https://symfony.com/doc/7.1/configuration/front_controllers_and_kernel.html
// @match        https://symfony.com/doc/7.2/configuration/front_controllers_and_kernel.html
// @match        https://symfony.com/doc/current/configuration/front_controllers_and_kernel.html
// @icon         https://www.google.com/s2/favicons?sz=64&domain=symfony.com
// @require      https://unpkg.com/jquery@3.7.1/dist/jquery.min.js
// @require      https://update.greasyfork.org/scripts/503008/fanyi.js
// @grant        none
// @license      MIT
// @downloadURL https://update.greasyfork.org/scripts/505013/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20configurationfront_controllers_and_kernelhtml.user.js
// @updateURL https://update.greasyfork.org/scripts/505013/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20configurationfront_controllers_and_kernelhtml.meta.js
// ==/UserScript==

(function($) {
    'use strict';

    const translates = {
        '\n        \n                    Understanding how the Front Controller, Kernel and Environments Work together\n        \n            ': '了解前端控制器（Front Controller）、内核（Kernel）和环境（Environments）如何协同工作',
        'The configuration environments section\nexplained the basics on how Symfony uses environments to run your application\nwith different configuration settings. This section will explain a bit more\nin-depth what happens when your application is bootstrapped. To hook into this\nprocess, you need to understand three parts that work together:': '<a href="../configuration.html#configuration-environments" class="reference internal">配置环境</a>部分解释了 Symfony 如何使用不同配置设置来运行你的应用程序的基本原理。本节将进一步详细说明当你启动应用程序时发生了什么。要介入这个过程，你需要理解三个相互协作的部分：',
        'The Front Controller': '前端控制器',
        'The Kernel Class': '内核',
        'The Environments': '环境',
        'Usually, you will not need to define your own front controller or\nKernel class as Symfony provides sensible default implementations.\nThis article is provided to explain what is going on behind the scenes.': '通常情况下，你不需要定义自己的前端控制器或 <code translate="no" class="notranslate">Kernel</code> 类，因为 Symfony 提供了合理的默认实现。本文旨在解释幕后的工作原理。',
        'The front controller is a design pattern; it is a section of code that all\nrequests served by an application run through.': '前端控制器是一种设计模式；它是应用程序处理所有请求时都会经过的一段代码。',
        'In the Symfony Skeleton, this role is taken by the index.php file in the\npublic/ directory. This is the very first PHP script that is run when a\nrequest is processed.': '在 Symfony Skeleton 中，这个角色由 <code translate="no" class="notranslate">public/</code> 目录下的 <code translate="no" class="notranslate">index.php</code> 文件承担。这是在处理请求时运行的第一个 PHP 脚本。',
        'The main purpose of the front controller is to create an instance of the\nKernel (more on that in a second), make it handle the request and return\nthe resulting response to the browser.': '前端控制器的主要目的是创建一个 <code translate="no" class="notranslate">Kernel</code> 实例（稍后会有更多介绍），让它处理请求并将其结果响应返回给浏览器。',
        'Because every request is routed through it, the front controller can be\nused to perform global initialization prior to setting up the kernel or\nto decorate the kernel with additional features. Examples include:': '由于每个请求都要通过它，前端控制器可以在设置内核之前执行全局初始化，或者用额外的功能来装饰内核。示例包括：',
        'You can choose the front controller that\'s used by adding it in the URL, like:': '你可以通过在 URL 中添加前端控制器来选择使用的前端控制器，例如：',
        'As you can see, this URL contains the PHP script to be used as the front\ncontroller. You can use that to switch to a custom made front controller\nthat is located in the public/ directory.': '如你所见，这个 URL 包含了用作前端控制器的 PHP 脚本。你可以通过这种方式切换到位于 <code translate="no" class="notranslate">public/</code> 目录中的自定义前端控制器。',
        'You almost never want to show the front controller in the URL. This is\nachieved by configuring the web server, as shown in\nConfiguring a Web Server.': '你几乎永远不想在 URL 中显示前端控制器。这可以通过配置 web 服务器来实现，如在<a href="../setup/web_server_configuration.html" class="reference internal">配置 web 服务器</a>中所示。',
        'Technically, the bin/console script used when running Symfony on the command\nline is also a front controller, only that is not used for web, but for command\nline requests.': '从技术上讲，当在命令行运行 Symfony 时使用的 <code translate="no" class="notranslate">bin/console</code> 脚本也是一个前端控制器，只是它不是用于 web，而是用于命令行请求。',
        'The Kernel is the core of\nSymfony. It is responsible for setting up all the bundles used by\nyour application and providing them with the application\'s configuration.\nIt then creates the service container before serving requests in its\nhandle()\nmethod.': '<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Kernel.php" class="reference external" title="Symfony\Component\HttpKernel\Kernel" rel="external noopener noreferrer" target="_blank">内核（Kernel）</a>是 Symfony 的核心。它负责设置应用程序使用的所有捆绑包（bundles），并向它们提供应用程序的配置。然后，它在 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/HttpKernelInterface.php#:~:text=function%20handle" class="reference external" title="Symfony\Component\HttpKernel\HttpKernelInterface::handle()" rel="external noopener noreferrer" target="_blank">handle()</a> 方法中创建服务容器并处理请求。',
        'The kernel used in Symfony applications extends from Kernel\nand uses the MicroKernelTrait.\nThe Kernel class leaves some methods from KernelInterface\nunimplemented and the MicroKernelTrait defines several abstract methods, so\nyou must implement them all:': 'Symfony 应用程序中使用的内核扩展自 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Kernel.php" class="reference external" title="Symfony\Component\HttpKernel\Kernel" rel="external noopener noreferrer" target="_blank">Kernel</a> 并使用 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/FrameworkBundle/Kernel/MicroKernelTrait.php" class="reference external" title="Symfony\Bundle\FrameworkBundle\Kernel\MicroKernelTrait" rel="external noopener noreferrer" target="_blank">MicroKernelTrait</a>。<code translate="no" class="notranslate">Kernel</code> 类中有一些来自 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/KernelInterface.php" class="reference external" title="Symfony\Component\HttpKernel\KernelInterface" rel="external noopener noreferrer" target="_blank">KernelInterface</a> 的方法未实现，而 <code translate="no" class="notranslate">MicroKernelTrait</code> 定义了几个抽象方法，因此你必须全部实现它们：',
        '\n                            It must return an array of all bundles needed to run the application.\n                    ': '它必须返回一个包含运行应用程序所需的所有捆绑包（bundles）的数组。',
        '\n                            It adds individual routes or collections of routes to the application (for\nexample loading the routes defined in some config file).\n                    ': '它向应用程序添加单个路由或路由集合（例如加载某些配置文件中定义的路由）。',
        '\n                            It loads the application configuration from config files or using the\nloadFromExtension() method and can also register new container parameters\nand services.\n                    ': '它从配置文件中或使用 <code translate="no" class="notranslate">loadFromExtension()</code> 方法加载应用程序配置，并且还可以注册新的容器参数和服务。',
        'To fill these (small) blanks, your application needs to extend the Kernel class\nand use the MicroKernelTrait to implement these methods. Symfony provides by\ndefault that kernel in the src/Kernel.php file.': '为了填补这些（小）空白，你的应用程序需要扩展 Kernel 类并使用 MicroKernelTrait 来实现这些方法。Symfony 默认在 <code translate="no" class="notranslate">src/Kernel.php</code> 文件中提供了该内核。',
        'This class uses the name of the environment - which is passed to the Kernel\'s\nconstructor\nmethod and is available via getEnvironment() -\nto decide which bundles to enable. The logic for that is in registerBundles().': '这个类使用环境的名称——该名称传递给内核的<a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Kernel.php#:~:text=function%20__construct" class="reference external" title="Symfony\Component\HttpKernel\Kernel::__construct()" rel="external noopener noreferrer" target="_blank">构造</a>方法，并通过 <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Component/HttpKernel/Kernel.php#:~:text=function%20getEnvironment" class="reference external" title="Symfony\Component\HttpKernel\Kernel::getEnvironment()" rel="external noopener noreferrer" target="_blank">getEnvironment()</a> 方法获取——来决定启用哪些捆绑包。相关的逻辑实现在 <code translate="no" class="notranslate">registerBundles()</code> 方法中。',
        'You are free to create your own, alternative or additional Kernel variants.\nAll you need is to adapt your (or add a new) front controller to make use of the\nnew kernel.': '你可以自由创建自己的替代或额外的 <code translate="no" class="notranslate">Kernel</code> 变体。你只需要调整你的前端控制器（或添加一个新的前端控制器）以使用新的内核。',
        'The name and location of the Kernel is not fixed. When putting\nmultiple kernels into a single application,\nit might therefore make sense to add additional sub-directories, for example\nsrc/admin/AdminKernel.php and src/api/ApiKernel.php. All that matters\nis that your front controller is able to create an instance of the appropriate kernel.': '<code translate="no" class="notranslate">Kernel</code> 的名称和位置并不是固定的。因此，在<a href="multiple_kernels.html" class="reference internal">将多个内核放入单个应用</a>时，增加额外的子目录可能是有意义的，例如 <code translate="no" class="notranslate">src/admin/AdminKernel.php</code> 和 <code translate="no" class="notranslate">src/api/ApiKernel.php</code>。重要的是你的前端控制器能够创建一个合适的内核实例。',
        'There\'s a lot more the Kernel can be used for, for example\noverriding the default directory structure.\nBut odds are high that you don\'t need to change things like this on the\nfly by having several Kernel implementations.': '<code translate="no" class="notranslate">Kernel</code> 还可以用于许多其它方面，例如<a href="override_dir_structure.html" class="reference internal">覆盖默认的目录结构</a>。但很有可能你并不需要通过实现多个 <code translate="no" class="notranslate">Kernel</code> 来动态地更改这样的设置。',
        'Debug Mode': '调试模式',
        'The second argument to the Kernel constructor specifies if the application\nshould run in "debug mode". Regardless of the\nconfiguration environment, a Symfony\napplication can be run with debug mode set to true or false.': '<code translate="no" class="notranslate">Kernel</code> 构造函数的第二个参数指定了应用程序是否应以“调试模式”运行。无论<a href="../configuration.html#configuration-environments" class="reference internal">配置环境</a>如何，Symfony 应用程序都可以设置为以 <code translate="no" class="notranslate">true</code> 或 <code translate="no" class="notranslate">false</code> 的调试模式运行。',
        'This affects many things in the application, such as displaying stack traces on\nerror pages or if cache files are dynamically rebuilt on each request. Though\nnot a requirement, debug mode is generally set to true for the dev and\ntest environments and false for the prod environment.': '这会影响应用程序中的许多方面，例如在错误页面上显示堆栈跟踪，或者缓存文件是否在每次请求时动态重建。尽管这不是硬性要求，但通常会为 <code translate="no" class="notranslate">dev</code> 和 <code translate="no" class="notranslate">test</code> 环境设置 <code translate="no" class="notranslate">true</code> 的调试模式，而为 <code translate="no" class="notranslate">prod</code> 生产环境设置 <code translate="no" class="notranslate">false</code> 的调试模式。',
        'Similar to configuring the environment\nyou can also enable/disable the debug mode using the .env file:': '类似于<a href="../configuration.html#selecting-the-active-environment" class="reference internal">配置环境</a>，你也可以使用 <a href="../configuration.html#config-dot-env" class="reference internal"><code translate="no" class="notranslate">.env</code> 文件</a>来启用或禁用调试模式：',
        'This value can be overridden for commands by passing the APP_DEBUG value\nbefore running them:': '这个值可以通过在运行命令前传递 <code translate="no" class="notranslate">APP_DEBUG</code> 值来覆盖：',
        'Internally, the value of the debug mode becomes the kernel.debug\nparameter used inside the service container.\nIf you look inside the application configuration file, you\'ll see the\nparameter used, for example, to turn Twig\'s debug mode on:': '在内部，调试模式的值会成为<a href="../service_container.html" class="reference internal">服务容器</a>中使用的 <code translate="no" class="notranslate">kernel.debug</code> 参数。如果你查看应用程序的配置文件，你会看到该参数被用来开启 Twig 的调试模式，例如：',
        'As mentioned above, the Kernel has to implement another method -\nconfigureContainer().\nThis method is responsible for loading the application\'s configuration from the\nright environment.': '如上所述，<code translate="no" class="notranslate">Kernel</code> 必须实现另一个方法 —— <a href="https://github.com/symfony/symfony/blob/'+doc_version+'/src/Symfony/Bundle/FrameworkBundle/Kernel/MicroKernelTrait.php#:~:text=function%20configureContainer" class="reference external" title="Symfony\Bundle\FrameworkBundle\Kernel\MicroKernelTrait::configureContainer()" rel="external noopener noreferrer" target="_blank">configureContainer()</a>。这个方法负责从正确的环境中加载应用程序的配置。',
        'Configuration environments allow to execute\nthe same code using different configuration. Symfony provides three environments\nby default called dev, prod and test.': '<a href="../configuration.html#configuration-environments" class="reference internal">配置环境</a>允许使用不同的配置来执行相同的代码。Symfony 默认提供了三个环境，分别是 <code translate="no" class="notranslate">dev</code>、<code translate="no" class="notranslate">prod</code> 和 <code translate="no" class="notranslate">test</code>。',
        'More technically, these names are nothing more than strings passed from the\nfront controller to the Kernel\'s constructor. This name can then be used in\nthe configureContainer() method to decide which configuration files to load.': '从技术上讲，这些名字只不过是从前端控制器传递给 <code translate="no" class="notranslate">Kernel</code> 构造函数的字符串。然后可以在 <code translate="no" class="notranslate">configureContainer()</code> 方法中使用这个名字来决定加载哪些配置文件。',
        'Symfony\'s default Kernel class implements this method by loading first the\nconfig files found on config/packages/* and then, the files found on\nconfig/packages/ENVIRONMENT_NAME/. You are free to implement this method\ndifferently if you need a more sophisticated way of loading your configuration.': 'Symfony 默认的 <code translate="no" class="notranslate">Kernel</code> 类通过这个方法首先加载位于 <code translate="no" class="notranslate">config/packages/*</code> 的配置文件，然后加载位于 <code translate="no" class="notranslate">config/packages/ENVIRONMENT_NAME/</code> 的文件。如果你需要更复杂的方式来加载配置，你可以自由地以不同的方式实现这个方法。',
        'Environments and the Cache Directory': '环境与缓存目录',
        'Symfony takes advantage of caching in many ways: the application configuration,\nrouting configuration, Twig templates and more are cached to PHP objects\nstored in files on the filesystem.': 'Symfony 在许多方面利用了缓存：应用程序配置、路由配置、Twig 模板等都被缓存为存储在文件系统中的 PHP 对象。',
        'By default, these cached files are largely stored in the var/cache/ directory.\nHowever, each environment caches its own set of files:': '默认情况下，这些缓存文件主要存储在 <code translate="no" class="notranslate">var/cache/</code> 目录中。然而，每个环境都会缓存自己的文件集：',
        'Sometimes, when debugging, it may be helpful to inspect a cached file to\nunderstand how something is working. When doing so, remember to look in\nthe directory of the environment you\'re using (most commonly dev/ while\ndeveloping and debugging). While it can vary, the var/cache/dev/ directory\nincludes the following:': '有时候，在调试时，检查缓存文件可能会有助于理解某些功能的工作原理。在这种情况下，请记得查看你正在使用的环境的目录（最常见的是在开发和调试时的 <code translate="no" class="notranslate">dev/</code>）。虽然可能会有所不同，但 <code translate="no" class="notranslate">var/cache/dev/</code> 目录通常包括以下内容：',
        '\n                            The cached "service container" that represents the cached application\nconfiguration.\n                    ': '代表缓存的应用程序配置的缓存“服务容器”。',
        '\n                            The cached routing configuration used when generating URLs.\n                    ': '用于生成 URL 时的缓存路由配置。',
        '\n                            The cached configuration used for route matching - look here to see the compiled\nregular expression logic used to match incoming URLs to different routes.\n                    ': '用于路由匹配的缓存配置——在这里可以看到用于将传入的 URL 匹配到不同路由的编译正则表达式逻辑。',
        '\n                            This directory contains all the cached Twig templates.\n                    ': '这个目录包含了所有缓存的 Twig 模板。',
        'You can change the cache directory location and name. For more information\nread the article How to Override Symfony\'s default Directory Structure.': '你可以更改缓存目录的位置和名称。更多信息请参阅文章<a href="override_dir_structure.html" class="reference internal">如何覆盖 Symfony 默认的目录结构</a>。',
    };

    const translates_li = {
        'Configuring the autoloader or adding additional autoloading mechanisms;': '配置自动加载器或添加额外的自动加载机制；',
        'Adding HTTP level caching by wrapping the kernel with an instance of\nHttpCache;': '通过使用 <a href="../http_cache.html#symfony-gateway-cache" class="reference internal">HttpCache</a> 实例包裹内核来添加 HTTP 级别的缓存；',
        'Enabling the Debug component.': '启用<a href="https://github.com/symfony/debug" class="reference external" rel="external noopener noreferrer" target="_blank">调试（Debug）组件</a>。',
    };

    fanyi(translates, '.toctree a,.ui-heading > h1,.ui-prose > .section p,.ui-prose > .section li > a,.ui-prose > .section h2>a,.ui-prose > .section h3>a,.ui-prose > .section h4>a,.ui-prose > .section dl>dt,.ui-prose > .section dl > dd,.hljs-comment');
    fanyi(translates_li, '.ui-prose > .section li');
})($);
