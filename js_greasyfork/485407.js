// ==UserScript==
// @name         community-post
// @namespace    npm/vite-plugin-monkey
// @version      0.0.2
// @author       monkey
// @description  游盛文章更新
// @license      MIT
// @icon         https://vitejs.dev/logo.svg
// @match        https://www.gamersky.com/*/*/*.shtml
// @match        https://www.csgo.com.cn/article/details/*/*.html
// @match        http://172.16.101.30:1134/*
// @match        https://buff.163.com/news/*
// @match        https://gl.ali213.net/html/*/*.html
// @match        https://bbs.hupu.com/*.html
// @match        http://172.16.101.30:1134/*
// @match        https://186admin.nps.doveaz.xyz:1443/*
// @grant        GM_addStyle
// @grant        GM_deleteValue
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_xmlhttpRequest
// @grant        window.close
// @downloadURL https://update.greasyfork.org/scripts/485407/community-post.user.js
// @updateURL https://update.greasyfork.org/scripts/485407/community-post.meta.js
// ==/UserScript==

(e=>{if(typeof GM_addStyle=="function"){GM_addStyle(e);return}const r=document.createElement("style");r.textContent=e,document.head.append(r)})(` @charset "UTF-8";:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","\u5FAE\u8F6F\u96C5\u9ED1",Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:.3s;--el-transition-duration-fast:.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(.645, .045, .355, 1);--el-transition-function-fast-bezier:cubic-bezier(.23, 1, .32, 1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px}:root{color-scheme:light;--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary:#409eff;--el-color-primary-light-3:#79bbff;--el-color-primary-light-5:#a0cfff;--el-color-primary-light-7:#c6e2ff;--el-color-primary-light-8:#d9ecff;--el-color-primary-light-9:#ecf5ff;--el-color-primary-dark-2:#337ecc;--el-color-success:#67c23a;--el-color-success-light-3:#95d475;--el-color-success-light-5:#b3e19d;--el-color-success-light-7:#d1edc4;--el-color-success-light-8:#e1f3d8;--el-color-success-light-9:#f0f9eb;--el-color-success-dark-2:#529b2e;--el-color-warning:#e6a23c;--el-color-warning-light-3:#eebe77;--el-color-warning-light-5:#f3d19e;--el-color-warning-light-7:#f8e3c5;--el-color-warning-light-8:#faecd8;--el-color-warning-light-9:#fdf6ec;--el-color-warning-dark-2:#b88230;--el-color-danger:#f56c6c;--el-color-danger-light-3:#f89898;--el-color-danger-light-5:#fab6b6;--el-color-danger-light-7:#fcd3d3;--el-color-danger-light-8:#fde2e2;--el-color-danger-light-9:#fef0f0;--el-color-danger-dark-2:#c45656;--el-color-error:#f56c6c;--el-color-error-light-3:#f89898;--el-color-error-light-5:#fab6b6;--el-color-error-light-7:#fcd3d3;--el-color-error-light-8:#fde2e2;--el-color-error-light-9:#fef0f0;--el-color-error-dark-2:#c45656;--el-color-info:#909399;--el-color-info-light-3:#b1b3b8;--el-color-info-light-5:#c8c9cc;--el-color-info-light-7:#dedfe0;--el-color-info-light-8:#e9e9eb;--el-color-info-light-9:#f4f4f5;--el-color-info-dark-2:#73767a;--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0, 0, 0, .04),0px 8px 20px rgba(0, 0, 0, .08);--el-box-shadow-light:0px 0px 12px rgba(0, 0, 0, .12);--el-box-shadow-lighter:0px 0px 6px rgba(0, 0, 0, .12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0, 0, 0, .08),0px 12px 32px rgba(0, 0, 0, .12),0px 8px 16px -8px rgba(0, 0, 0, .16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0, 0, 0, .8);--el-overlay-color-light:rgba(0, 0, 0, .7);--el-overlay-color-lighter:rgba(0, 0, 0, .5);--el-mask-color:rgba(255, 255, 255, .9);--el-mask-color-extra-light:rgba(255, 255, 255, .3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.el-icon-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@-webkit-keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.el-icon{--color:inherit;height:1em;width:1em;line-height:1em;display:inline-flex;justify-content:center;align-items:center;position:relative;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}.el-button{--el-button-font-weight:var(--el-font-weight-primary);--el-button-border-color:var(--el-border-color);--el-button-bg-color:var(--el-fill-color-blank);--el-button-text-color:var(--el-text-color-regular);--el-button-disabled-text-color:var(--el-disabled-text-color);--el-button-disabled-bg-color:var(--el-fill-color-blank);--el-button-disabled-border-color:var(--el-border-color-light);--el-button-divide-border-color:rgba(255, 255, 255, .5);--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-color-primary-light-9);--el-button-hover-border-color:var(--el-color-primary-light-7);--el-button-active-text-color:var(--el-button-hover-text-color);--el-button-active-border-color:var(--el-color-primary);--el-button-active-bg-color:var(--el-button-hover-bg-color);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-hover-link-text-color:var(--el-color-info);--el-button-active-color:var(--el-text-color-primary)}.el-button{display:inline-flex;justify-content:center;align-items:center;line-height:1;height:32px;white-space:nowrap;cursor:pointer;color:var(--el-button-text-color);text-align:center;box-sizing:border-box;outline:0;transition:.1s;font-weight:var(--el-button-font-weight);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-webkit-appearance:none;background-color:var(--el-button-bg-color);border:var(--el-border);border-color:var(--el-button-border-color);padding:8px 15px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button:focus,.el-button:hover{color:var(--el-button-hover-text-color);border-color:var(--el-button-hover-border-color);background-color:var(--el-button-hover-bg-color);outline:0}.el-button:active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button:focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button>span{display:inline-flex;align-items:center}.el-button+.el-button{margin-left:12px}.el-button.is-round{padding:8px 15px}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon]+span{margin-left:6px}.el-button [class*=el-icon] svg{vertical-align:bottom}.el-button.is-plain{--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-fill-color-blank);--el-button-hover-border-color:var(--el-color-primary)}.el-button.is-active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button.is-disabled,.el-button.is-disabled:focus,.el-button.is-disabled:hover{color:var(--el-button-disabled-text-color);cursor:not-allowed;background-image:none;background-color:var(--el-button-disabled-bg-color);border-color:var(--el-button-disabled-border-color)}.el-button.is-loading{position:relative;pointer-events:none}.el-button.is-loading:before{z-index:1;pointer-events:none;content:"";position:absolute;left:-1px;top:-1px;right:-1px;bottom:-1px;border-radius:inherit;background-color:var(--el-mask-color-extra-light)}.el-button.is-round{border-radius:var(--el-border-radius-round)}.el-button.is-circle{width:32px;border-radius:50%;padding:8px}.el-button.is-text{color:var(--el-button-text-color);border:0 solid transparent;background-color:transparent}.el-button.is-text.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important}.el-button.is-text:not(.is-disabled):focus,.el-button.is-text:not(.is-disabled):hover{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled):focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button.is-text:not(.is-disabled):active{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled).is-has-bg:focus,.el-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--el-fill-color-dark)}.el-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.el-button.is-link{border-color:transparent;color:var(--el-button-text-color);background:0 0;padding:2px;height:auto}.el-button.is-link:focus,.el-button.is-link:hover{color:var(--el-button-hover-link-text-color)}.el-button.is-link.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.el-button.is-link:not(.is-disabled):focus,.el-button.is-link:not(.is-disabled):hover{border-color:transparent;background-color:transparent}.el-button.is-link:not(.is-disabled):active{color:var(--el-button-active-color);border-color:transparent;background-color:transparent}.el-button--text{border-color:transparent;background:0 0;color:var(--el-color-primary);padding-left:0;padding-right:0}.el-button--text.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.el-button--text:not(.is-disabled):focus,.el-button--text:not(.is-disabled):hover{color:var(--el-color-primary-light-3);border-color:transparent;background-color:transparent}.el-button--text:not(.is-disabled):active{color:var(--el-color-primary-dark-2);border-color:transparent;background-color:transparent}.el-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.el-button--primary{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-primary);--el-button-border-color:var(--el-color-primary);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-active-color:var(--el-color-primary-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-primary-light-5);--el-button-hover-bg-color:var(--el-color-primary-light-3);--el-button-hover-border-color:var(--el-color-primary-light-3);--el-button-active-bg-color:var(--el-color-primary-dark-2);--el-button-active-border-color:var(--el-color-primary-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-primary-light-5);--el-button-disabled-border-color:var(--el-color-primary-light-5)}.el-button--primary.is-link,.el-button--primary.is-plain,.el-button--primary.is-text{--el-button-text-color:var(--el-color-primary);--el-button-bg-color:var(--el-color-primary-light-9);--el-button-border-color:var(--el-color-primary-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-primary);--el-button-hover-border-color:var(--el-color-primary);--el-button-active-text-color:var(--el-color-white)}.el-button--primary.is-link.is-disabled,.el-button--primary.is-link.is-disabled:active,.el-button--primary.is-link.is-disabled:focus,.el-button--primary.is-link.is-disabled:hover,.el-button--primary.is-plain.is-disabled,.el-button--primary.is-plain.is-disabled:active,.el-button--primary.is-plain.is-disabled:focus,.el-button--primary.is-plain.is-disabled:hover,.el-button--primary.is-text.is-disabled,.el-button--primary.is-text.is-disabled:active,.el-button--primary.is-text.is-disabled:focus,.el-button--primary.is-text.is-disabled:hover{color:var(--el-color-primary-light-5);background-color:var(--el-color-primary-light-9);border-color:var(--el-color-primary-light-8)}.el-button--success{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-success);--el-button-border-color:var(--el-color-success);--el-button-outline-color:var(--el-color-success-light-5);--el-button-active-color:var(--el-color-success-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-success-light-5);--el-button-hover-bg-color:var(--el-color-success-light-3);--el-button-hover-border-color:var(--el-color-success-light-3);--el-button-active-bg-color:var(--el-color-success-dark-2);--el-button-active-border-color:var(--el-color-success-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-success-light-5);--el-button-disabled-border-color:var(--el-color-success-light-5)}.el-button--success.is-link,.el-button--success.is-plain,.el-button--success.is-text{--el-button-text-color:var(--el-color-success);--el-button-bg-color:var(--el-color-success-light-9);--el-button-border-color:var(--el-color-success-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-success);--el-button-hover-border-color:var(--el-color-success);--el-button-active-text-color:var(--el-color-white)}.el-button--success.is-link.is-disabled,.el-button--success.is-link.is-disabled:active,.el-button--success.is-link.is-disabled:focus,.el-button--success.is-link.is-disabled:hover,.el-button--success.is-plain.is-disabled,.el-button--success.is-plain.is-disabled:active,.el-button--success.is-plain.is-disabled:focus,.el-button--success.is-plain.is-disabled:hover,.el-button--success.is-text.is-disabled,.el-button--success.is-text.is-disabled:active,.el-button--success.is-text.is-disabled:focus,.el-button--success.is-text.is-disabled:hover{color:var(--el-color-success-light-5);background-color:var(--el-color-success-light-9);border-color:var(--el-color-success-light-8)}.el-button--warning{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-warning);--el-button-border-color:var(--el-color-warning);--el-button-outline-color:var(--el-color-warning-light-5);--el-button-active-color:var(--el-color-warning-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-warning-light-5);--el-button-hover-bg-color:var(--el-color-warning-light-3);--el-button-hover-border-color:var(--el-color-warning-light-3);--el-button-active-bg-color:var(--el-color-warning-dark-2);--el-button-active-border-color:var(--el-color-warning-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-warning-light-5);--el-button-disabled-border-color:var(--el-color-warning-light-5)}.el-button--warning.is-link,.el-button--warning.is-plain,.el-button--warning.is-text{--el-button-text-color:var(--el-color-warning);--el-button-bg-color:var(--el-color-warning-light-9);--el-button-border-color:var(--el-color-warning-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-warning);--el-button-hover-border-color:var(--el-color-warning);--el-button-active-text-color:var(--el-color-white)}.el-button--warning.is-link.is-disabled,.el-button--warning.is-link.is-disabled:active,.el-button--warning.is-link.is-disabled:focus,.el-button--warning.is-link.is-disabled:hover,.el-button--warning.is-plain.is-disabled,.el-button--warning.is-plain.is-disabled:active,.el-button--warning.is-plain.is-disabled:focus,.el-button--warning.is-plain.is-disabled:hover,.el-button--warning.is-text.is-disabled,.el-button--warning.is-text.is-disabled:active,.el-button--warning.is-text.is-disabled:focus,.el-button--warning.is-text.is-disabled:hover{color:var(--el-color-warning-light-5);background-color:var(--el-color-warning-light-9);border-color:var(--el-color-warning-light-8)}.el-button--danger{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-danger);--el-button-border-color:var(--el-color-danger);--el-button-outline-color:var(--el-color-danger-light-5);--el-button-active-color:var(--el-color-danger-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-danger-light-5);--el-button-hover-bg-color:var(--el-color-danger-light-3);--el-button-hover-border-color:var(--el-color-danger-light-3);--el-button-active-bg-color:var(--el-color-danger-dark-2);--el-button-active-border-color:var(--el-color-danger-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-danger-light-5);--el-button-disabled-border-color:var(--el-color-danger-light-5)}.el-button--danger.is-link,.el-button--danger.is-plain,.el-button--danger.is-text{--el-button-text-color:var(--el-color-danger);--el-button-bg-color:var(--el-color-danger-light-9);--el-button-border-color:var(--el-color-danger-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-danger);--el-button-hover-border-color:var(--el-color-danger);--el-button-active-text-color:var(--el-color-white)}.el-button--danger.is-link.is-disabled,.el-button--danger.is-link.is-disabled:active,.el-button--danger.is-link.is-disabled:focus,.el-button--danger.is-link.is-disabled:hover,.el-button--danger.is-plain.is-disabled,.el-button--danger.is-plain.is-disabled:active,.el-button--danger.is-plain.is-disabled:focus,.el-button--danger.is-plain.is-disabled:hover,.el-button--danger.is-text.is-disabled,.el-button--danger.is-text.is-disabled:active,.el-button--danger.is-text.is-disabled:focus,.el-button--danger.is-text.is-disabled:hover{color:var(--el-color-danger-light-5);background-color:var(--el-color-danger-light-9);border-color:var(--el-color-danger-light-8)}.el-button--info{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-info);--el-button-border-color:var(--el-color-info);--el-button-outline-color:var(--el-color-info-light-5);--el-button-active-color:var(--el-color-info-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-info-light-5);--el-button-hover-bg-color:var(--el-color-info-light-3);--el-button-hover-border-color:var(--el-color-info-light-3);--el-button-active-bg-color:var(--el-color-info-dark-2);--el-button-active-border-color:var(--el-color-info-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-info-light-5);--el-button-disabled-border-color:var(--el-color-info-light-5)}.el-button--info.is-link,.el-button--info.is-plain,.el-button--info.is-text{--el-button-text-color:var(--el-color-info);--el-button-bg-color:var(--el-color-info-light-9);--el-button-border-color:var(--el-color-info-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-info);--el-button-hover-border-color:var(--el-color-info);--el-button-active-text-color:var(--el-color-white)}.el-button--info.is-link.is-disabled,.el-button--info.is-link.is-disabled:active,.el-button--info.is-link.is-disabled:focus,.el-button--info.is-link.is-disabled:hover,.el-button--info.is-plain.is-disabled,.el-button--info.is-plain.is-disabled:active,.el-button--info.is-plain.is-disabled:focus,.el-button--info.is-plain.is-disabled:hover,.el-button--info.is-text.is-disabled,.el-button--info.is-text.is-disabled:active,.el-button--info.is-text.is-disabled:focus,.el-button--info.is-text.is-disabled:hover{color:var(--el-color-info-light-5);background-color:var(--el-color-info-light-9);border-color:var(--el-color-info-light-8)}.el-button--large{--el-button-size:40px;height:var(--el-button-size);padding:12px 19px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button--large [class*=el-icon]+span{margin-left:8px}.el-button--large.is-round{padding:12px 19px}.el-button--large.is-circle{width:var(--el-button-size);padding:12px}.el-button--small{--el-button-size:24px;height:var(--el-button-size);padding:5px 11px;font-size:12px;border-radius:calc(var(--el-border-radius-base) - 1px)}.el-button--small [class*=el-icon]+span{margin-left:4px}.el-button--small.is-round{padding:5px 11px}.el-button--small.is-circle{width:var(--el-button-size);padding:5px}:root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:.5}.v-modal-enter{-webkit-animation:v-modal-in var(--el-transition-duration-fast) ease;animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{-webkit-animation:v-modal-out var(--el-transition-duration-fast) ease forwards;animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@-webkit-keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-in{0%{opacity:0}}@-webkit-keyframes v-modal-out{to{opacity:0}}@keyframes v-modal-out{to{opacity:0}}.v-modal{position:fixed;left:0;top:0;width:100%;height:100%;opacity:var(--el-popup-modal-opacity);background:var(--el-popup-modal-bg-color)}.el-popup-parent--hidden{overflow:hidden}.el-dialog{--el-dialog-width:50%;--el-dialog-margin-top:15vh;--el-dialog-bg-color:var(--el-bg-color);--el-dialog-box-shadow:var(--el-box-shadow);--el-dialog-title-font-size:var(--el-font-size-large);--el-dialog-content-font-size:14px;--el-dialog-font-line-height:var(--el-font-line-height-primary);--el-dialog-padding-primary:20px;--el-dialog-border-radius:var(--el-border-radius-small);position:relative;margin:var(--el-dialog-margin-top,15vh) auto 50px;background:var(--el-dialog-bg-color);border-radius:var(--el-dialog-border-radius);box-shadow:var(--el-dialog-box-shadow);box-sizing:border-box;width:var(--el-dialog-width,50%)}.el-dialog:focus{outline:0!important}.el-dialog.is-align-center{margin:auto}.el-dialog.is-fullscreen{--el-dialog-width:100%;--el-dialog-margin-top:0;margin-bottom:0;height:100%;overflow:auto}.el-dialog__wrapper{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto;margin:0}.el-dialog.is-draggable .el-dialog__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-dialog__header{padding:var(--el-dialog-padding-primary);padding-bottom:10px;margin-right:16px}.el-dialog__headerbtn{position:absolute;top:6px;right:0;padding:0;width:54px;height:54px;background:0 0;border:none;outline:0;cursor:pointer;font-size:var(--el-message-close-size,16px)}.el-dialog__headerbtn .el-dialog__close{color:var(--el-color-info);font-size:inherit}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:var(--el-color-primary)}.el-dialog__title{line-height:var(--el-dialog-font-line-height);font-size:var(--el-dialog-title-font-size);color:var(--el-text-color-primary)}.el-dialog__body{padding:calc(var(--el-dialog-padding-primary) + 10px) var(--el-dialog-padding-primary);color:var(--el-text-color-regular);font-size:var(--el-dialog-content-font-size)}.el-dialog__footer{padding:var(--el-dialog-padding-primary);padding-top:10px;text-align:right;box-sizing:border-box}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial;padding:25px calc(var(--el-dialog-padding-primary) + 5px) 30px}.el-dialog--center .el-dialog__footer{text-align:inherit}.el-overlay-dialog{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto}.dialog-fade-enter-active{-webkit-animation:modal-fade-in var(--el-transition-duration);animation:modal-fade-in var(--el-transition-duration)}.dialog-fade-enter-active .el-overlay-dialog{-webkit-animation:dialog-fade-in var(--el-transition-duration);animation:dialog-fade-in var(--el-transition-duration)}.dialog-fade-leave-active{-webkit-animation:modal-fade-out var(--el-transition-duration);animation:modal-fade-out var(--el-transition-duration)}.dialog-fade-leave-active .el-overlay-dialog{-webkit-animation:dialog-fade-out var(--el-transition-duration);animation:dialog-fade-out var(--el-transition-duration)}@-webkit-keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}to{transform:translateZ(0);opacity:1}}@-webkit-keyframes dialog-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}@keyframes dialog-fade-out{0%{transform:translateZ(0);opacity:1}to{transform:translate3d(0,-20px,0);opacity:0}}@-webkit-keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@-webkit-keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}@keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}.el-overlay{position:fixed;top:0;right:0;bottom:0;left:0;z-index:2000;height:100%;background-color:var(--el-overlay-color-lighter);overflow:auto}.el-overlay .el-overlay-root{height:0}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%}.el-textarea{position:relative;display:inline-block;width:100%;vertical-align:bottom;font-size:var(--el-font-size-base)}.el-textarea__inner{position:relative;display:block;resize:vertical;padding:5px 11px;line-height:1.5;box-sizing:border-box;width:100%;font-size:inherit;font-family:inherit;color:var(--el-input-text-color,var(--el-text-color-regular));background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;-webkit-appearance:none;box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));transition:var(--el-transition-box-shadow);border:none}.el-textarea__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{outline:0;box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-textarea .el-input__count{color:var(--el-color-info);background:var(--el-fill-color-blank);position:absolute;font-size:12px;line-height:14px;bottom:5px;right:10px}.el-textarea.is-disabled .el-textarea__inner{box-shadow:0 0 0 1px var(--el-disabled-border-color) inset;background-color:var(--el-disabled-bg-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%}.el-input{--el-input-height:var(--el-component-size);position:relative;font-size:var(--el-font-size-base);display:inline-flex;width:var(--el-input-width);line-height:var(--el-input-height);box-sizing:border-box;vertical-align:middle}.el-input::-webkit-scrollbar{z-index:11;width:6px}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{border-radius:5px;width:6px;background:var(--el-text-color-disabled)}.el-input::-webkit-scrollbar-corner{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);font-size:14px;cursor:pointer}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{height:100%;display:inline-flex;align-items:center;color:var(--el-color-info);font-size:12px}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);line-height:initial;display:inline-block;padding-left:8px}.el-input__wrapper{display:inline-flex;flex-grow:1;align-items:center;justify-content:center;padding:1px 11px;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));cursor:text;transition:var(--el-transition-box-shadow);transform:translateZ(0);box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px);width:100%;flex-grow:1;-webkit-appearance:none;color:var(--el-input-text-color,var(--el-text-color-regular));font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);padding:0;outline:0;border:none;background:0 0;box-sizing:border-box}.el-input__inner:focus{outline:0}.el-input__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__inner[type=number]{line-height:1}.el-input__prefix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__prefix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__suffix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{height:inherit;line-height:inherit;display:flex;justify-content:center;align-items:center;transition:all var(--el-transition-duration);margin-left:8px}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color,) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{display:inline-flex;width:100%;align-items:stretch}.el-input-group__append,.el-input-group__prepend{background-color:var(--el-fill-color-light);color:var(--el-color-info);position:relative;display:inline-flex;align-items:center;justify-content:center;min-height:100%;border-radius:var(--el-input-border-radius);padding:0 20px;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:0}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-select__wrapper,.el-input-group__append div.el-select:hover .el-select__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-select__wrapper,.el-input-group__prepend div.el-select:hover .el-select__wrapper{border-color:transparent;background-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-right:0;border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-left:0;border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-select__wrapper{border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--append>.el-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-select__wrapper{border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-tag{--el-tag-font-size:12px;--el-tag-border-radius:4px;--el-tag-border-radius-rounded:9999px}.el-tag{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary);--el-tag-text-color:var(--el-color-primary);background-color:var(--el-tag-bg-color);border-color:var(--el-tag-border-color);color:var(--el-tag-text-color);display:inline-flex;justify-content:center;align-items:center;vertical-align:middle;height:24px;padding:0 9px;font-size:var(--el-tag-font-size);line-height:1;border-width:1px;border-style:solid;border-radius:var(--el-tag-border-radius);box-sizing:border-box;white-space:nowrap;--el-icon-size:14px}.el-tag.el-tag--primary{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-bg-color:var(--el-color-success-light-9);--el-tag-border-color:var(--el-color-success-light-8);--el-tag-hover-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-bg-color:var(--el-color-warning-light-9);--el-tag-border-color:var(--el-color-warning-light-8);--el-tag-hover-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-bg-color:var(--el-color-danger-light-9);--el-tag-border-color:var(--el-color-danger-light-8);--el-tag-hover-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-bg-color:var(--el-color-error-light-9);--el-tag-border-color:var(--el-color-error-light-8);--el-tag-hover-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-bg-color:var(--el-color-info-light-9);--el-tag-border-color:var(--el-color-info-light-8);--el-tag-hover-color:var(--el-color-info)}.el-tag.el-tag--primary{--el-tag-text-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-text-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-text-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-text-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-text-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-text-color:var(--el-color-info)}.el-tag.is-hit{border-color:var(--el-color-primary)}.el-tag.is-round{border-radius:var(--el-tag-border-radius-rounded)}.el-tag .el-tag__close{flex-shrink:0;color:var(--el-tag-text-color)}.el-tag .el-tag__close:hover{color:var(--el-color-white);background-color:var(--el-tag-hover-color)}.el-tag .el-icon{border-radius:50%;cursor:pointer;font-size:calc(var(--el-icon-size) - 2px);height:var(--el-icon-size);width:var(--el-icon-size)}.el-tag .el-tag__close{margin-left:6px}.el-tag--dark{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3);--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--primary{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3)}.el-tag--dark.el-tag--success{--el-tag-bg-color:var(--el-color-success);--el-tag-border-color:var(--el-color-success);--el-tag-hover-color:var(--el-color-success-light-3)}.el-tag--dark.el-tag--warning{--el-tag-bg-color:var(--el-color-warning);--el-tag-border-color:var(--el-color-warning);--el-tag-hover-color:var(--el-color-warning-light-3)}.el-tag--dark.el-tag--danger{--el-tag-bg-color:var(--el-color-danger);--el-tag-border-color:var(--el-color-danger);--el-tag-hover-color:var(--el-color-danger-light-3)}.el-tag--dark.el-tag--error{--el-tag-bg-color:var(--el-color-error);--el-tag-border-color:var(--el-color-error);--el-tag-hover-color:var(--el-color-error-light-3)}.el-tag--dark.el-tag--info{--el-tag-bg-color:var(--el-color-info);--el-tag-border-color:var(--el-color-info);--el-tag-hover-color:var(--el-color-info-light-3)}.el-tag--dark.el-tag--primary,.el-tag--dark.el-tag--success,.el-tag--dark.el-tag--warning,.el-tag--dark.el-tag--danger,.el-tag--dark.el-tag--error,.el-tag--dark.el-tag--info{--el-tag-text-color:var(--el-color-white)}.el-tag--plain{--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary);--el-tag-bg-color:var(--el-fill-color-blank)}.el-tag--plain.el-tag--primary{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary)}.el-tag--plain.el-tag--success{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-success-light-5);--el-tag-hover-color:var(--el-color-success)}.el-tag--plain.el-tag--warning{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-warning-light-5);--el-tag-hover-color:var(--el-color-warning)}.el-tag--plain.el-tag--danger{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-danger-light-5);--el-tag-hover-color:var(--el-color-danger)}.el-tag--plain.el-tag--error{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-error-light-5);--el-tag-hover-color:var(--el-color-error)}.el-tag--plain.el-tag--info{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-info-light-5);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-closable{padding-right:5px}.el-tag--large{padding:0 11px;height:32px;--el-icon-size:16px}.el-tag--large .el-tag__close{margin-left:8px}.el-tag--large.is-closable{padding-right:7px}.el-tag--small{padding:0 7px;height:20px;--el-icon-size:12px}.el-tag--small .el-tag__close{margin-left:4px}.el-tag--small.is-closable{padding-right:3px}.el-tag--small .el-icon-close{transform:scale(.8)}.el-tag.el-tag--primary.is-hit{border-color:var(--el-color-primary)}.el-tag.el-tag--success.is-hit{border-color:var(--el-color-success)}.el-tag.el-tag--warning.is-hit{border-color:var(--el-color-warning)}.el-tag.el-tag--danger.is-hit{border-color:var(--el-color-danger)}.el-tag.el-tag--error.is-hit{border-color:var(--el-color-error)}.el-tag.el-tag--info.is-hit{border-color:var(--el-color-info)}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-selected:after{content:"";position:absolute;top:50%;right:20px;border-top:none;border-right:none;background-repeat:no-repeat;background-position:center;background-color:var(--el-color-primary);-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;transform:translateY(-50%);width:12px;height:12px}.el-scrollbar{--el-scrollbar-opacity:.3;--el-scrollbar-bg-color:var(--el-text-color-secondary);--el-scrollbar-hover-opacity:.5;--el-scrollbar-hover-bg-color:var(--el-text-color-secondary)}.el-scrollbar{overflow:hidden;position:relative;height:100%}.el-scrollbar__wrap{overflow:auto;height:100%}.el-scrollbar__wrap--hidden-default{scrollbar-width:none}.el-scrollbar__wrap--hidden-default::-webkit-scrollbar{display:none}.el-scrollbar__thumb{position:relative;display:block;width:0;height:0;cursor:pointer;border-radius:inherit;background-color:var(--el-scrollbar-bg-color,var(--el-text-color-secondary));transition:var(--el-transition-duration) background-color;opacity:var(--el-scrollbar-opacity,.3)}.el-scrollbar__thumb:hover{background-color:var(--el-scrollbar-hover-bg-color,var(--el-text-color-secondary));opacity:var(--el-scrollbar-hover-opacity,.5)}.el-scrollbar__bar{position:absolute;right:2px;bottom:2px;z-index:1;border-radius:4px}.el-scrollbar__bar.is-vertical{width:6px;top:2px}.el-scrollbar__bar.is-vertical>div{width:100%}.el-scrollbar__bar.is-horizontal{height:6px;left:2px}.el-scrollbar__bar.is-horizontal>div{height:100%}.el-scrollbar-fade-enter-active{transition:opacity .34s ease-out}.el-scrollbar-fade-leave-active{transition:opacity .12s ease-out}.el-scrollbar-fade-enter-from,.el-scrollbar-fade-leave-active{opacity:0}.el-popper{--el-popper-border-radius:var(--el-popover-border-radius, 4px)}.el-popper{position:absolute;border-radius:var(--el-popper-border-radius);padding:5px 11px;z-index:2000;font-size:12px;line-height:20px;min-width:10px;overflow-wrap:break-word;visibility:visible}.el-popper.is-dark{color:var(--el-bg-color);background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary)}.el-popper.is-dark .el-popper__arrow:before{border:1px solid var(--el-text-color-primary);background:var(--el-text-color-primary);right:0}.el-popper.is-light{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light)}.el-popper.is-light .el-popper__arrow:before{border:1px solid var(--el-border-color-light);background:var(--el-bg-color-overlay);right:0}.el-popper.is-pure{padding:0}.el-popper__arrow{position:absolute;width:10px;height:10px;z-index:-1}.el-popper__arrow:before{position:absolute;width:10px;height:10px;z-index:-1;content:" ";transform:rotate(45deg);background:var(--el-text-color-primary);box-sizing:border-box}.el-popper[data-popper-placement^=top]>.el-popper__arrow{bottom:-5px}.el-popper[data-popper-placement^=top]>.el-popper__arrow:before{border-bottom-right-radius:2px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow{top:-5px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow:before{border-top-left-radius:2px}.el-popper[data-popper-placement^=left]>.el-popper__arrow{right:-5px}.el-popper[data-popper-placement^=left]>.el-popper__arrow:before{border-top-right-radius:2px}.el-popper[data-popper-placement^=right]>.el-popper__arrow{left:-5px}.el-popper[data-popper-placement^=right]>.el-popper__arrow:before{border-bottom-left-radius:2px}.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent!important;border-left-color:transparent!important}.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent!important;border-right-color:transparent!important}.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent!important;border-bottom-color:transparent!important}.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent!important;border-top-color:transparent!important}.el-select-dropdown{z-index:calc(var(--el-index-top) + 1);border-radius:var(--el-border-radius-base);box-sizing:border-box}.el-select-dropdown .el-scrollbar.is-empty .el-select-dropdown__list{padding:0}.el-select-dropdown__empty{padding:10px 0;margin:0;text-align:center;color:var(--el-text-color-secondary);font-size:var(--el-select-font-size)}.el-select-dropdown__wrap{max-height:274px}.el-select-dropdown__list{list-style:none;padding:6px 0;margin:0;box-sizing:border-box}.el-select-dropdown__list.el-vl__window{margin:6px 0;padding:0}.el-select-dropdown__header{padding:10px;border-bottom:1px solid var(--el-border-color-light)}.el-select-dropdown__footer{padding:10px;border-top:1px solid var(--el-border-color-light)}.el-select-dropdown__item{font-size:var(--el-font-size-base);padding:0 32px 0 20px;position:relative;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--el-text-color-regular);height:34px;line-height:34px;box-sizing:border-box;cursor:pointer}.el-select-dropdown__item.is-hovering{background-color:var(--el-fill-color-light)}.el-select-dropdown__item.is-selected{color:var(--el-color-primary);font-weight:700}.el-select-dropdown__item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed;background-color:unset}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-selected:after{content:"";position:absolute;top:50%;right:20px;border-top:none;border-right:none;background-repeat:no-repeat;background-position:center;background-color:var(--el-color-primary);-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;transform:translateY(-50%);width:12px;height:12px}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-disabled:after{background-color:var(--el-text-color-placeholder)}.el-select-group{margin:0;padding:0}.el-select-group__wrap{position:relative;list-style:none;margin:0;padding:0}.el-select-group__wrap:not(:last-of-type){padding-bottom:24px}.el-select-group__wrap:not(:last-of-type):after{content:"";position:absolute;display:block;left:20px;right:20px;bottom:12px;height:1px;background:var(--el-border-color-light)}.el-select-group__split-dash{position:absolute;left:20px;right:20px;height:1px;background:var(--el-border-color-light)}.el-select-group__title{padding-left:20px;font-size:12px;color:var(--el-color-info);line-height:30px}.el-select-group .el-select-dropdown__item{padding-left:20px}.el-select{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px;--el-select-width:100%}.el-select{display:inline-block;position:relative;vertical-align:middle;width:var(--el-select-width)}.el-select__wrapper{display:flex;align-items:center;position:relative;box-sizing:border-box;cursor:pointer;text-align:left;font-size:14px;padding:4px 12px;gap:6px;min-height:32px;line-height:24px;border-radius:var(--el-border-radius-base);background-color:var(--el-fill-color-blank);transition:var(--el-transition-duration);box-shadow:0 0 0 1px var(--el-border-color) inset}.el-select__wrapper:hover{box-shadow:0 0 0 1px var(--el-text-color) inset}.el-select__wrapper.is-filterable{cursor:text}.el-select__wrapper.is-focused{box-shadow:0 0 0 1px var(--el-color-primary) inset}.el-select__wrapper.is-hovering:not(.is-focused){box-shadow:0 0 0 1px var(--el-border-color-hover) inset}.el-select__wrapper.is-disabled{cursor:not-allowed;background-color:var(--el-fill-color-light);color:var(--el-text-color-placeholder);box-shadow:0 0 0 1px var(--el-select-disabled-border) inset}.el-select__wrapper.is-disabled:hover{box-shadow:0 0 0 1px var(--el-select-disabled-border) inset}.el-select__wrapper.is-disabled.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-select__wrapper.is-disabled .el-select__caret,.el-select__wrapper.is-disabled .el-tag{cursor:not-allowed}.el-select__prefix,.el-select__suffix{display:flex;align-items:center;flex-shrink:0;gap:6px;color:var(--el-input-icon-color,var(--el-text-color-placeholder))}.el-select__caret{color:var(--el-select-input-color);font-size:var(--el-select-input-font-size);transition:var(--el-transition-duration);transform:rotate(0);cursor:pointer}.el-select__caret.is-reverse{transform:rotate(180deg)}.el-select__selection{position:relative;display:flex;flex-wrap:wrap;align-items:center;flex:1;min-width:0;gap:6px}.el-select__selection.is-near{margin-left:-8px}.el-select__selection .el-tag{cursor:pointer;border-color:transparent}.el-select__selection .el-tag .el-tag__content{min-width:0}.el-select__selected-item{display:flex;flex-wrap:wrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-select__tags-text{display:block;line-height:normal;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select__placeholder{position:absolute;display:block;top:50%;transform:translateY(-50%);width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--el-input-text-color,var(--el-text-color-regular))}.el-select__placeholder.is-transparent{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;color:var(--el-text-color-placeholder)}.el-select__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-select__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-select__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent;border-left-color:transparent}.el-select__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-select__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent;border-bottom-color:transparent}.el-select__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-select__input-wrapper{max-width:100%}.el-select__input-wrapper.is-hidden{position:absolute;opacity:0}.el-select__input{border:none;outline:0;padding:0;color:var(--el-select-multiple-input-color);font-size:inherit;-webkit-appearance:none;-moz-appearance:none;appearance:none;height:24px;max-width:100%;background-color:transparent}.el-select__input.is-disabled{cursor:not-allowed}.el-select__input-calculator{position:absolute;left:0;top:0;max-width:100%;visibility:hidden;white-space:nowrap;overflow:hidden}.el-select--large .el-select__wrapper{gap:6px;padding:8px 16px;min-height:40px;line-height:24px;font-size:14px}.el-select--large .el-select__selection{gap:6px}.el-select--large .el-select__selection.is-near{margin-left:-8px}.el-select--large .el-select__prefix,.el-select--large .el-select__suffix{gap:6px}.el-select--large .el-select__input{height:24px}.el-select--small .el-select__wrapper{gap:4px;padding:2px 8px;min-height:24px;line-height:20px;font-size:12px}.el-select--small .el-select__selection{gap:4px}.el-select--small .el-select__selection.is-near{margin-left:-6px}.el-select--small .el-select__prefix,.el-select--small .el-select__suffix{gap:4px}.el-select--small .el-select__input{height:20px}.el-date-table{font-size:12px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-date-table.is-week-mode .el-date-table__row:hover .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-date-table.is-week-mode .el-date-table__row:hover td.available:hover{color:var(--el-datepicker-text-color)}.el-date-table.is-week-mode .el-date-table__row:hover td:first-child .el-date-table-cell{margin-left:5px;border-top-left-radius:15px;border-bottom-left-radius:15px}.el-date-table.is-week-mode .el-date-table__row:hover td:last-child .el-date-table-cell{margin-right:5px;border-top-right-radius:15px;border-bottom-right-radius:15px}.el-date-table.is-week-mode .el-date-table__row.current .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-date-table td{width:32px;height:30px;padding:4px 0;box-sizing:border-box;text-align:center;cursor:pointer;position:relative}.el-date-table td .el-date-table-cell{height:30px;padding:3px 0;box-sizing:border-box}.el-date-table td .el-date-table-cell .el-date-table-cell__text{width:24px;height:24px;display:block;margin:0 auto;line-height:24px;position:absolute;left:50%;transform:translate(-50%);border-radius:50%}.el-date-table td.next-month,.el-date-table td.prev-month{color:var(--el-datepicker-off-text-color)}.el-date-table td.today{position:relative}.el-date-table td.today .el-date-table-cell__text{color:var(--el-color-primary);font-weight:700}.el-date-table td.today.end-date .el-date-table-cell__text,.el-date-table td.today.start-date .el-date-table-cell__text{color:#fff}.el-date-table td.available:hover{color:var(--el-datepicker-hover-text-color)}.el-date-table td.in-range .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-date-table td.in-range .el-date-table-cell:hover{background-color:var(--el-datepicker-inrange-hover-bg-color)}.el-date-table td.current:not(.disabled) .el-date-table-cell__text{color:#fff;background-color:var(--el-datepicker-active-color)}.el-date-table td.current:not(.disabled):focus-visible .el-date-table-cell__text{outline:2px solid var(--el-datepicker-active-color);outline-offset:1px}.el-date-table td.end-date .el-date-table-cell,.el-date-table td.start-date .el-date-table-cell{color:#fff}.el-date-table td.end-date .el-date-table-cell__text,.el-date-table td.start-date .el-date-table-cell__text{background-color:var(--el-datepicker-active-color)}.el-date-table td.start-date .el-date-table-cell{margin-left:5px;border-top-left-radius:15px;border-bottom-left-radius:15px}.el-date-table td.end-date .el-date-table-cell{margin-right:5px;border-top-right-radius:15px;border-bottom-right-radius:15px}.el-date-table td.disabled .el-date-table-cell{background-color:var(--el-fill-color-light);opacity:1;cursor:not-allowed;color:var(--el-text-color-placeholder)}.el-date-table td.selected .el-date-table-cell{margin-left:5px;margin-right:5px;background-color:var(--el-datepicker-inrange-bg-color);border-radius:15px}.el-date-table td.selected .el-date-table-cell:hover{background-color:var(--el-datepicker-inrange-hover-bg-color)}.el-date-table td.selected .el-date-table-cell__text{background-color:var(--el-datepicker-active-color);color:#fff;border-radius:15px}.el-date-table td.week{font-size:80%;color:var(--el-datepicker-header-text-color)}.el-date-table td:focus{outline:0}.el-date-table th{padding:5px;color:var(--el-datepicker-header-text-color);font-weight:400;border-bottom:solid 1px var(--el-border-color-lighter)}.el-month-table{font-size:12px;margin:-1px;border-collapse:collapse}.el-month-table td{text-align:center;padding:8px 0;cursor:pointer}.el-month-table td div{height:48px;padding:6px 0;box-sizing:border-box}.el-month-table td.today .cell{color:var(--el-color-primary);font-weight:700}.el-month-table td.today.end-date .cell,.el-month-table td.today.start-date .cell{color:#fff}.el-month-table td.disabled .cell{background-color:var(--el-fill-color-light);cursor:not-allowed;color:var(--el-text-color-placeholder)}.el-month-table td.disabled .cell:hover{color:var(--el-text-color-placeholder)}.el-month-table td .cell{width:60px;height:36px;display:block;line-height:36px;color:var(--el-datepicker-text-color);margin:0 auto;border-radius:18px}.el-month-table td .cell:hover{color:var(--el-datepicker-hover-text-color)}.el-month-table td.in-range div{background-color:var(--el-datepicker-inrange-bg-color)}.el-month-table td.in-range div:hover{background-color:var(--el-datepicker-inrange-hover-bg-color)}.el-month-table td.end-date div,.el-month-table td.start-date div{color:#fff}.el-month-table td.end-date .cell,.el-month-table td.start-date .cell{color:#fff;background-color:var(--el-datepicker-active-color)}.el-month-table td.start-date div{border-top-left-radius:24px;border-bottom-left-radius:24px}.el-month-table td.end-date div{border-top-right-radius:24px;border-bottom-right-radius:24px}.el-month-table td.current:not(.disabled) .cell{color:var(--el-datepicker-active-color)}.el-month-table td:focus-visible{outline:0}.el-month-table td:focus-visible .cell{outline:2px solid var(--el-datepicker-active-color)}.el-year-table{font-size:12px;margin:-1px;border-collapse:collapse}.el-year-table .el-icon{color:var(--el-datepicker-icon-color)}.el-year-table td{text-align:center;padding:20px 3px;cursor:pointer}.el-year-table td.today .cell{color:var(--el-color-primary);font-weight:700}.el-year-table td.disabled .cell{background-color:var(--el-fill-color-light);cursor:not-allowed;color:var(--el-text-color-placeholder)}.el-year-table td.disabled .cell:hover{color:var(--el-text-color-placeholder)}.el-year-table td .cell{width:48px;height:36px;display:block;line-height:36px;color:var(--el-datepicker-text-color);border-radius:18px;margin:0 auto}.el-year-table td .cell:hover{color:var(--el-datepicker-hover-text-color)}.el-year-table td.current:not(.disabled) .cell{color:var(--el-datepicker-active-color)}.el-year-table td:focus-visible{outline:0}.el-year-table td:focus-visible .cell{outline:2px solid var(--el-datepicker-active-color)}.el-time-spinner.has-seconds .el-time-spinner__wrapper{width:33.3%}.el-time-spinner__wrapper{max-height:192px;overflow:auto;display:inline-block;width:50%;vertical-align:top;position:relative}.el-time-spinner__wrapper.el-scrollbar__wrap:not(.el-scrollbar__wrap--hidden-default){padding-bottom:15px}.el-time-spinner__wrapper.is-arrow{box-sizing:border-box;text-align:center;overflow:hidden}.el-time-spinner__wrapper.is-arrow .el-time-spinner__list{transform:translateY(-32px)}.el-time-spinner__wrapper.is-arrow .el-time-spinner__item:hover:not(.is-disabled):not(.is-active){background:var(--el-fill-color-light);cursor:default}.el-time-spinner__arrow{font-size:12px;color:var(--el-text-color-secondary);position:absolute;left:0;width:100%;z-index:var(--el-index-normal);text-align:center;height:30px;line-height:30px;cursor:pointer}.el-time-spinner__arrow:hover{color:var(--el-color-primary)}.el-time-spinner__arrow.arrow-up{top:10px}.el-time-spinner__arrow.arrow-down{bottom:10px}.el-time-spinner__input.el-input{width:70%}.el-time-spinner__input.el-input .el-input__inner{padding:0;text-align:center}.el-time-spinner__list{padding:0;margin:0;list-style:none;text-align:center}.el-time-spinner__list:after,.el-time-spinner__list:before{content:"";display:block;width:100%;height:80px}.el-time-spinner__item{height:32px;line-height:32px;font-size:12px;color:var(--el-text-color-regular)}.el-time-spinner__item:hover:not(.is-disabled):not(.is-active){background:var(--el-fill-color-light);cursor:pointer}.el-time-spinner__item.is-active:not(.is-disabled){color:var(--el-text-color-primary);font-weight:700}.el-time-spinner__item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center top}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center bottom}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1);transition:var(--el-transition-md-fade);transform-origin:top left}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-picker__popper{--el-datepicker-border-color:var(--el-disabled-border-color)}.el-picker__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-datepicker-border-color);box-shadow:var(--el-box-shadow-light)}.el-picker__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-datepicker-border-color)}.el-picker__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent;border-left-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent;border-bottom-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-date-editor{--el-date-editor-width:220px;--el-date-editor-monthrange-width:300px;--el-date-editor-daterange-width:350px;--el-date-editor-datetimerange-width:400px;--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;position:relative;text-align:left;vertical-align:middle}.el-date-editor.el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset}.el-date-editor.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-date-editor.el-input,.el-date-editor.el-input__wrapper{width:var(--el-date-editor-width);height:var(--el-input-height,var(--el-component-size))}.el-date-editor--monthrange{--el-date-editor-width:var(--el-date-editor-monthrange-width)}.el-date-editor--daterange,.el-date-editor--timerange{--el-date-editor-width:var(--el-date-editor-daterange-width)}.el-date-editor--datetimerange{--el-date-editor-width:var(--el-date-editor-datetimerange-width)}.el-date-editor--dates .el-input__wrapper{text-overflow:ellipsis;white-space:nowrap}.el-date-editor .close-icon,.el-date-editor .clear-icon{cursor:pointer}.el-date-editor .clear-icon:hover{color:var(--el-text-color-secondary)}.el-date-editor .el-range__icon{height:inherit;font-size:14px;color:var(--el-text-color-placeholder);float:left}.el-date-editor .el-range__icon svg{vertical-align:middle}.el-date-editor .el-range-input{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;outline:0;display:inline-block;height:30px;line-height:30px;margin:0;padding:0;width:39%;text-align:center;font-size:var(--el-font-size-base);color:var(--el-text-color-regular);background-color:transparent}.el-date-editor .el-range-input::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-input:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-input::placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-separator{flex:1;display:inline-flex;justify-content:center;align-items:center;height:100%;padding:0 5px;margin:0;font-size:14px;overflow-wrap:break-word;color:var(--el-text-color-primary)}.el-date-editor .el-range__close-icon{font-size:14px;color:var(--el-text-color-placeholder);height:inherit;width:unset;cursor:pointer}.el-date-editor .el-range__close-icon:hover{color:var(--el-text-color-secondary)}.el-date-editor .el-range__close-icon svg{vertical-align:middle}.el-date-editor .el-range__close-icon--hidden{opacity:0;visibility:hidden}.el-range-editor.el-input__wrapper{display:inline-flex;align-items:center;padding:0 10px}.el-range-editor.is-active,.el-range-editor.is-active:hover{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-range-editor--large{line-height:var(--el-component-size-large)}.el-range-editor--large.el-input__wrapper{height:var(--el-component-size-large)}.el-range-editor--large .el-range-separator{line-height:40px;font-size:14px}.el-range-editor--large .el-range-input{height:38px;line-height:38px;font-size:14px}.el-range-editor--small{line-height:var(--el-component-size-small)}.el-range-editor--small.el-input__wrapper{height:var(--el-component-size-small)}.el-range-editor--small .el-range-separator{line-height:24px;font-size:12px}.el-range-editor--small .el-range-input{height:22px;line-height:22px;font-size:12px}.el-range-editor.is-disabled{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-range-editor.is-disabled:focus,.el-range-editor.is-disabled:hover{border-color:var(--el-disabled-border-color)}.el-range-editor.is-disabled input{background-color:var(--el-disabled-bg-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-range-editor.is-disabled input::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled input:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled input::placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled .el-range-separator{color:var(--el-disabled-text-color)}.el-picker-panel{color:var(--el-text-color-regular);background:var(--el-bg-color-overlay);border-radius:var(--el-border-radius-base);line-height:30px}.el-picker-panel .el-time-panel{margin:5px 0;border:solid 1px var(--el-datepicker-border-color);background-color:var(--el-bg-color-overlay);box-shadow:var(--el-box-shadow-light)}.el-picker-panel__body-wrapper:after,.el-picker-panel__body:after{content:"";display:table;clear:both}.el-picker-panel__content{position:relative;margin:15px}.el-picker-panel__footer{border-top:1px solid var(--el-datepicker-inner-border-color);padding:4px 12px;text-align:right;background-color:var(--el-bg-color-overlay);position:relative;font-size:0}.el-picker-panel__shortcut{display:block;width:100%;border:0;background-color:transparent;line-height:28px;font-size:14px;color:var(--el-datepicker-text-color);padding-left:12px;text-align:left;outline:0;cursor:pointer}.el-picker-panel__shortcut:hover{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__shortcut.active{background-color:#e6f1fe;color:var(--el-datepicker-active-color)}.el-picker-panel__btn{border:1px solid var(--el-fill-color-darker);color:var(--el-text-color-primary);line-height:24px;border-radius:2px;padding:0 20px;cursor:pointer;background-color:transparent;outline:0;font-size:12px}.el-picker-panel__btn[disabled]{color:var(--el-text-color-disabled);cursor:not-allowed}.el-picker-panel__icon-btn{font-size:12px;color:var(--el-datepicker-icon-color);border:0;background:0 0;cursor:pointer;outline:0;margin-top:8px}.el-picker-panel__icon-btn:hover{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__icon-btn:focus-visible{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__icon-btn.is-disabled{color:var(--el-text-color-disabled)}.el-picker-panel__icon-btn.is-disabled:hover{cursor:not-allowed}.el-picker-panel__icon-btn .el-icon{cursor:pointer;font-size:inherit}.el-picker-panel__link-btn{vertical-align:middle}.el-picker-panel [slot=sidebar],.el-picker-panel__sidebar{position:absolute;top:0;bottom:0;width:110px;border-right:1px solid var(--el-datepicker-inner-border-color);box-sizing:border-box;padding-top:6px;background-color:var(--el-bg-color-overlay);overflow:auto}.el-picker-panel [slot=sidebar]+.el-picker-panel__body,.el-picker-panel__sidebar+.el-picker-panel__body{margin-left:110px}.el-date-picker{--el-datepicker-text-color:var(--el-text-color-regular);--el-datepicker-off-text-color:var(--el-text-color-placeholder);--el-datepicker-header-text-color:var(--el-text-color-regular);--el-datepicker-icon-color:var(--el-text-color-primary);--el-datepicker-border-color:var(--el-disabled-border-color);--el-datepicker-inner-border-color:var(--el-border-color-light);--el-datepicker-inrange-bg-color:var(--el-border-color-extra-light);--el-datepicker-inrange-hover-bg-color:var(--el-border-color-extra-light);--el-datepicker-active-color:var(--el-color-primary);--el-datepicker-hover-text-color:var(--el-color-primary)}.el-date-picker{width:322px}.el-date-picker.has-sidebar.has-time{width:434px}.el-date-picker.has-sidebar{width:438px}.el-date-picker.has-time .el-picker-panel__body-wrapper{position:relative}.el-date-picker .el-picker-panel__content{width:292px}.el-date-picker table{table-layout:fixed;width:100%}.el-date-picker__editor-wrap{position:relative;display:table-cell;padding:0 5px}.el-date-picker__time-header{position:relative;border-bottom:1px solid var(--el-datepicker-inner-border-color);font-size:12px;padding:8px 5px 5px;display:table;width:100%;box-sizing:border-box}.el-date-picker__header{margin:12px;text-align:center}.el-date-picker__header--bordered{margin-bottom:0;padding-bottom:12px;border-bottom:solid 1px var(--el-border-color-lighter)}.el-date-picker__header--bordered+.el-picker-panel__content{margin-top:0}.el-date-picker__header-label{font-size:16px;font-weight:500;padding:0 5px;line-height:22px;text-align:center;cursor:pointer;color:var(--el-text-color-regular)}.el-date-picker__header-label:hover{color:var(--el-datepicker-hover-text-color)}.el-date-picker__header-label:focus-visible{outline:0;color:var(--el-datepicker-hover-text-color)}.el-date-picker__header-label.active{color:var(--el-datepicker-active-color)}.el-date-picker__prev-btn{float:left}.el-date-picker__next-btn{float:right}.el-date-picker__time-wrap{padding:10px;text-align:center}.el-date-picker__time-label{float:left;cursor:pointer;line-height:30px;margin-left:10px}.el-date-picker .el-time-panel{position:absolute}.el-date-range-picker{--el-datepicker-text-color:var(--el-text-color-regular);--el-datepicker-off-text-color:var(--el-text-color-placeholder);--el-datepicker-header-text-color:var(--el-text-color-regular);--el-datepicker-icon-color:var(--el-text-color-primary);--el-datepicker-border-color:var(--el-disabled-border-color);--el-datepicker-inner-border-color:var(--el-border-color-light);--el-datepicker-inrange-bg-color:var(--el-border-color-extra-light);--el-datepicker-inrange-hover-bg-color:var(--el-border-color-extra-light);--el-datepicker-active-color:var(--el-color-primary);--el-datepicker-hover-text-color:var(--el-color-primary)}.el-date-range-picker{width:646px}.el-date-range-picker.has-sidebar{width:756px}.el-date-range-picker.has-time .el-picker-panel__body-wrapper{position:relative}.el-date-range-picker table{table-layout:fixed;width:100%}.el-date-range-picker .el-picker-panel__body{min-width:513px}.el-date-range-picker .el-picker-panel__content{margin:0}.el-date-range-picker__header{position:relative;text-align:center;height:28px}.el-date-range-picker__header [class*=arrow-left]{float:left}.el-date-range-picker__header [class*=arrow-right]{float:right}.el-date-range-picker__header div{font-size:16px;font-weight:500;margin-right:50px}.el-date-range-picker__content{float:left;width:50%;box-sizing:border-box;margin:0;padding:16px}.el-date-range-picker__content.is-left{border-right:1px solid var(--el-datepicker-inner-border-color)}.el-date-range-picker__content .el-date-range-picker__header div{margin-left:50px;margin-right:50px}.el-date-range-picker__editors-wrap{box-sizing:border-box;display:table-cell}.el-date-range-picker__editors-wrap.is-right{text-align:right}.el-date-range-picker__time-header{position:relative;border-bottom:1px solid var(--el-datepicker-inner-border-color);font-size:12px;padding:8px 5px 5px;display:table;width:100%;box-sizing:border-box}.el-date-range-picker__time-header>.el-icon-arrow-right{font-size:20px;vertical-align:middle;display:table-cell;color:var(--el-datepicker-icon-color)}.el-date-range-picker__time-picker-wrap{position:relative;display:table-cell;padding:0 5px}.el-date-range-picker__time-picker-wrap .el-picker-panel{position:absolute;top:13px;right:0;z-index:1;background:#fff}.el-date-range-picker__time-picker-wrap .el-time-panel{position:absolute}.el-time-range-picker{width:354px;overflow:visible}.el-time-range-picker__content{position:relative;text-align:center;padding:10px;z-index:1}.el-time-range-picker__cell{box-sizing:border-box;margin:0;padding:4px 7px 7px;width:50%;display:inline-block}.el-time-range-picker__header{margin-bottom:5px;text-align:center;font-size:14px}.el-time-range-picker__body{border-radius:2px;border:1px solid var(--el-datepicker-border-color)}.el-time-panel{border-radius:2px;position:relative;width:180px;left:0;z-index:var(--el-index-top);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;box-sizing:content-box}.el-time-panel__content{font-size:0;position:relative;overflow:hidden}.el-time-panel__content:after,.el-time-panel__content:before{content:"";top:50%;position:absolute;margin-top:-16px;height:32px;z-index:-1;left:0;right:0;box-sizing:border-box;padding-top:6px;text-align:left}.el-time-panel__content:after{left:50%;margin-left:12%;margin-right:12%}.el-time-panel__content:before{padding-left:50%;margin-right:12%;margin-left:12%;border-top:1px solid var(--el-border-color-light);border-bottom:1px solid var(--el-border-color-light)}.el-time-panel__content.has-seconds:after{left:66.6666666667%}.el-time-panel__content.has-seconds:before{padding-left:33.3333333333%}.el-time-panel__footer{border-top:1px solid var(--el-timepicker-inner-border-color,var(--el-border-color-light));padding:4px;height:36px;line-height:25px;text-align:right;box-sizing:border-box}.el-time-panel__btn{border:none;line-height:28px;padding:0 5px;margin:0 5px;cursor:pointer;background-color:transparent;outline:0;font-size:12px;color:var(--el-text-color-primary)}.el-time-panel__btn.confirm{font-weight:800;color:var(--el-timepicker-active-color,var(--el-color-primary))}.control-dialog .el-select,.control-dialog .el-select div{overflow:unset}.control-dialog .el-dialog__body{padding:0 12px}.control-dialog footer{background:unset}.control-article{text-align:left}.control-article img{max-width:100%!important;margin:12px auto 0;display:block}.control-article *{margin-top:12px}.control-box{position:fixed;bottom:60px;left:100px} `);

(function () {
  'use strict';

  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var require_main_001 = __commonJS({
    "main-c262c14d.js"(exports, module) {
      /**
      * @vue/shared v3.4.13
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      function makeMap(str, expectsLowerCase) {
        const set2 = new Set(str.split(","));
        return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
      }
      const EMPTY_OBJ = {};
      const EMPTY_ARR = [];
      const NOOP = () => {
      };
      const NO = () => false;
      const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
      (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
      const isModelListener = (key) => key.startsWith("onUpdate:");
      const extend = Object.assign;
      const remove = (arr, el) => {
        const i = arr.indexOf(el);
        if (i > -1) {
          arr.splice(i, 1);
        }
      };
      const hasOwnProperty$a = Object.prototype.hasOwnProperty;
      const hasOwn = (val, key) => hasOwnProperty$a.call(val, key);
      const isArray$2 = Array.isArray;
      const isMap = (val) => toTypeString(val) === "[object Map]";
      const isSet = (val) => toTypeString(val) === "[object Set]";
      const isDate = (val) => toTypeString(val) === "[object Date]";
      const isFunction$1 = (val) => typeof val === "function";
      const isString$1 = (val) => typeof val === "string";
      const isSymbol$1 = (val) => typeof val === "symbol";
      const isObject$1 = (val) => val !== null && typeof val === "object";
      const isPromise = (val) => {
        return (isObject$1(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
      };
      const objectToString$1 = Object.prototype.toString;
      const toTypeString = (value) => objectToString$1.call(value);
      const toRawType = (value) => {
        return toTypeString(value).slice(8, -1);
      };
      const isPlainObject = (val) => toTypeString(val) === "[object Object]";
      const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
      const isReservedProp = /* @__PURE__ */ makeMap(
        // the leading comma is intentional so empty string "" is also included
        ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
      );
      const cacheStringFunction = (fn2) => {
        const cache = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache[str];
          return hit || (cache[str] = fn2(str));
        };
      };
      const camelizeRE = /-(\w)/g;
      const camelize = cacheStringFunction((str) => {
        return str.replace(camelizeRE, (_2, c) => c ? c.toUpperCase() : "");
      });
      const hyphenateRE = /\B([A-Z])/g;
      const hyphenate = cacheStringFunction(
        (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
      );
      const capitalize = cacheStringFunction((str) => {
        return str.charAt(0).toUpperCase() + str.slice(1);
      });
      const toHandlerKey = cacheStringFunction((str) => {
        const s2 = str ? `on${capitalize(str)}` : ``;
        return s2;
      });
      const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
      const invokeArrayFns = (fns, arg) => {
        for (let i = 0; i < fns.length; i++) {
          fns[i](arg);
        }
      };
      const def = (obj, key, value) => {
        Object.defineProperty(obj, key, {
          configurable: true,
          enumerable: false,
          value
        });
      };
      const looseToNumber = (val) => {
        const n2 = parseFloat(val);
        return isNaN(n2) ? val : n2;
      };
      const toNumber$1 = (val) => {
        const n2 = isString$1(val) ? Number(val) : NaN;
        return isNaN(n2) ? val : n2;
      };
      let _globalThis;
      const getGlobalThis = () => {
        return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
      };
      function normalizeStyle(value) {
        if (isArray$2(value)) {
          const res = {};
          for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
            if (normalized) {
              for (const key in normalized) {
                res[key] = normalized[key];
              }
            }
          }
          return res;
        } else if (isString$1(value) || isObject$1(value)) {
          return value;
        }
      }
      const listDelimiterRE = /;(?![^(]*\))/g;
      const propertyDelimiterRE = /:([^]+)/;
      const styleCommentRE = /\/\*[^]*?\*\//g;
      function parseStringStyle(cssText) {
        const ret = {};
        cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
          if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
          }
        });
        return ret;
      }
      function normalizeClass(value) {
        let res = "";
        if (isString$1(value)) {
          res = value;
        } else if (isArray$2(value)) {
          for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
              res += normalized + " ";
            }
          }
        } else if (isObject$1(value)) {
          for (const name in value) {
            if (value[name]) {
              res += name + " ";
            }
          }
        }
        return res.trim();
      }
      const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
      const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
      function includeBooleanAttr(value) {
        return !!value || value === "";
      }
      const toDisplayString = (val) => {
        return isString$1(val) ? val : val == null ? "" : isArray$2(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
      };
      const replacer = (_key, val) => {
        if (val && val.__v_isRef) {
          return replacer(_key, val.value);
        } else if (isMap(val)) {
          return {
            [`Map(${val.size})`]: [...val.entries()].reduce(
              (entries, [key, val2], i) => {
                entries[stringifySymbol(key, i) + " =>"] = val2;
                return entries;
              },
              {}
            )
          };
        } else if (isSet(val)) {
          return {
            [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
          };
        } else if (isSymbol$1(val)) {
          return stringifySymbol(val);
        } else if (isObject$1(val) && !isArray$2(val) && !isPlainObject(val)) {
          return String(val);
        }
        return val;
      };
      const stringifySymbol = (v, i = "") => {
        var _a2;
        return isSymbol$1(v) ? `Symbol(${(_a2 = v.description) != null ? _a2 : i})` : v;
      };
      /**
      * @vue/reactivity v3.4.13
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      let activeEffectScope;
      class EffectScope {
        constructor(detached = false) {
          this.detached = detached;
          this._active = true;
          this.effects = [];
          this.cleanups = [];
          this.parent = activeEffectScope;
          if (!detached && activeEffectScope) {
            this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
              this
            ) - 1;
          }
        }
        get active() {
          return this._active;
        }
        run(fn2) {
          if (this._active) {
            const currentEffectScope = activeEffectScope;
            try {
              activeEffectScope = this;
              return fn2();
            } finally {
              activeEffectScope = currentEffectScope;
            }
          }
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        on() {
          activeEffectScope = this;
        }
        /**
         * This should only be called on non-detached scopes
         * @internal
         */
        off() {
          activeEffectScope = this.parent;
        }
        stop(fromParent) {
          if (this._active) {
            let i, l2;
            for (i = 0, l2 = this.effects.length; i < l2; i++) {
              this.effects[i].stop();
            }
            for (i = 0, l2 = this.cleanups.length; i < l2; i++) {
              this.cleanups[i]();
            }
            if (this.scopes) {
              for (i = 0, l2 = this.scopes.length; i < l2; i++) {
                this.scopes[i].stop(true);
              }
            }
            if (!this.detached && this.parent && !fromParent) {
              const last = this.parent.scopes.pop();
              if (last && last !== this) {
                this.parent.scopes[this.index] = last;
                last.index = this.index;
              }
            }
            this.parent = void 0;
            this._active = false;
          }
        }
      }
      function recordEffectScope(effect, scope = activeEffectScope) {
        if (scope && scope.active) {
          scope.effects.push(effect);
        }
      }
      function getCurrentScope() {
        return activeEffectScope;
      }
      function onScopeDispose(fn2) {
        if (activeEffectScope) {
          activeEffectScope.cleanups.push(fn2);
        }
      }
      let activeEffect;
      class ReactiveEffect {
        constructor(fn2, trigger2, scheduler, scope) {
          this.fn = fn2;
          this.trigger = trigger2;
          this.scheduler = scheduler;
          this.active = true;
          this.deps = [];
          this._dirtyLevel = 2;
          this._trackId = 0;
          this._runnings = 0;
          this._shouldSchedule = false;
          this._depsLength = 0;
          recordEffectScope(this, scope);
        }
        get dirty() {
          if (this._dirtyLevel === 1) {
            pauseTracking();
            for (let i = 0; i < this._depsLength; i++) {
              const dep = this.deps[i];
              if (dep.computed) {
                triggerComputed(dep.computed);
                if (this._dirtyLevel >= 2) {
                  break;
                }
              }
            }
            if (this._dirtyLevel < 2) {
              this._dirtyLevel = 0;
            }
            resetTracking();
          }
          return this._dirtyLevel >= 2;
        }
        set dirty(v) {
          this._dirtyLevel = v ? 2 : 0;
        }
        run() {
          this._dirtyLevel = 0;
          if (!this.active) {
            return this.fn();
          }
          let lastShouldTrack = shouldTrack;
          let lastEffect = activeEffect;
          try {
            shouldTrack = true;
            activeEffect = this;
            this._runnings++;
            preCleanupEffect(this);
            return this.fn();
          } finally {
            postCleanupEffect(this);
            this._runnings--;
            activeEffect = lastEffect;
            shouldTrack = lastShouldTrack;
          }
        }
        stop() {
          var _a2;
          if (this.active) {
            preCleanupEffect(this);
            postCleanupEffect(this);
            (_a2 = this.onStop) == null ? void 0 : _a2.call(this);
            this.active = false;
          }
        }
      }
      function triggerComputed(computed2) {
        return computed2.value;
      }
      function preCleanupEffect(effect2) {
        effect2._trackId++;
        effect2._depsLength = 0;
      }
      function postCleanupEffect(effect2) {
        if (effect2.deps && effect2.deps.length > effect2._depsLength) {
          for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
            cleanupDepEffect(effect2.deps[i], effect2);
          }
          effect2.deps.length = effect2._depsLength;
        }
      }
      function cleanupDepEffect(dep, effect2) {
        const trackId = dep.get(effect2);
        if (trackId !== void 0 && effect2._trackId !== trackId) {
          dep.delete(effect2);
          if (dep.size === 0) {
            dep.cleanup();
          }
        }
      }
      let shouldTrack = true;
      let pauseScheduleStack = 0;
      const trackStack = [];
      function pauseTracking() {
        trackStack.push(shouldTrack);
        shouldTrack = false;
      }
      function resetTracking() {
        const last = trackStack.pop();
        shouldTrack = last === void 0 ? true : last;
      }
      function pauseScheduling() {
        pauseScheduleStack++;
      }
      function resetScheduling() {
        pauseScheduleStack--;
        while (!pauseScheduleStack && queueEffectSchedulers.length) {
          queueEffectSchedulers.shift()();
        }
      }
      function trackEffect(effect2, dep, debuggerEventExtraInfo) {
        if (dep.get(effect2) !== effect2._trackId) {
          dep.set(effect2, effect2._trackId);
          const oldDep = effect2.deps[effect2._depsLength];
          if (oldDep !== dep) {
            if (oldDep) {
              cleanupDepEffect(oldDep, effect2);
            }
            effect2.deps[effect2._depsLength++] = dep;
          } else {
            effect2._depsLength++;
          }
        }
      }
      const queueEffectSchedulers = [];
      function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
        pauseScheduling();
        for (const effect2 of dep.keys()) {
          if (dep.get(effect2) !== effect2._trackId) {
            continue;
          }
          if (effect2._dirtyLevel < dirtyLevel) {
            const lastDirtyLevel = effect2._dirtyLevel;
            effect2._dirtyLevel = dirtyLevel;
            if (lastDirtyLevel === 0) {
              effect2._shouldSchedule = true;
              effect2.trigger();
            }
          }
          if (effect2.scheduler && effect2._shouldSchedule && (!effect2._runnings || effect2.allowRecurse)) {
            effect2._shouldSchedule = false;
            queueEffectSchedulers.push(effect2.scheduler);
          }
        }
        resetScheduling();
      }
      const createDep = (cleanup, computed2) => {
        const dep = /* @__PURE__ */ new Map();
        dep.cleanup = cleanup;
        dep.computed = computed2;
        return dep;
      };
      const targetMap = /* @__PURE__ */ new WeakMap();
      const ITERATE_KEY = Symbol("");
      const MAP_KEY_ITERATE_KEY = Symbol("");
      function track(target, type, key) {
        if (shouldTrack && activeEffect) {
          let depsMap = targetMap.get(target);
          if (!depsMap) {
            targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
          }
          let dep = depsMap.get(key);
          if (!dep) {
            depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
          }
          trackEffect(
            activeEffect,
            dep
          );
        }
      }
      function trigger(target, type, key, newValue, oldValue, oldTarget) {
        const depsMap = targetMap.get(target);
        if (!depsMap) {
          return;
        }
        let deps = [];
        if (type === "clear") {
          deps = [...depsMap.values()];
        } else if (key === "length" && isArray$2(target)) {
          const newLength = Number(newValue);
          depsMap.forEach((dep, key2) => {
            if (key2 === "length" || !isSymbol$1(key2) && key2 >= newLength) {
              deps.push(dep);
            }
          });
        } else {
          if (key !== void 0) {
            deps.push(depsMap.get(key));
          }
          switch (type) {
            case "add":
              if (!isArray$2(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
                if (isMap(target)) {
                  deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              } else if (isIntegerKey(key)) {
                deps.push(depsMap.get("length"));
              }
              break;
            case "delete":
              if (!isArray$2(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
                if (isMap(target)) {
                  deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                }
              }
              break;
            case "set":
              if (isMap(target)) {
                deps.push(depsMap.get(ITERATE_KEY));
              }
              break;
          }
        }
        pauseScheduling();
        for (const dep of deps) {
          if (dep) {
            triggerEffects(
              dep,
              2
            );
          }
        }
        resetScheduling();
      }
      function getDepFromReactive(object, key) {
        var _a2;
        return (_a2 = targetMap.get(object)) == null ? void 0 : _a2.get(key);
      }
      const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
      const builtInSymbols = new Set(
        /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
      );
      const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
      function createArrayInstrumentations() {
        const instrumentations = {};
        ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
          instrumentations[key] = function(...args) {
            const arr = toRaw(this);
            for (let i = 0, l2 = this.length; i < l2; i++) {
              track(arr, "get", i + "");
            }
            const res = arr[key](...args);
            if (res === -1 || res === false) {
              return arr[key](...args.map(toRaw));
            } else {
              return res;
            }
          };
        });
        ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
          instrumentations[key] = function(...args) {
            pauseTracking();
            pauseScheduling();
            const res = toRaw(this)[key].apply(this, args);
            resetScheduling();
            resetTracking();
            return res;
          };
        });
        return instrumentations;
      }
      function hasOwnProperty$9(key) {
        const obj = toRaw(this);
        track(obj, "has", key);
        return obj.hasOwnProperty(key);
      }
      class BaseReactiveHandler {
        constructor(_isReadonly = false, _shallow = false) {
          this._isReadonly = _isReadonly;
          this._shallow = _shallow;
        }
        get(target, key, receiver) {
          const isReadonly2 = this._isReadonly, shallow = this._shallow;
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_isShallow") {
            return shallow;
          } else if (key === "__v_raw") {
            if (receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
            // this means the reciever is a user proxy of the reactive proxy
            Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
              return target;
            }
            return;
          }
          const targetIsArray = isArray$2(target);
          if (!isReadonly2) {
            if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
              return Reflect.get(arrayInstrumentations, key, receiver);
            }
            if (key === "hasOwnProperty") {
              return hasOwnProperty$9;
            }
          }
          const res = Reflect.get(target, key, receiver);
          if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
            return res;
          }
          if (!isReadonly2) {
            track(target, "get", key);
          }
          if (shallow) {
            return res;
          }
          if (isRef(res)) {
            return targetIsArray && isIntegerKey(key) ? res : res.value;
          }
          if (isObject$1(res)) {
            return isReadonly2 ? readonly(res) : reactive(res);
          }
          return res;
        }
      }
      class MutableReactiveHandler extends BaseReactiveHandler {
        constructor(shallow = false) {
          super(false, shallow);
        }
        set(target, key, value, receiver) {
          let oldValue = target[key];
          if (!this._shallow) {
            const isOldValueReadonly = isReadonly(oldValue);
            if (!isShallow(value) && !isReadonly(value)) {
              oldValue = toRaw(oldValue);
              value = toRaw(value);
            }
            if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
              if (isOldValueReadonly) {
                return false;
              } else {
                oldValue.value = value;
                return true;
              }
            }
          }
          const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
          const result = Reflect.set(target, key, value, receiver);
          if (target === toRaw(receiver)) {
            if (!hadKey) {
              trigger(target, "add", key, value);
            } else if (hasChanged(value, oldValue)) {
              trigger(target, "set", key, value);
            }
          }
          return result;
        }
        deleteProperty(target, key) {
          const hadKey = hasOwn(target, key);
          target[key];
          const result = Reflect.deleteProperty(target, key);
          if (result && hadKey) {
            trigger(target, "delete", key, void 0);
          }
          return result;
        }
        has(target, key) {
          const result = Reflect.has(target, key);
          if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
            track(target, "has", key);
          }
          return result;
        }
        ownKeys(target) {
          track(
            target,
            "iterate",
            isArray$2(target) ? "length" : ITERATE_KEY
          );
          return Reflect.ownKeys(target);
        }
      }
      class ReadonlyReactiveHandler extends BaseReactiveHandler {
        constructor(shallow = false) {
          super(true, shallow);
        }
        set(target, key) {
          return true;
        }
        deleteProperty(target, key) {
          return true;
        }
      }
      const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
      const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
      const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
        true
      );
      const toShallow = (value) => value;
      const getProto = (v) => Reflect.getPrototypeOf(v);
      function get$1(target, key, isReadonly2 = false, isShallow2 = false) {
        target = target["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!isReadonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "get", key);
          }
          track(rawTarget, "get", rawKey);
        }
        const { has: has2 } = getProto(rawTarget);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        if (has2.call(rawTarget, key)) {
          return wrap(target.get(key));
        } else if (has2.call(rawTarget, rawKey)) {
          return wrap(target.get(rawKey));
        } else if (target !== rawTarget) {
          target.get(key);
        }
      }
      function has(key, isReadonly2 = false) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const rawKey = toRaw(key);
        if (!isReadonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "has", key);
          }
          track(rawTarget, "has", rawKey);
        }
        return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
      }
      function size(target, isReadonly2 = false) {
        target = target["__v_raw"];
        !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
        return Reflect.get(target, "size", target);
      }
      function add(value) {
        value = toRaw(value);
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      }
      function set(key, value) {
        value = toRaw(value);
        const target = toRaw(this);
        const { has: has2, get: get2 } = getProto(target);
        let hadKey = has2.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target, key);
        }
        const oldValue = get2.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
        return this;
      }
      function deleteEntry(key) {
        const target = toRaw(this);
        const { has: has2, get: get2 } = getProto(target);
        let hadKey = has2.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has2.call(target, key);
        }
        get2 ? get2.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      }
      function clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(target, "clear", void 0, void 0);
        }
        return result;
      }
      function createForEach(isReadonly2, isShallow2) {
        return function forEach(callback, thisArg) {
          const observed = this;
          const target = observed["__v_raw"];
          const rawTarget = toRaw(target);
          const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
          !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
          return target.forEach((value, key) => {
            return callback.call(thisArg, wrap(value), wrap(key), observed);
          });
        };
      }
      function createIterableMethod(method, isReadonly2, isShallow2) {
        return function(...args) {
          const target = this["__v_raw"];
          const rawTarget = toRaw(target);
          const targetIsMap = isMap(rawTarget);
          const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
          const isKeyOnly = method === "keys" && targetIsMap;
          const innerIterator = target[method](...args);
          const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
          !isReadonly2 && track(
            rawTarget,
            "iterate",
            isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
          );
          return {
            // iterator protocol
            next() {
              const { value, done } = innerIterator.next();
              return done ? { value, done } : {
                value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                done
              };
            },
            // iterable protocol
            [Symbol.iterator]() {
              return this;
            }
          };
        };
      }
      function createReadonlyMethod(type) {
        return function(...args) {
          return type === "delete" ? false : type === "clear" ? void 0 : this;
        };
      }
      function createInstrumentations() {
        const mutableInstrumentations2 = {
          get(key) {
            return get$1(this, key);
          },
          get size() {
            return size(this);
          },
          has,
          add,
          set,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, false)
        };
        const shallowInstrumentations2 = {
          get(key) {
            return get$1(this, key, false, true);
          },
          get size() {
            return size(this);
          },
          has,
          add,
          set,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, true)
        };
        const readonlyInstrumentations2 = {
          get(key) {
            return get$1(this, key, true);
          },
          get size() {
            return size(this, true);
          },
          has(key) {
            return has.call(this, key, true);
          },
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear"),
          forEach: createForEach(true, false)
        };
        const shallowReadonlyInstrumentations2 = {
          get(key) {
            return get$1(this, key, true, true);
          },
          get size() {
            return size(this, true);
          },
          has(key) {
            return has.call(this, key, true);
          },
          add: createReadonlyMethod("add"),
          set: createReadonlyMethod("set"),
          delete: createReadonlyMethod("delete"),
          clear: createReadonlyMethod("clear"),
          forEach: createForEach(true, true)
        };
        const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
        iteratorMethods.forEach((method) => {
          mutableInstrumentations2[method] = createIterableMethod(
            method,
            false,
            false
          );
          readonlyInstrumentations2[method] = createIterableMethod(
            method,
            true,
            false
          );
          shallowInstrumentations2[method] = createIterableMethod(
            method,
            false,
            true
          );
          shallowReadonlyInstrumentations2[method] = createIterableMethod(
            method,
            true,
            true
          );
        });
        return [
          mutableInstrumentations2,
          readonlyInstrumentations2,
          shallowInstrumentations2,
          shallowReadonlyInstrumentations2
        ];
      }
      const [
        mutableInstrumentations,
        readonlyInstrumentations,
        shallowInstrumentations,
        shallowReadonlyInstrumentations
      ] = /* @__PURE__ */ createInstrumentations();
      function createInstrumentationGetter(isReadonly2, shallow) {
        const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
        return (target, key, receiver) => {
          if (key === "__v_isReactive") {
            return !isReadonly2;
          } else if (key === "__v_isReadonly") {
            return isReadonly2;
          } else if (key === "__v_raw") {
            return target;
          }
          return Reflect.get(
            hasOwn(instrumentations, key) && key in target ? instrumentations : target,
            key,
            receiver
          );
        };
      }
      const mutableCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, false)
      };
      const shallowCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, true)
      };
      const readonlyCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(true, false)
      };
      const reactiveMap = /* @__PURE__ */ new WeakMap();
      const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
      const readonlyMap = /* @__PURE__ */ new WeakMap();
      const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
      function targetTypeMap(rawType) {
        switch (rawType) {
          case "Object":
          case "Array":
            return 1;
          case "Map":
          case "Set":
          case "WeakMap":
          case "WeakSet":
            return 2;
          default:
            return 0;
        }
      }
      function getTargetType(value) {
        return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
      }
      function reactive(target) {
        if (isReadonly(target)) {
          return target;
        }
        return createReactiveObject(
          target,
          false,
          mutableHandlers,
          mutableCollectionHandlers,
          reactiveMap
        );
      }
      function shallowReactive(target) {
        return createReactiveObject(
          target,
          false,
          shallowReactiveHandlers,
          shallowCollectionHandlers,
          shallowReactiveMap
        );
      }
      function readonly(target) {
        return createReactiveObject(
          target,
          true,
          readonlyHandlers,
          readonlyCollectionHandlers,
          readonlyMap
        );
      }
      function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
        if (!isObject$1(target)) {
          return target;
        }
        if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
          return target;
        }
        const existingProxy = proxyMap.get(target);
        if (existingProxy) {
          return existingProxy;
        }
        const targetType = getTargetType(target);
        if (targetType === 0) {
          return target;
        }
        const proxy = new Proxy(
          target,
          targetType === 2 ? collectionHandlers : baseHandlers
        );
        proxyMap.set(target, proxy);
        return proxy;
      }
      function isReactive(value) {
        if (isReadonly(value)) {
          return isReactive(value["__v_raw"]);
        }
        return !!(value && value["__v_isReactive"]);
      }
      function isReadonly(value) {
        return !!(value && value["__v_isReadonly"]);
      }
      function isShallow(value) {
        return !!(value && value["__v_isShallow"]);
      }
      function isProxy(value) {
        return isReactive(value) || isReadonly(value);
      }
      function toRaw(observed) {
        const raw = observed && observed["__v_raw"];
        return raw ? toRaw(raw) : observed;
      }
      function markRaw(value) {
        def(value, "__v_skip", true);
        return value;
      }
      const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
      const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
      class ComputedRefImpl {
        constructor(getter, _setter, isReadonly2, isSSR) {
          this._setter = _setter;
          this.dep = void 0;
          this.__v_isRef = true;
          this["__v_isReadonly"] = false;
          this.effect = new ReactiveEffect(
            () => getter(this._value),
            () => triggerRefValue(this, 1)
          );
          this.effect.computed = this;
          this.effect.active = this._cacheable = !isSSR;
          this["__v_isReadonly"] = isReadonly2;
        }
        get value() {
          const self2 = toRaw(this);
          if (!self2._cacheable || self2.effect.dirty) {
            if (hasChanged(self2._value, self2._value = self2.effect.run())) {
              triggerRefValue(self2, 2);
            }
          }
          trackRefValue(self2);
          return self2._value;
        }
        set value(newValue) {
          this._setter(newValue);
        }
        // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
        get _dirty() {
          return this.effect.dirty;
        }
        set _dirty(v) {
          this.effect.dirty = v;
        }
        // #endregion
      }
      function computed$1(getterOrOptions, debugOptions, isSSR = false) {
        let getter;
        let setter;
        const onlyGetter = isFunction$1(getterOrOptions);
        if (onlyGetter) {
          getter = getterOrOptions;
          setter = NOOP;
        } else {
          getter = getterOrOptions.get;
          setter = getterOrOptions.set;
        }
        const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
        return cRef;
      }
      function trackRefValue(ref2) {
        if (shouldTrack && activeEffect) {
          ref2 = toRaw(ref2);
          trackEffect(
            activeEffect,
            ref2.dep || (ref2.dep = createDep(
              () => ref2.dep = void 0,
              ref2 instanceof ComputedRefImpl ? ref2 : void 0
            ))
          );
        }
      }
      function triggerRefValue(ref2, dirtyLevel = 2, newVal) {
        ref2 = toRaw(ref2);
        const dep = ref2.dep;
        if (dep) {
          triggerEffects(
            dep,
            dirtyLevel
          );
        }
      }
      function isRef(r2) {
        return !!(r2 && r2.__v_isRef === true);
      }
      function ref(value) {
        return createRef(value, false);
      }
      function shallowRef(value) {
        return createRef(value, true);
      }
      function createRef(rawValue, shallow) {
        if (isRef(rawValue)) {
          return rawValue;
        }
        return new RefImpl(rawValue, shallow);
      }
      class RefImpl {
        constructor(value, __v_isShallow) {
          this.__v_isShallow = __v_isShallow;
          this.dep = void 0;
          this.__v_isRef = true;
          this._rawValue = __v_isShallow ? value : toRaw(value);
          this._value = __v_isShallow ? value : toReactive(value);
        }
        get value() {
          trackRefValue(this);
          return this._value;
        }
        set value(newVal) {
          const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
          newVal = useDirectValue ? newVal : toRaw(newVal);
          if (hasChanged(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = useDirectValue ? newVal : toReactive(newVal);
            triggerRefValue(this, 2);
          }
        }
      }
      function unref(ref2) {
        return isRef(ref2) ? ref2.value : ref2;
      }
      const shallowUnwrapHandlers = {
        get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
        set: (target, key, value, receiver) => {
          const oldValue = target[key];
          if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
          } else {
            return Reflect.set(target, key, value, receiver);
          }
        }
      };
      function proxyRefs(objectWithRefs) {
        return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
      }
      function toRefs(object) {
        const ret = isArray$2(object) ? new Array(object.length) : {};
        for (const key in object) {
          ret[key] = propertyToRef(object, key);
        }
        return ret;
      }
      class ObjectRefImpl {
        constructor(_object, _key, _defaultValue) {
          this._object = _object;
          this._key = _key;
          this._defaultValue = _defaultValue;
          this.__v_isRef = true;
        }
        get value() {
          const val = this._object[this._key];
          return val === void 0 ? this._defaultValue : val;
        }
        set value(newVal) {
          this._object[this._key] = newVal;
        }
        get dep() {
          return getDepFromReactive(toRaw(this._object), this._key);
        }
      }
      class GetterRefImpl {
        constructor(_getter) {
          this._getter = _getter;
          this.__v_isRef = true;
          this.__v_isReadonly = true;
        }
        get value() {
          return this._getter();
        }
      }
      function toRef(source, key, defaultValue) {
        if (isRef(source)) {
          return source;
        } else if (isFunction$1(source)) {
          return new GetterRefImpl(source);
        } else if (isObject$1(source) && arguments.length > 1) {
          return propertyToRef(source, key, defaultValue);
        } else {
          return ref(source);
        }
      }
      function propertyToRef(source, key, defaultValue) {
        const val = source[key];
        return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
      }
      /**
      * @vue/runtime-core v3.4.13
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      const stack = [];
      function warn$1(msg, ...args) {
        pauseTracking();
        const instance = stack.length ? stack[stack.length - 1].component : null;
        const appWarnHandler = instance && instance.appContext.config.warnHandler;
        const trace = getComponentTrace();
        if (appWarnHandler) {
          callWithErrorHandling(
            appWarnHandler,
            instance,
            11,
            [
              msg + args.join(""),
              instance && instance.proxy,
              trace.map(
                ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
              ).join("\n"),
              trace
            ]
          );
        } else {
          const warnArgs = [`[Vue warn]: ${msg}`, ...args];
          if (trace.length && // avoid spamming console during tests
          true) {
            warnArgs.push(`
`, ...formatTrace(trace));
          }
          console.warn(...warnArgs);
        }
        resetTracking();
      }
      function getComponentTrace() {
        let currentVNode = stack[stack.length - 1];
        if (!currentVNode) {
          return [];
        }
        const normalizedStack = [];
        while (currentVNode) {
          const last = normalizedStack[0];
          if (last && last.vnode === currentVNode) {
            last.recurseCount++;
          } else {
            normalizedStack.push({
              vnode: currentVNode,
              recurseCount: 0
            });
          }
          const parentInstance = currentVNode.component && currentVNode.component.parent;
          currentVNode = parentInstance && parentInstance.vnode;
        }
        return normalizedStack;
      }
      function formatTrace(trace) {
        const logs = [];
        trace.forEach((entry, i) => {
          logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
        });
        return logs;
      }
      function formatTraceEntry({ vnode, recurseCount }) {
        const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
        const isRoot = vnode.component ? vnode.component.parent == null : false;
        const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
        const close = `>` + postfix;
        return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
      }
      function formatProps(props) {
        const res = [];
        const keys2 = Object.keys(props);
        keys2.slice(0, 3).forEach((key) => {
          res.push(...formatProp(key, props[key]));
        });
        if (keys2.length > 3) {
          res.push(` ...`);
        }
        return res;
      }
      function formatProp(key, value, raw) {
        if (isString$1(value)) {
          value = JSON.stringify(value);
          return raw ? value : [`${key}=${value}`];
        } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
          return raw ? value : [`${key}=${value}`];
        } else if (isRef(value)) {
          value = formatProp(key, toRaw(value.value), true);
          return raw ? value : [`${key}=Ref<`, value, `>`];
        } else if (isFunction$1(value)) {
          return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
        } else {
          value = toRaw(value);
          return raw ? value : [`${key}=`, value];
        }
      }
      function callWithErrorHandling(fn2, instance, type, args) {
        let res;
        try {
          res = args ? fn2(...args) : fn2();
        } catch (err) {
          handleError(err, instance, type);
        }
        return res;
      }
      function callWithAsyncErrorHandling(fn2, instance, type, args) {
        if (isFunction$1(fn2)) {
          const res = callWithErrorHandling(fn2, instance, type, args);
          if (res && isPromise(res)) {
            res.catch((err) => {
              handleError(err, instance, type);
            });
          }
          return res;
        }
        const values = [];
        for (let i = 0; i < fn2.length; i++) {
          values.push(callWithAsyncErrorHandling(fn2[i], instance, type, args));
        }
        return values;
      }
      function handleError(err, instance, type, throwInDev = true) {
        const contextVNode = instance ? instance.vnode : null;
        if (instance) {
          let cur = instance.parent;
          const exposedInstance = instance.proxy;
          const errorInfo = `https://vuejs.org/errors/#runtime-${type}`;
          while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
              for (let i = 0; i < errorCapturedHooks.length; i++) {
                if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                  return;
                }
              }
            }
            cur = cur.parent;
          }
          const appErrorHandler = instance.appContext.config.errorHandler;
          if (appErrorHandler) {
            callWithErrorHandling(
              appErrorHandler,
              null,
              10,
              [err, exposedInstance, errorInfo]
            );
            return;
          }
        }
        logError(err, type, contextVNode, throwInDev);
      }
      function logError(err, type, contextVNode, throwInDev = true) {
        {
          console.error(err);
        }
      }
      let isFlushing = false;
      let isFlushPending = false;
      const queue = [];
      let flushIndex = 0;
      const pendingPostFlushCbs = [];
      let activePostFlushCbs = null;
      let postFlushIndex = 0;
      const resolvedPromise = /* @__PURE__ */ Promise.resolve();
      let currentFlushPromise = null;
      function nextTick(fn2) {
        const p2 = currentFlushPromise || resolvedPromise;
        return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
      }
      function findInsertionIndex(id) {
        let start = flushIndex + 1;
        let end = queue.length;
        while (start < end) {
          const middle = start + end >>> 1;
          const middleJob = queue[middle];
          const middleJobId = getId(middleJob);
          if (middleJobId < id || middleJobId === id && middleJob.pre) {
            start = middle + 1;
          } else {
            end = middle;
          }
        }
        return start;
      }
      function queueJob(job) {
        if (!queue.length || !queue.includes(
          job,
          isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
        )) {
          if (job.id == null) {
            queue.push(job);
          } else {
            queue.splice(findInsertionIndex(job.id), 0, job);
          }
          queueFlush();
        }
      }
      function queueFlush() {
        if (!isFlushing && !isFlushPending) {
          isFlushPending = true;
          currentFlushPromise = resolvedPromise.then(flushJobs);
        }
      }
      function invalidateJob(job) {
        const i = queue.indexOf(job);
        if (i > flushIndex) {
          queue.splice(i, 1);
        }
      }
      function queuePostFlushCb(cb) {
        if (!isArray$2(cb)) {
          if (!activePostFlushCbs || !activePostFlushCbs.includes(
            cb,
            cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
          )) {
            pendingPostFlushCbs.push(cb);
          }
        } else {
          pendingPostFlushCbs.push(...cb);
        }
        queueFlush();
      }
      function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
        for (; i < queue.length; i++) {
          const cb = queue[i];
          if (cb && cb.pre) {
            if (instance && cb.id !== instance.uid) {
              continue;
            }
            queue.splice(i, 1);
            i--;
            cb();
          }
        }
      }
      function flushPostFlushCbs(seen) {
        if (pendingPostFlushCbs.length) {
          const deduped = [...new Set(pendingPostFlushCbs)].sort(
            (a, b) => getId(a) - getId(b)
          );
          pendingPostFlushCbs.length = 0;
          if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
          }
          activePostFlushCbs = deduped;
          for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            activePostFlushCbs[postFlushIndex]();
          }
          activePostFlushCbs = null;
          postFlushIndex = 0;
        }
      }
      const getId = (job) => job.id == null ? Infinity : job.id;
      const comparator = (a, b) => {
        const diff = getId(a) - getId(b);
        if (diff === 0) {
          if (a.pre && !b.pre)
            return -1;
          if (b.pre && !a.pre)
            return 1;
        }
        return diff;
      };
      function flushJobs(seen) {
        isFlushPending = false;
        isFlushing = true;
        queue.sort(comparator);
        try {
          for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job && job.active !== false) {
              if (false)
                ;
              callWithErrorHandling(job, null, 14);
            }
          }
        } finally {
          flushIndex = 0;
          queue.length = 0;
          flushPostFlushCbs();
          isFlushing = false;
          currentFlushPromise = null;
          if (queue.length || pendingPostFlushCbs.length) {
            flushJobs();
          }
        }
      }
      function emit(instance, event, ...rawArgs) {
        if (instance.isUnmounted)
          return;
        const props = instance.vnode.props || EMPTY_OBJ;
        let args = rawArgs;
        const isModelListener2 = event.startsWith("update:");
        const modelArg = isModelListener2 && event.slice(7);
        if (modelArg && modelArg in props) {
          const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
          const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
          if (trim) {
            args = rawArgs.map((a) => isString$1(a) ? a.trim() : a);
          }
          if (number) {
            args = rawArgs.map(looseToNumber);
          }
        }
        let handlerName;
        let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
        props[handlerName = toHandlerKey(camelize(event))];
        if (!handler && isModelListener2) {
          handler = props[handlerName = toHandlerKey(hyphenate(event))];
        }
        if (handler) {
          callWithAsyncErrorHandling(
            handler,
            instance,
            6,
            args
          );
        }
        const onceHandler = props[handlerName + `Once`];
        if (onceHandler) {
          if (!instance.emitted) {
            instance.emitted = {};
          } else if (instance.emitted[handlerName]) {
            return;
          }
          instance.emitted[handlerName] = true;
          callWithAsyncErrorHandling(
            onceHandler,
            instance,
            6,
            args
          );
        }
      }
      function normalizeEmitsOptions(comp, appContext, asMixin = false) {
        const cache = appContext.emitsCache;
        const cached = cache.get(comp);
        if (cached !== void 0) {
          return cached;
        }
        const raw = comp.emits;
        let normalized = {};
        let hasExtends = false;
        if (!isFunction$1(comp)) {
          const extendEmits = (raw2) => {
            const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
            if (normalizedFromExtend) {
              hasExtends = true;
              extend(normalized, normalizedFromExtend);
            }
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendEmits);
          }
          if (comp.extends) {
            extendEmits(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendEmits);
          }
        }
        if (!raw && !hasExtends) {
          if (isObject$1(comp)) {
            cache.set(comp, null);
          }
          return null;
        }
        if (isArray$2(raw)) {
          raw.forEach((key) => normalized[key] = null);
        } else {
          extend(normalized, raw);
        }
        if (isObject$1(comp)) {
          cache.set(comp, normalized);
        }
        return normalized;
      }
      function isEmitListener(options, key) {
        if (!options || !isOn(key)) {
          return false;
        }
        key = key.slice(2).replace(/Once$/, "");
        return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
      }
      let currentRenderingInstance = null;
      let currentScopeId = null;
      function setCurrentRenderingInstance(instance) {
        const prev = currentRenderingInstance;
        currentRenderingInstance = instance;
        currentScopeId = instance && instance.type.__scopeId || null;
        return prev;
      }
      function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
        if (!ctx)
          return fn2;
        if (fn2._n) {
          return fn2;
        }
        const renderFnWithContext = (...args) => {
          if (renderFnWithContext._d) {
            setBlockTracking(-1);
          }
          const prevInstance = setCurrentRenderingInstance(ctx);
          let res;
          try {
            res = fn2(...args);
          } finally {
            setCurrentRenderingInstance(prevInstance);
            if (renderFnWithContext._d) {
              setBlockTracking(1);
            }
          }
          return res;
        };
        renderFnWithContext._n = true;
        renderFnWithContext._c = true;
        renderFnWithContext._d = true;
        return renderFnWithContext;
      }
      function markAttrsAccessed() {
      }
      function renderComponentRoot(instance) {
        const {
          type: Component,
          vnode,
          proxy,
          withProxy,
          props,
          propsOptions: [propsOptions],
          slots,
          attrs,
          emit: emit2,
          render: render2,
          renderCache,
          data,
          setupState,
          ctx,
          inheritAttrs
        } = instance;
        let result;
        let fallthroughAttrs;
        const prev = setCurrentRenderingInstance(instance);
        try {
          if (vnode.shapeFlag & 4) {
            const proxyToUse = withProxy || proxy;
            const thisProxy = false ? new Proxy(proxyToUse, {
              get(target, key, receiver) {
                warn$1(
                  `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
                );
                return Reflect.get(target, key, receiver);
              }
            }) : proxyToUse;
            result = normalizeVNode(
              render2.call(
                thisProxy,
                proxyToUse,
                renderCache,
                props,
                setupState,
                data,
                ctx
              )
            );
            fallthroughAttrs = attrs;
          } else {
            const render22 = Component;
            if (false)
              ;
            result = normalizeVNode(
              render22.length > 1 ? render22(
                props,
                false ? {
                  get attrs() {
                    markAttrsAccessed();
                    return attrs;
                  },
                  slots,
                  emit: emit2
                } : { attrs, slots, emit: emit2 }
              ) : render22(
                props,
                null
                /* we know it doesn't need it */
              )
            );
            fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
          }
        } catch (err) {
          blockStack.length = 0;
          handleError(err, instance, 1);
          result = createVNode(Comment);
        }
        let root2 = result;
        if (fallthroughAttrs && inheritAttrs !== false) {
          const keys2 = Object.keys(fallthroughAttrs);
          const { shapeFlag } = root2;
          if (keys2.length) {
            if (shapeFlag & (1 | 6)) {
              if (propsOptions && keys2.some(isModelListener)) {
                fallthroughAttrs = filterModelListeners(
                  fallthroughAttrs,
                  propsOptions
                );
              }
              root2 = cloneVNode(root2, fallthroughAttrs);
            }
          }
        }
        if (vnode.dirs) {
          root2 = cloneVNode(root2);
          root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
        }
        if (vnode.transition) {
          root2.transition = vnode.transition;
        }
        {
          result = root2;
        }
        setCurrentRenderingInstance(prev);
        return result;
      }
      const getFunctionalFallthrough = (attrs) => {
        let res;
        for (const key in attrs) {
          if (key === "class" || key === "style" || isOn(key)) {
            (res || (res = {}))[key] = attrs[key];
          }
        }
        return res;
      };
      const filterModelListeners = (attrs, props) => {
        const res = {};
        for (const key in attrs) {
          if (!isModelListener(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
          }
        }
        return res;
      };
      function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
        const { props: prevProps, children: prevChildren, component } = prevVNode;
        const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
        const emits = component.emitsOptions;
        if (nextVNode.dirs || nextVNode.transition) {
          return true;
        }
        if (optimized && patchFlag >= 0) {
          if (patchFlag & 1024) {
            return true;
          }
          if (patchFlag & 16) {
            if (!prevProps) {
              return !!nextProps;
            }
            return hasPropsChanged(prevProps, nextProps, emits);
          } else if (patchFlag & 8) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i = 0; i < dynamicProps.length; i++) {
              const key = dynamicProps[i];
              if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
                return true;
              }
            }
          }
        } else {
          if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
              return true;
            }
          }
          if (prevProps === nextProps) {
            return false;
          }
          if (!prevProps) {
            return !!nextProps;
          }
          if (!nextProps) {
            return true;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        }
        return false;
      }
      function hasPropsChanged(prevProps, nextProps, emitsOptions) {
        const nextKeys = Object.keys(nextProps);
        if (nextKeys.length !== Object.keys(prevProps).length) {
          return true;
        }
        for (let i = 0; i < nextKeys.length; i++) {
          const key = nextKeys[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
            return true;
          }
        }
        return false;
      }
      function updateHOCHostEl({ vnode, parent }, el) {
        while (parent) {
          const root2 = parent.subTree;
          if (root2.suspense && root2.suspense.activeBranch === vnode) {
            root2.el = vnode.el;
          }
          if (root2 === vnode) {
            (vnode = parent.vnode).el = el;
            parent = parent.parent;
          } else {
            break;
          }
        }
      }
      const COMPONENTS = "components";
      const DIRECTIVES = "directives";
      function resolveComponent(name, maybeSelfReference) {
        return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
      }
      const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
      function resolveDynamicComponent(component) {
        if (isString$1(component)) {
          return resolveAsset(COMPONENTS, component, false) || component;
        } else {
          return component || NULL_DYNAMIC_COMPONENT;
        }
      }
      function resolveDirective(name) {
        return resolveAsset(DIRECTIVES, name);
      }
      function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
        const instance = currentRenderingInstance || currentInstance;
        if (instance) {
          const Component = instance.type;
          if (type === COMPONENTS) {
            const selfName = getComponentName(
              Component,
              false
            );
            if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
              return Component;
            }
          }
          const res = (
            // local registration
            // check instance[type] first which is resolved for options API
            resolve(instance[type] || Component[type], name) || // global registration
            resolve(instance.appContext[type], name)
          );
          if (!res && maybeSelfReference) {
            return Component;
          }
          return res;
        }
      }
      function resolve(registry, name) {
        return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
      }
      const isSuspense = (type) => type.__isSuspense;
      function queueEffectWithSuspense(fn2, suspense) {
        if (suspense && suspense.pendingBranch) {
          if (isArray$2(fn2)) {
            suspense.effects.push(...fn2);
          } else {
            suspense.effects.push(fn2);
          }
        } else {
          queuePostFlushCb(fn2);
        }
      }
      const ssrContextKey = Symbol.for("v-scx");
      const useSSRContext = () => {
        {
          const ctx = inject(ssrContextKey);
          return ctx;
        }
      };
      function watchEffect(effect, options) {
        return doWatch(effect, null, options);
      }
      const INITIAL_WATCHER_VALUE = {};
      function watch(source, cb, options) {
        return doWatch(source, cb, options);
      }
      function doWatch(source, cb, {
        immediate,
        deep,
        flush,
        once,
        onTrack,
        onTrigger
      } = EMPTY_OBJ) {
        if (cb && once) {
          const _cb = cb;
          cb = (...args) => {
            _cb(...args);
            unwatch();
          };
        }
        const instance = currentInstance;
        const reactiveGetter = (source2) => deep === true ? source2 : (
          // for deep: false, only traverse root-level properties
          traverse(source2, deep === false ? 1 : void 0)
        );
        let getter;
        let forceTrigger = false;
        let isMultiSource = false;
        if (isRef(source)) {
          getter = () => source.value;
          forceTrigger = isShallow(source);
        } else if (isReactive(source)) {
          getter = () => reactiveGetter(source);
          forceTrigger = true;
        } else if (isArray$2(source)) {
          isMultiSource = true;
          forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
          getter = () => source.map((s2) => {
            if (isRef(s2)) {
              return s2.value;
            } else if (isReactive(s2)) {
              return reactiveGetter(s2);
            } else if (isFunction$1(s2)) {
              return callWithErrorHandling(s2, instance, 2);
            } else
              ;
          });
        } else if (isFunction$1(source)) {
          if (cb) {
            getter = () => callWithErrorHandling(source, instance, 2);
          } else {
            getter = () => {
              if (cleanup) {
                cleanup();
              }
              return callWithAsyncErrorHandling(
                source,
                instance,
                3,
                [onCleanup]
              );
            };
          }
        } else {
          getter = NOOP;
        }
        if (cb && deep) {
          const baseGetter = getter;
          getter = () => traverse(baseGetter());
        }
        let cleanup;
        let onCleanup = (fn2) => {
          cleanup = effect.onStop = () => {
            callWithErrorHandling(fn2, instance, 4);
            cleanup = effect.onStop = void 0;
          };
        };
        let ssrCleanup;
        if (isInSSRComponentSetup) {
          onCleanup = NOOP;
          if (!cb) {
            getter();
          } else if (immediate) {
            callWithAsyncErrorHandling(cb, instance, 3, [
              getter(),
              isMultiSource ? [] : void 0,
              onCleanup
            ]);
          }
          if (flush === "sync") {
            const ctx = useSSRContext();
            ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
          } else {
            return NOOP;
          }
        }
        let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
        const job = () => {
          if (!effect.active || !effect.dirty) {
            return;
          }
          if (cb) {
            const newValue = effect.run();
            if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
              if (cleanup) {
                cleanup();
              }
              callWithAsyncErrorHandling(cb, instance, 3, [
                newValue,
                // pass undefined as the old value when it's changed for the first time
                oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                onCleanup
              ]);
              oldValue = newValue;
            }
          } else {
            effect.run();
          }
        };
        job.allowRecurse = !!cb;
        let scheduler;
        if (flush === "sync") {
          scheduler = job;
        } else if (flush === "post") {
          scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
        } else {
          job.pre = true;
          if (instance)
            job.id = instance.uid;
          scheduler = () => queueJob(job);
        }
        const effect = new ReactiveEffect(getter, NOOP, scheduler);
        const scope = getCurrentScope();
        const unwatch = () => {
          effect.stop();
          if (scope) {
            remove(scope.effects, effect);
          }
        };
        if (cb) {
          if (immediate) {
            job();
          } else {
            oldValue = effect.run();
          }
        } else if (flush === "post") {
          queuePostRenderEffect(
            effect.run.bind(effect),
            instance && instance.suspense
          );
        } else {
          effect.run();
        }
        if (ssrCleanup)
          ssrCleanup.push(unwatch);
        return unwatch;
      }
      function instanceWatch(source, value, options) {
        const publicThis = this.proxy;
        const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
        let cb;
        if (isFunction$1(value)) {
          cb = value;
        } else {
          cb = value.handler;
          options = value;
        }
        const reset = setCurrentInstance(this);
        const res = doWatch(getter, cb.bind(publicThis), options);
        reset();
        return res;
      }
      function createPathGetter(ctx, path) {
        const segments = path.split(".");
        return () => {
          let cur = ctx;
          for (let i = 0; i < segments.length && cur; i++) {
            cur = cur[segments[i]];
          }
          return cur;
        };
      }
      function traverse(value, depth, currentDepth = 0, seen) {
        if (!isObject$1(value) || value["__v_skip"]) {
          return value;
        }
        if (depth && depth > 0) {
          if (currentDepth >= depth) {
            return value;
          }
          currentDepth++;
        }
        seen = seen || /* @__PURE__ */ new Set();
        if (seen.has(value)) {
          return value;
        }
        seen.add(value);
        if (isRef(value)) {
          traverse(value.value, depth, currentDepth, seen);
        } else if (isArray$2(value)) {
          for (let i = 0; i < value.length; i++) {
            traverse(value[i], depth, currentDepth, seen);
          }
        } else if (isSet(value) || isMap(value)) {
          value.forEach((v) => {
            traverse(v, depth, currentDepth, seen);
          });
        } else if (isPlainObject(value)) {
          for (const key in value) {
            traverse(value[key], depth, currentDepth, seen);
          }
        }
        return value;
      }
      function withDirectives(vnode, directives) {
        if (currentRenderingInstance === null) {
          return vnode;
        }
        const instance = getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy;
        const bindings = vnode.dirs || (vnode.dirs = []);
        for (let i = 0; i < directives.length; i++) {
          let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
          if (dir) {
            if (isFunction$1(dir)) {
              dir = {
                mounted: dir,
                updated: dir
              };
            }
            if (dir.deep) {
              traverse(value);
            }
            bindings.push({
              dir,
              instance,
              value,
              oldValue: void 0,
              arg,
              modifiers
            });
          }
        }
        return vnode;
      }
      function invokeDirectiveHook(vnode, prevVNode, instance, name) {
        const bindings = vnode.dirs;
        const oldBindings = prevVNode && prevVNode.dirs;
        for (let i = 0; i < bindings.length; i++) {
          const binding = bindings[i];
          if (oldBindings) {
            binding.oldValue = oldBindings[i].value;
          }
          let hook = binding.dir[name];
          if (hook) {
            pauseTracking();
            callWithAsyncErrorHandling(hook, instance, 8, [
              vnode.el,
              binding,
              vnode,
              prevVNode
            ]);
            resetTracking();
          }
        }
      }
      const leaveCbKey = Symbol("_leaveCb");
      const enterCbKey = Symbol("_enterCb");
      function useTransitionState() {
        const state = {
          isMounted: false,
          isLeaving: false,
          isUnmounting: false,
          leavingVNodes: /* @__PURE__ */ new Map()
        };
        onMounted(() => {
          state.isMounted = true;
        });
        onBeforeUnmount(() => {
          state.isUnmounting = true;
        });
        return state;
      }
      const TransitionHookValidator = [Function, Array];
      const BaseTransitionPropsValidators = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
      };
      const BaseTransitionImpl = {
        name: `BaseTransition`,
        props: BaseTransitionPropsValidators,
        setup(props, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          let prevTransitionKey;
          return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
              return;
            }
            let child = children[0];
            if (children.length > 1) {
              for (const c of children) {
                if (c.type !== Comment) {
                  child = c;
                  break;
                }
              }
            }
            const rawProps = toRaw(props);
            const { mode } = rawProps;
            if (state.isLeaving) {
              return emptyPlaceholder(child);
            }
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
              return emptyPlaceholder(child);
            }
            const enterHooks = resolveTransitionHooks(
              innerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
              const key = getTransitionKey();
              if (prevTransitionKey === void 0) {
                prevTransitionKey = key;
              } else if (key !== prevTransitionKey) {
                prevTransitionKey = key;
                transitionKeyChanged = true;
              }
            }
            if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
              const leavingHooks = resolveTransitionHooks(
                oldInnerChild,
                rawProps,
                state,
                instance
              );
              setTransitionHooks(oldInnerChild, leavingHooks);
              if (mode === "out-in") {
                state.isLeaving = true;
                leavingHooks.afterLeave = () => {
                  state.isLeaving = false;
                  if (instance.update.active !== false) {
                    instance.effect.dirty = true;
                    instance.update();
                  }
                };
                return emptyPlaceholder(child);
              } else if (mode === "in-out" && innerChild.type !== Comment) {
                leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                  const leavingVNodesCache = getLeavingNodesForType(
                    state,
                    oldInnerChild
                  );
                  leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                  el[leaveCbKey] = () => {
                    earlyRemove();
                    el[leaveCbKey] = void 0;
                    delete enterHooks.delayedLeave;
                  };
                  enterHooks.delayedLeave = delayedLeave;
                };
              }
            }
            return child;
          };
        }
      };
      const BaseTransition = BaseTransitionImpl;
      function getLeavingNodesForType(state, vnode) {
        const { leavingVNodes } = state;
        let leavingVNodesCache = leavingVNodes.get(vnode.type);
        if (!leavingVNodesCache) {
          leavingVNodesCache = /* @__PURE__ */ Object.create(null);
          leavingVNodes.set(vnode.type, leavingVNodesCache);
        }
        return leavingVNodesCache;
      }
      function resolveTransitionHooks(vnode, props, state, instance) {
        const {
          appear,
          mode,
          persisted = false,
          onBeforeEnter,
          onEnter,
          onAfterEnter,
          onEnterCancelled,
          onBeforeLeave,
          onLeave,
          onAfterLeave,
          onLeaveCancelled,
          onBeforeAppear,
          onAppear,
          onAfterAppear,
          onAppearCancelled
        } = props;
        const key = String(vnode.key);
        const leavingVNodesCache = getLeavingNodesForType(state, vnode);
        const callHook2 = (hook, args) => {
          hook && callWithAsyncErrorHandling(
            hook,
            instance,
            9,
            args
          );
        };
        const callAsyncHook = (hook, args) => {
          const done = args[1];
          callHook2(hook, args);
          if (isArray$2(hook)) {
            if (hook.every((hook2) => hook2.length <= 1))
              done();
          } else if (hook.length <= 1) {
            done();
          }
        };
        const hooks = {
          mode,
          persisted,
          beforeEnter(el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
              if (appear) {
                hook = onBeforeAppear || onBeforeEnter;
              } else {
                return;
              }
            }
            if (el[leaveCbKey]) {
              el[leaveCbKey](
                true
                /* cancelled */
              );
            }
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
              leavingVNode.el[leaveCbKey]();
            }
            callHook2(hook, [el]);
          },
          enter(el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
              if (appear) {
                hook = onAppear || onEnter;
                afterHook = onAfterAppear || onAfterEnter;
                cancelHook = onAppearCancelled || onEnterCancelled;
              } else {
                return;
              }
            }
            let called = false;
            const done = el[enterCbKey] = (cancelled) => {
              if (called)
                return;
              called = true;
              if (cancelled) {
                callHook2(cancelHook, [el]);
              } else {
                callHook2(afterHook, [el]);
              }
              if (hooks.delayedLeave) {
                hooks.delayedLeave();
              }
              el[enterCbKey] = void 0;
            };
            if (hook) {
              callAsyncHook(hook, [el, done]);
            } else {
              done();
            }
          },
          leave(el, remove2) {
            const key2 = String(vnode.key);
            if (el[enterCbKey]) {
              el[enterCbKey](
                true
                /* cancelled */
              );
            }
            if (state.isUnmounting) {
              return remove2();
            }
            callHook2(onBeforeLeave, [el]);
            let called = false;
            const done = el[leaveCbKey] = (cancelled) => {
              if (called)
                return;
              called = true;
              remove2();
              if (cancelled) {
                callHook2(onLeaveCancelled, [el]);
              } else {
                callHook2(onAfterLeave, [el]);
              }
              el[leaveCbKey] = void 0;
              if (leavingVNodesCache[key2] === vnode) {
                delete leavingVNodesCache[key2];
              }
            };
            leavingVNodesCache[key2] = vnode;
            if (onLeave) {
              callAsyncHook(onLeave, [el, done]);
            } else {
              done();
            }
          },
          clone(vnode2) {
            return resolveTransitionHooks(vnode2, props, state, instance);
          }
        };
        return hooks;
      }
      function emptyPlaceholder(vnode) {
        if (isKeepAlive(vnode)) {
          vnode = cloneVNode(vnode);
          vnode.children = null;
          return vnode;
        }
      }
      function getKeepAliveChild(vnode) {
        return isKeepAlive(vnode) ? (
          // #7121 ensure get the child component subtree in case
          // it's been replaced during HMR
          vnode.children ? vnode.children[0] : void 0
        ) : vnode;
      }
      function setTransitionHooks(vnode, hooks) {
        if (vnode.shapeFlag & 6 && vnode.component) {
          setTransitionHooks(vnode.component.subTree, hooks);
        } else if (vnode.shapeFlag & 128) {
          vnode.ssContent.transition = hooks.clone(vnode.ssContent);
          vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
        } else {
          vnode.transition = hooks;
        }
      }
      function getTransitionRawChildren(children, keepComment = false, parentKey) {
        let ret = [];
        let keyedFragmentCount = 0;
        for (let i = 0; i < children.length; i++) {
          let child = children[i];
          const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
          if (child.type === Fragment) {
            if (child.patchFlag & 128)
              keyedFragmentCount++;
            ret = ret.concat(
              getTransitionRawChildren(child.children, keepComment, key)
            );
          } else if (keepComment || child.type !== Comment) {
            ret.push(key != null ? cloneVNode(child, { key }) : child);
          }
        }
        if (keyedFragmentCount > 1) {
          for (let i = 0; i < ret.length; i++) {
            ret[i].patchFlag = -2;
          }
        }
        return ret;
      }
      /*! #__NO_SIDE_EFFECTS__ */
      // @__NO_SIDE_EFFECTS__
      function defineComponent(options, extraOptions) {
        return isFunction$1(options) ? (
          // #8326: extend call and options.name access are considered side-effects
          // by Rollup, so we have to wrap it in a pure-annotated IIFE.
          /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
        ) : options;
      }
      const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
      const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
      function onActivated(hook, target) {
        registerKeepAliveHook(hook, "a", target);
      }
      function onDeactivated(hook, target) {
        registerKeepAliveHook(hook, "da", target);
      }
      function registerKeepAliveHook(hook, type, target = currentInstance) {
        const wrappedHook = hook.__wdc || (hook.__wdc = () => {
          let current = target;
          while (current) {
            if (current.isDeactivated) {
              return;
            }
            current = current.parent;
          }
          return hook();
        });
        injectHook(type, wrappedHook, target);
        if (target) {
          let current = target.parent;
          while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
              injectToKeepAliveRoot(wrappedHook, type, target, current);
            }
            current = current.parent;
          }
        }
      }
      function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
        const injected = injectHook(
          type,
          hook,
          keepAliveRoot,
          true
          /* prepend */
        );
        onUnmounted(() => {
          remove(keepAliveRoot[type], injected);
        }, target);
      }
      function injectHook(type, hook, target = currentInstance, prepend = false) {
        if (target) {
          const hooks = target[type] || (target[type] = []);
          const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
            if (target.isUnmounted) {
              return;
            }
            pauseTracking();
            const reset = setCurrentInstance(target);
            const res = callWithAsyncErrorHandling(hook, target, type, args);
            reset();
            resetTracking();
            return res;
          });
          if (prepend) {
            hooks.unshift(wrappedHook);
          } else {
            hooks.push(wrappedHook);
          }
          return wrappedHook;
        }
      }
      const createHook = (lifecycle) => (hook, target = currentInstance) => (
        // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
        (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
      );
      const onBeforeMount = createHook("bm");
      const onMounted = createHook("m");
      const onBeforeUpdate = createHook("bu");
      const onUpdated = createHook("u");
      const onBeforeUnmount = createHook("bum");
      const onUnmounted = createHook("um");
      const onServerPrefetch = createHook("sp");
      const onRenderTriggered = createHook(
        "rtg"
      );
      const onRenderTracked = createHook(
        "rtc"
      );
      function onErrorCaptured(hook, target = currentInstance) {
        injectHook("ec", hook, target);
      }
      function renderList(source, renderItem, cache, index) {
        let ret;
        const cached = cache && cache[index];
        if (isArray$2(source) || isString$1(source)) {
          ret = new Array(source.length);
          for (let i = 0, l2 = source.length; i < l2; i++) {
            ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
          }
        } else if (typeof source === "number") {
          ret = new Array(source);
          for (let i = 0; i < source; i++) {
            ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
          }
        } else if (isObject$1(source)) {
          if (source[Symbol.iterator]) {
            ret = Array.from(
              source,
              (item, i) => renderItem(item, i, void 0, cached && cached[i])
            );
          } else {
            const keys2 = Object.keys(source);
            ret = new Array(keys2.length);
            for (let i = 0, l2 = keys2.length; i < l2; i++) {
              const key = keys2[i];
              ret[i] = renderItem(source[key], key, i, cached && cached[i]);
            }
          }
        } else {
          ret = [];
        }
        if (cache) {
          cache[index] = ret;
        }
        return ret;
      }
      function createSlots(slots, dynamicSlots) {
        for (let i = 0; i < dynamicSlots.length; i++) {
          const slot = dynamicSlots[i];
          if (isArray$2(slot)) {
            for (let j = 0; j < slot.length; j++) {
              slots[slot[j].name] = slot[j].fn;
            }
          } else if (slot) {
            slots[slot.name] = slot.key ? (...args) => {
              const res = slot.fn(...args);
              if (res)
                res.key = slot.key;
              return res;
            } : slot.fn;
          }
        }
        return slots;
      }
      function renderSlot(slots, name, props = {}, fallback, noSlotted) {
        if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
          if (name !== "default")
            props.name = name;
          return createVNode("slot", props, fallback && fallback());
        }
        let slot = slots[name];
        if (slot && slot._c) {
          slot._d = false;
        }
        openBlock();
        const validSlotContent = slot && ensureValidVNode(slot(props));
        const rendered = createBlock(
          Fragment,
          {
            key: props.key || // slot content array of a dynamic conditional slot may have a branch
            // key attached in the `createSlots` helper, respect that
            validSlotContent && validSlotContent.key || `_${name}`
          },
          validSlotContent || (fallback ? fallback() : []),
          validSlotContent && slots._ === 1 ? 64 : -2
        );
        if (!noSlotted && rendered.scopeId) {
          rendered.slotScopeIds = [rendered.scopeId + "-s"];
        }
        if (slot && slot._c) {
          slot._d = true;
        }
        return rendered;
      }
      function ensureValidVNode(vnodes) {
        return vnodes.some((child) => {
          if (!isVNode(child))
            return true;
          if (child.type === Comment)
            return false;
          if (child.type === Fragment && !ensureValidVNode(child.children))
            return false;
          return true;
        }) ? vnodes : null;
      }
      const getPublicInstance = (i) => {
        if (!i)
          return null;
        if (isStatefulComponent(i))
          return getExposeProxy(i) || i.proxy;
        return getPublicInstance(i.parent);
      };
      const publicPropertiesMap = (
        // Move PURE marker to new line to workaround compiler discarding it
        // due to type annotation
        /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
          $: (i) => i,
          $el: (i) => i.vnode.el,
          $data: (i) => i.data,
          $props: (i) => i.props,
          $attrs: (i) => i.attrs,
          $slots: (i) => i.slots,
          $refs: (i) => i.refs,
          $parent: (i) => getPublicInstance(i.parent),
          $root: (i) => getPublicInstance(i.root),
          $emit: (i) => i.emit,
          $options: (i) => resolveMergedOptions(i),
          $forceUpdate: (i) => i.f || (i.f = () => {
            i.effect.dirty = true;
            queueJob(i.update);
          }),
          $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
          $watch: (i) => instanceWatch.bind(i)
        })
      );
      const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
      const PublicInstanceProxyHandlers = {
        get({ _: instance }, key) {
          const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
          let normalizedProps;
          if (key[0] !== "$") {
            const n2 = accessCache[key];
            if (n2 !== void 0) {
              switch (n2) {
                case 1:
                  return setupState[key];
                case 2:
                  return data[key];
                case 4:
                  return ctx[key];
                case 3:
                  return props[key];
              }
            } else if (hasSetupBinding(setupState, key)) {
              accessCache[key] = 1;
              return setupState[key];
            } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
              accessCache[key] = 2;
              return data[key];
            } else if (
              // only cache other properties when instance has declared (thus stable)
              // props
              (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
            ) {
              accessCache[key] = 3;
              return props[key];
            } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
              accessCache[key] = 4;
              return ctx[key];
            } else if (shouldCacheAccess) {
              accessCache[key] = 0;
            }
          }
          const publicGetter = publicPropertiesMap[key];
          let cssModule, globalProperties;
          if (publicGetter) {
            if (key === "$attrs") {
              track(instance, "get", key);
            }
            return publicGetter(instance);
          } else if (
            // css module (injected by vue-loader)
            (cssModule = type.__cssModules) && (cssModule = cssModule[key])
          ) {
            return cssModule;
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (
            // global properties
            globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
          ) {
            {
              return globalProperties[key];
            }
          } else
            ;
        },
        set({ _: instance }, key, value) {
          const { data, setupState, ctx } = instance;
          if (hasSetupBinding(setupState, key)) {
            setupState[key] = value;
            return true;
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            data[key] = value;
            return true;
          } else if (hasOwn(instance.props, key)) {
            return false;
          }
          if (key[0] === "$" && key.slice(1) in instance) {
            return false;
          } else {
            {
              ctx[key] = value;
            }
          }
          return true;
        },
        has({
          _: { data, setupState, accessCache, ctx, appContext, propsOptions }
        }, key) {
          let normalizedProps;
          return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
        },
        defineProperty(target, key, descriptor) {
          if (descriptor.get != null) {
            target._.accessCache[key] = 0;
          } else if (hasOwn(descriptor, "value")) {
            this.set(target, key, descriptor.value, null);
          }
          return Reflect.defineProperty(target, key, descriptor);
        }
      };
      function useSlots() {
        return getContext().slots;
      }
      function useAttrs$1() {
        return getContext().attrs;
      }
      function getContext() {
        const i = getCurrentInstance();
        return i.setupContext || (i.setupContext = createSetupContext(i));
      }
      function normalizePropsOrEmits(props) {
        return isArray$2(props) ? props.reduce(
          (normalized, p2) => (normalized[p2] = null, normalized),
          {}
        ) : props;
      }
      let shouldCacheAccess = true;
      function applyOptions(instance) {
        const options = resolveMergedOptions(instance);
        const publicThis = instance.proxy;
        const ctx = instance.ctx;
        shouldCacheAccess = false;
        if (options.beforeCreate) {
          callHook$1(options.beforeCreate, instance, "bc");
        }
        const {
          // state
          data: dataOptions,
          computed: computedOptions,
          methods,
          watch: watchOptions,
          provide: provideOptions,
          inject: injectOptions,
          // lifecycle
          created,
          beforeMount,
          mounted,
          beforeUpdate,
          updated,
          activated,
          deactivated,
          beforeDestroy,
          beforeUnmount,
          destroyed,
          unmounted,
          render: render2,
          renderTracked,
          renderTriggered,
          errorCaptured,
          serverPrefetch,
          // public API
          expose,
          inheritAttrs,
          // assets
          components,
          directives,
          filters
        } = options;
        const checkDuplicateProperties = null;
        if (injectOptions) {
          resolveInjections(injectOptions, ctx, checkDuplicateProperties);
        }
        if (methods) {
          for (const key in methods) {
            const methodHandler = methods[key];
            if (isFunction$1(methodHandler)) {
              {
                ctx[key] = methodHandler.bind(publicThis);
              }
            }
          }
        }
        if (dataOptions) {
          const data = dataOptions.call(publicThis, publicThis);
          if (!isObject$1(data))
            ;
          else {
            instance.data = reactive(data);
          }
        }
        shouldCacheAccess = true;
        if (computedOptions) {
          for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
            const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
            const c = computed({
              get: get2,
              set: set2
            });
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => c.value,
              set: (v) => c.value = v
            });
          }
        }
        if (watchOptions) {
          for (const key in watchOptions) {
            createWatcher(watchOptions[key], ctx, publicThis, key);
          }
        }
        if (provideOptions) {
          const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
          Reflect.ownKeys(provides).forEach((key) => {
            provide(key, provides[key]);
          });
        }
        if (created) {
          callHook$1(created, instance, "c");
        }
        function registerLifecycleHook(register, hook) {
          if (isArray$2(hook)) {
            hook.forEach((_hook) => register(_hook.bind(publicThis)));
          } else if (hook) {
            register(hook.bind(publicThis));
          }
        }
        registerLifecycleHook(onBeforeMount, beforeMount);
        registerLifecycleHook(onMounted, mounted);
        registerLifecycleHook(onBeforeUpdate, beforeUpdate);
        registerLifecycleHook(onUpdated, updated);
        registerLifecycleHook(onActivated, activated);
        registerLifecycleHook(onDeactivated, deactivated);
        registerLifecycleHook(onErrorCaptured, errorCaptured);
        registerLifecycleHook(onRenderTracked, renderTracked);
        registerLifecycleHook(onRenderTriggered, renderTriggered);
        registerLifecycleHook(onBeforeUnmount, beforeUnmount);
        registerLifecycleHook(onUnmounted, unmounted);
        registerLifecycleHook(onServerPrefetch, serverPrefetch);
        if (isArray$2(expose)) {
          if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach((key) => {
              Object.defineProperty(exposed, key, {
                get: () => publicThis[key],
                set: (val) => publicThis[key] = val
              });
            });
          } else if (!instance.exposed) {
            instance.exposed = {};
          }
        }
        if (render2 && instance.render === NOOP) {
          instance.render = render2;
        }
        if (inheritAttrs != null) {
          instance.inheritAttrs = inheritAttrs;
        }
        if (components)
          instance.components = components;
        if (directives)
          instance.directives = directives;
      }
      function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
        if (isArray$2(injectOptions)) {
          injectOptions = normalizeInject(injectOptions);
        }
        for (const key in injectOptions) {
          const opt = injectOptions[key];
          let injected;
          if (isObject$1(opt)) {
            if ("default" in opt) {
              injected = inject(
                opt.from || key,
                opt.default,
                true
              );
            } else {
              injected = inject(opt.from || key);
            }
          } else {
            injected = inject(opt);
          }
          if (isRef(injected)) {
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              get: () => injected.value,
              set: (v) => injected.value = v
            });
          } else {
            ctx[key] = injected;
          }
        }
      }
      function callHook$1(hook, instance, type) {
        callWithAsyncErrorHandling(
          isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
          instance,
          type
        );
      }
      function createWatcher(raw, ctx, publicThis, key) {
        const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
        if (isString$1(raw)) {
          const handler = ctx[raw];
          if (isFunction$1(handler)) {
            watch(getter, handler);
          }
        } else if (isFunction$1(raw)) {
          watch(getter, raw.bind(publicThis));
        } else if (isObject$1(raw)) {
          if (isArray$2(raw)) {
            raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
          } else {
            const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
            if (isFunction$1(handler)) {
              watch(getter, handler, raw);
            }
          }
        } else
          ;
      }
      function resolveMergedOptions(instance) {
        const base2 = instance.type;
        const { mixins, extends: extendsOptions } = base2;
        const {
          mixins: globalMixins,
          optionsCache: cache,
          config: { optionMergeStrategies }
        } = instance.appContext;
        const cached = cache.get(base2);
        let resolved;
        if (cached) {
          resolved = cached;
        } else if (!globalMixins.length && !mixins && !extendsOptions) {
          {
            resolved = base2;
          }
        } else {
          resolved = {};
          if (globalMixins.length) {
            globalMixins.forEach(
              (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
            );
          }
          mergeOptions(resolved, base2, optionMergeStrategies);
        }
        if (isObject$1(base2)) {
          cache.set(base2, resolved);
        }
        return resolved;
      }
      function mergeOptions(to, from, strats, asMixin = false) {
        const { mixins, extends: extendsOptions } = from;
        if (extendsOptions) {
          mergeOptions(to, extendsOptions, strats, true);
        }
        if (mixins) {
          mixins.forEach(
            (m) => mergeOptions(to, m, strats, true)
          );
        }
        for (const key in from) {
          if (asMixin && key === "expose")
            ;
          else {
            const strat = internalOptionMergeStrats[key] || strats && strats[key];
            to[key] = strat ? strat(to[key], from[key]) : from[key];
          }
        }
        return to;
      }
      const internalOptionMergeStrats = {
        data: mergeDataFn,
        props: mergeEmitsOrPropsOptions,
        emits: mergeEmitsOrPropsOptions,
        // objects
        methods: mergeObjectOptions,
        computed: mergeObjectOptions,
        // lifecycle
        beforeCreate: mergeAsArray,
        created: mergeAsArray,
        beforeMount: mergeAsArray,
        mounted: mergeAsArray,
        beforeUpdate: mergeAsArray,
        updated: mergeAsArray,
        beforeDestroy: mergeAsArray,
        beforeUnmount: mergeAsArray,
        destroyed: mergeAsArray,
        unmounted: mergeAsArray,
        activated: mergeAsArray,
        deactivated: mergeAsArray,
        errorCaptured: mergeAsArray,
        serverPrefetch: mergeAsArray,
        // assets
        components: mergeObjectOptions,
        directives: mergeObjectOptions,
        // watch
        watch: mergeWatchOptions,
        // provide / inject
        provide: mergeDataFn,
        inject: mergeInject
      };
      function mergeDataFn(to, from) {
        if (!from) {
          return to;
        }
        if (!to) {
          return from;
        }
        return function mergedDataFn() {
          return extend(
            isFunction$1(to) ? to.call(this, this) : to,
            isFunction$1(from) ? from.call(this, this) : from
          );
        };
      }
      function mergeInject(to, from) {
        return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
      }
      function normalizeInject(raw) {
        if (isArray$2(raw)) {
          const res = {};
          for (let i = 0; i < raw.length; i++) {
            res[raw[i]] = raw[i];
          }
          return res;
        }
        return raw;
      }
      function mergeAsArray(to, from) {
        return to ? [...new Set([].concat(to, from))] : from;
      }
      function mergeObjectOptions(to, from) {
        return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
      }
      function mergeEmitsOrPropsOptions(to, from) {
        if (to) {
          if (isArray$2(to) && isArray$2(from)) {
            return [.../* @__PURE__ */ new Set([...to, ...from])];
          }
          return extend(
            /* @__PURE__ */ Object.create(null),
            normalizePropsOrEmits(to),
            normalizePropsOrEmits(from != null ? from : {})
          );
        } else {
          return from;
        }
      }
      function mergeWatchOptions(to, from) {
        if (!to)
          return from;
        if (!from)
          return to;
        const merged = extend(/* @__PURE__ */ Object.create(null), to);
        for (const key in from) {
          merged[key] = mergeAsArray(to[key], from[key]);
        }
        return merged;
      }
      function createAppContext() {
        return {
          app: null,
          config: {
            isNativeTag: NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
          },
          mixins: [],
          components: {},
          directives: {},
          provides: /* @__PURE__ */ Object.create(null),
          optionsCache: /* @__PURE__ */ new WeakMap(),
          propsCache: /* @__PURE__ */ new WeakMap(),
          emitsCache: /* @__PURE__ */ new WeakMap()
        };
      }
      let uid$1 = 0;
      function createAppAPI(render2, hydrate) {
        return function createApp2(rootComponent, rootProps = null) {
          if (!isFunction$1(rootComponent)) {
            rootComponent = extend({}, rootComponent);
          }
          if (rootProps != null && !isObject$1(rootProps)) {
            rootProps = null;
          }
          const context = createAppContext();
          const installedPlugins = /* @__PURE__ */ new WeakSet();
          let isMounted = false;
          const app = context.app = {
            _uid: uid$1++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config() {
              return context.config;
            },
            set config(v) {
            },
            use(plugin, ...options) {
              if (installedPlugins.has(plugin))
                ;
              else if (plugin && isFunction$1(plugin.install)) {
                installedPlugins.add(plugin);
                plugin.install(app, ...options);
              } else if (isFunction$1(plugin)) {
                installedPlugins.add(plugin);
                plugin(app, ...options);
              } else
                ;
              return app;
            },
            mixin(mixin) {
              {
                if (!context.mixins.includes(mixin)) {
                  context.mixins.push(mixin);
                }
              }
              return app;
            },
            component(name, component) {
              if (!component) {
                return context.components[name];
              }
              context.components[name] = component;
              return app;
            },
            directive(name, directive) {
              if (!directive) {
                return context.directives[name];
              }
              context.directives[name] = directive;
              return app;
            },
            mount(rootContainer, isHydrate, namespace) {
              if (!isMounted) {
                const vnode = createVNode(rootComponent, rootProps);
                vnode.appContext = context;
                if (namespace === true) {
                  namespace = "svg";
                } else if (namespace === false) {
                  namespace = void 0;
                }
                if (isHydrate && hydrate) {
                  hydrate(vnode, rootContainer);
                } else {
                  render2(vnode, rootContainer, namespace);
                }
                isMounted = true;
                app._container = rootContainer;
                rootContainer.__vue_app__ = app;
                return getExposeProxy(vnode.component) || vnode.component.proxy;
              }
            },
            unmount() {
              if (isMounted) {
                render2(null, app._container);
                delete app._container.__vue_app__;
              }
            },
            provide(key, value) {
              context.provides[key] = value;
              return app;
            },
            runWithContext(fn2) {
              currentApp = app;
              try {
                return fn2();
              } finally {
                currentApp = null;
              }
            }
          };
          return app;
        };
      }
      let currentApp = null;
      function provide(key, value) {
        if (!currentInstance)
          ;
        else {
          let provides = currentInstance.provides;
          const parentProvides = currentInstance.parent && currentInstance.parent.provides;
          if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
          }
          provides[key] = value;
        }
      }
      function inject(key, defaultValue, treatDefaultAsFactory = false) {
        const instance = currentInstance || currentRenderingInstance;
        if (instance || currentApp) {
          const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
          if (provides && key in provides) {
            return provides[key];
          } else if (arguments.length > 1) {
            return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
          } else
            ;
        }
      }
      function initProps(instance, rawProps, isStateful, isSSR = false) {
        const props = {};
        const attrs = {};
        def(attrs, InternalObjectKey, 1);
        instance.propsDefaults = /* @__PURE__ */ Object.create(null);
        setFullProps(instance, rawProps, props, attrs);
        for (const key in instance.propsOptions[0]) {
          if (!(key in props)) {
            props[key] = void 0;
          }
        }
        if (isStateful) {
          instance.props = isSSR ? props : shallowReactive(props);
        } else {
          if (!instance.type.props) {
            instance.props = attrs;
          } else {
            instance.props = props;
          }
        }
        instance.attrs = attrs;
      }
      function updateProps(instance, rawProps, rawPrevProps, optimized) {
        const {
          props,
          attrs,
          vnode: { patchFlag }
        } = instance;
        const rawCurrentProps = toRaw(props);
        const [options] = instance.propsOptions;
        let hasAttrsChanged = false;
        if (
          // always force full diff in dev
          // - #1942 if hmr is enabled with sfc component
          // - vite#872 non-sfc component used by sfc component
          (optimized || patchFlag > 0) && !(patchFlag & 16)
        ) {
          if (patchFlag & 8) {
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              let key = propsToUpdate[i];
              if (isEmitListener(instance.emitsOptions, key)) {
                continue;
              }
              const value = rawProps[key];
              if (options) {
                if (hasOwn(attrs, key)) {
                  if (value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                  }
                } else {
                  const camelizedKey = camelize(key);
                  props[camelizedKey] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    camelizedKey,
                    value,
                    instance,
                    false
                  );
                }
              } else {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              }
            }
          }
        } else {
          if (setFullProps(instance, rawProps, props, attrs)) {
            hasAttrsChanged = true;
          }
          let kebabKey;
          for (const key in rawCurrentProps) {
            if (!rawProps || // for camelCase
            !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
            // and converted to camelCase (#955)
            ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
              if (options) {
                if (rawPrevProps && // for camelCase
                (rawPrevProps[key] !== void 0 || // for kebab-case
                rawPrevProps[kebabKey] !== void 0)) {
                  props[key] = resolvePropValue(
                    options,
                    rawCurrentProps,
                    key,
                    void 0,
                    instance,
                    true
                  );
                }
              } else {
                delete props[key];
              }
            }
          }
          if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
              if (!rawProps || !hasOwn(rawProps, key) && true) {
                delete attrs[key];
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (hasAttrsChanged) {
          trigger(instance, "set", "$attrs");
        }
      }
      function setFullProps(instance, rawProps, props, attrs) {
        const [options, needCastKeys] = instance.propsOptions;
        let hasAttrsChanged = false;
        let rawCastValues;
        if (rawProps) {
          for (let key in rawProps) {
            if (isReservedProp(key)) {
              continue;
            }
            const value = rawProps[key];
            let camelKey;
            if (options && hasOwn(options, camelKey = camelize(key))) {
              if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                props[camelKey] = value;
              } else {
                (rawCastValues || (rawCastValues = {}))[camelKey] = value;
              }
            } else if (!isEmitListener(instance.emitsOptions, key)) {
              if (!(key in attrs) || value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
        if (needCastKeys) {
          const rawCurrentProps = toRaw(props);
          const castValues = rawCastValues || EMPTY_OBJ;
          for (let i = 0; i < needCastKeys.length; i++) {
            const key = needCastKeys[i];
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              castValues[key],
              instance,
              !hasOwn(castValues, key)
            );
          }
        }
        return hasAttrsChanged;
      }
      function resolvePropValue(options, props, key, value, instance, isAbsent) {
        const opt = options[key];
        if (opt != null) {
          const hasDefault = hasOwn(opt, "default");
          if (hasDefault && value === void 0) {
            const defaultValue = opt.default;
            if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
              const { propsDefaults } = instance;
              if (key in propsDefaults) {
                value = propsDefaults[key];
              } else {
                const reset = setCurrentInstance(instance);
                value = propsDefaults[key] = defaultValue.call(
                  null,
                  props
                );
                reset();
              }
            } else {
              value = defaultValue;
            }
          }
          if (opt[
            0
            /* shouldCast */
          ]) {
            if (isAbsent && !hasDefault) {
              value = false;
            } else if (opt[
              1
              /* shouldCastTrue */
            ] && (value === "" || value === hyphenate(key))) {
              value = true;
            }
          }
        }
        return value;
      }
      function normalizePropsOptions(comp, appContext, asMixin = false) {
        const cache = appContext.propsCache;
        const cached = cache.get(comp);
        if (cached) {
          return cached;
        }
        const raw = comp.props;
        const normalized = {};
        const needCastKeys = [];
        let hasExtends = false;
        if (!isFunction$1(comp)) {
          const extendProps = (raw2) => {
            hasExtends = true;
            const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
            extend(normalized, props);
            if (keys2)
              needCastKeys.push(...keys2);
          };
          if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendProps);
          }
          if (comp.extends) {
            extendProps(comp.extends);
          }
          if (comp.mixins) {
            comp.mixins.forEach(extendProps);
          }
        }
        if (!raw && !hasExtends) {
          if (isObject$1(comp)) {
            cache.set(comp, EMPTY_ARR);
          }
          return EMPTY_ARR;
        }
        if (isArray$2(raw)) {
          for (let i = 0; i < raw.length; i++) {
            const normalizedKey = camelize(raw[i]);
            if (validatePropName(normalizedKey)) {
              normalized[normalizedKey] = EMPTY_OBJ;
            }
          }
        } else if (raw) {
          for (const key in raw) {
            const normalizedKey = camelize(key);
            if (validatePropName(normalizedKey)) {
              const opt = raw[key];
              const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
              if (prop) {
                const booleanIndex = getTypeIndex(Boolean, prop.type);
                const stringIndex = getTypeIndex(String, prop.type);
                prop[
                  0
                  /* shouldCast */
                ] = booleanIndex > -1;
                prop[
                  1
                  /* shouldCastTrue */
                ] = stringIndex < 0 || booleanIndex < stringIndex;
                if (booleanIndex > -1 || hasOwn(prop, "default")) {
                  needCastKeys.push(normalizedKey);
                }
              }
            }
          }
        }
        const res = [normalized, needCastKeys];
        if (isObject$1(comp)) {
          cache.set(comp, res);
        }
        return res;
      }
      function validatePropName(key) {
        if (key[0] !== "$") {
          return true;
        }
        return false;
      }
      function getType(ctor) {
        const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
        return match ? match[2] : ctor === null ? "null" : "";
      }
      function isSameType(a, b) {
        return getType(a) === getType(b);
      }
      function getTypeIndex(type, expectedTypes) {
        if (isArray$2(expectedTypes)) {
          return expectedTypes.findIndex((t2) => isSameType(t2, type));
        } else if (isFunction$1(expectedTypes)) {
          return isSameType(expectedTypes, type) ? 0 : -1;
        }
        return -1;
      }
      const isInternalKey = (key) => key[0] === "_" || key === "$stable";
      const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
      const normalizeSlot = (key, rawSlot, ctx) => {
        if (rawSlot._n) {
          return rawSlot;
        }
        const normalized = withCtx((...args) => {
          if (false)
            ;
          return normalizeSlotValue(rawSlot(...args));
        }, ctx);
        normalized._c = false;
        return normalized;
      };
      const normalizeObjectSlots = (rawSlots, slots, instance) => {
        const ctx = rawSlots._ctx;
        for (const key in rawSlots) {
          if (isInternalKey(key))
            continue;
          const value = rawSlots[key];
          if (isFunction$1(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
          } else if (value != null) {
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
          }
        }
      };
      const normalizeVNodeSlots = (instance, children) => {
        const normalized = normalizeSlotValue(children);
        instance.slots.default = () => normalized;
      };
      const initSlots = (instance, children) => {
        if (instance.vnode.shapeFlag & 32) {
          const type = children._;
          if (type) {
            instance.slots = toRaw(children);
            def(children, "_", type);
          } else {
            normalizeObjectSlots(
              children,
              instance.slots = {}
            );
          }
        } else {
          instance.slots = {};
          if (children) {
            normalizeVNodeSlots(instance, children);
          }
        }
        def(instance.slots, InternalObjectKey, 1);
      };
      const updateSlots = (instance, children, optimized) => {
        const { vnode, slots } = instance;
        let needDeletionCheck = true;
        let deletionComparisonTarget = EMPTY_OBJ;
        if (vnode.shapeFlag & 32) {
          const type = children._;
          if (type) {
            if (optimized && type === 1) {
              needDeletionCheck = false;
            } else {
              extend(slots, children);
              if (!optimized && type === 1) {
                delete slots._;
              }
            }
          } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
          }
          deletionComparisonTarget = children;
        } else if (children) {
          normalizeVNodeSlots(instance, children);
          deletionComparisonTarget = { default: 1 };
        }
        if (needDeletionCheck) {
          for (const key in slots) {
            if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
              delete slots[key];
            }
          }
        }
      };
      function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
        if (isArray$2(rawRef)) {
          rawRef.forEach(
            (r2, i) => setRef(
              r2,
              oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef),
              parentSuspense,
              vnode,
              isUnmount
            )
          );
          return;
        }
        if (isAsyncWrapper(vnode) && !isUnmount) {
          return;
        }
        const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
        const value = isUnmount ? null : refValue;
        const { i: owner, r: ref2 } = rawRef;
        const oldRef = oldRawRef && oldRawRef.r;
        const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
        const setupState = owner.setupState;
        if (oldRef != null && oldRef !== ref2) {
          if (isString$1(oldRef)) {
            refs[oldRef] = null;
            if (hasOwn(setupState, oldRef)) {
              setupState[oldRef] = null;
            }
          } else if (isRef(oldRef)) {
            oldRef.value = null;
          }
        }
        if (isFunction$1(ref2)) {
          callWithErrorHandling(ref2, owner, 12, [value, refs]);
        } else {
          const _isString = isString$1(ref2);
          const _isRef = isRef(ref2);
          if (_isString || _isRef) {
            const doSet = () => {
              if (rawRef.f) {
                const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
                if (isUnmount) {
                  isArray$2(existing) && remove(existing, refValue);
                } else {
                  if (!isArray$2(existing)) {
                    if (_isString) {
                      refs[ref2] = [refValue];
                      if (hasOwn(setupState, ref2)) {
                        setupState[ref2] = refs[ref2];
                      }
                    } else {
                      ref2.value = [refValue];
                      if (rawRef.k)
                        refs[rawRef.k] = ref2.value;
                    }
                  } else if (!existing.includes(refValue)) {
                    existing.push(refValue);
                  }
                }
              } else if (_isString) {
                refs[ref2] = value;
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = value;
                }
              } else if (_isRef) {
                ref2.value = value;
                if (rawRef.k)
                  refs[rawRef.k] = value;
              } else
                ;
            };
            if (value) {
              doSet.id = -1;
              queuePostRenderEffect(doSet, parentSuspense);
            } else {
              doSet();
            }
          }
        }
      }
      const queuePostRenderEffect = queueEffectWithSuspense;
      function createRenderer(options) {
        return baseCreateRenderer(options);
      }
      function baseCreateRenderer(options, createHydrationFns) {
        const target = getGlobalThis();
        target.__VUE__ = true;
        const {
          insert: hostInsert,
          remove: hostRemove,
          patchProp: hostPatchProp,
          createElement: hostCreateElement,
          createText: hostCreateText,
          createComment: hostCreateComment,
          setText: hostSetText,
          setElementText: hostSetElementText,
          parentNode: hostParentNode,
          nextSibling: hostNextSibling,
          setScopeId: hostSetScopeId = NOOP,
          insertStaticContent: hostInsertStaticContent
        } = options;
        const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
          if (n1 === n2) {
            return;
          }
          if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
          }
          if (n2.patchFlag === -2) {
            optimized = false;
            n2.dynamicChildren = null;
          }
          const { type, ref: ref2, shapeFlag } = n2;
          switch (type) {
            case Text:
              processText(n1, n2, container, anchor);
              break;
            case Comment:
              processCommentNode(n1, n2, container, anchor);
              break;
            case Static:
              if (n1 == null) {
                mountStaticNode(n2, container, anchor, namespace);
              }
              break;
            case Fragment:
              processFragment(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              break;
            default:
              if (shapeFlag & 1) {
                processElement(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else if (shapeFlag & 6) {
                processComponent(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else if (shapeFlag & 64) {
                type.process(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized,
                  internals
                );
              } else if (shapeFlag & 128) {
                type.process(
                  n1,
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized,
                  internals
                );
              } else
                ;
          }
          if (ref2 != null && parentComponent) {
            setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
          }
        };
        const processText = (n1, n2, container, anchor) => {
          if (n1 == null) {
            hostInsert(
              n2.el = hostCreateText(n2.children),
              container,
              anchor
            );
          } else {
            const el = n2.el = n1.el;
            if (n2.children !== n1.children) {
              hostSetText(el, n2.children);
            }
          }
        };
        const processCommentNode = (n1, n2, container, anchor) => {
          if (n1 == null) {
            hostInsert(
              n2.el = hostCreateComment(n2.children || ""),
              container,
              anchor
            );
          } else {
            n2.el = n1.el;
          }
        };
        const mountStaticNode = (n2, container, anchor, namespace) => {
          [n2.el, n2.anchor] = hostInsertStaticContent(
            n2.children,
            container,
            anchor,
            namespace,
            n2.el,
            n2.anchor
          );
        };
        const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
          let next;
          while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
          }
          hostInsert(anchor, container, nextSibling);
        };
        const removeStaticNode = ({ el, anchor }) => {
          let next;
          while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
          }
          hostRemove(anchor);
        };
        const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          if (n2.type === "svg") {
            namespace = "svg";
          } else if (n2.type === "math") {
            namespace = "mathml";
          }
          if (n1 == null) {
            mountElement(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            patchElement(
              n1,
              n2,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        };
        const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          let el;
          let vnodeHook;
          const { props, shapeFlag, transition, dirs } = vnode;
          el = vnode.el = hostCreateElement(
            vnode.type,
            namespace,
            props && props.is,
            props
          );
          if (shapeFlag & 8) {
            hostSetElementText(el, vnode.children);
          } else if (shapeFlag & 16) {
            mountChildren(
              vnode.children,
              el,
              null,
              parentComponent,
              parentSuspense,
              resolveChildrenNamespace(vnode, namespace),
              slotScopeIds,
              optimized
            );
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "created");
          }
          setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
          if (props) {
            for (const key in props) {
              if (key !== "value" && !isReservedProp(key)) {
                hostPatchProp(
                  el,
                  key,
                  null,
                  props[key],
                  namespace,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
            if ("value" in props) {
              hostPatchProp(el, "value", null, props.value, namespace);
            }
            if (vnodeHook = props.onVnodeBeforeMount) {
              invokeVNodeHook(vnodeHook, parentComponent, vnode);
            }
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
          }
          const needCallTransitionHooks = needTransition(parentSuspense, transition);
          if (needCallTransitionHooks) {
            transition.beforeEnter(el);
          }
          hostInsert(el, container, anchor);
          if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              needCallTransitionHooks && transition.enter(el);
              dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
          }
        };
        const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
          if (scopeId) {
            hostSetScopeId(el, scopeId);
          }
          if (slotScopeIds) {
            for (let i = 0; i < slotScopeIds.length; i++) {
              hostSetScopeId(el, slotScopeIds[i]);
            }
          }
          if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (vnode === subTree) {
              const parentVNode = parentComponent.vnode;
              setScopeId(
                el,
                parentVNode,
                parentVNode.scopeId,
                parentVNode.slotScopeIds,
                parentComponent.parent
              );
            }
          }
        };
        const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
          for (let i = start; i < children.length; i++) {
            const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
            patch(
              null,
              child,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        };
        const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          const el = n2.el = n1.el;
          let { patchFlag, dynamicChildren, dirs } = n2;
          patchFlag |= n1.patchFlag & 16;
          const oldProps = n1.props || EMPTY_OBJ;
          const newProps = n2.props || EMPTY_OBJ;
          let vnodeHook;
          parentComponent && toggleRecurse(parentComponent, false);
          if (vnodeHook = newProps.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          }
          if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
          }
          parentComponent && toggleRecurse(parentComponent, true);
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              el,
              parentComponent,
              parentSuspense,
              resolveChildrenNamespace(n2, namespace),
              slotScopeIds
            );
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              el,
              null,
              parentComponent,
              parentSuspense,
              resolveChildrenNamespace(n2, namespace),
              slotScopeIds,
              false
            );
          }
          if (patchFlag > 0) {
            if (patchFlag & 16) {
              patchProps(
                el,
                n2,
                oldProps,
                newProps,
                parentComponent,
                parentSuspense,
                namespace
              );
            } else {
              if (patchFlag & 2) {
                if (oldProps.class !== newProps.class) {
                  hostPatchProp(el, "class", null, newProps.class, namespace);
                }
              }
              if (patchFlag & 4) {
                hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
              }
              if (patchFlag & 8) {
                const propsToUpdate = n2.dynamicProps;
                for (let i = 0; i < propsToUpdate.length; i++) {
                  const key = propsToUpdate[i];
                  const prev = oldProps[key];
                  const next = newProps[key];
                  if (next !== prev || key === "value") {
                    hostPatchProp(
                      el,
                      key,
                      prev,
                      next,
                      namespace,
                      n1.children,
                      parentComponent,
                      parentSuspense,
                      unmountChildren
                    );
                  }
                }
              }
            }
            if (patchFlag & 1) {
              if (n1.children !== n2.children) {
                hostSetElementText(el, n2.children);
              }
            }
          } else if (!optimized && dynamicChildren == null) {
            patchProps(
              el,
              n2,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              namespace
            );
          }
          if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
              dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
            }, parentSuspense);
          }
        };
        const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
          for (let i = 0; i < newChildren.length; i++) {
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            const container = (
              // oldVNode may be an errored async setup() component inside Suspense
              // which will not have a mounted element
              oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
              // of the Fragment itself so it can move its children.
              (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
              // which also requires the correct parent container
              !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
              oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
                // In other cases, the parent container is not actually used so we
                // just pass the block element here to avoid a DOM parentNode call.
                fallbackContainer
              )
            );
            patch(
              oldVNode,
              newVNode,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              true
            );
          }
        };
        const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
          if (oldProps !== newProps) {
            if (oldProps !== EMPTY_OBJ) {
              for (const key in oldProps) {
                if (!isReservedProp(key) && !(key in newProps)) {
                  hostPatchProp(
                    el,
                    key,
                    oldProps[key],
                    null,
                    namespace,
                    vnode.children,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  );
                }
              }
            }
            for (const key in newProps) {
              if (isReservedProp(key))
                continue;
              const next = newProps[key];
              const prev = oldProps[key];
              if (next !== prev && key !== "value") {
                hostPatchProp(
                  el,
                  key,
                  prev,
                  next,
                  namespace,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
            if ("value" in newProps) {
              hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
            }
          }
        };
        const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
          const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
          let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
          if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
          }
          if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            mountChildren(
              // #10007
              // such fragment like `<></>` will be compiled into
              // a fragment which doesn't have a children.
              // In this case fallback to an empty array
              n2.children || [],
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
            // of renderSlot() with no valid children
            n1.dynamicChildren) {
              patchBlockChildren(
                n1.dynamicChildren,
                dynamicChildren,
                container,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds
              );
              if (
                // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                n2.key != null || parentComponent && n2 === parentComponent.subTree
              ) {
                traverseStaticChildren(
                  n1,
                  n2,
                  true
                  /* shallow */
                );
              }
            } else {
              patchChildren(
                n1,
                n2,
                container,
                fragmentEndAnchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          }
        };
        const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          n2.slotScopeIds = slotScopeIds;
          if (n1 == null) {
            if (n2.shapeFlag & 512) {
              parentComponent.ctx.activate(
                n2,
                container,
                anchor,
                namespace,
                optimized
              );
            } else {
              mountComponent(
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                optimized
              );
            }
          } else {
            updateComponent(n1, n2, optimized);
          }
        };
        const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
          const instance = initialVNode.component = createComponentInstance(
            initialVNode,
            parentComponent,
            parentSuspense
          );
          if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
          }
          {
            setupComponent(instance);
          }
          if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            if (!initialVNode.el) {
              const placeholder = instance.subTree = createVNode(Comment);
              processCommentNode(null, placeholder, container, anchor);
            }
          } else {
            setupRenderEffect(
              instance,
              initialVNode,
              container,
              anchor,
              parentSuspense,
              namespace,
              optimized
            );
          }
        };
        const updateComponent = (n1, n2, optimized) => {
          const instance = n2.component = n1.component;
          if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep && !instance.asyncResolved) {
              updateComponentPreRender(instance, n2, optimized);
              return;
            } else {
              instance.next = n2;
              invalidateJob(instance.update);
              instance.effect.dirty = true;
              instance.update();
            }
          } else {
            n2.el = n1.el;
            instance.vnode = n2;
          }
        };
        const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
          const componentUpdateFn = () => {
            if (!instance.isMounted) {
              let vnodeHook;
              const { el, props } = initialVNode;
              const { bm, m, parent } = instance;
              const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
              toggleRecurse(instance, false);
              if (bm) {
                invokeArrayFns(bm);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHook, parent, initialVNode);
              }
              toggleRecurse(instance, true);
              if (el && hydrateNode) {
                const hydrateSubTree = () => {
                  instance.subTree = renderComponentRoot(instance);
                  hydrateNode(
                    el,
                    instance.subTree,
                    instance,
                    parentSuspense,
                    null
                  );
                };
                if (isAsyncWrapperVNode) {
                  initialVNode.type.__asyncLoader().then(
                    // note: we are moving the render call into an async callback,
                    // which means it won't track dependencies - but it's ok because
                    // a server-rendered async wrapper is already in resolved state
                    // and it will never need to change.
                    () => !instance.isUnmounted && hydrateSubTree()
                  );
                } else {
                  hydrateSubTree();
                }
              } else {
                const subTree = instance.subTree = renderComponentRoot(instance);
                patch(
                  null,
                  subTree,
                  container,
                  anchor,
                  instance,
                  parentSuspense,
                  namespace
                );
                initialVNode.el = subTree.el;
              }
              if (m) {
                queuePostRenderEffect(m, parentSuspense);
              }
              if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                const scopedInitialVNode = initialVNode;
                queuePostRenderEffect(
                  () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                  parentSuspense
                );
              }
              if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
                instance.a && queuePostRenderEffect(instance.a, parentSuspense);
              }
              instance.isMounted = true;
              initialVNode = container = anchor = null;
            } else {
              let { next, bu, u, parent, vnode } = instance;
              {
                const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
                if (nonHydratedAsyncRoot) {
                  if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                  }
                  nonHydratedAsyncRoot.asyncDep.then(() => {
                    if (!instance.isUnmounted) {
                      componentUpdateFn();
                    }
                  });
                  return;
                }
              }
              let originNext = next;
              let vnodeHook;
              toggleRecurse(instance, false);
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              } else {
                next = vnode;
              }
              if (bu) {
                invokeArrayFns(bu);
              }
              if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
                invokeVNodeHook(vnodeHook, parent, next, vnode);
              }
              toggleRecurse(instance, true);
              const nextTree = renderComponentRoot(instance);
              const prevTree = instance.subTree;
              instance.subTree = nextTree;
              patch(
                prevTree,
                nextTree,
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el),
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree),
                instance,
                parentSuspense,
                namespace
              );
              next.el = nextTree.el;
              if (originNext === null) {
                updateHOCHostEl(instance, nextTree.el);
              }
              if (u) {
                queuePostRenderEffect(u, parentSuspense);
              }
              if (vnodeHook = next.props && next.props.onVnodeUpdated) {
                queuePostRenderEffect(
                  () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                  parentSuspense
                );
              }
            }
          };
          const effect = instance.effect = new ReactiveEffect(
            componentUpdateFn,
            NOOP,
            () => queueJob(update),
            instance.scope
            // track it in component's effect scope
          );
          const update = instance.update = () => {
            if (effect.dirty) {
              effect.run();
            }
          };
          update.id = instance.uid;
          toggleRecurse(instance, true);
          update();
        };
        const updateComponentPreRender = (instance, nextVNode, optimized) => {
          nextVNode.component = instance;
          const prevProps = instance.vnode.props;
          instance.vnode = nextVNode;
          instance.next = null;
          updateProps(instance, nextVNode.props, prevProps, optimized);
          updateSlots(instance, nextVNode.children, optimized);
          pauseTracking();
          flushPreFlushCbs(instance);
          resetTracking();
        };
        const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
          const c1 = n1 && n1.children;
          const prevShapeFlag = n1 ? n1.shapeFlag : 0;
          const c2 = n2.children;
          const { patchFlag, shapeFlag } = n2;
          if (patchFlag > 0) {
            if (patchFlag & 128) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              return;
            } else if (patchFlag & 256) {
              patchUnkeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              return;
            }
          }
          if (shapeFlag & 8) {
            if (prevShapeFlag & 16) {
              unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
              hostSetElementText(container, c2);
            }
          } else {
            if (prevShapeFlag & 16) {
              if (shapeFlag & 16) {
                patchKeyedChildren(
                  c1,
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else {
                unmountChildren(c1, parentComponent, parentSuspense, true);
              }
            } else {
              if (prevShapeFlag & 8) {
                hostSetElementText(container, "");
              }
              if (shapeFlag & 16) {
                mountChildren(
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              }
            }
          }
        };
        const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          c1 = c1 || EMPTY_ARR;
          c2 = c2 || EMPTY_ARR;
          const oldLength = c1.length;
          const newLength = c2.length;
          const commonLength = Math.min(oldLength, newLength);
          let i;
          for (i = 0; i < commonLength; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            patch(
              c1[i],
              nextChild,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
          if (oldLength > newLength) {
            unmountChildren(
              c1,
              parentComponent,
              parentSuspense,
              true,
              false,
              commonLength
            );
          } else {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              commonLength
            );
          }
        };
        const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
          let i = 0;
          const l2 = c2.length;
          let e1 = c1.length - 1;
          let e2 = l2 - 1;
          while (i <= e1 && i <= e2) {
            const n1 = c1[i];
            const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (isSameVNodeType(n1, n2)) {
              patch(
                n1,
                n2,
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              break;
            }
            i++;
          }
          while (i <= e1 && i <= e2) {
            const n1 = c1[e1];
            const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
            if (isSameVNodeType(n1, n2)) {
              patch(
                n1,
                n2,
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              break;
            }
            e1--;
            e2--;
          }
          if (i > e1) {
            if (i <= e2) {
              const nextPos = e2 + 1;
              const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
              while (i <= e2) {
                patch(
                  null,
                  c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
                i++;
              }
            }
          } else if (i > e2) {
            while (i <= e1) {
              unmount(c1[i], parentComponent, parentSuspense, true);
              i++;
            }
          } else {
            const s1 = i;
            const s2 = i;
            const keyToNewIndexMap = /* @__PURE__ */ new Map();
            for (i = s2; i <= e2; i++) {
              const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
              if (nextChild.key != null) {
                keyToNewIndexMap.set(nextChild.key, i);
              }
            }
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            let maxNewIndexSoFar = 0;
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i = 0; i < toBePatched; i++)
              newIndexToOldIndexMap[i] = 0;
            for (i = s1; i <= e1; i++) {
              const prevChild = c1[i];
              if (patched >= toBePatched) {
                unmount(prevChild, parentComponent, parentSuspense, true);
                continue;
              }
              let newIndex;
              if (prevChild.key != null) {
                newIndex = keyToNewIndexMap.get(prevChild.key);
              } else {
                for (j = s2; j <= e2; j++) {
                  if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                    newIndex = j;
                    break;
                  }
                }
              }
              if (newIndex === void 0) {
                unmount(prevChild, parentComponent, parentSuspense, true);
              } else {
                newIndexToOldIndexMap[newIndex - s2] = i + 1;
                if (newIndex >= maxNewIndexSoFar) {
                  maxNewIndexSoFar = newIndex;
                } else {
                  moved = true;
                }
                patch(
                  prevChild,
                  c2[newIndex],
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
                patched++;
              }
            }
            const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
            j = increasingNewIndexSequence.length - 1;
            for (i = toBePatched - 1; i >= 0; i--) {
              const nextIndex = s2 + i;
              const nextChild = c2[nextIndex];
              const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
              if (newIndexToOldIndexMap[i] === 0) {
                patch(
                  null,
                  nextChild,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else if (moved) {
                if (j < 0 || i !== increasingNewIndexSequence[j]) {
                  move(nextChild, container, anchor, 2);
                } else {
                  j--;
                }
              }
            }
          }
        };
        const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
          const { el, type, transition, children, shapeFlag } = vnode;
          if (shapeFlag & 6) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
          }
          if (shapeFlag & 128) {
            vnode.suspense.move(container, anchor, moveType);
            return;
          }
          if (shapeFlag & 64) {
            type.move(vnode, container, anchor, internals);
            return;
          }
          if (type === Fragment) {
            hostInsert(el, container, anchor);
            for (let i = 0; i < children.length; i++) {
              move(children[i], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
          }
          if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
          }
          const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
          if (needTransition2) {
            if (moveType === 0) {
              transition.beforeEnter(el);
              hostInsert(el, container, anchor);
              queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            } else {
              const { leave, delayLeave, afterLeave } = transition;
              const remove22 = () => hostInsert(el, container, anchor);
              const performLeave = () => {
                leave(el, () => {
                  remove22();
                  afterLeave && afterLeave();
                });
              };
              if (delayLeave) {
                delayLeave(el, remove22, performLeave);
              } else {
                performLeave();
              }
            }
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
          const {
            type,
            props,
            ref: ref2,
            children,
            dynamicChildren,
            shapeFlag,
            patchFlag,
            dirs
          } = vnode;
          if (ref2 != null) {
            setRef(ref2, null, parentSuspense, vnode, true);
          }
          if (shapeFlag & 256) {
            parentComponent.ctx.deactivate(vnode);
            return;
          }
          const shouldInvokeDirs = shapeFlag & 1 && dirs;
          const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
          let vnodeHook;
          if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
          if (shapeFlag & 6) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
          } else {
            if (shapeFlag & 128) {
              vnode.suspense.unmount(parentSuspense, doRemove);
              return;
            }
            if (shouldInvokeDirs) {
              invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
            }
            if (shapeFlag & 64) {
              vnode.type.remove(
                vnode,
                parentComponent,
                parentSuspense,
                optimized,
                internals,
                doRemove
              );
            } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
            (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
              unmountChildren(
                dynamicChildren,
                parentComponent,
                parentSuspense,
                false,
                true
              );
            } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
              unmountChildren(children, parentComponent, parentSuspense);
            }
            if (doRemove) {
              remove2(vnode);
            }
          }
          if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
            queuePostRenderEffect(() => {
              vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
              shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
            }, parentSuspense);
          }
        };
        const remove2 = (vnode) => {
          const { type, el, anchor, transition } = vnode;
          if (type === Fragment) {
            {
              removeFragment(el, anchor);
            }
            return;
          }
          if (type === Static) {
            removeStaticNode(vnode);
            return;
          }
          const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
              transition.afterLeave();
            }
          };
          if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
              delayLeave(vnode.el, performRemove, performLeave);
            } else {
              performLeave();
            }
          } else {
            performRemove();
          }
        };
        const removeFragment = (cur, end) => {
          let next;
          while (cur !== end) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
          }
          hostRemove(end);
        };
        const unmountComponent = (instance, parentSuspense, doRemove) => {
          const { bum, scope, update, subTree, um } = instance;
          if (bum) {
            invokeArrayFns(bum);
          }
          scope.stop();
          if (update) {
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
          }
          if (um) {
            queuePostRenderEffect(um, parentSuspense);
          }
          queuePostRenderEffect(() => {
            instance.isUnmounted = true;
          }, parentSuspense);
          if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
              parentSuspense.resolve();
            }
          }
        };
        const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
          for (let i = start; i < children.length; i++) {
            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
          }
        };
        const getNextHostNode = (vnode) => {
          if (vnode.shapeFlag & 6) {
            return getNextHostNode(vnode.component.subTree);
          }
          if (vnode.shapeFlag & 128) {
            return vnode.suspense.next();
          }
          return hostNextSibling(vnode.anchor || vnode.el);
        };
        let isFlushing2 = false;
        const render2 = (vnode, container, namespace) => {
          if (vnode == null) {
            if (container._vnode) {
              unmount(container._vnode, null, null, true);
            }
          } else {
            patch(
              container._vnode || null,
              vnode,
              container,
              null,
              null,
              null,
              namespace
            );
          }
          if (!isFlushing2) {
            isFlushing2 = true;
            flushPreFlushCbs();
            flushPostFlushCbs();
            isFlushing2 = false;
          }
          container._vnode = vnode;
        };
        const internals = {
          p: patch,
          um: unmount,
          m: move,
          r: remove2,
          mt: mountComponent,
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          n: getNextHostNode,
          o: options
        };
        let hydrate;
        let hydrateNode;
        if (createHydrationFns) {
          [hydrate, hydrateNode] = createHydrationFns(
            internals
          );
        }
        return {
          render: render2,
          hydrate,
          createApp: createAppAPI(render2, hydrate)
        };
      }
      function resolveChildrenNamespace({ type, props }, currentNamespace) {
        return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
      }
      function toggleRecurse({ effect, update }, allowed) {
        effect.allowRecurse = update.allowRecurse = allowed;
      }
      function needTransition(parentSuspense, transition) {
        return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
      }
      function traverseStaticChildren(n1, n2, shallow = false) {
        const ch1 = n1.children;
        const ch2 = n2.children;
        if (isArray$2(ch1) && isArray$2(ch2)) {
          for (let i = 0; i < ch1.length; i++) {
            const c1 = ch1[i];
            let c2 = ch2[i];
            if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
              if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                c2 = ch2[i] = cloneIfMounted(ch2[i]);
                c2.el = c1.el;
              }
              if (!shallow)
                traverseStaticChildren(c1, c2);
            }
            if (c2.type === Text) {
              c2.el = c1.el;
            }
          }
        }
      }
      function getSequence(arr) {
        const p2 = arr.slice();
        const result = [0];
        let i, j, u, v, c;
        const len = arr.length;
        for (i = 0; i < len; i++) {
          const arrI = arr[i];
          if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
              p2[i] = j;
              result.push(i);
              continue;
            }
            u = 0;
            v = result.length - 1;
            while (u < v) {
              c = u + v >> 1;
              if (arr[result[c]] < arrI) {
                u = c + 1;
              } else {
                v = c;
              }
            }
            if (arrI < arr[result[u]]) {
              if (u > 0) {
                p2[i] = result[u - 1];
              }
              result[u] = i;
            }
          }
        }
        u = result.length;
        v = result[u - 1];
        while (u-- > 0) {
          result[u] = v;
          v = p2[v];
        }
        return result;
      }
      function locateNonHydratedAsyncRoot(instance) {
        const subComponent = instance.subTree.component;
        if (subComponent) {
          if (subComponent.asyncDep && !subComponent.asyncResolved) {
            return subComponent;
          } else {
            return locateNonHydratedAsyncRoot(subComponent);
          }
        }
      }
      const isTeleport = (type) => type.__isTeleport;
      const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
      const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
      const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
      const resolveTarget = (props, select) => {
        const targetSelector = props && props.to;
        if (isString$1(targetSelector)) {
          if (!select) {
            return null;
          } else {
            const target = select(targetSelector);
            return target;
          }
        } else {
          return targetSelector;
        }
      };
      const TeleportImpl = {
        name: "Teleport",
        __isTeleport: true,
        process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
          const {
            mc: mountChildren,
            pc: patchChildren,
            pbc: patchBlockChildren,
            o: { insert, querySelector, createText, createComment }
          } = internals;
          const disabled = isTeleportDisabled(n2.props);
          let { shapeFlag, children, dynamicChildren } = n2;
          if (n1 == null) {
            const placeholder = n2.el = createText("");
            const mainAnchor = n2.anchor = createText("");
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = n2.targetAnchor = createText("");
            if (target) {
              insert(targetAnchor, target);
              if (namespace === "svg" || isTargetSVG(target)) {
                namespace = "svg";
              } else if (namespace === "mathml" || isTargetMathML(target)) {
                namespace = "mathml";
              }
            }
            const mount = (container2, anchor2) => {
              if (shapeFlag & 16) {
                mountChildren(
                  children,
                  container2,
                  anchor2,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              }
            };
            if (disabled) {
              mount(container, mainAnchor);
            } else if (target) {
              mount(target, targetAnchor);
            }
          } else {
            n2.el = n1.el;
            const mainAnchor = n2.anchor = n1.anchor;
            const target = n2.target = n1.target;
            const targetAnchor = n2.targetAnchor = n1.targetAnchor;
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            if (namespace === "svg" || isTargetSVG(target)) {
              namespace = "svg";
            } else if (namespace === "mathml" || isTargetMathML(target)) {
              namespace = "mathml";
            }
            if (dynamicChildren) {
              patchBlockChildren(
                n1.dynamicChildren,
                dynamicChildren,
                currentContainer,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds
              );
              traverseStaticChildren(n1, n2, true);
            } else if (!optimized) {
              patchChildren(
                n1,
                n2,
                currentContainer,
                currentAnchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                false
              );
            }
            if (disabled) {
              if (!wasDisabled) {
                moveTeleport(
                  n2,
                  container,
                  mainAnchor,
                  internals,
                  1
                );
              } else {
                if (n2.props && n1.props && n2.props.to !== n1.props.to) {
                  n2.props.to = n1.props.to;
                }
              }
            } else {
              if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                const nextTarget = n2.target = resolveTarget(
                  n2.props,
                  querySelector
                );
                if (nextTarget) {
                  moveTeleport(
                    n2,
                    nextTarget,
                    null,
                    internals,
                    0
                  );
                }
              } else if (wasDisabled) {
                moveTeleport(
                  n2,
                  target,
                  targetAnchor,
                  internals,
                  1
                );
              }
            }
          }
          updateCssVars(n2);
        },
        remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
          const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
          if (target) {
            hostRemove(targetAnchor);
          }
          doRemove && hostRemove(anchor);
          if (shapeFlag & 16) {
            const shouldRemove = doRemove || !isTeleportDisabled(props);
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              unmount(
                child,
                parentComponent,
                parentSuspense,
                shouldRemove,
                !!child.dynamicChildren
              );
            }
          }
        },
        move: moveTeleport,
        hydrate: hydrateTeleport
      };
      function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
        if (moveType === 0) {
          insert(vnode.targetAnchor, container, parentAnchor);
        }
        const { el, anchor, shapeFlag, children, props } = vnode;
        const isReorder = moveType === 2;
        if (isReorder) {
          insert(el, container, parentAnchor);
        }
        if (!isReorder || isTeleportDisabled(props)) {
          if (shapeFlag & 16) {
            for (let i = 0; i < children.length; i++) {
              move(
                children[i],
                container,
                parentAnchor,
                2
              );
            }
          }
        }
        if (isReorder) {
          insert(anchor, container, parentAnchor);
        }
      }
      function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
        o: { nextSibling, parentNode, querySelector }
      }, hydrateChildren) {
        const target = vnode.target = resolveTarget(
          vnode.props,
          querySelector
        );
        if (target) {
          const targetNode = target._lpa || target.firstChild;
          if (vnode.shapeFlag & 16) {
            if (isTeleportDisabled(vnode.props)) {
              vnode.anchor = hydrateChildren(
                nextSibling(node),
                vnode,
                parentNode(node),
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
              vnode.targetAnchor = targetNode;
            } else {
              vnode.anchor = nextSibling(node);
              let targetAnchor = targetNode;
              while (targetAnchor) {
                targetAnchor = nextSibling(targetAnchor);
                if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                  vnode.targetAnchor = targetAnchor;
                  target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                  break;
                }
              }
              hydrateChildren(
                targetNode,
                vnode,
                target,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
            }
          }
          updateCssVars(vnode);
        }
        return vnode.anchor && nextSibling(vnode.anchor);
      }
      const Teleport = TeleportImpl;
      function updateCssVars(vnode) {
        const ctx = vnode.ctx;
        if (ctx && ctx.ut) {
          let node = vnode.children[0].el;
          while (node && node !== vnode.targetAnchor) {
            if (node.nodeType === 1)
              node.setAttribute("data-v-owner", ctx.uid);
            node = node.nextSibling;
          }
          ctx.ut();
        }
      }
      const Fragment = Symbol.for("v-fgt");
      const Text = Symbol.for("v-txt");
      const Comment = Symbol.for("v-cmt");
      const Static = Symbol.for("v-stc");
      const blockStack = [];
      let currentBlock = null;
      function openBlock(disableTracking = false) {
        blockStack.push(currentBlock = disableTracking ? null : []);
      }
      function closeBlock() {
        blockStack.pop();
        currentBlock = blockStack[blockStack.length - 1] || null;
      }
      let isBlockTreeEnabled = 1;
      function setBlockTracking(value) {
        isBlockTreeEnabled += value;
      }
      function setupBlock(vnode) {
        vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
        closeBlock();
        if (isBlockTreeEnabled > 0 && currentBlock) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
        return setupBlock(
          createBaseVNode(
            type,
            props,
            children,
            patchFlag,
            dynamicProps,
            shapeFlag,
            true
          )
        );
      }
      function createBlock(type, props, children, patchFlag, dynamicProps) {
        return setupBlock(
          createVNode(
            type,
            props,
            children,
            patchFlag,
            dynamicProps,
            true
          )
        );
      }
      function isVNode(value) {
        return value ? value.__v_isVNode === true : false;
      }
      function isSameVNodeType(n1, n2) {
        return n1.type === n2.type && n1.key === n2.key;
      }
      const InternalObjectKey = `__vInternal`;
      const normalizeKey = ({ key }) => key != null ? key : null;
      const normalizeRef = ({
        ref: ref2,
        ref_key,
        ref_for
      }) => {
        if (typeof ref2 === "number") {
          ref2 = "" + ref2;
        }
        return ref2 != null ? isString$1(ref2) || isRef(ref2) || isFunction$1(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
      };
      function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
        const vnode = {
          __v_isVNode: true,
          __v_skip: true,
          type,
          props,
          key: props && normalizeKey(props),
          ref: props && normalizeRef(props),
          scopeId: currentScopeId,
          slotScopeIds: null,
          children,
          component: null,
          suspense: null,
          ssContent: null,
          ssFallback: null,
          dirs: null,
          transition: null,
          el: null,
          anchor: null,
          target: null,
          targetAnchor: null,
          staticCount: 0,
          shapeFlag,
          patchFlag,
          dynamicProps,
          dynamicChildren: null,
          appContext: null,
          ctx: currentRenderingInstance
        };
        if (needFullChildrenNormalization) {
          normalizeChildren(vnode, children);
          if (shapeFlag & 128) {
            type.normalize(vnode);
          }
        } else if (children) {
          vnode.shapeFlag |= isString$1(children) ? 8 : 16;
        }
        if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
        !isBlockNode && // has current parent block
        currentBlock && // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        vnode.patchFlag !== 32) {
          currentBlock.push(vnode);
        }
        return vnode;
      }
      const createVNode = _createVNode;
      function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
        if (!type || type === NULL_DYNAMIC_COMPONENT) {
          type = Comment;
        }
        if (isVNode(type)) {
          const cloned = cloneVNode(
            type,
            props,
            true
            /* mergeRef: true */
          );
          if (children) {
            normalizeChildren(cloned, children);
          }
          if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6) {
              currentBlock[currentBlock.indexOf(type)] = cloned;
            } else {
              currentBlock.push(cloned);
            }
          }
          cloned.patchFlag |= -2;
          return cloned;
        }
        if (isClassComponent(type)) {
          type = type.__vccOpts;
        }
        if (props) {
          props = guardReactiveProps(props);
          let { class: klass, style: style2 } = props;
          if (klass && !isString$1(klass)) {
            props.class = normalizeClass(klass);
          }
          if (isObject$1(style2)) {
            if (isProxy(style2) && !isArray$2(style2)) {
              style2 = extend({}, style2);
            }
            props.style = normalizeStyle(style2);
          }
        }
        const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$1(type) ? 2 : 0;
        return createBaseVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          isBlockNode,
          true
        );
      }
      function guardReactiveProps(props) {
        if (!props)
          return null;
        return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
      }
      function cloneVNode(vnode, extraProps, mergeRef = false) {
        const { props, ref: ref2, patchFlag, children } = vnode;
        const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
        const cloned = {
          __v_isVNode: true,
          __v_skip: true,
          type: vnode.type,
          props: mergedProps,
          key: mergedProps && normalizeKey(mergedProps),
          ref: extraProps && extraProps.ref ? (
            // #2078 in the case of <component :is="vnode" ref="extra"/>
            // if the vnode itself already has a ref, cloneVNode will need to merge
            // the refs so the single vnode can be set on multiple refs
            mergeRef && ref2 ? isArray$2(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
          ) : ref2,
          scopeId: vnode.scopeId,
          slotScopeIds: vnode.slotScopeIds,
          children,
          target: vnode.target,
          targetAnchor: vnode.targetAnchor,
          staticCount: vnode.staticCount,
          shapeFlag: vnode.shapeFlag,
          // if the vnode is cloned with extra props, we can no longer assume its
          // existing patch flag to be reliable and need to add the FULL_PROPS flag.
          // note: preserve flag for fragments since they use the flag for children
          // fast paths only.
          patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
          dynamicProps: vnode.dynamicProps,
          dynamicChildren: vnode.dynamicChildren,
          appContext: vnode.appContext,
          dirs: vnode.dirs,
          transition: vnode.transition,
          // These should technically only be non-null on mounted VNodes. However,
          // they *should* be copied for kept-alive vnodes. So we just always copy
          // them since them being non-null during a mount doesn't affect the logic as
          // they will simply be overwritten.
          component: vnode.component,
          suspense: vnode.suspense,
          ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
          ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
          el: vnode.el,
          anchor: vnode.anchor,
          ctx: vnode.ctx,
          ce: vnode.ce
        };
        return cloned;
      }
      function createTextVNode(text = " ", flag = 0) {
        return createVNode(Text, null, text, flag);
      }
      function createCommentVNode(text = "", asBlock = false) {
        return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
      }
      function normalizeVNode(child) {
        if (child == null || typeof child === "boolean") {
          return createVNode(Comment);
        } else if (isArray$2(child)) {
          return createVNode(
            Fragment,
            null,
            // #3666, avoid reference pollution when reusing vnode
            child.slice()
          );
        } else if (typeof child === "object") {
          return cloneIfMounted(child);
        } else {
          return createVNode(Text, null, String(child));
        }
      }
      function cloneIfMounted(child) {
        return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
      }
      function normalizeChildren(vnode, children) {
        let type = 0;
        const { shapeFlag } = vnode;
        if (children == null) {
          children = null;
        } else if (isArray$2(children)) {
          type = 16;
        } else if (typeof children === "object") {
          if (shapeFlag & (1 | 64)) {
            const slot = children.default;
            if (slot) {
              slot._c && (slot._d = false);
              normalizeChildren(vnode, slot());
              slot._c && (slot._d = true);
            }
            return;
          } else {
            type = 32;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) {
              children._ctx = currentRenderingInstance;
            } else if (slotFlag === 3 && currentRenderingInstance) {
              if (currentRenderingInstance.slots._ === 1) {
                children._ = 1;
              } else {
                children._ = 2;
                vnode.patchFlag |= 1024;
              }
            }
          }
        } else if (isFunction$1(children)) {
          children = { default: children, _ctx: currentRenderingInstance };
          type = 32;
        } else {
          children = String(children);
          if (shapeFlag & 64) {
            type = 16;
            children = [createTextVNode(children)];
          } else {
            type = 8;
          }
        }
        vnode.children = children;
        vnode.shapeFlag |= type;
      }
      function mergeProps(...args) {
        const ret = {};
        for (let i = 0; i < args.length; i++) {
          const toMerge = args[i];
          for (const key in toMerge) {
            if (key === "class") {
              if (ret.class !== toMerge.class) {
                ret.class = normalizeClass([ret.class, toMerge.class]);
              }
            } else if (key === "style") {
              ret.style = normalizeStyle([ret.style, toMerge.style]);
            } else if (isOn(key)) {
              const existing = ret[key];
              const incoming = toMerge[key];
              if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
                ret[key] = existing ? [].concat(existing, incoming) : incoming;
              }
            } else if (key !== "") {
              ret[key] = toMerge[key];
            }
          }
        }
        return ret;
      }
      function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
        callWithAsyncErrorHandling(hook, instance, 7, [
          vnode,
          prevVNode
        ]);
      }
      const emptyAppContext = createAppContext();
      let uid = 0;
      function createComponentInstance(vnode, parent, suspense) {
        const type = vnode.type;
        const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
        const instance = {
          uid: uid++,
          vnode,
          type,
          parent,
          appContext,
          root: null,
          // to be immediately set
          next: null,
          subTree: null,
          // will be set synchronously right after creation
          effect: null,
          update: null,
          // will be set synchronously right after creation
          scope: new EffectScope(
            true
            /* detached */
          ),
          render: null,
          proxy: null,
          exposed: null,
          exposeProxy: null,
          withProxy: null,
          provides: parent ? parent.provides : Object.create(appContext.provides),
          accessCache: null,
          renderCache: [],
          // local resolved assets
          components: null,
          directives: null,
          // resolved props and emits options
          propsOptions: normalizePropsOptions(type, appContext),
          emitsOptions: normalizeEmitsOptions(type, appContext),
          // emit
          emit: null,
          // to be set immediately
          emitted: null,
          // props default value
          propsDefaults: EMPTY_OBJ,
          // inheritAttrs
          inheritAttrs: type.inheritAttrs,
          // state
          ctx: EMPTY_OBJ,
          data: EMPTY_OBJ,
          props: EMPTY_OBJ,
          attrs: EMPTY_OBJ,
          slots: EMPTY_OBJ,
          refs: EMPTY_OBJ,
          setupState: EMPTY_OBJ,
          setupContext: null,
          attrsProxy: null,
          slotsProxy: null,
          // suspense related
          suspense,
          suspenseId: suspense ? suspense.pendingId : 0,
          asyncDep: null,
          asyncResolved: false,
          // lifecycle hooks
          // not using enums here because it results in computed properties
          isMounted: false,
          isUnmounted: false,
          isDeactivated: false,
          bc: null,
          c: null,
          bm: null,
          m: null,
          bu: null,
          u: null,
          um: null,
          bum: null,
          da: null,
          a: null,
          rtg: null,
          rtc: null,
          ec: null,
          sp: null
        };
        {
          instance.ctx = { _: instance };
        }
        instance.root = parent ? parent.root : instance;
        instance.emit = emit.bind(null, instance);
        if (vnode.ce) {
          vnode.ce(instance);
        }
        return instance;
      }
      let currentInstance = null;
      const getCurrentInstance = () => currentInstance || currentRenderingInstance;
      let internalSetCurrentInstance;
      let setInSSRSetupState;
      {
        const g = getGlobalThis();
        const registerGlobalSetter = (key, setter) => {
          let setters;
          if (!(setters = g[key]))
            setters = g[key] = [];
          setters.push(setter);
          return (v) => {
            if (setters.length > 1)
              setters.forEach((set2) => set2(v));
            else
              setters[0](v);
          };
        };
        internalSetCurrentInstance = registerGlobalSetter(
          `__VUE_INSTANCE_SETTERS__`,
          (v) => currentInstance = v
        );
        setInSSRSetupState = registerGlobalSetter(
          `__VUE_SSR_SETTERS__`,
          (v) => isInSSRComponentSetup = v
        );
      }
      const setCurrentInstance = (instance) => {
        const prev = currentInstance;
        internalSetCurrentInstance(instance);
        instance.scope.on();
        return () => {
          instance.scope.off();
          internalSetCurrentInstance(prev);
        };
      };
      const unsetCurrentInstance = () => {
        currentInstance && currentInstance.scope.off();
        internalSetCurrentInstance(null);
      };
      function isStatefulComponent(instance) {
        return instance.vnode.shapeFlag & 4;
      }
      let isInSSRComponentSetup = false;
      function setupComponent(instance, isSSR = false) {
        isSSR && setInSSRSetupState(isSSR);
        const { props, children } = instance.vnode;
        const isStateful = isStatefulComponent(instance);
        initProps(instance, props, isStateful, isSSR);
        initSlots(instance, children);
        const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
        isSSR && setInSSRSetupState(false);
        return setupResult;
      }
      function setupStatefulComponent(instance, isSSR) {
        const Component = instance.type;
        instance.accessCache = /* @__PURE__ */ Object.create(null);
        instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
        const { setup } = Component;
        if (setup) {
          const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
          const reset = setCurrentInstance(instance);
          pauseTracking();
          const setupResult = callWithErrorHandling(
            setup,
            instance,
            0,
            [
              instance.props,
              setupContext
            ]
          );
          resetTracking();
          reset();
          if (isPromise(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) {
              return setupResult.then((resolvedResult) => {
                handleSetupResult(instance, resolvedResult, isSSR);
              }).catch((e2) => {
                handleError(e2, instance, 0);
              });
            } else {
              instance.asyncDep = setupResult;
            }
          } else {
            handleSetupResult(instance, setupResult, isSSR);
          }
        } else {
          finishComponentSetup(instance, isSSR);
        }
      }
      function handleSetupResult(instance, setupResult, isSSR) {
        if (isFunction$1(setupResult)) {
          if (instance.type.__ssrInlineRender) {
            instance.ssrRender = setupResult;
          } else {
            instance.render = setupResult;
          }
        } else if (isObject$1(setupResult)) {
          instance.setupState = proxyRefs(setupResult);
        } else
          ;
        finishComponentSetup(instance, isSSR);
      }
      let compile;
      function finishComponentSetup(instance, isSSR, skipOptions) {
        const Component = instance.type;
        if (!instance.render) {
          if (!isSSR && compile && !Component.render) {
            const template = Component.template || resolveMergedOptions(instance).template;
            if (template) {
              const { isCustomElement, compilerOptions } = instance.appContext.config;
              const { delimiters, compilerOptions: componentCompilerOptions } = Component;
              const finalCompilerOptions = extend(
                extend(
                  {
                    isCustomElement,
                    delimiters
                  },
                  compilerOptions
                ),
                componentCompilerOptions
              );
              Component.render = compile(template, finalCompilerOptions);
            }
          }
          instance.render = Component.render || NOOP;
        }
        {
          const reset = setCurrentInstance(instance);
          pauseTracking();
          try {
            applyOptions(instance);
          } finally {
            resetTracking();
            reset();
          }
        }
      }
      function getAttrsProxy(instance) {
        return instance.attrsProxy || (instance.attrsProxy = new Proxy(
          instance.attrs,
          {
            get(target, key) {
              track(instance, "get", "$attrs");
              return target[key];
            }
          }
        ));
      }
      function createSetupContext(instance) {
        const expose = (exposed) => {
          instance.exposed = exposed || {};
        };
        {
          return {
            get attrs() {
              return getAttrsProxy(instance);
            },
            slots: instance.slots,
            emit: instance.emit,
            expose
          };
        }
      }
      function getExposeProxy(instance) {
        if (instance.exposed) {
          return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
            get(target, key) {
              if (key in target) {
                return target[key];
              } else if (key in publicPropertiesMap) {
                return publicPropertiesMap[key](instance);
              }
            },
            has(target, key) {
              return key in target || key in publicPropertiesMap;
            }
          }));
        }
      }
      const classifyRE = /(?:^|[-_])(\w)/g;
      const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
      function getComponentName(Component, includeInferred = true) {
        return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
      }
      function formatComponentName(instance, Component, isRoot = false) {
        let name = getComponentName(Component);
        if (!name && Component.__file) {
          const match = Component.__file.match(/([^/\\]+)\.\w+$/);
          if (match) {
            name = match[1];
          }
        }
        if (!name && instance && instance.parent) {
          const inferFromRegistry = (registry) => {
            for (const key in registry) {
              if (registry[key] === Component) {
                return key;
              }
            }
          };
          name = inferFromRegistry(
            instance.components || instance.parent.type.components
          ) || inferFromRegistry(instance.appContext.components);
        }
        return name ? classify(name) : isRoot ? `App` : `Anonymous`;
      }
      function isClassComponent(value) {
        return isFunction$1(value) && "__vccOpts" in value;
      }
      const computed = (getterOrOptions, debugOptions) => {
        return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
      };
      function h(type, propsOrChildren, children) {
        const l2 = arguments.length;
        if (l2 === 2) {
          if (isObject$1(propsOrChildren) && !isArray$2(propsOrChildren)) {
            if (isVNode(propsOrChildren)) {
              return createVNode(type, null, [propsOrChildren]);
            }
            return createVNode(type, propsOrChildren);
          } else {
            return createVNode(type, null, propsOrChildren);
          }
        } else {
          if (l2 > 3) {
            children = Array.prototype.slice.call(arguments, 2);
          } else if (l2 === 3 && isVNode(children)) {
            children = [children];
          }
          return createVNode(type, propsOrChildren, children);
        }
      }
      const version = "3.4.13";
      const warn = NOOP;
      /**
      * @vue/runtime-dom v3.4.13
      * (c) 2018-present Yuxi (Evan) You and Vue contributors
      * @license MIT
      **/
      const svgNS = "http://www.w3.org/2000/svg";
      const mathmlNS = "http://www.w3.org/1998/Math/MathML";
      const doc = typeof document !== "undefined" ? document : null;
      const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
      const nodeOps = {
        insert: (child, parent, anchor) => {
          parent.insertBefore(child, anchor || null);
        },
        remove: (child) => {
          const parent = child.parentNode;
          if (parent) {
            parent.removeChild(child);
          }
        },
        createElement: (tag, namespace, is, props) => {
          const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : doc.createElement(tag, is ? { is } : void 0);
          if (tag === "select" && props && props.multiple != null) {
            el.setAttribute("multiple", props.multiple);
          }
          return el;
        },
        createText: (text) => doc.createTextNode(text),
        createComment: (text) => doc.createComment(text),
        setText: (node, text) => {
          node.nodeValue = text;
        },
        setElementText: (el, text) => {
          el.textContent = text;
        },
        parentNode: (node) => node.parentNode,
        nextSibling: (node) => node.nextSibling,
        querySelector: (selector) => doc.querySelector(selector),
        setScopeId(el, id) {
          el.setAttribute(id, "");
        },
        // __UNSAFE__
        // Reason: innerHTML.
        // Static content here can only come from compiled templates.
        // As long as the user only uses trusted templates, this is safe.
        insertStaticContent(content, parent, anchor, namespace, start, end) {
          const before = anchor ? anchor.previousSibling : parent.lastChild;
          if (start && (start === end || start.nextSibling)) {
            while (true) {
              parent.insertBefore(start.cloneNode(true), anchor);
              if (start === end || !(start = start.nextSibling))
                break;
            }
          } else {
            templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
            const template = templateContainer.content;
            if (namespace === "svg" || namespace === "mathml") {
              const wrapper = template.firstChild;
              while (wrapper.firstChild) {
                template.appendChild(wrapper.firstChild);
              }
              template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
          }
          return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
          ];
        }
      };
      const TRANSITION = "transition";
      const ANIMATION = "animation";
      const vtcKey = Symbol("_vtc");
      const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
      Transition.displayName = "Transition";
      const DOMTransitionPropsValidators = {
        name: String,
        type: String,
        css: {
          type: Boolean,
          default: true
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
      };
      Transition.props = /* @__PURE__ */ extend(
        {},
        BaseTransitionPropsValidators,
        DOMTransitionPropsValidators
      );
      const callHook = (hook, args = []) => {
        if (isArray$2(hook)) {
          hook.forEach((h2) => h2(...args));
        } else if (hook) {
          hook(...args);
        }
      };
      const hasExplicitCallback = (hook) => {
        return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
      };
      function resolveTransitionProps(rawProps) {
        const baseProps = {};
        for (const key in rawProps) {
          if (!(key in DOMTransitionPropsValidators)) {
            baseProps[key] = rawProps[key];
          }
        }
        if (rawProps.css === false) {
          return baseProps;
        }
        const {
          name = "v",
          type,
          duration,
          enterFromClass = `${name}-enter-from`,
          enterActiveClass = `${name}-enter-active`,
          enterToClass = `${name}-enter-to`,
          appearFromClass = enterFromClass,
          appearActiveClass = enterActiveClass,
          appearToClass = enterToClass,
          leaveFromClass = `${name}-leave-from`,
          leaveActiveClass = `${name}-leave-active`,
          leaveToClass = `${name}-leave-to`
        } = rawProps;
        const durations = normalizeDuration(duration);
        const enterDuration = durations && durations[0];
        const leaveDuration = durations && durations[1];
        const {
          onBeforeEnter,
          onEnter,
          onEnterCancelled,
          onLeave,
          onLeaveCancelled,
          onBeforeAppear = onBeforeEnter,
          onAppear = onEnter,
          onAppearCancelled = onEnterCancelled
        } = baseProps;
        const finishEnter = (el, isAppear, done) => {
          removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
          removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
          done && done();
        };
        const finishLeave = (el, done) => {
          el._isLeaving = false;
          removeTransitionClass(el, leaveFromClass);
          removeTransitionClass(el, leaveToClass);
          removeTransitionClass(el, leaveActiveClass);
          done && done();
        };
        const makeEnterHook = (isAppear) => {
          return (el, done) => {
            const hook = isAppear ? onAppear : onEnter;
            const resolve2 = () => finishEnter(el, isAppear, done);
            callHook(hook, [el, resolve2]);
            nextFrame(() => {
              removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
              addTransitionClass(el, isAppear ? appearToClass : enterToClass);
              if (!hasExplicitCallback(hook)) {
                whenTransitionEnds(el, type, enterDuration, resolve2);
              }
            });
          };
        };
        return extend(baseProps, {
          onBeforeEnter(el) {
            callHook(onBeforeEnter, [el]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
          },
          onBeforeAppear(el) {
            callHook(onBeforeAppear, [el]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
          },
          onEnter: makeEnterHook(false),
          onAppear: makeEnterHook(true),
          onLeave(el, done) {
            el._isLeaving = true;
            const resolve2 = () => finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(() => {
              if (!el._isLeaving) {
                return;
              }
              removeTransitionClass(el, leaveFromClass);
              addTransitionClass(el, leaveToClass);
              if (!hasExplicitCallback(onLeave)) {
                whenTransitionEnds(el, type, leaveDuration, resolve2);
              }
            });
            callHook(onLeave, [el, resolve2]);
          },
          onEnterCancelled(el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [el]);
          },
          onAppearCancelled(el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [el]);
          },
          onLeaveCancelled(el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [el]);
          }
        });
      }
      function normalizeDuration(duration) {
        if (duration == null) {
          return null;
        } else if (isObject$1(duration)) {
          return [NumberOf(duration.enter), NumberOf(duration.leave)];
        } else {
          const n2 = NumberOf(duration);
          return [n2, n2];
        }
      }
      function NumberOf(val) {
        const res = toNumber$1(val);
        return res;
      }
      function addTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
        (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
      }
      function removeTransitionClass(el, cls) {
        cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
        const _vtc = el[vtcKey];
        if (_vtc) {
          _vtc.delete(cls);
          if (!_vtc.size) {
            el[vtcKey] = void 0;
          }
        }
      }
      function nextFrame(cb) {
        requestAnimationFrame(() => {
          requestAnimationFrame(cb);
        });
      }
      let endId = 0;
      function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
        const id = el._endId = ++endId;
        const resolveIfNotStale = () => {
          if (id === el._endId) {
            resolve2();
          }
        };
        if (explicitTimeout) {
          return setTimeout(resolveIfNotStale, explicitTimeout);
        }
        const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
        if (!type) {
          return resolve2();
        }
        const endEvent = type + "end";
        let ended = 0;
        const end = () => {
          el.removeEventListener(endEvent, onEnd);
          resolveIfNotStale();
        };
        const onEnd = (e2) => {
          if (e2.target === el && ++ended >= propCount) {
            end();
          }
        };
        setTimeout(() => {
          if (ended < propCount) {
            end();
          }
        }, timeout + 1);
        el.addEventListener(endEvent, onEnd);
      }
      function getTransitionInfo(el, expectedType) {
        const styles = window.getComputedStyle(el);
        const getStyleProperties = (key) => (styles[key] || "").split(", ");
        const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
        const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
        const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
        const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
        const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
        const animationTimeout = getTimeout(animationDelays, animationDurations);
        let type = null;
        let timeout = 0;
        let propCount = 0;
        if (expectedType === TRANSITION) {
          if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
          }
        } else if (expectedType === ANIMATION) {
          if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
          }
        } else {
          timeout = Math.max(transitionTimeout, animationTimeout);
          type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
          propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
        }
        const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
          getStyleProperties(`${TRANSITION}Property`).toString()
        );
        return {
          type,
          timeout,
          propCount,
          hasTransform
        };
      }
      function getTimeout(delays, durations) {
        while (delays.length < durations.length) {
          delays = delays.concat(delays);
        }
        return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
      }
      function toMs(s2) {
        if (s2 === "auto")
          return 0;
        return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
      }
      function forceReflow() {
        return document.body.offsetHeight;
      }
      function patchClass(el, value, isSVG) {
        const transitionClasses = el[vtcKey];
        if (transitionClasses) {
          value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
        }
        if (value == null) {
          el.removeAttribute("class");
        } else if (isSVG) {
          el.setAttribute("class", value);
        } else {
          el.className = value;
        }
      }
      const vShowOldKey = Symbol("_vod");
      const vShow = {
        beforeMount(el, { value }, { transition }) {
          el[vShowOldKey] = el.style.display === "none" ? "" : el.style.display;
          if (transition && value) {
            transition.beforeEnter(el);
          } else {
            setDisplay(el, value);
          }
        },
        mounted(el, { value }, { transition }) {
          if (transition && value) {
            transition.enter(el);
          }
        },
        updated(el, { value, oldValue }, { transition }) {
          if (!value === !oldValue)
            return;
          if (transition) {
            if (value) {
              transition.beforeEnter(el);
              setDisplay(el, true);
              transition.enter(el);
            } else {
              transition.leave(el, () => {
                setDisplay(el, false);
              });
            }
          } else {
            setDisplay(el, value);
          }
        },
        beforeUnmount(el, { value }) {
          setDisplay(el, value);
        }
      };
      function setDisplay(el, value) {
        el.style.display = value ? el[vShowOldKey] : "none";
      }
      const CSS_VAR_TEXT = Symbol("");
      function patchStyle(el, prev, next) {
        const style2 = el.style;
        const currentDisplay = style2.display;
        const isCssString = isString$1(next);
        if (next && !isCssString) {
          if (prev && !isString$1(prev)) {
            for (const key in prev) {
              if (next[key] == null) {
                setStyle(style2, key, "");
              }
            }
          }
          for (const key in next) {
            setStyle(style2, key, next[key]);
          }
        } else {
          if (isCssString) {
            if (prev !== next) {
              const cssVarText = style2[CSS_VAR_TEXT];
              if (cssVarText) {
                next += ";" + cssVarText;
              }
              style2.cssText = next;
            }
          } else if (prev) {
            el.removeAttribute("style");
          }
        }
        if (vShowOldKey in el) {
          style2.display = currentDisplay;
        }
      }
      const importantRE = /\s*!important$/;
      function setStyle(style2, name, val) {
        if (isArray$2(val)) {
          val.forEach((v) => setStyle(style2, name, v));
        } else {
          if (val == null)
            val = "";
          if (name.startsWith("--")) {
            style2.setProperty(name, val);
          } else {
            const prefixed = autoPrefix(style2, name);
            if (importantRE.test(val)) {
              style2.setProperty(
                hyphenate(prefixed),
                val.replace(importantRE, ""),
                "important"
              );
            } else {
              style2[prefixed] = val;
            }
          }
        }
      }
      const prefixes = ["Webkit", "Moz", "ms"];
      const prefixCache = {};
      function autoPrefix(style2, rawName) {
        const cached = prefixCache[rawName];
        if (cached) {
          return cached;
        }
        let name = camelize(rawName);
        if (name !== "filter" && name in style2) {
          return prefixCache[rawName] = name;
        }
        name = capitalize(name);
        for (let i = 0; i < prefixes.length; i++) {
          const prefixed = prefixes[i] + name;
          if (prefixed in style2) {
            return prefixCache[rawName] = prefixed;
          }
        }
        return rawName;
      }
      const xlinkNS = "http://www.w3.org/1999/xlink";
      function patchAttr(el, key, value, isSVG, instance) {
        if (isSVG && key.startsWith("xlink:")) {
          if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
          } else {
            el.setAttributeNS(xlinkNS, key, value);
          }
        } else {
          const isBoolean2 = isSpecialBooleanAttr(key);
          if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
            el.removeAttribute(key);
          } else {
            el.setAttribute(key, isBoolean2 ? "" : value);
          }
        }
      }
      function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
        if (key === "innerHTML" || key === "textContent") {
          if (prevChildren) {
            unmountChildren(prevChildren, parentComponent, parentSuspense);
          }
          el[key] = value == null ? "" : value;
          return;
        }
        const tag = el.tagName;
        if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
        !tag.includes("-")) {
          el._value = value;
          const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
          const newValue = value == null ? "" : value;
          if (oldValue !== newValue) {
            el.value = newValue;
          }
          if (value == null) {
            el.removeAttribute(key);
          }
          return;
        }
        let needRemove = false;
        if (value === "" || value == null) {
          const type = typeof el[key];
          if (type === "boolean") {
            value = includeBooleanAttr(value);
          } else if (value == null && type === "string") {
            value = "";
            needRemove = true;
          } else if (type === "number") {
            value = 0;
            needRemove = true;
          }
        }
        try {
          el[key] = value;
        } catch (e2) {
        }
        needRemove && el.removeAttribute(key);
      }
      function addEventListener(el, event, handler, options) {
        el.addEventListener(event, handler, options);
      }
      function removeEventListener(el, event, handler, options) {
        el.removeEventListener(event, handler, options);
      }
      const veiKey = Symbol("_vei");
      function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
        const invokers = el[veiKey] || (el[veiKey] = {});
        const existingInvoker = invokers[rawName];
        if (nextValue && existingInvoker) {
          existingInvoker.value = nextValue;
        } else {
          const [name, options] = parseName(rawName);
          if (nextValue) {
            const invoker = invokers[rawName] = createInvoker(nextValue, instance);
            addEventListener(el, name, invoker, options);
          } else if (existingInvoker) {
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = void 0;
          }
        }
      }
      const optionsModifierRE = /(?:Once|Passive|Capture)$/;
      function parseName(name) {
        let options;
        if (optionsModifierRE.test(name)) {
          options = {};
          let m;
          while (m = name.match(optionsModifierRE)) {
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
          }
        }
        const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
        return [event, options];
      }
      let cachedNow = 0;
      const p = /* @__PURE__ */ Promise.resolve();
      const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
      function createInvoker(initialValue, instance) {
        const invoker = (e2) => {
          if (!e2._vts) {
            e2._vts = Date.now();
          } else if (e2._vts <= invoker.attached) {
            return;
          }
          callWithAsyncErrorHandling(
            patchStopImmediatePropagation(e2, invoker.value),
            instance,
            5,
            [e2]
          );
        };
        invoker.value = initialValue;
        invoker.attached = getNow();
        return invoker;
      }
      function patchStopImmediatePropagation(e2, value) {
        if (isArray$2(value)) {
          const originalStop = e2.stopImmediatePropagation;
          e2.stopImmediatePropagation = () => {
            originalStop.call(e2);
            e2._stopped = true;
          };
          return value.map((fn2) => (e22) => !e22._stopped && fn2 && fn2(e22));
        } else {
          return value;
        }
      }
      const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
      key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
      const patchProp = (el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
        const isSVG = namespace === "svg";
        if (key === "class") {
          patchClass(el, nextValue, isSVG);
        } else if (key === "style") {
          patchStyle(el, prevValue, nextValue);
        } else if (isOn(key)) {
          if (!isModelListener(key)) {
            patchEvent(el, key, prevValue, nextValue, parentComponent);
          }
        } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
          patchDOMProp(
            el,
            key,
            nextValue,
            prevChildren,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        } else {
          if (key === "true-value") {
            el._trueValue = nextValue;
          } else if (key === "false-value") {
            el._falseValue = nextValue;
          }
          patchAttr(el, key, nextValue, isSVG);
        }
      };
      function shouldSetAsProp(el, key, value, isSVG) {
        if (isSVG) {
          if (key === "innerHTML" || key === "textContent") {
            return true;
          }
          if (key in el && isNativeOn(key) && isFunction$1(value)) {
            return true;
          }
          return false;
        }
        if (key === "spellcheck" || key === "draggable" || key === "translate") {
          return false;
        }
        if (key === "form") {
          return false;
        }
        if (key === "list" && el.tagName === "INPUT") {
          return false;
        }
        if (key === "type" && el.tagName === "TEXTAREA") {
          return false;
        }
        if (key === "width" || key === "height") {
          const tag = el.tagName;
          if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
            return false;
          }
        }
        if (isNativeOn(key) && isString$1(value)) {
          return false;
        }
        return key in el;
      }
      const getModelAssigner = (vnode) => {
        const fn2 = vnode.props["onUpdate:modelValue"] || false;
        return isArray$2(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
      };
      function onCompositionStart(e2) {
        e2.target.composing = true;
      }
      function onCompositionEnd(e2) {
        const target = e2.target;
        if (target.composing) {
          target.composing = false;
          target.dispatchEvent(new Event("input"));
        }
      }
      const assignKey = Symbol("_assign");
      const vModelText = {
        created(el, { modifiers: { lazy, trim, number } }, vnode) {
          el[assignKey] = getModelAssigner(vnode);
          const castToNumber = number || vnode.props && vnode.props.type === "number";
          addEventListener(el, lazy ? "change" : "input", (e2) => {
            if (e2.target.composing)
              return;
            let domValue = el.value;
            if (trim) {
              domValue = domValue.trim();
            }
            if (castToNumber) {
              domValue = looseToNumber(domValue);
            }
            el[assignKey](domValue);
          });
          if (trim) {
            addEventListener(el, "change", () => {
              el.value = el.value.trim();
            });
          }
          if (!lazy) {
            addEventListener(el, "compositionstart", onCompositionStart);
            addEventListener(el, "compositionend", onCompositionEnd);
            addEventListener(el, "change", onCompositionEnd);
          }
        },
        // set value on mounted so it's after min/max for type="range"
        mounted(el, { value }) {
          el.value = value == null ? "" : value;
        },
        beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
          el[assignKey] = getModelAssigner(vnode);
          if (el.composing)
            return;
          const elValue = number || el.type === "number" ? looseToNumber(el.value) : el.value;
          const newValue = value == null ? "" : value;
          if (elValue === newValue) {
            return;
          }
          if (document.activeElement === el && el.type !== "range") {
            if (lazy) {
              return;
            }
            if (trim && el.value.trim() === newValue) {
              return;
            }
          }
          el.value = newValue;
        }
      };
      const systemModifiers = ["ctrl", "shift", "alt", "meta"];
      const modifierGuards = {
        stop: (e2) => e2.stopPropagation(),
        prevent: (e2) => e2.preventDefault(),
        self: (e2) => e2.target !== e2.currentTarget,
        ctrl: (e2) => !e2.ctrlKey,
        shift: (e2) => !e2.shiftKey,
        alt: (e2) => !e2.altKey,
        meta: (e2) => !e2.metaKey,
        left: (e2) => "button" in e2 && e2.button !== 0,
        middle: (e2) => "button" in e2 && e2.button !== 1,
        right: (e2) => "button" in e2 && e2.button !== 2,
        exact: (e2, modifiers) => systemModifiers.some((m) => e2[`${m}Key`] && !modifiers.includes(m))
      };
      const withModifiers = (fn2, modifiers) => {
        const cache = fn2._withMods || (fn2._withMods = {});
        const cacheKey = modifiers.join(".");
        return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
          for (let i = 0; i < modifiers.length; i++) {
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers))
              return;
          }
          return fn2(event, ...args);
        });
      };
      const keyNames = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
      };
      const withKeys = (fn2, modifiers) => {
        const cache = fn2._withKeys || (fn2._withKeys = {});
        const cacheKey = modifiers.join(".");
        return cache[cacheKey] || (cache[cacheKey] = (event) => {
          if (!("key" in event)) {
            return;
          }
          const eventKey = hyphenate(event.key);
          if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
            return fn2(event);
          }
        });
      };
      const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
      let renderer;
      function ensureRenderer() {
        return renderer || (renderer = createRenderer(rendererOptions));
      }
      const render = (...args) => {
        ensureRenderer().render(...args);
      };
      const createApp = (...args) => {
        const app = ensureRenderer().createApp(...args);
        const { mount } = app;
        app.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (!container)
            return;
          const component = app._component;
          if (!isFunction$1(component) && !component.render && !component.template) {
            component.template = container.innerHTML;
          }
          container.innerHTML = "";
          const proxy = mount(container, false, resolveRootNamespace(container));
          if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
          }
          return proxy;
        };
        return app;
      };
      function resolveRootNamespace(container) {
        if (container instanceof SVGElement) {
          return "svg";
        }
        if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
          return "mathml";
        }
      }
      function normalizeContainer(container) {
        if (isString$1(container)) {
          const res = document.querySelector(container);
          return res;
        }
        return container;
      }
      const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])`;
      const isVisible = (element) => {
        const computed2 = getComputedStyle(element);
        return computed2.position === "fixed" ? false : element.offsetParent !== null;
      };
      const obtainAllFocusableElements$1 = (element) => {
        return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter((item) => isFocusable(item) && isVisible(item));
      };
      const isFocusable = (element) => {
        if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
          return true;
        }
        if (element.disabled) {
          return false;
        }
        switch (element.nodeName) {
          case "A": {
            return !!element.href && element.rel !== "ignore";
          }
          case "INPUT": {
            return !(element.type === "hidden" || element.type === "file");
          }
          case "BUTTON":
          case "SELECT":
          case "TEXTAREA": {
            return true;
          }
          default: {
            return false;
          }
        }
      };
      const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
        const handleEvent = (event) => {
          const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
          if (checkForDefaultPrevented === false || !shouldPrevent) {
            return oursHandler == null ? void 0 : oursHandler(event);
          }
        };
        return handleEvent;
      };
      var _a;
      const isClient = typeof window !== "undefined";
      const isString = (val) => typeof val === "string";
      const noop = () => {
      };
      const isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
      function resolveUnref(r2) {
        return typeof r2 === "function" ? r2() : unref(r2);
      }
      function identity$1(arg) {
        return arg;
      }
      function tryOnScopeDispose(fn2) {
        if (getCurrentScope()) {
          onScopeDispose(fn2);
          return true;
        }
        return false;
      }
      function tryOnMounted(fn2, sync = true) {
        if (getCurrentInstance())
          onMounted(fn2);
        else if (sync)
          fn2();
        else
          nextTick(fn2);
      }
      function useTimeoutFn(cb, interval, options = {}) {
        const {
          immediate = true
        } = options;
        const isPending = ref(false);
        let timer = null;
        function clear2() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function stop() {
          isPending.value = false;
          clear2();
        }
        function start(...args) {
          clear2();
          isPending.value = true;
          timer = setTimeout(() => {
            isPending.value = false;
            timer = null;
            cb(...args);
          }, resolveUnref(interval));
        }
        if (immediate) {
          isPending.value = true;
          if (isClient)
            start();
        }
        tryOnScopeDispose(stop);
        return {
          isPending: readonly(isPending),
          start,
          stop
        };
      }
      function unrefElement(elRef) {
        var _a2;
        const plain = resolveUnref(elRef);
        return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
      }
      const defaultWindow = isClient ? window : void 0;
      function useEventListener(...args) {
        let target;
        let events;
        let listeners;
        let options;
        if (isString(args[0]) || Array.isArray(args[0])) {
          [events, listeners, options] = args;
          target = defaultWindow;
        } else {
          [target, events, listeners, options] = args;
        }
        if (!target)
          return noop;
        if (!Array.isArray(events))
          events = [events];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register = (el, event, listener, options2) => {
          el.addEventListener(event, listener, options2);
          return () => el.removeEventListener(event, listener, options2);
        };
        const stopWatch = watch(() => [unrefElement(target), resolveUnref(options)], ([el, options2]) => {
          cleanup();
          if (!el)
            return;
          cleanups.push(...events.flatMap((event) => {
            return listeners.map((listener) => register(el, event, listener, options2));
          }));
        }, { immediate: true, flush: "post" });
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose(stop);
        return stop;
      }
      let _iOSWorkaround = false;
      function onClickOutside(target, handler, options = {}) {
        const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
        if (!window2)
          return;
        if (isIOS && !_iOSWorkaround) {
          _iOSWorkaround = true;
          Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop));
        }
        let shouldListen = true;
        const shouldIgnore = (event) => {
          return ignore.some((target2) => {
            if (typeof target2 === "string") {
              return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
            } else {
              const el = unrefElement(target2);
              return el && (event.target === el || event.composedPath().includes(el));
            }
          });
        };
        const listener = (event) => {
          const el = unrefElement(target);
          if (!el || el === event.target || event.composedPath().includes(el))
            return;
          if (event.detail === 0)
            shouldListen = !shouldIgnore(event);
          if (!shouldListen) {
            shouldListen = true;
            return;
          }
          handler(event);
        };
        const cleanup = [
          useEventListener(window2, "click", listener, { passive: true, capture }),
          useEventListener(window2, "pointerdown", (e2) => {
            const el = unrefElement(target);
            if (el)
              shouldListen = !e2.composedPath().includes(el) && !shouldIgnore(e2);
          }, { passive: true }),
          detectIframe && useEventListener(window2, "blur", (event) => {
            var _a2;
            const el = unrefElement(target);
            if (((_a2 = window2.document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
              handler(event);
          })
        ].filter(Boolean);
        const stop = () => cleanup.forEach((fn2) => fn2());
        return stop;
      }
      function useSupported(callback, sync = false) {
        const isSupported = ref();
        const update = () => isSupported.value = Boolean(callback());
        update();
        tryOnMounted(update, sync);
        return isSupported;
      }
      const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      const globalKey = "__vueuse_ssr_handlers__";
      _global[globalKey] = _global[globalKey] || {};
      var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
      var __hasOwnProp$g = Object.prototype.hasOwnProperty;
      var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
      var __objRest$2 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$g)
          for (var prop of __getOwnPropSymbols$g(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function useResizeObserver(target, callback, options = {}) {
        const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
        let observer;
        const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = watch(() => unrefElement(target), (el) => {
          cleanup();
          if (isSupported.value && window2 && el) {
            observer = new ResizeObserver(callback);
            observer.observe(el, observerOptions);
          }
        }, { immediate: true, flush: "post" });
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          stop
        };
      }
      var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
      var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
      var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
      var __objRest$1 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$8)
          for (var prop of __getOwnPropSymbols$8(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function useMutationObserver(target, callback, options = {}) {
        const _a2 = options, { window: window2 = defaultWindow } = _a2, mutationOptions = __objRest$1(_a2, ["window"]);
        let observer;
        const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const stopWatch = watch(() => unrefElement(target), (el) => {
          cleanup();
          if (isSupported.value && window2 && el) {
            observer = new MutationObserver(callback);
            observer.observe(el, mutationOptions);
          }
        }, { immediate: true });
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          stop
        };
      }
      var SwipeDirection;
      (function(SwipeDirection2) {
        SwipeDirection2["UP"] = "UP";
        SwipeDirection2["RIGHT"] = "RIGHT";
        SwipeDirection2["DOWN"] = "DOWN";
        SwipeDirection2["LEFT"] = "LEFT";
        SwipeDirection2["NONE"] = "NONE";
      })(SwipeDirection || (SwipeDirection = {}));
      var __defProp2 = Object.defineProperty;
      var __getOwnPropSymbols = Object.getOwnPropertySymbols;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __propIsEnum = Object.prototype.propertyIsEnumerable;
      var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues = (a, b) => {
        for (var prop in b || (b = {}))
          if (__hasOwnProp.call(b, prop))
            __defNormalProp2(a, prop, b[prop]);
        if (__getOwnPropSymbols)
          for (var prop of __getOwnPropSymbols(b)) {
            if (__propIsEnum.call(b, prop))
              __defNormalProp2(a, prop, b[prop]);
          }
        return a;
      };
      const _TransitionPresets = {
        easeInSine: [0.12, 0, 0.39, 0],
        easeOutSine: [0.61, 1, 0.88, 1],
        easeInOutSine: [0.37, 0, 0.63, 1],
        easeInQuad: [0.11, 0, 0.5, 0],
        easeOutQuad: [0.5, 1, 0.89, 1],
        easeInOutQuad: [0.45, 0, 0.55, 1],
        easeInCubic: [0.32, 0, 0.67, 0],
        easeOutCubic: [0.33, 1, 0.68, 1],
        easeInOutCubic: [0.65, 0, 0.35, 1],
        easeInQuart: [0.5, 0, 0.75, 0],
        easeOutQuart: [0.25, 1, 0.5, 1],
        easeInOutQuart: [0.76, 0, 0.24, 1],
        easeInQuint: [0.64, 0, 0.78, 0],
        easeOutQuint: [0.22, 1, 0.36, 1],
        easeInOutQuint: [0.83, 0, 0.17, 1],
        easeInExpo: [0.7, 0, 0.84, 0],
        easeOutExpo: [0.16, 1, 0.3, 1],
        easeInOutExpo: [0.87, 0, 0.13, 1],
        easeInCirc: [0.55, 0, 1, 0.45],
        easeOutCirc: [0, 0.55, 0.45, 1],
        easeInOutCirc: [0.85, 0, 0.15, 1],
        easeInBack: [0.36, 0, 0.66, -0.56],
        easeOutBack: [0.34, 1.56, 0.64, 1],
        easeInOutBack: [0.68, -0.6, 0.32, 1.6]
      };
      __spreadValues({
        linear: identity$1
      }, _TransitionPresets);
      const isFirefox = () => isClient && /firefox/i.test(window.navigator.userAgent);
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      const freeGlobal$1 = freeGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal$1 || freeSelf || Function("return this")();
      const root$1 = root;
      var Symbol$1 = root$1.Symbol;
      const Symbol$2 = Symbol$1;
      var objectProto$b = Object.prototype;
      var hasOwnProperty$8 = objectProto$b.hasOwnProperty;
      var nativeObjectToString$1 = objectProto$b.toString;
      var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty$8.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
          value[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e2) {
        }
        var result = nativeObjectToString$1.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$1] = tag;
          } else {
            delete value[symToStringTag$1];
          }
        }
        return result;
      }
      var objectProto$a = Object.prototype;
      var nativeObjectToString = objectProto$a.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var symbolTag$1 = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      var isArray = Array.isArray;
      const isArray$1 = isArray;
      var INFINITY$2 = 1 / 0;
      var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray$1(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
      }
      var reWhitespace = /\s/;
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var reTrimStart = /^\s+/;
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      var INFINITY$1 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY$1 || value === -INFINITY$1) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result = toFinite(value), remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }
      function identity(value) {
        return value;
      }
      var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      var coreJsData = root$1["__core-js_shared__"];
      const coreJsData$1 = coreJsData;
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var funcProto$1 = Function.prototype;
      var funcToString$1 = funcProto$1.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString$1.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype, objectProto$9 = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      var WeakMap$1 = getNative(root$1, "WeakMap");
      const WeakMap$2 = WeakMap$1;
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER$1 : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      var objectProto$8 = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$8;
        return value === proto;
      }
      function baseTimes(n2, iteratee) {
        var index = -1, result = Array(n2);
        while (++index < n2) {
          result[index] = iteratee(index);
        }
        return result;
      }
      var argsTag$2 = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag$2;
      }
      var objectProto$7 = Object.prototype;
      var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
      var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$6.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
      };
      const isArguments$1 = isArguments;
      function stubFalse() {
        return false;
      }
      var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
      var Buffer$1 = moduleExports$1 ? root$1.Buffer : void 0;
      var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      const isBuffer$1 = isBuffer;
      var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
      var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal$1.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      const nodeUtil$1 = nodeUtil;
      var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      const isTypedArray$1 = isTypedArray;
      var objectProto$6 = Object.prototype;
      var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty$5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      var nativeKeys = overArg(Object.keys, Object);
      const nativeKeys$1 = nativeKeys;
      var objectProto$5 = Object.prototype;
      var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys$1(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty$4.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
      function isKey(value, object) {
        if (isArray$1(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      var nativeCreate = getNative(Object, "create");
      const nativeCreate$1 = nativeCreate;
      function hashClear() {
        this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
      var objectProto$4 = Object.prototype;
      var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate$1) {
          var result = data[key];
          return result === HASH_UNDEFINED$2 ? void 0 : result;
        }
        return hasOwnProperty$3.call(data, key) ? data[key] : void 0;
      }
      var objectProto$3 = Object.prototype;
      var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$2.call(data, key);
      }
      var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
        return this;
      }
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      var Map$1 = getNative(root$1, "Map");
      const Map$2 = Map$1;
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map$2 || ListCache)(),
          "string": new Hash()
        };
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      var FUNC_ERROR_TEXT$1 = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$1);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result.cache;
        return result;
      }
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string) {
        var result = [];
        if (string.charCodeAt(0) === 46) {
          result.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      const stringToPath$1 = stringToPath;
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      function castPath(value, object) {
        if (isArray$1(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath$1(toString(value));
      }
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : void 0;
      }
      function get(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray$1(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function stubArray() {
        return [];
      }
      var objectProto$2 = Object.prototype;
      var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      const getSymbols$1 = getSymbols;
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols$1);
      }
      var DataView = getNative(root$1, "DataView");
      const DataView$1 = DataView;
      var Promise$1 = getNative(root$1, "Promise");
      const Promise$2 = Promise$1;
      var Set$1 = getNative(root$1, "Set");
      const Set$2 = Set$1;
      var mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]";
      var dataViewTag$1 = "[object DataView]";
      var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
      var getTag = baseGetTag;
      if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$1 || Map$2 && getTag(new Map$2()) != mapTag$1 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$1 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag$1;
              case mapCtorString:
                return mapTag$1;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag$1;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      const getTag$1 = getTag;
      var Uint8Array$1 = root$1.Uint8Array;
      const Uint8Array$2 = Uint8Array$1;
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack2.get(array);
        var othStacked = stack2.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
        stack2.set(array, other);
        stack2.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack2) : customizer(arrValue, othValue, index, array, other, stack2);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
            result = false;
            break;
          }
        }
        stack2["delete"](array);
        stack2["delete"](other);
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
      var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
      var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack2.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG$2;
            stack2.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
            stack2["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      var COMPARE_PARTIAL_FLAG$3 = 1;
      var objectProto$1 = Object.prototype;
      var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack2.get(object);
        var othStacked = stack2.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result = true;
        stack2.set(object, other);
        stack2.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack2["delete"](object);
        stack2["delete"](other);
        return result;
      }
      var COMPARE_PARTIAL_FLAG$2 = 1;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
        var objIsArr = isArray$1(object), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer$1(object)) {
          if (!isBuffer$1(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack2 || (stack2 = new Stack());
          return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack2 || (stack2 = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack2 || (stack2 = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
      }
      function baseIsEqual(value, other, bitmask, customizer, stack2) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
      }
      var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            var stack2 = new Stack();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack2);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function getMatchData(object) {
        var result = keys(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object) || isArguments$1(object));
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      var now = function() {
        return root$1.Date.now();
      };
      const now$1 = now;
      var FUNC_ERROR_TEXT = "Expected a function";
      var nativeMax$1 = Math.max, nativeMin$1 = Math.min;
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax$1(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now$1();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now$1());
        }
        function debounced() {
          var time = now$1(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var nativeMax = Math.max, nativeMin = Math.min;
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== void 0) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, baseIteratee(predicate), index, true);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
        while (++index < length) {
          var pair = pairs[index];
          result[pair[0]] = pair[1];
        }
        return result;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isNil(value) {
        return value == null;
      }
      function isUndefined$1(value) {
        return value === void 0;
      }
      const isUndefined = (val) => val === void 0;
      const isBoolean = (val) => typeof val === "boolean";
      const isNumber = (val) => typeof val === "number";
      const isEmpty = (val) => !val && val !== 0 || isArray$2(val) && val.length === 0 || isObject$1(val) && !Object.keys(val).length;
      const isElement = (e2) => {
        if (typeof Element === "undefined")
          return false;
        return e2 instanceof Element;
      };
      const isStringNumber = (val) => {
        if (!isString$1(val)) {
          return false;
        }
        return !Number.isNaN(Number(val));
      };
      const escapeStringRegexp = (string = "") => string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      const keysOf = (arr) => Object.keys(arr);
      class ElementPlusError extends Error {
        constructor(m) {
          super(m);
          this.name = "ElementPlusError";
        }
      }
      function throwError(scope, m) {
        throw new ElementPlusError(`[${scope}] ${m}`);
      }
      function debugWarn(scope, message) {
      }
      const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
      const hasClass = (el, cls) => {
        if (!el || !cls)
          return false;
        if (cls.includes(" "))
          throw new Error("className should not contain space.");
        return el.classList.contains(cls);
      };
      const addClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.add(...classNameToArray(cls));
      };
      const removeClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.remove(...classNameToArray(cls));
      };
      const getStyle = (element, styleName) => {
        var _a2;
        if (!isClient || !element || !styleName)
          return "";
        let key = camelize(styleName);
        if (key === "float")
          key = "cssFloat";
        try {
          const style2 = element.style[key];
          if (style2)
            return style2;
          const computed2 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element, "");
          return computed2 ? computed2[key] : "";
        } catch (e2) {
          return element.style[key];
        }
      };
      function addUnit(value, defaultUnit = "px") {
        if (!value)
          return "";
        if (isNumber(value) || isStringNumber(value)) {
          return `${value}${defaultUnit}`;
        } else if (isString$1(value)) {
          return value;
        }
      }
      let scrollBarWidth;
      const getScrollBarWidth = (namespace) => {
        var _a2;
        if (!isClient)
          return 0;
        if (scrollBarWidth !== void 0)
          return scrollBarWidth;
        const outer = document.createElement("div");
        outer.className = `${namespace}-scrollbar__wrap`;
        outer.style.visibility = "hidden";
        outer.style.width = "100px";
        outer.style.position = "absolute";
        outer.style.top = "-9999px";
        document.body.appendChild(outer);
        const widthNoScroll = outer.offsetWidth;
        outer.style.overflow = "scroll";
        const inner = document.createElement("div");
        inner.style.width = "100%";
        outer.appendChild(inner);
        const widthWithScroll = inner.offsetWidth;
        (_a2 = outer.parentNode) == null ? void 0 : _a2.removeChild(outer);
        scrollBarWidth = widthNoScroll - widthWithScroll;
        return scrollBarWidth;
      };
      function scrollIntoView(container, selected) {
        if (!isClient)
          return;
        if (!selected) {
          container.scrollTop = 0;
          return;
        }
        const offsetParents = [];
        let pointer = selected.offsetParent;
        while (pointer !== null && container !== pointer && container.contains(pointer)) {
          offsetParents.push(pointer);
          pointer = pointer.offsetParent;
        }
        const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
        const bottom = top + selected.offsetHeight;
        const viewRectTop = container.scrollTop;
        const viewRectBottom = viewRectTop + container.clientHeight;
        if (top < viewRectTop) {
          container.scrollTop = top;
        } else if (bottom > viewRectBottom) {
          container.scrollTop = bottom - container.clientHeight;
        }
      }
      /*! Element Plus Icons Vue v2.3.1 */
      var arrow_down_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowDown",
        __name: "arrow-down",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
            })
          ]));
        }
      });
      var arrow_down_default = arrow_down_vue_vue_type_script_setup_true_lang_default;
      var arrow_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowLeft",
        __name: "arrow-left",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
            })
          ]));
        }
      });
      var arrow_left_default = arrow_left_vue_vue_type_script_setup_true_lang_default;
      var arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowRight",
        __name: "arrow-right",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
            })
          ]));
        }
      });
      var arrow_right_default = arrow_right_vue_vue_type_script_setup_true_lang_default;
      var arrow_up_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowUp",
        __name: "arrow-up",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
            })
          ]));
        }
      });
      var arrow_up_default = arrow_up_vue_vue_type_script_setup_true_lang_default;
      var calendar_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Calendar",
        __name: "calendar",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64"
            })
          ]));
        }
      });
      var calendar_default = calendar_vue_vue_type_script_setup_true_lang_default;
      var circle_check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleCheck",
        __name: "circle-check",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
            })
          ]));
        }
      });
      var circle_check_default = circle_check_vue_vue_type_script_setup_true_lang_default;
      var circle_close_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleCloseFilled",
        __name: "circle-close-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
            })
          ]));
        }
      });
      var circle_close_filled_default = circle_close_filled_vue_vue_type_script_setup_true_lang_default;
      var circle_close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleClose",
        __name: "circle-close",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
            }),
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            })
          ]));
        }
      });
      var circle_close_default = circle_close_vue_vue_type_script_setup_true_lang_default;
      var clock_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Clock",
        __name: "clock",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32"
            }),
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32"
            })
          ]));
        }
      });
      var clock_default = clock_vue_vue_type_script_setup_true_lang_default;
      var close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Close",
        __name: "close",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
            })
          ]));
        }
      });
      var close_default = close_vue_vue_type_script_setup_true_lang_default;
      var d_arrow_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "DArrowLeft",
        __name: "d-arrow-left",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
            })
          ]));
        }
      });
      var d_arrow_left_default = d_arrow_left_vue_vue_type_script_setup_true_lang_default;
      var d_arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "DArrowRight",
        __name: "d-arrow-right",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688m-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
            })
          ]));
        }
      });
      var d_arrow_right_default = d_arrow_right_vue_vue_type_script_setup_true_lang_default;
      var hide_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Hide",
        __name: "hide",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
            }),
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
            })
          ]));
        }
      });
      var hide_default = hide_vue_vue_type_script_setup_true_lang_default;
      var info_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "InfoFilled",
        __name: "info-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
            })
          ]));
        }
      });
      var info_filled_default = info_filled_vue_vue_type_script_setup_true_lang_default;
      var loading_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Loading",
        __name: "loading",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
            })
          ]));
        }
      });
      var loading_default = loading_vue_vue_type_script_setup_true_lang_default;
      var success_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "SuccessFilled",
        __name: "success-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
            })
          ]));
        }
      });
      var success_filled_default = success_filled_vue_vue_type_script_setup_true_lang_default;
      var view_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "View",
        __name: "view",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
            })
          ]));
        }
      });
      var view_default = view_vue_vue_type_script_setup_true_lang_default;
      var warning_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "WarningFilled",
        __name: "warning-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createBaseVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
            })
          ]));
        }
      });
      var warning_filled_default = warning_filled_vue_vue_type_script_setup_true_lang_default;
      const epPropKey = "__epPropKey";
      const definePropType = (val) => val;
      const isEpProp = (val) => isObject$1(val) && !!val[epPropKey];
      const buildProp = (prop, key) => {
        if (!isObject$1(prop) || isEpProp(prop))
          return prop;
        const { values, required, default: defaultValue, type, validator } = prop;
        const _validator = values || validator ? (val) => {
          let valid = false;
          let allowedValues = [];
          if (values) {
            allowedValues = Array.from(values);
            if (hasOwn(prop, "default")) {
              allowedValues.push(defaultValue);
            }
            valid || (valid = allowedValues.includes(val));
          }
          if (validator)
            valid || (valid = validator(val));
          if (!valid && allowedValues.length > 0) {
            const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
            warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
          }
          return valid;
        } : void 0;
        const epProp = {
          type,
          required: !!required,
          validator: _validator,
          [epPropKey]: true
        };
        if (hasOwn(prop, "default"))
          epProp.default = defaultValue;
        return epProp;
      };
      const buildProps = (props) => fromPairs(Object.entries(props).map(([key, option]) => [
        key,
        buildProp(option, key)
      ]));
      const iconPropType = definePropType([
        String,
        Object,
        Function
      ]);
      const CloseComponents = {
        Close: close_default
      };
      const TypeComponents = {
        Close: close_default,
        SuccessFilled: success_filled_default,
        InfoFilled: info_filled_default,
        WarningFilled: warning_filled_default,
        CircleCloseFilled: circle_close_filled_default
      };
      const TypeComponentsMap = {
        success: success_filled_default,
        warning: warning_filled_default,
        error: circle_close_filled_default,
        info: info_filled_default
      };
      const ValidateComponentsMap = {
        validating: loading_default,
        success: circle_check_default,
        error: circle_close_default
      };
      const withInstall = (main, extra) => {
        main.install = (app) => {
          for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
            app.component(comp.name, comp);
          }
        };
        if (extra) {
          for (const [key, comp] of Object.entries(extra)) {
            main[key] = comp;
          }
        }
        return main;
      };
      const withNoopInstall = (component) => {
        component.install = NOOP;
        return component;
      };
      const composeRefs = (...refs) => {
        return (el) => {
          refs.forEach((ref2) => {
            if (isFunction$1(ref2)) {
              ref2(el);
            } else {
              ref2.value = el;
            }
          });
        };
      };
      const EVENT_CODE = {
        tab: "Tab",
        enter: "Enter",
        space: "Space",
        left: "ArrowLeft",
        up: "ArrowUp",
        right: "ArrowRight",
        down: "ArrowDown",
        esc: "Escape",
        delete: "Delete",
        backspace: "Backspace",
        numpadEnter: "NumpadEnter",
        pageUp: "PageUp",
        pageDown: "PageDown",
        home: "Home",
        end: "End"
      };
      const datePickTypes = [
        "year",
        "month",
        "date",
        "dates",
        "week",
        "datetime",
        "datetimerange",
        "daterange",
        "monthrange"
      ];
      const UPDATE_MODEL_EVENT = "update:modelValue";
      const CHANGE_EVENT = "change";
      const componentSizes = ["", "default", "small", "large"];
      const isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
      var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
        PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
        PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
        PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
        PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
        PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
        PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
        PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
        PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
        PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
        PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
        PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
        return PatchFlags2;
      })(PatchFlags || {});
      const castArray = (arr) => {
        if (!arr && arr !== 0)
          return [];
        return Array.isArray(arr) ? arr : [arr];
      };
      const isKorean = (text) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text);
      const mutable = (val) => val;
      const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
      const LISTENER_PREFIX = /^on[A-Z]/;
      const useAttrs = (params = {}) => {
        const { excludeListeners = false, excludeKeys } = params;
        const allExcludeKeys = computed(() => {
          return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
        });
        const instance = getCurrentInstance();
        if (!instance) {
          return computed(() => ({}));
        }
        return computed(() => {
          var _a2;
          return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
        });
      };
      const useDeprecated = ({ from, replacement, scope, version: version2, ref: ref2, type = "API" }, condition) => {
        watch(() => unref(condition), (val) => {
        }, {
          immediate: true
        });
      };
      const useDraggable = (targetRef, dragRef, draggable) => {
        let transform = {
          offsetX: 0,
          offsetY: 0
        };
        const onMousedown = (e2) => {
          const downX = e2.clientX;
          const downY = e2.clientY;
          const { offsetX, offsetY } = transform;
          const targetRect = targetRef.value.getBoundingClientRect();
          const targetLeft = targetRect.left;
          const targetTop = targetRect.top;
          const targetWidth = targetRect.width;
          const targetHeight = targetRect.height;
          const clientWidth = document.documentElement.clientWidth;
          const clientHeight = document.documentElement.clientHeight;
          const minLeft = -targetLeft + offsetX;
          const minTop = -targetTop + offsetY;
          const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
          const maxTop = clientHeight - targetTop - targetHeight + offsetY;
          const onMousemove = (e22) => {
            const moveX = Math.min(Math.max(offsetX + e22.clientX - downX, minLeft), maxLeft);
            const moveY = Math.min(Math.max(offsetY + e22.clientY - downY, minTop), maxTop);
            transform = {
              offsetX: moveX,
              offsetY: moveY
            };
            if (targetRef.value) {
              targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
            }
          };
          const onMouseup = () => {
            document.removeEventListener("mousemove", onMousemove);
            document.removeEventListener("mouseup", onMouseup);
          };
          document.addEventListener("mousemove", onMousemove);
          document.addEventListener("mouseup", onMouseup);
        };
        const onDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.addEventListener("mousedown", onMousedown);
          }
        };
        const offDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.removeEventListener("mousedown", onMousedown);
          }
        };
        onMounted(() => {
          watchEffect(() => {
            if (draggable.value) {
              onDraggable();
            } else {
              offDraggable();
            }
          });
        });
        onBeforeUnmount(() => {
          offDraggable();
        });
      };
      var English = {
        name: "en",
        el: {
          colorpicker: {
            confirm: "OK",
            clear: "Clear",
            defaultLabel: "color picker",
            description: "current color is {color}. press enter to select a new color."
          },
          datepicker: {
            now: "Now",
            today: "Today",
            cancel: "Cancel",
            clear: "Clear",
            confirm: "OK",
            dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
            monthTablePrompt: "Use the arrow keys and enter to select the month",
            yearTablePrompt: "Use the arrow keys and enter to select the year",
            selectedDate: "Selected date",
            selectDate: "Select date",
            selectTime: "Select time",
            startDate: "Start Date",
            startTime: "Start Time",
            endDate: "End Date",
            endTime: "End Time",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            year: "",
            month1: "January",
            month2: "February",
            month3: "March",
            month4: "April",
            month5: "May",
            month6: "June",
            month7: "July",
            month8: "August",
            month9: "September",
            month10: "October",
            month11: "November",
            month12: "December",
            week: "week",
            weeks: {
              sun: "Sun",
              mon: "Mon",
              tue: "Tue",
              wed: "Wed",
              thu: "Thu",
              fri: "Fri",
              sat: "Sat"
            },
            weeksFull: {
              sun: "Sunday",
              mon: "Monday",
              tue: "Tuesday",
              wed: "Wednesday",
              thu: "Thursday",
              fri: "Friday",
              sat: "Saturday"
            },
            months: {
              jan: "Jan",
              feb: "Feb",
              mar: "Mar",
              apr: "Apr",
              may: "May",
              jun: "Jun",
              jul: "Jul",
              aug: "Aug",
              sep: "Sep",
              oct: "Oct",
              nov: "Nov",
              dec: "Dec"
            }
          },
          inputNumber: {
            decrease: "decrease number",
            increase: "increase number"
          },
          select: {
            loading: "Loading",
            noMatch: "No matching data",
            noData: "No data",
            placeholder: "Select"
          },
          dropdown: {
            toggleDropdown: "Toggle Dropdown"
          },
          cascader: {
            noMatch: "No matching data",
            loading: "Loading",
            placeholder: "Select",
            noData: "No data"
          },
          pagination: {
            goto: "Go to",
            pagesize: "/page",
            total: "Total {total}",
            pageClassifier: "",
            page: "Page",
            prev: "Go to previous page",
            next: "Go to next page",
            currentPage: "page {pager}",
            prevPages: "Previous {pager} pages",
            nextPages: "Next {pager} pages",
            deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
          },
          dialog: {
            close: "Close this dialog"
          },
          drawer: {
            close: "Close this dialog"
          },
          messagebox: {
            title: "Message",
            confirm: "OK",
            cancel: "Cancel",
            error: "Illegal input",
            close: "Close this dialog"
          },
          upload: {
            deleteTip: "press delete to remove",
            delete: "Delete",
            preview: "Preview",
            continue: "Continue"
          },
          slider: {
            defaultLabel: "slider between {min} and {max}",
            defaultRangeStartLabel: "pick start value",
            defaultRangeEndLabel: "pick end value"
          },
          table: {
            emptyText: "No Data",
            confirmFilter: "Confirm",
            resetFilter: "Reset",
            clearFilter: "All",
            sumText: "Sum"
          },
          tour: {
            next: "Next",
            previous: "Previous",
            finish: "Finish"
          },
          tree: {
            emptyText: "No Data"
          },
          transfer: {
            noMatch: "No matching data",
            noData: "No data",
            titles: ["List 1", "List 2"],
            filterPlaceholder: "Enter keyword",
            noCheckedFormat: "{total} items",
            hasCheckedFormat: "{checked}/{total} checked"
          },
          image: {
            error: "FAILED"
          },
          pageHeader: {
            title: "Back"
          },
          popconfirm: {
            confirmButtonText: "Yes",
            cancelButtonText: "No"
          }
        }
      };
      const buildTranslator = (locale) => (path, option) => translate(path, option, unref(locale));
      const translate = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_2, key) => {
        var _a2;
        return `${(_a2 = option == null ? void 0 : option[key]) != null ? _a2 : `{${key}}`}`;
      });
      const buildLocaleContext = (locale) => {
        const lang = computed(() => unref(locale).name);
        const localeRef = isRef(locale) ? locale : ref(locale);
        return {
          lang,
          locale: localeRef,
          t: buildTranslator(locale)
        };
      };
      const localeContextKey = Symbol("localeContextKey");
      const useLocale = (localeOverrides) => {
        const locale = localeOverrides || inject(localeContextKey, ref());
        return buildLocaleContext(computed(() => locale.value || English));
      };
      const defaultNamespace = "el";
      const statePrefix = "is-";
      const _bem = (namespace, block, blockSuffix, element, modifier) => {
        let cls = `${namespace}-${block}`;
        if (blockSuffix) {
          cls += `-${blockSuffix}`;
        }
        if (element) {
          cls += `__${element}`;
        }
        if (modifier) {
          cls += `--${modifier}`;
        }
        return cls;
      };
      const namespaceContextKey = Symbol("namespaceContextKey");
      const useGetDerivedNamespace = (namespaceOverrides) => {
        const derivedNamespace = namespaceOverrides || (getCurrentInstance() ? inject(namespaceContextKey, ref(defaultNamespace)) : ref(defaultNamespace));
        const namespace = computed(() => {
          return unref(derivedNamespace) || defaultNamespace;
        });
        return namespace;
      };
      const useNamespace = (block, namespaceOverrides) => {
        const namespace = useGetDerivedNamespace(namespaceOverrides);
        const b = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
        const e2 = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
        const m = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
        const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
        const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
        const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
        const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
        const is = (name, ...args) => {
          const state = args.length >= 1 ? args[0] : true;
          return name && state ? `${statePrefix}${name}` : "";
        };
        const cssVar = (object) => {
          const styles = {};
          for (const key in object) {
            if (object[key]) {
              styles[`--${namespace.value}-${key}`] = object[key];
            }
          }
          return styles;
        };
        const cssVarBlock = (object) => {
          const styles = {};
          for (const key in object) {
            if (object[key]) {
              styles[`--${namespace.value}-${block}-${key}`] = object[key];
            }
          }
          return styles;
        };
        const cssVarName = (name) => `--${namespace.value}-${name}`;
        const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
        return {
          namespace,
          b,
          e: e2,
          m,
          be: be2,
          em,
          bm,
          bem,
          is,
          cssVar,
          cssVarName,
          cssVarBlock,
          cssVarBlockName
        };
      };
      const useLockscreen = (trigger2, options = {}) => {
        if (!isRef(trigger2)) {
          throwError("[useLockscreen]", "You need to pass a ref param to this function");
        }
        const ns = options.ns || useNamespace("popup");
        const hiddenCls = computed$1(() => ns.bm("parent", "hidden"));
        if (!isClient || hasClass(document.body, hiddenCls.value)) {
          return;
        }
        let scrollBarWidth2 = 0;
        let withoutHiddenClass = false;
        let bodyWidth = "0";
        const cleanup = () => {
          setTimeout(() => {
            removeClass(document == null ? void 0 : document.body, hiddenCls.value);
            if (withoutHiddenClass && document) {
              document.body.style.width = bodyWidth;
            }
          }, 200);
        };
        watch(trigger2, (val) => {
          if (!val) {
            cleanup();
            return;
          }
          withoutHiddenClass = !hasClass(document.body, hiddenCls.value);
          if (withoutHiddenClass) {
            bodyWidth = document.body.style.width;
          }
          scrollBarWidth2 = getScrollBarWidth(ns.namespace.value);
          const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
          const bodyOverflowY = getStyle(document.body, "overflowY");
          if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
            document.body.style.width = `calc(100% - ${scrollBarWidth2}px)`;
          }
          addClass(document.body, hiddenCls.value);
        });
        onScopeDispose(() => cleanup());
      };
      const _prop = buildProp({
        type: definePropType(Boolean),
        default: null
      });
      const _event = buildProp({
        type: definePropType(Function)
      });
      const createModelToggleComposable = (name) => {
        const updateEventKey = `update:${name}`;
        const updateEventKeyRaw = `onUpdate:${name}`;
        const useModelToggleEmits2 = [updateEventKey];
        const useModelToggleProps2 = {
          [name]: _prop,
          [updateEventKeyRaw]: _event
        };
        const useModelToggle2 = ({
          indicator,
          toggleReason,
          shouldHideWhenRouteChanges,
          shouldProceed,
          onShow,
          onHide
        }) => {
          const instance = getCurrentInstance();
          const { emit: emit2 } = instance;
          const props = instance.props;
          const hasUpdateHandler = computed(() => isFunction$1(props[updateEventKeyRaw]));
          const isModelBindingAbsent = computed(() => props[name] === null);
          const doShow = (event) => {
            if (indicator.value === true) {
              return;
            }
            indicator.value = true;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$1(onShow)) {
              onShow(event);
            }
          };
          const doHide = (event) => {
            if (indicator.value === false) {
              return;
            }
            indicator.value = false;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$1(onHide)) {
              onHide(event);
            }
          };
          const show = (event) => {
            if (props.disabled === true || isFunction$1(shouldProceed) && !shouldProceed())
              return;
            const shouldEmit = hasUpdateHandler.value && isClient;
            if (shouldEmit) {
              emit2(updateEventKey, true);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doShow(event);
            }
          };
          const hide = (event) => {
            if (props.disabled === true || !isClient)
              return;
            const shouldEmit = hasUpdateHandler.value && isClient;
            if (shouldEmit) {
              emit2(updateEventKey, false);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doHide(event);
            }
          };
          const onChange = (val) => {
            if (!isBoolean(val))
              return;
            if (props.disabled && val) {
              if (hasUpdateHandler.value) {
                emit2(updateEventKey, false);
              }
            } else if (indicator.value !== val) {
              if (val) {
                doShow();
              } else {
                doHide();
              }
            }
          };
          const toggle = () => {
            if (indicator.value) {
              hide();
            } else {
              show();
            }
          };
          watch(() => props[name], onChange);
          if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
            watch(() => ({
              ...instance.proxy.$route
            }), () => {
              if (shouldHideWhenRouteChanges.value && indicator.value) {
                hide();
              }
            });
          }
          onMounted(() => {
            onChange(props[name]);
          });
          return {
            hide,
            show,
            toggle,
            hasUpdateHandler
          };
        };
        return {
          useModelToggle: useModelToggle2,
          useModelToggleProps: useModelToggleProps2,
          useModelToggleEmits: useModelToggleEmits2
        };
      };
      const useProp = (name) => {
        const vm = getCurrentInstance();
        return computed(() => {
          var _a2, _b;
          return (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$props) == null ? void 0 : _b[name];
        });
      };
      var E = "top", R = "bottom", W = "right", P = "left", me = "auto", G = [E, R, W, P], U = "start", J = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t2, e2) {
        return t2.concat([e2 + "-" + U, e2 + "-" + J]);
      }, []), Ee = [].concat(G, [me]).reduce(function(t2, e2) {
        return t2.concat([e2, e2 + "-" + U, e2 + "-" + J]);
      }, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
      function C(t2) {
        return t2 ? (t2.nodeName || "").toLowerCase() : null;
      }
      function H(t2) {
        if (t2 == null)
          return window;
        if (t2.toString() !== "[object Window]") {
          var e2 = t2.ownerDocument;
          return e2 && e2.defaultView || window;
        }
        return t2;
      }
      function Q(t2) {
        var e2 = H(t2).Element;
        return t2 instanceof e2 || t2 instanceof Element;
      }
      function B(t2) {
        var e2 = H(t2).HTMLElement;
        return t2 instanceof e2 || t2 instanceof HTMLElement;
      }
      function Pe(t2) {
        if (typeof ShadowRoot == "undefined")
          return false;
        var e2 = H(t2).ShadowRoot;
        return t2 instanceof e2 || t2 instanceof ShadowRoot;
      }
      function Mt(t2) {
        var e2 = t2.state;
        Object.keys(e2.elements).forEach(function(n2) {
          var r2 = e2.styles[n2] || {}, o2 = e2.attributes[n2] || {}, i = e2.elements[n2];
          !B(i) || !C(i) || (Object.assign(i.style, r2), Object.keys(o2).forEach(function(a) {
            var s2 = o2[a];
            s2 === false ? i.removeAttribute(a) : i.setAttribute(a, s2 === true ? "" : s2);
          }));
        });
      }
      function Rt(t2) {
        var e2 = t2.state, n2 = { popper: { position: e2.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
        return Object.assign(e2.elements.popper.style, n2.popper), e2.styles = n2, e2.elements.arrow && Object.assign(e2.elements.arrow.style, n2.arrow), function() {
          Object.keys(e2.elements).forEach(function(r2) {
            var o2 = e2.elements[r2], i = e2.attributes[r2] || {}, a = Object.keys(e2.styles.hasOwnProperty(r2) ? e2.styles[r2] : n2[r2]), s2 = a.reduce(function(f, c) {
              return f[c] = "", f;
            }, {});
            !B(o2) || !C(o2) || (Object.assign(o2.style, s2), Object.keys(i).forEach(function(f) {
              o2.removeAttribute(f);
            }));
          });
        };
      }
      var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
      function q(t2) {
        return t2.split("-")[0];
      }
      var X = Math.max, ve = Math.min, Z = Math.round;
      function ee(t2, e2) {
        e2 === void 0 && (e2 = false);
        var n2 = t2.getBoundingClientRect(), r2 = 1, o2 = 1;
        if (B(t2) && e2) {
          var i = t2.offsetHeight, a = t2.offsetWidth;
          a > 0 && (r2 = Z(n2.width) / a || 1), i > 0 && (o2 = Z(n2.height) / i || 1);
        }
        return { width: n2.width / r2, height: n2.height / o2, top: n2.top / o2, right: n2.right / r2, bottom: n2.bottom / o2, left: n2.left / r2, x: n2.left / r2, y: n2.top / o2 };
      }
      function ke(t2) {
        var e2 = ee(t2), n2 = t2.offsetWidth, r2 = t2.offsetHeight;
        return Math.abs(e2.width - n2) <= 1 && (n2 = e2.width), Math.abs(e2.height - r2) <= 1 && (r2 = e2.height), { x: t2.offsetLeft, y: t2.offsetTop, width: n2, height: r2 };
      }
      function it(t2, e2) {
        var n2 = e2.getRootNode && e2.getRootNode();
        if (t2.contains(e2))
          return true;
        if (n2 && Pe(n2)) {
          var r2 = e2;
          do {
            if (r2 && t2.isSameNode(r2))
              return true;
            r2 = r2.parentNode || r2.host;
          } while (r2);
        }
        return false;
      }
      function N(t2) {
        return H(t2).getComputedStyle(t2);
      }
      function Wt(t2) {
        return ["table", "td", "th"].indexOf(C(t2)) >= 0;
      }
      function I(t2) {
        return ((Q(t2) ? t2.ownerDocument : t2.document) || window.document).documentElement;
      }
      function ge(t2) {
        return C(t2) === "html" ? t2 : t2.assignedSlot || t2.parentNode || (Pe(t2) ? t2.host : null) || I(t2);
      }
      function at(t2) {
        return !B(t2) || N(t2).position === "fixed" ? null : t2.offsetParent;
      }
      function Bt(t2) {
        var e2 = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n2 = navigator.userAgent.indexOf("Trident") !== -1;
        if (n2 && B(t2)) {
          var r2 = N(t2);
          if (r2.position === "fixed")
            return null;
        }
        var o2 = ge(t2);
        for (Pe(o2) && (o2 = o2.host); B(o2) && ["html", "body"].indexOf(C(o2)) < 0; ) {
          var i = N(o2);
          if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e2 && i.willChange === "filter" || e2 && i.filter && i.filter !== "none")
            return o2;
          o2 = o2.parentNode;
        }
        return null;
      }
      function se(t2) {
        for (var e2 = H(t2), n2 = at(t2); n2 && Wt(n2) && N(n2).position === "static"; )
          n2 = at(n2);
        return n2 && (C(n2) === "html" || C(n2) === "body" && N(n2).position === "static") ? e2 : n2 || Bt(t2) || e2;
      }
      function Le(t2) {
        return ["top", "bottom"].indexOf(t2) >= 0 ? "x" : "y";
      }
      function fe(t2, e2, n2) {
        return X(t2, ve(e2, n2));
      }
      function St(t2, e2, n2) {
        var r2 = fe(t2, e2, n2);
        return r2 > n2 ? n2 : r2;
      }
      function st() {
        return { top: 0, right: 0, bottom: 0, left: 0 };
      }
      function ft(t2) {
        return Object.assign({}, st(), t2);
      }
      function ct(t2, e2) {
        return e2.reduce(function(n2, r2) {
          return n2[r2] = t2, n2;
        }, {});
      }
      var Tt = function(t2, e2) {
        return t2 = typeof t2 == "function" ? t2(Object.assign({}, e2.rects, { placement: e2.placement })) : t2, ft(typeof t2 != "number" ? t2 : ct(t2, G));
      };
      function Ht(t2) {
        var e2, n2 = t2.state, r2 = t2.name, o2 = t2.options, i = n2.elements.arrow, a = n2.modifiersData.popperOffsets, s2 = q(n2.placement), f = Le(s2), c = [P, W].indexOf(s2) >= 0, u = c ? "height" : "width";
        if (!(!i || !a)) {
          var m = Tt(o2.padding, n2), v = ke(i), l2 = f === "y" ? E : P, h2 = f === "y" ? R : W, p2 = n2.rects.reference[u] + n2.rects.reference[f] - a[f] - n2.rects.popper[u], g = a[f] - n2.rects.reference[f], x = se(i), y = x ? f === "y" ? x.clientHeight || 0 : x.clientWidth || 0 : 0, $2 = p2 / 2 - g / 2, d = m[l2], b = y - v[u] - m[h2], w = y / 2 - v[u] / 2 + $2, O = fe(d, w, b), j = f;
          n2.modifiersData[r2] = (e2 = {}, e2[j] = O, e2.centerOffset = O - w, e2);
        }
      }
      function Ct(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = n2.element, o2 = r2 === void 0 ? "[data-popper-arrow]" : r2;
        o2 != null && (typeof o2 == "string" && (o2 = e2.elements.popper.querySelector(o2), !o2) || !it(e2.elements.popper, o2) || (e2.elements.arrow = o2));
      }
      var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
      function te(t2) {
        return t2.split("-")[1];
      }
      var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
      function Vt(t2) {
        var e2 = t2.x, n2 = t2.y, r2 = window, o2 = r2.devicePixelRatio || 1;
        return { x: Z(e2 * o2) / o2 || 0, y: Z(n2 * o2) / o2 || 0 };
      }
      function ut(t2) {
        var e2, n2 = t2.popper, r2 = t2.popperRect, o2 = t2.placement, i = t2.variation, a = t2.offsets, s2 = t2.position, f = t2.gpuAcceleration, c = t2.adaptive, u = t2.roundOffsets, m = t2.isFixed, v = a.x, l2 = v === void 0 ? 0 : v, h2 = a.y, p2 = h2 === void 0 ? 0 : h2, g = typeof u == "function" ? u({ x: l2, y: p2 }) : { x: l2, y: p2 };
        l2 = g.x, p2 = g.y;
        var x = a.hasOwnProperty("x"), y = a.hasOwnProperty("y"), $2 = P, d = E, b = window;
        if (c) {
          var w = se(n2), O = "clientHeight", j = "clientWidth";
          if (w === H(n2) && (w = I(n2), N(w).position !== "static" && s2 === "absolute" && (O = "scrollHeight", j = "scrollWidth")), w = w, o2 === E || (o2 === P || o2 === W) && i === J) {
            d = R;
            var A = m && w === b && b.visualViewport ? b.visualViewport.height : w[O];
            p2 -= A - r2.height, p2 *= f ? 1 : -1;
          }
          if (o2 === P || (o2 === E || o2 === R) && i === J) {
            $2 = W;
            var k = m && w === b && b.visualViewport ? b.visualViewport.width : w[j];
            l2 -= k - r2.width, l2 *= f ? 1 : -1;
          }
        }
        var D = Object.assign({ position: s2 }, c && qt), S = u === true ? Vt({ x: l2, y: p2 }) : { x: l2, y: p2 };
        if (l2 = S.x, p2 = S.y, f) {
          var L;
          return Object.assign({}, D, (L = {}, L[d] = y ? "0" : "", L[$2] = x ? "0" : "", L.transform = (b.devicePixelRatio || 1) <= 1 ? "translate(" + l2 + "px, " + p2 + "px)" : "translate3d(" + l2 + "px, " + p2 + "px, 0)", L));
        }
        return Object.assign({}, D, (e2 = {}, e2[d] = y ? p2 + "px" : "", e2[$2] = x ? l2 + "px" : "", e2.transform = "", e2));
      }
      function Nt(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = n2.gpuAcceleration, o2 = r2 === void 0 ? true : r2, i = n2.adaptive, a = i === void 0 ? true : i, s2 = n2.roundOffsets, f = s2 === void 0 ? true : s2, c = { placement: q(e2.placement), variation: te(e2.placement), popper: e2.elements.popper, popperRect: e2.rects.popper, gpuAcceleration: o2, isFixed: e2.options.strategy === "fixed" };
        e2.modifiersData.popperOffsets != null && (e2.styles.popper = Object.assign({}, e2.styles.popper, ut(Object.assign({}, c, { offsets: e2.modifiersData.popperOffsets, position: e2.options.strategy, adaptive: a, roundOffsets: f })))), e2.modifiersData.arrow != null && (e2.styles.arrow = Object.assign({}, e2.styles.arrow, ut(Object.assign({}, c, { offsets: e2.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f })))), e2.attributes.popper = Object.assign({}, e2.attributes.popper, { "data-popper-placement": e2.placement });
      }
      var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
      function It(t2) {
        var e2 = t2.state, n2 = t2.instance, r2 = t2.options, o2 = r2.scroll, i = o2 === void 0 ? true : o2, a = r2.resize, s2 = a === void 0 ? true : a, f = H(e2.elements.popper), c = [].concat(e2.scrollParents.reference, e2.scrollParents.popper);
        return i && c.forEach(function(u) {
          u.addEventListener("scroll", n2.update, ye);
        }), s2 && f.addEventListener("resize", n2.update, ye), function() {
          i && c.forEach(function(u) {
            u.removeEventListener("scroll", n2.update, ye);
          }), s2 && f.removeEventListener("resize", n2.update, ye);
        };
      }
      var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
      }, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
      function be(t2) {
        return t2.replace(/left|right|bottom|top/g, function(e2) {
          return _t[e2];
        });
      }
      var zt = { start: "end", end: "start" };
      function lt(t2) {
        return t2.replace(/start|end/g, function(e2) {
          return zt[e2];
        });
      }
      function We(t2) {
        var e2 = H(t2), n2 = e2.pageXOffset, r2 = e2.pageYOffset;
        return { scrollLeft: n2, scrollTop: r2 };
      }
      function Be(t2) {
        return ee(I(t2)).left + We(t2).scrollLeft;
      }
      function Ft(t2) {
        var e2 = H(t2), n2 = I(t2), r2 = e2.visualViewport, o2 = n2.clientWidth, i = n2.clientHeight, a = 0, s2 = 0;
        return r2 && (o2 = r2.width, i = r2.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = r2.offsetLeft, s2 = r2.offsetTop)), { width: o2, height: i, x: a + Be(t2), y: s2 };
      }
      function Ut(t2) {
        var e2, n2 = I(t2), r2 = We(t2), o2 = (e2 = t2.ownerDocument) == null ? void 0 : e2.body, i = X(n2.scrollWidth, n2.clientWidth, o2 ? o2.scrollWidth : 0, o2 ? o2.clientWidth : 0), a = X(n2.scrollHeight, n2.clientHeight, o2 ? o2.scrollHeight : 0, o2 ? o2.clientHeight : 0), s2 = -r2.scrollLeft + Be(t2), f = -r2.scrollTop;
        return N(o2 || n2).direction === "rtl" && (s2 += X(n2.clientWidth, o2 ? o2.clientWidth : 0) - i), { width: i, height: a, x: s2, y: f };
      }
      function Se(t2) {
        var e2 = N(t2), n2 = e2.overflow, r2 = e2.overflowX, o2 = e2.overflowY;
        return /auto|scroll|overlay|hidden/.test(n2 + o2 + r2);
      }
      function dt(t2) {
        return ["html", "body", "#document"].indexOf(C(t2)) >= 0 ? t2.ownerDocument.body : B(t2) && Se(t2) ? t2 : dt(ge(t2));
      }
      function ce(t2, e2) {
        var n2;
        e2 === void 0 && (e2 = []);
        var r2 = dt(t2), o2 = r2 === ((n2 = t2.ownerDocument) == null ? void 0 : n2.body), i = H(r2), a = o2 ? [i].concat(i.visualViewport || [], Se(r2) ? r2 : []) : r2, s2 = e2.concat(a);
        return o2 ? s2 : s2.concat(ce(ge(a)));
      }
      function Te(t2) {
        return Object.assign({}, t2, { left: t2.x, top: t2.y, right: t2.x + t2.width, bottom: t2.y + t2.height });
      }
      function Xt(t2) {
        var e2 = ee(t2);
        return e2.top = e2.top + t2.clientTop, e2.left = e2.left + t2.clientLeft, e2.bottom = e2.top + t2.clientHeight, e2.right = e2.left + t2.clientWidth, e2.width = t2.clientWidth, e2.height = t2.clientHeight, e2.x = e2.left, e2.y = e2.top, e2;
      }
      function ht(t2, e2) {
        return e2 === je ? Te(Ft(t2)) : Q(e2) ? Xt(e2) : Te(Ut(I(t2)));
      }
      function Yt(t2) {
        var e2 = ce(ge(t2)), n2 = ["absolute", "fixed"].indexOf(N(t2).position) >= 0, r2 = n2 && B(t2) ? se(t2) : t2;
        return Q(r2) ? e2.filter(function(o2) {
          return Q(o2) && it(o2, r2) && C(o2) !== "body";
        }) : [];
      }
      function Gt(t2, e2, n2) {
        var r2 = e2 === "clippingParents" ? Yt(t2) : [].concat(e2), o2 = [].concat(r2, [n2]), i = o2[0], a = o2.reduce(function(s2, f) {
          var c = ht(t2, f);
          return s2.top = X(c.top, s2.top), s2.right = ve(c.right, s2.right), s2.bottom = ve(c.bottom, s2.bottom), s2.left = X(c.left, s2.left), s2;
        }, ht(t2, i));
        return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
      }
      function mt(t2) {
        var e2 = t2.reference, n2 = t2.element, r2 = t2.placement, o2 = r2 ? q(r2) : null, i = r2 ? te(r2) : null, a = e2.x + e2.width / 2 - n2.width / 2, s2 = e2.y + e2.height / 2 - n2.height / 2, f;
        switch (o2) {
          case E:
            f = { x: a, y: e2.y - n2.height };
            break;
          case R:
            f = { x: a, y: e2.y + e2.height };
            break;
          case W:
            f = { x: e2.x + e2.width, y: s2 };
            break;
          case P:
            f = { x: e2.x - n2.width, y: s2 };
            break;
          default:
            f = { x: e2.x, y: e2.y };
        }
        var c = o2 ? Le(o2) : null;
        if (c != null) {
          var u = c === "y" ? "height" : "width";
          switch (i) {
            case U:
              f[c] = f[c] - (e2[u] / 2 - n2[u] / 2);
              break;
            case J:
              f[c] = f[c] + (e2[u] / 2 - n2[u] / 2);
              break;
          }
        }
        return f;
      }
      function ne(t2, e2) {
        e2 === void 0 && (e2 = {});
        var n2 = e2, r2 = n2.placement, o2 = r2 === void 0 ? t2.placement : r2, i = n2.boundary, a = i === void 0 ? Xe : i, s2 = n2.rootBoundary, f = s2 === void 0 ? je : s2, c = n2.elementContext, u = c === void 0 ? K : c, m = n2.altBoundary, v = m === void 0 ? false : m, l2 = n2.padding, h2 = l2 === void 0 ? 0 : l2, p2 = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g = u === K ? Ye : K, x = t2.rects.popper, y = t2.elements[v ? g : u], $2 = Gt(Q(y) ? y : y.contextElement || I(t2.elements.popper), a, f), d = ee(t2.elements.reference), b = mt({ reference: d, element: x, strategy: "absolute", placement: o2 }), w = Te(Object.assign({}, x, b)), O = u === K ? w : d, j = { top: $2.top - O.top + p2.top, bottom: O.bottom - $2.bottom + p2.bottom, left: $2.left - O.left + p2.left, right: O.right - $2.right + p2.right }, A = t2.modifiersData.offset;
        if (u === K && A) {
          var k = A[o2];
          Object.keys(j).forEach(function(D) {
            var S = [W, R].indexOf(D) >= 0 ? 1 : -1, L = [E, R].indexOf(D) >= 0 ? "y" : "x";
            j[D] += k[L] * S;
          });
        }
        return j;
      }
      function Jt(t2, e2) {
        e2 === void 0 && (e2 = {});
        var n2 = e2, r2 = n2.placement, o2 = n2.boundary, i = n2.rootBoundary, a = n2.padding, s2 = n2.flipVariations, f = n2.allowedAutoPlacements, c = f === void 0 ? Ee : f, u = te(r2), m = u ? s2 ? De : De.filter(function(h2) {
          return te(h2) === u;
        }) : G, v = m.filter(function(h2) {
          return c.indexOf(h2) >= 0;
        });
        v.length === 0 && (v = m);
        var l2 = v.reduce(function(h2, p2) {
          return h2[p2] = ne(t2, { placement: p2, boundary: o2, rootBoundary: i, padding: a })[q(p2)], h2;
        }, {});
        return Object.keys(l2).sort(function(h2, p2) {
          return l2[h2] - l2[p2];
        });
      }
      function Kt(t2) {
        if (q(t2) === me)
          return [];
        var e2 = be(t2);
        return [lt(t2), e2, lt(e2)];
      }
      function Qt(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = t2.name;
        if (!e2.modifiersData[r2]._skip) {
          for (var o2 = n2.mainAxis, i = o2 === void 0 ? true : o2, a = n2.altAxis, s2 = a === void 0 ? true : a, f = n2.fallbackPlacements, c = n2.padding, u = n2.boundary, m = n2.rootBoundary, v = n2.altBoundary, l2 = n2.flipVariations, h2 = l2 === void 0 ? true : l2, p2 = n2.allowedAutoPlacements, g = e2.options.placement, x = q(g), y = x === g, $2 = f || (y || !h2 ? [be(g)] : Kt(g)), d = [g].concat($2).reduce(function(z, V) {
            return z.concat(q(V) === me ? Jt(e2, { placement: V, boundary: u, rootBoundary: m, padding: c, flipVariations: h2, allowedAutoPlacements: p2 }) : V);
          }, []), b = e2.rects.reference, w = e2.rects.popper, O = /* @__PURE__ */ new Map(), j = true, A = d[0], k = 0; k < d.length; k++) {
            var D = d[k], S = q(D), L = te(D) === U, re = [E, R].indexOf(S) >= 0, oe = re ? "width" : "height", M = ne(e2, { placement: D, boundary: u, rootBoundary: m, altBoundary: v, padding: c }), T = re ? L ? W : P : L ? R : E;
            b[oe] > w[oe] && (T = be(T));
            var pe = be(T), _2 = [];
            if (i && _2.push(M[S] <= 0), s2 && _2.push(M[T] <= 0, M[pe] <= 0), _2.every(function(z) {
              return z;
            })) {
              A = D, j = false;
              break;
            }
            O.set(D, _2);
          }
          if (j)
            for (var ue = h2 ? 3 : 1, xe = function(z) {
              var V = d.find(function(de) {
                var ae = O.get(de);
                if (ae)
                  return ae.slice(0, z).every(function(Y) {
                    return Y;
                  });
              });
              if (V)
                return A = V, "break";
            }, ie = ue; ie > 0; ie--) {
              var le = xe(ie);
              if (le === "break")
                break;
            }
          e2.placement !== A && (e2.modifiersData[r2]._skip = true, e2.placement = A, e2.reset = true);
        }
      }
      var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
      function gt(t2, e2, n2) {
        return n2 === void 0 && (n2 = { x: 0, y: 0 }), { top: t2.top - e2.height - n2.y, right: t2.right - e2.width + n2.x, bottom: t2.bottom - e2.height + n2.y, left: t2.left - e2.width - n2.x };
      }
      function yt(t2) {
        return [E, W, R, P].some(function(e2) {
          return t2[e2] >= 0;
        });
      }
      function Zt(t2) {
        var e2 = t2.state, n2 = t2.name, r2 = e2.rects.reference, o2 = e2.rects.popper, i = e2.modifiersData.preventOverflow, a = ne(e2, { elementContext: "reference" }), s2 = ne(e2, { altBoundary: true }), f = gt(a, r2), c = gt(s2, o2, i), u = yt(f), m = yt(c);
        e2.modifiersData[n2] = { referenceClippingOffsets: f, popperEscapeOffsets: c, isReferenceHidden: u, hasPopperEscaped: m }, e2.attributes.popper = Object.assign({}, e2.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": m });
      }
      var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
      function en(t2, e2, n2) {
        var r2 = q(t2), o2 = [P, E].indexOf(r2) >= 0 ? -1 : 1, i = typeof n2 == "function" ? n2(Object.assign({}, e2, { placement: t2 })) : n2, a = i[0], s2 = i[1];
        return a = a || 0, s2 = (s2 || 0) * o2, [P, W].indexOf(r2) >= 0 ? { x: s2, y: a } : { x: a, y: s2 };
      }
      function tn(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = t2.name, o2 = n2.offset, i = o2 === void 0 ? [0, 0] : o2, a = Ee.reduce(function(u, m) {
          return u[m] = en(m, e2.rects, i), u;
        }, {}), s2 = a[e2.placement], f = s2.x, c = s2.y;
        e2.modifiersData.popperOffsets != null && (e2.modifiersData.popperOffsets.x += f, e2.modifiersData.popperOffsets.y += c), e2.modifiersData[r2] = a;
      }
      var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
      function nn(t2) {
        var e2 = t2.state, n2 = t2.name;
        e2.modifiersData[n2] = mt({ reference: e2.rects.reference, element: e2.rects.popper, strategy: "absolute", placement: e2.placement });
      }
      var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
      function rn(t2) {
        return t2 === "x" ? "y" : "x";
      }
      function on(t2) {
        var e2 = t2.state, n2 = t2.options, r2 = t2.name, o2 = n2.mainAxis, i = o2 === void 0 ? true : o2, a = n2.altAxis, s2 = a === void 0 ? false : a, f = n2.boundary, c = n2.rootBoundary, u = n2.altBoundary, m = n2.padding, v = n2.tether, l2 = v === void 0 ? true : v, h2 = n2.tetherOffset, p2 = h2 === void 0 ? 0 : h2, g = ne(e2, { boundary: f, rootBoundary: c, padding: m, altBoundary: u }), x = q(e2.placement), y = te(e2.placement), $2 = !y, d = Le(x), b = rn(d), w = e2.modifiersData.popperOffsets, O = e2.rects.reference, j = e2.rects.popper, A = typeof p2 == "function" ? p2(Object.assign({}, e2.rects, { placement: e2.placement })) : p2, k = typeof A == "number" ? { mainAxis: A, altAxis: A } : Object.assign({ mainAxis: 0, altAxis: 0 }, A), D = e2.modifiersData.offset ? e2.modifiersData.offset[e2.placement] : null, S = { x: 0, y: 0 };
        if (w) {
          if (i) {
            var L, re = d === "y" ? E : P, oe = d === "y" ? R : W, M = d === "y" ? "height" : "width", T = w[d], pe = T + g[re], _2 = T - g[oe], ue = l2 ? -j[M] / 2 : 0, xe = y === U ? O[M] : j[M], ie = y === U ? -j[M] : -O[M], le = e2.elements.arrow, z = l2 && le ? ke(le) : { width: 0, height: 0 }, V = e2.modifiersData["arrow#persistent"] ? e2.modifiersData["arrow#persistent"].padding : st(), de = V[re], ae = V[oe], Y = fe(0, O[M], z[M]), jt = $2 ? O[M] / 2 - ue - Y - de - k.mainAxis : xe - Y - de - k.mainAxis, Dt = $2 ? -O[M] / 2 + ue + Y + ae + k.mainAxis : ie + Y + ae + k.mainAxis, Oe = e2.elements.arrow && se(e2.elements.arrow), Et = Oe ? d === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L = D == null ? void 0 : D[d]) != null ? L : 0, Pt = T + jt - Ce - Et, At = T + Dt - Ce, qe = fe(l2 ? ve(pe, Pt) : pe, T, l2 ? X(_2, At) : _2);
            w[d] = qe, S[d] = qe - T;
          }
          if (s2) {
            var Ve, kt = d === "x" ? E : P, Lt = d === "x" ? R : W, F = w[b], he = b === "y" ? "height" : "width", Ne = F + g[kt], Ie = F - g[Lt], $e = [E, P].indexOf(x) !== -1, _e = (Ve = D == null ? void 0 : D[b]) != null ? Ve : 0, ze = $e ? Ne : F - O[he] - j[he] - _e + k.altAxis, Fe = $e ? F + O[he] + j[he] - _e - k.altAxis : Ie, Ue = l2 && $e ? St(ze, F, Fe) : fe(l2 ? ze : Ne, F, l2 ? Fe : Ie);
            w[b] = Ue, S[b] = Ue - F;
          }
          e2.modifiersData[r2] = S;
        }
      }
      var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
      function an(t2) {
        return { scrollLeft: t2.scrollLeft, scrollTop: t2.scrollTop };
      }
      function sn(t2) {
        return t2 === H(t2) || !B(t2) ? We(t2) : an(t2);
      }
      function fn(t2) {
        var e2 = t2.getBoundingClientRect(), n2 = Z(e2.width) / t2.offsetWidth || 1, r2 = Z(e2.height) / t2.offsetHeight || 1;
        return n2 !== 1 || r2 !== 1;
      }
      function cn(t2, e2, n2) {
        n2 === void 0 && (n2 = false);
        var r2 = B(e2), o2 = B(e2) && fn(e2), i = I(e2), a = ee(t2, o2), s2 = { scrollLeft: 0, scrollTop: 0 }, f = { x: 0, y: 0 };
        return (r2 || !r2 && !n2) && ((C(e2) !== "body" || Se(i)) && (s2 = sn(e2)), B(e2) ? (f = ee(e2, true), f.x += e2.clientLeft, f.y += e2.clientTop) : i && (f.x = Be(i))), { x: a.left + s2.scrollLeft - f.x, y: a.top + s2.scrollTop - f.y, width: a.width, height: a.height };
      }
      function pn(t2) {
        var e2 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Set(), r2 = [];
        t2.forEach(function(i) {
          e2.set(i.name, i);
        });
        function o2(i) {
          n2.add(i.name);
          var a = [].concat(i.requires || [], i.requiresIfExists || []);
          a.forEach(function(s2) {
            if (!n2.has(s2)) {
              var f = e2.get(s2);
              f && o2(f);
            }
          }), r2.push(i);
        }
        return t2.forEach(function(i) {
          n2.has(i.name) || o2(i);
        }), r2;
      }
      function un(t2) {
        var e2 = pn(t2);
        return ot.reduce(function(n2, r2) {
          return n2.concat(e2.filter(function(o2) {
            return o2.phase === r2;
          }));
        }, []);
      }
      function ln(t2) {
        var e2;
        return function() {
          return e2 || (e2 = new Promise(function(n2) {
            Promise.resolve().then(function() {
              e2 = void 0, n2(t2());
            });
          })), e2;
        };
      }
      function dn(t2) {
        var e2 = t2.reduce(function(n2, r2) {
          var o2 = n2[r2.name];
          return n2[r2.name] = o2 ? Object.assign({}, o2, r2, { options: Object.assign({}, o2.options, r2.options), data: Object.assign({}, o2.data, r2.data) }) : r2, n2;
        }, {});
        return Object.keys(e2).map(function(n2) {
          return e2[n2];
        });
      }
      var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
      function $t() {
        for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++)
          e2[n2] = arguments[n2];
        return !e2.some(function(r2) {
          return !(r2 && typeof r2.getBoundingClientRect == "function");
        });
      }
      function we(t2) {
        t2 === void 0 && (t2 = {});
        var e2 = t2, n2 = e2.defaultModifiers, r2 = n2 === void 0 ? [] : n2, o2 = e2.defaultOptions, i = o2 === void 0 ? Ot : o2;
        return function(a, s2, f) {
          f === void 0 && (f = i);
          var c = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i), modifiersData: {}, elements: { reference: a, popper: s2 }, attributes: {}, styles: {} }, u = [], m = false, v = { state: c, setOptions: function(p2) {
            var g = typeof p2 == "function" ? p2(c.options) : p2;
            h2(), c.options = Object.assign({}, i, c.options, g), c.scrollParents = { reference: Q(a) ? ce(a) : a.contextElement ? ce(a.contextElement) : [], popper: ce(s2) };
            var x = un(dn([].concat(r2, c.options.modifiers)));
            return c.orderedModifiers = x.filter(function(y) {
              return y.enabled;
            }), l2(), v.update();
          }, forceUpdate: function() {
            if (!m) {
              var p2 = c.elements, g = p2.reference, x = p2.popper;
              if ($t(g, x)) {
                c.rects = { reference: cn(g, se(x), c.options.strategy === "fixed"), popper: ke(x) }, c.reset = false, c.placement = c.options.placement, c.orderedModifiers.forEach(function(j) {
                  return c.modifiersData[j.name] = Object.assign({}, j.data);
                });
                for (var y = 0; y < c.orderedModifiers.length; y++) {
                  if (c.reset === true) {
                    c.reset = false, y = -1;
                    continue;
                  }
                  var $2 = c.orderedModifiers[y], d = $2.fn, b = $2.options, w = b === void 0 ? {} : b, O = $2.name;
                  typeof d == "function" && (c = d({ state: c, options: w, name: O, instance: v }) || c);
                }
              }
            }
          }, update: ln(function() {
            return new Promise(function(p2) {
              v.forceUpdate(), p2(c);
            });
          }), destroy: function() {
            h2(), m = true;
          } };
          if (!$t(a, s2))
            return v;
          v.setOptions(f).then(function(p2) {
            !m && f.onFirstUpdate && f.onFirstUpdate(p2);
          });
          function l2() {
            c.orderedModifiers.forEach(function(p2) {
              var g = p2.name, x = p2.options, y = x === void 0 ? {} : x, $2 = p2.effect;
              if (typeof $2 == "function") {
                var d = $2({ state: c, name: g, instance: v, options: y }), b = function() {
                };
                u.push(d || b);
              }
            });
          }
          function h2() {
            u.forEach(function(p2) {
              return p2();
            }), u = [];
          }
          return v;
        };
      }
      we();
      var mn = [Re, He, Me, Ae];
      we({ defaultModifiers: mn });
      var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
      const usePopper = (referenceElementRef, popperElementRef, opts = {}) => {
        const stateUpdater = {
          name: "updateState",
          enabled: true,
          phase: "write",
          fn: ({ state }) => {
            const derivedState = deriveState(state);
            Object.assign(states.value, derivedState);
          },
          requires: ["computeStyles"]
        };
        const options = computed(() => {
          const { onFirstUpdate, placement, strategy, modifiers } = unref(opts);
          return {
            onFirstUpdate,
            placement: placement || "bottom",
            strategy: strategy || "absolute",
            modifiers: [
              ...modifiers || [],
              stateUpdater,
              { name: "applyStyles", enabled: false }
            ]
          };
        });
        const instanceRef = shallowRef();
        const states = ref({
          styles: {
            popper: {
              position: unref(options).strategy,
              left: "0",
              top: "0"
            },
            arrow: {
              position: "absolute"
            }
          },
          attributes: {}
        });
        const destroy = () => {
          if (!instanceRef.value)
            return;
          instanceRef.value.destroy();
          instanceRef.value = void 0;
        };
        watch(options, (newOptions) => {
          const instance = unref(instanceRef);
          if (instance) {
            instance.setOptions(newOptions);
          }
        }, {
          deep: true
        });
        watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
          destroy();
          if (!referenceElement || !popperElement)
            return;
          instanceRef.value = yn(referenceElement, popperElement, unref(options));
        });
        onBeforeUnmount(() => {
          destroy();
        });
        return {
          state: computed(() => {
            var _a2;
            return { ...((_a2 = unref(instanceRef)) == null ? void 0 : _a2.state) || {} };
          }),
          styles: computed(() => unref(states).styles),
          attributes: computed(() => unref(states).attributes),
          update: () => {
            var _a2;
            return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.update();
          },
          forceUpdate: () => {
            var _a2;
            return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.forceUpdate();
          },
          instanceRef: computed(() => unref(instanceRef))
        };
      };
      function deriveState(state) {
        const elements = Object.keys(state.elements);
        const styles = fromPairs(elements.map((element) => [element, state.styles[element] || {}]));
        const attributes = fromPairs(elements.map((element) => [element, state.attributes[element]]));
        return {
          styles,
          attributes
        };
      }
      const useSameTarget = (handleClick) => {
        if (!handleClick) {
          return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
        }
        let mousedownTarget = false;
        let mouseupTarget = false;
        const onClick = (e2) => {
          if (mousedownTarget && mouseupTarget) {
            handleClick(e2);
          }
          mousedownTarget = mouseupTarget = false;
        };
        const onMousedown = (e2) => {
          mousedownTarget = e2.target === e2.currentTarget;
        };
        const onMouseup = (e2) => {
          mouseupTarget = e2.target === e2.currentTarget;
        };
        return { onClick, onMousedown, onMouseup };
      };
      function useTimeout() {
        let timeoutHandle;
        const registerTimeout = (fn2, delay) => {
          cancelTimeout();
          timeoutHandle = window.setTimeout(fn2, delay);
        };
        const cancelTimeout = () => window.clearTimeout(timeoutHandle);
        tryOnScopeDispose(() => cancelTimeout());
        return {
          registerTimeout,
          cancelTimeout
        };
      }
      const defaultIdInjection = {
        prefix: Math.floor(Math.random() * 1e4),
        current: 0
      };
      const ID_INJECTION_KEY = Symbol("elIdInjection");
      const useIdInjection = () => {
        return getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
      };
      const useId = (deterministicId) => {
        const idInjection = useIdInjection();
        const namespace = useGetDerivedNamespace();
        const idRef = computed(() => unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
        return idRef;
      };
      let registeredEscapeHandlers = [];
      const cachedHandler = (e2) => {
        const event = e2;
        if (event.key === EVENT_CODE.esc) {
          registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
        }
      };
      const useEscapeKeydown = (handler) => {
        onMounted(() => {
          if (registeredEscapeHandlers.length === 0) {
            document.addEventListener("keydown", cachedHandler);
          }
          if (isClient)
            registeredEscapeHandlers.push(handler);
        });
        onBeforeUnmount(() => {
          registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
          if (registeredEscapeHandlers.length === 0) {
            if (isClient)
              document.removeEventListener("keydown", cachedHandler);
          }
        });
      };
      let cachedContainer;
      const usePopperContainerId = () => {
        const namespace = useGetDerivedNamespace();
        const idInjection = useIdInjection();
        const id = computed(() => {
          return `${namespace.value}-popper-container-${idInjection.prefix}`;
        });
        const selector = computed(() => `#${id.value}`);
        return {
          id,
          selector
        };
      };
      const createContainer = (id) => {
        const container = document.createElement("div");
        container.id = id;
        document.body.appendChild(container);
        return container;
      };
      const usePopperContainer = () => {
        const { id, selector } = usePopperContainerId();
        onBeforeMount(() => {
          if (!isClient)
            return;
          if (!cachedContainer && !document.body.querySelector(selector.value)) {
            cachedContainer = createContainer(id.value);
          }
        });
        return {
          id,
          selector
        };
      };
      const useDelayedToggleProps = buildProps({
        showAfter: {
          type: Number,
          default: 0
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        autoClose: {
          type: Number,
          default: 0
        }
      });
      const useDelayedToggle = ({
        showAfter,
        hideAfter,
        autoClose,
        open,
        close
      }) => {
        const { registerTimeout } = useTimeout();
        const {
          registerTimeout: registerTimeoutForAutoClose,
          cancelTimeout: cancelTimeoutForAutoClose
        } = useTimeout();
        const onOpen = (event) => {
          registerTimeout(() => {
            open(event);
            const _autoClose = unref(autoClose);
            if (isNumber(_autoClose) && _autoClose > 0) {
              registerTimeoutForAutoClose(() => {
                close(event);
              }, _autoClose);
            }
          }, unref(showAfter));
        };
        const onClose = (event) => {
          cancelTimeoutForAutoClose();
          registerTimeout(() => {
            close(event);
          }, unref(hideAfter));
        };
        return {
          onOpen,
          onClose
        };
      };
      const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
      const useForwardRef = (forwardRef) => {
        const setForwardRef = (el) => {
          forwardRef.value = el;
        };
        provide(FORWARD_REF_INJECTION_KEY, {
          setForwardRef
        });
      };
      const useForwardRefDirective = (setForwardRef) => {
        return {
          mounted(el) {
            setForwardRef(el);
          },
          updated(el) {
            setForwardRef(el);
          },
          unmounted() {
            setForwardRef(null);
          }
        };
      };
      const zIndex = ref(0);
      const defaultInitialZIndex = 2e3;
      const zIndexContextKey = Symbol("zIndexContextKey");
      const useZIndex = (zIndexOverrides) => {
        const zIndexInjection = zIndexOverrides || (getCurrentInstance() ? inject(zIndexContextKey, void 0) : void 0);
        const initialZIndex = computed(() => {
          const zIndexFromInjection = unref(zIndexInjection);
          return isNumber(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
        });
        const currentZIndex = computed(() => initialZIndex.value + zIndex.value);
        const nextZIndex = () => {
          zIndex.value++;
          return currentZIndex.value;
        };
        return {
          initialZIndex,
          currentZIndex,
          nextZIndex
        };
      };
      function useCursor(input) {
        const selectionRef = ref();
        function recordCursor() {
          if (input.value == void 0)
            return;
          const { selectionStart, selectionEnd, value } = input.value;
          if (selectionStart == null || selectionEnd == null)
            return;
          const beforeTxt = value.slice(0, Math.max(0, selectionStart));
          const afterTxt = value.slice(Math.max(0, selectionEnd));
          selectionRef.value = {
            selectionStart,
            selectionEnd,
            value,
            beforeTxt,
            afterTxt
          };
        }
        function setCursor() {
          if (input.value == void 0 || selectionRef.value == void 0)
            return;
          const { value } = input.value;
          const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
          if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
            return;
          let startPos = value.length;
          if (value.endsWith(afterTxt)) {
            startPos = value.length - afterTxt.length;
          } else if (value.startsWith(beforeTxt)) {
            startPos = beforeTxt.length;
          } else {
            const beforeLastChar = beforeTxt[selectionStart - 1];
            const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
            if (newIndex !== -1) {
              startPos = newIndex + 1;
            }
          }
          input.value.setSelectionRange(startPos, startPos);
        }
        return [recordCursor, setCursor];
      }
      const useSizeProp = buildProp({
        type: String,
        values: componentSizes,
        required: false
      });
      const SIZE_INJECTION_KEY = Symbol("size");
      const useGlobalSize = () => {
        const injectedSize = inject(SIZE_INJECTION_KEY, {});
        return computed(() => {
          return unref(injectedSize.size) || "";
        });
      };
      function useFocusController(target, { afterFocus, beforeBlur, afterBlur } = {}) {
        const instance = getCurrentInstance();
        const { emit: emit2 } = instance;
        const wrapperRef = shallowRef();
        const isFocused = ref(false);
        const handleFocus = (event) => {
          if (isFocused.value)
            return;
          isFocused.value = true;
          emit2("focus", event);
          afterFocus == null ? void 0 : afterFocus();
        };
        const handleBlur = (event) => {
          var _a2;
          const cancelBlur = isFunction$1(beforeBlur) ? beforeBlur(event) : false;
          if (cancelBlur || event.relatedTarget && ((_a2 = wrapperRef.value) == null ? void 0 : _a2.contains(event.relatedTarget)))
            return;
          isFocused.value = false;
          emit2("blur", event);
          afterBlur == null ? void 0 : afterBlur();
        };
        const handleClick = () => {
          var _a2;
          (_a2 = target.value) == null ? void 0 : _a2.focus();
        };
        watch(wrapperRef, (el) => {
          if (el) {
            el.setAttribute("tabindex", "-1");
          }
        });
        useEventListener(wrapperRef, "click", handleClick);
        return {
          wrapperRef,
          isFocused,
          handleFocus,
          handleBlur
        };
      }
      const configProviderContextKey = Symbol();
      const globalConfig = ref();
      function useGlobalConfig(key, defaultValue = void 0) {
        const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
        if (key) {
          return computed(() => {
            var _a2, _b;
            return (_b = (_a2 = config.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
          });
        } else {
          return config;
        }
      }
      function useGlobalComponentSettings(block, sizeFallback) {
        const config = useGlobalConfig();
        const ns = useNamespace(block, computed(() => {
          var _a2;
          return ((_a2 = config.value) == null ? void 0 : _a2.namespace) || defaultNamespace;
        }));
        const locale = useLocale(computed(() => {
          var _a2;
          return (_a2 = config.value) == null ? void 0 : _a2.locale;
        }));
        const zIndex2 = useZIndex(computed(() => {
          var _a2;
          return ((_a2 = config.value) == null ? void 0 : _a2.zIndex) || defaultInitialZIndex;
        }));
        const size2 = computed(() => {
          var _a2;
          return unref(sizeFallback) || ((_a2 = config.value) == null ? void 0 : _a2.size) || "";
        });
        provideGlobalConfig(computed(() => unref(config) || {}));
        return {
          ns,
          locale,
          zIndex: zIndex2,
          size: size2
        };
      }
      const provideGlobalConfig = (config, app, global2 = false) => {
        var _a2;
        const inSetup = !!getCurrentInstance();
        const oldConfig = inSetup ? useGlobalConfig() : void 0;
        const provideFn = (_a2 = app == null ? void 0 : app.provide) != null ? _a2 : inSetup ? provide : void 0;
        if (!provideFn) {
          return;
        }
        const context = computed(() => {
          const cfg = unref(config);
          if (!(oldConfig == null ? void 0 : oldConfig.value))
            return cfg;
          return mergeConfig(oldConfig.value, cfg);
        });
        provideFn(configProviderContextKey, context);
        provideFn(localeContextKey, computed(() => context.value.locale));
        provideFn(namespaceContextKey, computed(() => context.value.namespace));
        provideFn(zIndexContextKey, computed(() => context.value.zIndex));
        provideFn(SIZE_INJECTION_KEY, {
          size: computed(() => context.value.size || "")
        });
        if (global2 || !globalConfig.value) {
          globalConfig.value = context.value;
        }
        return context;
      };
      const mergeConfig = (a, b) => {
        var _a2;
        const keys2 = [.../* @__PURE__ */ new Set([...keysOf(a), ...keysOf(b)])];
        const obj = {};
        for (const key of keys2) {
          obj[key] = (_a2 = b[key]) != null ? _a2 : a[key];
        }
        return obj;
      };
      const configProviderProps = buildProps({
        a11y: {
          type: Boolean,
          default: true
        },
        locale: {
          type: definePropType(Object)
        },
        size: useSizeProp,
        button: {
          type: definePropType(Object)
        },
        experimentalFeatures: {
          type: definePropType(Object)
        },
        keyboardNavigation: {
          type: Boolean,
          default: true
        },
        message: {
          type: definePropType(Object)
        },
        zIndex: Number,
        namespace: {
          type: String,
          default: "el"
        }
      });
      const messageConfig = {};
      const ConfigProvider = /* @__PURE__ */ defineComponent({
        name: "ElConfigProvider",
        props: configProviderProps,
        setup(props, { slots }) {
          watch(() => props.message, (val) => {
            Object.assign(messageConfig, val != null ? val : {});
          }, { immediate: true, deep: true });
          const config = provideGlobalConfig(props);
          return () => renderSlot(slots, "default", { config: config == null ? void 0 : config.value });
        }
      });
      const ElConfigProvider = withInstall(ConfigProvider);
      var _export_sfc = (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      };
      const iconProps = buildProps({
        size: {
          type: definePropType([Number, String])
        },
        color: {
          type: String
        }
      });
      const __default__$g = /* @__PURE__ */ defineComponent({
        name: "ElIcon",
        inheritAttrs: false
      });
      const _sfc_main$y = /* @__PURE__ */ defineComponent({
        ...__default__$g,
        props: iconProps,
        setup(__props) {
          const props = __props;
          const ns = useNamespace("icon");
          const style2 = computed(() => {
            const { size: size2, color } = props;
            if (!size2 && !color)
              return {};
            return {
              fontSize: isUndefined(size2) ? void 0 : addUnit(size2),
              "--color": color
            };
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("i", mergeProps({
              class: unref(ns).b(),
              style: unref(style2)
            }, _ctx.$attrs), [
              renderSlot(_ctx.$slots, "default")
            ], 16);
          };
        }
      });
      var Icon = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__file", "icon.vue"]]);
      const ElIcon = withInstall(Icon);
      const formContextKey = Symbol("formContextKey");
      const formItemContextKey = Symbol("formItemContextKey");
      const useFormSize = (fallback, ignore = {}) => {
        const emptyRef = ref(void 0);
        const size2 = ignore.prop ? emptyRef : useProp("size");
        const globalConfig2 = ignore.global ? emptyRef : useGlobalSize();
        const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
        const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
        return computed(() => size2.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
      };
      const useFormDisabled = (fallback) => {
        const disabled = useProp("disabled");
        const form = inject(formContextKey, void 0);
        return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
      };
      const useFormItem = () => {
        const form = inject(formContextKey, void 0);
        const formItem = inject(formItemContextKey, void 0);
        return {
          form,
          formItem
        };
      };
      const useFormItemInputId = (props, {
        formItemContext,
        disableIdGeneration,
        disableIdManagement
      }) => {
        if (!disableIdGeneration) {
          disableIdGeneration = ref(false);
        }
        if (!disableIdManagement) {
          disableIdManagement = ref(false);
        }
        const inputId = ref();
        let idUnwatch = void 0;
        const isLabeledByFormItem = computed(() => {
          var _a2;
          return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
        });
        onMounted(() => {
          idUnwatch = watch([toRef(props, "id"), disableIdGeneration], ([id, disableIdGeneration2]) => {
            const newId = id != null ? id : !disableIdGeneration2 ? useId().value : void 0;
            if (newId !== inputId.value) {
              if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
                inputId.value && formItemContext.removeInputId(inputId.value);
                if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                  formItemContext.addInputId(newId);
                }
              }
              inputId.value = newId;
            }
          }, { immediate: true });
        });
        onUnmounted(() => {
          idUnwatch && idUnwatch();
          if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
            inputId.value && formItemContext.removeInputId(inputId.value);
          }
        });
        return {
          isLabeledByFormItem,
          inputId
        };
      };
      let hiddenTextarea = void 0;
      const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  ${isFirefox() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
      const CONTEXT_STYLE = [
        "letter-spacing",
        "line-height",
        "padding-top",
        "padding-bottom",
        "font-family",
        "font-weight",
        "font-size",
        "text-rendering",
        "text-transform",
        "width",
        "text-indent",
        "padding-left",
        "padding-right",
        "border-width",
        "box-sizing"
      ];
      function calculateNodeStyling(targetElement) {
        const style2 = window.getComputedStyle(targetElement);
        const boxSizing = style2.getPropertyValue("box-sizing");
        const paddingSize = Number.parseFloat(style2.getPropertyValue("padding-bottom")) + Number.parseFloat(style2.getPropertyValue("padding-top"));
        const borderSize = Number.parseFloat(style2.getPropertyValue("border-bottom-width")) + Number.parseFloat(style2.getPropertyValue("border-top-width"));
        const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style2.getPropertyValue(name)}`).join(";");
        return { contextStyle, paddingSize, borderSize, boxSizing };
      }
      function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
        var _a2;
        if (!hiddenTextarea) {
          hiddenTextarea = document.createElement("textarea");
          document.body.appendChild(hiddenTextarea);
        }
        const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
        hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
        hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
        let height = hiddenTextarea.scrollHeight;
        const result = {};
        if (boxSizing === "border-box") {
          height = height + borderSize;
        } else if (boxSizing === "content-box") {
          height = height - paddingSize;
        }
        hiddenTextarea.value = "";
        const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (isNumber(minRows)) {
          let minHeight = singleRowHeight * minRows;
          if (boxSizing === "border-box") {
            minHeight = minHeight + paddingSize + borderSize;
          }
          height = Math.max(minHeight, height);
          result.minHeight = `${minHeight}px`;
        }
        if (isNumber(maxRows)) {
          let maxHeight = singleRowHeight * maxRows;
          if (boxSizing === "border-box") {
            maxHeight = maxHeight + paddingSize + borderSize;
          }
          height = Math.min(maxHeight, height);
        }
        result.height = `${height}px`;
        (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
        hiddenTextarea = void 0;
        return result;
      }
      const inputProps = buildProps({
        id: {
          type: String,
          default: void 0
        },
        size: useSizeProp,
        disabled: Boolean,
        modelValue: {
          type: definePropType([
            String,
            Number,
            Object
          ]),
          default: ""
        },
        maxlength: {
          type: [String, Number]
        },
        minlength: {
          type: [String, Number]
        },
        type: {
          type: String,
          default: "text"
        },
        resize: {
          type: String,
          values: ["none", "both", "horizontal", "vertical"]
        },
        autosize: {
          type: definePropType([Boolean, Object]),
          default: false
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        formatter: {
          type: Function
        },
        parser: {
          type: Function
        },
        placeholder: {
          type: String
        },
        form: {
          type: String
        },
        readonly: {
          type: Boolean,
          default: false
        },
        clearable: {
          type: Boolean,
          default: false
        },
        showPassword: {
          type: Boolean,
          default: false
        },
        showWordLimit: {
          type: Boolean,
          default: false
        },
        suffixIcon: {
          type: iconPropType
        },
        prefixIcon: {
          type: iconPropType
        },
        containerRole: {
          type: String,
          default: void 0
        },
        label: {
          type: String,
          default: void 0
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        inputStyle: {
          type: definePropType([Object, Array, String]),
          default: () => mutable({})
        },
        autofocus: {
          type: Boolean,
          default: false
        }
      });
      const inputEmits = {
        [UPDATE_MODEL_EVENT]: (value) => isString$1(value),
        input: (value) => isString$1(value),
        change: (value) => isString$1(value),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent,
        clear: () => true,
        mouseleave: (evt) => evt instanceof MouseEvent,
        mouseenter: (evt) => evt instanceof MouseEvent,
        keydown: (evt) => evt instanceof Event,
        compositionstart: (evt) => evt instanceof CompositionEvent,
        compositionupdate: (evt) => evt instanceof CompositionEvent,
        compositionend: (evt) => evt instanceof CompositionEvent
      };
      const _hoisted_1$g = ["role"];
      const _hoisted_2$d = ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"];
      const _hoisted_3$8 = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"];
      const __default__$f = /* @__PURE__ */ defineComponent({
        name: "ElInput",
        inheritAttrs: false
      });
      const _sfc_main$x = /* @__PURE__ */ defineComponent({
        ...__default__$f,
        props: inputProps,
        emits: inputEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const rawAttrs = useAttrs$1();
          const slots = useSlots();
          const containerAttrs = computed(() => {
            const comboBoxAttrs = {};
            if (props.containerRole === "combobox") {
              comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
              comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
              comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
            }
            return comboBoxAttrs;
          });
          const containerKls = computed(() => [
            props.type === "textarea" ? nsTextarea.b() : nsInput.b(),
            nsInput.m(inputSize.value),
            nsInput.is("disabled", inputDisabled.value),
            nsInput.is("exceed", inputExceed.value),
            {
              [nsInput.b("group")]: slots.prepend || slots.append,
              [nsInput.bm("group", "append")]: slots.append,
              [nsInput.bm("group", "prepend")]: slots.prepend,
              [nsInput.m("prefix")]: slots.prefix || props.prefixIcon,
              [nsInput.m("suffix")]: slots.suffix || props.suffixIcon || props.clearable || props.showPassword,
              [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value
            },
            rawAttrs.class
          ]);
          const wrapperKls = computed(() => [
            nsInput.e("wrapper"),
            nsInput.is("focus", isFocused.value)
          ]);
          const attrs = useAttrs({
            excludeKeys: computed(() => {
              return Object.keys(containerAttrs.value);
            })
          });
          const { form: elForm, formItem: elFormItem } = useFormItem();
          const { inputId } = useFormItemInputId(props, {
            formItemContext: elFormItem
          });
          const inputSize = useFormSize();
          const inputDisabled = useFormDisabled();
          const nsInput = useNamespace("input");
          const nsTextarea = useNamespace("textarea");
          const input = shallowRef();
          const textarea = shallowRef();
          const hovering = ref(false);
          const isComposing = ref(false);
          const passwordVisible = ref(false);
          const countStyle = ref();
          const textareaCalcStyle = shallowRef(props.inputStyle);
          const _ref = computed(() => input.value || textarea.value);
          const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, {
            afterBlur() {
              var _a2;
              if (props.validateEvent) {
                (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "blur").catch((err) => debugWarn());
              }
            }
          });
          const needStatusIcon = computed(() => {
            var _a2;
            return (_a2 = elForm == null ? void 0 : elForm.statusIcon) != null ? _a2 : false;
          });
          const validateState = computed(() => (elFormItem == null ? void 0 : elFormItem.validateState) || "");
          const validateIcon = computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
          const passwordIcon = computed(() => passwordVisible.value ? view_default : hide_default);
          const containerStyle = computed(() => [
            rawAttrs.style
          ]);
          const textareaStyle = computed(() => [
            props.inputStyle,
            textareaCalcStyle.value,
            { resize: props.resize }
          ]);
          const nativeInputValue = computed(() => isNil(props.modelValue) ? "" : String(props.modelValue));
          const showClear = computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
          const showPwdVisible = computed(() => props.showPassword && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || isFocused.value));
          const isWordLimitVisible = computed(() => props.showWordLimit && !!props.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
          const textLength = computed(() => nativeInputValue.value.length);
          const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(props.maxlength));
          const suffixVisible = computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
          const [recordCursor, setCursor] = useCursor(input);
          useResizeObserver(textarea, (entries) => {
            onceInitSizeTextarea();
            if (!isWordLimitVisible.value || props.resize !== "both")
              return;
            const entry = entries[0];
            const { width } = entry.contentRect;
            countStyle.value = {
              right: `calc(100% - ${width + 15 + 6}px)`
            };
          });
          const resizeTextarea = () => {
            const { type, autosize } = props;
            if (!isClient || type !== "textarea" || !textarea.value)
              return;
            if (autosize) {
              const minRows = isObject$1(autosize) ? autosize.minRows : void 0;
              const maxRows = isObject$1(autosize) ? autosize.maxRows : void 0;
              const textareaStyle2 = calcTextareaHeight(textarea.value, minRows, maxRows);
              textareaCalcStyle.value = {
                overflowY: "hidden",
                ...textareaStyle2
              };
              nextTick(() => {
                textarea.value.offsetHeight;
                textareaCalcStyle.value = textareaStyle2;
              });
            } else {
              textareaCalcStyle.value = {
                minHeight: calcTextareaHeight(textarea.value).minHeight
              };
            }
          };
          const createOnceInitResize = (resizeTextarea2) => {
            let isInit = false;
            return () => {
              var _a2;
              if (isInit || !props.autosize)
                return;
              const isElHidden = ((_a2 = textarea.value) == null ? void 0 : _a2.offsetParent) === null;
              if (!isElHidden) {
                resizeTextarea2();
                isInit = true;
              }
            };
          };
          const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
          const setNativeInputValue = () => {
            const input2 = _ref.value;
            const formatterValue = props.formatter ? props.formatter(nativeInputValue.value) : nativeInputValue.value;
            if (!input2 || input2.value === formatterValue)
              return;
            input2.value = formatterValue;
          };
          const handleInput = async (event) => {
            recordCursor();
            let { value } = event.target;
            if (props.formatter) {
              value = props.parser ? props.parser(value) : value;
            }
            if (isComposing.value)
              return;
            if (value === nativeInputValue.value) {
              setNativeInputValue();
              return;
            }
            emit2(UPDATE_MODEL_EVENT, value);
            emit2("input", value);
            await nextTick();
            setNativeInputValue();
            setCursor();
          };
          const handleChange = (event) => {
            emit2("change", event.target.value);
          };
          const handleCompositionStart = (event) => {
            emit2("compositionstart", event);
            isComposing.value = true;
          };
          const handleCompositionUpdate = (event) => {
            var _a2;
            emit2("compositionupdate", event);
            const text = (_a2 = event.target) == null ? void 0 : _a2.value;
            const lastCharacter = text[text.length - 1] || "";
            isComposing.value = !isKorean(lastCharacter);
          };
          const handleCompositionEnd = (event) => {
            emit2("compositionend", event);
            if (isComposing.value) {
              isComposing.value = false;
              handleInput(event);
            }
          };
          const handlePasswordVisible = () => {
            passwordVisible.value = !passwordVisible.value;
            focus();
          };
          const focus = async () => {
            var _a2;
            await nextTick();
            (_a2 = _ref.value) == null ? void 0 : _a2.focus();
          };
          const blur = () => {
            var _a2;
            return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
          };
          const handleMouseLeave = (evt) => {
            hovering.value = false;
            emit2("mouseleave", evt);
          };
          const handleMouseEnter = (evt) => {
            hovering.value = true;
            emit2("mouseenter", evt);
          };
          const handleKeydown = (evt) => {
            emit2("keydown", evt);
          };
          const select = () => {
            var _a2;
            (_a2 = _ref.value) == null ? void 0 : _a2.select();
          };
          const clear2 = () => {
            emit2(UPDATE_MODEL_EVENT, "");
            emit2("change", "");
            emit2("clear");
            emit2("input", "");
          };
          watch(() => props.modelValue, () => {
            var _a2;
            nextTick(() => resizeTextarea());
            if (props.validateEvent) {
              (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn());
            }
          });
          watch(nativeInputValue, () => setNativeInputValue());
          watch(() => props.type, async () => {
            await nextTick();
            setNativeInputValue();
            resizeTextarea();
          });
          onMounted(() => {
            if (!props.formatter && props.parser)
              ;
            setNativeInputValue();
            nextTick(resizeTextarea);
          });
          expose({
            input,
            textarea,
            ref: _ref,
            textareaStyle,
            autosize: toRef(props, "autosize"),
            focus,
            blur,
            select,
            clear: clear2,
            resizeTextarea
          });
          return (_ctx, _cache) => {
            return withDirectives((openBlock(), createElementBlock("div", mergeProps(unref(containerAttrs), {
              class: unref(containerKls),
              style: unref(containerStyle),
              role: _ctx.containerRole,
              onMouseenter: handleMouseEnter,
              onMouseleave: handleMouseLeave
            }), [
              createCommentVNode(" input "),
              _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createCommentVNode(" prepend slot "),
                _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(nsInput).be("group", "prepend"))
                }, [
                  renderSlot(_ctx.$slots, "prepend")
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  ref_key: "wrapperRef",
                  ref: wrapperRef,
                  class: normalizeClass(unref(wrapperKls))
                }, [
                  createCommentVNode(" prefix slot "),
                  _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(nsInput).e("prefix"))
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(nsInput).e("prefix-inner"))
                    }, [
                      renderSlot(_ctx.$slots, "prefix"),
                      _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass(unref(nsInput).e("icon"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true),
                  createBaseVNode("input", mergeProps({
                    id: unref(inputId),
                    ref_key: "input",
                    ref: input,
                    class: unref(nsInput).e("inner")
                  }, unref(attrs), {
                    minlength: _ctx.minlength,
                    maxlength: _ctx.maxlength,
                    type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                    disabled: unref(inputDisabled),
                    readonly: _ctx.readonly,
                    autocomplete: _ctx.autocomplete,
                    tabindex: _ctx.tabindex,
                    "aria-label": _ctx.label,
                    placeholder: _ctx.placeholder,
                    style: _ctx.inputStyle,
                    form: _ctx.form,
                    autofocus: _ctx.autofocus,
                    onCompositionstart: handleCompositionStart,
                    onCompositionupdate: handleCompositionUpdate,
                    onCompositionend: handleCompositionEnd,
                    onInput: handleInput,
                    onFocus: _cache[0] || (_cache[0] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                    onBlur: _cache[1] || (_cache[1] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                    onChange: handleChange,
                    onKeydown: handleKeydown
                  }), null, 16, _hoisted_2$d),
                  createCommentVNode(" suffix slot "),
                  unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass(unref(nsInput).e("suffix"))
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(nsInput).e("suffix-inner"))
                    }, [
                      !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        renderSlot(_ctx.$slots, "suffix"),
                        _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                          key: 0,
                          class: normalizeClass(unref(nsInput).e("icon"))
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : createCommentVNode("v-if", true)
                      ], 64)) : createCommentVNode("v-if", true),
                      unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 1,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                        onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                        onClick: clear2
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(circle_close_default))
                        ]),
                        _: 1
                      }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                      unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 2,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                        onClick: handlePasswordVisible
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true),
                      unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                        key: 3,
                        class: normalizeClass(unref(nsInput).e("count"))
                      }, [
                        createBaseVNode("span", {
                          class: normalizeClass(unref(nsInput).e("count-inner"))
                        }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 3)
                      ], 2)) : createCommentVNode("v-if", true),
                      unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 4,
                        class: normalizeClass([
                          unref(nsInput).e("icon"),
                          unref(nsInput).e("validateIcon"),
                          unref(nsInput).is("loading", unref(validateState) === "validating")
                        ])
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true)
                ], 2),
                createCommentVNode(" append slot "),
                _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(nsInput).be("group", "append"))
                }, [
                  renderSlot(_ctx.$slots, "append")
                ], 2)) : createCommentVNode("v-if", true)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createCommentVNode(" textarea "),
                createBaseVNode("textarea", mergeProps({
                  id: unref(inputId),
                  ref_key: "textarea",
                  ref: textarea,
                  class: unref(nsTextarea).e("inner")
                }, unref(attrs), {
                  tabindex: _ctx.tabindex,
                  disabled: unref(inputDisabled),
                  readonly: _ctx.readonly,
                  autocomplete: _ctx.autocomplete,
                  style: unref(textareaStyle),
                  "aria-label": _ctx.label,
                  placeholder: _ctx.placeholder,
                  form: _ctx.form,
                  autofocus: _ctx.autofocus,
                  onCompositionstart: handleCompositionStart,
                  onCompositionupdate: handleCompositionUpdate,
                  onCompositionend: handleCompositionEnd,
                  onInput: handleInput,
                  onFocus: _cache[2] || (_cache[2] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                  onBlur: _cache[3] || (_cache[3] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                  onChange: handleChange,
                  onKeydown: handleKeydown
                }), null, 16, _hoisted_3$8),
                unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  style: normalizeStyle(countStyle.value),
                  class: normalizeClass(unref(nsInput).e("count"))
                }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 7)) : createCommentVNode("v-if", true)
              ], 64))
            ], 16, _hoisted_1$g)), [
              [vShow, _ctx.type !== "hidden"]
            ]);
          };
        }
      });
      var Input = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["__file", "input.vue"]]);
      const ElInput = withInstall(Input);
      const GAP = 4;
      const BAR_MAP = {
        vertical: {
          offset: "offsetHeight",
          scroll: "scrollTop",
          scrollSize: "scrollHeight",
          size: "height",
          key: "vertical",
          axis: "Y",
          client: "clientY",
          direction: "top"
        },
        horizontal: {
          offset: "offsetWidth",
          scroll: "scrollLeft",
          scrollSize: "scrollWidth",
          size: "width",
          key: "horizontal",
          axis: "X",
          client: "clientX",
          direction: "left"
        }
      };
      const renderThumbStyle = ({
        move,
        size: size2,
        bar
      }) => ({
        [bar.size]: size2,
        transform: `translate${bar.axis}(${move}%)`
      });
      const scrollbarContextKey = Symbol("scrollbarContextKey");
      const thumbProps = buildProps({
        vertical: Boolean,
        size: String,
        move: Number,
        ratio: {
          type: Number,
          required: true
        },
        always: Boolean
      });
      const COMPONENT_NAME$2 = "Thumb";
      const _sfc_main$w = /* @__PURE__ */ defineComponent({
        __name: "thumb",
        props: thumbProps,
        setup(__props) {
          const props = __props;
          const scrollbar = inject(scrollbarContextKey);
          const ns = useNamespace("scrollbar");
          if (!scrollbar)
            throwError(COMPONENT_NAME$2, "can not inject scrollbar context");
          const instance = ref();
          const thumb = ref();
          const thumbState = ref({});
          const visible = ref(false);
          let cursorDown = false;
          let cursorLeave = false;
          let originalOnSelectStart = isClient ? document.onselectstart : null;
          const bar = computed(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
          const thumbStyle = computed(() => renderThumbStyle({
            size: props.size,
            move: props.move,
            bar: bar.value
          }));
          const offsetRatio = computed(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);
          const clickThumbHandler = (e2) => {
            var _a2;
            e2.stopPropagation();
            if (e2.ctrlKey || [1, 2].includes(e2.button))
              return;
            (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
            startDrag(e2);
            const el = e2.currentTarget;
            if (!el)
              return;
            thumbState.value[bar.value.axis] = el[bar.value.offset] - (e2[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
          };
          const clickTrackHandler = (e2) => {
            if (!thumb.value || !instance.value || !scrollbar.wrapElement)
              return;
            const offset = Math.abs(e2.target.getBoundingClientRect()[bar.value.direction] - e2[bar.value.client]);
            const thumbHalf = thumb.value[bar.value.offset] / 2;
            const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const startDrag = (e2) => {
            e2.stopImmediatePropagation();
            cursorDown = true;
            document.addEventListener("mousemove", mouseMoveDocumentHandler);
            document.addEventListener("mouseup", mouseUpDocumentHandler);
            originalOnSelectStart = document.onselectstart;
            document.onselectstart = () => false;
          };
          const mouseMoveDocumentHandler = (e2) => {
            if (!instance.value || !thumb.value)
              return;
            if (cursorDown === false)
              return;
            const prevPage = thumbState.value[bar.value.axis];
            if (!prevPage)
              return;
            const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e2[bar.value.client]) * -1;
            const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
            const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const mouseUpDocumentHandler = () => {
            cursorDown = false;
            thumbState.value[bar.value.axis] = 0;
            document.removeEventListener("mousemove", mouseMoveDocumentHandler);
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
            restoreOnselectstart();
            if (cursorLeave)
              visible.value = false;
          };
          const mouseMoveScrollbarHandler = () => {
            cursorLeave = false;
            visible.value = !!props.size;
          };
          const mouseLeaveScrollbarHandler = () => {
            cursorLeave = true;
            visible.value = cursorDown;
          };
          onBeforeUnmount(() => {
            restoreOnselectstart();
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
          });
          const restoreOnselectstart = () => {
            if (document.onselectstart !== originalOnSelectStart)
              document.onselectstart = originalOnSelectStart;
          };
          useEventListener(toRef(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
          useEventListener(toRef(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  ref_key: "instance",
                  ref: instance,
                  class: normalizeClass([unref(ns).e("bar"), unref(ns).is(unref(bar).key)]),
                  onMousedown: clickTrackHandler
                }, [
                  createBaseVNode("div", {
                    ref_key: "thumb",
                    ref: thumb,
                    class: normalizeClass(unref(ns).e("thumb")),
                    style: normalizeStyle(unref(thumbStyle)),
                    onMousedown: clickThumbHandler
                  }, null, 38)
                ], 34), [
                  [vShow, _ctx.always || visible.value]
                ])
              ]),
              _: 1
            }, 8, ["name"]);
          };
        }
      });
      var Thumb = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__file", "thumb.vue"]]);
      const barProps = buildProps({
        always: {
          type: Boolean,
          default: true
        },
        width: String,
        height: String,
        ratioX: {
          type: Number,
          default: 1
        },
        ratioY: {
          type: Number,
          default: 1
        }
      });
      const _sfc_main$v = /* @__PURE__ */ defineComponent({
        __name: "bar",
        props: barProps,
        setup(__props, { expose }) {
          const props = __props;
          const moveX = ref(0);
          const moveY = ref(0);
          const handleScroll = (wrap) => {
            if (wrap) {
              const offsetHeight = wrap.offsetHeight - GAP;
              const offsetWidth = wrap.offsetWidth - GAP;
              moveY.value = wrap.scrollTop * 100 / offsetHeight * props.ratioY;
              moveX.value = wrap.scrollLeft * 100 / offsetWidth * props.ratioX;
            }
          };
          expose({
            handleScroll
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(Thumb, {
                move: moveX.value,
                ratio: _ctx.ratioX,
                size: _ctx.width,
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"]),
              createVNode(Thumb, {
                move: moveY.value,
                ratio: _ctx.ratioY,
                size: _ctx.height,
                vertical: "",
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"])
            ], 64);
          };
        }
      });
      var Bar = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__file", "bar.vue"]]);
      const scrollbarProps = buildProps({
        height: {
          type: [String, Number],
          default: ""
        },
        maxHeight: {
          type: [String, Number],
          default: ""
        },
        native: {
          type: Boolean,
          default: false
        },
        wrapStyle: {
          type: definePropType([String, Object, Array]),
          default: ""
        },
        wrapClass: {
          type: [String, Array],
          default: ""
        },
        viewClass: {
          type: [String, Array],
          default: ""
        },
        viewStyle: {
          type: [String, Array, Object],
          default: ""
        },
        noresize: Boolean,
        tag: {
          type: String,
          default: "div"
        },
        always: Boolean,
        minSize: {
          type: Number,
          default: 20
        },
        id: String,
        role: String,
        ariaLabel: String,
        ariaOrientation: {
          type: String,
          values: ["horizontal", "vertical"]
        }
      });
      const scrollbarEmits = {
        scroll: ({
          scrollTop,
          scrollLeft
        }) => [scrollTop, scrollLeft].every(isNumber)
      };
      const COMPONENT_NAME$1 = "ElScrollbar";
      const __default__$e = /* @__PURE__ */ defineComponent({
        name: COMPONENT_NAME$1
      });
      const _sfc_main$u = /* @__PURE__ */ defineComponent({
        ...__default__$e,
        props: scrollbarProps,
        emits: scrollbarEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const ns = useNamespace("scrollbar");
          let stopResizeObserver = void 0;
          let stopResizeListener = void 0;
          const scrollbarRef = ref();
          const wrapRef = ref();
          const resizeRef = ref();
          const sizeWidth = ref("0");
          const sizeHeight = ref("0");
          const barRef = ref();
          const ratioY = ref(1);
          const ratioX = ref(1);
          const wrapStyle = computed(() => {
            const style2 = {};
            if (props.height)
              style2.height = addUnit(props.height);
            if (props.maxHeight)
              style2.maxHeight = addUnit(props.maxHeight);
            return [props.wrapStyle, style2];
          });
          const wrapKls = computed(() => {
            return [
              props.wrapClass,
              ns.e("wrap"),
              { [ns.em("wrap", "hidden-default")]: !props.native }
            ];
          });
          const resizeKls = computed(() => {
            return [ns.e("view"), props.viewClass];
          });
          const handleScroll = () => {
            var _a2;
            if (wrapRef.value) {
              (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
              emit2("scroll", {
                scrollTop: wrapRef.value.scrollTop,
                scrollLeft: wrapRef.value.scrollLeft
              });
            }
          };
          function scrollTo(arg1, arg2) {
            if (isObject$1(arg1)) {
              wrapRef.value.scrollTo(arg1);
            } else if (isNumber(arg1) && isNumber(arg2)) {
              wrapRef.value.scrollTo(arg1, arg2);
            }
          }
          const setScrollTop = (value) => {
            if (!isNumber(value)) {
              return;
            }
            wrapRef.value.scrollTop = value;
          };
          const setScrollLeft = (value) => {
            if (!isNumber(value)) {
              return;
            }
            wrapRef.value.scrollLeft = value;
          };
          const update = () => {
            if (!wrapRef.value)
              return;
            const offsetHeight = wrapRef.value.offsetHeight - GAP;
            const offsetWidth = wrapRef.value.offsetWidth - GAP;
            const originalHeight = offsetHeight ** 2 / wrapRef.value.scrollHeight;
            const originalWidth = offsetWidth ** 2 / wrapRef.value.scrollWidth;
            const height = Math.max(originalHeight, props.minSize);
            const width = Math.max(originalWidth, props.minSize);
            ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
            ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
            sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
            sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
          };
          watch(() => props.noresize, (noresize) => {
            if (noresize) {
              stopResizeObserver == null ? void 0 : stopResizeObserver();
              stopResizeListener == null ? void 0 : stopResizeListener();
            } else {
              ({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update));
              stopResizeListener = useEventListener("resize", update);
            }
          }, { immediate: true });
          watch(() => [props.maxHeight, props.height], () => {
            if (!props.native)
              nextTick(() => {
                var _a2;
                update();
                if (wrapRef.value) {
                  (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
                }
              });
          });
          provide(scrollbarContextKey, reactive({
            scrollbarElement: scrollbarRef,
            wrapElement: wrapRef
          }));
          onMounted(() => {
            if (!props.native)
              nextTick(() => {
                update();
              });
          });
          onUpdated(() => update());
          expose({
            wrapRef,
            update,
            scrollTo,
            setScrollTop,
            setScrollLeft,
            handleScroll
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "scrollbarRef",
              ref: scrollbarRef,
              class: normalizeClass(unref(ns).b())
            }, [
              createBaseVNode("div", {
                ref_key: "wrapRef",
                ref: wrapRef,
                class: normalizeClass(unref(wrapKls)),
                style: normalizeStyle(unref(wrapStyle)),
                onScroll: handleScroll
              }, [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
                  id: _ctx.id,
                  ref_key: "resizeRef",
                  ref: resizeRef,
                  class: normalizeClass(unref(resizeKls)),
                  style: normalizeStyle(_ctx.viewStyle),
                  role: _ctx.role,
                  "aria-label": _ctx.ariaLabel,
                  "aria-orientation": _ctx.ariaOrientation
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
              ], 38),
              !_ctx.native ? (openBlock(), createBlock(Bar, {
                key: 0,
                ref_key: "barRef",
                ref: barRef,
                height: sizeHeight.value,
                width: sizeWidth.value,
                always: _ctx.always,
                "ratio-x": ratioX.value,
                "ratio-y": ratioY.value
              }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"])) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Scrollbar = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__file", "scrollbar.vue"]]);
      const ElScrollbar = withInstall(Scrollbar);
      const POPPER_INJECTION_KEY = Symbol("popper");
      const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
      const roleTypes = [
        "dialog",
        "grid",
        "group",
        "listbox",
        "menu",
        "navigation",
        "tooltip",
        "tree"
      ];
      const popperProps = buildProps({
        role: {
          type: String,
          values: roleTypes,
          default: "tooltip"
        }
      });
      const __default__$d = /* @__PURE__ */ defineComponent({
        name: "ElPopper",
        inheritAttrs: false
      });
      const _sfc_main$t = /* @__PURE__ */ defineComponent({
        ...__default__$d,
        props: popperProps,
        setup(__props, { expose }) {
          const props = __props;
          const triggerRef = ref();
          const popperInstanceRef = ref();
          const contentRef = ref();
          const referenceRef = ref();
          const role = computed(() => props.role);
          const popperProvides = {
            triggerRef,
            popperInstanceRef,
            contentRef,
            referenceRef,
            role
          };
          expose(popperProvides);
          provide(POPPER_INJECTION_KEY, popperProvides);
          return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
          };
        }
      });
      var Popper = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__file", "popper.vue"]]);
      const popperArrowProps = buildProps({
        arrowOffset: {
          type: Number,
          default: 5
        }
      });
      const __default__$c = /* @__PURE__ */ defineComponent({
        name: "ElPopperArrow",
        inheritAttrs: false
      });
      const _sfc_main$s = /* @__PURE__ */ defineComponent({
        ...__default__$c,
        props: popperArrowProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("popper");
          const { arrowOffset, arrowRef, arrowStyle } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
          watch(() => props.arrowOffset, (val) => {
            arrowOffset.value = val;
          });
          onBeforeUnmount(() => {
            arrowRef.value = void 0;
          });
          expose({
            arrowRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              ref_key: "arrowRef",
              ref: arrowRef,
              class: normalizeClass(unref(ns).e("arrow")),
              style: normalizeStyle(unref(arrowStyle)),
              "data-popper-arrow": ""
            }, null, 6);
          };
        }
      });
      var ElPopperArrow = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__file", "arrow.vue"]]);
      const NAME = "ElOnlyChild";
      const OnlyChild = /* @__PURE__ */ defineComponent({
        name: NAME,
        setup(_2, {
          slots,
          attrs
        }) {
          var _a2;
          const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
          const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
          return () => {
            var _a22;
            const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
            if (!defaultSlot)
              return null;
            if (defaultSlot.length > 1) {
              return null;
            }
            const firstLegitNode = findFirstLegitChild(defaultSlot);
            if (!firstLegitNode) {
              return null;
            }
            return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
          };
        }
      });
      function findFirstLegitChild(node) {
        if (!node)
          return null;
        const children = node;
        for (const child of children) {
          if (isObject$1(child)) {
            switch (child.type) {
              case Comment:
                continue;
              case Text:
              case "svg":
                return wrapTextContent(child);
              case Fragment:
                return findFirstLegitChild(child.children);
              default:
                return child;
            }
          }
          return wrapTextContent(child);
        }
        return null;
      }
      function wrapTextContent(s2) {
        const ns = useNamespace("only-child");
        return createVNode("span", {
          "class": ns.e("content")
        }, [s2]);
      }
      const popperTriggerProps = buildProps({
        virtualRef: {
          type: definePropType(Object)
        },
        virtualTriggering: Boolean,
        onMouseenter: {
          type: definePropType(Function)
        },
        onMouseleave: {
          type: definePropType(Function)
        },
        onClick: {
          type: definePropType(Function)
        },
        onKeydown: {
          type: definePropType(Function)
        },
        onFocus: {
          type: definePropType(Function)
        },
        onBlur: {
          type: definePropType(Function)
        },
        onContextmenu: {
          type: definePropType(Function)
        },
        id: String,
        open: Boolean
      });
      const __default__$b = /* @__PURE__ */ defineComponent({
        name: "ElPopperTrigger",
        inheritAttrs: false
      });
      const _sfc_main$r = /* @__PURE__ */ defineComponent({
        ...__default__$b,
        props: popperTriggerProps,
        setup(__props, { expose }) {
          const props = __props;
          const { role, triggerRef } = inject(POPPER_INJECTION_KEY, void 0);
          useForwardRef(triggerRef);
          const ariaControls = computed(() => {
            return ariaHaspopup.value ? props.id : void 0;
          });
          const ariaDescribedby = computed(() => {
            if (role && role.value === "tooltip") {
              return props.open && props.id ? props.id : void 0;
            }
            return void 0;
          });
          const ariaHaspopup = computed(() => {
            if (role && role.value !== "tooltip") {
              return role.value;
            }
            return void 0;
          });
          const ariaExpanded = computed(() => {
            return ariaHaspopup.value ? `${props.open}` : void 0;
          });
          let virtualTriggerAriaStopWatch = void 0;
          onMounted(() => {
            watch(() => props.virtualRef, (virtualEl) => {
              if (virtualEl) {
                triggerRef.value = unrefElement(virtualEl);
              }
            }, {
              immediate: true
            });
            watch(triggerRef, (el, prevEl) => {
              virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
              virtualTriggerAriaStopWatch = void 0;
              if (isElement(el)) {
                [
                  "onMouseenter",
                  "onMouseleave",
                  "onClick",
                  "onKeydown",
                  "onFocus",
                  "onBlur",
                  "onContextmenu"
                ].forEach((eventName) => {
                  var _a2;
                  const handler = props[eventName];
                  if (handler) {
                    el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                    (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                  }
                });
                virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                  [
                    "aria-controls",
                    "aria-describedby",
                    "aria-haspopup",
                    "aria-expanded"
                  ].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (isElement(prevEl)) {
                [
                  "aria-controls",
                  "aria-describedby",
                  "aria-haspopup",
                  "aria-expanded"
                ].forEach((key) => prevEl.removeAttribute(key));
              }
            }, {
              immediate: true
            });
          });
          onBeforeUnmount(() => {
            virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
            virtualTriggerAriaStopWatch = void 0;
          });
          expose({
            triggerRef
          });
          return (_ctx, _cache) => {
            return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
              "aria-controls": unref(ariaControls),
              "aria-describedby": unref(ariaDescribedby),
              "aria-expanded": unref(ariaExpanded),
              "aria-haspopup": unref(ariaHaspopup)
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
          };
        }
      });
      var ElPopperTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__file", "trigger.vue"]]);
      const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
      const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
      const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
      const FOCUS_AFTER_TRAPPED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const FOCUSOUT_PREVENTED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
      const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
      const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
      const focusReason = ref();
      const lastUserFocusTimestamp = ref(0);
      const lastAutomatedFocusTimestamp = ref(0);
      let focusReasonUserCount = 0;
      const obtainAllFocusableElements = (element) => {
        const nodes = [];
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
          acceptNode: (node) => {
            const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
            if (node.disabled || node.hidden || isHiddenInput)
              return NodeFilter.FILTER_SKIP;
            return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
          }
        });
        while (walker.nextNode())
          nodes.push(walker.currentNode);
        return nodes;
      };
      const getVisibleElement = (elements, container) => {
        for (const element of elements) {
          if (!isHidden(element, container))
            return element;
        }
      };
      const isHidden = (element, container) => {
        if (getComputedStyle(element).visibility === "hidden")
          return true;
        while (element) {
          if (container && element === container)
            return false;
          if (getComputedStyle(element).display === "none")
            return true;
          element = element.parentElement;
        }
        return false;
      };
      const getEdges = (container) => {
        const focusable = obtainAllFocusableElements(container);
        const first = getVisibleElement(focusable, container);
        const last = getVisibleElement(focusable.reverse(), container);
        return [first, last];
      };
      const isSelectable = (element) => {
        return element instanceof HTMLInputElement && "select" in element;
      };
      const tryFocus = (element, shouldSelect) => {
        if (element && element.focus) {
          const prevFocusedElement = document.activeElement;
          element.focus({ preventScroll: true });
          lastAutomatedFocusTimestamp.value = window.performance.now();
          if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
            element.select();
          }
        }
      };
      function removeFromStack(list, item) {
        const copy = [...list];
        const idx = list.indexOf(item);
        if (idx !== -1) {
          copy.splice(idx, 1);
        }
        return copy;
      }
      const createFocusableStack = () => {
        let stack2 = [];
        const push = (layer) => {
          const currentLayer = stack2[0];
          if (currentLayer && layer !== currentLayer) {
            currentLayer.pause();
          }
          stack2 = removeFromStack(stack2, layer);
          stack2.unshift(layer);
        };
        const remove2 = (layer) => {
          var _a2, _b;
          stack2 = removeFromStack(stack2, layer);
          (_b = (_a2 = stack2[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
        };
        return {
          push,
          remove: remove2
        };
      };
      const focusFirstDescendant = (elements, shouldSelect = false) => {
        const prevFocusedElement = document.activeElement;
        for (const element of elements) {
          tryFocus(element, shouldSelect);
          if (document.activeElement !== prevFocusedElement)
            return;
        }
      };
      const focusableStack = createFocusableStack();
      const isFocusCausedByUserEvent = () => {
        return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
      };
      const notifyFocusReasonPointer = () => {
        focusReason.value = "pointer";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const notifyFocusReasonKeydown = () => {
        focusReason.value = "keyboard";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const useFocusReason = () => {
        onMounted(() => {
          if (focusReasonUserCount === 0) {
            document.addEventListener("mousedown", notifyFocusReasonPointer);
            document.addEventListener("touchstart", notifyFocusReasonPointer);
            document.addEventListener("keydown", notifyFocusReasonKeydown);
          }
          focusReasonUserCount++;
        });
        onBeforeUnmount(() => {
          focusReasonUserCount--;
          if (focusReasonUserCount <= 0) {
            document.removeEventListener("mousedown", notifyFocusReasonPointer);
            document.removeEventListener("touchstart", notifyFocusReasonPointer);
            document.removeEventListener("keydown", notifyFocusReasonKeydown);
          }
        });
        return {
          focusReason,
          lastUserFocusTimestamp,
          lastAutomatedFocusTimestamp
        };
      };
      const createFocusOutPreventedEvent = (detail) => {
        return new CustomEvent(FOCUSOUT_PREVENTED, {
          ...FOCUSOUT_PREVENTED_OPTS,
          detail
        });
      };
      const _sfc_main$q = /* @__PURE__ */ defineComponent({
        name: "ElFocusTrap",
        inheritAttrs: false,
        props: {
          loop: Boolean,
          trapped: Boolean,
          focusTrapEl: Object,
          focusStartEl: {
            type: [Object, String],
            default: "first"
          }
        },
        emits: [
          ON_TRAP_FOCUS_EVT,
          ON_RELEASE_FOCUS_EVT,
          "focusin",
          "focusout",
          "focusout-prevented",
          "release-requested"
        ],
        setup(props, { emit: emit2 }) {
          const forwardRef = ref();
          let lastFocusBeforeTrapped;
          let lastFocusAfterTrapped;
          const { focusReason: focusReason2 } = useFocusReason();
          useEscapeKeydown((event) => {
            if (props.trapped && !focusLayer.paused) {
              emit2("release-requested", event);
            }
          });
          const focusLayer = {
            paused: false,
            pause() {
              this.paused = true;
            },
            resume() {
              this.paused = false;
            }
          };
          const onKeydown = (e2) => {
            if (!props.loop && !props.trapped)
              return;
            if (focusLayer.paused)
              return;
            const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e2;
            const { loop } = props;
            const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
            const currentFocusingEl = document.activeElement;
            if (isTabbing && currentFocusingEl) {
              const container = currentTarget;
              const [first, last] = getEdges(container);
              const isTabbable = first && last;
              if (!isTabbable) {
                if (currentFocusingEl === container) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e2.preventDefault();
                  }
                }
              } else {
                if (!shiftKey && currentFocusingEl === last) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e2.preventDefault();
                    if (loop)
                      tryFocus(first, true);
                  }
                } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e2.preventDefault();
                    if (loop)
                      tryFocus(last, true);
                  }
                }
              }
            }
          };
          provide(FOCUS_TRAP_INJECTION_KEY, {
            focusTrapRef: forwardRef,
            onKeydown
          });
          watch(() => props.focusTrapEl, (focusTrapEl) => {
            if (focusTrapEl) {
              forwardRef.value = focusTrapEl;
            }
          }, { immediate: true });
          watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
            if (forwardRef2) {
              forwardRef2.addEventListener("keydown", onKeydown);
              forwardRef2.addEventListener("focusin", onFocusIn);
              forwardRef2.addEventListener("focusout", onFocusOut);
            }
            if (oldForwardRef) {
              oldForwardRef.removeEventListener("keydown", onKeydown);
              oldForwardRef.removeEventListener("focusin", onFocusIn);
              oldForwardRef.removeEventListener("focusout", onFocusOut);
            }
          });
          const trapOnFocus = (e2) => {
            emit2(ON_TRAP_FOCUS_EVT, e2);
          };
          const releaseOnFocus = (e2) => emit2(ON_RELEASE_FOCUS_EVT, e2);
          const onFocusIn = (e2) => {
            const trapContainer = unref(forwardRef);
            if (!trapContainer)
              return;
            const target = e2.target;
            const relatedTarget = e2.relatedTarget;
            const isFocusedInTrap = target && trapContainer.contains(target);
            if (!props.trapped) {
              const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
              if (!isPrevFocusedInTrap) {
                lastFocusBeforeTrapped = relatedTarget;
              }
            }
            if (isFocusedInTrap)
              emit2("focusin", e2);
            if (focusLayer.paused)
              return;
            if (props.trapped) {
              if (isFocusedInTrap) {
                lastFocusAfterTrapped = target;
              } else {
                tryFocus(lastFocusAfterTrapped, true);
              }
            }
          };
          const onFocusOut = (e2) => {
            const trapContainer = unref(forwardRef);
            if (focusLayer.paused || !trapContainer)
              return;
            if (props.trapped) {
              const relatedTarget = e2.relatedTarget;
              if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
                setTimeout(() => {
                  if (!focusLayer.paused && props.trapped) {
                    const focusoutPreventedEvent = createFocusOutPreventedEvent({
                      focusReason: focusReason2.value
                    });
                    emit2("focusout-prevented", focusoutPreventedEvent);
                    if (!focusoutPreventedEvent.defaultPrevented) {
                      tryFocus(lastFocusAfterTrapped, true);
                    }
                  }
                }, 0);
              }
            } else {
              const target = e2.target;
              const isFocusedInTrap = target && trapContainer.contains(target);
              if (!isFocusedInTrap)
                emit2("focusout", e2);
            }
          };
          async function startTrap() {
            await nextTick();
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              focusableStack.push(focusLayer);
              const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
              lastFocusBeforeTrapped = prevFocusedElement;
              const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
              if (!isPrevFocusContained) {
                const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
                trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
                trapContainer.dispatchEvent(focusEvent);
                if (!focusEvent.defaultPrevented) {
                  nextTick(() => {
                    let focusStartEl = props.focusStartEl;
                    if (!isString$1(focusStartEl)) {
                      tryFocus(focusStartEl);
                      if (document.activeElement !== focusStartEl) {
                        focusStartEl = "first";
                      }
                    }
                    if (focusStartEl === "first") {
                      focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                    }
                    if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                      tryFocus(trapContainer);
                    }
                  });
                }
              }
            }
          }
          function stopTrap() {
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
              const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
                ...FOCUS_AFTER_TRAPPED_OPTS,
                detail: {
                  focusReason: focusReason2.value
                }
              });
              trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              trapContainer.dispatchEvent(releasedEvent);
              if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
                tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
              }
              trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              focusableStack.remove(focusLayer);
            }
          }
          onMounted(() => {
            if (props.trapped) {
              startTrap();
            }
            watch(() => props.trapped, (trapped) => {
              if (trapped) {
                startTrap();
              } else {
                stopTrap();
              }
            });
          });
          onBeforeUnmount(() => {
            if (props.trapped) {
              stopTrap();
            }
          });
          return {
            onKeydown
          };
        }
      });
      function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
      }
      var ElFocusTrap = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$5], ["__file", "focus-trap.vue"]]);
      const POSITIONING_STRATEGIES = ["fixed", "absolute"];
      const popperCoreConfigProps = buildProps({
        boundariesPadding: {
          type: Number,
          default: 0
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: void 0
        },
        gpuAcceleration: {
          type: Boolean,
          default: true
        },
        offset: {
          type: Number,
          default: 12
        },
        placement: {
          type: String,
          values: Ee,
          default: "bottom"
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        strategy: {
          type: String,
          values: POSITIONING_STRATEGIES,
          default: "absolute"
        }
      });
      const popperContentProps = buildProps({
        ...popperCoreConfigProps,
        id: String,
        style: {
          type: definePropType([String, Array, Object])
        },
        className: {
          type: definePropType([String, Array, Object])
        },
        effect: {
          type: String,
          default: "dark"
        },
        visible: Boolean,
        enterable: {
          type: Boolean,
          default: true
        },
        pure: Boolean,
        focusOnShow: {
          type: Boolean,
          default: false
        },
        trapping: {
          type: Boolean,
          default: false
        },
        popperClass: {
          type: definePropType([String, Array, Object])
        },
        popperStyle: {
          type: definePropType([String, Array, Object])
        },
        referenceEl: {
          type: definePropType(Object)
        },
        triggerTargetEl: {
          type: definePropType(Object)
        },
        stopPopperMouseEvent: {
          type: Boolean,
          default: true
        },
        ariaLabel: {
          type: String,
          default: void 0
        },
        virtualTriggering: Boolean,
        zIndex: Number
      });
      const popperContentEmits = {
        mouseenter: (evt) => evt instanceof MouseEvent,
        mouseleave: (evt) => evt instanceof MouseEvent,
        focus: () => true,
        blur: () => true,
        close: () => true
      };
      const buildPopperOptions = (props, modifiers = []) => {
        const { placement, strategy, popperOptions } = props;
        const options = {
          placement,
          strategy,
          ...popperOptions,
          modifiers: [...genModifiers(props), ...modifiers]
        };
        deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
        return options;
      };
      const unwrapMeasurableEl = ($el) => {
        if (!isClient)
          return;
        return unrefElement($el);
      };
      function genModifiers(options) {
        const { offset, gpuAcceleration, fallbackPlacements } = options;
        return [
          {
            name: "offset",
            options: {
              offset: [0, offset != null ? offset : 12]
            }
          },
          {
            name: "preventOverflow",
            options: {
              padding: {
                top: 2,
                bottom: 2,
                left: 5,
                right: 5
              }
            }
          },
          {
            name: "flip",
            options: {
              padding: 5,
              fallbackPlacements
            }
          },
          {
            name: "computeStyles",
            options: {
              gpuAcceleration
            }
          }
        ];
      }
      function deriveExtraModifiers(options, modifiers) {
        if (modifiers) {
          options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
        }
      }
      const DEFAULT_ARROW_OFFSET = 0;
      const usePopperContent = (props) => {
        const { popperInstanceRef, contentRef, triggerRef, role } = inject(POPPER_INJECTION_KEY, void 0);
        const arrowRef = ref();
        const arrowOffset = ref();
        const eventListenerModifier = computed(() => {
          return {
            name: "eventListeners",
            enabled: !!props.visible
          };
        });
        const arrowModifier = computed(() => {
          var _a2;
          const arrowEl = unref(arrowRef);
          const offset = (_a2 = unref(arrowOffset)) != null ? _a2 : DEFAULT_ARROW_OFFSET;
          return {
            name: "arrow",
            enabled: !isUndefined$1(arrowEl),
            options: {
              element: arrowEl,
              padding: offset
            }
          };
        });
        const options = computed(() => {
          return {
            onFirstUpdate: () => {
              update();
            },
            ...buildPopperOptions(props, [
              unref(arrowModifier),
              unref(eventListenerModifier)
            ])
          };
        });
        const computedReference = computed(() => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef));
        const { attributes, state, styles, update, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options);
        watch(instanceRef, (instance) => popperInstanceRef.value = instance);
        onMounted(() => {
          watch(() => {
            var _a2;
            return (_a2 = unref(computedReference)) == null ? void 0 : _a2.getBoundingClientRect();
          }, () => {
            update();
          });
        });
        return {
          attributes,
          arrowRef,
          contentRef,
          instanceRef,
          state,
          styles,
          role,
          forceUpdate,
          update
        };
      };
      const usePopperContentDOM = (props, {
        attributes,
        styles,
        role
      }) => {
        const { nextZIndex } = useZIndex();
        const ns = useNamespace("popper");
        const contentAttrs = computed(() => unref(attributes).popper);
        const contentZIndex = ref(isNumber(props.zIndex) ? props.zIndex : nextZIndex());
        const contentClass = computed(() => [
          ns.b(),
          ns.is("pure", props.pure),
          ns.is(props.effect),
          props.popperClass
        ]);
        const contentStyle = computed(() => {
          return [
            { zIndex: unref(contentZIndex) },
            unref(styles).popper,
            props.popperStyle || {}
          ];
        });
        const ariaModal = computed(() => role.value === "dialog" ? "false" : void 0);
        const arrowStyle = computed(() => unref(styles).arrow || {});
        const updateZIndex = () => {
          contentZIndex.value = isNumber(props.zIndex) ? props.zIndex : nextZIndex();
        };
        return {
          ariaModal,
          arrowStyle,
          contentAttrs,
          contentClass,
          contentStyle,
          contentZIndex,
          updateZIndex
        };
      };
      const usePopperContentFocusTrap = (props, emit2) => {
        const trapped = ref(false);
        const focusStartRef = ref();
        const onFocusAfterTrapped = () => {
          emit2("focus");
        };
        const onFocusAfterReleased = (event) => {
          var _a2;
          if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) !== "pointer") {
            focusStartRef.value = "first";
            emit2("blur");
          }
        };
        const onFocusInTrap = (event) => {
          if (props.visible && !trapped.value) {
            if (event.target) {
              focusStartRef.value = event.target;
            }
            trapped.value = true;
          }
        };
        const onFocusoutPrevented = (event) => {
          if (!props.trapping) {
            if (event.detail.focusReason === "pointer") {
              event.preventDefault();
            }
            trapped.value = false;
          }
        };
        const onReleaseRequested = () => {
          trapped.value = false;
          emit2("close");
        };
        return {
          focusStartRef,
          trapped,
          onFocusAfterReleased,
          onFocusAfterTrapped,
          onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        };
      };
      const __default__$a = /* @__PURE__ */ defineComponent({
        name: "ElPopperContent"
      });
      const _sfc_main$p = /* @__PURE__ */ defineComponent({
        ...__default__$a,
        props: popperContentProps,
        emits: popperContentEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const {
            focusStartRef,
            trapped,
            onFocusAfterReleased,
            onFocusAfterTrapped,
            onFocusInTrap,
            onFocusoutPrevented,
            onReleaseRequested
          } = usePopperContentFocusTrap(props, emit2);
          const { attributes, arrowRef, contentRef, styles, instanceRef, role, update } = usePopperContent(props);
          const {
            ariaModal,
            arrowStyle,
            contentAttrs,
            contentClass,
            contentStyle,
            updateZIndex
          } = usePopperContentDOM(props, {
            styles,
            attributes,
            role
          });
          const formItemContext = inject(formItemContextKey, void 0);
          const arrowOffset = ref();
          provide(POPPER_CONTENT_INJECTION_KEY, {
            arrowStyle,
            arrowRef,
            arrowOffset
          });
          if (formItemContext && (formItemContext.addInputId || formItemContext.removeInputId)) {
            provide(formItemContextKey, {
              ...formItemContext,
              addInputId: NOOP,
              removeInputId: NOOP
            });
          }
          let triggerTargetAriaStopWatch = void 0;
          const updatePopper = (shouldUpdateZIndex = true) => {
            update();
            shouldUpdateZIndex && updateZIndex();
          };
          const togglePopperAlive = () => {
            updatePopper(false);
            if (props.visible && props.focusOnShow) {
              trapped.value = true;
            } else if (props.visible === false) {
              trapped.value = false;
            }
          };
          onMounted(() => {
            watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
              triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
              triggerTargetAriaStopWatch = void 0;
              const el = unref(triggerTargetEl || contentRef.value);
              const prevEl = unref(prevTriggerTargetEl || contentRef.value);
              if (isElement(el)) {
                triggerTargetAriaStopWatch = watch([role, () => props.ariaLabel, ariaModal, () => props.id], (watches) => {
                  ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (prevEl !== el && isElement(prevEl)) {
                ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                  prevEl.removeAttribute(key);
                });
              }
            }, { immediate: true });
            watch(() => props.visible, togglePopperAlive, { immediate: true });
          });
          onBeforeUnmount(() => {
            triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
            triggerTargetAriaStopWatch = void 0;
          });
          expose({
            popperContentRef: contentRef,
            popperInstanceRef: instanceRef,
            updatePopper,
            contentStyle
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", mergeProps({
              ref_key: "contentRef",
              ref: contentRef
            }, unref(contentAttrs), {
              style: unref(contentStyle),
              class: unref(contentClass),
              tabindex: "-1",
              onMouseenter: _cache[0] || (_cache[0] = (e2) => _ctx.$emit("mouseenter", e2)),
              onMouseleave: _cache[1] || (_cache[1] = (e2) => _ctx.$emit("mouseleave", e2))
            }), [
              createVNode(unref(ElFocusTrap), {
                trapped: unref(trapped),
                "trap-on-focus-in": true,
                "focus-trap-el": unref(contentRef),
                "focus-start-el": unref(focusStartRef),
                onFocusAfterTrapped: unref(onFocusAfterTrapped),
                onFocusAfterReleased: unref(onFocusAfterReleased),
                onFocusin: unref(onFocusInTrap),
                onFocusoutPrevented: unref(onFocusoutPrevented),
                onReleaseRequested: unref(onReleaseRequested)
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
            ], 16);
          };
        }
      });
      var ElPopperContent = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__file", "content.vue"]]);
      const ElPopper = withInstall(Popper);
      const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
      const useTooltipContentProps = buildProps({
        ...useDelayedToggleProps,
        ...popperContentProps,
        appendTo: {
          type: definePropType([String, Object])
        },
        content: {
          type: String,
          default: ""
        },
        rawContent: {
          type: Boolean,
          default: false
        },
        persistent: Boolean,
        ariaLabel: String,
        visible: {
          type: definePropType(Boolean),
          default: null
        },
        transition: String,
        teleported: {
          type: Boolean,
          default: true
        },
        disabled: Boolean
      });
      const useTooltipTriggerProps = buildProps({
        ...popperTriggerProps,
        disabled: Boolean,
        trigger: {
          type: definePropType([String, Array]),
          default: "hover"
        },
        triggerKeys: {
          type: definePropType(Array),
          default: () => [EVENT_CODE.enter, EVENT_CODE.space]
        }
      });
      const {
        useModelToggleProps: useTooltipModelToggleProps,
        useModelToggleEmits: useTooltipModelToggleEmits,
        useModelToggle: useTooltipModelToggle
      } = createModelToggleComposable("visible");
      const useTooltipProps = buildProps({
        ...popperProps,
        ...useTooltipModelToggleProps,
        ...useTooltipContentProps,
        ...useTooltipTriggerProps,
        ...popperArrowProps,
        showArrow: {
          type: Boolean,
          default: true
        }
      });
      const tooltipEmits = [
        ...useTooltipModelToggleEmits,
        "before-show",
        "before-hide",
        "show",
        "hide",
        "open",
        "close"
      ];
      const isTriggerType = (trigger2, type) => {
        if (isArray$2(trigger2)) {
          return trigger2.includes(type);
        }
        return trigger2 === type;
      };
      const whenTrigger = (trigger2, type, handler) => {
        return (e2) => {
          isTriggerType(unref(trigger2), type) && handler(e2);
        };
      };
      const __default__$9 = /* @__PURE__ */ defineComponent({
        name: "ElTooltipTrigger"
      });
      const _sfc_main$o = /* @__PURE__ */ defineComponent({
        ...__default__$9,
        props: useTooltipTriggerProps,
        setup(__props, { expose }) {
          const props = __props;
          const ns = useNamespace("tooltip");
          const { controlled, id, open, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const triggerRef = ref(null);
          const stopWhenControlledOrDisabled = () => {
            if (unref(controlled) || props.disabled) {
              return true;
            }
          };
          const trigger2 = toRef(props, "trigger");
          const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onOpen));
          const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onClose));
          const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "click", (e2) => {
            if (e2.button === 0) {
              onToggle(e2);
            }
          }));
          const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onOpen));
          const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onClose));
          const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "contextmenu", (e2) => {
            e2.preventDefault();
            onToggle(e2);
          }));
          const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e2) => {
            const { code } = e2;
            if (props.triggerKeys.includes(code)) {
              e2.preventDefault();
              onToggle(e2);
            }
          });
          expose({
            triggerRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopperTrigger), {
              id: unref(id),
              "virtual-ref": _ctx.virtualRef,
              open: unref(open),
              "virtual-triggering": _ctx.virtualTriggering,
              class: normalizeClass(unref(ns).e("trigger")),
              onBlur: unref(onBlur),
              onClick: unref(onClick),
              onContextmenu: unref(onContextMenu),
              onFocus: unref(onFocus),
              onMouseenter: unref(onMouseenter),
              onMouseleave: unref(onMouseleave),
              onKeydown: unref(onKeydown)
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
          };
        }
      });
      var ElTooltipTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__file", "trigger.vue"]]);
      const __default__$8 = /* @__PURE__ */ defineComponent({
        name: "ElTooltipContent",
        inheritAttrs: false
      });
      const _sfc_main$n = /* @__PURE__ */ defineComponent({
        ...__default__$8,
        props: useTooltipContentProps,
        setup(__props, { expose }) {
          const props = __props;
          const { selector } = usePopperContainerId();
          const ns = useNamespace("tooltip");
          const contentRef = ref(null);
          const destroyed = ref(false);
          const {
            controlled,
            id,
            open,
            trigger: trigger2,
            onClose,
            onOpen,
            onShow,
            onHide,
            onBeforeShow,
            onBeforeHide
          } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const transitionClass = computed(() => {
            return props.transition || `${ns.namespace.value}-fade-in-linear`;
          });
          const persistentRef = computed(() => {
            return props.persistent;
          });
          onBeforeUnmount(() => {
            destroyed.value = true;
          });
          const shouldRender = computed(() => {
            return unref(persistentRef) ? true : unref(open);
          });
          const shouldShow = computed(() => {
            return props.disabled ? false : unref(open);
          });
          const appendTo = computed(() => {
            return props.appendTo || selector.value;
          });
          const contentStyle = computed(() => {
            var _a2;
            return (_a2 = props.style) != null ? _a2 : {};
          });
          const ariaHidden = computed(() => !unref(open));
          const onTransitionLeave = () => {
            onHide();
          };
          const stopWhenControlled = () => {
            if (unref(controlled))
              return true;
          };
          const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
            if (props.enterable && unref(trigger2) === "hover") {
              onOpen();
            }
          });
          const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
            if (unref(trigger2) === "hover") {
              onClose();
            }
          });
          const onBeforeEnter = () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
            onBeforeShow == null ? void 0 : onBeforeShow();
          };
          const onBeforeLeave = () => {
            onBeforeHide == null ? void 0 : onBeforeHide();
          };
          const onAfterShow = () => {
            onShow();
            stopHandle = onClickOutside(computed(() => {
              var _a2;
              return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
            }), () => {
              if (unref(controlled))
                return;
              const $trigger = unref(trigger2);
              if ($trigger !== "hover") {
                onClose();
              }
            });
          };
          const onBlur = () => {
            if (!props.virtualTriggering) {
              onClose();
            }
          };
          let stopHandle;
          watch(() => unref(open), (val) => {
            if (!val) {
              stopHandle == null ? void 0 : stopHandle();
            }
          }, {
            flush: "post"
          });
          watch(() => props.content, () => {
            var _a2, _b;
            (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          });
          expose({
            contentRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              disabled: !_ctx.teleported,
              to: unref(appendTo)
            }, [
              createVNode(Transition, {
                name: unref(transitionClass),
                onAfterLeave: onTransitionLeave,
                onBeforeEnter,
                onAfterEnter: onAfterShow,
                onBeforeLeave
              }, {
                default: withCtx(() => [
                  unref(shouldRender) ? withDirectives((openBlock(), createBlock(unref(ElPopperContent), mergeProps({
                    key: 0,
                    id: unref(id),
                    ref_key: "contentRef",
                    ref: contentRef
                  }, _ctx.$attrs, {
                    "aria-label": _ctx.ariaLabel,
                    "aria-hidden": unref(ariaHidden),
                    "boundaries-padding": _ctx.boundariesPadding,
                    "fallback-placements": _ctx.fallbackPlacements,
                    "gpu-acceleration": _ctx.gpuAcceleration,
                    offset: _ctx.offset,
                    placement: _ctx.placement,
                    "popper-options": _ctx.popperOptions,
                    strategy: _ctx.strategy,
                    effect: _ctx.effect,
                    enterable: _ctx.enterable,
                    pure: _ctx.pure,
                    "popper-class": _ctx.popperClass,
                    "popper-style": [_ctx.popperStyle, unref(contentStyle)],
                    "reference-el": _ctx.referenceEl,
                    "trigger-target-el": _ctx.triggerTargetEl,
                    visible: unref(shouldShow),
                    "z-index": _ctx.zIndex,
                    onMouseenter: unref(onContentEnter),
                    onMouseleave: unref(onContentLeave),
                    onBlur,
                    onClose: unref(onClose)
                  }), {
                    default: withCtx(() => [
                      !destroyed.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                    ]),
                    _: 3
                  }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
                    [vShow, unref(shouldShow)]
                  ]) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["name"])
            ], 8, ["disabled", "to"]);
          };
        }
      });
      var ElTooltipContent = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__file", "content.vue"]]);
      const _hoisted_1$f = ["innerHTML"];
      const _hoisted_2$c = { key: 1 };
      const __default__$7 = /* @__PURE__ */ defineComponent({
        name: "ElTooltip"
      });
      const _sfc_main$m = /* @__PURE__ */ defineComponent({
        ...__default__$7,
        props: useTooltipProps,
        emits: tooltipEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          usePopperContainer();
          const id = useId();
          const popperRef = ref();
          const contentRef = ref();
          const updatePopper = () => {
            var _a2;
            const popperComponent = unref(popperRef);
            if (popperComponent) {
              (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
            }
          };
          const open = ref(false);
          const toggleReason = ref();
          const { show, hide, hasUpdateHandler } = useTooltipModelToggle({
            indicator: open,
            toggleReason
          });
          const { onOpen, onClose } = useDelayedToggle({
            showAfter: toRef(props, "showAfter"),
            hideAfter: toRef(props, "hideAfter"),
            autoClose: toRef(props, "autoClose"),
            open: show,
            close: hide
          });
          const controlled = computed(() => isBoolean(props.visible) && !hasUpdateHandler.value);
          provide(TOOLTIP_INJECTION_KEY, {
            controlled,
            id,
            open: readonly(open),
            trigger: toRef(props, "trigger"),
            onOpen: (event) => {
              onOpen(event);
            },
            onClose: (event) => {
              onClose(event);
            },
            onToggle: (event) => {
              if (unref(open)) {
                onClose(event);
              } else {
                onOpen(event);
              }
            },
            onShow: () => {
              emit2("show", toggleReason.value);
            },
            onHide: () => {
              emit2("hide", toggleReason.value);
            },
            onBeforeShow: () => {
              emit2("before-show", toggleReason.value);
            },
            onBeforeHide: () => {
              emit2("before-hide", toggleReason.value);
            },
            updatePopper
          });
          watch(() => props.disabled, (disabled) => {
            if (disabled && open.value) {
              open.value = false;
            }
          });
          const isFocusInsideContent = (event) => {
            var _a2, _b;
            const popperContent = (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.contentRef) == null ? void 0 : _b.popperContentRef;
            const activeElement = (event == null ? void 0 : event.relatedTarget) || document.activeElement;
            return popperContent && popperContent.contains(activeElement);
          };
          onDeactivated(() => open.value && hide());
          expose({
            popperRef,
            contentRef,
            isFocusInsideContent,
            updatePopper,
            onOpen,
            onClose,
            hide
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopper), {
              ref_key: "popperRef",
              ref: popperRef,
              role: _ctx.role
            }, {
              default: withCtx(() => [
                createVNode(ElTooltipTrigger, {
                  disabled: _ctx.disabled,
                  trigger: _ctx.trigger,
                  "trigger-keys": _ctx.triggerKeys,
                  "virtual-ref": _ctx.virtualRef,
                  "virtual-triggering": _ctx.virtualTriggering
                }, {
                  default: withCtx(() => [
                    _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
                createVNode(ElTooltipContent, {
                  ref_key: "contentRef",
                  ref: contentRef,
                  "aria-label": _ctx.ariaLabel,
                  "boundaries-padding": _ctx.boundariesPadding,
                  content: _ctx.content,
                  disabled: _ctx.disabled,
                  effect: _ctx.effect,
                  enterable: _ctx.enterable,
                  "fallback-placements": _ctx.fallbackPlacements,
                  "hide-after": _ctx.hideAfter,
                  "gpu-acceleration": _ctx.gpuAcceleration,
                  offset: _ctx.offset,
                  persistent: _ctx.persistent,
                  "popper-class": _ctx.popperClass,
                  "popper-style": _ctx.popperStyle,
                  placement: _ctx.placement,
                  "popper-options": _ctx.popperOptions,
                  pure: _ctx.pure,
                  "raw-content": _ctx.rawContent,
                  "reference-el": _ctx.referenceEl,
                  "trigger-target-el": _ctx.triggerTargetEl,
                  "show-after": _ctx.showAfter,
                  strategy: _ctx.strategy,
                  teleported: _ctx.teleported,
                  transition: _ctx.transition,
                  "virtual-triggering": _ctx.virtualTriggering,
                  "z-index": _ctx.zIndex,
                  "append-to": _ctx.appendTo
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "content", {}, () => [
                      _ctx.rawContent ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        innerHTML: _ctx.content
                      }, null, 8, _hoisted_1$f)) : (openBlock(), createElementBlock("span", _hoisted_2$c, toDisplayString(_ctx.content), 1))
                    ]),
                    _ctx.showArrow ? (openBlock(), createBlock(unref(ElPopperArrow), {
                      key: 0,
                      "arrow-offset": _ctx.arrowOffset
                    }, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
              ]),
              _: 3
            }, 8, ["role"]);
          };
        }
      });
      var Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__file", "tooltip.vue"]]);
      const ElTooltip = withInstall(Tooltip);
      const buttonGroupContextKey = Symbol("buttonGroupContextKey");
      const useButton = (props, emit2) => {
        useDeprecated({
          from: "type.text",
          replacement: "link",
          version: "3.0.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
        }, computed(() => props.type === "text"));
        const buttonGroupContext = inject(buttonGroupContextKey, void 0);
        const globalConfig2 = useGlobalConfig("button");
        const { form } = useFormItem();
        const _size = useFormSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
        const _disabled = useFormDisabled();
        const _ref = ref();
        const slots = useSlots();
        const _type = computed(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
        const autoInsertSpace = computed(() => {
          var _a2, _b, _c;
          return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
        });
        const _props = computed(() => {
          if (props.tag === "button") {
            return {
              ariaDisabled: _disabled.value || props.loading,
              disabled: _disabled.value || props.loading,
              autofocus: props.autofocus,
              type: props.nativeType
            };
          }
          return {};
        });
        const shouldAddSpace = computed(() => {
          var _a2;
          const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
          if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
            const slot = defaultSlot[0];
            if ((slot == null ? void 0 : slot.type) === Text) {
              const text = slot.children;
              return /^\p{Unified_Ideograph}{2}$/u.test(text.trim());
            }
          }
          return false;
        });
        const handleClick = (evt) => {
          if (props.nativeType === "reset") {
            form == null ? void 0 : form.resetFields();
          }
          emit2("click", evt);
        };
        return {
          _disabled,
          _size,
          _type,
          _ref,
          _props,
          shouldAddSpace,
          handleClick
        };
      };
      const buttonTypes = [
        "default",
        "primary",
        "success",
        "warning",
        "info",
        "danger",
        "text",
        ""
      ];
      const buttonNativeTypes = ["button", "submit", "reset"];
      const buttonProps = buildProps({
        size: useSizeProp,
        disabled: Boolean,
        type: {
          type: String,
          values: buttonTypes,
          default: ""
        },
        icon: {
          type: iconPropType
        },
        nativeType: {
          type: String,
          values: buttonNativeTypes,
          default: "button"
        },
        loading: Boolean,
        loadingIcon: {
          type: iconPropType,
          default: () => loading_default
        },
        plain: Boolean,
        text: Boolean,
        link: Boolean,
        bg: Boolean,
        autofocus: Boolean,
        round: Boolean,
        circle: Boolean,
        color: String,
        dark: Boolean,
        autoInsertSpace: {
          type: Boolean,
          default: void 0
        },
        tag: {
          type: definePropType([String, Object]),
          default: "button"
        }
      });
      const buttonEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      function bound01(n2, max) {
        if (isOnePointZero(n2)) {
          n2 = "100%";
        }
        var isPercent = isPercentage(n2);
        n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
        if (isPercent) {
          n2 = parseInt(String(n2 * max), 10) / 100;
        }
        if (Math.abs(n2 - max) < 1e-6) {
          return 1;
        }
        if (max === 360) {
          n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
        } else {
          n2 = n2 % max / parseFloat(String(max));
        }
        return n2;
      }
      function clamp01(val) {
        return Math.min(1, Math.max(0, val));
      }
      function isOnePointZero(n2) {
        return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
      }
      function isPercentage(n2) {
        return typeof n2 === "string" && n2.indexOf("%") !== -1;
      }
      function boundAlpha(a) {
        a = parseFloat(a);
        if (isNaN(a) || a < 0 || a > 1) {
          a = 1;
        }
        return a;
      }
      function convertToPercentage(n2) {
        if (n2 <= 1) {
          return "".concat(Number(n2) * 100, "%");
        }
        return n2;
      }
      function pad2(c) {
        return c.length === 1 ? "0" + c : String(c);
      }
      function rgbToRgb(r2, g, b) {
        return {
          r: bound01(r2, 255) * 255,
          g: bound01(g, 255) * 255,
          b: bound01(b, 255) * 255
        };
      }
      function rgbToHsl(r2, g, b) {
        r2 = bound01(r2, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max = Math.max(r2, g, b);
        var min = Math.min(r2, g, b);
        var h2 = 0;
        var s2 = 0;
        var l2 = (max + min) / 2;
        if (max === min) {
          s2 = 0;
          h2 = 0;
        } else {
          var d = max - min;
          s2 = l2 > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r2:
              h2 = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h2 = (b - r2) / d + 2;
              break;
            case b:
              h2 = (r2 - g) / d + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s: s2, l: l2 };
      }
      function hue2rgb(p2, q2, t2) {
        if (t2 < 0) {
          t2 += 1;
        }
        if (t2 > 1) {
          t2 -= 1;
        }
        if (t2 < 1 / 6) {
          return p2 + (q2 - p2) * (6 * t2);
        }
        if (t2 < 1 / 2) {
          return q2;
        }
        if (t2 < 2 / 3) {
          return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
        }
        return p2;
      }
      function hslToRgb(h2, s2, l2) {
        var r2;
        var g;
        var b;
        h2 = bound01(h2, 360);
        s2 = bound01(s2, 100);
        l2 = bound01(l2, 100);
        if (s2 === 0) {
          g = l2;
          b = l2;
          r2 = l2;
        } else {
          var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
          var p2 = 2 * l2 - q2;
          r2 = hue2rgb(p2, q2, h2 + 1 / 3);
          g = hue2rgb(p2, q2, h2);
          b = hue2rgb(p2, q2, h2 - 1 / 3);
        }
        return { r: r2 * 255, g: g * 255, b: b * 255 };
      }
      function rgbToHsv(r2, g, b) {
        r2 = bound01(r2, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max = Math.max(r2, g, b);
        var min = Math.min(r2, g, b);
        var h2 = 0;
        var v = max;
        var d = max - min;
        var s2 = max === 0 ? 0 : d / max;
        if (max === min) {
          h2 = 0;
        } else {
          switch (max) {
            case r2:
              h2 = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h2 = (b - r2) / d + 2;
              break;
            case b:
              h2 = (r2 - g) / d + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s: s2, v };
      }
      function hsvToRgb(h2, s2, v) {
        h2 = bound01(h2, 360) * 6;
        s2 = bound01(s2, 100);
        v = bound01(v, 100);
        var i = Math.floor(h2);
        var f = h2 - i;
        var p2 = v * (1 - s2);
        var q2 = v * (1 - f * s2);
        var t2 = v * (1 - (1 - f) * s2);
        var mod = i % 6;
        var r2 = [v, q2, p2, p2, t2, v][mod];
        var g = [t2, v, v, q2, p2, p2][mod];
        var b = [p2, p2, t2, v, v, q2][mod];
        return { r: r2 * 255, g: g * 255, b: b * 255 };
      }
      function rgbToHex(r2, g, b, allow3Char) {
        var hex = [
          pad2(Math.round(r2).toString(16)),
          pad2(Math.round(g).toString(16)),
          pad2(Math.round(b).toString(16))
        ];
        if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToHex(r2, g, b, a, allow4Char) {
        var hex = [
          pad2(Math.round(r2).toString(16)),
          pad2(Math.round(g).toString(16)),
          pad2(Math.round(b).toString(16)),
          pad2(convertDecimalToHex(a))
        ];
        if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }
        return hex.join("");
      }
      function convertDecimalToHex(d) {
        return Math.round(parseFloat(d) * 255).toString(16);
      }
      function convertHexToDecimal(h2) {
        return parseIntFromHex(h2) / 255;
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function numberInputToObject(color) {
        return {
          r: color >> 16,
          g: (color & 65280) >> 8,
          b: color & 255
        };
      }
      var names = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        goldenrod: "#daa520",
        gold: "#ffd700",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavenderblush: "#fff0f5",
        lavender: "#e6e6fa",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
      };
      function inputToRGB(color) {
        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var s2 = null;
        var v = null;
        var l2 = null;
        var ok = false;
        var format = false;
        if (typeof color === "string") {
          color = stringInputToObject(color);
        }
        if (typeof color === "object") {
          if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s2 = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s2, v);
            ok = true;
            format = "hsv";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s2 = convertToPercentage(color.s);
            l2 = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s2, l2);
            ok = true;
            format = "hsl";
          }
          if (Object.prototype.hasOwnProperty.call(color, "a")) {
            a = color.a;
          }
        }
        a = boundAlpha(a);
        return {
          ok,
          format: color.format || format,
          r: Math.min(255, Math.max(rgb.r, 0)),
          g: Math.min(255, Math.max(rgb.g, 0)),
          b: Math.min(255, Math.max(rgb.b, 0)),
          a
        };
      }
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var matchers = {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
      function stringInputToObject(color) {
        color = color.trim().toLowerCase();
        if (color.length === 0) {
          return false;
        }
        var named = false;
        if (names[color]) {
          color = names[color];
          named = true;
        } else if (color === "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match = matchers.rgb.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3] };
        }
        match = matchers.rgba.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        match = matchers.hsl.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3] };
        }
        match = matchers.hsla.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        match = matchers.hsv.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3] };
        }
        match = matchers.hsva.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        match = matchers.hex8.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex6.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
          };
        }
        match = matchers.hex4.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            a: convertHexToDecimal(match[4] + match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex3.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            format: named ? "name" : "hex"
          };
        }
        return false;
      }
      function isValidCSSUnit(color) {
        return Boolean(matchers.CSS_UNIT.exec(String(color)));
      }
      var TinyColor = (
        /** @class */
        function() {
          function TinyColor2(color, opts) {
            if (color === void 0) {
              color = "";
            }
            if (opts === void 0) {
              opts = {};
            }
            var _a2;
            if (color instanceof TinyColor2) {
              return color;
            }
            if (typeof color === "number") {
              color = numberInputToObject(color);
            }
            this.originalInput = color;
            var rgb = inputToRGB(color);
            this.originalInput = color;
            this.r = rgb.r;
            this.g = rgb.g;
            this.b = rgb.b;
            this.a = rgb.a;
            this.roundA = Math.round(100 * this.a) / 100;
            this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
            this.gradientType = opts.gradientType;
            if (this.r < 1) {
              this.r = Math.round(this.r);
            }
            if (this.g < 1) {
              this.g = Math.round(this.g);
            }
            if (this.b < 1) {
              this.b = Math.round(this.b);
            }
            this.isValid = rgb.ok;
          }
          TinyColor2.prototype.isDark = function() {
            return this.getBrightness() < 128;
          };
          TinyColor2.prototype.isLight = function() {
            return !this.isDark();
          };
          TinyColor2.prototype.getBrightness = function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
          };
          TinyColor2.prototype.getLuminance = function() {
            var rgb = this.toRgb();
            var R2;
            var G2;
            var B2;
            var RsRGB = rgb.r / 255;
            var GsRGB = rgb.g / 255;
            var BsRGB = rgb.b / 255;
            if (RsRGB <= 0.03928) {
              R2 = RsRGB / 12.92;
            } else {
              R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
            }
            if (GsRGB <= 0.03928) {
              G2 = GsRGB / 12.92;
            } else {
              G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
            }
            if (BsRGB <= 0.03928) {
              B2 = BsRGB / 12.92;
            } else {
              B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
          };
          TinyColor2.prototype.getAlpha = function() {
            return this.a;
          };
          TinyColor2.prototype.setAlpha = function(alpha) {
            this.a = boundAlpha(alpha);
            this.roundA = Math.round(100 * this.a) / 100;
            return this;
          };
          TinyColor2.prototype.isMonochrome = function() {
            var s2 = this.toHsl().s;
            return s2 === 0;
          };
          TinyColor2.prototype.toHsv = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
          };
          TinyColor2.prototype.toHsvString = function() {
            var hsv = rgbToHsv(this.r, this.g, this.b);
            var h2 = Math.round(hsv.h * 360);
            var s2 = Math.round(hsv.s * 100);
            var v = Math.round(hsv.v * 100);
            return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHsl = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
          };
          TinyColor2.prototype.toHslString = function() {
            var hsl = rgbToHsl(this.r, this.g, this.b);
            var h2 = Math.round(hsl.h * 360);
            var s2 = Math.round(hsl.s * 100);
            var l2 = Math.round(hsl.l * 100);
            return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toHex = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return rgbToHex(this.r, this.g, this.b, allow3Char);
          };
          TinyColor2.prototype.toHexString = function(allow3Char) {
            if (allow3Char === void 0) {
              allow3Char = false;
            }
            return "#" + this.toHex(allow3Char);
          };
          TinyColor2.prototype.toHex8 = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
          };
          TinyColor2.prototype.toHex8String = function(allow4Char) {
            if (allow4Char === void 0) {
              allow4Char = false;
            }
            return "#" + this.toHex8(allow4Char);
          };
          TinyColor2.prototype.toHexShortString = function(allowShortChar) {
            if (allowShortChar === void 0) {
              allowShortChar = false;
            }
            return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
          };
          TinyColor2.prototype.toRgb = function() {
            return {
              r: Math.round(this.r),
              g: Math.round(this.g),
              b: Math.round(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toRgbString = function() {
            var r2 = Math.round(this.r);
            var g = Math.round(this.g);
            var b = Math.round(this.b);
            return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r2, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toPercentageRgb = function() {
            var fmt = function(x) {
              return "".concat(Math.round(bound01(x, 255) * 100), "%");
            };
            return {
              r: fmt(this.r),
              g: fmt(this.g),
              b: fmt(this.b),
              a: this.a
            };
          };
          TinyColor2.prototype.toPercentageRgbString = function() {
            var rnd = function(x) {
              return Math.round(bound01(x, 255) * 100);
            };
            return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
          };
          TinyColor2.prototype.toName = function() {
            if (this.a === 0) {
              return "transparent";
            }
            if (this.a < 1) {
              return false;
            }
            var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
            for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
              var _b = _a2[_i], key = _b[0], value = _b[1];
              if (hex === value) {
                return key;
              }
            }
            return false;
          };
          TinyColor2.prototype.toString = function(format) {
            var formatSet = Boolean(format);
            format = format !== null && format !== void 0 ? format : this.format;
            var formattedString = false;
            var hasAlpha = this.a < 1 && this.a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith("hex") || format === "name");
            if (needsAlphaFormat) {
              if (format === "name" && this.a === 0) {
                return this.toName();
              }
              return this.toRgbString();
            }
            if (format === "rgb") {
              formattedString = this.toRgbString();
            }
            if (format === "prgb") {
              formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
              formattedString = this.toHexString();
            }
            if (format === "hex3") {
              formattedString = this.toHexString(true);
            }
            if (format === "hex4") {
              formattedString = this.toHex8String(true);
            }
            if (format === "hex8") {
              formattedString = this.toHex8String();
            }
            if (format === "name") {
              formattedString = this.toName();
            }
            if (format === "hsl") {
              formattedString = this.toHslString();
            }
            if (format === "hsv") {
              formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
          };
          TinyColor2.prototype.toNumber = function() {
            return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
          };
          TinyColor2.prototype.clone = function() {
            return new TinyColor2(this.toString());
          };
          TinyColor2.prototype.lighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l += amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.brighten = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var rgb = this.toRgb();
            rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
            rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
            rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
            return new TinyColor2(rgb);
          };
          TinyColor2.prototype.darken = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.l -= amount / 100;
            hsl.l = clamp01(hsl.l);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.tint = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("white", amount);
          };
          TinyColor2.prototype.shade = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            return this.mix("black", amount);
          };
          TinyColor2.prototype.desaturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s -= amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.saturate = function(amount) {
            if (amount === void 0) {
              amount = 10;
            }
            var hsl = this.toHsl();
            hsl.s += amount / 100;
            hsl.s = clamp01(hsl.s);
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.greyscale = function() {
            return this.desaturate(100);
          };
          TinyColor2.prototype.spin = function(amount) {
            var hsl = this.toHsl();
            var hue = (hsl.h + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.mix = function(color, amount) {
            if (amount === void 0) {
              amount = 50;
            }
            var rgb1 = this.toRgb();
            var rgb2 = new TinyColor2(color).toRgb();
            var p2 = amount / 100;
            var rgba = {
              r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
              g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
              b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
              a: (rgb2.a - rgb1.a) * p2 + rgb1.a
            };
            return new TinyColor2(rgba);
          };
          TinyColor2.prototype.analogous = function(results, slices) {
            if (results === void 0) {
              results = 6;
            }
            if (slices === void 0) {
              slices = 30;
            }
            var hsl = this.toHsl();
            var part = 360 / slices;
            var ret = [this];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
              hsl.h = (hsl.h + part) % 360;
              ret.push(new TinyColor2(hsl));
            }
            return ret;
          };
          TinyColor2.prototype.complement = function() {
            var hsl = this.toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return new TinyColor2(hsl);
          };
          TinyColor2.prototype.monochromatic = function(results) {
            if (results === void 0) {
              results = 6;
            }
            var hsv = this.toHsv();
            var h2 = hsv.h;
            var s2 = hsv.s;
            var v = hsv.v;
            var res = [];
            var modification = 1 / results;
            while (results--) {
              res.push(new TinyColor2({ h: h2, s: s2, v }));
              v = (v + modification) % 1;
            }
            return res;
          };
          TinyColor2.prototype.splitcomplement = function() {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            return [
              this,
              new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
              new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
            ];
          };
          TinyColor2.prototype.onBackground = function(background) {
            var fg = this.toRgb();
            var bg = new TinyColor2(background).toRgb();
            var alpha = fg.a + bg.a * (1 - fg.a);
            return new TinyColor2({
              r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
              g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
              b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
              a: alpha
            });
          };
          TinyColor2.prototype.triad = function() {
            return this.polyad(3);
          };
          TinyColor2.prototype.tetrad = function() {
            return this.polyad(4);
          };
          TinyColor2.prototype.polyad = function(n2) {
            var hsl = this.toHsl();
            var h2 = hsl.h;
            var result = [this];
            var increment = 360 / n2;
            for (var i = 1; i < n2; i++) {
              result.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
            }
            return result;
          };
          TinyColor2.prototype.equals = function(color) {
            return this.toRgbString() === new TinyColor2(color).toRgbString();
          };
          return TinyColor2;
        }()
      );
      function darken(color, amount = 20) {
        return color.mix("#141414", amount).toString();
      }
      function useButtonCustomStyle(props) {
        const _disabled = useFormDisabled();
        const ns = useNamespace("button");
        return computed(() => {
          let styles = {};
          const buttonColor = props.color;
          if (buttonColor) {
            const color = new TinyColor(buttonColor);
            const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);
            if (props.plain) {
              styles = ns.cssVarBlock({
                "bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
                "text-color": buttonColor,
                "border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
                "hover-text-color": `var(${ns.cssVarName("color-white")})`,
                "hover-bg-color": buttonColor,
                "hover-border-color": buttonColor,
                "active-bg-color": activeBgColor,
                "active-text-color": `var(${ns.cssVarName("color-white")})`,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                styles[ns.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
                styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
              }
            } else {
              const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
              const textColor = color.isDark() ? `var(${ns.cssVarName("color-white")})` : `var(${ns.cssVarName("color-black")})`;
              styles = ns.cssVarBlock({
                "bg-color": buttonColor,
                "text-color": textColor,
                "border-color": buttonColor,
                "hover-bg-color": hoverBgColor,
                "hover-text-color": textColor,
                "hover-border-color": hoverBgColor,
                "active-bg-color": activeBgColor,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
                styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns.cssVarName("color-white")})`;
                styles[ns.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
              }
            }
          }
          return styles;
        });
      }
      const __default__$6 = /* @__PURE__ */ defineComponent({
        name: "ElButton"
      });
      const _sfc_main$l = /* @__PURE__ */ defineComponent({
        ...__default__$6,
        props: buttonProps,
        emits: buttonEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const buttonStyle = useButtonCustomStyle(props);
          const ns = useNamespace("button");
          const { _ref, _size, _type, _disabled, _props, shouldAddSpace, handleClick } = useButton(props, emit2);
          expose({
            ref: _ref,
            size: _size,
            type: _type,
            disabled: _disabled,
            shouldAddSpace
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({
              ref_key: "_ref",
              ref: _ref
            }, unref(_props), {
              class: [
                unref(ns).b(),
                unref(ns).m(unref(_type)),
                unref(ns).m(unref(_size)),
                unref(ns).is("disabled", unref(_disabled)),
                unref(ns).is("loading", _ctx.loading),
                unref(ns).is("plain", _ctx.plain),
                unref(ns).is("round", _ctx.round),
                unref(ns).is("circle", _ctx.circle),
                unref(ns).is("text", _ctx.text),
                unref(ns).is("link", _ctx.link),
                unref(ns).is("has-bg", _ctx.bg)
              ],
              style: unref(buttonStyle),
              onClick: unref(handleClick)
            }), {
              default: withCtx(() => [
                _ctx.loading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass(unref(ns).is("loading"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"]))
                ], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                  default: withCtx(() => [
                    _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
                  ]),
                  _: 3
                })) : createCommentVNode("v-if", true),
                _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                  key: 2,
                  class: normalizeClass({ [unref(ns).em("text", "expand")]: unref(shouldAddSpace) })
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["class", "style", "onClick"]);
          };
        }
      });
      var Button = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__file", "button.vue"]]);
      const buttonGroupProps = {
        size: buttonProps.size,
        type: buttonProps.type
      };
      const __default__$5 = /* @__PURE__ */ defineComponent({
        name: "ElButtonGroup"
      });
      const _sfc_main$k = /* @__PURE__ */ defineComponent({
        ...__default__$5,
        props: buttonGroupProps,
        setup(__props) {
          const props = __props;
          provide(buttonGroupContextKey, reactive({
            size: toRef(props, "size"),
            type: toRef(props, "type")
          }));
          const ns = useNamespace("button");
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(`${unref(ns).b("group")}`)
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__file", "button-group.vue"]]);
      const ElButton = withInstall(Button, {
        ButtonGroup
      });
      withNoopInstall(ButtonGroup);
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function getDefaultExportFromCjs(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
      }
      function getAugmentedNamespace(n2) {
        if (n2.__esModule)
          return n2;
        var f = n2.default;
        if (typeof f == "function") {
          var a = function a2() {
            if (this instanceof a2) {
              return Reflect.construct(f, arguments, this.constructor);
            }
            return f.apply(this, arguments);
          };
          a.prototype = f.prototype;
        } else
          a = {};
        Object.defineProperty(a, "__esModule", { value: true });
        Object.keys(n2).forEach(function(k) {
          var d = Object.getOwnPropertyDescriptor(n2, k);
          Object.defineProperty(a, k, d.get ? d : {
            enumerable: true,
            get: function() {
              return n2[k];
            }
          });
        });
        return a;
      }
      var dayjs_min = { exports: {} };
      (function(module2, exports2) {
        !function(t2, e2) {
          module2.exports = e2();
        }(commonjsGlobal, function() {
          var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i = "second", s2 = "minute", u = "hour", a = "day", o2 = "week", c = "month", f = "quarter", h2 = "year", d = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
            var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
            return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
          } }, m = function(t3, e3, n3) {
            var r3 = String(t3);
            return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
          }, v = { s: m, z: function(t3) {
            var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i2 = n3 % 60;
            return (e3 <= 0 ? "+" : "-") + m(r3, 2, "0") + ":" + m(i2, 2, "0");
          }, m: function t3(e3, n3) {
            if (e3.date() < n3.date())
              return -t3(n3, e3);
            var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i2 = e3.clone().add(r3, c), s3 = n3 - i2 < 0, u2 = e3.clone().add(r3 + (s3 ? -1 : 1), c);
            return +(-(r3 + (n3 - i2) / (s3 ? i2 - u2 : u2 - i2)) || 0);
          }, a: function(t3) {
            return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
          }, p: function(t3) {
            return { M: c, y: h2, w: o2, d: a, D: d, h: u, m: s2, s: i, ms: r2, Q: f }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
          }, u: function(t3) {
            return void 0 === t3;
          } }, g = "en", D = {};
          D[g] = M;
          var p2 = "$isDayjsObject", S = function(t3) {
            return t3 instanceof _2 || !(!t3 || !t3[p2]);
          }, w = function t3(e3, n3, r3) {
            var i2;
            if (!e3)
              return g;
            if ("string" == typeof e3) {
              var s3 = e3.toLowerCase();
              D[s3] && (i2 = s3), n3 && (D[s3] = n3, i2 = s3);
              var u2 = e3.split("-");
              if (!i2 && u2.length > 1)
                return t3(u2[0]);
            } else {
              var a2 = e3.name;
              D[a2] = e3, i2 = a2;
            }
            return !r3 && i2 && (g = i2), i2 || !r3 && g;
          }, O = function(t3, e3) {
            if (S(t3))
              return t3.clone();
            var n3 = "object" == typeof e3 ? e3 : {};
            return n3.date = t3, n3.args = arguments, new _2(n3);
          }, b = v;
          b.l = w, b.i = S, b.w = function(t3, e3) {
            return O(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
          };
          var _2 = function() {
            function M2(t3) {
              this.$L = w(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
            }
            var m2 = M2.prototype;
            return m2.parse = function(t3) {
              this.$d = function(t4) {
                var e3 = t4.date, n3 = t4.utc;
                if (null === e3)
                  return /* @__PURE__ */ new Date(NaN);
                if (b.u(e3))
                  return /* @__PURE__ */ new Date();
                if (e3 instanceof Date)
                  return new Date(e3);
                if ("string" == typeof e3 && !/Z$/i.test(e3)) {
                  var r3 = e3.match($2);
                  if (r3) {
                    var i2 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
                    return n3 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
                  }
                }
                return new Date(e3);
              }(t3), this.init();
            }, m2.init = function() {
              var t3 = this.$d;
              this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
            }, m2.$utils = function() {
              return b;
            }, m2.isValid = function() {
              return !(this.$d.toString() === l2);
            }, m2.isSame = function(t3, e3) {
              var n3 = O(t3);
              return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
            }, m2.isAfter = function(t3, e3) {
              return O(t3) < this.startOf(e3);
            }, m2.isBefore = function(t3, e3) {
              return this.endOf(e3) < O(t3);
            }, m2.$g = function(t3, e3, n3) {
              return b.u(t3) ? this[e3] : this.set(n3, t3);
            }, m2.unix = function() {
              return Math.floor(this.valueOf() / 1e3);
            }, m2.valueOf = function() {
              return this.$d.getTime();
            }, m2.startOf = function(t3, e3) {
              var n3 = this, r3 = !!b.u(e3) || e3, f2 = b.p(t3), l3 = function(t4, e4) {
                var i2 = b.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
                return r3 ? i2 : i2.endOf(a);
              }, $3 = function(t4, e4) {
                return b.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
              }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
              switch (f2) {
                case h2:
                  return r3 ? l3(1, 0) : l3(31, 11);
                case c:
                  return r3 ? l3(1, M3) : l3(0, M3 + 1);
                case o2:
                  var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
                  return l3(r3 ? m3 - D2 : m3 + (6 - D2), M3);
                case a:
                case d:
                  return $3(v2 + "Hours", 0);
                case u:
                  return $3(v2 + "Minutes", 1);
                case s2:
                  return $3(v2 + "Seconds", 2);
                case i:
                  return $3(v2 + "Milliseconds", 3);
                default:
                  return this.clone();
              }
            }, m2.endOf = function(t3) {
              return this.startOf(t3, false);
            }, m2.$set = function(t3, e3) {
              var n3, o3 = b.p(t3), f2 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a] = f2 + "Date", n3[d] = f2 + "Date", n3[c] = f2 + "Month", n3[h2] = f2 + "FullYear", n3[u] = f2 + "Hours", n3[s2] = f2 + "Minutes", n3[i] = f2 + "Seconds", n3[r2] = f2 + "Milliseconds", n3)[o3], $3 = o3 === a ? this.$D + (e3 - this.$W) : e3;
              if (o3 === c || o3 === h2) {
                var y2 = this.clone().set(d, 1);
                y2.$d[l3]($3), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
              } else
                l3 && this.$d[l3]($3);
              return this.init(), this;
            }, m2.set = function(t3, e3) {
              return this.clone().$set(t3, e3);
            }, m2.get = function(t3) {
              return this[b.p(t3)]();
            }, m2.add = function(r3, f2) {
              var d2, l3 = this;
              r3 = Number(r3);
              var $3 = b.p(f2), y2 = function(t3) {
                var e3 = O(l3);
                return b.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
              };
              if ($3 === c)
                return this.set(c, this.$M + r3);
              if ($3 === h2)
                return this.set(h2, this.$y + r3);
              if ($3 === a)
                return y2(1);
              if ($3 === o2)
                return y2(7);
              var M3 = (d2 = {}, d2[s2] = e2, d2[u] = n2, d2[i] = t2, d2)[$3] || 1, m3 = this.$d.getTime() + r3 * M3;
              return b.w(m3, this);
            }, m2.subtract = function(t3, e3) {
              return this.add(-1 * t3, e3);
            }, m2.format = function(t3) {
              var e3 = this, n3 = this.$locale();
              if (!this.isValid())
                return n3.invalidDate || l2;
              var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s3 = this.$H, u2 = this.$m, a2 = this.$M, o3 = n3.weekdays, c2 = n3.months, f2 = n3.meridiem, h3 = function(t4, n4, i3, s4) {
                return t4 && (t4[n4] || t4(e3, r3)) || i3[n4].slice(0, s4);
              }, d2 = function(t4) {
                return b.s(s3 % 12 || 12, t4, "0");
              }, $3 = f2 || function(t4, e4, n4) {
                var r4 = t4 < 12 ? "AM" : "PM";
                return n4 ? r4.toLowerCase() : r4;
              };
              return r3.replace(y, function(t4, r4) {
                return r4 || function(t5) {
                  switch (t5) {
                    case "YY":
                      return String(e3.$y).slice(-2);
                    case "YYYY":
                      return b.s(e3.$y, 4, "0");
                    case "M":
                      return a2 + 1;
                    case "MM":
                      return b.s(a2 + 1, 2, "0");
                    case "MMM":
                      return h3(n3.monthsShort, a2, c2, 3);
                    case "MMMM":
                      return h3(c2, a2);
                    case "D":
                      return e3.$D;
                    case "DD":
                      return b.s(e3.$D, 2, "0");
                    case "d":
                      return String(e3.$W);
                    case "dd":
                      return h3(n3.weekdaysMin, e3.$W, o3, 2);
                    case "ddd":
                      return h3(n3.weekdaysShort, e3.$W, o3, 3);
                    case "dddd":
                      return o3[e3.$W];
                    case "H":
                      return String(s3);
                    case "HH":
                      return b.s(s3, 2, "0");
                    case "h":
                      return d2(1);
                    case "hh":
                      return d2(2);
                    case "a":
                      return $3(s3, u2, true);
                    case "A":
                      return $3(s3, u2, false);
                    case "m":
                      return String(u2);
                    case "mm":
                      return b.s(u2, 2, "0");
                    case "s":
                      return String(e3.$s);
                    case "ss":
                      return b.s(e3.$s, 2, "0");
                    case "SSS":
                      return b.s(e3.$ms, 3, "0");
                    case "Z":
                      return i2;
                  }
                  return null;
                }(t4) || i2.replace(":", "");
              });
            }, m2.utcOffset = function() {
              return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
            }, m2.diff = function(r3, d2, l3) {
              var $3, y2 = this, M3 = b.p(d2), m3 = O(r3), v2 = (m3.utcOffset() - this.utcOffset()) * e2, g2 = this - m3, D2 = function() {
                return b.m(y2, m3);
              };
              switch (M3) {
                case h2:
                  $3 = D2() / 12;
                  break;
                case c:
                  $3 = D2();
                  break;
                case f:
                  $3 = D2() / 3;
                  break;
                case o2:
                  $3 = (g2 - v2) / 6048e5;
                  break;
                case a:
                  $3 = (g2 - v2) / 864e5;
                  break;
                case u:
                  $3 = g2 / n2;
                  break;
                case s2:
                  $3 = g2 / e2;
                  break;
                case i:
                  $3 = g2 / t2;
                  break;
                default:
                  $3 = g2;
              }
              return l3 ? $3 : b.a($3);
            }, m2.daysInMonth = function() {
              return this.endOf(c).$D;
            }, m2.$locale = function() {
              return D[this.$L];
            }, m2.locale = function(t3, e3) {
              if (!t3)
                return this.$L;
              var n3 = this.clone(), r3 = w(t3, e3, true);
              return r3 && (n3.$L = r3), n3;
            }, m2.clone = function() {
              return b.w(this.$d, this);
            }, m2.toDate = function() {
              return new Date(this.valueOf());
            }, m2.toJSON = function() {
              return this.isValid() ? this.toISOString() : null;
            }, m2.toISOString = function() {
              return this.$d.toISOString();
            }, m2.toString = function() {
              return this.$d.toUTCString();
            }, M2;
          }(), k = _2.prototype;
          return O.prototype = k, [["$ms", r2], ["$s", i], ["$m", s2], ["$H", u], ["$W", a], ["$M", c], ["$y", h2], ["$D", d]].forEach(function(t3) {
            k[t3[1]] = function(e3) {
              return this.$g(e3, t3[0], t3[1]);
            };
          }), O.extend = function(t3, e3) {
            return t3.$i || (t3(e3, _2, O), t3.$i = true), O;
          }, O.locale = w, O.isDayjs = S, O.unix = function(t3) {
            return O(1e3 * t3);
          }, O.en = D[g], O.Ls = D, O.p = {}, O;
        });
      })(dayjs_min);
      var dayjs_minExports = dayjs_min.exports;
      const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
      var customParseFormat$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e2, t2) {
          module2.exports = t2();
        }(commonjsGlobal, function() {
          var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d\d/, r2 = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o2 = {}, s2 = function(e3) {
            return (e3 = +e3) + (e3 > 68 ? 1900 : 2e3);
          };
          var a = function(e3) {
            return function(t3) {
              this[e3] = +t3;
            };
          }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
            (this.zone || (this.zone = {})).offset = function(e4) {
              if (!e4)
                return 0;
              if ("Z" === e4)
                return 0;
              var t3 = e4.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
              return 0 === n3 ? 0 : "+" === t3[0] ? -n3 : n3;
            }(e3);
          }], h2 = function(e3) {
            var t3 = o2[e3];
            return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
          }, u = function(e3, t3) {
            var n3, r3 = o2.meridiem;
            if (r3) {
              for (var i2 = 1; i2 <= 24; i2 += 1)
                if (e3.indexOf(r3(i2, 0, t3)) > -1) {
                  n3 = i2 > 12;
                  break;
                }
            } else
              n3 = e3 === (t3 ? "pm" : "PM");
            return n3;
          }, d = { A: [i, function(e3) {
            this.afternoon = u(e3, false);
          }], a: [i, function(e3) {
            this.afternoon = u(e3, true);
          }], S: [/\d/, function(e3) {
            this.milliseconds = 100 * +e3;
          }], SS: [n2, function(e3) {
            this.milliseconds = 10 * +e3;
          }], SSS: [/\d{3}/, function(e3) {
            this.milliseconds = +e3;
          }], s: [r2, a("seconds")], ss: [r2, a("seconds")], m: [r2, a("minutes")], mm: [r2, a("minutes")], H: [r2, a("hours")], h: [r2, a("hours")], HH: [r2, a("hours")], hh: [r2, a("hours")], D: [r2, a("day")], DD: [n2, a("day")], Do: [i, function(e3) {
            var t3 = o2.ordinal, n3 = e3.match(/\d+/);
            if (this.day = n3[0], t3)
              for (var r3 = 1; r3 <= 31; r3 += 1)
                t3(r3).replace(/\[|\]/g, "") === e3 && (this.day = r3);
          }], M: [r2, a("month")], MM: [n2, a("month")], MMM: [i, function(e3) {
            var t3 = h2("months"), n3 = (h2("monthsShort") || t3.map(function(e4) {
              return e4.slice(0, 3);
            })).indexOf(e3) + 1;
            if (n3 < 1)
              throw new Error();
            this.month = n3 % 12 || n3;
          }], MMMM: [i, function(e3) {
            var t3 = h2("months").indexOf(e3) + 1;
            if (t3 < 1)
              throw new Error();
            this.month = t3 % 12 || t3;
          }], Y: [/[+-]?\d+/, a("year")], YY: [n2, function(e3) {
            this.year = s2(e3);
          }], YYYY: [/\d{4}/, a("year")], Z: f, ZZ: f };
          function c(n3) {
            var r3, i2;
            r3 = n3, i2 = o2 && o2.formats;
            for (var s3 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r4) {
              var o3 = r4 && r4.toUpperCase();
              return n4 || i2[r4] || e2[r4] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t4, n5) {
                return t4 || n5.slice(1);
              });
            })).match(t2), a2 = s3.length, f2 = 0; f2 < a2; f2 += 1) {
              var h3 = s3[f2], u2 = d[h3], c2 = u2 && u2[0], l2 = u2 && u2[1];
              s3[f2] = l2 ? { regex: c2, parser: l2 } : h3.replace(/^\[|\]$/g, "");
            }
            return function(e3) {
              for (var t3 = {}, n4 = 0, r4 = 0; n4 < a2; n4 += 1) {
                var i3 = s3[n4];
                if ("string" == typeof i3)
                  r4 += i3.length;
                else {
                  var o3 = i3.regex, f3 = i3.parser, h4 = e3.slice(r4), u3 = o3.exec(h4)[0];
                  f3.call(t3, u3), e3 = e3.replace(u3, "");
                }
              }
              return function(e4) {
                var t4 = e4.afternoon;
                if (void 0 !== t4) {
                  var n5 = e4.hours;
                  t4 ? n5 < 12 && (e4.hours += 12) : 12 === n5 && (e4.hours = 0), delete e4.afternoon;
                }
              }(t3), t3;
            };
          }
          return function(e3, t3, n3) {
            n3.p.customParseFormat = true, e3 && e3.parseTwoDigitYear && (s2 = e3.parseTwoDigitYear);
            var r3 = t3.prototype, i2 = r3.parse;
            r3.parse = function(e4) {
              var t4 = e4.date, r4 = e4.utc, s3 = e4.args;
              this.$u = r4;
              var a2 = s3[1];
              if ("string" == typeof a2) {
                var f2 = true === s3[2], h3 = true === s3[3], u2 = f2 || h3, d2 = s3[2];
                h3 && (d2 = s3[2]), o2 = this.$locale(), !f2 && d2 && (o2 = n3.Ls[d2]), this.$d = function(e5, t5, n4) {
                  try {
                    if (["x", "X"].indexOf(t5) > -1)
                      return new Date(("X" === t5 ? 1e3 : 1) * e5);
                    var r5 = c(t5)(e5), i3 = r5.year, o3 = r5.month, s4 = r5.day, a3 = r5.hours, f3 = r5.minutes, h4 = r5.seconds, u3 = r5.milliseconds, d3 = r5.zone, l3 = /* @__PURE__ */ new Date(), m2 = s4 || (i3 || o3 ? 1 : l3.getDate()), M2 = i3 || l3.getFullYear(), Y = 0;
                    i3 && !o3 || (Y = o3 > 0 ? o3 - 1 : l3.getMonth());
                    var p2 = a3 || 0, v = f3 || 0, D = h4 || 0, g = u3 || 0;
                    return d3 ? new Date(Date.UTC(M2, Y, m2, p2, v, D, g + 60 * d3.offset * 1e3)) : n4 ? new Date(Date.UTC(M2, Y, m2, p2, v, D, g)) : new Date(M2, Y, m2, p2, v, D, g);
                  } catch (e6) {
                    return /* @__PURE__ */ new Date("");
                  }
                }(t4, a2, r4), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t4 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), o2 = {};
              } else if (a2 instanceof Array)
                for (var l2 = a2.length, m = 1; m <= l2; m += 1) {
                  s3[1] = a2[m - 1];
                  var M = n3.apply(this, s3);
                  if (M.isValid()) {
                    this.$d = M.$d, this.$L = M.$L, this.init();
                    break;
                  }
                  m === l2 && (this.$d = /* @__PURE__ */ new Date(""));
                }
              else
                i2.call(this, e4);
            };
          };
        });
      })(customParseFormat$1);
      var customParseFormatExports = customParseFormat$1.exports;
      const customParseFormat = /* @__PURE__ */ getDefaultExportFromCjs(customParseFormatExports);
      const timeUnits = ["hours", "minutes", "seconds"];
      const DEFAULT_FORMATS_TIME = "HH:mm:ss";
      const DEFAULT_FORMATS_DATE = "YYYY-MM-DD";
      const DEFAULT_FORMATS_DATEPICKER = {
        date: DEFAULT_FORMATS_DATE,
        dates: DEFAULT_FORMATS_DATE,
        week: "gggg[w]ww",
        year: "YYYY",
        month: "YYYY-MM",
        datetime: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`,
        monthrange: "YYYY-MM",
        daterange: DEFAULT_FORMATS_DATE,
        datetimerange: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`
      };
      const buildTimeList = (value, bound) => {
        return [
          value > 0 ? value - 1 : void 0,
          value,
          value < bound ? value + 1 : void 0
        ];
      };
      const rangeArr = (n2) => Array.from(Array.from({ length: n2 }).keys());
      const extractDateFormat = (format) => {
        return format.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim();
      };
      const extractTimeFormat = (format) => {
        return format.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim();
      };
      const dateEquals = function(a, b) {
        const aIsDate = isDate(a);
        const bIsDate = isDate(b);
        if (aIsDate && bIsDate) {
          return a.getTime() === b.getTime();
        }
        if (!aIsDate && !bIsDate) {
          return a === b;
        }
        return false;
      };
      const valueEquals = function(a, b) {
        const aIsArray = isArray$2(a);
        const bIsArray = isArray$2(b);
        if (aIsArray && bIsArray) {
          if (a.length !== b.length) {
            return false;
          }
          return a.every((item, index) => dateEquals(item, b[index]));
        }
        if (!aIsArray && !bIsArray) {
          return dateEquals(a, b);
        }
        return false;
      };
      const parseDate = function(date2, format, lang) {
        const day = isEmpty(format) || format === "x" ? dayjs(date2).locale(lang) : dayjs(date2, format).locale(lang);
        return day.isValid() ? day : void 0;
      };
      const formatter = function(date2, format, lang) {
        if (isEmpty(format))
          return date2;
        if (format === "x")
          return +date2;
        return dayjs(date2).locale(lang).format(format);
      };
      const makeList = (total, method) => {
        var _a2;
        const arr = [];
        const disabledArr = method == null ? void 0 : method();
        for (let i = 0; i < total; i++) {
          arr.push((_a2 = disabledArr == null ? void 0 : disabledArr.includes(i)) != null ? _a2 : false);
        }
        return arr;
      };
      const disabledTimeListsProps = buildProps({
        disabledHours: {
          type: definePropType(Function)
        },
        disabledMinutes: {
          type: definePropType(Function)
        },
        disabledSeconds: {
          type: definePropType(Function)
        }
      });
      const timePanelSharedProps = buildProps({
        visible: Boolean,
        actualVisible: {
          type: Boolean,
          default: void 0
        },
        format: {
          type: String,
          default: ""
        }
      });
      const timePickerDefaultProps = buildProps({
        id: {
          type: definePropType([Array, String])
        },
        name: {
          type: definePropType([Array, String]),
          default: ""
        },
        popperClass: {
          type: String,
          default: ""
        },
        format: String,
        valueFormat: String,
        dateFormat: String,
        timeFormat: String,
        type: {
          type: String,
          default: ""
        },
        clearable: {
          type: Boolean,
          default: true
        },
        clearIcon: {
          type: definePropType([String, Object]),
          default: circle_close_default
        },
        editable: {
          type: Boolean,
          default: true
        },
        prefixIcon: {
          type: definePropType([String, Object]),
          default: ""
        },
        size: useSizeProp,
        readonly: Boolean,
        disabled: Boolean,
        placeholder: {
          type: String,
          default: ""
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        modelValue: {
          type: definePropType([Date, Array, String, Number]),
          default: ""
        },
        rangeSeparator: {
          type: String,
          default: "-"
        },
        startPlaceholder: String,
        endPlaceholder: String,
        defaultValue: {
          type: definePropType([Date, Array])
        },
        defaultTime: {
          type: definePropType([Date, Array])
        },
        isRange: Boolean,
        ...disabledTimeListsProps,
        disabledDate: {
          type: Function
        },
        cellClassName: {
          type: Function
        },
        shortcuts: {
          type: Array,
          default: () => []
        },
        arrowControl: Boolean,
        label: {
          type: String,
          default: void 0
        },
        tabindex: {
          type: definePropType([String, Number]),
          default: 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        unlinkPanels: Boolean
      });
      const _hoisted_1$e = ["id", "name", "placeholder", "value", "disabled", "readonly"];
      const _hoisted_2$b = ["id", "name", "placeholder", "value", "disabled", "readonly"];
      const __default__$4 = /* @__PURE__ */ defineComponent({
        name: "Picker"
      });
      const _sfc_main$j = /* @__PURE__ */ defineComponent({
        ...__default__$4,
        props: timePickerDefaultProps,
        emits: [
          "update:modelValue",
          "change",
          "focus",
          "blur",
          "calendar-change",
          "panel-change",
          "visible-change",
          "keydown"
        ],
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const attrs = useAttrs$1();
          const { lang } = useLocale();
          const nsDate = useNamespace("date");
          const nsInput = useNamespace("input");
          const nsRange = useNamespace("range");
          const { form, formItem } = useFormItem();
          const elPopperOptions = inject("ElPopperOptions", {});
          const refPopper = ref();
          const inputRef = ref();
          const pickerVisible = ref(false);
          const pickerActualVisible = ref(false);
          const valueOnOpen = ref(null);
          let hasJustTabExitedInput = false;
          let ignoreFocusEvent = false;
          const rangeInputKls = computed(() => [
            nsDate.b("editor"),
            nsDate.bm("editor", props.type),
            nsInput.e("wrapper"),
            nsDate.is("disabled", pickerDisabled.value),
            nsDate.is("active", pickerVisible.value),
            nsRange.b("editor"),
            pickerSize ? nsRange.bm("editor", pickerSize.value) : "",
            attrs.class
          ]);
          const clearIconKls = computed(() => [
            nsInput.e("icon"),
            nsRange.e("close-icon"),
            !showClose.value ? nsRange.e("close-icon--hidden") : ""
          ]);
          watch(pickerVisible, (val) => {
            if (!val) {
              userInput.value = null;
              nextTick(() => {
                emitChange(props.modelValue);
              });
            } else {
              nextTick(() => {
                if (val) {
                  valueOnOpen.value = props.modelValue;
                }
              });
            }
          });
          const emitChange = (val, isClear) => {
            if (isClear || !valueEquals(val, valueOnOpen.value)) {
              emit2("change", val);
              props.validateEvent && (formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn()));
            }
          };
          const emitInput = (input) => {
            if (!valueEquals(props.modelValue, input)) {
              let formatted;
              if (isArray$2(input)) {
                formatted = input.map((item) => formatter(item, props.valueFormat, lang.value));
              } else if (input) {
                formatted = formatter(input, props.valueFormat, lang.value);
              }
              emit2("update:modelValue", input ? formatted : input, lang.value);
            }
          };
          const emitKeydown = (e2) => {
            emit2("keydown", e2);
          };
          const refInput = computed(() => {
            if (inputRef.value) {
              const _r = isRangeInput.value ? inputRef.value : inputRef.value.$el;
              return Array.from(_r.querySelectorAll("input"));
            }
            return [];
          });
          const setSelectionRange = (start, end, pos) => {
            const _inputs = refInput.value;
            if (!_inputs.length)
              return;
            if (!pos || pos === "min") {
              _inputs[0].setSelectionRange(start, end);
              _inputs[0].focus();
            } else if (pos === "max") {
              _inputs[1].setSelectionRange(start, end);
              _inputs[1].focus();
            }
          };
          const focusOnInputBox = () => {
            focus(true, true);
            nextTick(() => {
              ignoreFocusEvent = false;
            });
          };
          const onPick = (date2 = "", visible = false) => {
            if (!visible) {
              ignoreFocusEvent = true;
            }
            pickerVisible.value = visible;
            let result;
            if (isArray$2(date2)) {
              result = date2.map((_2) => _2.toDate());
            } else {
              result = date2 ? date2.toDate() : date2;
            }
            userInput.value = null;
            emitInput(result);
          };
          const onBeforeShow = () => {
            pickerActualVisible.value = true;
          };
          const onShow = () => {
            emit2("visible-change", true);
          };
          const onKeydownPopperContent = (event) => {
            if ((event == null ? void 0 : event.key) === EVENT_CODE.esc) {
              focus(true, true);
            }
          };
          const onHide = () => {
            pickerActualVisible.value = false;
            pickerVisible.value = false;
            ignoreFocusEvent = false;
            emit2("visible-change", false);
          };
          const handleOpen = () => {
            pickerVisible.value = true;
          };
          const handleClose = () => {
            pickerVisible.value = false;
          };
          const focus = (focusStartInput = true, isIgnoreFocusEvent = false) => {
            ignoreFocusEvent = isIgnoreFocusEvent;
            const [leftInput, rightInput] = unref(refInput);
            let input = leftInput;
            if (!focusStartInput && isRangeInput.value) {
              input = rightInput;
            }
            if (input) {
              input.focus();
            }
          };
          const handleFocusInput = (e2) => {
            if (props.readonly || pickerDisabled.value || pickerVisible.value || ignoreFocusEvent) {
              return;
            }
            pickerVisible.value = true;
            emit2("focus", e2);
          };
          let currentHandleBlurDeferCallback = void 0;
          const handleBlurInput = (e2) => {
            const handleBlurDefer = async () => {
              setTimeout(() => {
                var _a2;
                if (currentHandleBlurDeferCallback === handleBlurDefer) {
                  if (!(((_a2 = refPopper.value) == null ? void 0 : _a2.isFocusInsideContent()) && !hasJustTabExitedInput) && refInput.value.filter((input) => {
                    return input.contains(document.activeElement);
                  }).length === 0) {
                    handleChange();
                    pickerVisible.value = false;
                    emit2("blur", e2);
                    props.validateEvent && (formItem == null ? void 0 : formItem.validate("blur").catch((err) => debugWarn()));
                  }
                  hasJustTabExitedInput = false;
                }
              }, 0);
            };
            currentHandleBlurDeferCallback = handleBlurDefer;
            handleBlurDefer();
          };
          const pickerDisabled = computed(() => {
            return props.disabled || (form == null ? void 0 : form.disabled);
          });
          const parsedValue2 = computed(() => {
            let dayOrDays;
            if (valueIsEmpty.value) {
              if (pickerOptions.value.getDefaultValue) {
                dayOrDays = pickerOptions.value.getDefaultValue();
              }
            } else {
              if (isArray$2(props.modelValue)) {
                dayOrDays = props.modelValue.map((d) => parseDate(d, props.valueFormat, lang.value));
              } else {
                dayOrDays = parseDate(props.modelValue, props.valueFormat, lang.value);
              }
            }
            if (pickerOptions.value.getRangeAvailableTime) {
              const availableResult = pickerOptions.value.getRangeAvailableTime(dayOrDays);
              if (!isEqual(availableResult, dayOrDays)) {
                dayOrDays = availableResult;
                emitInput(isArray$2(dayOrDays) ? dayOrDays.map((_2) => _2.toDate()) : dayOrDays.toDate());
              }
            }
            if (isArray$2(dayOrDays) && dayOrDays.some((day) => !day)) {
              dayOrDays = [];
            }
            return dayOrDays;
          });
          const displayValue = computed(() => {
            if (!pickerOptions.value.panelReady)
              return "";
            const formattedValue = formatDayjsToString(parsedValue2.value);
            if (isArray$2(userInput.value)) {
              return [
                userInput.value[0] || formattedValue && formattedValue[0] || "",
                userInput.value[1] || formattedValue && formattedValue[1] || ""
              ];
            } else if (userInput.value !== null) {
              return userInput.value;
            }
            if (!isTimePicker.value && valueIsEmpty.value)
              return "";
            if (!pickerVisible.value && valueIsEmpty.value)
              return "";
            if (formattedValue) {
              return isDatesPicker.value ? formattedValue.join(", ") : formattedValue;
            }
            return "";
          });
          const isTimeLikePicker = computed(() => props.type.includes("time"));
          const isTimePicker = computed(() => props.type.startsWith("time"));
          const isDatesPicker = computed(() => props.type === "dates");
          const triggerIcon = computed(() => props.prefixIcon || (isTimeLikePicker.value ? clock_default : calendar_default));
          const showClose = ref(false);
          const onClearIconClick = (event) => {
            if (props.readonly || pickerDisabled.value)
              return;
            if (showClose.value) {
              event.stopPropagation();
              focusOnInputBox();
              emitInput(null);
              emitChange(null, true);
              showClose.value = false;
              pickerVisible.value = false;
              pickerOptions.value.handleClear && pickerOptions.value.handleClear();
            }
          };
          const valueIsEmpty = computed(() => {
            const { modelValue } = props;
            return !modelValue || isArray$2(modelValue) && !modelValue.filter(Boolean).length;
          });
          const onMouseDownInput = async (event) => {
            var _a2;
            if (props.readonly || pickerDisabled.value)
              return;
            if (((_a2 = event.target) == null ? void 0 : _a2.tagName) !== "INPUT" || refInput.value.includes(document.activeElement)) {
              pickerVisible.value = true;
            }
          };
          const onMouseEnter = () => {
            if (props.readonly || pickerDisabled.value)
              return;
            if (!valueIsEmpty.value && props.clearable) {
              showClose.value = true;
            }
          };
          const onMouseLeave = () => {
            showClose.value = false;
          };
          const onTouchStartInput = (event) => {
            var _a2;
            if (props.readonly || pickerDisabled.value)
              return;
            if (((_a2 = event.touches[0].target) == null ? void 0 : _a2.tagName) !== "INPUT" || refInput.value.includes(document.activeElement)) {
              pickerVisible.value = true;
            }
          };
          const isRangeInput = computed(() => {
            return props.type.includes("range");
          });
          const pickerSize = useFormSize();
          const popperEl = computed(() => {
            var _a2, _b;
            return (_b = (_a2 = unref(refPopper)) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
          });
          const actualInputRef = computed(() => {
            var _a2;
            if (unref(isRangeInput)) {
              return unref(inputRef);
            }
            return (_a2 = unref(inputRef)) == null ? void 0 : _a2.$el;
          });
          onClickOutside(actualInputRef, (e2) => {
            const unrefedPopperEl = unref(popperEl);
            const inputEl = unref(actualInputRef);
            if (unrefedPopperEl && (e2.target === unrefedPopperEl || e2.composedPath().includes(unrefedPopperEl)) || e2.target === inputEl || e2.composedPath().includes(inputEl))
              return;
            pickerVisible.value = false;
          });
          const userInput = ref(null);
          const handleChange = () => {
            if (userInput.value) {
              const value = parseUserInputToDayjs(displayValue.value);
              if (value) {
                if (isValidValue(value)) {
                  emitInput(isArray$2(value) ? value.map((_2) => _2.toDate()) : value.toDate());
                  userInput.value = null;
                }
              }
            }
            if (userInput.value === "") {
              emitInput(null);
              emitChange(null);
              userInput.value = null;
            }
          };
          const parseUserInputToDayjs = (value) => {
            if (!value)
              return null;
            return pickerOptions.value.parseUserInput(value);
          };
          const formatDayjsToString = (value) => {
            if (!value)
              return null;
            return pickerOptions.value.formatToString(value);
          };
          const isValidValue = (value) => {
            return pickerOptions.value.isValidValue(value);
          };
          const handleKeydownInput = async (event) => {
            if (props.readonly || pickerDisabled.value)
              return;
            const { code } = event;
            emitKeydown(event);
            if (code === EVENT_CODE.esc) {
              if (pickerVisible.value === true) {
                pickerVisible.value = false;
                event.preventDefault();
                event.stopPropagation();
              }
              return;
            }
            if (code === EVENT_CODE.down) {
              if (pickerOptions.value.handleFocusPicker) {
                event.preventDefault();
                event.stopPropagation();
              }
              if (pickerVisible.value === false) {
                pickerVisible.value = true;
                await nextTick();
              }
              if (pickerOptions.value.handleFocusPicker) {
                pickerOptions.value.handleFocusPicker();
                return;
              }
            }
            if (code === EVENT_CODE.tab) {
              hasJustTabExitedInput = true;
              return;
            }
            if (code === EVENT_CODE.enter || code === EVENT_CODE.numpadEnter) {
              if (userInput.value === null || userInput.value === "" || isValidValue(parseUserInputToDayjs(displayValue.value))) {
                handleChange();
                pickerVisible.value = false;
              }
              event.stopPropagation();
              return;
            }
            if (userInput.value) {
              event.stopPropagation();
              return;
            }
            if (pickerOptions.value.handleKeydownInput) {
              pickerOptions.value.handleKeydownInput(event);
            }
          };
          const onUserInput = (e2) => {
            userInput.value = e2;
            if (!pickerVisible.value) {
              pickerVisible.value = true;
            }
          };
          const handleStartInput = (event) => {
            const target = event.target;
            if (userInput.value) {
              userInput.value = [target.value, userInput.value[1]];
            } else {
              userInput.value = [target.value, null];
            }
          };
          const handleEndInput = (event) => {
            const target = event.target;
            if (userInput.value) {
              userInput.value = [userInput.value[0], target.value];
            } else {
              userInput.value = [null, target.value];
            }
          };
          const handleStartChange = () => {
            var _a2;
            const values = userInput.value;
            const value = parseUserInputToDayjs(values && values[0]);
            const parsedVal = unref(parsedValue2);
            if (value && value.isValid()) {
              userInput.value = [
                formatDayjsToString(value),
                ((_a2 = displayValue.value) == null ? void 0 : _a2[1]) || null
              ];
              const newValue = [value, parsedVal && (parsedVal[1] || null)];
              if (isValidValue(newValue)) {
                emitInput(newValue);
                userInput.value = null;
              }
            }
          };
          const handleEndChange = () => {
            var _a2;
            const values = unref(userInput);
            const value = parseUserInputToDayjs(values && values[1]);
            const parsedVal = unref(parsedValue2);
            if (value && value.isValid()) {
              userInput.value = [
                ((_a2 = unref(displayValue)) == null ? void 0 : _a2[0]) || null,
                formatDayjsToString(value)
              ];
              const newValue = [parsedVal && parsedVal[0], value];
              if (isValidValue(newValue)) {
                emitInput(newValue);
                userInput.value = null;
              }
            }
          };
          const pickerOptions = ref({});
          const onSetPickerOption = (e2) => {
            pickerOptions.value[e2[0]] = e2[1];
            pickerOptions.value.panelReady = true;
          };
          const onCalendarChange = (e2) => {
            emit2("calendar-change", e2);
          };
          const onPanelChange = (value, mode, view) => {
            emit2("panel-change", value, mode, view);
          };
          provide("EP_PICKER_BASE", {
            props
          });
          expose({
            focus,
            handleFocusInput,
            handleBlurInput,
            handleOpen,
            handleClose,
            onPick
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTooltip), mergeProps({
              ref_key: "refPopper",
              ref: refPopper,
              visible: pickerVisible.value,
              effect: "light",
              pure: "",
              trigger: "click"
            }, _ctx.$attrs, {
              role: "dialog",
              teleported: "",
              transition: `${unref(nsDate).namespace.value}-zoom-in-top`,
              "popper-class": [`${unref(nsDate).namespace.value}-picker__popper`, _ctx.popperClass],
              "popper-options": unref(elPopperOptions),
              "fallback-placements": ["bottom", "top", "right", "left"],
              "gpu-acceleration": false,
              "stop-popper-mouse-event": false,
              "hide-after": 0,
              persistent: "",
              onBeforeShow,
              onShow,
              onHide
            }), {
              default: withCtx(() => [
                !unref(isRangeInput) ? (openBlock(), createBlock(unref(ElInput), {
                  key: 0,
                  id: _ctx.id,
                  ref_key: "inputRef",
                  ref: inputRef,
                  "container-role": "combobox",
                  "model-value": unref(displayValue),
                  name: _ctx.name,
                  size: unref(pickerSize),
                  disabled: unref(pickerDisabled),
                  placeholder: _ctx.placeholder,
                  class: normalizeClass([unref(nsDate).b("editor"), unref(nsDate).bm("editor", _ctx.type), _ctx.$attrs.class]),
                  style: normalizeStyle(_ctx.$attrs.style),
                  readonly: !_ctx.editable || _ctx.readonly || unref(isDatesPicker) || _ctx.type === "week",
                  label: _ctx.label,
                  tabindex: _ctx.tabindex,
                  "validate-event": false,
                  onInput: onUserInput,
                  onFocus: handleFocusInput,
                  onBlur: handleBlurInput,
                  onKeydown: handleKeydownInput,
                  onChange: handleChange,
                  onMousedown: onMouseDownInput,
                  onMouseenter: onMouseEnter,
                  onMouseleave: onMouseLeave,
                  onTouchstart: onTouchStartInput,
                  onClick: _cache[0] || (_cache[0] = withModifiers(() => {
                  }, ["stop"]))
                }, {
                  prefix: withCtx(() => [
                    unref(triggerIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(nsInput).e("icon")),
                      onMousedown: withModifiers(onMouseDownInput, ["prevent"]),
                      onTouchstart: onTouchStartInput
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(triggerIcon))))
                      ]),
                      _: 1
                    }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true)
                  ]),
                  suffix: withCtx(() => [
                    showClose.value && _ctx.clearIcon ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(`${unref(nsInput).e("icon")} clear-icon`),
                      onClick: withModifiers(onClearIconClick, ["stop"])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 1
                }, 8, ["id", "model-value", "name", "size", "disabled", "placeholder", "class", "style", "readonly", "label", "tabindex", "onKeydown"])) : (openBlock(), createElementBlock("div", {
                  key: 1,
                  ref_key: "inputRef",
                  ref: inputRef,
                  class: normalizeClass(unref(rangeInputKls)),
                  style: normalizeStyle(_ctx.$attrs.style),
                  onClick: handleFocusInput,
                  onMouseenter: onMouseEnter,
                  onMouseleave: onMouseLeave,
                  onTouchstart: onTouchStartInput,
                  onKeydown: handleKeydownInput
                }, [
                  unref(triggerIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass([unref(nsInput).e("icon"), unref(nsRange).e("icon")]),
                    onMousedown: withModifiers(onMouseDownInput, ["prevent"]),
                    onTouchstart: onTouchStartInput
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(triggerIcon))))
                    ]),
                    _: 1
                  }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                  createBaseVNode("input", {
                    id: _ctx.id && _ctx.id[0],
                    autocomplete: "off",
                    name: _ctx.name && _ctx.name[0],
                    placeholder: _ctx.startPlaceholder,
                    value: unref(displayValue) && unref(displayValue)[0],
                    disabled: unref(pickerDisabled),
                    readonly: !_ctx.editable || _ctx.readonly,
                    class: normalizeClass(unref(nsRange).b("input")),
                    onMousedown: onMouseDownInput,
                    onInput: handleStartInput,
                    onChange: handleStartChange,
                    onFocus: handleFocusInput,
                    onBlur: handleBlurInput
                  }, null, 42, _hoisted_1$e),
                  renderSlot(_ctx.$slots, "range-separator", {}, () => [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(nsRange).b("separator"))
                    }, toDisplayString(_ctx.rangeSeparator), 3)
                  ]),
                  createBaseVNode("input", {
                    id: _ctx.id && _ctx.id[1],
                    autocomplete: "off",
                    name: _ctx.name && _ctx.name[1],
                    placeholder: _ctx.endPlaceholder,
                    value: unref(displayValue) && unref(displayValue)[1],
                    disabled: unref(pickerDisabled),
                    readonly: !_ctx.editable || _ctx.readonly,
                    class: normalizeClass(unref(nsRange).b("input")),
                    onMousedown: onMouseDownInput,
                    onFocus: handleFocusInput,
                    onBlur: handleBlurInput,
                    onInput: handleEndInput,
                    onChange: handleEndChange
                  }, null, 42, _hoisted_2$b),
                  _ctx.clearIcon ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass(unref(clearIconKls)),
                    onClick: onClearIconClick
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true)
                ], 38))
              ]),
              content: withCtx(() => [
                renderSlot(_ctx.$slots, "default", {
                  visible: pickerVisible.value,
                  actualVisible: pickerActualVisible.value,
                  parsedValue: unref(parsedValue2),
                  format: _ctx.format,
                  dateFormat: _ctx.dateFormat,
                  timeFormat: _ctx.timeFormat,
                  unlinkPanels: _ctx.unlinkPanels,
                  type: _ctx.type,
                  defaultValue: _ctx.defaultValue,
                  onPick,
                  onSelectRange: setSelectionRange,
                  onSetPickerOption,
                  onCalendarChange,
                  onPanelChange,
                  onKeydown: onKeydownPopperContent,
                  onMousedown: _cache[1] || (_cache[1] = withModifiers(() => {
                  }, ["stop"]))
                })
              ]),
              _: 3
            }, 16, ["visible", "transition", "popper-class", "popper-options"]);
          };
        }
      });
      var CommonPicker = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__file", "picker.vue"]]);
      const panelTimePickerProps = buildProps({
        ...timePanelSharedProps,
        datetimeRole: String,
        parsedValue: {
          type: definePropType(Object)
        }
      });
      const useTimePanel = ({
        getAvailableHours,
        getAvailableMinutes,
        getAvailableSeconds
      }) => {
        const getAvailableTime = (date2, role, first, compareDate) => {
          const availableTimeGetters = {
            hour: getAvailableHours,
            minute: getAvailableMinutes,
            second: getAvailableSeconds
          };
          let result = date2;
          ["hour", "minute", "second"].forEach((type) => {
            if (availableTimeGetters[type]) {
              let availableTimeSlots;
              const method = availableTimeGetters[type];
              switch (type) {
                case "minute": {
                  availableTimeSlots = method(result.hour(), role, compareDate);
                  break;
                }
                case "second": {
                  availableTimeSlots = method(result.hour(), result.minute(), role, compareDate);
                  break;
                }
                default: {
                  availableTimeSlots = method(role, compareDate);
                  break;
                }
              }
              if ((availableTimeSlots == null ? void 0 : availableTimeSlots.length) && !availableTimeSlots.includes(result[type]())) {
                const pos = first ? 0 : availableTimeSlots.length - 1;
                result = result[type](availableTimeSlots[pos]);
              }
            }
          });
          return result;
        };
        const timePickerOptions = {};
        const onSetOption = ([key, val]) => {
          timePickerOptions[key] = val;
        };
        return {
          timePickerOptions,
          getAvailableTime,
          onSetOption
        };
      };
      const makeAvailableArr = (disabledList) => {
        const trueOrNumber = (isDisabled, index) => isDisabled || index;
        const getNumber = (predicate) => predicate !== true;
        return disabledList.map(trueOrNumber).filter(getNumber);
      };
      const getTimeLists = (disabledHours, disabledMinutes, disabledSeconds) => {
        const getHoursList = (role, compare) => {
          return makeList(24, disabledHours && (() => disabledHours == null ? void 0 : disabledHours(role, compare)));
        };
        const getMinutesList = (hour, role, compare) => {
          return makeList(60, disabledMinutes && (() => disabledMinutes == null ? void 0 : disabledMinutes(hour, role, compare)));
        };
        const getSecondsList = (hour, minute, role, compare) => {
          return makeList(60, disabledSeconds && (() => disabledSeconds == null ? void 0 : disabledSeconds(hour, minute, role, compare)));
        };
        return {
          getHoursList,
          getMinutesList,
          getSecondsList
        };
      };
      const buildAvailableTimeSlotGetter = (disabledHours, disabledMinutes, disabledSeconds) => {
        const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(disabledHours, disabledMinutes, disabledSeconds);
        const getAvailableHours = (role, compare) => {
          return makeAvailableArr(getHoursList(role, compare));
        };
        const getAvailableMinutes = (hour, role, compare) => {
          return makeAvailableArr(getMinutesList(hour, role, compare));
        };
        const getAvailableSeconds = (hour, minute, role, compare) => {
          return makeAvailableArr(getSecondsList(hour, minute, role, compare));
        };
        return {
          getAvailableHours,
          getAvailableMinutes,
          getAvailableSeconds
        };
      };
      const useOldValue = (props) => {
        const oldValue = ref(props.parsedValue);
        watch(() => props.visible, (val) => {
          if (!val) {
            oldValue.value = props.parsedValue;
          }
        });
        return oldValue;
      };
      const nodeList = /* @__PURE__ */ new Map();
      let startClick;
      if (isClient) {
        document.addEventListener("mousedown", (e2) => startClick = e2);
        document.addEventListener("mouseup", (e2) => {
          for (const handlers of nodeList.values()) {
            for (const { documentHandler } of handlers) {
              documentHandler(e2, startClick);
            }
          }
        });
      }
      function createDocumentHandler(el, binding) {
        let excludes = [];
        if (Array.isArray(binding.arg)) {
          excludes = binding.arg;
        } else if (isElement(binding.arg)) {
          excludes.push(binding.arg);
        }
        return function(mouseup, mousedown) {
          const popperRef = binding.instance.popperRef;
          const mouseUpTarget = mouseup.target;
          const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
          const isBound = !binding || !binding.instance;
          const isTargetExists = !mouseUpTarget || !mouseDownTarget;
          const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
          const isSelf = el === mouseUpTarget;
          const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
          const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
          if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
            return;
          }
          binding.value(mouseup, mousedown);
        };
      }
      const ClickOutside = {
        beforeMount(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          nodeList.get(el).push({
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          });
        },
        updated(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          const handlers = nodeList.get(el);
          const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
          const newHandler = {
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          };
          if (oldHandlerIndex >= 0) {
            handlers.splice(oldHandlerIndex, 1, newHandler);
          } else {
            handlers.push(newHandler);
          }
        },
        unmounted(el) {
          nodeList.delete(el);
        }
      };
      const REPEAT_INTERVAL = 100;
      const REPEAT_DELAY = 600;
      const vRepeatClick = {
        beforeMount(el, binding) {
          const value = binding.value;
          const { interval = REPEAT_INTERVAL, delay = REPEAT_DELAY } = isFunction$1(value) ? {} : value;
          let intervalId;
          let delayId;
          const handler = () => isFunction$1(value) ? value() : value.handler();
          const clear2 = () => {
            if (delayId) {
              clearTimeout(delayId);
              delayId = void 0;
            }
            if (intervalId) {
              clearInterval(intervalId);
              intervalId = void 0;
            }
          };
          el.addEventListener("mousedown", (evt) => {
            if (evt.button !== 0)
              return;
            clear2();
            handler();
            document.addEventListener("mouseup", () => clear2(), {
              once: true
            });
            delayId = setTimeout(() => {
              intervalId = setInterval(() => {
                handler();
              }, interval);
            }, delay);
          });
        }
      };
      const FOCUSABLE_CHILDREN = "_trap-focus-children";
      const FOCUS_STACK = [];
      const FOCUS_HANDLER = (e2) => {
        if (FOCUS_STACK.length === 0)
          return;
        const focusableElement = FOCUS_STACK[FOCUS_STACK.length - 1][FOCUSABLE_CHILDREN];
        if (focusableElement.length > 0 && e2.code === EVENT_CODE.tab) {
          if (focusableElement.length === 1) {
            e2.preventDefault();
            if (document.activeElement !== focusableElement[0]) {
              focusableElement[0].focus();
            }
            return;
          }
          const goingBackward = e2.shiftKey;
          const isFirst = e2.target === focusableElement[0];
          const isLast = e2.target === focusableElement[focusableElement.length - 1];
          if (isFirst && goingBackward) {
            e2.preventDefault();
            focusableElement[focusableElement.length - 1].focus();
          }
          if (isLast && !goingBackward) {
            e2.preventDefault();
            focusableElement[0].focus();
          }
        }
      };
      const TrapFocus = {
        beforeMount(el) {
          el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
          FOCUS_STACK.push(el);
          if (FOCUS_STACK.length <= 1) {
            document.addEventListener("keydown", FOCUS_HANDLER);
          }
        },
        updated(el) {
          nextTick(() => {
            el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
          });
        },
        unmounted() {
          FOCUS_STACK.shift();
          if (FOCUS_STACK.length === 0) {
            document.removeEventListener("keydown", FOCUS_HANDLER);
          }
        }
      };
      const basicTimeSpinnerProps = buildProps({
        role: {
          type: String,
          required: true
        },
        spinnerDate: {
          type: definePropType(Object),
          required: true
        },
        showSeconds: {
          type: Boolean,
          default: true
        },
        arrowControl: Boolean,
        amPmMode: {
          type: definePropType(String),
          default: ""
        },
        ...disabledTimeListsProps
      });
      const _hoisted_1$d = ["onClick"];
      const _hoisted_2$a = ["onMouseenter"];
      const _sfc_main$i = /* @__PURE__ */ defineComponent({
        __name: "basic-time-spinner",
        props: basicTimeSpinnerProps,
        emits: ["change", "select-range", "set-option"],
        setup(__props, { emit: emit2 }) {
          const props = __props;
          const ns = useNamespace("time");
          const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(props.disabledHours, props.disabledMinutes, props.disabledSeconds);
          let isScrolling = false;
          const currentScrollbar = ref();
          const listHoursRef = ref();
          const listMinutesRef = ref();
          const listSecondsRef = ref();
          const listRefsMap = {
            hours: listHoursRef,
            minutes: listMinutesRef,
            seconds: listSecondsRef
          };
          const spinnerItems = computed(() => {
            return props.showSeconds ? timeUnits : timeUnits.slice(0, 2);
          });
          const timePartials = computed(() => {
            const { spinnerDate } = props;
            const hours = spinnerDate.hour();
            const minutes = spinnerDate.minute();
            const seconds = spinnerDate.second();
            return { hours, minutes, seconds };
          });
          const timeList = computed(() => {
            const { hours, minutes } = unref(timePartials);
            return {
              hours: getHoursList(props.role),
              minutes: getMinutesList(hours, props.role),
              seconds: getSecondsList(hours, minutes, props.role)
            };
          });
          const arrowControlTimeList = computed(() => {
            const { hours, minutes, seconds } = unref(timePartials);
            return {
              hours: buildTimeList(hours, 23),
              minutes: buildTimeList(minutes, 59),
              seconds: buildTimeList(seconds, 59)
            };
          });
          const debouncedResetScroll = debounce((type) => {
            isScrolling = false;
            adjustCurrentSpinner(type);
          }, 200);
          const getAmPmFlag = (hour) => {
            const shouldShowAmPm = !!props.amPmMode;
            if (!shouldShowAmPm)
              return "";
            const isCapital = props.amPmMode === "A";
            let content = hour < 12 ? " am" : " pm";
            if (isCapital)
              content = content.toUpperCase();
            return content;
          };
          const emitSelectRange = (type) => {
            let range;
            switch (type) {
              case "hours":
                range = [0, 2];
                break;
              case "minutes":
                range = [3, 5];
                break;
              case "seconds":
                range = [6, 8];
                break;
            }
            const [left, right] = range;
            emit2("select-range", left, right);
            currentScrollbar.value = type;
          };
          const adjustCurrentSpinner = (type) => {
            adjustSpinner(type, unref(timePartials)[type]);
          };
          const adjustSpinners = () => {
            adjustCurrentSpinner("hours");
            adjustCurrentSpinner("minutes");
            adjustCurrentSpinner("seconds");
          };
          const getScrollbarElement = (el) => el.querySelector(`.${ns.namespace.value}-scrollbar__wrap`);
          const adjustSpinner = (type, value) => {
            if (props.arrowControl)
              return;
            const scrollbar = unref(listRefsMap[type]);
            if (scrollbar && scrollbar.$el) {
              getScrollbarElement(scrollbar.$el).scrollTop = Math.max(0, value * typeItemHeight(type));
            }
          };
          const typeItemHeight = (type) => {
            const scrollbar = unref(listRefsMap[type]);
            const listItem = scrollbar == null ? void 0 : scrollbar.$el.querySelector("li");
            if (listItem) {
              return Number.parseFloat(getStyle(listItem, "height")) || 0;
            }
            return 0;
          };
          const onIncrement = () => {
            scrollDown(1);
          };
          const onDecrement = () => {
            scrollDown(-1);
          };
          const scrollDown = (step) => {
            if (!currentScrollbar.value) {
              emitSelectRange("hours");
            }
            const label = currentScrollbar.value;
            const now2 = unref(timePartials)[label];
            const total = currentScrollbar.value === "hours" ? 24 : 60;
            const next = findNextUnDisabled(label, now2, step, total);
            modifyDateField(label, next);
            adjustSpinner(label, next);
            nextTick(() => emitSelectRange(label));
          };
          const findNextUnDisabled = (type, now2, step, total) => {
            let next = (now2 + step + total) % total;
            const list = unref(timeList)[type];
            while (list[next] && next !== now2) {
              next = (next + step + total) % total;
            }
            return next;
          };
          const modifyDateField = (type, value) => {
            const list = unref(timeList)[type];
            const isDisabled = list[value];
            if (isDisabled)
              return;
            const { hours, minutes, seconds } = unref(timePartials);
            let changeTo;
            switch (type) {
              case "hours":
                changeTo = props.spinnerDate.hour(value).minute(minutes).second(seconds);
                break;
              case "minutes":
                changeTo = props.spinnerDate.hour(hours).minute(value).second(seconds);
                break;
              case "seconds":
                changeTo = props.spinnerDate.hour(hours).minute(minutes).second(value);
                break;
            }
            emit2("change", changeTo);
          };
          const handleClick = (type, { value, disabled }) => {
            if (!disabled) {
              modifyDateField(type, value);
              emitSelectRange(type);
              adjustSpinner(type, value);
            }
          };
          const handleScroll = (type) => {
            isScrolling = true;
            debouncedResetScroll(type);
            const value = Math.min(Math.round((getScrollbarElement(unref(listRefsMap[type]).$el).scrollTop - (scrollBarHeight(type) * 0.5 - 10) / typeItemHeight(type) + 3) / typeItemHeight(type)), type === "hours" ? 23 : 59);
            modifyDateField(type, value);
          };
          const scrollBarHeight = (type) => {
            return unref(listRefsMap[type]).$el.offsetHeight;
          };
          const bindScrollEvent = () => {
            const bindFunction = (type) => {
              const scrollbar = unref(listRefsMap[type]);
              if (scrollbar && scrollbar.$el) {
                getScrollbarElement(scrollbar.$el).onscroll = () => {
                  handleScroll(type);
                };
              }
            };
            bindFunction("hours");
            bindFunction("minutes");
            bindFunction("seconds");
          };
          onMounted(() => {
            nextTick(() => {
              !props.arrowControl && bindScrollEvent();
              adjustSpinners();
              if (props.role === "start")
                emitSelectRange("hours");
            });
          });
          const setRef2 = (scrollbar, type) => {
            listRefsMap[type].value = scrollbar;
          };
          emit2("set-option", [`${props.role}_scrollDown`, scrollDown]);
          emit2("set-option", [`${props.role}_emitSelectRange`, emitSelectRange]);
          watch(() => props.spinnerDate, () => {
            if (isScrolling)
              return;
            adjustSpinners();
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b("spinner"), { "has-seconds": _ctx.showSeconds }])
            }, [
              !_ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(spinnerItems), (item) => {
                return openBlock(), createBlock(unref(ElScrollbar), {
                  key: item,
                  ref_for: true,
                  ref: (scrollbar) => setRef2(scrollbar, item),
                  class: normalizeClass(unref(ns).be("spinner", "wrapper")),
                  "wrap-style": "max-height: inherit;",
                  "view-class": unref(ns).be("spinner", "list"),
                  noresize: "",
                  tag: "ul",
                  onMouseenter: ($event) => emitSelectRange(item),
                  onMousemove: ($event) => adjustCurrentSpinner(item)
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(timeList)[item], (disabled, key) => {
                      return openBlock(), createElementBlock("li", {
                        key,
                        class: normalizeClass([
                          unref(ns).be("spinner", "item"),
                          unref(ns).is("active", key === unref(timePartials)[item]),
                          unref(ns).is("disabled", disabled)
                        ]),
                        onClick: ($event) => handleClick(item, { value: key, disabled })
                      }, [
                        item === "hours" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                          createTextVNode(toDisplayString(("0" + (_ctx.amPmMode ? key % 12 || 12 : key)).slice(-2)) + toDisplayString(getAmPmFlag(key)), 1)
                        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                          createTextVNode(toDisplayString(("0" + key).slice(-2)), 1)
                        ], 64))
                      ], 10, _hoisted_1$d);
                    }), 128))
                  ]),
                  _: 2
                }, 1032, ["class", "view-class", "onMouseenter", "onMousemove"]);
              }), 128)) : createCommentVNode("v-if", true),
              _ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(spinnerItems), (item) => {
                return openBlock(), createElementBlock("div", {
                  key: item,
                  class: normalizeClass([unref(ns).be("spinner", "wrapper"), unref(ns).is("arrow")]),
                  onMouseenter: ($event) => emitSelectRange(item)
                }, [
                  withDirectives((openBlock(), createBlock(unref(ElIcon), {
                    class: normalizeClass(["arrow-up", unref(ns).be("spinner", "arrow")])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(arrow_up_default))
                    ]),
                    _: 1
                  }, 8, ["class"])), [
                    [unref(vRepeatClick), onDecrement]
                  ]),
                  withDirectives((openBlock(), createBlock(unref(ElIcon), {
                    class: normalizeClass(["arrow-down", unref(ns).be("spinner", "arrow")])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(arrow_down_default))
                    ]),
                    _: 1
                  }, 8, ["class"])), [
                    [unref(vRepeatClick), onIncrement]
                  ]),
                  createBaseVNode("ul", {
                    class: normalizeClass(unref(ns).be("spinner", "list"))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(arrowControlTimeList)[item], (time, key) => {
                      return openBlock(), createElementBlock("li", {
                        key,
                        class: normalizeClass([
                          unref(ns).be("spinner", "item"),
                          unref(ns).is("active", time === unref(timePartials)[item]),
                          unref(ns).is("disabled", unref(timeList)[item][time])
                        ])
                      }, [
                        typeof time === "number" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                          item === "hours" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                            createTextVNode(toDisplayString(("0" + (_ctx.amPmMode ? time % 12 || 12 : time)).slice(-2)) + toDisplayString(getAmPmFlag(time)), 1)
                          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                            createTextVNode(toDisplayString(("0" + time).slice(-2)), 1)
                          ], 64))
                        ], 64)) : createCommentVNode("v-if", true)
                      ], 2);
                    }), 128))
                  ], 2)
                ], 42, _hoisted_2$a);
              }), 128)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var TimeSpinner = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__file", "basic-time-spinner.vue"]]);
      const _sfc_main$h = /* @__PURE__ */ defineComponent({
        __name: "panel-time-pick",
        props: panelTimePickerProps,
        emits: ["pick", "select-range", "set-picker-option"],
        setup(__props, { emit: emit2 }) {
          const props = __props;
          const pickerBase = inject("EP_PICKER_BASE");
          const {
            arrowControl,
            disabledHours,
            disabledMinutes,
            disabledSeconds,
            defaultValue
          } = pickerBase.props;
          const { getAvailableHours, getAvailableMinutes, getAvailableSeconds } = buildAvailableTimeSlotGetter(disabledHours, disabledMinutes, disabledSeconds);
          const ns = useNamespace("time");
          const { t: t2, lang } = useLocale();
          const selectionRange = ref([0, 2]);
          const oldValue = useOldValue(props);
          const transitionName = computed(() => {
            return isUndefined(props.actualVisible) ? `${ns.namespace.value}-zoom-in-top` : "";
          });
          const showSeconds = computed(() => {
            return props.format.includes("ss");
          });
          const amPmMode = computed(() => {
            if (props.format.includes("A"))
              return "A";
            if (props.format.includes("a"))
              return "a";
            return "";
          });
          const isValidValue = (_date) => {
            const parsedDate = dayjs(_date).locale(lang.value);
            const result = getRangeAvailableTime(parsedDate);
            return parsedDate.isSame(result);
          };
          const handleCancel = () => {
            emit2("pick", oldValue.value, false);
          };
          const handleConfirm = (visible = false, first = false) => {
            if (first)
              return;
            emit2("pick", props.parsedValue, visible);
          };
          const handleChange = (_date) => {
            if (!props.visible) {
              return;
            }
            const result = getRangeAvailableTime(_date).millisecond(0);
            emit2("pick", result, true);
          };
          const setSelectionRange = (start, end) => {
            emit2("select-range", start, end);
            selectionRange.value = [start, end];
          };
          const changeSelectionRange = (step) => {
            const list = [0, 3].concat(showSeconds.value ? [6] : []);
            const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
            const index = list.indexOf(selectionRange.value[0]);
            const next = (index + step + list.length) % list.length;
            timePickerOptions["start_emitSelectRange"](mapping[next]);
          };
          const handleKeydown = (event) => {
            const code = event.code;
            const { left, right, up, down } = EVENT_CODE;
            if ([left, right].includes(code)) {
              const step = code === left ? -1 : 1;
              changeSelectionRange(step);
              event.preventDefault();
              return;
            }
            if ([up, down].includes(code)) {
              const step = code === up ? -1 : 1;
              timePickerOptions["start_scrollDown"](step);
              event.preventDefault();
              return;
            }
          };
          const { timePickerOptions, onSetOption, getAvailableTime } = useTimePanel({
            getAvailableHours,
            getAvailableMinutes,
            getAvailableSeconds
          });
          const getRangeAvailableTime = (date2) => {
            return getAvailableTime(date2, props.datetimeRole || "", true);
          };
          const parseUserInput = (value) => {
            if (!value)
              return null;
            return dayjs(value, props.format).locale(lang.value);
          };
          const formatToString = (value) => {
            if (!value)
              return null;
            return value.format(props.format);
          };
          const getDefaultValue2 = () => {
            return dayjs(defaultValue).locale(lang.value);
          };
          emit2("set-picker-option", ["isValidValue", isValidValue]);
          emit2("set-picker-option", ["formatToString", formatToString]);
          emit2("set-picker-option", ["parseUserInput", parseUserInput]);
          emit2("set-picker-option", ["handleKeydownInput", handleKeydown]);
          emit2("set-picker-option", ["getRangeAvailableTime", getRangeAvailableTime]);
          emit2("set-picker-option", ["getDefaultValue", getDefaultValue2]);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, { name: unref(transitionName) }, {
              default: withCtx(() => [
                _ctx.actualVisible || _ctx.visible ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).b("panel"))
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass([unref(ns).be("panel", "content"), { "has-seconds": unref(showSeconds) }])
                  }, [
                    createVNode(TimeSpinner, {
                      ref: "spinner",
                      role: _ctx.datetimeRole || "start",
                      "arrow-control": unref(arrowControl),
                      "show-seconds": unref(showSeconds),
                      "am-pm-mode": unref(amPmMode),
                      "spinner-date": _ctx.parsedValue,
                      "disabled-hours": unref(disabledHours),
                      "disabled-minutes": unref(disabledMinutes),
                      "disabled-seconds": unref(disabledSeconds),
                      onChange: handleChange,
                      onSetOption: unref(onSetOption),
                      onSelectRange: setSelectionRange
                    }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onSetOption"])
                  ], 2),
                  createBaseVNode("div", {
                    class: normalizeClass(unref(ns).be("panel", "footer"))
                  }, [
                    createBaseVNode("button", {
                      type: "button",
                      class: normalizeClass([unref(ns).be("panel", "btn"), "cancel"]),
                      onClick: handleCancel
                    }, toDisplayString(unref(t2)("el.datepicker.cancel")), 3),
                    createBaseVNode("button", {
                      type: "button",
                      class: normalizeClass([unref(ns).be("panel", "btn"), "confirm"]),
                      onClick: _cache[0] || (_cache[0] = ($event) => handleConfirm())
                    }, toDisplayString(unref(t2)("el.datepicker.confirm")), 3)
                  ], 2)
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 1
            }, 8, ["name"]);
          };
        }
      });
      var TimePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__file", "panel-time-pick.vue"]]);
      var localeData$1 = { exports: {} };
      (function(module2, exports2) {
        !function(n2, e2) {
          module2.exports = e2();
        }(commonjsGlobal, function() {
          return function(n2, e2, t2) {
            var r2 = e2.prototype, o2 = function(n3) {
              return n3 && (n3.indexOf ? n3 : n3.s);
            }, u = function(n3, e3, t3, r3, u2) {
              var i2 = n3.name ? n3 : n3.$locale(), a2 = o2(i2[e3]), s3 = o2(i2[t3]), f = a2 || s3.map(function(n4) {
                return n4.slice(0, r3);
              });
              if (!u2)
                return f;
              var d = i2.weekStart;
              return f.map(function(n4, e4) {
                return f[(e4 + (d || 0)) % 7];
              });
            }, i = function() {
              return t2.Ls[t2.locale()];
            }, a = function(n3, e3) {
              return n3.formats[e3] || function(n4) {
                return n4.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n5, e4, t3) {
                  return e4 || t3.slice(1);
                });
              }(n3.formats[e3.toUpperCase()]);
            }, s2 = function() {
              var n3 = this;
              return { months: function(e3) {
                return e3 ? e3.format("MMMM") : u(n3, "months");
              }, monthsShort: function(e3) {
                return e3 ? e3.format("MMM") : u(n3, "monthsShort", "months", 3);
              }, firstDayOfWeek: function() {
                return n3.$locale().weekStart || 0;
              }, weekdays: function(e3) {
                return e3 ? e3.format("dddd") : u(n3, "weekdays");
              }, weekdaysMin: function(e3) {
                return e3 ? e3.format("dd") : u(n3, "weekdaysMin", "weekdays", 2);
              }, weekdaysShort: function(e3) {
                return e3 ? e3.format("ddd") : u(n3, "weekdaysShort", "weekdays", 3);
              }, longDateFormat: function(e3) {
                return a(n3.$locale(), e3);
              }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
            };
            r2.localeData = function() {
              return s2.bind(this)();
            }, t2.localeData = function() {
              var n3 = i();
              return { firstDayOfWeek: function() {
                return n3.weekStart || 0;
              }, weekdays: function() {
                return t2.weekdays();
              }, weekdaysShort: function() {
                return t2.weekdaysShort();
              }, weekdaysMin: function() {
                return t2.weekdaysMin();
              }, months: function() {
                return t2.months();
              }, monthsShort: function() {
                return t2.monthsShort();
              }, longDateFormat: function(e3) {
                return a(n3, e3);
              }, meridiem: n3.meridiem, ordinal: n3.ordinal };
            }, t2.months = function() {
              return u(i(), "months");
            }, t2.monthsShort = function() {
              return u(i(), "monthsShort", "months", 3);
            }, t2.weekdays = function(n3) {
              return u(i(), "weekdays", null, null, n3);
            }, t2.weekdaysShort = function(n3) {
              return u(i(), "weekdaysShort", "weekdays", 3, n3);
            }, t2.weekdaysMin = function(n3) {
              return u(i(), "weekdaysMin", "weekdays", 2, n3);
            };
          };
        });
      })(localeData$1);
      var localeDataExports = localeData$1.exports;
      const localeData = /* @__PURE__ */ getDefaultExportFromCjs(localeDataExports);
      const tagProps = buildProps({
        type: {
          type: String,
          values: ["success", "info", "warning", "danger", ""],
          default: ""
        },
        closable: Boolean,
        disableTransitions: Boolean,
        hit: Boolean,
        color: {
          type: String,
          default: ""
        },
        size: {
          type: String,
          values: componentSizes,
          default: ""
        },
        effect: {
          type: String,
          values: ["dark", "light", "plain"],
          default: "light"
        },
        round: Boolean
      });
      const tagEmits = {
        close: (evt) => evt instanceof MouseEvent,
        click: (evt) => evt instanceof MouseEvent
      };
      const __default__$3 = /* @__PURE__ */ defineComponent({
        name: "ElTag"
      });
      const _sfc_main$g = /* @__PURE__ */ defineComponent({
        ...__default__$3,
        props: tagProps,
        emits: tagEmits,
        setup(__props, { emit: emit2 }) {
          const props = __props;
          const tagSize = useFormSize();
          const ns = useNamespace("tag");
          const containerKls = computed(() => {
            const { type, hit, effect, closable, round } = props;
            return [
              ns.b(),
              ns.is("closable", closable),
              ns.m(type),
              ns.m(tagSize.value),
              ns.m(effect),
              ns.is("hit", hit),
              ns.is("round", round)
            ];
          });
          const handleClose = (event) => {
            emit2("close", event);
          };
          const handleClick = (event) => {
            emit2("click", event);
          };
          return (_ctx, _cache) => {
            return _ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass(unref(containerKls)),
              style: normalizeStyle({ backgroundColor: _ctx.color }),
              onClick: handleClick
            }, [
              createBaseVNode("span", {
                class: normalizeClass(unref(ns).e("content"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2),
              _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                key: 0,
                class: normalizeClass(unref(ns).e("close")),
                onClick: withModifiers(handleClose, ["stop"])
              }, {
                default: withCtx(() => [
                  createVNode(unref(close_default))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
            ], 6)) : (openBlock(), createBlock(Transition, {
              key: 1,
              name: `${unref(ns).namespace.value}-zoom-in-center`,
              appear: ""
            }, {
              default: withCtx(() => [
                createBaseVNode("span", {
                  class: normalizeClass(unref(containerKls)),
                  style: normalizeStyle({ backgroundColor: _ctx.color }),
                  onClick: handleClick
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(ns).e("content"))
                  }, [
                    renderSlot(_ctx.$slots, "default")
                  ], 2),
                  _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).e("close")),
                    onClick: withModifiers(handleClose, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(close_default))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ], 6)
              ]),
              _: 3
            }, 8, ["name"]));
          };
        }
      });
      var Tag = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__file", "tag.vue"]]);
      const ElTag = withInstall(Tag);
      var advancedFormat$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e2, t2) {
          module2.exports = t2();
        }(commonjsGlobal, function() {
          return function(e2, t2) {
            var r2 = t2.prototype, n2 = r2.format;
            r2.format = function(e3) {
              var t3 = this, r3 = this.$locale();
              if (!this.isValid())
                return n2.bind(this)(e3);
              var s2 = this.$utils(), a = (e3 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e4) {
                switch (e4) {
                  case "Q":
                    return Math.ceil((t3.$M + 1) / 3);
                  case "Do":
                    return r3.ordinal(t3.$D);
                  case "gggg":
                    return t3.weekYear();
                  case "GGGG":
                    return t3.isoWeekYear();
                  case "wo":
                    return r3.ordinal(t3.week(), "W");
                  case "w":
                  case "ww":
                    return s2.s(t3.week(), "w" === e4 ? 1 : 2, "0");
                  case "W":
                  case "WW":
                    return s2.s(t3.isoWeek(), "W" === e4 ? 1 : 2, "0");
                  case "k":
                  case "kk":
                    return s2.s(String(0 === t3.$H ? 24 : t3.$H), "k" === e4 ? 1 : 2, "0");
                  case "X":
                    return Math.floor(t3.$d.getTime() / 1e3);
                  case "x":
                    return t3.$d.getTime();
                  case "z":
                    return "[" + t3.offsetName() + "]";
                  case "zzz":
                    return "[" + t3.offsetName("long") + "]";
                  default:
                    return e4;
                }
              });
              return n2.bind(this)(a);
            };
          };
        });
      })(advancedFormat$1);
      var advancedFormatExports = advancedFormat$1.exports;
      const advancedFormat = /* @__PURE__ */ getDefaultExportFromCjs(advancedFormatExports);
      var weekOfYear$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e2, t2) {
          module2.exports = t2();
        }(commonjsGlobal, function() {
          var e2 = "week", t2 = "year";
          return function(i, n2, r2) {
            var f = n2.prototype;
            f.week = function(i2) {
              if (void 0 === i2 && (i2 = null), null !== i2)
                return this.add(7 * (i2 - this.week()), "day");
              var n3 = this.$locale().yearStart || 1;
              if (11 === this.month() && this.date() > 25) {
                var f2 = r2(this).startOf(t2).add(1, t2).date(n3), s2 = r2(this).endOf(e2);
                if (f2.isBefore(s2))
                  return 1;
              }
              var a = r2(this).startOf(t2).date(n3).startOf(e2).subtract(1, "millisecond"), o2 = this.diff(a, e2, true);
              return o2 < 0 ? r2(this).startOf("week").week() : Math.ceil(o2);
            }, f.weeks = function(e3) {
              return void 0 === e3 && (e3 = null), this.week(e3);
            };
          };
        });
      })(weekOfYear$1);
      var weekOfYearExports = weekOfYear$1.exports;
      const weekOfYear = /* @__PURE__ */ getDefaultExportFromCjs(weekOfYearExports);
      var weekYear$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e2, t2) {
          module2.exports = t2();
        }(commonjsGlobal, function() {
          return function(e2, t2) {
            t2.prototype.weekYear = function() {
              var e3 = this.month(), t3 = this.week(), n2 = this.year();
              return 1 === t3 && 11 === e3 ? n2 + 1 : 0 === e3 && t3 >= 52 ? n2 - 1 : n2;
            };
          };
        });
      })(weekYear$1);
      var weekYearExports = weekYear$1.exports;
      const weekYear = /* @__PURE__ */ getDefaultExportFromCjs(weekYearExports);
      var dayOfYear$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e2, t2) {
          module2.exports = t2();
        }(commonjsGlobal, function() {
          return function(e2, t2, n2) {
            t2.prototype.dayOfYear = function(e3) {
              var t3 = Math.round((n2(this).startOf("day") - n2(this).startOf("year")) / 864e5) + 1;
              return null == e3 ? t3 : this.add(e3 - t3, "day");
            };
          };
        });
      })(dayOfYear$1);
      var dayOfYearExports = dayOfYear$1.exports;
      const dayOfYear = /* @__PURE__ */ getDefaultExportFromCjs(dayOfYearExports);
      var isSameOrAfter$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e2, t2) {
          module2.exports = t2();
        }(commonjsGlobal, function() {
          return function(e2, t2) {
            t2.prototype.isSameOrAfter = function(e3, t3) {
              return this.isSame(e3, t3) || this.isAfter(e3, t3);
            };
          };
        });
      })(isSameOrAfter$1);
      var isSameOrAfterExports = isSameOrAfter$1.exports;
      const isSameOrAfter = /* @__PURE__ */ getDefaultExportFromCjs(isSameOrAfterExports);
      var isSameOrBefore$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e2, i) {
          module2.exports = i();
        }(commonjsGlobal, function() {
          return function(e2, i) {
            i.prototype.isSameOrBefore = function(e3, i2) {
              return this.isSame(e3, i2) || this.isBefore(e3, i2);
            };
          };
        });
      })(isSameOrBefore$1);
      var isSameOrBeforeExports = isSameOrBefore$1.exports;
      const isSameOrBefore = /* @__PURE__ */ getDefaultExportFromCjs(isSameOrBeforeExports);
      const ROOT_PICKER_INJECTION_KEY = Symbol();
      const datePickerProps = buildProps({
        ...timePickerDefaultProps,
        type: {
          type: definePropType(String),
          default: "date"
        }
      });
      const selectionModes = ["date", "dates", "year", "month", "week", "range"];
      const datePickerSharedProps = buildProps({
        disabledDate: {
          type: definePropType(Function)
        },
        date: {
          type: definePropType(Object),
          required: true
        },
        minDate: {
          type: definePropType(Object)
        },
        maxDate: {
          type: definePropType(Object)
        },
        parsedValue: {
          type: definePropType([Object, Array])
        },
        rangeState: {
          type: definePropType(Object),
          default: () => ({
            endDate: null,
            selecting: false
          })
        }
      });
      const panelSharedProps = buildProps({
        type: {
          type: definePropType(String),
          required: true,
          values: datePickTypes
        },
        dateFormat: String,
        timeFormat: String
      });
      const panelRangeSharedProps = buildProps({
        unlinkPanels: Boolean,
        parsedValue: {
          type: definePropType(Array)
        }
      });
      const selectionModeWithDefault = (mode) => {
        return {
          type: String,
          values: selectionModes,
          default: mode
        };
      };
      const panelDatePickProps = buildProps({
        ...panelSharedProps,
        parsedValue: {
          type: definePropType([Object, Array])
        },
        visible: {
          type: Boolean
        },
        format: {
          type: String,
          default: ""
        }
      });
      const basicDateTableProps = buildProps({
        ...datePickerSharedProps,
        cellClassName: {
          type: definePropType(Function)
        },
        showWeekNumber: Boolean,
        selectionMode: selectionModeWithDefault("date")
      });
      const basicDateTableEmits = ["changerange", "pick", "select"];
      const isValidRange = (range) => {
        if (!isArray$2(range))
          return false;
        const [left, right] = range;
        return dayjs.isDayjs(left) && dayjs.isDayjs(right) && left.isSameOrBefore(right);
      };
      const getDefaultValue = (defaultValue, { lang, unit: unit2, unlinkPanels }) => {
        let start;
        if (isArray$2(defaultValue)) {
          let [left, right] = defaultValue.map((d) => dayjs(d).locale(lang));
          if (!unlinkPanels) {
            right = left.add(1, unit2);
          }
          return [left, right];
        } else if (defaultValue) {
          start = dayjs(defaultValue);
        } else {
          start = dayjs();
        }
        start = start.locale(lang);
        return [start, start.add(1, unit2)];
      };
      const buildPickerTable = (dimension, rows, {
        columnIndexOffset,
        startDate,
        nextEndDate,
        now: now2,
        unit: unit2,
        relativeDateGetter,
        setCellMetadata,
        setRowMetadata
      }) => {
        for (let rowIndex = 0; rowIndex < dimension.row; rowIndex++) {
          const row = rows[rowIndex];
          for (let columnIndex = 0; columnIndex < dimension.column; columnIndex++) {
            let cell = row[columnIndex + columnIndexOffset];
            if (!cell) {
              cell = {
                row: rowIndex,
                column: columnIndex,
                type: "normal",
                inRange: false,
                start: false,
                end: false
              };
            }
            const index = rowIndex * dimension.column + columnIndex;
            const nextStartDate = relativeDateGetter(index);
            cell.dayjs = nextStartDate;
            cell.date = nextStartDate.toDate();
            cell.timestamp = nextStartDate.valueOf();
            cell.type = "normal";
            cell.inRange = !!(startDate && nextStartDate.isSameOrAfter(startDate, unit2) && nextEndDate && nextStartDate.isSameOrBefore(nextEndDate, unit2)) || !!(startDate && nextStartDate.isSameOrBefore(startDate, unit2) && nextEndDate && nextStartDate.isSameOrAfter(nextEndDate, unit2));
            if (startDate == null ? void 0 : startDate.isSameOrAfter(nextEndDate)) {
              cell.start = !!nextEndDate && nextStartDate.isSame(nextEndDate, unit2);
              cell.end = startDate && nextStartDate.isSame(startDate, unit2);
            } else {
              cell.start = !!startDate && nextStartDate.isSame(startDate, unit2);
              cell.end = !!nextEndDate && nextStartDate.isSame(nextEndDate, unit2);
            }
            const isToday = nextStartDate.isSame(now2, unit2);
            if (isToday) {
              cell.type = "today";
            }
            setCellMetadata == null ? void 0 : setCellMetadata(cell, { rowIndex, columnIndex });
            row[columnIndex + columnIndexOffset] = cell;
          }
          setRowMetadata == null ? void 0 : setRowMetadata(row);
        }
      };
      const isNormalDay = (type = "") => {
        return ["normal", "today"].includes(type);
      };
      const useBasicDateTable = (props, emit2) => {
        const { lang } = useLocale();
        const tbodyRef = ref();
        const currentCellRef = ref();
        const lastRow = ref();
        const lastColumn = ref();
        const tableRows = ref([[], [], [], [], [], []]);
        let focusWithClick = false;
        const firstDayOfWeek = props.date.$locale().weekStart || 7;
        const WEEKS_CONSTANT = props.date.locale("en").localeData().weekdaysShort().map((_2) => _2.toLowerCase());
        const offsetDay = computed(() => {
          return firstDayOfWeek > 3 ? 7 - firstDayOfWeek : -firstDayOfWeek;
        });
        const startDate = computed(() => {
          const startDayOfMonth = props.date.startOf("month");
          return startDayOfMonth.subtract(startDayOfMonth.day() || 7, "day");
        });
        const WEEKS = computed(() => {
          return WEEKS_CONSTANT.concat(WEEKS_CONSTANT).slice(firstDayOfWeek, firstDayOfWeek + 7);
        });
        const hasCurrent = computed(() => {
          return flatten(unref(rows)).some((row) => {
            return row.isCurrent;
          });
        });
        const days = computed(() => {
          const startOfMonth = props.date.startOf("month");
          const startOfMonthDay = startOfMonth.day() || 7;
          const dateCountOfMonth = startOfMonth.daysInMonth();
          const dateCountOfLastMonth = startOfMonth.subtract(1, "month").daysInMonth();
          return {
            startOfMonthDay,
            dateCountOfMonth,
            dateCountOfLastMonth
          };
        });
        const selectedDate = computed(() => {
          return props.selectionMode === "dates" ? castArray(props.parsedValue) : [];
        });
        const setDateText = (cell, { count, rowIndex, columnIndex }) => {
          const { startOfMonthDay, dateCountOfMonth, dateCountOfLastMonth } = unref(days);
          const offset = unref(offsetDay);
          if (rowIndex >= 0 && rowIndex <= 1) {
            const numberOfDaysFromPreviousMonth = startOfMonthDay + offset < 0 ? 7 + startOfMonthDay + offset : startOfMonthDay + offset;
            if (columnIndex + rowIndex * 7 >= numberOfDaysFromPreviousMonth) {
              cell.text = count;
              return true;
            } else {
              cell.text = dateCountOfLastMonth - (numberOfDaysFromPreviousMonth - columnIndex % 7) + 1 + rowIndex * 7;
              cell.type = "prev-month";
            }
          } else {
            if (count <= dateCountOfMonth) {
              cell.text = count;
            } else {
              cell.text = count - dateCountOfMonth;
              cell.type = "next-month";
            }
            return true;
          }
          return false;
        };
        const setCellMetadata = (cell, { columnIndex, rowIndex }, count) => {
          const { disabledDate: disabledDate2, cellClassName } = props;
          const _selectedDate = unref(selectedDate);
          const shouldIncrement = setDateText(cell, { count, rowIndex, columnIndex });
          const cellDate = cell.dayjs.toDate();
          cell.selected = _selectedDate.find((d) => d.valueOf() === cell.dayjs.valueOf());
          cell.isSelected = !!cell.selected;
          cell.isCurrent = isCurrent(cell);
          cell.disabled = disabledDate2 == null ? void 0 : disabledDate2(cellDate);
          cell.customClass = cellClassName == null ? void 0 : cellClassName(cellDate);
          return shouldIncrement;
        };
        const setRowMetadata = (row) => {
          if (props.selectionMode === "week") {
            const [start, end] = props.showWeekNumber ? [1, 7] : [0, 6];
            const isActive = isWeekActive(row[start + 1]);
            row[start].inRange = isActive;
            row[start].start = isActive;
            row[end].inRange = isActive;
            row[end].end = isActive;
          }
        };
        const rows = computed(() => {
          const { minDate, maxDate, rangeState, showWeekNumber } = props;
          const offset = unref(offsetDay);
          const rows_ = unref(tableRows);
          const dateUnit = "day";
          let count = 1;
          if (showWeekNumber) {
            for (let rowIndex = 0; rowIndex < 6; rowIndex++) {
              if (!rows_[rowIndex][0]) {
                rows_[rowIndex][0] = {
                  type: "week",
                  text: unref(startDate).add(rowIndex * 7 + 1, dateUnit).week()
                };
              }
            }
          }
          buildPickerTable({ row: 6, column: 7 }, rows_, {
            startDate: minDate,
            columnIndexOffset: showWeekNumber ? 1 : 0,
            nextEndDate: rangeState.endDate || maxDate || rangeState.selecting && minDate || null,
            now: dayjs().locale(unref(lang)).startOf(dateUnit),
            unit: dateUnit,
            relativeDateGetter: (idx) => unref(startDate).add(idx - offset, dateUnit),
            setCellMetadata: (...args) => {
              if (setCellMetadata(...args, count)) {
                count += 1;
              }
            },
            setRowMetadata
          });
          return rows_;
        });
        watch(() => props.date, async () => {
          var _a2;
          if ((_a2 = unref(tbodyRef)) == null ? void 0 : _a2.contains(document.activeElement)) {
            await nextTick();
            await focus();
          }
        });
        const focus = async () => {
          var _a2;
          return (_a2 = unref(currentCellRef)) == null ? void 0 : _a2.focus();
        };
        const isCurrent = (cell) => {
          return props.selectionMode === "date" && isNormalDay(cell.type) && cellMatchesDate(cell, props.parsedValue);
        };
        const cellMatchesDate = (cell, date2) => {
          if (!date2)
            return false;
          return dayjs(date2).locale(unref(lang)).isSame(props.date.date(Number(cell.text)), "day");
        };
        const getDateOfCell = (row, column) => {
          const offsetFromStart = row * 7 + (column - (props.showWeekNumber ? 1 : 0)) - unref(offsetDay);
          return unref(startDate).add(offsetFromStart, "day");
        };
        const handleMouseMove = (event) => {
          var _a2;
          if (!props.rangeState.selecting)
            return;
          let target = event.target;
          if (target.tagName === "SPAN") {
            target = (_a2 = target.parentNode) == null ? void 0 : _a2.parentNode;
          }
          if (target.tagName === "DIV") {
            target = target.parentNode;
          }
          if (target.tagName !== "TD")
            return;
          const row = target.parentNode.rowIndex - 1;
          const column = target.cellIndex;
          if (unref(rows)[row][column].disabled)
            return;
          if (row !== unref(lastRow) || column !== unref(lastColumn)) {
            lastRow.value = row;
            lastColumn.value = column;
            emit2("changerange", {
              selecting: true,
              endDate: getDateOfCell(row, column)
            });
          }
        };
        const isSelectedCell = (cell) => {
          return !unref(hasCurrent) && (cell == null ? void 0 : cell.text) === 1 && cell.type === "normal" || cell.isCurrent;
        };
        const handleFocus = (event) => {
          if (focusWithClick || unref(hasCurrent) || props.selectionMode !== "date")
            return;
          handlePickDate(event, true);
        };
        const handleMouseDown = (event) => {
          const target = event.target.closest("td");
          if (!target)
            return;
          focusWithClick = true;
        };
        const handleMouseUp = (event) => {
          const target = event.target.closest("td");
          if (!target)
            return;
          focusWithClick = false;
        };
        const handleRangePick = (newDate) => {
          if (!props.rangeState.selecting || !props.minDate) {
            emit2("pick", { minDate: newDate, maxDate: null });
            emit2("select", true);
          } else {
            if (newDate >= props.minDate) {
              emit2("pick", { minDate: props.minDate, maxDate: newDate });
            } else {
              emit2("pick", { minDate: newDate, maxDate: props.minDate });
            }
            emit2("select", false);
          }
        };
        const handleWeekPick = (newDate) => {
          const weekNumber = newDate.week();
          const value = `${newDate.year()}w${weekNumber}`;
          emit2("pick", {
            year: newDate.year(),
            week: weekNumber,
            value,
            date: newDate.startOf("week")
          });
        };
        const handleDatesPick = (newDate, selected) => {
          const newValue = selected ? castArray(props.parsedValue).filter((d) => (d == null ? void 0 : d.valueOf()) !== newDate.valueOf()) : castArray(props.parsedValue).concat([newDate]);
          emit2("pick", newValue);
        };
        const handlePickDate = (event, isKeyboardMovement = false) => {
          const target = event.target.closest("td");
          if (!target)
            return;
          const row = target.parentNode.rowIndex - 1;
          const column = target.cellIndex;
          const cell = unref(rows)[row][column];
          if (cell.disabled || cell.type === "week")
            return;
          const newDate = getDateOfCell(row, column);
          switch (props.selectionMode) {
            case "range": {
              handleRangePick(newDate);
              break;
            }
            case "date": {
              emit2("pick", newDate, isKeyboardMovement);
              break;
            }
            case "week": {
              handleWeekPick(newDate);
              break;
            }
            case "dates": {
              handleDatesPick(newDate, !!cell.selected);
              break;
            }
          }
        };
        const isWeekActive = (cell) => {
          if (props.selectionMode !== "week")
            return false;
          let newDate = props.date.startOf("day");
          if (cell.type === "prev-month") {
            newDate = newDate.subtract(1, "month");
          }
          if (cell.type === "next-month") {
            newDate = newDate.add(1, "month");
          }
          newDate = newDate.date(Number.parseInt(cell.text, 10));
          if (props.parsedValue && !Array.isArray(props.parsedValue)) {
            const dayOffset = (props.parsedValue.day() - firstDayOfWeek + 7) % 7 - 1;
            const weekDate = props.parsedValue.subtract(dayOffset, "day");
            return weekDate.isSame(newDate, "day");
          }
          return false;
        };
        return {
          WEEKS,
          rows,
          tbodyRef,
          currentCellRef,
          focus,
          isCurrent,
          isWeekActive,
          isSelectedCell,
          handlePickDate,
          handleMouseUp,
          handleMouseDown,
          handleMouseMove,
          handleFocus
        };
      };
      const useBasicDateTableDOM = (props, {
        isCurrent,
        isWeekActive
      }) => {
        const ns = useNamespace("date-table");
        const { t: t2 } = useLocale();
        const tableKls = computed(() => [
          ns.b(),
          { "is-week-mode": props.selectionMode === "week" }
        ]);
        const tableLabel = computed(() => t2("el.datepicker.dateTablePrompt"));
        const weekLabel = computed(() => t2("el.datepicker.week"));
        const getCellClasses = (cell) => {
          const classes = [];
          if (isNormalDay(cell.type) && !cell.disabled) {
            classes.push("available");
            if (cell.type === "today") {
              classes.push("today");
            }
          } else {
            classes.push(cell.type);
          }
          if (isCurrent(cell)) {
            classes.push("current");
          }
          if (cell.inRange && (isNormalDay(cell.type) || props.selectionMode === "week")) {
            classes.push("in-range");
            if (cell.start) {
              classes.push("start-date");
            }
            if (cell.end) {
              classes.push("end-date");
            }
          }
          if (cell.disabled) {
            classes.push("disabled");
          }
          if (cell.selected) {
            classes.push("selected");
          }
          if (cell.customClass) {
            classes.push(cell.customClass);
          }
          return classes.join(" ");
        };
        const getRowKls = (cell) => [
          ns.e("row"),
          { current: isWeekActive(cell) }
        ];
        return {
          tableKls,
          tableLabel,
          weekLabel,
          getCellClasses,
          getRowKls,
          t: t2
        };
      };
      const basicCellProps = buildProps({
        cell: {
          type: definePropType(Object)
        }
      });
      var ElDatePickerCell = /* @__PURE__ */ defineComponent({
        name: "ElDatePickerCell",
        props: basicCellProps,
        setup(props) {
          const ns = useNamespace("date-table-cell");
          const {
            slots
          } = inject(ROOT_PICKER_INJECTION_KEY);
          return () => {
            const {
              cell
            } = props;
            return renderSlot(slots, "default", {
              ...cell
            }, () => [createVNode("div", {
              "class": ns.b()
            }, [createVNode("span", {
              "class": ns.e("text")
            }, [cell == null ? void 0 : cell.text])])]);
          };
        }
      });
      const _hoisted_1$c = ["aria-label"];
      const _hoisted_2$9 = {
        key: 0,
        scope: "col"
      };
      const _hoisted_3$7 = ["aria-label"];
      const _hoisted_4$3 = ["aria-current", "aria-selected", "tabindex"];
      const _sfc_main$f = /* @__PURE__ */ defineComponent({
        __name: "basic-date-table",
        props: basicDateTableProps,
        emits: basicDateTableEmits,
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const {
            WEEKS,
            rows,
            tbodyRef,
            currentCellRef,
            focus,
            isCurrent,
            isWeekActive,
            isSelectedCell,
            handlePickDate,
            handleMouseUp,
            handleMouseDown,
            handleMouseMove,
            handleFocus
          } = useBasicDateTable(props, emit2);
          const { tableLabel, tableKls, weekLabel, getCellClasses, getRowKls, t: t2 } = useBasicDateTableDOM(props, {
            isCurrent,
            isWeekActive
          });
          expose({
            focus
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("table", {
              "aria-label": unref(tableLabel),
              class: normalizeClass(unref(tableKls)),
              cellspacing: "0",
              cellpadding: "0",
              role: "grid",
              onClick: _cache[1] || (_cache[1] = (...args) => unref(handlePickDate) && unref(handlePickDate)(...args)),
              onMousemove: _cache[2] || (_cache[2] = (...args) => unref(handleMouseMove) && unref(handleMouseMove)(...args)),
              onMousedown: _cache[3] || (_cache[3] = withModifiers((...args) => unref(handleMouseDown) && unref(handleMouseDown)(...args), ["prevent"])),
              onMouseup: _cache[4] || (_cache[4] = (...args) => unref(handleMouseUp) && unref(handleMouseUp)(...args))
            }, [
              createBaseVNode("tbody", {
                ref_key: "tbodyRef",
                ref: tbodyRef
              }, [
                createBaseVNode("tr", null, [
                  _ctx.showWeekNumber ? (openBlock(), createElementBlock("th", _hoisted_2$9, toDisplayString(unref(weekLabel)), 1)) : createCommentVNode("v-if", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(WEEKS), (week, key) => {
                    return openBlock(), createElementBlock("th", {
                      key,
                      "aria-label": unref(t2)("el.datepicker.weeksFull." + week),
                      scope: "col"
                    }, toDisplayString(unref(t2)("el.datepicker.weeks." + week)), 9, _hoisted_3$7);
                  }), 128))
                ]),
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(rows), (row, rowKey) => {
                  return openBlock(), createElementBlock("tr", {
                    key: rowKey,
                    class: normalizeClass(unref(getRowKls)(row[1]))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, columnKey) => {
                      return openBlock(), createElementBlock("td", {
                        key: `${rowKey}.${columnKey}`,
                        ref_for: true,
                        ref: (el) => unref(isSelectedCell)(cell) && (currentCellRef.value = el),
                        class: normalizeClass(unref(getCellClasses)(cell)),
                        "aria-current": cell.isCurrent ? "date" : void 0,
                        "aria-selected": cell.isCurrent,
                        tabindex: unref(isSelectedCell)(cell) ? 0 : -1,
                        onFocus: _cache[0] || (_cache[0] = (...args) => unref(handleFocus) && unref(handleFocus)(...args))
                      }, [
                        createVNode(unref(ElDatePickerCell), { cell }, null, 8, ["cell"])
                      ], 42, _hoisted_4$3);
                    }), 128))
                  ], 2);
                }), 128))
              ], 512)
            ], 42, _hoisted_1$c);
          };
        }
      });
      var DateTable = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__file", "basic-date-table.vue"]]);
      const basicMonthTableProps = buildProps({
        ...datePickerSharedProps,
        selectionMode: selectionModeWithDefault("month")
      });
      const _hoisted_1$b = ["aria-label"];
      const _hoisted_2$8 = ["aria-selected", "aria-label", "tabindex", "onKeydown"];
      const _hoisted_3$6 = { class: "cell" };
      const _sfc_main$e = /* @__PURE__ */ defineComponent({
        __name: "basic-month-table",
        props: basicMonthTableProps,
        emits: ["changerange", "pick", "select"],
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const datesInMonth = (year, month, lang2) => {
            const firstDay = dayjs().locale(lang2).startOf("month").month(month).year(year);
            const numOfDays = firstDay.daysInMonth();
            return rangeArr(numOfDays).map((n2) => firstDay.add(n2, "day").toDate());
          };
          const ns = useNamespace("month-table");
          const { t: t2, lang } = useLocale();
          const tbodyRef = ref();
          const currentCellRef = ref();
          const months = ref(props.date.locale("en").localeData().monthsShort().map((_2) => _2.toLowerCase()));
          const tableRows = ref([
            [],
            [],
            []
          ]);
          const lastRow = ref();
          const lastColumn = ref();
          const rows = computed(() => {
            var _a2, _b;
            const rows2 = tableRows.value;
            const now2 = dayjs().locale(lang.value).startOf("month");
            for (let i = 0; i < 3; i++) {
              const row = rows2[i];
              for (let j = 0; j < 4; j++) {
                const cell = row[j] || (row[j] = {
                  row: i,
                  column: j,
                  type: "normal",
                  inRange: false,
                  start: false,
                  end: false,
                  text: -1,
                  disabled: false
                });
                cell.type = "normal";
                const index = i * 4 + j;
                const calTime = props.date.startOf("year").month(index);
                const calEndDate = props.rangeState.endDate || props.maxDate || props.rangeState.selecting && props.minDate || null;
                cell.inRange = !!(props.minDate && calTime.isSameOrAfter(props.minDate, "month") && calEndDate && calTime.isSameOrBefore(calEndDate, "month")) || !!(props.minDate && calTime.isSameOrBefore(props.minDate, "month") && calEndDate && calTime.isSameOrAfter(calEndDate, "month"));
                if ((_a2 = props.minDate) == null ? void 0 : _a2.isSameOrAfter(calEndDate)) {
                  cell.start = !!(calEndDate && calTime.isSame(calEndDate, "month"));
                  cell.end = props.minDate && calTime.isSame(props.minDate, "month");
                } else {
                  cell.start = !!(props.minDate && calTime.isSame(props.minDate, "month"));
                  cell.end = !!(calEndDate && calTime.isSame(calEndDate, "month"));
                }
                const isToday = now2.isSame(calTime);
                if (isToday) {
                  cell.type = "today";
                }
                cell.text = index;
                cell.disabled = ((_b = props.disabledDate) == null ? void 0 : _b.call(props, calTime.toDate())) || false;
              }
            }
            return rows2;
          });
          const focus = () => {
            var _a2;
            (_a2 = currentCellRef.value) == null ? void 0 : _a2.focus();
          };
          const getCellStyle = (cell) => {
            const style2 = {};
            const year = props.date.year();
            const today = /* @__PURE__ */ new Date();
            const month = cell.text;
            style2.disabled = props.disabledDate ? datesInMonth(year, month, lang.value).every(props.disabledDate) : false;
            style2.current = castArray(props.parsedValue).findIndex((date2) => dayjs.isDayjs(date2) && date2.year() === year && date2.month() === month) >= 0;
            style2.today = today.getFullYear() === year && today.getMonth() === month;
            if (cell.inRange) {
              style2["in-range"] = true;
              if (cell.start) {
                style2["start-date"] = true;
              }
              if (cell.end) {
                style2["end-date"] = true;
              }
            }
            return style2;
          };
          const isSelectedCell = (cell) => {
            const year = props.date.year();
            const month = cell.text;
            return castArray(props.date).findIndex((date2) => date2.year() === year && date2.month() === month) >= 0;
          };
          const handleMouseMove = (event) => {
            var _a2;
            if (!props.rangeState.selecting)
              return;
            let target = event.target;
            if (target.tagName === "SPAN") {
              target = (_a2 = target.parentNode) == null ? void 0 : _a2.parentNode;
            }
            if (target.tagName === "DIV") {
              target = target.parentNode;
            }
            if (target.tagName !== "TD")
              return;
            const row = target.parentNode.rowIndex;
            const column = target.cellIndex;
            if (rows.value[row][column].disabled)
              return;
            if (row !== lastRow.value || column !== lastColumn.value) {
              lastRow.value = row;
              lastColumn.value = column;
              emit2("changerange", {
                selecting: true,
                endDate: props.date.startOf("year").month(row * 4 + column)
              });
            }
          };
          const handleMonthTableClick = (event) => {
            var _a2;
            const target = (_a2 = event.target) == null ? void 0 : _a2.closest("td");
            if ((target == null ? void 0 : target.tagName) !== "TD")
              return;
            if (hasClass(target, "disabled"))
              return;
            const column = target.cellIndex;
            const row = target.parentNode.rowIndex;
            const month = row * 4 + column;
            const newDate = props.date.startOf("year").month(month);
            if (props.selectionMode === "range") {
              if (!props.rangeState.selecting) {
                emit2("pick", { minDate: newDate, maxDate: null });
                emit2("select", true);
              } else {
                if (props.minDate && newDate >= props.minDate) {
                  emit2("pick", { minDate: props.minDate, maxDate: newDate });
                } else {
                  emit2("pick", { minDate: newDate, maxDate: props.minDate });
                }
                emit2("select", false);
              }
            } else {
              emit2("pick", month);
            }
          };
          watch(() => props.date, async () => {
            var _a2, _b;
            if ((_a2 = tbodyRef.value) == null ? void 0 : _a2.contains(document.activeElement)) {
              await nextTick();
              (_b = currentCellRef.value) == null ? void 0 : _b.focus();
            }
          });
          expose({
            focus
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("table", {
              role: "grid",
              "aria-label": unref(t2)("el.datepicker.monthTablePrompt"),
              class: normalizeClass(unref(ns).b()),
              onClick: handleMonthTableClick,
              onMousemove: handleMouseMove
            }, [
              createBaseVNode("tbody", {
                ref_key: "tbodyRef",
                ref: tbodyRef
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(rows), (row, key) => {
                  return openBlock(), createElementBlock("tr", { key }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, key_) => {
                      return openBlock(), createElementBlock("td", {
                        key: key_,
                        ref_for: true,
                        ref: (el) => isSelectedCell(cell) && (currentCellRef.value = el),
                        class: normalizeClass(getCellStyle(cell)),
                        "aria-selected": `${isSelectedCell(cell)}`,
                        "aria-label": unref(t2)(`el.datepicker.month${+cell.text + 1}`),
                        tabindex: isSelectedCell(cell) ? 0 : -1,
                        onKeydown: [
                          withKeys(withModifiers(handleMonthTableClick, ["prevent", "stop"]), ["space"]),
                          withKeys(withModifiers(handleMonthTableClick, ["prevent", "stop"]), ["enter"])
                        ]
                      }, [
                        createBaseVNode("div", null, [
                          createBaseVNode("span", _hoisted_3$6, toDisplayString(unref(t2)("el.datepicker.months." + months.value[cell.text])), 1)
                        ])
                      ], 42, _hoisted_2$8);
                    }), 128))
                  ]);
                }), 128))
              ], 512)
            ], 42, _hoisted_1$b);
          };
        }
      });
      var MonthTable = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__file", "basic-month-table.vue"]]);
      const { date, disabledDate, parsedValue } = datePickerSharedProps;
      const basicYearTableProps = buildProps({
        date,
        disabledDate,
        parsedValue
      });
      const _hoisted_1$a = ["aria-label"];
      const _hoisted_2$7 = ["aria-selected", "tabindex", "onKeydown"];
      const _hoisted_3$5 = { class: "cell" };
      const _hoisted_4$2 = { key: 1 };
      const _sfc_main$d = /* @__PURE__ */ defineComponent({
        __name: "basic-year-table",
        props: basicYearTableProps,
        emits: ["pick"],
        setup(__props, { expose, emit: emit2 }) {
          const props = __props;
          const datesInYear = (year, lang2) => {
            const firstDay = dayjs(String(year)).locale(lang2).startOf("year");
            const lastDay = firstDay.endOf("year");
            const numOfDays = lastDay.dayOfYear();
            return rangeArr(numOfDays).map((n2) => firstDay.add(n2, "day").toDate());
          };
          const ns = useNamespace("year-table");
          const { t: t2, lang } = useLocale();
          const tbodyRef = ref();
          const currentCellRef = ref();
          const startYear = computed(() => {
            return Math.floor(props.date.year() / 10) * 10;
          });
          const focus = () => {
            var _a2;
            (_a2 = currentCellRef.value) == null ? void 0 : _a2.focus();
          };
          const getCellKls = (year) => {
            const kls = {};
            const today = dayjs().locale(lang.value);
            kls.disabled = props.disabledDate ? datesInYear(year, lang.value).every(props.disabledDate) : false;
            kls.current = castArray(props.parsedValue).findIndex((d) => d.year() === year) >= 0;
            kls.today = today.year() === year;
            return kls;
          };
          const isSelectedCell = (year) => {
            return year === startYear.value && props.date.year() < startYear.value && props.date.year() > startYear.value + 9 || castArray(props.date).findIndex((date2) => date2.year() === year) >= 0;
          };
          const handleYearTableClick = (event) => {
            const clickTarget = event.target;
            const target = clickTarget.closest("td");
            if (target && target.textContent) {
              if (hasClass(target, "disabled"))
                return;
              const year = target.textContent || target.innerText;
              emit2("pick", Number(year));
            }
          };
          watch(() => props.date, async () => {
            var _a2, _b;
            if ((_a2 = tbodyRef.value) == null ? void 0 : _a2.contains(document.activeElement)) {
              await nextTick();
              (_b = currentCellRef.value) == null ? void 0 : _b.focus();
            }
          });
          expose({
            focus
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("table", {
              role: "grid",
              "aria-label": unref(t2)("el.datepicker.yearTablePrompt"),
              class: normalizeClass(unref(ns).b()),
              onClick: handleYearTableClick
            }, [
              createBaseVNode("tbody", {
                ref_key: "tbodyRef",
                ref: tbodyRef
              }, [
                (openBlock(), createElementBlock(Fragment, null, renderList(3, (_2, i) => {
                  return createBaseVNode("tr", { key: i }, [
                    (openBlock(), createElementBlock(Fragment, null, renderList(4, (__, j) => {
                      return openBlock(), createElementBlock(Fragment, {
                        key: i + "_" + j
                      }, [
                        i * 4 + j < 10 ? (openBlock(), createElementBlock("td", {
                          key: 0,
                          ref_for: true,
                          ref: (el) => isSelectedCell(unref(startYear) + i * 4 + j) && (currentCellRef.value = el),
                          class: normalizeClass(["available", getCellKls(unref(startYear) + i * 4 + j)]),
                          "aria-selected": `${isSelectedCell(unref(startYear) + i * 4 + j)}`,
                          tabindex: isSelectedCell(unref(startYear) + i * 4 + j) ? 0 : -1,
                          onKeydown: [
                            withKeys(withModifiers(handleYearTableClick, ["prevent", "stop"]), ["space"]),
                            withKeys(withModifiers(handleYearTableClick, ["prevent", "stop"]), ["enter"])
                          ]
                        }, [
                          createBaseVNode("span", _hoisted_3$5, toDisplayString(unref(startYear) + i * 4 + j), 1)
                        ], 42, _hoisted_2$7)) : (openBlock(), createElementBlock("td", _hoisted_4$2))
                      ], 64);
                    }), 64))
                  ]);
                }), 64))
              ], 512)
            ], 10, _hoisted_1$a);
          };
        }
      });
      var YearTable = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__file", "basic-year-table.vue"]]);
      const _hoisted_1$9 = ["onClick"];
      const _hoisted_2$6 = ["aria-label"];
      const _hoisted_3$4 = ["aria-label"];
      const _hoisted_4$1 = ["aria-label"];
      const _hoisted_5$1 = ["aria-label"];
      const _sfc_main$c = /* @__PURE__ */ defineComponent({
        __name: "panel-date-pick",
        props: panelDatePickProps,
        emits: ["pick", "set-picker-option", "panel-change"],
        setup(__props, { emit: contextEmit }) {
          const props = __props;
          const timeWithinRange = (_2, __, ___) => true;
          const ppNs = useNamespace("picker-panel");
          const dpNs = useNamespace("date-picker");
          const attrs = useAttrs$1();
          const slots = useSlots();
          const { t: t2, lang } = useLocale();
          const pickerBase = inject("EP_PICKER_BASE");
          const popper = inject(TOOLTIP_INJECTION_KEY);
          const { shortcuts, disabledDate: disabledDate2, cellClassName, defaultTime } = pickerBase.props;
          const defaultValue = toRef(pickerBase.props, "defaultValue");
          const currentViewRef = ref();
          const innerDate = ref(dayjs().locale(lang.value));
          const isChangeToNow = ref(false);
          let isShortcut = false;
          const defaultTimeD = computed(() => {
            return dayjs(defaultTime).locale(lang.value);
          });
          const month = computed(() => {
            return innerDate.value.month();
          });
          const year = computed(() => {
            return innerDate.value.year();
          });
          const selectableRange = ref([]);
          const userInputDate = ref(null);
          const userInputTime = ref(null);
          const checkDateWithinRange = (date2) => {
            return selectableRange.value.length > 0 ? timeWithinRange(date2, selectableRange.value, props.format || "HH:mm:ss") : true;
          };
          const formatEmit = (emitDayjs) => {
            if (defaultTime && !visibleTime.value && !isChangeToNow.value && !isShortcut) {
              return defaultTimeD.value.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
            }
            if (showTime.value)
              return emitDayjs.millisecond(0);
            return emitDayjs.startOf("day");
          };
          const emit2 = (value, ...args) => {
            if (!value) {
              contextEmit("pick", value, ...args);
            } else if (isArray$2(value)) {
              const dates = value.map(formatEmit);
              contextEmit("pick", dates, ...args);
            } else {
              contextEmit("pick", formatEmit(value), ...args);
            }
            userInputDate.value = null;
            userInputTime.value = null;
            isChangeToNow.value = false;
            isShortcut = false;
          };
          const handleDatePick = async (value, keepOpen) => {
            if (selectionMode.value === "date") {
              value = value;
              let newDate = props.parsedValue ? props.parsedValue.year(value.year()).month(value.month()).date(value.date()) : value;
              if (!checkDateWithinRange(newDate)) {
                newDate = selectableRange.value[0][0].year(value.year()).month(value.month()).date(value.date());
              }
              innerDate.value = newDate;
              emit2(newDate, showTime.value || keepOpen);
              if (props.type === "datetime") {
                await nextTick();
                handleFocusPicker();
              }
            } else if (selectionMode.value === "week") {
              emit2(value.date);
            } else if (selectionMode.value === "dates") {
              emit2(value, true);
            }
          };
          const moveByMonth = (forward) => {
            const action = forward ? "add" : "subtract";
            innerDate.value = innerDate.value[action](1, "month");
            handlePanelChange("month");
          };
          const moveByYear = (forward) => {
            const currentDate = innerDate.value;
            const action = forward ? "add" : "subtract";
            innerDate.value = currentView.value === "year" ? currentDate[action](10, "year") : currentDate[action](1, "year");
            handlePanelChange("year");
          };
          const currentView = ref("date");
          const yearLabel = computed(() => {
            const yearTranslation = t2("el.datepicker.year");
            if (currentView.value === "year") {
              const startYear = Math.floor(year.value / 10) * 10;
              if (yearTranslation) {
                return `${startYear} ${yearTranslation} - ${startYear + 9} ${yearTranslation}`;
              }
              return `${startYear} - ${startYear + 9}`;
            }
            return `${year.value} ${yearTranslation}`;
          });
          const handleShortcutClick = (shortcut) => {
            const shortcutValue = isFunction$1(shortcut.value) ? shortcut.value() : shortcut.value;
            if (shortcutValue) {
              isShortcut = true;
              emit2(dayjs(shortcutValue).locale(lang.value));
              return;
            }
            if (shortcut.onClick) {
              shortcut.onClick({
                attrs,
                slots,
                emit: contextEmit
              });
            }
          };
          const selectionMode = computed(() => {
            const { type } = props;
            if (["week", "month", "year", "dates"].includes(type))
              return type;
            return "date";
          });
          const keyboardMode = computed(() => {
            return selectionMode.value === "date" ? currentView.value : selectionMode.value;
          });
          const hasShortcuts = computed(() => !!shortcuts.length);
          const handleMonthPick = async (month2) => {
            innerDate.value = innerDate.value.startOf("month").month(month2);
            if (selectionMode.value === "month") {
              emit2(innerDate.value, false);
            } else {
              currentView.value = "date";
              if (["month", "year", "date", "week"].includes(selectionMode.value)) {
                emit2(innerDate.value, true);
                await nextTick();
                handleFocusPicker();
              }
            }
            handlePanelChange("month");
          };
          const handleYearPick = async (year2) => {
            if (selectionMode.value === "year") {
              innerDate.value = innerDate.value.startOf("year").year(year2);
              emit2(innerDate.value, false);
            } else {
              innerDate.value = innerDate.value.year(year2);
              currentView.value = "month";
              if (["month", "year", "date", "week"].includes(selectionMode.value)) {
                emit2(innerDate.value, true);
                await nextTick();
                handleFocusPicker();
              }
            }
            handlePanelChange("year");
          };
          const showPicker = async (view) => {
            currentView.value = view;
            await nextTick();
            handleFocusPicker();
          };
          const showTime = computed(() => props.type === "datetime" || props.type === "datetimerange");
          const footerVisible = computed(() => {
            return showTime.value || selectionMode.value === "dates";
          });
          const disabledConfirm = computed(() => {
            if (!disabledDate2)
              return false;
            if (!props.parsedValue)
              return true;
            if (isArray$2(props.parsedValue)) {
              return disabledDate2(props.parsedValue[0].toDate());
            }
            return disabledDate2(props.parsedValue.toDate());
          });
          const onConfirm = () => {
            if (selectionMode.value === "dates") {
              emit2(props.parsedValue);
            } else {
              let result = props.parsedValue;
              if (!result) {
                const defaultTimeD2 = dayjs(defaultTime).locale(lang.value);
                const defaultValueD = getDefaultValue2();
                result = defaultTimeD2.year(defaultValueD.year()).month(defaultValueD.month()).date(defaultValueD.date());
              }
              innerDate.value = result;
              emit2(result);
            }
          };
          const disabledNow = computed(() => {
            if (!disabledDate2)
              return false;
            return disabledDate2(dayjs().locale(lang.value).toDate());
          });
          const changeToNow = () => {
            const now2 = dayjs().locale(lang.value);
            const nowDate = now2.toDate();
            isChangeToNow.value = true;
            if ((!disabledDate2 || !disabledDate2(nowDate)) && checkDateWithinRange(nowDate)) {
              innerDate.value = dayjs().locale(lang.value);
              emit2(innerDate.value);
            }
          };
          const timeFormat = computed(() => {
            return props.timeFormat || extractTimeFormat(props.format);
          });
          const dateFormat = computed(() => {
            return props.dateFormat || extractDateFormat(props.format);
          });
          const visibleTime = computed(() => {
            if (userInputTime.value)
              return userInputTime.value;
            if (!props.parsedValue && !defaultValue.value)
              return;
            return (props.parsedValue || innerDate.value).format(timeFormat.value);
          });
          const visibleDate = computed(() => {
            if (userInputDate.value)
              return userInputDate.value;
            if (!props.parsedValue && !defaultValue.value)
              return;
            return (props.parsedValue || innerDate.value).format(dateFormat.value);
          });
          const timePickerVisible = ref(false);
          const onTimePickerInputFocus = () => {
            timePickerVisible.value = true;
          };
          const handleTimePickClose = () => {
            timePickerVisible.value = false;
          };
          const getUnits = (date2) => {
            return {
              hour: date2.hour(),
              minute: date2.minute(),
              second: date2.second(),
              year: date2.year(),
              month: date2.month(),
              date: date2.date()
            };
          };
          const handleTimePick = (value, visible, first) => {
            const { hour, minute, second } = getUnits(value);
            const newDate = props.parsedValue ? props.parsedValue.hour(hour).minute(minute).second(second) : value;
            innerDate.value = newDate;
            emit2(innerDate.value, true);
            if (!first) {
              timePickerVisible.value = visible;
            }
          };
          const handleVisibleTimeChange = (value) => {
            const newDate = dayjs(value, timeFormat.value).locale(lang.value);
            if (newDate.isValid() && checkDateWithinRange(newDate)) {
              const { year: year2, month: month2, date: date2 } = getUnits(innerDate.value);
              innerDate.value = newDate.year(year2).month(month2).date(date2);
              userInputTime.value = null;
              timePickerVisible.value = false;
              emit2(innerDate.value, true);
            }
          };
          const handleVisibleDateChange = (value) => {
            const newDate = dayjs(value, dateFormat.value).locale(lang.value);
            if (newDate.isValid()) {
              if (disabledDate2 && disabledDate2(newDate.toDate())) {
                return;
              }
              const { hour, minute, second } = getUnits(innerDate.value);
              innerDate.value = newDate.hour(hour).minute(minute).second(second);
              userInputDate.value = null;
              emit2(innerDate.value, true);
            }
          };
          const isValidValue = (date2) => {
            return dayjs.isDayjs(date2) && date2.isValid() && (disabledDate2 ? !disabledDate2(date2.toDate()) : true);
          };
          const formatToString = (value) => {
            if (selectionMode.value === "dates") {
              return value.map((_2) => _2.format(props.format));
            }
            return value.format(props.format);
          };
          const parseUserInput = (value) => {
            return dayjs(value, props.format).locale(lang.value);
          };
          const getDefaultValue2 = () => {
            const parseDate2 = dayjs(defaultValue.value).locale(lang.value);
            if (!defaultValue.value) {
              const defaultTimeDValue = defaultTimeD.value;
              return dayjs().hour(defaultTimeDValue.hour()).minute(defaultTimeDValue.minute()).second(defaultTimeDValue.second()).locale(lang.value);
            }
            return parseDate2;
          };
          const handleFocusPicker = async () => {
            var _a2;
            if (["week", "month", "year", "date"].includes(selectionMode.value)) {
              (_a2 = currentViewRef.value) == null ? void 0 : _a2.focus();
              if (selectionMode.value === "week") {
                handleKeyControl(EVENT_CODE.down);
              }
            }
          };
          const handleKeydownTable = (event) => {
            const { code } = event;
            const validCode = [
              EVENT_CODE.up,
              EVENT_CODE.down,
              EVENT_CODE.left,
              EVENT_CODE.right,
              EVENT_CODE.home,
              EVENT_CODE.end,
              EVENT_CODE.pageUp,
              EVENT_CODE.pageDown
            ];
            if (validCode.includes(code)) {
              handleKeyControl(code);
              event.stopPropagation();
              event.preventDefault();
            }
            if ([EVENT_CODE.enter, EVENT_CODE.space, EVENT_CODE.numpadEnter].includes(code) && userInputDate.value === null && userInputTime.value === null) {
              event.preventDefault();
              emit2(innerDate.value, false);
            }
          };
          const handleKeyControl = (code) => {
            var _a2;
            const { up, down, left, right, home, end, pageUp, pageDown } = EVENT_CODE;
            const mapping = {
              year: {
                [up]: -4,
                [down]: 4,
                [left]: -1,
                [right]: 1,
                offset: (date2, step) => date2.setFullYear(date2.getFullYear() + step)
              },
              month: {
                [up]: -4,
                [down]: 4,
                [left]: -1,
                [right]: 1,
                offset: (date2, step) => date2.setMonth(date2.getMonth() + step)
              },
              week: {
                [up]: -1,
                [down]: 1,
                [left]: -1,
                [right]: 1,
                offset: (date2, step) => date2.setDate(date2.getDate() + step * 7)
              },
              date: {
                [up]: -7,
                [down]: 7,
                [left]: -1,
                [right]: 1,
                [home]: (date2) => -date2.getDay(),
                [end]: (date2) => -date2.getDay() + 6,
                [pageUp]: (date2) => -new Date(date2.getFullYear(), date2.getMonth(), 0).getDate(),
                [pageDown]: (date2) => new Date(date2.getFullYear(), date2.getMonth() + 1, 0).getDate(),
                offset: (date2, step) => date2.setDate(date2.getDate() + step)
              }
            };
            const newDate = innerDate.value.toDate();
            while (Math.abs(innerDate.value.diff(newDate, "year", true)) < 1) {
              const map = mapping[keyboardMode.value];
              if (!map)
                return;
              map.offset(newDate, isFunction$1(map[code]) ? map[code](newDate) : (_a2 = map[code]) != null ? _a2 : 0);
              if (disabledDate2 && disabledDate2(newDate)) {
                break;
              }
              const result = dayjs(newDate).locale(lang.value);
              innerDate.value = result;
              contextEmit("pick", result, true);
              break;
            }
          };
          const handlePanelChange = (mode) => {
            contextEmit("panel-change", innerDate.value.toDate(), mode, currentView.value);
          };
          watch(() => selectionMode.value, (val) => {
            if (["month", "year"].includes(val)) {
              currentView.value = val;
              return;
            }
            currentView.value = "date";
          }, { immediate: true });
          watch(() => currentView.value, () => {
            popper == null ? void 0 : popper.updatePopper();
          });
          watch(() => defaultValue.value, (val) => {
            if (val) {
              innerDate.value = getDefaultValue2();
            }
          }, { immediate: true });
          watch(() => props.parsedValue, (val) => {
            if (val) {
              if (selectionMode.value === "dates")
                return;
              if (Array.isArray(val))
                return;
              innerDate.value = val;
            } else {
              innerDate.value = getDefaultValue2();
            }
          }, { immediate: true });
          contextEmit("set-picker-option", ["isValidValue", isValidValue]);
          contextEmit("set-picker-option", ["formatToString", formatToString]);
          contextEmit("set-picker-option", ["parseUserInput", parseUserInput]);
          contextEmit("set-picker-option", ["handleFocusPicker", handleFocusPicker]);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ppNs).b(),
                unref(dpNs).b(),
                {
                  "has-sidebar": _ctx.$slots.sidebar || unref(hasShortcuts),
                  "has-time": unref(showTime)
                }
              ])
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(ppNs).e("body-wrapper"))
              }, [
                renderSlot(_ctx.$slots, "sidebar", {
                  class: normalizeClass(unref(ppNs).e("sidebar"))
                }),
                unref(hasShortcuts) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ppNs).e("sidebar"))
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(shortcuts), (shortcut, key) => {
                    return openBlock(), createElementBlock("button", {
                      key,
                      type: "button",
                      class: normalizeClass(unref(ppNs).e("shortcut")),
                      onClick: ($event) => handleShortcutClick(shortcut)
                    }, toDisplayString(shortcut.text), 11, _hoisted_1$9);
                  }), 128))
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  class: normalizeClass(unref(ppNs).e("body"))
                }, [
                  unref(showTime) ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(unref(dpNs).e("time-header"))
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(dpNs).e("editor-wrap"))
                    }, [
                      createVNode(unref(ElInput), {
                        placeholder: unref(t2)("el.datepicker.selectDate"),
                        "model-value": unref(visibleDate),
                        size: "small",
                        "validate-event": false,
                        onInput: _cache[0] || (_cache[0] = (val) => userInputDate.value = val),
                        onChange: handleVisibleDateChange
                      }, null, 8, ["placeholder", "model-value"])
                    ], 2),
                    withDirectives((openBlock(), createElementBlock("span", {
                      class: normalizeClass(unref(dpNs).e("editor-wrap"))
                    }, [
                      createVNode(unref(ElInput), {
                        placeholder: unref(t2)("el.datepicker.selectTime"),
                        "model-value": unref(visibleTime),
                        size: "small",
                        "validate-event": false,
                        onFocus: onTimePickerInputFocus,
                        onInput: _cache[1] || (_cache[1] = (val) => userInputTime.value = val),
                        onChange: handleVisibleTimeChange
                      }, null, 8, ["placeholder", "model-value"]),
                      createVNode(unref(TimePickPanel), {
                        visible: timePickerVisible.value,
                        format: unref(timeFormat),
                        "parsed-value": innerDate.value,
                        onPick: handleTimePick
                      }, null, 8, ["visible", "format", "parsed-value"])
                    ], 2)), [
                      [unref(ClickOutside), handleTimePickClose]
                    ])
                  ], 2)) : createCommentVNode("v-if", true),
                  withDirectives(createBaseVNode("div", {
                    class: normalizeClass([
                      unref(dpNs).e("header"),
                      (currentView.value === "year" || currentView.value === "month") && unref(dpNs).e("header--bordered")
                    ])
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(dpNs).e("prev-btn"))
                    }, [
                      createBaseVNode("button", {
                        type: "button",
                        "aria-label": unref(t2)(`el.datepicker.prevYear`),
                        class: normalizeClass(["d-arrow-left", unref(ppNs).e("icon-btn")]),
                        onClick: _cache[2] || (_cache[2] = ($event) => moveByYear(false))
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(d_arrow_left_default))
                          ]),
                          _: 1
                        })
                      ], 10, _hoisted_2$6),
                      withDirectives(createBaseVNode("button", {
                        type: "button",
                        "aria-label": unref(t2)(`el.datepicker.prevMonth`),
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "arrow-left"]),
                        onClick: _cache[3] || (_cache[3] = ($event) => moveByMonth(false))
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(arrow_left_default))
                          ]),
                          _: 1
                        })
                      ], 10, _hoisted_3$4), [
                        [vShow, currentView.value === "date"]
                      ])
                    ], 2),
                    createBaseVNode("span", {
                      role: "button",
                      class: normalizeClass(unref(dpNs).e("header-label")),
                      "aria-live": "polite",
                      tabindex: "0",
                      onKeydown: _cache[4] || (_cache[4] = withKeys(($event) => showPicker("year"), ["enter"])),
                      onClick: _cache[5] || (_cache[5] = ($event) => showPicker("year"))
                    }, toDisplayString(unref(yearLabel)), 35),
                    withDirectives(createBaseVNode("span", {
                      role: "button",
                      "aria-live": "polite",
                      tabindex: "0",
                      class: normalizeClass([
                        unref(dpNs).e("header-label"),
                        { active: currentView.value === "month" }
                      ]),
                      onKeydown: _cache[6] || (_cache[6] = withKeys(($event) => showPicker("month"), ["enter"])),
                      onClick: _cache[7] || (_cache[7] = ($event) => showPicker("month"))
                    }, toDisplayString(unref(t2)(`el.datepicker.month${unref(month) + 1}`)), 35), [
                      [vShow, currentView.value === "date"]
                    ]),
                    createBaseVNode("span", {
                      class: normalizeClass(unref(dpNs).e("next-btn"))
                    }, [
                      withDirectives(createBaseVNode("button", {
                        type: "button",
                        "aria-label": unref(t2)(`el.datepicker.nextMonth`),
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "arrow-right"]),
                        onClick: _cache[8] || (_cache[8] = ($event) => moveByMonth(true))
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(arrow_right_default))
                          ]),
                          _: 1
                        })
                      ], 10, _hoisted_4$1), [
                        [vShow, currentView.value === "date"]
                      ]),
                      createBaseVNode("button", {
                        type: "button",
                        "aria-label": unref(t2)(`el.datepicker.nextYear`),
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-right"]),
                        onClick: _cache[9] || (_cache[9] = ($event) => moveByYear(true))
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(d_arrow_right_default))
                          ]),
                          _: 1
                        })
                      ], 10, _hoisted_5$1)
                    ], 2)
                  ], 2), [
                    [vShow, currentView.value !== "time"]
                  ]),
                  createBaseVNode("div", {
                    class: normalizeClass(unref(ppNs).e("content")),
                    onKeydown: handleKeydownTable
                  }, [
                    currentView.value === "date" ? (openBlock(), createBlock(DateTable, {
                      key: 0,
                      ref_key: "currentViewRef",
                      ref: currentViewRef,
                      "selection-mode": unref(selectionMode),
                      date: innerDate.value,
                      "parsed-value": _ctx.parsedValue,
                      "disabled-date": unref(disabledDate2),
                      "cell-class-name": unref(cellClassName),
                      onPick: handleDatePick
                    }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "cell-class-name"])) : createCommentVNode("v-if", true),
                    currentView.value === "year" ? (openBlock(), createBlock(YearTable, {
                      key: 1,
                      ref_key: "currentViewRef",
                      ref: currentViewRef,
                      date: innerDate.value,
                      "disabled-date": unref(disabledDate2),
                      "parsed-value": _ctx.parsedValue,
                      onPick: handleYearPick
                    }, null, 8, ["date", "disabled-date", "parsed-value"])) : createCommentVNode("v-if", true),
                    currentView.value === "month" ? (openBlock(), createBlock(MonthTable, {
                      key: 2,
                      ref_key: "currentViewRef",
                      ref: currentViewRef,
                      date: innerDate.value,
                      "parsed-value": _ctx.parsedValue,
                      "disabled-date": unref(disabledDate2),
                      onPick: handleMonthPick
                    }, null, 8, ["date", "parsed-value", "disabled-date"])) : createCommentVNode("v-if", true)
                  ], 34)
                ], 2)
              ], 2),
              withDirectives(createBaseVNode("div", {
                class: normalizeClass(unref(ppNs).e("footer"))
              }, [
                withDirectives(createVNode(unref(ElButton), {
                  text: "",
                  size: "small",
                  class: normalizeClass(unref(ppNs).e("link-btn")),
                  disabled: unref(disabledNow),
                  onClick: changeToNow
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref(t2)("el.datepicker.now")), 1)
                  ]),
                  _: 1
                }, 8, ["class", "disabled"]), [
                  [vShow, unref(selectionMode) !== "dates"]
                ]),
                createVNode(unref(ElButton), {
                  plain: "",
                  size: "small",
                  class: normalizeClass(unref(ppNs).e("link-btn")),
                  disabled: unref(disabledConfirm),
                  onClick: onConfirm
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref(t2)("el.datepicker.confirm")), 1)
                  ]),
                  _: 1
                }, 8, ["class", "disabled"])
              ], 2), [
                [vShow, unref(footerVisible) && currentView.value === "date"]
              ])
            ], 2);
          };
        }
      });
      var DatePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__file", "panel-date-pick.vue"]]);
      const panelDateRangeProps = buildProps({
        ...panelSharedProps,
        ...panelRangeSharedProps
      });
      const useShortcut = (lang) => {
        const { emit: emit2 } = getCurrentInstance();
        const attrs = useAttrs$1();
        const slots = useSlots();
        const handleShortcutClick = (shortcut) => {
          const shortcutValues = isFunction$1(shortcut.value) ? shortcut.value() : shortcut.value;
          if (shortcutValues) {
            emit2("pick", [
              dayjs(shortcutValues[0]).locale(lang.value),
              dayjs(shortcutValues[1]).locale(lang.value)
            ]);
            return;
          }
          if (shortcut.onClick) {
            shortcut.onClick({
              attrs,
              slots,
              emit: emit2
            });
          }
        };
        return handleShortcutClick;
      };
      const useRangePicker = (props, {
        defaultValue,
        leftDate,
        rightDate,
        unit: unit2,
        onParsedValueChanged
      }) => {
        const { emit: emit2 } = getCurrentInstance();
        const { pickerNs } = inject(ROOT_PICKER_INJECTION_KEY);
        const drpNs = useNamespace("date-range-picker");
        const { t: t2, lang } = useLocale();
        const handleShortcutClick = useShortcut(lang);
        const minDate = ref();
        const maxDate = ref();
        const rangeState = ref({
          endDate: null,
          selecting: false
        });
        const handleChangeRange = (val) => {
          rangeState.value = val;
        };
        const handleRangeConfirm = (visible = false) => {
          const _minDate = unref(minDate);
          const _maxDate = unref(maxDate);
          if (isValidRange([_minDate, _maxDate])) {
            emit2("pick", [_minDate, _maxDate], visible);
          }
        };
        const onSelect = (selecting) => {
          rangeState.value.selecting = selecting;
          if (!selecting) {
            rangeState.value.endDate = null;
          }
        };
        const restoreDefault = () => {
          const [start, end] = getDefaultValue(unref(defaultValue), {
            lang: unref(lang),
            unit: unit2,
            unlinkPanels: props.unlinkPanels
          });
          minDate.value = void 0;
          maxDate.value = void 0;
          leftDate.value = start;
          rightDate.value = end;
        };
        watch(defaultValue, (val) => {
          if (val) {
            restoreDefault();
          }
        }, { immediate: true });
        watch(() => props.parsedValue, (parsedValue2) => {
          if (isArray$2(parsedValue2) && parsedValue2.length === 2) {
            const [start, end] = parsedValue2;
            minDate.value = start;
            leftDate.value = start;
            maxDate.value = end;
            onParsedValueChanged(unref(minDate), unref(maxDate));
          } else {
            restoreDefault();
          }
        }, { immediate: true });
        return {
          minDate,
          maxDate,
          rangeState,
          lang,
          ppNs: pickerNs,
          drpNs,
          handleChangeRange,
          handleRangeConfirm,
          handleShortcutClick,
          onSelect,
          t: t2
        };
      };
      const _hoisted_1$8 = ["onClick"];
      const _hoisted_2$5 = ["aria-label"];
      const _hoisted_3$3 = ["aria-label"];
      const _hoisted_4 = ["disabled", "aria-label"];
      const _hoisted_5 = ["disabled", "aria-label"];
      const _hoisted_6 = ["disabled", "aria-label"];
      const _hoisted_7 = ["disabled", "aria-label"];
      const _hoisted_8 = ["aria-label"];
      const _hoisted_9 = ["aria-label"];
      const unit$1 = "month";
      const _sfc_main$b = /* @__PURE__ */ defineComponent({
        __name: "panel-date-range",
        props: panelDateRangeProps,
        emits: [
          "pick",
          "set-picker-option",
          "calendar-change",
          "panel-change"
        ],
        setup(__props, { emit: emit2 }) {
          const props = __props;
          const pickerBase = inject("EP_PICKER_BASE");
          const { disabledDate: disabledDate2, cellClassName, format, defaultTime, clearable } = pickerBase.props;
          const shortcuts = toRef(pickerBase.props, "shortcuts");
          const defaultValue = toRef(pickerBase.props, "defaultValue");
          const { lang } = useLocale();
          const leftDate = ref(dayjs().locale(lang.value));
          const rightDate = ref(dayjs().locale(lang.value).add(1, unit$1));
          const {
            minDate,
            maxDate,
            rangeState,
            ppNs,
            drpNs,
            handleChangeRange,
            handleRangeConfirm,
            handleShortcutClick,
            onSelect,
            t: t2
          } = useRangePicker(props, {
            defaultValue,
            leftDate,
            rightDate,
            unit: unit$1,
            onParsedValueChanged
          });
          const dateUserInput = ref({
            min: null,
            max: null
          });
          const timeUserInput = ref({
            min: null,
            max: null
          });
          const leftLabel = computed(() => {
            return `${leftDate.value.year()} ${t2("el.datepicker.year")} ${t2(`el.datepicker.month${leftDate.value.month() + 1}`)}`;
          });
          const rightLabel = computed(() => {
            return `${rightDate.value.year()} ${t2("el.datepicker.year")} ${t2(`el.datepicker.month${rightDate.value.month() + 1}`)}`;
          });
          const leftYear = computed(() => {
            return leftDate.value.year();
          });
          const leftMonth = computed(() => {
            return leftDate.value.month();
          });
          const rightYear = computed(() => {
            return rightDate.value.year();
          });
          const rightMonth = computed(() => {
            return rightDate.value.month();
          });
          const hasShortcuts = computed(() => !!shortcuts.value.length);
          const minVisibleDate = computed(() => {
            if (dateUserInput.value.min !== null)
              return dateUserInput.value.min;
            if (minDate.value)
              return minDate.value.format(dateFormat.value);
            return "";
          });
          const maxVisibleDate = computed(() => {
            if (dateUserInput.value.max !== null)
              return dateUserInput.value.max;
            if (maxDate.value || minDate.value)
              return (maxDate.value || minDate.value).format(dateFormat.value);
            return "";
          });
          const minVisibleTime = computed(() => {
            if (timeUserInput.value.min !== null)
              return timeUserInput.value.min;
            if (minDate.value)
              return minDate.value.format(timeFormat.value);
            return "";
          });
          const maxVisibleTime = computed(() => {
            if (timeUserInput.value.max !== null)
              return timeUserInput.value.max;
            if (maxDate.value || minDate.value)
              return (maxDate.value || minDate.value).format(timeFormat.value);
            return "";
          });
          const timeFormat = computed(() => {
            return props.timeFormat || extractTimeFormat(format);
          });
          const dateFormat = computed(() => {
            return props.dateFormat || extractDateFormat(format);
          });
          const isValidValue = (date2) => {
            return isValidRange(date2) && (disabledDate2 ? !disabledDate2(date2[0].toDate()) && !disabledDate2(date2[1].toDate()) : true);
          };
          const leftPrevYear = () => {
            leftDate.value = leftDate.value.subtract(1, "year");
            if (!props.unlinkPanels) {
              rightDate.value = leftDate.value.add(1, "month");
            }
            handlePanelChange("year");
          };
          const leftPrevMonth = () => {
            leftDate.value = leftDate.value.subtract(1, "month");
            if (!props.unlinkPanels) {
              rightDate.value = leftDate.value.add(1, "month");
            }
            handlePanelChange("month");
          };
          const rightNextYear = () => {
            if (!props.unlinkPanels) {
              leftDate.value = leftDate.value.add(1, "year");
              rightDate.value = leftDate.value.add(1, "month");
            } else {
              rightDate.value = rightDate.value.add(1, "year");
            }
            handlePanelChange("year");
          };
          const rightNextMonth = () => {
            if (!props.unlinkPanels) {
              leftDate.value = leftDate.value.add(1, "month");
              rightDate.value = leftDate.value.add(1, "month");
            } else {
              rightDate.value = rightDate.value.add(1, "month");
            }
            handlePanelChange("month");
          };
          const leftNextYear = () => {
            leftDate.value = leftDate.value.add(1, "year");
            handlePanelChange("year");
          };
          const leftNextMonth = () => {
            leftDate.value = leftDate.value.add(1, "month");
            handlePanelChange("month");
          };
          const rightPrevYear = () => {
            rightDate.value = rightDate.value.subtract(1, "year");
            handlePanelChange("year");
          };
          const rightPrevMonth = () => {
            rightDate.value = rightDate.value.subtract(1, "month");
            handlePanelChange("month");
          };
          const handlePanelChange = (mode) => {
            emit2("panel-change", [leftDate.value.toDate(), rightDate.value.toDate()], mode);
          };
          const enableMonthArrow = computed(() => {
            const nextMonth = (leftMonth.value + 1) % 12;
            const yearOffset = leftMonth.value + 1 >= 12 ? 1 : 0;
            return props.unlinkPanels && new Date(leftYear.value + yearOffset, nextMonth) < new Date(rightYear.value, rightMonth.value);
          });
          const enableYearArrow = computed(() => {
            return props.unlinkPanels && rightYear.value * 12 + rightMonth.value - (leftYear.value * 12 + leftMonth.value + 1) >= 12;
          });
          const btnDisabled = computed(() => {
            return !(minDate.value && maxDate.value && !rangeState.value.selecting && isValidRange([minDate.value, maxDate.value]));
          });
          const showTime = computed(() => props.type === "datetime" || props.type === "datetimerange");
          const formatEmit = (emitDayjs, index) => {
            if (!emitDayjs)
              return;
            if (defaultTime) {
              const defaultTimeD = dayjs(defaultTime[index] || defaultTime).locale(lang.value);
              return defaultTimeD.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
            }
            return emitDayjs;
          };
          const handleRangePick = (val, close = true) => {
            const min_ = val.minDate;
            const max_ = val.maxDate;
            const minDate_ = formatEmit(min_, 0);
            const maxDate_ = formatEmit(max_, 1);
            if (maxDate.value === maxDate_ && minDate.value === minDate_) {
              return;
            }
            emit2("calendar-change", [min_.toDate(), max_ && max_.toDate()]);
            maxDate.value = maxDate_;
            minDate.value = minDate_;
            if (!close || showTime.value)
              return;
            handleRangeConfirm();
          };
          const minTimePickerVisible = ref(false);
          const maxTimePickerVisible = ref(false);
          const handleMinTimeClose = () => {
            minTimePickerVisible.value = false;
          };
          const handleMaxTimeClose = () => {
            maxTimePickerVisible.value = false;
          };
          const handleDateInput = (value, type) => {
            dateUserInput.value[type] = value;
            const parsedValueD = dayjs(value, dateFormat.value).locale(lang.value);
            if (parsedValueD.isValid()) {
              if (disabledDate2 && disabledDate2(parsedValueD.toDate())) {
                return;
              }
              if (type === "min") {
                leftDate.value = parsedValueD;
                minDate.value = (minDate.value || leftDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
                if (!props.unlinkPanels && (!maxDate.value || maxDate.value.isBefore(minDate.value))) {
                  rightDate.value = parsedValueD.add(1, "month");
                  maxDate.value = minDate.value.add(1, "month");
                }
              } else {
                rightDate.value = parsedValueD;
                maxDate.value = (maxDate.value || rightDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
                if (!props.unlinkPanels && (!minDate.value || minDate.value.isAfter(maxDate.value))) {
                  leftDate.value = parsedValueD.subtract(1, "month");
                  minDate.value = maxDate.value.subtract(1, "month");
                }
              }
            }
          };
          const handleDateChange = (_2, type) => {
            dateUserInput.value[type] = null;
          };
          const handleTimeInput = (value, type) => {
            timeUserInput.value[type] = value;
            const parsedValueD = dayjs(value, timeFormat.value).locale(lang.value);
            if (parsedValueD.isValid()) {
              if (type === "min") {
                minTimePickerVisible.value = true;
                minDate.value = (minDate.value || leftDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
                if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
                  maxDate.value = minDate.value;
                }
              } else {
                maxTimePickerVisible.value = true;
                maxDate.value = (maxDate.value || rightDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
                rightDate.value = maxDate.value;
                if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
                  minDate.value = maxDate.value;
                }
              }
            }
          };
          const handleTimeChange = (value, type) => {
            timeUserInput.value[type] = null;
            if (type === "min") {
              leftDate.value = minDate.value;
              minTimePickerVisible.value = false;
            } else {
              rightDate.value = maxDate.value;
              maxTimePickerVisible.value = false;
            }
          };
          const handleMinTimePick = (value, visible, first) => {
            if (timeUserInput.value.min)
              return;
            if (value) {
              leftDate.value = value;
              minDate.value = (minDate.value || leftDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
            }
            if (!first) {
              minTimePickerVisible.value = visible;
            }
            if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
              maxDate.value = minDate.value;
              rightDate.value = value;
            }
          };
          const handleMaxTimePick = (value, visible, first) => {
            if (timeUserInput.value.max)
              return;
            if (value) {
              rightDate.value = value;
              maxDate.value = (maxDate.value || rightDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
            }
            if (!first) {
              maxTimePickerVisible.value = visible;
            }
            if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
              minDate.value = maxDate.value;
            }
          };
          const handleClear = () => {
            leftDate.value = getDefaultValue(unref(defaultValue), {
              lang: unref(lang),
              unit: "month",
              unlinkPanels: props.unlinkPanels
            })[0];
            rightDate.value = leftDate.value.add(1, "month");
            emit2("pick", null);
          };
          const formatToString = (value) => {
            return isArray$2(value) ? value.map((_2) => _2.format(format)) : value.format(format);
          };
          const parseUserInput = (value) => {
            return isArray$2(value) ? value.map((_2) => dayjs(_2, format).locale(lang.value)) : dayjs(value, format).locale(lang.value);
          };
          function onParsedValueChanged(minDate2, maxDate2) {
            if (props.unlinkPanels && maxDate2) {
              const minDateYear = (minDate2 == null ? void 0 : minDate2.year()) || 0;
              const minDateMonth = (minDate2 == null ? void 0 : minDate2.month()) || 0;
              const maxDateYear = maxDate2.year();
              const maxDateMonth = maxDate2.month();
              rightDate.value = minDateYear === maxDateYear && minDateMonth === maxDateMonth ? maxDate2.add(1, unit$1) : maxDate2;
            } else {
              rightDate.value = leftDate.value.add(1, unit$1);
              if (maxDate2) {
                rightDate.value = rightDate.value.hour(maxDate2.hour()).minute(maxDate2.minute()).second(maxDate2.second());
              }
            }
          }
          emit2("set-picker-option", ["isValidValue", isValidValue]);
          emit2("set-picker-option", ["parseUserInput", parseUserInput]);
          emit2("set-picker-option", ["formatToString", formatToString]);
          emit2("set-picker-option", ["handleClear", handleClear]);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ppNs).b(),
                unref(drpNs).b(),
                {
                  "has-sidebar": _ctx.$slots.sidebar || unref(hasShortcuts),
                  "has-time": unref(showTime)
                }
              ])
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(ppNs).e("body-wrapper"))
              }, [
                renderSlot(_ctx.$slots, "sidebar", {
                  class: normalizeClass(unref(ppNs).e("sidebar"))
                }),
                unref(hasShortcuts) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ppNs).e("sidebar"))
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(shortcuts), (shortcut, key) => {
                    return openBlock(), createElementBlock("button", {
                      key,
                      type: "button",
                      class: normalizeClass(unref(ppNs).e("shortcut")),
                      onClick: ($event) => unref(handleShortcutClick)(shortcut)
                    }, toDisplayString(shortcut.text), 11, _hoisted_1$8);
                  }), 128))
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  class: normalizeClass(unref(ppNs).e("body"))
                }, [
                  unref(showTime) ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(unref(drpNs).e("time-header"))
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(drpNs).e("editors-wrap"))
                    }, [
                      createBaseVNode("span", {
                        class: normalizeClass(unref(drpNs).e("time-picker-wrap"))
                      }, [
                        createVNode(unref(ElInput), {
                          size: "small",
                          disabled: unref(rangeState).selecting,
                          placeholder: unref(t2)("el.datepicker.startDate"),
                          class: normalizeClass(unref(drpNs).e("editor")),
                          "model-value": unref(minVisibleDate),
                          "validate-event": false,
                          onInput: _cache[0] || (_cache[0] = (val) => handleDateInput(val, "min")),
                          onChange: _cache[1] || (_cache[1] = (val) => handleDateChange(val, "min"))
                        }, null, 8, ["disabled", "placeholder", "class", "model-value"])
                      ], 2),
                      withDirectives((openBlock(), createElementBlock("span", {
                        class: normalizeClass(unref(drpNs).e("time-picker-wrap"))
                      }, [
                        createVNode(unref(ElInput), {
                          size: "small",
                          class: normalizeClass(unref(drpNs).e("editor")),
                          disabled: unref(rangeState).selecting,
                          placeholder: unref(t2)("el.datepicker.startTime"),
                          "model-value": unref(minVisibleTime),
                          "validate-event": false,
                          onFocus: _cache[2] || (_cache[2] = ($event) => minTimePickerVisible.value = true),
                          onInput: _cache[3] || (_cache[3] = (val) => handleTimeInput(val, "min")),
                          onChange: _cache[4] || (_cache[4] = (val) => handleTimeChange(val, "min"))
                        }, null, 8, ["class", "disabled", "placeholder", "model-value"]),
                        createVNode(unref(TimePickPanel), {
                          visible: minTimePickerVisible.value,
                          format: unref(timeFormat),
                          "datetime-role": "start",
                          "parsed-value": leftDate.value,
                          onPick: handleMinTimePick
                        }, null, 8, ["visible", "format", "parsed-value"])
                      ], 2)), [
                        [unref(ClickOutside), handleMinTimeClose]
                      ])
                    ], 2),
                    createBaseVNode("span", null, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(arrow_right_default))
                        ]),
                        _: 1
                      })
                    ]),
                    createBaseVNode("span", {
                      class: normalizeClass([unref(drpNs).e("editors-wrap"), "is-right"])
                    }, [
                      createBaseVNode("span", {
                        class: normalizeClass(unref(drpNs).e("time-picker-wrap"))
                      }, [
                        createVNode(unref(ElInput), {
                          size: "small",
                          class: normalizeClass(unref(drpNs).e("editor")),
                          disabled: unref(rangeState).selecting,
                          placeholder: unref(t2)("el.datepicker.endDate"),
                          "model-value": unref(maxVisibleDate),
                          readonly: !unref(minDate),
                          "validate-event": false,
                          onInput: _cache[5] || (_cache[5] = (val) => handleDateInput(val, "max")),
                          onChange: _cache[6] || (_cache[6] = (val) => handleDateChange(val, "max"))
                        }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"])
                      ], 2),
                      withDirectives((openBlock(), createElementBlock("span", {
                        class: normalizeClass(unref(drpNs).e("time-picker-wrap"))
                      }, [
                        createVNode(unref(ElInput), {
                          size: "small",
                          class: normalizeClass(unref(drpNs).e("editor")),
                          disabled: unref(rangeState).selecting,
                          placeholder: unref(t2)("el.datepicker.endTime"),
                          "model-value": unref(maxVisibleTime),
                          readonly: !unref(minDate),
                          "validate-event": false,
                          onFocus: _cache[7] || (_cache[7] = ($event) => unref(minDate) && (maxTimePickerVisible.value = true)),
                          onInput: _cache[8] || (_cache[8] = (val) => handleTimeInput(val, "max")),
                          onChange: _cache[9] || (_cache[9] = (val) => handleTimeChange(val, "max"))
                        }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"]),
                        createVNode(unref(TimePickPanel), {
                          "datetime-role": "end",
                          visible: maxTimePickerVisible.value,
                          format: unref(timeFormat),
                          "parsed-value": rightDate.value,
                          onPick: handleMaxTimePick
                        }, null, 8, ["visible", "format", "parsed-value"])
                      ], 2)), [
                        [unref(ClickOutside), handleMaxTimeClose]
                      ])
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true),
                  createBaseVNode("div", {
                    class: normalizeClass([[unref(ppNs).e("content"), unref(drpNs).e("content")], "is-left"])
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(unref(drpNs).e("header"))
                    }, [
                      createBaseVNode("button", {
                        type: "button",
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-left"]),
                        "aria-label": unref(t2)(`el.datepicker.prevYear`),
                        onClick: leftPrevYear
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(d_arrow_left_default))
                          ]),
                          _: 1
                        })
                      ], 10, _hoisted_2$5),
                      createBaseVNode("button", {
                        type: "button",
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "arrow-left"]),
                        "aria-label": unref(t2)(`el.datepicker.prevMonth`),
                        onClick: leftPrevMonth
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(arrow_left_default))
                          ]),
                          _: 1
                        })
                      ], 10, _hoisted_3$3),
                      _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                        key: 0,
                        type: "button",
                        disabled: !unref(enableYearArrow),
                        class: normalizeClass([[unref(ppNs).e("icon-btn"), { "is-disabled": !unref(enableYearArrow) }], "d-arrow-right"]),
                        "aria-label": unref(t2)(`el.datepicker.nextYear`),
                        onClick: leftNextYear
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(d_arrow_right_default))
                          ]),
                          _: 1
                        })
                      ], 10, _hoisted_4)) : createCommentVNode("v-if", true),
                      _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                        key: 1,
                        type: "button",
                        disabled: !unref(enableMonthArrow),
                        class: normalizeClass([[
                          unref(ppNs).e("icon-btn"),
                          { "is-disabled": !unref(enableMonthArrow) }
                        ], "arrow-right"]),
                        "aria-label": unref(t2)(`el.datepicker.nextMonth`),
                        onClick: leftNextMonth
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(arrow_right_default))
                          ]),
                          _: 1
                        })
                      ], 10, _hoisted_5)) : createCommentVNode("v-if", true),
                      createBaseVNode("div", null, toDisplayString(unref(leftLabel)), 1)
                    ], 2),
                    createVNode(DateTable, {
                      "selection-mode": "range",
                      date: leftDate.value,
                      "min-date": unref(minDate),
                      "max-date": unref(maxDate),
                      "range-state": unref(rangeState),
                      "disabled-date": unref(disabledDate2),
                      "cell-class-name": unref(cellClassName),
                      onChangerange: unref(handleChangeRange),
                      onPick: handleRangePick,
                      onSelect: unref(onSelect)
                    }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])
                  ], 2),
                  createBaseVNode("div", {
                    class: normalizeClass([[unref(ppNs).e("content"), unref(drpNs).e("content")], "is-right"])
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(unref(drpNs).e("header"))
                    }, [
                      _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                        key: 0,
                        type: "button",
                        disabled: !unref(enableYearArrow),
                        class: normalizeClass([[unref(ppNs).e("icon-btn"), { "is-disabled": !unref(enableYearArrow) }], "d-arrow-left"]),
                        "aria-label": unref(t2)(`el.datepicker.prevYear`),
                        onClick: rightPrevYear
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(d_arrow_left_default))
                          ]),
                          _: 1
                        })
                      ], 10, _hoisted_6)) : createCommentVNode("v-if", true),
                      _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                        key: 1,
                        type: "button",
                        disabled: !unref(enableMonthArrow),
                        class: normalizeClass([[
                          unref(ppNs).e("icon-btn"),
                          { "is-disabled": !unref(enableMonthArrow) }
                        ], "arrow-left"]),
                        "aria-label": unref(t2)(`el.datepicker.prevMonth`),
                        onClick: rightPrevMonth
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(arrow_left_default))
                          ]),
                          _: 1
                        })
                      ], 10, _hoisted_7)) : createCommentVNode("v-if", true),
                      createBaseVNode("button", {
                        type: "button",
                        "aria-label": unref(t2)(`el.datepicker.nextYear`),
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-right"]),
                        onClick: rightNextYear
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(d_arrow_right_default))
                          ]),
                          _: 1
                        })
                      ], 10, _hoisted_8),
                      createBaseVNode("button", {
                        type: "button",
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "arrow-right"]),
                        "aria-label": unref(t2)(`el.datepicker.nextMonth`),
                        onClick: rightNextMonth
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(arrow_right_default))
                          ]),
                          _: 1
                        })
                      ], 10, _hoisted_9),
                      createBaseVNode("div", null, toDisplayString(unref(rightLabel)), 1)
                    ], 2),
                    createVNode(DateTable, {
                      "selection-mode": "range",
                      date: rightDate.value,
                      "min-date": unref(minDate),
                      "max-date": unref(maxDate),
                      "range-state": unref(rangeState),
                      "disabled-date": unref(disabledDate2),
                      "cell-class-name": unref(cellClassName),
                      onChangerange: unref(handleChangeRange),
                      onPick: handleRangePick,
                      onSelect: unref(onSelect)
                    }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])
                  ], 2)
                ], 2)
              ], 2),
              unref(showTime) ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ppNs).e("footer"))
              }, [
                unref(clearable) ? (openBlock(), createBlock(unref(ElButton), {
                  key: 0,
                  text: "",
                  size: "small",
                  class: normalizeClass(unref(ppNs).e("link-btn")),
                  onClick: handleClear
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref(t2)("el.datepicker.clear")), 1)
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true),
                createVNode(unref(ElButton), {
                  plain: "",
                  size: "small",
                  class: normalizeClass(unref(ppNs).e("link-btn")),
                  disabled: unref(btnDisabled),
                  onClick: _cache[10] || (_cache[10] = ($event) => unref(handleRangeConfirm)(false))
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref(t2)("el.datepicker.confirm")), 1)
                  ]),
                  _: 1
                }, 8, ["class", "disabled"])
              ], 2)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var DateRangePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__file", "panel-date-range.vue"]]);
      const panelMonthRangeProps = buildProps({
        ...panelRangeSharedProps
      });
      const panelMonthRangeEmits = [
        "pick",
        "set-picker-option",
        "calendar-change"
      ];
      const useMonthRangeHeader = ({
        unlinkPanels,
        leftDate,
        rightDate
      }) => {
        const { t: t2 } = useLocale();
        const leftPrevYear = () => {
          leftDate.value = leftDate.value.subtract(1, "year");
          if (!unlinkPanels.value) {
            rightDate.value = rightDate.value.subtract(1, "year");
          }
        };
        const rightNextYear = () => {
          if (!unlinkPanels.value) {
            leftDate.value = leftDate.value.add(1, "year");
          }
          rightDate.value = rightDate.value.add(1, "year");
        };
        const leftNextYear = () => {
          leftDate.value = leftDate.value.add(1, "year");
        };
        const rightPrevYear = () => {
          rightDate.value = rightDate.value.subtract(1, "year");
        };
        const leftLabel = computed(() => {
          return `${leftDate.value.year()} ${t2("el.datepicker.year")}`;
        });
        const rightLabel = computed(() => {
          return `${rightDate.value.year()} ${t2("el.datepicker.year")}`;
        });
        const leftYear = computed(() => {
          return leftDate.value.year();
        });
        const rightYear = computed(() => {
          return rightDate.value.year() === leftDate.value.year() ? leftDate.value.year() + 1 : rightDate.value.year();
        });
        return {
          leftPrevYear,
          rightNextYear,
          leftNextYear,
          rightPrevYear,
          leftLabel,
          rightLabel,
          leftYear,
          rightYear
        };
      };
      const _hoisted_1$7 = ["onClick"];
      const _hoisted_2$4 = ["disabled"];
      const _hoisted_3$2 = ["disabled"];
      const unit = "year";
      const __default__$2 = /* @__PURE__ */ defineComponent({
        name: "DatePickerMonthRange"
      });
      const _sfc_main$a = /* @__PURE__ */ defineComponent({
        ...__default__$2,
        props: panelMonthRangeProps,
        emits: panelMonthRangeEmits,
        setup(__props, { emit: emit2 }) {
          const props = __props;
          const { lang } = useLocale();
          const pickerBase = inject("EP_PICKER_BASE");
          const { shortcuts, disabledDate: disabledDate2, format } = pickerBase.props;
          const defaultValue = toRef(pickerBase.props, "defaultValue");
          const leftDate = ref(dayjs().locale(lang.value));
          const rightDate = ref(dayjs().locale(lang.value).add(1, unit));
          const {
            minDate,
            maxDate,
            rangeState,
            ppNs,
            drpNs,
            handleChangeRange,
            handleRangeConfirm,
            handleShortcutClick,
            onSelect
          } = useRangePicker(props, {
            defaultValue,
            leftDate,
            rightDate,
            unit,
            onParsedValueChanged
          });
          const hasShortcuts = computed(() => !!shortcuts.length);
          const {
            leftPrevYear,
            rightNextYear,
            leftNextYear,
            rightPrevYear,
            leftLabel,
            rightLabel,
            leftYear,
            rightYear
          } = useMonthRangeHeader({
            unlinkPanels: toRef(props, "unlinkPanels"),
            leftDate,
            rightDate
          });
          const enableYearArrow = computed(() => {
            return props.unlinkPanels && rightYear.value > leftYear.value + 1;
          });
          const handleRangePick = (val, close = true) => {
            const minDate_ = val.minDate;
            const maxDate_ = val.maxDate;
            if (maxDate.value === maxDate_ && minDate.value === minDate_) {
              return;
            }
            emit2("calendar-change", [minDate_.toDate(), maxDate_ && maxDate_.toDate()]);
            maxDate.value = maxDate_;
            minDate.value = minDate_;
            if (!close)
              return;
            handleRangeConfirm();
          };
          const formatToString = (days) => {
            return days.map((day) => day.format(format));
          };
          function onParsedValueChanged(minDate2, maxDate2) {
            if (props.unlinkPanels && maxDate2) {
              const minDateYear = (minDate2 == null ? void 0 : minDate2.year()) || 0;
              const maxDateYear = maxDate2.year();
              rightDate.value = minDateYear === maxDateYear ? maxDate2.add(1, unit) : maxDate2;
            } else {
              rightDate.value = leftDate.value.add(1, unit);
            }
          }
          emit2("set-picker-option", ["formatToString", formatToString]);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ppNs).b(),
                unref(drpNs).b(),
                {
                  "has-sidebar": Boolean(_ctx.$slots.sidebar) || unref(hasShortcuts)
                }
              ])
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(ppNs).e("body-wrapper"))
              }, [
                renderSlot(_ctx.$slots, "sidebar", {
                  class: normalizeClass(unref(ppNs).e("sidebar"))
                }),
                unref(hasShortcuts) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ppNs).e("sidebar"))
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(shortcuts), (shortcut, key) => {
                    return openBlock(), createElementBlock("button", {
                      key,
                      type: "button",
                      class: normalizeClass(unref(ppNs).e("shortcut")),
                      onClick: ($event) => unref(handleShortcutClick)(shortcut)
                    }, toDisplayString(shortcut.text), 11, _hoisted_1$7);
                  }), 128))
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  class: normalizeClass(unref(ppNs).e("body"))
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass([[unref(ppNs).e("content"), unref(drpNs).e("content")], "is-left"])
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(unref(drpNs).e("header"))
                    }, [
                      createBaseVNode("button", {
                        type: "button",
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-left"]),
                        onClick: _cache[0] || (_cache[0] = (...args) => unref(leftPrevYear) && unref(leftPrevYear)(...args))
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(d_arrow_left_default))
                          ]),
                          _: 1
                        })
                      ], 2),
                      _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                        key: 0,
                        type: "button",
                        disabled: !unref(enableYearArrow),
                        class: normalizeClass([[
                          unref(ppNs).e("icon-btn"),
                          { [unref(ppNs).is("disabled")]: !unref(enableYearArrow) }
                        ], "d-arrow-right"]),
                        onClick: _cache[1] || (_cache[1] = (...args) => unref(leftNextYear) && unref(leftNextYear)(...args))
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(d_arrow_right_default))
                          ]),
                          _: 1
                        })
                      ], 10, _hoisted_2$4)) : createCommentVNode("v-if", true),
                      createBaseVNode("div", null, toDisplayString(unref(leftLabel)), 1)
                    ], 2),
                    createVNode(MonthTable, {
                      "selection-mode": "range",
                      date: leftDate.value,
                      "min-date": unref(minDate),
                      "max-date": unref(maxDate),
                      "range-state": unref(rangeState),
                      "disabled-date": unref(disabledDate2),
                      onChangerange: unref(handleChangeRange),
                      onPick: handleRangePick,
                      onSelect: unref(onSelect)
                    }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
                  ], 2),
                  createBaseVNode("div", {
                    class: normalizeClass([[unref(ppNs).e("content"), unref(drpNs).e("content")], "is-right"])
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(unref(drpNs).e("header"))
                    }, [
                      _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                        key: 0,
                        type: "button",
                        disabled: !unref(enableYearArrow),
                        class: normalizeClass([[unref(ppNs).e("icon-btn"), { "is-disabled": !unref(enableYearArrow) }], "d-arrow-left"]),
                        onClick: _cache[2] || (_cache[2] = (...args) => unref(rightPrevYear) && unref(rightPrevYear)(...args))
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(d_arrow_left_default))
                          ]),
                          _: 1
                        })
                      ], 10, _hoisted_3$2)) : createCommentVNode("v-if", true),
                      createBaseVNode("button", {
                        type: "button",
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-right"]),
                        onClick: _cache[3] || (_cache[3] = (...args) => unref(rightNextYear) && unref(rightNextYear)(...args))
                      }, [
                        createVNode(unref(ElIcon), null, {
                          default: withCtx(() => [
                            createVNode(unref(d_arrow_right_default))
                          ]),
                          _: 1
                        })
                      ], 2),
                      createBaseVNode("div", null, toDisplayString(unref(rightLabel)), 1)
                    ], 2),
                    createVNode(MonthTable, {
                      "selection-mode": "range",
                      date: rightDate.value,
                      "min-date": unref(minDate),
                      "max-date": unref(maxDate),
                      "range-state": unref(rangeState),
                      "disabled-date": unref(disabledDate2),
                      onChangerange: unref(handleChangeRange),
                      onPick: handleRangePick,
                      onSelect: unref(onSelect)
                    }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
                  ], 2)
                ], 2)
              ], 2)
            ], 2);
          };
        }
      });
      var MonthRangePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__file", "panel-month-range.vue"]]);
      const getPanel = function(type) {
        switch (type) {
          case "daterange":
          case "datetimerange": {
            return DateRangePickPanel;
          }
          case "monthrange": {
            return MonthRangePickPanel;
          }
          default: {
            return DatePickPanel;
          }
        }
      };
      dayjs.extend(localeData);
      dayjs.extend(advancedFormat);
      dayjs.extend(customParseFormat);
      dayjs.extend(weekOfYear);
      dayjs.extend(weekYear);
      dayjs.extend(dayOfYear);
      dayjs.extend(isSameOrAfter);
      dayjs.extend(isSameOrBefore);
      var DatePicker = /* @__PURE__ */ defineComponent({
        name: "ElDatePicker",
        install: null,
        props: datePickerProps,
        emits: ["update:modelValue"],
        setup(props, {
          expose,
          emit: emit2,
          slots
        }) {
          const ns = useNamespace("picker-panel");
          provide("ElPopperOptions", reactive(toRef(props, "popperOptions")));
          provide(ROOT_PICKER_INJECTION_KEY, {
            slots,
            pickerNs: ns
          });
          const commonPicker = ref();
          const refProps = {
            focus: (focusStartInput = true) => {
              var _a2;
              (_a2 = commonPicker.value) == null ? void 0 : _a2.focus(focusStartInput);
            },
            handleOpen: () => {
              var _a2;
              (_a2 = commonPicker.value) == null ? void 0 : _a2.handleOpen();
            },
            handleClose: () => {
              var _a2;
              (_a2 = commonPicker.value) == null ? void 0 : _a2.handleClose();
            }
          };
          expose(refProps);
          const onModelValueUpdated = (val) => {
            emit2("update:modelValue", val);
          };
          return () => {
            var _a2;
            const format = (_a2 = props.format) != null ? _a2 : DEFAULT_FORMATS_DATEPICKER[props.type] || DEFAULT_FORMATS_DATE;
            const Component = getPanel(props.type);
            return createVNode(CommonPicker, mergeProps(props, {
              "format": format,
              "type": props.type,
              "ref": commonPicker,
              "onUpdate:modelValue": onModelValueUpdated
            }), {
              default: (scopedProps) => createVNode(Component, scopedProps, null),
              "range-separator": slots["range-separator"]
            });
          };
        }
      });
      const _DatePicker = DatePicker;
      _DatePicker.install = (app) => {
        app.component(_DatePicker.name, _DatePicker);
      };
      const ElDatePicker = _DatePicker;
      const overlayProps = buildProps({
        mask: {
          type: Boolean,
          default: true
        },
        customMaskEvent: {
          type: Boolean,
          default: false
        },
        overlayClass: {
          type: definePropType([
            String,
            Array,
            Object
          ])
        },
        zIndex: {
          type: definePropType([String, Number])
        }
      });
      const overlayEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      const BLOCK = "overlay";
      var Overlay = /* @__PURE__ */ defineComponent({
        name: "ElOverlay",
        props: overlayProps,
        emits: overlayEmits,
        setup(props, { slots, emit: emit2 }) {
          const ns = useNamespace(BLOCK);
          const onMaskClick = (e2) => {
            emit2("click", e2);
          };
          const { onClick, onMousedown, onMouseup } = useSameTarget(props.customMaskEvent ? void 0 : onMaskClick);
          return () => {
            return props.mask ? createVNode("div", {
              class: [ns.b(), props.overlayClass],
              style: {
                zIndex: props.zIndex
              },
              onClick,
              onMousedown,
              onMouseup
            }, [renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h("div", {
              class: props.overlayClass,
              style: {
                zIndex: props.zIndex,
                position: "fixed",
                top: "0px",
                right: "0px",
                bottom: "0px",
                left: "0px"
              }
            }, [renderSlot(slots, "default")]);
          };
        }
      });
      const ElOverlay = Overlay;
      const dialogInjectionKey = Symbol("dialogInjectionKey");
      const dialogContentProps = buildProps({
        center: Boolean,
        alignCenter: Boolean,
        closeIcon: {
          type: iconPropType
        },
        customClass: {
          type: String,
          default: ""
        },
        draggable: Boolean,
        fullscreen: Boolean,
        showClose: {
          type: Boolean,
          default: true
        },
        title: {
          type: String,
          default: ""
        },
        ariaLevel: {
          type: String,
          default: "2"
        }
      });
      const dialogContentEmits = {
        close: () => true
      };
      const _hoisted_1$6 = ["aria-level"];
      const _hoisted_2$3 = ["aria-label"];
      const _hoisted_3$1 = ["id"];
      const __default__$1 = /* @__PURE__ */ defineComponent({ name: "ElDialogContent" });
      const _sfc_main$9 = /* @__PURE__ */ defineComponent({
        ...__default__$1,
        props: dialogContentProps,
        emits: dialogContentEmits,
        setup(__props) {
          const props = __props;
          const { t: t2 } = useLocale();
          const { Close } = CloseComponents;
          const { dialogRef, headerRef, bodyId, ns, style: style2 } = inject(dialogInjectionKey);
          const { focusTrapRef } = inject(FOCUS_TRAP_INJECTION_KEY);
          const dialogKls = computed(() => [
            ns.b(),
            ns.is("fullscreen", props.fullscreen),
            ns.is("draggable", props.draggable),
            ns.is("align-center", props.alignCenter),
            { [ns.m("center")]: props.center },
            props.customClass
          ]);
          const composedDialogRef = composeRefs(focusTrapRef, dialogRef);
          const draggable = computed(() => props.draggable);
          useDraggable(dialogRef, headerRef, draggable);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref: unref(composedDialogRef),
              class: normalizeClass(unref(dialogKls)),
              style: normalizeStyle(unref(style2)),
              tabindex: "-1"
            }, [
              createBaseVNode("header", {
                ref_key: "headerRef",
                ref: headerRef,
                class: normalizeClass(unref(ns).e("header"))
              }, [
                renderSlot(_ctx.$slots, "header", {}, () => [
                  createBaseVNode("span", {
                    role: "heading",
                    "aria-level": _ctx.ariaLevel,
                    class: normalizeClass(unref(ns).e("title"))
                  }, toDisplayString(_ctx.title), 11, _hoisted_1$6)
                ]),
                _ctx.showClose ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  "aria-label": unref(t2)("el.dialog.close"),
                  class: normalizeClass(unref(ns).e("headerbtn")),
                  type: "button",
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
                }, [
                  createVNode(unref(ElIcon), {
                    class: normalizeClass(unref(ns).e("close"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon || unref(Close))))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ], 10, _hoisted_2$3)) : createCommentVNode("v-if", true)
              ], 2),
              createBaseVNode("div", {
                id: unref(bodyId),
                class: normalizeClass(unref(ns).e("body"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 10, _hoisted_3$1),
              _ctx.$slots.footer ? (openBlock(), createElementBlock("footer", {
                key: 0,
                class: normalizeClass(unref(ns).e("footer"))
              }, [
                renderSlot(_ctx.$slots, "footer")
              ], 2)) : createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var ElDialogContent = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__file", "dialog-content.vue"]]);
      const dialogProps = buildProps({
        ...dialogContentProps,
        appendToBody: Boolean,
        appendTo: {
          type: definePropType(String),
          default: "body"
        },
        beforeClose: {
          type: definePropType(Function)
        },
        destroyOnClose: Boolean,
        closeOnClickModal: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        lockScroll: {
          type: Boolean,
          default: true
        },
        modal: {
          type: Boolean,
          default: true
        },
        openDelay: {
          type: Number,
          default: 0
        },
        closeDelay: {
          type: Number,
          default: 0
        },
        top: {
          type: String
        },
        modelValue: Boolean,
        modalClass: String,
        width: {
          type: [String, Number]
        },
        zIndex: {
          type: Number
        },
        trapFocus: {
          type: Boolean,
          default: false
        },
        headerAriaLevel: {
          type: String,
          default: "2"
        }
      });
      const dialogEmits = {
        open: () => true,
        opened: () => true,
        close: () => true,
        closed: () => true,
        [UPDATE_MODEL_EVENT]: (value) => isBoolean(value),
        openAutoFocus: () => true,
        closeAutoFocus: () => true
      };
      const useDialog = (props, targetRef) => {
        var _a2;
        const instance = getCurrentInstance();
        const emit2 = instance.emit;
        const { nextZIndex } = useZIndex();
        let lastPosition = "";
        const titleId = useId();
        const bodyId = useId();
        const visible = ref(false);
        const closed = ref(false);
        const rendered = ref(false);
        const zIndex2 = ref((_a2 = props.zIndex) != null ? _a2 : nextZIndex());
        let openTimer = void 0;
        let closeTimer = void 0;
        const namespace = useGlobalConfig("namespace", defaultNamespace);
        const style2 = computed(() => {
          const style22 = {};
          const varPrefix = `--${namespace.value}-dialog`;
          if (!props.fullscreen) {
            if (props.top) {
              style22[`${varPrefix}-margin-top`] = props.top;
            }
            if (props.width) {
              style22[`${varPrefix}-width`] = addUnit(props.width);
            }
          }
          return style22;
        });
        const overlayDialogStyle = computed(() => {
          if (props.alignCenter) {
            return { display: "flex" };
          }
          return {};
        });
        function afterEnter() {
          emit2("opened");
        }
        function afterLeave() {
          emit2("closed");
          emit2(UPDATE_MODEL_EVENT, false);
          if (props.destroyOnClose) {
            rendered.value = false;
          }
        }
        function beforeLeave() {
          emit2("close");
        }
        function open() {
          closeTimer == null ? void 0 : closeTimer();
          openTimer == null ? void 0 : openTimer();
          if (props.openDelay && props.openDelay > 0) {
            ({ stop: openTimer } = useTimeoutFn(() => doOpen(), props.openDelay));
          } else {
            doOpen();
          }
        }
        function close() {
          openTimer == null ? void 0 : openTimer();
          closeTimer == null ? void 0 : closeTimer();
          if (props.closeDelay && props.closeDelay > 0) {
            ({ stop: closeTimer } = useTimeoutFn(() => doClose(), props.closeDelay));
          } else {
            doClose();
          }
        }
        function handleClose() {
          function hide(shouldCancel) {
            if (shouldCancel)
              return;
            closed.value = true;
            visible.value = false;
          }
          if (props.beforeClose) {
            props.beforeClose(hide);
          } else {
            close();
          }
        }
        function onModalClick() {
          if (props.closeOnClickModal) {
            handleClose();
          }
        }
        function doOpen() {
          if (!isClient)
            return;
          visible.value = true;
        }
        function doClose() {
          visible.value = false;
        }
        function onOpenAutoFocus() {
          emit2("openAutoFocus");
        }
        function onCloseAutoFocus() {
          emit2("closeAutoFocus");
        }
        function onFocusoutPrevented(event) {
          var _a22;
          if (((_a22 = event.detail) == null ? void 0 : _a22.focusReason) === "pointer") {
            event.preventDefault();
          }
        }
        if (props.lockScroll) {
          useLockscreen(visible);
        }
        function onCloseRequested() {
          if (props.closeOnPressEscape) {
            handleClose();
          }
        }
        watch(() => props.modelValue, (val) => {
          if (val) {
            closed.value = false;
            open();
            rendered.value = true;
            zIndex2.value = isUndefined$1(props.zIndex) ? nextZIndex() : zIndex2.value++;
            nextTick(() => {
              emit2("open");
              if (targetRef.value) {
                targetRef.value.scrollTop = 0;
              }
            });
          } else {
            if (visible.value) {
              close();
            }
          }
        });
        watch(() => props.fullscreen, (val) => {
          if (!targetRef.value)
            return;
          if (val) {
            lastPosition = targetRef.value.style.transform;
            targetRef.value.style.transform = "";
          } else {
            targetRef.value.style.transform = lastPosition;
          }
        });
        onMounted(() => {
          if (props.modelValue) {
            visible.value = true;
            rendered.value = true;
            open();
          }
        });
        return {
          afterEnter,
          afterLeave,
          beforeLeave,
          handleClose,
          onModalClick,
          close,
          doClose,
          onOpenAutoFocus,
          onCloseAutoFocus,
          onCloseRequested,
          onFocusoutPrevented,
          titleId,
          bodyId,
          closed,
          style: style2,
          overlayDialogStyle,
          rendered,
          visible,
          zIndex: zIndex2
        };
      };
      const _hoisted_1$5 = ["aria-label", "aria-labelledby", "aria-describedby"];
      const __default__ = /* @__PURE__ */ defineComponent({
        name: "ElDialog",
        inheritAttrs: false
      });
      const _sfc_main$8 = /* @__PURE__ */ defineComponent({
        ...__default__,
        props: dialogProps,
        emits: dialogEmits,
        setup(__props, { expose }) {
          const props = __props;
          const slots = useSlots();
          useDeprecated({
            scope: "el-dialog",
            from: "the title slot",
            replacement: "the header slot",
            version: "3.0.0",
            ref: "https://element-plus.org/en-US/component/dialog.html#slots"
          }, computed(() => !!slots.title));
          useDeprecated({
            scope: "el-dialog",
            from: "custom-class",
            replacement: "class",
            version: "2.3.0",
            ref: "https://element-plus.org/en-US/component/dialog.html#attributes",
            type: "Attribute"
          }, computed(() => !!props.customClass));
          const ns = useNamespace("dialog");
          const dialogRef = ref();
          const headerRef = ref();
          const dialogContentRef = ref();
          const {
            visible,
            titleId,
            bodyId,
            style: style2,
            overlayDialogStyle,
            rendered,
            zIndex: zIndex2,
            afterEnter,
            afterLeave,
            beforeLeave,
            handleClose,
            onModalClick,
            onOpenAutoFocus,
            onCloseAutoFocus,
            onCloseRequested,
            onFocusoutPrevented
          } = useDialog(props, dialogRef);
          provide(dialogInjectionKey, {
            dialogRef,
            headerRef,
            bodyId,
            ns,
            rendered,
            style: style2
          });
          const overlayEvent = useSameTarget(onModalClick);
          const draggable = computed(() => props.draggable && !props.fullscreen);
          expose({
            visible,
            dialogContentRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Teleport, {
              to: _ctx.appendTo,
              disabled: _ctx.appendTo !== "body" ? false : !_ctx.appendToBody
            }, [
              createVNode(Transition, {
                name: "dialog-fade",
                onAfterEnter: unref(afterEnter),
                onAfterLeave: unref(afterLeave),
                onBeforeLeave: unref(beforeLeave),
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createVNode(unref(ElOverlay), {
                    "custom-mask-event": "",
                    mask: _ctx.modal,
                    "overlay-class": _ctx.modalClass,
                    "z-index": unref(zIndex2)
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", {
                        role: "dialog",
                        "aria-modal": "true",
                        "aria-label": _ctx.title || void 0,
                        "aria-labelledby": !_ctx.title ? unref(titleId) : void 0,
                        "aria-describedby": unref(bodyId),
                        class: normalizeClass(`${unref(ns).namespace.value}-overlay-dialog`),
                        style: normalizeStyle(unref(overlayDialogStyle)),
                        onClick: _cache[0] || (_cache[0] = (...args) => unref(overlayEvent).onClick && unref(overlayEvent).onClick(...args)),
                        onMousedown: _cache[1] || (_cache[1] = (...args) => unref(overlayEvent).onMousedown && unref(overlayEvent).onMousedown(...args)),
                        onMouseup: _cache[2] || (_cache[2] = (...args) => unref(overlayEvent).onMouseup && unref(overlayEvent).onMouseup(...args))
                      }, [
                        createVNode(unref(ElFocusTrap), {
                          loop: "",
                          trapped: unref(visible),
                          "focus-start-el": "container",
                          onFocusAfterTrapped: unref(onOpenAutoFocus),
                          onFocusAfterReleased: unref(onCloseAutoFocus),
                          onFocusoutPrevented: unref(onFocusoutPrevented),
                          onReleaseRequested: unref(onCloseRequested)
                        }, {
                          default: withCtx(() => [
                            unref(rendered) ? (openBlock(), createBlock(ElDialogContent, mergeProps({
                              key: 0,
                              ref_key: "dialogContentRef",
                              ref: dialogContentRef
                            }, _ctx.$attrs, {
                              "custom-class": _ctx.customClass,
                              center: _ctx.center,
                              "align-center": _ctx.alignCenter,
                              "close-icon": _ctx.closeIcon,
                              draggable: unref(draggable),
                              fullscreen: _ctx.fullscreen,
                              "show-close": _ctx.showClose,
                              title: _ctx.title,
                              "aria-level": _ctx.headerAriaLevel,
                              onClose: unref(handleClose)
                            }), createSlots({
                              header: withCtx(() => [
                                !_ctx.$slots.title ? renderSlot(_ctx.$slots, "header", {
                                  key: 0,
                                  close: unref(handleClose),
                                  titleId: unref(titleId),
                                  titleClass: unref(ns).e("title")
                                }) : renderSlot(_ctx.$slots, "title", { key: 1 })
                              ]),
                              default: withCtx(() => [
                                renderSlot(_ctx.$slots, "default")
                              ]),
                              _: 2
                            }, [
                              _ctx.$slots.footer ? {
                                name: "footer",
                                fn: withCtx(() => [
                                  renderSlot(_ctx.$slots, "footer")
                                ])
                              } : void 0
                            ]), 1040, ["custom-class", "center", "align-center", "close-icon", "draggable", "fullscreen", "show-close", "title", "aria-level", "onClose"])) : createCommentVNode("v-if", true)
                          ]),
                          _: 3
                        }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                      ], 46, _hoisted_1$5)
                    ]),
                    _: 3
                  }, 8, ["mask", "overlay-class", "z-index"]), [
                    [vShow, unref(visible)]
                  ])
                ]),
                _: 3
              }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
            ], 8, ["to", "disabled"]);
          };
        }
      });
      var Dialog = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__file", "dialog.vue"]]);
      const ElDialog = withInstall(Dialog);
      const selectGroupKey = Symbol("ElSelectGroup");
      const selectKey = Symbol("ElSelect");
      function useOption(props, states) {
        const select = inject(selectKey);
        const selectGroup = inject(selectGroupKey, { disabled: false });
        const itemSelected = computed(() => {
          if (!select.props.multiple) {
            return isEqual(props.value, select.props.modelValue);
          } else {
            return contains(select.props.modelValue, props.value);
          }
        });
        const limitReached = computed(() => {
          if (select.props.multiple) {
            const modelValue = select.props.modelValue || [];
            return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
          } else {
            return false;
          }
        });
        const currentLabel = computed(() => {
          return props.label || (isObject$1(props.value) ? "" : props.value);
        });
        const currentValue = computed(() => {
          return props.value || props.label || "";
        });
        const isDisabled = computed(() => {
          return props.disabled || states.groupDisabled || limitReached.value;
        });
        const instance = getCurrentInstance();
        const contains = (arr = [], target) => {
          if (!isObject$1(props.value)) {
            return arr && arr.includes(target);
          } else {
            const valueKey = select.props.valueKey;
            return arr && arr.some((item) => {
              return toRaw(get(item, valueKey)) === get(target, valueKey);
            });
          }
        };
        const hoverItem = () => {
          if (!props.disabled && !selectGroup.disabled) {
            select.states.hoveringIndex = select.optionsArray.indexOf(instance.proxy);
          }
        };
        const updateOption = (query) => {
          const regexp = new RegExp(escapeStringRegexp(query), "i");
          states.visible = regexp.test(currentLabel.value) || props.created;
        };
        watch(() => currentLabel.value, () => {
          if (!props.created && !select.props.remote)
            select.setSelected();
        });
        watch(() => props.value, (val, oldVal) => {
          const { remote, valueKey } = select.props;
          if (!isEqual(val, oldVal)) {
            select.onOptionDestroy(oldVal, instance.proxy);
            select.onOptionCreate(instance.proxy);
          }
          if (!props.created && !remote) {
            if (valueKey && isObject$1(val) && isObject$1(oldVal) && val[valueKey] === oldVal[valueKey]) {
              return;
            }
            select.setSelected();
          }
        });
        watch(() => selectGroup.disabled, () => {
          states.groupDisabled = selectGroup.disabled;
        }, { immediate: true });
        return {
          select,
          currentLabel,
          currentValue,
          itemSelected,
          isDisabled,
          hoverItem,
          updateOption
        };
      }
      const _sfc_main$7 = /* @__PURE__ */ defineComponent({
        name: "ElOption",
        componentName: "ElOption",
        props: {
          value: {
            required: true,
            type: [String, Number, Boolean, Object]
          },
          label: [String, Number],
          created: Boolean,
          disabled: Boolean
        },
        setup(props) {
          const ns = useNamespace("select");
          const id = useId();
          const containerKls = computed(() => [
            ns.be("dropdown", "item"),
            ns.is("disabled", unref(isDisabled)),
            ns.is("selected", unref(itemSelected)),
            ns.is("hovering", unref(hover))
          ]);
          const states = reactive({
            index: -1,
            groupDisabled: false,
            visible: true,
            hover: false
          });
          const {
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            hoverItem,
            updateOption
          } = useOption(props, states);
          const { visible, hover } = toRefs(states);
          const vm = getCurrentInstance().proxy;
          select.onOptionCreate(vm);
          onBeforeUnmount(() => {
            const key = vm.value;
            const { selected } = select.states;
            const selectedOptions = select.props.multiple ? selected : [selected];
            const doesSelected = selectedOptions.some((item) => {
              return item.value === vm.value;
            });
            nextTick(() => {
              if (select.states.cachedOptions.get(key) === vm && !doesSelected) {
                select.states.cachedOptions.delete(key);
              }
            });
            select.onOptionDestroy(key, vm);
          });
          function selectOptionClick() {
            if (props.disabled !== true && states.groupDisabled !== true) {
              select.handleOptionSelect(vm);
            }
          }
          return {
            ns,
            id,
            containerKls,
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            hoverItem,
            updateOption,
            visible,
            hover,
            selectOptionClick,
            states
          };
        }
      });
      const _hoisted_1$4 = ["id", "aria-disabled", "aria-selected"];
      function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
        return withDirectives((openBlock(), createElementBlock("li", {
          id: _ctx.id,
          class: normalizeClass(_ctx.containerKls),
          role: "option",
          "aria-disabled": _ctx.isDisabled || void 0,
          "aria-selected": _ctx.itemSelected,
          onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createBaseVNode("span", null, toDisplayString(_ctx.currentLabel), 1)
          ])
        ], 42, _hoisted_1$4)), [
          [vShow, _ctx.visible]
        ]);
      }
      var Option = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$4], ["__file", "option.vue"]]);
      const _sfc_main$6 = /* @__PURE__ */ defineComponent({
        name: "ElSelectDropdown",
        componentName: "ElSelectDropdown",
        setup() {
          const select = inject(selectKey);
          const ns = useNamespace("select");
          const popperClass = computed(() => select.props.popperClass);
          const isMultiple = computed(() => select.props.multiple);
          const isFitInputWidth = computed(() => select.props.fitInputWidth);
          const minWidth = ref("");
          function updateMinWidth() {
            var _a2;
            minWidth.value = `${(_a2 = select.selectRef) == null ? void 0 : _a2.offsetWidth}px`;
          }
          onMounted(() => {
            updateMinWidth();
            useResizeObserver(select.selectRef, updateMinWidth);
          });
          return {
            ns,
            minWidth,
            popperClass,
            isMultiple,
            isFitInputWidth
          };
        }
      });
      function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
          style: normalizeStyle({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
        }, [
          _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.ns.be("dropdown", "header"))
          }, [
            renderSlot(_ctx.$slots, "header")
          ], 2)) : createCommentVNode("v-if", true),
          renderSlot(_ctx.$slots, "default"),
          _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(_ctx.ns.be("dropdown", "footer"))
          }, [
            renderSlot(_ctx.$slots, "footer")
          ], 2)) : createCommentVNode("v-if", true)
        ], 6);
      }
      var ElSelectMenu = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$3], ["__file", "select-dropdown.vue"]]);
      function useInput(handleInput) {
        const isComposing = ref(false);
        const handleCompositionStart = () => {
          isComposing.value = true;
        };
        const handleCompositionUpdate = (event) => {
          const text = event.target.value;
          const lastCharacter = text[text.length - 1] || "";
          isComposing.value = !isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event) => {
          if (isComposing.value) {
            isComposing.value = false;
            if (isFunction$1(handleInput)) {
              handleInput(event);
            }
          }
        };
        return {
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        };
      }
      const MINIMUM_INPUT_WIDTH = 11;
      const useSelect = (props, emit2) => {
        const { t: t2 } = useLocale();
        const contentId = useId();
        const nsSelect = useNamespace("select");
        const nsInput = useNamespace("input");
        const states = reactive({
          inputValue: "",
          options: /* @__PURE__ */ new Map(),
          cachedOptions: /* @__PURE__ */ new Map(),
          disabledOptions: /* @__PURE__ */ new Map(),
          optionValues: [],
          selected: props.multiple ? [] : {},
          selectionWidth: 0,
          calculatorWidth: 0,
          selectedLabel: "",
          hoveringIndex: -1,
          previousQuery: null,
          inputHovering: false,
          menuVisibleOnFocus: false,
          isBeforeHide: false
        });
        useDeprecated({
          from: "suffixTransition",
          replacement: "override style scheme",
          version: "2.3.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
        }, computed(() => props.suffixTransition === false));
        const selectRef = ref(null);
        const selectionRef = ref(null);
        const tooltipRef = ref(null);
        const tagTooltipRef = ref(null);
        const inputRef = ref(null);
        const calculatorRef = ref(null);
        const prefixRef = ref(null);
        const suffixRef = ref(null);
        const menuRef = ref(null);
        const tagMenuRef = ref(null);
        const scrollbarRef = ref(null);
        const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(inputRef, {
          afterFocus() {
            if (props.automaticDropdown && !expanded.value) {
              expanded.value = true;
              states.menuVisibleOnFocus = true;
            }
          },
          beforeBlur(event) {
            var _a2, _b;
            return ((_a2 = tooltipRef.value) == null ? void 0 : _a2.isFocusInsideContent(event)) || ((_b = tagTooltipRef.value) == null ? void 0 : _b.isFocusInsideContent(event));
          },
          afterBlur() {
            expanded.value = false;
            states.menuVisibleOnFocus = false;
          }
        });
        const expanded = ref(false);
        const hoverOption = ref();
        const { form, formItem } = useFormItem();
        const { inputId } = useFormItemInputId(props, {
          formItemContext: formItem
        });
        const selectDisabled = computed(() => props.disabled || (form == null ? void 0 : form.disabled));
        const hasModelValue = computed(() => {
          return props.multiple ? isArray$2(props.modelValue) && props.modelValue.length > 0 : props.modelValue !== void 0 && props.modelValue !== null && props.modelValue !== "";
        });
        const showClose = computed(() => {
          const criteria = props.clearable && !selectDisabled.value && states.inputHovering && hasModelValue.value;
          return criteria;
        });
        const iconComponent = computed(() => props.remote && props.filterable && !props.remoteShowSuffix ? "" : props.suffixIcon);
        const iconReverse = computed(() => nsSelect.is("reverse", iconComponent.value && expanded.value && props.suffixTransition));
        const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
        const validateIcon = computed(() => ValidateComponentsMap[validateState.value]);
        const debounce$1 = computed(() => props.remote ? 300 : 0);
        const emptyText = computed(() => {
          if (props.loading) {
            return props.loadingText || t2("el.select.loading");
          } else {
            if (props.remote && !states.inputValue && states.options.size === 0)
              return false;
            if (props.filterable && states.inputValue && states.options.size > 0 && filteredOptionsCount.value === 0) {
              return props.noMatchText || t2("el.select.noMatch");
            }
            if (states.options.size === 0) {
              return props.noDataText || t2("el.select.noData");
            }
          }
          return null;
        });
        const filteredOptionsCount = computed(() => optionsArray.value.filter((option) => option.visible).length);
        const optionsArray = computed(() => {
          const list = Array.from(states.options.values());
          const newList = [];
          states.optionValues.forEach((item) => {
            const index = list.findIndex((i) => i.value === item);
            if (index > -1) {
              newList.push(list[index]);
            }
          });
          return newList.length >= list.length ? newList : list;
        });
        const cachedOptionsArray = computed(() => Array.from(states.cachedOptions.values()));
        const showNewOption = computed(() => {
          const hasExistingOption = optionsArray.value.filter((option) => {
            return !option.created;
          }).some((option) => {
            return option.currentLabel === states.inputValue;
          });
          return props.filterable && props.allowCreate && states.inputValue !== "" && !hasExistingOption;
        });
        const updateOptions = () => {
          if (props.filterable && isFunction$1(props.filterMethod))
            return;
          if (props.filterable && props.remote && isFunction$1(props.remoteMethod))
            return;
          optionsArray.value.forEach((option) => {
            option.updateOption(states.inputValue);
          });
        };
        const selectSize = useFormSize();
        const collapseTagSize = computed(() => ["small"].includes(selectSize.value) ? "small" : "default");
        const dropdownMenuVisible = computed({
          get() {
            return expanded.value && emptyText.value !== false;
          },
          set(val) {
            expanded.value = val;
          }
        });
        const shouldShowPlaceholder = computed(() => {
          if (isArray$2(props.modelValue)) {
            return props.modelValue.length === 0 && !states.inputValue;
          }
          return props.filterable ? !states.inputValue : true;
        });
        const currentPlaceholder = computed(() => {
          var _a2;
          const _placeholder = (_a2 = props.placeholder) != null ? _a2 : t2("el.select.placeholder");
          return props.multiple || !hasModelValue.value ? _placeholder : states.selectedLabel;
        });
        watch(() => props.modelValue, (val, oldVal) => {
          if (props.multiple) {
            if (props.filterable && !props.reserveKeyword) {
              states.inputValue = "";
              handleQueryChange("");
            }
          }
          setSelected();
          if (!isEqual(val, oldVal) && props.validateEvent) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        }, {
          flush: "post",
          deep: true
        });
        watch(() => expanded.value, (val) => {
          if (val) {
            handleQueryChange(states.inputValue);
          } else {
            states.inputValue = "";
            states.previousQuery = null;
            states.isBeforeHide = true;
          }
          emit2("visible-change", val);
        });
        watch(() => states.options.entries(), () => {
          var _a2;
          if (!isClient)
            return;
          const inputs = ((_a2 = selectRef.value) == null ? void 0 : _a2.querySelectorAll("input")) || [];
          if (!props.filterable && !props.defaultFirstOption && !isUndefined(props.modelValue) || !Array.from(inputs).includes(document.activeElement)) {
            setSelected();
          }
          if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
            checkDefaultFirstOption();
          }
        }, {
          flush: "post"
        });
        watch(() => states.hoveringIndex, (val) => {
          if (isNumber(val) && val > -1) {
            hoverOption.value = optionsArray.value[val] || {};
          } else {
            hoverOption.value = {};
          }
          optionsArray.value.forEach((option) => {
            option.hover = hoverOption.value === option;
          });
        });
        watchEffect(() => {
          if (states.isBeforeHide)
            return;
          updateOptions();
        });
        const handleQueryChange = (val) => {
          if (states.previousQuery === val) {
            return;
          }
          states.previousQuery = val;
          if (props.filterable && isFunction$1(props.filterMethod)) {
            props.filterMethod(val);
          } else if (props.filterable && props.remote && isFunction$1(props.remoteMethod)) {
            props.remoteMethod(val);
          }
          if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
            nextTick(checkDefaultFirstOption);
          } else {
            nextTick(updateHoveringIndex);
          }
        };
        const checkDefaultFirstOption = () => {
          const optionsInDropdown = optionsArray.value.filter((n2) => n2.visible && !n2.disabled && !n2.states.groupDisabled);
          const userCreatedOption = optionsInDropdown.find((n2) => n2.created);
          const firstOriginOption = optionsInDropdown[0];
          states.hoveringIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
        };
        const setSelected = () => {
          if (!props.multiple) {
            const option = getOption(props.modelValue);
            states.selectedLabel = option.currentLabel;
            states.selected = option;
            return;
          } else {
            states.selectedLabel = "";
          }
          const result = [];
          if (isArray$2(props.modelValue)) {
            props.modelValue.forEach((value) => {
              result.push(getOption(value));
            });
          }
          states.selected = result;
        };
        const getOption = (value) => {
          let option;
          const isObjectValue = toRawType(value).toLowerCase() === "object";
          const isNull2 = toRawType(value).toLowerCase() === "null";
          const isUndefined2 = toRawType(value).toLowerCase() === "undefined";
          for (let i = states.cachedOptions.size - 1; i >= 0; i--) {
            const cachedOption = cachedOptionsArray.value[i];
            const isEqualValue = isObjectValue ? getValueKey(cachedOption.value) === getValueKey(value) : cachedOption.value === value;
            if (isEqualValue) {
              option = {
                value,
                currentLabel: cachedOption.currentLabel,
                isDisabled: cachedOption.isDisabled
              };
              break;
            }
          }
          if (option)
            return option;
          const label = isObjectValue ? value.label : !isNull2 && !isUndefined2 ? value : "";
          const newOption = {
            value,
            currentLabel: label
          };
          return newOption;
        };
        const updateHoveringIndex = () => {
          if (!props.multiple) {
            states.hoveringIndex = optionsArray.value.findIndex((item) => {
              return getValueKey(item) === getValueKey(states.selected);
            });
          } else {
            if (states.selected.length > 0) {
              states.hoveringIndex = Math.min(...states.selected.map((selected) => {
                return optionsArray.value.findIndex((item) => {
                  return getValueKey(item) === getValueKey(selected);
                });
              }));
            } else {
              states.hoveringIndex = -1;
            }
          }
        };
        const resetSelectionWidth = () => {
          states.selectionWidth = selectionRef.value.getBoundingClientRect().width;
        };
        const resetCalculatorWidth = () => {
          states.calculatorWidth = calculatorRef.value.getBoundingClientRect().width;
        };
        const updateTooltip = () => {
          var _a2, _b;
          (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        };
        const updateTagTooltip = () => {
          var _a2, _b;
          (_b = (_a2 = tagTooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        };
        const onInputChange = () => {
          handleQueryChange(states.inputValue);
        };
        const onInput = (event) => {
          states.inputValue = event.target.value;
          if (states.inputValue.length > 0 && !expanded.value) {
            expanded.value = true;
          }
          if (props.remote) {
            debouncedOnInputChange();
          } else {
            return onInputChange();
          }
        };
        const debouncedOnInputChange = debounce(() => {
          onInputChange();
        }, debounce$1.value);
        const emitChange = (val) => {
          if (!isEqual(props.modelValue, val)) {
            emit2(CHANGE_EVENT, val);
          }
        };
        const getLastNotDisabledIndex = (value) => findLastIndex(value, (it2) => !states.disabledOptions.has(it2));
        const deletePrevTag = (e2) => {
          if (!props.multiple)
            return;
          if (e2.code === EVENT_CODE.delete)
            return;
          if (e2.target.value.length <= 0) {
            const value = props.modelValue.slice();
            const lastNotDisabledIndex = getLastNotDisabledIndex(value);
            if (lastNotDisabledIndex < 0)
              return;
            value.splice(lastNotDisabledIndex, 1);
            emit2(UPDATE_MODEL_EVENT, value);
            emitChange(value);
          }
        };
        const deleteTag = (event, tag) => {
          const index = states.selected.indexOf(tag);
          if (index > -1 && !selectDisabled.value) {
            const value = props.modelValue.slice();
            value.splice(index, 1);
            emit2(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            emit2("remove-tag", tag.value);
          }
          event.stopPropagation();
          focus();
        };
        const deleteSelected = (event) => {
          event.stopPropagation();
          const value = props.multiple ? [] : "";
          if (!isString$1(value)) {
            for (const item of states.selected) {
              if (item.isDisabled)
                value.push(item.value);
            }
          }
          emit2(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          states.hoveringIndex = -1;
          expanded.value = false;
          emit2("clear");
          focus();
        };
        const handleOptionSelect = (option) => {
          if (props.multiple) {
            const value = (props.modelValue || []).slice();
            const optionIndex = getValueIndex(value, getValueKey(option));
            if (optionIndex > -1) {
              value.splice(optionIndex, 1);
            } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {
              value.push(option.value);
            }
            emit2(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            if (option.created) {
              handleQueryChange("");
            }
            if (props.filterable && !props.reserveKeyword) {
              states.inputValue = "";
            }
          } else {
            emit2(UPDATE_MODEL_EVENT, option.value);
            emitChange(option.value);
            expanded.value = false;
          }
          focus();
          if (expanded.value)
            return;
          nextTick(() => {
            scrollToOption(option);
          });
        };
        const getValueIndex = (arr = [], value) => {
          if (!isObject$1(value))
            return arr.indexOf(value);
          return arr.findIndex((item) => {
            return isEqual(getValueKey(item), getValueKey(value));
          });
        };
        const scrollToOption = (option) => {
          var _a2, _b, _c, _d, _e;
          const targetOption = isArray$2(option) ? option[0] : option;
          let target = null;
          if (targetOption == null ? void 0 : targetOption.value) {
            const options = optionsArray.value.filter((item) => item.value === targetOption.value);
            if (options.length > 0) {
              target = options[0].$el;
            }
          }
          if (tooltipRef.value && target) {
            const menu = (_d = (_c = (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${nsSelect.be("dropdown", "wrap")}`);
            if (menu) {
              scrollIntoView(menu, target);
            }
          }
          (_e = scrollbarRef.value) == null ? void 0 : _e.handleScroll();
        };
        const onOptionCreate = (vm) => {
          states.options.set(vm.value, vm);
          states.cachedOptions.set(vm.value, vm);
          vm.disabled && states.disabledOptions.set(vm.value, vm);
        };
        const onOptionDestroy = (key, vm) => {
          if (states.options.get(key) === vm) {
            states.options.delete(key);
          }
        };
        const {
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        } = useInput((e2) => onInput(e2));
        const popperRef = computed(() => {
          var _a2, _b;
          return (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
        });
        const handleMenuEnter = () => {
          nextTick(() => scrollToOption(states.selected));
        };
        const focus = () => {
          var _a2;
          (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
        };
        const blur = () => {
          var _a2;
          (_a2 = inputRef.value) == null ? void 0 : _a2.blur();
        };
        const handleClearClick = (event) => {
          deleteSelected(event);
        };
        const handleClickOutside = (event) => {
          expanded.value = false;
          if (isFocused.value) {
            const _event2 = new FocusEvent("focus", event);
            handleBlur(_event2);
          }
        };
        const handleEsc = () => {
          if (states.inputValue.length > 0) {
            states.inputValue = "";
          } else {
            expanded.value = false;
          }
        };
        const toggleMenu = () => {
          if (selectDisabled.value)
            return;
          if (states.menuVisibleOnFocus) {
            states.menuVisibleOnFocus = false;
          } else {
            expanded.value = !expanded.value;
          }
        };
        const selectOption = () => {
          if (!expanded.value) {
            toggleMenu();
          } else {
            if (optionsArray.value[states.hoveringIndex]) {
              handleOptionSelect(optionsArray.value[states.hoveringIndex]);
            }
          }
        };
        const getValueKey = (item) => {
          return isObject$1(item.value) ? get(item.value, props.valueKey) : item.value;
        };
        const optionsAllDisabled = computed(() => optionsArray.value.filter((option) => option.visible).every((option) => option.disabled));
        const showTagList = computed(() => {
          if (!props.multiple) {
            return [];
          }
          return props.collapseTags ? states.selected.slice(0, props.maxCollapseTags) : states.selected;
        });
        const collapseTagList = computed(() => {
          if (!props.multiple) {
            return [];
          }
          return props.collapseTags ? states.selected.slice(props.maxCollapseTags) : [];
        });
        const navigateOptions = (direction) => {
          if (!expanded.value) {
            expanded.value = true;
            return;
          }
          if (states.options.size === 0 || filteredOptionsCount.value === 0)
            return;
          if (!optionsAllDisabled.value) {
            if (direction === "next") {
              states.hoveringIndex++;
              if (states.hoveringIndex === states.options.size) {
                states.hoveringIndex = 0;
              }
            } else if (direction === "prev") {
              states.hoveringIndex--;
              if (states.hoveringIndex < 0) {
                states.hoveringIndex = states.options.size - 1;
              }
            }
            const option = optionsArray.value[states.hoveringIndex];
            if (option.disabled === true || option.states.groupDisabled === true || !option.visible) {
              navigateOptions(direction);
            }
            nextTick(() => scrollToOption(hoverOption.value));
          }
        };
        const tagStyle = computed(() => {
          return { maxWidth: `${states.selectionWidth}px` };
        });
        const inputStyle = computed(() => ({
          width: `${Math.max(states.calculatorWidth, MINIMUM_INPUT_WIDTH)}px`
        }));
        if (props.multiple && !isArray$2(props.modelValue)) {
          emit2(UPDATE_MODEL_EVENT, []);
        }
        if (!props.multiple && isArray$2(props.modelValue)) {
          emit2(UPDATE_MODEL_EVENT, "");
        }
        useResizeObserver(selectionRef, resetSelectionWidth);
        useResizeObserver(calculatorRef, resetCalculatorWidth);
        useResizeObserver(menuRef, updateTooltip);
        useResizeObserver(tagMenuRef, updateTagTooltip);
        onMounted(() => {
          setSelected();
        });
        return {
          inputId,
          contentId,
          nsSelect,
          nsInput,
          states,
          isFocused,
          expanded,
          optionsArray,
          hoverOption,
          selectSize,
          filteredOptionsCount,
          resetCalculatorWidth,
          updateTooltip,
          updateTagTooltip,
          debouncedOnInputChange,
          onInput,
          deletePrevTag,
          deleteTag,
          deleteSelected,
          handleOptionSelect,
          scrollToOption,
          hasModelValue,
          shouldShowPlaceholder,
          currentPlaceholder,
          showClose,
          iconComponent,
          iconReverse,
          validateState,
          validateIcon,
          showNewOption,
          updateOptions,
          collapseTagSize,
          setSelected,
          selectDisabled,
          emptyText,
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd,
          onOptionCreate,
          onOptionDestroy,
          handleMenuEnter,
          handleFocus,
          focus,
          blur,
          handleBlur,
          handleClearClick,
          handleClickOutside,
          handleEsc,
          toggleMenu,
          selectOption,
          getValueKey,
          navigateOptions,
          dropdownMenuVisible,
          showTagList,
          collapseTagList,
          tagStyle,
          inputStyle,
          popperRef,
          inputRef,
          tooltipRef,
          tagTooltipRef,
          calculatorRef,
          prefixRef,
          suffixRef,
          selectRef,
          wrapperRef,
          selectionRef,
          scrollbarRef,
          menuRef,
          tagMenuRef
        };
      };
      var ElOptions = /* @__PURE__ */ defineComponent({
        name: "ElOptions",
        setup(_2, { slots }) {
          const select = inject(selectKey);
          let cachedValueList = [];
          return () => {
            var _a2, _b;
            const children = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
            const valueList = [];
            function filterOptions(children2) {
              if (!isArray$2(children2))
                return;
              children2.forEach((item) => {
                var _a22, _b2, _c, _d;
                const name = (_a22 = (item == null ? void 0 : item.type) || {}) == null ? void 0 : _a22.name;
                if (name === "ElOptionGroup") {
                  filterOptions(!isString$1(item.children) && !isArray$2(item.children) && isFunction$1((_b2 = item.children) == null ? void 0 : _b2.default) ? (_c = item.children) == null ? void 0 : _c.default() : item.children);
                } else if (name === "ElOption") {
                  valueList.push((_d = item.props) == null ? void 0 : _d.value);
                } else if (isArray$2(item.children)) {
                  filterOptions(item.children);
                }
              });
            }
            if (children.length) {
              filterOptions((_b = children[0]) == null ? void 0 : _b.children);
            }
            if (!isEqual(valueList, cachedValueList)) {
              cachedValueList = valueList;
              if (select) {
                select.states.optionValues = valueList;
              }
            }
            return children;
          };
        }
      });
      const SelectProps = buildProps({
        name: String,
        id: String,
        modelValue: {
          type: [Array, String, Number, Boolean, Object],
          default: void 0
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        automaticDropdown: Boolean,
        size: useSizeProp,
        effect: {
          type: definePropType(String),
          default: "light"
        },
        disabled: Boolean,
        clearable: Boolean,
        filterable: Boolean,
        allowCreate: Boolean,
        loading: Boolean,
        popperClass: {
          type: String,
          default: ""
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        remote: Boolean,
        loadingText: String,
        noMatchText: String,
        noDataText: String,
        remoteMethod: Function,
        filterMethod: Function,
        multiple: Boolean,
        multipleLimit: {
          type: Number,
          default: 0
        },
        placeholder: {
          type: String
        },
        defaultFirstOption: Boolean,
        reserveKeyword: {
          type: Boolean,
          default: true
        },
        valueKey: {
          type: String,
          default: "value"
        },
        collapseTags: Boolean,
        collapseTagsTooltip: Boolean,
        maxCollapseTags: {
          type: Number,
          default: 1
        },
        teleported: useTooltipContentProps.teleported,
        persistent: {
          type: Boolean,
          default: true
        },
        clearIcon: {
          type: iconPropType,
          default: circle_close_default
        },
        fitInputWidth: Boolean,
        suffixIcon: {
          type: iconPropType,
          default: arrow_down_default
        },
        tagType: { ...tagProps.type, default: "info" },
        validateEvent: {
          type: Boolean,
          default: true
        },
        remoteShowSuffix: Boolean,
        suffixTransition: {
          type: Boolean,
          default: true
        },
        placement: {
          type: definePropType(String),
          values: Ee,
          default: "bottom-start"
        },
        ariaLabel: {
          type: String,
          default: void 0
        }
      });
      const COMPONENT_NAME = "ElSelect";
      const _sfc_main$5 = /* @__PURE__ */ defineComponent({
        name: COMPONENT_NAME,
        componentName: COMPONENT_NAME,
        components: {
          ElInput,
          ElSelectMenu,
          ElOption: Option,
          ElOptions,
          ElTag,
          ElScrollbar,
          ElTooltip,
          ElIcon
        },
        directives: { ClickOutside },
        props: SelectProps,
        emits: [
          UPDATE_MODEL_EVENT,
          CHANGE_EVENT,
          "remove-tag",
          "clear",
          "visible-change",
          "focus",
          "blur"
        ],
        setup(props, { emit: emit2 }) {
          const API = useSelect(props, emit2);
          provide(selectKey, reactive({
            props,
            states: API.states,
            optionsArray: API.optionsArray,
            handleOptionSelect: API.handleOptionSelect,
            onOptionCreate: API.onOptionCreate,
            onOptionDestroy: API.onOptionDestroy,
            selectRef: API.selectRef,
            setSelected: API.setSelected
          }));
          return {
            ...API
          };
        }
      });
      const _hoisted_1$3 = ["id", "disabled", "autocomplete", "readonly", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"];
      const _hoisted_2$2 = ["textContent"];
      function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_tag = resolveComponent("el-tag");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_option = resolveComponent("el-option");
        const _component_el_options = resolveComponent("el-options");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_el_select_menu = resolveComponent("el-select-menu");
        const _directive_click_outside = resolveDirective("click-outside");
        return withDirectives((openBlock(), createElementBlock("div", {
          ref: "selectRef",
          class: normalizeClass([_ctx.nsSelect.b(), _ctx.nsSelect.m(_ctx.selectSize)]),
          onMouseenter: _cache[14] || (_cache[14] = ($event) => _ctx.states.inputHovering = true),
          onMouseleave: _cache[15] || (_cache[15] = ($event) => _ctx.states.inputHovering = false),
          onClick: _cache[16] || (_cache[16] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
        }, [
          createVNode(_component_el_tooltip, {
            ref: "tooltipRef",
            visible: _ctx.dropdownMenuVisible,
            placement: _ctx.placement,
            teleported: _ctx.teleported,
            "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
            "popper-options": _ctx.popperOptions,
            "fallback-placements": ["bottom-start", "top-start", "right", "left"],
            effect: _ctx.effect,
            pure: "",
            trigger: "click",
            transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
            "stop-popper-mouse-event": false,
            "gpu-acceleration": false,
            persistent: _ctx.persistent,
            onBeforeShow: _ctx.handleMenuEnter,
            onHide: _cache[13] || (_cache[13] = ($event) => _ctx.states.isBeforeHide = false)
          }, {
            default: withCtx(() => {
              var _a2;
              return [
                createBaseVNode("div", {
                  ref: "wrapperRef",
                  class: normalizeClass([
                    _ctx.nsSelect.e("wrapper"),
                    _ctx.nsSelect.is("focused", _ctx.isFocused),
                    _ctx.nsSelect.is("hovering", _ctx.states.inputHovering),
                    _ctx.nsSelect.is("filterable", _ctx.filterable),
                    _ctx.nsSelect.is("disabled", _ctx.selectDisabled)
                  ])
                }, [
                  _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    ref: "prefixRef",
                    class: normalizeClass(_ctx.nsSelect.e("prefix"))
                  }, [
                    renderSlot(_ctx.$slots, "prefix")
                  ], 2)) : createCommentVNode("v-if", true),
                  createBaseVNode("div", {
                    ref: "selectionRef",
                    class: normalizeClass([
                      _ctx.nsSelect.e("selection"),
                      _ctx.nsSelect.is("near", _ctx.multiple && !_ctx.$slots.prefix && !!_ctx.states.selected.length)
                    ])
                  }, [
                    _ctx.multiple ? renderSlot(_ctx.$slots, "tag", { key: 0 }, () => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showTagList, (item) => {
                        return openBlock(), createElementBlock("div", {
                          key: _ctx.getValueKey(item),
                          class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                        }, [
                          createVNode(_component_el_tag, {
                            closable: !_ctx.selectDisabled && !item.isDisabled,
                            size: _ctx.collapseTagSize,
                            type: _ctx.tagType,
                            "disable-transitions": "",
                            style: normalizeStyle(_ctx.tagStyle),
                            onClose: ($event) => _ctx.deleteTag($event, item)
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", {
                                class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                              }, toDisplayString(item.currentLabel), 3)
                            ]),
                            _: 2
                          }, 1032, ["closable", "size", "type", "style", "onClose"])
                        ], 2);
                      }), 128)),
                      _ctx.collapseTags && _ctx.states.selected.length > _ctx.maxCollapseTags ? (openBlock(), createBlock(_component_el_tooltip, {
                        key: 0,
                        ref: "tagTooltipRef",
                        disabled: !_ctx.collapseTagsTooltip,
                        "fallback-placements": ["bottom", "top", "right", "left"],
                        effect: _ctx.effect,
                        placement: "bottom",
                        teleported: _ctx.teleported
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                          }, [
                            createVNode(_component_el_tag, {
                              closable: false,
                              size: _ctx.collapseTagSize,
                              type: _ctx.tagType,
                              "disable-transitions": "",
                              style: normalizeStyle(_ctx.tagStyle)
                            }, {
                              default: withCtx(() => [
                                createBaseVNode("span", {
                                  class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                                }, " + " + toDisplayString(_ctx.states.selected.length - _ctx.maxCollapseTags), 3)
                              ]),
                              _: 1
                            }, 8, ["size", "type", "style"])
                          ], 2)
                        ]),
                        content: withCtx(() => [
                          createBaseVNode("div", {
                            ref: "tagMenuRef",
                            class: normalizeClass(_ctx.nsSelect.e("selection"))
                          }, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.collapseTagList, (item) => {
                              return openBlock(), createElementBlock("div", {
                                key: _ctx.getValueKey(item),
                                class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                              }, [
                                createVNode(_component_el_tag, {
                                  class: "in-tooltip",
                                  closable: !_ctx.selectDisabled && !item.isDisabled,
                                  size: _ctx.collapseTagSize,
                                  type: _ctx.tagType,
                                  "disable-transitions": "",
                                  onClose: ($event) => _ctx.deleteTag($event, item)
                                }, {
                                  default: withCtx(() => [
                                    createBaseVNode("span", {
                                      class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                                    }, toDisplayString(item.currentLabel), 3)
                                  ]),
                                  _: 2
                                }, 1032, ["closable", "size", "type", "onClose"])
                              ], 2);
                            }), 128))
                          ], 2)
                        ]),
                        _: 1
                      }, 8, ["disabled", "effect", "teleported"])) : createCommentVNode("v-if", true)
                    ]) : createCommentVNode("v-if", true),
                    !_ctx.selectDisabled ? (openBlock(), createElementBlock("div", {
                      key: 1,
                      class: normalizeClass([
                        _ctx.nsSelect.e("selected-item"),
                        _ctx.nsSelect.e("input-wrapper"),
                        _ctx.nsSelect.is("hidden", !_ctx.filterable)
                      ])
                    }, [
                      withDirectives(createBaseVNode("input", {
                        id: _ctx.inputId,
                        ref: "inputRef",
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.states.inputValue = $event),
                        type: "text",
                        class: normalizeClass([_ctx.nsSelect.e("input"), _ctx.nsSelect.is(_ctx.selectSize)]),
                        disabled: _ctx.selectDisabled,
                        autocomplete: _ctx.autocomplete,
                        style: normalizeStyle(_ctx.inputStyle),
                        role: "combobox",
                        readonly: !_ctx.filterable,
                        spellcheck: "false",
                        "aria-activedescendant": ((_a2 = _ctx.hoverOption) == null ? void 0 : _a2.id) || "",
                        "aria-controls": _ctx.contentId,
                        "aria-expanded": _ctx.dropdownMenuVisible,
                        "aria-label": _ctx.ariaLabel,
                        "aria-autocomplete": "none",
                        "aria-haspopup": "listbox",
                        onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                        onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                        onKeydown: [
                          _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["prevent"]), ["down"])),
                          _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["prevent"]), ["up"])),
                          _cache[5] || (_cache[5] = withKeys((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["esc"])),
                          _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                          _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["stop"]), ["delete"])),
                          _cache[8] || (_cache[8] = withKeys(($event) => _ctx.expanded = false, ["tab"]))
                        ],
                        onCompositionstart: _cache[9] || (_cache[9] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                        onCompositionupdate: _cache[10] || (_cache[10] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                        onCompositionend: _cache[11] || (_cache[11] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                        onInput: _cache[12] || (_cache[12] = (...args) => _ctx.onInput && _ctx.onInput(...args))
                      }, null, 46, _hoisted_1$3), [
                        [vModelText, _ctx.states.inputValue]
                      ]),
                      _ctx.filterable ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        ref: "calculatorRef",
                        "aria-hidden": "true",
                        class: normalizeClass(_ctx.nsSelect.e("input-calculator")),
                        textContent: toDisplayString(_ctx.states.inputValue)
                      }, null, 10, _hoisted_2$2)) : createCommentVNode("v-if", true)
                    ], 2)) : createCommentVNode("v-if", true),
                    _ctx.shouldShowPlaceholder ? (openBlock(), createElementBlock("div", {
                      key: 2,
                      class: normalizeClass([
                        _ctx.nsSelect.e("selected-item"),
                        _ctx.nsSelect.e("placeholder"),
                        _ctx.nsSelect.is("transparent", !_ctx.hasModelValue || _ctx.expanded && !_ctx.states.inputValue)
                      ])
                    }, [
                      createBaseVNode("span", null, toDisplayString(_ctx.currentPlaceholder), 1)
                    ], 2)) : createCommentVNode("v-if", true)
                  ], 2),
                  createBaseVNode("div", {
                    ref: "suffixRef",
                    class: normalizeClass(_ctx.nsSelect.e("suffix"))
                  }, [
                    _ctx.iconComponent && !_ctx.showClose ? (openBlock(), createBlock(_component_el_icon, {
                      key: 0,
                      class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true),
                    _ctx.showClose && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                      key: 1,
                      class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon")]),
                      onClick: _ctx.handleClearClick
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
                    _ctx.validateState && _ctx.validateIcon ? (openBlock(), createBlock(_component_el_icon, {
                      key: 2,
                      class: normalizeClass([_ctx.nsInput.e("icon"), _ctx.nsInput.e("validateIcon")])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.validateIcon)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2)
              ];
            }),
            content: withCtx(() => [
              createVNode(_component_el_select_menu, { ref: "menuRef" }, createSlots({
                default: withCtx(() => [
                  withDirectives(createVNode(_component_el_scrollbar, {
                    id: _ctx.contentId,
                    ref: "scrollbarRef",
                    tag: "ul",
                    "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
                    "view-class": _ctx.nsSelect.be("dropdown", "list"),
                    class: normalizeClass([_ctx.nsSelect.is("empty", _ctx.filteredOptionsCount === 0)]),
                    role: "listbox",
                    "aria-label": _ctx.ariaLabel,
                    "aria-orientation": "vertical"
                  }, {
                    default: withCtx(() => [
                      _ctx.showNewOption ? (openBlock(), createBlock(_component_el_option, {
                        key: 0,
                        value: _ctx.states.inputValue,
                        created: true
                      }, null, 8, ["value"])) : createCommentVNode("v-if", true),
                      createVNode(_component_el_options, null, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "default")
                        ]),
                        _: 3
                      })
                    ]),
                    _: 3
                  }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
                    [vShow, _ctx.states.options.size > 0 && !_ctx.loading]
                  ]),
                  _ctx.loading || _ctx.filteredOptionsCount === 0 ? renderSlot(_ctx.$slots, "empty", { key: 0 }, () => [
                    createBaseVNode("p", {
                      class: normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
                    }, toDisplayString(_ctx.emptyText), 3)
                  ]) : createCommentVNode("v-if", true)
                ]),
                _: 2
              }, [
                _ctx.$slots.header ? {
                  name: "header",
                  fn: withCtx(() => [
                    renderSlot(_ctx.$slots, "header")
                  ])
                } : void 0,
                _ctx.$slots.footer ? {
                  name: "footer",
                  fn: withCtx(() => [
                    renderSlot(_ctx.$slots, "footer")
                  ])
                } : void 0
              ]), 1536)
            ]),
            _: 3
          }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onBeforeShow"])
        ], 34)), [
          [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
        ]);
      }
      var Select = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$2], ["__file", "select.vue"]]);
      const _sfc_main$4 = /* @__PURE__ */ defineComponent({
        name: "ElOptionGroup",
        componentName: "ElOptionGroup",
        props: {
          label: String,
          disabled: Boolean
        },
        setup(props) {
          const ns = useNamespace("select");
          const groupRef = ref(null);
          const instance = getCurrentInstance();
          const children = ref([]);
          provide(selectGroupKey, reactive({
            ...toRefs(props)
          }));
          const visible = computed(() => children.value.some((option) => option.visible === true));
          const flattedChildren = (node) => {
            const children2 = [];
            if (isArray$2(node.children)) {
              node.children.forEach((child) => {
                var _a2;
                if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
                  children2.push(child.component.proxy);
                } else if ((_a2 = child.children) == null ? void 0 : _a2.length) {
                  children2.push(...flattedChildren(child));
                }
              });
            }
            return children2;
          };
          const updateChildren = () => {
            children.value = flattedChildren(instance.subTree);
          };
          onMounted(() => {
            updateChildren();
          });
          useMutationObserver(groupRef, updateChildren, {
            attributes: true,
            subtree: true,
            childList: true
          });
          return {
            groupRef,
            visible,
            ns
          };
        }
      });
      function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
        return withDirectives((openBlock(), createElementBlock("ul", {
          ref: "groupRef",
          class: normalizeClass(_ctx.ns.be("group", "wrap"))
        }, [
          createBaseVNode("li", {
            class: normalizeClass(_ctx.ns.be("group", "title"))
          }, toDisplayString(_ctx.label), 3),
          createBaseVNode("li", null, [
            createBaseVNode("ul", {
              class: normalizeClass(_ctx.ns.b("group"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)
          ])
        ], 2)), [
          [vShow, _ctx.visible]
        ]);
      }
      var OptionGroup = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$1], ["__file", "option-group.vue"]]);
      const ElSelect = withInstall(Select, {
        Option,
        OptionGroup
      });
      const ElOption = withNoopInstall(Option);
      withNoopInstall(OptionGroup);
      const _sfc_main$3 = /* @__PURE__ */ defineComponent({
        name: "ElMessageBox",
        directives: {
          TrapFocus
        },
        components: {
          ElButton,
          ElFocusTrap,
          ElInput,
          ElOverlay,
          ElIcon,
          ...TypeComponents
        },
        inheritAttrs: false,
        props: {
          buttonSize: {
            type: String,
            validator: isValidComponentSize
          },
          modal: {
            type: Boolean,
            default: true
          },
          lockScroll: {
            type: Boolean,
            default: true
          },
          showClose: {
            type: Boolean,
            default: true
          },
          closeOnClickModal: {
            type: Boolean,
            default: true
          },
          closeOnPressEscape: {
            type: Boolean,
            default: true
          },
          closeOnHashChange: {
            type: Boolean,
            default: true
          },
          center: Boolean,
          draggable: Boolean,
          roundButton: {
            default: false,
            type: Boolean
          },
          container: {
            type: String,
            default: "body"
          },
          boxType: {
            type: String,
            default: ""
          }
        },
        emits: ["vanish", "action"],
        setup(props, { emit: emit2 }) {
          const {
            locale,
            zIndex: zIndex2,
            ns,
            size: btnSize
          } = useGlobalComponentSettings("message-box", computed(() => props.buttonSize));
          const { t: t2 } = locale;
          const { nextZIndex } = zIndex2;
          const visible = ref(false);
          const state = reactive({
            autofocus: true,
            beforeClose: null,
            callback: null,
            cancelButtonText: "",
            cancelButtonClass: "",
            confirmButtonText: "",
            confirmButtonClass: "",
            customClass: "",
            customStyle: {},
            dangerouslyUseHTMLString: false,
            distinguishCancelAndClose: false,
            icon: "",
            inputPattern: null,
            inputPlaceholder: "",
            inputType: "text",
            inputValue: null,
            inputValidator: null,
            inputErrorMessage: "",
            message: null,
            modalFade: true,
            modalClass: "",
            showCancelButton: false,
            showConfirmButton: true,
            type: "",
            title: void 0,
            showInput: false,
            action: "",
            confirmButtonLoading: false,
            cancelButtonLoading: false,
            confirmButtonDisabled: false,
            editorErrorMessage: "",
            validateError: false,
            zIndex: nextZIndex()
          });
          const typeClass = computed(() => {
            const type = state.type;
            return { [ns.bm("icon", type)]: type && TypeComponentsMap[type] };
          });
          const contentId = useId();
          const inputId = useId();
          const iconComponent = computed(() => state.icon || TypeComponentsMap[state.type] || "");
          const hasMessage = computed(() => !!state.message);
          const rootRef = ref();
          const headerRef = ref();
          const focusStartRef = ref();
          const inputRef = ref();
          const confirmRef = ref();
          const confirmButtonClasses = computed(() => state.confirmButtonClass);
          watch(() => state.inputValue, async (val) => {
            await nextTick();
            if (props.boxType === "prompt" && val !== null) {
              validate();
            }
          }, { immediate: true });
          watch(() => visible.value, (val) => {
            var _a2, _b;
            if (val) {
              if (props.boxType !== "prompt") {
                if (state.autofocus) {
                  focusStartRef.value = (_b = (_a2 = confirmRef.value) == null ? void 0 : _a2.$el) != null ? _b : rootRef.value;
                } else {
                  focusStartRef.value = rootRef.value;
                }
              }
              state.zIndex = nextZIndex();
            }
            if (props.boxType !== "prompt")
              return;
            if (val) {
              nextTick().then(() => {
                var _a22;
                if (inputRef.value && inputRef.value.$el) {
                  if (state.autofocus) {
                    focusStartRef.value = (_a22 = getInputElement()) != null ? _a22 : rootRef.value;
                  } else {
                    focusStartRef.value = rootRef.value;
                  }
                }
              });
            } else {
              state.editorErrorMessage = "";
              state.validateError = false;
            }
          });
          const draggable = computed(() => props.draggable);
          useDraggable(rootRef, headerRef, draggable);
          onMounted(async () => {
            await nextTick();
            if (props.closeOnHashChange) {
              window.addEventListener("hashchange", doClose);
            }
          });
          onBeforeUnmount(() => {
            if (props.closeOnHashChange) {
              window.removeEventListener("hashchange", doClose);
            }
          });
          function doClose() {
            if (!visible.value)
              return;
            visible.value = false;
            nextTick(() => {
              if (state.action)
                emit2("action", state.action);
            });
          }
          const handleWrapperClick = () => {
            if (props.closeOnClickModal) {
              handleAction(state.distinguishCancelAndClose ? "close" : "cancel");
            }
          };
          const overlayEvent = useSameTarget(handleWrapperClick);
          const handleInputEnter = (e2) => {
            if (state.inputType !== "textarea") {
              e2.preventDefault();
              return handleAction("confirm");
            }
          };
          const handleAction = (action) => {
            var _a2;
            if (props.boxType === "prompt" && action === "confirm" && !validate()) {
              return;
            }
            state.action = action;
            if (state.beforeClose) {
              (_a2 = state.beforeClose) == null ? void 0 : _a2.call(state, action, state, doClose);
            } else {
              doClose();
            }
          };
          const validate = () => {
            if (props.boxType === "prompt") {
              const inputPattern = state.inputPattern;
              if (inputPattern && !inputPattern.test(state.inputValue || "")) {
                state.editorErrorMessage = state.inputErrorMessage || t2("el.messagebox.error");
                state.validateError = true;
                return false;
              }
              const inputValidator = state.inputValidator;
              if (typeof inputValidator === "function") {
                const validateResult = inputValidator(state.inputValue);
                if (validateResult === false) {
                  state.editorErrorMessage = state.inputErrorMessage || t2("el.messagebox.error");
                  state.validateError = true;
                  return false;
                }
                if (typeof validateResult === "string") {
                  state.editorErrorMessage = validateResult;
                  state.validateError = true;
                  return false;
                }
              }
            }
            state.editorErrorMessage = "";
            state.validateError = false;
            return true;
          };
          const getInputElement = () => {
            const inputRefs = inputRef.value.$refs;
            return inputRefs.input || inputRefs.textarea;
          };
          const handleClose = () => {
            handleAction("close");
          };
          const onCloseRequested = () => {
            if (props.closeOnPressEscape) {
              handleClose();
            }
          };
          if (props.lockScroll) {
            useLockscreen(visible);
          }
          return {
            ...toRefs(state),
            ns,
            overlayEvent,
            visible,
            hasMessage,
            typeClass,
            contentId,
            inputId,
            btnSize,
            iconComponent,
            confirmButtonClasses,
            rootRef,
            focusStartRef,
            headerRef,
            inputRef,
            confirmRef,
            doClose,
            handleClose,
            onCloseRequested,
            handleWrapperClick,
            handleInputEnter,
            handleAction,
            t: t2
          };
        }
      });
      const _hoisted_1$2 = ["aria-label", "aria-describedby"];
      const _hoisted_2$1 = ["aria-label"];
      const _hoisted_3 = ["id"];
      function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_icon = resolveComponent("el-icon");
        const _component_close = resolveComponent("close");
        const _component_el_input = resolveComponent("el-input");
        const _component_el_button = resolveComponent("el-button");
        const _component_el_focus_trap = resolveComponent("el-focus-trap");
        const _component_el_overlay = resolveComponent("el-overlay");
        return openBlock(), createBlock(Transition, {
          name: "fade-in-linear",
          onAfterLeave: _cache[11] || (_cache[11] = ($event) => _ctx.$emit("vanish")),
          persisted: ""
        }, {
          default: withCtx(() => [
            withDirectives(createVNode(_component_el_overlay, {
              "z-index": _ctx.zIndex,
              "overlay-class": [_ctx.ns.is("message-box"), _ctx.modalClass],
              mask: _ctx.modal
            }, {
              default: withCtx(() => [
                createBaseVNode("div", {
                  role: "dialog",
                  "aria-label": _ctx.title,
                  "aria-modal": "true",
                  "aria-describedby": !_ctx.showInput ? _ctx.contentId : void 0,
                  class: normalizeClass(`${_ctx.ns.namespace.value}-overlay-message-box`),
                  onClick: _cache[8] || (_cache[8] = (...args) => _ctx.overlayEvent.onClick && _ctx.overlayEvent.onClick(...args)),
                  onMousedown: _cache[9] || (_cache[9] = (...args) => _ctx.overlayEvent.onMousedown && _ctx.overlayEvent.onMousedown(...args)),
                  onMouseup: _cache[10] || (_cache[10] = (...args) => _ctx.overlayEvent.onMouseup && _ctx.overlayEvent.onMouseup(...args))
                }, [
                  createVNode(_component_el_focus_trap, {
                    loop: "",
                    trapped: _ctx.visible,
                    "focus-trap-el": _ctx.rootRef,
                    "focus-start-el": _ctx.focusStartRef,
                    onReleaseRequested: _ctx.onCloseRequested
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("div", {
                        ref: "rootRef",
                        class: normalizeClass([
                          _ctx.ns.b(),
                          _ctx.customClass,
                          _ctx.ns.is("draggable", _ctx.draggable),
                          { [_ctx.ns.m("center")]: _ctx.center }
                        ]),
                        style: normalizeStyle(_ctx.customStyle),
                        tabindex: "-1",
                        onClick: _cache[7] || (_cache[7] = withModifiers(() => {
                        }, ["stop"]))
                      }, [
                        _ctx.title !== null && _ctx.title !== void 0 ? (openBlock(), createElementBlock("div", {
                          key: 0,
                          ref: "headerRef",
                          class: normalizeClass(_ctx.ns.e("header"))
                        }, [
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.ns.e("title"))
                          }, [
                            _ctx.iconComponent && _ctx.center ? (openBlock(), createBlock(_component_el_icon, {
                              key: 0,
                              class: normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                            }, {
                              default: withCtx(() => [
                                (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                              ]),
                              _: 1
                            }, 8, ["class"])) : createCommentVNode("v-if", true),
                            createBaseVNode("span", null, toDisplayString(_ctx.title), 1)
                          ], 2),
                          _ctx.showClose ? (openBlock(), createElementBlock("button", {
                            key: 0,
                            type: "button",
                            class: normalizeClass(_ctx.ns.e("headerbtn")),
                            "aria-label": _ctx.t("el.messagebox.close"),
                            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel")),
                            onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"]))
                          }, [
                            createVNode(_component_el_icon, {
                              class: normalizeClass(_ctx.ns.e("close"))
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_close)
                              ]),
                              _: 1
                            }, 8, ["class"])
                          ], 42, _hoisted_2$1)) : createCommentVNode("v-if", true)
                        ], 2)) : createCommentVNode("v-if", true),
                        createBaseVNode("div", {
                          id: _ctx.contentId,
                          class: normalizeClass(_ctx.ns.e("content"))
                        }, [
                          createBaseVNode("div", {
                            class: normalizeClass(_ctx.ns.e("container"))
                          }, [
                            _ctx.iconComponent && !_ctx.center && _ctx.hasMessage ? (openBlock(), createBlock(_component_el_icon, {
                              key: 0,
                              class: normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                            }, {
                              default: withCtx(() => [
                                (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                              ]),
                              _: 1
                            }, 8, ["class"])) : createCommentVNode("v-if", true),
                            _ctx.hasMessage ? (openBlock(), createElementBlock("div", {
                              key: 1,
                              class: normalizeClass(_ctx.ns.e("message"))
                            }, [
                              renderSlot(_ctx.$slots, "default", {}, () => [
                                !_ctx.dangerouslyUseHTMLString ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                                  key: 0,
                                  for: _ctx.showInput ? _ctx.inputId : void 0
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString(!_ctx.dangerouslyUseHTMLString ? _ctx.message : ""), 1)
                                  ]),
                                  _: 1
                                }, 8, ["for"])) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                                  key: 1,
                                  for: _ctx.showInput ? _ctx.inputId : void 0,
                                  innerHTML: _ctx.message
                                }, null, 8, ["for", "innerHTML"]))
                              ])
                            ], 2)) : createCommentVNode("v-if", true)
                          ], 2),
                          withDirectives(createBaseVNode("div", {
                            class: normalizeClass(_ctx.ns.e("input"))
                          }, [
                            createVNode(_component_el_input, {
                              id: _ctx.inputId,
                              ref: "inputRef",
                              modelValue: _ctx.inputValue,
                              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.inputValue = $event),
                              type: _ctx.inputType,
                              placeholder: _ctx.inputPlaceholder,
                              "aria-invalid": _ctx.validateError,
                              class: normalizeClass({ invalid: _ctx.validateError }),
                              onKeydown: withKeys(_ctx.handleInputEnter, ["enter"])
                            }, null, 8, ["id", "modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                            createBaseVNode("div", {
                              class: normalizeClass(_ctx.ns.e("errormsg")),
                              style: normalizeStyle({
                                visibility: !!_ctx.editorErrorMessage ? "visible" : "hidden"
                              })
                            }, toDisplayString(_ctx.editorErrorMessage), 7)
                          ], 2), [
                            [vShow, _ctx.showInput]
                          ])
                        ], 10, _hoisted_3),
                        createBaseVNode("div", {
                          class: normalizeClass(_ctx.ns.e("btns"))
                        }, [
                          _ctx.showCancelButton ? (openBlock(), createBlock(_component_el_button, {
                            key: 0,
                            loading: _ctx.cancelButtonLoading,
                            class: normalizeClass([_ctx.cancelButtonClass]),
                            round: _ctx.roundButton,
                            size: _ctx.btnSize,
                            onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleAction("cancel")),
                            onKeydown: _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.handleAction("cancel"), ["prevent"]), ["enter"]))
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(_ctx.cancelButtonText || _ctx.t("el.messagebox.cancel")), 1)
                            ]),
                            _: 1
                          }, 8, ["loading", "class", "round", "size"])) : createCommentVNode("v-if", true),
                          withDirectives(createVNode(_component_el_button, {
                            ref: "confirmRef",
                            type: "primary",
                            loading: _ctx.confirmButtonLoading,
                            class: normalizeClass([_ctx.confirmButtonClasses]),
                            round: _ctx.roundButton,
                            disabled: _ctx.confirmButtonDisabled,
                            size: _ctx.btnSize,
                            onClick: _cache[5] || (_cache[5] = ($event) => _ctx.handleAction("confirm")),
                            onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.handleAction("confirm"), ["prevent"]), ["enter"]))
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(_ctx.confirmButtonText || _ctx.t("el.messagebox.confirm")), 1)
                            ]),
                            _: 1
                          }, 8, ["loading", "class", "round", "disabled", "size"]), [
                            [vShow, _ctx.showConfirmButton]
                          ])
                        ], 2)
                      ], 6)
                    ]),
                    _: 3
                  }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
                ], 42, _hoisted_1$2)
              ]),
              _: 3
            }, 8, ["z-index", "overlay-class", "mask"]), [
              [vShow, _ctx.visible]
            ])
          ]),
          _: 3
        });
      }
      var MessageBoxConstructor = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render], ["__file", "index.vue"]]);
      const messageInstance = /* @__PURE__ */ new Map();
      const getAppendToElement = (props) => {
        let appendTo = document.body;
        if (props.appendTo) {
          if (isString$1(props.appendTo)) {
            appendTo = document.querySelector(props.appendTo);
          }
          if (isElement(props.appendTo)) {
            appendTo = props.appendTo;
          }
          if (!isElement(appendTo)) {
            appendTo = document.body;
          }
        }
        return appendTo;
      };
      const initInstance = (props, container, appContext = null) => {
        const vnode = createVNode(MessageBoxConstructor, props, isFunction$1(props.message) || isVNode(props.message) ? {
          default: isFunction$1(props.message) ? props.message : () => props.message
        } : null);
        vnode.appContext = appContext;
        render(vnode, container);
        getAppendToElement(props).appendChild(container.firstElementChild);
        return vnode.component;
      };
      const genContainer = () => {
        return document.createElement("div");
      };
      const showMessage = (options, appContext) => {
        const container = genContainer();
        options.onVanish = () => {
          render(null, container);
          messageInstance.delete(vm);
        };
        options.onAction = (action) => {
          const currentMsg = messageInstance.get(vm);
          let resolve2;
          if (options.showInput) {
            resolve2 = { value: vm.inputValue, action };
          } else {
            resolve2 = action;
          }
          if (options.callback) {
            options.callback(resolve2, instance.proxy);
          } else {
            if (action === "cancel" || action === "close") {
              if (options.distinguishCancelAndClose && action !== "cancel") {
                currentMsg.reject("close");
              } else {
                currentMsg.reject("cancel");
              }
            } else {
              currentMsg.resolve(resolve2);
            }
          }
        };
        const instance = initInstance(options, container, appContext);
        const vm = instance.proxy;
        for (const prop in options) {
          if (hasOwn(options, prop) && !hasOwn(vm.$props, prop)) {
            vm[prop] = options[prop];
          }
        }
        vm.visible = true;
        return vm;
      };
      function MessageBox(options, appContext = null) {
        if (!isClient)
          return Promise.reject();
        let callback;
        if (isString$1(options) || isVNode(options)) {
          options = {
            message: options
          };
        } else {
          callback = options.callback;
        }
        return new Promise((resolve2, reject) => {
          const vm = showMessage(options, appContext != null ? appContext : MessageBox._context);
          messageInstance.set(vm, {
            options,
            callback,
            resolve: resolve2,
            reject
          });
        });
      }
      const MESSAGE_BOX_VARIANTS = ["alert", "confirm", "prompt"];
      const MESSAGE_BOX_DEFAULT_OPTS = {
        alert: { closeOnPressEscape: false, closeOnClickModal: false },
        confirm: { showCancelButton: true },
        prompt: { showCancelButton: true, showInput: true }
      };
      MESSAGE_BOX_VARIANTS.forEach((boxType) => {
        MessageBox[boxType] = messageBoxFactory(boxType);
      });
      function messageBoxFactory(boxType) {
        return (message, title, options, appContext) => {
          let titleOrOpts = "";
          if (isObject$1(title)) {
            options = title;
            titleOrOpts = "";
          } else if (isUndefined(title)) {
            titleOrOpts = "";
          } else {
            titleOrOpts = title;
          }
          return MessageBox(Object.assign({
            title: titleOrOpts,
            message,
            type: "",
            ...MESSAGE_BOX_DEFAULT_OPTS[boxType]
          }, options, {
            boxType
          }), appContext);
        };
      }
      MessageBox.close = () => {
        messageInstance.forEach((_2, vm) => {
          vm.doClose();
        });
        messageInstance.clear();
      };
      MessageBox._context = null;
      const _MessageBox = MessageBox;
      _MessageBox.install = (app) => {
        _MessageBox._context = app._context;
        app.config.globalProperties.$msgbox = _MessageBox;
        app.config.globalProperties.$messageBox = _MessageBox;
        app.config.globalProperties.$alert = _MessageBox.alert;
        app.config.globalProperties.$confirm = _MessageBox.confirm;
        app.config.globalProperties.$prompt = _MessageBox.prompt;
      };
      const ElMessageBox = _MessageBox;
      const _sfc_main$2 = /* @__PURE__ */ defineComponent({
        __name: "contenteditable",
        props: {
          "tag": String,
          "contenteditable": {
            type: [Boolean, String],
            default: true
          },
          "modelValue": String,
          "noHtml": {
            type: Boolean,
            default: true
          },
          "noNl": {
            type: Boolean,
            default: false
          }
        },
        emits: {
          "returned": String,
          "update:modelValue": String
        },
        setup(__props, { emit: emit2 }) {
          const props = __props;
          function replaceAll(str, search, replacement) {
            return str.split(search).join(replacement);
          }
          const element = ref();
          function currentContent() {
            return props.noHtml ? element.value.innerText : element.value.innerHTML;
          }
          function updateContent(newcontent) {
            if (props.noHtml) {
              element.value.innerText = newcontent;
            } else {
              element.value.innerHTML = newcontent;
            }
          }
          function update(event) {
            emit2("update:modelValue", currentContent());
          }
          function onPaste(event) {
            event.preventDefault();
            let text = (event.originalEvent || event).clipboardData.getData("text/plain");
            if (props.noNl) {
              text = replaceAll(text, "\r\n", " ");
              text = replaceAll(text, "\n", " ");
              text = replaceAll(text, "\r", " ");
            }
            window.document.execCommand("insertText", false, text);
          }
          function onKeypress(event) {
            if (event.key == "Enter" && props.noNl) {
              event.preventDefault();
              emit2("returned", currentContent());
            }
          }
          onMounted(() => {
            var _a2;
            updateContent((_a2 = props.modelValue) != null ? _a2 : "");
          });
          watch(() => props.modelValue, (newval, oldval) => {
            if (newval != currentContent()) {
              updateContent(newval != null ? newval : "");
            }
          });
          watch(() => props.noHtml, (newval, oldval) => {
            var _a2;
            updateContent((_a2 = props.modelValue) != null ? _a2 : "");
          });
          watch(() => props.tag, (newval, oldval) => {
            var _a2;
            updateContent((_a2 = props.modelValue) != null ? _a2 : "");
          }, { flush: "post" });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(__props.tag), {
              contenteditable: __props.contenteditable,
              onInput: update,
              onBlur: update,
              onPaste,
              onKeypress,
              ref_key: "element",
              ref: element
            }, null, 40, ["contenteditable"]);
          };
        }
      });
      var lib$1 = { exports: {} };
      var _default$1 = {};
      var lib = { exports: {} };
      var _default = {};
      function getDefaultWhiteList$1() {
        var whiteList = {};
        whiteList["align-content"] = false;
        whiteList["align-items"] = false;
        whiteList["align-self"] = false;
        whiteList["alignment-adjust"] = false;
        whiteList["alignment-baseline"] = false;
        whiteList["all"] = false;
        whiteList["anchor-point"] = false;
        whiteList["animation"] = false;
        whiteList["animation-delay"] = false;
        whiteList["animation-direction"] = false;
        whiteList["animation-duration"] = false;
        whiteList["animation-fill-mode"] = false;
        whiteList["animation-iteration-count"] = false;
        whiteList["animation-name"] = false;
        whiteList["animation-play-state"] = false;
        whiteList["animation-timing-function"] = false;
        whiteList["azimuth"] = false;
        whiteList["backface-visibility"] = false;
        whiteList["background"] = true;
        whiteList["background-attachment"] = true;
        whiteList["background-clip"] = true;
        whiteList["background-color"] = true;
        whiteList["background-image"] = true;
        whiteList["background-origin"] = true;
        whiteList["background-position"] = true;
        whiteList["background-repeat"] = true;
        whiteList["background-size"] = true;
        whiteList["baseline-shift"] = false;
        whiteList["binding"] = false;
        whiteList["bleed"] = false;
        whiteList["bookmark-label"] = false;
        whiteList["bookmark-level"] = false;
        whiteList["bookmark-state"] = false;
        whiteList["border"] = true;
        whiteList["border-bottom"] = true;
        whiteList["border-bottom-color"] = true;
        whiteList["border-bottom-left-radius"] = true;
        whiteList["border-bottom-right-radius"] = true;
        whiteList["border-bottom-style"] = true;
        whiteList["border-bottom-width"] = true;
        whiteList["border-collapse"] = true;
        whiteList["border-color"] = true;
        whiteList["border-image"] = true;
        whiteList["border-image-outset"] = true;
        whiteList["border-image-repeat"] = true;
        whiteList["border-image-slice"] = true;
        whiteList["border-image-source"] = true;
        whiteList["border-image-width"] = true;
        whiteList["border-left"] = true;
        whiteList["border-left-color"] = true;
        whiteList["border-left-style"] = true;
        whiteList["border-left-width"] = true;
        whiteList["border-radius"] = true;
        whiteList["border-right"] = true;
        whiteList["border-right-color"] = true;
        whiteList["border-right-style"] = true;
        whiteList["border-right-width"] = true;
        whiteList["border-spacing"] = true;
        whiteList["border-style"] = true;
        whiteList["border-top"] = true;
        whiteList["border-top-color"] = true;
        whiteList["border-top-left-radius"] = true;
        whiteList["border-top-right-radius"] = true;
        whiteList["border-top-style"] = true;
        whiteList["border-top-width"] = true;
        whiteList["border-width"] = true;
        whiteList["bottom"] = false;
        whiteList["box-decoration-break"] = true;
        whiteList["box-shadow"] = true;
        whiteList["box-sizing"] = true;
        whiteList["box-snap"] = true;
        whiteList["box-suppress"] = true;
        whiteList["break-after"] = true;
        whiteList["break-before"] = true;
        whiteList["break-inside"] = true;
        whiteList["caption-side"] = false;
        whiteList["chains"] = false;
        whiteList["clear"] = true;
        whiteList["clip"] = false;
        whiteList["clip-path"] = false;
        whiteList["clip-rule"] = false;
        whiteList["color"] = true;
        whiteList["color-interpolation-filters"] = true;
        whiteList["column-count"] = false;
        whiteList["column-fill"] = false;
        whiteList["column-gap"] = false;
        whiteList["column-rule"] = false;
        whiteList["column-rule-color"] = false;
        whiteList["column-rule-style"] = false;
        whiteList["column-rule-width"] = false;
        whiteList["column-span"] = false;
        whiteList["column-width"] = false;
        whiteList["columns"] = false;
        whiteList["contain"] = false;
        whiteList["content"] = false;
        whiteList["counter-increment"] = false;
        whiteList["counter-reset"] = false;
        whiteList["counter-set"] = false;
        whiteList["crop"] = false;
        whiteList["cue"] = false;
        whiteList["cue-after"] = false;
        whiteList["cue-before"] = false;
        whiteList["cursor"] = false;
        whiteList["direction"] = false;
        whiteList["display"] = true;
        whiteList["display-inside"] = true;
        whiteList["display-list"] = true;
        whiteList["display-outside"] = true;
        whiteList["dominant-baseline"] = false;
        whiteList["elevation"] = false;
        whiteList["empty-cells"] = false;
        whiteList["filter"] = false;
        whiteList["flex"] = false;
        whiteList["flex-basis"] = false;
        whiteList["flex-direction"] = false;
        whiteList["flex-flow"] = false;
        whiteList["flex-grow"] = false;
        whiteList["flex-shrink"] = false;
        whiteList["flex-wrap"] = false;
        whiteList["float"] = false;
        whiteList["float-offset"] = false;
        whiteList["flood-color"] = false;
        whiteList["flood-opacity"] = false;
        whiteList["flow-from"] = false;
        whiteList["flow-into"] = false;
        whiteList["font"] = true;
        whiteList["font-family"] = true;
        whiteList["font-feature-settings"] = true;
        whiteList["font-kerning"] = true;
        whiteList["font-language-override"] = true;
        whiteList["font-size"] = true;
        whiteList["font-size-adjust"] = true;
        whiteList["font-stretch"] = true;
        whiteList["font-style"] = true;
        whiteList["font-synthesis"] = true;
        whiteList["font-variant"] = true;
        whiteList["font-variant-alternates"] = true;
        whiteList["font-variant-caps"] = true;
        whiteList["font-variant-east-asian"] = true;
        whiteList["font-variant-ligatures"] = true;
        whiteList["font-variant-numeric"] = true;
        whiteList["font-variant-position"] = true;
        whiteList["font-weight"] = true;
        whiteList["grid"] = false;
        whiteList["grid-area"] = false;
        whiteList["grid-auto-columns"] = false;
        whiteList["grid-auto-flow"] = false;
        whiteList["grid-auto-rows"] = false;
        whiteList["grid-column"] = false;
        whiteList["grid-column-end"] = false;
        whiteList["grid-column-start"] = false;
        whiteList["grid-row"] = false;
        whiteList["grid-row-end"] = false;
        whiteList["grid-row-start"] = false;
        whiteList["grid-template"] = false;
        whiteList["grid-template-areas"] = false;
        whiteList["grid-template-columns"] = false;
        whiteList["grid-template-rows"] = false;
        whiteList["hanging-punctuation"] = false;
        whiteList["height"] = true;
        whiteList["hyphens"] = false;
        whiteList["icon"] = false;
        whiteList["image-orientation"] = false;
        whiteList["image-resolution"] = false;
        whiteList["ime-mode"] = false;
        whiteList["initial-letters"] = false;
        whiteList["inline-box-align"] = false;
        whiteList["justify-content"] = false;
        whiteList["justify-items"] = false;
        whiteList["justify-self"] = false;
        whiteList["left"] = false;
        whiteList["letter-spacing"] = true;
        whiteList["lighting-color"] = true;
        whiteList["line-box-contain"] = false;
        whiteList["line-break"] = false;
        whiteList["line-grid"] = false;
        whiteList["line-height"] = false;
        whiteList["line-snap"] = false;
        whiteList["line-stacking"] = false;
        whiteList["line-stacking-ruby"] = false;
        whiteList["line-stacking-shift"] = false;
        whiteList["line-stacking-strategy"] = false;
        whiteList["list-style"] = true;
        whiteList["list-style-image"] = true;
        whiteList["list-style-position"] = true;
        whiteList["list-style-type"] = true;
        whiteList["margin"] = true;
        whiteList["margin-bottom"] = true;
        whiteList["margin-left"] = true;
        whiteList["margin-right"] = true;
        whiteList["margin-top"] = true;
        whiteList["marker-offset"] = false;
        whiteList["marker-side"] = false;
        whiteList["marks"] = false;
        whiteList["mask"] = false;
        whiteList["mask-box"] = false;
        whiteList["mask-box-outset"] = false;
        whiteList["mask-box-repeat"] = false;
        whiteList["mask-box-slice"] = false;
        whiteList["mask-box-source"] = false;
        whiteList["mask-box-width"] = false;
        whiteList["mask-clip"] = false;
        whiteList["mask-image"] = false;
        whiteList["mask-origin"] = false;
        whiteList["mask-position"] = false;
        whiteList["mask-repeat"] = false;
        whiteList["mask-size"] = false;
        whiteList["mask-source-type"] = false;
        whiteList["mask-type"] = false;
        whiteList["max-height"] = true;
        whiteList["max-lines"] = false;
        whiteList["max-width"] = true;
        whiteList["min-height"] = true;
        whiteList["min-width"] = true;
        whiteList["move-to"] = false;
        whiteList["nav-down"] = false;
        whiteList["nav-index"] = false;
        whiteList["nav-left"] = false;
        whiteList["nav-right"] = false;
        whiteList["nav-up"] = false;
        whiteList["object-fit"] = false;
        whiteList["object-position"] = false;
        whiteList["opacity"] = false;
        whiteList["order"] = false;
        whiteList["orphans"] = false;
        whiteList["outline"] = false;
        whiteList["outline-color"] = false;
        whiteList["outline-offset"] = false;
        whiteList["outline-style"] = false;
        whiteList["outline-width"] = false;
        whiteList["overflow"] = false;
        whiteList["overflow-wrap"] = false;
        whiteList["overflow-x"] = false;
        whiteList["overflow-y"] = false;
        whiteList["padding"] = true;
        whiteList["padding-bottom"] = true;
        whiteList["padding-left"] = true;
        whiteList["padding-right"] = true;
        whiteList["padding-top"] = true;
        whiteList["page"] = false;
        whiteList["page-break-after"] = false;
        whiteList["page-break-before"] = false;
        whiteList["page-break-inside"] = false;
        whiteList["page-policy"] = false;
        whiteList["pause"] = false;
        whiteList["pause-after"] = false;
        whiteList["pause-before"] = false;
        whiteList["perspective"] = false;
        whiteList["perspective-origin"] = false;
        whiteList["pitch"] = false;
        whiteList["pitch-range"] = false;
        whiteList["play-during"] = false;
        whiteList["position"] = false;
        whiteList["presentation-level"] = false;
        whiteList["quotes"] = false;
        whiteList["region-fragment"] = false;
        whiteList["resize"] = false;
        whiteList["rest"] = false;
        whiteList["rest-after"] = false;
        whiteList["rest-before"] = false;
        whiteList["richness"] = false;
        whiteList["right"] = false;
        whiteList["rotation"] = false;
        whiteList["rotation-point"] = false;
        whiteList["ruby-align"] = false;
        whiteList["ruby-merge"] = false;
        whiteList["ruby-position"] = false;
        whiteList["shape-image-threshold"] = false;
        whiteList["shape-outside"] = false;
        whiteList["shape-margin"] = false;
        whiteList["size"] = false;
        whiteList["speak"] = false;
        whiteList["speak-as"] = false;
        whiteList["speak-header"] = false;
        whiteList["speak-numeral"] = false;
        whiteList["speak-punctuation"] = false;
        whiteList["speech-rate"] = false;
        whiteList["stress"] = false;
        whiteList["string-set"] = false;
        whiteList["tab-size"] = false;
        whiteList["table-layout"] = false;
        whiteList["text-align"] = true;
        whiteList["text-align-last"] = true;
        whiteList["text-combine-upright"] = true;
        whiteList["text-decoration"] = true;
        whiteList["text-decoration-color"] = true;
        whiteList["text-decoration-line"] = true;
        whiteList["text-decoration-skip"] = true;
        whiteList["text-decoration-style"] = true;
        whiteList["text-emphasis"] = true;
        whiteList["text-emphasis-color"] = true;
        whiteList["text-emphasis-position"] = true;
        whiteList["text-emphasis-style"] = true;
        whiteList["text-height"] = true;
        whiteList["text-indent"] = true;
        whiteList["text-justify"] = true;
        whiteList["text-orientation"] = true;
        whiteList["text-overflow"] = true;
        whiteList["text-shadow"] = true;
        whiteList["text-space-collapse"] = true;
        whiteList["text-transform"] = true;
        whiteList["text-underline-position"] = true;
        whiteList["text-wrap"] = true;
        whiteList["top"] = false;
        whiteList["transform"] = false;
        whiteList["transform-origin"] = false;
        whiteList["transform-style"] = false;
        whiteList["transition"] = false;
        whiteList["transition-delay"] = false;
        whiteList["transition-duration"] = false;
        whiteList["transition-property"] = false;
        whiteList["transition-timing-function"] = false;
        whiteList["unicode-bidi"] = false;
        whiteList["vertical-align"] = false;
        whiteList["visibility"] = false;
        whiteList["voice-balance"] = false;
        whiteList["voice-duration"] = false;
        whiteList["voice-family"] = false;
        whiteList["voice-pitch"] = false;
        whiteList["voice-range"] = false;
        whiteList["voice-rate"] = false;
        whiteList["voice-stress"] = false;
        whiteList["voice-volume"] = false;
        whiteList["volume"] = false;
        whiteList["white-space"] = false;
        whiteList["widows"] = false;
        whiteList["width"] = true;
        whiteList["will-change"] = false;
        whiteList["word-break"] = true;
        whiteList["word-spacing"] = true;
        whiteList["word-wrap"] = true;
        whiteList["wrap-flow"] = false;
        whiteList["wrap-through"] = false;
        whiteList["writing-mode"] = false;
        whiteList["z-index"] = false;
        return whiteList;
      }
      function onAttr(name, value, options) {
      }
      function onIgnoreAttr(name, value, options) {
      }
      var REGEXP_URL_JAVASCRIPT = /javascript\s*\:/img;
      function safeAttrValue$1(name, value) {
        if (REGEXP_URL_JAVASCRIPT.test(value))
          return "";
        return value;
      }
      _default.whiteList = getDefaultWhiteList$1();
      _default.getDefaultWhiteList = getDefaultWhiteList$1;
      _default.onAttr = onAttr;
      _default.onIgnoreAttr = onIgnoreAttr;
      _default.safeAttrValue = safeAttrValue$1;
      var util$1 = {
        indexOf: function(arr, item) {
          var i, j;
          if (Array.prototype.indexOf) {
            return arr.indexOf(item);
          }
          for (i = 0, j = arr.length; i < j; i++) {
            if (arr[i] === item) {
              return i;
            }
          }
          return -1;
        },
        forEach: function(arr, fn2, scope) {
          var i, j;
          if (Array.prototype.forEach) {
            return arr.forEach(fn2, scope);
          }
          for (i = 0, j = arr.length; i < j; i++) {
            fn2.call(scope, arr[i], i, arr);
          }
        },
        trim: function(str) {
          if (String.prototype.trim) {
            return str.trim();
          }
          return str.replace(/(^\s*)|(\s*$)/g, "");
        },
        trimRight: function(str) {
          if (String.prototype.trimRight) {
            return str.trimRight();
          }
          return str.replace(/(\s*$)/g, "");
        }
      };
      var _$3 = util$1;
      function parseStyle$1(css2, onAttr2) {
        css2 = _$3.trimRight(css2);
        if (css2[css2.length - 1] !== ";")
          css2 += ";";
        var cssLength = css2.length;
        var isParenthesisOpen = false;
        var lastPos = 0;
        var i = 0;
        var retCSS = "";
        function addNewAttr() {
          if (!isParenthesisOpen) {
            var source = _$3.trim(css2.slice(lastPos, i));
            var j2 = source.indexOf(":");
            if (j2 !== -1) {
              var name = _$3.trim(source.slice(0, j2));
              var value = _$3.trim(source.slice(j2 + 1));
              if (name) {
                var ret = onAttr2(lastPos, retCSS.length, name, value, source);
                if (ret)
                  retCSS += ret + "; ";
              }
            }
          }
          lastPos = i + 1;
        }
        for (; i < cssLength; i++) {
          var c = css2[i];
          if (c === "/" && css2[i + 1] === "*") {
            var j = css2.indexOf("*/", i + 2);
            if (j === -1)
              break;
            i = j + 1;
            lastPos = i + 1;
            isParenthesisOpen = false;
          } else if (c === "(") {
            isParenthesisOpen = true;
          } else if (c === ")") {
            isParenthesisOpen = false;
          } else if (c === ";") {
            if (isParenthesisOpen)
              ;
            else {
              addNewAttr();
            }
          } else if (c === "\n") {
            addNewAttr();
          }
        }
        return _$3.trim(retCSS);
      }
      var parser$2 = parseStyle$1;
      var DEFAULT$1 = _default;
      var parseStyle = parser$2;
      function isNull$1(obj) {
        return obj === void 0 || obj === null;
      }
      function shallowCopyObject$1(obj) {
        var ret = {};
        for (var i in obj) {
          ret[i] = obj[i];
        }
        return ret;
      }
      function FilterCSS$2(options) {
        options = shallowCopyObject$1(options || {});
        options.whiteList = options.whiteList || DEFAULT$1.whiteList;
        options.onAttr = options.onAttr || DEFAULT$1.onAttr;
        options.onIgnoreAttr = options.onIgnoreAttr || DEFAULT$1.onIgnoreAttr;
        options.safeAttrValue = options.safeAttrValue || DEFAULT$1.safeAttrValue;
        this.options = options;
      }
      FilterCSS$2.prototype.process = function(css2) {
        css2 = css2 || "";
        css2 = css2.toString();
        if (!css2)
          return "";
        var me2 = this;
        var options = me2.options;
        var whiteList = options.whiteList;
        var onAttr2 = options.onAttr;
        var onIgnoreAttr2 = options.onIgnoreAttr;
        var safeAttrValue2 = options.safeAttrValue;
        var retCSS = parseStyle(css2, function(sourcePosition, position, name, value, source) {
          var check = whiteList[name];
          var isWhite = false;
          if (check === true)
            isWhite = check;
          else if (typeof check === "function")
            isWhite = check(value);
          else if (check instanceof RegExp)
            isWhite = check.test(value);
          if (isWhite !== true)
            isWhite = false;
          value = safeAttrValue2(name, value);
          if (!value)
            return;
          var opts = {
            position,
            sourcePosition,
            source,
            isWhite
          };
          if (isWhite) {
            var ret = onAttr2(name, value, opts);
            if (isNull$1(ret)) {
              return name + ":" + value;
            } else {
              return ret;
            }
          } else {
            var ret = onIgnoreAttr2(name, value, opts);
            if (!isNull$1(ret)) {
              return ret;
            }
          }
        });
        return retCSS;
      };
      var css = FilterCSS$2;
      (function(module2, exports2) {
        var DEFAULT2 = _default;
        var FilterCSS2 = css;
        function filterCSS(html, options) {
          var xss2 = new FilterCSS2(options);
          return xss2.process(html);
        }
        exports2 = module2.exports = filterCSS;
        exports2.FilterCSS = FilterCSS2;
        for (var i in DEFAULT2)
          exports2[i] = DEFAULT2[i];
        if (typeof window !== "undefined") {
          window.filterCSS = module2.exports;
        }
      })(lib, lib.exports);
      var libExports$1 = lib.exports;
      var util = {
        indexOf: function(arr, item) {
          var i, j;
          if (Array.prototype.indexOf) {
            return arr.indexOf(item);
          }
          for (i = 0, j = arr.length; i < j; i++) {
            if (arr[i] === item) {
              return i;
            }
          }
          return -1;
        },
        forEach: function(arr, fn2, scope) {
          var i, j;
          if (Array.prototype.forEach) {
            return arr.forEach(fn2, scope);
          }
          for (i = 0, j = arr.length; i < j; i++) {
            fn2.call(scope, arr[i], i, arr);
          }
        },
        trim: function(str) {
          if (String.prototype.trim) {
            return str.trim();
          }
          return str.replace(/(^\s*)|(\s*$)/g, "");
        },
        spaceIndex: function(str) {
          var reg = /\s|\n|\t/;
          var match = reg.exec(str);
          return match ? match.index : -1;
        }
      };
      var FilterCSS$1 = libExports$1.FilterCSS;
      var getDefaultCSSWhiteList = libExports$1.getDefaultWhiteList;
      var _$2 = util;
      function getDefaultWhiteList() {
        return {
          a: ["target", "href", "title"],
          abbr: ["title"],
          address: [],
          area: ["shape", "coords", "href", "alt"],
          article: [],
          aside: [],
          audio: [
            "autoplay",
            "controls",
            "crossorigin",
            "loop",
            "muted",
            "preload",
            "src"
          ],
          b: [],
          bdi: ["dir"],
          bdo: ["dir"],
          big: [],
          blockquote: ["cite"],
          br: [],
          caption: [],
          center: [],
          cite: [],
          code: [],
          col: ["align", "valign", "span", "width"],
          colgroup: ["align", "valign", "span", "width"],
          dd: [],
          del: ["datetime"],
          details: ["open"],
          div: [],
          dl: [],
          dt: [],
          em: [],
          figcaption: [],
          figure: [],
          font: ["color", "size", "face"],
          footer: [],
          h1: [],
          h2: [],
          h3: [],
          h4: [],
          h5: [],
          h6: [],
          header: [],
          hr: [],
          i: [],
          img: ["src", "alt", "title", "width", "height"],
          ins: ["datetime"],
          li: [],
          mark: [],
          nav: [],
          ol: [],
          p: [],
          pre: [],
          s: [],
          section: [],
          small: [],
          span: [],
          sub: [],
          summary: [],
          sup: [],
          strong: [],
          strike: [],
          table: ["width", "border", "align", "valign"],
          tbody: ["align", "valign"],
          td: ["width", "rowspan", "colspan", "align", "valign"],
          tfoot: ["align", "valign"],
          th: ["width", "rowspan", "colspan", "align", "valign"],
          thead: ["align", "valign"],
          tr: ["rowspan", "align", "valign"],
          tt: [],
          u: [],
          ul: [],
          video: [
            "autoplay",
            "controls",
            "crossorigin",
            "loop",
            "muted",
            "playsinline",
            "poster",
            "preload",
            "src",
            "height",
            "width"
          ]
        };
      }
      var defaultCSSFilter = new FilterCSS$1();
      function onTag(tag, html, options) {
      }
      function onIgnoreTag(tag, html, options) {
      }
      function onTagAttr(tag, name, value) {
      }
      function onIgnoreTagAttr(tag, name, value) {
      }
      function escapeHtml(html) {
        return html.replace(REGEXP_LT, "&lt;").replace(REGEXP_GT, "&gt;");
      }
      function safeAttrValue(tag, name, value, cssFilter) {
        value = friendlyAttrValue(value);
        if (name === "href" || name === "src") {
          value = _$2.trim(value);
          if (value === "#")
            return "#";
          if (!(value.substr(0, 7) === "http://" || value.substr(0, 8) === "https://" || value.substr(0, 7) === "mailto:" || value.substr(0, 4) === "tel:" || value.substr(0, 11) === "data:image/" || value.substr(0, 6) === "ftp://" || value.substr(0, 2) === "./" || value.substr(0, 3) === "../" || value[0] === "#" || value[0] === "/")) {
            return "";
          }
        } else if (name === "background") {
          REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
          if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
            return "";
          }
        } else if (name === "style") {
          REGEXP_DEFAULT_ON_TAG_ATTR_7.lastIndex = 0;
          if (REGEXP_DEFAULT_ON_TAG_ATTR_7.test(value)) {
            return "";
          }
          REGEXP_DEFAULT_ON_TAG_ATTR_8.lastIndex = 0;
          if (REGEXP_DEFAULT_ON_TAG_ATTR_8.test(value)) {
            REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
            if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
              return "";
            }
          }
          if (cssFilter !== false) {
            cssFilter = cssFilter || defaultCSSFilter;
            value = cssFilter.process(value);
          }
        }
        value = escapeAttrValue(value);
        return value;
      }
      var REGEXP_LT = /</g;
      var REGEXP_GT = />/g;
      var REGEXP_QUOTE = /"/g;
      var REGEXP_QUOTE_2 = /&quot;/g;
      var REGEXP_ATTR_VALUE_1 = /&#([a-zA-Z0-9]*);?/gim;
      var REGEXP_ATTR_VALUE_COLON = /&colon;?/gim;
      var REGEXP_ATTR_VALUE_NEWLINE = /&newline;?/gim;
      var REGEXP_DEFAULT_ON_TAG_ATTR_4 = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi;
      var REGEXP_DEFAULT_ON_TAG_ATTR_7 = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi;
      var REGEXP_DEFAULT_ON_TAG_ATTR_8 = /u\s*r\s*l\s*\(.*/gi;
      function escapeQuote(str) {
        return str.replace(REGEXP_QUOTE, "&quot;");
      }
      function unescapeQuote(str) {
        return str.replace(REGEXP_QUOTE_2, '"');
      }
      function escapeHtmlEntities(str) {
        return str.replace(REGEXP_ATTR_VALUE_1, function replaceUnicode(str2, code) {
          return code[0] === "x" || code[0] === "X" ? String.fromCharCode(parseInt(code.substr(1), 16)) : String.fromCharCode(parseInt(code, 10));
        });
      }
      function escapeDangerHtml5Entities(str) {
        return str.replace(REGEXP_ATTR_VALUE_COLON, ":").replace(REGEXP_ATTR_VALUE_NEWLINE, " ");
      }
      function clearNonPrintableCharacter(str) {
        var str2 = "";
        for (var i = 0, len = str.length; i < len; i++) {
          str2 += str.charCodeAt(i) < 32 ? " " : str.charAt(i);
        }
        return _$2.trim(str2);
      }
      function friendlyAttrValue(str) {
        str = unescapeQuote(str);
        str = escapeHtmlEntities(str);
        str = escapeDangerHtml5Entities(str);
        str = clearNonPrintableCharacter(str);
        return str;
      }
      function escapeAttrValue(str) {
        str = escapeQuote(str);
        str = escapeHtml(str);
        return str;
      }
      function onIgnoreTagStripAll() {
        return "";
      }
      function StripTagBody(tags, next) {
        if (typeof next !== "function") {
          next = function() {
          };
        }
        var isRemoveAllTag = !Array.isArray(tags);
        function isRemoveTag(tag) {
          if (isRemoveAllTag)
            return true;
          return _$2.indexOf(tags, tag) !== -1;
        }
        var removeList = [];
        var posStart = false;
        return {
          onIgnoreTag: function(tag, html, options) {
            if (isRemoveTag(tag)) {
              if (options.isClosing) {
                var ret = "[/removed]";
                var end = options.position + ret.length;
                removeList.push([
                  posStart !== false ? posStart : options.position,
                  end
                ]);
                posStart = false;
                return ret;
              } else {
                if (!posStart) {
                  posStart = options.position;
                }
                return "[removed]";
              }
            } else {
              return next(tag, html, options);
            }
          },
          remove: function(html) {
            var rethtml = "";
            var lastPos = 0;
            _$2.forEach(removeList, function(pos) {
              rethtml += html.slice(lastPos, pos[0]);
              lastPos = pos[1];
            });
            rethtml += html.slice(lastPos);
            return rethtml;
          }
        };
      }
      function stripCommentTag(html) {
        var retHtml = "";
        var lastPos = 0;
        while (lastPos < html.length) {
          var i = html.indexOf("<!--", lastPos);
          if (i === -1) {
            retHtml += html.slice(lastPos);
            break;
          }
          retHtml += html.slice(lastPos, i);
          var j = html.indexOf("-->", i);
          if (j === -1) {
            break;
          }
          lastPos = j + 3;
        }
        return retHtml;
      }
      function stripBlankChar(html) {
        var chars = html.split("");
        chars = chars.filter(function(char) {
          var c = char.charCodeAt(0);
          if (c === 127)
            return false;
          if (c <= 31) {
            if (c === 10 || c === 13)
              return true;
            return false;
          }
          return true;
        });
        return chars.join("");
      }
      _default$1.whiteList = getDefaultWhiteList();
      _default$1.getDefaultWhiteList = getDefaultWhiteList;
      _default$1.onTag = onTag;
      _default$1.onIgnoreTag = onIgnoreTag;
      _default$1.onTagAttr = onTagAttr;
      _default$1.onIgnoreTagAttr = onIgnoreTagAttr;
      _default$1.safeAttrValue = safeAttrValue;
      _default$1.escapeHtml = escapeHtml;
      _default$1.escapeQuote = escapeQuote;
      _default$1.unescapeQuote = unescapeQuote;
      _default$1.escapeHtmlEntities = escapeHtmlEntities;
      _default$1.escapeDangerHtml5Entities = escapeDangerHtml5Entities;
      _default$1.clearNonPrintableCharacter = clearNonPrintableCharacter;
      _default$1.friendlyAttrValue = friendlyAttrValue;
      _default$1.escapeAttrValue = escapeAttrValue;
      _default$1.onIgnoreTagStripAll = onIgnoreTagStripAll;
      _default$1.StripTagBody = StripTagBody;
      _default$1.stripCommentTag = stripCommentTag;
      _default$1.stripBlankChar = stripBlankChar;
      _default$1.cssFilter = defaultCSSFilter;
      _default$1.getDefaultCSSWhiteList = getDefaultCSSWhiteList;
      var parser$1 = {};
      var _$1 = util;
      function getTagName(html) {
        var i = _$1.spaceIndex(html);
        var tagName;
        if (i === -1) {
          tagName = html.slice(1, -1);
        } else {
          tagName = html.slice(1, i + 1);
        }
        tagName = _$1.trim(tagName).toLowerCase();
        if (tagName.slice(0, 1) === "/")
          tagName = tagName.slice(1);
        if (tagName.slice(-1) === "/")
          tagName = tagName.slice(0, -1);
        return tagName;
      }
      function isClosing(html) {
        return html.slice(0, 2) === "</";
      }
      function parseTag$1(html, onTag2, escapeHtml2) {
        var rethtml = "";
        var lastPos = 0;
        var tagStart = false;
        var quoteStart = false;
        var currentPos = 0;
        var len = html.length;
        var currentTagName = "";
        var currentHtml = "";
        chariterator:
          for (currentPos = 0; currentPos < len; currentPos++) {
            var c = html.charAt(currentPos);
            if (tagStart === false) {
              if (c === "<") {
                tagStart = currentPos;
                continue;
              }
            } else {
              if (quoteStart === false) {
                if (c === "<") {
                  rethtml += escapeHtml2(html.slice(lastPos, currentPos));
                  tagStart = currentPos;
                  lastPos = currentPos;
                  continue;
                }
                if (c === ">" || currentPos === len - 1) {
                  rethtml += escapeHtml2(html.slice(lastPos, tagStart));
                  currentHtml = html.slice(tagStart, currentPos + 1);
                  currentTagName = getTagName(currentHtml);
                  rethtml += onTag2(
                    tagStart,
                    rethtml.length,
                    currentTagName,
                    currentHtml,
                    isClosing(currentHtml)
                  );
                  lastPos = currentPos + 1;
                  tagStart = false;
                  continue;
                }
                if (c === '"' || c === "'") {
                  var i = 1;
                  var ic = html.charAt(currentPos - i);
                  while (ic.trim() === "" || ic === "=") {
                    if (ic === "=") {
                      quoteStart = c;
                      continue chariterator;
                    }
                    ic = html.charAt(currentPos - ++i);
                  }
                }
              } else {
                if (c === quoteStart) {
                  quoteStart = false;
                  continue;
                }
              }
            }
          }
        if (lastPos < len) {
          rethtml += escapeHtml2(html.substr(lastPos));
        }
        return rethtml;
      }
      var REGEXP_ILLEGAL_ATTR_NAME = /[^a-zA-Z0-9\\_:.-]/gim;
      function parseAttr$1(html, onAttr2) {
        var lastPos = 0;
        var lastMarkPos = 0;
        var retAttrs = [];
        var tmpName = false;
        var len = html.length;
        function addAttr(name, value) {
          name = _$1.trim(name);
          name = name.replace(REGEXP_ILLEGAL_ATTR_NAME, "").toLowerCase();
          if (name.length < 1)
            return;
          var ret = onAttr2(name, value || "");
          if (ret)
            retAttrs.push(ret);
        }
        for (var i = 0; i < len; i++) {
          var c = html.charAt(i);
          var v, j;
          if (tmpName === false && c === "=") {
            tmpName = html.slice(lastPos, i);
            lastPos = i + 1;
            lastMarkPos = html.charAt(lastPos) === '"' || html.charAt(lastPos) === "'" ? lastPos : findNextQuotationMark(html, i + 1);
            continue;
          }
          if (tmpName !== false) {
            if (i === lastMarkPos) {
              j = html.indexOf(c, i + 1);
              if (j === -1) {
                break;
              } else {
                v = _$1.trim(html.slice(lastMarkPos + 1, j));
                addAttr(tmpName, v);
                tmpName = false;
                i = j;
                lastPos = i + 1;
                continue;
              }
            }
          }
          if (/\s|\n|\t/.test(c)) {
            html = html.replace(/\s|\n|\t/g, " ");
            if (tmpName === false) {
              j = findNextEqual(html, i);
              if (j === -1) {
                v = _$1.trim(html.slice(lastPos, i));
                addAttr(v);
                tmpName = false;
                lastPos = i + 1;
                continue;
              } else {
                i = j - 1;
                continue;
              }
            } else {
              j = findBeforeEqual(html, i - 1);
              if (j === -1) {
                v = _$1.trim(html.slice(lastPos, i));
                v = stripQuoteWrap(v);
                addAttr(tmpName, v);
                tmpName = false;
                lastPos = i + 1;
                continue;
              } else {
                continue;
              }
            }
          }
        }
        if (lastPos < html.length) {
          if (tmpName === false) {
            addAttr(html.slice(lastPos));
          } else {
            addAttr(tmpName, stripQuoteWrap(_$1.trim(html.slice(lastPos))));
          }
        }
        return _$1.trim(retAttrs.join(" "));
      }
      function findNextEqual(str, i) {
        for (; i < str.length; i++) {
          var c = str[i];
          if (c === " ")
            continue;
          if (c === "=")
            return i;
          return -1;
        }
      }
      function findNextQuotationMark(str, i) {
        for (; i < str.length; i++) {
          var c = str[i];
          if (c === " ")
            continue;
          if (c === "'" || c === '"')
            return i;
          return -1;
        }
      }
      function findBeforeEqual(str, i) {
        for (; i > 0; i--) {
          var c = str[i];
          if (c === " ")
            continue;
          if (c === "=")
            return i;
          return -1;
        }
      }
      function isQuoteWrapString(text) {
        if (text[0] === '"' && text[text.length - 1] === '"' || text[0] === "'" && text[text.length - 1] === "'") {
          return true;
        } else {
          return false;
        }
      }
      function stripQuoteWrap(text) {
        if (isQuoteWrapString(text)) {
          return text.substr(1, text.length - 2);
        } else {
          return text;
        }
      }
      parser$1.parseTag = parseTag$1;
      parser$1.parseAttr = parseAttr$1;
      var FilterCSS = libExports$1.FilterCSS;
      var DEFAULT = _default$1;
      var parser = parser$1;
      var parseTag = parser.parseTag;
      var parseAttr = parser.parseAttr;
      var _ = util;
      function isNull(obj) {
        return obj === void 0 || obj === null;
      }
      function getAttrs(html) {
        var i = _.spaceIndex(html);
        if (i === -1) {
          return {
            html: "",
            closing: html[html.length - 2] === "/"
          };
        }
        html = _.trim(html.slice(i + 1, -1));
        var isClosing2 = html[html.length - 1] === "/";
        if (isClosing2)
          html = _.trim(html.slice(0, -1));
        return {
          html,
          closing: isClosing2
        };
      }
      function shallowCopyObject(obj) {
        var ret = {};
        for (var i in obj) {
          ret[i] = obj[i];
        }
        return ret;
      }
      function keysToLowerCase(obj) {
        var ret = {};
        for (var i in obj) {
          if (Array.isArray(obj[i])) {
            ret[i.toLowerCase()] = obj[i].map(function(item) {
              return item.toLowerCase();
            });
          } else {
            ret[i.toLowerCase()] = obj[i];
          }
        }
        return ret;
      }
      function FilterXSS(options) {
        options = shallowCopyObject(options || {});
        if (options.stripIgnoreTag) {
          if (options.onIgnoreTag) {
            console.error(
              'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'
            );
          }
          options.onIgnoreTag = DEFAULT.onIgnoreTagStripAll;
        }
        if (options.whiteList || options.allowList) {
          options.whiteList = keysToLowerCase(options.whiteList || options.allowList);
        } else {
          options.whiteList = DEFAULT.whiteList;
        }
        options.onTag = options.onTag || DEFAULT.onTag;
        options.onTagAttr = options.onTagAttr || DEFAULT.onTagAttr;
        options.onIgnoreTag = options.onIgnoreTag || DEFAULT.onIgnoreTag;
        options.onIgnoreTagAttr = options.onIgnoreTagAttr || DEFAULT.onIgnoreTagAttr;
        options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
        options.escapeHtml = options.escapeHtml || DEFAULT.escapeHtml;
        this.options = options;
        if (options.css === false) {
          this.cssFilter = false;
        } else {
          options.css = options.css || {};
          this.cssFilter = new FilterCSS(options.css);
        }
      }
      FilterXSS.prototype.process = function(html) {
        html = html || "";
        html = html.toString();
        if (!html)
          return "";
        var me2 = this;
        var options = me2.options;
        var whiteList = options.whiteList;
        var onTag2 = options.onTag;
        var onIgnoreTag2 = options.onIgnoreTag;
        var onTagAttr2 = options.onTagAttr;
        var onIgnoreTagAttr2 = options.onIgnoreTagAttr;
        var safeAttrValue2 = options.safeAttrValue;
        var escapeHtml2 = options.escapeHtml;
        var cssFilter = me2.cssFilter;
        if (options.stripBlankChar) {
          html = DEFAULT.stripBlankChar(html);
        }
        if (!options.allowCommentTag) {
          html = DEFAULT.stripCommentTag(html);
        }
        var stripIgnoreTagBody = false;
        if (options.stripIgnoreTagBody) {
          stripIgnoreTagBody = DEFAULT.StripTagBody(
            options.stripIgnoreTagBody,
            onIgnoreTag2
          );
          onIgnoreTag2 = stripIgnoreTagBody.onIgnoreTag;
        }
        var retHtml = parseTag(
          html,
          function(sourcePosition, position, tag, html2, isClosing2) {
            var info = {
              sourcePosition,
              position,
              isClosing: isClosing2,
              isWhite: Object.prototype.hasOwnProperty.call(whiteList, tag)
            };
            var ret = onTag2(tag, html2, info);
            if (!isNull(ret))
              return ret;
            if (info.isWhite) {
              if (info.isClosing) {
                return "</" + tag + ">";
              }
              var attrs = getAttrs(html2);
              var whiteAttrList = whiteList[tag];
              var attrsHtml = parseAttr(attrs.html, function(name, value) {
                var isWhiteAttr = _.indexOf(whiteAttrList, name) !== -1;
                var ret2 = onTagAttr2(tag, name, value, isWhiteAttr);
                if (!isNull(ret2))
                  return ret2;
                if (isWhiteAttr) {
                  value = safeAttrValue2(tag, name, value, cssFilter);
                  if (value) {
                    return name + '="' + value + '"';
                  } else {
                    return name;
                  }
                } else {
                  ret2 = onIgnoreTagAttr2(tag, name, value, isWhiteAttr);
                  if (!isNull(ret2))
                    return ret2;
                  return;
                }
              });
              html2 = "<" + tag;
              if (attrsHtml)
                html2 += " " + attrsHtml;
              if (attrs.closing)
                html2 += " /";
              html2 += ">";
              return html2;
            } else {
              ret = onIgnoreTag2(tag, html2, info);
              if (!isNull(ret))
                return ret;
              return escapeHtml2(html2);
            }
          },
          escapeHtml2
        );
        if (stripIgnoreTagBody) {
          retHtml = stripIgnoreTagBody.remove(retHtml);
        }
        return retHtml;
      };
      var xss$1 = FilterXSS;
      (function(module2, exports2) {
        var DEFAULT2 = _default$1;
        var parser2 = parser$1;
        var FilterXSS2 = xss$1;
        function filterXSS(html, options) {
          var xss2 = new FilterXSS2(options);
          return xss2.process(html);
        }
        exports2 = module2.exports = filterXSS;
        exports2.filterXSS = filterXSS;
        exports2.FilterXSS = FilterXSS2;
        (function() {
          for (var i in DEFAULT2) {
            exports2[i] = DEFAULT2[i];
          }
          for (var j in parser2) {
            exports2[j] = parser2[j];
          }
        })();
        if (typeof window !== "undefined") {
          window.filterXSS = module2.exports;
        }
        function isWorkerEnv() {
          return typeof self !== "undefined" && typeof DedicatedWorkerGlobalScope !== "undefined" && self instanceof DedicatedWorkerGlobalScope;
        }
        if (isWorkerEnv()) {
          self.filterXSS = module2.exports;
        }
      })(lib$1, lib$1.exports);
      var libExports = lib$1.exports;
      const xss = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
      var jquery = { exports: {} };
      /*!
       * jQuery JavaScript Library v3.7.1
       * https://jquery.com/
       *
       * Copyright OpenJS Foundation and other contributors
       * Released under the MIT license
       * https://jquery.org/license
       *
       * Date: 2023-08-28T13:37Z
       */
      (function(module2) {
        (function(global2, factory) {
          {
            module2.exports = global2.document ? factory(global2, true) : function(w) {
              if (!w.document) {
                throw new Error("jQuery requires a window with a document");
              }
              return factory(w);
            };
          }
        })(typeof window !== "undefined" ? window : commonjsGlobal, function(window2, noGlobal) {
          var arr = [];
          var getProto2 = Object.getPrototypeOf;
          var slice = arr.slice;
          var flat = arr.flat ? function(array) {
            return arr.flat.call(array);
          } : function(array) {
            return arr.concat.apply([], array);
          };
          var push = arr.push;
          var indexOf = arr.indexOf;
          var class2type = {};
          var toString2 = class2type.toString;
          var hasOwn2 = class2type.hasOwnProperty;
          var fnToString = hasOwn2.toString;
          var ObjectFunctionString = fnToString.call(Object);
          var support = {};
          var isFunction2 = function isFunction3(obj) {
            return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
          };
          var isWindow = function isWindow2(obj) {
            return obj != null && obj === obj.window;
          };
          var document2 = window2.document;
          var preservedScriptAttributes = {
            type: true,
            src: true,
            nonce: true,
            noModule: true
          };
          function DOMEval(code, node, doc2) {
            doc2 = doc2 || document2;
            var i, val, script = doc2.createElement("script");
            script.text = code;
            if (node) {
              for (i in preservedScriptAttributes) {
                val = node[i] || node.getAttribute && node.getAttribute(i);
                if (val) {
                  script.setAttribute(i, val);
                }
              }
            }
            doc2.head.appendChild(script).parentNode.removeChild(script);
          }
          function toType(obj) {
            if (obj == null) {
              return obj + "";
            }
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString2.call(obj)] || "object" : typeof obj;
          }
          var version2 = "3.7.1", rhtmlSuffix = /HTML$/i, jQuery = function(selector, context) {
            return new jQuery.fn.init(selector, context);
          };
          jQuery.fn = jQuery.prototype = {
            // The current version of jQuery being used
            jquery: version2,
            constructor: jQuery,
            // The default length of a jQuery object is 0
            length: 0,
            toArray: function() {
              return slice.call(this);
            },
            // Get the Nth element in the matched element set OR
            // Get the whole matched element set as a clean array
            get: function(num) {
              if (num == null) {
                return slice.call(this);
              }
              return num < 0 ? this[num + this.length] : this[num];
            },
            // Take an array of elements and push it onto the stack
            // (returning the new matched element set)
            pushStack: function(elems) {
              var ret = jQuery.merge(this.constructor(), elems);
              ret.prevObject = this;
              return ret;
            },
            // Execute a callback for every element in the matched set.
            each: function(callback) {
              return jQuery.each(this, callback);
            },
            map: function(callback) {
              return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
              }));
            },
            slice: function() {
              return this.pushStack(slice.apply(this, arguments));
            },
            first: function() {
              return this.eq(0);
            },
            last: function() {
              return this.eq(-1);
            },
            even: function() {
              return this.pushStack(jQuery.grep(this, function(_elem, i) {
                return (i + 1) % 2;
              }));
            },
            odd: function() {
              return this.pushStack(jQuery.grep(this, function(_elem, i) {
                return i % 2;
              }));
            },
            eq: function(i) {
              var len = this.length, j = +i + (i < 0 ? len : 0);
              return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
            },
            end: function() {
              return this.prevObject || this.constructor();
            },
            // For internal use only.
            // Behaves like an Array's method, not like a jQuery method.
            push,
            sort: arr.sort,
            splice: arr.splice
          };
          jQuery.extend = jQuery.fn.extend = function() {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
            if (typeof target === "boolean") {
              deep = target;
              target = arguments[i] || {};
              i++;
            }
            if (typeof target !== "object" && !isFunction2(target)) {
              target = {};
            }
            if (i === length) {
              target = this;
              i--;
            }
            for (; i < length; i++) {
              if ((options = arguments[i]) != null) {
                for (name in options) {
                  copy = options[name];
                  if (name === "__proto__" || target === copy) {
                    continue;
                  }
                  if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                    src = target[name];
                    if (copyIsArray && !Array.isArray(src)) {
                      clone = [];
                    } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                      clone = {};
                    } else {
                      clone = src;
                    }
                    copyIsArray = false;
                    target[name] = jQuery.extend(deep, clone, copy);
                  } else if (copy !== void 0) {
                    target[name] = copy;
                  }
                }
              }
            }
            return target;
          };
          jQuery.extend({
            // Unique for each copy of jQuery on the page
            expando: "jQuery" + (version2 + Math.random()).replace(/\D/g, ""),
            // Assume jQuery is ready without the ready module
            isReady: true,
            error: function(msg) {
              throw new Error(msg);
            },
            noop: function() {
            },
            isPlainObject: function(obj) {
              var proto, Ctor;
              if (!obj || toString2.call(obj) !== "[object Object]") {
                return false;
              }
              proto = getProto2(obj);
              if (!proto) {
                return true;
              }
              Ctor = hasOwn2.call(proto, "constructor") && proto.constructor;
              return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
            },
            isEmptyObject: function(obj) {
              var name;
              for (name in obj) {
                return false;
              }
              return true;
            },
            // Evaluates a script in a provided context; falls back to the global one
            // if not specified.
            globalEval: function(code, options, doc2) {
              DOMEval(code, { nonce: options && options.nonce }, doc2);
            },
            each: function(obj, callback) {
              var length, i = 0;
              if (isArrayLike2(obj)) {
                length = obj.length;
                for (; i < length; i++) {
                  if (callback.call(obj[i], i, obj[i]) === false) {
                    break;
                  }
                }
              } else {
                for (i in obj) {
                  if (callback.call(obj[i], i, obj[i]) === false) {
                    break;
                  }
                }
              }
              return obj;
            },
            // Retrieve the text value of an array of DOM nodes
            text: function(elem) {
              var node, ret = "", i = 0, nodeType = elem.nodeType;
              if (!nodeType) {
                while (node = elem[i++]) {
                  ret += jQuery.text(node);
                }
              }
              if (nodeType === 1 || nodeType === 11) {
                return elem.textContent;
              }
              if (nodeType === 9) {
                return elem.documentElement.textContent;
              }
              if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
              }
              return ret;
            },
            // results is for internal usage only
            makeArray: function(arr2, results) {
              var ret = results || [];
              if (arr2 != null) {
                if (isArrayLike2(Object(arr2))) {
                  jQuery.merge(
                    ret,
                    typeof arr2 === "string" ? [arr2] : arr2
                  );
                } else {
                  push.call(ret, arr2);
                }
              }
              return ret;
            },
            inArray: function(elem, arr2, i) {
              return arr2 == null ? -1 : indexOf.call(arr2, elem, i);
            },
            isXMLDoc: function(elem) {
              var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
              return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
            },
            // Support: Android <=4.0 only, PhantomJS 1 only
            // push.apply(_, arraylike) throws on ancient WebKit
            merge: function(first, second) {
              var len = +second.length, j = 0, i = first.length;
              for (; j < len; j++) {
                first[i++] = second[j];
              }
              first.length = i;
              return first;
            },
            grep: function(elems, callback, invert) {
              var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
              for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                  matches.push(elems[i]);
                }
              }
              return matches;
            },
            // arg is for internal usage only
            map: function(elems, callback, arg) {
              var length, value, i = 0, ret = [];
              if (isArrayLike2(elems)) {
                length = elems.length;
                for (; i < length; i++) {
                  value = callback(elems[i], i, arg);
                  if (value != null) {
                    ret.push(value);
                  }
                }
              } else {
                for (i in elems) {
                  value = callback(elems[i], i, arg);
                  if (value != null) {
                    ret.push(value);
                  }
                }
              }
              return flat(ret);
            },
            // A global GUID counter for objects
            guid: 1,
            // jQuery.support is not used in Core but other projects attach their
            // properties to it so it needs to exist.
            support
          });
          if (typeof Symbol === "function") {
            jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
          }
          jQuery.each(
            "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
            function(_i, name) {
              class2type["[object " + name + "]"] = name.toLowerCase();
            }
          );
          function isArrayLike2(obj) {
            var length = !!obj && "length" in obj && obj.length, type = toType(obj);
            if (isFunction2(obj) || isWindow(obj)) {
              return false;
            }
            return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
          }
          function nodeName(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
          }
          var pop = arr.pop;
          var sort = arr.sort;
          var splice2 = arr.splice;
          var whitespace = "[\\x20\\t\\r\\n\\f]";
          var rtrimCSS = new RegExp(
            "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
            "g"
          );
          jQuery.contains = function(a, b) {
            var bup = b && b.parentNode;
            return a === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
            // IE doesn't have `contains` on SVG.
            (a.contains ? a.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
          };
          var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
          function fcssescape(ch, asCodePoint) {
            if (asCodePoint) {
              if (ch === "\0") {
                return "�";
              }
              return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
            }
            return "\\" + ch;
          }
          jQuery.escapeSelector = function(sel) {
            return (sel + "").replace(rcssescape, fcssescape);
          };
          var preferredDoc = document2, pushNative = push;
          (function() {
            var i, Expr, outermostContext, sortInput, hasDuplicate, push2 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches, expando = jQuery.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
              if (a === b) {
                hasDuplicate = true;
              }
              return 0;
            }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
            "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
            `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
              ID: new RegExp("^#(" + identifier + ")"),
              CLASS: new RegExp("^\\.(" + identifier + ")"),
              TAG: new RegExp("^(" + identifier + "|[*])"),
              ATTR: new RegExp("^" + attributes),
              PSEUDO: new RegExp("^" + pseudos),
              CHILD: new RegExp(
                "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
                "i"
              ),
              bool: new RegExp("^(?:" + booleans + ")$", "i"),
              // For use in libraries implementing .is()
              // We use this for POS matching in `select`
              needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
            }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape2, nonHex) {
              var high = "0x" + escape2.slice(1) - 65536;
              if (nonHex) {
                return nonHex;
              }
              return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
            }, unloadHandler = function() {
              setDocument();
            }, inDisabledFieldset = addCombinator(
              function(elem) {
                return elem.disabled === true && nodeName(elem, "fieldset");
              },
              { dir: "parentNode", next: "legend" }
            );
            function safeActiveElement() {
              try {
                return document3.activeElement;
              } catch (err) {
              }
            }
            try {
              push2.apply(
                arr = slice.call(preferredDoc.childNodes),
                preferredDoc.childNodes
              );
              arr[preferredDoc.childNodes.length].nodeType;
            } catch (e2) {
              push2 = {
                apply: function(target, els) {
                  pushNative.apply(target, slice.call(els));
                },
                call: function(target) {
                  pushNative.apply(target, slice.call(arguments, 1));
                }
              };
            }
            function find(selector, context, results, seed) {
              var m, i2, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
              results = results || [];
              if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                return results;
              }
              if (!seed) {
                setDocument(context);
                context = context || document3;
                if (documentIsHTML) {
                  if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                    if (m = match[1]) {
                      if (nodeType === 9) {
                        if (elem = context.getElementById(m)) {
                          if (elem.id === m) {
                            push2.call(results, elem);
                            return results;
                          }
                        } else {
                          return results;
                        }
                      } else {
                        if (newContext && (elem = newContext.getElementById(m)) && find.contains(context, elem) && elem.id === m) {
                          push2.call(results, elem);
                          return results;
                        }
                      }
                    } else if (match[2]) {
                      push2.apply(results, context.getElementsByTagName(selector));
                      return results;
                    } else if ((m = match[3]) && context.getElementsByClassName) {
                      push2.apply(results, context.getElementsByClassName(m));
                      return results;
                    }
                  }
                  if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    newSelector = selector;
                    newContext = context;
                    if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                      newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                      if (newContext != context || !support.scope) {
                        if (nid = context.getAttribute("id")) {
                          nid = jQuery.escapeSelector(nid);
                        } else {
                          context.setAttribute("id", nid = expando);
                        }
                      }
                      groups = tokenize(selector);
                      i2 = groups.length;
                      while (i2--) {
                        groups[i2] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i2]);
                      }
                      newSelector = groups.join(",");
                    }
                    try {
                      push2.apply(
                        results,
                        newContext.querySelectorAll(newSelector)
                      );
                      return results;
                    } catch (qsaError) {
                      nonnativeSelectorCache(selector, true);
                    } finally {
                      if (nid === expando) {
                        context.removeAttribute("id");
                      }
                    }
                  }
                }
              }
              return select(selector.replace(rtrimCSS, "$1"), context, results, seed);
            }
            function createCache() {
              var keys2 = [];
              function cache(key, value) {
                if (keys2.push(key + " ") > Expr.cacheLength) {
                  delete cache[keys2.shift()];
                }
                return cache[key + " "] = value;
              }
              return cache;
            }
            function markFunction(fn2) {
              fn2[expando] = true;
              return fn2;
            }
            function assert(fn2) {
              var el = document3.createElement("fieldset");
              try {
                return !!fn2(el);
              } catch (e2) {
                return false;
              } finally {
                if (el.parentNode) {
                  el.parentNode.removeChild(el);
                }
                el = null;
              }
            }
            function createInputPseudo(type) {
              return function(elem) {
                return nodeName(elem, "input") && elem.type === type;
              };
            }
            function createButtonPseudo(type) {
              return function(elem) {
                return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
              };
            }
            function createDisabledPseudo(disabled) {
              return function(elem) {
                if ("form" in elem) {
                  if (elem.parentNode && elem.disabled === false) {
                    if ("label" in elem) {
                      if ("label" in elem.parentNode) {
                        return elem.parentNode.disabled === disabled;
                      } else {
                        return elem.disabled === disabled;
                      }
                    }
                    return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                    elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                  }
                  return elem.disabled === disabled;
                } else if ("label" in elem) {
                  return elem.disabled === disabled;
                }
                return false;
              };
            }
            function createPositionalPseudo(fn2) {
              return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches2) {
                  var j, matchIndexes = fn2([], seed.length, argument), i2 = matchIndexes.length;
                  while (i2--) {
                    if (seed[j = matchIndexes[i2]]) {
                      seed[j] = !(matches2[j] = seed[j]);
                    }
                  }
                });
              });
            }
            function testContext(context) {
              return context && typeof context.getElementsByTagName !== "undefined" && context;
            }
            function setDocument(node) {
              var subWindow, doc2 = node ? node.ownerDocument || node : preferredDoc;
              if (doc2 == document3 || doc2.nodeType !== 9 || !doc2.documentElement) {
                return document3;
              }
              document3 = doc2;
              documentElement2 = document3.documentElement;
              documentIsHTML = !jQuery.isXMLDoc(document3);
              matches = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
              if (documentElement2.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
              // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
              // two documents; shallow comparisons work.
              // eslint-disable-next-line eqeqeq
              preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
                subWindow.addEventListener("unload", unloadHandler);
              }
              support.getById = assert(function(el) {
                documentElement2.appendChild(el).id = jQuery.expando;
                return !document3.getElementsByName || !document3.getElementsByName(jQuery.expando).length;
              });
              support.disconnectedMatch = assert(function(el) {
                return matches.call(el, "*");
              });
              support.scope = assert(function() {
                return document3.querySelectorAll(":scope");
              });
              support.cssHas = assert(function() {
                try {
                  document3.querySelector(":has(*,:jqfake)");
                  return false;
                } catch (e2) {
                  return true;
                }
              });
              if (support.getById) {
                Expr.filter.ID = function(id) {
                  var attrId = id.replace(runescape, funescape);
                  return function(elem) {
                    return elem.getAttribute("id") === attrId;
                  };
                };
                Expr.find.ID = function(id, context) {
                  if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                    var elem = context.getElementById(id);
                    return elem ? [elem] : [];
                  }
                };
              } else {
                Expr.filter.ID = function(id) {
                  var attrId = id.replace(runescape, funescape);
                  return function(elem) {
                    var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                    return node2 && node2.value === attrId;
                  };
                };
                Expr.find.ID = function(id, context) {
                  if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                    var node2, i2, elems, elem = context.getElementById(id);
                    if (elem) {
                      node2 = elem.getAttributeNode("id");
                      if (node2 && node2.value === id) {
                        return [elem];
                      }
                      elems = context.getElementsByName(id);
                      i2 = 0;
                      while (elem = elems[i2++]) {
                        node2 = elem.getAttributeNode("id");
                        if (node2 && node2.value === id) {
                          return [elem];
                        }
                      }
                    }
                    return [];
                  }
                };
              }
              Expr.find.TAG = function(tag, context) {
                if (typeof context.getElementsByTagName !== "undefined") {
                  return context.getElementsByTagName(tag);
                } else {
                  return context.querySelectorAll(tag);
                }
              };
              Expr.find.CLASS = function(className, context) {
                if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                  return context.getElementsByClassName(className);
                }
              };
              rbuggyQSA = [];
              assert(function(el) {
                var input;
                documentElement2.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a><select id='" + expando + "-\r\\' disabled='disabled'><option selected=''></option></select>";
                if (!el.querySelectorAll("[selected]").length) {
                  rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                }
                if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                  rbuggyQSA.push("~=");
                }
                if (!el.querySelectorAll("a#" + expando + "+*").length) {
                  rbuggyQSA.push(".#.+[+~]");
                }
                if (!el.querySelectorAll(":checked").length) {
                  rbuggyQSA.push(":checked");
                }
                input = document3.createElement("input");
                input.setAttribute("type", "hidden");
                el.appendChild(input).setAttribute("name", "D");
                documentElement2.appendChild(el).disabled = true;
                if (el.querySelectorAll(":disabled").length !== 2) {
                  rbuggyQSA.push(":enabled", ":disabled");
                }
                input = document3.createElement("input");
                input.setAttribute("name", "");
                el.appendChild(input);
                if (!el.querySelectorAll("[name='']").length) {
                  rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
                }
              });
              if (!support.cssHas) {
                rbuggyQSA.push(":has");
              }
              rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
              sortOrder = function(a, b) {
                if (a === b) {
                  hasDuplicate = true;
                  return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                  return compare;
                }
                compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : (
                  // Otherwise we know they are disconnected
                  1
                );
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                  if (a === document3 || a.ownerDocument == preferredDoc && find.contains(preferredDoc, a)) {
                    return -1;
                  }
                  if (b === document3 || b.ownerDocument == preferredDoc && find.contains(preferredDoc, b)) {
                    return 1;
                  }
                  return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
              };
              return document3;
            }
            find.matches = function(expr, elements) {
              return find(expr, null, null, elements);
            };
            find.matchesSelector = function(elem, expr) {
              setDocument(elem);
              if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                  var ret = matches.call(elem, expr);
                  if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                  // fragment in IE 9
                  elem.document && elem.document.nodeType !== 11) {
                    return ret;
                  }
                } catch (e2) {
                  nonnativeSelectorCache(expr, true);
                }
              }
              return find(expr, document3, null, [elem]).length > 0;
            };
            find.contains = function(context, elem) {
              if ((context.ownerDocument || context) != document3) {
                setDocument(context);
              }
              return jQuery.contains(context, elem);
            };
            find.attr = function(elem, name) {
              if ((elem.ownerDocument || elem) != document3) {
                setDocument(elem);
              }
              var fn2 = Expr.attrHandle[name.toLowerCase()], val = fn2 && hasOwn2.call(Expr.attrHandle, name.toLowerCase()) ? fn2(elem, name, !documentIsHTML) : void 0;
              if (val !== void 0) {
                return val;
              }
              return elem.getAttribute(name);
            };
            find.error = function(msg) {
              throw new Error("Syntax error, unrecognized expression: " + msg);
            };
            jQuery.uniqueSort = function(results) {
              var elem, duplicates = [], j = 0, i2 = 0;
              hasDuplicate = !support.sortStable;
              sortInput = !support.sortStable && slice.call(results, 0);
              sort.call(results, sortOrder);
              if (hasDuplicate) {
                while (elem = results[i2++]) {
                  if (elem === results[i2]) {
                    j = duplicates.push(i2);
                  }
                }
                while (j--) {
                  splice2.call(results, duplicates[j], 1);
                }
              }
              sortInput = null;
              return results;
            };
            jQuery.fn.uniqueSort = function() {
              return this.pushStack(jQuery.uniqueSort(slice.apply(this)));
            };
            Expr = jQuery.expr = {
              // Can be adjusted by the user
              cacheLength: 50,
              createPseudo: markFunction,
              match: matchExpr,
              attrHandle: {},
              find: {},
              relative: {
                ">": { dir: "parentNode", first: true },
                " ": { dir: "parentNode" },
                "+": { dir: "previousSibling", first: true },
                "~": { dir: "previousSibling" }
              },
              preFilter: {
                ATTR: function(match) {
                  match[1] = match[1].replace(runescape, funescape);
                  match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                  if (match[2] === "~=") {
                    match[3] = " " + match[3] + " ";
                  }
                  return match.slice(0, 4);
                },
                CHILD: function(match) {
                  match[1] = match[1].toLowerCase();
                  if (match[1].slice(0, 3) === "nth") {
                    if (!match[3]) {
                      find.error(match[0]);
                    }
                    match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                    match[5] = +(match[7] + match[8] || match[3] === "odd");
                  } else if (match[3]) {
                    find.error(match[0]);
                  }
                  return match;
                },
                PSEUDO: function(match) {
                  var excess, unquoted = !match[6] && match[2];
                  if (matchExpr.CHILD.test(match[0])) {
                    return null;
                  }
                  if (match[3]) {
                    match[2] = match[4] || match[5] || "";
                  } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
                  (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
                  (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                    match[0] = match[0].slice(0, excess);
                    match[2] = unquoted.slice(0, excess);
                  }
                  return match.slice(0, 3);
                }
              },
              filter: {
                TAG: function(nodeNameSelector) {
                  var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                  return nodeNameSelector === "*" ? function() {
                    return true;
                  } : function(elem) {
                    return nodeName(elem, expectedNodeName);
                  };
                },
                CLASS: function(className) {
                  var pattern = classCache[className + " "];
                  return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                    return pattern.test(
                      typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                    );
                  });
                },
                ATTR: function(name, operator, check) {
                  return function(elem) {
                    var result = find.attr(elem, name);
                    if (result == null) {
                      return operator === "!=";
                    }
                    if (!operator) {
                      return true;
                    }
                    result += "";
                    if (operator === "=") {
                      return result === check;
                    }
                    if (operator === "!=") {
                      return result !== check;
                    }
                    if (operator === "^=") {
                      return check && result.indexOf(check) === 0;
                    }
                    if (operator === "*=") {
                      return check && result.indexOf(check) > -1;
                    }
                    if (operator === "$=") {
                      return check && result.slice(-check.length) === check;
                    }
                    if (operator === "~=") {
                      return (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
                    }
                    if (operator === "|=") {
                      return result === check || result.slice(0, check.length + 1) === check + "-";
                    }
                    return false;
                  };
                },
                CHILD: function(type, what, _argument, first, last) {
                  var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                  return first === 1 && last === 0 ? (
                    // Shortcut for :nth-*(n)
                    function(elem) {
                      return !!elem.parentNode;
                    }
                  ) : function(elem, _context, xml) {
                    var cache, outerCache, node, nodeIndex, start, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                    if (parent) {
                      if (simple) {
                        while (dir2) {
                          node = elem;
                          while (node = node[dir2]) {
                            if (ofType ? nodeName(node, name) : node.nodeType === 1) {
                              return false;
                            }
                          }
                          start = dir2 = type === "only" && !start && "nextSibling";
                        }
                        return true;
                      }
                      start = [forward ? parent.firstChild : parent.lastChild];
                      if (forward && useCache) {
                        outerCache = parent[expando] || (parent[expando] = {});
                        cache = outerCache[type] || [];
                        nodeIndex = cache[0] === dirruns && cache[1];
                        diff = nodeIndex && cache[2];
                        node = nodeIndex && parent.childNodes[nodeIndex];
                        while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                        (diff = nodeIndex = 0) || start.pop()) {
                          if (node.nodeType === 1 && ++diff && node === elem) {
                            outerCache[type] = [dirruns, nodeIndex, diff];
                            break;
                          }
                        }
                      } else {
                        if (useCache) {
                          outerCache = elem[expando] || (elem[expando] = {});
                          cache = outerCache[type] || [];
                          nodeIndex = cache[0] === dirruns && cache[1];
                          diff = nodeIndex;
                        }
                        if (diff === false) {
                          while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start.pop()) {
                            if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {
                              if (useCache) {
                                outerCache = node[expando] || (node[expando] = {});
                                outerCache[type] = [dirruns, diff];
                              }
                              if (node === elem) {
                                break;
                              }
                            }
                          }
                        }
                      }
                      diff -= last;
                      return diff === first || diff % first === 0 && diff / first >= 0;
                    }
                  };
                },
                PSEUDO: function(pseudo, argument) {
                  var args, fn2 = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find.error("unsupported pseudo: " + pseudo);
                  if (fn2[expando]) {
                    return fn2(argument);
                  }
                  if (fn2.length > 1) {
                    args = [pseudo, pseudo, "", argument];
                    return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                      var idx, matched = fn2(seed, argument), i2 = matched.length;
                      while (i2--) {
                        idx = indexOf.call(seed, matched[i2]);
                        seed[idx] = !(matches2[idx] = matched[i2]);
                      }
                    }) : function(elem) {
                      return fn2(elem, 0, args);
                    };
                  }
                  return fn2;
                }
              },
              pseudos: {
                // Potentially complex pseudos
                not: markFunction(function(selector) {
                  var input = [], results = [], matcher = compile2(selector.replace(rtrimCSS, "$1"));
                  return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                    var elem, unmatched = matcher(seed, null, xml, []), i2 = seed.length;
                    while (i2--) {
                      if (elem = unmatched[i2]) {
                        seed[i2] = !(matches2[i2] = elem);
                      }
                    }
                  }) : function(elem, _context, xml) {
                    input[0] = elem;
                    matcher(input, null, xml, results);
                    input[0] = null;
                    return !results.pop();
                  };
                }),
                has: markFunction(function(selector) {
                  return function(elem) {
                    return find(selector, elem).length > 0;
                  };
                }),
                contains: markFunction(function(text) {
                  text = text.replace(runescape, funescape);
                  return function(elem) {
                    return (elem.textContent || jQuery.text(elem)).indexOf(text) > -1;
                  };
                }),
                // "Whether an element is represented by a :lang() selector
                // is based solely on the element's language value
                // being equal to the identifier C,
                // or beginning with the identifier C immediately followed by "-".
                // The matching of C against the element's language value is performed case-insensitively.
                // The identifier C does not have to be a valid language name."
                // https://www.w3.org/TR/selectors/#lang-pseudo
                lang: markFunction(function(lang) {
                  if (!ridentifier.test(lang || "")) {
                    find.error("unsupported lang: " + lang);
                  }
                  lang = lang.replace(runescape, funescape).toLowerCase();
                  return function(elem) {
                    var elemLang;
                    do {
                      if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                        elemLang = elemLang.toLowerCase();
                        return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                      }
                    } while ((elem = elem.parentNode) && elem.nodeType === 1);
                    return false;
                  };
                }),
                // Miscellaneous
                target: function(elem) {
                  var hash = window2.location && window2.location.hash;
                  return hash && hash.slice(1) === elem.id;
                },
                root: function(elem) {
                  return elem === documentElement2;
                },
                focus: function(elem) {
                  return elem === safeActiveElement() && document3.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                // Boolean properties
                enabled: createDisabledPseudo(false),
                disabled: createDisabledPseudo(true),
                checked: function(elem) {
                  return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
                },
                selected: function(elem) {
                  if (elem.parentNode) {
                    elem.parentNode.selectedIndex;
                  }
                  return elem.selected === true;
                },
                // Contents
                empty: function(elem) {
                  for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                    if (elem.nodeType < 6) {
                      return false;
                    }
                  }
                  return true;
                },
                parent: function(elem) {
                  return !Expr.pseudos.empty(elem);
                },
                // Element/input types
                header: function(elem) {
                  return rheader.test(elem.nodeName);
                },
                input: function(elem) {
                  return rinputs.test(elem.nodeName);
                },
                button: function(elem) {
                  return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
                },
                text: function(elem) {
                  var attr;
                  return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
                  // New HTML5 attribute values (e.g., "search") appear
                  // with elem.type === "text"
                  ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },
                // Position-in-collection
                first: createPositionalPseudo(function() {
                  return [0];
                }),
                last: createPositionalPseudo(function(_matchIndexes, length) {
                  return [length - 1];
                }),
                eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
                  return [argument < 0 ? argument + length : argument];
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                  var i2 = 0;
                  for (; i2 < length; i2 += 2) {
                    matchIndexes.push(i2);
                  }
                  return matchIndexes;
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                  var i2 = 1;
                  for (; i2 < length; i2 += 2) {
                    matchIndexes.push(i2);
                  }
                  return matchIndexes;
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                  var i2;
                  if (argument < 0) {
                    i2 = argument + length;
                  } else if (argument > length) {
                    i2 = length;
                  } else {
                    i2 = argument;
                  }
                  for (; --i2 >= 0; ) {
                    matchIndexes.push(i2);
                  }
                  return matchIndexes;
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                  var i2 = argument < 0 ? argument + length : argument;
                  for (; ++i2 < length; ) {
                    matchIndexes.push(i2);
                  }
                  return matchIndexes;
                })
              }
            };
            Expr.pseudos.nth = Expr.pseudos.eq;
            for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
              Expr.pseudos[i] = createInputPseudo(i);
            }
            for (i in { submit: true, reset: true }) {
              Expr.pseudos[i] = createButtonPseudo(i);
            }
            function setFilters() {
            }
            setFilters.prototype = Expr.filters = Expr.pseudos;
            Expr.setFilters = new setFilters();
            function tokenize(selector, parseOnly) {
              var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
              if (cached) {
                return parseOnly ? 0 : cached.slice(0);
              }
              soFar = selector;
              groups = [];
              preFilters = Expr.preFilter;
              while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                  if (match) {
                    soFar = soFar.slice(match[0].length) || soFar;
                  }
                  groups.push(tokens = []);
                }
                matched = false;
                if (match = rleadingCombinator.exec(soFar)) {
                  matched = match.shift();
                  tokens.push({
                    value: matched,
                    // Cast descendant combinators to space
                    type: match[0].replace(rtrimCSS, " ")
                  });
                  soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                  if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                    matched = match.shift();
                    tokens.push({
                      value: matched,
                      type,
                      matches: match
                    });
                    soFar = soFar.slice(matched.length);
                  }
                }
                if (!matched) {
                  break;
                }
              }
              if (parseOnly) {
                return soFar.length;
              }
              return soFar ? find.error(selector) : (
                // Cache the tokens
                tokenCache(selector, groups).slice(0)
              );
            }
            function toSelector(tokens) {
              var i2 = 0, len = tokens.length, selector = "";
              for (; i2 < len; i2++) {
                selector += tokens[i2].value;
              }
              return selector;
            }
            function addCombinator(matcher, combinator, base2) {
              var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base2 && key === "parentNode", doneName = done++;
              return combinator.first ? (
                // Check against closest ancestor/preceding element
                function(elem, context, xml) {
                  while (elem = elem[dir2]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                      return matcher(elem, context, xml);
                    }
                  }
                  return false;
                }
              ) : (
                // Check against all ancestor/preceding elements
                function(elem, context, xml) {
                  var oldCache, outerCache, newCache = [dirruns, doneName];
                  if (xml) {
                    while (elem = elem[dir2]) {
                      if (elem.nodeType === 1 || checkNonElements) {
                        if (matcher(elem, context, xml)) {
                          return true;
                        }
                      }
                    }
                  } else {
                    while (elem = elem[dir2]) {
                      if (elem.nodeType === 1 || checkNonElements) {
                        outerCache = elem[expando] || (elem[expando] = {});
                        if (skip && nodeName(elem, skip)) {
                          elem = elem[dir2] || elem;
                        } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                          return newCache[2] = oldCache[2];
                        } else {
                          outerCache[key] = newCache;
                          if (newCache[2] = matcher(elem, context, xml)) {
                            return true;
                          }
                        }
                      }
                    }
                  }
                  return false;
                }
              );
            }
            function elementMatcher(matchers2) {
              return matchers2.length > 1 ? function(elem, context, xml) {
                var i2 = matchers2.length;
                while (i2--) {
                  if (!matchers2[i2](elem, context, xml)) {
                    return false;
                  }
                }
                return true;
              } : matchers2[0];
            }
            function multipleContexts(selector, contexts, results) {
              var i2 = 0, len = contexts.length;
              for (; i2 < len; i2++) {
                find(selector, contexts[i2], results);
              }
              return results;
            }
            function condense(unmatched, map, filter, context, xml) {
              var elem, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map != null;
              for (; i2 < len; i2++) {
                if (elem = unmatched[i2]) {
                  if (!filter || filter(elem, context, xml)) {
                    newUnmatched.push(elem);
                    if (mapped) {
                      map.push(i2);
                    }
                  }
                }
              }
              return newUnmatched;
            }
            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
              if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
              }
              if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
              }
              return markFunction(function(seed, results, context, xml) {
                var temp, i2, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
                  selector || "*",
                  context.nodeType ? [context] : context,
                  []
                ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;
                if (matcher) {
                  matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                    // ...intermediate processing is necessary
                    []
                  ) : (
                    // ...otherwise use results directly
                    results
                  );
                  matcher(matcherIn, matcherOut, context, xml);
                } else {
                  matcherOut = matcherIn;
                }
                if (postFilter) {
                  temp = condense(matcherOut, postMap);
                  postFilter(temp, [], context, xml);
                  i2 = temp.length;
                  while (i2--) {
                    if (elem = temp[i2]) {
                      matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
                    }
                  }
                }
                if (seed) {
                  if (postFinder || preFilter) {
                    if (postFinder) {
                      temp = [];
                      i2 = matcherOut.length;
                      while (i2--) {
                        if (elem = matcherOut[i2]) {
                          temp.push(matcherIn[i2] = elem);
                        }
                      }
                      postFinder(null, matcherOut = [], temp, xml);
                    }
                    i2 = matcherOut.length;
                    while (i2--) {
                      if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i2]) > -1) {
                        seed[temp] = !(results[temp] = elem);
                      }
                    }
                  }
                } else {
                  matcherOut = condense(
                    matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
                  );
                  if (postFinder) {
                    postFinder(null, results, matcherOut, xml);
                  } else {
                    push2.apply(results, matcherOut);
                  }
                }
              });
            }
            function matcherFromTokens(tokens) {
              var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                return elem === checkContext;
              }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf.call(checkContext, elem) > -1;
              }, implicitRelative, true), matchers2 = [function(elem, context, xml) {
                var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                checkContext = null;
                return ret;
              }];
              for (; i2 < len; i2++) {
                if (matcher = Expr.relative[tokens[i2].type]) {
                  matchers2 = [addCombinator(elementMatcher(matchers2), matcher)];
                } else {
                  matcher = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
                  if (matcher[expando]) {
                    j = ++i2;
                    for (; j < len; j++) {
                      if (Expr.relative[tokens[j].type]) {
                        break;
                      }
                    }
                    return setMatcher(
                      i2 > 1 && elementMatcher(matchers2),
                      i2 > 1 && toSelector(
                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                        tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })
                      ).replace(rtrimCSS, "$1"),
                      matcher,
                      i2 < j && matcherFromTokens(tokens.slice(i2, j)),
                      j < len && matcherFromTokens(tokens = tokens.slice(j)),
                      j < len && toSelector(tokens)
                    );
                  }
                  matchers2.push(matcher);
                }
              }
              return elementMatcher(matchers2);
            }
            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
              var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i2 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                if (outermost) {
                  outermostContext = context == document3 || context || outermost;
                }
                for (; i2 !== len && (elem = elems[i2]) != null; i2++) {
                  if (byElement && elem) {
                    j = 0;
                    if (!context && elem.ownerDocument != document3) {
                      setDocument(elem);
                      xml = !documentIsHTML;
                    }
                    while (matcher = elementMatchers[j++]) {
                      if (matcher(elem, context || document3, xml)) {
                        push2.call(results, elem);
                        break;
                      }
                    }
                    if (outermost) {
                      dirruns = dirrunsUnique;
                    }
                  }
                  if (bySet) {
                    if (elem = !matcher && elem) {
                      matchedCount--;
                    }
                    if (seed) {
                      unmatched.push(elem);
                    }
                  }
                }
                matchedCount += i2;
                if (bySet && i2 !== matchedCount) {
                  j = 0;
                  while (matcher = setMatchers[j++]) {
                    matcher(unmatched, setMatched, context, xml);
                  }
                  if (seed) {
                    if (matchedCount > 0) {
                      while (i2--) {
                        if (!(unmatched[i2] || setMatched[i2])) {
                          setMatched[i2] = pop.call(results);
                        }
                      }
                    }
                    setMatched = condense(setMatched);
                  }
                  push2.apply(results, setMatched);
                  if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                    jQuery.uniqueSort(results);
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                  outermostContext = contextBackup;
                }
                return unmatched;
              };
              return bySet ? markFunction(superMatcher) : superMatcher;
            }
            function compile2(selector, match) {
              var i2, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
              if (!cached) {
                if (!match) {
                  match = tokenize(selector);
                }
                i2 = match.length;
                while (i2--) {
                  cached = matcherFromTokens(match[i2]);
                  if (cached[expando]) {
                    setMatchers.push(cached);
                  } else {
                    elementMatchers.push(cached);
                  }
                }
                cached = compilerCache(
                  selector,
                  matcherFromGroupMatchers(elementMatchers, setMatchers)
                );
                cached.selector = selector;
              }
              return cached;
            }
            function select(selector, context, results, seed) {
              var i2, tokens, token, type, find2, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
              results = results || [];
              if (match.length === 1) {
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                  context = (Expr.find.ID(
                    token.matches[0].replace(runescape, funescape),
                    context
                  ) || [])[0];
                  if (!context) {
                    return results;
                  } else if (compiled) {
                    context = context.parentNode;
                  }
                  selector = selector.slice(tokens.shift().value.length);
                }
                i2 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
                while (i2--) {
                  token = tokens[i2];
                  if (Expr.relative[type = token.type]) {
                    break;
                  }
                  if (find2 = Expr.find[type]) {
                    if (seed = find2(
                      token.matches[0].replace(runescape, funescape),
                      rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                    )) {
                      tokens.splice(i2, 1);
                      selector = seed.length && toSelector(tokens);
                      if (!selector) {
                        push2.apply(results, seed);
                        return results;
                      }
                      break;
                    }
                  }
                }
              }
              (compiled || compile2(selector, match))(
                seed,
                context,
                !documentIsHTML,
                results,
                !context || rsibling.test(selector) && testContext(context.parentNode) || context
              );
              return results;
            }
            support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
            setDocument();
            support.sortDetached = assert(function(el) {
              return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
            });
            jQuery.find = find;
            jQuery.expr[":"] = jQuery.expr.pseudos;
            jQuery.unique = jQuery.uniqueSort;
            find.compile = compile2;
            find.select = select;
            find.setDocument = setDocument;
            find.tokenize = tokenize;
            find.escape = jQuery.escapeSelector;
            find.getText = jQuery.text;
            find.isXML = jQuery.isXMLDoc;
            find.selectors = jQuery.expr;
            find.support = jQuery.support;
            find.uniqueSort = jQuery.uniqueSort;
          })();
          var dir = function(elem, dir2, until) {
            var matched = [], truncate = until !== void 0;
            while ((elem = elem[dir2]) && elem.nodeType !== 9) {
              if (elem.nodeType === 1) {
                if (truncate && jQuery(elem).is(until)) {
                  break;
                }
                matched.push(elem);
              }
            }
            return matched;
          };
          var siblings = function(n2, elem) {
            var matched = [];
            for (; n2; n2 = n2.nextSibling) {
              if (n2.nodeType === 1 && n2 !== elem) {
                matched.push(n2);
              }
            }
            return matched;
          };
          var rneedsContext = jQuery.expr.match.needsContext;
          var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
          function winnow(elements, qualifier, not) {
            if (isFunction2(qualifier)) {
              return jQuery.grep(elements, function(elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
              });
            }
            if (qualifier.nodeType) {
              return jQuery.grep(elements, function(elem) {
                return elem === qualifier !== not;
              });
            }
            if (typeof qualifier !== "string") {
              return jQuery.grep(elements, function(elem) {
                return indexOf.call(qualifier, elem) > -1 !== not;
              });
            }
            return jQuery.filter(qualifier, elements, not);
          }
          jQuery.filter = function(expr, elems, not) {
            var elem = elems[0];
            if (not) {
              expr = ":not(" + expr + ")";
            }
            if (elems.length === 1 && elem.nodeType === 1) {
              return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
            }
            return jQuery.find.matches(expr, jQuery.grep(elems, function(elem2) {
              return elem2.nodeType === 1;
            }));
          };
          jQuery.fn.extend({
            find: function(selector) {
              var i, ret, len = this.length, self2 = this;
              if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function() {
                  for (i = 0; i < len; i++) {
                    if (jQuery.contains(self2[i], this)) {
                      return true;
                    }
                  }
                }));
              }
              ret = this.pushStack([]);
              for (i = 0; i < len; i++) {
                jQuery.find(selector, self2[i], ret);
              }
              return len > 1 ? jQuery.uniqueSort(ret) : ret;
            },
            filter: function(selector) {
              return this.pushStack(winnow(this, selector || [], false));
            },
            not: function(selector) {
              return this.pushStack(winnow(this, selector || [], true));
            },
            is: function(selector) {
              return !!winnow(
                this,
                // If this is a positional/relative selector, check membership in the returned set
                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [],
                false
              ).length;
            }
          });
          var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context, root2) {
            var match, elem;
            if (!selector) {
              return this;
            }
            root2 = root2 || rootjQuery;
            if (typeof selector === "string") {
              if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                match = [null, selector, null];
              } else {
                match = rquickExpr.exec(selector);
              }
              if (match && (match[1] || !context)) {
                if (match[1]) {
                  context = context instanceof jQuery ? context[0] : context;
                  jQuery.merge(this, jQuery.parseHTML(
                    match[1],
                    context && context.nodeType ? context.ownerDocument || context : document2,
                    true
                  ));
                  if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                    for (match in context) {
                      if (isFunction2(this[match])) {
                        this[match](context[match]);
                      } else {
                        this.attr(match, context[match]);
                      }
                    }
                  }
                  return this;
                } else {
                  elem = document2.getElementById(match[2]);
                  if (elem) {
                    this[0] = elem;
                    this.length = 1;
                  }
                  return this;
                }
              } else if (!context || context.jquery) {
                return (context || root2).find(selector);
              } else {
                return this.constructor(context).find(selector);
              }
            } else if (selector.nodeType) {
              this[0] = selector;
              this.length = 1;
              return this;
            } else if (isFunction2(selector)) {
              return root2.ready !== void 0 ? root2.ready(selector) : (
                // Execute immediately if ready is not present
                selector(jQuery)
              );
            }
            return jQuery.makeArray(selector, this);
          };
          init.prototype = jQuery.fn;
          rootjQuery = jQuery(document2);
          var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
          };
          jQuery.fn.extend({
            has: function(target) {
              var targets = jQuery(target, this), l2 = targets.length;
              return this.filter(function() {
                var i = 0;
                for (; i < l2; i++) {
                  if (jQuery.contains(this, targets[i])) {
                    return true;
                  }
                }
              });
            },
            closest: function(selectors, context) {
              var cur, i = 0, l2 = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
              if (!rneedsContext.test(selectors)) {
                for (; i < l2; i++) {
                  for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                      // Don't pass non-elements to jQuery#find
                      cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors)
                    ))) {
                      matched.push(cur);
                      break;
                    }
                  }
                }
              }
              return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
            },
            // Determine the position of an element within the set
            index: function(elem) {
              if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
              }
              if (typeof elem === "string") {
                return indexOf.call(jQuery(elem), this[0]);
              }
              return indexOf.call(
                this,
                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem
              );
            },
            add: function(selector, context) {
              return this.pushStack(
                jQuery.uniqueSort(
                  jQuery.merge(this.get(), jQuery(selector, context))
                )
              );
            },
            addBack: function(selector) {
              return this.add(
                selector == null ? this.prevObject : this.prevObject.filter(selector)
              );
            }
          });
          function sibling(cur, dir2) {
            while ((cur = cur[dir2]) && cur.nodeType !== 1) {
            }
            return cur;
          }
          jQuery.each({
            parent: function(elem) {
              var parent = elem.parentNode;
              return parent && parent.nodeType !== 11 ? parent : null;
            },
            parents: function(elem) {
              return dir(elem, "parentNode");
            },
            parentsUntil: function(elem, _i, until) {
              return dir(elem, "parentNode", until);
            },
            next: function(elem) {
              return sibling(elem, "nextSibling");
            },
            prev: function(elem) {
              return sibling(elem, "previousSibling");
            },
            nextAll: function(elem) {
              return dir(elem, "nextSibling");
            },
            prevAll: function(elem) {
              return dir(elem, "previousSibling");
            },
            nextUntil: function(elem, _i, until) {
              return dir(elem, "nextSibling", until);
            },
            prevUntil: function(elem, _i, until) {
              return dir(elem, "previousSibling", until);
            },
            siblings: function(elem) {
              return siblings((elem.parentNode || {}).firstChild, elem);
            },
            children: function(elem) {
              return siblings(elem.firstChild);
            },
            contents: function(elem) {
              if (elem.contentDocument != null && // Support: IE 11+
              // <object> elements with no `data` attribute has an object
              // `contentDocument` with a `null` prototype.
              getProto2(elem.contentDocument)) {
                return elem.contentDocument;
              }
              if (nodeName(elem, "template")) {
                elem = elem.content || elem;
              }
              return jQuery.merge([], elem.childNodes);
            }
          }, function(name, fn2) {
            jQuery.fn[name] = function(until, selector) {
              var matched = jQuery.map(this, fn2, until);
              if (name.slice(-5) !== "Until") {
                selector = until;
              }
              if (selector && typeof selector === "string") {
                matched = jQuery.filter(selector, matched);
              }
              if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                  jQuery.uniqueSort(matched);
                }
                if (rparentsprev.test(name)) {
                  matched.reverse();
                }
              }
              return this.pushStack(matched);
            };
          });
          var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
          function createOptions(options) {
            var object = {};
            jQuery.each(options.match(rnothtmlwhite) || [], function(_2, flag) {
              object[flag] = true;
            });
            return object;
          }
          jQuery.Callbacks = function(options) {
            options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
            var firing, memory, fired, locked, list = [], queue2 = [], firingIndex = -1, fire = function() {
              locked = locked || options.once;
              fired = firing = true;
              for (; queue2.length; firingIndex = -1) {
                memory = queue2.shift();
                while (++firingIndex < list.length) {
                  if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                    firingIndex = list.length;
                    memory = false;
                  }
                }
              }
              if (!options.memory) {
                memory = false;
              }
              firing = false;
              if (locked) {
                if (memory) {
                  list = [];
                } else {
                  list = "";
                }
              }
            }, self2 = {
              // Add a callback or a collection of callbacks to the list
              add: function() {
                if (list) {
                  if (memory && !firing) {
                    firingIndex = list.length - 1;
                    queue2.push(memory);
                  }
                  (function add2(args) {
                    jQuery.each(args, function(_2, arg) {
                      if (isFunction2(arg)) {
                        if (!options.unique || !self2.has(arg)) {
                          list.push(arg);
                        }
                      } else if (arg && arg.length && toType(arg) !== "string") {
                        add2(arg);
                      }
                    });
                  })(arguments);
                  if (memory && !firing) {
                    fire();
                  }
                }
                return this;
              },
              // Remove a callback from the list
              remove: function() {
                jQuery.each(arguments, function(_2, arg) {
                  var index;
                  while ((index = jQuery.inArray(arg, list, index)) > -1) {
                    list.splice(index, 1);
                    if (index <= firingIndex) {
                      firingIndex--;
                    }
                  }
                });
                return this;
              },
              // Check if a given callback is in the list.
              // If no argument is given, return whether or not list has callbacks attached.
              has: function(fn2) {
                return fn2 ? jQuery.inArray(fn2, list) > -1 : list.length > 0;
              },
              // Remove all callbacks from the list
              empty: function() {
                if (list) {
                  list = [];
                }
                return this;
              },
              // Disable .fire and .add
              // Abort any current/pending executions
              // Clear all callbacks and values
              disable: function() {
                locked = queue2 = [];
                list = memory = "";
                return this;
              },
              disabled: function() {
                return !list;
              },
              // Disable .fire
              // Also disable .add unless we have memory (since it would have no effect)
              // Abort any pending executions
              lock: function() {
                locked = queue2 = [];
                if (!memory && !firing) {
                  list = memory = "";
                }
                return this;
              },
              locked: function() {
                return !!locked;
              },
              // Call all callbacks with the given context and arguments
              fireWith: function(context, args) {
                if (!locked) {
                  args = args || [];
                  args = [context, args.slice ? args.slice() : args];
                  queue2.push(args);
                  if (!firing) {
                    fire();
                  }
                }
                return this;
              },
              // Call all the callbacks with the given arguments
              fire: function() {
                self2.fireWith(this, arguments);
                return this;
              },
              // To know if the callbacks have already been called at least once
              fired: function() {
                return !!fired;
              }
            };
            return self2;
          };
          function Identity(v) {
            return v;
          }
          function Thrower(ex) {
            throw ex;
          }
          function adoptValue(value, resolve2, reject, noValue) {
            var method;
            try {
              if (value && isFunction2(method = value.promise)) {
                method.call(value).done(resolve2).fail(reject);
              } else if (value && isFunction2(method = value.then)) {
                method.call(value, resolve2, reject);
              } else {
                resolve2.apply(void 0, [value].slice(noValue));
              }
            } catch (value2) {
              reject.apply(void 0, [value2]);
            }
          }
          jQuery.extend({
            Deferred: function(func) {
              var tuples = [
                // action, add listener, callbacks,
                // ... .then handlers, argument index, [final state]
                [
                  "notify",
                  "progress",
                  jQuery.Callbacks("memory"),
                  jQuery.Callbacks("memory"),
                  2
                ],
                [
                  "resolve",
                  "done",
                  jQuery.Callbacks("once memory"),
                  jQuery.Callbacks("once memory"),
                  0,
                  "resolved"
                ],
                [
                  "reject",
                  "fail",
                  jQuery.Callbacks("once memory"),
                  jQuery.Callbacks("once memory"),
                  1,
                  "rejected"
                ]
              ], state = "pending", promise = {
                state: function() {
                  return state;
                },
                always: function() {
                  deferred.done(arguments).fail(arguments);
                  return this;
                },
                "catch": function(fn2) {
                  return promise.then(null, fn2);
                },
                // Keep pipe for back-compat
                pipe: function() {
                  var fns = arguments;
                  return jQuery.Deferred(function(newDefer) {
                    jQuery.each(tuples, function(_i, tuple) {
                      var fn2 = isFunction2(fns[tuple[4]]) && fns[tuple[4]];
                      deferred[tuple[1]](function() {
                        var returned = fn2 && fn2.apply(this, arguments);
                        if (returned && isFunction2(returned.promise)) {
                          returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                        } else {
                          newDefer[tuple[0] + "With"](
                            this,
                            fn2 ? [returned] : arguments
                          );
                        }
                      });
                    });
                    fns = null;
                  }).promise();
                },
                then: function(onFulfilled, onRejected, onProgress) {
                  var maxDepth = 0;
                  function resolve2(depth, deferred2, handler, special) {
                    return function() {
                      var that = this, args = arguments, mightThrow = function() {
                        var returned, then;
                        if (depth < maxDepth) {
                          return;
                        }
                        returned = handler.apply(that, args);
                        if (returned === deferred2.promise()) {
                          throw new TypeError("Thenable self-resolution");
                        }
                        then = returned && // Support: Promises/A+ section 2.3.4
                        // https://promisesaplus.com/#point-64
                        // Only check objects and functions for thenability
                        (typeof returned === "object" || typeof returned === "function") && returned.then;
                        if (isFunction2(then)) {
                          if (special) {
                            then.call(
                              returned,
                              resolve2(maxDepth, deferred2, Identity, special),
                              resolve2(maxDepth, deferred2, Thrower, special)
                            );
                          } else {
                            maxDepth++;
                            then.call(
                              returned,
                              resolve2(maxDepth, deferred2, Identity, special),
                              resolve2(maxDepth, deferred2, Thrower, special),
                              resolve2(
                                maxDepth,
                                deferred2,
                                Identity,
                                deferred2.notifyWith
                              )
                            );
                          }
                        } else {
                          if (handler !== Identity) {
                            that = void 0;
                            args = [returned];
                          }
                          (special || deferred2.resolveWith)(that, args);
                        }
                      }, process = special ? mightThrow : function() {
                        try {
                          mightThrow();
                        } catch (e2) {
                          if (jQuery.Deferred.exceptionHook) {
                            jQuery.Deferred.exceptionHook(
                              e2,
                              process.error
                            );
                          }
                          if (depth + 1 >= maxDepth) {
                            if (handler !== Thrower) {
                              that = void 0;
                              args = [e2];
                            }
                            deferred2.rejectWith(that, args);
                          }
                        }
                      };
                      if (depth) {
                        process();
                      } else {
                        if (jQuery.Deferred.getErrorHook) {
                          process.error = jQuery.Deferred.getErrorHook();
                        } else if (jQuery.Deferred.getStackHook) {
                          process.error = jQuery.Deferred.getStackHook();
                        }
                        window2.setTimeout(process);
                      }
                    };
                  }
                  return jQuery.Deferred(function(newDefer) {
                    tuples[0][3].add(
                      resolve2(
                        0,
                        newDefer,
                        isFunction2(onProgress) ? onProgress : Identity,
                        newDefer.notifyWith
                      )
                    );
                    tuples[1][3].add(
                      resolve2(
                        0,
                        newDefer,
                        isFunction2(onFulfilled) ? onFulfilled : Identity
                      )
                    );
                    tuples[2][3].add(
                      resolve2(
                        0,
                        newDefer,
                        isFunction2(onRejected) ? onRejected : Thrower
                      )
                    );
                  }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function(obj) {
                  return obj != null ? jQuery.extend(obj, promise) : promise;
                }
              }, deferred = {};
              jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[5];
                promise[tuple[1]] = list.add;
                if (stateString) {
                  list.add(
                    function() {
                      state = stateString;
                    },
                    // rejected_callbacks.disable
                    // fulfilled_callbacks.disable
                    tuples[3 - i][2].disable,
                    // rejected_handlers.disable
                    // fulfilled_handlers.disable
                    tuples[3 - i][3].disable,
                    // progress_callbacks.lock
                    tuples[0][2].lock,
                    // progress_handlers.lock
                    tuples[0][3].lock
                  );
                }
                list.add(tuple[3].fire);
                deferred[tuple[0]] = function() {
                  deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
                  return this;
                };
                deferred[tuple[0] + "With"] = list.fireWith;
              });
              promise.promise(deferred);
              if (func) {
                func.call(deferred, deferred);
              }
              return deferred;
            },
            // Deferred helper
            when: function(singleValue) {
              var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), primary = jQuery.Deferred(), updateFunc = function(i2) {
                return function(value) {
                  resolveContexts[i2] = this;
                  resolveValues[i2] = arguments.length > 1 ? slice.call(arguments) : value;
                  if (!--remaining) {
                    primary.resolveWith(resolveContexts, resolveValues);
                  }
                };
              };
              if (remaining <= 1) {
                adoptValue(
                  singleValue,
                  primary.done(updateFunc(i)).resolve,
                  primary.reject,
                  !remaining
                );
                if (primary.state() === "pending" || isFunction2(resolveValues[i] && resolveValues[i].then)) {
                  return primary.then();
                }
              }
              while (i--) {
                adoptValue(resolveValues[i], updateFunc(i), primary.reject);
              }
              return primary.promise();
            }
          });
          var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
          jQuery.Deferred.exceptionHook = function(error, asyncError) {
            if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
              window2.console.warn(
                "jQuery.Deferred exception: " + error.message,
                error.stack,
                asyncError
              );
            }
          };
          jQuery.readyException = function(error) {
            window2.setTimeout(function() {
              throw error;
            });
          };
          var readyList = jQuery.Deferred();
          jQuery.fn.ready = function(fn2) {
            readyList.then(fn2).catch(function(error) {
              jQuery.readyException(error);
            });
            return this;
          };
          jQuery.extend({
            // Is the DOM ready to be used? Set to true once it occurs.
            isReady: false,
            // A counter to track how many items to wait for before
            // the ready event fires. See trac-6781
            readyWait: 1,
            // Handle when the DOM is ready
            ready: function(wait) {
              if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
              }
              jQuery.isReady = true;
              if (wait !== true && --jQuery.readyWait > 0) {
                return;
              }
              readyList.resolveWith(document2, [jQuery]);
            }
          });
          jQuery.ready.then = readyList.then;
          function completed() {
            document2.removeEventListener("DOMContentLoaded", completed);
            window2.removeEventListener("load", completed);
            jQuery.ready();
          }
          if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
            window2.setTimeout(jQuery.ready);
          } else {
            document2.addEventListener("DOMContentLoaded", completed);
            window2.addEventListener("load", completed);
          }
          var access = function(elems, fn2, key, value, chainable, emptyGet, raw) {
            var i = 0, len = elems.length, bulk = key == null;
            if (toType(key) === "object") {
              chainable = true;
              for (i in key) {
                access(elems, fn2, i, key[i], true, emptyGet, raw);
              }
            } else if (value !== void 0) {
              chainable = true;
              if (!isFunction2(value)) {
                raw = true;
              }
              if (bulk) {
                if (raw) {
                  fn2.call(elems, value);
                  fn2 = null;
                } else {
                  bulk = fn2;
                  fn2 = function(elem, _key, value2) {
                    return bulk.call(jQuery(elem), value2);
                  };
                }
              }
              if (fn2) {
                for (; i < len; i++) {
                  fn2(
                    elems[i],
                    key,
                    raw ? value : value.call(elems[i], i, fn2(elems[i], key))
                  );
                }
              }
            }
            if (chainable) {
              return elems;
            }
            if (bulk) {
              return fn2.call(elems);
            }
            return len ? fn2(elems[0], key) : emptyGet;
          };
          var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
          function fcamelCase(_all, letter) {
            return letter.toUpperCase();
          }
          function camelCase(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
          }
          var acceptData = function(owner) {
            return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
          };
          function Data() {
            this.expando = jQuery.expando + Data.uid++;
          }
          Data.uid = 1;
          Data.prototype = {
            cache: function(owner) {
              var value = owner[this.expando];
              if (!value) {
                value = {};
                if (acceptData(owner)) {
                  if (owner.nodeType) {
                    owner[this.expando] = value;
                  } else {
                    Object.defineProperty(owner, this.expando, {
                      value,
                      configurable: true
                    });
                  }
                }
              }
              return value;
            },
            set: function(owner, data, value) {
              var prop, cache = this.cache(owner);
              if (typeof data === "string") {
                cache[camelCase(data)] = value;
              } else {
                for (prop in data) {
                  cache[camelCase(prop)] = data[prop];
                }
              }
              return cache;
            },
            get: function(owner, key) {
              return key === void 0 ? this.cache(owner) : (
                // Always use camelCase key (gh-2257)
                owner[this.expando] && owner[this.expando][camelCase(key)]
              );
            },
            access: function(owner, key, value) {
              if (key === void 0 || key && typeof key === "string" && value === void 0) {
                return this.get(owner, key);
              }
              this.set(owner, key, value);
              return value !== void 0 ? value : key;
            },
            remove: function(owner, key) {
              var i, cache = owner[this.expando];
              if (cache === void 0) {
                return;
              }
              if (key !== void 0) {
                if (Array.isArray(key)) {
                  key = key.map(camelCase);
                } else {
                  key = camelCase(key);
                  key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
                }
                i = key.length;
                while (i--) {
                  delete cache[key[i]];
                }
              }
              if (key === void 0 || jQuery.isEmptyObject(cache)) {
                if (owner.nodeType) {
                  owner[this.expando] = void 0;
                } else {
                  delete owner[this.expando];
                }
              }
            },
            hasData: function(owner) {
              var cache = owner[this.expando];
              return cache !== void 0 && !jQuery.isEmptyObject(cache);
            }
          };
          var dataPriv = new Data();
          var dataUser = new Data();
          var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
          function getData(data) {
            if (data === "true") {
              return true;
            }
            if (data === "false") {
              return false;
            }
            if (data === "null") {
              return null;
            }
            if (data === +data + "") {
              return +data;
            }
            if (rbrace.test(data)) {
              return JSON.parse(data);
            }
            return data;
          }
          function dataAttr(elem, key, data) {
            var name;
            if (data === void 0 && elem.nodeType === 1) {
              name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
              data = elem.getAttribute(name);
              if (typeof data === "string") {
                try {
                  data = getData(data);
                } catch (e2) {
                }
                dataUser.set(elem, key, data);
              } else {
                data = void 0;
              }
            }
            return data;
          }
          jQuery.extend({
            hasData: function(elem) {
              return dataUser.hasData(elem) || dataPriv.hasData(elem);
            },
            data: function(elem, name, data) {
              return dataUser.access(elem, name, data);
            },
            removeData: function(elem, name) {
              dataUser.remove(elem, name);
            },
            // TODO: Now that all calls to _data and _removeData have been replaced
            // with direct calls to dataPriv methods, these can be deprecated.
            _data: function(elem, name, data) {
              return dataPriv.access(elem, name, data);
            },
            _removeData: function(elem, name) {
              dataPriv.remove(elem, name);
            }
          });
          jQuery.fn.extend({
            data: function(key, value) {
              var i, name, data, elem = this[0], attrs = elem && elem.attributes;
              if (key === void 0) {
                if (this.length) {
                  data = dataUser.get(elem);
                  if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                    i = attrs.length;
                    while (i--) {
                      if (attrs[i]) {
                        name = attrs[i].name;
                        if (name.indexOf("data-") === 0) {
                          name = camelCase(name.slice(5));
                          dataAttr(elem, name, data[name]);
                        }
                      }
                    }
                    dataPriv.set(elem, "hasDataAttrs", true);
                  }
                }
                return data;
              }
              if (typeof key === "object") {
                return this.each(function() {
                  dataUser.set(this, key);
                });
              }
              return access(this, function(value2) {
                var data2;
                if (elem && value2 === void 0) {
                  data2 = dataUser.get(elem, key);
                  if (data2 !== void 0) {
                    return data2;
                  }
                  data2 = dataAttr(elem, key);
                  if (data2 !== void 0) {
                    return data2;
                  }
                  return;
                }
                this.each(function() {
                  dataUser.set(this, key, value2);
                });
              }, null, value, arguments.length > 1, null, true);
            },
            removeData: function(key) {
              return this.each(function() {
                dataUser.remove(this, key);
              });
            }
          });
          jQuery.extend({
            queue: function(elem, type, data) {
              var queue2;
              if (elem) {
                type = (type || "fx") + "queue";
                queue2 = dataPriv.get(elem, type);
                if (data) {
                  if (!queue2 || Array.isArray(data)) {
                    queue2 = dataPriv.access(elem, type, jQuery.makeArray(data));
                  } else {
                    queue2.push(data);
                  }
                }
                return queue2 || [];
              }
            },
            dequeue: function(elem, type) {
              type = type || "fx";
              var queue2 = jQuery.queue(elem, type), startLength = queue2.length, fn2 = queue2.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
              };
              if (fn2 === "inprogress") {
                fn2 = queue2.shift();
                startLength--;
              }
              if (fn2) {
                if (type === "fx") {
                  queue2.unshift("inprogress");
                }
                delete hooks.stop;
                fn2.call(elem, next, hooks);
              }
              if (!startLength && hooks) {
                hooks.empty.fire();
              }
            },
            // Not public - generate a queueHooks object, or return the current one
            _queueHooks: function(elem, type) {
              var key = type + "queueHooks";
              return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                  dataPriv.remove(elem, [type + "queue", key]);
                })
              });
            }
          });
          jQuery.fn.extend({
            queue: function(type, data) {
              var setter = 2;
              if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
              }
              if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
              }
              return data === void 0 ? this : this.each(function() {
                var queue2 = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === "fx" && queue2[0] !== "inprogress") {
                  jQuery.dequeue(this, type);
                }
              });
            },
            dequeue: function(type) {
              return this.each(function() {
                jQuery.dequeue(this, type);
              });
            },
            clearQueue: function(type) {
              return this.queue(type || "fx", []);
            },
            // Get a promise resolved when queues of a certain type
            // are emptied (fx is the type by default)
            promise: function(type, obj) {
              var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve2 = function() {
                if (!--count) {
                  defer.resolveWith(elements, [elements]);
                }
              };
              if (typeof type !== "string") {
                obj = type;
                type = void 0;
              }
              type = type || "fx";
              while (i--) {
                tmp = dataPriv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                  count++;
                  tmp.empty.add(resolve2);
                }
              }
              resolve2();
              return defer.promise(obj);
            }
          });
          var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
          var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
          var cssExpand = ["Top", "Right", "Bottom", "Left"];
          var documentElement = document2.documentElement;
          var isAttached = function(elem) {
            return jQuery.contains(elem.ownerDocument, elem);
          }, composed = { composed: true };
          if (documentElement.getRootNode) {
            isAttached = function(elem) {
              return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
            };
          }
          var isHiddenWithinTree = function(elem, el) {
            elem = el || elem;
            return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
            // Support: Firefox <=43 - 45
            // Disconnected elements can have computed display: none, so first confirm that elem is
            // in the document.
            isAttached(elem) && jQuery.css(elem, "display") === "none";
          };
          function adjustCSS(elem, prop, valueParts, tween) {
            var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
              return tween.cur();
            } : function() {
              return jQuery.css(elem, prop, "");
            }, initial = currentValue(), unit2 = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit2 !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
            if (initialInUnit && initialInUnit[3] !== unit2) {
              initial = initial / 2;
              unit2 = unit2 || initialInUnit[3];
              initialInUnit = +initial || 1;
              while (maxIterations--) {
                jQuery.style(elem, prop, initialInUnit + unit2);
                if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
                  maxIterations = 0;
                }
                initialInUnit = initialInUnit / scale;
              }
              initialInUnit = initialInUnit * 2;
              jQuery.style(elem, prop, initialInUnit + unit2);
              valueParts = valueParts || [];
            }
            if (valueParts) {
              initialInUnit = +initialInUnit || +initial || 0;
              adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
              if (tween) {
                tween.unit = unit2;
                tween.start = initialInUnit;
                tween.end = adjusted;
              }
            }
            return adjusted;
          }
          var defaultDisplayMap = {};
          function getDefaultDisplay(elem) {
            var temp, doc2 = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
            if (display) {
              return display;
            }
            temp = doc2.body.appendChild(doc2.createElement(nodeName2));
            display = jQuery.css(temp, "display");
            temp.parentNode.removeChild(temp);
            if (display === "none") {
              display = "block";
            }
            defaultDisplayMap[nodeName2] = display;
            return display;
          }
          function showHide(elements, show) {
            var display, elem, values = [], index = 0, length = elements.length;
            for (; index < length; index++) {
              elem = elements[index];
              if (!elem.style) {
                continue;
              }
              display = elem.style.display;
              if (show) {
                if (display === "none") {
                  values[index] = dataPriv.get(elem, "display") || null;
                  if (!values[index]) {
                    elem.style.display = "";
                  }
                }
                if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                  values[index] = getDefaultDisplay(elem);
                }
              } else {
                if (display !== "none") {
                  values[index] = "none";
                  dataPriv.set(elem, "display", display);
                }
              }
            }
            for (index = 0; index < length; index++) {
              if (values[index] != null) {
                elements[index].style.display = values[index];
              }
            }
            return elements;
          }
          jQuery.fn.extend({
            show: function() {
              return showHide(this, true);
            },
            hide: function() {
              return showHide(this);
            },
            toggle: function(state) {
              if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
              }
              return this.each(function() {
                if (isHiddenWithinTree(this)) {
                  jQuery(this).show();
                } else {
                  jQuery(this).hide();
                }
              });
            }
          });
          var rcheckableType = /^(?:checkbox|radio)$/i;
          var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
          var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
          (function() {
            var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
            input.setAttribute("type", "radio");
            input.setAttribute("checked", "checked");
            input.setAttribute("name", "t");
            div.appendChild(input);
            support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
            div.innerHTML = "<textarea>x</textarea>";
            support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
            div.innerHTML = "<option></option>";
            support.option = !!div.lastChild;
          })();
          var wrapMap = {
            // XHTML parsers do not magically insert elements in the
            // same way that tag soup parsers do. So we cannot shorten
            // this by omitting <tbody> or other required elements.
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
          };
          wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
          wrapMap.th = wrapMap.td;
          if (!support.option) {
            wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
          }
          function getAll(context, tag) {
            var ret;
            if (typeof context.getElementsByTagName !== "undefined") {
              ret = context.getElementsByTagName(tag || "*");
            } else if (typeof context.querySelectorAll !== "undefined") {
              ret = context.querySelectorAll(tag || "*");
            } else {
              ret = [];
            }
            if (tag === void 0 || tag && nodeName(context, tag)) {
              return jQuery.merge([context], ret);
            }
            return ret;
          }
          function setGlobalEval(elems, refElements) {
            var i = 0, l2 = elems.length;
            for (; i < l2; i++) {
              dataPriv.set(
                elems[i],
                "globalEval",
                !refElements || dataPriv.get(refElements[i], "globalEval")
              );
            }
          }
          var rhtml = /<|&#?\w+;/;
          function buildFragment(elems, context, scripts, selection, ignored) {
            var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l2 = elems.length;
            for (; i < l2; i++) {
              elem = elems[i];
              if (elem || elem === 0) {
                if (toType(elem) === "object") {
                  jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                } else if (!rhtml.test(elem)) {
                  nodes.push(context.createTextNode(elem));
                } else {
                  tmp = tmp || fragment.appendChild(context.createElement("div"));
                  tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                  wrap = wrapMap[tag] || wrapMap._default;
                  tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
                  j = wrap[0];
                  while (j--) {
                    tmp = tmp.lastChild;
                  }
                  jQuery.merge(nodes, tmp.childNodes);
                  tmp = fragment.firstChild;
                  tmp.textContent = "";
                }
              }
            }
            fragment.textContent = "";
            i = 0;
            while (elem = nodes[i++]) {
              if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) {
                  ignored.push(elem);
                }
                continue;
              }
              attached = isAttached(elem);
              tmp = getAll(fragment.appendChild(elem), "script");
              if (attached) {
                setGlobalEval(tmp);
              }
              if (scripts) {
                j = 0;
                while (elem = tmp[j++]) {
                  if (rscriptType.test(elem.type || "")) {
                    scripts.push(elem);
                  }
                }
              }
            }
            return fragment;
          }
          var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
          function returnTrue() {
            return true;
          }
          function returnFalse() {
            return false;
          }
          function on2(elem, types, selector, data, fn2, one) {
            var origFn, type;
            if (typeof types === "object") {
              if (typeof selector !== "string") {
                data = data || selector;
                selector = void 0;
              }
              for (type in types) {
                on2(elem, type, selector, data, types[type], one);
              }
              return elem;
            }
            if (data == null && fn2 == null) {
              fn2 = selector;
              data = selector = void 0;
            } else if (fn2 == null) {
              if (typeof selector === "string") {
                fn2 = data;
                data = void 0;
              } else {
                fn2 = data;
                data = selector;
                selector = void 0;
              }
            }
            if (fn2 === false) {
              fn2 = returnFalse;
            } else if (!fn2) {
              return elem;
            }
            if (one === 1) {
              origFn = fn2;
              fn2 = function(event) {
                jQuery().off(event);
                return origFn.apply(this, arguments);
              };
              fn2.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return elem.each(function() {
              jQuery.event.add(this, types, fn2, data, selector);
            });
          }
          jQuery.event = {
            global: {},
            add: function(elem, types, handler, data, selector) {
              var handleObjIn, eventHandle, tmp, events, t2, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
              if (!acceptData(elem)) {
                return;
              }
              if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
              }
              if (selector) {
                jQuery.find.matchesSelector(documentElement, selector);
              }
              if (!handler.guid) {
                handler.guid = jQuery.guid++;
              }
              if (!(events = elemData.events)) {
                events = elemData.events = /* @__PURE__ */ Object.create(null);
              }
              if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function(e2) {
                  return typeof jQuery !== "undefined" && jQuery.event.triggered !== e2.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
                };
              }
              types = (types || "").match(rnothtmlwhite) || [""];
              t2 = types.length;
              while (t2--) {
                tmp = rtypenamespace.exec(types[t2]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                  continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                  type,
                  origType,
                  data,
                  handler,
                  guid: handler.guid,
                  selector,
                  needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                  namespace: namespaces.join(".")
                }, handleObjIn);
                if (!(handlers = events[type])) {
                  handlers = events[type] = [];
                  handlers.delegateCount = 0;
                  if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                    if (elem.addEventListener) {
                      elem.addEventListener(type, eventHandle);
                    }
                  }
                }
                if (special.add) {
                  special.add.call(elem, handleObj);
                  if (!handleObj.handler.guid) {
                    handleObj.handler.guid = handler.guid;
                  }
                }
                if (selector) {
                  handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                  handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
              }
            },
            // Detach an event or set of events from an element
            remove: function(elem, types, handler, selector, mappedTypes) {
              var j, origCount, tmp, events, t2, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
              if (!elemData || !(events = elemData.events)) {
                return;
              }
              types = (types || "").match(rnothtmlwhite) || [""];
              t2 = types.length;
              while (t2--) {
                tmp = rtypenamespace.exec(types[t2]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                  for (type in events) {
                    jQuery.event.remove(elem, type + types[t2], handler, selector, true);
                  }
                  continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                origCount = j = handlers.length;
                while (j--) {
                  handleObj = handlers[j];
                  if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                    handlers.splice(j, 1);
                    if (handleObj.selector) {
                      handlers.delegateCount--;
                    }
                    if (special.remove) {
                      special.remove.call(elem, handleObj);
                    }
                  }
                }
                if (origCount && !handlers.length) {
                  if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                    jQuery.removeEvent(elem, type, elemData.handle);
                  }
                  delete events[type];
                }
              }
              if (jQuery.isEmptyObject(events)) {
                dataPriv.remove(elem, "handle events");
              }
            },
            dispatch: function(nativeEvent) {
              var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery.event.special[event.type] || {};
              args[0] = event;
              for (i = 1; i < arguments.length; i++) {
                args[i] = arguments[i];
              }
              event.delegateTarget = this;
              if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
              }
              handlerQueue = jQuery.event.handlers.call(this, event, handlers);
              i = 0;
              while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                  if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                    event.handleObj = handleObj;
                    event.data = handleObj.data;
                    ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                    if (ret !== void 0) {
                      if ((event.result = ret) === false) {
                        event.preventDefault();
                        event.stopPropagation();
                      }
                    }
                  }
                }
              }
              if (special.postDispatch) {
                special.postDispatch.call(this, event);
              }
              return event.result;
            },
            handlers: function(event, handlers) {
              var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
              if (delegateCount && // Support: IE <=9
              // Black-hole SVG <use> instance trees (trac-13180)
              cur.nodeType && // Support: Firefox <=42
              // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
              // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
              // Support: IE 11 only
              // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
              !(event.type === "click" && event.button >= 1)) {
                for (; cur !== this; cur = cur.parentNode || this) {
                  if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                    matchedHandlers = [];
                    matchedSelectors = {};
                    for (i = 0; i < delegateCount; i++) {
                      handleObj = handlers[i];
                      sel = handleObj.selector + " ";
                      if (matchedSelectors[sel] === void 0) {
                        matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                      }
                      if (matchedSelectors[sel]) {
                        matchedHandlers.push(handleObj);
                      }
                    }
                    if (matchedHandlers.length) {
                      handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                    }
                  }
                }
              }
              cur = this;
              if (delegateCount < handlers.length) {
                handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
              }
              return handlerQueue;
            },
            addProp: function(name, hook) {
              Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: true,
                configurable: true,
                get: isFunction2(hook) ? function() {
                  if (this.originalEvent) {
                    return hook(this.originalEvent);
                  }
                } : function() {
                  if (this.originalEvent) {
                    return this.originalEvent[name];
                  }
                },
                set: function(value) {
                  Object.defineProperty(this, name, {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value
                  });
                }
              });
            },
            fix: function(originalEvent) {
              return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
            },
            special: {
              load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
              },
              click: {
                // Utilize native event to ensure correct state for checkable inputs
                setup: function(data) {
                  var el = this || data;
                  if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                    leverageNative(el, "click", true);
                  }
                  return false;
                },
                trigger: function(data) {
                  var el = this || data;
                  if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                    leverageNative(el, "click");
                  }
                  return true;
                },
                // For cross-browser consistency, suppress native .click() on links
                // Also prevent it if we're currently inside a leveraged native-event stack
                _default: function(event) {
                  var target = event.target;
                  return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
                }
              },
              beforeunload: {
                postDispatch: function(event) {
                  if (event.result !== void 0 && event.originalEvent) {
                    event.originalEvent.returnValue = event.result;
                  }
                }
              }
            }
          };
          function leverageNative(el, type, isSetup) {
            if (!isSetup) {
              if (dataPriv.get(el, type) === void 0) {
                jQuery.event.add(el, type, returnTrue);
              }
              return;
            }
            dataPriv.set(el, type, false);
            jQuery.event.add(el, type, {
              namespace: false,
              handler: function(event) {
                var result, saved = dataPriv.get(this, type);
                if (event.isTrigger & 1 && this[type]) {
                  if (!saved) {
                    saved = slice.call(arguments);
                    dataPriv.set(this, type, saved);
                    this[type]();
                    result = dataPriv.get(this, type);
                    dataPriv.set(this, type, false);
                    if (saved !== result) {
                      event.stopImmediatePropagation();
                      event.preventDefault();
                      return result;
                    }
                  } else if ((jQuery.event.special[type] || {}).delegateType) {
                    event.stopPropagation();
                  }
                } else if (saved) {
                  dataPriv.set(this, type, jQuery.event.trigger(
                    saved[0],
                    saved.slice(1),
                    this
                  ));
                  event.stopPropagation();
                  event.isImmediatePropagationStopped = returnTrue;
                }
              }
            });
          }
          jQuery.removeEvent = function(elem, type, handle) {
            if (elem.removeEventListener) {
              elem.removeEventListener(type, handle);
            }
          };
          jQuery.Event = function(src, props) {
            if (!(this instanceof jQuery.Event)) {
              return new jQuery.Event(src, props);
            }
            if (src && src.type) {
              this.originalEvent = src;
              this.type = src.type;
              this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
              src.returnValue === false ? returnTrue : returnFalse;
              this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
              this.currentTarget = src.currentTarget;
              this.relatedTarget = src.relatedTarget;
            } else {
              this.type = src;
            }
            if (props) {
              jQuery.extend(this, props);
            }
            this.timeStamp = src && src.timeStamp || Date.now();
            this[jQuery.expando] = true;
          };
          jQuery.Event.prototype = {
            constructor: jQuery.Event,
            isDefaultPrevented: returnFalse,
            isPropagationStopped: returnFalse,
            isImmediatePropagationStopped: returnFalse,
            isSimulated: false,
            preventDefault: function() {
              var e2 = this.originalEvent;
              this.isDefaultPrevented = returnTrue;
              if (e2 && !this.isSimulated) {
                e2.preventDefault();
              }
            },
            stopPropagation: function() {
              var e2 = this.originalEvent;
              this.isPropagationStopped = returnTrue;
              if (e2 && !this.isSimulated) {
                e2.stopPropagation();
              }
            },
            stopImmediatePropagation: function() {
              var e2 = this.originalEvent;
              this.isImmediatePropagationStopped = returnTrue;
              if (e2 && !this.isSimulated) {
                e2.stopImmediatePropagation();
              }
              this.stopPropagation();
            }
          };
          jQuery.each({
            altKey: true,
            bubbles: true,
            cancelable: true,
            changedTouches: true,
            ctrlKey: true,
            detail: true,
            eventPhase: true,
            metaKey: true,
            pageX: true,
            pageY: true,
            shiftKey: true,
            view: true,
            "char": true,
            code: true,
            charCode: true,
            key: true,
            keyCode: true,
            button: true,
            buttons: true,
            clientX: true,
            clientY: true,
            offsetX: true,
            offsetY: true,
            pointerId: true,
            pointerType: true,
            screenX: true,
            screenY: true,
            targetTouches: true,
            toElement: true,
            touches: true,
            which: true
          }, jQuery.event.addProp);
          jQuery.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
            function focusMappedHandler(nativeEvent) {
              if (document2.documentMode) {
                var handle = dataPriv.get(this, "handle"), event = jQuery.event.fix(nativeEvent);
                event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
                event.isSimulated = true;
                handle(nativeEvent);
                if (event.target === event.currentTarget) {
                  handle(event);
                }
              } else {
                jQuery.event.simulate(
                  delegateType,
                  nativeEvent.target,
                  jQuery.event.fix(nativeEvent)
                );
              }
            }
            jQuery.event.special[type] = {
              // Utilize native event if possible so blur/focus sequence is correct
              setup: function() {
                var attaches;
                leverageNative(this, type, true);
                if (document2.documentMode) {
                  attaches = dataPriv.get(this, delegateType);
                  if (!attaches) {
                    this.addEventListener(delegateType, focusMappedHandler);
                  }
                  dataPriv.set(this, delegateType, (attaches || 0) + 1);
                } else {
                  return false;
                }
              },
              trigger: function() {
                leverageNative(this, type);
                return true;
              },
              teardown: function() {
                var attaches;
                if (document2.documentMode) {
                  attaches = dataPriv.get(this, delegateType) - 1;
                  if (!attaches) {
                    this.removeEventListener(delegateType, focusMappedHandler);
                    dataPriv.remove(this, delegateType);
                  } else {
                    dataPriv.set(this, delegateType, attaches);
                  }
                } else {
                  return false;
                }
              },
              // Suppress native focus or blur if we're currently inside
              // a leveraged native-event stack
              _default: function(event) {
                return dataPriv.get(event.target, type);
              },
              delegateType
            };
            jQuery.event.special[delegateType] = {
              setup: function() {
                var doc2 = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc2, attaches = dataPriv.get(dataHolder, delegateType);
                if (!attaches) {
                  if (document2.documentMode) {
                    this.addEventListener(delegateType, focusMappedHandler);
                  } else {
                    doc2.addEventListener(type, focusMappedHandler, true);
                  }
                }
                dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
              },
              teardown: function() {
                var doc2 = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc2, attaches = dataPriv.get(dataHolder, delegateType) - 1;
                if (!attaches) {
                  if (document2.documentMode) {
                    this.removeEventListener(delegateType, focusMappedHandler);
                  } else {
                    doc2.removeEventListener(type, focusMappedHandler, true);
                  }
                  dataPriv.remove(dataHolder, delegateType);
                } else {
                  dataPriv.set(dataHolder, delegateType, attaches);
                }
              }
            };
          });
          jQuery.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
          }, function(orig, fix) {
            jQuery.event.special[orig] = {
              delegateType: fix,
              bindType: fix,
              handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                  event.type = handleObj.origType;
                  ret = handleObj.handler.apply(this, arguments);
                  event.type = fix;
                }
                return ret;
              }
            };
          });
          jQuery.fn.extend({
            on: function(types, selector, data, fn2) {
              return on2(this, types, selector, data, fn2);
            },
            one: function(types, selector, data, fn2) {
              return on2(this, types, selector, data, fn2, 1);
            },
            off: function(types, selector, fn2) {
              var handleObj, type;
              if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(
                  handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                  handleObj.selector,
                  handleObj.handler
                );
                return this;
              }
              if (typeof types === "object") {
                for (type in types) {
                  this.off(type, selector, types[type]);
                }
                return this;
              }
              if (selector === false || typeof selector === "function") {
                fn2 = selector;
                selector = void 0;
              }
              if (fn2 === false) {
                fn2 = returnFalse;
              }
              return this.each(function() {
                jQuery.event.remove(this, types, fn2, selector);
              });
            }
          });
          var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
          function manipulationTarget(elem, content) {
            if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
              return jQuery(elem).children("tbody")[0] || elem;
            }
            return elem;
          }
          function disableScript(elem) {
            elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
            return elem;
          }
          function restoreScript(elem) {
            if ((elem.type || "").slice(0, 5) === "true/") {
              elem.type = elem.type.slice(5);
            } else {
              elem.removeAttribute("type");
            }
            return elem;
          }
          function cloneCopyEvent(src, dest) {
            var i, l2, type, pdataOld, udataOld, udataCur, events;
            if (dest.nodeType !== 1) {
              return;
            }
            if (dataPriv.hasData(src)) {
              pdataOld = dataPriv.get(src);
              events = pdataOld.events;
              if (events) {
                dataPriv.remove(dest, "handle events");
                for (type in events) {
                  for (i = 0, l2 = events[type].length; i < l2; i++) {
                    jQuery.event.add(dest, type, events[type][i]);
                  }
                }
              }
            }
            if (dataUser.hasData(src)) {
              udataOld = dataUser.access(src);
              udataCur = jQuery.extend({}, udataOld);
              dataUser.set(dest, udataCur);
            }
          }
          function fixInput(src, dest) {
            var nodeName2 = dest.nodeName.toLowerCase();
            if (nodeName2 === "input" && rcheckableType.test(src.type)) {
              dest.checked = src.checked;
            } else if (nodeName2 === "input" || nodeName2 === "textarea") {
              dest.defaultValue = src.defaultValue;
            }
          }
          function domManip(collection, args, callback, ignored) {
            args = flat(args);
            var fragment, first, scripts, hasScripts, node, doc2, i = 0, l2 = collection.length, iNoClone = l2 - 1, value = args[0], valueIsFunction = isFunction2(value);
            if (valueIsFunction || l2 > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
              return collection.each(function(index) {
                var self2 = collection.eq(index);
                if (valueIsFunction) {
                  args[0] = value.call(this, index, self2.html());
                }
                domManip(self2, args, callback, ignored);
              });
            }
            if (l2) {
              fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
              first = fragment.firstChild;
              if (fragment.childNodes.length === 1) {
                fragment = first;
              }
              if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                hasScripts = scripts.length;
                for (; i < l2; i++) {
                  node = fragment;
                  if (i !== iNoClone) {
                    node = jQuery.clone(node, true, true);
                    if (hasScripts) {
                      jQuery.merge(scripts, getAll(node, "script"));
                    }
                  }
                  callback.call(collection[i], node, i);
                }
                if (hasScripts) {
                  doc2 = scripts[scripts.length - 1].ownerDocument;
                  jQuery.map(scripts, restoreScript);
                  for (i = 0; i < hasScripts; i++) {
                    node = scripts[i];
                    if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc2, node)) {
                      if (node.src && (node.type || "").toLowerCase() !== "module") {
                        if (jQuery._evalUrl && !node.noModule) {
                          jQuery._evalUrl(node.src, {
                            nonce: node.nonce || node.getAttribute("nonce")
                          }, doc2);
                        }
                      } else {
                        DOMEval(node.textContent.replace(rcleanScript, ""), node, doc2);
                      }
                    }
                  }
                }
              }
            }
            return collection;
          }
          function remove2(elem, selector, keepData) {
            var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
            for (; (node = nodes[i]) != null; i++) {
              if (!keepData && node.nodeType === 1) {
                jQuery.cleanData(getAll(node));
              }
              if (node.parentNode) {
                if (keepData && isAttached(node)) {
                  setGlobalEval(getAll(node, "script"));
                }
                node.parentNode.removeChild(node);
              }
            }
            return elem;
          }
          jQuery.extend({
            htmlPrefilter: function(html) {
              return html;
            },
            clone: function(elem, dataAndEvents, deepDataAndEvents) {
              var i, l2, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
              if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l2 = srcElements.length; i < l2; i++) {
                  fixInput(srcElements[i], destElements[i]);
                }
              }
              if (dataAndEvents) {
                if (deepDataAndEvents) {
                  srcElements = srcElements || getAll(elem);
                  destElements = destElements || getAll(clone);
                  for (i = 0, l2 = srcElements.length; i < l2; i++) {
                    cloneCopyEvent(srcElements[i], destElements[i]);
                  }
                } else {
                  cloneCopyEvent(elem, clone);
                }
              }
              destElements = getAll(clone, "script");
              if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
              }
              return clone;
            },
            cleanData: function(elems) {
              var data, elem, type, special = jQuery.event.special, i = 0;
              for (; (elem = elems[i]) !== void 0; i++) {
                if (acceptData(elem)) {
                  if (data = elem[dataPriv.expando]) {
                    if (data.events) {
                      for (type in data.events) {
                        if (special[type]) {
                          jQuery.event.remove(elem, type);
                        } else {
                          jQuery.removeEvent(elem, type, data.handle);
                        }
                      }
                    }
                    elem[dataPriv.expando] = void 0;
                  }
                  if (elem[dataUser.expando]) {
                    elem[dataUser.expando] = void 0;
                  }
                }
              }
            }
          });
          jQuery.fn.extend({
            detach: function(selector) {
              return remove2(this, selector, true);
            },
            remove: function(selector) {
              return remove2(this, selector);
            },
            text: function(value) {
              return access(this, function(value2) {
                return value2 === void 0 ? jQuery.text(this) : this.empty().each(function() {
                  if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    this.textContent = value2;
                  }
                });
              }, null, value, arguments.length);
            },
            append: function() {
              return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                  var target = manipulationTarget(this, elem);
                  target.appendChild(elem);
                }
              });
            },
            prepend: function() {
              return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                  var target = manipulationTarget(this, elem);
                  target.insertBefore(elem, target.firstChild);
                }
              });
            },
            before: function() {
              return domManip(this, arguments, function(elem) {
                if (this.parentNode) {
                  this.parentNode.insertBefore(elem, this);
                }
              });
            },
            after: function() {
              return domManip(this, arguments, function(elem) {
                if (this.parentNode) {
                  this.parentNode.insertBefore(elem, this.nextSibling);
                }
              });
            },
            empty: function() {
              var elem, i = 0;
              for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                  jQuery.cleanData(getAll(elem, false));
                  elem.textContent = "";
                }
              }
              return this;
            },
            clone: function(dataAndEvents, deepDataAndEvents) {
              dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
              deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
              return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
              });
            },
            html: function(value) {
              return access(this, function(value2) {
                var elem = this[0] || {}, i = 0, l2 = this.length;
                if (value2 === void 0 && elem.nodeType === 1) {
                  return elem.innerHTML;
                }
                if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
                  value2 = jQuery.htmlPrefilter(value2);
                  try {
                    for (; i < l2; i++) {
                      elem = this[i] || {};
                      if (elem.nodeType === 1) {
                        jQuery.cleanData(getAll(elem, false));
                        elem.innerHTML = value2;
                      }
                    }
                    elem = 0;
                  } catch (e2) {
                  }
                }
                if (elem) {
                  this.empty().append(value2);
                }
              }, null, value, arguments.length);
            },
            replaceWith: function() {
              var ignored = [];
              return domManip(this, arguments, function(elem) {
                var parent = this.parentNode;
                if (jQuery.inArray(this, ignored) < 0) {
                  jQuery.cleanData(getAll(this));
                  if (parent) {
                    parent.replaceChild(elem, this);
                  }
                }
              }, ignored);
            }
          });
          jQuery.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
          }, function(name, original) {
            jQuery.fn[name] = function(selector) {
              var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
              for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
              }
              return this.pushStack(ret);
            };
          });
          var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
          var rcustomProp = /^--/;
          var getStyles = function(elem) {
            var view = elem.ownerDocument.defaultView;
            if (!view || !view.opener) {
              view = window2;
            }
            return view.getComputedStyle(elem);
          };
          var swap = function(elem, options, callback) {
            var ret, name, old = {};
            for (name in options) {
              old[name] = elem.style[name];
              elem.style[name] = options[name];
            }
            ret = callback.call(elem);
            for (name in options) {
              elem.style[name] = old[name];
            }
            return ret;
          };
          var rboxStyle = new RegExp(cssExpand.join("|"), "i");
          (function() {
            function computeStyleTests() {
              if (!div) {
                return;
              }
              container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
              div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
              documentElement.appendChild(container).appendChild(div);
              var divStyle = window2.getComputedStyle(div);
              pixelPositionVal = divStyle.top !== "1%";
              reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
              div.style.right = "60%";
              pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
              boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
              div.style.position = "absolute";
              scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
              documentElement.removeChild(container);
              div = null;
            }
            function roundPixelMeasures(measure) {
              return Math.round(parseFloat(measure));
            }
            var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
            if (!div.style) {
              return;
            }
            div.style.backgroundClip = "content-box";
            div.cloneNode(true).style.backgroundClip = "";
            support.clearCloneStyle = div.style.backgroundClip === "content-box";
            jQuery.extend(support, {
              boxSizingReliable: function() {
                computeStyleTests();
                return boxSizingReliableVal;
              },
              pixelBoxStyles: function() {
                computeStyleTests();
                return pixelBoxStylesVal;
              },
              pixelPosition: function() {
                computeStyleTests();
                return pixelPositionVal;
              },
              reliableMarginLeft: function() {
                computeStyleTests();
                return reliableMarginLeftVal;
              },
              scrollboxSize: function() {
                computeStyleTests();
                return scrollboxSizeVal;
              },
              // Support: IE 9 - 11+, Edge 15 - 18+
              // IE/Edge misreport `getComputedStyle` of table rows with width/height
              // set in CSS while `offset*` properties report correct values.
              // Behavior in IE 9 is more subtle than in newer versions & it passes
              // some versions of this test; make sure not to make it pass there!
              //
              // Support: Firefox 70+
              // Only Firefox includes border widths
              // in computed dimensions. (gh-4529)
              reliableTrDimensions: function() {
                var table, tr, trChild, trStyle;
                if (reliableTrDimensionsVal == null) {
                  table = document2.createElement("table");
                  tr = document2.createElement("tr");
                  trChild = document2.createElement("div");
                  table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
                  tr.style.cssText = "box-sizing:content-box;border:1px solid";
                  tr.style.height = "1px";
                  trChild.style.height = "9px";
                  trChild.style.display = "block";
                  documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
                  trStyle = window2.getComputedStyle(tr);
                  reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
                  documentElement.removeChild(table);
                }
                return reliableTrDimensionsVal;
              }
            });
          })();
          function curCSS(elem, name, computed2) {
            var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style2 = elem.style;
            computed2 = computed2 || getStyles(elem);
            if (computed2) {
              ret = computed2.getPropertyValue(name) || computed2[name];
              if (isCustomProp && ret) {
                ret = ret.replace(rtrimCSS, "$1") || void 0;
              }
              if (ret === "" && !isAttached(elem)) {
                ret = jQuery.style(elem, name);
              }
              if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
                width = style2.width;
                minWidth = style2.minWidth;
                maxWidth = style2.maxWidth;
                style2.minWidth = style2.maxWidth = style2.width = ret;
                ret = computed2.width;
                style2.width = width;
                style2.minWidth = minWidth;
                style2.maxWidth = maxWidth;
              }
            }
            return ret !== void 0 ? (
              // Support: IE <=9 - 11 only
              // IE returns zIndex value as an integer.
              ret + ""
            ) : ret;
          }
          function addGetHookIf(conditionFn, hookFn) {
            return {
              get: function() {
                if (conditionFn()) {
                  delete this.get;
                  return;
                }
                return (this.get = hookFn).apply(this, arguments);
              }
            };
          }
          var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
          function vendorPropName(name) {
            var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
            while (i--) {
              name = cssPrefixes[i] + capName;
              if (name in emptyStyle) {
                return name;
              }
            }
          }
          function finalPropName(name) {
            var final = jQuery.cssProps[name] || vendorProps[name];
            if (final) {
              return final;
            }
            if (name in emptyStyle) {
              return name;
            }
            return vendorProps[name] = vendorPropName(name) || name;
          }
          var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
          };
          function setPositiveNumber(_elem, value, subtract) {
            var matches = rcssNum.exec(value);
            return matches ? (
              // Guard against undefined "subtract", e.g., when used as in cssHooks
              Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
            ) : value;
          }
          function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
            var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
            if (box === (isBorderBox ? "border" : "content")) {
              return 0;
            }
            for (; i < 4; i += 2) {
              if (box === "margin") {
                marginDelta += jQuery.css(elem, box + cssExpand[i], true, styles);
              }
              if (!isBorderBox) {
                delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                if (box !== "padding") {
                  delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                } else {
                  extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
              } else {
                if (box === "content") {
                  delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                }
                if (box !== "margin") {
                  delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
              }
            }
            if (!isBorderBox && computedVal >= 0) {
              delta += Math.max(0, Math.ceil(
                elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
                // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
                // Use an explicit zero to avoid NaN (gh-3964)
              )) || 0;
            }
            return delta + marginDelta;
          }
          function getWidthOrHeight(elem, dimension, extra) {
            var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
            if (rnumnonpx.test(val)) {
              if (!extra) {
                return val;
              }
              val = "auto";
            }
            if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
            // IE/Edge misreport `getComputedStyle` of table rows with width/height
            // set in CSS while `offset*` properties report correct values.
            // Interestingly, in some cases IE 9 doesn't suffer from this issue.
            !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
            // This happens for inline elements with no explicit setting (gh-3571)
            val === "auto" || // Support: Android <=4.1 - 4.3 only
            // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
            !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
            elem.getClientRects().length) {
              isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
              valueIsBorderBox = offsetProp in elem;
              if (valueIsBorderBox) {
                val = elem[offsetProp];
              }
            }
            val = parseFloat(val) || 0;
            return val + boxModelAdjustment(
              elem,
              dimension,
              extra || (isBorderBox ? "border" : "content"),
              valueIsBorderBox,
              styles,
              // Provide the current computed size to request scroll gutter calculation (gh-3589)
              val
            ) + "px";
          }
          jQuery.extend({
            // Add in style property hooks for overriding the default
            // behavior of getting and setting a style property
            cssHooks: {
              opacity: {
                get: function(elem, computed2) {
                  if (computed2) {
                    var ret = curCSS(elem, "opacity");
                    return ret === "" ? "1" : ret;
                  }
                }
              }
            },
            // Don't automatically add "px" to these possibly-unitless properties
            cssNumber: {
              animationIterationCount: true,
              aspectRatio: true,
              borderImageSlice: true,
              columnCount: true,
              flexGrow: true,
              flexShrink: true,
              fontWeight: true,
              gridArea: true,
              gridColumn: true,
              gridColumnEnd: true,
              gridColumnStart: true,
              gridRow: true,
              gridRowEnd: true,
              gridRowStart: true,
              lineHeight: true,
              opacity: true,
              order: true,
              orphans: true,
              scale: true,
              widows: true,
              zIndex: true,
              zoom: true,
              // SVG-related
              fillOpacity: true,
              floodOpacity: true,
              stopOpacity: true,
              strokeMiterlimit: true,
              strokeOpacity: true
            },
            // Add in properties whose names you wish to fix before
            // setting or getting the value
            cssProps: {},
            // Get and set the style property on a DOM Node
            style: function(elem, name, value, extra) {
              if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
              }
              var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style2 = elem.style;
              if (!isCustomProp) {
                name = finalPropName(origName);
              }
              hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
              if (value !== void 0) {
                type = typeof value;
                if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                  value = adjustCSS(elem, name, ret);
                  type = "number";
                }
                if (value == null || value !== value) {
                  return;
                }
                if (type === "number" && !isCustomProp) {
                  value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
                }
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                  style2[name] = "inherit";
                }
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
                  if (isCustomProp) {
                    style2.setProperty(name, value);
                  } else {
                    style2[name] = value;
                  }
                }
              } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
                  return ret;
                }
                return style2[name];
              }
            },
            css: function(elem, name, extra, styles) {
              var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
              if (!isCustomProp) {
                name = finalPropName(origName);
              }
              hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
              if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
              }
              if (val === void 0) {
                val = curCSS(elem, name, styles);
              }
              if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
              }
              if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
              }
              return val;
            }
          });
          jQuery.each(["height", "width"], function(_i, dimension) {
            jQuery.cssHooks[dimension] = {
              get: function(elem, computed2, extra) {
                if (computed2) {
                  return rdisplayswap.test(jQuery.css(elem, "display")) && // Support: Safari 8+
                  // Table columns in Safari have non-zero offsetWidth & zero
                  // getBoundingClientRect().width unless display is changed.
                  // Support: IE <=11 only
                  // Running getBoundingClientRect on a disconnected node
                  // in IE throws an error.
                  (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                    return getWidthOrHeight(elem, dimension, extra);
                  }) : getWidthOrHeight(elem, dimension, extra);
                }
              },
              set: function(elem, value, extra) {
                var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
                  elem,
                  dimension,
                  extra,
                  isBorderBox,
                  styles
                ) : 0;
                if (isBorderBox && scrollboxSizeBuggy) {
                  subtract -= Math.ceil(
                    elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
                  );
                }
                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                  elem.style[dimension] = value;
                  value = jQuery.css(elem, dimension);
                }
                return setPositiveNumber(elem, value, subtract);
              }
            };
          });
          jQuery.cssHooks.marginLeft = addGetHookIf(
            support.reliableMarginLeft,
            function(elem, computed2) {
              if (computed2) {
                return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
                  return elem.getBoundingClientRect().left;
                })) + "px";
              }
            }
          );
          jQuery.each({
            margin: "",
            padding: "",
            border: "Width"
          }, function(prefix, suffix) {
            jQuery.cssHooks[prefix + suffix] = {
              expand: function(value) {
                var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
                for (; i < 4; i++) {
                  expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
              }
            };
            if (prefix !== "margin") {
              jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
            }
          });
          jQuery.fn.extend({
            css: function(name, value) {
              return access(this, function(elem, name2, value2) {
                var styles, len, map = {}, i = 0;
                if (Array.isArray(name2)) {
                  styles = getStyles(elem);
                  len = name2.length;
                  for (; i < len; i++) {
                    map[name2[i]] = jQuery.css(elem, name2[i], false, styles);
                  }
                  return map;
                }
                return value2 !== void 0 ? jQuery.style(elem, name2, value2) : jQuery.css(elem, name2);
              }, name, value, arguments.length > 1);
            }
          });
          function Tween(elem, options, prop, end, easing) {
            return new Tween.prototype.init(elem, options, prop, end, easing);
          }
          jQuery.Tween = Tween;
          Tween.prototype = {
            constructor: Tween,
            init: function(elem, options, prop, end, easing, unit2) {
              this.elem = elem;
              this.prop = prop;
              this.easing = easing || jQuery.easing._default;
              this.options = options;
              this.start = this.now = this.cur();
              this.end = end;
              this.unit = unit2 || (jQuery.cssNumber[prop] ? "" : "px");
            },
            cur: function() {
              var hooks = Tween.propHooks[this.prop];
              return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
            },
            run: function(percent) {
              var eased, hooks = Tween.propHooks[this.prop];
              if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](
                  percent,
                  this.options.duration * percent,
                  0,
                  1,
                  this.options.duration
                );
              } else {
                this.pos = eased = percent;
              }
              this.now = (this.end - this.start) * eased + this.start;
              if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
              }
              if (hooks && hooks.set) {
                hooks.set(this);
              } else {
                Tween.propHooks._default.set(this);
              }
              return this;
            }
          };
          Tween.prototype.init.prototype = Tween.prototype;
          Tween.propHooks = {
            _default: {
              get: function(tween) {
                var result;
                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                  return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, "");
                return !result || result === "auto" ? 0 : result;
              },
              set: function(tween) {
                if (jQuery.fx.step[tween.prop]) {
                  jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
                  jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                  tween.elem[tween.prop] = tween.now;
                }
              }
            }
          };
          Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
            set: function(tween) {
              if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
              }
            }
          };
          jQuery.easing = {
            linear: function(p2) {
              return p2;
            },
            swing: function(p2) {
              return 0.5 - Math.cos(p2 * Math.PI) / 2;
            },
            _default: "swing"
          };
          jQuery.fx = Tween.prototype.init;
          jQuery.fx.step = {};
          var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
          function schedule() {
            if (inProgress) {
              if (document2.hidden === false && window2.requestAnimationFrame) {
                window2.requestAnimationFrame(schedule);
              } else {
                window2.setTimeout(schedule, jQuery.fx.interval);
              }
              jQuery.fx.tick();
            }
          }
          function createFxNow() {
            window2.setTimeout(function() {
              fxNow = void 0;
            });
            return fxNow = Date.now();
          }
          function genFx(type, includeWidth) {
            var which, i = 0, attrs = { height: type };
            includeWidth = includeWidth ? 1 : 0;
            for (; i < 4; i += 2 - includeWidth) {
              which = cssExpand[i];
              attrs["margin" + which] = attrs["padding" + which] = type;
            }
            if (includeWidth) {
              attrs.opacity = attrs.width = type;
            }
            return attrs;
          }
          function createTween(value, prop, animation) {
            var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
            for (; index < length; index++) {
              if (tween = collection[index].call(animation, prop, value)) {
                return tween;
              }
            }
          }
          function defaultPrefilter(elem, props, opts) {
            var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style2 = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
            if (!opts.queue) {
              hooks = jQuery._queueHooks(elem, "fx");
              if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                  if (!hooks.unqueued) {
                    oldfire();
                  }
                };
              }
              hooks.unqueued++;
              anim.always(function() {
                anim.always(function() {
                  hooks.unqueued--;
                  if (!jQuery.queue(elem, "fx").length) {
                    hooks.empty.fire();
                  }
                });
              });
            }
            for (prop in props) {
              value = props[prop];
              if (rfxtypes.test(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                  if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                    hidden = true;
                  } else {
                    continue;
                  }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
              }
            }
            propTween = !jQuery.isEmptyObject(props);
            if (!propTween && jQuery.isEmptyObject(orig)) {
              return;
            }
            if (isBox && elem.nodeType === 1) {
              opts.overflow = [style2.overflow, style2.overflowX, style2.overflowY];
              restoreDisplay = dataShow && dataShow.display;
              if (restoreDisplay == null) {
                restoreDisplay = dataPriv.get(elem, "display");
              }
              display = jQuery.css(elem, "display");
              if (display === "none") {
                if (restoreDisplay) {
                  display = restoreDisplay;
                } else {
                  showHide([elem], true);
                  restoreDisplay = elem.style.display || restoreDisplay;
                  display = jQuery.css(elem, "display");
                  showHide([elem]);
                }
              }
              if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
                if (jQuery.css(elem, "float") === "none") {
                  if (!propTween) {
                    anim.done(function() {
                      style2.display = restoreDisplay;
                    });
                    if (restoreDisplay == null) {
                      display = style2.display;
                      restoreDisplay = display === "none" ? "" : display;
                    }
                  }
                  style2.display = "inline-block";
                }
              }
            }
            if (opts.overflow) {
              style2.overflow = "hidden";
              anim.always(function() {
                style2.overflow = opts.overflow[0];
                style2.overflowX = opts.overflow[1];
                style2.overflowY = opts.overflow[2];
              });
            }
            propTween = false;
            for (prop in orig) {
              if (!propTween) {
                if (dataShow) {
                  if ("hidden" in dataShow) {
                    hidden = dataShow.hidden;
                  }
                } else {
                  dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
                }
                if (toggle) {
                  dataShow.hidden = !hidden;
                }
                if (hidden) {
                  showHide([elem], true);
                }
                anim.done(function() {
                  if (!hidden) {
                    showHide([elem]);
                  }
                  dataPriv.remove(elem, "fxshow");
                  for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                  }
                });
              }
              propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
              if (!(prop in dataShow)) {
                dataShow[prop] = propTween.start;
                if (hidden) {
                  propTween.end = propTween.start;
                  propTween.start = 0;
                }
              }
            }
          }
          function propFilter(props, specialEasing) {
            var index, name, easing, value, hooks;
            for (index in props) {
              name = camelCase(index);
              easing = specialEasing[name];
              value = props[index];
              if (Array.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
              }
              if (index !== name) {
                props[name] = value;
                delete props[index];
              }
              hooks = jQuery.cssHooks[name];
              if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                  if (!(index in props)) {
                    props[index] = value[index];
                    specialEasing[index] = easing;
                  }
                }
              } else {
                specialEasing[name] = easing;
              }
            }
          }
          function Animation(elem, properties, options) {
            var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
              delete tick.elem;
            }), tick = function() {
              if (stopped) {
                return false;
              }
              var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
              for (; index2 < length2; index2++) {
                animation.tweens[index2].run(percent);
              }
              deferred.notifyWith(elem, [animation, percent, remaining]);
              if (percent < 1 && length2) {
                return remaining;
              }
              if (!length2) {
                deferred.notifyWith(elem, [animation, 1, 0]);
              }
              deferred.resolveWith(elem, [animation]);
              return false;
            }, animation = deferred.promise({
              elem,
              props: jQuery.extend({}, properties),
              opts: jQuery.extend(true, {
                specialEasing: {},
                easing: jQuery.easing._default
              }, options),
              originalProperties: properties,
              originalOptions: options,
              startTime: fxNow || createFxNow(),
              duration: options.duration,
              tweens: [],
              createTween: function(prop, end) {
                var tween = jQuery.Tween(
                  elem,
                  animation.opts,
                  prop,
                  end,
                  animation.opts.specialEasing[prop] || animation.opts.easing
                );
                animation.tweens.push(tween);
                return tween;
              },
              stop: function(gotoEnd) {
                var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
                if (stopped) {
                  return this;
                }
                stopped = true;
                for (; index2 < length2; index2++) {
                  animation.tweens[index2].run(1);
                }
                if (gotoEnd) {
                  deferred.notifyWith(elem, [animation, 1, 0]);
                  deferred.resolveWith(elem, [animation, gotoEnd]);
                } else {
                  deferred.rejectWith(elem, [animation, gotoEnd]);
                }
                return this;
              }
            }), props = animation.props;
            propFilter(props, animation.opts.specialEasing);
            for (; index < length; index++) {
              result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
              if (result) {
                if (isFunction2(result.stop)) {
                  jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
                }
                return result;
              }
            }
            jQuery.map(props, createTween, animation);
            if (isFunction2(animation.opts.start)) {
              animation.opts.start.call(elem, animation);
            }
            animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
            jQuery.fx.timer(
              jQuery.extend(tick, {
                elem,
                anim: animation,
                queue: animation.opts.queue
              })
            );
            return animation;
          }
          jQuery.Animation = jQuery.extend(Animation, {
            tweeners: {
              "*": [function(prop, value) {
                var tween = this.createTween(prop, value);
                adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                return tween;
              }]
            },
            tweener: function(props, callback) {
              if (isFunction2(props)) {
                callback = props;
                props = ["*"];
              } else {
                props = props.match(rnothtmlwhite);
              }
              var prop, index = 0, length = props.length;
              for (; index < length; index++) {
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
              }
            },
            prefilters: [defaultPrefilter],
            prefilter: function(callback, prepend) {
              if (prepend) {
                Animation.prefilters.unshift(callback);
              } else {
                Animation.prefilters.push(callback);
              }
            }
          });
          jQuery.speed = function(speed, easing, fn2) {
            var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
              complete: fn2 || !fn2 && easing || isFunction2(speed) && speed,
              duration: speed,
              easing: fn2 && easing || easing && !isFunction2(easing) && easing
            };
            if (jQuery.fx.off) {
              opt.duration = 0;
            } else {
              if (typeof opt.duration !== "number") {
                if (opt.duration in jQuery.fx.speeds) {
                  opt.duration = jQuery.fx.speeds[opt.duration];
                } else {
                  opt.duration = jQuery.fx.speeds._default;
                }
              }
            }
            if (opt.queue == null || opt.queue === true) {
              opt.queue = "fx";
            }
            opt.old = opt.complete;
            opt.complete = function() {
              if (isFunction2(opt.old)) {
                opt.old.call(this);
              }
              if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
              }
            };
            return opt;
          };
          jQuery.fn.extend({
            fadeTo: function(speed, to, easing, callback) {
              return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
            },
            animate: function(prop, speed, easing, callback) {
              var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                if (empty || dataPriv.get(this, "finish")) {
                  anim.stop(true);
                }
              };
              doAnimation.finish = doAnimation;
              return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
            },
            stop: function(type, clearQueue, gotoEnd) {
              var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
              };
              if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = void 0;
              }
              if (clearQueue) {
                this.queue(type || "fx", []);
              }
              return this.each(function() {
                var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
                if (index) {
                  if (data[index] && data[index].stop) {
                    stopQueue(data[index]);
                  }
                } else {
                  for (index in data) {
                    if (data[index] && data[index].stop && rrun.test(index)) {
                      stopQueue(data[index]);
                    }
                  }
                }
                for (index = timers.length; index--; ) {
                  if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                    timers[index].anim.stop(gotoEnd);
                    dequeue = false;
                    timers.splice(index, 1);
                  }
                }
                if (dequeue || !gotoEnd) {
                  jQuery.dequeue(this, type);
                }
              });
            },
            finish: function(type) {
              if (type !== false) {
                type = type || "fx";
              }
              return this.each(function() {
                var index, data = dataPriv.get(this), queue2 = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue2 ? queue2.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                  hooks.stop.call(this, true);
                }
                for (index = timers.length; index--; ) {
                  if (timers[index].elem === this && timers[index].queue === type) {
                    timers[index].anim.stop(true);
                    timers.splice(index, 1);
                  }
                }
                for (index = 0; index < length; index++) {
                  if (queue2[index] && queue2[index].finish) {
                    queue2[index].finish.call(this);
                  }
                }
                delete data.finish;
              });
            }
          });
          jQuery.each(["toggle", "show", "hide"], function(_i, name) {
            var cssFn = jQuery.fn[name];
            jQuery.fn[name] = function(speed, easing, callback) {
              return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
            };
          });
          jQuery.each({
            slideDown: genFx("show"),
            slideUp: genFx("hide"),
            slideToggle: genFx("toggle"),
            fadeIn: { opacity: "show" },
            fadeOut: { opacity: "hide" },
            fadeToggle: { opacity: "toggle" }
          }, function(name, props) {
            jQuery.fn[name] = function(speed, easing, callback) {
              return this.animate(props, speed, easing, callback);
            };
          });
          jQuery.timers = [];
          jQuery.fx.tick = function() {
            var timer, i = 0, timers = jQuery.timers;
            fxNow = Date.now();
            for (; i < timers.length; i++) {
              timer = timers[i];
              if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
              }
            }
            if (!timers.length) {
              jQuery.fx.stop();
            }
            fxNow = void 0;
          };
          jQuery.fx.timer = function(timer) {
            jQuery.timers.push(timer);
            jQuery.fx.start();
          };
          jQuery.fx.interval = 13;
          jQuery.fx.start = function() {
            if (inProgress) {
              return;
            }
            inProgress = true;
            schedule();
          };
          jQuery.fx.stop = function() {
            inProgress = null;
          };
          jQuery.fx.speeds = {
            slow: 600,
            fast: 200,
            // Default speed
            _default: 400
          };
          jQuery.fn.delay = function(time, type) {
            time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
            type = type || "fx";
            return this.queue(type, function(next, hooks) {
              var timeout = window2.setTimeout(next, time);
              hooks.stop = function() {
                window2.clearTimeout(timeout);
              };
            });
          };
          (function() {
            var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
            input.type = "checkbox";
            support.checkOn = input.value !== "";
            support.optSelected = opt.selected;
            input = document2.createElement("input");
            input.value = "t";
            input.type = "radio";
            support.radioValue = input.value === "t";
          })();
          var boolHook, attrHandle = jQuery.expr.attrHandle;
          jQuery.fn.extend({
            attr: function(name, value) {
              return access(this, jQuery.attr, name, value, arguments.length > 1);
            },
            removeAttr: function(name) {
              return this.each(function() {
                jQuery.removeAttr(this, name);
              });
            }
          });
          jQuery.extend({
            attr: function(elem, name, value) {
              var ret, hooks, nType = elem.nodeType;
              if (nType === 3 || nType === 8 || nType === 2) {
                return;
              }
              if (typeof elem.getAttribute === "undefined") {
                return jQuery.prop(elem, name, value);
              }
              if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0);
              }
              if (value !== void 0) {
                if (value === null) {
                  jQuery.removeAttr(elem, name);
                  return;
                }
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                  return ret;
                }
                elem.setAttribute(name, value + "");
                return value;
              }
              if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
              }
              ret = jQuery.find.attr(elem, name);
              return ret == null ? void 0 : ret;
            },
            attrHooks: {
              type: {
                set: function(elem, value) {
                  if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                    var val = elem.value;
                    elem.setAttribute("type", value);
                    if (val) {
                      elem.value = val;
                    }
                    return value;
                  }
                }
              }
            },
            removeAttr: function(elem, value) {
              var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
              if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                  elem.removeAttribute(name);
                }
              }
            }
          });
          boolHook = {
            set: function(elem, value, name) {
              if (value === false) {
                jQuery.removeAttr(elem, name);
              } else {
                elem.setAttribute(name, name);
              }
              return name;
            }
          };
          jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i, name) {
            var getter = attrHandle[name] || jQuery.find.attr;
            attrHandle[name] = function(elem, name2, isXML) {
              var ret, handle, lowercaseName = name2.toLowerCase();
              if (!isXML) {
                handle = attrHandle[lowercaseName];
                attrHandle[lowercaseName] = ret;
                ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
                attrHandle[lowercaseName] = handle;
              }
              return ret;
            };
          });
          var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
          jQuery.fn.extend({
            prop: function(name, value) {
              return access(this, jQuery.prop, name, value, arguments.length > 1);
            },
            removeProp: function(name) {
              return this.each(function() {
                delete this[jQuery.propFix[name] || name];
              });
            }
          });
          jQuery.extend({
            prop: function(elem, name, value) {
              var ret, hooks, nType = elem.nodeType;
              if (nType === 3 || nType === 8 || nType === 2) {
                return;
              }
              if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
              }
              if (value !== void 0) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                  return ret;
                }
                return elem[name] = value;
              }
              if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
              }
              return elem[name];
            },
            propHooks: {
              tabIndex: {
                get: function(elem) {
                  var tabindex = jQuery.find.attr(elem, "tabindex");
                  if (tabindex) {
                    return parseInt(tabindex, 10);
                  }
                  if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                    return 0;
                  }
                  return -1;
                }
              }
            },
            propFix: {
              "for": "htmlFor",
              "class": "className"
            }
          });
          if (!support.optSelected) {
            jQuery.propHooks.selected = {
              get: function(elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                  parent.parentNode.selectedIndex;
                }
                return null;
              },
              set: function(elem) {
                var parent = elem.parentNode;
                if (parent) {
                  parent.selectedIndex;
                  if (parent.parentNode) {
                    parent.parentNode.selectedIndex;
                  }
                }
              }
            };
          }
          jQuery.each([
            "tabIndex",
            "readOnly",
            "maxLength",
            "cellSpacing",
            "cellPadding",
            "rowSpan",
            "colSpan",
            "useMap",
            "frameBorder",
            "contentEditable"
          ], function() {
            jQuery.propFix[this.toLowerCase()] = this;
          });
          function stripAndCollapse(value) {
            var tokens = value.match(rnothtmlwhite) || [];
            return tokens.join(" ");
          }
          function getClass(elem) {
            return elem.getAttribute && elem.getAttribute("class") || "";
          }
          function classesToArray(value) {
            if (Array.isArray(value)) {
              return value;
            }
            if (typeof value === "string") {
              return value.match(rnothtmlwhite) || [];
            }
            return [];
          }
          jQuery.fn.extend({
            addClass: function(value) {
              var classNames, cur, curValue, className, i, finalValue;
              if (isFunction2(value)) {
                return this.each(function(j) {
                  jQuery(this).addClass(value.call(this, j, getClass(this)));
                });
              }
              classNames = classesToArray(value);
              if (classNames.length) {
                return this.each(function() {
                  curValue = getClass(this);
                  cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                  if (cur) {
                    for (i = 0; i < classNames.length; i++) {
                      className = classNames[i];
                      if (cur.indexOf(" " + className + " ") < 0) {
                        cur += className + " ";
                      }
                    }
                    finalValue = stripAndCollapse(cur);
                    if (curValue !== finalValue) {
                      this.setAttribute("class", finalValue);
                    }
                  }
                });
              }
              return this;
            },
            removeClass: function(value) {
              var classNames, cur, curValue, className, i, finalValue;
              if (isFunction2(value)) {
                return this.each(function(j) {
                  jQuery(this).removeClass(value.call(this, j, getClass(this)));
                });
              }
              if (!arguments.length) {
                return this.attr("class", "");
              }
              classNames = classesToArray(value);
              if (classNames.length) {
                return this.each(function() {
                  curValue = getClass(this);
                  cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                  if (cur) {
                    for (i = 0; i < classNames.length; i++) {
                      className = classNames[i];
                      while (cur.indexOf(" " + className + " ") > -1) {
                        cur = cur.replace(" " + className + " ", " ");
                      }
                    }
                    finalValue = stripAndCollapse(cur);
                    if (curValue !== finalValue) {
                      this.setAttribute("class", finalValue);
                    }
                  }
                });
              }
              return this;
            },
            toggleClass: function(value, stateVal) {
              var classNames, className, i, self2, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
              if (isFunction2(value)) {
                return this.each(function(i2) {
                  jQuery(this).toggleClass(
                    value.call(this, i2, getClass(this), stateVal),
                    stateVal
                  );
                });
              }
              if (typeof stateVal === "boolean" && isValidValue) {
                return stateVal ? this.addClass(value) : this.removeClass(value);
              }
              classNames = classesToArray(value);
              return this.each(function() {
                if (isValidValue) {
                  self2 = jQuery(this);
                  for (i = 0; i < classNames.length; i++) {
                    className = classNames[i];
                    if (self2.hasClass(className)) {
                      self2.removeClass(className);
                    } else {
                      self2.addClass(className);
                    }
                  }
                } else if (value === void 0 || type === "boolean") {
                  className = getClass(this);
                  if (className) {
                    dataPriv.set(this, "__className__", className);
                  }
                  if (this.setAttribute) {
                    this.setAttribute(
                      "class",
                      className || value === false ? "" : dataPriv.get(this, "__className__") || ""
                    );
                  }
                }
              });
            },
            hasClass: function(selector) {
              var className, elem, i = 0;
              className = " " + selector + " ";
              while (elem = this[i++]) {
                if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                  return true;
                }
              }
              return false;
            }
          });
          var rreturn = /\r/g;
          jQuery.fn.extend({
            val: function(value) {
              var hooks, ret, valueIsFunction, elem = this[0];
              if (!arguments.length) {
                if (elem) {
                  hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                  if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                    return ret;
                  }
                  ret = elem.value;
                  if (typeof ret === "string") {
                    return ret.replace(rreturn, "");
                  }
                  return ret == null ? "" : ret;
                }
                return;
              }
              valueIsFunction = isFunction2(value);
              return this.each(function(i) {
                var val;
                if (this.nodeType !== 1) {
                  return;
                }
                if (valueIsFunction) {
                  val = value.call(this, i, jQuery(this).val());
                } else {
                  val = value;
                }
                if (val == null) {
                  val = "";
                } else if (typeof val === "number") {
                  val += "";
                } else if (Array.isArray(val)) {
                  val = jQuery.map(val, function(value2) {
                    return value2 == null ? "" : value2 + "";
                  });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
                  this.value = val;
                }
              });
            }
          });
          jQuery.extend({
            valHooks: {
              option: {
                get: function(elem) {
                  var val = jQuery.find.attr(elem, "value");
                  return val != null ? val : (
                    // Support: IE <=10 - 11 only
                    // option.text throws exceptions (trac-14686, trac-14858)
                    // Strip and collapse whitespace
                    // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                    stripAndCollapse(jQuery.text(elem))
                  );
                }
              },
              select: {
                get: function(elem) {
                  var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index + 1 : options.length;
                  if (index < 0) {
                    i = max;
                  } else {
                    i = one ? index : 0;
                  }
                  for (; i < max; i++) {
                    option = options[i];
                    if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
                    !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                      value = jQuery(option).val();
                      if (one) {
                        return value;
                      }
                      values.push(value);
                    }
                  }
                  return values;
                },
                set: function(elem, value) {
                  var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                  while (i--) {
                    option = options[i];
                    if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                      optionSet = true;
                    }
                  }
                  if (!optionSet) {
                    elem.selectedIndex = -1;
                  }
                  return values;
                }
              }
            }
          });
          jQuery.each(["radio", "checkbox"], function() {
            jQuery.valHooks[this] = {
              set: function(elem, value) {
                if (Array.isArray(value)) {
                  return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
                }
              }
            };
            if (!support.checkOn) {
              jQuery.valHooks[this].get = function(elem) {
                return elem.getAttribute("value") === null ? "on" : elem.value;
              };
            }
          });
          var location2 = window2.location;
          var nonce = { guid: Date.now() };
          var rquery = /\?/;
          jQuery.parseXML = function(data) {
            var xml, parserErrorElem;
            if (!data || typeof data !== "string") {
              return null;
            }
            try {
              xml = new window2.DOMParser().parseFromString(data, "text/xml");
            } catch (e2) {
            }
            parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
            if (!xml || parserErrorElem) {
              jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {
                return el.textContent;
              }).join("\n") : data));
            }
            return xml;
          };
          var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e2) {
            e2.stopPropagation();
          };
          jQuery.extend(jQuery.event, {
            trigger: function(event, data, elem, onlyHandlers) {
              var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn2.call(event, "type") ? event.type : event, namespaces = hasOwn2.call(event, "namespace") ? event.namespace.split(".") : [];
              cur = lastElement = tmp = elem = elem || document2;
              if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
              }
              if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
              }
              if (type.indexOf(".") > -1) {
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
              }
              ontype = type.indexOf(":") < 0 && "on" + type;
              event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
              event.isTrigger = onlyHandlers ? 2 : 3;
              event.namespace = namespaces.join(".");
              event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
              event.result = void 0;
              if (!event.target) {
                event.target = elem;
              }
              data = data == null ? [event] : jQuery.makeArray(data, [event]);
              special = jQuery.event.special[type] || {};
              if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
              }
              if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                  cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                  eventPath.push(cur);
                  tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document2)) {
                  eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
                }
              }
              i = 0;
              while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                lastElement = cur;
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
                if (handle) {
                  handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                  event.result = handle.apply(cur, data);
                  if (event.result === false) {
                    event.preventDefault();
                  }
                }
              }
              event.type = type;
              if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                  if (ontype && isFunction2(elem[type]) && !isWindow(elem)) {
                    tmp = elem[ontype];
                    if (tmp) {
                      elem[ontype] = null;
                    }
                    jQuery.event.triggered = type;
                    if (event.isPropagationStopped()) {
                      lastElement.addEventListener(type, stopPropagationCallback);
                    }
                    elem[type]();
                    if (event.isPropagationStopped()) {
                      lastElement.removeEventListener(type, stopPropagationCallback);
                    }
                    jQuery.event.triggered = void 0;
                    if (tmp) {
                      elem[ontype] = tmp;
                    }
                  }
                }
              }
              return event.result;
            },
            // Piggyback on a donor event to simulate a different one
            // Used only for `focus(in | out)` events
            simulate: function(type, elem, event) {
              var e2 = jQuery.extend(
                new jQuery.Event(),
                event,
                {
                  type,
                  isSimulated: true
                }
              );
              jQuery.event.trigger(e2, null, elem);
            }
          });
          jQuery.fn.extend({
            trigger: function(type, data) {
              return this.each(function() {
                jQuery.event.trigger(type, data, this);
              });
            },
            triggerHandler: function(type, data) {
              var elem = this[0];
              if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
              }
            }
          });
          var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
          function buildParams(prefix, obj, traditional, add2) {
            var name;
            if (Array.isArray(obj)) {
              jQuery.each(obj, function(i, v) {
                if (traditional || rbracket.test(prefix)) {
                  add2(prefix, v);
                } else {
                  buildParams(
                    prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
                    v,
                    traditional,
                    add2
                  );
                }
              });
            } else if (!traditional && toType(obj) === "object") {
              for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add2);
              }
            } else {
              add2(prefix, obj);
            }
          }
          jQuery.param = function(a, traditional) {
            var prefix, s2 = [], add2 = function(key, valueOrFunction) {
              var value = isFunction2(valueOrFunction) ? valueOrFunction() : valueOrFunction;
              s2[s2.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
            };
            if (a == null) {
              return "";
            }
            if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
              jQuery.each(a, function() {
                add2(this.name, this.value);
              });
            } else {
              for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add2);
              }
            }
            return s2.join("&");
          };
          jQuery.fn.extend({
            serialize: function() {
              return jQuery.param(this.serializeArray());
            },
            serializeArray: function() {
              return this.map(function() {
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
              }).filter(function() {
                var type = this.type;
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
              }).map(function(_i, elem) {
                var val = jQuery(this).val();
                if (val == null) {
                  return null;
                }
                if (Array.isArray(val)) {
                  return jQuery.map(val, function(val2) {
                    return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
                  });
                }
                return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
              }).get();
            }
          });
          var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
          originAnchor.href = location2.href;
          function addToPrefiltersOrTransports(structure) {
            return function(dataTypeExpression, func) {
              if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
              }
              var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
              if (isFunction2(func)) {
                while (dataType = dataTypes[i++]) {
                  if (dataType[0] === "+") {
                    dataType = dataType.slice(1) || "*";
                    (structure[dataType] = structure[dataType] || []).unshift(func);
                  } else {
                    (structure[dataType] = structure[dataType] || []).push(func);
                  }
                }
              }
            };
          }
          function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
            var inspected = {}, seekingTransport = structure === transports;
            function inspect(dataType) {
              var selected;
              inspected[dataType] = true;
              jQuery.each(structure[dataType] || [], function(_2, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                  options.dataTypes.unshift(dataTypeOrTransport);
                  inspect(dataTypeOrTransport);
                  return false;
                } else if (seekingTransport) {
                  return !(selected = dataTypeOrTransport);
                }
              });
              return selected;
            }
            return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
          }
          function ajaxExtend(target, src) {
            var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
            for (key in src) {
              if (src[key] !== void 0) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
              }
            }
            if (deep) {
              jQuery.extend(true, target, deep);
            }
            return target;
          }
          function ajaxHandleResponses(s2, jqXHR, responses) {
            var ct2, type, finalDataType, firstDataType, contents = s2.contents, dataTypes = s2.dataTypes;
            while (dataTypes[0] === "*") {
              dataTypes.shift();
              if (ct2 === void 0) {
                ct2 = s2.mimeType || jqXHR.getResponseHeader("Content-Type");
              }
            }
            if (ct2) {
              for (type in contents) {
                if (contents[type] && contents[type].test(ct2)) {
                  dataTypes.unshift(type);
                  break;
                }
              }
            }
            if (dataTypes[0] in responses) {
              finalDataType = dataTypes[0];
            } else {
              for (type in responses) {
                if (!dataTypes[0] || s2.converters[type + " " + dataTypes[0]]) {
                  finalDataType = type;
                  break;
                }
                if (!firstDataType) {
                  firstDataType = type;
                }
              }
              finalDataType = finalDataType || firstDataType;
            }
            if (finalDataType) {
              if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
              }
              return responses[finalDataType];
            }
          }
          function ajaxConvert(s2, response, jqXHR, isSuccess) {
            var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s2.dataTypes.slice();
            if (dataTypes[1]) {
              for (conv in s2.converters) {
                converters[conv.toLowerCase()] = s2.converters[conv];
              }
            }
            current = dataTypes.shift();
            while (current) {
              if (s2.responseFields[current]) {
                jqXHR[s2.responseFields[current]] = response;
              }
              if (!prev && isSuccess && s2.dataFilter) {
                response = s2.dataFilter(response, s2.dataType);
              }
              prev = current;
              current = dataTypes.shift();
              if (current) {
                if (current === "*") {
                  current = prev;
                } else if (prev !== "*" && prev !== current) {
                  conv = converters[prev + " " + current] || converters["* " + current];
                  if (!conv) {
                    for (conv2 in converters) {
                      tmp = conv2.split(" ");
                      if (tmp[1] === current) {
                        conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                        if (conv) {
                          if (conv === true) {
                            conv = converters[conv2];
                          } else if (converters[conv2] !== true) {
                            current = tmp[0];
                            dataTypes.unshift(tmp[1]);
                          }
                          break;
                        }
                      }
                    }
                  }
                  if (conv !== true) {
                    if (conv && s2.throws) {
                      response = conv(response);
                    } else {
                      try {
                        response = conv(response);
                      } catch (e2) {
                        return {
                          state: "parsererror",
                          error: conv ? e2 : "No conversion from " + prev + " to " + current
                        };
                      }
                    }
                  }
                }
              }
            }
            return { state: "success", data: response };
          }
          jQuery.extend({
            // Counter for holding the number of active queries
            active: 0,
            // Last-Modified header cache for next request
            lastModified: {},
            etag: {},
            ajaxSettings: {
              url: location2.href,
              type: "GET",
              isLocal: rlocalProtocol.test(location2.protocol),
              global: true,
              processData: true,
              async: true,
              contentType: "application/x-www-form-urlencoded; charset=UTF-8",
              /*
              timeout: 0,
              data: null,
              dataType: null,
              username: null,
              password: null,
              cache: null,
              throws: false,
              traditional: false,
              headers: {},
              */
              accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
              },
              contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
              },
              responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
              },
              // Data converters
              // Keys separate source (or catchall "*") and destination types with a single space
              converters: {
                // Convert anything to text
                "* text": String,
                // Text to html (true = no transformation)
                "text html": true,
                // Evaluate text as a json expression
                "text json": JSON.parse,
                // Parse text as xml
                "text xml": jQuery.parseXML
              },
              // For options that shouldn't be deep extended:
              // you can add your own custom options here if
              // and when you create one that shouldn't be
              // deep extended (see ajaxExtend)
              flatOptions: {
                url: true,
                context: true
              }
            },
            // Creates a full fledged settings object into target
            // with both ajaxSettings and settings fields.
            // If target is omitted, writes into ajaxSettings.
            ajaxSetup: function(target, settings) {
              return settings ? (
                // Building a settings object
                ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
              ) : (
                // Extending ajaxSettings
                ajaxExtend(jQuery.ajaxSettings, target)
              );
            },
            ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
            ajaxTransport: addToPrefiltersOrTransports(transports),
            // Main method
            ajax: function(url, options) {
              if (typeof url === "object") {
                options = url;
                url = void 0;
              }
              options = options || {};
              var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i, uncached, s2 = jQuery.ajaxSetup({}, options), callbackContext = s2.context || s2, globalEventContext = s2.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s2.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
                readyState: 0,
                // Builds headers hashtable if needed
                getResponseHeader: function(key) {
                  var match;
                  if (completed2) {
                    if (!responseHeaders) {
                      responseHeaders = {};
                      while (match = rheaders.exec(responseHeadersString)) {
                        responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                      }
                    }
                    match = responseHeaders[key.toLowerCase() + " "];
                  }
                  return match == null ? null : match.join(", ");
                },
                // Raw string
                getAllResponseHeaders: function() {
                  return completed2 ? responseHeadersString : null;
                },
                // Caches the header
                setRequestHeader: function(name, value) {
                  if (completed2 == null) {
                    name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                    requestHeaders[name] = value;
                  }
                  return this;
                },
                // Overrides response content-type header
                overrideMimeType: function(type) {
                  if (completed2 == null) {
                    s2.mimeType = type;
                  }
                  return this;
                },
                // Status-dependent callbacks
                statusCode: function(map) {
                  var code;
                  if (map) {
                    if (completed2) {
                      jqXHR.always(map[jqXHR.status]);
                    } else {
                      for (code in map) {
                        statusCode[code] = [statusCode[code], map[code]];
                      }
                    }
                  }
                  return this;
                },
                // Cancel the request
                abort: function(statusText) {
                  var finalText = statusText || strAbort;
                  if (transport) {
                    transport.abort(finalText);
                  }
                  done(0, finalText);
                  return this;
                }
              };
              deferred.promise(jqXHR);
              s2.url = ((url || s2.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
              s2.type = options.method || options.type || s2.method || s2.type;
              s2.dataTypes = (s2.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
              if (s2.crossDomain == null) {
                urlAnchor = document2.createElement("a");
                try {
                  urlAnchor.href = s2.url;
                  urlAnchor.href = urlAnchor.href;
                  s2.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
                } catch (e2) {
                  s2.crossDomain = true;
                }
              }
              if (s2.data && s2.processData && typeof s2.data !== "string") {
                s2.data = jQuery.param(s2.data, s2.traditional);
              }
              inspectPrefiltersOrTransports(prefilters, s2, options, jqXHR);
              if (completed2) {
                return jqXHR;
              }
              fireGlobals = jQuery.event && s2.global;
              if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
              }
              s2.type = s2.type.toUpperCase();
              s2.hasContent = !rnoContent.test(s2.type);
              cacheURL = s2.url.replace(rhash, "");
              if (!s2.hasContent) {
                uncached = s2.url.slice(cacheURL.length);
                if (s2.data && (s2.processData || typeof s2.data === "string")) {
                  cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s2.data;
                  delete s2.data;
                }
                if (s2.cache === false) {
                  cacheURL = cacheURL.replace(rantiCache, "$1");
                  uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
                }
                s2.url = cacheURL + uncached;
              } else if (s2.data && s2.processData && (s2.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
                s2.data = s2.data.replace(r20, "+");
              }
              if (s2.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                  jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                  jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                }
              }
              if (s2.data && s2.hasContent && s2.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s2.contentType);
              }
              jqXHR.setRequestHeader(
                "Accept",
                s2.dataTypes[0] && s2.accepts[s2.dataTypes[0]] ? s2.accepts[s2.dataTypes[0]] + (s2.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s2.accepts["*"]
              );
              for (i in s2.headers) {
                jqXHR.setRequestHeader(i, s2.headers[i]);
              }
              if (s2.beforeSend && (s2.beforeSend.call(callbackContext, jqXHR, s2) === false || completed2)) {
                return jqXHR.abort();
              }
              strAbort = "abort";
              completeDeferred.add(s2.complete);
              jqXHR.done(s2.success);
              jqXHR.fail(s2.error);
              transport = inspectPrefiltersOrTransports(transports, s2, options, jqXHR);
              if (!transport) {
                done(-1, "No Transport");
              } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                  globalEventContext.trigger("ajaxSend", [jqXHR, s2]);
                }
                if (completed2) {
                  return jqXHR;
                }
                if (s2.async && s2.timeout > 0) {
                  timeoutTimer = window2.setTimeout(function() {
                    jqXHR.abort("timeout");
                  }, s2.timeout);
                }
                try {
                  completed2 = false;
                  transport.send(requestHeaders, done);
                } catch (e2) {
                  if (completed2) {
                    throw e2;
                  }
                  done(-1, e2);
                }
              }
              function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (completed2) {
                  return;
                }
                completed2 = true;
                if (timeoutTimer) {
                  window2.clearTimeout(timeoutTimer);
                }
                transport = void 0;
                responseHeadersString = headers || "";
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                  response = ajaxHandleResponses(s2, jqXHR, responses);
                }
                if (!isSuccess && jQuery.inArray("script", s2.dataTypes) > -1 && jQuery.inArray("json", s2.dataTypes) < 0) {
                  s2.converters["text script"] = function() {
                  };
                }
                response = ajaxConvert(s2, response, jqXHR, isSuccess);
                if (isSuccess) {
                  if (s2.ifModified) {
                    modified = jqXHR.getResponseHeader("Last-Modified");
                    if (modified) {
                      jQuery.lastModified[cacheURL] = modified;
                    }
                    modified = jqXHR.getResponseHeader("etag");
                    if (modified) {
                      jQuery.etag[cacheURL] = modified;
                    }
                  }
                  if (status === 204 || s2.type === "HEAD") {
                    statusText = "nocontent";
                  } else if (status === 304) {
                    statusText = "notmodified";
                  } else {
                    statusText = response.state;
                    success = response.data;
                    error = response.error;
                    isSuccess = !error;
                  }
                } else {
                  error = statusText;
                  if (status || !statusText) {
                    statusText = "error";
                    if (status < 0) {
                      status = 0;
                    }
                  }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                if (isSuccess) {
                  deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                  deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = void 0;
                if (fireGlobals) {
                  globalEventContext.trigger(
                    isSuccess ? "ajaxSuccess" : "ajaxError",
                    [jqXHR, s2, isSuccess ? success : error]
                  );
                }
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
                if (fireGlobals) {
                  globalEventContext.trigger("ajaxComplete", [jqXHR, s2]);
                  if (!--jQuery.active) {
                    jQuery.event.trigger("ajaxStop");
                  }
                }
              }
              return jqXHR;
            },
            getJSON: function(url, data, callback) {
              return jQuery.get(url, data, callback, "json");
            },
            getScript: function(url, callback) {
              return jQuery.get(url, void 0, callback, "script");
            }
          });
          jQuery.each(["get", "post"], function(_i, method) {
            jQuery[method] = function(url, data, callback, type) {
              if (isFunction2(data)) {
                type = type || callback;
                callback = data;
                data = void 0;
              }
              return jQuery.ajax(jQuery.extend({
                url,
                type: method,
                dataType: type,
                data,
                success: callback
              }, jQuery.isPlainObject(url) && url));
            };
          });
          jQuery.ajaxPrefilter(function(s2) {
            var i;
            for (i in s2.headers) {
              if (i.toLowerCase() === "content-type") {
                s2.contentType = s2.headers[i] || "";
              }
            }
          });
          jQuery._evalUrl = function(url, options, doc2) {
            return jQuery.ajax({
              url,
              // Make this explicit, since user can override this through ajaxSetup (trac-11264)
              type: "GET",
              dataType: "script",
              cache: true,
              async: false,
              global: false,
              // Only evaluate the response if it is successful (gh-4126)
              // dataFilter is not invoked for failure responses, so using it instead
              // of the default converter is kludgy but it works.
              converters: {
                "text script": function() {
                }
              },
              dataFilter: function(response) {
                jQuery.globalEval(response, options, doc2);
              }
            });
          };
          jQuery.fn.extend({
            wrapAll: function(html) {
              var wrap;
              if (this[0]) {
                if (isFunction2(html)) {
                  html = html.call(this[0]);
                }
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                  wrap.insertBefore(this[0]);
                }
                wrap.map(function() {
                  var elem = this;
                  while (elem.firstElementChild) {
                    elem = elem.firstElementChild;
                  }
                  return elem;
                }).append(this);
              }
              return this;
            },
            wrapInner: function(html) {
              if (isFunction2(html)) {
                return this.each(function(i) {
                  jQuery(this).wrapInner(html.call(this, i));
                });
              }
              return this.each(function() {
                var self2 = jQuery(this), contents = self2.contents();
                if (contents.length) {
                  contents.wrapAll(html);
                } else {
                  self2.append(html);
                }
              });
            },
            wrap: function(html) {
              var htmlIsFunction = isFunction2(html);
              return this.each(function(i) {
                jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
              });
            },
            unwrap: function(selector) {
              this.parent(selector).not("body").each(function() {
                jQuery(this).replaceWith(this.childNodes);
              });
              return this;
            }
          });
          jQuery.expr.pseudos.hidden = function(elem) {
            return !jQuery.expr.pseudos.visible(elem);
          };
          jQuery.expr.pseudos.visible = function(elem) {
            return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
          };
          jQuery.ajaxSettings.xhr = function() {
            try {
              return new window2.XMLHttpRequest();
            } catch (e2) {
            }
          };
          var xhrSuccessStatus = {
            // File protocol always yields status code 0, assume 200
            0: 200,
            // Support: IE <=9 only
            // trac-1450: sometimes IE returns 1223 when it should be 204
            1223: 204
          }, xhrSupported = jQuery.ajaxSettings.xhr();
          support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
          support.ajax = xhrSupported = !!xhrSupported;
          jQuery.ajaxTransport(function(options) {
            var callback, errorCallback;
            if (support.cors || xhrSupported && !options.crossDomain) {
              return {
                send: function(headers, complete) {
                  var i, xhr = options.xhr();
                  xhr.open(
                    options.type,
                    options.url,
                    options.async,
                    options.username,
                    options.password
                  );
                  if (options.xhrFields) {
                    for (i in options.xhrFields) {
                      xhr[i] = options.xhrFields[i];
                    }
                  }
                  if (options.mimeType && xhr.overrideMimeType) {
                    xhr.overrideMimeType(options.mimeType);
                  }
                  if (!options.crossDomain && !headers["X-Requested-With"]) {
                    headers["X-Requested-With"] = "XMLHttpRequest";
                  }
                  for (i in headers) {
                    xhr.setRequestHeader(i, headers[i]);
                  }
                  callback = function(type) {
                    return function() {
                      if (callback) {
                        callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                        if (type === "abort") {
                          xhr.abort();
                        } else if (type === "error") {
                          if (typeof xhr.status !== "number") {
                            complete(0, "error");
                          } else {
                            complete(
                              // File: protocol always yields status 0; see trac-8605, trac-14207
                              xhr.status,
                              xhr.statusText
                            );
                          }
                        } else {
                          complete(
                            xhrSuccessStatus[xhr.status] || xhr.status,
                            xhr.statusText,
                            // Support: IE <=9 only
                            // IE9 has no XHR2 but throws on binary (trac-11426)
                            // For XHR2 non-text, let the caller handle it (gh-2498)
                            (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                            xhr.getAllResponseHeaders()
                          );
                        }
                      }
                    };
                  };
                  xhr.onload = callback();
                  errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
                  if (xhr.onabort !== void 0) {
                    xhr.onabort = errorCallback;
                  } else {
                    xhr.onreadystatechange = function() {
                      if (xhr.readyState === 4) {
                        window2.setTimeout(function() {
                          if (callback) {
                            errorCallback();
                          }
                        });
                      }
                    };
                  }
                  callback = callback("abort");
                  try {
                    xhr.send(options.hasContent && options.data || null);
                  } catch (e2) {
                    if (callback) {
                      throw e2;
                    }
                  }
                },
                abort: function() {
                  if (callback) {
                    callback();
                  }
                }
              };
            }
          });
          jQuery.ajaxPrefilter(function(s2) {
            if (s2.crossDomain) {
              s2.contents.script = false;
            }
          });
          jQuery.ajaxSetup({
            accepts: {
              script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
            },
            contents: {
              script: /\b(?:java|ecma)script\b/
            },
            converters: {
              "text script": function(text) {
                jQuery.globalEval(text);
                return text;
              }
            }
          });
          jQuery.ajaxPrefilter("script", function(s2) {
            if (s2.cache === void 0) {
              s2.cache = false;
            }
            if (s2.crossDomain) {
              s2.type = "GET";
            }
          });
          jQuery.ajaxTransport("script", function(s2) {
            if (s2.crossDomain || s2.scriptAttrs) {
              var script, callback;
              return {
                send: function(_2, complete) {
                  script = jQuery("<script>").attr(s2.scriptAttrs || {}).prop({ charset: s2.scriptCharset, src: s2.url }).on("load error", callback = function(evt) {
                    script.remove();
                    callback = null;
                    if (evt) {
                      complete(evt.type === "error" ? 404 : 200, evt.type);
                    }
                  });
                  document2.head.appendChild(script[0]);
                },
                abort: function() {
                  if (callback) {
                    callback();
                  }
                }
              };
            }
          });
          var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
          jQuery.ajaxSetup({
            jsonp: "callback",
            jsonpCallback: function() {
              var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
              this[callback] = true;
              return callback;
            }
          });
          jQuery.ajaxPrefilter("json jsonp", function(s2, originalSettings, jqXHR) {
            var callbackName, overwritten, responseContainer, jsonProp = s2.jsonp !== false && (rjsonp.test(s2.url) ? "url" : typeof s2.data === "string" && (s2.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s2.data) && "data");
            if (jsonProp || s2.dataTypes[0] === "jsonp") {
              callbackName = s2.jsonpCallback = isFunction2(s2.jsonpCallback) ? s2.jsonpCallback() : s2.jsonpCallback;
              if (jsonProp) {
                s2[jsonProp] = s2[jsonProp].replace(rjsonp, "$1" + callbackName);
              } else if (s2.jsonp !== false) {
                s2.url += (rquery.test(s2.url) ? "&" : "?") + s2.jsonp + "=" + callbackName;
              }
              s2.converters["script json"] = function() {
                if (!responseContainer) {
                  jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
              };
              s2.dataTypes[0] = "json";
              overwritten = window2[callbackName];
              window2[callbackName] = function() {
                responseContainer = arguments;
              };
              jqXHR.always(function() {
                if (overwritten === void 0) {
                  jQuery(window2).removeProp(callbackName);
                } else {
                  window2[callbackName] = overwritten;
                }
                if (s2[callbackName]) {
                  s2.jsonpCallback = originalSettings.jsonpCallback;
                  oldCallbacks.push(callbackName);
                }
                if (responseContainer && isFunction2(overwritten)) {
                  overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = void 0;
              });
              return "script";
            }
          });
          support.createHTMLDocument = function() {
            var body = document2.implementation.createHTMLDocument("").body;
            body.innerHTML = "<form></form><form></form>";
            return body.childNodes.length === 2;
          }();
          jQuery.parseHTML = function(data, context, keepScripts) {
            if (typeof data !== "string") {
              return [];
            }
            if (typeof context === "boolean") {
              keepScripts = context;
              context = false;
            }
            var base2, parsed, scripts;
            if (!context) {
              if (support.createHTMLDocument) {
                context = document2.implementation.createHTMLDocument("");
                base2 = context.createElement("base");
                base2.href = document2.location.href;
                context.head.appendChild(base2);
              } else {
                context = document2;
              }
            }
            parsed = rsingleTag.exec(data);
            scripts = !keepScripts && [];
            if (parsed) {
              return [context.createElement(parsed[1])];
            }
            parsed = buildFragment([data], context, scripts);
            if (scripts && scripts.length) {
              jQuery(scripts).remove();
            }
            return jQuery.merge([], parsed.childNodes);
          };
          jQuery.fn.load = function(url, params, callback) {
            var selector, type, response, self2 = this, off = url.indexOf(" ");
            if (off > -1) {
              selector = stripAndCollapse(url.slice(off));
              url = url.slice(0, off);
            }
            if (isFunction2(params)) {
              callback = params;
              params = void 0;
            } else if (params && typeof params === "object") {
              type = "POST";
            }
            if (self2.length > 0) {
              jQuery.ajax({
                url,
                // If "type" variable is undefined, then "GET" method will be used.
                // Make value of this field explicit since
                // user can override it through ajaxSetup method
                type: type || "GET",
                dataType: "html",
                data: params
              }).done(function(responseText) {
                response = arguments;
                self2.html(selector ? (
                  // If a selector was specified, locate the right elements in a dummy div
                  // Exclude scripts to avoid IE 'Permission Denied' errors
                  jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector)
                ) : (
                  // Otherwise use the full result
                  responseText
                ));
              }).always(callback && function(jqXHR, status) {
                self2.each(function() {
                  callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
                });
              });
            }
            return this;
          };
          jQuery.expr.pseudos.animated = function(elem) {
            return jQuery.grep(jQuery.timers, function(fn2) {
              return elem === fn2.elem;
            }).length;
          };
          jQuery.offset = {
            setOffset: function(elem, options, i) {
              var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
              if (position === "static") {
                elem.style.position = "relative";
              }
              curOffset = curElem.offset();
              curCSSTop = jQuery.css(elem, "top");
              curCSSLeft = jQuery.css(elem, "left");
              calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
              if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
              } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
              }
              if (isFunction2(options)) {
                options = options.call(elem, i, jQuery.extend({}, curOffset));
              }
              if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
              }
              if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
              }
              if ("using" in options) {
                options.using.call(elem, props);
              } else {
                curElem.css(props);
              }
            }
          };
          jQuery.fn.extend({
            // offset() relates an element's border box to the document origin
            offset: function(options) {
              if (arguments.length) {
                return options === void 0 ? this : this.each(function(i) {
                  jQuery.offset.setOffset(this, options, i);
                });
              }
              var rect, win, elem = this[0];
              if (!elem) {
                return;
              }
              if (!elem.getClientRects().length) {
                return { top: 0, left: 0 };
              }
              rect = elem.getBoundingClientRect();
              win = elem.ownerDocument.defaultView;
              return {
                top: rect.top + win.pageYOffset,
                left: rect.left + win.pageXOffset
              };
            },
            // position() relates an element's margin box to its offset parent's padding box
            // This corresponds to the behavior of CSS absolute positioning
            position: function() {
              if (!this[0]) {
                return;
              }
              var offsetParent, offset, doc2, elem = this[0], parentOffset = { top: 0, left: 0 };
              if (jQuery.css(elem, "position") === "fixed") {
                offset = elem.getBoundingClientRect();
              } else {
                offset = this.offset();
                doc2 = elem.ownerDocument;
                offsetParent = elem.offsetParent || doc2.documentElement;
                while (offsetParent && (offsetParent === doc2.body || offsetParent === doc2.documentElement) && jQuery.css(offsetParent, "position") === "static") {
                  offsetParent = offsetParent.parentNode;
                }
                if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                  parentOffset = jQuery(offsetParent).offset();
                  parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
                  parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
                }
              }
              return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
              };
            },
            // This method will return documentElement in the following cases:
            // 1) For the element inside the iframe without offsetParent, this method will return
            //    documentElement of the parent window
            // 2) For the hidden or detached element
            // 3) For body or html element, i.e. in case of the html node - it will return itself
            //
            // but those exceptions were never presented as a real life use-cases
            // and might be considered as more preferable results.
            //
            // This logic, however, is not guaranteed and can change at any point in the future
            offsetParent: function() {
              return this.map(function() {
                var offsetParent = this.offsetParent;
                while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
                  offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || documentElement;
              });
            }
          });
          jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
            var top = "pageYOffset" === prop;
            jQuery.fn[method] = function(val) {
              return access(this, function(elem, method2, val2) {
                var win;
                if (isWindow(elem)) {
                  win = elem;
                } else if (elem.nodeType === 9) {
                  win = elem.defaultView;
                }
                if (val2 === void 0) {
                  return win ? win[prop] : elem[method2];
                }
                if (win) {
                  win.scrollTo(
                    !top ? val2 : win.pageXOffset,
                    top ? val2 : win.pageYOffset
                  );
                } else {
                  elem[method2] = val2;
                }
              }, method, val, arguments.length);
            };
          });
          jQuery.each(["top", "left"], function(_i, prop) {
            jQuery.cssHooks[prop] = addGetHookIf(
              support.pixelPosition,
              function(elem, computed2) {
                if (computed2) {
                  computed2 = curCSS(elem, prop);
                  return rnumnonpx.test(computed2) ? jQuery(elem).position()[prop] + "px" : computed2;
                }
              }
            );
          });
          jQuery.each({ Height: "height", Width: "width" }, function(name, type) {
            jQuery.each({
              padding: "inner" + name,
              content: type,
              "": "outer" + name
            }, function(defaultExtra, funcName) {
              jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                return access(this, function(elem, type2, value2) {
                  var doc2;
                  if (isWindow(elem)) {
                    return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                  }
                  if (elem.nodeType === 9) {
                    doc2 = elem.documentElement;
                    return Math.max(
                      elem.body["scroll" + name],
                      doc2["scroll" + name],
                      elem.body["offset" + name],
                      doc2["offset" + name],
                      doc2["client" + name]
                    );
                  }
                  return value2 === void 0 ? (
                    // Get width or height on the element, requesting but not forcing parseFloat
                    jQuery.css(elem, type2, extra)
                  ) : (
                    // Set width or height on the element
                    jQuery.style(elem, type2, value2, extra)
                  );
                }, type, chainable ? margin : void 0, chainable);
              };
            });
          });
          jQuery.each([
            "ajaxStart",
            "ajaxStop",
            "ajaxComplete",
            "ajaxError",
            "ajaxSuccess",
            "ajaxSend"
          ], function(_i, type) {
            jQuery.fn[type] = function(fn2) {
              return this.on(type, fn2);
            };
          });
          jQuery.fn.extend({
            bind: function(types, data, fn2) {
              return this.on(types, null, data, fn2);
            },
            unbind: function(types, fn2) {
              return this.off(types, null, fn2);
            },
            delegate: function(selector, types, data, fn2) {
              return this.on(types, selector, data, fn2);
            },
            undelegate: function(selector, types, fn2) {
              return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn2);
            },
            hover: function(fnOver, fnOut) {
              return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
            }
          });
          jQuery.each(
            "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
            function(_i, name) {
              jQuery.fn[name] = function(data, fn2) {
                return arguments.length > 0 ? this.on(name, null, data, fn2) : this.trigger(name);
              };
            }
          );
          var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
          jQuery.proxy = function(fn2, context) {
            var tmp, args, proxy;
            if (typeof context === "string") {
              tmp = fn2[context];
              context = fn2;
              fn2 = tmp;
            }
            if (!isFunction2(fn2)) {
              return void 0;
            }
            args = slice.call(arguments, 2);
            proxy = function() {
              return fn2.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn2.guid = fn2.guid || jQuery.guid++;
            return proxy;
          };
          jQuery.holdReady = function(hold) {
            if (hold) {
              jQuery.readyWait++;
            } else {
              jQuery.ready(true);
            }
          };
          jQuery.isArray = Array.isArray;
          jQuery.parseJSON = JSON.parse;
          jQuery.nodeName = nodeName;
          jQuery.isFunction = isFunction2;
          jQuery.isWindow = isWindow;
          jQuery.camelCase = camelCase;
          jQuery.type = toType;
          jQuery.now = Date.now;
          jQuery.isNumeric = function(obj) {
            var type = jQuery.type(obj);
            return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            !isNaN(obj - parseFloat(obj));
          };
          jQuery.trim = function(text) {
            return text == null ? "" : (text + "").replace(rtrim, "$1");
          };
          var _jQuery = window2.jQuery, _$ = window2.$;
          jQuery.noConflict = function(deep) {
            if (window2.$ === jQuery) {
              window2.$ = _$;
            }
            if (deep && window2.jQuery === jQuery) {
              window2.jQuery = _jQuery;
            }
            return jQuery;
          };
          if (typeof noGlobal === "undefined") {
            window2.jQuery = window2.$ = jQuery;
          }
          return jQuery;
        });
      })(jquery);
      var jqueryExports = jquery.exports;
      const $$1 = /* @__PURE__ */ getDefaultExportFromCjs(jqueryExports);
      const isDev = false;
      function getGameSkyContent(text) {
        if (text) {
          return $$1(text).find(".Mid2L_con,.MidLcon").html();
        } else {
          return (document.querySelector(".Mid2L_con") || document.querySelector(".MidLcon")).innerHTML;
        }
      }
      function commonTitleClean(content) {
        return content;
      }
      function commonContentClean(content) {
        content = xss(content, {
          whiteList: {
            p: ["align"],
            span: [],
            br: [],
            h1: [],
            h2: [],
            h3: [],
            h4: [],
            h5: [],
            h6: [],
            img: ["src", "original-image-width", "original-image-height"]
          },
          stripIgnoreTag: true,
          stripIgnoreTagBody: ["script", "table"],
          allowCommentTag: false,
          onTag: (tag, html, options) => {
          }
        });
        content = domCleanBySelectorList(content, [
          "br+br",
          "p:empty+p:empty",
          "p:last-child:empty",
          "p:last-child:empty",
          "p:last-child:empty",
          "br:last-child:empty",
          "br:last-child:empty",
          "br:last-child:empty"
        ]);
        content = content.replaceAll(/游侠网/g, "186社区");
        content = content.replaceAll(/游民星空/g, "186社区");
        content = content.replaceAll(/虎扑/g, "186社区");
        content = content.replaceAll(/虎扑/g, "186社区");
        return content;
      }
      function gameSkyContentClean(content) {
        let $content = $$1(`<div>${content}</div>`);
        $content.find("img[data-src]").each(function() {
          const dataSrc = $$1(this).attr("data-src");
          $$1(this).attr("src", dataSrc);
        });
        content = $content.html();
        content = domCleanBySelectorList(content, [
          ".page_css",
          ".gs_nc_editor",
          "#pe100_page_contentpage",
          ".gs_ccs_solve",
          ".post_ding",
          ".post_ding_top",
          "p:contains('更多相关内容请关注')",
          "p:contains('更多相关资讯请关注')",
          "p:contains('本文由游民星空制作发布，未经允许禁止转载')"
        ]);
        content = commonContentClean(content);
        return content;
      }
      function buffContentClean(content) {
        content = content.replaceAll("data-original=", "src=");
        content = commonContentClean(content);
        content = content.replace(
          /<p>本文由游民星空制作发布，未经允许禁止转载。<\/p>[\s\S]*/,
          ""
        );
        return content;
      }
      function ali213ContentClean(content) {
        content = domCleanBySelectorList(content, [
          ".morezjjump-source",
          ".n_show_g",
          ".morezjjump"
        ]);
        content = commonContentClean(content);
        content = content.replaceAll(
          /<p><span><span><img src="(.*?)"><\/span><\/span><\/p>/g,
          `<img src="$1" />`
        );
        return content;
      }
      function hupuContentClean(content) {
        content = domCleanBySelectorList(content, [".article-source"]);
        content = commonContentClean(content);
        return content;
      }
      function domCleanBySelectorList(content, selectorList) {
        let $content = $$1(`<div>${content}</div>`);
        selectorList.forEach((item) => {
          $content.find(item).remove();
        });
        return $content.html();
      }
      typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
      const isDef = (val) => typeof val !== "undefined";
      function cloneFnJSON(source) {
        return JSON.parse(JSON.stringify(source));
      }
      function useVModel(props, key, emit2, options = {}) {
        var _a2, _b, _c;
        const {
          clone = false,
          passive = false,
          eventName,
          deep = false,
          defaultValue,
          shouldEmit
        } = options;
        const vm = getCurrentInstance();
        const _emit = emit2 || (vm == null ? void 0 : vm.emit) || ((_a2 = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a2.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
        let event = eventName;
        if (!key) {
          {
            key = "modelValue";
          }
        }
        event = event || `update:${key.toString()}`;
        const cloneFn = (val) => !clone ? val : typeof clone === "function" ? clone(val) : cloneFnJSON(val);
        const getValue2 = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;
        const triggerEmit = (value) => {
          if (shouldEmit) {
            if (shouldEmit(value))
              _emit(event, value);
          } else {
            _emit(event, value);
          }
        };
        if (passive) {
          const initialValue = getValue2();
          const proxy = ref(initialValue);
          let isUpdating = false;
          watch(
            () => props[key],
            (v) => {
              if (!isUpdating) {
                isUpdating = true;
                proxy.value = cloneFn(v);
                nextTick(() => isUpdating = false);
              }
            }
          );
          watch(
            proxy,
            (v) => {
              if (!isUpdating && (v !== props[key] || deep))
                triggerEmit(v);
            },
            { deep }
          );
          return proxy;
        } else {
          return computed({
            get() {
              return getValue2();
            },
            set(value) {
              triggerEmit(value);
            }
          });
        }
      }
      async function rollGetGameSkyContent() {
        const list = [];
        let html = "";
        extractPages(list);
        for (let item of list) {
          await fetch(item.href).then((res) => res.text()).then((res) => {
            let data = getGameSkyContent(res);
            html += data;
            extractPages(list, res);
          });
        }
        return html;
      }
      function extractPages(list, dom = document) {
        $(dom).find(".page_css a").each(function() {
          const num = +$(this).text();
          if (!!num && !list.find((item) => item.page === num)) {
            list.push({
              page: num,
              href: $(this).attr("href")
            });
          }
        });
      }
      const _hoisted_1$1 = { class: "max-h-70vh overflow-auto" };
      const _hoisted_2 = { class: "flex space-x-12px items-center justify-end" };
      const _sfc_main$1 = {
        __name: "ArticleDialog",
        props: {
          visible: false
        },
        emits: ["update:visible"],
        setup(__props, { emit: __emit }) {
          const props = __props;
          const emit2 = __emit;
          const visible = useVModel(props, "visible", emit2);
          const date2 = ref(null);
          const category = ref(null);
          const tags = ref(null);
          const title = ref("");
          const content = ref("");
          const getData = async () => {
            if (location.origin === "https://www.csgo.com.cn") {
              title.value = document.querySelector(".title-box h2").innerHTML;
              content.value = commonContentClean(
                document.querySelector(".wen_news").innerHTML
              );
            } else if (location.origin === "https://www.gamersky.com") {
              title.value = document.querySelector("h1").innerHTML;
              if (document.querySelector(".page_css")) {
                content.value = gameSkyContentClean(await rollGetGameSkyContent());
              } else {
                content.value = gameSkyContentClean(getGameSkyContent());
              }
            } else if (location.origin === "https://buff.163.com") {
              title.value = document.querySelector("h1").innerHTML;
              content.value = buffContentClean(
                document.querySelector(".news-detail-cont").innerHTML
              );
            } else if (location.origin === "https://gl.ali213.net") {
              title.value = document.querySelector("h1 .big").innerHTML;
              content.value = ali213ContentClean(
                document.querySelector(".c-detail").outerHTML
              );
            } else if (location.origin === "https://bbs.hupu.com") {
              title.value = commonTitleClean(
                (document.querySelector("h1") || document.querySelector(".post-fix-title-title")).innerText
              );
              content.value = hupuContentClean(
                document.querySelector(".thread-content-detail").innerHTML
              );
            }
          };
          watch(visible, (val) => {
            if (val) {
              getData();
            }
          });
          return (_ctx, _cache) => {
            const _component_el_date_picker = ElDatePicker;
            const _component_el_option = ElOption;
            const _component_el_select = ElSelect;
            const _component_el_button = ElButton;
            const _component_el_dialog = ElDialog;
            return openBlock(), createElementBlock("div", null, [
              createVNode(_component_el_dialog, {
                "align-center": "",
                class: "control-dialog",
                width: "860px",
                modelValue: unref(visible),
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => isRef(visible) ? visible.value = $event : null),
                "append-to-body": ""
              }, {
                header: withCtx(() => [
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => title.value = $event),
                    class: "text-22px font-bold text-center w-780px p-2 text-left border-none"
                  }, null, 512), [
                    [vModelText, title.value]
                  ])
                ]),
                footer: withCtx(() => [
                  createBaseVNode("div", _hoisted_2, [
                    createVNode(_component_el_date_picker, {
                      modelValue: date2.value,
                      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => date2.value = $event),
                      type: "datetime",
                      size: "large",
                      placeholder: "定时发送"
                    }, null, 8, ["modelValue"]),
                    createVNode(_component_el_select, {
                      modelValue: category.value,
                      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => category.value = $event),
                      size: "large",
                      clearable: "",
                      placeholder: "专区",
                      class: "!w-160px"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_option, {
                          value: "1",
                          label: "1"
                        }),
                        createVNode(_component_el_option, {
                          value: "2",
                          label: "2"
                        }),
                        createVNode(_component_el_option, {
                          value: "3",
                          label: "3"
                        }),
                        createVNode(_component_el_option, {
                          value: "4",
                          label: "4"
                        })
                      ]),
                      _: 1
                    }, 8, ["modelValue"]),
                    createVNode(_component_el_select, {
                      modelValue: tags.value,
                      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => tags.value = $event),
                      multiple: "",
                      clearable: "",
                      size: "large",
                      placeholder: "话题",
                      class: "!w-160px"
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_option, {
                          value: "1",
                          label: "1"
                        }),
                        createVNode(_component_el_option, {
                          value: "2",
                          label: "2"
                        }),
                        createVNode(_component_el_option, {
                          value: "3",
                          label: "3"
                        }),
                        createVNode(_component_el_option, {
                          value: "4",
                          label: "4"
                        })
                      ]),
                      _: 1
                    }, 8, ["modelValue"]),
                    createVNode(_component_el_button, {
                      size: "large",
                      class: "w-120px",
                      type: "primary"
                    }, {
                      default: withCtx(() => [
                        createTextVNode("发布")
                      ]),
                      _: 1
                    })
                  ])
                ]),
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_1$1, [
                    createVNode(unref(_sfc_main$2), {
                      "no-html": false,
                      tag: "div",
                      modelValue: content.value,
                      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => content.value = $event),
                      class: "control-article mt-3 w-800px text-16px leading-24px p-6px"
                    }, null, 8, ["modelValue"])
                  ])
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]);
          };
        }
      };
      var _GM_addStyle = /* @__PURE__ */ (() => typeof GM_addStyle != "undefined" ? GM_addStyle : void 0)();
      var _GM_deleteValue = /* @__PURE__ */ (() => typeof GM_deleteValue != "undefined" ? GM_deleteValue : void 0)();
      var _GM_getValue = /* @__PURE__ */ (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)();
      var _GM_setValue = /* @__PURE__ */ (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)();
      var _GM_xmlhttpRequest = /* @__PURE__ */ (() => typeof GM_xmlhttpRequest != "undefined" ? GM_xmlhttpRequest : void 0)();
      function http(url, options) {
        return new Promise((resolve2, reject) => {
          _GM_xmlhttpRequest({
            url,
            responseType: "json",
            ...options,
            onloadend: (res) => {
              if (res.response.code === "0000") {
                resolve2(res.response.data);
              } else {
                reject(new Error("出错了"));
              }
            },
            onerror: () => {
              reject(new Error("出错了"));
            }
          });
        });
      }
      function getToken() {
        return _GM_getValue("admin-token");
      }
      function setToken(data) {
        _GM_setValue("admin-token", data);
      }
      function removeToken(data) {
        _GM_deleteValue("admin-token");
      }
      async function ensureToken() {
        let result = null;
        if (!getToken()) {
          result = false;
        }
        await http("https://186admin.nps.doveaz.xyz:1443/api/adminUser/getAdmin", {
          headers: {
            token: getToken()
          }
        }).then((res) => {
          console.log("success");
          result = true;
        }).catch(() => {
          console.log("error");
          result = false;
        });
        return result;
      }
      /*! Element Plus v2.5.0 */
      var zhCn = {
        name: "zh-cn",
        el: {
          colorpicker: {
            confirm: "确定",
            clear: "清空"
          },
          datepicker: {
            now: "此刻",
            today: "今天",
            cancel: "取消",
            clear: "清空",
            confirm: "确定",
            selectDate: "选择日期",
            selectTime: "选择时间",
            startDate: "开始日期",
            startTime: "开始时间",
            endDate: "结束日期",
            endTime: "结束时间",
            prevYear: "前一年",
            nextYear: "后一年",
            prevMonth: "上个月",
            nextMonth: "下个月",
            year: "年",
            month1: "1 月",
            month2: "2 月",
            month3: "3 月",
            month4: "4 月",
            month5: "5 月",
            month6: "6 月",
            month7: "7 月",
            month8: "8 月",
            month9: "9 月",
            month10: "10 月",
            month11: "11 月",
            month12: "12 月",
            weeks: {
              sun: "日",
              mon: "一",
              tue: "二",
              wed: "三",
              thu: "四",
              fri: "五",
              sat: "六"
            },
            months: {
              jan: "一月",
              feb: "二月",
              mar: "三月",
              apr: "四月",
              may: "五月",
              jun: "六月",
              jul: "七月",
              aug: "八月",
              sep: "九月",
              oct: "十月",
              nov: "十一月",
              dec: "十二月"
            }
          },
          select: {
            loading: "加载中",
            noMatch: "无匹配数据",
            noData: "无数据",
            placeholder: "请选择"
          },
          cascader: {
            noMatch: "无匹配数据",
            loading: "加载中",
            placeholder: "请选择",
            noData: "暂无数据"
          },
          pagination: {
            goto: "前往",
            pagesize: "条/页",
            total: "共 {total} 条",
            pageClassifier: "页",
            page: "页",
            prev: "上一页",
            next: "下一页",
            currentPage: "第 {pager} 页",
            prevPages: "向前 {pager} 页",
            nextPages: "向后 {pager} 页",
            deprecationWarning: "你使用了一些已被废弃的用法，请参考 el-pagination 的官方文档"
          },
          messagebox: {
            title: "提示",
            confirm: "确定",
            cancel: "取消",
            error: "输入的数据不合法!"
          },
          upload: {
            deleteTip: "按 delete 键可删除",
            delete: "删除",
            preview: "查看图片",
            continue: "继续上传"
          },
          table: {
            emptyText: "暂无数据",
            confirmFilter: "筛选",
            resetFilter: "重置",
            clearFilter: "全部",
            sumText: "合计"
          },
          tour: {
            next: "下一步",
            previous: "上一步",
            finish: "结束导览"
          },
          tree: {
            emptyText: "暂无数据"
          },
          transfer: {
            noMatch: "无匹配数据",
            noData: "无数据",
            titles: ["列表 1", "列表 2"],
            filterPlaceholder: "请输入搜索内容",
            noCheckedFormat: "共 {total} 项",
            hasCheckedFormat: "已选 {checked}/{total} 项"
          },
          image: {
            error: "加载失败"
          },
          pageHeader: {
            title: "返回"
          },
          popconfirm: {
            confirmButtonText: "确定",
            cancelButtonText: "取消"
          }
        }
      };
      const t$1 = (t2) => "object" == typeof t2 && null != t2 && 1 === t2.nodeType, e$1 = (t2, e2) => (!e2 || "hidden" !== t2) && ("visible" !== t2 && "clip" !== t2), n$1 = (t2, n2) => {
        if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
          const o2 = getComputedStyle(t2, null);
          return e$1(o2.overflowY, n2) || e$1(o2.overflowX, n2) || ((t3) => {
            const e2 = ((t4) => {
              if (!t4.ownerDocument || !t4.ownerDocument.defaultView)
                return null;
              try {
                return t4.ownerDocument.defaultView.frameElement;
              } catch (t5) {
                return null;
              }
            })(t3);
            return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
          })(t2);
        }
        return false;
      }, o$2 = (t2, e2, n2, o2, l2, r2, i, s2) => r2 < t2 && i > e2 || r2 > t2 && i < e2 ? 0 : r2 <= t2 && s2 <= n2 || i >= e2 && s2 >= n2 ? r2 - t2 - o2 : i > e2 && s2 < n2 || r2 < t2 && s2 > n2 ? i - e2 + l2 : 0, l$1 = (t2) => {
        const e2 = t2.parentElement;
        return null == e2 ? t2.getRootNode().host || null : e2;
      }, r$1 = (e2, r2) => {
        var i, s2, d, h2;
        if ("undefined" == typeof document)
          return [];
        const { scrollMode: c, block: f, inline: u, boundary: a, skipOverflowHiddenElements: g } = r2, p2 = "function" == typeof a ? a : (t2) => t2 !== a;
        if (!t$1(e2))
          throw new TypeError("Invalid target");
        const m = document.scrollingElement || document.documentElement, w = [];
        let W2 = e2;
        for (; t$1(W2) && p2(W2); ) {
          if (W2 = l$1(W2), W2 === m) {
            w.push(W2);
            break;
          }
          null != W2 && W2 === document.body && n$1(W2) && !n$1(document.documentElement) || null != W2 && n$1(W2, g) && w.push(W2);
        }
        const b = null != (s2 = null == (i = window.visualViewport) ? void 0 : i.width) ? s2 : innerWidth, H2 = null != (h2 = null == (d = window.visualViewport) ? void 0 : d.height) ? h2 : innerHeight, { scrollX: y, scrollY: M } = window, { height: v, width: E2, top: x, right: C2, bottom: I2, left: R2 } = e2.getBoundingClientRect(), { top: T, right: B2, bottom: F, left: V } = ((t2) => {
          const e3 = window.getComputedStyle(t2);
          return { top: parseFloat(e3.scrollMarginTop) || 0, right: parseFloat(e3.scrollMarginRight) || 0, bottom: parseFloat(e3.scrollMarginBottom) || 0, left: parseFloat(e3.scrollMarginLeft) || 0 };
        })(e2);
        let k = "start" === f || "nearest" === f ? x - T : "end" === f ? I2 + F : x + v / 2 - T + F, D = "center" === u ? R2 + E2 / 2 - V + B2 : "end" === u ? C2 + B2 : R2 - V;
        const L = [];
        for (let t2 = 0; t2 < w.length; t2++) {
          const e3 = w[t2], { height: n2, width: l2, top: r3, right: i2, bottom: s3, left: d2 } = e3.getBoundingClientRect();
          if ("if-needed" === c && x >= 0 && R2 >= 0 && I2 <= H2 && C2 <= b && x >= r3 && I2 <= s3 && R2 >= d2 && C2 <= i2)
            return L;
          const h3 = getComputedStyle(e3), a2 = parseInt(h3.borderLeftWidth, 10), g2 = parseInt(h3.borderTopWidth, 10), p3 = parseInt(h3.borderRightWidth, 10), W3 = parseInt(h3.borderBottomWidth, 10);
          let T2 = 0, B3 = 0;
          const F2 = "offsetWidth" in e3 ? e3.offsetWidth - e3.clientWidth - a2 - p3 : 0, V2 = "offsetHeight" in e3 ? e3.offsetHeight - e3.clientHeight - g2 - W3 : 0, S = "offsetWidth" in e3 ? 0 === e3.offsetWidth ? 0 : l2 / e3.offsetWidth : 0, X2 = "offsetHeight" in e3 ? 0 === e3.offsetHeight ? 0 : n2 / e3.offsetHeight : 0;
          if (m === e3)
            T2 = "start" === f ? k : "end" === f ? k - H2 : "nearest" === f ? o$2(M, M + H2, H2, g2, W3, M + k, M + k + v, v) : k - H2 / 2, B3 = "start" === u ? D : "center" === u ? D - b / 2 : "end" === u ? D - b : o$2(y, y + b, b, a2, p3, y + D, y + D + E2, E2), T2 = Math.max(0, T2 + M), B3 = Math.max(0, B3 + y);
          else {
            T2 = "start" === f ? k - r3 - g2 : "end" === f ? k - s3 + W3 + V2 : "nearest" === f ? o$2(r3, s3, n2, g2, W3 + V2, k, k + v, v) : k - (r3 + n2 / 2) + V2 / 2, B3 = "start" === u ? D - d2 - a2 : "center" === u ? D - (d2 + l2 / 2) + F2 / 2 : "end" === u ? D - i2 + p3 + F2 : o$2(d2, i2, l2, a2, p3 + F2, D, D + E2, E2);
            const { scrollLeft: t3, scrollTop: h4 } = e3;
            T2 = 0 === X2 ? 0 : Math.max(0, Math.min(h4 + T2 / X2, e3.scrollHeight - n2 / X2 + V2)), B3 = 0 === S ? 0 : Math.max(0, Math.min(t3 + B3 / S, e3.scrollWidth - l2 / S + F2)), k += h4 - T2, D += t3 - B3;
          }
          L.push({ el: e3, top: T2, left: B3 });
        }
        return L;
      };
      const o$1 = (t2) => false === t2 ? { block: "end", inline: "nearest" } : ((t3) => t3 === Object(t3) && 0 !== Object.keys(t3).length)(t2) ? t2 : { block: "start", inline: "nearest" };
      function e(e2, r2) {
        if (!e2.isConnected || !((t2) => {
          let o2 = t2;
          for (; o2 && o2.parentNode; ) {
            if (o2.parentNode === document)
              return true;
            o2 = o2.parentNode instanceof ShadowRoot ? o2.parentNode.host : o2.parentNode;
          }
          return false;
        })(e2))
          return;
        const n2 = ((t2) => {
          const o2 = window.getComputedStyle(t2);
          return { top: parseFloat(o2.scrollMarginTop) || 0, right: parseFloat(o2.scrollMarginRight) || 0, bottom: parseFloat(o2.scrollMarginBottom) || 0, left: parseFloat(o2.scrollMarginLeft) || 0 };
        })(e2);
        if (((t2) => "object" == typeof t2 && "function" == typeof t2.behavior)(r2))
          return r2.behavior(r$1(e2, r2));
        const l2 = "boolean" == typeof r2 || null == r2 ? void 0 : r2.behavior;
        for (const { el: a, top: i, left: s2 } of r$1(e2, o$1(r2))) {
          const t2 = i - n2.top + n2.bottom, o2 = s2 - n2.left + n2.right;
          a.scroll({ top: t2, left: o2, behavior: l2 });
        }
      }
      let o;
      const t = () => (o || (o = "performance" in window ? performance.now.bind(performance) : Date.now), o());
      function l(e2) {
        const o2 = t(), n2 = Math.min((o2 - e2.startTime) / e2.duration, 1), r2 = e2.ease(n2), s2 = e2.startX + (e2.x - e2.startX) * r2, i = e2.startY + (e2.y - e2.startY) * r2;
        e2.method(s2, i, n2, r2), s2 !== e2.x || i !== e2.y ? requestAnimationFrame(() => l(e2)) : e2.cb();
      }
      function n(e2, o2, n2) {
        let r2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 600, s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : (e3) => 1 + --e3 * e3 * e3 * e3 * e3, i = arguments.length > 5 ? arguments[5] : void 0, a = arguments.length > 6 ? arguments[6] : void 0;
        const c = e2, d = e2.scrollLeft, m = e2.scrollTop;
        l({ scrollable: c, method: (o3, t2, l2, n3) => {
          const r3 = Math.ceil(o3), s3 = Math.ceil(t2);
          e2.scrollLeft = r3, e2.scrollTop = s3, null == a || a({ target: e2, elapsed: l2, value: n3, left: r3, top: s3 });
        }, startTime: t(), startX: d, startY: m, x: o2, y: n2, duration: r2, ease: s2, cb: i });
      }
      const r = (e2) => e2 && !e2.behavior || "smooth" === e2.behavior;
      const s = function(o2, t2) {
        const l2 = t2 || {};
        return r(l2) ? e(o2, { block: l2.block, inline: l2.inline, scrollMode: l2.scrollMode, boundary: l2.boundary, skipOverflowHiddenElements: l2.skipOverflowHiddenElements, behavior: (e2) => Promise.all(e2.reduce((e3, o3) => {
          let { el: t3, left: r2, top: s2 } = o3;
          const i = t3.scrollLeft, a = t3.scrollTop;
          return i === r2 && a === s2 ? e3 : [...e3, new Promise((e4) => n(t3, r2, s2, l2.duration, l2.ease, () => e4({ el: t3, left: [i, r2], top: [a, s2] }), l2.onScrollChange))];
        }, [])) }) : Promise.resolve(e(o2, t2));
      };
      const _hoisted_1 = { class: "control-box" };
      const _sfc_main = {
        __name: "App",
        setup(__props) {
          const articleDialogVisible = ref(false);
          const handleOpen = async () => {
            if (await ensureToken()) {
              if (location.origin === "https://bbs.hupu.com") {
                const placeholderImgList = document.querySelector(".thread-content-detail").querySelectorAll(".placeholder-img");
                if (placeholderImgList.length) {
                  await s(
                    document.querySelector(".post-operate-comp-main-recommend"),
                    {
                      scrollMode: "if-needed",
                      block: "start"
                    }
                  );
                  await s(
                    document.querySelector(".post-operate-comp-main-recommend"),
                    {
                      scrollMode: "if-needed",
                      block: "start"
                    }
                  );
                }
              }
              articleDialogVisible.value = true;
            } else {
              ElMessageBox.confirm("请先去后台进行授权", "提示", {
                type: "warning"
              }).then(() => {
                _GM_setValue("getToken", true);
                window.open("https://186admin.nps.doveaz.xyz:1443");
              });
            }
          };
          return (_ctx, _cache) => {
            const _component_el_button = ElButton;
            const _component_el_config_provider = ElConfigProvider;
            return openBlock(), createBlock(_component_el_config_provider, { locale: unref(zhCn) }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_1, [
                  createVNode(_component_el_button, {
                    type: "primary",
                    onClick: handleOpen
                  }, {
                    default: withCtx(() => [
                      createTextVNode("转发")
                    ]),
                    _: 1
                  }),
                  unref(isDev) ? (openBlock(), createBlock(_component_el_button, {
                    key: 0,
                    type: "primary",
                    onClick: unref(removeToken)
                  }, {
                    default: withCtx(() => [
                      createTextVNode("clear token")
                    ]),
                    _: 1
                  }, 8, ["onClick"])) : createCommentVNode("", true),
                  unref(isDev) ? (openBlock(), createBlock(_component_el_button, {
                    key: 1,
                    type: "primary",
                    onClick: unref(ensureToken)
                  }, {
                    default: withCtx(() => [
                      createTextVNode("ensure token")
                    ]),
                    _: 1
                  }, 8, ["onClick"])) : createCommentVNode("", true)
                ]),
                createVNode(_sfc_main$1, {
                  visible: articleDialogVisible.value,
                  "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => articleDialogVisible.value = $event)
                }, null, 8, ["visible"])
              ]),
              _: 1
            }, 8, ["locale"]);
          };
        }
      };
      const getTokenKey = () => {
        for (let i = 0; i < localStorage.length; i++) {
          let key = localStorage.key(i);
          if (key.includes("COMMON__LOCAL__KEY__")) {
            return key;
          }
        }
      };
      var aes = { exports: {} };
      function commonjsRequire(path) {
        throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
      }
      var core = { exports: {} };
      const __viteBrowserExternal = {};
      const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        default: __viteBrowserExternal
      }, Symbol.toStringTag, { value: "Module" }));
      const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
      var hasRequiredCore;
      function requireCore() {
        if (hasRequiredCore)
          return core.exports;
        hasRequiredCore = 1;
        (function(module2, exports2) {
          (function(root2, factory) {
            {
              module2.exports = factory();
            }
          })(commonjsGlobal, function() {
            var CryptoJS = CryptoJS || function(Math2, undefined$1) {
              var crypto;
              if (typeof window !== "undefined" && window.crypto) {
                crypto = window.crypto;
              }
              if (typeof self !== "undefined" && self.crypto) {
                crypto = self.crypto;
              }
              if (typeof globalThis !== "undefined" && globalThis.crypto) {
                crypto = globalThis.crypto;
              }
              if (!crypto && typeof window !== "undefined" && window.msCrypto) {
                crypto = window.msCrypto;
              }
              if (!crypto && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
                crypto = commonjsGlobal.crypto;
              }
              if (!crypto && typeof commonjsRequire === "function") {
                try {
                  crypto = require$$0;
                } catch (err) {
                }
              }
              var cryptoSecureRandomInt = function() {
                if (crypto) {
                  if (typeof crypto.getRandomValues === "function") {
                    try {
                      return crypto.getRandomValues(new Uint32Array(1))[0];
                    } catch (err) {
                    }
                  }
                  if (typeof crypto.randomBytes === "function") {
                    try {
                      return crypto.randomBytes(4).readInt32LE();
                    } catch (err) {
                    }
                  }
                }
                throw new Error("Native crypto module could not be used to get secure random number.");
              };
              var create = Object.create || function() {
                function F() {
                }
                return function(obj) {
                  var subtype;
                  F.prototype = obj;
                  subtype = new F();
                  F.prototype = null;
                  return subtype;
                };
              }();
              var C2 = {};
              var C_lib = C2.lib = {};
              var Base = C_lib.Base = function() {
                return {
                  /**
                   * Creates a new object that inherits from this object.
                   *
                   * @param {Object} overrides Properties to copy into the new object.
                   *
                   * @return {Object} The new object.
                   *
                   * @static
                   *
                   * @example
                   *
                   *     var MyType = CryptoJS.lib.Base.extend({
                   *         field: 'value',
                   *
                   *         method: function () {
                   *         }
                   *     });
                   */
                  extend: function(overrides) {
                    var subtype = create(this);
                    if (overrides) {
                      subtype.mixIn(overrides);
                    }
                    if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                      subtype.init = function() {
                        subtype.$super.init.apply(this, arguments);
                      };
                    }
                    subtype.init.prototype = subtype;
                    subtype.$super = this;
                    return subtype;
                  },
                  /**
                   * Extends this object and runs the init method.
                   * Arguments to create() will be passed to init().
                   *
                   * @return {Object} The new object.
                   *
                   * @static
                   *
                   * @example
                   *
                   *     var instance = MyType.create();
                   */
                  create: function() {
                    var instance = this.extend();
                    instance.init.apply(instance, arguments);
                    return instance;
                  },
                  /**
                   * Initializes a newly created object.
                   * Override this method to add some logic when your objects are created.
                   *
                   * @example
                   *
                   *     var MyType = CryptoJS.lib.Base.extend({
                   *         init: function () {
                   *             // ...
                   *         }
                   *     });
                   */
                  init: function() {
                  },
                  /**
                   * Copies properties into this object.
                   *
                   * @param {Object} properties The properties to mix in.
                   *
                   * @example
                   *
                   *     MyType.mixIn({
                   *         field: 'value'
                   *     });
                   */
                  mixIn: function(properties) {
                    for (var propertyName in properties) {
                      if (properties.hasOwnProperty(propertyName)) {
                        this[propertyName] = properties[propertyName];
                      }
                    }
                    if (properties.hasOwnProperty("toString")) {
                      this.toString = properties.toString;
                    }
                  },
                  /**
                   * Creates a copy of this object.
                   *
                   * @return {Object} The clone.
                   *
                   * @example
                   *
                   *     var clone = instance.clone();
                   */
                  clone: function() {
                    return this.init.prototype.extend(this);
                  }
                };
              }();
              var WordArray = C_lib.WordArray = Base.extend({
                /**
                 * Initializes a newly created word array.
                 *
                 * @param {Array} words (Optional) An array of 32-bit words.
                 * @param {number} sigBytes (Optional) The number of significant bytes in the words.
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.lib.WordArray.create();
                 *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
                 *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
                 */
                init: function(words, sigBytes) {
                  words = this.words = words || [];
                  if (sigBytes != undefined$1) {
                    this.sigBytes = sigBytes;
                  } else {
                    this.sigBytes = words.length * 4;
                  }
                },
                /**
                 * Converts this word array to a string.
                 *
                 * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
                 *
                 * @return {string} The stringified word array.
                 *
                 * @example
                 *
                 *     var string = wordArray + '';
                 *     var string = wordArray.toString();
                 *     var string = wordArray.toString(CryptoJS.enc.Utf8);
                 */
                toString: function(encoder) {
                  return (encoder || Hex).stringify(this);
                },
                /**
                 * Concatenates a word array to this word array.
                 *
                 * @param {WordArray} wordArray The word array to append.
                 *
                 * @return {WordArray} This word array.
                 *
                 * @example
                 *
                 *     wordArray1.concat(wordArray2);
                 */
                concat: function(wordArray) {
                  var thisWords = this.words;
                  var thatWords = wordArray.words;
                  var thisSigBytes = this.sigBytes;
                  var thatSigBytes = wordArray.sigBytes;
                  this.clamp();
                  if (thisSigBytes % 4) {
                    for (var i = 0; i < thatSigBytes; i++) {
                      var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                      thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
                    }
                  } else {
                    for (var j = 0; j < thatSigBytes; j += 4) {
                      thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
                    }
                  }
                  this.sigBytes += thatSigBytes;
                  return this;
                },
                /**
                 * Removes insignificant bits.
                 *
                 * @example
                 *
                 *     wordArray.clamp();
                 */
                clamp: function() {
                  var words = this.words;
                  var sigBytes = this.sigBytes;
                  words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
                  words.length = Math2.ceil(sigBytes / 4);
                },
                /**
                 * Creates a copy of this word array.
                 *
                 * @return {WordArray} The clone.
                 *
                 * @example
                 *
                 *     var clone = wordArray.clone();
                 */
                clone: function() {
                  var clone = Base.clone.call(this);
                  clone.words = this.words.slice(0);
                  return clone;
                },
                /**
                 * Creates a word array filled with random bytes.
                 *
                 * @param {number} nBytes The number of random bytes to generate.
                 *
                 * @return {WordArray} The random word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.lib.WordArray.random(16);
                 */
                random: function(nBytes) {
                  var words = [];
                  for (var i = 0; i < nBytes; i += 4) {
                    words.push(cryptoSecureRandomInt());
                  }
                  return new WordArray.init(words, nBytes);
                }
              });
              var C_enc = C2.enc = {};
              var Hex = C_enc.Hex = {
                /**
                 * Converts a word array to a hex string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The hex string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
                 */
                stringify: function(wordArray) {
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
                  var hexChars = [];
                  for (var i = 0; i < sigBytes; i++) {
                    var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                    hexChars.push((bite >>> 4).toString(16));
                    hexChars.push((bite & 15).toString(16));
                  }
                  return hexChars.join("");
                },
                /**
                 * Converts a hex string to a word array.
                 *
                 * @param {string} hexStr The hex string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
                 */
                parse: function(hexStr) {
                  var hexStrLength = hexStr.length;
                  var words = [];
                  for (var i = 0; i < hexStrLength; i += 2) {
                    words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
                  }
                  return new WordArray.init(words, hexStrLength / 2);
                }
              };
              var Latin1 = C_enc.Latin1 = {
                /**
                 * Converts a word array to a Latin1 string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The Latin1 string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
                 */
                stringify: function(wordArray) {
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
                  var latin1Chars = [];
                  for (var i = 0; i < sigBytes; i++) {
                    var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                    latin1Chars.push(String.fromCharCode(bite));
                  }
                  return latin1Chars.join("");
                },
                /**
                 * Converts a Latin1 string to a word array.
                 *
                 * @param {string} latin1Str The Latin1 string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
                 */
                parse: function(latin1Str) {
                  var latin1StrLength = latin1Str.length;
                  var words = [];
                  for (var i = 0; i < latin1StrLength; i++) {
                    words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
                  }
                  return new WordArray.init(words, latin1StrLength);
                }
              };
              var Utf8 = C_enc.Utf8 = {
                /**
                 * Converts a word array to a UTF-8 string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The UTF-8 string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
                 */
                stringify: function(wordArray) {
                  try {
                    return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                  } catch (e2) {
                    throw new Error("Malformed UTF-8 data");
                  }
                },
                /**
                 * Converts a UTF-8 string to a word array.
                 *
                 * @param {string} utf8Str The UTF-8 string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
                 */
                parse: function(utf8Str) {
                  return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
                }
              };
              var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
                /**
                 * Resets this block algorithm's data buffer to its initial state.
                 *
                 * @example
                 *
                 *     bufferedBlockAlgorithm.reset();
                 */
                reset: function() {
                  this._data = new WordArray.init();
                  this._nDataBytes = 0;
                },
                /**
                 * Adds new data to this block algorithm's buffer.
                 *
                 * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
                 *
                 * @example
                 *
                 *     bufferedBlockAlgorithm._append('data');
                 *     bufferedBlockAlgorithm._append(wordArray);
                 */
                _append: function(data) {
                  if (typeof data == "string") {
                    data = Utf8.parse(data);
                  }
                  this._data.concat(data);
                  this._nDataBytes += data.sigBytes;
                },
                /**
                 * Processes available data blocks.
                 *
                 * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
                 *
                 * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
                 *
                 * @return {WordArray} The processed data.
                 *
                 * @example
                 *
                 *     var processedData = bufferedBlockAlgorithm._process();
                 *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
                 */
                _process: function(doFlush) {
                  var processedWords;
                  var data = this._data;
                  var dataWords = data.words;
                  var dataSigBytes = data.sigBytes;
                  var blockSize = this.blockSize;
                  var blockSizeBytes = blockSize * 4;
                  var nBlocksReady = dataSigBytes / blockSizeBytes;
                  if (doFlush) {
                    nBlocksReady = Math2.ceil(nBlocksReady);
                  } else {
                    nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
                  }
                  var nWordsReady = nBlocksReady * blockSize;
                  var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
                  if (nWordsReady) {
                    for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                      this._doProcessBlock(dataWords, offset);
                    }
                    processedWords = dataWords.splice(0, nWordsReady);
                    data.sigBytes -= nBytesReady;
                  }
                  return new WordArray.init(processedWords, nBytesReady);
                },
                /**
                 * Creates a copy of this object.
                 *
                 * @return {Object} The clone.
                 *
                 * @example
                 *
                 *     var clone = bufferedBlockAlgorithm.clone();
                 */
                clone: function() {
                  var clone = Base.clone.call(this);
                  clone._data = this._data.clone();
                  return clone;
                },
                _minBufferSize: 0
              });
              C_lib.Hasher = BufferedBlockAlgorithm.extend({
                /**
                 * Configuration options.
                 */
                cfg: Base.extend(),
                /**
                 * Initializes a newly created hasher.
                 *
                 * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
                 *
                 * @example
                 *
                 *     var hasher = CryptoJS.algo.SHA256.create();
                 */
                init: function(cfg) {
                  this.cfg = this.cfg.extend(cfg);
                  this.reset();
                },
                /**
                 * Resets this hasher to its initial state.
                 *
                 * @example
                 *
                 *     hasher.reset();
                 */
                reset: function() {
                  BufferedBlockAlgorithm.reset.call(this);
                  this._doReset();
                },
                /**
                 * Updates this hasher with a message.
                 *
                 * @param {WordArray|string} messageUpdate The message to append.
                 *
                 * @return {Hasher} This hasher.
                 *
                 * @example
                 *
                 *     hasher.update('message');
                 *     hasher.update(wordArray);
                 */
                update: function(messageUpdate) {
                  this._append(messageUpdate);
                  this._process();
                  return this;
                },
                /**
                 * Finalizes the hash computation.
                 * Note that the finalize operation is effectively a destructive, read-once operation.
                 *
                 * @param {WordArray|string} messageUpdate (Optional) A final message update.
                 *
                 * @return {WordArray} The hash.
                 *
                 * @example
                 *
                 *     var hash = hasher.finalize();
                 *     var hash = hasher.finalize('message');
                 *     var hash = hasher.finalize(wordArray);
                 */
                finalize: function(messageUpdate) {
                  if (messageUpdate) {
                    this._append(messageUpdate);
                  }
                  var hash = this._doFinalize();
                  return hash;
                },
                blockSize: 512 / 32,
                /**
                 * Creates a shortcut function to a hasher's object interface.
                 *
                 * @param {Hasher} hasher The hasher to create a helper for.
                 *
                 * @return {Function} The shortcut function.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
                 */
                _createHelper: function(hasher) {
                  return function(message, cfg) {
                    return new hasher.init(cfg).finalize(message);
                  };
                },
                /**
                 * Creates a shortcut function to the HMAC's object interface.
                 *
                 * @param {Hasher} hasher The hasher to use in this HMAC helper.
                 *
                 * @return {Function} The shortcut function.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
                 */
                _createHmacHelper: function(hasher) {
                  return function(message, key) {
                    return new C_algo.HMAC.init(hasher, key).finalize(message);
                  };
                }
              });
              var C_algo = C2.algo = {};
              return C2;
            }(Math);
            return CryptoJS;
          });
        })(core);
        return core.exports;
      }
      var encBase64 = { exports: {} };
      var hasRequiredEncBase64;
      function requireEncBase64() {
        if (hasRequiredEncBase64)
          return encBase64.exports;
        hasRequiredEncBase64 = 1;
        (function(module2, exports2) {
          (function(root2, factory) {
            {
              module2.exports = factory(requireCore());
            }
          })(commonjsGlobal, function(CryptoJS) {
            (function() {
              var C2 = CryptoJS;
              var C_lib = C2.lib;
              var WordArray = C_lib.WordArray;
              var C_enc = C2.enc;
              C_enc.Base64 = {
                /**
                 * Converts a word array to a Base64 string.
                 *
                 * @param {WordArray} wordArray The word array.
                 *
                 * @return {string} The Base64 string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
                 */
                stringify: function(wordArray) {
                  var words = wordArray.words;
                  var sigBytes = wordArray.sigBytes;
                  var map = this._map;
                  wordArray.clamp();
                  var base64Chars = [];
                  for (var i = 0; i < sigBytes; i += 3) {
                    var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                    var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
                    var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
                    var triplet = byte1 << 16 | byte2 << 8 | byte3;
                    for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                      base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
                    }
                  }
                  var paddingChar = map.charAt(64);
                  if (paddingChar) {
                    while (base64Chars.length % 4) {
                      base64Chars.push(paddingChar);
                    }
                  }
                  return base64Chars.join("");
                },
                /**
                 * Converts a Base64 string to a word array.
                 *
                 * @param {string} base64Str The Base64 string.
                 *
                 * @return {WordArray} The word array.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
                 */
                parse: function(base64Str) {
                  var base64StrLength = base64Str.length;
                  var map = this._map;
                  var reverseMap = this._reverseMap;
                  if (!reverseMap) {
                    reverseMap = this._reverseMap = [];
                    for (var j = 0; j < map.length; j++) {
                      reverseMap[map.charCodeAt(j)] = j;
                    }
                  }
                  var paddingChar = map.charAt(64);
                  if (paddingChar) {
                    var paddingIndex = base64Str.indexOf(paddingChar);
                    if (paddingIndex !== -1) {
                      base64StrLength = paddingIndex;
                    }
                  }
                  return parseLoop(base64Str, base64StrLength, reverseMap);
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
              };
              function parseLoop(base64Str, base64StrLength, reverseMap) {
                var words = [];
                var nBytes = 0;
                for (var i = 0; i < base64StrLength; i++) {
                  if (i % 4) {
                    var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
                    var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
                    var bitsCombined = bits1 | bits2;
                    words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                    nBytes++;
                  }
                }
                return WordArray.create(words, nBytes);
              }
            })();
            return CryptoJS.enc.Base64;
          });
        })(encBase64);
        return encBase64.exports;
      }
      var md5 = { exports: {} };
      var hasRequiredMd5;
      function requireMd5() {
        if (hasRequiredMd5)
          return md5.exports;
        hasRequiredMd5 = 1;
        (function(module2, exports2) {
          (function(root2, factory) {
            {
              module2.exports = factory(requireCore());
            }
          })(commonjsGlobal, function(CryptoJS) {
            (function(Math2) {
              var C2 = CryptoJS;
              var C_lib = C2.lib;
              var WordArray = C_lib.WordArray;
              var Hasher = C_lib.Hasher;
              var C_algo = C2.algo;
              var T = [];
              (function() {
                for (var i = 0; i < 64; i++) {
                  T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
                }
              })();
              var MD5 = C_algo.MD5 = Hasher.extend({
                _doReset: function() {
                  this._hash = new WordArray.init([
                    1732584193,
                    4023233417,
                    2562383102,
                    271733878
                  ]);
                },
                _doProcessBlock: function(M, offset) {
                  for (var i = 0; i < 16; i++) {
                    var offset_i = offset + i;
                    var M_offset_i = M[offset_i];
                    M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
                  }
                  var H2 = this._hash.words;
                  var M_offset_0 = M[offset + 0];
                  var M_offset_1 = M[offset + 1];
                  var M_offset_2 = M[offset + 2];
                  var M_offset_3 = M[offset + 3];
                  var M_offset_4 = M[offset + 4];
                  var M_offset_5 = M[offset + 5];
                  var M_offset_6 = M[offset + 6];
                  var M_offset_7 = M[offset + 7];
                  var M_offset_8 = M[offset + 8];
                  var M_offset_9 = M[offset + 9];
                  var M_offset_10 = M[offset + 10];
                  var M_offset_11 = M[offset + 11];
                  var M_offset_12 = M[offset + 12];
                  var M_offset_13 = M[offset + 13];
                  var M_offset_14 = M[offset + 14];
                  var M_offset_15 = M[offset + 15];
                  var a = H2[0];
                  var b = H2[1];
                  var c = H2[2];
                  var d = H2[3];
                  a = FF(a, b, c, d, M_offset_0, 7, T[0]);
                  d = FF(d, a, b, c, M_offset_1, 12, T[1]);
                  c = FF(c, d, a, b, M_offset_2, 17, T[2]);
                  b = FF(b, c, d, a, M_offset_3, 22, T[3]);
                  a = FF(a, b, c, d, M_offset_4, 7, T[4]);
                  d = FF(d, a, b, c, M_offset_5, 12, T[5]);
                  c = FF(c, d, a, b, M_offset_6, 17, T[6]);
                  b = FF(b, c, d, a, M_offset_7, 22, T[7]);
                  a = FF(a, b, c, d, M_offset_8, 7, T[8]);
                  d = FF(d, a, b, c, M_offset_9, 12, T[9]);
                  c = FF(c, d, a, b, M_offset_10, 17, T[10]);
                  b = FF(b, c, d, a, M_offset_11, 22, T[11]);
                  a = FF(a, b, c, d, M_offset_12, 7, T[12]);
                  d = FF(d, a, b, c, M_offset_13, 12, T[13]);
                  c = FF(c, d, a, b, M_offset_14, 17, T[14]);
                  b = FF(b, c, d, a, M_offset_15, 22, T[15]);
                  a = GG(a, b, c, d, M_offset_1, 5, T[16]);
                  d = GG(d, a, b, c, M_offset_6, 9, T[17]);
                  c = GG(c, d, a, b, M_offset_11, 14, T[18]);
                  b = GG(b, c, d, a, M_offset_0, 20, T[19]);
                  a = GG(a, b, c, d, M_offset_5, 5, T[20]);
                  d = GG(d, a, b, c, M_offset_10, 9, T[21]);
                  c = GG(c, d, a, b, M_offset_15, 14, T[22]);
                  b = GG(b, c, d, a, M_offset_4, 20, T[23]);
                  a = GG(a, b, c, d, M_offset_9, 5, T[24]);
                  d = GG(d, a, b, c, M_offset_14, 9, T[25]);
                  c = GG(c, d, a, b, M_offset_3, 14, T[26]);
                  b = GG(b, c, d, a, M_offset_8, 20, T[27]);
                  a = GG(a, b, c, d, M_offset_13, 5, T[28]);
                  d = GG(d, a, b, c, M_offset_2, 9, T[29]);
                  c = GG(c, d, a, b, M_offset_7, 14, T[30]);
                  b = GG(b, c, d, a, M_offset_12, 20, T[31]);
                  a = HH(a, b, c, d, M_offset_5, 4, T[32]);
                  d = HH(d, a, b, c, M_offset_8, 11, T[33]);
                  c = HH(c, d, a, b, M_offset_11, 16, T[34]);
                  b = HH(b, c, d, a, M_offset_14, 23, T[35]);
                  a = HH(a, b, c, d, M_offset_1, 4, T[36]);
                  d = HH(d, a, b, c, M_offset_4, 11, T[37]);
                  c = HH(c, d, a, b, M_offset_7, 16, T[38]);
                  b = HH(b, c, d, a, M_offset_10, 23, T[39]);
                  a = HH(a, b, c, d, M_offset_13, 4, T[40]);
                  d = HH(d, a, b, c, M_offset_0, 11, T[41]);
                  c = HH(c, d, a, b, M_offset_3, 16, T[42]);
                  b = HH(b, c, d, a, M_offset_6, 23, T[43]);
                  a = HH(a, b, c, d, M_offset_9, 4, T[44]);
                  d = HH(d, a, b, c, M_offset_12, 11, T[45]);
                  c = HH(c, d, a, b, M_offset_15, 16, T[46]);
                  b = HH(b, c, d, a, M_offset_2, 23, T[47]);
                  a = II(a, b, c, d, M_offset_0, 6, T[48]);
                  d = II(d, a, b, c, M_offset_7, 10, T[49]);
                  c = II(c, d, a, b, M_offset_14, 15, T[50]);
                  b = II(b, c, d, a, M_offset_5, 21, T[51]);
                  a = II(a, b, c, d, M_offset_12, 6, T[52]);
                  d = II(d, a, b, c, M_offset_3, 10, T[53]);
                  c = II(c, d, a, b, M_offset_10, 15, T[54]);
                  b = II(b, c, d, a, M_offset_1, 21, T[55]);
                  a = II(a, b, c, d, M_offset_8, 6, T[56]);
                  d = II(d, a, b, c, M_offset_15, 10, T[57]);
                  c = II(c, d, a, b, M_offset_6, 15, T[58]);
                  b = II(b, c, d, a, M_offset_13, 21, T[59]);
                  a = II(a, b, c, d, M_offset_4, 6, T[60]);
                  d = II(d, a, b, c, M_offset_11, 10, T[61]);
                  c = II(c, d, a, b, M_offset_2, 15, T[62]);
                  b = II(b, c, d, a, M_offset_9, 21, T[63]);
                  H2[0] = H2[0] + a | 0;
                  H2[1] = H2[1] + b | 0;
                  H2[2] = H2[2] + c | 0;
                  H2[3] = H2[3] + d | 0;
                },
                _doFinalize: function() {
                  var data = this._data;
                  var dataWords = data.words;
                  var nBitsTotal = this._nDataBytes * 8;
                  var nBitsLeft = data.sigBytes * 8;
                  dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                  var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
                  var nBitsTotalL = nBitsTotal;
                  dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
                  dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
                  data.sigBytes = (dataWords.length + 1) * 4;
                  this._process();
                  var hash = this._hash;
                  var H2 = hash.words;
                  for (var i = 0; i < 4; i++) {
                    var H_i = H2[i];
                    H2[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
                  }
                  return hash;
                },
                clone: function() {
                  var clone = Hasher.clone.call(this);
                  clone._hash = this._hash.clone();
                  return clone;
                }
              });
              function FF(a, b, c, d, x, s2, t2) {
                var n2 = a + (b & c | ~b & d) + x + t2;
                return (n2 << s2 | n2 >>> 32 - s2) + b;
              }
              function GG(a, b, c, d, x, s2, t2) {
                var n2 = a + (b & d | c & ~d) + x + t2;
                return (n2 << s2 | n2 >>> 32 - s2) + b;
              }
              function HH(a, b, c, d, x, s2, t2) {
                var n2 = a + (b ^ c ^ d) + x + t2;
                return (n2 << s2 | n2 >>> 32 - s2) + b;
              }
              function II(a, b, c, d, x, s2, t2) {
                var n2 = a + (c ^ (b | ~d)) + x + t2;
                return (n2 << s2 | n2 >>> 32 - s2) + b;
              }
              C2.MD5 = Hasher._createHelper(MD5);
              C2.HmacMD5 = Hasher._createHmacHelper(MD5);
            })(Math);
            return CryptoJS.MD5;
          });
        })(md5);
        return md5.exports;
      }
      var evpkdf = { exports: {} };
      var sha1 = { exports: {} };
      var hasRequiredSha1;
      function requireSha1() {
        if (hasRequiredSha1)
          return sha1.exports;
        hasRequiredSha1 = 1;
        (function(module2, exports2) {
          (function(root2, factory) {
            {
              module2.exports = factory(requireCore());
            }
          })(commonjsGlobal, function(CryptoJS) {
            (function() {
              var C2 = CryptoJS;
              var C_lib = C2.lib;
              var WordArray = C_lib.WordArray;
              var Hasher = C_lib.Hasher;
              var C_algo = C2.algo;
              var W2 = [];
              var SHA1 = C_algo.SHA1 = Hasher.extend({
                _doReset: function() {
                  this._hash = new WordArray.init([
                    1732584193,
                    4023233417,
                    2562383102,
                    271733878,
                    3285377520
                  ]);
                },
                _doProcessBlock: function(M, offset) {
                  var H2 = this._hash.words;
                  var a = H2[0];
                  var b = H2[1];
                  var c = H2[2];
                  var d = H2[3];
                  var e2 = H2[4];
                  for (var i = 0; i < 80; i++) {
                    if (i < 16) {
                      W2[i] = M[offset + i] | 0;
                    } else {
                      var n2 = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
                      W2[i] = n2 << 1 | n2 >>> 31;
                    }
                    var t2 = (a << 5 | a >>> 27) + e2 + W2[i];
                    if (i < 20) {
                      t2 += (b & c | ~b & d) + 1518500249;
                    } else if (i < 40) {
                      t2 += (b ^ c ^ d) + 1859775393;
                    } else if (i < 60) {
                      t2 += (b & c | b & d | c & d) - 1894007588;
                    } else {
                      t2 += (b ^ c ^ d) - 899497514;
                    }
                    e2 = d;
                    d = c;
                    c = b << 30 | b >>> 2;
                    b = a;
                    a = t2;
                  }
                  H2[0] = H2[0] + a | 0;
                  H2[1] = H2[1] + b | 0;
                  H2[2] = H2[2] + c | 0;
                  H2[3] = H2[3] + d | 0;
                  H2[4] = H2[4] + e2 | 0;
                },
                _doFinalize: function() {
                  var data = this._data;
                  var dataWords = data.words;
                  var nBitsTotal = this._nDataBytes * 8;
                  var nBitsLeft = data.sigBytes * 8;
                  dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                  dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
                  dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                  data.sigBytes = dataWords.length * 4;
                  this._process();
                  return this._hash;
                },
                clone: function() {
                  var clone = Hasher.clone.call(this);
                  clone._hash = this._hash.clone();
                  return clone;
                }
              });
              C2.SHA1 = Hasher._createHelper(SHA1);
              C2.HmacSHA1 = Hasher._createHmacHelper(SHA1);
            })();
            return CryptoJS.SHA1;
          });
        })(sha1);
        return sha1.exports;
      }
      var hmac = { exports: {} };
      var hasRequiredHmac;
      function requireHmac() {
        if (hasRequiredHmac)
          return hmac.exports;
        hasRequiredHmac = 1;
        (function(module2, exports2) {
          (function(root2, factory) {
            {
              module2.exports = factory(requireCore());
            }
          })(commonjsGlobal, function(CryptoJS) {
            (function() {
              var C2 = CryptoJS;
              var C_lib = C2.lib;
              var Base = C_lib.Base;
              var C_enc = C2.enc;
              var Utf8 = C_enc.Utf8;
              var C_algo = C2.algo;
              C_algo.HMAC = Base.extend({
                /**
                 * Initializes a newly created HMAC.
                 *
                 * @param {Hasher} hasher The hash algorithm to use.
                 * @param {WordArray|string} key The secret key.
                 *
                 * @example
                 *
                 *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
                 */
                init: function(hasher, key) {
                  hasher = this._hasher = new hasher.init();
                  if (typeof key == "string") {
                    key = Utf8.parse(key);
                  }
                  var hasherBlockSize = hasher.blockSize;
                  var hasherBlockSizeBytes = hasherBlockSize * 4;
                  if (key.sigBytes > hasherBlockSizeBytes) {
                    key = hasher.finalize(key);
                  }
                  key.clamp();
                  var oKey = this._oKey = key.clone();
                  var iKey = this._iKey = key.clone();
                  var oKeyWords = oKey.words;
                  var iKeyWords = iKey.words;
                  for (var i = 0; i < hasherBlockSize; i++) {
                    oKeyWords[i] ^= 1549556828;
                    iKeyWords[i] ^= 909522486;
                  }
                  oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
                  this.reset();
                },
                /**
                 * Resets this HMAC to its initial state.
                 *
                 * @example
                 *
                 *     hmacHasher.reset();
                 */
                reset: function() {
                  var hasher = this._hasher;
                  hasher.reset();
                  hasher.update(this._iKey);
                },
                /**
                 * Updates this HMAC with a message.
                 *
                 * @param {WordArray|string} messageUpdate The message to append.
                 *
                 * @return {HMAC} This HMAC instance.
                 *
                 * @example
                 *
                 *     hmacHasher.update('message');
                 *     hmacHasher.update(wordArray);
                 */
                update: function(messageUpdate) {
                  this._hasher.update(messageUpdate);
                  return this;
                },
                /**
                 * Finalizes the HMAC computation.
                 * Note that the finalize operation is effectively a destructive, read-once operation.
                 *
                 * @param {WordArray|string} messageUpdate (Optional) A final message update.
                 *
                 * @return {WordArray} The HMAC.
                 *
                 * @example
                 *
                 *     var hmac = hmacHasher.finalize();
                 *     var hmac = hmacHasher.finalize('message');
                 *     var hmac = hmacHasher.finalize(wordArray);
                 */
                finalize: function(messageUpdate) {
                  var hasher = this._hasher;
                  var innerHash = hasher.finalize(messageUpdate);
                  hasher.reset();
                  var hmac2 = hasher.finalize(this._oKey.clone().concat(innerHash));
                  return hmac2;
                }
              });
            })();
          });
        })(hmac);
        return hmac.exports;
      }
      var hasRequiredEvpkdf;
      function requireEvpkdf() {
        if (hasRequiredEvpkdf)
          return evpkdf.exports;
        hasRequiredEvpkdf = 1;
        (function(module2, exports2) {
          (function(root2, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireSha1(), requireHmac());
            }
          })(commonjsGlobal, function(CryptoJS) {
            (function() {
              var C2 = CryptoJS;
              var C_lib = C2.lib;
              var Base = C_lib.Base;
              var WordArray = C_lib.WordArray;
              var C_algo = C2.algo;
              var MD5 = C_algo.MD5;
              var EvpKDF = C_algo.EvpKDF = Base.extend({
                /**
                 * Configuration options.
                 *
                 * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
                 * @property {Hasher} hasher The hash algorithm to use. Default: MD5
                 * @property {number} iterations The number of iterations to perform. Default: 1
                 */
                cfg: Base.extend({
                  keySize: 128 / 32,
                  hasher: MD5,
                  iterations: 1
                }),
                /**
                 * Initializes a newly created key derivation function.
                 *
                 * @param {Object} cfg (Optional) The configuration options to use for the derivation.
                 *
                 * @example
                 *
                 *     var kdf = CryptoJS.algo.EvpKDF.create();
                 *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
                 *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
                 */
                init: function(cfg) {
                  this.cfg = this.cfg.extend(cfg);
                },
                /**
                 * Derives a key from a password.
                 *
                 * @param {WordArray|string} password The password.
                 * @param {WordArray|string} salt A salt.
                 *
                 * @return {WordArray} The derived key.
                 *
                 * @example
                 *
                 *     var key = kdf.compute(password, salt);
                 */
                compute: function(password, salt) {
                  var block;
                  var cfg = this.cfg;
                  var hasher = cfg.hasher.create();
                  var derivedKey = WordArray.create();
                  var derivedKeyWords = derivedKey.words;
                  var keySize = cfg.keySize;
                  var iterations = cfg.iterations;
                  while (derivedKeyWords.length < keySize) {
                    if (block) {
                      hasher.update(block);
                    }
                    block = hasher.update(password).finalize(salt);
                    hasher.reset();
                    for (var i = 1; i < iterations; i++) {
                      block = hasher.finalize(block);
                      hasher.reset();
                    }
                    derivedKey.concat(block);
                  }
                  derivedKey.sigBytes = keySize * 4;
                  return derivedKey;
                }
              });
              C2.EvpKDF = function(password, salt, cfg) {
                return EvpKDF.create(cfg).compute(password, salt);
              };
            })();
            return CryptoJS.EvpKDF;
          });
        })(evpkdf);
        return evpkdf.exports;
      }
      var cipherCore = { exports: {} };
      var hasRequiredCipherCore;
      function requireCipherCore() {
        if (hasRequiredCipherCore)
          return cipherCore.exports;
        hasRequiredCipherCore = 1;
        (function(module2, exports2) {
          (function(root2, factory, undef) {
            {
              module2.exports = factory(requireCore(), requireEvpkdf());
            }
          })(commonjsGlobal, function(CryptoJS) {
            CryptoJS.lib.Cipher || function(undefined$1) {
              var C2 = CryptoJS;
              var C_lib = C2.lib;
              var Base = C_lib.Base;
              var WordArray = C_lib.WordArray;
              var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
              var C_enc = C2.enc;
              C_enc.Utf8;
              var Base64 = C_enc.Base64;
              var C_algo = C2.algo;
              var EvpKDF = C_algo.EvpKDF;
              var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
                /**
                 * Configuration options.
                 *
                 * @property {WordArray} iv The IV to use for this operation.
                 */
                cfg: Base.extend(),
                /**
                 * Creates this cipher in encryption mode.
                 *
                 * @param {WordArray} key The key.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {Cipher} A cipher instance.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
                 */
                createEncryptor: function(key, cfg) {
                  return this.create(this._ENC_XFORM_MODE, key, cfg);
                },
                /**
                 * Creates this cipher in decryption mode.
                 *
                 * @param {WordArray} key The key.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {Cipher} A cipher instance.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
                 */
                createDecryptor: function(key, cfg) {
                  return this.create(this._DEC_XFORM_MODE, key, cfg);
                },
                /**
                 * Initializes a newly created cipher.
                 *
                 * @param {number} xformMode Either the encryption or decryption transormation mode constant.
                 * @param {WordArray} key The key.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @example
                 *
                 *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
                 */
                init: function(xformMode, key, cfg) {
                  this.cfg = this.cfg.extend(cfg);
                  this._xformMode = xformMode;
                  this._key = key;
                  this.reset();
                },
                /**
                 * Resets this cipher to its initial state.
                 *
                 * @example
                 *
                 *     cipher.reset();
                 */
                reset: function() {
                  BufferedBlockAlgorithm.reset.call(this);
                  this._doReset();
                },
                /**
                 * Adds data to be encrypted or decrypted.
                 *
                 * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
                 *
                 * @return {WordArray} The data after processing.
                 *
                 * @example
                 *
                 *     var encrypted = cipher.process('data');
                 *     var encrypted = cipher.process(wordArray);
                 */
                process: function(dataUpdate) {
                  this._append(dataUpdate);
                  return this._process();
                },
                /**
                 * Finalizes the encryption or decryption process.
                 * Note that the finalize operation is effectively a destructive, read-once operation.
                 *
                 * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
                 *
                 * @return {WordArray} The data after final processing.
                 *
                 * @example
                 *
                 *     var encrypted = cipher.finalize();
                 *     var encrypted = cipher.finalize('data');
                 *     var encrypted = cipher.finalize(wordArray);
                 */
                finalize: function(dataUpdate) {
                  if (dataUpdate) {
                    this._append(dataUpdate);
                  }
                  var finalProcessedData = this._doFinalize();
                  return finalProcessedData;
                },
                keySize: 128 / 32,
                ivSize: 128 / 32,
                _ENC_XFORM_MODE: 1,
                _DEC_XFORM_MODE: 2,
                /**
                 * Creates shortcut functions to a cipher's object interface.
                 *
                 * @param {Cipher} cipher The cipher to create a helper for.
                 *
                 * @return {Object} An object with encrypt and decrypt shortcut functions.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
                 */
                _createHelper: function() {
                  function selectCipherStrategy(key) {
                    if (typeof key == "string") {
                      return PasswordBasedCipher;
                    } else {
                      return SerializableCipher;
                    }
                  }
                  return function(cipher) {
                    return {
                      encrypt: function(message, key, cfg) {
                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                      },
                      decrypt: function(ciphertext, key, cfg) {
                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                      }
                    };
                  };
                }()
              });
              C_lib.StreamCipher = Cipher.extend({
                _doFinalize: function() {
                  var finalProcessedBlocks = this._process(true);
                  return finalProcessedBlocks;
                },
                blockSize: 1
              });
              var C_mode = C2.mode = {};
              var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
                /**
                 * Creates this mode for encryption.
                 *
                 * @param {Cipher} cipher A block cipher instance.
                 * @param {Array} iv The IV words.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
                 */
                createEncryptor: function(cipher, iv) {
                  return this.Encryptor.create(cipher, iv);
                },
                /**
                 * Creates this mode for decryption.
                 *
                 * @param {Cipher} cipher A block cipher instance.
                 * @param {Array} iv The IV words.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
                 */
                createDecryptor: function(cipher, iv) {
                  return this.Decryptor.create(cipher, iv);
                },
                /**
                 * Initializes a newly created mode.
                 *
                 * @param {Cipher} cipher A block cipher instance.
                 * @param {Array} iv The IV words.
                 *
                 * @example
                 *
                 *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
                 */
                init: function(cipher, iv) {
                  this._cipher = cipher;
                  this._iv = iv;
                }
              });
              var CBC = C_mode.CBC = function() {
                var CBC2 = BlockCipherMode.extend();
                CBC2.Encryptor = CBC2.extend({
                  /**
                   * Processes the data block at offset.
                   *
                   * @param {Array} words The data words to operate on.
                   * @param {number} offset The offset where the block starts.
                   *
                   * @example
                   *
                   *     mode.processBlock(data.words, offset);
                   */
                  processBlock: function(words, offset) {
                    var cipher = this._cipher;
                    var blockSize = cipher.blockSize;
                    xorBlock.call(this, words, offset, blockSize);
                    cipher.encryptBlock(words, offset);
                    this._prevBlock = words.slice(offset, offset + blockSize);
                  }
                });
                CBC2.Decryptor = CBC2.extend({
                  /**
                   * Processes the data block at offset.
                   *
                   * @param {Array} words The data words to operate on.
                   * @param {number} offset The offset where the block starts.
                   *
                   * @example
                   *
                   *     mode.processBlock(data.words, offset);
                   */
                  processBlock: function(words, offset) {
                    var cipher = this._cipher;
                    var blockSize = cipher.blockSize;
                    var thisBlock = words.slice(offset, offset + blockSize);
                    cipher.decryptBlock(words, offset);
                    xorBlock.call(this, words, offset, blockSize);
                    this._prevBlock = thisBlock;
                  }
                });
                function xorBlock(words, offset, blockSize) {
                  var block;
                  var iv = this._iv;
                  if (iv) {
                    block = iv;
                    this._iv = undefined$1;
                  } else {
                    block = this._prevBlock;
                  }
                  for (var i = 0; i < blockSize; i++) {
                    words[offset + i] ^= block[i];
                  }
                }
                return CBC2;
              }();
              var C_pad = C2.pad = {};
              var Pkcs7 = C_pad.Pkcs7 = {
                /**
                 * Pads data using the algorithm defined in PKCS #5/7.
                 *
                 * @param {WordArray} data The data to pad.
                 * @param {number} blockSize The multiple that the data should be padded to.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
                 */
                pad: function(data, blockSize) {
                  var blockSizeBytes = blockSize * 4;
                  var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
                  var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
                  var paddingWords = [];
                  for (var i = 0; i < nPaddingBytes; i += 4) {
                    paddingWords.push(paddingWord);
                  }
                  var padding = WordArray.create(paddingWords, nPaddingBytes);
                  data.concat(padding);
                },
                /**
                 * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
                 *
                 * @param {WordArray} data The data to unpad.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     CryptoJS.pad.Pkcs7.unpad(wordArray);
                 */
                unpad: function(data) {
                  var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
                  data.sigBytes -= nPaddingBytes;
                }
              };
              C_lib.BlockCipher = Cipher.extend({
                /**
                 * Configuration options.
                 *
                 * @property {Mode} mode The block mode to use. Default: CBC
                 * @property {Padding} padding The padding strategy to use. Default: Pkcs7
                 */
                cfg: Cipher.cfg.extend({
                  mode: CBC,
                  padding: Pkcs7
                }),
                reset: function() {
                  var modeCreator;
                  Cipher.reset.call(this);
                  var cfg = this.cfg;
                  var iv = cfg.iv;
                  var mode = cfg.mode;
                  if (this._xformMode == this._ENC_XFORM_MODE) {
                    modeCreator = mode.createEncryptor;
                  } else {
                    modeCreator = mode.createDecryptor;
                    this._minBufferSize = 1;
                  }
                  if (this._mode && this._mode.__creator == modeCreator) {
                    this._mode.init(this, iv && iv.words);
                  } else {
                    this._mode = modeCreator.call(mode, this, iv && iv.words);
                    this._mode.__creator = modeCreator;
                  }
                },
                _doProcessBlock: function(words, offset) {
                  this._mode.processBlock(words, offset);
                },
                _doFinalize: function() {
                  var finalProcessedBlocks;
                  var padding = this.cfg.padding;
                  if (this._xformMode == this._ENC_XFORM_MODE) {
                    padding.pad(this._data, this.blockSize);
                    finalProcessedBlocks = this._process(true);
                  } else {
                    finalProcessedBlocks = this._process(true);
                    padding.unpad(finalProcessedBlocks);
                  }
                  return finalProcessedBlocks;
                },
                blockSize: 128 / 32
              });
              var CipherParams = C_lib.CipherParams = Base.extend({
                /**
                 * Initializes a newly created cipher params object.
                 *
                 * @param {Object} cipherParams An object with any of the possible cipher parameters.
                 *
                 * @example
                 *
                 *     var cipherParams = CryptoJS.lib.CipherParams.create({
                 *         ciphertext: ciphertextWordArray,
                 *         key: keyWordArray,
                 *         iv: ivWordArray,
                 *         salt: saltWordArray,
                 *         algorithm: CryptoJS.algo.AES,
                 *         mode: CryptoJS.mode.CBC,
                 *         padding: CryptoJS.pad.PKCS7,
                 *         blockSize: 4,
                 *         formatter: CryptoJS.format.OpenSSL
                 *     });
                 */
                init: function(cipherParams) {
                  this.mixIn(cipherParams);
                },
                /**
                 * Converts this cipher params object to a string.
                 *
                 * @param {Format} formatter (Optional) The formatting strategy to use.
                 *
                 * @return {string} The stringified cipher params.
                 *
                 * @throws Error If neither the formatter nor the default formatter is set.
                 *
                 * @example
                 *
                 *     var string = cipherParams + '';
                 *     var string = cipherParams.toString();
                 *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
                 */
                toString: function(formatter2) {
                  return (formatter2 || this.formatter).stringify(this);
                }
              });
              var C_format = C2.format = {};
              var OpenSSLFormatter = C_format.OpenSSL = {
                /**
                 * Converts a cipher params object to an OpenSSL-compatible string.
                 *
                 * @param {CipherParams} cipherParams The cipher params object.
                 *
                 * @return {string} The OpenSSL-compatible string.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
                 */
                stringify: function(cipherParams) {
                  var wordArray;
                  var ciphertext = cipherParams.ciphertext;
                  var salt = cipherParams.salt;
                  if (salt) {
                    wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
                  } else {
                    wordArray = ciphertext;
                  }
                  return wordArray.toString(Base64);
                },
                /**
                 * Converts an OpenSSL-compatible string to a cipher params object.
                 *
                 * @param {string} openSSLStr The OpenSSL-compatible string.
                 *
                 * @return {CipherParams} The cipher params object.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
                 */
                parse: function(openSSLStr) {
                  var salt;
                  var ciphertext = Base64.parse(openSSLStr);
                  var ciphertextWords = ciphertext.words;
                  if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
                    salt = WordArray.create(ciphertextWords.slice(2, 4));
                    ciphertextWords.splice(0, 4);
                    ciphertext.sigBytes -= 16;
                  }
                  return CipherParams.create({ ciphertext, salt });
                }
              };
              var SerializableCipher = C_lib.SerializableCipher = Base.extend({
                /**
                 * Configuration options.
                 *
                 * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
                 */
                cfg: Base.extend({
                  format: OpenSSLFormatter
                }),
                /**
                 * Encrypts a message.
                 *
                 * @param {Cipher} cipher The cipher algorithm to use.
                 * @param {WordArray|string} message The message to encrypt.
                 * @param {WordArray} key The key.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {CipherParams} A cipher params object.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
                 *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
                 *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                 */
                encrypt: function(cipher, message, key, cfg) {
                  cfg = this.cfg.extend(cfg);
                  var encryptor = cipher.createEncryptor(key, cfg);
                  var ciphertext = encryptor.finalize(message);
                  var cipherCfg = encryptor.cfg;
                  return CipherParams.create({
                    ciphertext,
                    key,
                    iv: cipherCfg.iv,
                    algorithm: cipher,
                    mode: cipherCfg.mode,
                    padding: cipherCfg.padding,
                    blockSize: cipher.blockSize,
                    formatter: cfg.format
                  });
                },
                /**
                 * Decrypts serialized ciphertext.
                 *
                 * @param {Cipher} cipher The cipher algorithm to use.
                 * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
                 * @param {WordArray} key The key.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {WordArray} The plaintext.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                 *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                 */
                decrypt: function(cipher, ciphertext, key, cfg) {
                  cfg = this.cfg.extend(cfg);
                  ciphertext = this._parse(ciphertext, cfg.format);
                  var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
                  return plaintext;
                },
                /**
                 * Converts serialized ciphertext to CipherParams,
                 * else assumed CipherParams already and returns ciphertext unchanged.
                 *
                 * @param {CipherParams|string} ciphertext The ciphertext.
                 * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
                 *
                 * @return {CipherParams} The unserialized ciphertext.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
                 */
                _parse: function(ciphertext, format) {
                  if (typeof ciphertext == "string") {
                    return format.parse(ciphertext, this);
                  } else {
                    return ciphertext;
                  }
                }
              });
              var C_kdf = C2.kdf = {};
              var OpenSSLKdf = C_kdf.OpenSSL = {
                /**
                 * Derives a key and IV from a password.
                 *
                 * @param {string} password The password to derive from.
                 * @param {number} keySize The size in words of the key to generate.
                 * @param {number} ivSize The size in words of the IV to generate.
                 * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
                 *
                 * @return {CipherParams} A cipher params object with the key, IV, and salt.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
                 *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
                 */
                execute: function(password, keySize, ivSize, salt, hasher) {
                  if (!salt) {
                    salt = WordArray.random(64 / 8);
                  }
                  if (!hasher) {
                    var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
                  } else {
                    var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
                  }
                  var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
                  key.sigBytes = keySize * 4;
                  return CipherParams.create({ key, iv, salt });
                }
              };
              var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
                /**
                 * Configuration options.
                 *
                 * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
                 */
                cfg: SerializableCipher.cfg.extend({
                  kdf: OpenSSLKdf
                }),
                /**
                 * Encrypts a message using a password.
                 *
                 * @param {Cipher} cipher The cipher algorithm to use.
                 * @param {WordArray|string} message The message to encrypt.
                 * @param {string} password The password.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {CipherParams} A cipher params object.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
                 *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
                 */
                encrypt: function(cipher, message, password, cfg) {
                  cfg = this.cfg.extend(cfg);
                  var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
                  cfg.iv = derivedParams.iv;
                  var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
                  ciphertext.mixIn(derivedParams);
                  return ciphertext;
                },
                /**
                 * Decrypts serialized ciphertext using a password.
                 *
                 * @param {Cipher} cipher The cipher algorithm to use.
                 * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
                 * @param {string} password The password.
                 * @param {Object} cfg (Optional) The configuration options to use for this operation.
                 *
                 * @return {WordArray} The plaintext.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
                 *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
                 */
                decrypt: function(cipher, ciphertext, password, cfg) {
                  cfg = this.cfg.extend(cfg);
                  ciphertext = this._parse(ciphertext, cfg.format);
                  var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
                  cfg.iv = derivedParams.iv;
                  var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
                  return plaintext;
                }
              });
            }();
          });
        })(cipherCore);
        return cipherCore.exports;
      }
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS) {
          (function() {
            var C2 = CryptoJS;
            var C_lib = C2.lib;
            var BlockCipher = C_lib.BlockCipher;
            var C_algo = C2.algo;
            var SBOX = [];
            var INV_SBOX = [];
            var SUB_MIX_0 = [];
            var SUB_MIX_1 = [];
            var SUB_MIX_2 = [];
            var SUB_MIX_3 = [];
            var INV_SUB_MIX_0 = [];
            var INV_SUB_MIX_1 = [];
            var INV_SUB_MIX_2 = [];
            var INV_SUB_MIX_3 = [];
            (function() {
              var d = [];
              for (var i = 0; i < 256; i++) {
                if (i < 128) {
                  d[i] = i << 1;
                } else {
                  d[i] = i << 1 ^ 283;
                }
              }
              var x = 0;
              var xi = 0;
              for (var i = 0; i < 256; i++) {
                var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
                sx = sx >>> 8 ^ sx & 255 ^ 99;
                SBOX[x] = sx;
                INV_SBOX[sx] = x;
                var x2 = d[x];
                var x4 = d[x2];
                var x8 = d[x4];
                var t2 = d[sx] * 257 ^ sx * 16843008;
                SUB_MIX_0[x] = t2 << 24 | t2 >>> 8;
                SUB_MIX_1[x] = t2 << 16 | t2 >>> 16;
                SUB_MIX_2[x] = t2 << 8 | t2 >>> 24;
                SUB_MIX_3[x] = t2;
                var t2 = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
                INV_SUB_MIX_0[sx] = t2 << 24 | t2 >>> 8;
                INV_SUB_MIX_1[sx] = t2 << 16 | t2 >>> 16;
                INV_SUB_MIX_2[sx] = t2 << 8 | t2 >>> 24;
                INV_SUB_MIX_3[sx] = t2;
                if (!x) {
                  x = xi = 1;
                } else {
                  x = x2 ^ d[d[d[x8 ^ x2]]];
                  xi ^= d[d[xi]];
                }
              }
            })();
            var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
            var AES = C_algo.AES = BlockCipher.extend({
              _doReset: function() {
                var t2;
                if (this._nRounds && this._keyPriorReset === this._key) {
                  return;
                }
                var key = this._keyPriorReset = this._key;
                var keyWords = key.words;
                var keySize = key.sigBytes / 4;
                var nRounds = this._nRounds = keySize + 6;
                var ksRows = (nRounds + 1) * 4;
                var keySchedule = this._keySchedule = [];
                for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                  if (ksRow < keySize) {
                    keySchedule[ksRow] = keyWords[ksRow];
                  } else {
                    t2 = keySchedule[ksRow - 1];
                    if (!(ksRow % keySize)) {
                      t2 = t2 << 8 | t2 >>> 24;
                      t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                      t2 ^= RCON[ksRow / keySize | 0] << 24;
                    } else if (keySize > 6 && ksRow % keySize == 4) {
                      t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                    }
                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t2;
                  }
                }
                var invKeySchedule = this._invKeySchedule = [];
                for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                  var ksRow = ksRows - invKsRow;
                  if (invKsRow % 4) {
                    var t2 = keySchedule[ksRow];
                  } else {
                    var t2 = keySchedule[ksRow - 4];
                  }
                  if (invKsRow < 4 || ksRow <= 4) {
                    invKeySchedule[invKsRow] = t2;
                  } else {
                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t2 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t2 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t2 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t2 & 255]];
                  }
                }
              },
              encryptBlock: function(M, offset) {
                this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
              },
              decryptBlock: function(M, offset) {
                var t2 = M[offset + 1];
                M[offset + 1] = M[offset + 3];
                M[offset + 3] = t2;
                this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
                var t2 = M[offset + 1];
                M[offset + 1] = M[offset + 3];
                M[offset + 3] = t2;
              },
              _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
                var nRounds = this._nRounds;
                var s0 = M[offset] ^ keySchedule[0];
                var s1 = M[offset + 1] ^ keySchedule[1];
                var s2 = M[offset + 2] ^ keySchedule[2];
                var s3 = M[offset + 3] ^ keySchedule[3];
                var ksRow = 4;
                for (var round = 1; round < nRounds; round++) {
                  var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
                  var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
                  var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
                  var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
                  s0 = t0;
                  s1 = t1;
                  s2 = t2;
                  s3 = t3;
                }
                var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
                var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
                var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
                var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
                M[offset] = t0;
                M[offset + 1] = t1;
                M[offset + 2] = t2;
                M[offset + 3] = t3;
              },
              keySize: 256 / 32
            });
            C2.AES = BlockCipher._createHelper(AES);
          })();
          return CryptoJS.AES;
        });
      })(aes);
      var aesExports = aes.exports;
      var padPkcs7 = { exports: {} };
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS) {
          return CryptoJS.pad.Pkcs7;
        });
      })(padPkcs7);
      var padPkcs7Exports = padPkcs7.exports;
      const pkcs7 = /* @__PURE__ */ getDefaultExportFromCjs(padPkcs7Exports);
      var encUtf8 = { exports: {} };
      (function(module2, exports2) {
        (function(root2, factory) {
          {
            module2.exports = factory(requireCore());
          }
        })(commonjsGlobal, function(CryptoJS) {
          return CryptoJS.enc.Utf8;
        });
      })(encUtf8);
      var encUtf8Exports = encUtf8.exports;
      const UTF8 = /* @__PURE__ */ getDefaultExportFromCjs(encUtf8Exports);
      var modeEcb = { exports: {} };
      (function(module2, exports2) {
        (function(root2, factory, undef) {
          {
            module2.exports = factory(requireCore(), requireCipherCore());
          }
        })(commonjsGlobal, function(CryptoJS) {
          CryptoJS.mode.ECB = function() {
            var ECB2 = CryptoJS.lib.BlockCipherMode.extend();
            ECB2.Encryptor = ECB2.extend({
              processBlock: function(words, offset) {
                this._cipher.encryptBlock(words, offset);
              }
            });
            ECB2.Decryptor = ECB2.extend({
              processBlock: function(words, offset) {
                this._cipher.decryptBlock(words, offset);
              }
            });
            return ECB2;
          }();
          return CryptoJS.mode.ECB;
        });
      })(modeEcb);
      var modeEcbExports = modeEcb.exports;
      const ECB = /* @__PURE__ */ getDefaultExportFromCjs(modeEcbExports);
      const decrypt = (data) => {
        return aesExports.decrypt(data, encUtf8Exports.parse("_11111000001111@"), {
          mode: ECB,
          padding: pkcs7,
          iv: encUtf8Exports.parse("@11111000001111_")
        }).toString(UTF8);
      };
      (() => {
        var xs = Object.defineProperty;
        var ys = (e2, t2) => {
          for (var r2 in t2)
            xs(e2, r2, { get: t2[r2], enumerable: true });
        };
        function re(e2) {
          return e2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }
        function Q2(e2) {
          let t2 = e2.length, r2 = -1, n2, o2 = "", i = e2.charCodeAt(0);
          for (; ++r2 < t2; ) {
            if (n2 = e2.charCodeAt(r2), n2 === 0) {
              o2 += "�";
              continue;
            }
            if (n2 === 37) {
              o2 += "\\%";
              continue;
            }
            if (n2 === 44) {
              o2 += "\\,";
              continue;
            }
            if (n2 >= 1 && n2 <= 31 || n2 === 127 || r2 === 0 && n2 >= 48 && n2 <= 57 || r2 === 1 && n2 >= 48 && n2 <= 57 && i === 45) {
              o2 += `\\${n2.toString(16)} `;
              continue;
            }
            if (r2 === 0 && t2 === 1 && n2 === 45) {
              o2 += `\\${e2.charAt(r2)}`;
              continue;
            }
            if (n2 >= 128 || n2 === 45 || n2 === 95 || n2 >= 48 && n2 <= 57 || n2 >= 65 && n2 <= 90 || n2 >= 97 && n2 <= 122) {
              o2 += e2.charAt(r2);
              continue;
            }
            o2 += `\\${e2.charAt(r2)}`;
          }
          return o2;
        }
        var Ze2 = Q2;
        function _2(e2 = []) {
          return Array.isArray(e2) ? e2 : [e2];
        }
        function be2(e2) {
          return Array.from(new Set(e2));
        }
        function wn(e2, t2) {
          return e2.reduce(
            (r2, n2) => (r2.findIndex((i) => t2(n2, i)) === -1 && r2.push(n2), r2),
            []
          );
        }
        function O(e2) {
          return typeof e2 == "string";
        }
        function xe(e2) {
          return O(e2) ? e2 : (Array.isArray(e2) ? e2 : Object.entries(e2)).filter((t2) => t2[1] != null);
        }
        function $n(e2) {
          return Array.isArray(e2) ? e2.find((t2) => !Array.isArray(t2) || Array.isArray(t2[0])) ? e2.map((t2) => xe(t2)) : [e2] : [xe(e2)];
        }
        function vs(e2) {
          return e2.filter(([t2, r2], n2) => {
            if (t2.startsWith("$$"))
              return false;
            for (let o2 = n2 - 1; o2 >= 0; o2--)
              if (e2[o2][0] === t2 && e2[o2][1] === r2)
                return false;
            return true;
          });
        }
        function ye2(e2) {
          return e2 == null ? "" : vs(e2).map(([t2, r2]) => r2 != null ? `${t2}:${r2};` : void 0).filter(Boolean).join("");
        }
        function Je2(e2) {
          return e2 && typeof e2 == "object" && !Array.isArray(e2);
        }
        function Or(e2, t2, r2 = false) {
          let n2 = e2, o2 = t2;
          if (Array.isArray(o2))
            return r2 && Array.isArray(o2) ? [...n2, ...o2] : [...o2];
          let i = { ...n2 };
          return Je2(n2) && Je2(o2) && Object.keys(o2).forEach((a) => {
            Je2(n2[a]) && Je2(o2[a]) || Array.isArray(n2[a]) && Array.isArray(o2[a]) ? i[a] = Or(n2[a], o2[a], r2) : Object.assign(i, { [a]: o2[a] });
          }), i;
        }
        function ze(e2) {
          let t2, r2, n2;
          if (Array.isArray(e2)) {
            for (r2 = Array(t2 = e2.length); t2--; )
              r2[t2] = (n2 = e2[t2]) && typeof n2 == "object" ? ze(n2) : n2;
            return r2;
          }
          if (Object.prototype.toString.call(e2) === "[object Object]") {
            r2 = {};
            for (t2 in e2)
              t2 === "__proto__" ? Object.defineProperty(r2, t2, {
                value: ze(e2[t2]),
                configurable: true,
                enumerable: true,
                writable: true
              }) : r2[t2] = (n2 = e2[t2]) && typeof n2 == "object" ? ze(n2) : n2;
            return r2;
          }
          return e2;
        }
        function kn(e2) {
          return O(e2[0]);
        }
        function Sn(e2) {
          return O(e2[0]);
        }
        var ws = /^\[(.+?)~?="(.*)"\]$/;
        var $s = /[\w\u00A0-\uFFFF-_:%-?]/, Ar = "$$shortcut-no-merge";
        function Cn(e2) {
          return e2.match(ws);
        }
        function Oe(e2 = "") {
          return $s.test(e2);
        }
        function Rn(e2) {
          return typeof e2 == "function" ? { match: e2 } : e2;
        }
        function Vr(e2) {
          return e2.length === 3;
        }
        function Tn(e2) {
          return e2 != null;
        }
        function En() {
        }
        var Qe2 = class {
          constructor() {
            __publicField(this, "_map", /* @__PURE__ */ new Map());
          }
          get(t2, r2) {
            let n2 = this._map.get(t2);
            if (n2)
              return n2.get(r2);
          }
          getFallback(t2, r2, n2) {
            let o2 = this._map.get(t2);
            return o2 || (o2 = /* @__PURE__ */ new Map(), this._map.set(t2, o2)), o2.has(r2) || o2.set(r2, n2), o2.get(r2);
          }
          set(t2, r2, n2) {
            let o2 = this._map.get(t2);
            return o2 || (o2 = /* @__PURE__ */ new Map(), this._map.set(t2, o2)), o2.set(r2, n2), this;
          }
          has(t2, r2) {
            var _a3;
            return (_a3 = this._map.get(t2)) == null ? void 0 : _a3.has(r2);
          }
          delete(t2, r2) {
            var _a3;
            return ((_a3 = this._map.get(t2)) == null ? void 0 : _a3.delete(r2)) || false;
          }
          deleteTop(t2) {
            return this._map.delete(t2);
          }
          map(t2) {
            return Array.from(this._map.entries()).flatMap(
              ([r2, n2]) => Array.from(n2.entries()).map(([o2, i]) => t2(i, r2, o2))
            );
          }
        };
        var Ae2 = class extends Set {
          constructor(t2) {
            super(t2);
            __publicField(this, "_map");
            this._map ?? (this._map = /* @__PURE__ */ new Map());
          }
          add(t2) {
            return this._map ?? (this._map = /* @__PURE__ */ new Map()), this._map.set(t2, (this._map.get(t2) ?? 0) + 1), super.add(t2);
          }
          delete(t2) {
            return this._map.delete(t2), super.delete(t2);
          }
          clear() {
            this._map.clear(), super.clear();
          }
          getCount(t2) {
            return this._map.get(t2) ?? 0;
          }
          setCount(t2, r2) {
            return this._map.set(t2, r2), super.add(t2);
          }
        };
        function et2(e2) {
          return e2 instanceof Ae2;
        }
        var tt2 = {};
        function ks(e2 = ["-", ":"]) {
          let t2 = e2.join("|");
          return tt2[t2] || (tt2[t2] = new RegExp(
            `((?:[!@<~\\w+:_/-]|\\[&?>?:?\\S*\\])+?)(${t2})\\(((?:[~!<>\\w\\s:/\\\\,%#.$?-]|\\[.*?\\])+?)\\)(?!\\s*?=>)`,
            "gm"
          )), tt2[t2].lastIndex = 0, tt2[t2];
        }
        function Ss(e2, t2 = ["-", ":"], r2 = 5) {
          let n2 = ks(t2), o2, i = e2.toString(), a = /* @__PURE__ */ new Set(), s2 = /* @__PURE__ */ new Map();
          do
            o2 = false, i = i.replace(n2, (f, u, p2, d, h2) => {
              var _a3;
              if (!t2.includes(p2))
                return f;
              o2 = true, a.add(u + p2);
              let x = h2 + u.length + p2.length + 1, $2 = { length: f.length, items: [] };
              s2.set(h2, $2);
              for (let y of [...d.matchAll(/\S+/g)]) {
                let C2 = x + y.index, b = (_a3 = s2.get(C2)) == null ? void 0 : _a3.items;
                b ? s2.delete(C2) : b = [{ offset: C2, length: y[0].length, className: y[0] }];
                for (let R2 of b)
                  R2.className = R2.className === "~" ? u : R2.className.replace(/^(!?)(.*)/, `$1${u}${p2}$2`), $2.items.push(R2);
              }
              return "$".repeat(f.length);
            }), r2 -= 1;
          while (o2 && r2);
          let c;
          if (typeof e2 == "string") {
            c = "";
            let f = 0;
            for (let [u, p2] of s2)
              c += e2.slice(f, u), c += p2.items.map((d) => d.className).join(" "), f = u + p2.length;
            c += e2.slice(f);
          } else {
            c = e2;
            for (let [f, u] of s2)
              c.overwrite(f, f + u.length, u.items.map((p2) => p2.className).join(" "));
          }
          return {
            prefixes: Array.from(a),
            hasChanged: o2,
            groupsByOffset: s2,
            get expanded() {
              return c.toString();
            }
          };
        }
        function jn(e2, t2 = ["-", ":"], r2 = 5) {
          let n2 = Ss(e2, t2, r2);
          return typeof e2 == "string" ? n2.expanded : e2;
        }
        var zn = /* @__PURE__ */ new Set();
        function ne2(e2) {
          zn.has(e2) || (console.warn("[unocss]", e2), zn.add(e2));
        }
        var rt2 = /[\\:]?[\s'"`;{}]+/g;
        function Cs(e2) {
          return e2.split(rt2);
        }
        var nt2 = {
          name: "@unocss/core/extractor-split",
          order: 0,
          extract({ code: e2 }) {
            return Cs(e2);
          }
        };
        function On() {
          return {
            events: {},
            emit(e2, ...t2) {
              (this.events[e2] || []).forEach((r2) => r2(...t2));
            },
            on(e2, t2) {
              return (this.events[e2] = this.events[e2] || []).push(t2), () => this.events[e2] = (this.events[e2] || []).filter((r2) => r2 !== t2);
            }
          };
        }
        var ot2 = "default", it2 = "preflights", Rs = "shortcuts", Ts = "imports", An = { [Ts]: -200, [it2]: -100, [Rs]: -10, [ot2]: 0 };
        function _n(e2) {
          return _2(e2).flatMap((t2) => Array.isArray(t2) ? [t2] : Object.entries(t2));
        }
        var Vn = "_uno_resolved";
        function Es(e2) {
          var _a3;
          let t2 = typeof e2 == "function" ? e2() : e2;
          if (Vn in t2)
            return t2;
          t2 = { ...t2 }, Object.defineProperty(t2, Vn, { value: true, enumerable: false });
          let r2 = t2.shortcuts ? _n(t2.shortcuts) : void 0;
          if (t2.shortcuts = r2, t2.prefix || t2.layer) {
            let n2 = (o2) => {
              o2[2] || (o2[2] = {});
              let i = o2[2];
              i.prefix == null && t2.prefix && (i.prefix = _2(t2.prefix)), i.layer == null && t2.layer && (i.layer = t2.layer);
            };
            r2 == null ? void 0 : r2.forEach(n2), (_a3 = t2.rules) == null ? void 0 : _a3.forEach(n2);
          }
          return t2;
        }
        function Pn(e2) {
          let t2 = Es(e2);
          if (!t2.presets)
            return [t2];
          let r2 = (t2.presets || []).flatMap(_2).flatMap(Pn);
          return [t2, ...r2];
        }
        function _r(e2 = {}, t2 = {}) {
          var _a3, _b;
          let r2 = Object.assign({}, t2, e2), n2 = wn(
            (r2.presets || []).flatMap(_2).flatMap(Pn),
            (m, w) => m.name === w.name
          ), o2 = [
            ...n2.filter((m) => m.enforce === "pre"),
            ...n2.filter((m) => !m.enforce),
            ...n2.filter((m) => m.enforce === "post")
          ], i = [...o2, r2], a = [...i].reverse(), s2 = Object.assign({}, An, ...i.map((m) => m.layers));
          function c(m) {
            return be2(i.flatMap((w) => _2(w[m] || [])));
          }
          let f = c("extractors"), u = (_a3 = a.find((m) => m.extractorDefault !== void 0)) == null ? void 0 : _a3.extractorDefault;
          u === void 0 && (u = nt2), u && !f.includes(u) && f.unshift(u), f.sort((m, w) => (m.order || 0) - (w.order || 0));
          let p2 = c("rules"), d = {}, h2 = p2.length, x = p2.map((m, w) => {
            var _a4;
            if (kn(m)) {
              _2(((_a4 = m[2]) == null ? void 0 : _a4.prefix) || "").forEach((W2) => {
                d[W2 + m[0]] = [w, m[1], m[2], m];
              });
              return;
            }
            return [w, ...m];
          }).filter(Boolean).reverse(), $2 = js(i.map((m) => m.theme)), y = c("extendTheme");
          for (let m of y)
            $2 = m($2) || $2;
          let C2 = {
            templates: be2(i.flatMap((m) => {
              var _a4;
              return _2((_a4 = m.autocomplete) == null ? void 0 : _a4.templates);
            })),
            extractors: i.flatMap((m) => {
              var _a4;
              return _2((_a4 = m.autocomplete) == null ? void 0 : _a4.extractors);
            }).sort((m, w) => (m.order || 0) - (w.order || 0)),
            shorthands: zs(i.map((m) => {
              var _a4;
              return ((_a4 = m.autocomplete) == null ? void 0 : _a4.shorthands) || {};
            }))
          }, b = c("separators");
          b.length || (b = [":", "-"]);
          let R2 = {
            mergeSelectors: true,
            warn: true,
            sortLayers: (m) => m,
            ...r2,
            blocklist: c("blocklist"),
            presets: o2,
            envMode: r2.envMode || "build",
            shortcutsLayer: r2.shortcutsLayer || "shortcuts",
            layers: s2,
            theme: $2,
            rulesSize: h2,
            rulesDynamic: x,
            rulesStaticMap: d,
            preprocess: c("preprocess"),
            postprocess: c("postprocess"),
            preflights: c("preflights"),
            autocomplete: C2,
            variants: c("variants").map(Rn).sort((m, w) => (m.order || 0) - (w.order || 0)),
            shortcuts: _n(c("shortcuts")).reverse(),
            extractors: f,
            safelist: c("safelist"),
            separators: b,
            details: r2.details ?? r2.envMode === "dev"
          };
          for (let m of i)
            (_b = m == null ? void 0 : m.configResolved) == null ? void 0 : _b.call(m, R2);
          return R2;
        }
        function js(e2) {
          return e2.map((t2) => t2 ? ze(t2) : {}).reduce((t2, r2) => Or(t2, r2), {});
        }
        function zs(e2) {
          return e2.reduce((t2, r2) => {
            let n2 = {};
            for (let o2 in r2) {
              let i = r2[o2];
              Array.isArray(i) ? n2[o2] = `(${i.join("|")})` : n2[o2] = i;
            }
            return { ...t2, ...n2 };
          }, {});
        }
        var Mn = "0.58.3";
        var Pr = class {
          constructor(t2 = {}, r2 = {}) {
            __publicField(this, "version", Mn);
            __publicField(this, "_cache", /* @__PURE__ */ new Map());
            __publicField(this, "config");
            __publicField(this, "blocked", /* @__PURE__ */ new Set());
            __publicField(this, "parentOrders", /* @__PURE__ */ new Map());
            __publicField(this, "events", On());
            this.userConfig = t2;
            this.defaults = r2;
            this.config = _r(t2, r2), this.events.emit("config", this.config);
          }
          setConfig(t2, r2) {
            t2 && (r2 && (this.defaults = r2), this.userConfig = t2, this.blocked.clear(), this.parentOrders.clear(), this._cache.clear(), this.config = _r(t2, this.defaults), this.events.emit("config", this.config));
          }
          async applyExtractors(t2, r2, n2 = /* @__PURE__ */ new Set()) {
            var _a3;
            let o2 = {
              original: t2,
              code: t2,
              id: r2,
              extracted: n2,
              envMode: this.config.envMode
            };
            for (let i of this.config.extractors) {
              let a = await ((_a3 = i.extract) == null ? void 0 : _a3.call(i, o2));
              if (a)
                if (et2(a) && et2(n2))
                  for (let s2 of a)
                    n2.setCount(s2, n2.getCount(s2) + a.getCount(s2));
                else
                  for (let s2 of a)
                    n2.add(s2);
            }
            return n2;
          }
          makeContext(t2, r2) {
            let n2 = {
              rawSelector: t2,
              currentSelector: r2[1],
              theme: this.config.theme,
              generator: this,
              variantHandlers: r2[2],
              constructCSS: (...o2) => this.constructCustomCSS(n2, ...o2),
              variantMatch: r2
            };
            return n2;
          }
          async parseToken(t2, r2) {
            var _a3;
            if (this.blocked.has(t2))
              return;
            let n2 = `${t2}${r2 ? ` ${r2}` : ""}`;
            if (this._cache.has(n2))
              return this._cache.get(n2);
            let o2 = t2;
            for (let f of this.config.preprocess)
              o2 = f(t2);
            if (this.isBlocked(o2)) {
              this.blocked.add(t2), this._cache.set(n2, null);
              return;
            }
            let i = await this.matchVariants(t2, o2);
            if (!i || this.isBlocked(i[1])) {
              this.blocked.add(t2), this._cache.set(n2, null);
              return;
            }
            let a = this.makeContext(t2, [r2 || i[0], i[1], i[2], i[3]]);
            this.config.details && (a.variants = [...i[3]]);
            let s2 = await this.expandShortcut(a.currentSelector, a), c = s2 ? await this.stringifyShortcuts(a.variantMatch, a, s2[0], s2[1]) : (_a3 = await this.parseUtil(a.variantMatch, a)) == null ? void 0 : _a3.map((f) => this.stringifyUtil(f, a)).filter(Tn);
            if (c == null ? void 0 : c.length)
              return this._cache.set(n2, c), c;
            this._cache.set(n2, null);
          }
          async generate(t2, r2 = {}) {
            let {
              id: n2,
              scope: o2,
              preflights: i = true,
              safelist: a = true,
              minify: s2 = false,
              extendedInfo: c = false
            } = r2, f = O(t2) ? await this.applyExtractors(t2, n2, c ? new Ae2() : /* @__PURE__ */ new Set()) : Array.isArray(t2) ? new Set(t2) : t2;
            a && this.config.safelist.forEach((m) => {
              f.has(m) || f.add(m);
            });
            let u = s2 ? "" : `
`, p2 = /* @__PURE__ */ new Set([ot2]), d = c ? /* @__PURE__ */ new Map() : /* @__PURE__ */ new Set(), h2 = /* @__PURE__ */ new Map(), x = {}, $2 = Array.from(f).map(async (m) => {
              var _a3;
              if (d.has(m))
                return;
              let w = await this.parseToken(m);
              if (w != null) {
                d instanceof Map ? d.set(m, { data: w, count: et2(f) ? f.getCount(m) : -1 }) : d.add(m);
                for (let z of w) {
                  let W2 = z[3] || "", N2 = (_a3 = z[4]) == null ? void 0 : _a3.layer;
                  h2.has(W2) || h2.set(W2, []), h2.get(W2).push(z), N2 && p2.add(N2);
                }
              }
            });
            await Promise.all($2), await (async () => {
              if (!i)
                return;
              let m = { generator: this, theme: this.config.theme }, w = /* @__PURE__ */ new Set([]);
              this.config.preflights.forEach(({ layer: z = it2 }) => {
                p2.add(z), w.add(z);
              }), x = Object.fromEntries(
                await Promise.all(
                  Array.from(w).map(async (z) => {
                    let N2 = (await Promise.all(
                      this.config.preflights.filter((ce2) => (ce2.layer || it2) === z).map(async (ce2) => await ce2.getCSS(m))
                    )).filter(Boolean).join(u);
                    return [z, N2];
                  })
                )
              );
            })();
            let y = this.config.sortLayers(
              Array.from(p2).sort(
                (m, w) => (this.config.layers[m] ?? 0) - (this.config.layers[w] ?? 0) || m.localeCompare(w)
              )
            ), C2 = {}, b = (m) => {
              if (C2[m])
                return C2[m];
              let w = Array.from(h2).sort(
                (W2, N2) => {
                  var _a3;
                  return (this.parentOrders.get(W2[0]) ?? 0) - (this.parentOrders.get(N2[0]) ?? 0) || ((_a3 = W2[0]) == null ? void 0 : _a3.localeCompare(N2[0] || "")) || 0;
                }
              ).map(([W2, N2]) => {
                let ce2 = N2.length, ge2 = N2.filter((g) => {
                  var _a3;
                  return (((_a3 = g[4]) == null ? void 0 : _a3.layer) || ot2) === m;
                }).sort(
                  (g, k) => {
                    var _a3, _b, _c2, _d, _e2, _f, _g;
                    return g[0] - k[0] || (((_a3 = g[4]) == null ? void 0 : _a3.sort) || 0) - (((_b = k[4]) == null ? void 0 : _b.sort) || 0) || ((_e2 = (_c2 = g[5]) == null ? void 0 : _c2.currentSelector) == null ? void 0 : _e2.localeCompare(
                      ((_d = k[5]) == null ? void 0 : _d.currentSelector) ?? ""
                    )) || ((_f = g[1]) == null ? void 0 : _f.localeCompare(k[1] || "")) || ((_g = g[2]) == null ? void 0 : _g.localeCompare(k[2] || "")) || 0;
                  }
                ).map(([, g, k, , E2, , B2]) => [
                  [[(g && Vs(g, o2)) ?? "", (E2 == null ? void 0 : E2.sort) ?? 0]],
                  k,
                  !!(B2 ?? (E2 == null ? void 0 : E2.noMerge))
                ]);
                if (!ge2.length)
                  return;
                let je2 = ge2.reverse().map(([g, k, E2], B2) => {
                  if (!E2 && this.config.mergeSelectors)
                    for (let D = B2 + 1; D < ce2; D++) {
                      let Z2 = ge2[D];
                      if (Z2 && !Z2[2] && (g && Z2[0] || g == null && Z2[0] == null) && Z2[1] === k)
                        return g && Z2[0] && Z2[0].push(...g), null;
                    }
                  let K2 = g ? be2(
                    g.sort(
                      (D, Z2) => {
                        var _a3;
                        return D[1] - Z2[1] || ((_a3 = D[0]) == null ? void 0 : _a3.localeCompare(Z2[0] || "")) || 0;
                      }
                    ).map((D) => D[0]).filter(Boolean)
                  ) : [];
                  return K2.length ? `${K2.join(`,${u}`)}{${k}}` : k;
                }).filter(Boolean).reverse().join(u);
                if (!W2)
                  return je2;
                let Xe2 = W2.split(" $$ ");
                return `${Xe2.join("{")}{${u}${je2}${u}${"}".repeat(Xe2.length)}`;
              }).filter(Boolean).join(u);
              i && (w = [x[m], w].filter(Boolean).join(u));
              let z = s2 ? "" : `/* layer: ${m} */${u}`;
              return C2[m] = w ? z + w : "";
            }, R2 = (m = y, w) => m.filter((z) => !(w == null ? void 0 : w.includes(z))).map((z) => b(z) || "").filter(Boolean).join(u);
            return {
              get css() {
                return R2();
              },
              layers: y,
              matched: d,
              getLayers: R2,
              getLayer: b
            };
          }
          async matchVariants(t2, r2) {
            let n2 = /* @__PURE__ */ new Set(), o2 = [], i = r2 || t2, a = true, s2 = { rawSelector: t2, theme: this.config.theme, generator: this };
            for (; a; ) {
              a = false;
              for (let c of this.config.variants) {
                if (!c.multiPass && n2.has(c))
                  continue;
                let f = await c.match(i, s2);
                if (f) {
                  if (O(f)) {
                    if (f === i)
                      continue;
                    f = { matcher: f };
                  }
                  i = f.matcher, o2.unshift(f), n2.add(c), a = true;
                  break;
                }
              }
              if (!a)
                break;
              if (o2.length > 500)
                throw new Error(`Too many variants applied to "${t2}"`);
            }
            return [t2, i, o2, n2];
          }
          applyVariants(t2, r2 = t2[4], n2 = t2[1]) {
            let i = r2.slice().sort((f, u) => (f.order || 0) - (u.order || 0)).reduceRight(
              (f, u) => (p2) => {
                var _a3, _b;
                let d = ((_a3 = u.body) == null ? void 0 : _a3.call(u, p2.entries)) || p2.entries, h2 = Array.isArray(u.parent) ? u.parent : [u.parent, void 0];
                return (u.handle ?? Ps)(
                  {
                    ...p2,
                    entries: d,
                    selector: ((_b = u.selector) == null ? void 0 : _b.call(u, p2.selector, d)) || p2.selector,
                    parent: h2[0] || p2.parent,
                    parentOrder: h2[1] || p2.parentOrder,
                    layer: u.layer || p2.layer,
                    sort: u.sort || p2.sort
                  },
                  f
                );
              },
              (f) => f
            )({ prefix: "", selector: _s(n2), pseudo: "", entries: t2[2] }), { parent: a, parentOrder: s2 } = i;
            a != null && s2 != null && this.parentOrders.set(a, s2);
            let c = {
              selector: [i.prefix, i.selector, i.pseudo].join(""),
              entries: i.entries,
              parent: a,
              layer: i.layer,
              sort: i.sort,
              noMerge: i.noMerge
            };
            for (let f of this.config.postprocess)
              f(c);
            return c;
          }
          constructCustomCSS(t2, r2, n2) {
            let o2 = xe(r2);
            if (O(o2))
              return o2;
            let {
              selector: i,
              entries: a,
              parent: s2
            } = this.applyVariants([
              0,
              n2 || t2.rawSelector,
              o2,
              void 0,
              t2.variantHandlers
            ]), c = `${i}{${ye2(a)}}`;
            return s2 ? `${s2}{${c}}` : c;
          }
          async parseUtil(t2, r2, n2 = false, o2) {
            var _a3;
            let [i, a, s2] = O(t2) ? await this.matchVariants(t2) : t2;
            this.config.details && (r2.rules = r2.rules ?? []);
            let c = this.config.rulesStaticMap[a];
            if (c && c[1] && (n2 || !((_a3 = c[2]) == null ? void 0 : _a3.internal))) {
              this.config.details && r2.rules.push(c[3]);
              let u = c[0], p2 = xe(c[1]), d = c[2];
              return O(p2) ? [[u, p2, d]] : [[u, i, p2, d, s2]];
            }
            r2.variantHandlers = s2;
            let { rulesDynamic: f } = this.config;
            for (let [u, p2, d, h2] of f) {
              if ((h2 == null ? void 0 : h2.internal) && !n2)
                continue;
              let x = a;
              if (h2 == null ? void 0 : h2.prefix) {
                let b = _2(h2.prefix);
                if (o2) {
                  let R2 = _2(o2);
                  if (!b.some((m) => R2.includes(m)))
                    continue;
                } else {
                  let R2 = b.find((m) => a.startsWith(m));
                  if (R2 == null)
                    continue;
                  x = a.slice(R2.length);
                }
              }
              let $2 = x.match(p2);
              if (!$2)
                continue;
              let y = await d($2, r2);
              if (!y)
                continue;
              this.config.details && r2.rules.push([p2, d, h2]);
              let C2 = $n(y).filter((b) => b.length);
              if (C2.length)
                return C2.map((b) => O(b) ? [u, b, h2] : [u, i, b, h2, s2]);
            }
          }
          stringifyUtil(t2, r2) {
            if (!t2)
              return;
            if (Vr(t2))
              return [
                t2[0],
                void 0,
                t2[1],
                void 0,
                t2[2],
                this.config.details ? r2 : void 0,
                void 0
              ];
            let {
              selector: n2,
              entries: o2,
              parent: i,
              layer: a,
              sort: s2,
              noMerge: c
            } = this.applyVariants(t2), f = ye2(o2);
            if (!f)
              return;
            let { layer: u, sort: p2, ...d } = t2[3] ?? {}, h2 = { ...d, layer: a ?? u, sort: s2 ?? p2 };
            return [t2[0], n2, f, i, h2, this.config.details ? r2 : void 0, c];
          }
          async expandShortcut(t2, r2, n2 = 5) {
            var _a3;
            if (n2 === 0)
              return;
            let o2 = this.config.details ? (s2) => {
              r2.shortcuts = r2.shortcuts ?? [], r2.shortcuts.push(s2);
            } : En, i, a;
            for (let s2 of this.config.shortcuts) {
              let c = t2;
              if ((_a3 = s2[2]) == null ? void 0 : _a3.prefix) {
                let u = _2(s2[2].prefix).find((p2) => t2.startsWith(p2));
                if (u == null)
                  continue;
                c = t2.slice(u.length);
              }
              if (Sn(s2)) {
                if (s2[0] === c) {
                  i = i || s2[2], a = s2[1], o2(s2);
                  break;
                }
              } else {
                let f = c.match(s2[0]);
                if (f && (a = s2[1](f, r2)), a) {
                  i = i || s2[2], o2(s2);
                  break;
                }
              }
            }
            if (O(a) && (a = jn(a.trim()).split(/\s+/g)), !a) {
              let [s2, c] = O(t2) ? await this.matchVariants(t2) : t2;
              if (s2 !== c) {
                let f = await this.expandShortcut(c, r2, n2 - 1);
                f && (a = f[0].map((u) => O(u) ? s2.replace(c, u) : u));
              }
            }
            if (a)
              return [
                (await Promise.all(
                  a.map(
                    async (s2) => {
                      var _a4;
                      return (O(s2) ? (_a4 = await this.expandShortcut(s2, r2, n2 - 1)) == null ? void 0 : _a4[0] : void 0) || [s2];
                    }
                  )
                )).flat(1).filter(Boolean),
                i
              ];
          }
          async stringifyShortcuts(t2, r2, n2, o2 = { layer: this.config.shortcutsLayer }) {
            var _a3;
            let i = new Qe2(), a = (await Promise.all(
              be2(n2).map(async (u) => {
                let p2 = O(u) ? await this.parseUtil(u, r2, true, o2.prefix) : [[Number.POSITIVE_INFINITY, "{inline}", xe(u), void 0, []]];
                return !p2 && this.config.warn && ne2(`unmatched utility "${u}" in shortcut "${t2[1]}"`), p2 || [];
              })
            )).flat(1).filter(Boolean).sort((u, p2) => u[0] - p2[0]), [s2, , c] = t2, f = [];
            for (let u of a) {
              if (Vr(u)) {
                f.push([u[0], void 0, u[1], void 0, u[2], r2, void 0]);
                continue;
              }
              let {
                selector: p2,
                entries: d,
                parent: h2,
                sort: x,
                noMerge: $2
              } = this.applyVariants(u, [...u[4], ...c], s2);
              i.getFallback(p2, h2, [[], u[0]])[0].push([
                d,
                !!($2 ?? ((_a3 = u[3]) == null ? void 0 : _a3.noMerge)),
                x ?? 0
              ]);
            }
            return f.concat(
              i.map(([u, p2], d, h2) => {
                let x = (y, C2, b) => {
                  let R2 = Math.max(...b.map((w) => w[1])), m = b.map((w) => w[0]);
                  return (y ? [m.flat(1)] : m).map((w) => {
                    let z = ye2(w);
                    if (z)
                      return [p2, d, z, h2, { ...o2, noMerge: C2, sort: R2 }, r2, void 0];
                  });
                };
                return [
                  [u.filter(([, y]) => y).map(([y, , C2]) => [y, C2]), true],
                  [u.filter(([, y]) => !y).map(([y, , C2]) => [y, C2]), false]
                ].map(([y, C2]) => [
                  ...x(
                    false,
                    C2,
                    y.filter(([b]) => b.some((R2) => R2[0] === Ar))
                  ),
                  ...x(
                    true,
                    C2,
                    y.filter(([b]) => b.every((R2) => R2[0] !== Ar))
                  )
                ]);
              }).flat(2).filter(Boolean)
            );
          }
          isBlocked(t2) {
            return !t2 || this.config.blocklist.some(
              (r2) => typeof r2 == "function" ? r2(t2) : O(r2) ? r2 === t2 : r2.test(t2)
            );
          }
        };
        function Un(e2, t2) {
          return new Pr(e2, t2);
        }
        var Ln = /\s\$\$\s+/g;
        function As(e2) {
          return Ln.test(e2);
        }
        function Vs(e2, t2) {
          return As(e2) ? e2.replace(Ln, t2 ? ` ${t2} ` : " ") : t2 ? `${t2} ${e2}` : e2;
        }
        var Fn = /^\[(.+?)(~?=)"(.*)"\]$/;
        function _s(e2) {
          return Fn.test(e2) ? e2.replace(Fn, (t2, r2, n2, o2) => `[${Ze2(r2)}${n2}"${Ze2(o2)}"]`) : `.${Ze2(e2)}`;
        }
        function Ps(e2, t2) {
          return t2(e2);
        }
        var Ms = /\/\/#\s*sourceMappingURL=.*\n?/g;
        function Wn(e2) {
          return e2.includes("sourceMappingURL=") ? e2.replace(Ms, "") : e2;
        }
        var Fs = /(?:[\w&:[\]-]|\[\S+=\S+\])+\[\\?['"]?\S+?['"]\]\]?[\w:-]*/g, Us = /\[(\\\W|[\w-])+:[^\s:]*?("\S+?"|'\S+?'|`\S+?`|[^\s:]+?)[^\s:]*?\)?\]/g, Ls = /^\[(\\\W|[\w-])+:['"]?\S+?['"]?\]$/;
        function Ws(e2) {
          let t2 = [];
          for (let r2 of e2.matchAll(Us))
            r2.index !== 0 && !/^[\s'"`]/.test(e2[r2.index - 1] ?? "") || t2.push(r2[0]);
          for (let r2 of e2.matchAll(Fs))
            t2.push(r2[0]);
          return e2.split(rt2).forEach((r2) => {
            Oe(r2) && !Ls.test(r2) && t2.push(r2);
          }), t2;
        }
        var Nn = {
          name: "@unocss/extractor-arbitrary-variants",
          order: 0,
          extract({ code: e2 }) {
            return Ws(Wn(e2));
          }
        };
        var Bn = [
          {
            layer: "preflights",
            getCSS(e2) {
              if (e2.theme.preflightBase) {
                let t2 = ye2(Object.entries(e2.theme.preflightBase));
                return _2(
                  e2.theme.preflightRoot ?? ["*,::before,::after", "::backdrop"]
                ).map((n2) => `${n2}{${t2}}`).join("");
              }
            }
          }
        ];
        var F = {
          l: ["-left"],
          r: ["-right"],
          t: ["-top"],
          b: ["-bottom"],
          s: ["-inline-start"],
          e: ["-inline-end"],
          x: ["-left", "-right"],
          y: ["-top", "-bottom"],
          "": [""],
          bs: ["-block-start"],
          be: ["-block-end"],
          is: ["-inline-start"],
          ie: ["-inline-end"],
          block: ["-block-start", "-block-end"],
          inline: ["-inline-start", "-inline-end"]
        }, Mr = {
          ...F,
          s: ["-inset-inline-start"],
          start: ["-inset-inline-start"],
          e: ["-inset-inline-end"],
          end: ["-inset-inline-end"],
          bs: ["-inset-block-start"],
          be: ["-inset-block-end"],
          is: ["-inset-inline-start"],
          ie: ["-inset-inline-end"],
          block: ["-inset-block-start", "-inset-block-end"],
          inline: ["-inset-inline-start", "-inset-inline-end"]
        }, Fr = {
          l: ["-top-left", "-bottom-left"],
          r: ["-top-right", "-bottom-right"],
          t: ["-top-left", "-top-right"],
          b: ["-bottom-left", "-bottom-right"],
          tl: ["-top-left"],
          lt: ["-top-left"],
          tr: ["-top-right"],
          rt: ["-top-right"],
          bl: ["-bottom-left"],
          lb: ["-bottom-left"],
          br: ["-bottom-right"],
          rb: ["-bottom-right"],
          "": [""],
          bs: ["-start-start", "-start-end"],
          be: ["-end-start", "-end-end"],
          s: ["-end-start", "-start-start"],
          is: ["-end-start", "-start-start"],
          e: ["-start-end", "-end-end"],
          ie: ["-start-end", "-end-end"],
          ss: ["-start-start"],
          "bs-is": ["-start-start"],
          "is-bs": ["-start-start"],
          se: ["-start-end"],
          "bs-ie": ["-start-end"],
          "ie-bs": ["-start-end"],
          es: ["-end-start"],
          "be-is": ["-end-start"],
          "is-be": ["-end-start"],
          ee: ["-end-end"],
          "be-ie": ["-end-end"],
          "ie-be": ["-end-end"]
        }, at2 = { x: ["-x"], y: ["-y"], z: ["-z"], "": ["-x", "-y"] }, Dn = [
          "top",
          "top center",
          "top left",
          "top right",
          "bottom",
          "bottom center",
          "bottom left",
          "bottom right",
          "left",
          "left center",
          "left top",
          "left bottom",
          "right",
          "right center",
          "right top",
          "right bottom",
          "center",
          "center top",
          "center bottom",
          "center left",
          "center right",
          "center center"
        ], M = Object.assign(
          {},
          ...Dn.map((e2) => ({ [e2.replace(/ /, "-")]: e2 })),
          ...Dn.map((e2) => ({
            [e2.replace(/\b(\w)\w+/g, "$1").replace(/ /, "")]: e2
          }))
        ), S = ["inherit", "initial", "revert", "revert-layer", "unset"], Ve = /^(calc|clamp|min|max)\s*\((.+)\)(.*)/;
        function ve2(e2, t2, r2) {
          if (e2 === "")
            return;
          let n2 = e2.length, o2 = 0, i = false, a = 0;
          for (let s2 = 0; s2 < n2; s2++)
            switch (e2[s2]) {
              case t2:
                i || (i = true, a = s2), o2++;
                break;
              case r2:
                if (--o2, o2 < 0)
                  return;
                if (o2 === 0)
                  return [e2.slice(a, s2 + 1), e2.slice(s2 + 1), e2.slice(0, a)];
                break;
            }
        }
        function oe(e2, t2, r2, n2) {
          if (e2 === "" || (O(n2) && (n2 = [n2]), n2.length === 0))
            return;
          let o2 = e2.length, i = 0;
          for (let a = 0; a < o2; a++)
            switch (e2[a]) {
              case t2:
                i++;
                break;
              case r2:
                if (--i < 0)
                  return;
                break;
              default:
                for (let s2 of n2) {
                  let c = s2.length;
                  if (c && s2 === e2.slice(a, a + c) && i === 0)
                    return a === 0 || a === o2 - c ? void 0 : [e2.slice(0, a), e2.slice(a + c)];
                }
            }
          return [e2, ""];
        }
        function le(e2, t2, r2) {
          r2 = r2 ?? 10;
          let n2 = [], o2 = 0;
          for (; e2 !== ""; ) {
            if (++o2 > r2)
              return;
            let i = oe(e2, "(", ")", t2);
            if (!i)
              return;
            let [a, s2] = i;
            n2.push(a), e2 = s2;
          }
          if (n2.length > 0)
            return n2;
        }
        var Ur = [
          "hsl",
          "hsla",
          "hwb",
          "lab",
          "lch",
          "oklab",
          "oklch",
          "rgb",
          "rgba"
        ], In = ["%alpha", "<alpha-value>"], Ns = new RegExp(In.map((e2) => re(e2)).join("|"));
        function G2(e2 = "") {
          let t2 = Bs(e2);
          if (t2 == null || t2 === false)
            return;
          let { type: r2, components: n2, alpha: o2 } = t2, i = r2.toLowerCase();
          if (n2.length !== 0 && !(Ur.includes(i) && ![1, 3].includes(n2.length)))
            return {
              type: i,
              components: n2.map((a) => typeof a == "string" ? a.trim() : a),
              alpha: typeof o2 == "string" ? o2.trim() : o2
            };
        }
        function ee2(e2) {
          let t2 = e2.alpha ?? 1;
          return typeof t2 == "string" && In.includes(t2) ? 1 : t2;
        }
        function A(e2, t2) {
          if (typeof e2 == "string")
            return e2.replace(Ns, `${t2 ?? 1}`);
          let { components: r2 } = e2, { alpha: n2, type: o2 } = e2;
          return n2 = t2 ?? n2, o2 = o2.toLowerCase(), ["hsla", "rgba"].includes(o2) ? `${o2}(${r2.join(", ")}${n2 == null ? "" : `, ${n2}`})` : (n2 = n2 == null ? "" : ` / ${n2}`, Ur.includes(o2) ? `${o2}(${r2.join(" ")}${n2})` : `color(${o2} ${r2.join(" ")}${n2})`);
        }
        function Bs(e2) {
          if (!e2)
            return;
          let t2 = Ds(e2);
          if (t2 != null || (t2 = Is(e2), t2 != null) || (t2 = Ks(e2), t2 != null) || (t2 = Hs(e2), t2 != null) || (t2 = qs(e2), t2 != null))
            return t2;
        }
        function Ds(e2) {
          let [, t2] = e2.match(/^#([\da-f]+)$/i) || [];
          if (t2)
            switch (t2.length) {
              case 3:
              case 4:
                let r2 = Array.from(t2, (o2) => Number.parseInt(o2, 16)).map(
                  (o2) => o2 << 4 | o2
                );
                return {
                  type: "rgb",
                  components: r2.slice(0, 3),
                  alpha: t2.length === 3 ? void 0 : Math.round(r2[3] / 255 * 100) / 100
                };
              case 6:
              case 8:
                let n2 = Number.parseInt(t2, 16);
                return {
                  type: "rgb",
                  components: t2.length === 6 ? [n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255] : [n2 >> 24 & 255, n2 >> 16 & 255, n2 >> 8 & 255],
                  alpha: t2.length === 6 ? void 0 : Math.round((n2 & 255) / 255 * 100) / 100
                };
            }
        }
        function Is(e2) {
          let t2 = { rebeccapurple: [102, 51, 153, 1] }[e2];
          if (t2 != null)
            return { type: "rgb", components: t2.slice(0, 3), alpha: t2[3] };
        }
        function Ks(e2) {
          let t2 = e2.match(/^(rgb|rgba|hsl|hsla)\((.+)\)$/i);
          if (!t2)
            return;
          let [, r2, n2] = t2, o2 = le(n2, ",", 5);
          if (o2) {
            if ([3, 4].includes(o2.length))
              return { type: r2, components: o2.slice(0, 3), alpha: o2[3] };
            if (o2.length !== 1)
              return false;
          }
        }
        var Gs = new RegExp(`^(${Ur.join("|")})\\((.+)\\)$`, "i");
        function Hs(e2) {
          let t2 = e2.match(Gs);
          if (!t2)
            return;
          let [, r2, n2] = t2, o2 = Kn(`${r2} ${n2}`);
          if (o2) {
            let {
              alpha: i,
              components: [a, ...s2]
            } = o2;
            return { type: a, components: s2, alpha: i };
          }
        }
        function qs(e2) {
          let t2 = e2.match(/^color\((.+)\)$/);
          if (!t2)
            return;
          let r2 = Kn(t2[1]);
          if (r2) {
            let {
              alpha: n2,
              components: [o2, ...i]
            } = r2;
            return { type: o2, components: i, alpha: n2 };
          }
        }
        function Kn(e2) {
          let t2 = le(e2, " ");
          if (!t2)
            return;
          let r2 = t2.length;
          if (t2[r2 - 2] === "/")
            return { components: t2.slice(0, r2 - 2), alpha: t2[r2 - 1] };
          if (t2[r2 - 2] != null && (t2[r2 - 2].endsWith("/") || t2[r2 - 1].startsWith("/"))) {
            let i = t2.splice(r2 - 2);
            t2.push(i.join(" ")), --r2;
          }
          let n2 = le(t2[r2 - 1], "/", 2);
          if (!n2)
            return;
          if (n2.length === 1 || n2[n2.length - 1] === "")
            return { components: t2 };
          let o2 = n2.pop();
          return t2[r2 - 1] = n2.join("/"), { components: t2, alpha: o2 };
        }
        function st2(e2) {
          let t2 = function(n2) {
            var _a3;
            let o2 = ((_a3 = this.__options) == null ? void 0 : _a3.sequence) || [];
            this.__options.sequence = [];
            for (let i of o2) {
              let a = e2[i](n2);
              if (a != null)
                return a;
            }
          };
          function r2(n2, o2) {
            return n2.__options || (n2.__options = { sequence: [] }), n2.__options.sequence.push(o2), n2;
          }
          for (let n2 of Object.keys(e2))
            Object.defineProperty(t2, n2, {
              enumerable: true,
              get() {
                return r2(this, n2);
              }
            });
          return t2;
        }
        function I2(e2, t2) {
          let r2;
          return {
            name: e2,
            match(n2, o2) {
              r2 || (r2 = new RegExp(
                `^${re(e2)}(?:${o2.generator.config.separators.join("|")})`
              ));
              let i = n2.match(r2);
              if (i)
                return {
                  matcher: n2.slice(i[0].length),
                  handle: (a, s2) => s2({ ...a, ...t2(a) })
                };
            },
            autocomplete: `${e2}:`
          };
        }
        function U2(e2, t2) {
          let r2;
          return {
            name: e2,
            match(n2, o2) {
              r2 || (r2 = new RegExp(
                `^${re(e2)}(?:${o2.generator.config.separators.join("|")})`
              ));
              let i = n2.match(r2);
              if (i)
                return {
                  matcher: n2.slice(i[0].length),
                  handle: (a, s2) => s2({ ...a, parent: `${a.parent ? `${a.parent} $$ ` : ""}${t2}` })
                };
            },
            autocomplete: `${e2}:`
          };
        }
        function ie(e2, t2, r2) {
          if (t2.startsWith(`${e2}[`)) {
            let [n2, o2] = ve2(t2.slice(e2.length), "[", "]") ?? [];
            if (n2 && o2) {
              for (let i of r2)
                if (o2.startsWith(i))
                  return [n2, o2.slice(i.length), i];
              return [n2, o2, ""];
            }
          }
        }
        function L(e2, t2, r2) {
          if (t2.startsWith(e2)) {
            let n2 = ie(e2, t2, r2);
            if (n2) {
              let [o2 = "", i = n2[1]] = L("/", n2[1], r2) ?? [];
              return [n2[0], i, o2];
            }
            for (let o2 of r2.filter((i) => i !== "/")) {
              let i = t2.indexOf(o2, e2.length);
              if (i !== -1) {
                let a = t2.indexOf("/", e2.length), s2 = a === -1 || i <= a;
                return [
                  t2.slice(e2.length, s2 ? i : a),
                  t2.slice(i + o2.length),
                  s2 ? "" : t2.slice(a + 1, i)
                ];
              }
            }
          }
        }
        var Gn = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Hn = new Uint8Array(64), Ys = new Uint8Array(128);
        for (let e2 = 0; e2 < Gn.length; e2++) {
          let t2 = Gn.charCodeAt(e2);
          Hn[e2] = t2, Ys[t2] = e2;
        }
        var Lr = typeof TextDecoder < "u" ? new TextDecoder() : typeof Buffer < "u" ? {
          decode(e2) {
            return Buffer.from(
              e2.buffer,
              e2.byteOffset,
              e2.byteLength
            ).toString();
          }
        } : {
          decode(e2) {
            let t2 = "";
            for (let r2 = 0; r2 < e2.length; r2++)
              t2 += String.fromCharCode(e2[r2]);
            return t2;
          }
        };
        function qn(e2) {
          let t2 = new Int32Array(5), r2 = 1024 * 16, n2 = r2 - 36, o2 = new Uint8Array(r2), i = o2.subarray(0, n2), a = 0, s2 = "";
          for (let c = 0; c < e2.length; c++) {
            let f = e2[c];
            if (c > 0 && (a === r2 && (s2 += Lr.decode(o2), a = 0), o2[a++] = 59), f.length !== 0) {
              t2[0] = 0;
              for (let u = 0; u < f.length; u++) {
                let p2 = f[u];
                a > n2 && (s2 += Lr.decode(i), o2.copyWithin(0, n2, a), a -= n2), u > 0 && (o2[a++] = 44), a = _e(o2, a, t2, p2, 0), p2.length !== 1 && (a = _e(o2, a, t2, p2, 1), a = _e(o2, a, t2, p2, 2), a = _e(o2, a, t2, p2, 3), p2.length !== 4 && (a = _e(o2, a, t2, p2, 4)));
              }
            }
          }
          return s2 + Lr.decode(o2.subarray(0, a));
        }
        function _e(e2, t2, r2, n2, o2) {
          let i = n2[o2], a = i - r2[o2];
          r2[o2] = i, a = a < 0 ? -a << 1 | 1 : a << 1;
          do {
            let s2 = a & 31;
            a >>>= 5, a > 0 && (s2 |= 32), e2[t2++] = Hn[s2];
          } while (a > 0);
          return t2;
        }
        var ct2 = class e2 {
          constructor(t2) {
            this.bits = t2 instanceof e2 ? t2.bits.slice() : [];
          }
          add(t2) {
            this.bits[t2 >> 5] |= 1 << (t2 & 31);
          }
          has(t2) {
            return !!(this.bits[t2 >> 5] & 1 << (t2 & 31));
          }
        }, lt2 = class e2 {
          constructor(t2, r2, n2) {
            this.start = t2, this.end = r2, this.original = n2, this.intro = "", this.outro = "", this.content = n2, this.storeName = false, this.edited = false, this.previous = null, this.next = null;
          }
          appendLeft(t2) {
            this.outro += t2;
          }
          appendRight(t2) {
            this.intro = this.intro + t2;
          }
          clone() {
            let t2 = new e2(this.start, this.end, this.original);
            return t2.intro = this.intro, t2.outro = this.outro, t2.content = this.content, t2.storeName = this.storeName, t2.edited = this.edited, t2;
          }
          contains(t2) {
            return this.start < t2 && t2 < this.end;
          }
          eachNext(t2) {
            let r2 = this;
            for (; r2; )
              t2(r2), r2 = r2.next;
          }
          eachPrevious(t2) {
            let r2 = this;
            for (; r2; )
              t2(r2), r2 = r2.previous;
          }
          edit(t2, r2, n2) {
            return this.content = t2, n2 || (this.intro = "", this.outro = ""), this.storeName = r2, this.edited = true, this;
          }
          prependLeft(t2) {
            this.outro = t2 + this.outro;
          }
          prependRight(t2) {
            this.intro = t2 + this.intro;
          }
          split(t2) {
            let r2 = t2 - this.start, n2 = this.original.slice(0, r2), o2 = this.original.slice(r2);
            this.original = n2;
            let i = new e2(t2, this.end, o2);
            return i.outro = this.outro, this.outro = "", this.end = t2, this.edited ? (i.edit("", false), this.content = "") : this.content = n2, i.next = this.next, i.next && (i.next.previous = i), i.previous = this, this.next = i, i;
          }
          toString() {
            return this.intro + this.content + this.outro;
          }
          trimEnd(t2) {
            if (this.outro = this.outro.replace(t2, ""), this.outro.length)
              return true;
            let r2 = this.content.replace(t2, "");
            if (r2.length)
              return r2 !== this.content && (this.split(this.start + r2.length).edit("", void 0, true), this.edited && this.edit(r2, this.storeName, true)), true;
            if (this.edit("", void 0, true), this.intro = this.intro.replace(t2, ""), this.intro.length)
              return true;
          }
          trimStart(t2) {
            if (this.intro = this.intro.replace(t2, ""), this.intro.length)
              return true;
            let r2 = this.content.replace(t2, "");
            if (r2.length) {
              if (r2 !== this.content) {
                let n2 = this.split(this.end - r2.length);
                this.edited && n2.edit(r2, this.storeName, true), this.edit("", void 0, true);
              }
              return true;
            } else if (this.edit("", void 0, true), this.outro = this.outro.replace(t2, ""), this.outro.length)
              return true;
          }
        };
        function Xs() {
          return typeof window < "u" && typeof window.btoa == "function" ? (e2) => window.btoa(unescape(encodeURIComponent(e2))) : typeof Buffer == "function" ? (e2) => Buffer.from(e2, "utf-8").toString("base64") : () => {
            throw new Error(
              "Unsupported environment: `window.btoa` or `Buffer` should be supported."
            );
          };
        }
        var Zs = Xs(), Wr = class {
          constructor(t2) {
            this.version = 3, this.file = t2.file, this.sources = t2.sources, this.sourcesContent = t2.sourcesContent, this.names = t2.names, this.mappings = qn(t2.mappings), typeof t2.x_google_ignoreList < "u" && (this.x_google_ignoreList = t2.x_google_ignoreList);
          }
          toString() {
            return JSON.stringify(this);
          }
          toUrl() {
            return "data:application/json;charset=utf-8;base64," + Zs(this.toString());
          }
        };
        function Js(e2) {
          let t2 = e2.split(`
`), r2 = t2.filter((i) => /^\t+/.test(i)), n2 = t2.filter((i) => /^ {2,}/.test(i));
          if (r2.length === 0 && n2.length === 0)
            return null;
          if (r2.length >= n2.length)
            return "	";
          let o2 = n2.reduce((i, a) => {
            let s2 = /^ +/.exec(a)[0].length;
            return Math.min(s2, i);
          }, 1 / 0);
          return new Array(o2 + 1).join(" ");
        }
        function Qs(e2, t2) {
          let r2 = e2.split(/[/\\]/), n2 = t2.split(/[/\\]/);
          for (r2.pop(); r2[0] === n2[0]; )
            r2.shift(), n2.shift();
          if (r2.length) {
            let o2 = r2.length;
            for (; o2--; )
              r2[o2] = "..";
          }
          return r2.concat(n2).join("/");
        }
        var ec = Object.prototype.toString;
        function tc(e2) {
          return ec.call(e2) === "[object Object]";
        }
        function Yn(e2) {
          let t2 = e2.split(`
`), r2 = [];
          for (let n2 = 0, o2 = 0; n2 < t2.length; n2++)
            r2.push(o2), o2 += t2[n2].length + 1;
          return function(o2) {
            let i = 0, a = r2.length;
            for (; i < a; ) {
              let f = i + a >> 1;
              o2 < r2[f] ? a = f : i = f + 1;
            }
            let s2 = i - 1, c = o2 - r2[s2];
            return { line: s2, column: c };
          };
        }
        var rc = /\w/, Nr = class {
          constructor(t2) {
            this.hires = t2, this.generatedCodeLine = 0, this.generatedCodeColumn = 0, this.raw = [], this.rawSegments = this.raw[this.generatedCodeLine] = [], this.pending = null;
          }
          addEdit(t2, r2, n2, o2) {
            if (r2.length) {
              let i = r2.indexOf(
                `
`,
                0
              ), a = -1;
              for (; i >= 0; ) {
                let c = [this.generatedCodeColumn, t2, n2.line, n2.column];
                o2 >= 0 && c.push(o2), this.rawSegments.push(c), this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, a = i, i = r2.indexOf(
                  `
`,
                  i + 1
                );
              }
              let s2 = [this.generatedCodeColumn, t2, n2.line, n2.column];
              o2 >= 0 && s2.push(o2), this.rawSegments.push(s2), this.advance(r2.slice(a + 1));
            } else
              this.pending && (this.rawSegments.push(this.pending), this.advance(r2));
            this.pending = null;
          }
          addUneditedChunk(t2, r2, n2, o2, i) {
            let a = r2.start, s2 = true, c = false;
            for (; a < r2.end; ) {
              if (this.hires || s2 || i.has(a)) {
                let f = [this.generatedCodeColumn, t2, o2.line, o2.column];
                this.hires === "boundary" ? rc.test(n2[a]) ? c || (this.rawSegments.push(f), c = true) : (this.rawSegments.push(f), c = false) : this.rawSegments.push(f);
              }
              n2[a] === `
` ? (o2.line += 1, o2.column = 0, this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, s2 = true) : (o2.column += 1, this.generatedCodeColumn += 1, s2 = false), a += 1;
            }
            this.pending = null;
          }
          advance(t2) {
            if (!t2)
              return;
            let r2 = t2.split(`
`);
            if (r2.length > 1) {
              for (let n2 = 0; n2 < r2.length - 1; n2++)
                this.generatedCodeLine++, this.raw[this.generatedCodeLine] = this.rawSegments = [];
              this.generatedCodeColumn = 0;
            }
            this.generatedCodeColumn += r2[r2.length - 1].length;
          }
        }, Pe2 = `
`, we2 = { insertLeft: false, insertRight: false, storeName: false }, ft2 = class e2 {
          constructor(t2, r2 = {}) {
            let n2 = new lt2(0, t2.length, t2);
            Object.defineProperties(this, {
              original: { writable: true, value: t2 },
              outro: { writable: true, value: "" },
              intro: { writable: true, value: "" },
              firstChunk: { writable: true, value: n2 },
              lastChunk: { writable: true, value: n2 },
              lastSearchedChunk: { writable: true, value: n2 },
              byStart: { writable: true, value: {} },
              byEnd: { writable: true, value: {} },
              filename: { writable: true, value: r2.filename },
              indentExclusionRanges: {
                writable: true,
                value: r2.indentExclusionRanges
              },
              sourcemapLocations: { writable: true, value: new ct2() },
              storedNames: { writable: true, value: {} },
              indentStr: { writable: true, value: void 0 },
              ignoreList: { writable: true, value: r2.ignoreList }
            }), this.byStart[0] = n2, this.byEnd[t2.length] = n2;
          }
          addSourcemapLocation(t2) {
            this.sourcemapLocations.add(t2);
          }
          append(t2) {
            if (typeof t2 != "string")
              throw new TypeError("outro content must be a string");
            return this.outro += t2, this;
          }
          appendLeft(t2, r2) {
            if (typeof r2 != "string")
              throw new TypeError("inserted content must be a string");
            this._split(t2);
            let n2 = this.byEnd[t2];
            return n2 ? n2.appendLeft(r2) : this.intro += r2, this;
          }
          appendRight(t2, r2) {
            if (typeof r2 != "string")
              throw new TypeError("inserted content must be a string");
            this._split(t2);
            let n2 = this.byStart[t2];
            return n2 ? n2.appendRight(r2) : this.outro += r2, this;
          }
          clone() {
            let t2 = new e2(this.original, { filename: this.filename }), r2 = this.firstChunk, n2 = t2.firstChunk = t2.lastSearchedChunk = r2.clone();
            for (; r2; ) {
              t2.byStart[n2.start] = n2, t2.byEnd[n2.end] = n2;
              let o2 = r2.next, i = o2 && o2.clone();
              i && (n2.next = i, i.previous = n2, n2 = i), r2 = o2;
            }
            return t2.lastChunk = n2, this.indentExclusionRanges && (t2.indentExclusionRanges = this.indentExclusionRanges.slice()), t2.sourcemapLocations = new ct2(this.sourcemapLocations), t2.intro = this.intro, t2.outro = this.outro, t2;
          }
          generateDecodedMap(t2) {
            t2 = t2 || {};
            let r2 = 0, n2 = Object.keys(this.storedNames), o2 = new Nr(t2.hires), i = Yn(this.original);
            return this.intro && o2.advance(this.intro), this.firstChunk.eachNext((a) => {
              let s2 = i(a.start);
              a.intro.length && o2.advance(a.intro), a.edited ? o2.addEdit(
                r2,
                a.content,
                s2,
                a.storeName ? n2.indexOf(a.original) : -1
              ) : o2.addUneditedChunk(
                r2,
                a,
                this.original,
                s2,
                this.sourcemapLocations
              ), a.outro.length && o2.advance(a.outro);
            }), {
              file: t2.file ? t2.file.split(/[/\\]/).pop() : void 0,
              sources: [t2.source ? Qs(t2.file || "", t2.source) : t2.file || ""],
              sourcesContent: t2.includeContent ? [this.original] : void 0,
              names: n2,
              mappings: o2.raw,
              x_google_ignoreList: this.ignoreList ? [r2] : void 0
            };
          }
          generateMap(t2) {
            return new Wr(this.generateDecodedMap(t2));
          }
          _ensureindentStr() {
            this.indentStr === void 0 && (this.indentStr = Js(this.original));
          }
          _getRawIndentString() {
            return this._ensureindentStr(), this.indentStr;
          }
          getIndentString() {
            return this._ensureindentStr(), this.indentStr === null ? "	" : this.indentStr;
          }
          indent(t2, r2) {
            let n2 = /^[^\r\n]/gm;
            if (tc(t2) && (r2 = t2, t2 = void 0), t2 === void 0 && (this._ensureindentStr(), t2 = this.indentStr || "	"), t2 === "")
              return this;
            r2 = r2 || {};
            let o2 = {};
            r2.exclude && (typeof r2.exclude[0] == "number" ? [r2.exclude] : r2.exclude).forEach(
              (u) => {
                for (let p2 = u[0]; p2 < u[1]; p2 += 1)
                  o2[p2] = true;
              }
            );
            let i = r2.indentStart !== false, a = (f) => i ? `${t2}${f}` : (i = true, f);
            this.intro = this.intro.replace(n2, a);
            let s2 = 0, c = this.firstChunk;
            for (; c; ) {
              let f = c.end;
              if (c.edited)
                o2[s2] || (c.content = c.content.replace(n2, a), c.content.length && (i = c.content[c.content.length - 1] === `
`));
              else
                for (s2 = c.start; s2 < f; ) {
                  if (!o2[s2]) {
                    let u = this.original[s2];
                    u === `
` ? i = true : u !== "\r" && i && (i = false, s2 === c.start || (this._splitChunk(c, s2), c = c.next), c.prependRight(t2));
                  }
                  s2 += 1;
                }
              s2 = c.end, c = c.next;
            }
            return this.outro = this.outro.replace(n2, a), this;
          }
          insert() {
            throw new Error(
              "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
            );
          }
          insertLeft(t2, r2) {
            return we2.insertLeft || (console.warn(
              "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
            ), we2.insertLeft = true), this.appendLeft(t2, r2);
          }
          insertRight(t2, r2) {
            return we2.insertRight || (console.warn(
              "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
            ), we2.insertRight = true), this.prependRight(t2, r2);
          }
          move(t2, r2, n2) {
            if (n2 >= t2 && n2 <= r2)
              throw new Error("Cannot move a selection inside itself");
            this._split(t2), this._split(r2), this._split(n2);
            let o2 = this.byStart[t2], i = this.byEnd[r2], a = o2.previous, s2 = i.next, c = this.byStart[n2];
            if (!c && i === this.lastChunk)
              return this;
            let f = c ? c.previous : this.lastChunk;
            return a && (a.next = s2), s2 && (s2.previous = a), f && (f.next = o2), c && (c.previous = i), o2.previous || (this.firstChunk = i.next), i.next || (this.lastChunk = o2.previous, this.lastChunk.next = null), o2.previous = f, i.next = c || null, f || (this.firstChunk = o2), c || (this.lastChunk = i), this;
          }
          overwrite(t2, r2, n2, o2) {
            return o2 = o2 || {}, this.update(t2, r2, n2, { ...o2, overwrite: !o2.contentOnly });
          }
          update(t2, r2, n2, o2) {
            if (typeof n2 != "string")
              throw new TypeError("replacement content must be a string");
            for (; t2 < 0; )
              t2 += this.original.length;
            for (; r2 < 0; )
              r2 += this.original.length;
            if (r2 > this.original.length)
              throw new Error("end is out of bounds");
            if (t2 === r2)
              throw new Error(
                "Cannot overwrite a zero-length range – use appendLeft or prependRight instead"
              );
            this._split(t2), this._split(r2), o2 === true && (we2.storeName || (console.warn(
              "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
            ), we2.storeName = true), o2 = { storeName: true });
            let i = o2 !== void 0 ? o2.storeName : false, a = o2 !== void 0 ? o2.overwrite : false;
            if (i) {
              let f = this.original.slice(t2, r2);
              Object.defineProperty(this.storedNames, f, {
                writable: true,
                value: true,
                enumerable: true
              });
            }
            let s2 = this.byStart[t2], c = this.byEnd[r2];
            if (s2) {
              let f = s2;
              for (; f !== c; ) {
                if (f.next !== this.byStart[f.end])
                  throw new Error("Cannot overwrite across a split point");
                f = f.next, f.edit("", false);
              }
              s2.edit(n2, i, !a);
            } else {
              let f = new lt2(t2, r2, "").edit(n2, i);
              c.next = f, f.previous = c;
            }
            return this;
          }
          prepend(t2) {
            if (typeof t2 != "string")
              throw new TypeError("outro content must be a string");
            return this.intro = t2 + this.intro, this;
          }
          prependLeft(t2, r2) {
            if (typeof r2 != "string")
              throw new TypeError("inserted content must be a string");
            this._split(t2);
            let n2 = this.byEnd[t2];
            return n2 ? n2.prependLeft(r2) : this.intro = r2 + this.intro, this;
          }
          prependRight(t2, r2) {
            if (typeof r2 != "string")
              throw new TypeError("inserted content must be a string");
            this._split(t2);
            let n2 = this.byStart[t2];
            return n2 ? n2.prependRight(r2) : this.outro = r2 + this.outro, this;
          }
          remove(t2, r2) {
            for (; t2 < 0; )
              t2 += this.original.length;
            for (; r2 < 0; )
              r2 += this.original.length;
            if (t2 === r2)
              return this;
            if (t2 < 0 || r2 > this.original.length)
              throw new Error("Character is out of bounds");
            if (t2 > r2)
              throw new Error("end must be greater than start");
            this._split(t2), this._split(r2);
            let n2 = this.byStart[t2];
            for (; n2; )
              n2.intro = "", n2.outro = "", n2.edit(""), n2 = r2 > n2.end ? this.byStart[n2.end] : null;
            return this;
          }
          lastChar() {
            if (this.outro.length)
              return this.outro[this.outro.length - 1];
            let t2 = this.lastChunk;
            do {
              if (t2.outro.length)
                return t2.outro[t2.outro.length - 1];
              if (t2.content.length)
                return t2.content[t2.content.length - 1];
              if (t2.intro.length)
                return t2.intro[t2.intro.length - 1];
            } while (t2 = t2.previous);
            return this.intro.length ? this.intro[this.intro.length - 1] : "";
          }
          lastLine() {
            let t2 = this.outro.lastIndexOf(Pe2);
            if (t2 !== -1)
              return this.outro.substr(t2 + 1);
            let r2 = this.outro, n2 = this.lastChunk;
            do {
              if (n2.outro.length > 0) {
                if (t2 = n2.outro.lastIndexOf(Pe2), t2 !== -1)
                  return n2.outro.substr(t2 + 1) + r2;
                r2 = n2.outro + r2;
              }
              if (n2.content.length > 0) {
                if (t2 = n2.content.lastIndexOf(Pe2), t2 !== -1)
                  return n2.content.substr(t2 + 1) + r2;
                r2 = n2.content + r2;
              }
              if (n2.intro.length > 0) {
                if (t2 = n2.intro.lastIndexOf(Pe2), t2 !== -1)
                  return n2.intro.substr(t2 + 1) + r2;
                r2 = n2.intro + r2;
              }
            } while (n2 = n2.previous);
            return t2 = this.intro.lastIndexOf(Pe2), t2 !== -1 ? this.intro.substr(t2 + 1) + r2 : this.intro + r2;
          }
          slice(t2 = 0, r2 = this.original.length) {
            for (; t2 < 0; )
              t2 += this.original.length;
            for (; r2 < 0; )
              r2 += this.original.length;
            let n2 = "", o2 = this.firstChunk;
            for (; o2 && (o2.start > t2 || o2.end <= t2); ) {
              if (o2.start < r2 && o2.end >= r2)
                return n2;
              o2 = o2.next;
            }
            if (o2 && o2.edited && o2.start !== t2)
              throw new Error(
                `Cannot use replaced character ${t2} as slice start anchor.`
              );
            let i = o2;
            for (; o2; ) {
              o2.intro && (i !== o2 || o2.start === t2) && (n2 += o2.intro);
              let a = o2.start < r2 && o2.end >= r2;
              if (a && o2.edited && o2.end !== r2)
                throw new Error(
                  `Cannot use replaced character ${r2} as slice end anchor.`
                );
              let s2 = i === o2 ? t2 - o2.start : 0, c = a ? o2.content.length + r2 - o2.end : o2.content.length;
              if (n2 += o2.content.slice(s2, c), o2.outro && (!a || o2.end === r2) && (n2 += o2.outro), a)
                break;
              o2 = o2.next;
            }
            return n2;
          }
          snip(t2, r2) {
            let n2 = this.clone();
            return n2.remove(0, t2), n2.remove(r2, n2.original.length), n2;
          }
          _split(t2) {
            if (this.byStart[t2] || this.byEnd[t2])
              return;
            let r2 = this.lastSearchedChunk, n2 = t2 > r2.end;
            for (; r2; ) {
              if (r2.contains(t2))
                return this._splitChunk(r2, t2);
              r2 = n2 ? this.byStart[r2.end] : this.byEnd[r2.start];
            }
          }
          _splitChunk(t2, r2) {
            if (t2.edited && t2.content.length) {
              let o2 = Yn(this.original)(r2);
              throw new Error(
                `Cannot split a chunk that has already been edited (${o2.line}:${o2.column} – "${t2.original}")`
              );
            }
            let n2 = t2.split(r2);
            return this.byEnd[r2] = t2, this.byStart[r2] = n2, this.byEnd[n2.end] = n2, t2 === this.lastChunk && (this.lastChunk = n2), this.lastSearchedChunk = t2, true;
          }
          toString() {
            let t2 = this.intro, r2 = this.firstChunk;
            for (; r2; )
              t2 += r2.toString(), r2 = r2.next;
            return t2 + this.outro;
          }
          isEmpty() {
            let t2 = this.firstChunk;
            do
              if (t2.intro.length && t2.intro.trim() || t2.content.length && t2.content.trim() || t2.outro.length && t2.outro.trim())
                return false;
            while (t2 = t2.next);
            return true;
          }
          length() {
            let t2 = this.firstChunk, r2 = 0;
            do
              r2 += t2.intro.length + t2.content.length + t2.outro.length;
            while (t2 = t2.next);
            return r2;
          }
          trimLines() {
            return this.trim("[\\r\\n]");
          }
          trim(t2) {
            return this.trimStart(t2).trimEnd(t2);
          }
          trimEndAborted(t2) {
            let r2 = new RegExp((t2 || "\\s") + "+$");
            if (this.outro = this.outro.replace(r2, ""), this.outro.length)
              return true;
            let n2 = this.lastChunk;
            do {
              let o2 = n2.end, i = n2.trimEnd(r2);
              if (n2.end !== o2 && (this.lastChunk === n2 && (this.lastChunk = n2.next), this.byEnd[n2.end] = n2, this.byStart[n2.next.start] = n2.next, this.byEnd[n2.next.end] = n2.next), i)
                return true;
              n2 = n2.previous;
            } while (n2);
            return false;
          }
          trimEnd(t2) {
            return this.trimEndAborted(t2), this;
          }
          trimStartAborted(t2) {
            let r2 = new RegExp("^" + (t2 || "\\s") + "+");
            if (this.intro = this.intro.replace(r2, ""), this.intro.length)
              return true;
            let n2 = this.firstChunk;
            do {
              let o2 = n2.end, i = n2.trimStart(r2);
              if (n2.end !== o2 && (n2 === this.lastChunk && (this.lastChunk = n2.next), this.byEnd[n2.end] = n2, this.byStart[n2.next.start] = n2.next, this.byEnd[n2.next.end] = n2.next), i)
                return true;
              n2 = n2.next;
            } while (n2);
            return false;
          }
          trimStart(t2) {
            return this.trimStartAborted(t2), this;
          }
          hasChanged() {
            return this.original !== this.toString();
          }
          _replaceRegexp(t2, r2) {
            function n2(i, a) {
              return typeof r2 == "string" ? r2.replace(
                /\$(\$|&|\d+)/g,
                (s2, c) => c === "$" ? "$" : c === "&" ? i[0] : +c < i.length ? i[+c] : `$${c}`
              ) : r2(...i, i.index, a, i.groups);
            }
            function o2(i, a) {
              let s2, c = [];
              for (; s2 = i.exec(a); )
                c.push(s2);
              return c;
            }
            if (t2.global)
              o2(t2, this.original).forEach((a) => {
                a.index != null && this.overwrite(
                  a.index,
                  a.index + a[0].length,
                  n2(a, this.original)
                );
              });
            else {
              let i = this.original.match(t2);
              i && i.index != null && this.overwrite(i.index, i.index + i[0].length, n2(i, this.original));
            }
            return this;
          }
          _replaceString(t2, r2) {
            let { original: n2 } = this, o2 = n2.indexOf(t2);
            return o2 !== -1 && this.overwrite(o2, o2 + t2.length, r2), this;
          }
          replace(t2, r2) {
            return typeof t2 == "string" ? this._replaceString(t2, r2) : this._replaceRegexp(t2, r2);
          }
          _replaceAllString(t2, r2) {
            let { original: n2 } = this, o2 = t2.length;
            for (let i = n2.indexOf(t2); i !== -1; i = n2.indexOf(t2, i + o2))
              this.overwrite(i, i + o2, r2);
            return this;
          }
          replaceAll(t2, r2) {
            if (typeof t2 == "string")
              return this._replaceAllString(t2, r2);
            if (!t2.global)
              throw new TypeError(
                "MagicString.prototype.replaceAll called with a non-global RegExp argument"
              );
            return this._replaceRegexp(t2, r2);
          }
        };
        var nc = /theme\(\s*['"]?(.*?)['"]?\s*\)/g;
        function Xn(e2) {
          return e2.includes("theme(") && e2.includes(")");
        }
        function Zn(e2, t2, r2 = true) {
          let n2 = Array.from(e2.toString().matchAll(nc));
          if (!n2.length)
            return e2;
          let o2 = new ft2(e2);
          for (let i of n2) {
            let a = i[1];
            if (!a)
              throw new Error("theme() expect exact one argument, but got 0");
            let [s2, c] = a.split("/"), u = s2.trim().split(".").reduce((p2, d) => p2 == null ? void 0 : p2[d], t2);
            if (typeof u == "string") {
              if (c) {
                let p2 = G2(u);
                p2 && (u = A(p2, c));
              }
              o2.overwrite(i.index, i.index + i[0].length, u);
            } else if (r2)
              throw new Error(`theme of "${a}" did not found`);
          }
          return o2.toString();
        }
        var Ir = {};
        ys(Ir, {
          auto: () => ac,
          bracket: () => pc,
          bracketOfColor: () => dc,
          bracketOfLength: () => mc,
          bracketOfPosition: () => hc,
          cssvar: () => gc,
          degree: () => xc,
          fraction: () => uc,
          global: () => yc,
          number: () => lc,
          numberWithUnit: () => ic,
          percent: () => fc,
          position: () => wc,
          properties: () => vc,
          px: () => cc,
          rem: () => sc,
          time: () => bc
        });
        var $e = /^(-?\d*(?:\.\d+)?)(px|pt|pc|%|r?(?:em|ex|lh|cap|ch|ic)|(?:[sld]?v|cq)(?:[whib]|min|max)|in|cm|mm|rpx)?$/i, Br = /^(-?\d*(?:\.\d+)?)$/i, Dr = /^(px)$/i, ut2 = /^\[(color|length|position|quoted|string):/i;
        var oc = [
          "color",
          "border-color",
          "background-color",
          "flex-grow",
          "flex",
          "flex-shrink",
          "caret-color",
          "font",
          "gap",
          "opacity",
          "visibility",
          "z-index",
          "font-weight",
          "zoom",
          "text-shadow",
          "transform",
          "box-shadow",
          "background-position",
          "left",
          "right",
          "top",
          "bottom",
          "object-position",
          "max-height",
          "min-height",
          "max-width",
          "min-width",
          "height",
          "width",
          "border-width",
          "margin",
          "padding",
          "outline-width",
          "outline-offset",
          "font-size",
          "line-height",
          "text-indent",
          "vertical-align",
          "border-spacing",
          "letter-spacing",
          "word-spacing",
          "stroke",
          "filter",
          "backdrop-filter",
          "fill",
          "mask",
          "mask-size",
          "mask-border",
          "clip-path",
          "clip",
          "border-radius"
        ];
        function H2(e2) {
          return e2.toFixed(10).replace(/\.0+$/, "").replace(/(\.\d+?)0+$/, "$1");
        }
        function ic(e2) {
          let t2 = e2.match($e);
          if (!t2)
            return;
          let [, r2, n2] = t2, o2 = Number.parseFloat(r2);
          if (n2 && !Number.isNaN(o2))
            return `${H2(o2)}${n2}`;
        }
        function ac(e2) {
          if (e2 === "auto" || e2 === "a")
            return "auto";
        }
        function sc(e2) {
          if (Dr.test(e2))
            return `1${e2}`;
          let t2 = e2.match($e);
          if (!t2)
            return;
          let [, r2, n2] = t2, o2 = Number.parseFloat(r2);
          if (!Number.isNaN(o2))
            return o2 === 0 ? "0" : n2 ? `${H2(o2)}${n2}` : `${H2(o2 / 4)}rem`;
        }
        function cc(e2) {
          if (Dr.test(e2))
            return `1${e2}`;
          let t2 = e2.match($e);
          if (!t2)
            return;
          let [, r2, n2] = t2, o2 = Number.parseFloat(r2);
          if (!Number.isNaN(o2))
            return n2 ? `${H2(o2)}${n2}` : `${H2(o2)}px`;
        }
        function lc(e2) {
          if (!Br.test(e2))
            return;
          let t2 = Number.parseFloat(e2);
          if (!Number.isNaN(t2))
            return H2(t2);
        }
        function fc(e2) {
          if (e2.endsWith("%") && (e2 = e2.slice(0, -1)), !Br.test(e2))
            return;
          let t2 = Number.parseFloat(e2);
          if (!Number.isNaN(t2))
            return `${H2(t2 / 100)}`;
        }
        function uc(e2) {
          if (e2 === "full")
            return "100%";
          let [t2, r2] = e2.split("/"), n2 = Number.parseFloat(t2) / Number.parseFloat(r2);
          if (!Number.isNaN(n2))
            return n2 === 0 ? "0" : `${H2(n2 * 100)}%`;
        }
        function pt2(e2, t2) {
          if (e2 && e2.startsWith("[") && e2.endsWith("]")) {
            let r2, n2, o2 = e2.match(ut2);
            if (o2 ? (t2 || (n2 = o2[1]), r2 = e2.slice(o2[0].length, -1)) : r2 = e2.slice(1, -1), !r2 || r2 === '=""')
              return;
            r2.startsWith("--") && (r2 = `var(${r2})`);
            let i = 0;
            for (let a of r2)
              if (a === "[")
                i += 1;
              else if (a === "]" && (i -= 1, i < 0))
                return;
            if (i)
              return;
            switch (n2) {
              case "string":
                return r2.replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_");
              case "quoted":
                return r2.replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_").replace(/(["\\])/g, "\\$1").replace(/^(.+)$/, '"$1"');
            }
            return r2.replace(/(url\(.*?\))/g, (a) => a.replace(/_/g, "\\_")).replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_").replace(/(?:calc|clamp|max|min)\((.*)/g, (a) => {
              let s2 = [];
              return a.replace(
                /var\((--.+?)[,)]/g,
                (c, f) => (s2.push(f), c.replace(f, "--un-calc"))
              ).replace(
                /(-?\d*\.?\d(?!\b-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g,
                "$1 $2 "
              ).replace(/--un-calc/g, () => s2.shift());
            });
          }
        }
        function pc(e2) {
          return pt2(e2);
        }
        function dc(e2) {
          return pt2(e2, "color");
        }
        function mc(e2) {
          return pt2(e2, "length");
        }
        function hc(e2) {
          return pt2(e2, "position");
        }
        function gc(e2) {
          if (/^\$[^\s'"`;{}]/.test(e2)) {
            let [t2, r2] = e2.slice(1).split(",");
            return `var(--${Q2(t2)}${r2 ? `, ${r2}` : ""})`;
          }
        }
        function bc(e2) {
          let t2 = e2.match(/^(-?[0-9.]+)(s|ms)?$/i);
          if (!t2)
            return;
          let [, r2, n2] = t2, o2 = Number.parseFloat(r2);
          if (!Number.isNaN(o2))
            return o2 === 0 && !n2 ? "0s" : n2 ? `${H2(o2)}${n2}` : `${H2(o2)}ms`;
        }
        function xc(e2) {
          let t2 = e2.match(/^(-?[0-9.]+)(deg|rad|grad|turn)?$/i);
          if (!t2)
            return;
          let [, r2, n2] = t2, o2 = Number.parseFloat(r2);
          if (!Number.isNaN(o2))
            return o2 === 0 ? "0" : n2 ? `${H2(o2)}${n2}` : `${H2(o2)}deg`;
        }
        function yc(e2) {
          if (S.includes(e2))
            return e2;
        }
        function vc(e2) {
          if (e2.split(",").every((t2) => oc.includes(t2)))
            return e2;
        }
        function wc(e2) {
          if (["top", "left", "right", "bottom", "center"].includes(e2))
            return e2;
        }
        var $c = st2(Ir), l2 = $c;
        var Jn = {
          mid: "middle",
          base: "baseline",
          btm: "bottom",
          baseline: "baseline",
          top: "top",
          start: "top",
          middle: "middle",
          bottom: "bottom",
          end: "bottom",
          "text-top": "text-top",
          "text-bottom": "text-bottom",
          sub: "sub",
          super: "super",
          ...Object.fromEntries(S.map((e2) => [e2, e2]))
        }, dt2 = [
          [
            /^(?:vertical|align|v)-([-\w]+%?)$/,
            ([, e2]) => ({ "vertical-align": Jn[e2] ?? l2.numberWithUnit(e2) }),
            {
              autocomplete: [
                `(vertical|align|v)-(${Object.keys(Jn).join("|")})`,
                "(vertical|align|v)-<percentage>"
              ]
            }
          ]
        ], mt2 = ["center", "left", "right", "justify", "start", "end"].map((e2) => [
          `text-${e2}`,
          { "text-align": e2 }
        ]);
        var eo = "$$mini-no-negative";
        function V(e2) {
          return ([t2, r2, n2], { theme: o2 }) => {
            var _a3;
            let i = ((_a3 = o2.spacing) == null ? void 0 : _a3[n2 || "DEFAULT"]) ?? l2.bracket.cssvar.global.auto.fraction.rem(n2);
            if (i != null)
              return F[r2].map((a) => [`${e2}${a}`, i]);
          };
        }
        function Qn(e2, t2, r2 = "colors") {
          let n2 = e2[r2], o2 = -1;
          for (let i of t2) {
            if (o2 += 1, n2 && typeof n2 != "string") {
              let a = t2.slice(o2).join("-").replace(/(-[a-z])/g, (s2) => s2.slice(1).toUpperCase());
              if (n2[a])
                return n2[a];
              if (n2[i]) {
                n2 = n2[i];
                continue;
              }
            }
            return;
          }
          return n2;
        }
        function ht2(e2, t2, r2) {
          return Qn(e2, t2, r2) || Qn(e2, t2, "colors");
        }
        function Kr(e2, t2) {
          let [r2, n2] = oe(e2, "[", "]", ["/", ":"]) ?? [];
          if (r2 != null) {
            let o2 = (r2.match(ut2) ?? [])[1];
            if (o2 == null || o2 === t2)
              return [r2, n2];
          }
        }
        function ke2(e2, t2, r2) {
          let n2 = Kr(e2, "color");
          if (!n2)
            return;
          let [o2, i] = n2, a = o2.replace(/([a-z])([0-9])/g, "$1-$2").split(/-/g), [s2] = a;
          if (!s2)
            return;
          let c, f = l2.bracketOfColor(o2), u = f || o2;
          if (l2.numberWithUnit(u))
            return;
          if (/^#[\da-fA-F]+/.test(u) ? c = u : /^hex-[\da-fA-F]+/.test(u) ? c = `#${u.slice(4)}` : o2.startsWith("$") && (c = l2.cssvar(o2)), c = c || f, !c) {
            let d = ht2(t2, [o2], r2);
            typeof d == "string" && (c = d);
          }
          let p2 = "DEFAULT";
          if (!c) {
            let d, [h2] = a.slice(-1);
            /^\d+$/.test(h2) ? (p2 = h2, d = ht2(t2, a.slice(0, -1), r2), !d || typeof d == "string" ? c = void 0 : c = d[p2]) : (d = ht2(t2, a, r2), !d && a.length <= 2 && ([, p2 = p2] = a, d = ht2(t2, [s2], r2)), typeof d == "string" ? c = d : p2 && d && (c = d[p2]));
          }
          return {
            opacity: i,
            name: s2,
            no: p2,
            color: c,
            cssColor: G2(c),
            alpha: l2.bracket.cssvar.percent(i ?? "")
          };
        }
        function j(e2, t2, r2, n2) {
          return ([, o2], { theme: i }) => {
            let a = ke2(o2, i, r2);
            if (!a)
              return;
            let { alpha: s2, color: c, cssColor: f } = a, u = {};
            if (f)
              if (s2 != null)
                u[e2] = A(f, s2);
              else {
                let p2 = `--un-${t2}-opacity`, d = A(f, `var(${p2})`);
                d.includes(p2) && (u[p2] = ee2(f)), u[e2] = d;
              }
            else if (c)
              if (s2 != null)
                u[e2] = A(c, s2);
              else {
                let p2 = `--un-${t2}-opacity`, d = A(c, `var(${p2})`);
                d.includes(p2) && (u[p2] = 1), u[e2] = d;
              }
            if ((n2 == null ? void 0 : n2(u)) !== false)
              return u;
          };
        }
        function Se2(e2, t2) {
          let r2 = [];
          e2 = _2(e2);
          for (let n2 = 0; n2 < e2.length; n2++) {
            let o2 = le(e2[n2], " ", 6);
            if (!o2 || o2.length < 3 || G2(o2.at(0)))
              return e2;
            let i = "";
            if (G2(o2.at(-1))) {
              let a = G2(o2.pop());
              a && (i = `, ${A(a)}`);
            }
            r2.push(`${o2.join(" ")} var(${t2}${i})`);
          }
          return r2;
        }
        function Ce(e2, t2, r2) {
          var _a3;
          return e2 != null && !!((_a3 = ke2(e2, t2, r2)) == null ? void 0 : _a3.color);
        }
        function fe2({ theme: e2, generator: t2 }, r2 = "breakpoints") {
          let n2;
          return t2.userConfig && t2.userConfig.theme && (n2 = t2.userConfig.theme[r2]), n2 || (n2 = e2[r2]), n2 ? Object.entries(n2).sort(
            (o2, i) => Number.parseInt(o2[1].replace(/[a-z]+/gi, "")) - Number.parseInt(i[1].replace(/[a-z]+/gi, ""))
          ).map(([o2, i]) => ({ point: o2, size: i })) : void 0;
        }
        function v(e2, t2) {
          return S.map((r2) => [`${e2}-${r2}`, { [t2 ?? e2]: r2 }]);
        }
        function q2(e2) {
          return e2 != null && Ve.test(e2);
        }
        function to(e2) {
          return e2[0] === "[" && e2.slice(-1) === "]" && (e2 = e2.slice(1, -1)), Ve.test(e2) || $e.test(e2);
        }
        var gt2 = [
          [
            /^outline-(?:width-|size-)?(.+)$/,
            ro,
            { autocomplete: "outline-(width|size)-<num>" }
          ],
          [/^outline-(?:color-)?(.+)$/, kc, { autocomplete: "outline-$colors" }],
          [
            /^outline-offset-(.+)$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "outline-offset": ((_a3 = t2.lineWidth) == null ? void 0 : _a3[e2]) ?? l2.bracket.cssvar.global.px(e2)
              };
            },
            { autocomplete: "outline-(offset)-<num>" }
          ],
          ["outline", { "outline-style": "solid" }],
          ...[
            "auto",
            "dashed",
            "dotted",
            "double",
            "hidden",
            "solid",
            "groove",
            "ridge",
            "inset",
            "outset",
            ...S
          ].map((e2) => [`outline-${e2}`, { "outline-style": e2 }]),
          [
            "outline-none",
            { outline: "2px solid transparent", "outline-offset": "2px" }
          ]
        ];
        function ro([, e2], { theme: t2 }) {
          var _a3;
          return {
            "outline-width": ((_a3 = t2.lineWidth) == null ? void 0 : _a3[e2]) ?? l2.bracket.cssvar.global.px(e2)
          };
        }
        function kc(e2, t2) {
          return q2(l2.bracket(e2[1])) ? ro(e2, t2) : j("outline-color", "outline-color", "borderColor")(e2, t2);
        }
        var bt2 = [
          ["appearance-auto", { "-webkit-appearance": "auto", appearance: "auto" }],
          ["appearance-none", { "-webkit-appearance": "none", appearance: "none" }]
        ];
        function Sc(e2) {
          return l2.properties.auto.global(e2) ?? { contents: "contents", scroll: "scroll-position" }[e2];
        }
        var xt2 = [[/^will-change-(.+)/, ([, e2]) => ({ "will-change": Sc(e2) })]];
        var ue = [
          "solid",
          "dashed",
          "dotted",
          "double",
          "hidden",
          "none",
          "groove",
          "ridge",
          "inset",
          "outset",
          ...S
        ], yt2 = [
          [
            /^(?:border|b)()(?:-(.+))?$/,
            X2,
            { autocomplete: "(border|b)-<directions>" }
          ],
          [/^(?:border|b)-([xy])(?:-(.+))?$/, X2],
          [/^(?:border|b)-([rltbse])(?:-(.+))?$/, X2],
          [/^(?:border|b)-(block|inline)(?:-(.+))?$/, X2],
          [/^(?:border|b)-([bi][se])(?:-(.+))?$/, X2],
          [
            /^(?:border|b)-()(?:width|size)-(.+)$/,
            X2,
            { autocomplete: ["(border|b)-<num>", "(border|b)-<directions>-<num>"] }
          ],
          [/^(?:border|b)-([xy])-(?:width|size)-(.+)$/, X2],
          [/^(?:border|b)-([rltbse])-(?:width|size)-(.+)$/, X2],
          [/^(?:border|b)-(block|inline)-(?:width|size)-(.+)$/, X2],
          [/^(?:border|b)-([bi][se])-(?:width|size)-(.+)$/, X2],
          [
            /^(?:border|b)-()(?:color-)?(.+)$/,
            Me2,
            {
              autocomplete: [
                "(border|b)-$colors",
                "(border|b)-<directions>-$colors"
              ]
            }
          ],
          [/^(?:border|b)-([xy])-(?:color-)?(.+)$/, Me2],
          [/^(?:border|b)-([rltbse])-(?:color-)?(.+)$/, Me2],
          [/^(?:border|b)-(block|inline)-(?:color-)?(.+)$/, Me2],
          [/^(?:border|b)-([bi][se])-(?:color-)?(.+)$/, Me2],
          [
            /^(?:border|b)-()op(?:acity)?-?(.+)$/,
            Fe,
            { autocomplete: "(border|b)-(op|opacity)-<percent>" }
          ],
          [/^(?:border|b)-([xy])-op(?:acity)?-?(.+)$/, Fe],
          [/^(?:border|b)-([rltbse])-op(?:acity)?-?(.+)$/, Fe],
          [/^(?:border|b)-(block|inline)-op(?:acity)?-?(.+)$/, Fe],
          [/^(?:border|b)-([bi][se])-op(?:acity)?-?(.+)$/, Fe],
          [
            /^(?:border-|b-)?(?:rounded|rd)()(?:-(.+))?$/,
            Ue,
            {
              autocomplete: [
                "(border|b)-(rounded|rd)",
                "(border|b)-(rounded|rd)-<num>",
                "(rounded|rd)",
                "(rounded|rd)-<num>"
              ]
            }
          ],
          [/^(?:border-|b-)?(?:rounded|rd)-([rltbse])(?:-(.+))?$/, Ue],
          [/^(?:border-|b-)?(?:rounded|rd)-([rltb]{2})(?:-(.+))?$/, Ue],
          [/^(?:border-|b-)?(?:rounded|rd)-([bise][se])(?:-(.+))?$/, Ue],
          [/^(?:border-|b-)?(?:rounded|rd)-([bi][se]-[bi][se])(?:-(.+))?$/, Ue],
          [
            /^(?:border|b)-(?:style-)?()(.+)$/,
            Le2,
            {
              autocomplete: [
                "(border|b)-style",
                `(border|b)-(${ue.join("|")})`,
                "(border|b)-<directions>-style",
                `(border|b)-<directions>-(${ue.join("|")})`,
                `(border|b)-<directions>-style-(${ue.join("|")})`,
                `(border|b)-style-(${ue.join("|")})`
              ]
            }
          ],
          [/^(?:border|b)-([xy])-(?:style-)?(.+)$/, Le2],
          [/^(?:border|b)-([rltbse])-(?:style-)?(.+)$/, Le2],
          [/^(?:border|b)-(block|inline)-(?:style-)?(.+)$/, Le2],
          [/^(?:border|b)-([bi][se])-(?:style-)?(.+)$/, Le2]
        ];
        function no(e2, t2, r2) {
          if (t2 != null)
            return { [`border${r2}-color`]: A(e2, t2) };
          if (r2 === "") {
            let n2 = {}, o2 = "--un-border-opacity", i = A(e2, `var(${o2})`);
            return i.includes(o2) && (n2[o2] = typeof e2 == "string" ? 1 : ee2(e2)), n2["border-color"] = i, n2;
          } else {
            let n2 = {}, o2 = "--un-border-opacity", i = `--un-border${r2}-opacity`, a = A(e2, `var(${i})`);
            return a.includes(i) && (n2[o2] = typeof e2 == "string" ? 1 : ee2(e2), n2[i] = `var(${o2})`), n2[`border${r2}-color`] = a, n2;
          }
        }
        function Cc(e2) {
          return ([, t2], r2) => {
            let n2 = ke2(t2, r2, "borderColor");
            if (!n2)
              return;
            let { alpha: o2, color: i, cssColor: a } = n2;
            if (a)
              return no(a, o2, e2);
            if (i)
              return no(i, o2, e2);
          };
        }
        function X2([, e2 = "", t2], { theme: r2 }) {
          var _a3;
          let n2 = ((_a3 = r2.lineWidth) == null ? void 0 : _a3[t2 || "DEFAULT"]) ?? l2.bracket.cssvar.global.px(t2 || "1");
          if (e2 in F && n2 != null)
            return F[e2].map((o2) => [`border${o2}-width`, n2]);
        }
        function Me2([, e2 = "", t2], r2) {
          if (e2 in F) {
            if (q2(l2.bracket(t2)))
              return X2(["", e2, t2], r2);
            if (Ce(t2, r2.theme, "borderColor"))
              return Object.assign({}, ...F[e2].map((n2) => Cc(n2)(["", t2], r2.theme)));
          }
        }
        function Fe([, e2 = "", t2]) {
          let r2 = l2.bracket.percent.cssvar(t2);
          if (e2 in F && r2 != null)
            return F[e2].map((n2) => [`--un-border${n2}-opacity`, r2]);
        }
        function Ue([, e2 = "", t2], { theme: r2 }) {
          var _a3;
          let n2 = ((_a3 = r2.borderRadius) == null ? void 0 : _a3[t2 || "DEFAULT"]) || l2.bracket.cssvar.global.fraction.rem(t2 || "1");
          if (e2 in Fr && n2 != null)
            return Fr[e2].map((o2) => [`border${o2}-radius`, n2]);
        }
        function Le2([, e2 = "", t2]) {
          if (ue.includes(t2) && e2 in F)
            return F[e2].map((r2) => [`border${r2}-style`, t2]);
        }
        var vt2 = [
          [
            /^op(?:acity)?-?(.+)$/,
            ([, e2]) => ({ opacity: l2.bracket.percent.cssvar(e2) })
          ]
        ], Rc = /^\[url\(.+\)\]$/, Tc = /^\[length:.+\]$/, Ec = /^\[position:.+\]$/, wt2 = [
          [
            /^bg-(.+)$/,
            (...e2) => {
              let t2 = e2[0][1];
              return Rc.test(t2) ? { "--un-url": l2.bracket(t2), "background-image": "var(--un-url)" } : Tc.test(t2) && l2.bracketOfLength(t2) != null ? {
                "background-size": l2.bracketOfLength(t2).split(" ").map((r2) => l2.fraction.auto.px.cssvar(r2) ?? r2).join(" ")
              } : (to(t2) || Ec.test(t2)) && l2.bracketOfPosition(t2) != null ? {
                "background-position": l2.bracketOfPosition(t2).split(" ").map((r2) => l2.position.fraction.auto.px.cssvar(r2) ?? r2).join(" ")
              } : j("background-color", "bg", "backgroundColor")(...e2);
            }
          ],
          [
            /^bg-op(?:acity)?-?(.+)$/,
            ([, e2]) => ({ "--un-bg-opacity": l2.bracket.percent.cssvar(e2) }),
            { autocomplete: "bg-(op|opacity)-<percent>" }
          ]
        ], oo = [[/^color-scheme-(\w+)$/, ([, e2]) => ({ "color-scheme": e2 })]];
        var $t2 = [
          [
            /^@container(?:\/(\w+))?(?:-(normal))?$/,
            ([, e2, t2]) => (ne2(
              "The container query rule is experimental and may not follow semver."
            ), { "container-type": t2 ?? "inline-size", "container-name": e2 })
          ]
        ];
        var io = ["solid", "double", "dotted", "dashed", "wavy", ...S], kt = [
          [
            /^(?:decoration-)?(underline|overline|line-through)$/,
            ([, e2]) => ({ "text-decoration-line": e2 }),
            { autocomplete: "decoration-(underline|overline|line-through)" }
          ],
          [
            /^(?:underline|decoration)-(?:size-)?(.+)$/,
            ao,
            { autocomplete: "(underline|decoration)-<num>" }
          ],
          [
            /^(?:underline|decoration)-(auto|from-font)$/,
            ([, e2]) => ({ "text-decoration-thickness": e2 }),
            { autocomplete: "(underline|decoration)-(auto|from-font)" }
          ],
          [
            /^(?:underline|decoration)-(.+)$/,
            jc,
            { autocomplete: "(underline|decoration)-$colors" }
          ],
          [
            /^(?:underline|decoration)-op(?:acity)?-?(.+)$/,
            ([, e2]) => ({ "--un-line-opacity": l2.bracket.percent.cssvar(e2) }),
            { autocomplete: "(underline|decoration)-(op|opacity)-<percent>" }
          ],
          [
            /^(?:underline|decoration)-offset-(.+)$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "text-underline-offset": ((_a3 = t2.lineWidth) == null ? void 0 : _a3[e2]) ?? l2.auto.bracket.cssvar.global.px(e2)
              };
            },
            { autocomplete: "(underline|decoration)-(offset)-<num>" }
          ],
          ...io.map((e2) => [`underline-${e2}`, { "text-decoration-style": e2 }]),
          ...io.map((e2) => [`decoration-${e2}`, { "text-decoration-style": e2 }]),
          ["no-underline", { "text-decoration": "none" }],
          ["decoration-none", { "text-decoration": "none" }]
        ];
        function ao([, e2], { theme: t2 }) {
          var _a3;
          return {
            "text-decoration-thickness": ((_a3 = t2.lineWidth) == null ? void 0 : _a3[e2]) ?? l2.bracket.cssvar.global.px(e2)
          };
        }
        function jc(e2, t2) {
          if (q2(l2.bracket(e2[1])))
            return ao(e2, t2);
          let r2 = j("text-decoration-color", "line", "borderColor")(e2, t2);
          if (r2)
            return {
              "-webkit-text-decoration-color": r2["text-decoration-color"],
              ...r2
            };
        }
        var St2 = {
          all: "all",
          colors: [
            "color",
            "background-color",
            "border-color",
            "outline-color",
            "text-decoration-color",
            "fill",
            "stroke"
          ].join(","),
          none: "none",
          opacity: "opacity",
          shadow: "box-shadow",
          transform: "transform"
        };
        function so(e2) {
          return l2.properties(e2) ?? St2[e2];
        }
        var Ct2 = [
          [
            /^transition(?:-([a-z-]+(?:,[a-z-]+)*))?(?:-(\d+))?$/,
            ([, e2, t2], { theme: r2 }) => {
              var _a3;
              let n2 = e2 != null ? so(e2) : [
                St2.colors,
                "opacity",
                "box-shadow",
                "transform",
                "filter",
                "backdrop-filter"
              ].join(",");
              if (n2) {
                let o2 = ((_a3 = r2.duration) == null ? void 0 : _a3[t2 || "DEFAULT"]) ?? l2.time(t2 || "150");
                return {
                  "transition-property": n2,
                  "transition-timing-function": "cubic-bezier(0.4, 0, 0.2, 1)",
                  "transition-duration": o2
                };
              }
            },
            { autocomplete: `transition-(${Object.keys(St2).join("|")})` }
          ],
          [
            /^(?:transition-)?duration-(.+)$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "transition-duration": ((_a3 = t2.duration) == null ? void 0 : _a3[e2 || "DEFAULT"]) ?? l2.bracket.cssvar.time(e2)
              };
            },
            { autocomplete: ["transition-duration-$duration", "duration-$duration"] }
          ],
          [
            /^(?:transition-)?delay-(.+)$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "transition-delay": ((_a3 = t2.duration) == null ? void 0 : _a3[e2 || "DEFAULT"]) ?? l2.bracket.cssvar.time(e2)
              };
            },
            { autocomplete: ["transition-delay-$duration", "delay-$duration"] }
          ],
          [
            /^(?:transition-)?ease(?:-(.+))?$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "transition-timing-function": ((_a3 = t2.easing) == null ? void 0 : _a3[e2 || "DEFAULT"]) ?? l2.bracket.cssvar(e2)
              };
            },
            {
              autocomplete: [
                "transition-ease-(linear|in|out|in-out|DEFAULT)",
                "ease-(linear|in|out|in-out|DEFAULT)"
              ]
            }
          ],
          [
            /^(?:transition-)?property-(.+)$/,
            ([, e2]) => ({ "transition-property": l2.bracket.global(e2) || so(e2) }),
            {
              autocomplete: [
                `transition-property-(${[...S, ...Object.keys(St2)].join("|")})`
              ]
            }
          ],
          ["transition-none", { transition: "none" }],
          ...v("transition")
        ];
        var Rt2 = [
          ["flex", { display: "flex" }],
          ["inline-flex", { display: "inline-flex" }],
          ["flex-inline", { display: "inline-flex" }],
          [
            /^flex-(.*)$/,
            ([, e2]) => ({
              flex: l2.bracket(e2) != null ? l2.bracket(e2).split(" ").map((t2) => l2.cssvar.fraction(t2) ?? t2).join(" ") : l2.cssvar.fraction(e2)
            })
          ],
          ["flex-1", { flex: "1 1 0%" }],
          ["flex-auto", { flex: "1 1 auto" }],
          ["flex-initial", { flex: "0 1 auto" }],
          ["flex-none", { flex: "none" }],
          [
            /^(?:flex-)?shrink(?:-(.*))?$/,
            ([, e2 = ""]) => ({ "flex-shrink": l2.bracket.cssvar.number(e2) ?? 1 }),
            { autocomplete: ["flex-shrink-<num>", "shrink-<num>"] }
          ],
          [
            /^(?:flex-)?grow(?:-(.*))?$/,
            ([, e2 = ""]) => ({ "flex-grow": l2.bracket.cssvar.number(e2) ?? 1 }),
            { autocomplete: ["flex-grow-<num>", "grow-<num>"] }
          ],
          [
            /^(?:flex-)?basis-(.+)$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "flex-basis": ((_a3 = t2.spacing) == null ? void 0 : _a3[e2]) ?? l2.bracket.cssvar.auto.fraction.rem(e2)
              };
            },
            { autocomplete: ["flex-basis-$spacing", "basis-$spacing"] }
          ],
          ["flex-row", { "flex-direction": "row" }],
          ["flex-row-reverse", { "flex-direction": "row-reverse" }],
          ["flex-col", { "flex-direction": "column" }],
          ["flex-col-reverse", { "flex-direction": "column-reverse" }],
          ["flex-wrap", { "flex-wrap": "wrap" }],
          ["flex-wrap-reverse", { "flex-wrap": "wrap-reverse" }],
          ["flex-nowrap", { "flex-wrap": "nowrap" }]
        ];
        var Tt2 = [
          [/^text-(.+)$/, Oc, { autocomplete: "text-$fontSize" }],
          [
            /^(?:text|font)-size-(.+)$/,
            co,
            { autocomplete: "text-size-$fontSize" }
          ],
          [/^text-(?:color-)?(.+)$/, zc, { autocomplete: "text-$colors" }],
          [
            /^(?:color|c)-(.+)$/,
            j("color", "text", "textColor"),
            { autocomplete: "(color|c)-$colors" }
          ],
          [
            /^(?:text|color|c)-(.+)$/,
            ([, e2]) => S.includes(e2) ? { color: e2 } : void 0,
            { autocomplete: `(text|color|c)-(${S.join("|")})` }
          ],
          [
            /^(?:text|color|c)-op(?:acity)?-?(.+)$/,
            ([, e2]) => ({ "--un-text-opacity": l2.bracket.percent.cssvar(e2) }),
            { autocomplete: "(text|color|c)-(op|opacity)-<percent>" }
          ],
          [
            /^(?:font|fw)-?([^-]+)$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "font-weight": ((_a3 = t2.fontWeight) == null ? void 0 : _a3[e2]) || l2.bracket.global.number(e2)
              };
            },
            {
              autocomplete: [
                "(font|fw)-(100|200|300|400|500|600|700|800|900)",
                "(font|fw)-$fontWeight"
              ]
            }
          ],
          [
            /^(?:font-)?(?:leading|lh|line-height)-(.+)$/,
            ([, e2], { theme: t2 }) => ({ "line-height": Gr(e2, t2, "lineHeight") }),
            { autocomplete: "(leading|lh|line-height)-$lineHeight" }
          ],
          ["font-synthesis-weight", { "font-synthesis": "weight" }],
          ["font-synthesis-style", { "font-synthesis": "style" }],
          ["font-synthesis-small-caps", { "font-synthesis": "small-caps" }],
          ["font-synthesis-none", { "font-synthesis": "none" }],
          [
            /^font-synthesis-(.+)$/,
            ([, e2]) => ({ "font-synthesis": l2.bracket.cssvar.global(e2) })
          ],
          [
            /^(?:font-)?tracking-(.+)$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "letter-spacing": ((_a3 = t2.letterSpacing) == null ? void 0 : _a3[e2]) || l2.bracket.cssvar.global.rem(e2)
              };
            },
            { autocomplete: "tracking-$letterSpacing" }
          ],
          [
            /^(?:font-)?word-spacing-(.+)$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "word-spacing": ((_a3 = t2.wordSpacing) == null ? void 0 : _a3[e2]) || l2.bracket.cssvar.global.rem(e2)
              };
            },
            { autocomplete: "word-spacing-$wordSpacing" }
          ],
          [
            /^font-(.+)$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "font-family": ((_a3 = t2.fontFamily) == null ? void 0 : _a3[e2]) || l2.bracket.cssvar.global(e2)
              };
            },
            { autocomplete: "font-$fontFamily" }
          ]
        ], Et = [
          [
            /^tab(?:-(.+))?$/,
            ([, e2]) => {
              let t2 = l2.bracket.cssvar.global.number(e2 || "4");
              if (t2 != null)
                return { "-moz-tab-size": t2, "-o-tab-size": t2, "tab-size": t2 };
            }
          ]
        ], jt = [
          [
            /^indent(?:-(.+))?$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "text-indent": ((_a3 = t2.textIndent) == null ? void 0 : _a3[e2 || "DEFAULT"]) || l2.bracket.cssvar.global.fraction.rem(e2)
              };
            },
            { autocomplete: "indent-$textIndent" }
          ]
        ], zt2 = [
          [
            /^text-stroke(?:-(.+))?$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "-webkit-text-stroke-width": ((_a3 = t2.textStrokeWidth) == null ? void 0 : _a3[e2 || "DEFAULT"]) || l2.bracket.cssvar.px(e2)
              };
            },
            { autocomplete: "text-stroke-$textStrokeWidth" }
          ],
          [
            /^text-stroke-(.+)$/,
            j("-webkit-text-stroke-color", "text-stroke", "borderColor"),
            { autocomplete: "text-stroke-$colors" }
          ],
          [
            /^text-stroke-op(?:acity)?-?(.+)$/,
            ([, e2]) => ({
              "--un-text-stroke-opacity": l2.bracket.percent.cssvar(e2)
            }),
            { autocomplete: "text-stroke-(op|opacity)-<percent>" }
          ]
        ], Ot2 = [
          [
            /^text-shadow(?:-(.+))?$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              let r2 = (_a3 = t2.textShadow) == null ? void 0 : _a3[e2 || "DEFAULT"];
              return r2 != null ? {
                "--un-text-shadow": Se2(r2, "--un-text-shadow-color").join(","),
                "text-shadow": "var(--un-text-shadow)"
              } : { "text-shadow": l2.bracket.cssvar.global(e2) };
            },
            { autocomplete: "text-shadow-$textShadow" }
          ],
          [
            /^text-shadow-color-(.+)$/,
            j("--un-text-shadow-color", "text-shadow", "shadowColor"),
            { autocomplete: "text-shadow-color-$colors" }
          ],
          [
            /^text-shadow-color-op(?:acity)?-?(.+)$/,
            ([, e2]) => ({
              "--un-text-shadow-opacity": l2.bracket.percent.cssvar(e2)
            }),
            { autocomplete: "text-shadow-color-(op|opacity)-<percent>" }
          ]
        ];
        function Gr(e2, t2, r2) {
          var _a3;
          return ((_a3 = t2[r2]) == null ? void 0 : _a3[e2]) || l2.bracket.cssvar.global.rem(e2);
        }
        function co([, e2], { theme: t2 }) {
          var _a3, _b;
          let n2 = ((_b = _2((_a3 = t2.fontSize) == null ? void 0 : _a3[e2])) == null ? void 0 : _b[0]) ?? l2.bracket.cssvar.global.rem(e2);
          if (n2 != null)
            return { "font-size": n2 };
        }
        function zc(e2, t2) {
          return q2(l2.bracket(e2[1])) ? co(e2, t2) : j("color", "text", "textColor")(e2, t2);
        }
        function Oc([, e2 = "base"], { theme: t2 }) {
          var _a3;
          let r2 = Kr(e2, "length");
          if (!r2)
            return;
          let [n2, o2] = r2, i = _2((_a3 = t2.fontSize) == null ? void 0 : _a3[n2]), a = o2 ? Gr(o2, t2, "lineHeight") : void 0;
          if (i == null ? void 0 : i[0]) {
            let [c, f, u] = i;
            return typeof f == "object" ? { "font-size": c, ...f } : {
              "font-size": c,
              "line-height": a ?? f ?? "1",
              "letter-spacing": u ? Gr(u, t2, "letterSpacing") : void 0
            };
          }
          let s2 = l2.bracketOfLength.rem(n2);
          return a && s2 ? { "font-size": s2, "line-height": a } : { "font-size": l2.bracketOfLength.rem(e2) };
        }
        var Ac = { "": "", x: "column-", y: "row-", col: "column-", row: "row-" };
        function Hr([, e2 = "", t2], { theme: r2 }) {
          var _a3;
          let n2 = ((_a3 = r2.spacing) == null ? void 0 : _a3[t2]) ?? l2.bracket.cssvar.global.rem(t2);
          if (n2 != null)
            return { [`${Ac[e2]}gap`]: n2 };
        }
        var At = [
          [
            /^(?:flex-|grid-)?gap-?()(.+)$/,
            Hr,
            { autocomplete: ["gap-$spacing", "gap-<num>"] }
          ],
          [
            /^(?:flex-|grid-)?gap-([xy])-?(.+)$/,
            Hr,
            { autocomplete: ["gap-(x|y)-$spacing", "gap-(x|y)-<num>"] }
          ],
          [
            /^(?:flex-|grid-)?gap-(col|row)-?(.+)$/,
            Hr,
            { autocomplete: ["gap-(col|row)-$spacing", "gap-(col|row)-<num>"] }
          ]
        ];
        function J2(e2) {
          return e2.replace("col", "column");
        }
        function qr(e2) {
          return e2[0] === "r" ? "Row" : "Column";
        }
        function Vc(e2, t2, r2) {
          var _a3;
          let n2 = (_a3 = t2[`gridAuto${qr(e2)}`]) == null ? void 0 : _a3[r2];
          if (n2 != null)
            return n2;
          switch (r2) {
            case "min":
              return "min-content";
            case "max":
              return "max-content";
            case "fr":
              return "minmax(0,1fr)";
          }
          return l2.bracket.cssvar.auto.rem(r2);
        }
        var Vt2 = [
          ["grid", { display: "grid" }],
          ["inline-grid", { display: "inline-grid" }],
          [
            /^(?:grid-)?(row|col)-(.+)$/,
            ([, e2, t2], { theme: r2 }) => {
              var _a3;
              return {
                [`grid-${J2(e2)}`]: ((_a3 = r2[`grid${qr(e2)}`]) == null ? void 0 : _a3[t2]) ?? l2.bracket.cssvar.auto(t2)
              };
            }
          ],
          [
            /^(?:grid-)?(row|col)-span-(.+)$/,
            ([, e2, t2]) => {
              if (t2 === "full")
                return { [`grid-${J2(e2)}`]: "1/-1" };
              let r2 = l2.bracket.number(t2);
              if (r2 != null)
                return { [`grid-${J2(e2)}`]: `span ${r2}/span ${r2}` };
            },
            { autocomplete: ["grid-(row|col)-span-<num>", "(row|col)-span-<num>"] }
          ],
          [
            /^(?:grid-)?(row|col)-start-(.+)$/,
            ([, e2, t2]) => ({ [`grid-${J2(e2)}-start`]: l2.bracket.cssvar(t2) ?? t2 })
          ],
          [
            /^(?:grid-)?(row|col)-end-(.+)$/,
            ([, e2, t2]) => ({ [`grid-${J2(e2)}-end`]: l2.bracket.cssvar(t2) ?? t2 }),
            { autocomplete: ["grid-(row|col)-(start|end)-<num>"] }
          ],
          [
            /^(?:grid-)?auto-(rows|cols)-(.+)$/,
            ([, e2, t2], { theme: r2 }) => ({ [`grid-auto-${J2(e2)}`]: Vc(e2, r2, t2) }),
            { autocomplete: ["grid-auto-(rows|cols)-<num>"] }
          ],
          [
            /^(?:grid-auto-flow|auto-flow|grid-flow)-(.+)$/,
            ([, e2]) => ({ "grid-auto-flow": l2.bracket.cssvar(e2) })
          ],
          [
            /^(?:grid-auto-flow|auto-flow|grid-flow)-(row|col|dense|row-dense|col-dense)$/,
            ([, e2]) => ({ "grid-auto-flow": J2(e2).replace("-", " ") }),
            {
              autocomplete: [
                "(grid-auto-flow|auto-flow|grid-flow)-(row|col|dense|row-dense|col-dense)"
              ]
            }
          ],
          [
            /^grid-(rows|cols)-(.+)$/,
            ([, e2, t2], { theme: r2 }) => {
              var _a3;
              return {
                [`grid-template-${J2(e2)}`]: ((_a3 = r2[`gridTemplate${qr(e2)}`]) == null ? void 0 : _a3[t2]) ?? l2.bracket.cssvar(t2)
              };
            }
          ],
          [
            /^grid-(rows|cols)-minmax-([\w.-]+)$/,
            ([, e2, t2]) => ({
              [`grid-template-${J2(e2)}`]: `repeat(auto-fill,minmax(${t2},1fr))`
            })
          ],
          [
            /^grid-(rows|cols)-(\d+)$/,
            ([, e2, t2]) => ({
              [`grid-template-${J2(e2)}`]: `repeat(${t2},minmax(0,1fr))`
            }),
            { autocomplete: ["grid-(rows|cols)-<num>", "grid-(rows|cols)-none"] }
          ],
          [
            /^grid-area(s)?-(.+)$/,
            ([, e2, t2]) => e2 != null ? {
              "grid-template-areas": l2.cssvar(t2) ?? t2.split("-").map((r2) => `"${l2.bracket(r2)}"`).join(" ")
            } : { "grid-area": l2.bracket.cssvar(t2) }
          ],
          ["grid-rows-none", { "grid-template-rows": "none" }],
          ["grid-cols-none", { "grid-template-columns": "none" }],
          ["grid-rows-subgrid", { "grid-template-rows": "subgrid" }],
          ["grid-cols-subgrid", { "grid-template-columns": "subgrid" }]
        ];
        var _t2 = ["auto", "hidden", "clip", "visible", "scroll", "overlay", ...S], Pt = [
          [
            /^(?:overflow|of)-(.+)$/,
            ([, e2]) => _t2.includes(e2) ? { overflow: e2 } : void 0,
            {
              autocomplete: [
                `(overflow|of)-(${_t2.join("|")})`,
                `(overflow|of)-(x|y)-(${_t2.join("|")})`
              ]
            }
          ],
          [
            /^(?:overflow|of)-([xy])-(.+)$/,
            ([, e2, t2]) => _t2.includes(t2) ? { [`overflow-${e2}`]: t2 } : void 0
          ]
        ];
        var Mt2 = [
          [
            /^(?:position-|pos-)?(relative|absolute|fixed|sticky)$/,
            ([, e2]) => ({ position: e2 }),
            {
              autocomplete: [
                "(position|pos)-<position>",
                "(position|pos)-<globalKeyword>",
                "<position>"
              ]
            }
          ],
          [
            /^(?:position-|pos-)([-\w]+)$/,
            ([, e2]) => S.includes(e2) ? { position: e2 } : void 0
          ],
          [/^(?:position-|pos-)?(static)$/, ([, e2]) => ({ position: e2 })]
        ], Ne = [
          ["justify-start", { "justify-content": "flex-start" }],
          ["justify-end", { "justify-content": "flex-end" }],
          ["justify-center", { "justify-content": "center" }],
          ["justify-between", { "justify-content": "space-between" }],
          ["justify-around", { "justify-content": "space-around" }],
          ["justify-evenly", { "justify-content": "space-evenly" }],
          ["justify-stretch", { "justify-content": "stretch" }],
          ["justify-left", { "justify-content": "left" }],
          ["justify-right", { "justify-content": "right" }],
          ...v("justify", "justify-content"),
          ["justify-items-start", { "justify-items": "start" }],
          ["justify-items-end", { "justify-items": "end" }],
          ["justify-items-center", { "justify-items": "center" }],
          ["justify-items-stretch", { "justify-items": "stretch" }],
          ...v("justify-items"),
          ["justify-self-auto", { "justify-self": "auto" }],
          ["justify-self-start", { "justify-self": "start" }],
          ["justify-self-end", { "justify-self": "end" }],
          ["justify-self-center", { "justify-self": "center" }],
          ["justify-self-stretch", { "justify-self": "stretch" }],
          ...v("justify-self")
        ], Ft2 = [
          [/^order-(.+)$/, ([, e2]) => ({ order: l2.bracket.cssvar.number(e2) })],
          ["order-first", { order: "-9999" }],
          ["order-last", { order: "9999" }],
          ["order-none", { order: "0" }]
        ], Be2 = [
          ["content-center", { "align-content": "center" }],
          ["content-start", { "align-content": "flex-start" }],
          ["content-end", { "align-content": "flex-end" }],
          ["content-between", { "align-content": "space-between" }],
          ["content-around", { "align-content": "space-around" }],
          ["content-evenly", { "align-content": "space-evenly" }],
          ...v("content", "align-content"),
          ["items-start", { "align-items": "flex-start" }],
          ["items-end", { "align-items": "flex-end" }],
          ["items-center", { "align-items": "center" }],
          ["items-baseline", { "align-items": "baseline" }],
          ["items-stretch", { "align-items": "stretch" }],
          ...v("items", "align-items"),
          ["self-auto", { "align-self": "auto" }],
          ["self-start", { "align-self": "flex-start" }],
          ["self-end", { "align-self": "flex-end" }],
          ["self-center", { "align-self": "center" }],
          ["self-stretch", { "align-self": "stretch" }],
          ["self-baseline", { "align-self": "baseline" }],
          ...v("self", "align-self")
        ], Ut2 = [
          ["place-content-center", { "place-content": "center" }],
          ["place-content-start", { "place-content": "start" }],
          ["place-content-end", { "place-content": "end" }],
          ["place-content-between", { "place-content": "space-between" }],
          ["place-content-around", { "place-content": "space-around" }],
          ["place-content-evenly", { "place-content": "space-evenly" }],
          ["place-content-stretch", { "place-content": "stretch" }],
          ...v("place-content"),
          ["place-items-start", { "place-items": "start" }],
          ["place-items-end", { "place-items": "end" }],
          ["place-items-center", { "place-items": "center" }],
          ["place-items-stretch", { "place-items": "stretch" }],
          ...v("place-items"),
          ["place-self-auto", { "place-self": "auto" }],
          ["place-self-start", { "place-self": "start" }],
          ["place-self-end", { "place-self": "end" }],
          ["place-self-center", { "place-self": "center" }],
          ["place-self-stretch", { "place-self": "stretch" }],
          ...v("place-self")
        ], Lt = [...Ne, ...Be2].flatMap(([e2, t2]) => [
          [`flex-${e2}`, t2],
          [`grid-${e2}`, t2]
        ]);
        function Yr(e2, { theme: t2 }) {
          var _a3;
          return ((_a3 = t2.spacing) == null ? void 0 : _a3[e2]) ?? l2.bracket.cssvar.global.auto.fraction.rem(e2);
        }
        function We2([, e2, t2], r2) {
          let n2 = Yr(t2, r2);
          if (n2 != null && e2 in Mr)
            return Mr[e2].map((o2) => [o2.slice(1), n2]);
        }
        var Wt2 = [
          [
            /^(?:position-|pos-)?inset-(.+)$/,
            ([, e2], t2) => ({ inset: Yr(e2, t2) }),
            {
              autocomplete: [
                "(position|pos)-inset-<directions>-$spacing",
                "(position|pos)-inset-(block|inline)-$spacing",
                "(position|pos)-inset-(bs|be|is|ie)-$spacing",
                "(position|pos)-(top|left|right|bottom)-$spacing"
              ]
            }
          ],
          [/^(?:position-|pos-)?(start|end)-(.+)$/, We2],
          [/^(?:position-|pos-)?inset-([xy])-(.+)$/, We2],
          [/^(?:position-|pos-)?inset-([rltbse])-(.+)$/, We2],
          [/^(?:position-|pos-)?inset-(block|inline)-(.+)$/, We2],
          [/^(?:position-|pos-)?inset-([bi][se])-(.+)$/, We2],
          [
            /^(?:position-|pos-)?(top|left|right|bottom)-(.+)$/,
            ([, e2, t2], r2) => ({ [e2]: Yr(t2, r2) })
          ]
        ], Nt2 = [
          ["float-left", { float: "left" }],
          ["float-right", { float: "right" }],
          ["float-none", { float: "none" }],
          ...v("float"),
          ["clear-left", { clear: "left" }],
          ["clear-right", { clear: "right" }],
          ["clear-both", { clear: "both" }],
          ["clear-none", { clear: "none" }],
          ...v("clear")
        ], Bt2 = [
          [
            /^(?:position-|pos-)?z([\d.]+)$/,
            ([, e2]) => ({ "z-index": l2.number(e2) })
          ],
          [
            /^(?:position-|pos-)?z-(.+)$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "z-index": ((_a3 = t2.zIndex) == null ? void 0 : _a3[e2]) ?? l2.bracket.cssvar.global.auto.number(e2)
              };
            },
            { autocomplete: "z-<num>" }
          ]
        ], Dt = [
          ["box-border", { "box-sizing": "border-box" }],
          ["box-content", { "box-sizing": "content-box" }],
          ...v("box", "box-sizing")
        ];
        var _c = [
          "auto",
          "default",
          "none",
          "context-menu",
          "help",
          "pointer",
          "progress",
          "wait",
          "cell",
          "crosshair",
          "text",
          "vertical-text",
          "alias",
          "copy",
          "move",
          "no-drop",
          "not-allowed",
          "grab",
          "grabbing",
          "all-scroll",
          "col-resize",
          "row-resize",
          "n-resize",
          "e-resize",
          "s-resize",
          "w-resize",
          "ne-resize",
          "nw-resize",
          "se-resize",
          "sw-resize",
          "ew-resize",
          "ns-resize",
          "nesw-resize",
          "nwse-resize",
          "zoom-in",
          "zoom-out"
        ], Pc = [
          "none",
          "strict",
          "content",
          "size",
          "inline-size",
          "layout",
          "style",
          "paint"
        ], T = " ", It2 = [
          ["inline", { display: "inline" }],
          ["block", { display: "block" }],
          ["inline-block", { display: "inline-block" }],
          ["contents", { display: "contents" }],
          ["flow-root", { display: "flow-root" }],
          ["list-item", { display: "list-item" }],
          ["hidden", { display: "none" }],
          [/^display-(.+)$/, ([, e2]) => ({ display: l2.bracket.cssvar.global(e2) })]
        ], Kt2 = [
          ["visible", { visibility: "visible" }],
          ["invisible", { visibility: "hidden" }],
          ["backface-visible", { "backface-visibility": "visible" }],
          ["backface-hidden", { "backface-visibility": "hidden" }],
          ...v("backface", "backface-visibility")
        ], Gt2 = [
          [/^cursor-(.+)$/, ([, e2]) => ({ cursor: l2.bracket.cssvar.global(e2) })],
          ..._c.map((e2) => [`cursor-${e2}`, { cursor: e2 }])
        ], Ht2 = [
          [
            /^contain-(.*)$/,
            ([, e2]) => l2.bracket(e2) != null ? {
              contain: l2.bracket(e2).split(" ").map((t2) => l2.cssvar.fraction(t2) ?? t2).join(" ")
            } : Pc.includes(e2) ? { contain: e2 } : void 0
          ]
        ], qt2 = [
          ["pointer-events-auto", { "pointer-events": "auto" }],
          ["pointer-events-none", { "pointer-events": "none" }],
          ...v("pointer-events")
        ], Yt2 = [
          ["resize-x", { resize: "horizontal" }],
          ["resize-y", { resize: "vertical" }],
          ["resize", { resize: "both" }],
          ["resize-none", { resize: "none" }],
          ...v("resize")
        ], Xt2 = [
          ["select-auto", { "-webkit-user-select": "auto", "user-select": "auto" }],
          ["select-all", { "-webkit-user-select": "all", "user-select": "all" }],
          ["select-text", { "-webkit-user-select": "text", "user-select": "text" }],
          ["select-none", { "-webkit-user-select": "none", "user-select": "none" }],
          ...v("select", "user-select")
        ], Zt2 = [
          [
            /^(?:whitespace-|ws-)([-\w]+)$/,
            ([, e2]) => [
              "normal",
              "nowrap",
              "pre",
              "pre-line",
              "pre-wrap",
              "break-spaces",
              ...S
            ].includes(e2) ? { "white-space": e2 } : void 0,
            {
              autocomplete: "(whitespace|ws)-(normal|nowrap|pre|pre-line|pre-wrap|break-spaces)"
            }
          ]
        ], Jt2 = [
          [
            /^intrinsic-size-(.+)$/,
            ([, e2]) => ({
              "contain-intrinsic-size": l2.bracket.cssvar.global.fraction.rem(e2)
            }),
            { autocomplete: "intrinsic-size-<num>" }
          ],
          ["content-visibility-visible", { "content-visibility": "visible" }],
          ["content-visibility-hidden", { "content-visibility": "hidden" }],
          ["content-visibility-auto", { "content-visibility": "auto" }],
          ...v("content-visibility")
        ], Qt2 = [
          [/^content-(.+)$/, ([, e2]) => ({ content: l2.bracket.cssvar(e2) })],
          ["content-empty", { content: '""' }],
          ["content-none", { content: "none" }]
        ], er = [
          ["break-normal", { "overflow-wrap": "normal", "word-break": "normal" }],
          ["break-words", { "overflow-wrap": "break-word" }],
          ["break-all", { "word-break": "break-all" }],
          ["break-keep", { "word-break": "keep-all" }],
          ["break-anywhere", { "overflow-wrap": "anywhere" }]
        ], tr = [
          ["text-wrap", { "text-wrap": "wrap" }],
          ["text-nowrap", { "text-wrap": "nowrap" }],
          ["text-balance", { "text-wrap": "balance" }],
          ["text-pretty", { "text-wrap": "pretty" }]
        ], rr = [
          [
            "truncate",
            {
              overflow: "hidden",
              "text-overflow": "ellipsis",
              "white-space": "nowrap"
            }
          ],
          [
            "text-truncate",
            {
              overflow: "hidden",
              "text-overflow": "ellipsis",
              "white-space": "nowrap"
            }
          ],
          ["text-ellipsis", { "text-overflow": "ellipsis" }],
          ["text-clip", { "text-overflow": "clip" }]
        ], nr = [
          ["case-upper", { "text-transform": "uppercase" }],
          ["case-lower", { "text-transform": "lowercase" }],
          ["case-capital", { "text-transform": "capitalize" }],
          ["case-normal", { "text-transform": "none" }],
          ...v("case", "text-transform")
        ], or = [
          ["italic", { "font-style": "italic" }],
          ["not-italic", { "font-style": "normal" }],
          ["font-italic", { "font-style": "italic" }],
          ["font-not-italic", { "font-style": "normal" }],
          ["oblique", { "font-style": "oblique" }],
          ["not-oblique", { "font-style": "normal" }],
          ["font-oblique", { "font-style": "oblique" }],
          ["font-not-oblique", { "font-style": "normal" }]
        ], ir = [
          [
            "antialiased",
            {
              "-webkit-font-smoothing": "antialiased",
              "-moz-osx-font-smoothing": "grayscale"
            }
          ],
          [
            "subpixel-antialiased",
            { "-webkit-font-smoothing": "auto", "-moz-osx-font-smoothing": "auto" }
          ]
        ];
        var ar = {
          "--un-ring-inset": T,
          "--un-ring-offset-width": "0px",
          "--un-ring-offset-color": "#fff",
          "--un-ring-width": "0px",
          "--un-ring-color": "rgb(147 197 253 / 0.5)",
          "--un-shadow": "0 0 rgb(0 0 0 / 0)"
        }, sr = [
          [
            /^ring(?:-(.+))?$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              let r2 = ((_a3 = t2.ringWidth) == null ? void 0 : _a3[e2 || "DEFAULT"]) ?? l2.px(e2 || "1");
              if (r2)
                return {
                  "--un-ring-width": r2,
                  "--un-ring-offset-shadow": "var(--un-ring-inset) 0 0 0 var(--un-ring-offset-width) var(--un-ring-offset-color)",
                  "--un-ring-shadow": "var(--un-ring-inset) 0 0 0 calc(var(--un-ring-width) + var(--un-ring-offset-width)) var(--un-ring-color)",
                  "box-shadow": "var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow)"
                };
            },
            { autocomplete: "ring-$ringWidth" }
          ],
          [
            /^ring-(?:width-|size-)(.+)$/,
            lo,
            { autocomplete: "ring-(width|size)-$lineWidth" }
          ],
          ["ring-offset", { "--un-ring-offset-width": "1px" }],
          [
            /^ring-offset-(?:width-|size-)?(.+)$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "--un-ring-offset-width": ((_a3 = t2.lineWidth) == null ? void 0 : _a3[e2]) ?? l2.bracket.cssvar.px(e2)
              };
            },
            { autocomplete: "ring-offset-(width|size)-$lineWidth" }
          ],
          [/^ring-(.+)$/, Mc, { autocomplete: "ring-$colors" }],
          [
            /^ring-op(?:acity)?-?(.+)$/,
            ([, e2]) => ({ "--un-ring-opacity": l2.bracket.percent.cssvar(e2) }),
            { autocomplete: "ring-(op|opacity)-<percent>" }
          ],
          [
            /^ring-offset-(.+)$/,
            j("--un-ring-offset-color", "ring-offset", "borderColor"),
            { autocomplete: "ring-offset-$colors" }
          ],
          [
            /^ring-offset-op(?:acity)?-?(.+)$/,
            ([, e2]) => ({
              "--un-ring-offset-opacity": l2.bracket.percent.cssvar(e2)
            }),
            { autocomplete: "ring-offset-(op|opacity)-<percent>" }
          ],
          ["ring-inset", { "--un-ring-inset": "inset" }]
        ];
        function lo([, e2], { theme: t2 }) {
          var _a3;
          return { "--un-ring-width": ((_a3 = t2.ringWidth) == null ? void 0 : _a3[e2]) ?? l2.bracket.cssvar.px(e2) };
        }
        function Mc(e2, t2) {
          return q2(l2.bracket(e2[1])) ? lo(e2, t2) : j("--un-ring-color", "ring", "borderColor")(e2, t2);
        }
        var cr = {
          "--un-ring-offset-shadow": "0 0 rgb(0 0 0 / 0)",
          "--un-ring-shadow": "0 0 rgb(0 0 0 / 0)",
          "--un-shadow-inset": T,
          "--un-shadow": "0 0 rgb(0 0 0 / 0)"
        }, lr = [
          [
            /^shadow(?:-(.+))?$/,
            (e2, t2) => {
              var _a3;
              let [, r2] = e2, { theme: n2 } = t2, o2 = (_a3 = n2.boxShadow) == null ? void 0 : _a3[r2 || "DEFAULT"], i = r2 ? l2.bracket.cssvar(r2) : void 0;
              return (o2 != null || i != null) && !Ce(i, n2, "shadowColor") ? {
                "--un-shadow": Se2(o2 || i, "--un-shadow-color").join(","),
                "box-shadow": "var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow)"
              } : j("--un-shadow-color", "shadow", "shadowColor")(e2, t2);
            },
            { autocomplete: ["shadow-$colors", "shadow-$boxShadow"] }
          ],
          [
            /^shadow-op(?:acity)?-?(.+)$/,
            ([, e2]) => ({ "--un-shadow-opacity": l2.bracket.percent.cssvar(e2) }),
            { autocomplete: "shadow-(op|opacity)-<percent>" }
          ],
          ["shadow-inset", { "--un-shadow-inset": "inset" }]
        ];
        var Fc = {
          h: "height",
          w: "width",
          inline: "inline-size",
          block: "block-size"
        };
        function pe(e2, t2) {
          return `${e2 || ""}${Fc[t2]}`;
        }
        function fr(e2, t2, r2, n2) {
          var _a3;
          let o2 = pe(e2, t2).replace(/-(\w)/g, (a, s2) => s2.toUpperCase()), i = (_a3 = r2[o2]) == null ? void 0 : _a3[n2];
          if (i != null)
            return i;
          switch (n2) {
            case "fit":
            case "max":
            case "min":
              return `${n2}-content`;
          }
          return l2.bracket.cssvar.global.auto.fraction.rem(n2);
        }
        var ur = [
          [
            /^size-(min-|max-)?(.+)$/,
            ([, e2, t2], { theme: r2 }) => ({
              [pe(e2, "w")]: fr(e2, "w", r2, t2),
              [pe(e2, "h")]: fr(e2, "h", r2, t2)
            })
          ],
          [
            /^(?:size-)?(min-|max-)?([wh])-?(.+)$/,
            ([, e2, t2, r2], { theme: n2 }) => ({ [pe(e2, t2)]: fr(e2, t2, n2, r2) })
          ],
          [
            /^(?:size-)?(min-|max-)?(block|inline)-(.+)$/,
            ([, e2, t2, r2], { theme: n2 }) => ({ [pe(e2, t2)]: fr(e2, t2, n2, r2) }),
            {
              autocomplete: [
                "(w|h)-$width|height|maxWidth|maxHeight|minWidth|minHeight|inlineSize|blockSize|maxInlineSize|maxBlockSize|minInlineSize|minBlockSize",
                "(block|inline)-$width|height|maxWidth|maxHeight|minWidth|minHeight|inlineSize|blockSize|maxInlineSize|maxBlockSize|minInlineSize|minBlockSize",
                "(max|min)-(w|h|block|inline)",
                "(max|min)-(w|h|block|inline)-$width|height|maxWidth|maxHeight|minWidth|minHeight|inlineSize|blockSize|maxInlineSize|maxBlockSize|minInlineSize|minBlockSize",
                "(w|h)-full",
                "(max|min)-(w|h)-full"
              ]
            }
          ],
          [
            /^(?:size-)?(min-|max-)?(h)-screen-(.+)$/,
            ([, e2, t2, r2], n2) => ({ [pe(e2, t2)]: fo(n2, r2, "verticalBreakpoints") })
          ],
          [
            /^(?:size-)?(min-|max-)?(w)-screen-(.+)$/,
            ([, e2, t2, r2], n2) => ({ [pe(e2, t2)]: fo(n2, r2) }),
            {
              autocomplete: [
                "(w|h)-screen",
                "(min|max)-(w|h)-screen",
                "h-screen-$verticalBreakpoints",
                "(min|max)-h-screen-$verticalBreakpoints",
                "w-screen-$breakpoints",
                "(min|max)-w-screen-$breakpoints"
              ]
            }
          ]
        ];
        function fo(e2, t2, r2 = "breakpoints") {
          var _a3;
          let n2 = fe2(e2, r2);
          if (n2)
            return (_a3 = n2.find((o2) => o2.point === t2)) == null ? void 0 : _a3.size;
        }
        function Uc(e2) {
          if (/^\d+\/\d+$/.test(e2))
            return e2;
          switch (e2) {
            case "square":
              return "1/1";
            case "video":
              return "16/9";
          }
          return l2.bracket.cssvar.global.auto.number(e2);
        }
        var pr = [
          [
            /^(?:size-)?aspect-(?:ratio-)?(.+)$/,
            ([, e2]) => ({ "aspect-ratio": Uc(e2) }),
            {
              autocomplete: [
                "aspect-(square|video|ratio)",
                "aspect-ratio-(square|video)"
              ]
            }
          ]
        ];
        var dr = [
          [
            /^pa?()-?(-?.+)$/,
            V("padding"),
            { autocomplete: ["(m|p)<num>", "(m|p)-<num>"] }
          ],
          [/^p-?xy()()$/, V("padding"), { autocomplete: "(m|p)-(xy)" }],
          [/^p-?([xy])(?:-?(-?.+))?$/, V("padding")],
          [
            /^p-?([rltbse])(?:-?(-?.+))?$/,
            V("padding"),
            { autocomplete: "(m|p)<directions>-<num>" }
          ],
          [
            /^p-(block|inline)(?:-(-?.+))?$/,
            V("padding"),
            { autocomplete: "(m|p)-(block|inline)-<num>" }
          ],
          [
            /^p-?([bi][se])(?:-?(-?.+))?$/,
            V("padding"),
            { autocomplete: "(m|p)-(bs|be|is|ie)-<num>" }
          ]
        ], mr = [
          [/^ma?()-?(-?.+)$/, V("margin")],
          [/^m-?xy()()$/, V("margin")],
          [/^m-?([xy])(?:-?(-?.+))?$/, V("margin")],
          [/^m-?([rltbse])(?:-?(-?.+))?$/, V("margin")],
          [/^m-(block|inline)(?:-(-?.+))?$/, V("margin")],
          [/^m-?([bi][se])(?:-?(-?.+))?$/, V("margin")]
        ];
        var hr = ["translate", "rotate", "scale"], de = [
          "translateX(var(--un-translate-x))",
          "translateY(var(--un-translate-y))",
          "translateZ(var(--un-translate-z))",
          "rotate(var(--un-rotate))",
          "rotateX(var(--un-rotate-x))",
          "rotateY(var(--un-rotate-y))",
          "rotateZ(var(--un-rotate-z))",
          "skewX(var(--un-skew-x))",
          "skewY(var(--un-skew-y))",
          "scaleX(var(--un-scale-x))",
          "scaleY(var(--un-scale-y))",
          "scaleZ(var(--un-scale-z))"
        ].join(" "), Lc = [
          "translate3d(var(--un-translate-x), var(--un-translate-y), var(--un-translate-z))",
          "rotate(var(--un-rotate))",
          "rotateX(var(--un-rotate-x))",
          "rotateY(var(--un-rotate-y))",
          "rotateZ(var(--un-rotate-z))",
          "skewX(var(--un-skew-x))",
          "skewY(var(--un-skew-y))",
          "scaleX(var(--un-scale-x))",
          "scaleY(var(--un-scale-y))",
          "scaleZ(var(--un-scale-z))"
        ].join(" "), gr = {
          "--un-rotate": 0,
          "--un-rotate-x": 0,
          "--un-rotate-y": 0,
          "--un-rotate-z": 0,
          "--un-scale-x": 1,
          "--un-scale-y": 1,
          "--un-scale-z": 1,
          "--un-skew-x": 0,
          "--un-skew-y": 0,
          "--un-translate-x": 0,
          "--un-translate-y": 0,
          "--un-translate-z": 0
        }, br = [
          [
            /^(?:transform-)?origin-(.+)$/,
            ([, e2]) => ({ "transform-origin": M[e2] ?? l2.bracket.cssvar(e2) }),
            {
              autocomplete: [
                `transform-origin-(${Object.keys(M).join("|")})`,
                `origin-(${Object.keys(M).join("|")})`
              ]
            }
          ],
          [
            /^(?:transform-)?perspect(?:ive)?-(.+)$/,
            ([, e2]) => {
              let t2 = l2.bracket.cssvar.px.numberWithUnit(e2);
              if (t2 != null)
                return { "-webkit-perspective": t2, perspective: t2 };
            }
          ],
          [
            /^(?:transform-)?perspect(?:ive)?-origin-(.+)$/,
            ([, e2]) => {
              let t2 = l2.bracket.cssvar(e2) ?? (e2.length >= 3 ? M[e2] : void 0);
              if (t2 != null)
                return { "-webkit-perspective-origin": t2, "perspective-origin": t2 };
            }
          ],
          [/^(?:transform-)?translate-()(.+)$/, uo],
          [/^(?:transform-)?translate-([xyz])-(.+)$/, uo],
          [/^(?:transform-)?rotate-()(.+)$/, mo],
          [/^(?:transform-)?rotate-([xyz])-(.+)$/, mo],
          [/^(?:transform-)?skew-()(.+)$/, ho],
          [
            /^(?:transform-)?skew-([xy])-(.+)$/,
            ho,
            {
              autocomplete: [
                "transform-skew-(x|y)-<percent>",
                "skew-(x|y)-<percent>"
              ]
            }
          ],
          [/^(?:transform-)?scale-()(.+)$/, po],
          [
            /^(?:transform-)?scale-([xyz])-(.+)$/,
            po,
            {
              autocomplete: [
                `transform-(${hr.join("|")})-<percent>`,
                `transform-(${hr.join("|")})-(x|y|z)-<percent>`,
                `(${hr.join("|")})-<percent>`,
                `(${hr.join("|")})-(x|y|z)-<percent>`
              ]
            }
          ],
          [
            /^(?:transform-)?preserve-3d$/,
            () => ({ "transform-style": "preserve-3d" })
          ],
          [/^(?:transform-)?preserve-flat$/, () => ({ "transform-style": "flat" })],
          ["transform", { transform: de }],
          ["transform-cpu", { transform: de }],
          ["transform-gpu", { transform: Lc }],
          ["transform-none", { transform: "none" }],
          ...v("transform")
        ];
        function uo([, e2, t2], { theme: r2 }) {
          var _a3;
          let n2 = ((_a3 = r2.spacing) == null ? void 0 : _a3[t2]) ?? l2.bracket.cssvar.fraction.rem(t2);
          if (n2 != null)
            return [
              ...at2[e2].map((o2) => [`--un-translate${o2}`, n2]),
              ["transform", de]
            ];
        }
        function po([, e2, t2]) {
          let r2 = l2.bracket.cssvar.fraction.percent(t2);
          if (r2 != null)
            return [...at2[e2].map((n2) => [`--un-scale${n2}`, r2]), ["transform", de]];
        }
        function mo([, e2 = "", t2]) {
          let r2 = l2.bracket.cssvar.degree(t2);
          if (r2 != null)
            return e2 ? { "--un-rotate": 0, [`--un-rotate-${e2}`]: r2, transform: de } : {
              "--un-rotate-x": 0,
              "--un-rotate-y": 0,
              "--un-rotate-z": 0,
              "--un-rotate": r2,
              transform: de
            };
        }
        function ho([, e2, t2]) {
          let r2 = l2.bracket.cssvar.degree(t2);
          if (r2 != null)
            return [...at2[e2].map((n2) => [`--un-skew${n2}`, r2]), ["transform", de]];
        }
        var Wc = {
          backface: "backface-visibility",
          break: "word-break",
          case: "text-transform",
          content: "align-content",
          fw: "font-weight",
          items: "align-items",
          justify: "justify-content",
          select: "user-select",
          self: "align-self",
          vertical: "vertical-align",
          visible: "visibility",
          whitespace: "white-space",
          ws: "white-space"
        }, xr = [
          [
            /^(.+?)-(\$.+)$/,
            ([, e2, t2]) => {
              let r2 = Wc[e2];
              if (r2)
                return { [r2]: l2.cssvar(t2) };
            }
          ]
        ], yr = [
          [
            /^\[(.*)\]$/,
            ([e2, t2], { theme: r2 }) => {
              if (!t2.includes(":"))
                return;
              let [n2, ...o2] = t2.split(":"), i = o2.join(":");
              if (!Bc(t2) && /^[a-z-]+$/.test(n2) && Nc(i)) {
                let a;
                if (Xn(i) && (a = Zn(i, r2)), (!a || a === i) && (a = l2.bracket(`[${i}]`)), a)
                  return { [n2]: a };
              }
            }
          ]
        ];
        function Nc(e2) {
          let t2 = 0;
          function r2(n2) {
            for (; t2 < e2.length; )
              if (t2 += 1, e2[t2] === n2)
                return true;
            return false;
          }
          for (t2 = 0; t2 < e2.length; t2++) {
            let n2 = e2[t2];
            if ("\"`'".includes(n2)) {
              if (!r2(n2))
                return false;
            } else if (n2 === "(") {
              if (!r2(")"))
                return false;
            } else if ("[]{}:".includes(n2))
              return false;
          }
          return true;
        }
        function Bc(e2) {
          if (!e2.includes("://"))
            return false;
          try {
            return new URL(e2).host !== "";
          } catch {
            return false;
          }
        }
        var vr = [
          [
            /^(where|\?)$/,
            (e2, { constructCSS: t2, generator: r2 }) => {
              if (r2.userConfig.envMode === "dev")
                return `@keyframes __un_qm{0%{box-shadow:inset 4px 4px #ff1e90, inset -4px -4px #ff1e90}100%{box-shadow:inset 8px 8px #3399ff, inset -8px -8px #3399ff}}
${t2({ animation: "__un_qm 0.5s ease-in-out alternate infinite" })}`;
            }
          ]
        ];
        var wr = [
          [
            /^fill-(.+)$/,
            j("fill", "fill", "backgroundColor"),
            { autocomplete: "fill-$colors" }
          ],
          [
            /^fill-op(?:acity)?-?(.+)$/,
            ([, e2]) => ({ "--un-fill-opacity": l2.bracket.percent.cssvar(e2) }),
            { autocomplete: "fill-(op|opacity)-<percent>" }
          ],
          ["fill-none", { fill: "none" }],
          [
            /^stroke-(?:width-|size-)?(.+)$/,
            go,
            { autocomplete: ["stroke-width-$lineWidth", "stroke-size-$lineWidth"] }
          ],
          [
            /^stroke-dash-(.+)$/,
            ([, e2]) => ({ "stroke-dasharray": l2.bracket.cssvar.number(e2) }),
            { autocomplete: "stroke-dash-<num>" }
          ],
          [
            /^stroke-offset-(.+)$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "stroke-dashoffset": ((_a3 = t2.lineWidth) == null ? void 0 : _a3[e2]) ?? l2.bracket.cssvar.px.numberWithUnit(e2)
              };
            },
            { autocomplete: "stroke-offset-$lineWidth" }
          ],
          [/^stroke-(.+)$/, Dc, { autocomplete: "stroke-$colors" }],
          [
            /^stroke-op(?:acity)?-?(.+)$/,
            ([, e2]) => ({ "--un-stroke-opacity": l2.bracket.percent.cssvar(e2) }),
            { autocomplete: "stroke-(op|opacity)-<percent>" }
          ],
          ["stroke-cap-square", { "stroke-linecap": "square" }],
          ["stroke-cap-round", { "stroke-linecap": "round" }],
          ["stroke-cap-auto", { "stroke-linecap": "butt" }],
          ["stroke-join-arcs", { "stroke-linejoin": "arcs" }],
          ["stroke-join-bevel", { "stroke-linejoin": "bevel" }],
          ["stroke-join-clip", { "stroke-linejoin": "miter-clip" }],
          ["stroke-join-round", { "stroke-linejoin": "round" }],
          ["stroke-join-auto", { "stroke-linejoin": "miter" }],
          ["stroke-none", { stroke: "none" }]
        ];
        function go([, e2], { theme: t2 }) {
          var _a3;
          return {
            "stroke-width": ((_a3 = t2.lineWidth) == null ? void 0 : _a3[e2]) ?? l2.bracket.cssvar.fraction.px.number(e2)
          };
        }
        function Dc(e2, t2) {
          return q2(l2.bracket(e2[1])) ? go(e2, t2) : j("stroke", "stroke", "borderColor")(e2, t2);
        }
        var bo = [
          xr,
          yr,
          dr,
          mr,
          It2,
          vt2,
          wt2,
          oo,
          wr,
          yt2,
          Jt2,
          Qt2,
          Tt2,
          Et,
          jt,
          rr,
          kt,
          zt2,
          Ot2,
          nr,
          mt2,
          or,
          ir,
          lr,
          sr,
          Rt2,
          Vt2,
          At,
          Mt2,
          ur,
          pr,
          Gt2,
          Kt2,
          qt2,
          Yt2,
          dt2,
          Xt2,
          Zt2,
          er,
          Pt,
          gt2,
          bt2,
          Ft2,
          Ne,
          Be2,
          Ut2,
          Lt,
          Wt2,
          Nt2,
          Bt2,
          Dt,
          Ct2,
          br,
          xt2,
          $t2,
          Ht2,
          tr,
          vr
        ].flat(1);
        var Xr = {
          inherit: "inherit",
          current: "currentColor",
          transparent: "transparent",
          black: "#000",
          white: "#fff",
          rose: {
            50: "#fff1f2",
            100: "#ffe4e6",
            200: "#fecdd3",
            300: "#fda4af",
            400: "#fb7185",
            500: "#f43f5e",
            600: "#e11d48",
            700: "#be123c",
            800: "#9f1239",
            900: "#881337",
            950: "#4c0519"
          },
          pink: {
            50: "#fdf2f8",
            100: "#fce7f3",
            200: "#fbcfe8",
            300: "#f9a8d4",
            400: "#f472b6",
            500: "#ec4899",
            600: "#db2777",
            700: "#be185d",
            800: "#9d174d",
            900: "#831843",
            950: "#500724"
          },
          fuchsia: {
            50: "#fdf4ff",
            100: "#fae8ff",
            200: "#f5d0fe",
            300: "#f0abfc",
            400: "#e879f9",
            500: "#d946ef",
            600: "#c026d3",
            700: "#a21caf",
            800: "#86198f",
            900: "#701a75",
            950: "#4a044e"
          },
          purple: {
            50: "#faf5ff",
            100: "#f3e8ff",
            200: "#e9d5ff",
            300: "#d8b4fe",
            400: "#c084fc",
            500: "#a855f7",
            600: "#9333ea",
            700: "#7e22ce",
            800: "#6b21a8",
            900: "#581c87",
            950: "#3b0764"
          },
          violet: {
            50: "#f5f3ff",
            100: "#ede9fe",
            200: "#ddd6fe",
            300: "#c4b5fd",
            400: "#a78bfa",
            500: "#8b5cf6",
            600: "#7c3aed",
            700: "#6d28d9",
            800: "#5b21b6",
            900: "#4c1d95",
            950: "#2e1065"
          },
          indigo: {
            50: "#eef2ff",
            100: "#e0e7ff",
            200: "#c7d2fe",
            300: "#a5b4fc",
            400: "#818cf8",
            500: "#6366f1",
            600: "#4f46e5",
            700: "#4338ca",
            800: "#3730a3",
            900: "#312e81",
            950: "#1e1b4b"
          },
          blue: {
            50: "#eff6ff",
            100: "#dbeafe",
            200: "#bfdbfe",
            300: "#93c5fd",
            400: "#60a5fa",
            500: "#3b82f6",
            600: "#2563eb",
            700: "#1d4ed8",
            800: "#1e40af",
            900: "#1e3a8a",
            950: "#172554"
          },
          sky: {
            50: "#f0f9ff",
            100: "#e0f2fe",
            200: "#bae6fd",
            300: "#7dd3fc",
            400: "#38bdf8",
            500: "#0ea5e9",
            600: "#0284c7",
            700: "#0369a1",
            800: "#075985",
            900: "#0c4a6e",
            950: "#082f49"
          },
          cyan: {
            50: "#ecfeff",
            100: "#cffafe",
            200: "#a5f3fc",
            300: "#67e8f9",
            400: "#22d3ee",
            500: "#06b6d4",
            600: "#0891b2",
            700: "#0e7490",
            800: "#155e75",
            900: "#164e63",
            950: "#083344"
          },
          teal: {
            50: "#f0fdfa",
            100: "#ccfbf1",
            200: "#99f6e4",
            300: "#5eead4",
            400: "#2dd4bf",
            500: "#14b8a6",
            600: "#0d9488",
            700: "#0f766e",
            800: "#115e59",
            900: "#134e4a",
            950: "#042f2e"
          },
          emerald: {
            50: "#ecfdf5",
            100: "#d1fae5",
            200: "#a7f3d0",
            300: "#6ee7b7",
            400: "#34d399",
            500: "#10b981",
            600: "#059669",
            700: "#047857",
            800: "#065f46",
            900: "#064e3b",
            950: "#022c22"
          },
          green: {
            50: "#f0fdf4",
            100: "#dcfce7",
            200: "#bbf7d0",
            300: "#86efac",
            400: "#4ade80",
            500: "#22c55e",
            600: "#16a34a",
            700: "#15803d",
            800: "#166534",
            900: "#14532d",
            950: "#052e16"
          },
          lime: {
            50: "#f7fee7",
            100: "#ecfccb",
            200: "#d9f99d",
            300: "#bef264",
            400: "#a3e635",
            500: "#84cc16",
            600: "#65a30d",
            700: "#4d7c0f",
            800: "#3f6212",
            900: "#365314",
            950: "#1a2e05"
          },
          yellow: {
            50: "#fefce8",
            100: "#fef9c3",
            200: "#fef08a",
            300: "#fde047",
            400: "#facc15",
            500: "#eab308",
            600: "#ca8a04",
            700: "#a16207",
            800: "#854d0e",
            900: "#713f12",
            950: "#422006"
          },
          amber: {
            50: "#fffbeb",
            100: "#fef3c7",
            200: "#fde68a",
            300: "#fcd34d",
            400: "#fbbf24",
            500: "#f59e0b",
            600: "#d97706",
            700: "#b45309",
            800: "#92400e",
            900: "#78350f",
            950: "#451a03"
          },
          orange: {
            50: "#fff7ed",
            100: "#ffedd5",
            200: "#fed7aa",
            300: "#fdba74",
            400: "#fb923c",
            500: "#f97316",
            600: "#ea580c",
            700: "#c2410c",
            800: "#9a3412",
            900: "#7c2d12",
            950: "#431407"
          },
          red: {
            50: "#fef2f2",
            100: "#fee2e2",
            200: "#fecaca",
            300: "#fca5a5",
            400: "#f87171",
            500: "#ef4444",
            600: "#dc2626",
            700: "#b91c1c",
            800: "#991b1b",
            900: "#7f1d1d",
            950: "#450a0a"
          },
          gray: {
            50: "#f9fafb",
            100: "#f3f4f6",
            200: "#e5e7eb",
            300: "#d1d5db",
            400: "#9ca3af",
            500: "#6b7280",
            600: "#4b5563",
            700: "#374151",
            800: "#1f2937",
            900: "#111827",
            950: "#030712"
          },
          slate: {
            50: "#f8fafc",
            100: "#f1f5f9",
            200: "#e2e8f0",
            300: "#cbd5e1",
            400: "#94a3b8",
            500: "#64748b",
            600: "#475569",
            700: "#334155",
            800: "#1e293b",
            900: "#0f172a",
            950: "#020617"
          },
          zinc: {
            50: "#fafafa",
            100: "#f4f4f5",
            200: "#e4e4e7",
            300: "#d4d4d8",
            400: "#a1a1aa",
            500: "#71717a",
            600: "#52525b",
            700: "#3f3f46",
            800: "#27272a",
            900: "#18181b",
            950: "#09090b"
          },
          neutral: {
            50: "#fafafa",
            100: "#f5f5f5",
            200: "#e5e5e5",
            300: "#d4d4d4",
            400: "#a3a3a3",
            500: "#737373",
            600: "#525252",
            700: "#404040",
            800: "#262626",
            900: "#171717",
            950: "#0a0a0a"
          },
          stone: {
            50: "#fafaf9",
            100: "#f5f5f4",
            200: "#e7e5e4",
            300: "#d6d3d1",
            400: "#a8a29e",
            500: "#78716c",
            600: "#57534e",
            700: "#44403c",
            800: "#292524",
            900: "#1c1917",
            950: "#0c0a09"
          },
          light: {
            50: "#fdfdfd",
            100: "#fcfcfc",
            200: "#fafafa",
            300: "#f8f9fa",
            400: "#f6f6f6",
            500: "#f2f2f2",
            600: "#f1f3f5",
            700: "#e9ecef",
            800: "#dee2e6",
            900: "#dde1e3",
            950: "#d8dcdf"
          },
          dark: {
            50: "#4a4a4a",
            100: "#3c3c3c",
            200: "#323232",
            300: "#2d2d2d",
            400: "#222222",
            500: "#1f1f1f",
            600: "#1c1c1e",
            700: "#1b1b1b",
            800: "#181818",
            900: "#0f0f0f",
            950: "#080808"
          },
          get lightblue() {
            return this.sky;
          },
          get lightBlue() {
            return this.sky;
          },
          get warmgray() {
            return this.stone;
          },
          get warmGray() {
            return this.stone;
          },
          get truegray() {
            return this.neutral;
          },
          get trueGray() {
            return this.neutral;
          },
          get coolgray() {
            return this.gray;
          },
          get coolGray() {
            return this.gray;
          },
          get bluegray() {
            return this.slate;
          },
          get blueGray() {
            return this.slate;
          }
        };
        Object.values(Xr).forEach((e2) => {
          typeof e2 != "string" && e2 !== void 0 && (e2.DEFAULT = e2.DEFAULT || e2[400], Object.keys(e2).forEach((t2) => {
            let r2 = +t2 / 100;
            r2 === Math.round(r2) && (e2[r2] = e2[t2]);
          }));
        });
        var xo = {
          sans: [
            "ui-sans-serif",
            "system-ui",
            "-apple-system",
            "BlinkMacSystemFont",
            '"Segoe UI"',
            "Roboto",
            '"Helvetica Neue"',
            "Arial",
            '"Noto Sans"',
            "sans-serif",
            '"Apple Color Emoji"',
            '"Segoe UI Emoji"',
            '"Segoe UI Symbol"',
            '"Noto Color Emoji"'
          ].join(","),
          serif: [
            "ui-serif",
            "Georgia",
            "Cambria",
            '"Times New Roman"',
            "Times",
            "serif"
          ].join(","),
          mono: [
            "ui-monospace",
            "SFMono-Regular",
            "Menlo",
            "Monaco",
            "Consolas",
            '"Liberation Mono"',
            '"Courier New"',
            "monospace"
          ].join(",")
        }, yo = {
          xs: ["0.75rem", "1rem"],
          sm: ["0.875rem", "1.25rem"],
          base: ["1rem", "1.5rem"],
          lg: ["1.125rem", "1.75rem"],
          xl: ["1.25rem", "1.75rem"],
          "2xl": ["1.5rem", "2rem"],
          "3xl": ["1.875rem", "2.25rem"],
          "4xl": ["2.25rem", "2.5rem"],
          "5xl": ["3rem", "1"],
          "6xl": ["3.75rem", "1"],
          "7xl": ["4.5rem", "1"],
          "8xl": ["6rem", "1"],
          "9xl": ["8rem", "1"]
        }, vo = {
          DEFAULT: "1.5rem",
          xs: "0.5rem",
          sm: "1rem",
          md: "1.5rem",
          lg: "2rem",
          xl: "2.5rem",
          "2xl": "3rem",
          "3xl": "4rem"
        }, wo = {
          DEFAULT: "1.5rem",
          none: "0",
          sm: "thin",
          md: "medium",
          lg: "thick"
        }, $o = {
          DEFAULT: ["0 0 1px rgb(0 0 0 / 0.2)", "0 0 1px rgb(1 0 5 / 0.1)"],
          none: "0 0 rgb(0 0 0 / 0)",
          sm: "1px 1px 3px rgb(36 37 47 / 0.25)",
          md: [
            "0 1px 2px rgb(30 29 39 / 0.19)",
            "1px 2px 4px rgb(54 64 147 / 0.18)"
          ],
          lg: ["3px 3px 6px rgb(0 0 0 / 0.26)", "0 0 5px rgb(15 3 86 / 0.22)"],
          xl: [
            "1px 1px 3px rgb(0 0 0 / 0.29)",
            "2px 4px 7px rgb(73 64 125 / 0.35)"
          ]
        }, ko = {
          none: "1",
          tight: "1.25",
          snug: "1.375",
          normal: "1.5",
          relaxed: "1.625",
          loose: "2"
        }, Zr = {
          tighter: "-0.05em",
          tight: "-0.025em",
          normal: "0em",
          wide: "0.025em",
          wider: "0.05em",
          widest: "0.1em"
        }, So = {
          thin: "100",
          extralight: "200",
          light: "300",
          normal: "400",
          medium: "500",
          semibold: "600",
          bold: "700",
          extrabold: "800",
          black: "900"
        }, Co = Zr;
        var Jr = {
          sm: "640px",
          md: "768px",
          lg: "1024px",
          xl: "1280px",
          "2xl": "1536px"
        }, Ro = { ...Jr }, To = { DEFAULT: "1px", none: "0" }, Eo = {
          DEFAULT: "1rem",
          none: "0",
          xs: "0.75rem",
          sm: "0.875rem",
          lg: "1.125rem",
          xl: "1.25rem",
          "2xl": "1.5rem",
          "3xl": "1.875rem",
          "4xl": "2.25rem",
          "5xl": "3rem",
          "6xl": "3.75rem",
          "7xl": "4.5rem",
          "8xl": "6rem",
          "9xl": "8rem"
        }, jo = {
          DEFAULT: "150ms",
          none: "0s",
          75: "75ms",
          100: "100ms",
          150: "150ms",
          200: "200ms",
          300: "300ms",
          500: "500ms",
          700: "700ms",
          1e3: "1000ms"
        }, zo = {
          DEFAULT: "0.25rem",
          none: "0",
          sm: "0.125rem",
          md: "0.375rem",
          lg: "0.5rem",
          xl: "0.75rem",
          "2xl": "1rem",
          "3xl": "1.5rem",
          full: "9999px"
        }, Oo = {
          DEFAULT: [
            "var(--un-shadow-inset) 0 1px 3px 0 rgb(0 0 0 / 0.1)",
            "var(--un-shadow-inset) 0 1px 2px -1px rgb(0 0 0 / 0.1)"
          ],
          none: "0 0 rgb(0 0 0 / 0)",
          sm: "var(--un-shadow-inset) 0 1px 2px 0 rgb(0 0 0 / 0.05)",
          md: [
            "var(--un-shadow-inset) 0 4px 6px -1px rgb(0 0 0 / 0.1)",
            "var(--un-shadow-inset) 0 2px 4px -2px rgb(0 0 0 / 0.1)"
          ],
          lg: [
            "var(--un-shadow-inset) 0 10px 15px -3px rgb(0 0 0 / 0.1)",
            "var(--un-shadow-inset) 0 4px 6px -4px rgb(0 0 0 / 0.1)"
          ],
          xl: [
            "var(--un-shadow-inset) 0 20px 25px -5px rgb(0 0 0 / 0.1)",
            "var(--un-shadow-inset) 0 8px 10px -6px rgb(0 0 0 / 0.1)"
          ],
          "2xl": "var(--un-shadow-inset) 0 25px 50px -12px rgb(0 0 0 / 0.25)",
          inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)"
        }, Ao = {
          DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
          linear: "linear",
          in: "cubic-bezier(0.4, 0, 1, 1)",
          out: "cubic-bezier(0, 0, 0.2, 1)",
          "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
        }, Vo = { DEFAULT: "1px", none: "0" }, _o = { auto: "auto" }, Po = { mouse: "(hover) and (pointer: fine)" };
        var Mo = {
          DEFAULT: "8px",
          0: "0",
          sm: "4px",
          md: "12px",
          lg: "16px",
          xl: "24px",
          "2xl": "40px",
          "3xl": "64px"
        }, Fo = {
          DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
          sm: "0 1px 1px rgb(0 0 0 / 0.05)",
          md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
          lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
          xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
          "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
          none: "0 0 rgb(0 0 0 / 0)"
        };
        var De2 = {
          xs: "20rem",
          sm: "24rem",
          md: "28rem",
          lg: "32rem",
          xl: "36rem",
          "2xl": "42rem",
          "3xl": "48rem",
          "4xl": "56rem",
          "5xl": "64rem",
          "6xl": "72rem",
          "7xl": "80rem",
          prose: "65ch"
        }, Qr = { auto: "auto", ...De2, screen: "100vw" }, Ie = { none: "none", ...De2, screen: "100vw" }, en2 = { auto: "auto", ...De2, screen: "100vh" }, Ke2 = { none: "none", ...De2, screen: "100vh" }, Uo = Object.fromEntries(
          Object.entries(De2).map(([e2, t2]) => [e2, `(min-width: ${t2})`])
        );
        var Lo = { ...gr, ...cr, ...ar };
        var Wo = {
          width: Qr,
          height: en2,
          maxWidth: Ie,
          maxHeight: Ke2,
          minWidth: Ie,
          minHeight: Ke2,
          inlineSize: Qr,
          blockSize: en2,
          maxInlineSize: Ie,
          maxBlockSize: Ke2,
          minInlineSize: Ie,
          minBlockSize: Ke2,
          colors: Xr,
          fontFamily: xo,
          fontSize: yo,
          fontWeight: So,
          breakpoints: Jr,
          verticalBreakpoints: Ro,
          borderRadius: zo,
          lineHeight: ko,
          letterSpacing: Zr,
          wordSpacing: Co,
          boxShadow: Oo,
          textIndent: vo,
          textShadow: $o,
          textStrokeWidth: wo,
          blur: Mo,
          dropShadow: Fo,
          easing: Ao,
          lineWidth: To,
          spacing: Eo,
          duration: jo,
          ringWidth: Vo,
          preflightBase: Lo,
          containers: Uo,
          zIndex: _o,
          media: Po
        };
        var No = {
          name: "aria",
          match(e2, t2) {
            var _a3;
            let r2 = L("aria-", e2, t2.generator.config.separators);
            if (r2) {
              let [n2, o2] = r2, i = l2.bracket(n2) ?? ((_a3 = t2.theme.aria) == null ? void 0 : _a3[n2]) ?? "";
              if (i)
                return { matcher: o2, selector: (a) => `${a}[aria-${i}]` };
            }
          }
        };
        function Bo(e2) {
          var _a3;
          let t2 = ((_a3 = e2.match(/^-?[0-9]+\.?[0-9]*/)) == null ? void 0 : _a3[0]) || "", r2 = e2.slice(t2.length);
          if (r2 === "px") {
            let n2 = Number.parseFloat(t2) - 0.1;
            return Number.isNaN(n2) ? e2 : `${n2}${r2}`;
          }
          return `calc(${e2} - 0.1px)`;
        }
        function Do() {
          let e2 = {};
          return {
            name: "breakpoints",
            match(t2, r2) {
              let n2 = (fe2(r2) ?? []).map(({ point: o2, size: i }, a) => [o2, i, a]);
              for (let [o2, i, a] of n2) {
                e2[o2] || (e2[o2] = new RegExp(
                  `^((?:([al]t-|[<~]|max-))?${o2}(?:${r2.generator.config.separators.join("|")}))`
                ));
                let s2 = t2.match(e2[o2]);
                if (!s2)
                  continue;
                let [, c] = s2, f = t2.slice(c.length);
                if (f === "container")
                  continue;
                let u = c.startsWith("lt-") || c.startsWith("<") || c.startsWith("max-"), p2 = c.startsWith("at-") || c.startsWith("~"), d = 1e3;
                return u ? (d -= a + 1, {
                  matcher: f,
                  handle: (h2, x) => x({
                    ...h2,
                    parent: `${h2.parent ? `${h2.parent} $$ ` : ""}@media (max-width: ${Bo(i)})`,
                    parentOrder: d
                  })
                }) : (d += a + 1, p2 && a < n2.length - 1 ? {
                  matcher: f,
                  handle: (h2, x) => x({
                    ...h2,
                    parent: `${h2.parent ? `${h2.parent} $$ ` : ""}@media (min-width: ${i}) and (max-width: ${Bo(n2[a + 1][1])})`,
                    parentOrder: d
                  })
                } : {
                  matcher: f,
                  handle: (h2, x) => x({
                    ...h2,
                    parent: `${h2.parent ? `${h2.parent} $$ ` : ""}@media (min-width: ${i})`,
                    parentOrder: d
                  })
                });
              }
            },
            multiPass: true,
            autocomplete: "(at-|lt-|max-|)$breakpoints:"
          };
        }
        function Ge2(e2, t2) {
          return {
            name: `combinator:${e2}`,
            match(r2, n2) {
              if (!r2.startsWith(e2))
                return;
              let o2 = n2.generator.config.separators, i = ie(`${e2}-`, r2, o2);
              if (!i) {
                for (let s2 of o2)
                  if (r2.startsWith(`${e2}${s2}`)) {
                    i = ["", r2.slice(e2.length + s2.length)];
                    break;
                  }
                if (!i)
                  return;
              }
              let a = l2.bracket(i[0]) ?? "";
              return a === "" && (a = "*"), { matcher: i[1], selector: (s2) => `${s2}${t2}${a}` };
            },
            multiPass: true
          };
        }
        var Io = [
          Ge2("all", " "),
          Ge2("children", ">"),
          Ge2("next", "+"),
          Ge2("sibling", "+"),
          Ge2("siblings", "~")
        ];
        var Ko = {
          name: "@",
          match(e2, t2) {
            var _a3;
            if (e2.startsWith("@container"))
              return;
            let r2 = L("@", e2, t2.generator.config.separators);
            if (r2) {
              let [n2, o2, i] = r2, a = l2.bracket(n2), s2;
              if (a) {
                let c = l2.numberWithUnit(a);
                c && (s2 = `(min-width: ${c})`);
              } else
                s2 = ((_a3 = t2.theme.containers) == null ? void 0 : _a3[n2]) ?? "";
              if (s2)
                return ne2(
                  "The container query variant is experimental and may not follow semver."
                ), {
                  matcher: o2,
                  handle: (c, f) => f({
                    ...c,
                    parent: `${c.parent ? `${c.parent} $$ ` : ""}@container${i ? ` ${i} ` : " "}${s2}`
                  })
                };
            }
          },
          multiPass: true
        };
        function Go(e2 = {}) {
          if ((e2 == null ? void 0 : e2.dark) === "class" || typeof e2.dark == "object") {
            let { dark: t2 = ".dark", light: r2 = ".light" } = typeof e2.dark == "string" ? {} : e2.dark;
            return [
              I2("dark", (n2) => ({ prefix: `${t2} $$ ${n2.prefix}` })),
              I2("light", (n2) => ({ prefix: `${r2} $$ ${n2.prefix}` }))
            ];
          }
          return [
            U2("dark", "@media (prefers-color-scheme: dark)"),
            U2("light", "@media (prefers-color-scheme: light)")
          ];
        }
        var Ho = {
          name: "data",
          match(e2, t2) {
            var _a3;
            let r2 = L("data-", e2, t2.generator.config.separators);
            if (r2) {
              let [n2, o2] = r2, i = l2.bracket(n2) ?? ((_a3 = t2.theme.data) == null ? void 0 : _a3[n2]) ?? "";
              if (i)
                return { matcher: o2, selector: (a) => `${a}[data-${i}]` };
            }
          }
        };
        function $r(e2) {
          return {
            name: `${e2}-data`,
            match(t2, r2) {
              var _a3;
              let n2 = L(`${e2}-data-`, t2, r2.generator.config.separators);
              if (n2) {
                let [o2, i] = n2, a = l2.bracket(o2) ?? ((_a3 = r2.theme.data) == null ? void 0 : _a3[o2]) ?? "";
                if (a)
                  return { matcher: `${e2}-[[data-${a}]]:${i}` };
              }
            }
          };
        }
        var qo = [$r("group"), $r("peer"), $r("parent"), $r("previous")];
        var Yo = [
          I2("rtl", (e2) => ({ prefix: `[dir="rtl"] $$ ${e2.prefix}` })),
          I2("ltr", (e2) => ({ prefix: `[dir="ltr"] $$ ${e2.prefix}` }))
        ];
        var Xo = {
          name: "selector",
          match(e2, t2) {
            let r2 = ie("selector-", e2, t2.generator.config.separators);
            if (r2) {
              let [n2, o2] = r2, i = l2.bracket(n2);
              if (i)
                return { matcher: o2, selector: () => i };
            }
          }
        }, Zo = {
          name: "layer",
          match(e2, t2) {
            let r2 = L("layer-", e2, t2.generator.config.separators);
            if (r2) {
              let [n2, o2] = r2, i = l2.bracket(n2) ?? n2;
              if (i)
                return {
                  matcher: o2,
                  handle: (a, s2) => s2({
                    ...a,
                    parent: `${a.parent ? `${a.parent} $$ ` : ""}@layer ${i}`
                  })
                };
            }
          }
        }, Jo = {
          name: "uno-layer",
          match(e2, t2) {
            let r2 = L("uno-layer-", e2, t2.generator.config.separators);
            if (r2) {
              let [n2, o2] = r2, i = l2.bracket(n2) ?? n2;
              if (i)
                return { matcher: o2, layer: i };
            }
          }
        }, Qo = {
          name: "scope",
          match(e2, t2) {
            let r2 = ie("scope-", e2, t2.generator.config.separators);
            if (r2) {
              let [n2, o2] = r2, i = l2.bracket(n2);
              if (i)
                return { matcher: o2, selector: (a) => `${i} $$ ${a}` };
            }
          }
        }, ei = {
          name: "variables",
          match(e2, t2) {
            if (!e2.startsWith("["))
              return;
            let [r2, n2] = ve2(e2, "[", "]") ?? [];
            if (!(r2 && n2))
              return;
            let o2;
            for (let s2 of t2.generator.config.separators)
              if (n2.startsWith(s2)) {
                o2 = n2.slice(s2.length);
                break;
              }
            if (o2 == null)
              return;
            let i = l2.bracket(r2) ?? "", a = i.startsWith("@");
            if (a || i.includes("&"))
              return {
                matcher: o2,
                handle(s2, c) {
                  let f = a ? { parent: `${s2.parent ? `${s2.parent} $$ ` : ""}${i}` } : { selector: i.replace(/&/g, s2.selector) };
                  return c({ ...s2, ...f });
                }
              };
          },
          multiPass: true
        };
        var ti = /^-?[0-9.]+(?:[a-z]+|%)?$/, ri = /-?[0-9.]+(?:[a-z]+|%)?/, Ic = [/\b(opacity|color|flex|backdrop-filter|^filter|transform)\b/];
        function Kc(e2) {
          let t2 = e2.match(Ve);
          if (t2) {
            let [r2, n2] = oe(`(${t2[2]})${t2[3]}`, "(", ")", " ") ?? [];
            if (r2)
              return `calc(${t2[1]}${r2} * -1)${n2 ? ` ${n2}` : ""}`;
          }
        }
        var Gc = /\b(hue-rotate)\s*(\(.*)/;
        function Hc(e2) {
          let t2 = e2.match(Gc);
          if (t2) {
            let [r2, n2] = oe(t2[2], "(", ")", " ") ?? [];
            if (r2) {
              let o2 = ti.test(r2.slice(1, -1)) ? r2.replace(ri, (i) => i.startsWith("-") ? i.slice(1) : `-${i}`) : `(calc(${r2} * -1))`;
              return `${t2[1]}${o2}${n2 ? ` ${n2}` : ""}`;
            }
          }
        }
        var ni = {
          name: "negative",
          match(e2) {
            if (e2.startsWith("-"))
              return {
                matcher: e2.slice(1),
                body: (t2) => {
                  if (t2.find((n2) => n2[0] === eo))
                    return;
                  let r2 = false;
                  return t2.forEach((n2) => {
                    var _a3;
                    let o2 = (_a3 = n2[1]) == null ? void 0 : _a3.toString();
                    if (!o2 || o2 === "0" || Ic.some((s2) => s2.test(n2[0])))
                      return;
                    let i = Kc(o2);
                    if (i) {
                      n2[1] = i, r2 = true;
                      return;
                    }
                    let a = Hc(o2);
                    if (a) {
                      n2[1] = a, r2 = true;
                      return;
                    }
                    ti.test(o2) && (n2[1] = o2.replace(
                      ri,
                      (s2) => s2.startsWith("-") ? s2.slice(1) : `-${s2}`
                    ), r2 = true);
                  }), r2 ? t2 : [];
                }
              };
          }
        };
        function oi() {
          let e2;
          return {
            name: "important",
            match(t2, r2) {
              e2 || (e2 = new RegExp(
                `^(important(?:${r2.generator.config.separators.join("|")})|!)`
              ));
              let n2, o2 = t2.match(e2);
              if (o2 ? n2 = t2.slice(o2[0].length) : t2.endsWith("!") && (n2 = t2.slice(0, -1)), n2)
                return {
                  matcher: n2,
                  body: (i) => (i.forEach((a) => {
                    a[1] && (a[1] += " !important");
                  }), i)
                };
            }
          };
        }
        var ii = U2("print", "@media print"), ai = {
          name: "media",
          match(e2, t2) {
            var _a3;
            let r2 = L("media-", e2, t2.generator.config.separators);
            if (r2) {
              let [n2, o2] = r2, i = l2.bracket(n2) ?? "";
              if (i === "" && (i = ((_a3 = t2.theme.media) == null ? void 0 : _a3[n2]) ?? ""), i)
                return {
                  matcher: o2,
                  handle: (a, s2) => s2({
                    ...a,
                    parent: `${a.parent ? `${a.parent} $$ ` : ""}@media ${i}`
                  })
                };
            }
          },
          multiPass: true
        };
        var si = {
          name: "supports",
          match(e2, t2) {
            var _a3;
            let r2 = L("supports-", e2, t2.generator.config.separators);
            if (r2) {
              let [n2, o2] = r2, i = l2.bracket(n2) ?? "";
              if (i === "" && (i = ((_a3 = t2.theme.supports) == null ? void 0 : _a3[n2]) ?? ""), i)
                return {
                  matcher: o2,
                  handle: (a, s2) => s2({
                    ...a,
                    parent: `${a.parent ? `${a.parent} $$ ` : ""}@supports ${i}`
                  })
                };
            }
          },
          multiPass: true
        };
        var Re2 = Object.fromEntries(
          [
            ["first-letter", "::first-letter"],
            ["first-line", "::first-line"],
            "any-link",
            "link",
            "visited",
            "target",
            ["open", "[open]"],
            "default",
            "checked",
            "indeterminate",
            "placeholder-shown",
            "autofill",
            "optional",
            "required",
            "valid",
            "invalid",
            "user-valid",
            "user-invalid",
            "in-range",
            "out-of-range",
            "read-only",
            "read-write",
            "empty",
            "focus-within",
            "hover",
            "focus",
            "focus-visible",
            "active",
            "enabled",
            "disabled",
            "root",
            "empty",
            ["even-of-type", ":nth-of-type(even)"],
            ["even", ":nth-child(even)"],
            ["odd-of-type", ":nth-of-type(odd)"],
            ["odd", ":nth-child(odd)"],
            "first-of-type",
            ["first", ":first-child"],
            "last-of-type",
            ["last", ":last-child"],
            "only-child",
            "only-of-type",
            ["backdrop-element", "::backdrop"],
            ["placeholder", "::placeholder"],
            ["before", "::before"],
            ["after", "::after"],
            ["selection", "::selection"],
            ["marker", "::marker"],
            ["file", "::file-selector-button"]
          ].map((e2) => Array.isArray(e2) ? e2 : [e2, `:${e2}`])
        ), fi = Object.keys(Re2), Te2 = Object.fromEntries(
          [["backdrop", "::backdrop"]].map(
            (e2) => Array.isArray(e2) ? e2 : [e2, `:${e2}`]
          )
        ), ui = Object.keys(Te2), qc = ["not", "is", "where", "has"], tn2 = Object.entries(Re2).filter(([, e2]) => !e2.startsWith("::")).map(([e2]) => e2).sort((e2, t2) => t2.length - e2.length).join("|"), rn2 = Object.entries(Te2).filter(([, e2]) => !e2.startsWith("::")).map(([e2]) => e2).sort((e2, t2) => t2.length - e2.length).join("|"), me2 = qc.join("|");
        function Yc(e2, t2, r2) {
          let n2 = new RegExp(`^(${re(t2)}:)(\\S+)${re(r2)}\\1`), o2, i, a, s2, c = (p2) => {
            var _a3;
            let d = ie(`${e2}-`, p2, []);
            if (!d)
              return;
            let [h2, x] = d, $2 = l2.bracket(h2);
            if ($2 == null)
              return;
            let y = ((_a3 = x.split(o2, 1)) == null ? void 0 : _a3[0]) ?? "", C2 = `${t2}${Q2(y)}`;
            return [
              y,
              p2.slice(p2.length - (x.length - y.length - 1)),
              $2.includes("&") ? $2.replace(/&/g, C2) : `${C2}${$2}`
            ];
          }, f = (p2) => {
            let d = p2.match(i) || p2.match(a);
            if (!d)
              return;
            let [h2, x, $2] = d, y = d[3] ?? "", C2 = Re2[$2] || Te2[$2] || `:${$2}`;
            return x && (C2 = `:${x}(${C2})`), [y, p2.slice(h2.length), `${t2}${Q2(y)}${C2}`, $2];
          }, u = (p2) => {
            let d = p2.match(s2);
            if (!d)
              return;
            let [h2, x, $2] = d, y = d[3] ?? "", C2 = `:${x}(${$2})`;
            return [y, p2.slice(h2.length), `${t2}${Q2(y)}${C2}`];
          };
          return {
            name: `pseudo:${e2}`,
            match(p2, d) {
              if (o2 && i && a || (o2 = new RegExp(`(?:${d.generator.config.separators.join("|")})`), i = new RegExp(
                `^${e2}-(?:(?:(${me2})-)?(${tn2}))(?:(/\\w+))?(?:${d.generator.config.separators.join("|")})`
              ), a = new RegExp(
                `^${e2}-(?:(?:(${me2})-)?(${rn2}))(?:(/\\w+))?(?:${d.generator.config.separators.filter((b) => b !== "-").join("|")})`
              ), s2 = new RegExp(
                `^${e2}-(?:(${me2})-)?\\[(.+)\\](?:(/\\w+))?(?:${d.generator.config.separators.filter((b) => b !== "-").join("|")})`
              )), !p2.startsWith(e2))
                return;
              let h2 = c(p2) || f(p2) || u(p2);
              if (!h2)
                return;
              let [x, $2, y, C2 = ""] = h2;
              return x !== "" && ne2(
                "The labeled variant is experimental and may not follow semver."
              ), {
                matcher: $2,
                handle: (b, R2) => R2({
                  ...b,
                  prefix: `${y}${r2}${b.prefix}`.replace(n2, "$1$2:"),
                  sort: fi.indexOf(C2) ?? ui.indexOf(C2)
                })
              };
            },
            multiPass: true
          };
        }
        var Xc = [
          "::-webkit-resizer",
          "::-webkit-scrollbar",
          "::-webkit-scrollbar-button",
          "::-webkit-scrollbar-corner",
          "::-webkit-scrollbar-thumb",
          "::-webkit-scrollbar-track",
          "::-webkit-scrollbar-track-piece",
          "::file-selector-button"
        ], ci = Object.entries(Re2).map(([e2]) => e2).sort((e2, t2) => t2.length - e2.length).join("|"), li = Object.entries(Te2).map(([e2]) => e2).sort((e2, t2) => t2.length - e2.length).join("|");
        function pi() {
          let e2, t2;
          return {
            name: "pseudo",
            match(r2, n2) {
              e2 && e2 || (e2 = new RegExp(
                `^(${ci})(?:${n2.generator.config.separators.join("|")})`
              ), t2 = new RegExp(
                `^(${li})(?:${n2.generator.config.separators.filter((i) => i !== "-").join("|")})`
              ));
              let o2 = r2.match(e2) || r2.match(t2);
              if (o2) {
                let i = Re2[o2[1]] || Te2[o2[1]] || `:${o2[1]}`, a = fi.indexOf(o2[1]);
                return a === -1 && (a = ui.indexOf(o2[1])), a === -1 && (a = void 0), {
                  matcher: r2.slice(o2[0].length),
                  handle: (s2, c) => {
                    let f = i.startsWith("::") && !Xc.includes(i) ? { pseudo: `${s2.pseudo}${i}` } : { selector: `${s2.selector}${i}` };
                    return c({ ...s2, ...f, sort: a, noMerge: true });
                  }
                };
              }
            },
            multiPass: true,
            autocomplete: `(${ci}|${li}):`
          };
        }
        function di() {
          let e2, t2, r2;
          return {
            match(n2, o2) {
              e2 && t2 || (e2 = new RegExp(
                `^(${me2})-(${tn2})(?:${o2.generator.config.separators.join("|")})`
              ), t2 = new RegExp(
                `^(${me2})-(${rn2})(?:${o2.generator.config.separators.filter((a) => a !== "-").join("|")})`
              ), r2 = new RegExp(
                `^(${me2})-(\\[.+\\])(?:${o2.generator.config.separators.filter((a) => a !== "-").join("|")})`
              ));
              let i = n2.match(e2) || n2.match(t2) || n2.match(r2);
              if (i) {
                let a = i[1], c = ve2(i[2], "[", "]") ? l2.bracket(i[2]) : Re2[i[2]] || Te2[i[2]] || `:${i[2]}`;
                return {
                  matcher: n2.slice(i[0].length),
                  selector: (f) => `${f}:${a}(${c})`
                };
              }
            },
            multiPass: true,
            autocomplete: `(${me2})-(${tn2}|${rn2}):`
          };
        }
        function mi(e2 = {}) {
          let t2 = !!(e2 == null ? void 0 : e2.attributifyPseudo), r2 = (e2 == null ? void 0 : e2.prefix) ?? "";
          r2 = (Array.isArray(r2) ? r2 : [r2]).filter(Boolean)[0] ?? "";
          let n2 = (o2, i) => Yc(o2, t2 ? `[${r2}${o2}=""]` : `.${r2}${o2}`, i);
          return [
            n2("group", " "),
            n2("peer", "~"),
            n2("parent", ">"),
            n2("previous", "+")
          ];
        }
        var Zc = /(part-\[(.+)]:)(.+)/, hi = {
          match(e2) {
            let t2 = e2.match(Zc);
            if (t2) {
              let r2 = `part(${t2[2]})`;
              return {
                matcher: e2.slice(t2[1].length),
                selector: (n2) => `${n2}::${r2}`
              };
            }
          },
          multiPass: true
        };
        function kr(e2) {
          return [
            No,
            Ho,
            Zo,
            Xo,
            Jo,
            ni,
            oi(),
            si,
            ii,
            ai,
            Do(),
            ...Io,
            pi(),
            di(),
            ...mi(e2),
            hi,
            ...Go(e2),
            ...Yo,
            Qo,
            Ko,
            ei,
            ...qo
          ];
        }
        var gi = {
          position: ["relative", "absolute", "fixed", "sticky", "static"],
          globalKeyword: S
        };
        var bi = (e2 = {}) => (e2.dark = e2.dark ?? "class", e2.attributifyPseudo = e2.attributifyPseudo ?? false, e2.preflight = e2.preflight ?? true, e2.variablePrefix = e2.variablePrefix ?? "un-", {
          name: "@unocss/preset-mini",
          theme: Wo,
          rules: bo,
          variants: kr(e2),
          options: e2,
          prefix: e2.prefix,
          postprocess: Jc(e2.variablePrefix),
          preflights: e2.preflight ? Qc(Bn, e2.variablePrefix) : [],
          extractorDefault: e2.arbitraryVariants === false ? void 0 : Nn,
          autocomplete: { shorthands: gi }
        });
        function Jc(e2) {
          if (e2 !== "un-")
            return (t2) => {
              t2.entries.forEach((r2) => {
                r2[0] = r2[0].replace(/^--un-/, `--${e2}`), typeof r2[1] == "string" && (r2[1] = r2[1].replace(/var\(--un-/g, `var(--${e2}`));
              });
            };
        }
        function Qc(e2, t2) {
          return t2 !== "un-" ? e2.map((r2) => ({
            ...r2,
            getCSS: async (n2) => {
              let o2 = await r2.getCSS(n2);
              if (o2)
                return o2.replace(/--un-/g, `--${t2}`);
            }
          })) : e2;
        }
        var xi = [
          [
            /^(?:animate-)?keyframes-(.+)$/,
            ([, e2], { theme: t2 }) => {
              var _a3, _b;
              let r2 = (_b = (_a3 = t2.animation) == null ? void 0 : _a3.keyframes) == null ? void 0 : _b[e2];
              if (r2)
                return [`@keyframes ${e2}${r2}`, { animation: e2 }];
            },
            {
              autocomplete: [
                "animate-keyframes-$animation.keyframes",
                "keyframes-$animation.keyframes"
              ]
            }
          ],
          [
            /^animate-(.+)$/,
            ([, e2], { theme: t2 }) => {
              var _a3, _b, _c2, _d, _e2, _f, _g, _h, _i2, _j;
              let r2 = (_b = (_a3 = t2.animation) == null ? void 0 : _a3.keyframes) == null ? void 0 : _b[e2];
              if (r2) {
                let n2 = ((_d = (_c2 = t2.animation) == null ? void 0 : _c2.durations) == null ? void 0 : _d[e2]) ?? "1s", o2 = ((_f = (_e2 = t2.animation) == null ? void 0 : _e2.timingFns) == null ? void 0 : _f[e2]) ?? "linear", i = ((_h = (_g = t2.animation) == null ? void 0 : _g.counts) == null ? void 0 : _h[e2]) ?? 1, a = (_j = (_i2 = t2.animation) == null ? void 0 : _i2.properties) == null ? void 0 : _j[e2];
                return [
                  `@keyframes ${e2}${r2}`,
                  { animation: `${e2} ${n2} ${o2} ${i}`, ...a }
                ];
              }
              return { animation: l2.bracket.cssvar(e2) };
            },
            { autocomplete: "animate-$animation.keyframes" }
          ],
          [
            /^animate-name-(.+)/,
            ([, e2]) => ({ "animation-name": l2.bracket.cssvar(e2) ?? e2 })
          ],
          [
            /^animate-duration-(.+)$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "animation-duration": ((_a3 = t2.duration) == null ? void 0 : _a3[e2 || "DEFAULT"]) ?? l2.bracket.cssvar.time(e2)
              };
            },
            { autocomplete: ["animate-duration", "animate-duration-$duration"] }
          ],
          [
            /^animate-delay-(.+)$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "animation-delay": ((_a3 = t2.duration) == null ? void 0 : _a3[e2 || "DEFAULT"]) ?? l2.bracket.cssvar.time(e2)
              };
            },
            { autocomplete: ["animate-delay", "animate-delay-$duration"] }
          ],
          [
            /^animate-ease(?:-(.+))?$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              return {
                "animation-timing-function": ((_a3 = t2.easing) == null ? void 0 : _a3[e2 || "DEFAULT"]) ?? l2.bracket.cssvar(e2)
              };
            },
            { autocomplete: ["animate-ease", "animate-ease-$easing"] }
          ],
          [
            /^animate-(fill-mode-|fill-|mode-)?(.+)$/,
            ([, e2, t2]) => ["none", "forwards", "backwards", "both", e2 ? S : []].includes(t2) ? { "animation-fill-mode": t2 } : void 0,
            {
              autocomplete: [
                "animate-(fill|mode|fill-mode)",
                "animate-(fill|mode|fill-mode)-(none|forwards|backwards|both|inherit|initial|revert|revert-layer|unset)",
                "animate-(none|forwards|backwards|both|inherit|initial|revert|revert-layer|unset)"
              ]
            }
          ],
          [
            /^animate-(direction-)?(.+)$/,
            ([, e2, t2]) => [
              "normal",
              "reverse",
              "alternate",
              "alternate-reverse",
              e2 ? S : []
            ].includes(t2) ? { "animation-direction": t2 } : void 0,
            {
              autocomplete: [
                "animate-direction",
                "animate-direction-(normal|reverse|alternate|alternate-reverse|inherit|initial|revert|revert-layer|unset)",
                "animate-(normal|reverse|alternate|alternate-reverse|inherit|initial|revert|revert-layer|unset)"
              ]
            }
          ],
          [
            /^animate-(?:iteration-count-|iteration-|count-)(.+)$/,
            ([, e2]) => ({
              "animation-iteration-count": l2.bracket.cssvar(e2) ?? e2.replace(/\-/g, ",")
            }),
            {
              autocomplete: [
                "animate-(iteration|count|iteration-count)",
                "animate-(iteration|count|iteration-count)-<num>"
              ]
            }
          ],
          [
            /^animate-(play-state-|play-|state-)?(.+)$/,
            ([, e2, t2]) => ["paused", "running", e2 ? S : []].includes(t2) ? { "animation-play-state": t2 } : void 0,
            {
              autocomplete: [
                "animate-(play|state|play-state)",
                "animate-(play|state|play-state)-(paused|running|inherit|initial|revert|revert-layer|unset)",
                "animate-(paused|running|inherit|initial|revert|revert-layer|unset)"
              ]
            }
          ],
          ["animate-none", { animation: "none" }],
          ...v("animate", "animation")
        ];
        function yi(e2) {
          return e2 ? A(e2, 0) : "rgb(255 255 255 / 0)";
        }
        function el(e2, t2, r2, n2) {
          return t2 ? n2 != null ? A(t2, n2) : A(t2, `var(--un-${e2}-opacity, ${ee2(t2)})`) : A(r2, n2);
        }
        function nn2() {
          return ([, e2, t2], { theme: r2 }) => {
            let n2 = ke2(t2, r2, "backgroundColor");
            if (!n2)
              return;
            let { alpha: o2, color: i, cssColor: a } = n2;
            if (!i)
              return;
            let s2 = el(e2, a, i, o2);
            switch (e2) {
              case "from":
                return {
                  "--un-gradient-from-position": "0%",
                  "--un-gradient-from": `${s2} var(--un-gradient-from-position)`,
                  "--un-gradient-to-position": "100%",
                  "--un-gradient-to": `${yi(a)} var(--un-gradient-to-position)`,
                  "--un-gradient-stops": "var(--un-gradient-from), var(--un-gradient-to)"
                };
              case "via":
                return {
                  "--un-gradient-via-position": "50%",
                  "--un-gradient-to": yi(a),
                  "--un-gradient-stops": `var(--un-gradient-from), ${s2} var(--un-gradient-via-position), var(--un-gradient-to)`
                };
              case "to":
                return {
                  "--un-gradient-to-position": "100%",
                  "--un-gradient-to": `${s2} var(--un-gradient-to-position)`
                };
            }
          };
        }
        function tl() {
          return ([, e2, t2]) => ({
            [`--un-gradient-${e2}-position`]: `${Number(l2.bracket.cssvar.percent(t2)) * 100}%`
          });
        }
        var vi = [
          [
            /^bg-gradient-(.+)$/,
            ([, e2]) => ({ "--un-gradient": l2.bracket(e2) }),
            {
              autocomplete: [
                "bg-gradient",
                "bg-gradient-(from|to|via)",
                "bg-gradient-(from|to|via)-$colors",
                "bg-gradient-(from|to|via)-(op|opacity)",
                "bg-gradient-(from|to|via)-(op|opacity)-<percent>"
              ]
            }
          ],
          [
            /^(?:bg-gradient-)?stops-(\[.+\])$/,
            ([, e2]) => ({ "--un-gradient-stops": l2.bracket(e2) })
          ],
          [/^(?:bg-gradient-)?(from)-(.+)$/, nn2()],
          [/^(?:bg-gradient-)?(via)-(.+)$/, nn2()],
          [/^(?:bg-gradient-)?(to)-(.+)$/, nn2()],
          [
            /^(?:bg-gradient-)?(from|via|to)-op(?:acity)?-?(.+)$/,
            ([, e2, t2]) => ({ [`--un-${e2}-opacity`]: l2.bracket.percent(t2) })
          ],
          [/^(from|via|to)-([\d\.]+)%$/, tl()],
          [
            /^bg-gradient-((?:repeating-)?(?:linear|radial|conic))$/,
            ([, e2]) => ({
              "background-image": `${e2}-gradient(var(--un-gradient, var(--un-gradient-stops, rgb(255 255 255 / 0))))`
            }),
            {
              autocomplete: [
                "bg-gradient-repeating",
                "bg-gradient-(linear|radial|conic)",
                "bg-gradient-repeating-(linear|radial|conic)"
              ]
            }
          ],
          [
            /^bg-gradient-to-([rltb]{1,2})$/,
            ([, e2]) => {
              if (e2 in M)
                return {
                  "--un-gradient-shape": `to ${M[e2]}`,
                  "--un-gradient": "var(--un-gradient-shape), var(--un-gradient-stops)",
                  "background-image": "linear-gradient(var(--un-gradient))"
                };
            },
            {
              autocomplete: `bg-gradient-to-(${Object.keys(M).filter(
              (e2) => e2.length <= 2 && Array.from(e2).every((t2) => "rltb".includes(t2))
            ).join("|")})`
            }
          ],
          [
            /^(?:bg-gradient-)?shape-(.+)$/,
            ([, e2]) => {
              let t2 = e2 in M ? `to ${M[e2]}` : l2.bracket(e2);
              if (t2 != null)
                return {
                  "--un-gradient-shape": t2,
                  "--un-gradient": "var(--un-gradient-shape), var(--un-gradient-stops)"
                };
            },
            {
              autocomplete: [
                "bg-gradient-shape",
                `bg-gradient-shape-(${Object.keys(M).join("|")})`,
                `shape-(${Object.keys(M).join("|")})`
              ]
            }
          ],
          ["bg-none", { "background-image": "none" }],
          ["box-decoration-slice", { "box-decoration-break": "slice" }],
          ["box-decoration-clone", { "box-decoration-break": "clone" }],
          ...v("box-decoration", "box-decoration-break"),
          ["bg-auto", { "background-size": "auto" }],
          ["bg-cover", { "background-size": "cover" }],
          ["bg-contain", { "background-size": "contain" }],
          ["bg-fixed", { "background-attachment": "fixed" }],
          ["bg-local", { "background-attachment": "local" }],
          ["bg-scroll", { "background-attachment": "scroll" }],
          [
            "bg-clip-border",
            {
              "-webkit-background-clip": "border-box",
              "background-clip": "border-box"
            }
          ],
          [
            "bg-clip-content",
            {
              "-webkit-background-clip": "content-box",
              "background-clip": "content-box"
            }
          ],
          [
            "bg-clip-padding",
            {
              "-webkit-background-clip": "padding-box",
              "background-clip": "padding-box"
            }
          ],
          [
            "bg-clip-text",
            { "-webkit-background-clip": "text", "background-clip": "text" }
          ],
          ...S.map((e2) => [
            `bg-clip-${e2}`,
            { "-webkit-background-clip": e2, "background-clip": e2 }
          ]),
          [/^bg-([-\w]{3,})$/, ([, e2]) => ({ "background-position": M[e2] })],
          ["bg-repeat", { "background-repeat": "repeat" }],
          ["bg-no-repeat", { "background-repeat": "no-repeat" }],
          ["bg-repeat-x", { "background-repeat": "repeat-x" }],
          ["bg-repeat-y", { "background-repeat": "repeat-y" }],
          ["bg-repeat-round", { "background-repeat": "round" }],
          ["bg-repeat-space", { "background-repeat": "space" }],
          ...v("bg-repeat", "background-repeat"),
          ["bg-origin-border", { "background-origin": "border-box" }],
          ["bg-origin-padding", { "background-origin": "padding-box" }],
          ["bg-origin-content", { "background-origin": "content-box" }],
          ...v("bg-origin", "background-origin")
        ];
        var on2 = {
          disc: "disc",
          circle: "circle",
          square: "square",
          decimal: "decimal",
          "zero-decimal": "decimal-leading-zero",
          greek: "lower-greek",
          roman: "lower-roman",
          "upper-roman": "upper-roman",
          alpha: "lower-alpha",
          "upper-alpha": "upper-alpha",
          latin: "lower-latin",
          "upper-latin": "upper-latin"
        }, wi = [
          [
            /^list-(.+?)(?:-(outside|inside))?$/,
            ([, e2, t2]) => {
              let r2 = on2[e2];
              if (r2)
                return t2 ? { "list-style-position": t2, "list-style-type": r2 } : { "list-style-type": r2 };
            },
            {
              autocomplete: [
                `list-(${Object.keys(on2).join("|")})`,
                `list-(${Object.keys(on2).join("|")})-(outside|inside)`
              ]
            }
          ],
          ["list-outside", { "list-style-position": "outside" }],
          ["list-inside", { "list-style-position": "inside" }],
          ["list-none", { "list-style-type": "none" }],
          [
            /^list-image-(.+)$/,
            ([, e2]) => {
              if (/^\[url\(.+\)\]$/.test(e2))
                return { "list-style-image": l2.bracket(e2) };
            }
          ],
          ["list-image-none", { "list-style-image": "none" }],
          ...v("list", "list-style-type")
        ], $i = [
          [
            /^accent-(.+)$/,
            j("accent-color", "accent", "accentColor"),
            { autocomplete: "accent-$colors" }
          ],
          [
            /^accent-op(?:acity)?-?(.+)$/,
            ([, e2]) => ({ "--un-accent-opacity": l2.bracket.percent(e2) }),
            {
              autocomplete: [
                "accent-(op|opacity)",
                "accent-(op|opacity)-<percent>"
              ]
            }
          ]
        ], ki = [
          [
            /^caret-(.+)$/,
            j("caret-color", "caret", "textColor"),
            { autocomplete: "caret-$colors" }
          ],
          [
            /^caret-op(?:acity)?-?(.+)$/,
            ([, e2]) => ({ "--un-caret-opacity": l2.bracket.percent(e2) }),
            {
              autocomplete: ["caret-(op|opacity)", "caret-(op|opacity)-<percent>"]
            }
          ]
        ], Si = [
          ["image-render-auto", { "image-rendering": "auto" }],
          ["image-render-edge", { "image-rendering": "crisp-edges" }],
          [
            "image-render-pixel",
            [
              ["-ms-interpolation-mode", "nearest-neighbor"],
              ["image-rendering", "-webkit-optimize-contrast"],
              ["image-rendering", "-moz-crisp-edges"],
              ["image-rendering", "-o-pixelated"],
              ["image-rendering", "pixelated"]
            ]
          ]
        ], Ci = [
          ["overscroll-auto", { "overscroll-behavior": "auto" }],
          ["overscroll-contain", { "overscroll-behavior": "contain" }],
          ["overscroll-none", { "overscroll-behavior": "none" }],
          ...v("overscroll", "overscroll-behavior"),
          ["overscroll-x-auto", { "overscroll-behavior-x": "auto" }],
          ["overscroll-x-contain", { "overscroll-behavior-x": "contain" }],
          ["overscroll-x-none", { "overscroll-behavior-x": "none" }],
          ...v("overscroll-x", "overscroll-behavior-x"),
          ["overscroll-y-auto", { "overscroll-behavior-y": "auto" }],
          ["overscroll-y-contain", { "overscroll-behavior-y": "contain" }],
          ["overscroll-y-none", { "overscroll-behavior-y": "none" }],
          ...v("overscroll-y", "overscroll-behavior-y")
        ], Ri = [
          ["scroll-auto", { "scroll-behavior": "auto" }],
          ["scroll-smooth", { "scroll-behavior": "smooth" }],
          ...v("scroll", "scroll-behavior")
        ];
        var Ti = [
          [
            /^columns-(.+)$/,
            ([, e2]) => ({ columns: l2.bracket.global.number.auto.numberWithUnit(e2) }),
            { autocomplete: "columns-<num>" }
          ],
          ["break-before-auto", { "break-before": "auto" }],
          ["break-before-avoid", { "break-before": "avoid" }],
          ["break-before-all", { "break-before": "all" }],
          ["break-before-avoid-page", { "break-before": "avoid-page" }],
          ["break-before-page", { "break-before": "page" }],
          ["break-before-left", { "break-before": "left" }],
          ["break-before-right", { "break-before": "right" }],
          ["break-before-column", { "break-before": "column" }],
          ...v("break-before"),
          ["break-inside-auto", { "break-inside": "auto" }],
          ["break-inside-avoid", { "break-inside": "avoid" }],
          ["break-inside-avoid-page", { "break-inside": "avoid-page" }],
          ["break-inside-avoid-column", { "break-inside": "avoid-column" }],
          ...v("break-inside"),
          ["break-after-auto", { "break-after": "auto" }],
          ["break-after-avoid", { "break-after": "avoid" }],
          ["break-after-all", { "break-after": "all" }],
          ["break-after-avoid-page", { "break-after": "avoid-page" }],
          ["break-after-page", { "break-after": "page" }],
          ["break-after-left", { "break-after": "left" }],
          ["break-after-right", { "break-after": "right" }],
          ["break-after-column", { "break-after": "column" }],
          ...v("break-after")
        ];
        var rl = /@media \(min-width: (.+)\)/, Ei = [
          [
            /^__container$/,
            (e2, t2) => {
              var _a3, _b, _c2, _d, _e2, _f, _g;
              let { theme: r2, variantHandlers: n2 } = t2, o2 = (_a3 = r2.container) == null ? void 0 : _a3.padding, i;
              O(o2) ? i = o2 : i = o2 == null ? void 0 : o2.DEFAULT;
              let a = (_b = r2.container) == null ? void 0 : _b.maxWidth, s2;
              for (let f of n2) {
                let u = (_d = (_c2 = f.handle) == null ? void 0 : _c2.call(f, {}, (p2) => p2)) == null ? void 0 : _d.parent;
                if (O(u)) {
                  let p2 = (_e2 = u.match(rl)) == null ? void 0 : _e2[1];
                  if (p2) {
                    let h2 = (_f = (fe2(t2) ?? []).find((x) => x.size === p2)) == null ? void 0 : _f.point;
                    a ? h2 && (s2 = a == null ? void 0 : a[h2]) : s2 = p2, h2 && !O(o2) && (i = (o2 == null ? void 0 : o2[h2]) ?? i);
                  }
                }
              }
              let c = { "max-width": s2 };
              return n2.length || (c.width = "100%"), ((_g = r2.container) == null ? void 0 : _g.center) && (c["margin-left"] = "auto", c["margin-right"] = "auto"), o2 && (c["padding-left"] = i, c["padding-right"] = i), c;
            },
            { internal: true }
          ]
        ], ji = [
          [
            /^(?:(\w+)[:-])?container$/,
            ([, e2], t2) => {
              let r2 = (fe2(t2) ?? []).map((o2) => o2.point);
              if (e2) {
                if (!r2.includes(e2))
                  return;
                r2 = r2.slice(r2.indexOf(e2));
              }
              let n2 = r2.map((o2) => `${o2}:__container`);
              return e2 || n2.unshift("__container"), n2;
            }
          ]
        ];
        var zi = {
          "--un-blur": T,
          "--un-brightness": T,
          "--un-contrast": T,
          "--un-drop-shadow": T,
          "--un-grayscale": T,
          "--un-hue-rotate": T,
          "--un-invert": T,
          "--un-saturate": T,
          "--un-sepia": T
        }, Sr = "var(--un-blur) var(--un-brightness) var(--un-contrast) var(--un-drop-shadow) var(--un-grayscale) var(--un-hue-rotate) var(--un-invert) var(--un-saturate) var(--un-sepia)", Oi = {
          "--un-backdrop-blur": T,
          "--un-backdrop-brightness": T,
          "--un-backdrop-contrast": T,
          "--un-backdrop-grayscale": T,
          "--un-backdrop-hue-rotate": T,
          "--un-backdrop-invert": T,
          "--un-backdrop-opacity": T,
          "--un-backdrop-saturate": T,
          "--un-backdrop-sepia": T
        }, Cr = "var(--un-backdrop-blur) var(--un-backdrop-brightness) var(--un-backdrop-contrast) var(--un-backdrop-grayscale) var(--un-backdrop-hue-rotate) var(--un-backdrop-invert) var(--un-backdrop-opacity) var(--un-backdrop-saturate) var(--un-backdrop-sepia)";
        function an2(e2) {
          let t2 = l2.bracket.cssvar(e2 || "");
          if (t2 != null || (t2 = e2 ? l2.percent(e2) : "1", t2 != null && Number.parseFloat(t2) <= 1))
            return t2;
        }
        function te2(e2, t2) {
          return ([, r2, n2], { theme: o2 }) => {
            let i = t2(n2, o2) ?? (n2 === "none" ? "0" : "");
            if (i !== "")
              return r2 ? {
                [`--un-${r2}${e2}`]: `${e2}(${i})`,
                "-webkit-backdrop-filter": Cr,
                "backdrop-filter": Cr
              } : { [`--un-${e2}`]: `${e2}(${i})`, filter: Sr };
          };
        }
        function nl([, e2], { theme: t2 }) {
          var _a3;
          let r2 = (_a3 = t2.dropShadow) == null ? void 0 : _a3[e2 || "DEFAULT"];
          if (r2 != null)
            return {
              "--un-drop-shadow": `drop-shadow(${Se2(r2, "--un-drop-shadow-color").join(") drop-shadow(")})`,
              filter: Sr
            };
          if (r2 = l2.bracket.cssvar(e2), r2 != null)
            return { "--un-drop-shadow": `drop-shadow(${r2})`, filter: Sr };
        }
        var Ai = [
          [
            /^(?:(backdrop-)|filter-)?blur(?:-(.+))?$/,
            te2("blur", (e2, t2) => {
              var _a3;
              return ((_a3 = t2.blur) == null ? void 0 : _a3[e2 || "DEFAULT"]) || l2.bracket.cssvar.px(e2);
            }),
            {
              autocomplete: [
                "(backdrop|filter)-blur-$blur",
                "blur-$blur",
                "filter-blur"
              ]
            }
          ],
          [
            /^(?:(backdrop-)|filter-)?brightness-(.+)$/,
            te2("brightness", (e2) => l2.bracket.cssvar.percent(e2)),
            {
              autocomplete: [
                "(backdrop|filter)-brightness-<percent>",
                "brightness-<percent>"
              ]
            }
          ],
          [
            /^(?:(backdrop-)|filter-)?contrast-(.+)$/,
            te2("contrast", (e2) => l2.bracket.cssvar.percent(e2)),
            {
              autocomplete: [
                "(backdrop|filter)-contrast-<percent>",
                "contrast-<percent>"
              ]
            }
          ],
          [
            /^(?:filter-)?drop-shadow(?:-(.+))?$/,
            nl,
            {
              autocomplete: [
                "filter-drop",
                "filter-drop-shadow",
                "filter-drop-shadow-color",
                "drop-shadow",
                "drop-shadow-color",
                "filter-drop-shadow-$dropShadow",
                "drop-shadow-$dropShadow",
                "filter-drop-shadow-color-$colors",
                "drop-shadow-color-$colors",
                "filter-drop-shadow-color-(op|opacity)",
                "drop-shadow-color-(op|opacity)",
                "filter-drop-shadow-color-(op|opacity)-<percent>",
                "drop-shadow-color-(op|opacity)-<percent>"
              ]
            }
          ],
          [
            /^(?:filter-)?drop-shadow-color-(.+)$/,
            j("--un-drop-shadow-color", "drop-shadow", "shadowColor")
          ],
          [
            /^(?:filter-)?drop-shadow-color-op(?:acity)?-?(.+)$/,
            ([, e2]) => ({ "--un-drop-shadow-opacity": l2.bracket.percent(e2) })
          ],
          [
            /^(?:(backdrop-)|filter-)?grayscale(?:-(.+))?$/,
            te2("grayscale", an2),
            {
              autocomplete: [
                "(backdrop|filter)-grayscale",
                "(backdrop|filter)-grayscale-<percent>",
                "grayscale-<percent>"
              ]
            }
          ],
          [
            /^(?:(backdrop-)|filter-)?hue-rotate-(.+)$/,
            te2("hue-rotate", (e2) => l2.bracket.cssvar.degree(e2))
          ],
          [
            /^(?:(backdrop-)|filter-)?invert(?:-(.+))?$/,
            te2("invert", an2),
            {
              autocomplete: [
                "(backdrop|filter)-invert",
                "(backdrop|filter)-invert-<percent>",
                "invert-<percent>"
              ]
            }
          ],
          [
            /^(backdrop-)op(?:acity)-(.+)$/,
            te2("opacity", (e2) => l2.bracket.cssvar.percent(e2)),
            {
              autocomplete: [
                "backdrop-(op|opacity)",
                "backdrop-(op|opacity)-<percent>"
              ]
            }
          ],
          [
            /^(?:(backdrop-)|filter-)?saturate-(.+)$/,
            te2("saturate", (e2) => l2.bracket.cssvar.percent(e2)),
            {
              autocomplete: [
                "(backdrop|filter)-saturate",
                "(backdrop|filter)-saturate-<percent>",
                "saturate-<percent>"
              ]
            }
          ],
          [
            /^(?:(backdrop-)|filter-)?sepia(?:-(.+))?$/,
            te2("sepia", an2),
            {
              autocomplete: [
                "(backdrop|filter)-sepia",
                "(backdrop|filter)-sepia-<percent>",
                "sepia-<percent>"
              ]
            }
          ],
          ["filter", { filter: Sr }],
          [
            "backdrop-filter",
            { "-webkit-backdrop-filter": Cr, "backdrop-filter": Cr }
          ],
          ["filter-none", { filter: "none" }],
          [
            "backdrop-filter-none",
            { "-webkit-backdrop-filter": "none", "backdrop-filter": "none" }
          ],
          ...S.map((e2) => [`filter-${e2}`, { filter: e2 }]),
          ...S.map((e2) => [
            `backdrop-filter-${e2}`,
            { "-webkit-backdrop-filter": e2, "backdrop-filter": e2 }
          ])
        ];
        var _i = [
          [
            /^space-([xy])-(-?.+)$/,
            Vi,
            {
              autocomplete: [
                "space-(x|y|block|inline)",
                "space-(x|y|block|inline)-reverse",
                "space-(x|y|block|inline)-$spacing"
              ]
            }
          ],
          [/^space-([xy])-reverse$/, ([, e2]) => ({ [`--un-space-${e2}-reverse`]: 1 })],
          [/^space-(block|inline)-(-?.+)$/, Vi],
          [
            /^space-(block|inline)-reverse$/,
            ([, e2]) => ({ [`--un-space-${e2}-reverse`]: 1 })
          ]
        ];
        function Vi([, e2, t2], { theme: r2 }) {
          var _a3;
          let n2 = ((_a3 = r2.spacing) == null ? void 0 : _a3[t2 || "DEFAULT"]) ?? l2.bracket.cssvar.auto.fraction.rem(t2 || "1");
          if (n2 != null) {
            n2 === "0" && (n2 = "0px");
            let o2 = F[e2].map((i) => {
              let a = `margin${i}`, s2 = i.endsWith("right") || i.endsWith("bottom") ? `calc(${n2} * var(--un-space-${e2}-reverse))` : `calc(${n2} * calc(1 - var(--un-space-${e2}-reverse)))`;
              return [a, s2];
            });
            if (o2)
              return [[`--un-space-${e2}-reverse`, 0], ...o2];
          }
        }
        var Pi = [
          ["uppercase", { "text-transform": "uppercase" }],
          ["lowercase", { "text-transform": "lowercase" }],
          ["capitalize", { "text-transform": "capitalize" }],
          ["normal-case", { "text-transform": "none" }]
        ], Mi = [
          ...["manual", "auto", "none", ...S].map((e2) => [
            `hyphens-${e2}`,
            { "-webkit-hyphens": e2, "-ms-hyphens": e2, hyphens: e2 }
          ])
        ], Fi = [
          ["write-vertical-right", { "writing-mode": "vertical-rl" }],
          ["write-vertical-left", { "writing-mode": "vertical-lr" }],
          ["write-normal", { "writing-mode": "horizontal-tb" }],
          ...v("write", "writing-mode")
        ], Ui = [
          ["write-orient-mixed", { "text-orientation": "mixed" }],
          ["write-orient-sideways", { "text-orientation": "sideways" }],
          ["write-orient-upright", { "text-orientation": "upright" }],
          ...v("write-orient", "text-orientation")
        ], Li = [
          [
            "sr-only",
            {
              position: "absolute",
              width: "1px",
              height: "1px",
              padding: "0",
              margin: "-1px",
              overflow: "hidden",
              clip: "rect(0,0,0,0)",
              "white-space": "nowrap",
              "border-width": 0
            }
          ],
          [
            "not-sr-only",
            {
              position: "static",
              width: "auto",
              height: "auto",
              padding: "0",
              margin: "0",
              overflow: "visible",
              clip: "auto",
              "white-space": "normal"
            }
          ]
        ], Wi = [
          ["isolate", { isolation: "isolate" }],
          ["isolate-auto", { isolation: "auto" }],
          ["isolation-auto", { isolation: "auto" }]
        ], Ni = [
          ["object-cover", { "object-fit": "cover" }],
          ["object-contain", { "object-fit": "contain" }],
          ["object-fill", { "object-fit": "fill" }],
          ["object-scale-down", { "object-fit": "scale-down" }],
          ["object-none", { "object-fit": "none" }],
          [
            /^object-(.+)$/,
            ([, e2]) => {
              if (M[e2])
                return { "object-position": M[e2] };
              if (l2.bracketOfPosition(e2) != null)
                return {
                  "object-position": l2.bracketOfPosition(e2).split(" ").map((t2) => l2.position.fraction.auto.px.cssvar(t2) ?? t2).join(" ")
                };
            },
            { autocomplete: `object-(${Object.keys(M).join("|")})` }
          ]
        ], Bi = [
          ["bg-blend-multiply", { "background-blend-mode": "multiply" }],
          ["bg-blend-screen", { "background-blend-mode": "screen" }],
          ["bg-blend-overlay", { "background-blend-mode": "overlay" }],
          ["bg-blend-darken", { "background-blend-mode": "darken" }],
          ["bg-blend-lighten", { "background-blend-mode": "lighten" }],
          ["bg-blend-color-dodge", { "background-blend-mode": "color-dodge" }],
          ["bg-blend-color-burn", { "background-blend-mode": "color-burn" }],
          ["bg-blend-hard-light", { "background-blend-mode": "hard-light" }],
          ["bg-blend-soft-light", { "background-blend-mode": "soft-light" }],
          ["bg-blend-difference", { "background-blend-mode": "difference" }],
          ["bg-blend-exclusion", { "background-blend-mode": "exclusion" }],
          ["bg-blend-hue", { "background-blend-mode": "hue" }],
          ["bg-blend-saturation", { "background-blend-mode": "saturation" }],
          ["bg-blend-color", { "background-blend-mode": "color" }],
          ["bg-blend-luminosity", { "background-blend-mode": "luminosity" }],
          ["bg-blend-normal", { "background-blend-mode": "normal" }],
          ...v("bg-blend", "background-blend")
        ], Di = [
          ["mix-blend-multiply", { "mix-blend-mode": "multiply" }],
          ["mix-blend-screen", { "mix-blend-mode": "screen" }],
          ["mix-blend-overlay", { "mix-blend-mode": "overlay" }],
          ["mix-blend-darken", { "mix-blend-mode": "darken" }],
          ["mix-blend-lighten", { "mix-blend-mode": "lighten" }],
          ["mix-blend-color-dodge", { "mix-blend-mode": "color-dodge" }],
          ["mix-blend-color-burn", { "mix-blend-mode": "color-burn" }],
          ["mix-blend-hard-light", { "mix-blend-mode": "hard-light" }],
          ["mix-blend-soft-light", { "mix-blend-mode": "soft-light" }],
          ["mix-blend-difference", { "mix-blend-mode": "difference" }],
          ["mix-blend-exclusion", { "mix-blend-mode": "exclusion" }],
          ["mix-blend-hue", { "mix-blend-mode": "hue" }],
          ["mix-blend-saturation", { "mix-blend-mode": "saturation" }],
          ["mix-blend-color", { "mix-blend-mode": "color" }],
          ["mix-blend-luminosity", { "mix-blend-mode": "luminosity" }],
          ["mix-blend-plus-lighter", { "mix-blend-mode": "plus-lighter" }],
          ["mix-blend-normal", { "mix-blend-mode": "normal" }],
          ...v("mix-blend")
        ], Ii = [
          ["min-h-dvh", { "min-height": "100dvh" }],
          ["min-h-svh", { "min-height": "100svh" }],
          ["min-h-lvh", { "min-height": "100lvh" }],
          ["h-dvh", { height: "100dvh" }],
          ["h-svh", { height: "100svh" }],
          ["h-lvh", { height: "100lvh" }],
          ["max-h-dvh", { "max-height": "100dvh" }],
          ["max-h-svh", { "max-height": "100svh" }],
          ["max-h-lvh", { "max-height": "100lvh" }]
        ];
        var Gi = { "--un-border-spacing-x": 0, "--un-border-spacing-y": 0 }, Ki = "var(--un-border-spacing-x) var(--un-border-spacing-y)", Hi = [
          ["inline-table", { display: "inline-table" }],
          ["table", { display: "table" }],
          ["table-caption", { display: "table-caption" }],
          ["table-cell", { display: "table-cell" }],
          ["table-column", { display: "table-column" }],
          ["table-column-group", { display: "table-column-group" }],
          ["table-footer-group", { display: "table-footer-group" }],
          ["table-header-group", { display: "table-header-group" }],
          ["table-row", { display: "table-row" }],
          ["table-row-group", { display: "table-row-group" }],
          ["border-collapse", { "border-collapse": "collapse" }],
          ["border-separate", { "border-collapse": "separate" }],
          [
            /^border-spacing-(.+)$/,
            ([, e2], { theme: t2 }) => {
              var _a3;
              let r2 = ((_a3 = t2.spacing) == null ? void 0 : _a3[e2]) ?? l2.bracket.cssvar.global.auto.fraction.rem(e2);
              if (r2 != null)
                return {
                  "--un-border-spacing-x": r2,
                  "--un-border-spacing-y": r2,
                  "border-spacing": Ki
                };
            },
            { autocomplete: ["border-spacing", "border-spacing-$spacing"] }
          ],
          [
            /^border-spacing-([xy])-(.+)$/,
            ([, e2, t2], { theme: r2 }) => {
              var _a3;
              let n2 = ((_a3 = r2.spacing) == null ? void 0 : _a3[t2]) ?? l2.bracket.cssvar.global.auto.fraction.rem(t2);
              if (n2 != null)
                return { [`--un-border-spacing-${e2}`]: n2, "border-spacing": Ki };
            },
            {
              autocomplete: [
                "border-spacing-(x|y)",
                "border-spacing-(x|y)-$spacing"
              ]
            }
          ],
          ["caption-top", { "caption-side": "top" }],
          ["caption-bottom", { "caption-side": "bottom" }],
          ["table-auto", { "table-layout": "auto" }],
          ["table-fixed", { "table-layout": "fixed" }],
          ["table-empty-cells-visible", { "empty-cells": "show" }],
          ["table-empty-cells-hidden", { "empty-cells": "hide" }]
        ];
        var ol = {
          "bg-blend": "background-blend-mode",
          "bg-clip": "-webkit-background-clip",
          "bg-gradient": "linear-gradient",
          "bg-image": "background-image",
          "bg-origin": "background-origin",
          "bg-position": "background-position",
          "bg-repeat": "background-repeat",
          "bg-size": "background-size",
          "mix-blend": "mix-blend-mode",
          object: "object-fit",
          "object-position": "object-position",
          write: "writing-mode",
          "write-orient": "text-orientation"
        }, qi = [
          [
            /^(.+?)-(\$.+)$/,
            ([, e2, t2]) => {
              let r2 = ol[e2];
              if (r2)
                return { [r2]: l2.cssvar(t2) };
            }
          ]
        ];
        var Yi = [
          [
            /^divide-?([xy])$/,
            Rr,
            {
              autocomplete: [
                "divide-(x|y|block|inline)",
                "divide-(x|y|block|inline)-reverse",
                "divide-(x|y|block|inline)-$lineWidth"
              ]
            }
          ],
          [/^divide-?([xy])-?(-?.+)$/, Rr],
          [
            /^divide-?([xy])-reverse$/,
            ([, e2]) => ({ [`--un-divide-${e2}-reverse`]: 1 })
          ],
          [/^divide-(block|inline)$/, Rr],
          [/^divide-(block|inline)-(-?.+)$/, Rr],
          [
            /^divide-(block|inline)-reverse$/,
            ([, e2]) => ({ [`--un-divide-${e2}-reverse`]: 1 })
          ],
          [
            /^divide-(.+)$/,
            j("border-color", "divide", "borderColor"),
            { autocomplete: "divide-$colors" }
          ],
          [
            /^divide-op(?:acity)?-?(.+)$/,
            ([, e2]) => ({ "--un-divide-opacity": l2.bracket.percent(e2) }),
            {
              autocomplete: ["divide-(op|opacity)", "divide-(op|opacity)-<percent>"]
            }
          ],
          ...ue.map((e2) => [`divide-${e2}`, { "border-style": e2 }])
        ];
        function Rr([, e2, t2], { theme: r2 }) {
          var _a3;
          let n2 = ((_a3 = r2.lineWidth) == null ? void 0 : _a3[t2 || "DEFAULT"]) ?? l2.bracket.cssvar.px(t2 || "1");
          if (n2 != null) {
            n2 === "0" && (n2 = "0px");
            let o2 = F[e2].map((i) => {
              let a = `border${i}-width`, s2 = i.endsWith("right") || i.endsWith("bottom") ? `calc(${n2} * var(--un-divide-${e2}-reverse))` : `calc(${n2} * calc(1 - var(--un-divide-${e2}-reverse)))`;
              return [a, s2];
            });
            if (o2)
              return [[`--un-divide-${e2}-reverse`, 0], ...o2];
          }
        }
        var Xi = [
          [
            /^line-clamp-(\d+)$/,
            ([, e2]) => ({
              overflow: "hidden",
              display: "-webkit-box",
              "-webkit-box-orient": "vertical",
              "-webkit-line-clamp": e2,
              "line-clamp": e2
            }),
            { autocomplete: ["line-clamp", "line-clamp-<num>"] }
          ],
          ...["none", ...S].map((e2) => [
            `line-clamp-${e2}`,
            {
              overflow: "visible",
              display: "block",
              "-webkit-box-orient": "horizontal",
              "-webkit-line-clamp": e2,
              "line-clamp": e2
            }
          ])
        ];
        var Zi = {
          "--un-ordinal": T,
          "--un-slashed-zero": T,
          "--un-numeric-figure": T,
          "--un-numeric-spacing": T,
          "--un-numeric-fraction": T
        };
        function ae(e2) {
          return {
            ...e2,
            "font-variant-numeric": "var(--un-ordinal) var(--un-slashed-zero) var(--un-numeric-figure) var(--un-numeric-spacing) var(--un-numeric-fraction)"
          };
        }
        var Ji = [
          [
            /^ordinal$/,
            () => ae({ "--un-ordinal": "ordinal" }),
            { autocomplete: "ordinal" }
          ],
          [
            /^slashed-zero$/,
            () => ae({ "--un-slashed-zero": "slashed-zero" }),
            { autocomplete: "slashed-zero" }
          ],
          [
            /^lining-nums$/,
            () => ae({ "--un-numeric-figure": "lining-nums" }),
            { autocomplete: "lining-nums" }
          ],
          [
            /^oldstyle-nums$/,
            () => ae({ "--un-numeric-figure": "oldstyle-nums" }),
            { autocomplete: "oldstyle-nums" }
          ],
          [
            /^proportional-nums$/,
            () => ae({ "--un-numeric-spacing": "proportional-nums" }),
            { autocomplete: "proportional-nums" }
          ],
          [
            /^tabular-nums$/,
            () => ae({ "--un-numeric-spacing": "tabular-nums" }),
            { autocomplete: "tabular-nums" }
          ],
          [
            /^diagonal-fractions$/,
            () => ae({ "--un-numeric-fraction": "diagonal-fractions" }),
            { autocomplete: "diagonal-fractions" }
          ],
          [
            /^stacked-fractions$/,
            () => ae({ "--un-numeric-fraction": "stacked-fractions" }),
            { autocomplete: "stacked-fractions" }
          ],
          ["normal-nums", { "font-variant-numeric": "normal" }]
        ];
        var Qi = { "--un-pan-x": T, "--un-pan-y": T, "--un-pinch-zoom": T }, sn2 = "var(--un-pan-x) var(--un-pan-y) var(--un-pinch-zoom)", ea = [
          [
            /^touch-pan-(x|left|right)$/,
            ([, e2]) => ({ "--un-pan-x": `pan-${e2}`, "touch-action": sn2 }),
            { autocomplete: ["touch-pan", "touch-pan-(x|left|right|y|up|down)"] }
          ],
          [
            /^touch-pan-(y|up|down)$/,
            ([, e2]) => ({ "--un-pan-y": `pan-${e2}`, "touch-action": sn2 })
          ],
          [
            "touch-pinch-zoom",
            { "--un-pinch-zoom": "pinch-zoom", "touch-action": sn2 }
          ],
          ["touch-auto", { "touch-action": "auto" }],
          ["touch-manipulation", { "touch-action": "manipulation" }],
          ["touch-none", { "touch-action": "none" }],
          ...v("touch", "touch-action")
        ];
        var ta = { "--un-scroll-snap-strictness": "proximity" }, ra = [
          [
            /^snap-(x|y)$/,
            ([, e2]) => ({
              "scroll-snap-type": `${e2} var(--un-scroll-snap-strictness)`
            }),
            { autocomplete: "snap-(x|y|both)" }
          ],
          [
            /^snap-both$/,
            () => ({ "scroll-snap-type": "both var(--un-scroll-snap-strictness)" })
          ],
          ["snap-mandatory", { "--un-scroll-snap-strictness": "mandatory" }],
          ["snap-proximity", { "--un-scroll-snap-strictness": "proximity" }],
          ["snap-none", { "scroll-snap-type": "none" }],
          ["snap-start", { "scroll-snap-align": "start" }],
          ["snap-end", { "scroll-snap-align": "end" }],
          ["snap-center", { "scroll-snap-align": "center" }],
          ["snap-align-none", { "scroll-snap-align": "none" }],
          ["snap-normal", { "scroll-snap-stop": "normal" }],
          ["snap-always", { "scroll-snap-stop": "always" }],
          [
            /^scroll-ma?()-?(-?.+)$/,
            V("scroll-margin"),
            {
              autocomplete: [
                "scroll-(m|p|ma|pa|block|inline)",
                "scroll-(m|p|ma|pa|block|inline)-$spacing",
                "scroll-(m|p|ma|pa|block|inline)-(x|y|r|l|t|b|bs|be|is|ie)",
                "scroll-(m|p|ma|pa|block|inline)-(x|y|r|l|t|b|bs|be|is|ie)-$spacing"
              ]
            }
          ],
          [/^scroll-m-?([xy])-?(-?.+)$/, V("scroll-margin")],
          [/^scroll-m-?([rltb])-?(-?.+)$/, V("scroll-margin")],
          [/^scroll-m-(block|inline)-(-?.+)$/, V("scroll-margin")],
          [/^scroll-m-?([bi][se])-?(-?.+)$/, V("scroll-margin")],
          [/^scroll-pa?()-?(-?.+)$/, V("scroll-padding")],
          [/^scroll-p-?([xy])-?(-?.+)$/, V("scroll-padding")],
          [/^scroll-p-?([rltb])-?(-?.+)$/, V("scroll-padding")],
          [/^scroll-p-(block|inline)-(-?.+)$/, V("scroll-padding")],
          [/^scroll-p-?([bi][se])-?(-?.+)$/, V("scroll-padding")]
        ];
        var na = [
          [
            /^\$ placeholder-(.+)$/,
            j("color", "placeholder", "accentColor"),
            { autocomplete: "placeholder-$colors" }
          ],
          [
            /^\$ placeholder-op(?:acity)?-?(.+)$/,
            ([, e2]) => ({ "--un-placeholder-opacity": l2.bracket.percent(e2) }),
            {
              autocomplete: [
                "placeholder-(op|opacity)",
                "placeholder-(op|opacity)-<percent>"
              ]
            }
          ]
        ];
        var oa = [
          [/^view-transition-([\w_-]+)$/, ([, e2]) => ({ "view-transition-name": e2 })]
        ];
        var ia = [
          xr,
          qi,
          yr,
          Ei,
          Ht2,
          Li,
          qt2,
          Kt2,
          Mt2,
          Wt2,
          Xi,
          Wi,
          Bt2,
          Ft2,
          Vt2,
          Nt2,
          mr,
          Dt,
          It2,
          pr,
          ur,
          Rt2,
          Hi,
          br,
          xi,
          Gt2,
          ea,
          Xt2,
          Yt2,
          ra,
          wi,
          bt2,
          Ti,
          Ut2,
          Be2,
          Ne,
          At,
          Lt,
          _i,
          Yi,
          Pt,
          Ci,
          Ri,
          rr,
          Zt2,
          er,
          yt2,
          wt2,
          vi,
          wr,
          Ni,
          dr,
          mt2,
          jt,
          tr,
          dt2,
          Tt2,
          nr,
          Pi,
          or,
          Ji,
          kt,
          ir,
          Et,
          zt2,
          Ot2,
          Mi,
          Fi,
          Ui,
          ki,
          $i,
          vt2,
          Bi,
          Di,
          lr,
          gt2,
          sr,
          Si,
          Ai,
          Ct2,
          xt2,
          Jt2,
          Qt2,
          na,
          $t2,
          oa,
          Ii,
          vr
        ].flat(1);
        var aa = [...ji];
        var cn2 = {
          inherit: "inherit",
          current: "currentColor",
          transparent: "transparent",
          black: "#000",
          white: "#fff",
          rose: {
            50: "#fff1f2",
            100: "#ffe4e6",
            200: "#fecdd3",
            300: "#fda4af",
            400: "#fb7185",
            500: "#f43f5e",
            600: "#e11d48",
            700: "#be123c",
            800: "#9f1239",
            900: "#881337",
            950: "#4c0519"
          },
          pink: {
            50: "#fdf2f8",
            100: "#fce7f3",
            200: "#fbcfe8",
            300: "#f9a8d4",
            400: "#f472b6",
            500: "#ec4899",
            600: "#db2777",
            700: "#be185d",
            800: "#9d174d",
            900: "#831843",
            950: "#500724"
          },
          fuchsia: {
            50: "#fdf4ff",
            100: "#fae8ff",
            200: "#f5d0fe",
            300: "#f0abfc",
            400: "#e879f9",
            500: "#d946ef",
            600: "#c026d3",
            700: "#a21caf",
            800: "#86198f",
            900: "#701a75",
            950: "#4a044e"
          },
          purple: {
            50: "#faf5ff",
            100: "#f3e8ff",
            200: "#e9d5ff",
            300: "#d8b4fe",
            400: "#c084fc",
            500: "#a855f7",
            600: "#9333ea",
            700: "#7e22ce",
            800: "#6b21a8",
            900: "#581c87",
            950: "#3b0764"
          },
          violet: {
            50: "#f5f3ff",
            100: "#ede9fe",
            200: "#ddd6fe",
            300: "#c4b5fd",
            400: "#a78bfa",
            500: "#8b5cf6",
            600: "#7c3aed",
            700: "#6d28d9",
            800: "#5b21b6",
            900: "#4c1d95",
            950: "#2e1065"
          },
          indigo: {
            50: "#eef2ff",
            100: "#e0e7ff",
            200: "#c7d2fe",
            300: "#a5b4fc",
            400: "#818cf8",
            500: "#6366f1",
            600: "#4f46e5",
            700: "#4338ca",
            800: "#3730a3",
            900: "#312e81",
            950: "#1e1b4b"
          },
          blue: {
            50: "#eff6ff",
            100: "#dbeafe",
            200: "#bfdbfe",
            300: "#93c5fd",
            400: "#60a5fa",
            500: "#3b82f6",
            600: "#2563eb",
            700: "#1d4ed8",
            800: "#1e40af",
            900: "#1e3a8a",
            950: "#172554"
          },
          sky: {
            50: "#f0f9ff",
            100: "#e0f2fe",
            200: "#bae6fd",
            300: "#7dd3fc",
            400: "#38bdf8",
            500: "#0ea5e9",
            600: "#0284c7",
            700: "#0369a1",
            800: "#075985",
            900: "#0c4a6e",
            950: "#082f49"
          },
          cyan: {
            50: "#ecfeff",
            100: "#cffafe",
            200: "#a5f3fc",
            300: "#67e8f9",
            400: "#22d3ee",
            500: "#06b6d4",
            600: "#0891b2",
            700: "#0e7490",
            800: "#155e75",
            900: "#164e63",
            950: "#083344"
          },
          teal: {
            50: "#f0fdfa",
            100: "#ccfbf1",
            200: "#99f6e4",
            300: "#5eead4",
            400: "#2dd4bf",
            500: "#14b8a6",
            600: "#0d9488",
            700: "#0f766e",
            800: "#115e59",
            900: "#134e4a",
            950: "#042f2e"
          },
          emerald: {
            50: "#ecfdf5",
            100: "#d1fae5",
            200: "#a7f3d0",
            300: "#6ee7b7",
            400: "#34d399",
            500: "#10b981",
            600: "#059669",
            700: "#047857",
            800: "#065f46",
            900: "#064e3b",
            950: "#022c22"
          },
          green: {
            50: "#f0fdf4",
            100: "#dcfce7",
            200: "#bbf7d0",
            300: "#86efac",
            400: "#4ade80",
            500: "#22c55e",
            600: "#16a34a",
            700: "#15803d",
            800: "#166534",
            900: "#14532d",
            950: "#052e16"
          },
          lime: {
            50: "#f7fee7",
            100: "#ecfccb",
            200: "#d9f99d",
            300: "#bef264",
            400: "#a3e635",
            500: "#84cc16",
            600: "#65a30d",
            700: "#4d7c0f",
            800: "#3f6212",
            900: "#365314",
            950: "#1a2e05"
          },
          yellow: {
            50: "#fefce8",
            100: "#fef9c3",
            200: "#fef08a",
            300: "#fde047",
            400: "#facc15",
            500: "#eab308",
            600: "#ca8a04",
            700: "#a16207",
            800: "#854d0e",
            900: "#713f12",
            950: "#422006"
          },
          amber: {
            50: "#fffbeb",
            100: "#fef3c7",
            200: "#fde68a",
            300: "#fcd34d",
            400: "#fbbf24",
            500: "#f59e0b",
            600: "#d97706",
            700: "#b45309",
            800: "#92400e",
            900: "#78350f",
            950: "#451a03"
          },
          orange: {
            50: "#fff7ed",
            100: "#ffedd5",
            200: "#fed7aa",
            300: "#fdba74",
            400: "#fb923c",
            500: "#f97316",
            600: "#ea580c",
            700: "#c2410c",
            800: "#9a3412",
            900: "#7c2d12",
            950: "#431407"
          },
          red: {
            50: "#fef2f2",
            100: "#fee2e2",
            200: "#fecaca",
            300: "#fca5a5",
            400: "#f87171",
            500: "#ef4444",
            600: "#dc2626",
            700: "#b91c1c",
            800: "#991b1b",
            900: "#7f1d1d",
            950: "#450a0a"
          },
          gray: {
            50: "#f9fafb",
            100: "#f3f4f6",
            200: "#e5e7eb",
            300: "#d1d5db",
            400: "#9ca3af",
            500: "#6b7280",
            600: "#4b5563",
            700: "#374151",
            800: "#1f2937",
            900: "#111827",
            950: "#030712"
          },
          slate: {
            50: "#f8fafc",
            100: "#f1f5f9",
            200: "#e2e8f0",
            300: "#cbd5e1",
            400: "#94a3b8",
            500: "#64748b",
            600: "#475569",
            700: "#334155",
            800: "#1e293b",
            900: "#0f172a",
            950: "#020617"
          },
          zinc: {
            50: "#fafafa",
            100: "#f4f4f5",
            200: "#e4e4e7",
            300: "#d4d4d8",
            400: "#a1a1aa",
            500: "#71717a",
            600: "#52525b",
            700: "#3f3f46",
            800: "#27272a",
            900: "#18181b",
            950: "#09090b"
          },
          neutral: {
            50: "#fafafa",
            100: "#f5f5f5",
            200: "#e5e5e5",
            300: "#d4d4d4",
            400: "#a3a3a3",
            500: "#737373",
            600: "#525252",
            700: "#404040",
            800: "#262626",
            900: "#171717",
            950: "#0a0a0a"
          },
          stone: {
            50: "#fafaf9",
            100: "#f5f5f4",
            200: "#e7e5e4",
            300: "#d6d3d1",
            400: "#a8a29e",
            500: "#78716c",
            600: "#57534e",
            700: "#44403c",
            800: "#292524",
            900: "#1c1917",
            950: "#0c0a09"
          },
          light: {
            50: "#fdfdfd",
            100: "#fcfcfc",
            200: "#fafafa",
            300: "#f8f9fa",
            400: "#f6f6f6",
            500: "#f2f2f2",
            600: "#f1f3f5",
            700: "#e9ecef",
            800: "#dee2e6",
            900: "#dde1e3",
            950: "#d8dcdf"
          },
          dark: {
            50: "#4a4a4a",
            100: "#3c3c3c",
            200: "#323232",
            300: "#2d2d2d",
            400: "#222222",
            500: "#1f1f1f",
            600: "#1c1c1e",
            700: "#1b1b1b",
            800: "#181818",
            900: "#0f0f0f",
            950: "#080808"
          },
          get lightblue() {
            return this.sky;
          },
          get lightBlue() {
            return this.sky;
          },
          get warmgray() {
            return this.stone;
          },
          get warmGray() {
            return this.stone;
          },
          get truegray() {
            return this.neutral;
          },
          get trueGray() {
            return this.neutral;
          },
          get coolgray() {
            return this.gray;
          },
          get coolGray() {
            return this.gray;
          },
          get bluegray() {
            return this.slate;
          },
          get blueGray() {
            return this.slate;
          }
        };
        Object.values(cn2).forEach((e2) => {
          typeof e2 != "string" && e2 !== void 0 && (e2.DEFAULT = e2.DEFAULT || e2[400], Object.keys(e2).forEach((t2) => {
            let r2 = +t2 / 100;
            r2 === Math.round(r2) && (e2[r2] = e2[t2]);
          }));
        });
        var Er = { x: ["-x"], y: ["-y"], z: ["-z"], "": ["-x", "-y"] }, sa = [
          "top",
          "top center",
          "top left",
          "top right",
          "bottom",
          "bottom center",
          "bottom left",
          "bottom right",
          "left",
          "left center",
          "left top",
          "left bottom",
          "right",
          "right center",
          "right top",
          "right bottom",
          "center",
          "center top",
          "center bottom",
          "center left",
          "center right",
          "center center"
        ], He2 = Object.assign(
          {},
          ...sa.map((e2) => ({ [e2.replace(/ /, "-")]: e2 })),
          ...sa.map((e2) => ({
            [e2.replace(/\b(\w)\w+/g, "$1").replace(/ /, "")]: e2
          }))
        ), ln2 = ["inherit", "initial", "revert", "revert-layer", "unset"], fn2 = /^(-?\d*(?:\.\d+)?)(px|pt|pc|%|r?(?:em|ex|lh|cap|ch|ic)|(?:[sld]?v|cq)(?:[whib]|min|max)|in|cm|mm|rpx)?$/i, la = /^(-?\d*(?:\.\d+)?)$/i, fa = /^(px)$/i, ua = /^\[(color|length|position|quoted|string):/i, sl = [
          "color",
          "border-color",
          "background-color",
          "flex-grow",
          "flex",
          "flex-shrink",
          "caret-color",
          "font",
          "gap",
          "opacity",
          "visibility",
          "z-index",
          "font-weight",
          "zoom",
          "text-shadow",
          "transform",
          "box-shadow",
          "background-position",
          "left",
          "right",
          "top",
          "bottom",
          "object-position",
          "max-height",
          "min-height",
          "max-width",
          "min-width",
          "height",
          "width",
          "border-width",
          "margin",
          "padding",
          "outline-width",
          "outline-offset",
          "font-size",
          "line-height",
          "text-indent",
          "vertical-align",
          "border-spacing",
          "letter-spacing",
          "word-spacing",
          "stroke",
          "filter",
          "backdrop-filter",
          "fill",
          "mask",
          "mask-size",
          "mask-border",
          "clip-path",
          "clip",
          "border-radius"
        ];
        function Y(e2) {
          return e2.toFixed(10).replace(/\.0+$/, "").replace(/(\.\d+?)0+$/, "$1");
        }
        function cl(e2) {
          let t2 = e2.match(fn2);
          if (!t2)
            return;
          let [, r2, n2] = t2, o2 = Number.parseFloat(r2);
          if (n2 && !Number.isNaN(o2))
            return `${Y(o2)}${n2}`;
        }
        function ll(e2) {
          if (e2 === "auto" || e2 === "a")
            return "auto";
        }
        function fl(e2) {
          if (fa.test(e2))
            return `1${e2}`;
          let t2 = e2.match(fn2);
          if (!t2)
            return;
          let [, r2, n2] = t2, o2 = Number.parseFloat(r2);
          if (!Number.isNaN(o2))
            return o2 === 0 ? "0" : n2 ? `${Y(o2)}${n2}` : `${Y(o2 / 4)}rem`;
        }
        function ul(e2) {
          if (fa.test(e2))
            return `1${e2}`;
          let t2 = e2.match(fn2);
          if (!t2)
            return;
          let [, r2, n2] = t2, o2 = Number.parseFloat(r2);
          if (!Number.isNaN(o2))
            return n2 ? `${Y(o2)}${n2}` : `${Y(o2)}px`;
        }
        function pl(e2) {
          if (!la.test(e2))
            return;
          let t2 = Number.parseFloat(e2);
          if (!Number.isNaN(t2))
            return Y(t2);
        }
        function dl(e2) {
          if (e2.endsWith("%") && (e2 = e2.slice(0, -1)), !la.test(e2))
            return;
          let t2 = Number.parseFloat(e2);
          if (!Number.isNaN(t2))
            return `${Y(t2 / 100)}`;
        }
        function ml(e2) {
          if (e2 === "full")
            return "100%";
          let [t2, r2] = e2.split("/"), n2 = Number.parseFloat(t2) / Number.parseFloat(r2);
          if (!Number.isNaN(n2))
            return n2 === 0 ? "0" : `${Y(n2 * 100)}%`;
        }
        function jr(e2, t2) {
          if (e2 && e2.startsWith("[") && e2.endsWith("]")) {
            let r2, n2, o2 = e2.match(ua);
            if (o2 ? (t2 || (n2 = o2[1]), r2 = e2.slice(o2[0].length, -1)) : r2 = e2.slice(1, -1), !r2 || r2 === '=""')
              return;
            r2.startsWith("--") && (r2 = `var(${r2})`);
            let i = 0;
            for (let a of r2)
              if (a === "[")
                i += 1;
              else if (a === "]" && (i -= 1, i < 0))
                return;
            if (i)
              return;
            switch (n2) {
              case "string":
                return r2.replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_");
              case "quoted":
                return r2.replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_").replace(/(["\\])/g, "\\$1").replace(/^(.+)$/, '"$1"');
            }
            return r2.replace(/(url\(.*?\))/g, (a) => a.replace(/_/g, "\\_")).replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_").replace(/(?:calc|clamp|max|min)\((.*)/g, (a) => {
              let s2 = [];
              return a.replace(
                /var\((--.+?)[,)]/g,
                (c, f) => (s2.push(f), c.replace(f, "--un-calc"))
              ).replace(
                /(-?\d*\.?\d(?!\b-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g,
                "$1 $2 "
              ).replace(/--un-calc/g, () => s2.shift());
            });
          }
        }
        function hl(e2) {
          return jr(e2);
        }
        function gl(e2) {
          return jr(e2, "color");
        }
        function bl(e2) {
          return jr(e2, "length");
        }
        function xl(e2) {
          return jr(e2, "position");
        }
        function yl(e2) {
          if (/^\$[^\s'"`;{}]/.test(e2)) {
            let [t2, r2] = e2.slice(1).split(",");
            return `var(--${Q2(t2)}${r2 ? `, ${r2}` : ""})`;
          }
        }
        function vl(e2) {
          let t2 = e2.match(/^(-?[0-9.]+)(s|ms)?$/i);
          if (!t2)
            return;
          let [, r2, n2] = t2, o2 = Number.parseFloat(r2);
          if (!Number.isNaN(o2))
            return o2 === 0 && !n2 ? "0s" : n2 ? `${Y(o2)}${n2}` : `${Y(o2)}ms`;
        }
        function wl(e2) {
          let t2 = e2.match(/^(-?[0-9.]+)(deg|rad|grad|turn)?$/i);
          if (!t2)
            return;
          let [, r2, n2] = t2, o2 = Number.parseFloat(r2);
          if (!Number.isNaN(o2))
            return o2 === 0 ? "0" : n2 ? `${Y(o2)}${n2}` : `${Y(o2)}deg`;
        }
        function $l(e2) {
          if (ln2.includes(e2))
            return e2;
        }
        function kl(e2) {
          if (e2.split(",").every((t2) => sl.includes(t2)))
            return e2;
        }
        function Sl(e2) {
          if (["top", "left", "right", "bottom", "center"].includes(e2))
            return e2;
        }
        var Cl = {
          __proto__: null,
          auto: ll,
          bracket: hl,
          bracketOfColor: gl,
          bracketOfLength: bl,
          bracketOfPosition: xl,
          cssvar: yl,
          degree: wl,
          fraction: ml,
          global: $l,
          number: pl,
          numberWithUnit: cl,
          percent: dl,
          position: Sl,
          properties: kl,
          px: ul,
          rem: fl,
          time: vl
        }, Rl = st2(Cl), P2 = Rl;
        function se2(e2, t2) {
          return ln2.map((r2) => [`${e2}-${r2}`, { [t2 ?? e2]: r2 }]);
        }
        var ba = " ";
        var xa = {
          "--un-ring-inset": ba,
          "--un-ring-offset-width": "0px",
          "--un-ring-offset-color": "#fff",
          "--un-ring-width": "0px",
          "--un-ring-color": "rgb(147 197 253 / 0.5)",
          "--un-shadow": "0 0 rgb(0 0 0 / 0)"
        };
        var va = {
          "--un-ring-offset-shadow": "0 0 rgb(0 0 0 / 0)",
          "--un-ring-shadow": "0 0 rgb(0 0 0 / 0)",
          "--un-shadow-inset": ba,
          "--un-shadow": "0 0 rgb(0 0 0 / 0)"
        };
        var zr = ["translate", "rotate", "scale"], he = [
          "translateX(var(--un-translate-x))",
          "translateY(var(--un-translate-y))",
          "translateZ(var(--un-translate-z))",
          "rotate(var(--un-rotate))",
          "rotateX(var(--un-rotate-x))",
          "rotateY(var(--un-rotate-y))",
          "rotateZ(var(--un-rotate-z))",
          "skewX(var(--un-skew-x))",
          "skewY(var(--un-skew-y))",
          "scaleX(var(--un-scale-x))",
          "scaleY(var(--un-scale-y))",
          "scaleZ(var(--un-scale-z))"
        ].join(" "), Ol = [
          "translate3d(var(--un-translate-x), var(--un-translate-y), var(--un-translate-z))",
          "rotate(var(--un-rotate))",
          "rotateX(var(--un-rotate-x))",
          "rotateY(var(--un-rotate-y))",
          "rotateZ(var(--un-rotate-z))",
          "skewX(var(--un-skew-x))",
          "skewY(var(--un-skew-y))",
          "scaleX(var(--un-scale-x))",
          "scaleY(var(--un-scale-y))",
          "scaleZ(var(--un-scale-z))"
        ].join(" "), wa = {
          "--un-rotate": 0,
          "--un-rotate-x": 0,
          "--un-rotate-y": 0,
          "--un-rotate-z": 0,
          "--un-scale-x": 1,
          "--un-scale-y": 1,
          "--un-scale-z": 1,
          "--un-skew-x": 0,
          "--un-skew-y": 0,
          "--un-translate-x": 0,
          "--un-translate-y": 0,
          "--un-translate-z": 0
        };
        [
          [
            /^(?:transform-)?origin-(.+)$/,
            ([, e2]) => ({ "transform-origin": He2[e2] ?? P2.bracket.cssvar(e2) }),
            {
              autocomplete: [
                `transform-origin-(${Object.keys(He2).join("|")})`,
                `origin-(${Object.keys(He2).join("|")})`
              ]
            }
          ],
          [
            /^(?:transform-)?perspect(?:ive)?-(.+)$/,
            ([, e2]) => {
              let t2 = P2.bracket.cssvar.px.numberWithUnit(e2);
              if (t2 != null)
                return { "-webkit-perspective": t2, perspective: t2 };
            }
          ],
          [
            /^(?:transform-)?perspect(?:ive)?-origin-(.+)$/,
            ([, e2]) => {
              let t2 = P2.bracket.cssvar(e2) ?? (e2.length >= 3 ? He2[e2] : void 0);
              if (t2 != null)
                return { "-webkit-perspective-origin": t2, "perspective-origin": t2 };
            }
          ],
          [/^(?:transform-)?translate-()(.+)$/, da],
          [/^(?:transform-)?translate-([xyz])-(.+)$/, da],
          [/^(?:transform-)?rotate-()(.+)$/, ha],
          [/^(?:transform-)?rotate-([xyz])-(.+)$/, ha],
          [/^(?:transform-)?skew-()(.+)$/, ga],
          [
            /^(?:transform-)?skew-([xy])-(.+)$/,
            ga,
            {
              autocomplete: [
                "transform-skew-(x|y)-<percent>",
                "skew-(x|y)-<percent>"
              ]
            }
          ],
          [/^(?:transform-)?scale-()(.+)$/, ma],
          [
            /^(?:transform-)?scale-([xyz])-(.+)$/,
            ma,
            {
              autocomplete: [
                `transform-(${zr.join("|")})-<percent>`,
                `transform-(${zr.join("|")})-(x|y|z)-<percent>`,
                `(${zr.join("|")})-<percent>`,
                `(${zr.join("|")})-(x|y|z)-<percent>`
              ]
            }
          ],
          [
            /^(?:transform-)?preserve-3d$/,
            () => ({ "transform-style": "preserve-3d" })
          ],
          [/^(?:transform-)?preserve-flat$/, () => ({ "transform-style": "flat" })],
          ["transform", { transform: he }],
          ["transform-cpu", { transform: he }],
          ["transform-gpu", { transform: Ol }],
          ["transform-none", { transform: "none" }],
          ...se2("transform")
        ];
        function da([, e2, t2], { theme: r2 }) {
          var _a3;
          let n2 = ((_a3 = r2.spacing) == null ? void 0 : _a3[t2]) ?? P2.bracket.cssvar.fraction.rem(t2);
          if (n2 != null)
            return [
              ...Er[e2].map((o2) => [`--un-translate${o2}`, n2]),
              ["transform", he]
            ];
        }
        function ma([, e2, t2]) {
          let r2 = P2.bracket.cssvar.fraction.percent(t2);
          if (r2 != null)
            return [...Er[e2].map((n2) => [`--un-scale${n2}`, r2]), ["transform", he]];
        }
        function ha([, e2 = "", t2]) {
          let r2 = P2.bracket.cssvar.degree(t2);
          if (r2 != null)
            return e2 ? { "--un-rotate": 0, [`--un-rotate-${e2}`]: r2, transform: he } : {
              "--un-rotate-x": 0,
              "--un-rotate-y": 0,
              "--un-rotate-z": 0,
              "--un-rotate": r2,
              transform: he
            };
        }
        function ga([, e2, t2]) {
          let r2 = P2.bracket.cssvar.degree(t2);
          if (r2 != null)
            return [...Er[e2].map((n2) => [`--un-skew${n2}`, r2]), ["transform", he]];
        }
        var $a = {
          sans: [
            "ui-sans-serif",
            "system-ui",
            "-apple-system",
            "BlinkMacSystemFont",
            '"Segoe UI"',
            "Roboto",
            '"Helvetica Neue"',
            "Arial",
            '"Noto Sans"',
            "sans-serif",
            '"Apple Color Emoji"',
            '"Segoe UI Emoji"',
            '"Segoe UI Symbol"',
            '"Noto Color Emoji"'
          ].join(","),
          serif: [
            "ui-serif",
            "Georgia",
            "Cambria",
            '"Times New Roman"',
            "Times",
            "serif"
          ].join(","),
          mono: [
            "ui-monospace",
            "SFMono-Regular",
            "Menlo",
            "Monaco",
            "Consolas",
            '"Liberation Mono"',
            '"Courier New"',
            "monospace"
          ].join(",")
        }, ka = {
          xs: ["0.75rem", "1rem"],
          sm: ["0.875rem", "1.25rem"],
          base: ["1rem", "1.5rem"],
          lg: ["1.125rem", "1.75rem"],
          xl: ["1.25rem", "1.75rem"],
          "2xl": ["1.5rem", "2rem"],
          "3xl": ["1.875rem", "2.25rem"],
          "4xl": ["2.25rem", "2.5rem"],
          "5xl": ["3rem", "1"],
          "6xl": ["3.75rem", "1"],
          "7xl": ["4.5rem", "1"],
          "8xl": ["6rem", "1"],
          "9xl": ["8rem", "1"]
        }, Sa = {
          DEFAULT: "1.5rem",
          xs: "0.5rem",
          sm: "1rem",
          md: "1.5rem",
          lg: "2rem",
          xl: "2.5rem",
          "2xl": "3rem",
          "3xl": "4rem"
        }, Ca = {
          DEFAULT: "1.5rem",
          none: "0",
          sm: "thin",
          md: "medium",
          lg: "thick"
        }, Ra = {
          DEFAULT: ["0 0 1px rgb(0 0 0 / 0.2)", "0 0 1px rgb(1 0 5 / 0.1)"],
          none: "0 0 rgb(0 0 0 / 0)",
          sm: "1px 1px 3px rgb(36 37 47 / 0.25)",
          md: [
            "0 1px 2px rgb(30 29 39 / 0.19)",
            "1px 2px 4px rgb(54 64 147 / 0.18)"
          ],
          lg: ["3px 3px 6px rgb(0 0 0 / 0.26)", "0 0 5px rgb(15 3 86 / 0.22)"],
          xl: [
            "1px 1px 3px rgb(0 0 0 / 0.29)",
            "2px 4px 7px rgb(73 64 125 / 0.35)"
          ]
        }, Ta = {
          none: "1",
          tight: "1.25",
          snug: "1.375",
          normal: "1.5",
          relaxed: "1.625",
          loose: "2"
        }, mn2 = {
          tighter: "-0.05em",
          tight: "-0.025em",
          normal: "0em",
          wide: "0.025em",
          wider: "0.05em",
          widest: "0.1em"
        }, Ea = {
          thin: "100",
          extralight: "200",
          light: "300",
          normal: "400",
          medium: "500",
          semibold: "600",
          bold: "700",
          extrabold: "800",
          black: "900"
        }, ja = mn2, hn = {
          sm: "640px",
          md: "768px",
          lg: "1024px",
          xl: "1280px",
          "2xl": "1536px"
        }, za = { ...hn }, Oa = { DEFAULT: "1px", none: "0" }, Aa = {
          DEFAULT: "1rem",
          none: "0",
          xs: "0.75rem",
          sm: "0.875rem",
          lg: "1.125rem",
          xl: "1.25rem",
          "2xl": "1.5rem",
          "3xl": "1.875rem",
          "4xl": "2.25rem",
          "5xl": "3rem",
          "6xl": "3.75rem",
          "7xl": "4.5rem",
          "8xl": "6rem",
          "9xl": "8rem"
        }, Va = {
          DEFAULT: "150ms",
          none: "0s",
          75: "75ms",
          100: "100ms",
          150: "150ms",
          200: "200ms",
          300: "300ms",
          500: "500ms",
          700: "700ms",
          1e3: "1000ms"
        }, _a2 = {
          DEFAULT: "0.25rem",
          none: "0",
          sm: "0.125rem",
          md: "0.375rem",
          lg: "0.5rem",
          xl: "0.75rem",
          "2xl": "1rem",
          "3xl": "1.5rem",
          full: "9999px"
        }, Pa = {
          DEFAULT: [
            "var(--un-shadow-inset) 0 1px 3px 0 rgb(0 0 0 / 0.1)",
            "var(--un-shadow-inset) 0 1px 2px -1px rgb(0 0 0 / 0.1)"
          ],
          none: "0 0 rgb(0 0 0 / 0)",
          sm: "var(--un-shadow-inset) 0 1px 2px 0 rgb(0 0 0 / 0.05)",
          md: [
            "var(--un-shadow-inset) 0 4px 6px -1px rgb(0 0 0 / 0.1)",
            "var(--un-shadow-inset) 0 2px 4px -2px rgb(0 0 0 / 0.1)"
          ],
          lg: [
            "var(--un-shadow-inset) 0 10px 15px -3px rgb(0 0 0 / 0.1)",
            "var(--un-shadow-inset) 0 4px 6px -4px rgb(0 0 0 / 0.1)"
          ],
          xl: [
            "var(--un-shadow-inset) 0 20px 25px -5px rgb(0 0 0 / 0.1)",
            "var(--un-shadow-inset) 0 8px 10px -6px rgb(0 0 0 / 0.1)"
          ],
          "2xl": "var(--un-shadow-inset) 0 25px 50px -12px rgb(0 0 0 / 0.25)",
          inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)"
        }, Ma = {
          DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
          linear: "linear",
          in: "cubic-bezier(0.4, 0, 1, 1)",
          out: "cubic-bezier(0, 0, 0.2, 1)",
          "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
        }, Fa = { DEFAULT: "1px", none: "0" }, Ua = { auto: "auto" }, La = { mouse: "(hover) and (pointer: fine)" }, Wa = {
          DEFAULT: "8px",
          0: "0",
          sm: "4px",
          md: "12px",
          lg: "16px",
          xl: "24px",
          "2xl": "40px",
          "3xl": "64px"
        }, Na = {
          DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
          sm: "0 1px 1px rgb(0 0 0 / 0.05)",
          md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
          lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
          xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
          "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
          none: "0 0 rgb(0 0 0 / 0)"
        }, Ee2 = {
          xs: "20rem",
          sm: "24rem",
          md: "28rem",
          lg: "32rem",
          xl: "36rem",
          "2xl": "42rem",
          "3xl": "48rem",
          "4xl": "56rem",
          "5xl": "64rem",
          "6xl": "72rem",
          "7xl": "80rem",
          prose: "65ch"
        }, pn2 = { auto: "auto", ...Ee2, screen: "100vw" }, qe = { none: "none", ...Ee2, screen: "100vw" }, dn2 = { auto: "auto", ...Ee2, screen: "100vh" }, Ye2 = { none: "none", ...Ee2, screen: "100vh" }, Ba = Object.fromEntries(
          Object.entries(Ee2).map(([e2, t2]) => [e2, `(min-width: ${t2})`])
        ), Da = { ...wa, ...va, ...xa }, gn2 = {
          width: pn2,
          height: dn2,
          maxWidth: qe,
          maxHeight: Ye2,
          minWidth: qe,
          minHeight: Ye2,
          inlineSize: pn2,
          blockSize: dn2,
          maxInlineSize: qe,
          maxBlockSize: Ye2,
          minInlineSize: qe,
          minBlockSize: Ye2,
          colors: cn2,
          fontFamily: $a,
          fontSize: ka,
          fontWeight: Ea,
          breakpoints: hn,
          verticalBreakpoints: za,
          borderRadius: _a2,
          lineHeight: Ta,
          letterSpacing: mn2,
          wordSpacing: ja,
          boxShadow: Pa,
          textIndent: Sa,
          textShadow: Ra,
          textStrokeWidth: Ca,
          blur: Wa,
          dropShadow: Na,
          easing: Ma,
          lineWidth: Oa,
          spacing: Aa,
          duration: Va,
          ringWidth: Fa,
          preflightBase: Da,
          containers: Ba,
          zIndex: Ua,
          media: La
        };
        var Ia = {
          ...gn2,
          aria: {
            busy: 'busy="true"',
            checked: 'checked="true"',
            disabled: 'disabled="true"',
            expanded: 'expanded="true"',
            hidden: 'hidden="true"',
            pressed: 'pressed="true"',
            readonly: 'readonly="true"',
            required: 'required="true"',
            selected: 'selected="true"'
          },
          animation: {
            keyframes: {
              pulse: "{0%, 100% {opacity:1} 50% {opacity:.5}}",
              bounce: "{0%, 100% {transform:translateY(-25%);animation-timing-function:cubic-bezier(0.8,0,1,1)} 50% {transform:translateY(0);animation-timing-function:cubic-bezier(0,0,0.2,1)}}",
              spin: "{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}",
              ping: "{0%{transform:scale(1);opacity:1}75%,100%{transform:scale(2);opacity:0}}",
              "bounce-alt": "{from,20%,53%,80%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1);transform:translate3d(0,0,0)}40%,43%{animation-timing-function:cubic-bezier(0.755,0.05,0.855,0.06);transform:translate3d(0,-30px,0)}70%{animation-timing-function:cubic-bezier(0.755,0.05,0.855,0.06);transform:translate3d(0,-15px,0)}90%{transform:translate3d(0,-4px,0)}}",
              flash: "{from,50%,to{opacity:1}25%,75%{opacity:0}}",
              "pulse-alt": "{from{transform:scale3d(1,1,1)}50%{transform:scale3d(1.05,1.05,1.05)}to{transform:scale3d(1,1,1)}}",
              "rubber-band": "{from{transform:scale3d(1,1,1)}30%{transform:scale3d(1.25,0.75,1)}40%{transform:scale3d(0.75,1.25,1)}50%{transform:scale3d(1.15,0.85,1)}65%{transform:scale3d(0.95,1.05,1)}75%{transform:scale3d(1.05,0.95,1)}to{transform:scale3d(1,1,1)}}",
              "shake-x": "{from,to{transform:translate3d(0,0,0)}10%,30%,50%,70%,90%{transform:translate3d(-10px,0,0)}20%,40%,60%,80%{transform:translate3d(10px,0,0)}}",
              "shake-y": "{from,to{transform:translate3d(0,0,0)}10%,30%,50%,70%,90%{transform:translate3d(0,-10px,0)}20%,40%,60%,80%{transform:translate3d(0,10px,0)}}",
              "head-shake": "{0%{transform:translateX(0)}6.5%{transform:translateX(-6px) rotateY(-9deg)}18.5%{transform:translateX(5px) rotateY(7deg)}31.5%{transform:translateX(-3px) rotateY(-5deg)}43.5%{transform:translateX(2px) rotateY(3deg)}50%{transform:translateX(0)}}",
              swing: "{20%{transform:rotate3d(0,0,1,15deg)}40%{transform:rotate3d(0,0,1,-10deg)}60%{transform:rotate3d(0,0,1,5deg)}80%{transform:rotate3d(0,0,1,-5deg)}to{transform:rotate3d(0,0,1,0deg)}}",
              tada: "{from{transform:scale3d(1,1,1)}10%,20%{transform:scale3d(0.9,0.9,0.9) rotate3d(0,0,1,-3deg)}30%,50%,70%,90%{transform:scale3d(1.1,1.1,1.1) rotate3d(0,0,1,3deg)}40%,60%,80%{transform:scale3d(1.1,1.1,1.1) rotate3d(0,0,1,-3deg)}to{transform:scale3d(1,1,1)}}",
              wobble: "{from{transform:translate3d(0,0,0)}15%{transform:translate3d(-25%,0,0) rotate3d(0,0,1,-5deg)}30%{transform:translate3d(20%,0,0) rotate3d(0,0,1,3deg)}45%{transform:translate3d(-15%,0,0) rotate3d(0,0,1,-3deg)}60%{transform:translate3d(10%,0,0) rotate3d(0,0,1,2deg)}75%{transform:translate3d(-5%,0,0) rotate3d(0,0,1,-1deg)}to{transform:translate3d(0,0,0)}}",
              jello: "{from,11.1%,to{transform:translate3d(0,0,0)}22.2%{transform:skewX(-12.5deg) skewY(-12.5deg)}33.3%{transform:skewX(6.25deg) skewY(6.25deg)}44.4%{transform:skewX(-3.125deg)skewY(-3.125deg)}55.5%{transform:skewX(1.5625deg) skewY(1.5625deg)}66.6%{transform:skewX(-0.78125deg) skewY(-0.78125deg)}77.7%{transform:skewX(0.390625deg) skewY(0.390625deg)}88.8%{transform:skewX(-0.1953125deg) skewY(-0.1953125deg)}}",
              "heart-beat": "{0%{transform:scale(1)}14%{transform:scale(1.3)}28%{transform:scale(1)}42%{transform:scale(1.3)}70%{transform:scale(1)}}",
              hinge: "{0%{transform-origin:top left;animation-timing-function:ease-in-out}20%,60%{transform:rotate3d(0,0,1,80deg);transform-origin:top left;animation-timing-function:ease-in-out}40%,80%{transform:rotate3d(0,0,1,60deg);transform-origin:top left;animation-timing-function:ease-in-out}to{transform:translate3d(0,700px,0);opacity:0}}",
              "jack-in-the-box": "{from{opacity:0;transform-origin:center bottom;transform:scale(0.1) rotate(30deg)}50%{transform:rotate(-10deg)}70%{transform:rotate(3deg)}to{transform:scale(1)}}",
              "light-speed-in-left": "{from{opacity:0;transform:translate3d(-100%,0,0) skewX(-30deg)}60%{opacity:1;transform:skewX(20deg)}80%{transform:skewX(-5deg)}to{transform:translate3d(0,0,0)}}",
              "light-speed-in-right": "{from{opacity:0;transform:translate3d(100%,0,0) skewX(-30deg)}60%{opacity:1;transform:skewX(20deg)}80%{transform:skewX(-5deg)}to{transform:translate3d(0,0,0)}}",
              "light-speed-out-left": "{from{opacity:1}to{opacity:0;transform:translate3d(-100%,0,0) skewX(30deg)}}",
              "light-speed-out-right": "{from{opacity:1}to{opacity:0;transform:translate3d(100%,0,0) skewX(30deg)}}",
              flip: "{from{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,0) rotate3d(0,1,0,-360deg);animation-timing-function:ease-out}40%{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,150px) rotate3d(0,1,0,-190deg);animation-timing-function:ease-out}50%{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,150px) rotate3d(0,1,0,-170deg);animation-timing-function:ease-in}80%{transform:perspective(400px) scale3d(0.95,0.95,0.95) translate3d(0,0,0) rotate3d(0,1,0,0deg);animation-timing-function:ease-in}to{transform:perspective(400px) scale3d(1,1,1) translate3d(0,0,0) rotate3d(0,1,0,0deg);animation-timing-function:ease-in}}",
              "flip-in-x": "{from{transform:perspective(400px) rotate3d(1,0,0,90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotate3d(1,0,0,-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotate3d(1,0,0,10deg);opacity:1}80%{transform:perspective(400px) rotate3d(1,0,0,-5deg)}to{transform:perspective(400px)}}",
              "flip-in-y": "{from{transform:perspective(400px) rotate3d(0,1,0,90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotate3d(0,1,0,-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotate3d(0,1,0,10deg);opacity:1}80%{transform:perspective(400px) rotate3d(0,1,0,-5deg)}to{transform:perspective(400px)}}",
              "flip-out-x": "{from{transform:perspective(400px)}30%{transform:perspective(400px) rotate3d(1,0,0,-20deg);opacity:1}to{transform:perspective(400px) rotate3d(1,0,0,90deg);opacity:0}}",
              "flip-out-y": "{from{transform:perspective(400px)}30%{transform:perspective(400px) rotate3d(0,1,0,-15deg);opacity:1}to{transform:perspective(400px) rotate3d(0,1,0,90deg);opacity:0}}",
              "rotate-in": "{from{transform-origin:center;transform:rotate3d(0,0,1,-200deg);opacity:0}to{transform-origin:center;transform:translate3d(0,0,0);opacity:1}}",
              "rotate-in-down-left": "{from{transform-origin:left bottom;transform:rotate3d(0,0,1,-45deg);opacity:0}to{transform-origin:left bottom;transform:translate3d(0,0,0);opacity:1}}",
              "rotate-in-down-right": "{from{transform-origin:right bottom;transform:rotate3d(0,0,1,45deg);opacity:0}to{transform-origin:right bottom;transform:translate3d(0,0,0);opacity:1}}",
              "rotate-in-up-left": "{from{transform-origin:left top;transform:rotate3d(0,0,1,45deg);opacity:0}to{transform-origin:left top;transform:translate3d(0,0,0);opacity:1}}",
              "rotate-in-up-right": "{from{transform-origin:right bottom;transform:rotate3d(0,0,1,-90deg);opacity:0}to{transform-origin:right bottom;transform:translate3d(0,0,0);opacity:1}}",
              "rotate-out": "{from{transform-origin:center;opacity:1}to{transform-origin:center;transform:rotate3d(0,0,1,200deg);opacity:0}}",
              "rotate-out-down-left": "{from{transform-origin:left bottom;opacity:1}to{transform-origin:left bottom;transform:rotate3d(0,0,1,45deg);opacity:0}}",
              "rotate-out-down-right": "{from{transform-origin:right bottom;opacity:1}to{transform-origin:right bottom;transform:rotate3d(0,0,1,-45deg);opacity:0}}",
              "rotate-out-up-left": "{from{transform-origin:left bottom;opacity:1}to{transform-origin:left bottom;transform:rotate3d(0,0,1,-45deg);opacity:0}}",
              "rotate-out-up-right": "{from{transform-origin:right bottom;opacity:1}to{transform-origin:left bottom;transform:rotate3d(0,0,1,90deg);opacity:0}}",
              "roll-in": "{from{opacity:0;transform:translate3d(-100%,0,0) rotate3d(0,0,1,-120deg)}to{opacity:1;transform:translate3d(0,0,0)}}",
              "roll-out": "{from{opacity:1}to{opacity:0;transform:translate3d(100%,0,0) rotate3d(0,0,1,120deg)}}",
              "zoom-in": "{from{opacity:0;transform:scale3d(0.3,0.3,0.3)}50%{opacity:1}}",
              "zoom-in-down": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,-1000px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,60px,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
              "zoom-in-left": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(-1000px,0,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(10px,0,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
              "zoom-in-right": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(1000px,0,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(-10px,0,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
              "zoom-in-up": "{from{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,1000px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}60%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,-60px,0);animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
              "zoom-out": "{from{opacity:1}50%{opacity:0;transform:scale3d(0.3,0.3,0.3)}to{opacity:0}}",
              "zoom-out-down": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,-60px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}to{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,2000px,0);transform-origin:center bottom;animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
              "zoom-out-left": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(42px,0,0)}to{opacity:0;transform:scale(0.1) translate3d(-2000px,0,0);transform-origin:left center}}",
              "zoom-out-right": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(-42px,0,0)}to{opacity:0;transform:scale(0.1) translate3d(2000px,0,0);transform-origin:right center}}",
              "zoom-out-up": "{40%{opacity:1;transform:scale3d(0.475,0.475,0.475) translate3d(0,60px,0);animation-timing-function:cubic-bezier(0.55,0.055,0.675,0.19)}to{opacity:0;transform:scale3d(0.1,0.1,0.1) translate3d(0,-2000px,0);transform-origin:center bottom;animation-timing-function:cubic-bezier(0.175,0.885,0.32,1)}}",
              "bounce-in": "{from,20%,40%,60%,80%,to{animation-timing-function:ease-in-out}0%{opacity:0;transform:scale3d(0.3,0.3,0.3)}20%{transform:scale3d(1.1,1.1,1.1)}40%{transform:scale3d(0.9,0.9,0.9)}60%{transform:scale3d(1.03,1.03,1.03);opacity:1}80%{transform:scale3d(0.97,0.97,0.97)}to{opacity:1;transform:scale3d(1,1,1)}}",
              "bounce-in-down": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:translate3d(0,0,0)}}",
              "bounce-in-left": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:translate3d(0,0,0)}}",
              "bounce-in-right": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:translate3d(0,0,0)}}",
              "bounce-in-up": "{from,60%,75%,90%,to{animation-timing-function:cubic-bezier(0.215,0.61,0.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translate3d(0,0,0)}}",
              "bounce-out": "{20%{transform:scale3d(0.9,0.9,0.9)}50%,55%{opacity:1;transform:scale3d(1.1,1.1,1.1)}to{opacity:0;transform:scale3d(0.3,0.3,0.3)}}",
              "bounce-out-down": "{20%{transform:translate3d(0,10px,0)}40%,45%{opacity:1;transform:translate3d(0,-20px,0)}to{opacity:0;transform:translate3d(0,2000px,0)}}",
              "bounce-out-left": "{20%{opacity:1;transform:translate3d(20px,0,0)}to{opacity:0;transform:translate3d(-2000px,0,0)}}",
              "bounce-out-right": "{20%{opacity:1;transform:translate3d(-20px,0,0)}to{opacity:0;transform:translate3d(2000px,0,0)}}",
              "bounce-out-up": "{20%{transform:translate3d(0,-10px,0)}40%,45%{opacity:1;transform:translate3d(0,20px,0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}",
              "slide-in-down": "{from{transform:translate3d(0,-100%,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
              "slide-in-left": "{from{transform:translate3d(-100%,0,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
              "slide-in-right": "{from{transform:translate3d(100%,0,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
              "slide-in-up": "{from{transform:translate3d(0,100%,0);visibility:visible}to{transform:translate3d(0,0,0)}}",
              "slide-out-down": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(0,100%,0)}}",
              "slide-out-left": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(-100%,0,0)}}",
              "slide-out-right": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(100%,0,0)}}",
              "slide-out-up": "{from{transform:translate3d(0,0,0)}to{visibility:hidden;transform:translate3d(0,-100%,0)}}",
              "fade-in": "{from{opacity:0}to{opacity:1}}",
              "fade-in-down": "{from{opacity:0;transform:translate3d(0,-100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
              "fade-in-down-big": "{from{opacity:0;transform:translate3d(0,-2000px,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
              "fade-in-left": "{from{opacity:0;transform:translate3d(-100%,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
              "fade-in-left-big": "{from{opacity:0;transform:translate3d(-2000px,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
              "fade-in-right": "{from{opacity:0;transform:translate3d(100%,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
              "fade-in-right-big": "{from{opacity:0;transform:translate3d(2000px,0,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
              "fade-in-up": "{from{opacity:0;transform:translate3d(0,100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
              "fade-in-up-big": "{from{opacity:0;transform:translate3d(0,2000px,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
              "fade-in-top-left": "{from{opacity:0;transform:translate3d(-100%,-100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
              "fade-in-top-right": "{from{opacity:0;transform:translate3d(100%,-100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
              "fade-in-bottom-left": "{from{opacity:0;transform:translate3d(-100%,100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
              "fade-in-bottom-right": "{from{opacity:0;transform:translate3d(100%,100%,0)}to{opacity:1;transform:translate3d(0,0,0)}}",
              "fade-out": "{from{opacity:1}to{opacity:0}}",
              "fade-out-down": "{from{opacity:1}to{opacity:0;transform:translate3d(0,100%,0)}}",
              "fade-out-down-big": "{from{opacity:1}to{opacity:0;transform:translate3d(0,2000px,0)}}",
              "fade-out-left": "{from{opacity:1}to{opacity:0;transform:translate3d(-100%,0,0)}}",
              "fade-out-left-big": "{from{opacity:1}to{opacity:0;transform:translate3d(-2000px,0,0)}}",
              "fade-out-right": "{from{opacity:1}to{opacity:0;transform:translate3d(100%,0,0)}}",
              "fade-out-right-big": "{from{opacity:1}to{opacity:0;transform:translate3d(2000px,0,0)}}",
              "fade-out-up": "{from{opacity:1}to{opacity:0;transform:translate3d(0,-100%,0)}}",
              "fade-out-up-big": "{from{opacity:1}to{opacity:0;transform:translate3d(0,-2000px,0)}}",
              "fade-out-top-left": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(-100%,-100%,0)}}",
              "fade-out-top-right": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(100%,-100%,0)}}",
              "fade-out-bottom-left": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(-100%,100%,0)}}",
              "fade-out-bottom-right": "{from{opacity:1;transform:translate3d(0,0,0)}to{opacity:0;transform:translate3d(100%,100%,0)}}",
              "back-in-up": "{0%{opacity:0.7;transform:translateY(1200px) scale(0.7)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
              "back-in-down": "{0%{opacity:0.7;transform:translateY(-1200px) scale(0.7)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
              "back-in-right": "{0%{opacity:0.7;transform:translateX(2000px) scale(0.7)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
              "back-in-left": "{0%{opacity:0.7;transform:translateX(-2000px) scale(0.7)}80%{opacity:0.7;transform:translateX(0px) scale(0.7)}100%{opacity:1;transform:scale(1)}}",
              "back-out-up": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:0.7;transform:translateY(-700px) scale(0.7)}}",
              "back-out-down": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:0.7;transform:translateY(700px) scale(0.7)}}",
              "back-out-right": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateY(0px) scale(0.7)}100%{opacity:0.7;transform:translateX(2000px) scale(0.7)}}",
              "back-out-left": "{0%{opacity:1;transform:scale(1)}80%{opacity:0.7;transform:translateX(-2000px) scale(0.7)}100%{opacity:0.7;transform:translateY(-700px) scale(0.7)}}"
            },
            durations: {
              pulse: "2s",
              "heart-beat": "1.3s",
              "bounce-in": "0.75s",
              "bounce-out": "0.75s",
              "flip-out-x": "0.75s",
              "flip-out-y": "0.75s",
              hinge: "2s"
            },
            timingFns: {
              pulse: "cubic-bezier(0.4,0,.6,1)",
              ping: "cubic-bezier(0,0,.2,1)",
              "head-shake": "ease-in-out",
              "heart-beat": "ease-in-out",
              "pulse-alt": "ease-in-out",
              "light-speed-in-left": "ease-out",
              "light-speed-in-right": "ease-out",
              "light-speed-out-left": "ease-in",
              "light-speed-out-right": "ease-in"
            },
            properties: {
              "bounce-alt": { "transform-origin": "center bottom" },
              jello: { "transform-origin": "center" },
              swing: { "transform-origin": "top center" },
              flip: { "backface-visibility": "visible" },
              "flip-in-x": { "backface-visibility": "visible !important" },
              "flip-in-y": { "backface-visibility": "visible !important" },
              "flip-out-x": { "backface-visibility": "visible !important" },
              "flip-out-y": { "backface-visibility": "visible !important" },
              "rotate-in": { "transform-origin": "center" },
              "rotate-in-down-left": { "transform-origin": "left bottom" },
              "rotate-in-down-right": { "transform-origin": "right bottom" },
              "rotate-in-up-left": { "transform-origin": "left bottom" },
              "rotate-in-up-right": { "transform-origin": "right bottom" },
              "rotate-out": { "transform-origin": "center" },
              "rotate-out-down-left": { "transform-origin": "left bottom" },
              "rotate-out-down-right": { "transform-origin": "right bottom" },
              "rotate-out-up-left": { "transform-origin": "left bottom" },
              "rotate-out-up-right": { "transform-origin": "right bottom" },
              hinge: { "transform-origin": "top left" },
              "zoom-out-down": { "transform-origin": "center bottom" },
              "zoom-out-left": { "transform-origin": "left center" },
              "zoom-out-right": { "transform-origin": "right center" },
              "zoom-out-up": { "transform-origin": "center bottom" }
            },
            counts: {
              spin: "infinite",
              ping: "infinite",
              pulse: "infinite",
              "pulse-alt": "infinite",
              bounce: "infinite",
              "bounce-alt": "infinite"
            }
          },
          media: {
            portrait: "(orientation: portrait)",
            landscape: "(orientation: landscape)",
            os_dark: "(prefers-color-scheme: dark)",
            os_light: "(prefers-color-scheme: light)",
            motion_ok: "(prefers-reduced-motion: no-preference)",
            motion_not_ok: "(prefers-reduced-motion: reduce)",
            high_contrast: "(prefers-contrast: high)",
            low_contrast: "(prefers-contrast: low)",
            opacity_ok: "(prefers-reduced-transparency: no-preference)",
            opacity_not_ok: "(prefers-reduced-transparency: reduce)",
            use_data_ok: "(prefers-reduced-data: no-preference)",
            use_data_not_ok: "(prefers-reduced-data: reduce)",
            touch: "(hover: none) and (pointer: coarse)",
            stylus: "(hover: none) and (pointer: fine)",
            pointer: "(hover) and (pointer: coarse)",
            mouse: "(hover) and (pointer: fine)",
            hd_color: "(dynamic-range: high)"
          },
          supports: { grid: "(display: grid)" },
          preflightBase: {
            ...gr,
            ...Qi,
            ...ta,
            ...Zi,
            ...Gi,
            ...cr,
            ...ar,
            ...zi,
            ...Oi
          }
        };
        var Ka = [I2("svg", (e2) => ({ selector: `${e2.selector} svg` }))];
        var Ga = [
          I2(".dark", (e2) => ({ prefix: `.dark $$ ${e2.prefix}` })),
          I2(".light", (e2) => ({ prefix: `.light $$ ${e2.prefix}` })),
          U2("@dark", "@media (prefers-color-scheme: dark)"),
          U2("@light", "@media (prefers-color-scheme: light)")
        ];
        var Ha = [
          U2("contrast-more", "@media (prefers-contrast: more)"),
          U2("contrast-less", "@media (prefers-contrast: less)")
        ], qa = [
          U2("motion-reduce", "@media (prefers-reduced-motion: reduce)"),
          U2("motion-safe", "@media (prefers-reduced-motion: no-preference)")
        ], Ya = [
          U2("landscape", "@media (orientation: landscape)"),
          U2("portrait", "@media (orientation: portrait)")
        ];
        var Xa = (e2) => {
          if (!e2.startsWith("_") && (/space-([xy])-(-?.+)$/.test(e2) || /divide-/.test(e2)))
            return {
              matcher: e2,
              selector: (t2) => {
                let r2 = ">:not([hidden])~:not([hidden])";
                return t2.includes(r2) ? t2 : `${t2}${r2}`;
              }
            };
        }, Za = [
          I2("@hover", (e2) => ({
            parent: `${e2.parent ? `${e2.parent} $$ ` : ""}@media (hover: hover) and (pointer: fine)`,
            selector: `${e2.selector || ""}:hover`
          }))
        ];
        var Ja = (e2, { theme: t2 }) => {
          let r2 = e2.match(/^(.*)\b(placeholder-)(.+)$/);
          if (r2) {
            let [, n2 = "", o2, i] = r2;
            if (Ce(i, t2, "accentColor") || Al(i))
              return { matcher: `${n2}placeholder-$ ${o2}${i}` };
          }
        };
        function Al(e2) {
          let t2 = e2.match(/^op(?:acity)?-?(.+)$/);
          return t2 && t2[1] != null ? l2.bracket.percent(t2[1]) != null : false;
        }
        function Qa(e2) {
          return [Ja, Xa, ...kr(e2), ...Ha, ...Ya, ...qa, ...Ka, ...Ga, ...Za];
        }
        var es = (e2 = {}) => ({
          ...bi(e2),
          name: "@unocss/preset-wind",
          theme: Ia,
          rules: ia,
          shortcuts: aa,
          variants: Qa(e2)
        });
        function ts(e2, t2, r2) {
          return `calc(${t2} + (${e2} - ${t2}) * ${r2} / 100)`;
        }
        function rs(e2, t2, r2) {
          let n2 = [e2, t2], o2 = [];
          for (let a = 0; a < 2; ++a) {
            let s2 = typeof n2[a] == "string" ? G2(n2[a]) : n2[a];
            if (!s2 || !["rgb", "rgba"].includes(s2.type))
              return;
            o2.push(s2);
          }
          let i = [];
          for (let a = 0; a < 3; ++a)
            i.push(ts(o2[0].components[a], o2[1].components[a], r2));
          return {
            type: "rgb",
            components: i,
            alpha: ts(o2[0].alpha ?? 1, o2[1].alpha ?? 1, r2)
          };
        }
        function ns(e2, t2) {
          return rs("#fff", e2, t2);
        }
        function os(e2, t2) {
          return rs("#000", e2, t2);
        }
        function Vl(e2, t2) {
          let r2 = Number.parseFloat(`${t2}`);
          if (!Number.isNaN(r2))
            return r2 > 0 ? os(e2, t2) : ns(e2, -r2);
        }
        var _l = { tint: ns, shade: os, shift: Vl };
        function is() {
          let e2;
          return {
            name: "mix",
            match(t2, r2) {
              e2 || (e2 = new RegExp(
                `^mix-(tint|shade|shift)-(-?\\d{1,3})(?:${r2.generator.config.separators.join("|")})`
              ));
              let n2 = t2.match(e2);
              if (n2)
                return {
                  matcher: t2.slice(n2[0].length),
                  body: (o2) => (o2.forEach((i) => {
                    if (i[1]) {
                      let a = G2(`${i[1]}`);
                      if (a) {
                        let s2 = _l[n2[1]](a, n2[2]);
                        s2 && (i[1] = A(s2));
                      }
                    }
                  }), o2)
                };
            }
          };
        }
        var Pl = (e2 = {}) => {
          let t2 = es(e2);
          return {
            ...t2,
            name: "@unocss/preset-uno",
            variants: [...t2.variants, is()]
          };
        }, as = Pl;
        var bn = /^(?!.*\[(?:[^:]+):(?:.+)\]$)((?:.+:)?!?)?(.*)$/;
        function ss(e2 = {}) {
          let t2 = e2.prefix ?? "un-", r2 = e2.prefixedOnly ?? false, n2 = e2.trueToNonValued ?? false, o2;
          return {
            name: "attributify",
            match(i, { generator: a }) {
              var _a3, _b;
              let s2 = Cn(i);
              if (!s2)
                return;
              let c = s2[1];
              if (c.startsWith(t2))
                c = c.slice(t2.length);
              else if (r2)
                return;
              let f = s2[2], [, u = "", p2 = f] = f.match(bn) || [];
              if (p2 === "~" || n2 && p2 === "true" || !p2)
                return `${u}${c}`;
              if (o2 == null) {
                let d = (_b = (_a3 = a == null ? void 0 : a.config) == null ? void 0 : _a3.separators) == null ? void 0 : _b.join("|");
                d ? o2 = new RegExp(`^(.*\\](?:${d}))(\\[[^\\]]+?\\])$`) : o2 = false;
              }
              if (o2) {
                let [, d, h2] = f.match(o2) || [];
                if (h2)
                  return `${d}${u}${c}-${h2}`;
              }
              return `${u}${c}-${p2}`;
            }
          };
        }
        var Ml = /(<\w[\w:\.$-]*\s)((?:'[^>]*?'|"[^>]*?"|`[^>]*?`|\{[^>]*?\}|[^>]*?)*)/g, Fl = /([?]|(?!\d|-{2}|-\d)[a-zA-Z0-9\u00A0-\uFFFF-_:%-]+)(?:=("[^"]*|'[^']*))?/g, cs = /[\s'"`;>]+/;
        function ls(e2) {
          return {
            name: "attributify",
            extract: ({ content: t2, cursor: r2 }) => {
              let n2 = t2.matchAll(Ml), o2, i = 0;
              for (let b of n2) {
                let [, R2, m] = b, w = b.index + R2.length;
                if (r2 > w && r2 <= w + m.length) {
                  i = w, o2 = m;
                  break;
                }
              }
              if (!o2)
                return null;
              let a = o2.matchAll(Fl), s2 = 0, c, f;
              for (let b of a) {
                let [R2, m, w] = b, z = i + b.index;
                if (r2 > z && r2 <= z + R2.length) {
                  s2 = z, c = m, f = w == null ? void 0 : w.slice(1);
                  break;
                }
              }
              if (!c || c === "class" || c === "className" || c === ":class")
                return null;
              let u = !!(e2 == null ? void 0 : e2.prefix) && c.startsWith(e2.prefix);
              if ((e2 == null ? void 0 : e2.prefixedOnly) && !u)
                return null;
              let p2 = u ? c.slice(e2.prefix.length) : c;
              if (f === void 0)
                return {
                  extracted: p2,
                  resolveReplacement(b) {
                    let R2 = u ? e2.prefix.length : 0;
                    return { start: s2 + R2, end: s2 + c.length, replacement: b };
                  }
                };
              let d = s2 + c.length + 2, h2 = cs.exec(f), x = 0, $2;
              for (; h2; ) {
                let [b] = h2;
                if (r2 > d + x && r2 <= d + x + h2.index) {
                  $2 = f.slice(x, x + h2.index);
                  break;
                }
                x += h2.index + b.length, h2 = cs.exec(f.slice(x));
              }
              $2 === void 0 && ($2 = f.slice(x));
              let [, y = "", C2] = $2.match(bn) || [];
              return {
                extracted: `${y}${p2}-${C2}`,
                transformSuggestions(b) {
                  return b.filter((R2) => R2.startsWith(`${y}${p2}-`)).map((R2) => y + R2.slice(y.length + p2.length + 1));
                },
                resolveReplacement(b) {
                  return {
                    start: x + d,
                    end: x + d + $2.length,
                    replacement: y + b.slice(y.length + p2.length + 1)
                  };
                }
              };
            }
          };
        }
        var Ul = ["v-bind:", ":"], fs = /[\s'"`;]+/g, xn = /<[^>\s]*\s((?:'.*?'|".*?"|`.*?`|\{.*?\}|[^>]*?)*)/g, Ll = /([?]|(?!\d|-{2}|-\d)[a-zA-Z0-9\u00A0-\uFFFF-_:!%-.~<]+)=?(?:["]([^"]*)["]|[']([^']*)[']|[{]([^}]*)[}])?/gms, yn2 = ["placeholder", "fill", "opacity", "stroke-opacity"];
        function us(e2) {
          let t2 = (e2 == null ? void 0 : e2.ignoreAttributes) ?? yn2, r2 = (e2 == null ? void 0 : e2.nonValuedAttribute) ?? true, n2 = (e2 == null ? void 0 : e2.trueToNonValued) ?? false;
          return {
            name: "@unocss/preset-attributify/extractor",
            extract({ code: o2 }) {
              return Array.from(o2.matchAll(xn)).flatMap((i) => Array.from((i[1] || "").matchAll(Ll))).flatMap(([, i, ...a]) => {
                let s2 = a.filter(Boolean).join("");
                if (t2.includes(i))
                  return [];
                for (let c of Ul)
                  if (i.startsWith(c)) {
                    i = i.slice(c.length);
                    break;
                  }
                if (!s2) {
                  if (Oe(i) && r2 !== false) {
                    let c = [`[${i}=""]`];
                    return n2 && c.push(`[${i}="true"]`), c;
                  }
                  return [];
                }
                return ["class", "className"].includes(i) ? s2.split(fs).filter(Oe) : xn.test(s2) ? (xn.lastIndex = 0, this.extract({ code: s2 })) : (e2 == null ? void 0 : e2.prefixedOnly) && e2.prefix && !i.startsWith(e2.prefix) ? [] : s2.split(fs).filter((c) => !!c && c !== ":").map((c) => `[${i}~="${c}"]`);
              });
            }
          };
        }
        var Wl = (e2 = {}) => {
          e2.strict = e2.strict ?? false, e2.prefix = e2.prefix ?? "un-", e2.prefixedOnly = e2.prefixedOnly ?? false, e2.nonValuedAttribute = e2.nonValuedAttribute ?? true, e2.ignoreAttributes = e2.ignoreAttributes ?? yn2;
          let t2 = [ss(e2)], r2 = [us(e2)], n2 = [ls(e2)];
          return {
            name: "@unocss/preset-attributify",
            enforce: "post",
            variants: t2,
            extractors: r2,
            options: e2,
            autocomplete: { extractors: n2 },
            extractorDefault: e2.strict ? false : void 0
          };
        }, ps = Wl;
        function Nl(e2) {
          return e2.replace(/-(\w)/g, (t2, r2) => r2 ? r2.toUpperCase() : "");
        }
        function ds(e2) {
          return e2.charAt(0).toUpperCase() + e2.slice(1);
        }
        function ms(e2) {
          return e2.replace(/(?:^|\B)([A-Z])/g, "-$1").toLowerCase();
        }
        var hs = ["Webkit", "Moz", "ms"];
        function gs(e2) {
          let t2 = {};
          function r2(n2) {
            let o2 = t2[n2];
            if (o2)
              return o2;
            let i = Nl(n2);
            if (i !== "filter" && i in e2)
              return t2[n2] = ms(i);
            i = ds(i);
            for (let a = 0; a < hs.length; a++) {
              let s2 = `${hs[a]}${i}`;
              if (s2 in e2)
                return t2[n2] = ms(ds(s2));
            }
            return n2;
          }
          return ({ entries: n2 }) => n2.forEach((o2) => {
            o2[0].startsWith("--") || (o2[0] = r2(o2[0]));
          });
        }
        function bs(e2) {
          return e2.replace(/&amp;/g, "&").replace(/&gt;/g, ">").replace(/&lt;/g, "<");
        }
        function vn(e2 = {}) {
          var _a3, _b, _c2;
          if (typeof window > "u") {
            console.warn(
              "@unocss/runtime been used in non-browser environment, skipped."
            );
            return;
          }
          let t2 = window, r2 = window.document, n2 = () => r2.documentElement, o2 = t2.__unocss || {}, i = Object.assign({}, e2, o2.runtime), a = i.defaults || {}, s2 = i.cloakAttribute ?? "un-cloak";
          i.autoPrefix && (a.postprocess = _2(a.postprocess)).unshift(
            gs(r2.createElement("div").style)
          ), (_a3 = i.configResolved) == null ? void 0 : _a3.call(i, o2, a);
          let c = Un(o2, a), f = (g) => i.inject ? i.inject(g) : n2().prepend(g), u = () => i.rootElement ? i.rootElement() : r2.body, p2 = /* @__PURE__ */ new Map(), d = true, h2 = /* @__PURE__ */ new Set(), x, $2, y = [], C2 = () => new Promise((g) => {
            y.push(g), $2 != null && clearTimeout($2), $2 = setTimeout(
              () => m().then(() => {
                let k = y;
                y = [], k.forEach((E2) => E2());
              }),
              0
            );
          });
          function b(g) {
            if (g.nodeType !== 1)
              return;
            let k = g;
            k.hasAttribute(s2) && k.removeAttribute(s2), k.querySelectorAll(`[${s2}]`).forEach((E2) => {
              E2.removeAttribute(s2);
            });
          }
          function R2(g, k) {
            let E2 = p2.get(g);
            if (!E2)
              if (E2 = r2.createElement("style"), E2.setAttribute("data-unocss-runtime-layer", g), p2.set(g, E2), k == null)
                f(E2);
              else {
                let B2 = R2(k), K2 = B2.parentNode;
                K2 ? K2.insertBefore(E2, B2.nextSibling) : f(E2);
              }
            return E2;
          }
          async function m() {
            let g = await c.generate(h2);
            return g.layers.reduce(
              (k, E2) => (R2(E2, k).innerHTML = g.getLayer(E2) ?? "", E2),
              void 0
            ), h2 = g.matched, { ...g, getStyleElement: (k) => p2.get(k), getStyleElements: () => p2 };
          }
          async function w(g) {
            let k = h2.size;
            await c.applyExtractors(g, void 0, h2), k !== h2.size && await C2();
          }
          async function z(g = u()) {
            let k = g && g.outerHTML;
            k && (await w(`${k} ${bs(k)}`), b(n2()), b(g));
          }
          let W2 = new MutationObserver((g) => {
            d || g.forEach(async (k) => {
              if (k.target.nodeType !== 1)
                return;
              let E2 = k.target;
              for (let B2 of p2)
                if (E2 === B2[1])
                  return;
              if (k.type === "childList")
                k.addedNodes.forEach(async (B2) => {
                  if (B2.nodeType !== 1)
                    return;
                  let K2 = B2;
                  x && !x(K2) || (await w(K2.outerHTML), b(K2));
                });
              else {
                if (x && !x(E2))
                  return;
                if (k.attributeName !== s2) {
                  let B2 = Array.from(E2.attributes).map((D) => D.value ? `${D.name}="${D.value}"` : D.name).join(" "), K2 = `<${E2.tagName.toLowerCase()} ${B2}>`;
                  await w(K2);
                }
                E2.hasAttribute(s2) && E2.removeAttribute(s2);
              }
            });
          }), N2 = false;
          function ce2() {
            var _a4, _b2;
            if (N2)
              return;
            let g = ((_a4 = i.observer) == null ? void 0 : _a4.target) ? i.observer.target() : u();
            g && (W2.observe(g, {
              childList: true,
              subtree: true,
              attributes: true,
              attributeFilter: (_b2 = i.observer) == null ? void 0 : _b2.attributeFilter
            }), N2 = true);
          }
          function ge2() {
            i.bypassDefined && Bl(c.blocked), z(), ce2();
          }
          function je2() {
            r2.readyState === "loading" ? t2.addEventListener("DOMContentLoaded", ge2) : ge2();
          }
          let Xe2 = t2.__unocss_runtime = t2.__unocss_runtime = {
            version: c.version,
            uno: c,
            async extract(g) {
              O(g) || (g.forEach((k) => h2.add(k)), g = ""), await w(g);
            },
            extractAll: z,
            inspect(g) {
              x = g;
            },
            toggleObserver(g) {
              g === void 0 ? d = !d : d = !!g, !N2 && !d && je2();
            },
            update: m,
            presets: ((_b = t2.__unocss_runtime) == null ? void 0 : _b.presets) ?? {}
          };
          ((_c2 = i.ready) == null ? void 0 : _c2.call(i, Xe2)) !== false && (d = false, je2());
        }
        function Bl(e2 = /* @__PURE__ */ new Set()) {
          for (let t2 = 0; t2 < document.styleSheets.length; t2++) {
            let r2 = document.styleSheets[t2], n2;
            try {
              if (n2 = r2.cssRules || r2.rules, !n2)
                continue;
              Array.from(n2).flatMap((o2) => {
                var _a3;
                return ((_a3 = o2.selectorText) == null ? void 0 : _a3.split(/,/g)) || [];
              }).forEach((o2) => {
                o2 && (o2 = o2.trim(), o2.startsWith(".") && (o2 = o2.slice(1)), e2.add(o2));
              });
            } catch {
              continue;
            }
          }
          return e2;
        }
        vn({ defaults: { presets: [as(), ps()] } });
      })();
      const tokenKey = getTokenKey();
      _GM_addStyle(
        "@import url('https://cdn.bootcdn.net/ajax/libs/element-plus/2.5.0/index.min.css');"
      );
      if (location.origin === "https://186admin.nps.doveaz.xyz:1443") {
        if (_GM_getValue("getToken")) {
          const getTokenSuccess = (token) => {
            setToken(token);
            _GM_deleteValue("getToken");
            ElMessageBox.confirm("获取授权成功", "提示", {
              type: "success",
              confirmButtonText: "返回",
              cancelButtonText: "关闭弹窗"
            }).then(() => {
              window.close();
            });
          };
          if (_GM_getValue("getToken")) {
            let data = localStorage.getItem(tokenKey);
            data = decrypt(data);
            const token = JSON.parse(data).value.TOKEN__.value;
            if (token) {
              getTokenSuccess(token);
            } else {
              const interval = setInterval(() => {
                let data2 = localStorage.getItem(tokenKey);
                data2 = decrypt(data2);
                const token2 = JSON.parse(data2).value.TOKEN__.value;
                if (token2) {
                  getTokenSuccess(token2);
                  clearInterval(interval);
                }
              }, 1e3);
            }
          }
        }
      } else {
        const app = createApp(_sfc_main);
        const dom = document.createElement("div");
        document.body.append(dom);
        app.mount(dom);
      }
    }
  });
  require_main_001();

})();