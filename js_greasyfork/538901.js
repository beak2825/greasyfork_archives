// ==UserScript==
// @name         idlepoe战斗分析
// @namespace
// @version      1.301
// @description  点击按钮打开模态框 只能分析统计中获取的数据  切换角色, 刷新页面会丢失数据(或者你想清理数据就可以这么做)
// @description 目前功能
// @description 1. 战斗失败日志 回放最后一幕
// @description 2. 人物使用技能统计,伤害, 次数, dps
// @description 3. 玩家受到伤害统计
// @description 4. 遇怪分析, 怪物血量,护盾, 战斗时长等
// @description 5. 增益减益统计
// @author       群友
// @run-at       document-idle
// @match        *://*.idlepoe.com/*
// @match        *://idlepoe.com/*
// @match        *://poe.faith.wang/*
// @icon         https://www.google.com/s2/favicons?domain=idlepoe.com
// @grant        unsafeWindow
// @license      MIT
// @namespace https://idlepoe.com
// @downloadURL https://update.greasyfork.org/scripts/538901/idlepoe%E6%88%98%E6%96%97%E5%88%86%E6%9E%90.user.js
// @updateURL https://update.greasyfork.org/scripts/538901/idlepoe%E6%88%98%E6%96%97%E5%88%86%E6%9E%90.meta.js
// ==/UserScript==



(async function() {
    'use strict';
    //获取 当前玩家token
    const token = localStorage.getItem("token");
    const classEmojis = {
        2: "👑",
        3: "🪄",
        4: "🏹",
        7: "🗡️",
        1: "🪓",
        5: "⚔️",
        6: "🛡️"
    };``
    let playerClassEmj = "🦸‍♂️"; // 默认 emoji
    let playerId = "xxx"; // 应该会读取真正的id
    const playerInfoUrl = "https://poe.faith.wang/api/character";

    //高级控制和其他功能相关
    let printNextDetail = false;
    let dragMode = false;
    let dragPostitionLeft = localStorage.getItem("combatPlugin_dragPostitionLeft")??"210px";
    let dragPostitionTop = localStorage.getItem("combatPlugin_dragPostitionTop")??"70px";
    let firstSkillMode = 0;//默认0无特殊处理, 1只统计首次技能 -1不统计首次技能
    let magicAvgMode = Number(localStorage.getItem("combatPlugin_magicAvgMode"))??1;//默认1显示平均值,无buff不会影响平均值 0平均值*覆盖率, 即显示有效平均值,

    //魔法效果
    const MAGIC_TYPE = {
        "0": "（无效）未知词缀",
        "1": "物理伤害提高%",
        "2": "该装备的能量护盾提高%",
        "3": "晕眩回复和格挡回复提高%",
        "4": "属性需求降低%",
        "5": "每击败一名敌人获得魔力",
        "6": "照亮范围扩大%",
        "7": "命中值",
        "8": "全属性",
        "9": "攻击技能的元素伤害提高%",
        "10": "物理攻击伤害转化为生命偷取%",
        "11": "物理攻击伤害转化为魔力偷取%",
        "12": "力量",
        "13": "敏捷",
        "14": "智慧",
        "15": "攻击速度%",
        "16": "敌人晕眩门槛降低%",
        "17": "火焰抗性%",
        "18": "冰霜抗性%",
        "19": "闪电抗性%",
        "20": "混沌抗性%",
        "21": "敌人被晕眩时间延长%",
        "22": "每击中一名敌人获得生命",
        "23": "每击败一名敌人获得生命",
        "24": "每击中一名敌人获得魔力",
        "25": "该装备的攻击暴击率提高%",
        "26": "全域暴击伤害加成%",
        "27": "命中值提高%",
        "28": "击中时有几率使目标中毒%",
        "29": "击中时有几率使目标流血%",
        "30": "中毒伤害提高%",
        "31": "流血伤害提高%",
        "32": "有几率造成瘫痪%",
        "33": "该武器击中后造成的物理伤害转换为一种随机元素伤害%",
        "34": "全域暴击率%",
        "35": "攻击伤害格挡率%",
        "36": "用该武器击中时，所有伤害都导致中毒",
        "37": "法术伤害提高%",
        "38": "攻击和法术附加基础火焰伤害",
        "39": "攻击和法术附加基础冰霜伤害",
        "40": "攻击和法术附加基础闪电伤害",
        "41": "攻击和法术附加基础混沌伤害",
        "42": "施法速度%",
        "43": "每 6 秒获得一个耐力球、狂怒球或暴击球",
        "44": "召唤生物的伤害提高%",
        "45": "全局物理伤害提高%",
        "46": "最大怒火",
        "47": "使用该武器近战击中时触发",
        "48": "元素伤害提高%",
        "49": "伤害穿透元素抗性%",
        "50": "元素超载",
        "51": "元素之相",
        "52": "苦难秘辛",
        "53": "你使用插入的技能时触发",
        "54": "移动速度%",
        "55": "持长杖时攻击伤害格挡几率%",
        "56": "施放插入的技能时，在消耗魔力前先消耗能量护盾",
        "57": "最大能量护盾",
        "58": "力量和敏捷",
        "59": "暴击攻击无视敌人的元素抗性",
        "60": "流血持续伤害加成%",
        "61": "最大品质%",
        "62": "效果区域扩大%",
        "63": "范围伤害提高%",
        "64": "有几率造成双倍伤害%",
        "65": "有几率使晕眩时间延长 1 倍%",
        "66": "战吼增助额外攻击",
        "67": "力量提高%",
        "68": "暴击球和耐力球上限",
        "69": "插槽数量",
        "70": "攻击附加基础物理伤害",
        "71": "攻击附加基础火焰伤害",
        "72": "攻击附加基础冰霜伤害",
        "73": "攻击附加基础闪电伤害",
        "74": "攻击附加基础混沌伤害",
        "75": "你的攻击击中每个敌人会回复生命",
        "76": "投射物速度加快%",
        "77": "箭矢会穿透额外目标",
        "78": "攻击附加基础物理伤害",
        "79": "攻击附加基础火焰伤害",
        "80": "攻击附加基础冰霜伤害",
        "81": "攻击附加基础闪电伤害",
        "82": "攻击附加基础混沌伤害",
        "83": "弓类攻击的暴击率提高%",
        "84": "获得额外混沌伤害，其数值等同于物理伤害的%",
        "85": "图腾放置速度加快%",
        "86": "弓类攻击附加点物理伤害",
        "87": "最大生命",
        "88": "你格挡敌人的伤害时烧灼敌人",
        "89": "你格挡敌人的伤害时，给它们施加易碎",
        "90": "你格挡敌人的伤害时使它们力竭",
        "91": "格挡回复提高%",
        "92": "所有元素抗性%",
        "93": "法术伤害压制率%",
        "94": "混沌抗性%",
        "95": "增助攻击的伤害提高%",
        "96": "战吼技能冷却时间",
        "97": "主手攻击伤害%",
        "98": "副手攻击伤害%",
        "99": "魔力上限%",
        "100": "你施放技能时有几率得到等于其花费的魔力%",
        "101": "近战伤害提高%",
        "102": "投射物攻击伤害提高%",
        "103": "持续伤害提高%",
        "104": "被格挡的攻击对你造成伤害%",
        "105": "每点命中值都附加攻击闪电伤害",
        "106": "总命中值提升%",
        "107": "位移技能的的冷却恢复速度加快%",
        "108": "冰霜与闪电抗性提高%",
        "109": "火焰与冰霜抗性提高%",
        "110": "火焰与闪电抗性提高%",
        "111": "最大魔力",
        "112": "所有瓦尔主动技能石等级",
        "113": "额外物理伤害减免%",
        "114": "你被碾压了",
        "115": "护身上限",
        "116": "插入的技能击中时施加火焰、冰霜、闪电曝露效果",
        "117": "附加基础冰霜伤害",
        "118": "附加基础闪电伤害",
        "119": "附加基础混沌伤害",
        "120": "附加基础火焰伤害",
        "121": "你的击中将冰霜抗性视为比实际高%",
        "122": "魔力再生率提高%",
        "123": "生命每秒再生",
        "124": "物品稀有度提高%",
        "125": "敏捷与智慧",
        "126": "力量与智慧",
        "127": "基底词缀不能改变",
        "128": "具有裂界者、塑界者和所有征服者影响效果",
        "129": "允许的前缀",
        "130": "允许的后缀",
        "131": "外延词缀幅度提高%",
        "132": "能量护盾充能时间提前%",
        "133": "火焰伤害提高%",
        "134": "冰霜伤害提高%",
        "135": "闪电伤害提高%",
        "136": "混沌伤害提高%",
        "137": "数量上限",
        "138": "攻击与施法速度加快%",
        "139": "生命每秒再生%",
        "140": "的几率使敌人受到冰冻，感电与点燃%",
        "141": "全局防御提高%",
        "142": "受到击中火焰伤害转为冰霜伤害%",
        "143": "受到击中火焰伤害转为闪电伤害%",
        "144": "受到击中冰霜伤害转为火焰伤害%",
        "145": "受到击中冰霜伤害转为闪电伤害%",
        "146": "受到击中闪电伤害转为冰霜伤害%",
        "147": "受到击中闪电伤害转为火焰伤害%",
        "148": "生命上限%",
        "149": "投射物会穿透额外目标",
        "150": "物品掉落数量提高%",
        "151": "伤害%",
        "152": "击败敌人时有几率获得一个暴击球%",
        "153": "击败敌人时有几率获得一个狂怒球%",
        "154": "击败敌人有几率时获得耐力球%",
        "155": "获得等同物理伤害的随机元素伤害%",
        "156": "攻击伤害提高%",
        "157": "所有属性提高%",
        "158": "召唤生物获得元素抗性%",
        "159": "左边的戒指栏位：技能效果的持续时间%",
        "160": "右边的戒指栏位：技能效果的持续时间%",
        "161": "左边的戒指栏位：你受到的诅咒效果%",
        "162": "右边的戒指栏位：你受到的诅咒效果%",
        "163": "左边的戒指栏位：召唤生物受到的伤害%",
        "164": "右边的戒指栏位：召唤生物受到的伤害%",
        "165": "左边的戒指栏位：你处于异常状态的时间%",
        "166": "右边的戒指栏位：你处于异常状态的时间%",
        "167": "左边的戒指栏位：受到的冰霜伤害转化为火焰伤害%",
        "168": "右边的戒指栏位：受到的火焰伤害转化为冰霜伤害%",
        "169": "左边的戒指栏位：受到的火焰伤害转化为闪电伤害%",
        "170": "右边的戒指栏位：受到的闪电伤害转化为火焰伤害%",
        "171": "左边的戒指栏位：受到的闪电伤害转化为冰霜伤害%",
        "172": "右边的戒指栏位：受到的冰霜伤害转化为闪电伤害%",
        "173": "属性在裂隙内得到加倍",
        "174": "物理伤害提高",
        "175": "该装备的护甲提高%",
        "176": "护甲提高",
        "177": "对较近的目标造成的击中伤害提高最多%",
        "178": "被辅助的近战攻击技能可额外重复次",
        "179": "被辅助技能的总近战攻击速度总增%",
        "180": "的几率点燃敌人%",
        "181": "发射额外投射物",
        "182": "冰缓敌人如同伤害总增%",
        "183": "物理伤害转化为冰霜伤害%",
        "184": "冰霜异常状态效果提高%",
        "185": "击中敌人时召唤幻影弓手",
        "186": "机率迴避攻击%",
        "187": "护甲提高%",
        "188": "附加物理傷害的火焰傷害%",
        "189": "附加物理傷害的冰冷傷害%",
        "190": "闪避值%",
        "191": "反射伤害给近战攻击者",
        "192": "物理伤害在使用双手武器时提高%",
        "193": "双手近战武器攻击造成的异常状态伤害提高%",
        "194": "双手近战武器攻击的攻击速度提高%",
        "195": "物理伤害在使用单手武器时提高%",
        "196": "单手近战武器攻击造成的异常状态伤害提高%",
        "197": "单手近战武器攻击的攻击速度提高%",
        "198": "火焰抗性上限提高%",
        "199": "持续伤害加成%",
        "200": "该装备上的技能石等级",
        "201": "此物品上装备的【近战技能石】等级",
        "202": "混沌持续伤害加成%",
        "203": "所有法术主动技能石等级",
        "204": "法术附加基础火焰伤害",
        "205": "法术附加基础闪电伤害",
        "206": "法术附加基础冰霜伤害",
        "207": "施法速度%",
        "208": "法术暴击率提高%",
        "209": "有几率造成冻结状态%",
        "210": "闪电伤害击中时有几率使敌人受到感电效果影响%",
        "211": "燃烧伤害提高%",
        "212": "弓类攻击发射额外箭矢",
        "213": "闪避值",
        "214": "将所受伤害吸纳为生命%",
        "215": "弓类技能伤害提高%",
        "216": "弓类攻击暴击伤害加成%",
        "217": "攻击技能的持续伤害加成%",
        "218": "生命再生率提高%",
        "219": "能量护盾充能率提高%",
        "220": "该装备的护甲与闪避提高%",
        "221": "该装备的护甲与能量护盾提高%",
        "222": "该装备的闪避与能量护盾提高%",
        "223": "该装备的护甲、闪避和能量护盾提高%",
        "224": "该装备攻击格挡率%",
        "225": "生命回复你格挡时",
        "226": "几率避免元素异常状态%",
        "227": "受到的暴击伤害降低%",
        "228": "冰霜抗性上限提高%",
        "229": "闪电抗性上限提高%",
        "230": "混沌抗性上限提高%",
        "231": "全部抗性上限提高%",
        "232": "法术伤害格挡几率%",
        "233": "将物理伤害转化为火焰伤害%",
        "234": "近战攻击的物理伤害总增%",
        "235": "近战击中造成的流血和中毒伤害总增%",
        "236": "额外获得物理伤害，并转化为火焰伤害%",
        "237": "无法被冰冻",
        "238": "最多可以击中目标周围的额外敌人",
        "239": "感电敌人如同伤害总增%",
        "240": "攻击伤害%",
        "241": "第一个重复的被辅助技能造成的伤害总增%",
        "242": "第二个重复的被辅助技能造成的伤害总增%",
        "243": "连锁弹射次",
        "244": "每剩 1 次连锁弹射，伤害总增%",
        "245": "的几率使敌人感电%",
        "246": "闪电异常状态效果提高%",
        "247": "提高暴击率%",
        "248": "该装备物理伤害提高%",
        "249": "伤害会转化为生命偷取%",
        "250": "若该近战攻击没有失手，则后续的闪电投射物无法被躲避",
        "251": "获得物理伤害，并转化为冰霜伤害%",
        "252": "冰霜伤害总增%",
        "253": "物理伤害转换为闪电伤害%",
        "254": "召唤使用一个使用该技能的图腾",
        "255": "当图腾存在时，玩家攻击速度总增%",
        "256": "该装备的闪避率提高%",
        "257": "该装备附加基础物理伤害",
        "258": "受到伤害增加%",
        "259": "伤害穿透闪电抗性%",
        "260": "被你感电的敌人速度减慢%",
        "261": "用该武器击中时使敌人感电，如同伤害总增%",
        "262": "没有插槽",
        "263": "闪电伤害转化为混沌伤害%",
        "264": "混沌伤害可以造成感电",
        "265": "最大感电效果%",
        "266": "近战伤害对流血的敌人提高%",
        "267": "暴击时有几率致盲敌人%",
        "268": "暴击无法吸血",
        "269": "暴击时有几率造成流血%",
        "270": "你的击中无法被闪避",
        "271": "反击附加基础冰霜伤害",
        "272": "伤害总增%",
        "273": "法术可重复次",
        "274": "施法速度%",
        "275": "击中受到的伤害在生命和能量护盾承受之前，优先由该增益效果承受%",
        "276": "该增益效果能承受伤害",
        "277": "攻击造成的物理伤害提高%",
        "278": "攻击技能的异常状态伤害提高%",
        "279": "投射物伤害提高%",
        "280": "能量护盾上限%",
        "281": "对流血敌人附加基础物理伤害",
        "282": "连续攻击次",
        "283": "技能宝石等级提高",
        "284": "击中生命小于的敌人时，会将其秒杀%",
        "285": "投射物可重复击中相同目标",
        "286": "近战攻击速度提高%",
        "287": "技能的保留效能%",
        "288": "法术伤害的暴击伤害加成%",
        "289": "技能的魔力保留效能%",
        "290": "弓类攻击的攻击速度加快%",
        "291": "弓类攻击的命中值提高%",
        "292": "弓类技能的持续伤害效果提高%",
        "293": "法术技能的闪电伤害总增%",
        "294": "消耗及保留加成%",
        "295": "物理伤害总增%",
        "296": "无法造成混沌伤害",
        "297": "无法造成元素伤害",
        "298": "近战物理伤害提高%",
        "299": "法术伤害转化为能量护盾偷取%",
        "300": "的几率使敌人受到冰冻、感电和点燃%",
        "301": "近战武器攻击造成的异常状态伤害提高%",
        "302": "近战攻击暴击率提高%",
        "303": "近战攻击暴击伤害加成%",
        "304": "发射额外箭矢",
        "305": "法术伤害总增%",
        "306": "非召唤生物有几率在击中稀有或传奇敌人时，造成奉献地面%",
        "307": "持盾牌时施法速度加快%",
        "308": "法术伤害在持盾牌时提高%",
        "309": "你技能的非诅咒类光环效果提高%",
        "310": "剑类攻击暴击伤害加成%",
        "311": "剑类攻击的暴击率提高%",
        "312": "斧类物理伤害提高%",
        "313": "斧类攻击造成的异常状态伤害提高%",
        "314": "斧类攻击的攻击速度加快%",
        "315": "剑类攻击的命中值提高%",
        "316": "剑类攻击的攻击速度加快%",
        "317": "剑类物理伤害提高%",
        "318": "斧类攻击的暴击率提高%",
        "319": "斧类攻击暴击伤害加成%",
        "320": "剑类攻击造成的异常状态伤害提高%",
        "321": "剑类攻击造成的击中和异常状态伤害提高%",
        "322": "斧类攻击造成的击中和异常状态伤害提高%",
        "323": "剑类攻击命中值",
        "324": "锤类或短杖攻击的攻击速度加快%",
        "325": "锤类或短杖物理伤害提高%",
        "326": "锤类或短杖攻击造成的异常状态伤害提高%",
        "327": "锤类或短杖攻击造成的击中和异常状态伤害提高%",
        "328": "锤类或短杖攻击的暴击率提高%",
        "329": "锤类或短杖攻击暴击伤害加成%",
        "330": "锤类或短杖攻击命中值",
        "331": "锤类或短杖的命中值提高%",
        "332": "锤类或短杖的元素伤害提高%",
        "333": "长杖攻击造成的击中和异常状态伤害提高%",
        "334": "持长杖时全域暴击伤害加成%",
        "335": "持长杖时，暴击率提高%",
        "336": "长杖攻击的暴击率提高%",
        "337": "持长杖时攻击伤害格挡几率%",
        "338": "持长杖时法术伤害格挡几率%",
        "339": "反射冰霜伤害给近战攻击者",
        "340": "长杖攻击的元素伤害提高%",
        "341": "长杖攻击的命中值提高%",
        "342": "长杖攻击暴击伤害加成%",
        "343": "持长杖时攻击速度加快%",
        "344": "持长杖时施法速度加快%",
        "345": "法杖攻击的元素伤害提高%",
        "346": "持法杖时攻击速度加快%",
        "347": "法杖攻击的命中值提高%",
        "348": "法杖物理伤害提高%",
        "349": "法杖攻击造成的异常状态伤害提高%",
        "350": "伤害在持法杖时提高%",
        "351": "法杖攻击的暴击率提高%",
        "352": "法杖攻击暴击伤害加成%",
        "353": "法杖攻击造成的击中和异常状态伤害提高%",
        "354": "获得额外闪电伤害，数值等同于法杖物理伤害的%",
        "355": "持匕首时攻击速度加快%",
        "356": "匕首攻击的命中值提高%",
        "357": "匕首攻击的暴击率提高%",
        "358": "匕首攻击暴击伤害加成%",
        "359": "匕首攻击造成的击中和异常状态伤害提高%",
        "360": "匕首攻击造成的异常状态伤害提高%",
        "361": "匕首攻击的暴击使敌人中毒",
        "362": "爪类攻击速度加快%",
        "363": "爪类攻击的暴击率提高%",
        "364": "爪类攻击暴击伤害加成%",
        "365": "爪类攻击造成的异常状态伤害提高%",
        "366": "爪类攻击造成的击中和异常状态伤害提高%",
        "367": "爪类攻击的命中值提高%",
        "368": "持盾牌时攻击造成的物理伤害提高%",
        "369": "持盾牌时，攻击造成的异常状态伤害提高%",
        "370": "从盾牌获取的防御提高%",
        "371": "持盾牌时攻击格挡率%",
        "372": "持盾牌时造成的攻击伤害提高%",
        "373": "持盾牌时攻击速度加快%",
        "374": "持盾牌时元素抗性%",
        "375": "持盾牌时有几率格挡法术伤害%",
        "376": "从盾牌获取的能量护盾提高%",
        "377": "双手近战武器的攻击暴击率提高%",
        "378": "双手近战武器的攻击暴击伤害加成%",
        "379": "双手近战武器的攻击命中值提高%",
        "380": "双手近战武器的攻击速度加快%",
        "381": "双手近战武器攻击造成的击中和异常状态伤害提高%",
        "382": "单手近战武器的攻击速度加快%",
        "383": "单手武器的攻击伤害提高%",
        "384": "单手武器攻击造成的异常状态伤害提高%",
        "385": "单手武器的攻击速度加快%",
        "386": "双持攻击的攻击速度加快%",
        "387": "双持攻击的命中值提高%",
        "388": "双持武器时，攻击技能的伤害提高%",
        "389": "双持时攻击伤害格挡率%",
        "390": "双持时，攻击技能造成的异常状态伤害提高%",
        "391": "双持时施法速度加快%",
        "392": "法术伤害在双持武器时提高%",
        "393": "移动速度在双持武器时加快%",
        "394": "双持时法术伤害格挡率%",
        "395": "双持武器时，攻击暴击率提高%",
        "396": "双持武器时，攻击暴击伤害加成%",
        "397": "物理持续伤害加成%",
        "398": "火焰持续伤害加成%",
        "399": "中毒持续伤害加成%",
        "400": "伤害型异常状态生效速度加快%",
        "401": "攻击技能的持续火焰伤害加成%",
        "402": "暴击造成异常状态时，持续伤害加成%",
        "403": "你造成的点燃的伤害生效速度加快%",
        "404": "闪电异常状态持续时间延长%",
        "405": "闪电技能暴击伤害加成%",
        "406": "对感电目标的暴击率提高%",
        "407": "该装备的攻击速度提高%",
        "408": "技能效果持续时间%",
        "409": "持续性伤害总增%",
        "410": "攻击技能的元素伤害总增%",
        "411": "穿透元素抗性%",
        "412": "伤害穿透火焰抗性%",
        "413": "伤害穿透冰霜抗性%",
        "414": "伤害穿透闪电抗性%",
        "415": "伤害穿透混沌抗性%",
        "416": "武器造成的伤害穿透元素抗性%",
        "417": "攻击伤害穿透元素抗性%",
        "418": "武器造成的伤害穿透冰霜抗性%",
        "419": "武器造成的伤害穿透闪电抗性%",
        "420": "武器造成的伤害穿透混沌抗性%",
        "421": "武器造成的伤害穿透火焰抗性%",
        "422": "攻击技能的冰霜伤害提高%",
        "423": "攻击技能的闪电伤害提高%",
        "424": "攻击技能的混沌伤害提高%",
        "425": "攻击技能的火焰伤害提高%",
        "426": "压制物理伤害减免%",
        "427": "弓类的物理伤害提高%",
        "428": "投射物攻击技能的暴击率提高%",
        "429": "投射物攻击技能的暴击伤害加成%",
        "430": "非伤害性异常状态效果提高%",
        "431": "冰霜持续伤害加成%",
        "432": "前缀无法被改变",
        "433": "后缀无法被改变",
        "434": "该装备最大能量护盾",
        "435": "该装备护甲提高",
        "436": "该装备攻击附加基础火焰伤害",
        "437": "该装备攻击附加基础冰霜伤害",
        "438": "该装备攻击附加基础闪电伤害",
        "439": "该装备攻击附加基础混沌伤害",
        "440": "（无效）击中时对敌人附加绝望诅咒",
        "441": "（无效）击中时对敌人附加元素要害诅咒",
        "442": "（无效）击中时对敌人附加衰弱诅咒",
        "443": "（无效）击中时对敌人附加时空锁链诅咒",
        "444": "（无效）击中时对敌人附加脆弱诅咒",
        "445": "攻击附加基础暴击率%",
        "446": "法术暴击率提高%",
        "447": "狂怒球数量上限",
        "448": "该装备上的技能石等级",
        "449": "该装备上的持续时间技能石等级",
        "450": "该装备上的效果区域技能石等级",
        "451": "该装备上的光环技能石等级",
        "452": "该装备上的诅咒技能石等级",
        "453": "该装备上的陷阱或地雷技能石等级",
        "454": "该装备上的召唤生物技能石等级",
        "455": "该装备上的战吼技能石等级",
        "456": "该装备上的投射物技能石等级",
        "457": "击中时有几率使敌人致盲%",
        "458": "（无效）击中时有几率使敌人瘫痪%",
        "459": "（无效）法术击中时有几率使敌人缓速%",
        "460": "（无效）近战攻击击退敌人",
        "461": "击中时有几率威吓敌人%",
        "462": "法术击中时有几率使敌人恐惧%",
        "463": "中毒持续时间延长%",
        "464": "流血伤害生效速度加快%",
        "465": "暴击时有几率获得 1 个暴击球%",
        "466": "击败敌人时有几率获得不洁之力 3 秒%",
        "467": "近战击中有几率提供护体状态%",
        "468": "击败敌人时有几率获得 4 秒【猛攻】状态%",
        "469": "（无效）坚毅之心",
        "470": "（无效）消耗总计魔力后获得 1 个狂怒球",
        "471": "击中时几率造成流血；攻击伤害对流血的敌人提高%",
        "472": "当你晕眩 1 个敌人时，有几率获得 1 个耐力球%",
        "473": "此物品上的技能石受到级的 致盲 辅助",
        "474": "此物品上的技能石受到级的 快速投射 辅助",
        "475": "插槽中的宝石受级动量辅助",
        "476": "此物品上的技能石受到级的 额外命中 辅助",
        "477": "此物品上的技能石受到级的 护体 辅助",
        "478": "（无效）武器范围米",
        "479": "插入的技能石被级的赤炼辅助",
        "480": "此物品上的技能石受到级的 击中生命回复 辅助",
        "481": "此物品上的技能石受到级的【启迪】辅助",
        "482": "（无效）你能施加一个额外诅咒",
        "483": "（无效）获得级的主动技能【清晰】，且可被此道具上的技能石辅助",
        "484": "（无效）获得级的主动技能【怨毒光环】",
        "485": "（无效）获得级的主动技能【火焰净化】，且可被此道具上的技能石辅助",
        "486": "（无效）获得级的主动技能【冰霜净化】，且可被此道具上的技能石辅助",
        "487": "（无效）获得级的主动技能【闪电净化】，且可被此道具上的技能石辅助",
        "488": "（无效）获得级的主动技能【元素净化】，且可被此道具上的技能石辅助",
        "489": "冰霜伤害转化为生命偷取%",
        "490": "火焰伤害转化为生命偷取%",
        "491": "闪电伤害转化为生命偷取%",
        "492": "【雷霆】的光环效果提高%",
        "493": "【愤怒】光环的效果提高%",
        "494": "【憎恨】的光环效果提高%",
        "495": "【坚定】的光环效果提高%",
        "496": "【纪律】的光环效果提高%",
        "497": "【优雅】的光环效果提高%",
        "498": "【怨毒光环】的光环效果提高%",
        "499": "【奋锐光环】的光环效果提高%",
        "500": "【尊严】的光环效果提高%",
        "501": "敏捷提高%",
        "502": "智慧提高%",
        "503": "力量提高%",
        "504": "获得级的主动技能【愤怒】且可被此道具上的技能石辅助",
        "505": "获得级的主动技能【雷霆】且可被此道具上的技能石辅助",
        "506": "获得级的主动技能【憎恨】且可被此道具上的技能石辅助",
        "507": "获得级的主动技能【奋锐光环】",
        "508": "获得级的主动技能【尊严】",
        "509": "获得级的主动技能【导电】，且可被此道具上的技能石辅助",
        "510": "获得级的主动技能【绝望】，且可被此道具上的技能石辅助",
        "511": "获得级的主动技能【易燃】，且可被此道具上的技能石辅助",
        "512": "获得级的主动技能【冻伤】，且可被此道具上的技能石辅助",
        "513": "免疫流血",
        "514": "无法被点燃",
        "515": "不会中毒",
        "516": "力量提高%，敏捷提高%",
        "517": "力量提高%，智慧提高%",
        "518": "敏捷提高%，智慧提高%",
        "519": "（无效）药剂持续期间，暴击伤害加成%",
        "520": "（无效）药剂持续期间，攻击速度加快%",
        "521": "（无效）药剂持续期间，施法速度加快%",
        "522": "（无效）药剂持续期间，暴击几率提高%",
        "523": "（无效）药剂持续期间，移动速度%",
        "524": "（无效）静止时护甲",
        "525": "（无效）移动时最大闪避值",
        "526": "获得级的主动技能【迅捷】且可被此道具上的技能石辅助",
        "527": "耐力球数量上限",
        "528": "（无效）移动时每秒回复生命",
        "529": "（无效）静止时受到的物理伤害降低%",
        "530": "（无效）全部抗性上限%",
        "531": "（无效）受到的火焰伤害降低%",
        "532": "（无效）受到的冰霜伤害降低%",
        "533": "（无效）受到的闪电伤害降低%",
        "534": "（无效）受到的混沌伤害降低%",
        "535": "免疫致盲",
        "536": "感电效果提高%",
        "537": "弓类攻击附加基础冰霜伤害",
        "538": "弓类攻击附加基础火焰伤害",
        "539": "弓类攻击附加基础闪电伤害",
        "540": "弓类攻击附加基础混沌伤害",
        "541": "每次连锁投射物伤害提高%",
        "542": "（无效）每次穿透投射物伤害提高%",
        "543": "获得额外火焰伤害，等同于物理伤害的%",
        "544": "获得额外闪电伤害，等同于物理伤害的%",
        "545": "（无效）零点射击",
        "546": "近战打击范围米",
        "547": "召唤图腾数量上限",
        "548": "图腾生命提高%",
        "549": "图腾伤害提高%",
        "550": "图腾的持续时间延长%",
        "551": "图腾施放的技能暴击率提高%",
        "552": "可以拥有多个大师工艺",
        "553": "所有混沌法术主动技能石等级",
        "554": "所有闪电法术主动技能石等级",
        "555": "所有火焰法术主动技能石等级",
        "556": "所有冰霜法术主动技能石等级",
        "557": "所有物理主动法术技能石等级",
        "558": "所有火焰主动技能石等级",
        "559": "所有冰霜主动技能石等级",
        "560": "所有闪电主动技能石等级",
        "561": "所有物理主动技能石等级",
        "562": "所有混沌主动技能石等级",
        "563": "所有主动技能石等级",
        "564": "闪电技能施法速度提高%",
        "565": "火焰技能施法速度提高%",
        "566": "冰霜技能施法速度提高%",
        "567": "投射物有几率丢失%",
        "568": "品质增加生命",
        "569": "品质增加魔力",
        "570": "品质增加力量",
        "571": "品质增加敏捷",
        "572": "品质增加智慧",
        "573": "品质增加火焰抗性%",
        "574": "品质增加冰霜抗性%",
        "575": "品质增加闪电抗性%",
        "576": "品质增加武器射程",
        "577": "品质增加效果区域%",
        "578": "品质增加精度%",
        "579": "品质增加攻击速度%",
        "580": "品质增加暴击率%",
        "581": "品质增加元素伤害%",
        "582": "（标识）品质不提高防具防御",
        "583": "（标识）品质不提高武器物理伤害",
        "585": "对传奇敌人的暴击伤害加成 +",
        "586": "对满生命敌人的暴击几率提高",
        "587": "暴击造成的晕眩持续时间提高",
        "588": "你的每个光环或先驱影响你时，伤害提高",
        "589": "若你保留了生命和魔力，所有元素抗性上限 +",
        "590": "技能的生命保留效能提高",
        "591": "光环技能范围效果提高",
        "592": "非诅咒光环技能持续时间延长",
        "593": "对有闪电曝露的敌人，暴击几率提高",
        "594": "感电扩散半径 + 米",
        "595": "最大魔力的提高与降低同样以 的数值作用于感电效果",
        "596": "当你被感电时，击中你的敌人的闪电伤害不幸运",
        "597": "非瓦尔打击技能额外瞄准 个附近敌人",
        "598": "敌人无法格挡你的攻击",
        "599": "每个近距离敌人使攻击速度提高",
        "600": "拥有怒火时，附近敌人被【威吓】",
        "601": "你施加的火焰曝露额外降低 抗性",
        "602": "击败燃烧敌人时可能爆炸",
        "603": "暴击时有 几率刷新点燃持续时间",
        "604": "每 1% 未封顶的火焰抗性：生命每秒再生",
        "605": "暴击不会固有地造成点燃",
        "606": "对点燃敌人的击中伤害提高",
        "607": "敌人每被你冰冻 1 秒，永久受到的伤害提高 5%，最多 50%",
        "608": "你的击中造成的冰缓至少降低 10% 行动速度",
        "609": "你粉碎的目标附近的敌人有几率被冰霜覆盖",
        "610": "受到的反射物理伤害降低",
        "611": "物理攻击伤害上限总增",
        "612": "不会被只造成物理伤害的击中晕眩",
        "613": "击中有 几率无视敌人的物理伤害减免",
        "614": "消耗生命的技能物理伤害提高",
        "615": "每层【穿刺】使流血的持续伤害加成 +",
        "616": "你施加的曝露至少降低 抗性",
        "617": "受到的反射元素伤害降低",
        "618": "你受到的曝露效果降低",
        "619": "击中有 几率将敌人的元素抗性视为反转",
        "620": "对你的暴击不会固有地造成元素异常状态",
        "621": "击中有 几率造成额外随机元素伤害",
        "622": "【闪现射击】与【镜像射击】冷却回复速度加快",
        "623": "装备弓时，效果区域扩大",
        "624": "箭矢飞行距离越远，暴击几率提高",
        "625": "幻影射手持续时间延长",
        "626": "装备的弓每个绿色插槽：命中值 +",
        "627": "投射物速度同样套用至弓类伤害",
        "628": "剑类近战打击范围 + 米",
        "629": "剑类攻击的暴击率提高",
        "630": "剑类攻击的暴击伤害加成降低",
        "631": "敌人格挡剑类攻击几率降低",
        "632": "装备剑时：副手命中值等于主手命中值",
        "633": "击中传奇敌人时有 几率获得 1 个狂怒球",
        "634": "攻击击中时穿刺几率",
        "635": "每秒回复 点魔力",
        "636": "使用守护技能时，在 1 秒内回复 魔力",
        "637": "受到的伤害的 转化为魔力返还",
        "638": "技能的魔力消耗降低",
        "639": "使用技能时有 几率回复魔力",
        "640": "光照范围基于能量护盾而非生命；光照范围扩大",
        "641": "满能量护盾时，受到的物理伤害降低",
        "642": "晕眩阈值基于你 的能量护盾而非生命",
        "643": "每秒回复 能量护盾",
        "644": "受到的混沌伤害的 不会穿透能量护盾",
        "645": "装备的头部提供的能量护盾提高",
        "646": "拥有能量护盾时，闪避值提高",
        "647": "若近期未被击中，能量护盾充能速度加快",
        "648": "若你的两个戒指都有闪避词缀：最大能量护盾提高",
        "649": "若你的项链有闪避词缀：能量护盾充能速度加快",
        "650": "若最近 2 秒内开始过能量护盾回复：闪避值提高",
        "651": "每 5 点智慧 闪避值提高%",
        "652": "每 4 秒，在 1 秒内回复等同于 1% 闪避值的能量护盾",
        "653": "锤类和短杖击中时粉碎敌人",
        "654": "锤类和短杖的所有伤害造成冰缓",
        "655": "若你近期内造成过暴击：效果区域扩大",
        "656": "若攻击时间超过 1 秒：攻击有 几率造成双倍伤害",
        "657": "你对敌人的晕眩持续时间延长",
        "658": "你对晕眩敌人的击中拥有【终结】",
        "659": "流血持续时间延长%",
        "660": "敌人身上的点燃持续时间延长%",
        "661": "护体上限",
        "662": "投射物速度的增强与减弱效果同样作用于该技能的效果区域",
        "663": "技能效果半径米",
        "664": "攻击伤害对流血的敌人提高%",
        "665": "无法造成暴击",
        "666": "你对未中毒敌人造成的中毒伤害提高",
        "667": "你造成的中毒伤害生效速度加快",
        "668": "你对流血敌人造成的中毒持续伤害加成 +",
        "669": "被你中毒的敌人无法造成暴击",
        "670": "击败中毒敌人时回复 生命",
        "671": "【瘟疫使者】的最大瘟疫值提高",
        "672": "暴击率%",
        "673": "对满生命敌人的暴击伤害加成 +",
        "674": "水银爪印",
        "675": "生命偷取每秒总恢复量总增",
        "676": "该武器的攻击附加相当于你最大能量护盾的最大闪电伤害%",
        "677": "每点闪避值可使攻击伤害提高%",
        "678": "对感电敌人的击中伤害提高",
        "679": "近战击中时获得怒火",
        "680": "每一点怒火使你获得相当于物理伤害的额外火焰伤害%",
        "681": "你造成中毒时，有几率对同一目标造成额外一次中毒%",
        "682": "对感电敌人造成的伤害的 转化为生命偷取",
        "683": "反射你的另一枚戒指",
        "684": "被敌人击中前获得已损失未保留生命的%",
        "685": "魔力在你格挡时",
        "686": "攻击伤害格挡几率上限%",
        "687": "格挡时反射物理伤害给攻击者",
        "688": "受到的火焰伤害总增%",
        "689": "周围敌人灰烬缠身",
        "690": "每隔 10 秒：在 5 秒内，攻击每击中一个敌人回复相当于最大生命的生命%",
        "691": "每隔 10 秒：在 5 秒内，每击败一个敌人获得相当于最大生命的生命%",
        "692": "敌人受到的元素异常状态时间缩短%",
        "693": "装备和技能石的属性需求提高%",
        "694": "总是使敌人受到冰冻、感电与点燃",
        "695": "敌人被冰冻的持续时间延长%",
        "696": "你造成的冻结会扩散给米内的其他敌人",
        "697": "若你近期内有冰冻敌人，伤害提高%",
        "698": "对冰缓的敌人，伤害穿透其冰霜抗性%",
        "699": "被敌人击中后使其冰缓秒，行动速度降低%",
        "700": "击中冰缓的敌人时使其致盲",
        "701": "被点燃时移动速度 提高/降低",
        "702": "获得级的主动技能【精准】且可被此道具上的技能石辅助",
        "703": "【精准】的魔力保留效能提高%",
        "704": "弓类攻击带终结效果",
        "705": "护体本身不能降低你受到的伤害",
        "706": "法术伤害压制率按照每层护体%",
        "707": "达到护体上限时，攻击和施法速度加快%",
        "708": "暴击拥有终结能力",
        "709": "【憎恨】的魔力保留效能提高%",
        "710": "非暴击造成的闪电伤害特别幸运",
        "711": "若你近期内获得过暴击球，暴击伤害加成%",
        "712": "每个暴击球造成闪电伤害",
        "713": "暴击球持续时间%",
        "714": "击败中毒层数 ≥5 的敌人时，有 几率获得 1 个狂怒球",
        "715": "周围敌人被致盲",
        "716": "无法被冰缓",
        "717": "被冻结时每秒再生生命%",
        "718": "不受感电影响",
        "719": "敌人击中你的闪电伤害会特别幸运",
        "720": "周围友军击中造成的伤害特别幸运",
        "721": "击中造成的伤害特别幸运",
        "722": "每个狂怒球使投射物速度加快",
        "723": "被感电时每秒再生生命%",
        "724": "每个暴击球使投射物伤害提高",
        "725": "任意装备的每个空的红色插槽使最大生命 +",
        "726": "任意装备的每个空的绿色插槽使命中值 +",
        "727": "任意装备的每个空的蓝色插槽使最大魔力 +",
        "728": "任意装备的每个空的白色插槽使所有元素抗性 +%",
        "729": "攻击击中承受 - 物理伤害",
        "730": "你身上的减益效果消失速度加快",
        "731": "免疫晕眩",
        "732": "阻挡被压制的法术伤害 +",
        "733": "击败中毒层数 <5 的敌人时，有 几率获得 1 个暴击球",
        "734": " 的最大生命转化为能量护盾",
        "735": "你的暴击不造成额外暴击伤害",
        "736": "你每使敌人受到一种异常状态，它们受到的伤害便提高",
        "737": "你的元素伤害可以造成感电",
        "738": "造成的异常状态持续时间缩短",
        "739": "击中时有 几率偷取暴击、狂怒和耐力球",
        "740": "击中周围敌人时，暴击几率提高",
        "741": "你流血时也会被冰缓",
        "742": "每个狂怒球使中毒伤害提高",
        "743": "每个暴击球使中毒持续时间延长",
        "744": "耐力球持续时间 提高/降低",
        "745": "你造成流血的敌人若没有冰缓，则受到冰缓",
        "746": "当你失去一个暴击球时，获得一个耐力球",
        "747": "被你的击中所击败的流血敌人会粉碎",
        "748": "周围友军每秒再生 生命",
        "749": "周围友军的魔力再生速度提高",
        "750": "每个暴击球使你的暴击率降低",
        "751": "每个暴击球使你受到伤害的 由魔力先承担",
        "752": "每个暴击球使魔力再生速度提高",
        "753": "击败敌人时恢复相当于最大生命 的生命",
        "754": "击败敌人时有 几率给予周围敌人【猛攻】（持续 10 秒）",
        "755": "击败敌人时有 几率使周围的敌人获得【不洁之力】（持续 10 秒）",
        "756": "获得等同于你的混沌抗性一半的额外元素伤害减免",
        "757": "来自已装备盾牌的护甲值加倍",
        "758": "耐力、狂怒和暴击球上限为",
        "759": "无法从已装备的身体护甲获得护甲值",
        "760": "满血时移动速度 提高/降低",
        "761": "近战伤害在满血时提高",
        "762": "被点燃时，伤害提高",
        "763": "你身上的冰缓效果颠倒",
        "764": "当你点燃一个敌人时，受到 点火焰伤害",
        "765": "被点燃时，火焰伤害的 转化为生命偷取",
        "766": "你中毒时也会被冰缓",
        "767": "被你的击中所击败的中毒敌人会粉碎",
        "768": "插入的辅助宝石也能辅助你身体护甲上的技能",
        "769": "当你晕眩 1 个敌人时，有 几率获得 1 个狂怒球",
        "770": "混沌伤害的 转化为生命偷取",
        "771": "用法术击中每个敌人时，失去 生命",
        "772": "用攻击击中每个敌人时，失去 生命",
        "773": "连锁的投射物将 非混沌伤害作为其额外混沌伤害",
        "774": "你造成中毒的敌人若没有冰缓，则受到冰缓",
        "775": "每 100 最大魔力，攻击附加 混沌伤害",
        "776": "技能消耗能量护盾，而非魔力或生命",
        "777": "（无效）内部占位",
        "778": "对冰缓敌人附加 基础冰霜伤害",
        "779": "物理伤害的 转化为混沌伤害",
        "780": "对拥有能量护盾的敌人造成的混沌伤害额外提高",
        "781": "施加【凋零】时，有 几率直接施加最大层数",
        "782": "击败敌人时：每层【凋零】回复 生命",
        "783": "使用混沌技能时，失去 生命与能量护盾",
        "784": "被点燃时，攻击速度加快",
        "785": "被点燃时，施法速度加快",
        "786": "被击中时有 几率被点燃",
        "787": "被击中时，所有伤害都可以点燃你",
        "788": "当你点燃一个敌人时，回复 生命",
        "789": "你可以对敌人造成额外 个点燃效果",
        "790": "你造成的点燃伤害总降",
        "791": "你有 几率避免被晕眩",
        "792": "打击技能同时将其之前攻击的敌人设为目标",
        "793": "低生命时，移动速度 提高/降低",
        "794": "低生命时，混沌抗性 +",
        "795": "低生命时，敌人击中你的伤害特别不幸",
        "796": "敌人每受到一种元素异常状态影响，击中和异常状态造成的元素伤害提高",
        "797": "承受的元素伤害提高",
        "798": "击败敌人时获得肾上腺素，持续 秒",
        "799": " 火焰伤害转化为混沌伤害",
        "800": " 冰霜伤害转化为混沌伤害",
        "801": "附近敌人的混沌抗性为 0",
        "802": "混抗为0",
        "803": "非暴击时获得一个暴击球",
        "804": "暴击时失去所有暴击球",
        "805": "攻击暴击时造成威吓 秒",
        "806": "法术暴击时造成恐惧 秒",
        "807": "当你击败一名感电敌人时，对其附近的敌人造成相同的感电效果",
        "808": "当你击败一名点燃敌人时，对其附近的敌人造成相同的点燃效果",
        "809": "对被冰冻的敌人时，伤害的 转化为能量护盾偷取",
        "810": "你的法术有 几率对冰冻的敌人造成感电",
        "811": " 的闪电伤害转化为冰霜伤害",
        "812": "冰冻时 + 点护甲",
        "813": "每个红色插槽 + 最大生命（仅此物品）",
        "814": "每个绿色插槽 + 最大魔力（仅此物品）",
        "815": "每个蓝色插槽 + 最大能量护盾（仅此物品）",
        "816": "每个白色插槽 物品稀有度提高 %（仅此物品）",
        "817": "你的闪电伤害可以造成点燃",
        "818": "击中点燃敌人时附加 基础闪电伤害",
        "819": "燃烧伤害在你近期内每次使非感电敌人陷入感电时提高，最多 120%",
        "820": "当你使用技能时，受到 点火焰伤害",
        "821": "伤害穿透的火焰抗性等同于你的超量火焰抗性，上限为 %",
        "822": "你被感电的持续时间延长",
        "823": "你施加的感电会反射回自己身上",
        "824": "被感电时，伤害提高",
        "825": "被感电时，移动速度 提高/降低",
        "826": "若你的能量护盾在过去 2 秒内开始充能，你获得【迷踪】",
        "827": "【迷踪】状态时移动速度 提高/降低",
        "828": "身上每种异常状态使你每秒再生 生命",
        "829": "击中伤害对稀有怪物提高",
        "830": "当你击败稀有怪物时，会获得该怪物属性修正 秒",
        "831": "击中时有 几率施加【凋零】",
        "833": "未被点燃、冰冻、感电时，护甲提高",
        "834": "从魔力偷取中获得的每秒总恢复量总增",
        "835": "若敏捷高于智慧，则无法被冰冻",
        "836": "若力量高于敏捷，则无法被点燃",
        "837": "若智慧高于力量，则无法被感电",
        "838": "你最低的属性每有 5 点，伤害提高",
        "839": "周围敌人在你至少有 25 点怒火时被碾压",
        "840": "敌人受到的元素异常状态时间延长%",
        "841": "被你感电的敌人将物理伤害转化为闪电伤害%",
        "842": "被你点燃的敌人将物理伤害转化为火焰伤害%",
        "843": "周围的敌人会被威吓",
        "844": "对冰缓的敌人造成的攻击伤害转化为生命偷取%",
        "845": "法术暴击时造成威吓 秒",
        "846": "晕眩门槛提高%",
        "847": "每 50 点力量使护甲降低%",
        "849": "击中伤害对魔法怪物提高",
        "850": "当你击败魔法怪物时，有 几率获得其词缀",
        "851": "从魔法怪物获得的词缀持续 秒",
        "854": "基底词缀幅度变为三倍",
        "855": "攻击暴击时造成恐惧 秒",
        "856": "附近敌人将物理伤害转化为火焰伤害%",
        "857": "若你近期停止受到燃烧伤害，不会受到点燃",
        "859": "获得等同于最大生命的额外能量护盾%",
        "861": "非混沌伤害有穿透能量护盾%",
        "862": "获得残暴球替代耐力球",
        "863": "残暴球数量上限等于耐力球数量上限",
        "864": "调整耐力球数量下限的词缀改为调整残暴球数量下限",
        "865": "获得痛苦球替代狂怒球",
        "866": "痛苦球数量上限等于狂怒球数量上限",
        "867": "调整狂怒球数量下限的词缀改为调整痛苦球数量下限",
        "868": "暴击球数量上限",
        "869": "获得吸收球替代暴击球",
        "870": "吸收球数量上限等于暴击球数量上限",
        "871": "调整暴击球数量下限的词缀改为调整吸收球数量下限",
        "872": "每隔 5 秒，获得以下效果之一",
        "873": "你的击中始终为暴击",
        "874": "对你的击中始终为暴击",
        "875": "攻击无法击中你",
        "876": "对你的攻击必定击中",
        "877": "对你的击中伤害特别幸运",
        "878": "物理攻击伤害下限总降%",
        "879": "晕眩敌人时获得生命",
        "880": "取护甲和闪避值之间的较低者，每 200 点可使攻击伤害提高%",
        "881": "带眩晕效果的近战击中提供护体状态",
        "882": "你在护体状态下获得猛攻效果",
        "883": "若你近期内被击中，攻击伤害提高%",
        "884": "在受到暴击后的 4 秒内，你的下一个攻击的所有击中造成暴击",
        "885": "每个暴击球使攻击技能的元素伤害提高%",
        "886": "每个暴击球会提供攻击伤害的魔力偷取%",
        "887": "冰缓效果和冰冻时长基于你能量护盾的 100% 计算",
        "888": "不受感电地面影响",
        "889": "不受燃烧地面影响",
        "890": "不受伤害异常状态影响",
        "892": "无法被击退",
        "893": "你的行动速度无法被减速至基础值以下",
        "894": "你和在场的敌人受到元素异常状态影响时视作移动中",
        "895": "流血时不会中毒",
        "896": "流血时无法被眩晕",
        "897": "流血时移动不会使你受到额外伤害",
        "898": "移动时，你受到的流血消减速度减慢",
        "899": "流血时，击中获得 1 个狂怒球",
        "900": "中毒时，击中获得 1 个暴击球",
        "901": "被击中时，有 几率流血",
        "902": "对你的法术击中有 几率施加中毒",
        "903": "静止时，混沌抗性 +",
        "904": "每个狂怒球使移动速度 提高/降低",
        "905": "每个狂怒球使攻击速度加快%",
        "906": "每个狂怒球使你每秒再生 生命",
        "907": "对低血敌人，每个狂怒球使伤害提高",
        "908": "不会因被压制的法术伤害而眩晕",
        "909": "压制敌人的法术伤害时使其【疲惫】 秒",
        "910": "瘀血爪印",
        "911": "在【猛攻】状态期间，闪避值提高%",
        "912": "处于【迷踪】状态时，有几率避免元素异常状态%",
        "913": "不受冰缓地面影响",
        "914": "敌人无法偷取你的生命",
        "915": "每 10 点敏捷最大生命",
        "916": "每个暴击球使伤害提高",
        "917": "当你可能获得暴击球时，有 几率直接获得最大数量的暴击球",
        "918": "你无法再生生命",
        "919": "你的晕眩阈值基于最大魔力的%，而非生命",
        "920": "每个狂怒球使闪避值提高%",
        "921": "狂怒球持续时间%",
        "922": "周围敌人被灼蚀",
        "923": "灼蚀效果提高",
        "924": "（弃用）击败被灼蚀的敌人时，有 几率制造燃烧地面 4 秒",
        "925": "击败烧灼的敌人时有 几率使周围所有敌人燃烧",
        "926": "视作拥有最大数量的暴击球",
        "927": "你无法被施加【腐化之血】",
        "928": "每 80 点力量，攻击附加混沌伤害",
        "929": "自身受到的元素异常状态持续时间延长%",
        "930": "被点燃时获得【肾上腺素】",
        "931": "被点燃时每秒承受火焰伤害",
        "932": "赋予等级【烈焰之触】技能",
        "933": "能量护盾全满时，移动速度 提高/降低",
        "934": "能量护盾全满时，受到的伤害提高",
        "935": "击败敌人时获得迷踪 秒",
        "936": "迷踪状态下，受到的伤害提高",
        "937": "你处于迷踪状态时，投射物额外连锁 次",
        "938": "击败敌人时有 几率获得一个随机充能球",
        "939": "能量连接",
        "941": "近战打击技能对周围目标造成溅射（最多额外目标）",
        "942": "击中获得怒火时，有改为获得最大怒火%",
        "943": "击退距离延长%",
        "944": "每秒失去怒火",
        "945": "怒火上限减半",
        "946": "受到的伤害降低%",
        "947": "每层护体使攻击速度提高%",
        "948": "击中时有几率击退敌人%",
        "949": "你被晕眩的持续时间延长%",
        "950": "你在耐力球达到上限时无法被感电",
        "951": "每个耐力球使近战伤害提高%",
        "952": "生命再生不再回复生命",
        "953": "每有 200 点来自再生的每秒生命回复，每秒再生怒火",
        "954": "你的暴击伤害加成为%",
        "955": "使用技能时失去魔力",
        "956": "击败敌人时获得能量护盾",
        "957": "施法时，献祭生命的%来获得等量的能量护盾",
        "958": "此物品上装备的【元素技能石】等级",
        "959": "不能造成非混沌伤害",
        "960": "击败流血的敌人时产生爆炸，造成等同其最大生命的物理伤害%",
        "961": "当因未保留生命已满而移除生命偷取时，有几率获得肾上腺素",
        "962": "当因未保留生命已满而移除生命偷取时，有几率获得猛攻",
        "963": "每个狂怒球使元素伤害提高%",
        "964": "每个耐力球使物理伤害提高%",
        "965": "每个暴击球使法术伤害提高%",
        "966": "周围被击败的敌人都视为被你击败",
        "967": "你的冰霜伤害可以造成中毒",
        "968": "冰霜技能有几率使敌人中毒%",
        "969": "你的火焰伤害可以造成中毒",
        "970": "火焰技能有几率使敌人中毒%",
        "971": "你的闪电伤害可以造成中毒",
        "972": "闪电技能有几率使敌人中毒%",
        "974": "你只能击败被冰冻的敌人",
        "975": "你的混沌伤害可以点燃敌人",
        "976": "混沌技能有几率点燃敌人%",
        "977": "点燃持续时间%",
        "978": "中毒持续时间%",
        "979": "每 1 点智慧命中值",
        "980": "每 10 点力量最大魔力",
        "981": "每 10 点力量 使最大能量护盾提高%",
        "982": "每 10 点敏捷 近战物理伤害提高%",
        "983": "满生命时 攻击速度加快%",
        "984": "你施加的每层【凋零】都使敌人从你的击中中承受的元素伤害提高%",
        "985": "你的击中无法穿透或无视元素抗性",
        "986": "徒手近战攻击的物理伤害总增%",
        "987": "偷取魔力时，你造成的冰缓效果提高%",
        "988": "偷取能量护盾时，你造成的感电效果提高%",
        "989": "偷取魔力时不受冰缓影响",
        "990": "偷取能量护盾时不受感电影响",
        "991": "击中稀有或传奇敌人时吞噬一个灵魂",
        "992": "被吞噬的灵魂数量上限",
        "993": "每个狂怒球使命中值提高%",
        "994": "每个狂怒球中毒持续伤害加成%",
        "995": "拥有最大数量的狂怒球时，攻击有几率使敌人中毒%",
        "996": "此物品上的技能石受到 [等级] 级的 [技能] 辅助",
        "997": "攻击击中每个敌人会获得 能量护盾",
        "998": "击中时有 几率获得 1 个耐力球",
        "999": "击中时有 几率获得 1 个狂怒球",
        "1000": "击中时有 几率获得 1 个暴击球",
        "1001": "每 6 秒依次给予你【玛拉凯的耐力、玛拉凯的狂怒、玛拉凯的暴击】，各持续 6 秒",
        "1002": "击中没有护甲值的敌人时，有 几率获得 1 个耐力球",
        "1003": "击中没有闪避值的敌人时，有 几率获得 1 个狂怒球",
        "1004": "击中时有 几率施加【腐蚀】",
        "1005": "插入的投射物法术的击中伤害总增",
        "1006": "插入的投射物法术的冷却时间 + 秒",
        "1007": "插入的投射物法术发射 枚额外投射物",
        "1008": "插入的投射物法术环状发射投射物",
        "1009": "插入的投射物法术的技能效果持续时间总降",
        "1011": "受到的近战物理伤害的 会反射给攻击者",
        "1012": "受到的持续性混沌伤害降低",
        "1013": "每个镶嵌的宝石使此物品上的技能石等级 -",
        "1014": "每有 50 点力量，攻击伤害格挡几率额外 +%",
        "1015": "格挡法术伤害的几率会特别不幸",
        "1016": "不再通过力量获得伤害加成",
        "1017": "每 10 点力量会使近战物理伤害提高",
        "1018": "你身上的神龛增益效果提高%",
        "1019": "你具有次级威猛神龛效果",
        "1020": "你具有次级巨人神龛效果",
        "1021": "角色大小提高%",
        "1022": "力量需求",
        "1023": "力量不对最大生命提供加成",
        "1024": "不会受到暴击所造成的额外暴击伤害",
        "1025": "远程武器攻击的物理伤害提高",
        "1026": "受到击中火焰伤害的 转为物理伤害",
        "1027": "每 [数值] 闪避值提高 1% 移动速度，最多 [数值]%",
        "1028": "若你近期内未被击中，受到的伤害总降低",
        "1029": "若你近期内被击中，闪避值提高",
        "1030": "你造成的冰缓持续时间延长",
        "1032": "闪避值随超量冰霜抗性提高（每 1% 超量冰抗提供 % 闪避值提高）",
        "1034": "法杖攻击附加 闪电伤害",
        "1035": "你造成的感电持续时间延长",
        "1036": "攻击伤害的 会转化为生命偷取",
        "1037": "攻击伤害的 会转化为魔力偷取",
        "1038": "法杖暴击时有 几率获得 1 个暴击球",
        "1039": "法杖击中时使敌人陷入恐惧，持续 秒",
        "1040": "法杖攻击额外发射 个投射物",
        "1041": "装备法杖时，法术伤害的提高和降低同样套用至攻击",
        "1048": "主手爪类攻击每击中一个敌人回复 生命",
        "1049": "副手爪类攻击每击中一个敌人回复 魔力",
        "1050": "对低血敌人的爪类伤害提高",
        "1051": "每装备一把爪，有 的偷取会立即生效",
        "1052": "若你近期用爪击中过，潜行效果提高",
        "1053": "被夜刃辅助的技能迷踪效果提高",
        "1054": "法术的最后一次重复范围效果提高%",
        "1055": "若你近期施法时被晕眩过，法术伤害提高%",
        "1056": "你近期施放的每个不同的非瞬发法术使施法速度提高%",
        "1057": "可以获得强度的法术最大强度",
        "1058": "被释放辅助的技能最大印记数量",
        "1059": "施放法术时有几率打开附近的箱子%",
        "1060": "装备护甲提供的能量护盾改为提供生命",
        "1061": "格挡时有几率制造奉献地面",
        "1062": "技能石镶嵌时可以无视此物品上的插槽颜色",
        "1063": "红色插槽内的技能石等级",
        "1064": "绿色插槽内的技能石品质（展示）%",
        "1065": "蓝色插槽内的技能石获得的经验提高%",
        "1066": "此物品没有属性需求",
        "1067": "被击中时有几率获得 1 个耐力球%",
        "1068": "的物理、冰霜与闪电伤害转化为火焰伤害，无法造成非火焰伤害%",
        "1069": "暴击球持续时间%",
        "1070": "狂怒球持续时间%",
        "1071": "耐力球持续时间%",
        "1072": "使用双手近战武器造成的晕眩持续时间%",
        "1073": "使用长杖或战杖造成的晕眩持续时间%",
        "1074": "使用弓造成的晕眩持续时间%",
        "1075": "使用锤类或短杖击中时，敌人晕眩门槛降低%",
        "1076": "使用弓击中时，敌人晕眩门槛降低%",
        "1077": "你的闪电技能使敌人晕眩门槛降低%",
        "1078": "近战击败敌人时，有几率制造奉献地面",
        "1079": "对近身（2 米内）敌人的近战击中伤害提高%",
        "1080": "受到的物理伤害减少%",
        "1081": "受到的元素伤害减少%"
    }

    //获取玩家职业
    async function getPlayerInfo() {
        const classElements = document.getElementsByClassName("class");
        const data = await fetchPlayerInfo();
        playerId = data.data.name;
        let key = data.data.class;
        playerClassEmj = classEmojis[key];

        console.log(playerClassEmj + playerId);
    }

    async function fetchPlayerInfo() {
        const res = await fetch(playerInfoUrl, {
            headers: {
                'Authorization': 'Bearer ' + token
            }
        });
        return await res.json();
    }

    await getPlayerInfo();
    // 统计基础类，管理 min, max, count, total
    // 统计平均最小最大覆盖率的
    let BATTLE_INFO_COUNT = 0;
    let BATTLE_ENEMY_INFO_COUNT = 0;
    class StatTracker {
        constructor() {
            this.min = Infinity;
            this.max = -Infinity;
            this.count = 0;
            this.total = 0;
        }

        // 更新统计数据
        update(value) {
            if (typeof value !== 'number' || isNaN(value)) {
                // 非法值直接忽略
                return;
            }
            this.total += value;
            this.count++;
            if (value < this.min) this.min = value;
            if (value > this.max) this.max = value;
        }

        // 计算平均值
        getAvg() {
            return this.count === 0 ? 0 : this.total / this.count;
        }

        toString() {
            if (this.count === 0) return "🚫 无数据";
            const avg = this.total / this.count;
            return `⚖️ 均值: ${formatNumberSmart(avg)} | 🔽 最小: ${formatNumberSmart(this.min)} | 🔼 最大: ${formatNumberSmart(this.max)} | 🔁 次数: ${this.count} | 🌙 累计: ${formatNumberSmart(this.total)}`;
        };
        toString2(denominator,coefficient = 1){
            if (this.count === 0) return "🚫 无数据";
            const avg = this.total / this.count;
            const coverage = this.count/denominator;
            if (coefficient !== 1){
                coefficient = coverage;
                return `⚖️ 均值: ${formatNumberSmart(avg*coefficient)} | 🔽 最小: ${formatNumberSmart(this.min)} | 🔼 最大: ${formatNumberSmart(this.max)} | 🌙 覆盖率: ${formatNumberSmart(coverage*100)}%`;
            }else {
                return `⚖️ 均值: ${formatNumberSmart(avg)} | 🔽 最小: ${formatNumberSmart(this.min)} | 🔼 最大: ${formatNumberSmart(this.max)} | 🌙 覆盖率: ${formatNumberSmart(coverage*100)}%`;
            }
        }
    }
    //根据key 分类统计
    class StatTrackerByKey {
        constructor(keyNames = []) {
            this.map = {};
            this.keyNames = keyNames; // 用于 toString 排序和显示
        }

        update(key, value) {
            // 自动初始化，如果 key 不在 keyNames 中也能统计，但 getAllStats()/toString() 不会显示
            if (!this.map[key]) {
                this.map[key] = new StatTracker();
            }
            this.map[key].update(value);
        }

        getStats(key) {
            return this.map[key] || new StatTracker();
        }

        getAllStats() {
            return this.keyNames.map(key => ({ key, stats: this.getStats(key) }));
        }

        toString() {
            return this.keyNames.map(key =>
                `${key}: ${this.getStats(key).toString()}`
            ).join('\n');
        }
    }
    //分稀有度的
    const RARITY_NORMAL = 1;
    const RARITY_MAGIC = 2;
    const RARITY_RARE = 3;
    const RARITY_BOSS = 4;

    const rarityLabels = {
        [RARITY_NORMAL]: "⚪ 普通 ",
        [RARITY_MAGIC]: "🔵 魔法 ",
        [RARITY_RARE]: "🟡 稀有 ",
        [RARITY_BOSS]: "🔴 头目 "
    };
    //根据稀有度分类统计
    class StatTrackerByRarity extends StatTrackerByKey {
        constructor() {
            super([RARITY_NORMAL, RARITY_MAGIC, RARITY_RARE, RARITY_BOSS]);
        }

        toString() {
            return this.keyNames.map(key =>
                `                    ${rarityLabels[key]}: ${this.getStats(key).toString()}`
            ).join('\n');
        }
    }
    //根据伤害类型分类统计
    const DAMAGE_TYPE_INDEX_PHYSICAL  = 1;
    const DAMAGE_TYPE_INDEX_FIRE      = 2;
    const DAMAGE_TYPE_INDEX_COLD      = 3;
    const DAMAGE_TYPE_INDEX_LIGHTNING = 4;
    const DAMAGE_TYPE_INDEX_CHAOS     = 5;

    const damageLabels = {
        [DAMAGE_TYPE_INDEX_PHYSICAL]:  "⚔️ 物理",
        [DAMAGE_TYPE_INDEX_FIRE]:      "🔥 火焰",
        [DAMAGE_TYPE_INDEX_COLD]:      "❄️ 冰霜",
        [DAMAGE_TYPE_INDEX_LIGHTNING]: "⚡ 闪电",
        [DAMAGE_TYPE_INDEX_CHAOS]:     "☠️ 混沌"
    };

    class StatTrackerByType extends StatTrackerByKey {
        constructor() {
            super([
                DAMAGE_TYPE_INDEX_PHYSICAL,
                DAMAGE_TYPE_INDEX_FIRE,
                DAMAGE_TYPE_INDEX_COLD,
                DAMAGE_TYPE_INDEX_LIGHTNING,
                DAMAGE_TYPE_INDEX_CHAOS
            ]);
        }

        toString() {
            const lines = this.keyNames
                .filter(key => this.getStats(key).count > 0)
                .map(key =>
                    `                    ${damageLabels[key]}: ${this.getStats(key).toString()}`
                );

            if (lines.length === 0) {
                return '                    🚫 无数据';
            }

            return lines.join('\n');
        }
    }
    //根据技能分类统计
    class SkillStat {
        constructor(name,stoneId) {
            this.name = name;
            this.stoneId = stoneId;
            this.totalTracker = new StatTracker();          // 总伤害
            this.typeTracker = new StatTrackerByType();     // 按类型的伤害
            this.speedTracker = new StatTracker();          // 释放间隔
            this.critCount = 0;                             // 暴击次数
            this.nonCritCount = 0;                          // 非暴击次数
            this.miss = 0;                                  // 未命中次数
        }

        updateDamage(totalDamage = 0, damageByType = {}, isCrit = false) {
            this.totalTracker.update(totalDamage);

            for (const type in damageByType) {
                const dmg = damageByType[type];
                if (typeof dmg === "number" && !isNaN(dmg)) {
                    this.typeTracker.update(parseInt(type), dmg);
                }
            }

            if (isCrit) {
                this.critCount++;
            } else {
                this.nonCritCount++;
            }

            if (totalDamage === 0){
                this.miss ++;
            }
        }

        updateInterval(number,interval){
            this.speedTracker.update(interval);
        }

        getCritRate() {
            const total = this.critCount + this.nonCritCount - this.miss;
            return total > 0 ? formatNumberSmart(this.critCount / total * 100) : "N/A";
        }

        getAverageDPS(){
            let totalDamage = this.totalTracker.total;
            let totalTime = this.speedTracker.total;
            if (totalTime !== null && totalTime !== undefined && totalTime !== 0){
                return formatNumberSmart(totalDamage/totalTime);
            }else {
                return formatNumberSmart(totalDamage/battleTimeStat.total);
            }
        }

        getAverageHitDPS(){
            let averageDamage = this.totalTracker.getAvg();
            let averageTime = this.speedTracker.getAvg();
            return formatNumberSmart(averageDamage/averageTime);
        }

        getHitRate(){
            let miss = this.miss;
            let total = this.critCount + this.nonCritCount;
            return total > 0 ? formatNumberSmart((1 - miss / total) * 100) : "N/A";
        }

        getEffectiveInterval(){
            let totalCount = this.critCount + this.nonCritCount;
            return formatNumberSmart(battleTimeStat.total/totalCount);
        }

        toString() {
            if (this.stoneId !== ""){
                return `🧪 技能: ${this.name}  (🆔 ${this.stoneId}) \n
                    💥 伤害: ${this.totalTracker.toString()} \n
                    🗡️ 单体击中DPS:  ${this.getAverageHitDPS()} | ⚔️ 实际释放DPS: ${this.getAverageDPS()} | ⏱️ 平均释放间隔: ${this.speedTracker.count > 0 ? formatNumberSmart(this.speedTracker.getAvg()) + " 秒" : "无"} \n
                    🧿 命中率: ${this.getHitRate()}% | 💫 暴击率: ${this.getCritRate()}% | 🎯 暴击: ${this.critCount} 次 | 🟢 普通命中: ${this.nonCritCount - this.miss} 次 | ❌ 未命中: ${this.miss} 次  \n
                    📊 按类型伤害:\n${this.typeTracker.toString()}`;
            }else if(this.name !== "") {
                return `🧪 非技能: ${this.name} \n
                    💥 伤害: ${this.totalTracker.toString()} \n
                    ⚔️ 统计实际DPS:  ${this.getAverageDPS()} | ⏱️ 平均生效间隔: ${this.getEffectiveInterval() + " 秒"} \n
                    🧿 命中率: ${this.getHitRate()}% | 💫 暴击率: ${this.getCritRate()}% | 🎯 暴击: ${this.critCount} 次 | 🟢 普通命中: ${this.nonCritCount - this.miss} 次 | ❌ 未命中: ${this.miss} 次  \n
                    📊 按类型伤害:\n${this.typeTracker.toString()}`;
            }

        }
    }

    const MagicWidth = 20;
    //魔法效果
    class MagicStat{
        constructor(id) {
            this.id = id;
            if (MAGIC_TYPE[id]){
                this.desc = MAGIC_TYPE[id];
            }else {
                this.desc = "未知效果: " + id
            }
            this.stats = new StatTracker();
        }

        update(value){
            this.stats.update(value);
        }

        toString(denominator,coefficient = magicAvgMode){
            //magicAvgMode 模式不同时 使用不同的emj颜色
            if (coefficient === 1){
                return `                   🔹magic:${formatStringSmart(this.desc,MagicWidth,28)}  ${this.stats.toString2(denominator,coefficient)} \n `;
            }else {
                return `                   🔸magic:${formatStringSmart(this.desc,MagicWidth,28)}  ${this.stats.toString2(denominator,coefficient)} \n `;
            }
        }
    }
    //buff统计 一个buff可能有多个魔法效果
    class BuffStat{
        constructor(name,type) {
            this.name = name;
            this.type = type;
            this.magics = {};
            this.stackStat = new StatTracker();
        }

        update(stack=1,kind=1){
            switch (kind){
                //1为通常buff处理
                case 1:{
                    this.stackStat.update(stack);
                    break;
                }
                //2为猎首buff处理
                case 2:{
                    break;
                }
            }
        }

        updateMagic(type,value,kind = 1){
            switch (kind){
                //1为通常buff处理
                case 1:{
                    if(!this.magics[type]){
                        this.magics[type] = new MagicStat(type);
                    }
                    this.magics[type].update(value);
                    break;
                }
                //2为猎首buff处理
                case 2:{
                    break;
                }
            }
        }

        toString(denominator,coefficient = magicAvgMode){
            const magicsStr = Object.values(this.magics)
                .map(m => m.toString(denominator,coefficient))
                .join('');

            //魔法效果的说明, 计算覆盖率后的平均值, 覆盖率, 出现时的平均值, 最大值, 最小值
            //特殊处理猎首, 魔法效果 对应的每次统计的平均总值, 覆盖率, 数量, 最大值, 最小值
            return `   ✨ Buff:${this.name} 
            ${formatStringSmart("叠加层数",MagicWidth,13)}  ${this.stackStat.toString2(denominator)} \n\n ${magicsStr}
            `;
        }
    }
    // 记录上条json时间 主要为了计算技能释放间隔, 在前面的init部分初始化
    let lastTime = 0;
    // 最近的战斗记录
    let lastBattle = {};
    //失败的战斗记录
    let lossBattle = {};
    //总战斗次数 好像没啥用
    let totalBattles =  0;
    //是否是连接后的第一场战斗 (去除不完整部分)
    let firstBattle = true;
    // 处理 battle searching 的时间统计
    const searchTime = new StatTracker();

    let totalWins = 0;        // 胜利总次数
    let totalLosses = 0;      // 失败总次数
    //战斗时间数据统计
    const battleTimeStat = new StatTracker();
    // 战斗时长记录 根据稀有度分类
    const battleTimeStatByRarity = new StatTrackerByRarity();
    //经验值数据统计
    const expStats =  new StatTracker();
    // 经验值分稀有度(好像没办法获取单个怪物经验)

    // 敌人数 生命值 es 统计
    const enemyCount = new StatTracker();
    const enemyHp = new StatTracker();
    const enemyEs = new StatTracker();

    // 敌人数按稀有度分类
    const enemyCountByRarity = new StatTrackerByRarity();
    const enemyHpByRarity = new StatTrackerByRarity();
    const enemyEsByRarity = new StatTrackerByRarity();

    const healStatsBySkill = {};  // 治疗技能统计
    const playerSkillStats = {};  // 所有玩家技能
    const enemySkillStats = {}; //敌人所有技能
    const playerBuffStats = {}; //所有玩家buff
    const enemyBuffStats = {}; //所有敌人buff
    const totalDamageByType = new StatTrackerByType();  // 所有技能总的按类型统计
    const takenDamageByType = new StatTrackerByType();  // 受到伤害按类型统计
    const absorbedDamage = new StatTracker();

    let extraSearchingTime = 5000;

    function connectSSEWithAuth({url, token, onMessage, onError, retryInterval = 3000}) {
        let controller = null;
        let isStopped = false;
        let heartbeatTimer = null;
        let lastMessageTime = Date.now();
        const heartbeatInterval = 5000;
        const maxSilentTime = 5000;

        let hasConnectedOnce = false; // ✅ 新增：是否曾经成功连接过
        let hasConnectedThisTime = false; // ✅ 当前连接是否已成功

        function clearHeartbeat() {
            if (heartbeatTimer) {
                clearInterval(heartbeatTimer);
                heartbeatTimer = null;
            }
        }

        function start() {
            controller = new AbortController();
            lastMessageTime = Date.now();
            hasConnectedThisTime = false; // ✅ 重置本轮连接状态

            fetch(url, {
                method: "GET",
                headers: {
                    Authorization: `Bearer ${token}`,
                    Accept: "text/event-stream"
                },
                signal: controller.signal
            }).then(response => {
                if (response.status === 401) {
                    myLog.error("❌ ERROR: 授权失败（401 Unauthorized）");
                    onError?.(new Error("Unauthorized"));
                    updateBtnStatus("disconnected");
                    return;
                }

                if (!response.ok) {
                    myLog.error(`❌ ERROR: HTTP状态错误 ${response.status}`);
                    onError?.(new Error(`Connection failed: ${response.status}`));
                    updateBtnStatus("disconnected");
                    retry();
                    return;
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");

                function read() {
                    reader.read().then(({done, value}) => {
                        if (done) {
                            myLog.warn("⚠️ DISCONNECTED (auto): 服务器主动关闭连接，准备重连...");
                            updateBtnStatus("disconnected");
                            clearHeartbeat();
                            retry();
                            return;
                        }

                        const text = decoder.decode(value, {stream: true});
                        lastMessageTime = Date.now();

                        // ✅ 第一次收到消息，认为连接已成功
                        if (!hasConnectedThisTime) {
                            hasConnectedThisTime = true;

                            if (!hasConnectedOnce) {
                                myLog.log("✅ 连接成功, 可点击统计分析获取数据");
                            } else {
                                myLog.log("🔁 重连成功");
                            }
                            hasConnectedOnce = true;
                            updateBtnStatus("connected");
                        }

                        onMessage?.({event: "message", data: text.trim()});
                        read(); // 继续监听
                    }).catch(err => {
                        if (err.name === 'AbortError') return;
                        myLog.error(`❌ ERROR: 数据读取失败: ${err.message}`);
                        onError?.(err);
                        clearHeartbeat();
                        retry();
                    });
                }

                // 启动静默检测
                clearHeartbeat();
                heartbeatTimer = setInterval(() => {
                    const silentFor = Date.now() - lastMessageTime;
                    if (silentFor > maxSilentTime + extraSearchingTime) {
                        myLog.warn(`⚠️ ${silentFor / 1000}s 未收到消息，尝试重连...`);
                        controller?.abort(); // 触发 catch 或 retry
                        clearHeartbeat();
                        retry();
                    }
                }, heartbeatInterval);

                read();
            }).catch(err => {
                myLog.error(`❌ ERROR: 请求连接失败 - ${err.message}`);
                onError?.(err);
                clearHeartbeat();
                retry();
            });
        }

        function retry() {
            if (isStopped) return;
            myLog.log(`🔁 ${retryInterval / 1000}s 后重试连接...`);
            updateBtnStatus("connecting");
            setTimeout(start, retryInterval);
        }

        start();

        return {
            stop() {
                isStopped = true;
                controller?.abort();
                clearHeartbeat();
                updateBtnStatus("disconnected");
                myLog.log("🛑 DISCONNECTED (manual): 手动断开连接");
            }
        };
    }


    let sseConnection = null;

    function startSSE() {
        if (sseConnection) {
            myLog.warn("⚠️ 已经建立连接，无需重复连接！");
            return;
        }

        myLog.log("🔌 正在尝试连接战斗数据服务中，请稍候...");
        updateBtnStatus("connecting");
        firstBattle = true;

        const timeoutMs = 10_000;
        let hasConnected = false;

        const timeoutId = setTimeout(() => {
            if (!hasConnected) {
                myLog.error(`⏱️ 连接超时！${timeoutMs / 1000} 秒未收到响应`);
                stopSSE(); // 确保断开连接
            }
        }, timeoutMs);

        sseConnection = connectSSEWithAuth({
            url: "https://poe.faith.wang/api/battle/sse",
            token,
            onMessage: ({event, data}) => {
                if (!hasConnected) {
                    hasConnected = true;
                    clearTimeout(timeoutId);
                    // ✅ 不再重复 updateBtnStatus，这个已在 connectSSEWithAuth 中处理
                }

                try {
                    const {dataList} = parseSSEChunk(data);
                    dataList.forEach(json => analyzeBattleType(json));
                } catch (e) {
                    myLog.error(`❌ 单条数据解析错误：${e}`);
                    console.log(parseSSEChunk(data));
                }
            },
            onError: (err) => {
                myLog.error(`[${new Date().toLocaleString()}] ❌ SSE连接失败:\n`, err);
                updateBtnStatus("disconnected");
            }
        });
    }

    function stopSSE() {
        if (sseConnection) {
            sseConnection.stop();
            sseConnection = null;
            myLog.log("🛑 已断开连接");
            updateBtnStatus("disconnected");
        } else {
            myLog.warn("⚠️ 当前没有活动连接");
        }
    }

    //ssechunk 解析工具
    function parseSSEChunk(chunkText) {
        const lines = chunkText.split("\n");
        let event = "message";  // 默认事件名
        let dataLines = [];

        for (const line of lines) {
            if (line.startsWith("event:")) {
                event = line.slice(6).trim();
            } else if (line.startsWith("data:")) {
                dataLines.push(line.slice(5).trim());
            }
            // 忽略其他行（如id:、retry:）
        }

        const dataStr = dataLines.join("\n");
        const parsedObjects = extractJSONObjects(dataStr);

        return {event, dataList: parsedObjects, rawData: dataStr};
    }

    //处理可能包含的多个json对象
    function extractJSONObjects(text) {
        const objects = [];
        let depth = 0;
        let start = -1;

        for (let i = 0; i < text.length; i++) {
            if (text[i] === '{') {
                if (depth === 0) start = i;
                depth++;
            } else if (text[i] === '}') {
                depth--;
                if (depth === 0 && start !== -1) {
                    const jsonStr = text.slice(start, i + 1);
                    try {
                        objects.push(JSON.parse(jsonStr));
                    } catch (e) {
                        myLog.warn("⚠️ JSON 解析失败:", jsonStr);
                    }
                    start = -1;
                }
            }
        }

        return objects;
    }

        // 配置参数
        const MAX_LOSS_BATTLE_RECORDS = 20; // 最多保存的失败战斗记录数
        const MAX_LAST_BATTLE_TIME = 6 * 60 * 1000; // 6分钟未结算的战斗自动清理

// 定时清理函数
        function setupBattleCleanup() {
            // 每隔一段时间清理一次未结算的战斗记录
            setInterval(() => {
                const now = Date.now();
                for (const battleId in lastBattle) {
                    const battle = lastBattle[battleId];
                    // 清理超过6分钟未结算的战斗
                    if (now - battle.startTime > MAX_LAST_BATTLE_TIME) {
                        myLog.warn(`自动清理战斗详情: ${battleId}`);
                        delete lastBattle[battleId];
                    }
                }
            }, MAX_LAST_BATTLE_TIME); // 6分钟检查一次

            // 每30分钟清理一次旧失败记录
            setInterval(() => {
                cleanupLossBattle();
            }, 30 * 60 * 1000); // 30分钟清理一次
        }

// 清理旧失败记录
        function cleanupLossBattle() {
            const keys = Object.keys(lossBattle);
            if (keys.length > MAX_LOSS_BATTLE_RECORDS) {
                // 按时间排序（最早的在前面）
                keys.sort((a, b) => lossBattle[a].endTime - lossBattle[b].endTime);

                // 计算需要删除的数量
                const deleteCount = keys.length - MAX_LOSS_BATTLE_RECORDS;
                for (let i = 0; i < deleteCount; i++) {
                    const id = keys[i];
                    //myLog.log(`清理旧失败记录: ${id}`);
                    delete lossBattle[id];
                }
            }
        }

// 在程序初始化时调用
        setupBattleCleanup();


    /**
     * 根据传入的战斗相关 JSON 数据类型，调用对应的分析函数。
     * 用于区分：寻路、初始化、战斗事件、结算等不同阶段的数据。
     *
     * @param {Object} json - 一条战斗相关的数据记录（来源于日志）
     *    可包含字段：
     *      - battleId        : 标识战斗阶段（没有时代表寻路）
     *      - isWin           : 战斗结算标志（true/false）
     *      - targets         : 战斗过程中的目标数据（攻击对象等）
     */
    function analyzeBattleType(json) {
// 修改后的核心逻辑
        if (json.battleId === undefined) {
            analyzeBattleSearching(json);
            let searchTime = json.time;
            extraSearchingTime = searchTime;
            lastTime = 0;
        }
        else if (firstBattle) {
            // 跳过处理
        }
        else if (json.totalTime !== undefined) {
            const battleId = json.battleId;
            // 战斗结算处理
            analyzeBattleResult(json);
            // 战斗结算处理, 统计遇怪时间
            let rightTeam = lastBattle[battleId][0].rightTeam;
            let rarity = new Set(rightTeam.map(one => one.rarity));
            rarity.forEach(r => battleTimeStatByRarity.update(r, json.totalTime));


            if (lastBattle[battleId]) {
                // 添加结算事件
                lastBattle[battleId].push(json);

                // 记录结束时间（用于后续清理）
                lastBattle[battleId].endTime = Date.now();

                if (!json.isWin) {
                    // 记录失败战斗
                    myLog.group("战斗失败! 详细战斗日志:");
                    _analyzeLoss(lastBattle[battleId]);
                    myLog.groupEnd();

                    // 保存失败记录
                    lossBattle[battleId] = lastBattle[battleId];
                    // 记录结束时间（用于后续清理）
                    lossBattle[battleId].endTime = Date.now();

                    // 检查是否需要清理旧记录
                    if (Object.keys(lossBattle).length > MAX_LOSS_BATTLE_RECORDS) {
                        cleanupLossBattle();
                    }
                }
            }

            if (printNextDetail){
                myLog.array(lastBattle[battleId]);
                console.log(lastBattle[battleId]);
                printNextDetail = false;
            }

            // 无论胜败，清理战斗记录
            delete lastBattle[battleId];
        }
        else if (json.targets !== undefined) {
            // 战斗事件处理
            analyzeBattleEvent(json);

            const battleId = json.battleId;
            if (lastBattle[battleId]) {
                lastBattle[battleId].push(json);
            }
        }
        else {
            // 战斗初始化
            const battleId = json.battleId;

            // 清理可能存在的旧记录
            if (lastBattle[battleId]) {
                delete lastBattle[battleId];
            }

            // 创建新战斗记录
            lastBattle[battleId] = [json];
            // 记录开始时间（用于超时清理）
            lastBattle[battleId].startTime = Date.now();
            analyzeBattleInit(json);
        }
    }

    /**
     * 分析一次战斗搜索所用时间，并更新平均值、最小值和最大值
     * @param {Object} json - 包含搜索时间的对象，需包含 json.time 字段
     */
    function analyzeBattleSearching(json) {
        searchTime.update(json.time / 1000)
        // 增加总战斗数
        totalBattles++;
        firstBattle = false;
    }

    function analyzeBattleInit(json) {
        //获取敌人数组
        const enemies = json.rightTeam;
        //更新敌人数量
        enemyCount.update(enemies.length);
        //新建数据  根据稀有度统计数量
        let enemyCountArray = [0,0,0,0,0];
        //遍历敌人, 获取其生命,es信息
        enemies.forEach(enemy => {
            const { hpMax, esMax, rarity } = enemy;

            // 统计 ES 值（有esMax即视为存在ES）
            if (esMax !== undefined) {
                enemyEs.update(esMax);
                enemyEsByRarity.update(rarity,esMax)
            }

            // 统计 HP 值
            enemyHp.update(hpMax);
            enemyHpByRarity.update(rarity,hpMax);
            enemyCountArray[rarity] += 1;
        });
        //统计数量
        for (let i = 0; i < enemyCountArray.length; i++) {
            enemyCountByRarity.update(i,enemyCountArray[i])
        }
    }


    // 处理 battle result（战斗结果）的时间、胜负、经验统计

    /**
     * 分析单场战斗的结果并更新统计信息
     * @param {Object} json - 包含战斗数据的 JSON 对象
     *    json.isWin         - 是否胜利（true/false）
     *    json.totalTime     - 战斗时长
     *    json.trophy.exp    - 战斗获得的经验值（数值）
     */
    function analyzeBattleResult(json) {
        // 判断胜负
        if (json.isWin) {
            totalWins++;
        } else {
            totalLosses++;
        }

        // 读取战斗时长与经验值
        battleTimeStat.update(json.totalTime);
        expStats.update(json.trophy?.exp ?? 0) // 安全读取 trophy.exp，默认值为 0

        //todo 分析掉落
    }
    //分析造成伤害
    function _analyzeDamage(target, skillName, stoneId = "") {
        // 生成唯一键，避免同名技能冲突
        const key = `${skillName}::${stoneId}`;
        if (!playerSkillStats[key]) {
            playerSkillStats[key] = new SkillStat(skillName,stoneId);
        }

        const isCrit = !!target.isCritical;
        const totalDamage = target.totalDamage ?? 0;
        const damageByType = target.damages ?? {};

        playerSkillStats[key].updateDamage(totalDamage, damageByType, isCrit);

        // 更新总类型统计
        for (const type in damageByType) {
            totalDamageByType.update(parseInt(type), damageByType[type]);
        }
    }
    //分析玩家技能
    function  _analyzeSkill(targets, skillName, stoneId = skillName, interval){
        // 生成唯一键，避免同名技能冲突
        const key = `${skillName}::${stoneId}`;
        if (!playerSkillStats[key]) {
            playerSkillStats[key] = new SkillStat(skillName,stoneId);
        }
        playerSkillStats[key].updateInterval(targets.length, interval);
    }
    //分析治疗
    function _analyzeHeal(target, skillName) {
        if (!healStatsBySkill[skillName]) {
            healStatsBySkill[skillName] = new StatTracker();
        }
        healStatsBySkill[skillName].update(target.totalHeal);
    }
    //分析承受伤害
    function _analyzeTaken(target,skillName){
        if (!enemySkillStats[skillName]) {
            enemySkillStats[skillName] = new SkillStat(skillName);
        }
        const isCrit = !!target.isCritical; // 转换为布尔值，确保可靠
        enemySkillStats[skillName].updateDamage(target.totalDamage, target.damages, isCrit);
        //计算被吸收的伤害
        if (target.absorbed !== undefined){
            absorbedDamage.update(target.absorbed);
        }

        // 总体统计也记录
        for (const type in target.damages) {
            takenDamageByType.update(parseInt(type), target.damages[type]);
        }
    }
    //分析增益
    function _analyzePlayerBuff(buffs){
        let headHunterBuff = [];
        buffs.forEach(buff => {
            let key = buff.name;
            //特殊处理猎首buff
            if (key.includes("猎首")){
                headHunterBuff.push(buff);
            }else if(key.includes("奉献地面")){
                //单独处理奉献地面
            }else{
                if (!playerBuffStats[key]){
                    playerBuffStats[key] = new BuffStat(key,buff.type);
                }
                //buff层数
                playerBuffStats[key].update(buff.stacks ?? 1);
                if (buff.magics && typeof buff.magics === "object"){
                    // 遍历魔法效果
                    Object.entries(buff.magics).forEach(([magicKey, magicValues]) => {
                        //magicValues为一个只有一个数字的数组
                        playerBuffStats[key].updateMagic(magicKey,magicValues[0]);
                    });
                }
            }
        })

        //特殊处理猎首buff
        const headHunterKey = "猎首:窃取词缀";
        const headHunterType = 1;
        if (headHunterBuff.length > 0){
            if (!playerBuffStats[headHunterKey]){
                playerBuffStats[headHunterKey] = new BuffStat(headHunterKey,headHunterType);
            }
            //buff层数
            playerBuffStats[headHunterKey].update(headHunterBuff.length);
            //magic效果合并
            let headHunterMagics = {};
            headHunterBuff.forEach(buff =>{
                if (buff.magics && typeof buff.magics === "object"){
                    // 遍历所有猎首buff的魔法效果
                    Object.entries(buff.magics).forEach(([magicKey, magicValues]) => {
                        //magicValues为一个只有一个数字的数组
                        if (headHunterMagics[magicKey]){
                            headHunterMagics[magicKey] += magicValues[0];
                        } else {
                            headHunterMagics[magicKey] = magicValues[0];
                        }
                    });
                }
            });
            // 遍历合并后的魔法效果
            Object.entries(headHunterMagics).forEach(([magicKey, magicValues]) => {
                //magic为一个只有一个数字的数组
                playerBuffStats[headHunterKey].updateMagic(magicKey,magicValues);
            });
        }
    }
    function _analyzeEnemyBuff(buffs){
        BATTLE_ENEMY_INFO_COUNT++
        if (buffs !== undefined && Array.isArray(buffs)){
            buffs.forEach(buff => {
                let key = buff.name;
                if (!enemyBuffStats[key]){
                    enemyBuffStats[key] = new BuffStat(key,buff.type);
                }
                //buff层数
                enemyBuffStats[key].update(buff.stacks ?? 1);
                if (buff.magics && typeof buff.magics === "object"){
                    // 遍历魔法效果
                    Object.entries(buff.magics).forEach(([magicKey, magicValues]) => {
                        //magicValues为一个只有一个数字的数组
                        enemyBuffStats[key].updateMagic(magicKey,magicValues[0]);
                    });
                }
            })
        }
    }

    //分析战斗事件
    function analyzeBattleEvent(json) {
        //所有事件都统计buff
        BATTLE_INFO_COUNT++;
        _analyzePlayerBuff(json.leftTeam[0].buffs);
        const enemies = json.rightTeam;
        if (enemies !== undefined && Array.isArray(enemies)){
            enemies.forEach(enemy => {
                _analyzeEnemyBuff(enemy.buffs);
            })
        }

        //没有攻击来源的伤害
        if (json.actor === undefined) {
            // DOT
            json.targets.forEach(target => {
                if (target.name !== playerId) {
                    _analyzeDamage(target, target.reason);
                }else if (target.damages !== undefined && target.damages !== null){
                    _analyzeTaken(target, target.reason);
                }else {
                    //todo 奉献地面治疗效果等
                }
            });
        } else if (json.actor.name === playerId) {
            let skillName;
            let skillId;
            if (json.skill !== undefined){
                // 主动技能
                skillName = json.skill.name;
                skillId = json.skill.stoneId;
                _analyzeSkill(json.targets,skillName,skillId,json.time-lastTime);
                lastTime = json.time;
                json.targets.forEach(target => {
                    if (target.name === playerId) {
                        // 治疗自己
                        if (target.totalHeal !== undefined) {
                            _analyzeHeal(target, skillName);
                        }
                    } else {
                        //玩家使用伤害技能
                        _analyzeDamage(target, skillName,skillId);
                    }
                });
            }else {
                // 非主动技能
                json.targets.forEach(target => {
                    if (target.name === playerId) {
                        skillName = target.reason;
                        // 治疗自己
                        if (target.totalHeal !== undefined) {
                            _analyzeHeal(target, skillName);
                        }
                    } else {
                        skillName = target.reason;
                        //玩家造成伤害事件
                        _analyzeDamage(target, skillName);
                    }
                });
            }
        } else if(json.targets !== null && json.targets !== undefined){
            // 敌人造成伤害
            if (json.targets[0].name === playerId){
                _analyzeTaken(json.targets[0],json.skill.name)
            }
        } else {
            console.log(json);
            throw new Error("无法解析的战斗数据");
        }
    }

    //展示数据
    function showData() {
        if (totalBattles <= 1){
            myLog.log("🔮 目前数据不足, 需获取数据且等待至少一场战斗结束...");
            return
        }
        const size = Object.keys(lossBattle).reduce((total, key) => {
            return total + lossBattle[key].length;
        }, 0);

        if (size > 100000) {
            myLog.log(`🛰️ 数据量极多，正在分析海量战斗记录 (可能需要十五分钟或更久)`);
        } else if (size > 10000) {
            myLog.log(`🧬 数据量较大，正在分析与渲染，喝口水缓一缓 ☕(可能需要数分钟)`);
        } else if (size > 1000) {
            myLog.log(`🔍 正在分析与渲染数据中, 请稍等...`);
        } else if (size > 100) {
            myLog.log(`⌛ 快速分析中`);
        }

        myLog.group(`📊 基本统计（🕒 ${new Date().toLocaleString()}）=================`);

        const total = totalWins + totalLosses;
        const winRate = total > 0 ? (totalWins / total * 100).toFixed(2) : "N/A";

        myLog.log(`${playerClassEmj} 玩家: ${playerId}`);
        myLog.log(`🎖️ 总战斗场数: ${total}`);
        myLog.log(`✅ 胜利: ${totalWins} 次 | ❌ 失败: ${totalLosses} 次 | 🏆 胜率: ${winRate}%`);
        myLog.log(`⏳ 寻路时间: ${searchTime.toString()}`);
        myLog.log(`🧭 战斗时间: ${battleTimeStat.toString()}`);
        myLog.log(`⭐ 获取经验: ${expStats.toString()}`);
        myLog.groupEnd();

        if(lossBattle && Object.keys(lossBattle).length > 0){
            myLog.group("死亡回放");
            Object.values(lossBattle).forEach(battle => {
                _analyzeLoss(battle);
            });
            myLog.groupEnd();
        }

        myLog.group("=== 玩家造成伤害 ============================================================================");
        myLog.group("▶ 造成伤害分来源统计");
        for (const [name, stat] of Object.entries(playerSkillStats)) {
            myLog.log(stat.toString());
            myLog.log("\n");
        }
        myLog.groupEnd();

        myLog.group("▶ 造成伤害分类型统计--------------------------------------");
        myLog.log(totalDamageByType.toString());
        myLog.groupEnd();
        myLog.groupEnd();

        myLog.group("=== 玩家承受伤害 ============================================================================");
        myLog.group("▶ 承受伤害分类型统计");
        myLog.log(takenDamageByType.toString());
        myLog.groupEnd();
        myLog.groupEnd();

        myLog.group("=== 敌人技能伤害 ============================================================================");
        for (const [name, stat] of Object.entries(enemySkillStats)) {
            myLog.log(stat.toString());
        }
        myLog.groupEnd();

        myLog.group("=== 敌人信息统计 ============================================================================");
        myLog.group("▶ 数量--------------------------------------------------");
        myLog.log(enemyCountByRarity.toString());
        myLog.groupEnd();

        myLog.group("▶ 生命值统计(HP)-----------------------------------------");
        myLog.log(enemyHpByRarity.toString());
        myLog.groupEnd();

        myLog.group("▶ 能量护盾统计(ES)----------------------------------------");
        myLog.log(enemyEsByRarity.toString());
        myLog.groupEnd();

        myLog.group("▶ 战斗时长统计--------------------------------------------");
        myLog.log(battleTimeStatByRarity.toString());
        myLog.groupEnd();

        myLog.groupEnd();

        //todo 增益减益统计
        myLog.group("=== 玩家buff统计 ============================================================================");
        for (const [name, stat] of Object.entries(playerBuffStats)) {
            myLog.group()
            myLog.log(stat.toString(BATTLE_INFO_COUNT));
            myLog.groupEnd()
        }
        myLog.groupEnd();

        //todo 敌人增益减益统计
        myLog.group("=== 敌人buff统计 ============================================================================");
        for (const [name, stat] of Object.entries(enemyBuffStats)) {
            myLog.group()
            myLog.log(stat.toString(BATTLE_ENEMY_INFO_COUNT));
            myLog.groupEnd()
        }
        myLog.groupEnd();
        myLog.log("\n\n");
    }

    //死亡回放显示
    function _analyzeLoss(lossJsonArray) {
        myLog.array(lossJsonArray);
        const finalScene = lossJsonArray[lossJsonArray.length - 2];

        myLog.group(`📉 失败战斗分析 (🆔 battleId: ${finalScene.battleId})`);
        myLog.logWithScroll(`🎭 最后行动角色: ${finalScene.actor?finalScene.actor.name:null}`);
        myLog.logWithScroll(`🧪 使用技能: ${finalScene.skill?finalScene.skill.name:null}`);
        //展示最后一击
        const targets = finalScene.targets;
        for (let i = 0; i < targets.length; i++) {
            const target = targets[i];
            myLog.group(`🎯 技能目标: ${target.name}`);
            if (target.reason !== undefined && target.reason !== null && target.reason !== ''){
                myLog.logWithScroll(`❓ 原因: ${target.reason}`)
            }

            const isCrit = !!target.isCritical;
            const critText = isCrit ? " 💥暴击" : " ❌未暴击";

            if (target.damages !== undefined && target.damages !== null) {
                const finalDamageStat = new StatTrackerByType();
                for (const type in target.damages) {
                    const dmg = target.damages[type];
                    if (typeof dmg === "number" && !isNaN(dmg)) {
                        finalDamageStat.update(parseInt(type), dmg);
                    }
                }

                myLog.logWithScroll(`🧨 技能${critText}，造成的伤害如下:\n${finalDamageStat.toString()}`);
            } else {
                myLog.logWithScroll("⚠️ 未记录伤害数据");
            }

            myLog.groupEnd();
        }
        //展示敌方队伍 rightTeam 是敌人 数组
        myLog.group(`👹 敌方队伍详细信息`)
        const rightTeam = finalScene.rightTeam;
        rightTeam.forEach(enemy => {
            const rarityEmoji = rarityLabels[enemy.rarity] || "❓ 未知";

            const isDead = enemy.hp === 0;
            const deathEmoji = isDead ? "🪦" : "";

            const name = enemy.name || "（无名）";
            const nameWithDeath = `${deathEmoji}${name}`;

            // 第一行: 稀有度 + 名字
            const line1 = `${rarityEmoji} ${nameWithDeath}`;

            // 第二行: ES 和 HP，用 | 分隔
            let line2Parts = [];
            if (enemy.hpMax !== undefined) {
                const hp = enemy.hp ?? 0;
                const hpPct = ((hp / enemy.hpMax) * 100).toFixed(1);
                line2Parts.push(`❤️ HP: ${hp} / ${enemy.hpMax} (${hpPct}%)`);
            }
            if (enemy.esMax !== undefined) {
                const es = enemy.es ?? 0;
                const esPct = ((es / enemy.esMax) * 100).toFixed(1);
                line2Parts.push(`🛡️ ES: ${es} / ${enemy.esMax} (${esPct}%)`);
            }
            const line2 = line2Parts.join(' | ');

            // 拼接两行，注意要换行
            myLog.logWithScroll(`   ${line1}\n\t\t\t\t\t\t${line2}`);
        });
        myLog.groupEnd();

        myLog.logWithScroll(`⏱️ 最终战斗时间: ${finalScene.time.toFixed(3)}`);
        myLog.groupEnd();
        myLog.logWithScroll("\n\n")
    }

    /**
     * 智能格式化数字：
     * - 如果是整数，无小数部分，直接显示整数。
     * - 如果数值 >= 10000，转为以 K（千）为单位显示。
     * - 根据数值大小智能决定保留几位小数：
     *   < 10 → 保留3位小数
     *   < 100 → 保留2位小数
     *   < 10000 → 保留1位小数
     *   >= 10000 → 使用 K 格式
     */
    function formatNumberSmart(value) {
        // 处理非有限数字（例如 NaN、Infinity）
        if (!isFinite(value)) return 'NaN';

        const absVal = Math.abs(value);

        // 单位换算优先级（T > B > M > K）
        if (absVal >= 1e12) {
            return `${formatWithPrecision(value / 1e12)}T`;
        } else if (absVal >= 1e9) {
            return `${formatWithPrecision(value / 1e9)}B`;
        } else if (absVal >= 1e6) {
            return `${formatWithPrecision(value / 1e6)}M`;
        } else if (absVal >= 1e3) {
            return `${formatWithPrecision(value / 1e3)}K`;
        }

        // 对小于 1e3 的数值，使用普通精度格式化
        return formatWithPrecision(value);

        /**
         * 根据数值的绝对值范围决定保留的小数位数：
         * <10 → 保留 3 位
         * <100 → 保留 2 位
         * <10000 → 保留 1 位
         * ≥10000 → 已处理过，不会触发这段代码
         */
        function formatWithPrecision(num) {
            const absNum = Math.abs(num);

            if (absNum < 10) {
                return num.toFixed(3);
            } else if (absNum < 100) {
                return num.toFixed(2);
            } else if (absNum < 1000) {
                return num.toFixed(1);
            } else {
                // 理论上不会执行到这里（已在主函数中处理 ≥10000）
                return Math.round(num).toString();
            }
        }
    }

    /**
     * 智能格式化字符串（单行，支持中文、英文、emoji 的自定义宽度比例）
     * 如果总宽度小于lineLength, 补空格至lineLength, 如果超过lineLength, 在字符串后加换行符
     * @param {string} str - 要格式化的字符串
     * @param {number} lineLength - 目标总宽度（基于宽度权重）
     * @param {object} [weights] - 可选宽度配置，例如：{ chinese: 2, latin: 1, emoji: 1.8 }
     * @returns {string} - 格式化后的字符串
     */
    function formatStringSmart(str, lineLength,extraSpace = 0, weights = { chinese: 5/3, latin: 1, emoji: 2 }) {
        if (typeof str !== "string") str = String(str ?? "");
        if (typeof lineLength !== "number" || lineLength <= 0) return str;

        const getCharWidth = (ch) => {
            if (/[\u{1F300}-\u{1FAFF}\u{2600}-\u27BF]/u.test(ch)) return weights.emoji; // emoji
            if (/[\u4E00-\u9FFF\u3000-\u303F\uFF00-\uFFEF]/.test(ch)) return weights.chinese; // 中文/全角
            return weights.latin; // 其他字符
        };

        const totalWidth = Array.from(str).reduce((sum, ch) => sum + getCharWidth(ch), 0);

        if (totalWidth > lineLength) {
            return str + "\n" + ' '.repeat(extraSpace+lineLength); // 超过 → 加换行符, 换行后补充空格
        } else if (totalWidth == lineLength) {
            return str; // 刚好 → 直接返回
        } else {
            //根据比例补全角和半角空格
            const fullWidthSpaceUnit = weights.chinese; // 用中文全角空格作为“最大单位”
            const remaining = (lineLength - totalWidth);
            const fullSpaces = Math.floor(remaining / fullWidthSpaceUnit);
            const halfSpaces = Math.round((remaining % fullWidthSpaceUnit) / weights.latin);
            return str + '\u3000'.repeat(fullSpaces) + ' '.repeat(halfSpaces);
        }
    }




    //绘制前端样式
    (() => {
        const theme = localStorage.getItem("combatPlugin_theme") ?? "dark";
        let currentTheme = theme;

        // ----- 样式注入 -----
        function injectStyle(theme) {
            const style = document.createElement('style');
            style.id = 'myLogStyle';
            style.textContent = `
      #myLogModal {
        background: ${theme === 'light' ? '#fafafa' : '#1e1e1e'};
        color: ${theme === 'light' ? '#222' : '#eee'};
        border: 2px solid ${theme === 'light' ? '#ccc' : '#666'};
        box-shadow: 0 0 10px ${theme === 'light' ? '#ccc' : '#000'};
        position: fixed;
        top: 5%;
        left: 5%;
        width: 90%;
        height: 90%;
        overflow-y: auto;
        font-family: Consolas, monospace;
        font-size: 13px;
        white-space: pre-wrap;
        user-select: text;
        border-radius: 6px;
        padding: 10px;
        display: none;
        z-index: 999999;
      }
      #myLogModal header {
        display: flex;
        justify-content: flex-end;
        height: 30px;
      }
      #myLogModal .myLog-group {
        border-left: 2px solid ${theme === 'light' ? '#bbb' : '#444'};
        margin-left: 16px;
        padding-left: 8px;
        margin-bottom: 4px;
      }
      #myLogModal .myLog-info { color: ${theme === 'light' ? '#007acc' : '#4fc3f7'}; }
      #myLogModal .myLog-warn { color: ${theme === 'light' ? '#b28500' : '#f9a825'}; }
      #myLogModal .myLog-error { color: ${theme === 'light' ? '#c62828' : '#e53935'}; }
      #myLogModal .myLog-debug { color: ${theme === 'light' ? '#4a90e2' : '#90caf9'}; }

      #myLogFloatingButtons {
        position: sticky;
        justify-content: space-between; /* 左右两侧分开 */
        top: 0;
        right: 0;
        display: flex;
        gap: 8px;
        width: 100%; /* 确保撑满容器宽度 */
        padding: 8px 10px;
        background: ${theme === 'light' ? '#fafafa' : '#1e1e1e'};
        border-bottom: 1px solid ${theme === 'light' ? '#ddd' : '#444'};
        z-index: 10002;
      }
      .myLog-left-buttons,
      .myLog-right-buttons {
          display: flex;
          gap: 8px;
      }
      #myLogFloatingButtons button {
        background: transparent;
        color: ${theme === 'light' ? '#333' : '#ccc'};
        border: none;
        padding: 6px 12px;
        font-size: 14px;
        border-radius: 6px;
        cursor: pointer;
        transition: 0.2s ease;
        opacity: 0.75;
      }
      #myLogFloatingButtons button:hover {
        opacity: 1;
        background: ${theme === 'light' ? 'rgba(0,0,0,0.05)' : 'rgba(255,255,255,0.1)'};
        color: ${theme === 'light' ? '#000' : '#fff'};
      }

      #logToggleBtn {
        position: fixed;
        top: 70px;  /* 在创建按钮后重新渲染位置了 */
        left: 210px;
        padding: 8px 16px;
        font-size: 14px;
        border-radius: 6px;
        cursor: pointer;
        z-index: 9999;
        background: ${theme === 'light' ? '#ddd' : '#333'};
        color: ${theme === 'light' ? '#222' : '#eee'};
        border: none;
      }
      #logToggleBtn:hover {
        background: ${theme === 'light' ? '#bbb' : '#555'};
      }
      
/* 主菜单容器 */
.menu {
  position: relative;
  display: flex; /* 保证与其他按钮风格一致 */
  align-items: center;
}

/* 主按钮样式 */
.menu > button {
  padding: 6px 16px;
  background: ${theme === 'light' ? '#e0e0e0' : '#2d2d2d'};
  border: 1px solid ${theme === 'light' ? '#bbb' : '#444'};
  color: ${theme === 'light' ? '#000' : '#fff'};
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.2s;
  white-space: nowrap;
}

.menu > button:hover {
  background-color: ${theme === 'light' ? '#d0d0d0' : '#3a3a3a'};
}

/* 下拉菜单 */
.dropdown {
  display: inline-block;
  position: absolute;
  top: 0;               /* 从按钮顶端对齐 */
  left: calc(100% + 4px);  /* 右侧浮出 */
  background: ${theme === 'light' ? '#ddd' : '#333'};
  color: ${theme === 'light' ? '#222' : '#eee'};
  border: 1px solid ${theme === 'light' ? '#ccc' : '#444'};
  border-radius: 6px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  min-width: 160px;       /* ✅ 控制宽度 */
  z-index: 10;
  padding: 2px 0;
  white-space: nowrap;
}

/* 下拉菜单项 */
.dropdown button {
  display: block;
  width: 100%;
  padding: 6px 12px;
  border: none;
  background: none;
  text-align: left;
  cursor: pointer;
  color: inherit;
  font-size: 13px;
}

.dropdown button:hover {
  background-color: ${theme === 'light' ? '#ccc' : '#444'};
}

/* 悬停显示 */
.menu:hover .dropdown {
  display: block;
}
      
    `;
            const old = document.getElementById('myLogStyle');
            if (old) old.remove();
            document.head.appendChild(style);

            // 给所有 .menu 元素添加延迟消失的悬停逻辑

            document.querySelectorAll('.menu').forEach(menu => {
                let hideTimer;

                const dropdown = menu.querySelector('.dropdown');
                dropdown.style.display = 'none'; // 初始化隐藏

                if (!dropdown) return;

                menu.addEventListener('mouseenter', () => {
                    clearTimeout(hideTimer);
                    dropdown.style.display = 'block';
                    dropdown.style.opacity = '1';
                });

                menu.addEventListener('mouseleave', () => {
                    clearTimeout(hideTimer);
                    hideTimer = setTimeout(() => {
                        dropdown.style.display = 'none';
                    }, 200); // ← 延迟 0.2 秒隐藏
                });
            });
        }

        // ----- DOM结构 -----
        const modal = document.createElement('div');
        modal.id = 'myLogModal';
        modal.innerHTML = `
    <div id="myLogFloatingButtons">
        <div class="myLog-left-buttons">
            <button id="btnAnalyzeBattle">📡 获取数据</button>
            <button id="btnPrintData">📊 统计分析</button>
            <button id="myLogClearBtn">🗑️ 清空面板</button>
            <div class="menu">
                <button>⚙️ 高级分析 ▸</button>
                    <div class="dropdown">
                        <button id="firstSkillBtn" style="display: none">🚫 特殊策略-首发技能</button>
                        <button id="magicAvgBtn">🔹 特殊策略-magic均值</button>
                        <button id="btnTest">👀 展示当前战斗原始数据</button>
                    </div>
            </div>
            <div class="menu">
                <button>🧩 其他功能 ▸</button>
                    <div class="dropdown">
                        <button id="positionBtn">🧊 调整位置</button>
                        <button id="updatelogBtn">ℹ️ 更新日志</button>
                        <button id="feedbackBtn">💬 反馈建议</button>
                    </div>
            </div>
        </div>
        <div class="myLog-right-buttons">
            <button id="myLogCloseBtn">❌ 关闭</button>
        </div>
    </div>
    <div id="myLogContent"></div>
  `;
        document.body.appendChild(modal);

        const content      = modal.querySelector('#myLogContent');
        const clearBtn     = modal.querySelector('#myLogClearBtn');
        const closeBtn     = modal.querySelector('#myLogCloseBtn');
        const analyzeBtn   = modal.querySelector('#btnAnalyzeBattle');
        const printBtn     = modal.querySelector('#btnPrintData');
        const btnTest      = modal.querySelector("#btnTest");
        const updatelogBtn = modal.querySelector("#updatelogBtn");
        const feedbackBtn  = modal.querySelector("#feedbackBtn");
        const positionBtn  = modal.querySelector("#positionBtn");
        const firstSkillBtn = modal.querySelector("#firstSkillBtn");
        const magicAvgBtn   = modal.querySelector("#magicAvgBtn");

        analyzeBtn.id = "_my_analyzeBtn";

// 创建按钮
        const toggleButton = document.createElement("button");
        toggleButton.id = "logToggleBtn";
        toggleButton.style.left = dragPostitionLeft;
        toggleButton.style.top = dragPostitionTop;
        toggleButton.textContent = "战斗分析";
        toggleButton.onclick = () => {
            modal.style.display = modal.style.display === 'block' ? 'none' : 'block';
            modal.scrollTop = modal.scrollHeight;
        };
        //拖拽逻辑实现
        let isDragging = false;
        let offsetX = 0;
        let offsetY = 0;
// 鼠标按下开始拖动
        toggleButton.addEventListener('mousedown', (e) => {
            if (!dragMode) return;
            isDragging = true;
            offsetX = e.clientX - toggleButton.offsetLeft;
            offsetY = e.clientY - toggleButton.offsetTop;
            toggleButton.style.transition = 'none';
        });

// 拖动中
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            let x = e.clientX - offsetX;
            let y = e.clientY - offsetY;

            // 限制在窗口内
            x = Math.max(0, Math.min(window.innerWidth - toggleButton.offsetWidth, x));
            y = Math.max(0, Math.min(window.innerHeight - toggleButton.offsetHeight, y));

            toggleButton.style.left = x + 'px';
            toggleButton.style.top = y + 'px';
        });

// 鼠标释放
        document.addEventListener('mouseup', () => {
            if (!isDragging) return;
            isDragging = false;
            toggleButton.style.transition = '';

            // 保存位置
            localStorage.setItem('combatPlugin_dragPostitionLeft', toggleButton.style.left);
            localStorage.setItem('combatPlugin_dragPostitionTop', toggleButton.style.top);
        });


        document.body.appendChild(toggleButton);

        // ----- 按钮功能 -----
        clearBtn.onclick = () => {
            content.innerHTML = '';
            logState.currentGroup = content;
        };
        closeBtn.onclick = () => modal.style.display = 'none';
        analyzeBtn.onclick = () => {
            if (sseConnection) {
                stopSSE();
            } else {
                startSSE?.();
            }
        };
        printBtn.onclick = () => {
            if (typeof showData === 'function') {
                showData();
            } else {
                myLog.warn("⚠️ showData 函数不存在");
            }
        };
        btnTest.onclick = () => {
            if (printNextDetail){
                myLog.logWithScroll("请开启获取数据并等待当前战斗结束")
            }else {
                printNextDetail = true;
            }
        };
        updatelogBtn.onclick = () => {
            myLog.group("v1.3")
            myLog.log("1. 新增增益/减益统计");
            myLog.log("2. 新增高级分析, magic均值显示策略/展示当前战斗原始数据");
            myLog.log("3. 新增其他功能, 调整外部按钮位置/查看版本更新日志/反馈建议");
            myLog.groupEnd()

            myLog.group("v1.029")
            myLog.log("完善非技能dps统计");
            myLog.groupEnd()

            myLog.group("v1.028")
            myLog.log("1. 优化显示效果");
            myLog.log("2. 完善断线重连");
            myLog.log("3. 显示命中率. 暴击率不再计算未命中");
            myLog.groupEnd()

            myLog.group("v1.021")
            myLog.log("改了下排版");
            myLog.groupEnd()

            myLog.group("v1.02")
            myLog.log("1. 回放增加敌方队伍显示");
            myLog.log("2. 优化伤害分类型显示, 没有的类型默认不显示");
            myLog.groupEnd()

            myLog.group("v1.001")
            myLog.log("略微优化显示数据, 提示更全面");
            myLog.groupEnd()

            myLog.group("v1.0")
            myLog.log("控制台打印数据改到模态框打印数据");
            myLog.groupEnd()

            myLog.group("v0.1")
            myLog.log("1. 战斗失败日志 回放最后一幕");
            myLog.log("2. 人物使用技能统计,伤害, 次数, dps");
            myLog.log("3. 玩家受到伤害统计");
            myLog.log("4. 遇怪分析, 怪物血量,护盾等");
            myLog.groupEnd()
        };
        feedbackBtn.onclick = () => {
            myLog.logWithScroll("直接群里@忆境脊弓");
        };
        positionBtn.onclick = () =>{
            dragMode = !dragMode;
            if (dragMode){
                myLog.logWithScroll("现在可以拖动调整外部[战斗分析]按钮位置, 再次点击[调整位置]后关闭拖动调整模式");
            }else {
                myLog.logWithScroll("拖动模式已经关闭, 位置已经记录")
            }
        };
        firstSkillBtn.onclick = () => {
            switch (firstSkillMode){
                case 0:{
                    firstSkillMode = 1;
                    myLog.logWithScroll("已切换至 只统计每场战斗的首次技能数据, 再次点击按钮以切换");
                    break;
                }
                case 1:{
                    firstSkillMode = -1;
                    myLog.logWithScroll("已切换至 不统计每场战斗的首次技能数据, 再次点击按钮以切换");
                    break;
                }
                case -1:{
                    firstSkillMode = 0;
                    myLog.logWithScroll("已切换至 默认模式, 再次点击按钮以切换");
                    break;
                }
            }
        };
        magicAvgBtn.onclick = () => {
            switch (magicAvgMode){
                case 1:{
                    magicAvgMode = 0;
                    localStorage.setItem('combatPlugin_magicAvgMode', magicAvgMode);
                    myLog.logWithScroll("已切换至 magic均值将乘覆盖率, 即显示有效均值(不影响buff的叠加层数均值), 再次点击按钮以切换");
                    break;
                }
                case 0:{
                    magicAvgMode = 1;
                    localStorage.setItem('combatPlugin_magicAvgMode', magicAvgMode);
                    myLog.logWithScroll("已切换至 magic均值直接显示, 即只计算有对应magic情况下的均值, 再次点击按钮以切换");
                    break;
                }
            }
        };


        // ----- 日志状态 -----
        const logState = {
            currentGroup: content,
            groupStack: [],
        };

        // 格式化日志参数
        function formatArg(arg) {
            if (typeof arg === 'string') return arg;
            try {
                return JSON.stringify(arg, null, 2);
            } catch {
                return String(arg);
            }
        }

        function outputLog(message, type = 'info',autoScroll = false) {
            const el = document.createElement('div');
            el.textContent = message;
            el.className = `myLog-${type}`;
            logState.currentGroup.appendChild(el);

            // 如果当前自动滚动才滚动到底部
            if (autoScroll) {
                modal.scrollTop = modal.scrollHeight;
            }
        }

        function formatArg(arg) {
            if (typeof arg === 'string') return arg;
            try {
                return JSON.stringify(arg, null, 2);
            } catch {
                return String(arg);
            }
        }

        // ----- myLog 接口 -----
        window.myLog = window.myLog = {
            setTheme(newTheme) {
                if (newTheme === 'dark' || newTheme === 'light') {
                    currentTheme = newTheme;
                    localStorage.setItem("theme", newTheme);
                    injectStyle(newTheme);
                }
            },
            info(...args){
                const msg = args.map(formatArg).join(' ');
                outputLog(msg, 'info',false);
            },
            log(...args) {
                const msg = args.map(formatArg).join(' ');
                outputLog(msg, 'info',false);
            },
            logWithScroll(...args) {
                const msg = args.map(formatArg).join(' ');
                outputLog(msg, 'info', true); // true 表示允许自动滚动
            },
            warn(...args) {
                const msg = args.map(formatArg).join(' ');
                outputLog(msg, 'warn');
            },
            error(...args) {
                const msg = args.map(formatArg).join(' ');
                outputLog(msg, 'error');
            },
            debug(...args) {
                const msg = args.map(formatArg).join(' ');
                outputLog(msg, 'debug',false);
            },
            group(title) {
                const group = document.createElement('div');
                group.className = 'myLog-group';
                const label = document.createElement('div');
                label.textContent = title;
                label.style.fontWeight = 'bold';
                group.appendChild(label);
                logState.currentGroup.appendChild(group);
                logState.groupStack.push(logState.currentGroup);
                logState.currentGroup = group;
            },
            groupEnd() {
                if (logState.groupStack.length > 0) {
                    logState.currentGroup = logState.groupStack.pop();
                }
            },
            // 新增 array 方法
            array(obj) {
                if (!logState.currentGroup) return;

                function renderCollapsible(data, level = 0) {
                    const container = document.createElement('div');
                    container.style.marginLeft = level * 12 + 'px';
                    container.style.fontFamily = 'monospace';

                    if (typeof data !== 'object' || data === null) {
                        container.textContent = String(data);
                        return container;
                    }

                    const isArray = Array.isArray(data);
                    const summary = document.createElement('div');
                    summary.style.cursor = 'pointer';
                    summary.style.userSelect = 'none';
                    summary.style.fontWeight = 'bold';
                    summary.textContent = isArray ? `Array(${data.length})` : 'Object';

                    const content = document.createElement('div');
                    content.style.display = isArray ? 'none' : 'block'; // ✅ 关键修改：数组默认折叠，对象默认展开
                    content.style.marginLeft = '12px';

                    summary.onclick = () => {
                        content.style.display = content.style.display === 'none' ? 'block' : 'none';
                    };

                    container.appendChild(summary);
                    container.appendChild(content);

                    if (isArray) {
                        data.forEach((item, idx) => {
                            const child = renderCollapsible(item, level + 1);
                            const wrapper = document.createElement('div');
                            wrapper.style.display = 'flex';

                            const indexSpan = document.createElement('span');
                            indexSpan.textContent = idx + ': ';
                            indexSpan.style.fontWeight = 'normal';
                            indexSpan.style.marginRight = '6px';

                            wrapper.appendChild(indexSpan);
                            wrapper.appendChild(child);
                            content.appendChild(wrapper);
                        });
                    } else {
                        for (const key in data) {
                            if (!Object.hasOwnProperty.call(data, key)) continue;

                            const child = renderCollapsible(data[key], level + 1);
                            const wrapper = document.createElement('div');

                            const keySpan = document.createElement('span');
                            keySpan.textContent = `${key}: `;
                            keySpan.style.fontWeight = 'normal';
                            keySpan.style.marginRight = '6px';

                            wrapper.appendChild(keySpan);
                            wrapper.appendChild(child);
                            content.appendChild(wrapper);
                        }
                    }

                    return container;
                }

                const el = document.createElement('div');
                el.className = 'myLog-info';
                el.appendChild(renderCollapsible(obj));
                logState.currentGroup.appendChild(el);

                const modal = document.getElementById('myLogModal');
                if (modal) modal.scrollTop = modal.scrollHeight;
            }

        };


        // 初始化样式
        injectStyle(currentTheme);
    })();

    function updateBtnStatus(status) {
        _updateToggleButtonEmoji(status);
        const analyzeBtn = document.getElementById("_my_analyzeBtn");
        const textMap = {
            connected: '🛑 停止获取',
            disconnected: '📡 获取数据',
            connecting: '🟡 连接中',
            null: ''
        }
        const text = textMap[status] || '📡 获取数据';
        analyzeBtn.textContent = text;
    }
    function _updateToggleButtonEmoji(status) {
        const emojiMap = {
            connected: '🟢',
            disconnected: '',
            connecting: '🟡',
            null: ''
        };
        const emoji = emojiMap[status] || '';
        const toggleButton = document.getElementById("logToggleBtn");
        toggleButton.textContent = `${emoji} 战斗分析`;
    }
})();