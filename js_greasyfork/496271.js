// ==UserScript==
// @name        Duellstat
// @name:de     Clothcache (früher Duellstat)
// @name:en     Clothcache (ex-Duellstat)
// @name:es     Caché de Ropas (antes Duellstat)
// @author      xyzabcd
// @namespace   xyzabcd
// @description create a duell statistik
// @description:de traducción alemán
// @description:es traducción español
// @include https://*.the-west.*/game.php*
// @include https://*.tw.innogames.*/game.php*

// @version     v0.73-2
// @grant       none
// @downloadURL https://update.greasyfork.org/scripts/496271/Duellstat.user.js
// @updateURL https://update.greasyfork.org/scripts/496271/Duellstat.meta.js
// ==/UserScript==

(function(fn) {
  var script = document.createElement('script');
  script.setAttribute('type', 'application/javascript');
  script.textContent = '(' + fn + ')();';
  document.body.appendChild(script);
  document.body.removeChild(script);
})(function() {
const TWDS = { }

TWDS.scriptname = 'Caché de Ropas'
TWDS.scriptnameTitle = 'Caché de Ropas'
TWDS.scriptnameMiniTitle = 'Caché de Ropas'
TWDS.window = null
TWDS.settings = null
TWDS.lfd = 0
TWDS.baseURL = 'https://ohse.de/uwe/tw-duellstat/'
TWDS.version = 'v0.73-2'
TWDS.crafting = null // to be filled by main.js - async, so don't expect it to be filled.

// a hash function. Source: https://stackoverflow.com/a/52171480
// doesn't work with IE11. Too bad.
TWDS.cyrb53 = function cyrb53 (str, seed = 0) {
  let h1 = 0xdeadbeef ^ seed; let
    h2 = 0x41c6ce57 ^ seed
  for (let i = 0, ch; i < str.length; i++) {
    ch = str.charCodeAt(i)
    h1 = Math.imul(h1 ^ ch, 2654435761)
    h2 = Math.imul(h2 ^ ch, 1597334677)
  }
  h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909)
  h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909)
  return 4294967296 * (2097151 & h2) + (h1 >>> 0)
}

TWDS.createTab = function (k) {
  const div = document.createElement('div')
  div.style = 'display:none; overflow: hidden'
  div.id = 'TWDS_tab_' + k
  div.className = 'TWDS_tabcontent'
  return div
}
TWDS.knownTabs = {}
TWDS.registerTab = function (key, title, contentFunc, actiFunc, isDefault = false) {
  const o = {
    key: key,
    title: title,
    contentFunc: contentFunc,
    activationFunc: actiFunc,
    isDefault: isDefault
  }
  TWDS.knownTabs[key] = o
}
TWDS.activateTab = function (k) {
  const tabData = TWDS.knownTabs[k]
  if (typeof tabData === 'undefined') return

  const id = 'TWDS_tab_' + k
  const div = document.getElementById(id)
  div.innerHTML = ''
  div.appendChild(tabData.contentFunc())

  $('.TWDS_tabcontent').hide()
  $('.tw2gui_window_tab_active', TWDS.window.getMainDiv())
    .removeClass('tw2gui_window_tab_active')
  $('.TWDS_tabcontent').closest('.tw2gui_scrollpane').hide()
  $('#TWDS_tab_' + k).show()
  $('#TWDS_tab_' + k).closest('.tw2gui_scrollpane').show()
  $('._tab_id_' + k, TWDS.window.getMainDiv())
    .addClass('tw2gui_window_tab_active')
}
TWDS.startFunctions = []
TWDS.registerStartFunc = function (x) {
  TWDS.startFunctions.push(x)
}
// this is a hack for the developer.
TWDS.reload = function (x, y) {
  let u
  if (x.length === 2) {
    u = TWDS.baseURL + 'dev/' + x + '.json'
  } else {
    u = TWDS.baseURL + 'dev/' + x + '.js'
  }
  $.getScript(u, function () {
    console.log('getScript', x, 'done')
    if (x.length === 2) {
      TWDS.fixTranslation()
    }
    if (y) { y() }
  })
}

// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.jobData = {
  job_1: { job_wages: 13.17, job_exp: 7.25, job_luck: 0, job_danger: 1, job_maxdmg: 10 },
  job_2: { job_wages: 8.37, job_exp: 11.50, job_luck: 2, job_danger: 20, job_maxdmg: 40 },
  job_3: { job_wages: 11.17, job_exp: 11.49, job_luck: 0, job_danger: 10, job_maxdmg: 25 },
  job_4: { job_wages: 17.57, job_exp: 7.33, job_luck: 2, job_danger: 2, job_maxdmg: 40 },
  job_5: { job_wages: 8.46, job_exp: 12.93, job_luck: 0, job_danger: 3, job_maxdmg: 10 },
  job_6: { job_wages: 16.46, job_exp: 9.73, job_luck: 4, job_danger: 1, job_maxdmg: 25 },
  job_7: { job_wages: 8.32, job_exp: 7.25, job_luck: 6, job_danger: 2, job_maxdmg: 10 },
  job_8: { job_wages: 11.17, job_exp: 15.25, job_luck: 2, job_danger: 4, job_maxdmg: 10 },
  job_9: { job_wages: 11.17, job_exp: 15.25, job_luck: 5, job_danger: 6, job_maxdmg: 49 },
  job_10: { job_wages: 13.17, job_exp: 14.18, job_luck: 0, job_danger: 2, job_maxdmg: 15 },
  job_11: { job_wages: 17.59, job_exp: 7.25, job_luck: 2, job_danger: 1, job_maxdmg: 15 },
  job_12: { job_wages: 16.32, job_exp: 16.31, job_luck: 3, job_danger: 3, job_maxdmg: 15 },
  job_13: { job_wages: 22.74, job_exp: 16.31, job_luck: 0, job_danger: 5, job_maxdmg: 25 },
  job_14: { job_wages: 14.97, job_exp: 16.31, job_luck: 8, job_danger: 5, job_maxdmg: 10 },
  job_15: { job_wages: 20.97, job_exp: 16.31, job_luck: 4, job_danger: 5, job_maxdmg: 10 },
  job_16: { job_wages: 13.17, job_exp: 18.18, job_luck: 2, job_danger: 7, job_maxdmg: 50 },
  job_17: { job_wages: 23.59, job_exp: 22.49, job_luck: 5, job_danger: 18, job_maxdmg: 10 },
  job_18: { job_wages: 22.74, job_exp: 11.49, job_luck: 5, job_danger: 7, job_maxdmg: 20 },
  job_19: { job_wages: 26.59, job_exp: 20.47, job_luck: 22, job_danger: 9, job_maxdmg: 10 },
  job_20: { job_wages: 13.17, job_exp: 21.90, job_luck: 7, job_danger: 21, job_maxdmg: 7 },
  job_21: { job_wages: 21.97, job_exp: 24.31, job_luck: 5, job_danger: 10, job_maxdmg: 15 },
  job_22: { job_wages: 16.32, job_exp: 23.74, job_luck: 0, job_danger: 11, job_maxdmg: 25 },
  job_23: { job_wages: 18.80, job_exp: 19.74, job_luck: 5, job_danger: 6, job_maxdmg: 25 },
  job_24: { job_wages: 30.97, job_exp: 20.47, job_luck: 6, job_danger: 32, job_maxdmg: 10 },
  job_25: { job_wages: 27.25, job_exp: 17.28, job_luck: 9, job_danger: 33, job_maxdmg: 10 },
  job_26: { job_wages: 19.97, job_exp: 26.39, job_luck: 15, job_danger: 12, job_maxdmg: 5 },
  job_27: { job_wages: 27.97, job_exp: 14.18, job_luck: 2, job_danger: 21, job_maxdmg: 45 },
  job_28: { job_wages: 18.80, job_exp: 21.19, job_luck: 15, job_danger: 6, job_maxdmg: 10 },
  job_29: { job_wages: 19.97, job_exp: 27.97, job_luck: 0, job_danger: 35, job_maxdmg: 10 },
  job_30: { job_wages: 27.25, job_exp: 21.19, job_luck: 6, job_danger: 30, job_maxdmg: 25 },
  job_31: { job_wages: 14.97, job_exp: 24.31, job_luck: 9, job_danger: 41, job_maxdmg: 50 },
  job_32: { job_wages: 32.17, job_exp: 16.31, job_luck: 8, job_danger: 4, job_maxdmg: 6 },
  job_33: { job_wages: 35.17, job_exp: 12.93, job_luck: 4, job_danger: 29, job_maxdmg: 15 },
  job_34: { job_wages: 16.32, job_exp: 26.98, job_luck: 42, job_danger: 11, job_maxdmg: 25 },
  job_35: { job_wages: 24.39, job_exp: 30.98, job_luck: 10, job_danger: 52, job_maxdmg: 20 },
  job_36: { job_wages: 25.97, job_exp: 11.49, job_luck: 25, job_danger: 12, job_maxdmg: 20 },
  job_37: { job_wages: 29.80, job_exp: 27.97, job_luck: 3, job_danger: 14, job_maxdmg: 20 },
  job_38: { job_wages: 20.97, job_exp: 31.32, job_luck: 23, job_danger: 19, job_maxdmg: 15 },
  job_39: { job_wages: 35.59, job_exp: 23.74, job_luck: 6, job_danger: 21, job_maxdmg: 15 },
  job_40: { job_wages: 34.59, job_exp: 21.90, job_luck: 0, job_danger: 13, job_maxdmg: 15 },
  job_41: { job_wages: 34.59, job_exp: 25.39, job_luck: 5, job_danger: 7, job_maxdmg: 15 },
  job_42: { job_wages: 17.59, job_exp: 26.98, job_luck: 23, job_danger: 38, job_maxdmg: 10 },
  job_43: { job_wages: 23.59, job_exp: 36.31, job_luck: 7, job_danger: 15, job_maxdmg: 25 },
  job_44: { job_wages: 39.97, job_exp: 34.98, job_luck: 6, job_danger: 18, job_maxdmg: 15 },
  job_45: { job_wages: 8.32, job_exp: 35.65, job_luck: 22, job_danger: 37, job_maxdmg: 50 },
  job_46: { job_wages: 30.97, job_exp: 35.65, job_luck: 0, job_danger: 52, job_maxdmg: 25 },
  job_47: { job_wages: 27.25, job_exp: 31.32, job_luck: 18, job_danger: 53, job_maxdmg: 15 },
  job_48: { job_wages: 34.17, job_exp: 35.65, job_luck: 0, job_danger: 42, job_maxdmg: 15 },
  job_49: { job_wages: 39.97, job_exp: 17.28, job_luck: 15, job_danger: 20, job_maxdmg: 10 },
  job_50: { job_wages: 30.97, job_exp: 20.47, job_luck: 64, job_danger: 93, job_maxdmg: 66 },
  job_51: { job_wages: 25.97, job_exp: 34.98, job_luck: 26, job_danger: 45, job_maxdmg: 20 },
  job_52: { job_wages: 31.49, job_exp: 40.80, job_luck: 0, job_danger: 72, job_maxdmg: 33 },
  job_53: { job_wages: 35.97, job_exp: 43.17, job_luck: 17, job_danger: 35, job_maxdmg: 14 },
  job_54: { job_wages: 22.74, job_exp: 21.90, job_luck: 63, job_danger: 34, job_maxdmg: 20 },
  job_55: { job_wages: 46.97, job_exp: 17.28, job_luck: 9, job_danger: 16, job_maxdmg: 50 },
  job_56: { job_wages: 51.17, job_exp: 17.28, job_luck: 0, job_danger: 32, job_maxdmg: 25 },
  job_57: { job_wages: 36.49, job_exp: 44.74, job_luck: 45, job_danger: 43, job_maxdmg: 33 },
  job_58: { job_wages: 29.80, job_exp: 41.10, job_luck: 15, job_danger: 67, job_maxdmg: 25 },
  job_59: { job_wages: 21.97, job_exp: 40.25, job_luck: 30, job_danger: 33, job_maxdmg: 25 },
  job_60: { job_wages: 47.59, job_exp: 31.74, job_luck: 18, job_danger: 43, job_maxdmg: 20 },
  job_61: { job_wages: 32.17, job_exp: 32.13, job_luck: 38, job_danger: 4, job_maxdmg: 20 },
  job_62: { job_wages: 16.32, job_exp: 40.59, job_luck: 52, job_danger: 77, job_maxdmg: 50 },
  job_63: { job_wages: 25.97, job_exp: 36.64, job_luck: 51, job_danger: 44, job_maxdmg: 20 },
  job_64: { job_wages: 25.97, job_exp: 32.13, job_luck: 72, job_danger: 82, job_maxdmg: 25 },
  job_65: { job_wages: 25.17, job_exp: 21.90, job_luck: 90, job_danger: 34, job_maxdmg: 33 },
  job_66: { job_wages: 32.17, job_exp: 44.93, job_luck: 35, job_danger: 71, job_maxdmg: 40 },
  job_67: { job_wages: 53.17, job_exp: 27.97, job_luck: 20, job_danger: 7, job_maxdmg: 33 },
  job_68: { job_wages: 29.17, job_exp: 25.39, job_luck: 83, job_danger: 24, job_maxdmg: 24 },
  job_69: { job_wages: 44.65, job_exp: 44.47, job_luck: 17, job_danger: 35, job_maxdmg: 65 },
  job_70: { job_wages: 42.17, job_exp: 37.28, job_luck: 74, job_danger: 66, job_maxdmg: 15 },
  job_71: { job_wages: 55.39, job_exp: 37.90, job_luck: 23, job_danger: 65, job_maxdmg: 50 },
  job_72: { job_wages: 33.59, job_exp: 44.20, job_luck: 85, job_danger: 83, job_maxdmg: 90 },
  job_73: { job_wages: 51.65, job_exp: 28.80, job_luck: 78, job_danger: 86, job_maxdmg: 50 },
  job_74: { job_wages: 40.25, job_exp: 43.74, job_luck: 95, job_danger: 67, job_maxdmg: 40 },
  job_75: { job_wages: 55.39, job_exp: 30.98, job_luck: 79, job_danger: 72, job_maxdmg: 50 },
  job_76: { job_wages: 30.97, job_exp: 42.65, job_luck: 85, job_danger: 44, job_maxdmg: 33 },
  job_77: { job_wages: 48.49, job_exp: 47.04, job_luck: 92, job_danger: 96, job_maxdmg: 80 },
  job_78: { job_wages: 52.25, job_exp: 31.74, job_luck: 81, job_danger: 26, job_maxdmg: 25 },
  job_79: { job_wages: 47.97, job_exp: 37.28, job_luck: 52, job_danger: 67, job_maxdmg: 20 },
  job_80: { job_wages: 35.97, job_exp: 42.49, job_luck: 76, job_danger: 44, job_maxdmg: 13 },
  job_82: { job_wages: 52.80, job_exp: 32.13, job_luck: 15, job_danger: 14, job_maxdmg: 25 },
  job_83: { job_wages: 46.97, job_exp: 35.65, job_luck: 83, job_danger: 56, job_maxdmg: 30 },
  job_84: { job_wages: 33.59, job_exp: 40.59, job_luck: 17, job_danger: 24, job_maxdmg: 10 },
  job_85: { job_wages: 43.59, job_exp: 30.98, job_luck: 15, job_danger: 29, job_maxdmg: 40 },
  job_86: { job_wages: 32.17, job_exp: 34.65, job_luck: 12, job_danger: 27, job_maxdmg: 25 },
  job_87: { job_wages: 24.39, job_exp: 20.47, job_luck: 7, job_danger: 11, job_maxdmg: 10 },
  job_88: { job_wages: 25.17, job_exp: 29.25, job_luck: 9, job_danger: 23, job_maxdmg: 10 },
  job_90: { job_wages: 25.97, job_exp: 34.32, job_luck: 65, job_danger: 45, job_maxdmg: 45 },
  job_91: { job_wages: 25.17, job_exp: 27.97, job_luck: 10, job_danger: 21, job_maxdmg: 10 },
  job_92: { job_wages: 14.96, job_exp: 14.21, job_luck: 2, job_danger: 6, job_maxdmg: 14 },
  job_93: { job_wages: 13.17, job_exp: 9.65, job_luck: 3, job_danger: 2, job_maxdmg: 9 },
  job_94: { job_wages: 8.32, job_exp: 12.93, job_luck: 0, job_danger: 2, job_maxdmg: 9 },
  job_95: { job_wages: 19.97, job_exp: 38.18, job_luck: 5, job_danger: 5, job_maxdmg: 10 },
  job_96: { job_wages: 27.25, job_exp: 40.25, job_luck: 10, job_danger: 20, job_maxdmg: 15 },
  job_97: { job_wages: 41.17, job_exp: 35.65, job_luck: 10, job_danger: 10, job_maxdmg: 12 },
  job_98: { job_wages: 43.59, job_exp: 32.13, job_luck: 35, job_danger: 15, job_maxdmg: 10 },
  job_99: { job_wages: 36.49, job_exp: 27.97, job_luck: 54, job_danger: 25, job_maxdmg: 25 },
  job_100: { job_wages: 41.80, job_exp: 26.98, job_luck: 60, job_danger: 15, job_maxdmg: 9 },
  job_101: { job_wages: 44.32, job_exp: 35.65, job_luck: 35, job_danger: 20, job_maxdmg: 7 },
  job_102: { job_wages: 48.49, job_exp: 39.17, job_luck: 35, job_danger: 12, job_maxdmg: 3 },
  job_103: { job_wages: 44.32, job_exp: 45.19, job_luck: 5, job_danger: 23, job_maxdmg: 9 },
  job_104: { job_wages: 48.49, job_exp: 44.47, job_luck: 56, job_danger: 45, job_maxdmg: 20 },
  job_105: { job_wages: 51.17, job_exp: 31.74, job_luck: 78, job_danger: 32, job_maxdmg: 11 },
  job_106: { job_wages: 53.32, job_exp: 43.97, job_luck: 30, job_danger: 57, job_maxdmg: 7 },
  job_107: { job_wages: 48.49, job_exp: 39.40, job_luck: 69, job_danger: 63, job_maxdmg: 12 },
  job_108: { job_wages: 49.97, job_exp: 35.97, job_luck: 71, job_danger: 73, job_maxdmg: 43 },
  job_109: { job_wages: 46.97, job_exp: 38.18, job_luck: 58, job_danger: 27, job_maxdmg: 23 },
  job_110: { job_wages: 48.17, job_exp: 45.90, job_luck: 69, job_danger: 48, job_maxdmg: 10 },
  job_111: { job_wages: 51.17, job_exp: 39.17, job_luck: 69, job_danger: 78, job_maxdmg: 35 },
  job_112: { job_wages: 45.97, job_exp: 35.97, job_luck: 97, job_danger: 67, job_maxdmg: 15 },
  job_113: { job_wages: 51.65, job_exp: 47.49, job_luck: 35, job_danger: 83, job_maxdmg: 23 },
  job_114: { job_wages: 41.39, job_exp: 47.49, job_luck: 39, job_danger: 93, job_maxdmg: 34 },
  job_115: { job_wages: 54.17, job_exp: 43.74, job_luck: 29, job_danger: 69, job_maxdmg: 24 },
  job_116: { job_wages: 50.59, job_exp: 47.97, job_luck: 34, job_danger: 56, job_maxdmg: 65 },
  job_117: { job_wages: 54.65, job_exp: 43.49, job_luck: 22, job_danger: 72, job_maxdmg: 20 },
  job_118: { job_wages: 55.17, job_exp: 44.93, job_luck: 23, job_danger: 77, job_maxdmg: 34 },
  job_119: { job_wages: 55.39, job_exp: 45.90, job_luck: 54, job_danger: 38, job_maxdmg: 13 },
  job_120: { job_wages: 51.65, job_exp: 48.13, job_luck: 23, job_danger: 47, job_maxdmg: 24 },
  job_121: { job_wages: 54.17, job_exp: 47.74, job_luck: 60, job_danger: 94, job_maxdmg: 34 },
  job_122: { job_wages: 53.32, job_exp: 42.98, job_luck: 89, job_danger: 99, job_maxdmg: 67 },
  job_123: { job_wages: 55.65, job_exp: 46.39, job_luck: 30, job_danger: 89, job_maxdmg: 75 },
  job_124: { job_wages: 53.32, job_exp: 48.39, job_luck: 28, job_danger: 92, job_maxdmg: 75 },
  job_125: { job_wages: 55.39, job_exp: 48.59, job_luck: 65, job_danger: 70, job_maxdmg: 100 },
  job_126: { job_wages: 35.97, job_exp: 41.65, job_luck: 20, job_danger: 30, job_maxdmg: 15 },
  job_127: { job_wages: 11.17, job_exp: 7.25, job_luck: 2, job_danger: 20, job_maxdmg: 5 },
  job_128: { job_wages: 0.00, job_exp: 9.73, job_luck: 0, job_danger: 1, job_maxdmg: 10 },
  job_129: { job_wages: 11.17, job_exp: 9.73, job_luck: 2, job_danger: 20, job_maxdmg: 5 },
  job_130: { job_wages: 11.17, job_exp: 11.49, job_luck: 1, job_danger: 10, job_maxdmg: 5 },
  job_131: { job_wages: 53.32, job_exp: 45.65, job_luck: 23, job_danger: 40, job_maxdmg: 33 },
  job_132: { job_wages: 50.25, job_exp: 47.97, job_luck: 21, job_danger: 30, job_maxdmg: 25 },
  job_133: { job_wages: 51.39, job_exp: 48.80, job_luck: 33, job_danger: 50, job_maxdmg: 65 },
  job_134: { job_wages: 50.97, job_exp: 47.49, job_luck: 55, job_danger: 20, job_maxdmg: 10 },
  job_135: { job_wages: 56.97, job_exp: 48.80, job_luck: 34, job_danger: 43, job_maxdmg: 20 },
  job_136: { job_wages: 57.97, job_exp: 48.39, job_luck: 83, job_danger: 78, job_maxdmg: 35 },
  job_137: { job_wages: 55.39, job_exp: 47.04, job_luck: 56, job_danger: 48, job_maxdmg: 22 },
  job_138: { job_wages: 51.97, job_exp: 44.74, job_luck: 91, job_danger: 67, job_maxdmg: 100 },
  job_139: { job_wages: 59.49, job_exp: 50.07, job_luck: 87, job_danger: 96, job_maxdmg: 100 },
  job_140: { job_wages: 57.97, job_exp: 49.49, job_luck: 67, job_danger: 85, job_maxdmg: 60 },
  job_141: { job_wages: 54.65, job_exp: 54.80, job_luck: 74, job_danger: 94, job_maxdmg: 34 },
  job_142: { job_wages: 59.97, job_exp: 52.31, job_luck: 82, job_danger: 78, job_maxdmg: 40 },
  job_143: { job_wages: 58.17, job_exp: 52.50, job_luck: 81, job_danger: 81, job_maxdmg: 25 },
  job_144: { job_wages: 58.59, job_exp: 52.93, job_luck: 85, job_danger: 89, job_maxdmg: 25 },
  job_145: { job_wages: 57.59, job_exp: 55.49, job_luck: 82, job_danger: 96, job_maxdmg: 44 },
  job_146: { job_wages: 58.97, job_exp: 52.74, job_luck: 83, job_danger: 76, job_maxdmg: 38 },
  job_147: { job_wages: 55.17, job_exp: 55.17, job_luck: 67, job_danger: 56, job_maxdmg: 39 },
  job_148: { job_wages: 60.17, job_exp: 52.50, job_luck: 57, job_danger: 67, job_maxdmg: 35 },
  job_149: { job_wages: 45.32, job_exp: 54.60, job_luck: 78, job_danger: 56, job_maxdmg: 7 },
  job_150: { job_wages: 55.65, job_exp: 54.24, job_luck: 47, job_danger: 37, job_maxdmg: 60 },
  job_151: { job_wages: 58.17, job_exp: 56.13, job_luck: 57, job_danger: 49, job_maxdmg: 22 },
  job_152: { job_wages: 54.65, job_exp: 59.32, job_luck: 23, job_danger: 67, job_maxdmg: 25 },
  job_153: { job_wages: 55.17, job_exp: 61.59, job_luck: 12, job_danger: 87, job_maxdmg: 100 },
  job_154: { job_wages: 61.49, job_exp: 52.13, job_luck: 34, job_danger: 93, job_maxdmg: 70 },
  job_155: { job_wages: 57.59, job_exp: 47.04, job_luck: 121, job_danger: 63, job_maxdmg: 30 },
  job_156: { job_wages: 62.17, job_exp: 49.65, job_luck: 65, job_danger: 99, job_maxdmg: 99 },
  job_157: { job_wages: 59.25, job_exp: 54.80, job_luck: 87, job_danger: 87, job_maxdmg: 25 },
  job_158: { job_wages: 58.32, job_exp: 52.93, job_luck: 110, job_danger: 76, job_maxdmg: 30 },
  job_159: { job_wages: 60.59, job_exp: 56.93, job_luck: 56, job_danger: 94, job_maxdmg: 50 },
  job_160: { job_wages: 59.74, job_exp: 55.68, job_luck: 110, job_danger: 89, job_maxdmg: 70 },
  /* ab hier selbst kalkuliert. */
  job_161: { job_wages: 62.8, job_exp: 55.6, job_luck: 126.963, job_danger: 73, job_maxdmg: 50 },
  job_162: { job_wages: 61.3, job_exp: 52.1, job_luck: 66.963, job_danger: 33, job_maxdmg: 80 },
  job_163: { job_wages: 60.2, job_exp: 52.7, job_luck: 50, job_danger: 25, job_maxdmg: 40 },
  job_164: { job_wages: 61.9, job_exp: 53.8, job_luck: 80, job_danger: 50, job_maxdmg: 80 },
  job_165: { job_wages: 61, job_exp: 56, job_luck: 74.963, job_danger: 48.21, job_maxdmg: 14 },
  job_166: { job_wages: 62.2, job_exp: 55, job_luck: 98.963, job_danger: 67, job_maxdmg: 20 },
  job_167: { job_wages: 62.8, job_exp: 54, job_luck: 86.963, job_danger: 58, job_maxdmg: 20 },
  job_168: { job_wages: 63.5, job_exp: 55.3, job_luck: 92, job_danger: 74, job_maxdmg: 33 },
  job_169: { job_wages: 61.9, job_exp: 53.7, job_luck: 98.963, job_danger: 50, job_maxdmg: 80 },
  job_170: { job_wages: 61.3, job_exp: 56.5, job_luck: 110.964, job_danger: 42, job_maxdmg: 12 },
  job_171: { job_wages: 64.1, job_exp: 55.2, job_luck: 96.963, job_danger: 58, job_maxdmg: 30 },
  job_172: { job_wages: 63.1, job_exp: 55.6, job_luck: 84.963, job_danger: 56, job_maxdmg: 5 },
  job_173: { job_wages: 61.3, job_exp: 53.7, job_luck: 110, job_danger: 50, job_maxdmg: 15 },
  job_174: { job_wages: 66, job_exp: 55.5, job_luck: 100, job_danger: 87, job_maxdmg: 20 },
  job_175: { job_wages: 65.6, job_exp: 56.7, job_luck: 78, job_danger: 74, job_maxdmg: 20 },
  job_176: { job_wages: 60, job_exp: 57, job_luck: 76, job_danger: 49, job_maxdmg: 15 },
  job_177: { job_wages: 65.6, job_exp: 60.4, job_luck: 88, job_danger: 72, job_maxdmg: 10 },
  job_178: { job_wages: 67.7, job_exp: 57.7, job_luck: 90, job_danger: 70, job_maxdmg: 70 },
  job_179: { job_wages: 69.7, job_exp: 56.3, job_luck: 150, job_danger: 78, job_maxdmg: 18 },
  job_180: { job_wages: 61.3, job_exp: 63.3, job_luck: 98, job_danger: 65, job_maxdmg: 50 },
  job_181: { job_wages: 63.5, job_exp: 62.3, job_luck: 124.964, job_danger: 97, job_maxdmg: 17 },
  job_182: { job_wages: 68, job_exp: 60, job_luck: 78, job_danger: 37, job_maxdmg: 70 },
  job_183: { job_wages: 67.6, job_exp: 55.5, job_luck: 58, job_danger: 70, job_maxdmg: 50 },
  job_184: { job_wages: 69.5, job_exp: 59.6, job_luck: 74, job_danger: 71, job_maxdmg: 100 },
  job_185: { job_wages: 68, job_exp: 63.6, job_luck: 174.964, job_danger: 90, job_maxdmg: 97 },
  job_186: { job_wages: 60, job_exp: 58.6, job_luck: 98.963, job_danger: 47, job_maxdmg: 20 },
  job_187: { job_wages: 65.8, job_exp: 63.5, job_luck: 134.964, job_danger: 55, job_maxdmg: 10 },
  job_188: { job_wages: 63.1, job_exp: 60.1, job_luck: 74, job_danger: 61, job_maxdmg: 89 },
  job_189: { job_wages: 71.3, job_exp: 62.8, job_luck: 46.963, job_danger: 84, job_maxdmg: 10 },
  job_190: { job_wages: 67, job_exp: 60.3, job_luck: 144.963, job_danger: 93, job_maxdmg: 14 },
  job_191: { job_wages: 62.4, job_exp: 57.2, job_luck: 132, job_danger: 71, job_maxdmg: 90 },
  job_192: { job_wages: 63.6, job_exp: 65, job_luck: 76, job_danger: 63, job_maxdmg: 25 },
  job_193: { job_wages: 63.1, job_exp: 56.4, job_luck: 184.963, job_danger: 57, job_maxdmg: 20 },
  job_194: { job_wages: 64.1, job_exp: 61.5, job_luck: 96.963, job_danger: 84, job_maxdmg: 20 },
  job_195: { job_wages: 63.5, job_exp: 60, job_luck: 66.963, job_danger: 84, job_maxdmg: 50 },
  job_196: { job_wages: 66.9, job_exp: 63.2, job_luck: 116.963, job_danger: 64, job_maxdmg: 15 },
  job_197: { job_wages: 65.6, job_exp: 61.3, job_luck: 84, job_danger: 90, job_maxdmg: 85 },
  job_198: { job_wages: 66.1, job_exp: 54.8, job_luck: 134.963, job_danger: 95, job_maxdmg: 17 },
  job_199: { job_wages: 74.4, job_exp: 63.6, job_luck: 174.963, job_danger: 85, job_maxdmg: 25 },
  job_200: { job_wages: 71.7, job_exp: 63.9, job_luck: 102, job_danger: 47, job_maxdmg: 60 },
  job_201: { job_wages: 68.9, job_exp: 65.2, job_luck: 110.963, job_danger: 72, job_maxdmg: 50 },
  job_202: { job_wages: 72.6, job_exp: 66.7, job_luck: 180, job_danger: 98, job_maxdmg: 75 },
  job_203: { job_wages: 76.8, job_exp: 62.4, job_luck: 124.964, job_danger: 43, job_maxdmg: 9 },
  job_204: { job_wages: 75.0, job_exp: 64.5, job_luck: 140, job_danger: 71, job_maxdmg: 70 },
  job_205: { job_wages: 76.3, job_exp: 66.7, job_luck: 150, job_danger: 97, job_maxdmg: 50 }
}
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.utils = {}

TWDS.settingList = []
TWDS.extraList = []
TWDS.saveSettings = function () {
  window.localStorage.setItem('TWDS_settings', JSON.stringify(TWDS.settings))
}
TWDS.loadSettings = function () {
  try {
    const x = window.localStorage.getItem('TWDS_settings')
    if (x) {
      TWDS.settings = JSON.parse(x)
    }
  } catch (e) {
    console.log('failed to get settings', e)
  }
}
TWDS.registerExtra = function (fn, text, help) {
  TWDS.extraList.push({ fn: fn, text: text, help: help })
}
TWDS.registerSetting = function (mode, name, text, opts, callback, group, subgroup, ordervalue) {
  if (typeof opts !== 'object') {
    const tmp = opts
    opts = {
      default: tmp
    }
  }
  const o = {
    mode: mode,
    name: name,
    text: text,
    opts: opts,
    callback: callback || null,
    group: group || 'misc',
    subgroup: subgroup || '',
    ordervalue: ordervalue || 0
  }
  TWDS.settingList.push(o)
  if (TWDS.settings === null) {
    TWDS.loadSettings()
    if (TWDS.settings === null) {
      TWDS.settings = {}
    }
  }
  if (!(name in TWDS.settings)) {
    TWDS.settings[name] = opts.default
  }
  if (callback) { callback(TWDS.settings[name]) }
}

TWDS.wearItemsHandler = function (ids) {
  if (!Bag.loaded) {
    EventHandler.listen('inventory_loaded', function () {
      TWDS.wearItemsHandler(ids)
      return EventHandler.ONE_TIME_EVENT
    })
    return
  }

  if (Premium.hasBonus('automation')) {
    // i want to open the worn items window, but not the inventory.
    let isMin = false
    let isCreated = false
    if (Inventory !== null) {
      isMin = wman.isMinimized(Inventory.uid) === true
      isCreated = wman.isWindowCreated(Inventory.uid) === true
    }
    if (!wman.isWindowCreated(Wear.uid)) {
      Wear.open()
    } else if (wman.isMinimized(Wear.uid)) {
      wman.reopen(Wear.uid)
    }
    if (!isCreated) {
      wman.close(Inventory.uid)
    } else if (isMin) {
      wman.minimize(Inventory.uid)
    }
    for (const ii of ids) {
      const b = Bag.getItemByItemId(Number(ii))
      if (b) {
        Wear.carry(b)
      }
    }
    return
  }

  if (!wman.getById(Inventory.uid)) { Inventory.open() }
  Wear.open()

  const invItems = Bag.getItemsByItemIds(ids)
  const result = []
  for (let i = 0; i < invItems.length; i++) {
    const invItem = invItems[i]
    const wearItem = Wear.get(invItem.getType())
    if (!wearItem || (wearItem && (wearItem.getItemBaseId() !== invItem.getItemBaseId() ||
        wearItem.getItemLevel() < invItem.getItemLevel()))) {
      result.push(invItem)
    }
  }
  Inventory.showCustomItems(result)
}

TWDS.q1 = function (sel, pa) {
  if (pa) {
    if (pa instanceof Node) {
      return pa.querySelector(sel)
    }
    if (pa instanceof jQuery) {
      if (pa.length) { return pa[0].querySelector(sel) }
      return null
    }
    const x = TWDS.q1(pa)
    if (!x) return null
    return x.querySelector(sel)
  }
  return document.querySelector(sel)
}
TWDS.q = function (sel, pa) {
  if (pa) {
    if (pa instanceof Node) {
      return pa.querySelectorAll(sel)
    }
    if (pa instanceof jQuery) {
      if (pa.length) { return pa[0].querySelectorAll(sel) }
      return null
    }
    const x = TWDS.q1(pa)
    if (!x) return null
    return x.querySelectorAll(sel)
  }
  return document.querySelectorAll(sel)
}

TWDS.createElement = function (par = {}, par2 = null) {
  if (typeof par === 'string') {
    if (typeof par2 === 'object' && par2 !== null) {
      par2.nodeName = par
      par = par2
    } else {
      par = {
        nodeName: par
      }
    }
  }
  let dotpos = par.nodeName.indexOf('.')
  let classadd = null
  if (dotpos !== -1) {
    const n = par.nodeName.substring(0, dotpos)
    classadd = par.nodeName.substring(dotpos + 1)
    par.nodeName = n
  }
  const thing = document.createElement(par.nodeName)
  for (const [k, v] of Object.entries(par)) {
    if (k === 'nodeName') continue
    if (k === 'before' || k === 'beforebegin') {
      v.insertAdjacentElement('beforebegin', thing)
      continue
    }
    if (k === 'after' || k === 'afterend') {
      v.insertAdjacentElement('afterend', thing)
      continue
    }
    if (k === 'first' || k === 'afterbegin') {
      v.insertAdjacentElement('afterbegin', thing)
      continue
    }
    if (k === 'last' || k === 'beforeend') {
      v.insertAdjacentElement('beforeend', thing)
      continue
    }
    if (k === 'dataset' || k === 'dataSet') {
      for (const [k2, v2] of Object.entries(v)) {
        thing.dataset[k2] = v2
      }
      continue
    }
    if (k === 'style' || k === 'css') {
      for (const [k2, v2] of Object.entries(v)) {
        thing.style[k2] = v2
      }
      continue
    }
    if (k === 'classList') {
      for (const add of v) {
        thing.classList.add(add)
      }
      continue
    }
    if (k === 'childNodes' || k === 'children') {
      for (const c of Object.values(v)) {
        if (c instanceof Node) {
          thing.appendChild(c)
        } else {
          const ce = TWDS.createElement(c)
          thing.appendChild(ce)
        }
      }
      continue
    }
    if (k === 'list') {
      thing.setAttribute('list', v)
      continue
    }
    thing[k] = v
    /*
    if (!(k in thing) || thing.list !== v) {
      thing.setAttribute(k, v)
    }
    */
  }
  if (classadd !== null) {
    dotpos = classadd.indexOf('.')
    while (dotpos !== -1) {
      const p = classadd.substring(0, dotpos)
      thing.classList.add(p)
      classadd = classadd.substring(dotpos + 1)
      dotpos = classadd.indexOf('.')
    }
    thing.classList.add(classadd)
  }
  return thing
}
TWDS.createEle = TWDS.createElement
TWDS.createButton = function (text, par) {
  if (text !== null && text !== '') {
    par.textContent = text
  }
  if (!('classList' in par)) par.classList = []
  par.classList.push('TWDS_button')
  par.nodeName = 'button'
  return TWDS.createEle(par)
}

TWDS.employerOpenButton = function (id) {
  return TWDS.createEle({
    nodeName: 'span',
    className: 'TWDS_quest_employer_link TWDS_clickable',
    dataset: { id: id },
    title: TWDS._('UTIL_QUEST_EMPLOYER_LINK', 'Center the map on the employer'),
    children: [
      {
        nodeName: 'img',
        src: '/images/map/minimap/icons/miniicon_quests.png',
        alt: 'Quests'
      }
    ]
  })
}

TWDS.jobOpenButton = function (id) {
  if (Premium.hasBonus('automation')) {
    return TWDS.createElement({
      nodeName: 'span',
      classList: ['TWDS_joblist_openbutton'],
      dataset: { job_id: id },
      title: TWDS._('JOBOPENBUTTON_TITLE', 'Abrir una ventana para comenzar el trabajo más cercano.'),
      childNodes: [
        {
          nodeName: 'img',
          src: Game.cdnURL + '/images/icons/hammer.png',
          alt: ''
        }
      ]
    })
  }
  return null
}
TWDS.jobOpenButton2 = function (id) {
  if (!Premium.hasBonus('automation')) return null
  return TWDS.createEle({
    nodeName: 'span',
    className: 'tw2gui-iconset tw2gui-icon-hammer TWDS_job_open_button TWDS_clickable',
    dataset: { jobid: id },
    title: TWDS._('UTIL_JOBOPENBUTTON_TITLE', 'Abrir el trabajo más cercano a su posición.')
  })
}

TWDS.item_wear_handler = function () {
  const id = this.dataset.item_id
  TWDS.wearItemsHandler([id])
}
TWDS.itemWearButton = function (id) {
  const it = ItemManager.get(id)
  if (!it) return null

  const t = TWDS.createElement({
    nodeName: 'span',
    className: 'TWDS_item_wear_button linklike',
    dataset: { item_id: id },
    title: TWDS._('ITEMWEATBUTTON_TITLE', 'Usar este artículo'),
    childNodes: [
      {
        nodeName: 'img',
        src: Game.cdnURL + '/images/icons/scrollto.png',
        alt: ''
      }
    ]
  })
  return t
}

TWDS.itemSellButton = function (id, count, desc) {
  const it = ItemManager.get(id)
  if (!it) return null

  if (!it.auctionable) return null

  return TWDS.createElement({
    nodeName: 'span',
    className: 'TWDS_item_sell_button',
    dataset: { item_id: id, count: count, desc: desc },
    title: TWDS._('ITEMSELLBUTTON_TITLE', 'Vender en el mercado'),
    childNodes: [
      {
        nodeName: 'span',
        textContent: '$$',
        style: {
          color: 'green'
        }
      }
    ]
  })
}
TWDS.itemBidButton = function (id) {
  const it = ItemManager.get(id)
  if (!it) return null

  if (!it.auctionable) return null

  return TWDS.createElement({
    nodeName: 'span',
    className: 'TWDS_storage_market_button',
    dataset: { item_id: id },
    title: TWDS._('ITEMBIDBUTTON_TITLE', 'Buscar en el mercado'),
    childNodes: [
      {
        nodeName: 'img',
        src: Game.cdnURL + '/images/icons/bid.png',
        alt: ''
      }
    ]
  })
}
TWDS.itemAnyCraftButton = function (id) {
  const it = ItemManager.get(id)
  if (!it) return null

  if (it.type !== 'yield') return null
  if (!TWDS.utils.iscraftableitem(id)) return null

  return TWDS.createElement({
    nodeName: 'span',
    className: 'TWDS_craft_button',
    title: TWDS._('ITEMCRAFTBUTTON_TITLE', 'Artesanía'),
    dataset: { item_id: id },
    childNodes: [
      {
        nodeName: 'img',
        src: Game.cdnURL + '/images/items/yield/toolbox.png',
        alt: ''
      }
    ]
  })
}
TWDS.itemCraftButton = function (id) {
  const it = ItemManager.get(id)
  if (!it) return null

  if (it.type !== 'yield') return null
  if (it.spec_type !== 'crafting') return null
  if (!TWDS.crafting) return null
  if (!TWDS.crafting.items) return null
  if (!TWDS.crafting.items[id]) return null

  return TWDS.createElement({
    nodeName: 'span',
    className: 'TWDS_storage_craft_button',
    title: TWDS._('ITEMCRAFTBUTTON_TITLE', 'Artesanía'),
    dataset: { item_id: id },
    childNodes: [
      {
        nodeName: 'img',
        src: Game.cdnURL + '/images/icons/icon_consumable.png',
        alt: ''
      }
    ]
  })
}

TWDS.delegate = function (root, evname, selector, func) {
  const h = function (ev) {
    const tg = ev.target.closest(selector)
    if (tg) {
      func.call(tg, ev)
    }
  }
  root.removeEventListener(evname, h)
  root.addEventListener(evname, h)
}

// logic from
// https://stackoverflow.com/questions/15547198/export-html-table-to-csv-using-vanilla-javascript
TWDS.download_table = function (name, selector, sep = ',') {
  let rows
  if (selector instanceof Node) {
    rows = TWDS.q('tr', selector)
  } else {
    rows = TWDS.q(selector + ' tr')
  }

  const csv = []
  for (let i = 0; i < rows.length; i++) {
    const row = []; const cols = rows[i].querySelectorAll('td, th')
    for (let j = 0; j < cols.length; j++) {
      // Clean innertext to remove multiple spaces and jumpline (break csv)
      let data = cols[j].innerText.replace(/(\r\n|\n|\r)/gm, '').replace(/(\s\s)/gm, ' ')
      // Escape double-quote with double-double-quote (see https://stackoverflow.com/questions/17808511/properly-escape-a-double-quote-in-csv)
      data = data.replace(/"/g, '""')
      // Push escaped string
      row.push('"' + data + '"')
      if (cols[j].colSpan) {
        let x = cols[j].colSpan
        if (cols[j].dataset.fullColSpan) { x = cols[j].dataset.fullColSpan }
        let k = parseInt(x)
        while (k > 1) {
          row.push('')
          k--
        }
      }
    }
    csv.push(row.join(sep))
  }
  // Download it
  const filename = 'twds_' + name + '_' + new Date().toLocaleDateString() + '.csv'
  const link = TWDS.createEle({
    nodeName: 'a',
    style: {
      display: 'none'
    },
    href: 'data:text/csv;charset=utf-8,' + window.encodeURIComponent(csv.join('\n')),
    target: '_blank',
    download: filename
  })
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
}

TWDS.marketsearchlink = function (itemid) {
  const it = ItemManager.get(itemid)
  if (!it) return false
  return TWDS.createEle({
    nodeName: 'span',
    className: 'tw2gui-iconset tw2gui-icon-friends TWDS_marketsearchlink',
    dataset: {
      itemid: itemid,
      itemname: it.name
    }
  })
}
TWDS.marketsearchlinkhandler = function (ev) {
  console.log('MSLH', ev, this, this.dataset)
  if (!Character.homeTown || !Character.homeTown.town_id) { return }
  MarketWindow.open(Character.homeTown.town_id, 0, Character.homeTown.town_name)
  MarketWindow.showTab('buy')
  const x = TWDS.q1('.tw2gui_window.marketplace input[name=market_search_search]')
  const y = TWDS.q1('.tw2gui_window.marketplace .iconBut_mpb_refresh')
  if (x && y) {
    x.value = this.dataset.itemname
    const event = new window.MouseEvent('click', {
      view: window,
      bubbles: true,
      cancelable: true
    })
    y.dispatchEvent(event)
  }
}
TWDS.market_item_sell_handler = function (ev) {
  console.log('MISH', ev, this, this.dataset)
  const ds = this.dataset
  const patcher = function () {
    console.log('PATCHER running')
    const x = TWDS.q1('#market_createoffer_window')
    if (!x) {
      console.log('PATCHER restarted because no window')
      setTimeout(patcher, 50)
      return
    }
    if (!(x.classList.contains('TWDS_enhanced'))) {
      console.log('PATCHER restarted because window not enhanced')
      setTimeout(patcher, 50)
      return
    }
    console.log('PATCHER working', ds)
    TWDS.q1('#market_sell_itemStack').value = ds.count
    if (ds.desc > '') { TWDS.q1('#auction_description').value = ds.desc }
  }
  Ajax.remoteCallMode('town', 'get_town', Character.position, function (json) {
    if (json.error) {
      return new UserMessage(json.msg).show()
    }
    MarketWindow.open(json.town_id, json.allBuildings.market.stage, json.town_name)
    MarketWindow.showTab('sell')
    MarketWindow.createMarketOffer(parseInt(ds.item_id))
    setTimeout(patcher, 20)
    console.log('PATCHER process started')
  })
}
TWDS.job_open_button_handler = function () {
  const id = this.dataset.jobid
  if (!id || !Premium.hasBonus('automation')) { return false }
  Ajax.remoteCall('work', 'get_nearest_job', {
    job_id: id
  }, function (json) {
    if (json.error) { return new UserMessage(json.msg).show() }
    JobWindow.open(id, json.x, json.y)
  })
}
TWDS.quest_employer_link_handler = function () {
  const id = this.dataset.id
  Ajax.get('map', 'get_minimap', {}, function (data) {
    const pos = data.quest_locations[id]
    if (!pos) return ''
    Map.center(pos[0][0], pos[0][1])
  })
}

TWDS.registerStartFunc(function () {
  TWDS.delegate(document.body, 'click', '.TWDS_job_open_button', TWDS.job_open_button_handler)
  TWDS.delegate(document.body, 'click', '.TWDS_quest_employer_link', TWDS.quest_employer_link_handler)
  TWDS.delegate(document.body, 'click', '.TWDS_marketsearchlink', TWDS.marketsearchlinkhandler)
  TWDS.delegate(document.body, 'click', '.TWDS_item_sell_button', TWDS.market_item_sell_handler)
  TWDS.delegate(document.body, 'click', '.TWDS_item_wear_button', TWDS.item_wear_handler)
})

// 2023. <select> still is a mess. typeahead? styling? intelligent limiting?
// unfortunately input w/ datalist doesn't cut it, too.
TWDS.createFilteredSelect = function (filltext, allthings) {
  const d = TWDS.createEle('div.filteredselectcontainer')
  const sf = TWDS.createEle('input', {
    type: 'text',
    placeholder: TWDS._('UTIL_SELECT_FILTERTEXT', 'filtrar -->'),
    title: TWDS._('UTIL_SELECT_FILTERTITLE', 'Limitar la larga lista. Javascript-RX: Skel|Heart works'),
    last: d
  })
  const ss = TWDS.createEle('select', { type: 'text', last: d })

  allthings.sort(function (a, b) {
    return a[1].localeCompare(b[1])
  })
  TWDS.createEle('option', {
    last: ss,
    value: '',
    textContent: filltext
  })
  for (let i = 0; i < allthings.length; i++) {
    TWDS.createEle('option', {
      last: ss,
      value: allthings[i][0],
      textContent: allthings[i][1]
    })
  }
  sf.onchange = function () {
    console.log('OC', this)
    const searchstring = this.value.toLocaleLowerCase()
    const d = this.closest('.filteredselectcontainer')
    const ss = TWDS.q1('select', d)
    const opts = TWDS.q('option', ss)
    for (let i = 0; i < opts.length; i++) {
      const o = opts[i]
      o.style.display = 'block'
      if (searchstring > '' && o.textContent.toLocaleLowerCase().search(searchstring) === -1) {
        o.style.display = 'none'
      }
    }
  }
  sf.onblur = function () {
    sf.onchange.apply(this)
  }
  return d
}
TWDS.utils.stdwindow = function (name, title, minititle, classes) {
  const iscreated = wman.isWindowCreated(name)
  if (iscreated) {
    const ismin = wman.isMinimized(name)
    if (ismin) {
      wman.reopen(name)
    }
    return wman.getById(name)
  }

  const win = wman.open(name, title, classes)
  win.setMiniTitle(minititle || title)
  const sp = new west.gui.Scrollpane()
  win.appendToContentPane(sp.getMainDiv())
  return win
}
TWDS.utils.getcontainer = function (win) {
  return TWDS.q1('.tw2gui_scrollpane_clipper_contentpane', win.getContentPane())
}
TWDS.utils.showhelp = function (key) {
  const win = TWDS.utils.stdwindow('TWDS_helpwindow', 'Ayuda Caché de Ropas', 'Ayuda CR')
  const container = TWDS.utils.getcontainer(win)
  container.innerHTML = ''
  TWDS.createEle('iframe', {
    last: container,
    src: TWDS.baseURL + '/help/' + key + '.html',
    style: {
      width: '100%',
      height: '95%',
      border: '0',
      marginBottom: '1px'
    }
  })
}
// it=itemManager.get(itemid), type=yield && spec_type=crafting should be enough,
// but isn't, as spec_type isn't set correctly everywhere.
TWDS.utils.iscraftableitem = function (itemid) {
  itemid = parseInt(itemid)
  if (!('cacheactive' in TWDS.utils.iscraftableitem)) {
    TWDS.utils.iscraftableitem.cache = {}
    TWDS.utils.iscraftableitem.cacheactive = true
    const a = ItemManager.getAll()
    for (const iid of Object.keys(a)) {
      const it = a[iid]
      if ('craftitem' in it) {
        TWDS.utils.iscraftableitem.cache[it.craftitem] = true
      }
    }
  }
  return TWDS.utils.iscraftableitem.cache[itemid] ?? false
}
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.logging = {}
TWDS.loglist = []
TWDS.dolog = function (lv, ...args) {
  const str = args.join(', ')
  const e = {
    lv: lv,
    ts: (new Date()).getTime(),
    str: str
  }
  TWDS.loglist.push(e)
  const l = TWDS.loglist.length
  const max = 200
  if (l > max) {
    TWDS.loglist = TWDS.loglist.slice(l - max, l)
  }
  const win = wman.getById('TWDS_log_window')
  if (win) {
    const x = TWDS.q1('.TWDS_log_window table tbody')
    if (x) {
      TWDS.logging.prependline(x, e)
    }
  }
}
TWDS.logging.prependline = function (tbody, e) {
  const tr = TWDS.createEle({
    nodeName: 'tr',
    className: 'logline',
    first: tbody
  })
  const d = (new Date(e.ts)).toLocaleTimeString()
  TWDS.createEle({
    nodeName: 'td',
    textContent: d,
    beforeend: tr
  })
  TWDS.createEle({
    nodeName: 'td',
    textContent: e.lv,
    beforeend: tr
  })
  TWDS.createEle({
    nodeName: 'td',
    textContent: e.str,
    beforeend: tr
  })
}
TWDS.debug = function (...args) { TWDS.dolog('d', args) }
TWDS.info = function (...args) { TWDS.dolog('i', args) }
TWDS.error = function (...args) { TWDS.dolog('e', args) }

TWDS.logging.openwindow = function () {
  const win = wman.open('TWDS_log_window', 'Registro', 'TWDS_log_window')
  win.setMiniTitle('Log')

  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_log_container'
  })
  const table = TWDS.createEle('table', { beforeend: content })
  const thead = TWDS.createEle('thead', { beforeend: table })
  thead.appendChild(TWDS.createEle({
    nodeName: 'tr',
    children: [
      { nodeName: 'th', textContent: 'hhmmss', className: 'ts' },
      { nodeName: 'th', textContent: 'lv', className: 'lv' },
      { nodeName: 'th', textContent: 'Contenido', className: 'str' }
    ]
  }))
  const tbody = TWDS.createEle('tbody', { beforeend: table })
  for (let i = 0; i < TWDS.loglist.length; i++) {
    const e = TWDS.loglist[i]
    TWDS.logging.prependline(tbody, e)
  }
  sp.appendContent(content)

  win.appendToContentPane(sp.getMainDiv())
}
// this is not translated, because it runs quite early
TWDS.registerExtra('TWDS.logging.openwindow', 'Inicio sesión', 'Mostrar información de inicio sesión')
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.insertStyles = function () {
  const css = `
    :root {
      --twds-gold: #f8c57c;
      --twds-dark-brown: #5c3f1e;
    }
    .TWDS_clicktarget {
      text-decoration:underline;
      cursor:pointer;
    }

    .TWDS_blinking {
      animation: blinker 0.5s linear 120
    }
    #TWDS_settings {
      display:grid;
      grid-template-columns: 2fr 1fr;
    }
    #TWDS_settings .TWDS_VERSIONINFO {
      grid-row:1;
      grid-column:2;
      border:blue;
      color: #333;
      text-align: right;
      padding: 0 2px 5px 0;
    }
    #TWDS_settings .TWDS_settings_cache {
      grid-row:1/ span 2;
      grid-column:1;
    }
    #TWDS_settings .TWDS_settings_main {
      grid-column:1/ span 2;
    }
    #TWDS_settings h2 {
      font-size:22px;
    }
    #TWDS_settings h2, h3 {
      margin-bottom:0.5em;
      margin-top:1em;
    }
    @keyframes blinker {
      50% {
        opacity: 0;
      }
    }
    .TWDS_chat_highlight {
      background-color: black;
      color:white;
      border-left:2px solid red;
      border-right:2px solid red;
      text-decoration: underline red;
    }

    .TWDS .tw2gui_scrollpane {
      margin:1em 0;
    }
    .TWDS_tabcontent {
      padding-bottom:1em;
    }
    #TWDS_job .hasMousePopup,
    #TWDS_job [title],
    #TWDS_equipment .hasMousePopup,
    #TWDS_equipment [title],
    #TWDS_bonuslist .hasMousePopup,
    #TWDS_bonuslist [title],
    #TWDS_bonus .hasMousePopup,
    #TWDS_bonus [title] {
      text-decoration: dotted underline;
    }
    #TWDS_bonuslist td:first-child {
      text-align:right;
    }
    #TWDS_equipment { border-collapse: collapse;}
    #TWDS_equipment .headrow {
      font-weight:bold;
    }
    #TWDS_equipment .datarow {
      text-align:right;
    }
    #TWDS_equipment .hasMousePopup {
      text-decoration: dotted underline;
    }
    #TWDS_equipment .datarow th:nth-child(1) {
      text-align:left;
      font-weight:normal;
    }
    #TWDS_equipment .best { color: #0c0; font-weight:bold; }
    #TWDS_equipment .verygood { color: #0c0; }
    #TWDS_equipment .good { color: green;}
    #TWDS_equipment .ok { }
    #TWDS_equipment .other { color: #800;}
    #TWDS_equipment tr, #TWDS_equipment td, #TWDS_table th { border:1px solid #888;}
    #TWDS_equipment td, #TWDS_equipment th { padding:1px 2px;}
    .TWDS_button {
      min-width:3.5em;
      border-color:#2B1C19;
      color:white;
      border-width:2px;
      margin:1px;
      border-style:inset;
      padding:1px 1px;
      line-height:18px;
      cursor:pointer;
      background: rgb(46,16,2);
      background: radial-gradient(circle, rgba(46,16,2,1) 0%, rgba(93,63,30,1) 49%, rgba(60,29,6,1) 100%);
    }
    .TWDS_button_small {
      min-width:auto;
    }
    .TWDS_specialequipment_button {
      margin:0.2em 0.5em;
    }
    .TWDS_SPEC_spec {
      display:flex;
      justify-content:space-between;
    }
    .TWDS_SPEC_SKILLS {
      width:100%;
    }
    .TWDS_SPEC_SKILLS td {
      text-align:center;
    }
    .TWDS_SPEC_SKILLS button {
      min-width:100px;
    }
    .TWDS_spec_strength {
      background-color:#8003;
      border-color:red;
    }
    .TWDS_spec_flexibility {
      background-color:#0803;
      border-color:green;
    }
    .TWDS_spec_dexterity {
      background-color:#0083;
      border-color:blue;
    }
    .TWDS_spec_charisma {
      background-color:#8803;
      border-color:yellow;
    }

    #TWDS_people { border-collapse: collapse; width:100%;}
    #TWDS_people tr, #TWDS_people td, #TWDS_people th { border:1px solid #888;}
    #TWDS_people tbody td {
      padding:1px 2px;
      text-align:right;
    }
    #TWDS_people tbody th {
      padding:1px 2px;
      text-align:left;
      text-decoration:underline;
      cursor:pointer;
      font-weight:normal;
    }
    #TWDS_people_subtab table {
      border-collapse: collapse;
    }
    #TWDS_people_subtab .openreport {
      text-decoration:underline;
      cursor:pointer;
    }
    #TWDS_people_subtab .attacker,
    #TWDS_people_subtab .winner {
      text-align:right;
    }
    #TWDS_attr_skill {
      border-collapse: collapse;
    }

    #TWDS_attr_skill .bonus-strength1 {
      border-left:2px solid red;
      border-top:2px solid red;
      border-right:2px solid red;
      background-color:#8003;
    }
    #TWDS_attr_skill .bonus-strength2 {
      border-left:2px solid red;
      border-bottom:2px solid red;
      border-right:2px solid red;
      background-color:#8003;
    }
    #TWDS_attr_skill .bonus-flexibility1 {
      border-left:2px solid green;
      border-top:2px solid green;
      border-right:2px solid green;
      background-color:#0803;
    }
    #TWDS_attr_skill .bonus-flexibility2 {
      border-left:2px solid green;
      border-bottom:2px solid green;
      border-right:2px solid green;
      background-color:#0803;
    }
    #TWDS_attr_skill .bonus-dexterity1 {
      border-left:2px solid blue;
      border-top:2px solid blue;
      border-right:2px solid blue;
      background-color:#0083;
    }
    #TWDS_attr_skill .bonus-dexterity2 {
      border-left:2px solid blue;
      border-bottom:2px solid blue;
      border-right:2px solid blue;
      background-color:#0083;
    }
    #TWDS_attr_skill .bonus-charisma1 {
      border-left:2px solid yellow;
      border-top:2px solid yellow;
      border-right:2px solid yellow;
      background-color:#8802;
    }
    #TWDS_attr_skill .bonus-charisma2 {
      border-left:2px solid yellow;
      border-bottom:2px solid yellow;
      border-right:2px solid yellow;
      background-color:#8803;
    }
    #TWDS_attr_skill td {
      text-align:center;
    }

    table.TWDS_with_border {
      border-collapse: collapse;
    }
    table.TWDS_with_border tr,
    table.TWDS_with_border th,
    table.TWDS_with_border td { border:1px solid #888 }
    table.TWDS_padded th,
    table.TWDS_padded td { padding:1px;}
    th.ra, td.ra { text-align:right }
    th.center, td.center { text-align:enter }


    div.item span.TWDS_itemusageinfo {
      top:0;
      right:0;
      display:block;
      background-color:#8888;
      color:white;
      box-shadow: 1px 1px 2px #000000;
    }
    .TWDS_joblist_stars {
      opacity:0.5;
      color:green;
      text-shadow: 0 0 0px black;
    }
    .TWDS_joblist_stars.TWDS_joblist_stage_gold {
      color:gold;
    }
    .TWDS_joblist_stars.TWDS_joblist_stage_silver {
      color:silver;
    }
    .TWDS_joblist_stars.TWDS_joblist_stage_bronze {
      color:#cd7f32;
    }
    .TWDS_job_negative {
      color:red;
    }
    .TWDS_job_less {
      color:orange;
    }
    #TWDS_job p {
      text-align:right
    }
    #TWDS_job tr.hidden {
      display:none
    }
    #TWDS_job_filtergroup {
      margin-right:2em;
      display:inline-block;
    }
    #TWDS_job_filterx {
      border-radius:5px;
    }

    .job_bestwearbutton {
      top:-10px !important;
    }
    .job_bestwearbutton .twdb_bestwear {
      position:absolute;
      top:0;
    }
    .job_bestwearbutton .TWDS_getbestwear {
      position:absolute;
      top:0;
      position: absolute;
      top: 43px;
      left: 48px;
      line-height:16px;
    }
    #TWDS_storage_list {
      border-collapse:collapse;
    }
    #TWDS_storage_list tr,
    #TWDS_storage_list td,
    #TWDS_storage_list th {
      border:1px solid #888;
    }
    #TWDS_storage_list .TWDS_storage_image img {
      max-height:43px;
    }
    #TWDS_storage_list .TWDS_storage_name .TWDS_joblist_openbutton {
      margin-right:4px;
    }
    #TWDS_storage_list .TWDS_storage_percent {
      text-align:right;
    }
    #TWDS_storage_list .TWDS_storage_count {
      text-align:right;
    }
    #TWDS_storage_list .TWDS_storage_countinput {
      width:5em;
      text-align:right;
    }

    #TWDS_storage_select {
      border:1px solid #888;
      display:none;
    }
    #TWDS_storage_select.visible {
      display:block;
    }
    .TWDS_lp_hint {
      position: absolute;
      left: 2px;
      width: 18px;
      height: 18px;
      background-color: #432;
      border: 2px ridge #976;
      border-radius: 11px;
      background-blend-mode: soft-light;
    }

    .jobgroupicon .TWDS_storage_needs_item,
    .job .item-job {
      width: 20px;
      height: 20px;
      position: absolute;
      font-size:130%;
      color:white;
      color: var(--twds-gold);
      background-color:#2B1C19;
      border:2px solid #4F210D;
      border-radius:10px;
      top: -20px;
      left: +20px;
    }
    .market-buy img[alt="report"] {
      margin-left:5px;
    }
    #TWDS_wuw {
      height:340px;
      overflow-y: auto !important;
      overflow-x: auto !important;
    }
    #TWDS_wuw_table {
      border-collapse: collapse;
    }
    #TWDS_wuw td,
    #TWDS_wuw th {
      border-bottom:1px dotted #888;
      padding:2px;
    }
    #TWDS_wuw td {
      border-left:1px dotted #888;
    }
    input[type=number][size="2"] {
      width:3em;
    }
    input[type=number][size="7"] {
      width:8em;
    }
    #TWDS_tab_itemsets, #TWDS_tab_wuw, #TWDS_tab_settings {
      height:340px;
      overflow-y: auto !important;
      overflow-x: auto !important;
    }

    #TWDS_tab_updates dt {
      margin-left:2px;
      margin-top:1em;
      font-weight:bold;
    }
    #TWDS_tab_updates dd {
      margin-left:1em;
    }
    #TWDS_tab_updates dd::before {
      content: "*";
      margin-right:2px;
    }
    #TWDS_tab_updates dd ul {
      margin-left:2em;
    }
    .TWDS_fbs_basestats_content table {
      margin: 0 auto;
      border-collapse: collapse;
    }
    .TWDS_fbs_basestats_content table thead tr {
      height:24px;
      box-shadow: inset #7a481f 0px -2px 6px 0px;
    }
    .TWDS_fbs_basestats_content table tbody tr {
      height:24px;
      box-shadow: inset #7a481f 0px 2px 6px 0px;
    }
    .TWDS_fbs_basestats_content table tbody td {
      vertical-align:middle;
      text-align:right;
      padding: 0 4px;
      width:230px;
    }
    .TWDS_fbs_basestats_content table tbody th {
      width:176px;
      p
    }
    .TWDS_fbs_basestats_content p {
      margin-bottom:0.5em;
    }
    .TWDS_fbs_basestats_content table thead th {
      padding: 0 8px;
    }
    .TWDS_fbs_basestats_content table td {
      font-family:fixed;
    }
    .TWDS_fbs_basestats_content table th.subhead {
      background-color:wheat;
    }
    .TWDS_fbs_basestats_content .dotnull {
      visibility:hidden;
    }
    .TWDS_fbs_basestats .tw2gui_window_content_pane {
      max-height:320px;
      overflow: auto;
    }
    .TWDS_scrollbar::-webkit-scrollbar-thumb {
      background-color: #584329;
      border-radius: 6px;
      border: 3px solid #584329;
    }
    .TWDS_scrollbar::-webkit-scrollbar-track {
      background: #200;
      border-radius: 6px;
    }
    .TWDS_scrollbar::-webkit-scrollbar {
      width:14px;
    }

    .TWDS_jobwindow_setbuttons {
      height: 50px; /* same as the premium thing it replaces */
      display: flex;
      flex-flow: wrap;
      overflow:hidden;
      justify-content: center;
    }
    .TWDS_jobwindow_setbuttons .TWDS_button {
      margin-top:0;
    }
    .TWDS_settingline {
      padding-left:1.25em;
      text-indent:-1.25em;
    }
    .TWDS_setting_info {
      margin-top:1em;
      border-top:1px dotted #888;
    }
    .TWDS_sleephelper .tw2gui_scrollpane {
      min-width:27em;
    }
    .TWDS_quickusableshelper .tw2gui_scrollpane {
      min-width:16em;
    }
    .TWDS_quickusableshelper .tw2gui_scrollpane li:nth-child(4) {
      border-bottom: 3px solid black;
    }
    .TWDS_sleephelper li span span {
      float:right;
      font-width:bold;
      font-family:fixed;
      line-height:20px;
    }
    .TWDS_sleephelper li span span.stars5,
    .TWDS_sleephelper li span span.stars6 {
      color:green;
    }
    .TWDS_sleephelper li span span.stars1,
    .TWDS_sleephelper li span span.stars2 {
      color:red;
    }
    .TWDS_clickable {
      cursor:pointer;
    }
    #TWDS_trackbar_container {
      width: 515px;
      height: 20px;
      bottom: 64px;
      position: absolute;
      z-index: 13;
      left: 50%;
      margin-left: -258px;
      display: flex;
      justify-content: space-around;
      background: rgb(46,16,2);
      background: url('https://westde.innogamescdn.com/images/tw2gui/window/minimized_bg.png?24');
      background-position: 0 -35px;
    }
    #user-interface.TWDS_trackbar_active  .friendsbar-toggle {
      bottom:84px;
    }
    #user-interface.TWDS_trackbar_active.friendsbar-open  .friendsbar-toggle {
      bottom:158px;
    }
    #TWDS_trackbar_container .TWDS_trackbar_tracker {
      height:12px;
      flex-grow:1;
      margin:2px;
      box-sizing:border-box;
      border:1px solid hsl(0deg 0% 40%);
      background: url('https://westde.innogamescdn.com/images/tw2gui/window/minimized_bg.png?24');
      background-position: 0 -3px;
      position:relative;
      border-radius:8px;
    }
    #TWDS_trackbar_container .TWDS_trackbar_tracker::before {
      width:var(--twds-progress);
      display:block;
      content: "x";
      color:transparent;
      background-color: hsl(32deg 76% 45%);
      position:absolute;
      border-radius:8px;
      height:12px;
      margin-top:-1px;
      mix-blend-mode:difference;
    }
    #TWDS_trackbar_container .TWDS_trackbar_xp::before {
      background-color: hsl(32deg 76% 45%);
    }
    #TWDS_trackbar_container .TWDS_trackbar_achievement::before {
      background-color: hsl(181deg 41% 40%)
    }
    #TWDS_trackbar_container .TWDS_trackbar_storage::before {
      background-color: hsl(121deg 76% 35%);
    }
    #TWDS_trackbar_container .TWDS_trackbar_product::before {
      background-color: hsl(151deg 56% 35%);
    }
    #TWDS_trackbar_container .TWDS_trackbar_tracker::after {
      content: attr(data-text);
      color:black;
      position:absolute;
      left:3px;
      font-size:10px;
      height:100%;
      line-height:100%;
      color:#FFF;
    }
    body.TWDS_quicksilver_exclamation .TWDS_gold::after,
    body.TWDS_quicksilver_exclamation .TWDS_silver::after {
      content: "!";
      display: block;
      font-size: 96px;
      position: relative;
      font-weight: bold;
      width: 100%;
      height: 100%;
      left: 50%;
      top: -50%;
      color:transparent;
      font-style: italic;
      text-shadow:3px 2px black;
    }
    body.TWDS_quicksilver_exclamation .TWDS_gold.opened::after,
    body.TWDS_quicksilver_exclamation .TWDS_silver.opened::after {
      color:transparent;
      text-shadow:none;
    }
    body.TWDS_quicksilver_exclamation .TWDS_gold::after {
      color:gold;
    }
    body.TWDS_quicksilver_exclamation .TWDS_silver::after {
      color:silver;
    }
    body.TWDS_quicksilver_exclamation .TWDS_gold,
    body.TWDS_quicksilver_exclamation .TWDS_silver {
      outline-color: transparent;
      background-color:transparent;
    }
    .TWDS_gold, .TWDS_silver {
      outline-style:solid;
      outline-color: transparent;
      outline-width: 3px;
      outline-offset:3px;
    }
    .TWDS_gold {
      background-color:gold;
      outline-color: gold;
    }
    .TWDS_silver {
      background-color:silver;
      outline-color: silver;
    }
    #ui_questtracker .TWDS-quest-list-to-book {
      display:none;
      color:white;
      line-height:13px;
    }
    #ui_questtracker .quest-list.title:hover .TWDS-quest-list-to-book {
      display: inline-block;
      zoom: 1;
    }
    body.TWDS_daily_tasks_open .char_links.daily::after {
      content: "\\21da";
      display: block;
      color: red;
      position: relative;
      left: 25px;
      top:2px;
      letter-spacing: -4px;
      font-size: 350%;
      font-weight: bold;
      line-height: 20px;
      text-shadow: #000 1px 1px;
    }
    body.TWDS_quest_finishable #ui_menubar > .questtracker::after {
      content: "\\2794";
      display: block;
      color: orange;
      position: absolute;
      right: 36px;
      top:13px;
      letter-spacing: -4px;
      font-size: 200%;
      font-weight: bold;
      line-height: 20px;
      text-shadow: #000 1px 1px;
    }
    body.TWDS_quest_finishable #windows > .questtracker {
      box-shadow: orange -1px -1px 10px 3px;
    }
    body.TWDS_show_trader_max_value .item_sell .pricing_container .input_max_value {
      display: block;
      border: 1px solid #8a6322;
      margin-bottom: 5px;
      border-radius: 4px;
      background-color: #d6d2cd;
    }
    body.TWDS_searchmode .TWDS_minimap_navcontainer {
      opacity:1.0;
      border:1px solid #0008;
      border-radius:8px;
      background-color:#2228;
      position:fixed;
      left:calc(50% - 39px);
      top:calc(50% - 39px);
    }
    .TWDS_overlay {
      position:fixed;
      z-index:1;
      cursor:move;
      background-Color:#2228;
      border:1px solid white;
      width: max-content;
      height: max-content;
      color:white;
      padding:4px;
      cursor:move,
    }
    .TWDS_overlay:hover {
      outline:2px dashed green;
    }
    .TWDS_overlay table td {
      text-align:right;
    }
    .TWDS_overlay table th {
      font-weight:normal;
      text-align:left;
    }
    .TWDS_overlay table th:nth-child(3) {
      padding-left:0.75em;
    }
    .TWDS_overlay_battledata {
      border-collapse: collapse;
    }
    .TWDS_overlay_battledata td {
      border:1px solid #888;
      padding:1px 2px;
    }
    .TWDS_overlay_battledata td:first-child {
      text-align:left;
      padding-right:0.5em;
    }
    .TWDS_overlay_battledata td:nth-child(2),
    .TWDS_overlay_battledata td:nth-child(4),
    .TWDS_overlay_battledata td:nth-child(6) {
      text-align:left;
    }
    .TWDS_overlay .note {
      border-top:1px dotted #f00;
    }
    .TWDS_overlay .note:hover {
      border-top:1px dotted #f00;
      cursor:text;
    }
    .TWDS_overlay:hover .note:after {
      border-top:1px dotted #888;
      display:block;
      position: absolute;
      content:'✏';
      right: 0em;
      bottom: -0.25em;
      font-size: 2em;
      color:#FFF;
      transform: rotate(45deg);
      cursor:text;
      z-index:2;
    }
    .TWDS_overlay > div {
      margin-top:1.0em;
    }
    .TWDS_overlay > div:first-child {
      margin-top:0.0em;
    }
    .TWDS_trader_filter_collectibles {
      position:absolute;
      right: 15px;
      top:4px;
      accent-color:var(--twds-dark-brown);
    }
    .TWDS_trader_town_shop_search {
      position:absolute;
      right:80px;
      top:4px;
      width:110px;
      accent-color:var(--twds-dark-brown);
    }
    .TWDS_smartstart {
      position:absolute;
      bottom:120px;
      left:10px !important;
      background-color:var(--twds-dark-brown);
      color:white;
      width:80px;
      padding-block:3px;
      text-align:center;
    }
    div.job_durationbar .TWDS_jw_luck {
      top:135px;
      right:16px;
      left:auto;
      width:65px;
      color: rgb(119, 255, 119);
    }
    div.job_durationbar .TWDS_jw_luck::after {
      content: "\\2618";
      display:inline;
      color: rgb(119, 255, 119);
    }
    .TWDS_itemusewindow table {
      border-collapse:collapse;
      border:1px solid #888;
    }
    .TWDS_itemusewindow .header td,
    .TWDS_itemusewindow .header th {
      border-bottom: 3px solid #888;
    }
    .TWDS_itemusewindow th:first-child {
      border-right: 1px solid #888;
    }
    .TWDS_itemusewindow table th,
    .TWDS_itemusewindow table td {
    border-bottom:1px solid #888;
    }
    .TWDS_collections_list dd > span {
      display:inline-block;
    }
    .TWDS_collections_list dd > span > .item {
      float:none;
      display:inline-block;
    }
    .TWDS_collections_list dd > span > b {
      display: inline-flex;
      flex-direction: column;
    }
    .TWDS_shopitemlink {
      display: inline-block;
      cursor: pointer;
      vertical-align: middle;
      margin-right: 2px;
    }
    .TWDS_marketsearchlink {
      display: inline-block;
      cursor: pointer;
      vertical-align: middle;
      margin-right: 2px;
    }
    .TWDS_questgivers_list dt {
      cursor:pointer;
      font-weight:bold;
      margin-top:1em;
    }
    .TWDS_questgivers_list dd {
      padding-left:2em;
      height:20px;
      font-weight:bold;
      border-top:2px solid #eec;
    }
    .TWDS_questgivers_list .TWDS_questlist_questlink {
      cursor:pointer;
      text-decoration:underline;
      padding-right:2em;
    }
    .TWDS_questgivers_list .TWDS_questlist_questlink.finishable {
      color:rgb(102,102,102);
    }
    .TWDS_questgivers_list .TWDS_questlist_questlink::before {
      content: " ";
      position:static;
      margin-left:-1em;
      display:inline-block;
      background: url(https://westen.innogamescdn.com/images/tw2gui/iconset.png?14) no-repeat;
      width: 16px;
      height: 16px;
      background-position: 16px 1000px;
    }
    .TWDS_questgivers_list .TWDS_questlist_questlink.acceptable::before {
      background-position: -48px -64px;
    }
    .TWDS_questgivers_list .TWDS_questlist_questlink.accepted::before {
      background-position: -112px -96px;
    }
    .TWDS_questgivers_list .TWDS_questlist_questlink.finishable::before {
      background-position: -128px -80px;
    }
    .TWDS_questgivers_list .TWDS_questlist_questgrouplink {
      cursor:pointer;
      text-decoration:underline;
    }
    .TWDS_questlist_please_wait {
      font-size:200%;
      color: red;
    }
    .TWDS_questlist_please_wait::before {
      content: "!";
      font-size:250%;
    }
    .TWDS_questlist_please_wait::after {
      content: "!";
      font-size:250%;
    }

    .TWDS_altinv_container table {
      border-collapse: collapse;
    }
    .TWDS_altinv_container td,
    .TWDS_altinv_container th {
      border: 1px solid #888;
      padding:1px;
      vertical-align:middle;
    }
    .TWDS_altinv_container tbody .itemname {
    }
    .TWDS_altinv_container tbody .used .itemname {
    }
    .TWDS_altinv_container tbody .setname {
      font-weight: bold;
    }
    .TWDS_altinv_container tbody .buy,
    .TWDS_altinv_container tbody .sell {
      font-weight: bold;
    }
    .TWDS_altinv_container tbody .setitemcount,
    .TWDS_altinv_container tbody .count {
      text-align: right;
    }
    .TWDS_altinv_container tbody .searchword {
      float: right;
      font-weight: normal;
    }
    .TWDS_altinv_container tbody .setname {
      text-decoration: underline;
    }
    .TWDS_altinv_container tbody .setrow .unused {
      color:red;
    }
    .TWDS_altinv_container tbody .itemrow .unused {
      color:red;
    }
    .TWDS_altinv_container tbody .itemrow .used {
      text-decoration: underline;
    }
    .TWDS_minimap_export_pos:hover {
      text-decoration:underline;
    }
    .market-buy .TWDS_storage_missing::before {
      content: '[' attr(data-have) ' / ' attr(data-want) ']';
      padding-inline:2px;
      color: red;
    }
    .market-buy .TWDS_collection_missing::before {
      content: '\\1F3C6';
      width:24px;
      font-size:larger;
      padding-inline:1px;
      color: palegoldenrod;
    }
    .TWDS_craftcalc_inputarea {
      display:flex;
      justify-content:space-around;
    }
    .TWDS_craftcalc_content h1 {
      margin-top:1em;
    }
    .TWDS_craftcalc_content h1:first-child {
      margin-top:0em;
    }
    .TWDS_craftcalc_resultarea {
      border-top:2px solid #888;
      margin-top:1em;
    }
    .TWDS_collections_shoplink {
      cursor:pointer;
    }
@charset "UTF-8";
.TWDS_craft_button img {
  width: 24px; }

.TWDS_job_open_button {
  display: inline-block;
  vertical-align: middle; }

.TWDS_helpwindow .tw2gui_scrollpane_clipper_contentpane {
  height: 100%; }

#popup-container .TWDS_c15extras,
.tw2gui_window.minimap .TWDS_c15extras {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  text-align: right; }

#popup-container .TWDS_bonusjob,
.tw2gui_window.minimap .TWDS_bonusjob {
  z-index: 7;
  position: absolute;
  display: block;
  width: 6px;
  height: 6px;
  background-color: white;
  border: 1px solid black;
  box-sizing: border-box; }
  #popup-container .TWDS_bonusjob.noabs,
  .tw2gui_window.minimap .TWDS_bonusjob.noabs {
    position: static;
    display: inline-block; }
  #popup-container .TWDS_bonusjob.gold,
  .tw2gui_window.minimap .TWDS_bonusjob.gold {
    background-color: yellow;
    border-color: red; }
  #popup-container .TWDS_bonusjob.storagemissing,
  .tw2gui_window.minimap .TWDS_bonusjob.storagemissing {
    border-color: #00cc00;
    border-width: 2.3px; }
  #popup-container .TWDS_bonusjob.collection,
  .tw2gui_window.minimap .TWDS_bonusjob.collection {
    border-color: #880088;
    border-width: 2.3px; }
  #popup-container .TWDS_bonusjob.hl_always,
  .tw2gui_window.minimap .TWDS_bonusjob.hl_always {
    border-color: #ff3197;
    border-width: 2.3px; }
  #popup-container .TWDS_bonusjob.tracked,
  .tw2gui_window.minimap .TWDS_bonusjob.tracked {
    border-color: #4983ff;
    border-width: 2.3px; }
  #popup-container .TWDS_bonusjob.searched,
  .tw2gui_window.minimap .TWDS_bonusjob.searched {
    border-color: #FF00FF;
    border-width: 2.3px; }
  #popup-container .TWDS_bonusjob.marked,
  .tw2gui_window.minimap .TWDS_bonusjob.marked {
    outline: 2px dotted red; }

#popup-container .TWDS_minimap_taskjob_button,
.tw2gui_window.minimap .TWDS_minimap_taskjob_button {
  padding-left: 29px;
  text-decoration: underline;
  cursor: pointer; }

#popup-container #TWDS_minimap_silvergold,
.tw2gui_window.minimap #TWDS_minimap_silvergold {
  display: inline-block;
  float: right;
  margin-right: 8px; }
  #popup-container #TWDS_minimap_silvergold label span,
  .tw2gui_window.minimap #TWDS_minimap_silvergold label span {
    display: inline-block;
    min-width: 12px;
    height: 12px;
    background-color: silver;
    border: 1px solid black;
    color: black;
    line-height: 12px;
    text-align: center;
    margin: 1px 2px;
    cursor: pointer; }

#popup-container .TWDS_minimap_navcontainer,
.tw2gui_window.minimap .TWDS_minimap_navcontainer {
  position: absolute;
  right: 20px;
  font-size: 200%;
  top: 218px;
  width: 78px;
  height: 78px; }
  #popup-container .TWDS_minimap_navcontainer span:hover,
  .tw2gui_window.minimap .TWDS_minimap_navcontainer span:hover {
    color: white;
    color: green;
    background-color: black; }
  #popup-container .TWDS_minimap_navcontainer span,
  .tw2gui_window.minimap .TWDS_minimap_navcontainer span {
    width: 26px;
    height: 26px;
    line-height: 22px;
    text-align: center;
    position: absolute;
    cursor: pointer; }
  #popup-container .TWDS_minimap_navcontainer .up,
  .tw2gui_window.minimap .TWDS_minimap_navcontainer .up {
    top: 0;
    left: 26px;
    cursor: n-resize; }
  #popup-container .TWDS_minimap_navcontainer .down,
  .tw2gui_window.minimap .TWDS_minimap_navcontainer .down {
    bottom: 0;
    left: 26px;
    cursor: s-resize; }
  #popup-container .TWDS_minimap_navcontainer .left,
  .tw2gui_window.minimap .TWDS_minimap_navcontainer .left {
    left: 0;
    top: 26px;
    cursor: w-resize; }
  #popup-container .TWDS_minimap_navcontainer .right,
  .tw2gui_window.minimap .TWDS_minimap_navcontainer .right {
    right: 0;
    top: 26px;
    cursor: e-resize; }
  #popup-container .TWDS_minimap_navcontainer .TWDS_minimap_opacity_checkbox,
  .tw2gui_window.minimap .TWDS_minimap_navcontainer .TWDS_minimap_opacity_checkbox {
    right: calc(39px - 0.5em);
    top: calc(39px - 0.5em);
    position: absolute; }
  body.TWDS_searchmode #popup-container .TWDS_minimap_navcontainer, body.TWDS_searchmode .tw2gui_window.minimap .TWDS_minimap_navcontainer {
    opacity: 1.0;
    border: 1px solid #0008;
    border-radius: 8px;
    background-color: #2228;
    position: fixed;
    left: calc(50% - 39px);
    top: calc(50% - 39px); }

body.TWDS_searchmode #user-interface,
body.TWDS_searchmode #windows > * {
  display: none !important; }

body.TWDS_searchmode #windows > .minimap {
  display: block !important;
  width: 0px;
  height: 0px;
  overflow: hidden; }

#TWDS_joblist_container .hasMousePopup,
#TWDS_joblist_container [title] {
  text-decoration: underline; }

#TWDS_joblist_container p {
  text-align: right;
  display: grid; }

#TWDS_joblist_container #TWDS_job_filtergroup {
  grid-column: 1;
  grid-row: 1 / span 3;
  margin-right: 2em;
  display: inline-block; }

#TWDS_joblist_container #TWDS_job_modearea {
  grid-column: 2;
  grid-row: 1; }

#TWDS_joblist_container #TWDS_job_searchgroup {
  grid-column: 2;
  grid-row: 2; }

#TWDS_joblist_container #TWDS_job_search {
  width: 140px; }

#TWDS_joblist_container #TWDS_job_duration {
  grid-column: 2;
  grid-row: 3;
  justify-self: end;
  min-width: 5em; }

#TWDS_joblist_container #TWDS_joblist_filter_container {
  text-align: left; }
  #TWDS_joblist_container #TWDS_joblist_filter_container fieldset {
    display: inline-block;
    max-width: 12em; }
  #TWDS_joblist_container #TWDS_joblist_filter_container select {
    display: block; }
  #TWDS_joblist_container #TWDS_joblist_filter_container input {
    display: block;
    width: 75px; }

#TWDS_joblist_container #TWDS_jobs {
  margin-bottom: 1em;
  border-collapse: collapse;
  width: 98%;
  margin-left: 1%;
  margin-right: 1%; }
  #TWDS_joblist_container #TWDS_jobs tr, #TWDS_joblist_container #TWDS_jobs td, #TWDS_joblist_container #TWDS_jobs th {
    border: 1px solid #888; }
  #TWDS_joblist_container #TWDS_jobs td {
    text-align: right; }
  #TWDS_joblist_container #TWDS_jobs td[data-field=name] {
    text-align: left;
    padding: 1px 2px; }
  #TWDS_joblist_container #TWDS_jobs th[data-field=danger] {
    color: red; }
  #TWDS_joblist_container #TWDS_jobs th[data-field=luck] {
    color: green; }
  #TWDS_joblist_container #TWDS_jobs tr.gold td {
    background-color: #ffd70050; }
  #TWDS_joblist_container #TWDS_jobs tr.silver td {
    background-color: #c0c0c080; }
  #TWDS_joblist_container #TWDS_jobs input.color {
    width: 19px;
    height: 19px; }

#TWDS_joblist_container .TWDS_joblist_stars {
  opacity: 0.5;
  color: green;
  text-shadow: 0 0 0px black; }

#TWDS_joblist_container .TWDS_joblist_stars.TWDS_joblist_stage_gold {
  color: gold; }

#TWDS_joblist_container .TWDS_joblist_stars.TWDS_joblist_stage_silver {
  color: silver; }

#TWDS_joblist_container .TWDS_joblist_stars.TWDS_joblist_stage_bronze {
  color: #cd7f32; }

#TWDS_joblist_container .TWDS_job_negative {
  color: red; }

#TWDS_joblist_container .TWDS_job_less {
  color: orange; }

#TWDS_joblist_container #TWDS_job p {
  text-align: right; }

#TWDS_joblist_container #TWDS_jobs tr.hidden {
  display: none; }

#TWDS_joblist_container #TWDS_job_filterx {
  border-radius: 5px; }

#market_buytable .TWDS_market_buy_red {
  color: red !important; }

#market_buytable .TWDS_market_buy_green {
  color: green !important; }

#market_buytable .TWDS_market_buy_blue {
  color: blue !important; }

#market_buytable .mpb_buynow {
  color: inherit !important; }

#market_createoffer_window .TWDS_market_bulkmode_active {
  outline: 2px solid red;
  background-color: #ffcec0c0; }

#market_createoffer_window .TWDS_market_bulkmode_container {
  margin-top: 0.5em; }

#market_createoffer_window .TWDS_surcharge_line span {
  padding-left: 0.5em;
  padding-right: 0.5em;
  cursor: pointer; }

.marketplace.active_tab_id_sell .TWDS_sellstat {
  font-size: smaller; }

.TWDS_market_map td:first-child {
  padding-left: 1.15em; }

.TWDS_market_map .townline td {
  padding-top: 0.5em;
  padding-left: 0.15em; }

.TWDS_market_map .townline_dist .linklike {
  padding-left: 0.2em;
  padding-right: 0.2em; }

.TWDS_market_map .townline_center {
  padding-left: 0.2em;
  padding-right: 0.2em; }

.TWDS_craftwindow_content {
  height: 373px;
  overflow-y: auto !important;
  overflow-x: auto !important; }
  .TWDS_craftwindow_content .head {
    display: grid;
    justify-content: space-between; }
    .TWDS_craftwindow_content .head select, .TWDS_craftwindow_content .head input {
      align-self: start; }
    .TWDS_craftwindow_content .head h3 {
      grid-column: 1;
      grid-row-start: 1;
      grid-row-end: 3;
      margin-top: 0.25em;
      margin-bottom: 0.15em; }
      .TWDS_craftwindow_content .head h3 span:last-child {
        padding-left: 0.5em; }
    .TWDS_craftwindow_content .head .proffilter {
      grid-row: 1;
      grid-column: 2; }
    .TWDS_craftwindow_content .head .quickfilter {
      grid-row: 1;
      grid-column: 3; }
    .TWDS_craftwindow_content .head .searchfilter {
      grid-row: 1;
      grid-column: 4; }
    .TWDS_craftwindow_content .head label.pointfilter {
      grid-row: 2;
      grid-column: 4; }
    .TWDS_craftwindow_content .head label.blocktimefilter {
      grid-row: 2;
      grid-column: 3; }
  .TWDS_craftwindow_content .TWDS_craftwindow_divider1 {
    background-image: url("https://westde.innogamescdn.com/images/window/market/wood_devider.png");
    height: 12px;
    width: 90%;
    background-repeat: no-repeat;
    margin: 0 auto;
    background-position: top -13px right;
    background-clip: border-box;
    background-size: cover;
    background-attachment: local;
    margin-top: 0.15em; }

.TWDS_craftwindow_table {
  min-width: 90%;
  margin: 0 auto 0.15em;
  border-collapse: collapse; }
  .TWDS_craftwindow_table .recipeline th, .TWDS_craftwindow_table .recipeline td {
    padding: 2px; }
  .TWDS_craftwindow_table tbody {
    border-bottom: 1px solid #1d150a; }
  .TWDS_craftwindow_table td:first-child {
    border-left: 1px solid #1d150a; }
  .TWDS_craftwindow_table td:last-child {
    border-right: 1px solid #1d150a; }
  .TWDS_craftwindow_table th:first-child {
    border-left: 1px solid #1d150a; }
  .TWDS_craftwindow_table th:last-child {
    border-right: 1px solid #1d150a; }
  .TWDS_craftwindow_table thead th,
  .TWDS_craftwindow_table .recipeline td,
  .TWDS_craftwindow_table .recipeline th {
    border-top: 1px solid #1d150a;
    border-bottom: 1px solid #1d150a; }
  .TWDS_craftwindow_table .recipeline .toggle {
    text-decoration: none; }
  .TWDS_craftwindow_table .recipeline.cangetpoints th {
    color: green; }
  .TWDS_craftwindow_table .theinput {
    width: 4em; }
  .TWDS_craftwindow_table .max {
    font-weight: bold; }
  .TWDS_craftwindow_table .levels span:nth-child(1) {
    color: #92753a; }
  .TWDS_craftwindow_table .levels span:nth-child(3) {
    color: #3c903c; }
  .TWDS_craftwindow_table .levels span:nth-child(5) {
    color: #229aaa; }
  .TWDS_craftwindow_table .levels .current {
    font-weight: bold; }
  .TWDS_craftwindow_table .dolearn {
    background-color: green;
    color: white; }
  .TWDS_craftwindow_table button {
    margin-left: 0.33em; }
  .TWDS_craftwindow_table button:first-child {
    margin-left: 0; }

.TWDS_craftwindow_table .resourceline {
  display: none; }
  .TWDS_craftwindow_table .resourceline.active {
    display: table-row; }
  .TWDS_craftwindow_table .resourceline img {
    max-height: 43px; }
  .TWDS_craftwindow_table .resourceline section {
    display: inline-grid;
    border: 1px solid #888;
    margin: 2px; }
    .TWDS_craftwindow_table .resourceline section .imgwrapper {
      grid-row: 1;
      grid-column: 1;
      background: url(//westen.innogamescdn.com/images/inventory/itembox.png?9);
      background-repeat: no-repeat; }
    .TWDS_craftwindow_table .resourceline section .numbers {
      grid-row: 2;
      grid-column: 1; }
    .TWDS_craftwindow_table .resourceline section .functions {
      grid-row: 1 / span 2;
      grid-column: 2;
      width: 18px;
      padding-left: 0.2em;
      border-left: 1px solid #888; }
      .TWDS_craftwindow_table .resourceline section .functions .TWDS_item_sell_button {
        color: green; }

.window-quest_employer .finishable .TWDS_minimaplink, .window-quest_log .finishable .TWDS_minimaplink, #ui_questtracker .finishable .TWDS_minimaplink {
  opacity: 0.5; }

.window-quest_employer .questlog_entrie .finishable, .window-quest_log .questlog_entrie .finishable, #ui_questtracker .questlog_entrie .finishable {
  color: #070; }

.window-quest_employer .TWDS_questentry_functions.with_craftlink ~ .quest_craftlink, .window-quest_log .TWDS_questentry_functions.with_craftlink ~ .quest_craftlink, #ui_questtracker .TWDS_questentry_functions.with_craftlink ~ .quest_craftlink {
  display: none !important; }

.window-quest_employer .TWDS_craft_button, .window-quest_log .TWDS_craft_button, #ui_questtracker .TWDS_craft_button {
  vertical-align: middle; }
  .window-quest_employer .TWDS_craft_button img, .window-quest_log .TWDS_craft_button img, #ui_questtracker .TWDS_craft_button img {
    width: 15px;
    height: 15px; }

.window-quest_employer .TWDS_quest_fn_craft, .window-quest_log .TWDS_quest_fn_craft, #ui_questtracker .TWDS_quest_fn_craft {
  background-image: url("/images/items/yield/toolbox.png");
  width: 15px;
  height: 15px;
  display: inline-block;
  background-size: contain;
  vertical-align: middle; }

.window-quest_employer .TWDS_quest_fn_buy, .window-quest_log .TWDS_quest_fn_buy, #ui_questtracker .TWDS_quest_fn_buy {
  background-image: url("/images/icons/bid.png");
  width: 12px;
  height: 15px;
  display: inline-block;
  background-size: contain;
  vertical-align: middle; }

.jobwindow .item.TWDS_jobwindow_collectible {
  position: absolute;
  right: 8px;
  top: 26px;
  width: 37px;
  height: 37px; }
  .jobwindow .item.TWDS_jobwindow_collectible img {
    width: 100%;
    height: auto;
    margin-left: 0;
    margin-top: 0; }

.jobwindow .TWDS_quickequipment_shirt {
  display: inline-block;
  position: absolute;
  right: 79px;
  bottom: -7px; }

.jobwindow .TWDS_jw_editable {
  position: absolute;
  left: -16px;
  top: -37px;
  min-width: 19px;
  min-height: 19px;
  color: #eee; }
  .jobwindow .TWDS_jw_editable:hover {
    outline: 2px dashed #888; }
  .jobwindow .TWDS_jw_editable.emptyeditable:hover:after {
    position: absolute;
    content: '✏';
    right: 0em;
    bottom: -0.25em;
    font-size: 2em;
    color: #FFF;
    transform: rotate(45deg);
    cursor: text;
    z-index: 2; }

.TWDS_simulator_window .target {
  width: 60px;
  margin: 2px 1px;
  display: inline-grid; }
  .TWDS_simulator_window .target .leveling {
    grid-row: 2; }
  .TWDS_simulator_window .target .item {
    grid-row: 1; }
    .TWDS_simulator_window .target .item img {
      width: auto;
      max-height: 60px; }

.TWDS_simulator_window .comboareacontainer {
  display: grid;
  justify-content: space-around; }

.TWDS_simulator_window .comboarea {
  vertical-align: top;
  display: inline-block;
  width: 325px; }
  .TWDS_simulator_window .comboarea .setselectarea select {
    max-width: 95%; }
  .TWDS_simulator_window .comboarea .usecurrent {
    float: right;
    font-size: 20px;
    padding-right: 20px; }

.TWDS_simulator_window .comboarea0 {
  grid-row: 1;
  grid-column: 1; }

.TWDS_simulator_window .arrowarea {
  grid-row: 1;
  grid-column: 2;
  font-size: 24px; }

.TWDS_simulator_window .comboarea1 {
  grid-row: 1;
  grid-column: 3;
  text-align: right;
  position: relative; }
  .TWDS_simulator_window .comboarea1.disabled div {
    opacity: 0.0; }
  .TWDS_simulator_window .comboarea1.disabled::before, .TWDS_simulator_window .comboarea1.disabled::after {
    position: absolute;
    content: "";
    background: red;
    display: block;
    width: 90%;
    height: 2px;
    transform: rotate(-45deg);
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    margin: auto; }
  .TWDS_simulator_window .comboarea1.disabled::after {
    transform: rotate(45deg); }

.TWDS_simulator_window .red {
  color: #900; }

.TWDS_simulator_window .green {
  color: #070; }

.TWDS_simulator_window .delta {
  color: #666; }

.TWDS_simulator_window .delta::before {
  content: "("; }

.TWDS_simulator_window .delta::after {
  content: ")"; }

.TWDS_simulator_window .results td, .TWDS_simulator_window .results th {
  min-width: 4em; }

.TWDS_simulator_window .results th {
  padding-left: 2em; }

.TWDS_simulator_window .results td {
  text-align: right; }

.TWDS_simulator_window h2 {
  text-align: center;
  line-height: 30px;
  margin: 5px 0 10px;
  font-size: 18px;
  font-weight: bold;
  position: relative; }
  .TWDS_simulator_window h2 input {
    right: 0;
    position: absolute; }

.TWDS_simulator_window table.alljobs {
  margin-top: 1em; }

div.tw2gui_win2.TWDS_simulator_window {
  height: 768px !important; }
  div.tw2gui_win2.TWDS_simulator_window .tw2gui_window_inset {
    background-size: 722px 734px; }
    div.tw2gui_win2.TWDS_simulator_window .tw2gui_window_inset .tw2gui_inner_window_bg2 {
      background-size: cover;
      width: 20px;
      right: 0; }

.TWDS_craftcalc table.needed {
  border-collapse: collapse; }
  .TWDS_craftcalc table.needed .available.red {
    color: red; }
  .TWDS_craftcalc table.needed .available {
    text-align: right; }
  .TWDS_craftcalc table.needed th, .TWDS_craftcalc table.needed td {
    border: 1px solid #888; }
  .TWDS_craftcalc table.needed .functions > * {
    margin-right: 1em; }

.TWDS_craftcalc .forcopying {
  margin: 0.5em 0 0.5em 1em;
  user-select: text; }

.TWDS_craftcalc .TWDS_craftcalc_resultarea {
  user-select: text; }

div.tw2gui_window.TWDS_wide_window {
  --w: Min( Max(50vw,748px), 1400px);
  --h: Min( Max(66vh,471px) , 845px);
  width: var(--w) !important;
  height: var(--h) !important; }
  div.tw2gui_window.TWDS_wide_window .tw2gui_window_inset {
    left: 0;
    clip-path: polygon(12px 0, 100% 0, 100% 100%, 12px 100%);
    background-size: calc( var(--w) - 14px) calc( var(--h) - 46px); }
    div.tw2gui_window.TWDS_wide_window .tw2gui_window_inset .tw2gui_inner_window_bg2 {
      background-size: calc( var(--w) - 14px) calc( var(--h) - 46px);
      width: 20px;
      right: 0; }

#TWDS_tab_itemsets #TWDS_itemsettable_plus,
#TWDS_tab_itemsets #TWDS_itemsettable_minus,
.TWDS_itemset_window #TWDS_itemsettable_plus,
.TWDS_itemset_window #TWDS_itemsettable_minus {
  min-width: 2em;
  margin-right: 0.5em; }

#TWDS_tab_itemsets .TWDS_itemsets_filterline,
.TWDS_itemset_window .TWDS_itemsets_filterline {
  display: flex;
  justify-content: space-between; }
  #TWDS_tab_itemsets .TWDS_itemsets_filterline div, #TWDS_tab_itemsets .TWDS_itemsets_filterline label,
  .TWDS_itemset_window .TWDS_itemsets_filterline div,
  .TWDS_itemset_window .TWDS_itemsets_filterline label {
    grid-row: 1; }
  #TWDS_tab_itemsets .TWDS_itemsets_filterline label:last-child,
  .TWDS_itemset_window .TWDS_itemsets_filterline label:last-child {
    grid-row: 2;
    grid-column: 3 / span 2; }

#TWDS_tab_itemsets .TWDS_itemsets_options select,
#TWDS_tab_itemsets .TWDS_itemsets_options label,
.TWDS_itemset_window .TWDS_itemsets_options select,
.TWDS_itemset_window .TWDS_itemsets_options label {
  margin-left: 1em; }

#TWDS_tab_itemsets #TWDS_itemset_table,
.TWDS_itemset_window #TWDS_itemset_table {
  border-collapse: collapse; }
  #TWDS_tab_itemsets #TWDS_itemset_table thead,
  .TWDS_itemset_window #TWDS_itemset_table thead {
    position: sticky;
    top: 0;
    background-color: wheat; }
  #TWDS_tab_itemsets #TWDS_itemset_table td.perlevel,
  .TWDS_itemset_window #TWDS_itemset_table td.perlevel {
    font-style: italic; }
  #TWDS_tab_itemsets #TWDS_itemset_table td,
  #TWDS_tab_itemsets #TWDS_itemset_table tbody th,
  .TWDS_itemset_window #TWDS_itemset_table td,
  .TWDS_itemset_window #TWDS_itemset_table tbody th {
    border: 1px solid #888;
    padding: 2px;
    font-size: inherit; }
  #TWDS_tab_itemsets #TWDS_itemset_table thead th,
  .TWDS_itemset_window #TWDS_itemset_table thead th {
    border: 1px solid #888;
    padding: 2px;
    font-size: inherit; }
  #TWDS_tab_itemsets #TWDS_itemset_table thead tr.colspanrow th,
  .TWDS_itemset_window #TWDS_itemset_table thead tr.colspanrow th {
    border-top: none; }
  #TWDS_tab_itemsets #TWDS_itemset_table tbody th.setname,
  .TWDS_itemset_window #TWDS_itemset_table tbody th.setname {
    cursor: pointer; }

body.TWDS_itemsettable_hidemany #TWDS_itemset_table .maybehidden {
  display: none; }

#TWDS_extras ul {
  columns: 2; }

.TWDS_bufflist_window .TWDS_bufflist_table {
  border-collapse: collapse; }
  .TWDS_bufflist_window .TWDS_bufflist_table th, .TWDS_bufflist_window .TWDS_bufflist_table td {
    border: 1px solid #888;
    padding: 1px; }
  .TWDS_bufflist_window .TWDS_bufflist_table th {
    text-align: left; }
  .TWDS_bufflist_window .TWDS_bufflist_table td.count {
    text-align: right; }

table.TWDS_achievements_table {
  border-collapse: collapse;
  clear: both; }
  table.TWDS_achievements_table th {
    text-align: left; }
  table.TWDS_achievements_table td, table.TWDS_achievements_table th {
    padding: 1px;
    border: 1px solid #888; }
  table.TWDS_achievements_table .points {
    text-align: right; }

.TWDS_achievements_warning {
  color: red; }

.TWDS_achievements_search_wrapper {
  display: none;
  float: right; }

body div.TWDS_achievements_show_one .achievement_meta {
  display: block; }

body div.TWDS_achievements_show_one .achievement_expand_icon {
  display: none !important; }

body div.TWDS_achievements_show_one .cb2showachievements {
  display: none; }

.TWDS_iteminfo_popuparea {
  float: left;
  border: 2px solid black; }

.inventory_popup.TWDS_enhanced h2 {
  font-size: 110%; }

.inventory_popup.TWDS_enhanced.TWDS_with_set_bonus {
  display: grid;
  max-width: 500px;
  grid-template-columns: 1fr;
  column-gap: 1em; }
  .inventory_popup.TWDS_enhanced.TWDS_with_set_bonus .invPopup_head {
    grid-column: 1;
    grid-row: 1; }
  .inventory_popup.TWDS_enhanced.TWDS_with_set_bonus .invPopup_body {
    grid-column: 1;
    grid-row: 2; }
  .inventory_popup.TWDS_enhanced.TWDS_with_set_bonus .invPopup_foot {
    grid-column: 1;
    grid-row: 3; }
  .inventory_popup.TWDS_enhanced.TWDS_with_set_bonus .itemsetinfo {
    grid-column: 2;
    grid-row-start: 1;
    grid-row-end: 3; }
  .inventory_popup.TWDS_enhanced.TWDS_with_set_bonus .item_set_bonus {
    margin-top: 0.5em; }

.inventory_popup.TWDS_enhanced ul {
  list-style-type: none; }

.inventory_popup.TWDS_enhanced .inventory_popup_prices {
  margin-top: 0.5em; }

.inventory_popup.TWDS_enhanced .invPopup_head {
  display: grid;
  max-height: none;
  height: auto;
  grid-template-columns: 1fr; }
  .inventory_popup.TWDS_enhanced .invPopup_head .TWDS_popup_enhance2 {
    width: 40px;
    height: auto;
    position: absolute;
    top: 0px;
    right: 1px;
    z-index: 3; }
  .inventory_popup.TWDS_enhanced .invPopup_head .inventory_popup_icon {
    position: relative;
    grid-row: 1; }
    .inventory_popup.TWDS_enhanced .invPopup_head .inventory_popup_icon .twds_count {
      position: absolute;
      left: 3px;
      bottom: 5px;
      border-radius: 0 2px 0 2px;
      box-shadow: 1px -1px 2px #000000;
      background-color: rgba(127, 111, 85, 0.7);
      color: white;
      min-width: 23px; }
    .inventory_popup.TWDS_enhanced .invPopup_head .inventory_popup_icon .item_level {
      position: absolute;
      display: block;
      top: 3px;
      left: 3px;
      background: url(/images/items/item_level.png) 0 50% no-repeat;
      color: white;
      text-shadow: black -1px 0 1px, black 0 1px 1px, black 1px 0 1px, black 0 -1px 1px;
      height: 14px;
      line-height: 14px;
      font-size: 11px;
      padding: 0 3px 0 17px;
      font-weight: normal;
      border-radius: 0 0 2px 0;
      box-shadow: 1px 1px 3px #000000;
      background-color: rgba(127, 111, 85, 0.7); }
      .inventory_popup.TWDS_enhanced .invPopup_head .inventory_popup_icon .item_level span {
        box-shadow: 1px 1px 2px black;
        border-radius: 0 2px 0 2px; }
  .inventory_popup.TWDS_enhanced .invPopup_head .TWDS_id {
    margin-top: 2px;
    grid-row: 2;
    margin-bottom: 2px;
    color: blue; }
  .inventory_popup.TWDS_enhanced .invPopup_head .TWDS_eventdata {
    grid-row: 3;
    font-style: italic;
    font-size: smaller; }
    .inventory_popup.TWDS_enhanced .invPopup_head .TWDS_eventdata .event {
      padding-left: 0.25em; }

.inventory_popup.TWDS_enhanced .TWDS_avgdamage {
  color: green; }
  .inventory_popup.TWDS_enhanced .TWDS_avgdamage::before {
    content: " ("; }
  .inventory_popup.TWDS_enhanced .TWDS_avgdamage::after {
    content: ")"; }

.inventory_popup.TWDS_enhanced br + br {
  display: none; }

.inventory_popup.TWDS_enhanced .invPopup_foot {
  margin-top: 0.33em; }

.inventory_popup.TWDS_enhanced .jobinfo {
  text-align: center;
  margin-top: 0.33em; }
  .inventory_popup.TWDS_enhanced .jobinfo .onejob {
    display: block; }
    .inventory_popup.TWDS_enhanced .jobinfo .onejob span.name {
      padding-right: 0.25em; }

.inventory_popup.TWDS_enhanced .recipeinfo {
  display: grid; }
  .inventory_popup.TWDS_enhanced .recipeinfo .profinfo {
    grid-row: 1;
    grid-column: 1;
    width: 60px;
    height: 60px;
    position: relative;
    background-size: contain;
    background-position: center center; }
    .inventory_popup.TWDS_enhanced .recipeinfo .profinfo.profession_1 {
      background-image: url(/images/items/recipe/recipe_cook.png); }
    .inventory_popup.TWDS_enhanced .recipeinfo .profinfo.profession_2 {
      background-image: url(/images/items/recipe/recipe_quack.png); }
    .inventory_popup.TWDS_enhanced .recipeinfo .profinfo.profession_3 {
      background-image: url(/images/items/recipe/recipe_smith.png); }
    .inventory_popup.TWDS_enhanced .recipeinfo .profinfo.profession_4 {
      background-image: url(/images/items/recipe/recipe_sattle.png); }
    .inventory_popup.TWDS_enhanced .recipeinfo .profinfo:after {
      display: block;
      content: attr(data-level);
      position: absolute;
      left: 0;
      top: 0;
      border: 1px solid #888;
      left: 3px;
      top: 5px;
      border-radius: 0 2px 0 2px;
      box-shadow: 1px 1px 2px #000000;
      background-color: rgba(127, 111, 85, 0.7);
      color: white; }
  .inventory_popup.TWDS_enhanced .recipeinfo .rsinfo {
    grid-row: 1;
    grid-column: 2;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap; }

.TWDS_iteminfo_content .TWDS_iteminfo_resultcontainer {
  display: block; }
  .TWDS_iteminfo_content .TWDS_iteminfo_resultcontainer .TWDS_iteminfo_resultarea {
    display: inline-block;
    max-width: 400px; }
    .TWDS_iteminfo_content .TWDS_iteminfo_resultcontainer .TWDS_iteminfo_resultarea .row {
      border-bottom: 1px solid #1d150a;
      display: grid;
      width: 100%;
      clear: both;
      grid-template-columns: 11em 1fr min-content; }
      .TWDS_iteminfo_content .TWDS_iteminfo_resultcontainer .TWDS_iteminfo_resultarea .row h6::after {
        content: ":"; }
      .TWDS_iteminfo_content .TWDS_iteminfo_resultcontainer .TWDS_iteminfo_resultarea .row h6 {
        font-size: 1em;
        display: inline-block;
        width: 11em;
        text-align: left;
        box-sizing: border-box;
        grid-column: 1;
        word-break: break-all; }
      .TWDS_iteminfo_content .TWDS_iteminfo_resultcontainer .TWDS_iteminfo_resultarea .row span {
        text-align: left;
        display: inline;
        grid-column: 2;
        word-break: break-all; }
      .TWDS_iteminfo_content .TWDS_iteminfo_resultcontainer .TWDS_iteminfo_resultarea .row div.extra {
        grid-column: 3; }
    .TWDS_iteminfo_content .TWDS_iteminfo_resultcontainer .TWDS_iteminfo_resultarea .row.level1 h6 {
      padding-left: 1em; }
    .TWDS_iteminfo_content .TWDS_iteminfo_resultcontainer .TWDS_iteminfo_resultarea .row.level1 {
      border-bottom: 1px dotted #1d150a; }
    .TWDS_iteminfo_content .TWDS_iteminfo_resultcontainer .TWDS_iteminfo_resultarea .row.level2 h6 {
      padding-left: 2em; }
    .TWDS_iteminfo_content .TWDS_iteminfo_resultcontainer .TWDS_iteminfo_resultarea .row.level3 h6 {
      padding-left: 3em; }
    .TWDS_iteminfo_content .TWDS_iteminfo_resultcontainer .TWDS_iteminfo_resultarea .row.level4 h6 {
      padding-left: 4em; }

#TWDS_storage_list .datarow.silver td {
  background-color: #c0c0c080; }

#TWDS_storage_list .datarow.gold td {
  background-color: #ffd70050; }

#TWDS_storage_search_container button {
  margin-left: 1em; }

#TWDS_ui_character_container_copy {
  position: absolute;
  top: 20px;
  left: 5px;
  width: 143px;
  height: 176px;
  z-index: 16;
  overflow: hidden;
  clip-path: polygon(0 100px, 143px 100px, 143px 176px, 0px 176px);
  background-image: url("https://westen.innogamescdn.com/images/interface/character/character.png?3"); }

body.TWDS_fix_tailor_scrollbar .tw2gui_window.trader.tailor #arrow_right {
  left: 319px; }

body.TWDS_fix_tailor_scrollbar .tw2gui_window.trader.tailor #trader_bag_pages {
  width: auto;
  left: 134px;
  padding-left: 7px;
  padding-right: 7px;
  height: 15px;
  background-color: #420;
  min-width: 170px; }

body.TWDS_fix_graveyard .fortoverview-recentbattles .graveyardtable tbody tr td:nth-child(1),
body.TWDS_fix_graveyard .fortoverview-recentbattles .graveyardtable tbody tr td:nth-child(2),
body.TWDS_fix_graveyard .fortoverview-recentbattles .graveyardtable tbody tr td:nth-child(3),
body.TWDS_fix_graveyard .fortoverview-recentbattles .graveyardtable tbody tr td:nth-child(7) {
  text-align: left; }

body.TWDS_fix_graveyard .fortoverview-recentbattles .graveyardtable tbody tr td:nth-child(2) {
  font-size: smaller; }

body.TWDS_fix_graveyard .fortoverview-recentbattles .graveyardtable tbody tr td {
  white-space: nowrap; }

.TWDS_bordered {
  border-image-source: linear-gradient(to bottom right, #aa8e69, #745434, #8d6c51, #51361e);
  border-image-slice: 1;
  border-width: 2px;
  margin-top: 2px;
  border-style: solid;
  accent-color: #745434; }

table.TWDS_simpleborder {
  border-collapse: collapse; }
  table.TWDS_simpleborder td, table.TWDS_simpleborder th {
    border: 1px solid #888;
    padding: 2px; }

#TWDS_pinning_cooldowninfo {
  position: absolute;
  right: 8px;
  bottom: 0px;
  font-size: 13px;
  color: yellow;
  font-weight: normal; }

.TWDS_pinning_container .cooldown {
  box-shadow: 1px 1px 1px black; }
  .TWDS_pinning_container .cooldown p {
    font-size: 11px; }

.TWDS_pinning_container div.item .tw_item {
  width: 60px;
  height: 60px; }

.TWDS_pinning_container div.item .cooldown {
  top: 22px; }

.TWDS_pinning_container div.item .invpin {
  top: 3px;
  right: 0px;
  display: block;
  position: absolute; }

.TWDS_pinning_container div.item .threedots {
  color: white;
  position: absolute;
  top: 3px;
  right: 0px;
  display: block;
  border-bottom: 1px solid #000;
  border-right: 1px solid #000;
  border-radius: 0px 0 0px 2px;
  background-color: rgba(127, 111, 85, 0.7);
  box-shadow: #000 -1px 1px 2px; }
  .TWDS_pinning_container div.item .threedots b {
    display: inline-block;
    font-weight: bold;
    transform: rotate(90deg) translate(0px, -4px); }

#ui_notibar .TWDS_notibar_item div.image {
  background: none; }

.TWDS_calendar_container table {
  border-collapse: collapse; }
  .TWDS_calendar_container table tbody th, .TWDS_calendar_container table tbody td {
    border: 1px solid #888;
    padding: 2px 3px; }

#buffbars .buffbar_vip .bag_item_mini {
  position: relative; }
  #buffbars .buffbar_vip .bag_item_mini div.TWDS_vipendtime {
    color: gold;
    text-align: center;
    font-size: 9px;
    text-shadow: 0 0 4px black;
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #0006; }

body.TWDS_large_inventory #windows .inventory.TWDS_filters_active .TWDS_filter_configure,
body.TWDS_normal_inventory_filters #windows .inventory.TWDS_filters_active .TWDS_filter_configure {
  outline: 2px solid red; }

body.TWDS_large_inventory #windows .inventory.TWDS_filters_active .TWDS_maybefiltered,
body.TWDS_normal_inventory_filters #windows .inventory.TWDS_filters_active .TWDS_maybefiltered {
  box-shadow: 0 2px red; }

body.TWDS_large_inventory #windows .inventory .filters .TWDS_filter_configure,
body.TWDS_normal_inventory_filters #windows .inventory .filters .TWDS_filter_configure {
  font-size: 200%;
  font-weight: bold;
  text-align: center;
  color: white; }

body.TWDS_large_inventory #windows .inventory .filters .TWDS_filter,
body.TWDS_normal_inventory_filters #windows .inventory .filters .TWDS_filter {
  width: 36px;
  height: 38px;
  margin-top: 2px;
  border-image-source: linear-gradient(to bottom right, #aa8e69, #745434, #8d6c51, #51361e);
  border-image-slice: 1;
  border-width: 2px;
  margin-top: 2px;
  border-style: solid;
  transform: scale(0.85); }
  body.TWDS_large_inventory #windows .inventory .filters .TWDS_filter.TWDS_filter_recipe,
  body.TWDS_normal_inventory_filters #windows .inventory .filters .TWDS_filter.TWDS_filter_recipe {
    background-image: url("/images/items/recipe/recipe_cook.png"), url("/images/items/recipe/recipe_smith.png"), url("/images/items/recipe/recipe_quack.png"), url("/images/items/recipe/recipe_sattle.png");
    background-position: top left, top right, bottom left, bottom right;
    background-size: 63%;
    background-repeat: no-repeat; }
  body.TWDS_large_inventory #windows .inventory .filters .TWDS_filter.TWDS_filter_useable,
  body.TWDS_normal_inventory_filters #windows .inventory .filters .TWDS_filter.TWDS_filter_useable {
    background-image: url("/images/items/yield/lifeelixir.png"), url("/images/items/yield/14days_vip_bonus.png?5"), url("/images/items/yield/fb_chest_steel.png"), url("/images/items/yield/amoslide.png");
    background-position: top left, top right, bottom left, bottom right;
    background-size: 63%;
    background-repeat: no-repeat; }
  body.TWDS_large_inventory #windows .inventory .filters .TWDS_filter.TWDS_filter_all,
  body.TWDS_normal_inventory_filters #windows .inventory .filters .TWDS_filter.TWDS_filter_all {
    background-image: url("/images/items/yield/item_53356.png");
    background-size: 99%;
    background-repeat: no-repeat; }

body.TWDS_large_inventory #windows .inventory table.TWDS_inv_filterselect,
body.TWDS_normal_inventory_filters #windows .inventory table.TWDS_inv_filterselect {
  position: absolute;
  z-index: 3;
  right: 0;
  top: 0;
  width: auto;
  height: auto;
  border: 3px solid #745434;
  background: url("/images/interface/wood_texture_dark.jpg") 0 0 repeat;
  border-collapse: collapse; }
  body.TWDS_large_inventory #windows .inventory table.TWDS_inv_filterselect td:first-child,
  body.TWDS_large_inventory #windows .inventory table.TWDS_inv_filterselect th:first-child,
  body.TWDS_normal_inventory_filters #windows .inventory table.TWDS_inv_filterselect td:first-child,
  body.TWDS_normal_inventory_filters #windows .inventory table.TWDS_inv_filterselect th:first-child {
    padding-left: 4px; }
  body.TWDS_large_inventory #windows .inventory table.TWDS_inv_filterselect td:last-child,
  body.TWDS_large_inventory #windows .inventory table.TWDS_inv_filterselect th:last-child,
  body.TWDS_normal_inventory_filters #windows .inventory table.TWDS_inv_filterselect td:last-child,
  body.TWDS_normal_inventory_filters #windows .inventory table.TWDS_inv_filterselect th:last-child {
    padding-right: 4px; }
  body.TWDS_large_inventory #windows .inventory table.TWDS_inv_filterselect tr.filterhead th,
  body.TWDS_normal_inventory_filters #windows .inventory table.TWDS_inv_filterselect tr.filterhead th {
    position: relative; }
    body.TWDS_large_inventory #windows .inventory table.TWDS_inv_filterselect tr.filterhead th button,
    body.TWDS_normal_inventory_filters #windows .inventory table.TWDS_inv_filterselect tr.filterhead th button {
      position: absolute;
      right: 0; }
  body.TWDS_large_inventory #windows .inventory table.TWDS_inv_filterselect td,
  body.TWDS_normal_inventory_filters #windows .inventory table.TWDS_inv_filterselect td {
    border-bottom: 1px solid #8d6c51;
    color: white;
    padding-top: 2px;
    padding-right: 3px; }
  body.TWDS_large_inventory #windows .inventory table.TWDS_inv_filterselect td:nth-child(3),
  body.TWDS_normal_inventory_filters #windows .inventory table.TWDS_inv_filterselect td:nth-child(3) {
    padding-right: 1em; }
  body.TWDS_large_inventory #windows .inventory table.TWDS_inv_filterselect th,
  body.TWDS_normal_inventory_filters #windows .inventory table.TWDS_inv_filterselect th {
    color: white;
    padding-top: 8px; }
  body.TWDS_large_inventory #windows .inventory table.TWDS_inv_filterselect tr:nth-child(1) th,
  body.TWDS_normal_inventory_filters #windows .inventory table.TWDS_inv_filterselect tr:nth-child(1) th {
    padding-top: 2px; }

body.TWDS_large_inventory #windows .inventory {
  width: 724px; }
  body.TWDS_large_inventory #windows .inventory .tw2gui_inner_window_bg {
    background: inherit; }
  body.TWDS_large_inventory #windows .inventory div.tw2gui_window_inset {
    background: url("/images/tw2gui/window/window2_bg_repeat.jpg") 0 0 repeat-y; }
  body.TWDS_large_inventory #windows .inventory .bag_navigation {
    display: contents;
    position: absolute;
    left: 30px;
    display: block;
    bottom: 2px;
    z-index: 1; }
    body.TWDS_large_inventory #windows .inventory .bag_navigation .bag_pages span.current_page {
      color: black; }
    body.TWDS_large_inventory #windows .inventory .bag_navigation .bag_pages a.page {
      color: #333;
      text-decoration: underline; }
  body.TWDS_large_inventory #windows .inventory #bag {
    width: calc(244px + 430px);
    height: calc(305px + 40px);
    color: white; }
  body.TWDS_large_inventory #windows .inventory .search_container {
    bottom: 20px; }
  body.TWDS_large_inventory #windows .inventory .actions {
    height: 36px;
    position: absolute;
    bottom: -12px;
    left: 0;
    right: 0; }
    body.TWDS_large_inventory #windows .inventory .actions .upgrade_items {
      left: 150px;
      right: 10px; }
  body.TWDS_large_inventory #windows .inventory .filters {
    width: calc(258px + 420px);
    background: url("/images/interface/wood_texture_dark.jpg") 0 0 repeat-x;
    display: flex; }

body.TWDS_normal_inventory_filters #windows .inventory .filters .TWDS_filter, body.TWDS_normal_inventory_filters #windows .inventory .filters .filter_inventory {
  display: inline-block;
  vertical-align: top;
  height: 30px; }

#TWDS_settings input[type=number] {
  width: 7em; }

#TWDS_settings tr.head th {
  padding-top: 0.5em;
  font-size: 130%;
  text-align: left; }

#TWDS_settings tr.info td {
  padding-top: 0.3em; }

#TWDS_settings tr.settings td:first-child {
  padding-left: 1em;
  text-indent: -1em; }
  #TWDS_settings tr.settings td:first-child span {
    margin-left: 0.3em; }

#TWDS_settings tr.settings td.settingname {
  text-align: right;
  font-size: smaller; }

#ui_bottombar .multiplayer {
  position: relative; }
  #ui_bottombar .multiplayer span.TWDS_fbcount {
    position: absolute;
    left: 15px;
    bottom: 0;
    background: url("/images/interface/friendsbar/level_bg.png");
    width: 21px;
    height: 15px;
    z-index: 1;
    color: white;
    font-size: smaller; }

.TWDS_topicfromchat {
  margin: 0.33em; }

.fortbattle .fort_battle_battleground .cell.TWDS_multiplechars {
  outline: 1px dotted #4f4; }

.fortbattle.battle .otherchar {
  width: 15px;
  height: 15px;
  position: absolute;
  top: 1px;
  left: 1px;
  z-index: 1;
  opacity: 1;
  background: url(/images/fort/battle/fort_class_players.png); }
  .fortbattle.battle .otherchar.defender {
    background-position-x: -61px; }
  .fortbattle.battle .otherchar.defender.freelancer {
    background-position-x: -76px; }
  .fortbattle.battle .otherchar.attacker {
    background-position-x: -31px; }
  .fortbattle.battle .otherchar.attacker.freelancer {
    background-position-x: -46px; }
  .fortbattle.battle .otherchar.adventurer {
    background-position-y: -31px; }
  .fortbattle.battle .otherchar.soldier {
    background-position-y: -76px; }
  .fortbattle.battle .otherchar.duelist {
    background-position-y: -46px; }
  .fortbattle.battle .otherchar.worker {
    background-position-y: -61px; }
  .fortbattle.battle .otherchar.greenhorn {
    background-position-y: -16px; }

.town-overview .town-alliance {
  position: absolute;
  z-index: 7;
  top: 30px;
  right: 10px;
  width: 215px;
  height: 30px;
  background: url("/images/town/cityinfo.png");
  text-align: center;
  font-weight: bold;
  padding-top: 10px; }

.pp-prof .TWDS_craftpoints {
  color: wheat;
  position: absolute;
  left: 4px;
  bottom: 4px;
  font-size: smaller;
  text-shadow: 1px 0 black, -1px 0 black, 0 1px black,0 -1px black; }

.TWDS_profilewindow_show_bonus_button {
  position: absolute;
  top: 6px;
  left: 5px;
  z-index: 2; }

table.TWDS_pwin_bonus2 {
  max-width: 49%; }

table.TWDS_pwin_bonus3 {
  max-width: 49%; }

table.TWDS_pwin_bonus1 {
  color: wheat;
  width: 100%; }
  table.TWDS_pwin_bonus1 td {
    position: relative;
    text-align: center; }
  table.TWDS_pwin_bonus1 span.xx {
    display: inline-block; }
    table.TWDS_pwin_bonus1 span.xx img {
      max-width: 45px;
      max-height: 32px; }
    table.TWDS_pwin_bonus1 span.xx span.yy {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      text-align: center;
      text-shadow: -1px -1px 2px black; }

.playerprofile-main .TWDS_pp_hack {
  color: wheat;
  position: absolute;
  background-color: #444c;
  bottom: 0;
  right: 0;
  width: 341px;
  z-index: 1; }

.TWDS_speedcalc_container dt.head {
  font-weight: bold;
  padding-top: 0.5em;
  font-size: larger; }

.TWDS_showset .TWDS_showset_selectors {
  display: flex;
  justify-content: space-between;
  border-bottom: 1px dotted #888;
  padding-bottom: 0.25em;
  margin-bottom: 0.25em; }

.TWDS_showset .TWDS_topcontainer {
  display: flex;
  flex-flow: wrap; }
  .TWDS_showset .TWDS_topcontainer li {
    list-style-type: none; }

.TWDS_showset .TWDS_topcontainer > * {
  width: 49%; }

.TWDS_showset .TWDS_setcontainer br {
  display: none; }

.TWDS_showset .TWDS_itemcontainer {
  border-top: 1px dotted #888;
  display: flex;
  flex-flow: wrap; }
  .TWDS_showset .TWDS_itemcontainer .TWDS_item {
    width: 49%;
    border: 1px dotted #888; }
  .TWDS_showset .TWDS_itemcontainer .inventory_popup .item_set_names,
  .TWDS_showset .TWDS_itemcontainer .inventory_popup .inventory_popup_item_set_names,
  .TWDS_showset .TWDS_itemcontainer .inventory_popup .item_set_names + span {
    display: none !important; }
  .TWDS_showset .TWDS_itemcontainer .inventory_popup .inventory_popup_item_set_names + br {
    display: none !important; }
  .TWDS_showset .TWDS_itemcontainer .inventory_popup_requirement_text {
    margin-top: -3em;
    display: inline-block; }
  .TWDS_showset .TWDS_itemcontainer .TWDS_item {
    position: relative; }
    .TWDS_showset .TWDS_itemcontainer .TWDS_item input[type=checkbox] {
      position: absolute;
      top: 2px;
      right: 2px;
      z-index: 2; }
    .TWDS_showset .TWDS_itemcontainer .TWDS_item .TWDS_enhanced_itempopup.TWDS_with_set {
      display: block; }
      .TWDS_showset .TWDS_itemcontainer .TWDS_item .TWDS_enhanced_itempopup.TWDS_with_set aside {
        display: none; }

button.TWDS_buildwindow_start {
  background-color: wheat;
  margin: 0.33em auto 0;
  display: block;
  user-select: none; }
  button.TWDS_buildwindow_start img:first-child {
    transform: rotate(0deg); }
    button.TWDS_buildwindow_start img:first-child:hover {
      transform: rotate(90deg); }

.wof-fairsite button.TWDS_buildwindow_start {
  position: absolute;
  right: 66px;
  top: 29px;
  transform: scale(0.75); }

.TWDS_shopsearch_content .infoarea {
  font-weight: bold;
  color: red; }

.TWDS_shopsearch_content .inputarea {
  display: flex;
  justify-content: space-around;
  margin-bottom: 1em; }
  .TWDS_shopsearch_content .inputarea input {
    max-width: 120px; }
  .TWDS_shopsearch_content .inputarea select {
    display: none;
    max-width: 200px; }

.TWDS_shopsearch_content table {
  margin: 1em auto 0 auto; }
  .TWDS_shopsearch_content table td, .TWDS_shopsearch_content table th {
    padding-left: 1em; }

.TWDS_shopsearch_content button, .TWDS_shopsearch_content input, .TWDS_shopsearch_content select {
  border-image-source: linear-gradient(to bottom right, #aa8e69, #745434, #8d6c51, #51361e);
  border-image-slice: 1;
  border-width: 2px;
  margin-top: 2px;
  border-style: solid;
  accent-color: #745434; }

.item_fortstorage.TWDS_fortbuild_rs .count-required.TWDS_has_required {
  display: block;
  right: 0;
  top: 0;
  position: absolute;
  left: auto;
  font-size: smaller;
  color: #ddd; }

.TWDS_fbmatinfo_window .overfilled {
  color: red; }

.TWDS_fbmatinfo_window table {
  border-collapse: collapse;
  user-select: text; }
  .TWDS_fbmatinfo_window table th {
    vertical-align: top; }
  .TWDS_fbmatinfo_window table td, .TWDS_fbmatinfo_window table th {
    border: 1px solid #888;
    padding: 2px; }
  .TWDS_fbmatinfo_window table th.item {
    text-align: center; }
    .TWDS_fbmatinfo_window table th.item .item_fortstorage {
      margin-right: 0;
      margin-left: 0;
      left: 0;
      top: 0; }
  .TWDS_fbmatinfo_window table .instock, .TWDS_fbmatinfo_window table .brutto, .TWDS_fbmatinfo_window table .netto {
    text-align: right; }

.TWDS_fbmatinfo_window p {
  user-select: text;
  padding: 0.5em 1em; }

#ui_character_container .TWDS_quickequipment_shirt {
  background-image: url("https://westen.innogamescdn.com/images/interface/character/character.png?3");
  background-clip: padding-box;
  background-origin: padding-box;
  background-repeat: no-repeat;
  position: absolute;
  top: auto !important;
  right: 3px;
  bottom: 4px;
  width: 33px;
  height: 33px;
  text-align: center;
  no-outline: 1px dotted #c88;
  background-position-y: -107px;
  background-position-x: -141px;
  padding-left: 2px; }
  #ui_character_container .TWDS_quickequipment_shirt span {
    display: block;
    padding-top: 2px;
    width: 25px;
    height: 25px;
    no-outline: 1px dotted #ff0;
    margin: 4px;
    box-sizing: border-box; }

#TWDS_ui_character_container_copy2 {
  position: absolute;
  top: 20px;
  left: 5px;
  width: 143px;
  height: 176px;
  z-index: 16;
  overflow: hidden;
  clip-path: polygon(0 100px, 143px 100px, 143px 176px, 0px 176px);
  background-image: url("https://westen.innogamescdn.com/images/interface/character/character.png?3"); }

.TWDS_overlay .event .iteminfo {
  padding-left: 0.5em; }

table.stathist {
  --c: #888;
  --g: #444;
  border-collapse: collapse;
  margin-top: 1em; }
  table.stathist thead tr:first-child th {
    border-top: 1px solid var(--c);
    border-left: 1px solid var(--c);
    border-right: 1px solid var(--c); }
  table.stathist thead tr:nth-child(2) th {
    border-bottom: 1px solid var(--c); }
    table.stathist thead tr:nth-child(2) th.newgroup {
      border-left: 1px solid var(--c); }
    table.stathist thead tr:nth-child(2) th:last-child {
      border-right: 1px solid var(--c); }
  table.stathist tbody td {
    border-left: 1px dotted var(--g);
    border-right: 1px dotted var(--g);
    text-align: right;
    padding-left: 0.25em; }
    table.stathist tbody td.newgroup {
      border-left: 1px solid var(--c); }
  table.stathist tbody tr:last-child td {
    border-bottom: 1px solid var(--c); }
  table.stathist tr {
    border-right: 1px solid var(--c); }
  table.stathist th.hidden {
    display: none; }
  table.stathist td.hidden {
    display: none; }

.TWDS_calc_container .presetselect {
  margin-left: 1em; }

.TWDS_calc_container .TWDS_calc_group.attrgroup,
.TWDS_calc_container .TWDS_calc_group.boostgroup {
  width: 50%;
  display: inline-block; }

.TWDS_calc_container .TWDS_calc_selectarea .onebonus {
  display: inline-block;
  width: 49px;
  padding: 2px; }

.TWDS_calc_container .TWDS_calc_selectarea .onebonus input {
  width: 4em; }

.TWDS_calc_container .TWDS_calc_selectarea .onebonus img {
  width: 45px; }

.TWDS_calc_container .savesearch {
  margin-right: 0.5em;
  float: right; }

.TWDS_calcmaintain_window ol {
  margin-left: 20px;
  margin-top: 8px; }

.TWDS_calcmaintain_window button {
  margin-left: 0.5em; }

.TWDS_playerliststat table {
  border-collapse: collapse;
  margin-left: 1em; }

.TWDS_playerliststat th, .TWDS_playerliststat td {
  border-left: 1px solid black;
  border-right: 1px solid black;
  padding: 2px; }

.TWDS_playerliststat thead td, .TWDS_playerliststat thead th {
  border-top: 1px solid black;
  border-bottom: 1px solid black; }

.TWDS_playerliststat .townline.first td, .TWDS_playerliststat .townline.first th {
  border-top: 1px solid black; }

.TWDS_playerliststat .townline:last-child td, .TWDS_playerliststat .townline:last-child th {
  border-bottom: 1px solid black; }

.TWDS_log_window table tbody {
  user-select: text; }

.TWDS_upshop_count {
  position: absolute;
  bottom: 47px;
  left: 19px;
  background-color: #958066;
  box-shadow: #000 1px -1px 2px 1px;
  color: white;
  padding: 3px;
  border-radius: 0 4px 0px 0px; }

.TWDS_upshop_collection {
  position: absolute;
  bottom: 47px;
  right: 19px;
  background-color: #958066;
  box-shadow: #000 -1px -1px 2px 1px;
  color: white;
  padding: 2px;
  border-radius: 4px 0 0px 0px; }
  .TWDS_upshop_collection::before {
    content: '\\1F3C6';
    width: 24px;
    height: 24px;
    font-size: smaller;
    padding-inline: 1px;
    color: palegoldenrod; }

.TWDS_ghosttowns_container {
  display: grid; }
  .TWDS_ghosttowns_container table {
    grid-row: 1;
    grid-column: 2; }
  .TWDS_ghosttowns_container table:nth-child(1) {
    grid-column: 1;
    border-right: 1px solid #888; }

.tw2gui_window.active_tab_id_TWDS_DUELMAP .tw2gui_window_inset {
  background-size: cover; }
  .tw2gui_window.active_tab_id_TWDS_DUELMAP .tw2gui_window_inset .tw2gui_inner_window_bg2 {
    background-size: contain; }

.tw2gui_window.active_tab_id_TWDS_DUELMAP .duels-TWDS_DUELMAP_CONTAINER .tw2gui_scrollpane {
  height: 245px; }

.tw2gui_window.active_tab_id_TWDS_DUELMAP table.TWDS_opponents .name.linklike.friend {
  color: #0a0; }

#TWDS_nextaction {
  position: absolute;
  bottom: 0px;
  right: 0px;
  display: block;
  color: black;
  background-color: #f0e0d0;
  border: 1px solid #420;
  border-bottom: none; }

.fort_battle_recruitlist .fort_battle_recruitlist_list.TWDS_enhanced .trows .count {
  width: 24px; }

.fort_battle_recruitlist .fort_battle_recruitlist_list.TWDS_enhanced .trows .town {
  width: 70px; }

.fort_battle_recruitlist .fort_battle_recruitlist_list.TWDS_enhanced .trows .class {
  width: 48px; }

.fort_battle_recruitlist .fort_battle_recruitlist_list.TWDS_enhanced .trows .status {
  width: 24px; }

.fort_battle_recruitlist .fort_battle_recruitlist_list.TWDS_enhanced .trows .evaluated {
  width: 60px;
  padding-left: 2px; }

.fort_battle_recruitlist .fort_battle_recruitlist_list.TWDS_enhanced .trows .hp {
  width: 76px;
  font-size: smaller;
  text-align: right; }
  .fort_battle_recruitlist .fort_battle_recruitlist_list.TWDS_enhanced .trows .hp.notfull {
    color: red; }

.fort_battle_recruitlist .fort_battle_recruitlist_list.TWDS_enhanced .trows .dist {
  width: 38px;
  font-size: smaller;
  text-align: right; }
  .fort_battle_recruitlist .fort_battle_recruitlist_list.TWDS_enhanced .trows .dist.away {
    color: red; }

.fort_battle_recruitlist .fort_battle_recruitlist_list.TWDS_enhanced .trows .row_head .cell {
  overflow: hidden;
  text-overflow: ellipsis; }

.TWDS_grouptele_window .help {
  float: right;
  padding: 3px;
  border: 1px dotted #888;
  border-radius: 50%;
  background-color: #8888;
  margin: 3px 3px 0 0; }

.TWDS_grouptele_window h1 {
  margin-top: 5px; }

.TWDS_grouptele_window .inputgroup {
  margin-top: 0.15em; }
  .TWDS_grouptele_window .inputgroup label span {
    display: inline-block;
    width: 6em; }
  .TWDS_grouptele_window .inputgroup label input {
    width: calc(100% - 7em); }

.TWDS_grouptele_window .inputgroup.functions {
  margin-top: 0.5em; }
  .TWDS_grouptele_window .inputgroup.functions label {
    margin-left: 1em; }
    .TWDS_grouptele_window .inputgroup.functions label input {
      width: 8em; }
  .TWDS_grouptele_window .inputgroup.functions label:first-child {
    margin-left: 6em; }
  `
  const sty = document.createElement('style')
  sty.textContent = css
  sty.id = 'TWDS_style_hack'
  const x = TWDS.q1('#TWDS_style_hack')
  if (x) x.remove()
  document.body.appendChild(sty)
}
TWDS.insertStyles() // no reason to wait with that.
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.translation_de = {
  YES: 'Ja',
  NO: 'Nein',
  SEARCH: 'Suchen',
  ITEMS: 'Gegenstände',
  SPEED: 'Geschwindigkeit',
  DUEL_LEVEL: 'Duellstufe',
  EP: 'Erfahrungspunkte',
  EXPERIENCE: 'Erfahrung',
  DAMAGE: 'Schaden',
  BONUS_LUCK: 'Glückschance',
  BONUS_DOLLAR: 'Verdienst',
  BONUS_DROP: 'Produktfundchance',
  BONUS_EXPERIENCE: 'Erfahrung',
  BONUS_REGEN: 'Regeneration',
  BONUS_PRAY: 'Beten',
  PLEASE_SELECT: 'Bitte wählen',

  CONFIRM_REMOVE: 'Ausrüstungsset $name$ wirklich löschen?',
  ENTER_NEW_NAME: 'Neuer Name für Ausrüstungsset $name$?',
  SHORT_SHOTWEAPON: ' (Schuss)',
  SHORT_MELEEWEAPON: ' (Schlag)',
  BONUSNAME_dollar: 'Geld für Arbeiten und Duelle',
  BONUSNAME_regen: 'Regeneration im Hotel',
  BONUSNAME_drop: 'Fundchance bei Arbeiten',
  BONUSNAME_experience: 'Erfahrungspunkte für Arbeiten, Duelle und Fortkämpfe',
  BONUSNAME_speed: 'Geschwindigkeit',
  BONUSNAME_luck: 'Glück',
  BONUSNAME_sectordamage: 'Sektorschaden',

  MINDMG_HAND: '$dmg$ Minimalschaden bei Handtreffer und Widerstand >= $res$',
  MINDMG: '$dmg$ Minimalschaden bei Handtreffer und Widerstand um $res$',
  MAXDMG: '$dmg$ Maximalschaden bei Handtreffer und Widerstand um $res$',
  MAXDMG_HEAD: '$dmg$ Maximalschaden bei Kopftreffer und Widerstand <= $res$',

  DMG_HELP: 'Der Schaden hängt von der Waffe, Schadensmodifizierendem Skill, Trefferzone, dem Widerstand des Gegners gegen die Schadensart, und Buffs ab. Buffs sind in den obigen Kalkulationen nicht enthalten.',
  SHOT_RESISTANCE_DEF: 'Widerstand gegen Schußwaffen: Reflex + 25% der Zähigkeit',
  MELEE_RESISTANCE_DEF: 'Widerstand gegen Schlagwaffen: Zähigkeit + 25% des Reflexes',
  VALUE_SUM_TEXT: 'Summe von mittlerem Schaden, Zielen, Ausweichen, entweder Schlagkraft oder Schießen, dem maximalen Widerstand, und dem Maximum von Auftreten oder Taktik.',
  VALUE_SUM_TEXT_MIN: 'Wie oben, nur wurden die Minima statt der Maxima eingerechnet.',
  DODGE_CHANCE_INFO: 'Wenn der Gegner in der letzten Runde gezielt hat (stehen blieb, und sich weder duckte noch nach rechts oder links auswich), wird sein Zielen verdoppelt. Wenn Du in die richtige Richtung duckst/ausweichst, erhältst Du einen Bonus auf Ausweichen (die Höhe ist unbekannt). Nimm diese Werte als Anhaltspunkte, und vergiss nicht, dass der Zufall ein komisches Ding ist.',
  DODGE_CHANCE_AGAINST_AIMING: 'Gegen Zielen $aim$: $chance$%',
  HIT_CHANCE_AGAINST_DODGING: 'Gegen Ausweichen $dodge$: $chance$%',
  AIMING: 'Zielen',
  DODGING: 'Ausweichen',
  RESISTANCE: 'Widerstand',
  AGAINST_MELEE: ' gegen Schlagwaffen',
  AGAINST_SHOT: ' gegen Schußwaffen',
  LABOR_POINTS_FOR_ALL: 'Arbeitspunkte für alle Arbeiten',
  LABOR_POINTS_FOR: 'Arbeitspunkte für $name$',
  NAME: 'Name',
  MENU_LEVEL_SHORT: 'Lv',
  MENU_LEVEL_LONG: 'Dein Level als die Berechnungen gemacht wurden.',
  MENU_AIM_SHORT: 'Ziel',
  MENU_AIM_LONG: 'Zielen.',
  MENU_APPEARANCE_SHORT: 'Auft.',
  MENU_APPEARANCE_LONG: 'Auftreten. Wird mit Taktik verglichen, und gibt einen Bonus auf Zielen.',
  MENU_DMGBON_SHORT: 'SchBo',
  MENU_DMGBON_LONG: 'Schadensbonus-Skill: Entweder Schlagkraft oder Schießen',
  MENU_DODGING_SHORT: 'Ausw',
  MENU_DODGING_LONG: 'Ausweichen.',
  MENU_TACTICS_SHORT: 'Takt',
  MENU_TACTICS_LONG: 'Taktik. Wird mit Auftreten des Angreifers verglichen, und gibt, wenn höher, einen Bonus auf Zielen.',
  MENU_RES_MELEE_SHORT: 'WNah',
  MENU_RES_MELEE_LONG: 'Widerstand gegen Schlagwaffen: Zähigkeit plus 25% Reflex.',
  MENU_RES_SHOT_SHORT: 'WFern',
  MENU_RES_SHOT_LONG: 'Widerstand gegen Schußwaffen: Reflex plus 25% Zähigkeit.',
  MENU_DAMAGE_SHORT: 'Scha.',
  MENU_DAMAGE_LONG: 'Der durchschnittliche Schaden.',
  MENU_DELETE_SHORT: 'Löschen',
  BONUS_INTRO: 'Diese Seite zeigt die Boni der aktuell angelegten Ausrüstung, ohne Deine Attribute und Fähigkeiten.',
  TITLE_ATTR_SKILLS_BONUS: 'Attribute und Skills',
  TITLE_OTHER_BONUS: 'Andere Boni',
  TABNAME_BONUS: 'Boni',
  TABNAME_EQUIPMENT: 'Ausrüstungssets',
  TABNAME_PEOPLE: 'Leute',
  TABNAME_EXTRAS: 'Extras',
  EQ_SET_REMOVE: 'Löschen',
  EQ_SET_REMOVE_MOUSEOVER: 'Entfernt diese Ausrüstungskombination von der Liste.',
  EQ_SET_WEAR: 'Tragen',
  EQ_SET_WEAR_MOUSEOVER: 'Diese Ausrüstungskombination anziehen.',
  EQUIPMENT_TAKEOVER_BUTTON: 'Aktuelle Ausrüstung hinzufügen',
  REGEX_DUEL_WON: '>([^>]+) gewinnt',
  REGEX_DUEL_WAGES: 'Lohn" .><.th><td>([^<]+)',
  REGEX_DUEL_XP: 'Erfahrungspunkte" .><.th><td>([^<]+)',
  REGEX_DUEL_DAMAGE: 'Schaden" .><.th><td>([^<]+)',
  REGEX_DUEL_ME_HAS_ATTACKED: '^Duell: $me$ vs. (.+)',
  REGEX_DUEL_ME_WAS_ATTACKED: '^Duell: (.*) vs. $me$',
  PEOPLETAB_NUM_INFO: '$num$ Angriffe von mir',
  PEOPLETAB_NUM_ATTACKS_WON: '$num$ Angriffe gewonnen',
  PEOPLETAB_NUM_DEFENCES_WON: '$num$ Verteidigungen gewonnen',
  PEOPLETAB_DOLLARS_INFO: '$$dollars_me$ gewann ich<br>$$dollars_other$ gewann $opponent$',
  PEOPLETAB_DAMAGE_INFO: '$dmg_done_me$ Schaden durch mich<br>$dmg_done_other$ Schaden durch $opponent$',

  PEOPLETAB_MENU_OPPONENT: 'Gegner',
  PEOPLETAB_MENU_OPPONENT_MOUSEOVER: 'Der Name des Gegners',
  PEOPLETAB_MENU_DUELS: 'Duelle',
  PEOPLETAB_MENU_TOTAL: 'Insgesamt',
  PEOPLETAB_MENU_TOTAL_MOUSEOVER: 'Die Gesamtzahl der Duelle gegen diesen Gegner',
  PEOPLETAB_MENU_VICTORIES: 'Siege',
  PEOPLETAB_MENU_VICTORIES_MOUSEOVER: 'Anzahl der von Dir gewonnenen Duelle',
  PEOPLETAB_MENU_LOSSES: 'Nied.',
  PEOPLETAB_MENU_LOSSES_MOUSEOVER: 'Die Anzahl Deiner Niederlagen',
  PEOPLETAB_MENU_PLUSMINUS: '+-',
  PEOPLETAB_MENU_PLUSMINUS_MOUSEOVER: 'Siege abzüglich Niederlagen',
  PEOPLETAB_MENU_DOLLAR: 'Dollar',
  PEOPLETAB_MENU_DOLLARSUM: 'Summe',
  PEOPLETAB_MENU_DOLLARSUM_MOUSEOVER: 'Die Gesamtsumme der von Dir gewonnenen Dollars abzüglich der vom Gegner gewonnenen Dollars. Zusätzliche Verluste bei KOs werden nicht berücksichtigt.',
  PEOPLETAB_MENU_DMG_DONE: 'Gemachter Schaden',
  PEOPLETAB_MENU_DMG_BY_ME: 'Ich',
  PEOPLETAB_MENU_DMG_BY_ME_MOUSEOVER: 'Summe der durch Dich gemachten Schäden.',
  PEOPLETAB_MENU_DMG_BY_OTHER: 'Gegner',
  PEOPLETAB_MENU_DMG_BY_OTHER_MOUSEOVER: 'Summe der durch den Gegner gemachten Schäden.',
  PEOPLETAB_MENU_DMG_DIFF: '+-',
  PEOPLETAB_MENU_DMG_DIFF_MOUSEOVER: 'Schaden durch Dich, abzüglich Schaden an Dir',
  PEOPLETAB_MENU_XP: 'Erfahrung für',
  PEOPLETAB_MENU_XP_ME: 'mich',
  PEOPLETAB_MENU_XP_ME_MOUSEOVER: 'Erfahrungspunkte, die Du erhalten hast',
  PEOPLETAB_MENU_XP_OTHER: 'Gegner',
  PEOPLETAB_MENU_XP_OTHER_MOUSEOVER: 'Erfahrungspunkte, die Dein Gegner erhalten hat',
  PEOPLETAB_DELETE_DATA: 'Daten löschen',
  PEOPLETAB_IMPORT: 'Neue Duelle importieren',
  SPECIAL_EQUIPMENT_HELPER: 'Spezialausrüstungen',
  SPECIAL_EQUIPMENT_INFO: 'Bei einem Klick auf folgenden Buttons berechnet der Computer entsprechend optimierte Ausrüstungskombinationen. Das kann auf langsamen Computer einige Zeit dauern.',
  SPECIAL_BONUS: 'Bonus',
  SPECIAL_BUTTON_SPEED: 'Geschwindigkeit',
  SPECIAL_BUTTON_XP: 'Erfahrung',
  SPECIAL_BUTTON_REGEN: 'Regeneration',
  SPECIAL_BUTTON_LUCK: 'Glück',
  SPECIAL_BUTTON_PRAY: 'Beten',
  SPECIAL_BUTTON_DOLLAR: 'Verdienst',
  SPECIAL_BUTTON_DROP: 'Produktfundchance',
  SPECIAL_SKILLS: 'Fertigkeiten',
  SPECIAL_DUELS: 'Duelle',
  SPECIAL_DUELS_INFO: 'Diese Funktionen stellen halbwegs brauchbare Ausrüstung für Duelle zusammen. Sie ersetzen aber nicht das Denken, und sie können nicht die "beste" Ausrüstung finden, denn die gibt es nicht, und sie wissen auch nichts über Deinen Gegner',
  SPECIAL_DUELS_DMG: 'Schadensmacher',
  SPECIAL_DUELS_DMG_R_A: 'Schußwaffe, Angriff',
  SPECIAL_DUELS_DMG_R_D: 'Schußwaffe, Verteidigung',
  SPECIAL_DUELS_DMG_M_A: 'Schlagwaffe, Angreifer',
  SPECIAL_DUELS_DMG_M_D: 'Schlagwaffe, Verteidigung',
  SPECIAL_DUELS_DODGING: 'Zappler (Ausweicher)',
  SPECIAL_DUELS_DODGE_R_A: 'Schußwaffe, Angriff',
  SPECIAL_DUELS_DODGE_R_D: 'Schußwaffe, Verteidigung',
  SPECIAL_DUELS_DODGE_M_A: 'Schlagwaffe, Angriff',
  SPECIAL_DUELS_DODGE_M_D: 'Schlagwaffe, Verteidigung',
  SPECIAL_DUELS_RES: 'Widerständler',
  SPECIAL_DUELS_RES_AR_A: 'Angriff gegen Schußwaffe',
  SPECIAL_DUELS_RES_AR_D: 'Verteidigung gegen Schußwaffe',
  SPECIAL_DUELS_RES_AM_A: 'Angriff gegen Schlagwaffe',
  SPECIAL_DUELS_RES_AM_D: 'Verteidigung gegen Schlagwaffe',
  SPECIAL_DUELS_RES_D: 'Verteidigung gegen ???',

  SPECIAL_FB: 'Fortkämpfe',
  SPECIAL_FB_INFO: 'Auch diese Funktionen suchen akzeptablen Kompromissen. Erstaunlicherweise finden sie gelegentlich welche (ja, wirklich). Sie können aber nicht für jede Rolle und Situation die perfekte Ausrüstung finden, Denken ersetzen sie also nicht.',
  SPECIAL_FB_TANK_ATT: 'LP/Tank, Att.',
  SPECIAL_FB_TANK_DEF: 'LP/Tank, Def.',
  SPECIAL_FB_DMG_ATT: 'Schadensmacher, Att.',
  SPECIAL_FB_DMG_DEF: 'Schadensmacher, Def.',

  CLOTHCACHE_BUTTON: 'Gemerkt [$agestr$]',
  CLOTHCACHE_BUTTON_MOUSEOVER: 'Die zuletzt berechnete Ausrüstung anlegen',
  CLOTHCACHE_PROTECT: 'Markiere die beste Ausrüstung für alle Jobs und die Gegenstände aus den gemanagten Sets (Spiel, tw-calc, ' + TWDS.scriptname + ') als nicht verkauf- und nicht auktionierbar. Nach Änderung muß die Seite neu geladen werden',
  CLOTHCACHE_SHIFT_CLICK_FOR: '. Mehr Informationen gibt es mit Umschalt-Klick auf die Zahl.',
  CLOTHCACHE_JOBS: '$n$ Arbeiten',
  CLOTHCACHE_TW_EQ_SETS: '$n$ Ausrüstungen',
  CLOTHCACHE_DS_EQ_SETS: '$n$ Duellstat-Ausrüstungssets',
  CLOTHCACHE_TC_EQ_SETS: '$n$ TW-Calc-Ausrüstungssets',

  CLOTHECACHE_SETTING_INTRO: "Die Ergebnisse der Kalkulationen, welche Ausrüstung die meisten Arbeitspunkte liefert, werden im Cache gespeichert, und können im Arbeitsfenster erneut verwendet werden ('Gemerkt'). Das spart insbesondere auf langsamen Computern und beim Besitz von vielen Setgegenständen viel Zeit, und erlaubt außerdem weitere Features. Hier kannst Du den Cache löschen, füllen oder auch einfach updaten, wobei das unter den eben genannte Umständen länger dauern kann.",
  CLOTHCACHE_BUTTON_CLEAR: 'Cache löschen',
  CLOTHCACHE_RELOAD_ALL: 'Alle',
  CLOTHCACHE_RELOAD_ALL_MOUSEOVER: 'Den Cache für alle Arbeiten neu aufbauen.',
  CLOTHCACHE_RELOAD_MISSING: 'Fehlende',
  CLOTHCACHE_RELOAD_MISSING_MOUSEOVER: 'Den Cache für fehlende Arbeiten neu aufbauen.',
  CLOTHCACHE_RELOAD_1D: 'Mindestens einen Tag alt.',
  CLOTHCACHE_RELOAD_1D_MOUSEOVER: 'Den Cache für Arbeiten neu aufbauen, deren Daten älter als einen Tag sind.',
  CLOTHCACHE_RELOAD_1W: 'Eine Woche',
  CLOTHCACHE_RELOAD_1W_MOUSEOVER: 'Den Cache für Arbeiten neu aufbauen, deren Daten älter als eine Woche sind.',
  CLOTHCACHE_RELOAD_30D: '30 Tage',
  CLOTHCACHE_RELOAD_30D_MOUSEOVER: 'Den Cache für Arbeiten neu aufbauen, deren Daten älter als 30 Tage sind.',
  CLOTHCACHE_STATUS_AGE_DAYS: '$n$ Tage',
  CLOTHCACHE_STATUS_AGE_HOURS: '$n$ Stunden',
  CLOTHCACHE_STATUS_AGE_MINUTES: '$n$ Minuten',
  CLOTHCACHE_STATUS_AGE_TEXT: 'Im Durchschnitt sind die Daten $age$ alt.',
  CLOTHCACHE_STATUS_INFO_TEXT: 'Für $found$ von $total$ Arbeiten sind Daten im Cache.',
  CLOTHCACHE_RELOAD_QUESTION: 'Den Cache neu berechnen?',

  SLEEP_SETTING: 'Ein Klick auf die Gesundheitsleiste öffnet eine Schlafplatzauswahl.',
  SLEEP_HOTEL: 'Hotel',
  SLEEP_BARRACK: 'Kaserne',

  QUEST_CANCEL_QUESTION: 'Wollen Sie diese Quest wirklich abbrechen?',
  QUEST_CANCEL_QUESTION_TITLE: 'Quest abbrechen?',
  QUESTS_OPEN_BOOK: 'Im Questbuch anzeigen',
  QUESTS_SETTING_SHOW_ITEMCOUNT_TRACKER: 'Zeige im Questtracker die Anzahl der gesuchten Gegenstände in Deinem Besitz.',
  QUESTS_SETTING_SHOW_ITEMCOUNT: 'Zeige im Questfenster die Anzahl der gesuchten Gegenstände in Deinem Besitz.',
  QUESTS_SETTING_CANCEL: 'Stelle vor dem Abbruch einer Quest eine Rückfrage.',
  QUESTS_SETTING_ADD_BOOK_LINK: 'Füge dem Questtracker einen Link ins Questbuch an.',
  QUESTS_SETTING_ADD_UTIL_BUTTONS: 'Ergänze das Questfenster um Hilfsfunktionen (Handwerk, Markt, Anzahlsanzeige).',

  AUCTION_SAVED: 'Gespeichert.',
  AUCTION_PRICE_MINIMUM: 'Mindestpreis',
  AUCTION_PRICE_REGULAR: 'Regulärer Preis',
  AUCTION_SAVE_FOR_FUTURE_SALES: 'Für zukünftige Verkäufe speichern.',
  AUCTION_SETTING: 'Verbessere den Verkaufsdialog im Markt.',

  BANKING_DEPOSIT_YOUR_CASH: 'Bargeld auf das Konto einzahlen.',
  BANKING_ONLY_IN_TOWN: 'Das ist nur möglich, wenn Du Dich in einer Stadt aufhältst.',
  BANKING_ARRIVED_HOME: 'Du hast Deine Heimatstadt erreicht. Möchtest Du Dein Geld auf Dein Bankkonto einzahlen?',
  BANKING_SETTING_AUTOHOME: 'Einen Dialog zum Einzahlen des Bargelds auf Dein Konto öffnen, wenn Du Deine Heimatstadt erreichst.',
  BANKING_SETTING_DEPOSIT_BUTTON: 'Ein Klick auf den Kontostand, ganz oben auf dem Bildschirm, öffnet einen Dialog zum Einzahlen des Bargeldes. Das funktioniert nur, wenn Du in einer Stadt bist.',

  ATTRIBUTES: 'Attribute',
  SKILLS: 'Fertigkeiten',
  HANDWEAPON: 'Schlagwaffe',
  SHOTWEAPON: 'Schußwaffe',
  FORTBATTLE: 'Fortkampf',
  FORTBATTLES_SECTORBONUS: 'Fortkampf-Sektorbonus',
  INCREASE_FONT_SIZE: 'Schrift vergrößern',
  DECREASE_FONT_SIZE: 'Schrift verkleinern',
  YEAR: 'Jahr',
  EVENT: 'Event',

  SHOWSET_SELECT_LEVEL: 'Stufe auswählen',

  ITEMSETS_ALL_ITEM_SETS: 'Alle Sets',
  ITEMSETS_DOWNLOAD_TABLE: 'Tabelle herunterladen',
  ITEMSETS_INFLUENCE_OPTIONS: 'Optionen, die die Berechnung beeinflussen: ',
  ITEMSETS_FILTER_FOR: 'Filtern nach…',
  ITEMSETS_ANY_BONUS: 'Alle Boni',
  ITEMSETS_FILTER_MONEY: 'Verdienst',
  ITEMSETS_FILTER_DROP: 'Fundchance',
  ITEMSETS_FILTER_JOBPOINTS: 'Arbeitspunkte',
  ITEMSETS_FILTER_LUCK: 'Glück',
  ITEMSETS_FILTER_PRAY: 'Beten',
  ITEMSETS_FILTER_REGEN: 'Regeneration',
  ITEMSETS_FILTER_SPEED: 'Geschwindigkeit',
  ITEMSETS_FILTER_XP: 'Erfahrungspunkte',
  ITEMSETS_FILTER_FB: 'Fortkampf',
  ITEMSETS_FILTER_ANY_YEAR: 'Alle Jahre',
  ITEMSETS_FILTER_ANY_EVENT: 'Alle Events',
  ITEMSETS_INCLUDE_ITEMS: 'Auch Gegenstände einrechnen',
  ITEMSETS_HIDE_MANY: 'Viele Spalten verstecken',
  ITEMSETS_SETNAME: 'Name',
  ITEMSETS_OR_SET_KEY: 'Entweder ein Name oder Kürzel des Events, oder der interne Schlüssel für den Event.',
  ITEMSETS_NUMBER_OF_ITEMS: 'Anzahl Gegenstände im Set.',
  ITEMSETS_TOTAL_BONUS_ATTR: 'Gesamter Bonus für die vier Attribute.',
  ITEMSETS_TOTAL_BONUS_SKILLS: 'Gesamter Bonus für die 20 Fertigkeiten.',
  ITEMSETS_TH_JP: 'AP',
  ITEMSETS_TH_JP_TITLE: 'Arbeitspunkte für alle Arbeiten. Solche für einzelne werden nicht gezählt.',
  ITEMSETS_TH_DROP: 'Fund',
  ITEMSETS_TH_DROP_TITLE: 'Verbesserung der Chance, Produkte zu finden.',
  ITEMSETS_TH_LUCK: 'Glück',
  ITEMSETS_TH_PRAY: 'Beten',
  ITEMSETS_TH_REGEN: 'Regen',
  ITEMSETS_TH_REGEN_TITLE: 'Schnellere Regeneration',
  ITEMSETS_TH_SPEED: 'Tempo',
  ITEMSETS_TH_SPEED_TITLE: 'Höhere Geschwindigkeit.',
  ITEMSETS_TH_XP: 'Exp',
  ITEMSETS_TH_XP_TITLE: 'Erfahrung.',
  ITEMSETS_TH_FB_OFF: 'Att',
  ITEMSETS_TH_FB_OFF_TITLE: 'Angriff (Fortkampfbonus)',
  ITEMSETS_TH_FB_DEF: 'Def',
  ITEMSETS_TH_FB_DEF_TITLE: 'Verteidigung (Fortkampfbonus)',
  ITEMSETS_TH_FB_RES: 'Wid',
  ITEMSETS_TH_FB_RES_TITLE: 'Widerstand (Fortkampfbonus)',
  ITEMSETS_TH_FBS_OFF: 'Att',
  ITEMSETS_TH_FBS_OFF_TITLE: 'Angriff (Fortkampfsektorbonus)',
  ITEMSETS_TH_FBS_DEF: 'Def',
  ITEMSETS_TH_FBS_DEF_TITLE: 'Verteidigung (Fortkampfsektorbonus)',
  ITEMSETS_TH_FBS_DMG: 'Sch',
  ITEMSETS_TH_FBS_DMG_TITLE: 'Schaden (Fortkampfsektorbonus)',

  STORAGE_MARK_JOBGROUPS: 'Markiere auf der Karte Arbeitsorte, an denen fehlende Gegenstände gefunden werden können.',
  STORAGE_NAME: 'Name',
  STORAGE_COUNT: 'Anzahl',
  STORAGE_ID: 'Id',
  STORAGE_ADD_THIS: 'Hinzufügen',
  STORAGE_IN_BAG: 'Vorhanden',
  STORAGE_TARGET: 'Ziel',
  STORAGE_TRACKING: 'Verfolgen',
  STORAGE_COMMENT: 'Kommentar',
  STORAGE_REMOVE: 'Entfernen',
  STORAGE_REMOVE_TITLE: 'Entfernt diese Zeile aus der Liste.',
  STORAGE_TRACKING_TITLE: 'Diesen Gegenstand im Tracker verfolgen (falls der aktiv ist).',
  STORAGE_SEARCH_PLACEHOLDER: 'Nach Gegenständen suchen',
  STORAGE_EXPORT: 'Exportieren',
  STORAGE_EXPORT_TITLE: 'Exportiert die gesamte Liste ins Clipboard.',
  STORAGE_EXPORT_SELECTED: 'Ausgewählte exportieren',
  STORAGE_EXPORT_SELECTED_TITLE: 'Du wirst nach einem Suchbegriff gefragt, und Gegenstände, deren Kommentare den begriff enthalten, werden in das Clipboard exportiert.',
  STORAGE_IMPORT: 'Importieren',
  STORAGE_IMPORT_TITLE: 'Import Daten aus dem Clipboard. Du bekommst die Möglichkeit, Änderungen zu prüfen, bevor sie umgesetzt werden.',
  STORAGE_RECALC_SUMS: '&sum;',
  STORAGE_RECALC_SUMS_TITLE: 'Die Zielwerte aus den Kommentaren berechnen.',
  STORAGE_REMOVE_SELECTED: 'Ausgewählte löschen',
  STORAGE_REMOVE_SELECTED_TITLE: 'Auf einen Suchtext passende Kommentare werden entfernt. Danach werden die Zielwerte neu berechnet.',

  FBS_SETTING: 'Ergänze den Fortkampfbericht um eine Statistik.',
  FBS_OUTCOME_DEFENDED: 'Fort verteidigt',
  FBS_OUTCOME_FLAGLOST: 'Flagge erobert',
  FBS_OUTCOME_ATTACKERS_BEATEN: 'Angreifer geschlagen',
  FBS_OUTCOME_DEFENDERS_BEATEN: 'Verteidiger geschlagen',
  FBS_TITLE: 'Statistik',
  FBS_THE_FIGHT_FOR: 'Der Kampf um',
  FBS_ATT_SIDE: 'Angreifer',
  FBS_DEF_SIDE: 'Verteidiger',
  FBS_OVER_ALL_CLASSES: 'Über alle Charakterklassen',
  FBS_FIGHTERS: 'Kämpfer',
  FBS_SURVIVORS: 'Überlebende',
  FBS_AVERAGE_ALIVE: 'Durchschnittliche Zahl lebender Kämpfer',
  FBS_HP_AT_START: 'LP zu Beginn',
  FBS_HP_AT_END: 'LP am Ende',
  FBS_MOST_HP: 'Meiste LP',
  FBS_HP_LOST: 'LP verloren',
  FBS_HP_AVERAGE: 'durchschnittliche LP',
  FBS_TOTAL_DAMAGE_DONE: 'Gesamter gemachter Schaden',
  FBS_AVERAGE_DAMAGE_DONE: 'Durchschn. gemachter Schaden pro Kopf',
  FBS_AVERAGE_DAMAGE_PER_HIT: 'Durchschn. gemachter Schaden pro Treffer',
  FBS_AVERAGE_HITS_DONE: 'Durchschnittliche erzielte Treffer',
  FBS_AVERAGE_MISSED_SHOTS: 'Durchschnittliche Fehlschüsse',
  FBS_AVERAGE_DAMAGE_TAKEN: 'Durchschnittlicher erhaltener Schaden',
  FBS_AVERAGE_DODGED_SHOTS: 'Durchschnittliche Ausweicher',
  FBS_AVERAGE_HITS_TAKEN: 'Durchschnittliche erhaltene Treffer',
  FBS_KOS_ACHIEVED: 'KOs gemacht',
  FBS_CRITICAL_HITS: 'Kritische Treffer',
  FBS_GHOSTS: 'Ghosts',
  FBS_TOTAL_LEVELS: 'Gesamtstufen',
  FBS_AVERAGE_LEVEL: 'Durchschnittliche Stufe',
  FBS_HIGHEST_LEVEL: 'Höchste Stufe',
  FBS_AVERAGE_MAX_WEAPON_DMG: 'Durchschn. max. Waffenschaden',
  FBS_AVERAGE_MIN_WEAPON_DMG: 'Durchschn. min. Waffenschaden',
  FBS_HIGHEST_DMG_BY_1: 'Höchster Schaden durch einen Kämpfer',
  FBS_HIGHEST_SINGLE_SHOT_DMG: 'Höchster Schaden durch einen Treffer',
  FBS_MOST_HITS: 'Meiste Treffer',
  FBS_HIGHEST_HIT_PERCENT: 'Höchste Trefferquote',
  FBS_MOST_DODGES: 'Meiste Ausweicher',
  FBS_HIGHEST_DODGE_PERCENT: 'Höchste Ausweichquote',
  FBS_MOST_HITS_TAKEN: 'Meiste erhaltene Treffer',
  FBS_MOST_KOS: 'Meiste KOs',
  FBS_MOST_CRITS: 'Meiste Crits',
  FBS_MOST_GHOSTS: 'Meiste Ghosts',
  FBS_MOST_MOVES: 'Meiste Bewegungen',
  FBS_MOST_FIELDS_MOVED: 'Meiste Felder bewegt',
  FBS_MOST_SECTORS_MOVED: 'Meiste Sektoren bewegt',

  FBS_SHOTS_FIRED: 'Schußanzahl',
  FBS_SHOTS_FIRED_PERCENT: 'Schußquote',
  FBS_ONLINE_PERCENT: 'Online %',
  FBS_DOTDOT_BY: '... durch',
  FBS_MISSING_HP: 'fehlende LP',

  JOBOPENBUTTON_TITLE: 'Öffne ein Fenster, um die Arbeit am nächstmöglichen Ort zu beginnen.',
  ITEMBIDBUTTON_TITLE: 'Auf dem Markt suchen',
  ITEMCRAFTBUTTON_TITLE: 'Herstellen',

  OVERLAY_FULL_HEALTH: 'Volle Gesundheit',
  OVERLAY_FULL_ENERGY: 'Volle Erholung',
  OVERLAY_RES_MELEE: 'Widerstand/Schlag',
  OVERLAY_RES_SHOT: 'Widerstand/Schuss',
  OVERLAY_LEVELEQ: '~Stufe',
  OVERLAY_LEVELEQ_TITLE: 'Du würdest ungefähr diesen Level benötigen, um die angezeigten Werte ohne Ausrüstung erreichen zu können. Dabei sind die Lebenspunkte nicht mitgerechnet.',

  QUESTLIST_TITLE: 'Quests nach Arbeitgebern',
  QUESTLIST_PLEASE_WAIT: 'Bitte warten, das dauert etwas',

  EXTRAS_TITLE: 'Weitere Funktionen',
  EXTRAS_WUW_TEXT: 'Was wird genutzt?',
  EXTRAS_WUW_HELP: 'Zeigt welche Ausrüstung in Arbeiten oder Ausrüstungssets verwendet wird.',
  EXTRAS_CHESTS_TEXT: 'Kisteninhalte',
  EXTRAS_CHESTS_HELP: 'Zeigt den Inhalt der geöffneten Kisten / Verpackungen.',
  EXTRAS_QUESTS_TEXT: 'Quests',
  EXTRAS_QUESTS_HELP: 'Zeigt, nach Arbeitgeber geordnet, die gerade verfügbaren Quests',
  EXTRAS_INVSTAT_TEXT: 'Inventar-Statistik',
  EXTRAS_INVSTAT_HELP: 'Zeigt eine Statistik über Dein Inventar',
  EXTRAS_ALTINV_TEXT: 'Inventar-Tabelle',
  EXTRAS_ALTINV_HELP: 'Zeigt Dein gesamtes Inventar als eine Tabelle',
  EXTRAS_COLLECTIONS_TEXT: 'Sammelgegenstände',
  EXTRAS_COLLECTIONS_HELP: 'Zeigt die fehlenden Sammelgegenstände in einer Seite',
  ITEMINFO_DESC: 'Zeigt Informationen über einen Gegenstand',
  ITEMINFO_TITLE: 'Gegenstands-Information',

  RECRUIT_HEALTH_FIX: 'Überlange Zeilen im Rekrutierungsbildschirm vermeiden',

  JOBWINDOW_SSB12_TITLE: 'Starte so viele Arbeiten in derselben Motivationsklasse, wie es möglich ist.',
  JOBWINDOW_SHOW_COLLECTIBLES: 'Zeige im Arbeitsfenster eventuelle bei der Arbeit zu findende Sammelgegenstände.',
  ITEMSELLBUTTON_TITLE: 'Auf dem Markt verkaufen',
  TRACKBAR_SETTING: 'Ersetze die Erfahrungspunkte-Leiste durch eine Trackleiste, die Erfahrung, Erfolge, und Produkte gleichzeitig verfolgt.',
  TRACKBAR_SETTING_STORAGESUMMARY: 'Zeige die Summe der fehlenden Produkte in der Trackleiste.',
  TABNAME_UPDATES: 'Updates',
  TABNAME_STORAGE: 'Storage',
  TABNAME_SETTINGS: 'Einstellungen',
  QUICKSILVER_SETTING: 'Markiere bekannte Bonusarbeiten auf der Minimap.',
  QUICKSILVER_SETTING_EXCLAMATION: 'Bonusarbeiten mit Ausrufezeichen markieren (statt der auffälligen Fläche)',

  UTIL_SETSELECT_FILTERTEXT: 'Filtern -->',
  UTIL_SETSELECT_FILTERTITLE: 'Die Riesenliste von Sets verkleinern. Javascript-Regex. Skel|Kolum funktioniert.',
  ACHIEVEMENTS_EXTRA_DESC: 'Zeigt Deine Erfolge als eine Tabelle',
  ACHIEVEMENTS_EXTRA_TITLE: 'Erfolge',
  ALLIMPA_EXTRA_DESC: 'Zeigt eine Weltkarte mit den wichtigsten Allianzen',
  ALLIMPA_EXTRA: 'Allianz-Weltkarte',
  BUFFLIST_NAME: 'Name',
  BUFFLIST_ID: 'Id',
  BUFFLIST_EFFECTS: 'Effekte',
  BUFFLIST_PRICE: 'Preis',
  BUFFLIST_TIME: 'Zeit',
  BUFFLIST_FUNCTIONS: 'Funktionen',
  BUFFLIST_TITLE: 'Buffs',
  BUFFLIST_QUICK_FILTER: 'Effekte',
  BUFFLIST_TYPE: 'Typ',
  BUFFLIST_EXTRA_TITLE: 'Buffs',
  BUFFLIST_EXTRA_DESC: 'Liste der verfügbaren Buffs',
  BUILDWINDOW_SETTING: 'Füge dem Ausbaufenster eine Funktion zum Wechseln der Kleidung zu.',
  BUILDWINDOW_SETTING_WOF: 'Füge dem Ausbaufenster des Wanderzirkus eine Funktion zum Wechseln der Kleidung zu.',
  BUILDWINDOW_CLOTH_TITLE: 'Kleidung wechseln',
  C_TOWN: 'Stadt',
  C_ALLIANCE: 'Allianz',
  C_PLAYERS: 'Spieler',
  C_ALL: 'Alle',
  C_SOMESTRING_NOT_FOUND: '$string$ not found',
  C_FRIEND: 'Freund',
  C_NAME: 'Name',
  CALCULATOR_EXTRA_TITLE: 'Rechner',
  CALCULATOR_EXTRA_DESC: 'Arbeitspunkt- und Bonusberechnung',
  CALCULATOR_TITLE: 'Rechner',
  CALCULATOR_INCLUDE: 'Berücksichtige ',
  CALCULATOR_OWNED: 'eigene ',
  CALCULATOR_TOWN_TRADERS: 'Läden ',
  CALCULATOR_AUCTIONABLE: 'auktionierbare ',
  CALCULATOR_NOTAUCTIONABLE: 'nicht auktionierbare',
  CALCULATOR_BLACKLISTED: 'inkl. Blacklist',
  CALCULATOR_UNWEARABLE: 'auch nicht tragbare Gegenstände',
  CALCULATOR_AND: 'und ',
  CALCULATOR_DOIT: 'Berechnen',
  CALCULATOR_RESULT: 'Ergebnis',
  CALCULATOR_RESULTLINE: 'Diese Kombination bringt $p$ Punkte.',
  CALCULATOR_ITEMS: 'Gegenstände (ohne Setbonus)',
  CALCULATOR_MP_ATTACK: 'Angriff (Fortkampfbonus)',
  CALCULATOR_MP_DEFENSE: 'Verteidigung  (Fortkampfbonus)',
  CALCULATOR_SECTOR_ATTACK: 'Angriff (Fortkampfsektorbonus)',
  CALCULATOR_SECTOR_DEFENSE: 'Verteidigung (Fortkampfsektorbonus)',
  CALCULATOR_RESISTANCE: 'Widerstand (Fortkampfbonus)',
  CALCULATOR_SECTOR_DAMAGE: 'Schaden (Fortkampfsektorbonus)',
  CALCULATOR_EXPERIENCE: 'Erfahrung',
  CALCULATOR_DOLLAR: 'Verdienst',
  CALCULATOR_LUCK: 'Glück',
  CALCULATOR_DROP: 'Fundchance',
  CALCULATOR_JP: 'Arbeitspunkte (alle Arbeiten)',
  CALCULATOR_SPEED: 'Geschwindigkeit (die Funktion im Ausrüstungstab ist vermutlich geeigneter. Diese hier sucht nur den Bonus!)',
  CALCULATOR_REGEN: 'Regeneration',
  CALCULATOR_PRAY: 'Beten',
  CALCULATOR_WEAR: 'Ausrüsten',

  CALCULATOR_SAVE: 'Suche speichern',
  CALCULATOR_MAINTAINSAVES: 'Gespeicherte Suchen verwalten',
  CALCULATOR_SAVENAME_PLACEHOLDER: 'Name für Suche',
  CALCULATOR_NEEDNAME: 'Sie müssen einen Namen für die zu speichernde Suche angeben.',
  CALCULATOR_SAVEDAS: 'Gespeichert als $name$.',

  CALCULATOR_MAINTAINTITLE: 'Gespeicherte Suchen verwalten',
  CALCULATOR_SAVEDSEARCHES: 'Sie haben folgenden Suchen gespeichert:',
  CALCULATOR_CLICKTOUSE: 'Anklicken um diese Suche im Rechner zu sehen',
  CALCULATOR_DELETESAVE: 'Diese Suche löschen',
  CALCULATOR_MAINTAIN_INFO: 'Klicken Sie auf den Namen einer Suche, um sie im Rechner anzusehen.',
  CHAT_SETTING_NOSTRANGER: '',
  CHAT_ACTIVE_SHORTHELP: 'Listet aktive Spieler (grüne Punkte).',
  CHAT_ACTIVE_HELP: 'Zeigt Dir eine Liste in diesem Chat aktiver Spieler. Du kannst hier einen Suchbegriff verwenden.',
  CHAT_ACTIVE_TEXT: 'Aktiv: $list$',
  CHAT_PING_SHORTHELP: 'Spielern anpingen.',
  CHAT_PING_HELP: 'Ruft das/den/die Spieler(in) in diesen Kanal.',
  CHAT_ALLIANCE_ROOM: '(Allianzchat)',
  CHAT_TOWN_ROOM: '(Stadtchat)',
  CHAT_FB_ROOM: '(Fortkampf-Chat)',
  CHAT_PING_TEXT: 'Komme bitte in $roomname$ $info$',
  CHAT_PINGED_MESSAGE: '$search$ wurde gerufen.',

  CHAT_UNCOLOR_SHORTHELP: 'Entfernt Farben aus Chat-Nachrichten.',
  CHAT_UNCOLOR_HELP: 'Entfernt (+) oder erlaubt (-) Farben in den Nachrichten eines Spielers.',
  CHAT_UNCOLOR_USAGE: '/uncolor (+ | -) spielername . + zum Entfernen, - zum Erlauben von Farben. Alles, was nicht auf diese Syntax passt, zeigt eine aktuelle Konfiguration.',
  CHAT_UNCOLOR_LIST: 'Du entfernst Farben dieser Spieler:',
  CHAT_UNCOLOR_NONE: 'Du entfernst Farben keiner Spieler.',
  CHAT_UNCOLOR_EXAMPLE1: 'Farben aus allen Nachrichten eines Spieler entfernen: /removecolors + SPIELER NAME.',
  CHAT_UNCOLOR_EXAMPLE2: 'Farben in allen Nachrichten eines Spieler erlauben: /removecolors - SPIELER NAME.',
  CHAT_UNCOLOR_ADDED: 'Die Farben in den Nachrichten von $player$ werden entfernt.',
  CHAT_UNCOLOR_NOTREMOVINGCOLORS: 'Die Farben in den Nachrichten von $player$ werden nicht entfernt.',

  CHAT_MARK_SHORTHELP: 'Einen Spieler markieren',
  CHAT_MARK_HELP: 'Markiere einen Spieler mit einem farbigen Rahmen',
  CHAT_MARK_USAGE: '/mark Farbcode Suchtext - zb. /mark 990 abc',
  CHAT_SWAP_SHORTHELP: 'Swapanweisung erzeugen',
  CHAT_SWAP_HELP: 'Erzeugt eine Anweisung mit Positionsangabe zum Tausch zwischen zwei Spielern',
  CHAT_FBW_WINDOW_NOT_FOUND: 'Fortkampf-Fenster nicht gefunden',
  CHAT_MARK_NOT_IN_PREBATTLE: 'Das geht nicht während der Vorbereitung, erst im Kampf.',
  CHAT_MARK_NO_CHARACTERS: 'Charakterliste nicht gefunden',
  CHAT_MARK_COLORFAIL: 'Farbangabe nicht verstanden. Benutze - zum Entfernen von Markierungen, oder NNN zum Markieren, wobei N für eine Ziffer von 0 bis 9 steht.',
  CHAT_MARK_MARKED: '$name$ wurde markiert',
  CHAT_MARK_UNMARKED: 'Markierung von $name$ entfernt',
  CHAT_COLOR_SHORTHELP: 'Farbe voreinstellen.',
  CHAT_COLOR_HELP: 'Setzt eine Defaultfarbe für alle Räume und diesen und zukünftige Sessions.',
  CRAFTCALC_TITLE: 'Handwerks-Rechner',
  CRAFTCALC_WINDOW_TITLE: 'Handwerks-Rechner',
  CRAFTCALC_NUMBER: 'Anzahl',
  CRAFTCALC_NUMBER_TITLE: 'Anzahl der herzustellenden Gegenstände',
  CRAFTCALC_ITEM_TITLE: 'Herzustellenden Gegenstand wählen',
  CRAFTCALC_ITEM_NEEDED: 'Benötigt',
  CRAFTCALC_ITEM_AVAILABLE: 'Vorhanden',
  CRAFTCALC_DEREF_BASE: 'Basis-Gegenstände',
  CRAFTCALC_DEREF_OTHER: 'Herstellbar durch Andere',
  CRAFTCALC_DEREF_CRAFTED: 'Herstellbar',
  CRAFTCALC_RESOURCES_NEEDED: 'Notwendiges Material',
  CRAFTCALC_ITEM: 'Gegenstand',
  CRAFTCALC_ITEM_NAME: 'Name',
  CRAFTCALC_CHAT_MESSAGES: 'Für Chat und Nachrichten',
  CRAFTCALC_COPY_EXPORT: 'Kopieren / Exportieren',
  CRAFTCALC_DESC: 'Berechnet für Handwerk benötigte Gegenstände',
  CRAFTCALC_FOR: 'für',
  CRAFTCALC_PRODUCT_IN_BAG: '$count$ vorhanden.',
  CRAFTCALC_SPLIT: 'aufteilen',
  CRAFTCALC_SPLIT_TITLE: 'In Bestandteile aufteilen.',
  CRAFTCALC_ITEM_FUNCTIONS: 'Funktionen.',
  CRAFTCALC_SELLALL: 'Biete all das auf dem Markt an.',
  CRAFTCALC_PLAINTEXT: 'Als einfacher Text',
  CRAFTWINDOW_TITLE: 'Handwerk',
  CRAFTWINDOW_DESC: 'Handwerksübersicht',
  CRAFTWINDOW_SETTING_REPLACE: 'Ersetze das Handwerksfenster',
  CRAFTWINDOW_TITLE_MAX: 'Setze die Anzahl auf das Maximum (1 wenn das Rezept eine zeitliche Beschränkung hat)',
  CRAFTWINDOW_BUY: 'Kaufen',
  CRAFTWINDOW_TITLE_BUY: 'Die Zutat auf dem Markt suchen',
  CRAFTWINDOW_ORDER: 'Bestellen',
  CRAFTWINDOW_TITLE_ORDER: 'Verkaufe die benötigten Produkte auf dem Markt',
  CRAFTWINDOW_CRAFT: 'Herstellen',
  CRAFTWINDOW_LEARN: 'Lernen',
  CRAFTWINDOW_TITLE_NUMBERS_PROD: 'Anzahl Einheiten des Produkts im Inventar',
  CRAFTWINDOW_TITLE_NUMBERS_RS: 'Benötigtes Material / Material im Inventar',
  CRAFTWINDOW_SEARCH_FILTER: 'Suchen / Filtern',
  TWDS_CRAFTWINDOW_JUMP: 'Zum Rezept springen',
  CRAFTWINDOW_MINITITLE: 'Handwerk',
  CRAFTWINDOW_PROF_FILTER: 'Beruf',
  CRAFTWINDOW_CHECKBOX_LABEL_POINTS: 'Punkte',
  CRAFTWINDOW_POINTS_TITLE: 'Zeige nur Rezepte, für die es Punkte geben kann.',
  CRAFTWINDOW_QUICK_FILTER: 'Effekte',
  CRAFTWINDOW_BLOCKTIME_INFO: 'Dieses Rezept hat eine Cooldown-Zeit.',
  CRAFTWINDOW_CHECKBOX_LABEL_BLOCKTIME: 'Blockzeit/Cooldown',
  CRAFTWINDOW_BLOCKTIMEFILTER_TITLE: 'Zeige nur Rezepte mit einer Blockzeit (Cooldown)',

  CRAFTWINDOW_TH_INBAG_TITLE: 'Anzahl der Gegenstände in Deinem Inventar',
  CRAFTWINDOW_TH_INBAG: '#',

  CRAFTWINDOW_TH_CRAFTORJOB_TITLE: 'Entweder der Button zum Herstellen, oder der Name des benötigten Handwerks. Wenn es Dein Handwerk ist, hast Du das Rezept noch nicht gelernt.',
  CRAFTWINDOW_TH_CRAFTORJOB: 'Herstellen',
  CRAFTWINDOW_TH_INPUT_TITLE: 'Anzahl der Gegenstände, die Du herstellen willst, gefolgt von der Anzahl der Gegenstände, für die Du das Material hast.',
  CRAFTWINDOW_TH_INPUT: '# herzustellen',
  CRAFTWINDOW_TH_POINTS_TITLE: 'Handwerkspunkte: Hohe / niedrige / keine Chance auf einen weiteren Punkt.',
  CRAFTWINDOW_TH_POINTS: 'Punkte',
  CRAFTWINDOW_TH_PRODUCTNAME: 'Produkt',

  DUELINFO_DUEL_MOTIVATION: 'Duellmotivation',
  DUELINFO_SUSPENSION: 'Duellsperre bis',
  DUELINFO_PROTECTION: 'Duellschutz bis',
  DUELMAP_WHEN: 'Wann',
  DUELMAP_WHEN_TITLE: 'Zuletzt duelliert vor … Tagen',
  DUELMAP_LV: 'St',
  DUELMAP_LV_TITLE: 'Stufe',
  DUELMAP_DLV: 'DSt',
  DUELMAP_DLV_TITLE: 'Duellstufe',
  DUELMAP_XP: 'Erf',
  DUELMAP_XP_TITLE: 'Mögliche Duellerfahrungspunkte',
  DUELMAP_CLASS: 'Klasse',
  DUELMAP_WAYTIME: 'Reisezeit',
  DUELMAP_WAYTIME_TITLE: 'Klicke auf die Zeit, um die Karte auf den Gegner zu zentrieren.',
  DUELMAP_MORE: 'Mehr',
  DUELMAP_NEWSEARCH: 'Neue Suche',
  DUELMAP_10m: '10 Minuten',
  DUELMAP_15m: '15 Minuten',
  DUELMAP_30m: '30 Minuten',
  DUELMAP_60m: '1 Stunde',
  DUELMAP_120m: '2 Stunden',
  DUELMAP_UNLIMITED: '-- kein Limit --',
  DEFENDING_SET: 'Verteidigung',
  ATTACKING_SET: 'Angriff',
  FBCHAT_WITH_DELTA: "--- LP: Ang. <span style='color:#ff2222'>$atthp$ ($attdelta$)</span>, Vert. <span style='color:#00ccff'>$defhp$ ($defdelta$)</span>",
  FBCHAT_WITHOUT_DELTA: "--- LP: Ang. <span style='color:#ff2222'>$atthp$</span>, Vert. <span style='color:#00ccff'>$defhp$</span>",
  FBCHAT_ROUND: '--- Runde $roundno$ ',
  FBCHAT_SETTING: 'Zeige Informationen zum Lebenspunkt-Stand im Fortkampf-Chat',
  FBCHAT_NOT_UNIQUE_MATCHES: '$string$ ist nicht eindeutig, passt auf $cand$',
  FBCHAT_NOT_SAME_BATTLE: '$name1$ sind $name2$ nicht im selben Kampf',
  FBCHAT_SWAPSTRING: '$name1$ tausche $dir$ mit $name2$',
  FBCHAT_SWAP1: 'Spieler tausche...',
  FBCHAT_SWAP2: '... mit Spieler',
  FBCHAT_WHISPER: 'Anflüstern',
  FBCHAT_LEFT: 'links',
  FBCHAT_RIGHT: 'rechts',
  FBCHAT_UP: 'hoch',
  FBCHAT_DOWN: 'runter',
  FBMISC_SETTING_WALK: 'Ein Klick auf die Hinweg-Zeit in der Fortkampfliste erlaubt es zum Fort zu laufen',
  FBMISC_SETTING_CHARICONS: 'Zeige spezifische Icons der Charakterklassen im Fortkampf-Vorbereitungsfenster',
  FBMISC_SETTING_CHATTOPIC: 'Kopiere das Thema des Chats in das Fortkampf-Vorbereitungsfenster. ###beißt sich mit TWIR###',
  FBMISC_SETTING_FCOUNT: 'Zeige die Anzahl der ausgerufenen Kämpfe in der unteren Menüleiste',
  FORTBUILD_ONESTAGEINFO: '$mats$ für Level $stage$ von $bname$',
  FORTBUILD_TOTALSTAGEINFO: '$nstages$ Level von $bname$',
  FORTBUILD_ALLSTAGEINFO: 'Mindestens $mats$ für $nstages$ Level von $bname$',
  FORTBUILD_WINDOW_TITLE: 'Nötige Rohstoffe',
  FORTBUILD_MINITITLE: 'Benötigt',
  FORTBUILD_ALLSTAGEINFOTOTAL: 'Mindestens $$mats$ für $nstages$ Level:',
  FORTBUILD_ALLDONE: 'In diesem Fort werden keine weiteren Resourcen benötigt.',
  FORTBUILD_NEEDED: 'Nötig',
  FORTBUILD_BRUTTO: 'Brutto',
  FORTBUILD_NETTO: 'Netto',
  FORTBUILD_INSTOCK: 'Im Lager',
  FORTBUILD_ITEM: 'Item',
  FORTBUILD_INFO: 'Info',

  GHOSTTOWNS_CENTER: 'Stadt auf der Karte zentrieren',
  GHOSTTOWNS_MINI_TITLE: 'Geister',
  GHOSTTOWNS_WIN_TITLE: 'Geisterstädte',
  GHOSTTOWNS_TITLE: 'Geisterstädte',
  GHOSTTOWNS_DESC: 'Geisterstädte mit wenigen / vielen Ausbaupunkten auflisten',
  GHOSTTOWNS_TOWN_NAME: 'Name',
  GHOSTTOWNS_TOWN_POS: 'Position',
  GHOSTTOWNS_TOWN_POINTS: 'Ausbaupkt.',
  GROUPTELE_REASON_ALLIANCE_NAME: 'Allianzname',
  GROUPTELE_REASON_ALLIANCE_ID: 'Allianz-Id',
  GROUPTELE_REASON_PLAYER_NAME: 'Spielername',
  GROUPTELE_REASON_PLAYER_ID: 'Spieler-Id',
  GROUPTELE_REASON_TOWN_NAME: 'Stadtname',
  GROUPTELE_REASON_TOWN_ID: 'Stadt-Id',
  GROUPTELE_ALLIANCES: 'Allianzen',
  GROUPTELE_TOWNS: 'Städte',
  GROUPTELE_PLAYERS: 'Spieler',
  GROUPTELE_EXCEPTIONS: 'Ausnahmen',
  GROUPTELE_SAVE: 'Speichern',
  GROUPTELE_CHECK: 'Prüfen',
  GROUPTELE_SEND: 'Versenden',
  GROUPTELE_WINDOW_TITLE: 'Gruppentelegramme',
  GROUPTELE_WINDOW_MINITITLE: 'Grp-Tele',
  GROUPTELE_TAB_H1: 'Gruppentelegram #',
  GROUPTELE_HELP: 'Hilfe',
  GROUPTELE_EXTRA: 'Gruppentelegramme',
  GROUPTELE_EXTRA_HELP: 'Versand von Gruppentelegrammen, Verwaltung von Empfängerlisten',
  INVENTORY_PRODUCTS: 'Produkte',
  INVENTORY_RECIPES: 'Rezepte',

  INVENTORY_SHOW_ALL: 'Alle zeigen',
  INVENTORY_SHOW_RECIPES: 'Rezepte',
  INVENTORY_SHOW_USABLES: 'Benutzbares',
  INVENTORY_FILTER_CONFIGURE: 'Konfigurieren',
  INVENTORY_FILTER: 'Filter',
  INVENTORY_RESET: 'Reset',

  INVENTORY_S_ID: 'Id',
  INVENTORY_S_NAME: 'Name',
  INVENTORY_S_COUNT: 'Anzahl',
  INVENTORY_S_PREIS: 'Preis',
  INVENTORY_S_STACKPRICE: 'Gesamtpreis',

  INVENTORY_D_AUCTIONABLE: 'Auktionierbar',
  INVENTORY_D_SELLABLE: 'Verkaufbar',
  INVENTORY_D_UPGRADEABLE: 'Veredelbar',
  INVENTORY_D_UPGRADED: 'Veredelt',
  INVENTORY_D_DUPLICATE: 'Duplikat',
  INVENTORY_D_DROPABLE: 'Arbeitsfund',
  INVENTORY_D_TRADEABLE: 'In Städten kaufbar',
  INVENTORY_D_USED: 'Benutzt',
  INVENTORY_D_SETPART: 'Teil eines Sets',
  INVENTORY_D_QUEST: 'Questgegenstand',
  INVENTORY_D_CLASSGENDER: 'Auf Klasse/Geschlecht beschränkt',
  INVENTORY_SORT: 'Sortieren',

  INVENTORY_IS: 'Ist',
  INVENTORY_ISNOT: 'Ist nicht',
  INVENTORY_IGNORE: 'Ignoriere',
  INVENTORY_UP: '+ / aufwärts',
  INVENTORY_DOWN: '- / abwärts',
  SETTING_INVENTORY: 'Ein größeres Inventarfenster verwenden.',
  SETTING_INVENTORY_ADD_FILTERS: 'Auch in einem kleinen Inventarfenster zusätzliche Filter zeigen.',
  ITEMPOPUP_CRAFTED: 'Handwerk',
  ITEMPOPUP_CRAFTED_FOUNDITEMS: ', $n$ Gegenstände zu finden (<= $time$)',
  ITEMPOPUP_SHOPITEMS: ', $n$ Gegenstände aus dem UP-Shop',
  ITEMPOPUP_FOUNDITEM_WORKTIME: 'Gefunden, <= $time$ zum Sammeln',
  ITEMPOPUP_UPGRADEABLE: 'Veredelbar',
  ITEMPOPUP_AUCTIONABLE: 'Auktionierbar',
  ITEMPOPUP_SELLABLE: 'Verkaufbar',
  ITEMPOPUP_EVENTNAME_Christmas: 'Weihnachten',
  ITEMPOPUP_EVENTNAME_Sale: 'Sale',
  ITEMPOPUP_EVENTNAME_Easter: 'Ostern',
  ITEMPOPUP_EVENTNAME_Ingame: 'Im Spiel',
  ITEMPOPUP_EVENTNAME_Oktoberfest: 'Oktoberfest',
  'ITEMPOPUP_EVENTNAME_4th of july': 'Unabhängigkeitstag',
  'ITEMPOPUP_EVENTNAME_Day of the dead': 'Tag der Toten',
  'ITEMPOPUP_EVENTNAME_Valentine day': 'Valentinstag',
  ITEMPOPUP_EVENTNAME_Fair: 'Wanderzirkus',
  ITEMPOPUP_EVENTNAME_Shop: 'UP-Shop',
  SETTING_ITEMPOPUP_BONUS_CHARLEVEL: 'Gegenstände/Sets mit Werten des Charakterlevels zeigen',
  SETTING_ITEMPOPUP_ID: 'ID des Gegenstands im Popup zeigen',
  SETTING_ITEMPOPUP_COUNT: 'Anzahl der Gegenstände im Popup zeigen',
  SETTING_ITEMPOPUP_SHOWTIME: 'Zeit zum Sammeln des Gegenstands oder der benötigten Gegenstände (Handwerk) zeigen, unter Verwendung der Basis-Fundwerte',
  SETTING_ITEMPOPUP_EVENTINFO: 'Event-Information im Popup zeigen',
  SETTING_ITEMPOPUP_ENABLE: 'Erweitertes Gegenstands-Popup zeigen',
  SETTING_ITEMPOPUP_SHOWJOBICON: 'Bei Sammelgegenständen das Icon der Arbeits zeigen, bei der der Gegenstand gefunden werden kann.',

  ITEMSETS_ANIMALYIELD: 'Tier/Produkt',
  ITEMSETS_WEAPONS: 'Waffen',
  ITEMSETS_CLOTHES: 'Kleidung',
  JOBLIST_WINDOW_TITLE: 'Arbeitsliste',
  JOBLIST_MINITITLE: 'Arbeitsliste',
  JOBLIST_DESC: 'Liste der Arbeiten',
  JOBLIST_LEGEND_lp: 'Arbeitspunkte',
  JOBLIST_LEGEND_xp: 'Erfahrung',
  JOBLIST_LEGEND_$: '$',
  JOBLIST_LEGEND_luck: 'Glück',
  'JOBLIST_LEGEND_motiv.': 'Motiv.',
  JOBLIST_LEGEND_danger: 'Gefahr',
  JOBLIST_ASSUME_BEST: 'Beste Ausrüstung',
  JOBLIST_ASSUME_BEST_TITLE: 'Sonst wird mit der aktuellen Ausrüstung gerechnet.',
  JOBLIST_IN_BEST_CLOTHES: '(in der besten Ausrüstung)',
  JOBLIST_15101: ' (15s/10m/1h)',
  JOBLIST_INJURY_CHANCE: 'Gefahr einer Verletzung',
  JOBLIST_INJURY_CHANCE_IBC: 'Gefahr einer Verletzung in der besten Ausrüstung',
  JOBLIST_INJURY_COST: 'Eine Verletzung kostet bis zu $maxhp$ Lebenspunkte ($percent$% der maximalen Lebenspunkte).',
  JOBLIST_MIGHT_LAST: 'Im schlimmsten Fall überlebst Du nur $worst$ Arbeiten.',
  JOBLIST_START_NEAREST: 'Starte die Arbeit bei der nächsten möglichen Position.',

  JOBLIST_NUMBER: 'Nr.',
  JOBLIST_DATE: 'Datum',
  JOBLIST_DATE_TITLE: "An diesem Datum wurde die 'beste' Ausrüstung bestimmt.",
  JOBLIST_NAME: 'Name',
  JOBLIST_LABORPOINTS: 'AP',
  JOBLIST_STARS: '***',
  JOBLIST_XP: 'EP',
  JOBLIST_XP_TITLE: 'Erfahrungspunkte.',
  JOBLIST_MONEY: 'Dollar',
  JOBLIST_LUCK_TITLE: 'Der Maximalwert der Gegenstände, die Du finden kannst.',
  JOBLIST_MOTIVATION: 'Motiv.',
  JOBLIST_MOTIVATION_TITLE: 'Aktuelle Motivation für diese Arbeit.',
  JOBLIST_DANGER_TITLE: 'Die Chance eines Unfalls in Prozent.',
  JOBLIST_LUCK_MOD: 'Glücksparameter für 15s/10m/1h',
  JOBLIST_HIGHLIGHT_TITLE: 'Markiere bekannte Bonus-Jobs auf der Minimap.',
  JOBLIST_TITLE: 'Arbeitsliste',
  JOBLIST_DANGER_MULT: '$value$: Verletzungsrisiko ($ic$%) multipliziert mit dem maximalen Schaden ($md$% der dann aktuellen maximalen Lebenspunkte.',
  JOBLIST_DANGERCOMBINED_TITLE: 'Multiplikation von Verletzungsrisiko mit dem dem maximalen Schaden in Prozent der dann aktuellen maximalen Lebenspunkte.',
  JOBLIST_MODE_CURRENT: 'Aktuelle Ausrüstung',
  JOBLIST_MODE_BEST: 'Beste Ausrüstung',
  JOBLIST_MODE_RAW: 'Rohdaten',
  JOBLIST_MODE_TITLE: "Wähle zwischen drei Anzeigemodi: 'aktuell' berechnet alle Daten auf Basis der aktuell getragenen Ausrüstung, und berücksichtigt Boni der Ausrüstung für Glücksfunde, Erfahrungspunkte und Verdienst.<br>'beste' berechnet ... auf Basis der besten bekannten Ausrüstung, berücksichtigt aber deren Boni für Glück, Erfahrungspunkte und Verdienst nicht.<br>'rohdaten' zeigt die Ausgangsdaten für Glück, Erfahrungspunkte, Verdienst und Schaden, ohne Ausrüstung oder Arbeitspunkte zu berücksichtigen.",

  JOBWINDOW_SETTING_NOTEPAD: 'Notizfläche in das Jobfenster integrieren',
  JOBWINDOW_SETTING_QUICKEQUIPMENT: 'Im Arbeitsfenster Ausrüstungs-Schnellzugriff integrieren.',
  MARKET_TOWN_SHOP_COLLECT_SWITCH_SETTING: 'Füge den Stadt-Shops einen Schalter hinzu, um nur die sammelbaren Gegenstände zu zeigen.',
  MARKET_TOWN_SHOP_FILTER_COLLECTIBLES: 'Nur Gegenstände zeigen, die zu Sammlungen fehlen.',
  MARKET_TOWN_SHOP_SEARCH_SETTING: 'Ergänze die Stadtshops um eine Suche.',
  MARKETWINDOW_FILTER_NONE: 'Alle',
  MARKETWINDOW_FILTER_BONUS: 'Bonusgegenstände',
  MARKETWINDOW_FILTER_SET: 'Setgegenstände',
  MARKETWINDOW_FILTER_NOSET: 'Setlose Items',
  MARKETWINDOW_FILTER_CRAFT: 'Dein Handwerk',
  MARKETWINDOW_FILTER_COLLECT: 'Sammlungen',
  MARKETWINDOW_FILTER_MISSING: 'Fehlende Items',
  MARKETWINDOW_BULKMODE: 'Mengen-Modus',
  MARKETWINDOW_BULKMODE_HELP: 'Mengen-Modus: Inventar und Verkaufen-Liste im Markt werden erst nach einigen Sekunden Pause aktualisiert.<br>Das Schicksal meint es dann viel seltener nicht gut zu den Vielverkäufern.',
  MARKETWINDOW_BULKMODE_READ: 'Gelesen und verstanden.',
  MARKETWINDOW_OFFERED_MSG: 'Die Ware wird zum Kauf angeboten, die Gebühr beträgt $ $fee$.',
  MARKETWINDOW_SURCHARGE: 'Aufschlag',
  MARKETWINDOW_SELLSTAT: '$entries$ Posten. $num_sold$ verkauft, $num_bid$ mit Gebot, $num_unbid$ ohne. $$dollar_sold$ verkauft, $$dollar_bid$ mit Gebot, $$dollar_unbid$ Rest.',

  MARKETMAP_SALEINFO_SOLD: '$$money$ für $offers$ Verkäufe von $items$ Gegenständen.',
  MARKETMAP_SALEINFO_UNSOLD: '$offers$ unverkaufte Posten mit $items$ Gegenständen.',
  MARKETMAP_SALEINFO_OPENWITH: 'Auf $open$ Posten mit $items$ Gegenständen wurde geboten.',
  MARKETMAP_SALEINFO_OPENWITHOUT: 'Auf $open$ Posten mit $items$ Gegenständen wurde noch nicht geboten.',
  MARKETMAP_SHOW_TOWN: 'Zentriere Stadt auf der Karte.',
  MARKETMAP_MOVE_TO_TOWN: 'Zur Stadt bewegen.',
  MARKETMAP_DISTANCE: 'Distanz:',
  MARKETMAP_TITLE: 'Marktkarte',
  MARKET_OPEN_TOWNWINDOW: 'Stadtfenster öffnen',

  MINIMAP_MARKET_ITEMS_ON_WORLDMAP: 'Marktgegenstände (Weltkarte)',
  MINIMAP_SETTING_SILVERGOLD: 'Bekannte Bonus-Arbeiten auf der Minimap zeigen.',
  MINIMAP_SETTING_COORDINPUT: 'Arbeits-Eingabefeld verarbeitet auch Koordinaten.',
  MINIMAP_SETTING_WORLDMAPMARKET: 'Zeige eine Checkbox, die das Zeigen von Marktgegenständen auf der Weltkarte erlaubt.',
  MINIMAP_SETTING_NAVIGATION: 'Ergänze den rechten Bereich der Minimap um Navigationspfeile.',
  MINIMAP_OPACITY_CHECKBOX_TITLE: 'Benutzerinterface größtenteils transparent machen (Suchmodus)',
  MINIMAP_TASKJOB_BUTTON: 'Zeige aktive Job Gruppen',
  MINIMAP_SETTING_TASKJOBDISPLAY: 'Biete eine Schaltfläche zum Aufzeigen aller aktiven Jobgruppen in der County-Karte.',
  MINIMAP_SETTING_SILVERGOLD_STORAGEHELPER: 'Markiere Bonusarbeiten für im Storage fehlende Gegenstände',
  MINIMAP_SETTING_SILVERGOLD_COLLECTHELPER: 'Markiere Bonusarbeiten, bei denen noch fehlende Sammelgegenstände gefunden werden können',
  MINIMAP_SETTING_SILVERGOLD_TRACKERHELPER: 'Markiere Bonusarbeiten für Arbeiten im Questtracker',
  MISC_SETTING_NOTIBAR_REMOVE_SALE: 'Entferne den Sale-Button aus der Infolaufleiste (Saloon etc).',
  MISC_SETTING_NOTIBAR_MAIN_MAX: 'Anzahl der Elemente in der Infolaufleiste (Saloon etc)',
  MISC_SETTING_TAILOR_SCROLLBAR_FIX: 'Überlauf im Scrollbalken des Schneiders beheben.',
  MISC_SETTING_DUELINFO_DISPLAY: 'Duellstatus-Leiste unter den Charakterinformationen anzeigen.',
  MISC_SETTING_PINNING: 'Pinning-Eimer in der oberen Menüleiste zeigen. Die Funktion ist alternativ auch durch einen Klick auf die Duellstatus-Leiste erreichbar.',
  MISC_SETTING_SHOW_MAX_BUTTON: 'Zeige beim fahrenden Händler die Funktion zum Verkaufen aller Gegenstände immer',
  MISC_SETTING_DUELPROTECTION_DISPLAY: 'Blende Duellschutz-Informationen über dem Profil ein.',
  MISC_SETTING_PROFILE_TEXT_CLICK: 'Ein Klick auf deinen Profiltext öffnet die Profiltext-Bearbeitung in den Einstellungen.',
  MISC_HIGHLIGHT_TELEGRAMS: 'Markiere den Nachrichten-Knopf bei neuen Teles',
  MISC_AVOID_NUGGETS: 'Bevorzuge andere Zahlungsarten als Nuggets, wenn möglich (ändert den Default)',
  TWDS_SETTING_no_jobgroup_animation: 'Unterbinde die Animation beim Öffnen und Schließen von Arbeitsplätzen/Arbeitsgruppen.',
  MISC_MARK_QUEST_FINISHABLE: 'Markiere den Questtracker, wenn eine Quest abgeschlossen werden kann',
  MISC_DAILY_ACTIVITIES_SETTING: 'Zeige eine Erinnerung, dass die täglichen Aktivitäten noch nicht abgeschlossen sind.',
  MISC_SETTING_CHESTANALYZER: 'Den Inhalt von Kisten merken (Ergebnis unter Extras)',
  SHOW_FRIENDREQUEST_COUNTER: 'Zeige die Anzahl ausstehender Einladungen in der unteren Menüleiste',
  MISC_SETTING_SHERIFF_MINBOUNTY: "Beim 'Kopfgeld aussetzen' das minimale Kopfgeld voreinstellen.",
  NIGHTMODE_START: 'Nachtmodus um diese Stunde beginnen',
  NIGHTMODE_END: 'Nachtmodus nach dieser Stunde beenden',
  NIGHTMODE_BRIGHTNESS: 'Helligkeit des Nachtmodus in Prozent. 75% könnte ein guter Anfang sein',
  OVERLAY_FB_SECT: 'Sektorbonus',
  OVERLAY_FB_BASE_DAMAGE: 'Grundschaden, immun geg. Klam/Set-Widerstand',
  OVERLAY_FB_AVG: 'Mittel',
  OVERLAY_FB_DAMAGE: 'Schaden',
  OVERLAY_FB_DEF: 'Verteidigung',
  OVERLAY_FB_RESISTANCE1: 'Skill-Wid.',
  OVERLAY_FB_RESISTANCE2: 'Sonst-Wid.',
  OVERLAY_FB_DODGE: 'Ausweichen',
  OVERLAY_FB_HIT: 'Treffen',
  OVERLAY_FB_ATT: 'Attacke',
  OVERLAY_FB_VALUES: 'Fortkampf-Daten',
  PLAYERLISTWINDOW_AVG_LV: 'Mitt. Level',
  PLAYERLISTWINDOW_STAT_TITLE: 'Übersicht über die Spieler an diesem Ort',
  PLAYERLISTWINDOW_SUMMARY: 'Übersicht',
  PLAYERLISTWINDOW_NOTOWN: 'Ohne Stadt',
  PLAYERLISTWINDOW_NOALLIANCE: 'Ohne Allianz',
  PLAYERLISTWINDOW_ANY: 'Egal / keine',
  PROFILEWINDOW_SETTING_CRAFTPOINTS: 'Zeige Handwerks-Level im Profil.',
  QUESTS_SETTING_COLOR_FINISHABLE: 'Farbe von Quests anpassen, die beendet werden können',
  QUICKEQUIPMENT_CHARCONTAINER: 'Zeige neben dem Charakterstatus den Ausrüstungs-Schnellzugriff, nahe den täglichen Aufgaben',
  QUICKEQUIPMENT_CACHETIME_MINUTES: 'Daten des Ausrüstungs-Schnellzugriffs für so viele Minuten zwischenspeichern',
  QUICKUSABLES_ENERGY: 'Erholung',
  QUICKUSABLES_HEALTH: 'Lebenspunkte',
  QUICKUSABLES_WMOT: 'Arbeitsmotivation',
  QUICKUSABLES_DMOT: 'Duellmotivation',
  QUICKUSABLES_DROP: 'Produktfundchance',
  QUICKUSABLES_XP: 'Erfahrung',
  QUICKUSABLES_LUCK: 'Glück',
  QUICKUSABLES_MONEY: 'Geld',
  QUICKUSABLES_DUELDAMAGE: 'Duell-Schaden',
  QUICKUSABLES_DUELSKILL: 'Duell-Fertigkeiten',
  QUICKUSABLES_FBDAMAGE: 'Fortkampf-Schaden',
  QUICKUSABLES_FBSKILL: 'Fortkampf-Fertigkeiten',
  QUICKUSABLES_MPI: 'Multiplayer',
  QUICKUSABLES_WAYTIME: 'Wegzeitverkürzung',
  QUICKUSABLES_SPEED: 'Geschwindigkeit',
  QUICKUSABLES_LP: 'Arbeitspunkte',
  QUICKUSABLES_MOVEMENT: 'Bewegung',
  QUICKUSABLES_OPENUNPACK: 'Öffnen/Auspacken',
  QUICKUSABLES_SETTING: 'Ein Klick auf die Energieanzeige öffnet eine Buff-Auswahl.',
  QUICKUSABLES_XPLEVEL: 'Erfahrung als % Deines Levels',
  QUICKUSABLES_DUEL: 'Duell',
  QUICKUSABLES_FB: 'Fortkampf',
  QUICKUSABLES_BONDS: 'Bonds',
  QUICKUSABLES_CEMPASUCHILS: 'Cempasúchil',
  QUICKUSABLES_HEARTS: 'Herzen',
  QUICKUSABLES_PRETZELS: 'Brezeln',
  QUICKUSABLES_FIREWORKS: 'Feuerwerk',
  QUICKUSABLES_EASTEREGGS: 'Ostereier',
  QUICKUSABLES_OTHER: 'Sonstige',
  QUICKUSABLES_QUEST: 'Quests',
  QUICKUSABLES_DEBUFF: 'Debuff / Zurücksetzen',
  QUICKUSABLES_PREMIUM: 'Premium',
  QUICKUSABLES_SKILLPOINTS: 'Attribute + Fähigkeiten',
  QUICKUSABLES_REGENERATION: 'Regeneration',
  STORESEARCH_ITEM_NOT_IN_SHOPS: '$itemname$ wurde in keine Stadt gefunden.',
  STORESEARCH_TH_TOWN: 'Stadt',
  STORESEARCH_TH_WAYTIME: 'Reisezeit',
  STORESEARCH_TH_ITEMS: 'Gegenstände',
  STORESEARCH_ID_NOT_FOUND: 'Gegenstand mit Base-ID #$bid$ nicht gefunden.',
  STORESEARCH_NAME_NOT_FOUND: 'Kein Gegenstand mit dem Namen $search$ gefunden.',
  STORESEARCH_TOO_MANY: 'Zu viele Gegenstände passen auf $search$. Versuchen Sie bitte eine spezifischere Suche',
  STORESEARCH_ITEM: 'Name oder #',
  STORESEARCH_ITEM_TITLE: 'Name oder Nummer des gesuchten Gegenstands',
  STORESEARCH_SELECT_TITLE: 'Wählen Sie den gesuchten Gegenstand aus.',
  STORESEARCH_CLEARMAP: 'Leeren',
  STORESEARCH_CLEARMAP_TITLE: 'Karte bereinigen (Ergebnis löschen)',
  STORESEARCH_CLEARCACHE: 'Cache leeren',
  STORESEARCH_CLEARCACHE_TITLE: 'Cache leeren ($b$ bytes). Danach dauern Suchen deutlich länger.',
  STORESEARCH_WINDOW_TITLE: 'Shopsuche',
  STORESEARCH_ALLIANCE_MODE_TITLE: 'Suche nur in den Städten Deiner Allianz.',
  STORESEARCH_ALLIANCE_MODE: 'Allianz',
  STORESEARCH_MULTI_MODE: 'Mehrere',
  STORESEARCH_MULTI_MODE_TITLE: 'Suche nicht beim ersten Resultat abbrechen.',
  STORESEARCH_EXTRA: 'Shopsuche',
  STORESEARCH_EXTRA_DESC: 'Nach Gegenständen in den Geschäften suchen.',
  TOWNLOG_EXTRA_TITLE: 'Stadtlog',
  TOWNLOG_EXTRA_DESC: 'Zeigt Zusammenfassung des Stadtlogs',
  TOWNLOG_PLEASE_WAIT: 'Bitte warten',
  TOWNLOG_PAUSED: 'Pausiert. Zum Fortführen klicken.',
  TOWNLOG_NOISE: 'Rauschen',
  TOWNLOG_INFORMATION: 'Information',
  TOWNLOG_STATUS: 'Seite $cur$ / $total$ gelesen.',
  TOWNLOG_TOWNLOG: 'Stadtlog',
  TOWNWINDOW_SETTING_SHOW_RANKING_CRAFTERS: 'Füge dem Einwohnerfenster einen Link auf die höchstrangigen Handwerker zu.',
  TOWNWINDOW_SETTING_ALLIANCE: 'Zeige den Allianznamen im Stadtfenster',
  UPSHOP_COUNT_TITLE: 'So viele Gegenstände dieses Typs besitzt Du.',
  UPSHOP_COLLECTION_TITLE: 'Dieser Gegenstand fehlt für eine Sammlung.',
  UPSHOP_SETTING_SHOW_COUNT: 'Zeige im UP-Shop, wie viele Gegenstände Du hast',
  UPSHOP_SETTING_SHOW_COLLECTIONS: 'Markiere im UP-Shop Gegenstände, die in Sammlungen fehlen',
  VIPENDTIME_SETIING_SHOW: 'Zeige die VIP-Endzeit über der VIP-Anzeige',

  DUMMY: 'Dummy'
}
TWDS.translation = {}
TWDS.lang = null
TWDS.trans_warned = {}
// this once read the translation, now it just links.
TWDS.fixTranslation = function fixTranslation () {
  let l = Game.locale
  l = l.replace(/-.*/, '')
  l = l.replace(/_.*/, '')
  const s = 'translation_' + l
  if (s in TWDS) {
    TWDS.translation = TWDS[s]
  }
  TWDS.lang = l
}
TWDS._ = function _ (s, def, para) {
  let work
  if (TWDS.lang === null) {
    TWDS.fixTranslation()
  }
  if (s in TWDS.translation) {
    work = TWDS.translation[s]
  } else {
    work = def
    if (TWDS.lang !== 'en') {
      if (!(s in TWDS.trans_warned)) {
        if ('dolog' in TWDS) {
          TWDS.info('using default translation for ', s, '=', def)
        }
        console.log('_', 'using default translation for ', s, '=', def)
        TWDS.trans_warned[s] = true
      }
    }
  }
  if (typeof para !== 'undefined') {
    for (const i of Object.keys(para)) {
      work = work.replace(`$${i}$`, para[i])
    }
  }
  return work
}

// vim: tabstop=2 shiftwidth=2 expandtab

TWDS.bonuscalc = {}
TWDS.bonuscalc.lasthash = null
TWDS.bonuscalc.lastbonus = null

TWDS.bonuscalc.getSpeed = function (itemids) {
  if (itemids === null || itemids === undefined) {
    itemids = []
    for (const e of Object.entries(Wear.slots)) {
      const x = Wear.get(e[1])
      if (x) { itemids.push(x.obj.item_id) }
    }
  }
  const bo = TWDS.bonuscalc.getComboBonus(itemids)
  let speed = 100

  let animal = null
  for (let i = 0; i < itemids.length; i++) {
    const it = ItemManager.get(itemids[i])
    if (it.type === 'animal') {
      animal = it
    }
  }

  if (animal) {
    speed += CharacterSkills.getSkill('ride').points // includes mobility
    if (bo.flexibility) speed += bo.flexibility
    if (bo.ride) speed += bo.ride
    let x = animal.speed
    x = Character.defaultSpeed / (Character.defaultSpeed * x) * 100 - 100
    speed += x
    if (bo.speed) {
      speed = speed * (1 + bo.speed)
    }
  }
  if (Premium.hasBonus('greenhorn')) { speed *= 2 }
  return speed
}
TWDS.bonuscalc.getComboBonus = function (itemids, fixnames, level) {
  const dummychar = {
    level: level || Character.level
  }
  const usedSets = {}
  const gethash = function (itemids) {
    itemids.sort(function (a, b) {
      return a - b
    })
    const str = dummychar.level + '/' + itemids.join(',')
    return TWDS.cyrb53(str)
  }

  if (itemids === null || itemids === undefined) {
    itemids = []
    for (const e of Object.entries(Wear.slots)) {
      const x = Wear.get(e[1])
      if (x) { itemids.push(x.obj.item_id) }
    }
  }
  const hash = gethash(itemids)
  if (hash === TWDS.bonuscalc.lasthash) { return JSON.parse(TWDS.bonuscalc.lastbonus) }

  const items = []
  for (let i = 0; i < itemids.length; i++) {
    items.push(ItemManager.get(itemids[i]))
  }
  const setlist = west.storage.ItemSetManager._setList
  for (const item of items) { // this is item.obj!
    if (item === undefined) continue
    const set = item.set
    if (!(set in setlist)) continue
    if (!(set in usedSets)) {
      usedSets[set] = []
    }
    usedSets[set].push(item.item_base_id)
  }
  const totalbonus = {}
  const addbonus = function (b) {
    if (!(b.key in totalbonus)) { totalbonus[b.key] = 0 }
    totalbonus[b.key] += b.value
  }
  const extractor = new west.item.BonusExtractor(dummychar)
  for (const setkey of Object.keys(usedSets)) {
    const set = west.storage.ItemSetManager.get(setkey)
    const itemsinuse = usedSets[setkey].length
    const setbonuses = set.getMergedStages(itemsinuse)
    for (let i = 0; i < setbonuses.length; i++) {
      addbonus(extractor.getExportValue(setbonuses[i]))
    }
  }
  for (let i = 0; i < items.length; i++) {
    const it = items[i]
    if (it === undefined) continue
    for (let j = 0; j < it.bonus.item.length; j++) {
      extractor.init(dummychar, it.item_level)
      const v = extractor.getExportValue(it.bonus.item[j])
      addbonus(v)
    }
    if (it.bonus.attributes && it.bonus.attributes.length) {
      console.warn('unhandled attributes bonus', it, it.bonus.attributes)
    }
    if (it.bonus.skills && it.bonus.skills.length) {
      console.warn('unhandled attributes bonus', it, it.bonus.attributes)
    }
    if (it.bonus.fortbattle) {
      if (it.bonus.fortbattle.offense) {
        addbonus({ key: fixnames ? 'fort_offense' : 'fortbattle_offense', value: it.bonus.fortbattle.offense })
      }
      if (it.bonus.fortbattle.defense) {
        addbonus({ key: fixnames ? 'fort_defense' : 'fortbattle_defense', value: it.bonus.fortbattle.defense })
      }
      if (it.bonus.fortbattle.resistance) {
        addbonus({ key: fixnames ? 'fort_resistance' : 'fortbattle_resistance', value: it.bonus.fortbattle.resistance })
      }
    }
    if (it.bonus.fortbattlesector) {
      if (it.bonus.fortbattlesector.offense) {
        addbonus({ key: fixnames ? 'fort_offense_sector' : 'fortbattlesector_offense', value: it.bonus.fortbattlesector.offense })
      }
      if (it.bonus.fortbattlesector.defense) {
        addbonus({ key: fixnames ? 'fort_defense_sector' : 'fortbattlesector_defense', value: it.bonus.fortbattlesector.defense })
      }
      if (it.bonus.fortbattlesector.damage) {
        addbonus({ key: fixnames ? 'fort_damage_sector' : 'fortbattlesector_damage', value: it.bonus.fortbattlesector.damage })
      }
    }
  }
  TWDS.bonuscalc.lasthash = hash
  TWDS.bonuscalc.lastbonus = JSON.stringify(totalbonus)
  return totalbonus
}

TWDS.getComboBonus = function (combo) {
  const usedSets = {}
  const allBonus = {}

  const pimp = function (level, value) {
    let plus
    if (!level) return value
    if (value < 1) {
      plus = value * level / 10
      plus = Math.round(plus * 100) / 100
    } else {
      plus = Math.max(1, value / 10 * level)
      plus = Math.round(plus)
    }
    return value + plus
  }

  const handleOneGoldenBonusThing = function (name, value, source) {
    if (value) {
      if (!(name in allBonus)) {
        allBonus[name] = [0, []]
      }
      allBonus[name][0] += value
      allBonus[name][1].push([value, source])
    }
  }

  const handleRounding = function (value, method) {
    switch (method) {
      case 'ceil':
        return Math.ceil(value)
      case 'floatceil':
        return Math.ceil(100 * value) / 100
      case 'floor':
        return Math.floor(value)
      case 'round':
        return Math.round(value)
      default:
        return value
    }
  }

  const handleOneBonusThing = function (entry, doRound, wtype, source, ilv = 0) {
    let realtype
    let value
    if (entry.type === 'character') {
      realtype = entry.bonus.name
      if (typeof realtype === 'undefined') {
        realtype = entry.bonus.type
        if (realtype === 'job') {
          realtype = `job_${entry.bonus.job}`
        }
      }
      value = entry.bonus.value
      if (entry.bonus.isSector) {
        realtype = 'sector' + realtype
      }
    } else if (entry.type === 'job') {
      realtype = `job_${entry.job}`
      value = entry.value
    } else if (entry.type === 'fortbattle') {
      realtype = entry.name
      value = entry.value
      if (entry.isSector) {
        realtype += '/sector'
      }
    } else {
      realtype = entry.type
      value = entry.value
    }
    if (wtype && realtype === 'damage') {
      if (wtype === 1) realtype = 'dueldamage'
    }
    if (!(realtype in allBonus)) {
      allBonus[realtype] = [0, []]
    }
    if ('key' in entry) {
      if (entry.key === 'level') {
        value *= Character.level
      } else {
        console.log('unknown bonus key', entry.key, source)
        return false
      }
    }
    value = pimp(ilv, value)
    value = handleRounding(value, entry.roundingMethod)
    allBonus[realtype][0] += value
    allBonus[realtype][1].push([value, source])
    if (value) {
      // console.log('updated', realtype, ' with +', value, 'to', allBonus[realtype], source)
    }
    return true
  }

  const handleOneItem = function (item) {
    const bo = item.bonus
    let wtype = 0
    const ilv = item.item_level
    if (item.type === 'right_arm') wtype = 1
    if (item.type === 'left_arm') wtype = 2
    // console.log('ITEM', item, wtype)
    for (let j = 0; j < bo.item.length; j++) {
      handleOneBonusThing(bo.item[j], true, wtype, item.name, ilv)
    }
    // golden gun and such things.
    handleOneGoldenBonusThing('offense', bo.fortbattle.offense, item.name)
    handleOneGoldenBonusThing('defense', bo.fortbattle.defense, item.name)
    handleOneGoldenBonusThing('resistance', bo.fortbattle.resistance, item.name)
    handleOneGoldenBonusThing('offense/sector', bo.fortbattlesector.offense, item.name)
    handleOneGoldenBonusThing('defense/sector', bo.fortbattlesector.defense, item.name)
    handleOneGoldenBonusThing('damage/sector', bo.fortbattlesector.damage, item.name)
  }

  for (const [k, v] of Object.entries(combo)) {
    if (typeof v === 'number') {
      combo[k] = ItemManager.get(v)
    }
  }

  const setlist = west.storage.ItemSetManager._setList
  for (const item of combo) { // this is item.obj!
    handleOneItem(item)
    const set = item.set
    if (!(set in setlist)) continue
    if (!(set in usedSets)) {
      usedSets[set] = []
    }
    usedSets[set].push(item.item_base_id)
  }

  // setbonus
  for (const setcode in usedSets) {
    const setHas = setlist[setcode].items.length
    const weHave = usedSets[setcode].length
    const addup = {}
    for (let numThings = 1; numThings <= Math.min(setHas, weHave); numThings++) {
      const bonuslist = setlist[setcode].bonus[numThings]
      if (typeof bonuslist === 'undefined') {
        continue
      }
      for (let i = 0; i < bonuslist.length; i++) {
        const one = bonuslist[i]
        if (one.key === 'level') {
          if (!(one.bonus.name in addup)) {
            addup[one.bonus.name] = Object.assign({}, one)
            // Object.assign makes shallow clones, so...
            addup[one.bonus.name].bonus = Object.assign({}, one.bonus)
            addup[one.bonus.name].things = bonuslist.length
          } else {
            addup[one.bonus.name].bonus.value += one.bonus.value
          }
        } else {
          handleOneBonusThing(bonuslist[i], false, 0,
            `${setlist[setcode].name} (#${numThings})`)
        }
      }
    }
    for (const one of Object.values(addup)) {
      handleOneBonusThing(one, false, 0,
          `${setlist[setcode].name} (#${one.things})`)
    }
  }
  return allBonus
}
TWDS.getWearBonus = function () {
  const list = []
  for (const item of Object.values(Wear.wear)) {
    list.push(item.obj)
  }
  return TWDS.getComboBonus(list)
}
TWDS.initBonusDisplay = function (container) {
  const ele = function (tr, what, t) {
    const td = document.createElement(what)
    td.textContent = t
    tr.appendChild(td)
  }
  const vele = function (tr, what, val) {
    const td = document.createElement(what)
    if (val !== 0) {
      td.textContent = val[0]
      let ti = ''
      for (const pair of Object.values(val[1])) {
        ti += `${pair[0]} ${pair[1]}<br>`
      }
      td.title = ti
    } else {
      td.innerHTML = '&nbsp;'
    }
    tr.appendChild(td)
  }
  const ab = TWDS.getWearBonus()

  const intro = document.createElement('p')
  intro.textContent = TWDS._('BONUS_INTRO',
    'Esta página muestra los valores de bonificación del equipo actual, sin tus atributos y habilidades.')
  container.appendChild(intro)

  let h1 = document.createElement('h1')
  h1.textContent = TWDS._('TITLE_ATTR_SKILLS_BONUS',
    'Atributos y Habilidades')
  container.appendChild(h1)

  let tab = document.createElement('table')
  tab.id = 'TWDS_attr_skill'
  let tr
  tr = document.createElement('tr')
  tr.className = 'bonus-strength1'
  tab.appendChild(tr)
  ele(tr, 'th', CharacterSkills.attributes.strength.name)
  ele(tr, 'th', CharacterSkills.skills.build.name)
  ele(tr, 'th', CharacterSkills.skills.punch.name)
  ele(tr, 'th', CharacterSkills.skills.tough.name)
  ele(tr, 'th', CharacterSkills.skills.endurance.name)
  ele(tr, 'th', CharacterSkills.skills.health.name)
  tr = document.createElement('tr')
  tr.className = 'bonus-strength2'
  tab.appendChild(tr)
  vele(tr, 'td', ab.strength || 0)
  vele(tr, 'td', ab.build || 0)
  vele(tr, 'td', ab.punch || 0)
  vele(tr, 'td', ab.tough || 0)
  vele(tr, 'td', ab.endurance || 0)
  vele(tr, 'td', ab.health || 0)
  container.appendChild(tab)

  tr = document.createElement('tr')
  tr.className = 'bonus-flexibility1'
  tab.appendChild(tr)
  ele(tr, 'th', CharacterSkills.attributes.flexibility.name)
  ele(tr, 'th', CharacterSkills.skills.ride.name)
  ele(tr, 'th', CharacterSkills.skills.reflex.name)
  ele(tr, 'th', CharacterSkills.skills.dodge.name)
  ele(tr, 'th', CharacterSkills.skills.hide.name)
  ele(tr, 'th', CharacterSkills.skills.swim.name)
  tr = document.createElement('tr')
  tr.className = 'bonus-flexibility2'
  tab.appendChild(tr)
  vele(tr, 'td', ab.flexibility || 0)
  vele(tr, 'td', ab.ride || 0)
  vele(tr, 'td', ab.reflex || 0)
  vele(tr, 'td', ab.dodge || 0)
  vele(tr, 'td', ab.hide || 0)
  vele(tr, 'td', ab.swim || 0)

  tr = document.createElement('tr')
  tr.className = 'bonus-dexterity1'
  tab.appendChild(tr)
  ele(tr, 'th', CharacterSkills.attributes.dexterity.name)
  ele(tr, 'th', CharacterSkills.skills.aim.name)
  ele(tr, 'th', CharacterSkills.skills.shot.name)
  ele(tr, 'th', CharacterSkills.skills.pitfall.name)
  ele(tr, 'th', CharacterSkills.skills.finger_dexterity.name)
  ele(tr, 'th', CharacterSkills.skills.repair.name)
  tr = document.createElement('tr')
  tr.className = 'bonus-dexterity2'
  tab.appendChild(tr)
  vele(tr, 'td', ab.dexterity || 0)
  vele(tr, 'td', ab.aim || 0)
  vele(tr, 'td', ab.shot || 0)
  vele(tr, 'td', ab.pitfall || 0)
  vele(tr, 'td', ab.finger_dexterity || 0)
  vele(tr, 'td', ab.repair || 0)

  tr = document.createElement('tr')
  tr.className = 'bonus-charisma1'
  tab.appendChild(tr)
  ele(tr, 'th', CharacterSkills.attributes.charisma.name)
  ele(tr, 'th', CharacterSkills.skills.leadership.name)
  ele(tr, 'th', CharacterSkills.skills.tactic.name)
  ele(tr, 'th', CharacterSkills.skills.trade.name)
  ele(tr, 'th', CharacterSkills.skills.animal.name)
  ele(tr, 'th', CharacterSkills.skills.appearance.name)
  tr = document.createElement('tr')
  tr.className = 'bonus-charisma2'
  tab.appendChild(tr)
  vele(tr, 'td', ab.charisma || 0)
  vele(tr, 'td', ab.leadership || 0)
  vele(tr, 'td', ab.tactic || 0)
  vele(tr, 'td', ab.trade || 0)
  vele(tr, 'td', ab.animal || 0)
  vele(tr, 'td', ab.appearance || 0)

  container.appendChild(tab)

  h1 = document.createElement('h1')
  h1.textContent = TWDS._('TITLE_OTHER_BONUS',
    'Otras bonificaciones')
  container.appendChild(h1)

  tab = document.createElement('table')
  container.appendChild(tab)
  tab.id = 'TWDS_bonuslist'

  const names = []
  for (const k of Object.keys(ab)) {
    let name
    if (CharacterSkills.allAttrKeys.includes(k)) continue
    if (CharacterSkills.allSkillKeys.includes(k)) continue
    if (k === 'damage') continue
    if (k === 'dueldamage') continue
    const m = k.match(/^job_(.*)/, k)
    if (m && m[1] === 'all') {
      name = TWDS._('LABOR_POINTS_FOR_ALL',
        'puntos trabajo para todos los trabajos')
    } else if (m && m[1] === '1000') {
      name = TWDS._('LABOR_POINTS_FOR_CONSTRUCTION',
        'puntos trabajo para construcción')
    } else if (m) {
      const job = JobList.getJobById(m[1])
      name = TWDS._('LABOR_POINTS_FOR',
        'puntos trabajo hacia $name$',
        { name: job.name })
    } else {
      name = TWDS._(`BONUSNAME_${k}`, k)
    }
    names.push([k, name])
  }
  names.sort((a, b) => a[1].localeCompare(b[1]))
  for (const entry of Object.values(names)) {
    const key = entry[0]
    const name = entry[1]
    tr = document.createElement('tr')
    tab.appendChild(tr)
    let v = ab[key][0]
    if (key === 'experience' || key === 'dollar' || key === 'drop' || key === 'luck' ||
      key === 'regen' || key === 'speed') {
      v = `+${Math.round(v * 1000) / 10}%`
    }
    ab[key][0] = v
    vele(tr, 'td', ab[key])

    const td = document.createElement('td')
    td.setAttribute('colspan', 5)
    td.textContent = name
    tr.appendChild(td)
  }
}
TWDS.getBonusContent = function () {
  const div = document.createElement('div')
  div.id = 'TWDS_bonus'
  TWDS.initBonusDisplay(div)
  return div
}
TWDS.activateBonusTab = function () {
  TWDS.activateTab('bonus')
}
TWDS.bonusStartFunction = function () {
  TWDS.registerTab('bonus',
    TWDS._('TABNAME_BONUS', 'Bonificaciones'),
    TWDS.getBonusContent,
    TWDS.activateBonusTab,
    true)
  /*
  window.EventHandler.listen('wear_changed', function () {
    if (!wman.isWindowCreated('TWDS')) return
    if (!TWDS.window) return
    if (TWDS.window.currentActiveTabId !== 'bonus') return
    TWDS.activateTab('bonus')
  })
  */
}
TWDS.registerStartFunc(TWDS.bonusStartFunction)

// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.equipmenttab = {}
TWDS.describeItemCombo = function (singleItems) {
  const setsInUse = {}
  const setNames = []
  const names = []
  const setlist = west.storage.ItemSetManager._setList
  for (let i = 0; i < singleItems.length; i++) {
    if (typeof singleItems[i] === 'number') {
      const ii = singleItems[i]
      let obj = ItemManager.get(ii)
      if (typeof obj === 'undefined') {
        // work around clothcalc
        if (typeof ItemManager.__twdb__get === 'function') {
          obj = ItemManager.__twdb__get(ii)
        }
      }
      if (typeof obj === 'undefined') {
        continue
      }
      singleItems[i] = obj
    }
  }
  for (let i = 0; i < singleItems.length; i++) {
    const item = singleItems[i]
    if (item === undefined) continue
    const set = item.set
    if (!(set in setlist)) continue
    if (!(set in setsInUse)) {
      setsInUse[set] = []
    }
    setsInUse[set].push(item.item_base_id)
  }

  const numDuelWeaponsInSet = function (set) {
    const setItems = setlist[set].items
    let numDuelweaponsContained = 0
    for (let i = 0; i < setItems.length; i++) {
      const item = ItemManager.getByBaseId(setItems[i])
      if (item.type === 'right_arm' || item.type === 'left_arm') {
        numDuelweaponsContained++
      }
    }
    return numDuelweaponsContained
  }

  for (const i in setsInUse) {
    const setItemCount = setlist[i].items.length
    const setItemsWorn = setsInUse[i].length
    if (setItemsWorn === 1) {
      continue
    }
    const nd = numDuelWeaponsInSet(i)
    let name = ''
    if (setItemCount !== setItemsWorn) {
      if (nd > 1 && setItemsWorn === setItemCount - 1) {
        name = setlist[i].name
      } else {
        name = setlist[i].name + ' (' + setItemsWorn + '/' + setItemCount + ')'
      }
    } else {
      name = setlist[i].name
    }
    if (nd > 0) {
      if (Wear.wear.right_arm.obj.sub_type === 'shot') {
        name += TWDS._('SHORT_SHOTWEAPON', ' (fuego)')
      } else if (Wear.wear.right_arm.obj.sub_type !== 'shot') {
        name += TWDS._('SHORT_MELEEWEAPON', ' (contundente)')
      }
    }
    names.push(name)
  }
  setNames.sort()

  for (let i = 0; i < singleItems.length; i++) {
    const item = singleItems[i]
    if (item === undefined) continue
    const set = item.set
    if (!(set in setsInUse) || setsInUse[set].length < 2) {
      names.push(item.name)
    }
  }

  names.sort()
  let is = ''
  for (let i = 0; i < setNames.length; i++) {
    if (is > '') { is += ', ' }
    is += setNames[i]
  }
  for (let i = 0; i < names.length; i++) {
    if (is > '') { is += ', ' }
    is += names[i]
  }
  return is
}
// reading the current skill values, and the items
TWDS.getEquipmentData = function (noskills) {
  const getOne = function (s) {
    const x = CharacterSkills.getSkill(s)
    if (noskills) return x.bonus
    return x.bonus + x.points
  }
  const schlag = getOne('punch')
  const zaeh = getOne('tough')
  const hp = getOne('health')
  const refl = getOne('reflex')
  const ausw = getOne('dodge')
  const ziel = getOne('aim')
  const schuss = getOne('shot')
  const takt = getOne('tactic')
  const auft = getOne('appearance')
  const meleeRes = zaeh + refl / 4
  const shotRes = refl + zaeh / 4
  const setNames = []
  const names = []
  const ids = []

  const singleItems = []
  const setsInUse = {}
  for (const item of Object.keys(Wear.wear)) {
    ids.push(Wear.wear[item].obj.item_id)
    singleItems.push(Wear.wear[item].obj)
  }
  const setlist = west.storage.ItemSetManager._setList
  for (let i = 0; i < singleItems.length; i++) {
    const item = singleItems[i]
    const set = item.set
    if (!(set in setlist)) continue
    if (!(set in setsInUse)) {
      setsInUse[set] = []
    }
    setsInUse[set].push(item.item_base_id)
  }
  const numDuelWeaponsInSet = function (set) {
    const setItems = setlist[set].items
    let numDuelweaponsContained = 0
    for (let i = 0; i < setItems.length; i++) {
      const item = ItemManager.getByBaseId(setItems[i])
      if (item.type === 'right_arm' || item.type === 'left_arm') {
        numDuelweaponsContained++
      }
    }
    return numDuelweaponsContained
  }
  for (const i in setsInUse) {
    const setItemCount = setlist[i].items.length
    const setItemsWorn = setsInUse[i].length
    if (setItemsWorn === 1) {
      continue
    }
    const nd = numDuelWeaponsInSet(i)
    let name = ''
    if (setItemCount !== setItemsWorn) {
      if (nd > 1 && setItemsWorn === setItemCount - 1) {
        name = setlist[i].name
      } else {
        name = setlist[i].name + ' (' + setItemsWorn + '/' + setItemCount + ')'
      }
    } else {
      name = setlist[i].name
    }
    if (nd > 0) {
      if (Wear.wear.right_arm) {
        if (Wear.wear.right_arm.obj.sub_type === 'shot') {
          name += TWDS._('SHORT_SHOTWEAPON', ' (shot)')
        } else if (Wear.wear.right_arm.obj.sub_type !== 'shot') {
          name += TWDS._('SHORT_MELEEWEAPON', ' (melee)')
        }
      }
    }
    names.push(name)
  }
  setNames.sort()

  for (let i = 0; i < singleItems.length; i++) {
    const item = singleItems[i]
    const set = item.set
    if (!(set in setsInUse) || setsInUse[set].length < 2) {
      names.push(item.name)
    }
  }

  names.sort()
  let is = ''
  for (let i = 0; i < setNames.length; i++) {
    if (is > '') { is += ', ' }
    is += setNames[i]
  }
  for (let i = 0; i < names.length; i++) {
    if (is > '') { is += ', ' }
    is += names[i]
  }

  ids.sort()
  let hashstr = ''
  for (let i = 0; i < ids.length; i++) {
    hashstr += ',' + ids[i]
  }

  let dmg = 0
  if (Wear.wear.right_arm) { dmg = Wear.wear.right_arm.obj.getDamage(Character) }
  const hash = TWDS.cyrb53(hashstr)
  const key = 'TWDS_h_' + hash
  const tmp = window.localStorage.getItem(key)
  let o = {}
  o.name = hash
  if (tmp) {
    o = JSON.parse(tmp)
  }
  o.level = Character.level
  o.item_ids = ids
  o.items = is
  o.schlag = schlag
  o.zaeh = zaeh
  o.hp = hp
  o.refl = refl
  o.ausw = ausw
  o.ziel = ziel
  o.schuss = schuss
  o.takt = takt
  o.auft = auft
  o.wid_schlag = meleeRes
  o.wid_schuss = shotRes
  o.dmg_abs_min = dmg.min * 0.25
  o.dmg_min = dmg.min
  o.dmg_max = dmg.max
  o.dmg_abs_max = dmg.max * 1.75 * 1.5
  o.shot = (Wear.wear.right_arm && Wear.wear.right_arm.obj.sub_type === 'shot')

  let lvtmp = zaeh + refl + ausw + ziel
  if (o.shot) {
    lvtmp += schuss
  } else {
    lvtmp += schlag
  }
  // 5: 3 skill points and 1 attribute, which can be worth 2 skill points (Green/Blue)
  o.leveleq_attack = Math.round((lvtmp + auft) / 5)
  o.leveleq_defense = Math.round((lvtmp + takt) / 5)

  const s = JSON.stringify(o)
  return [key, s]
}

TWDS.fillEquipmentTab = function (tab) {
  const l = []
  for (let i = 0; i < window.localStorage.length; i++) {
    const k = window.localStorage.key(i)
    if (!k.match(/^TWDS_h_/)) {
      continue
    }
    const s = window.localStorage.getItem(k)
    const t = {}
    const o = JSON.parse(s)
    t.name = o.name
    t.key = k
    l.push(t)
  }
  l.sort(function (a, b) {
    a = a.name
    b = b.name
    if (typeof a !== 'string') { a = a + '' }
    if (typeof b !== 'string') { b = b + '' }
    return a.localeCompare(b)
  })
  for (const i in l) {
    const k = l[i].key
    const s = window.localStorage.getItem(k)
    if (s > '') {
      const o = JSON.parse(s)
      TWDS.add1ToTab(tab, i, k, o)
    }
  }
  TWDS.highlightEquipmentTable(tab)
  return l.length
}
TWDS.highlightEquipmentTable = function (tab) {
  const rows = $('.datarow', tab)
  const merk = {}
  $(rows).each(function () {
    $('td[data-field]', this).each(function () {
      const f = this.dataset.field
      if (!(f in merk)) {
        merk[f] = []
      }
      merk[f].push(parseInt(this.textContent))
    })
  })
  for (const k in merk) {
    merk[k].sort(function (a, b) { return b - a })
  }
  $(rows).each(function () {
    $('td[data-field]', this).each(function () {
      const f = this.dataset.field
      const v = parseInt(this.textContent)
      if (v >= merk[f][0]) {
        this.classList.add('best')
      } else if (v >= 0.90 * merk[f][0]) {
        this.classList.add('verygood')
      } else if (v >= 0.75 * merk[f][0]) {
        this.classList.add('good')
      } else if (v >= 0.5 * merk[f][0]) {
        this.classList.add('ok')
      } else {
        this.classList.add('other')
      }
    })
  })
}
TWDS.classifyEquipment = function (o) {
  let schaden = o.schlag
  if (o.shot) schaden = o.schuss
  const widerstand = Math.max(o.wid_schuss, o.wid_schlag)

  let avg = o.ziel + o.ausw + schaden + widerstand
  avg /= 4

  const ca = [
    [o.ziel, TWDS._('AIMING', 'Apuntar')],
    [o.ausw, TWDS._('DODGING', 'Eludir')],
    [widerstand, TWDS._('RESISTANCE', 'Resistencia')],
    [schaden, TWDS._('DAMAGE', 'Daño')]
  ]
  ca.sort(function (a, b) {
    return b[0] - a[0]
  })

  let type = ''
  if (o.auft > o.takt + 100) { type = TWDS._('ATTACKING_SET', 'Attacking,') } else if (o.takt > o.auft + 100) { type = TWDS._('DEFENDING_SET', 'Defending,') }
  let sep = ' '
  for (let i = 0; i < ca.length; i++) {
    if (ca[i][0] > avg) {
      type += sep
      sep = '/'
      if (ca[i][0] > avg * 1.33) {
        type += '<b>'
        type += ca[i][1]
        type += '</b>'
      } else {
        type += ca[i][1]
      }
    }
  }
  for (let i = 0; i < ca.length; i++) {
    if (ca[i][0] < avg * 0.5) {
      type += sep
      sep = '/'
      type += '<strike>'
      type += ca[i][1]
      type += '</strike>'
    }
  }

  if (o.wid_schlag > o.wid_schuss + 100) { type += TWDS._('AGAINST_MELEE', ' contra armas contundentes') }
  if (o.wid_schuss > o.wid_schlag + 100) { type += TWDS._('AGAINST_SHOT', ' contra armas de fuego') }
  return type
}
/*
  name  - Name der Ausrüstung (oder hash)
  Fn    - Funktionen (löschen, anlegen)
  Lv    - Level bei Anlegen / Updaten
  Zielen - mit Mouseover für Chancen
  Auftreten
  Schuß/Schlag
  Ausweichen - mit Mouseover für Chancen
  Taktik
  Widerstand Nah - Widerstand gegen Schlag
  Widerstand Fern - Widerstand gegen Schuss
  Schaden - mit Mouseover
 */
TWDS.add1ToTab = function (tab, i, key, o) {
  const appOne = function (tr, v0, dn = null, ti = null) {
    const td = document.createElement('td')
    let v = Math.round(v0)
    if (isNaN(v)) { v = v0 }
    td.textContent = v
    if (dn != null) {
      td.dataset.field = dn
    }
    if (ti != null) {
      td.title = ti
    }
    tr.appendChild(td)
  }
  const calcChance = function (ziel, aw) {
    let t = 0
    let v = 0
    for (let i = 1; i < ziel + 5; i++) {
      for (let j = 1; j < aw + 5; j++) {
        v++
        if (i > j) {
          t++
        }
      }
    }
    return Math.round(t / v * 1000) / 10
  }
  const tr = document.createElement('tr')
  tr.classList.add('datarow')
  tr.dataset.key = key
  tab.appendChild(tr)

  let baseValues = ''
  baseValues += o.ziel + ' ' + CharacterSkills.keyNames.aim + '<br>'
  baseValues += o.schuss + ' ' + CharacterSkills.keyNames.shot + '<br>'
  baseValues += o.schlag + ' ' + CharacterSkills.keyNames.punch + '<br>'
  baseValues += o.ausw + ' ' + CharacterSkills.keyNames.dodge + '<br>'
  baseValues += o.refl + ' ' + CharacterSkills.keyNames.reflex + '<br>'
  baseValues += o.zaeh + ' ' + CharacterSkills.keyNames.tough + '<br>'
  baseValues += o.auft + ' ' + CharacterSkills.keyNames.appearance + '<br>'
  baseValues += o.takt + ' ' + CharacterSkills.keyNames.tactic + '<br>'
  baseValues += o.hp + ' ' + CharacterSkills.keyNames.health + '<br>'

  const classification = TWDS.classifyEquipment(o)

  // Spalte 1: Name der Ausrüstung, mit Items und Werten aus Mouseover.
  const th = document.createElement('th')
  th.textContent = o.name
  th.title = o.items + '<br>' + classification + '</br>' + baseValues
  th.onclick = 'TWDS.nameEdit()'
  th.classList.add('TWDS_nameeditTrigger')
  tr.appendChild(th)

  // Spalte 2: Anziehen
  let td = document.createElement('td')
  tr.appendChild(td)
  let but = TWDS.createButton(
    TWDS._('EQ_SET_WEAR', 'usar'), {
      title: TWDS._('EQ_SET_WEAR_MOUSEOVER', 'Cambiar a esta equipación.'),
      classList: ['TWDS_wear']
    })
  td.appendChild(but)

  let aimChanceText = ''

  for (let aw = 100; aw <= 1500; aw += 100) {
    let c = calcChance(o.ziel, aw)
    c = Math.round(c * 100) / 100
    aimChanceText += TWDS._('HIT_CHANCE_AGAINST_DODGING',
      'Contra esquivar $dodge$: $chance$%', {
        dodge: aw,
        chance: c
      })
    aimChanceText += '<br>'
  }
  let dodgeChanceText = ''
  for (let ziel = 100; ziel <= 1500; ziel += 100) {
    let c = 100 - calcChance(ziel, o.ausw)
    c = Math.round(c * 100) / 100
    dodgeChanceText += TWDS._('DODGE_CHANCE_AGAINST_AIMING',
      'Contra apuntar $aim$: $chance$%', {
        aim: ziel,
        chance: c
      })
    dodgeChanceText += '<br>'
  }
  dodgeChanceText += TWDS._('DODGE_CHANCE_INFO',
  `
    Si el oponente apuntó y no esquivó ni se agachó en la última ronda, el valor de apuntar se duplica. Si esquivas o te agachas en la dirección correcta, tus posibilidades de esquivar son mayores (se desconoce la cantidad). Así que aproveche estas oportunidades con cautela.

  `)
  let sum = (o.dmg_min + o.dmg_max) / 2 + o.ziel + o.ausw
  if (o.shot) sum += o.schuss; else sum += o.schlag
  const sum1 = sum + Math.max(o.wid_schlag, o.wid_schuss) + Math.max(o.takt, o.auft)
  const sum2 = sum + Math.min(o.wid_schlag, o.wid_schuss) + Math.min(o.takt, o.auft)
  let sumText = sum1 + ' ' + TWDS._('VALUE_SUM_TEXT',
    `Suma del daño promedio, apuntar, esquivar, ya sea vigor o disparar,
    el valor máximo de resistencia y el máximo de apariencia y táctica.`) + '<br>'
  sumText += sum2 + ' ' + TWDS._('VALUE_SUM_TEXT_MIN',
    'Como arriba, con los dos máximos reemplazados por los mínimos.')

  // Spalte 3: Level
  appOne(tr, o.level, null, sumText)
  // Spalte 4: Zielen
  appOne(tr, o.ziel, 'ziel', aimChanceText)
  // Spalte 5: Auftreten
  appOne(tr, o.auft, 'auft')
  // Spalte 6: Schuß oder Schlag
  if (o.shot) {
    appOne(tr, o.schuss, 'dmgmod')
  } else {
    appOne(tr, o.schlag, 'dmgmod')
  }
  // Spalte 7: Ausweichen
  appOne(tr, o.ausw, 'ausw', dodgeChanceText)
  // Spalte 8: Taktik
  appOne(tr, o.takt, 'takt')
  // Spalte 9: Widerstand Nah
  appOne(tr, o.wid_schlag, 'wid_schlag',
    TWDS._('MELEE_RESISTANCE_DEF',
      'Resistencia contra armas contundentes: Tenacidad + 25% de Reflejo'))
  // Spalte 10: Widerstand Fern
  appOne(tr, o.wid_schuss, 'wid_schuss',
    TWDS._('SHOT_RESISTANCE_DEF',
      'Resistencia contra armas de fuego: Reflejo + 25% of Disparar'))

  // Spalte 11: Schaden
  const sch = Math.round((o.dmg_min + o.dmg_max) / 2)
  let dmgText = ''

  let rel = o.schlag
  if (o.shot) rel = o.schuss
  dmgText += TWDS._('MINDMG_HAND',
    '$dmg$ daño mínimo con tiro a mano y resistencia &gt;= $res$',
    { dmg: o.dmg_abs_min, res: rel + 100 })
  dmgText += '<br>'
  dmgText += TWDS._('MINDMG',
    '$dmg$ daño mínimo con tiro a mano y resistencia alrededor $res$',
    { dmg: o.dmg_min, res: rel })
  dmgText += '<br>'
  dmgText += TWDS._('MAXDMG',
    '$dmg$ daño máximo con tiro a cabeza y resistencia alrededor $res$',
    { dmg: o.dmg_max, res: rel })
  dmgText += '<br>'
  dmgText += TWDS._('MAXDMG_HEAD',
    '$dmg$ daño mñaximo con tiro a cabeza y resistencia &lt;= $res$',
    { dmg: o.dmg_abs_max, res: rel - 100 })
  dmgText += '<br>'
  dmgText += TWDS._('DMG_HELP',
    'El daño infligido depende del arma, el modificador de daño (vigor o disparo), la zona de impacto, la resistencia del oponente contra el tipo de arma y los buffs usados. Los buffs no se incluyen en los cálculos anteriores.')
  appOne(tr, sch, 'dmg', dmgText)

  // Spalte 12: Löschen
  td = document.createElement('td')
  tr.appendChild(td)
  but = TWDS.createButton(
    TWDS._('EQ_SET_REMOVE', 'eliminar'), {
      title: TWDS._('EQ_SET_REMOVE_MOUSEOVER', 'Eliminar esta equipación de la lista'),
      classList: ['TWDS_delete']
    })
  td.appendChild(but)
}

TWDS.getEquipmentContent = function () {
  const addHeadRow = function (tab) {
    const appOne = function (tr, ti, mo = null) {
      const td = document.createElement('td')
      td.textContent = ti
      if (mo != null) td.title = mo
      tr.appendChild(td)
    }
    const tr = document.createElement('tr')
    tr.className = 'headrow'
    tab.appendChild(tr)
    appOne(tr, TWDS._('NAME', 'Nombre'))
    appOne(tr, '') // no label, not needed
    appOne(tr, TWDS._('MENU_LEVEL_SHORT', 'Nivel'),
      TWDS._('MENU_LEVEL_LONG', 'El nivel del personaje en el momento en que se realizaron los cálculos.<br>Si abres el script nuevamente, con este equipo usado, los valores se actualizarán.'))
    appOne(tr, TWDS._('MENU_AIM_SHORT', 'Apuntar'),
      TWDS._('MENU_AIM_LONG', 'Puntería'))
    appOne(tr, TWDS._('MENU_APPEARANCE_SHORT', 'Apariencia'),
      TWDS._('MENU_APPEARANCE_LONG', "La habilidad de apariencia. Si es mayor que la habilidad táctica del defensor, el atacante obtendrá una bonificación de puntería (posiblemente la diferencia total)."))
    appOne(tr, TWDS._('MENU_DMGBON_SHORT', 'Mod. Daño'),
      TWDS._('MENU_DMGBON_LONG', 'La bonificación de daño: ya sea por vigor o por disparar.'))
    appOne(tr, TWDS._('MENU_DODGING_SHORT', 'Eludir'),
      TWDS._('MENU_DODGING_LONG', 'Eludir.'))
    appOne(tr, TWDS._('MENU_TACTICS_SHORT', 'Tácticas'),
      TWDS._('MENU_TACTICS_LONG', "La habilidad tácticas. Si es más grande que la apariencia del atacante, el defensor obtendrá una bonificación de puntería (posiblemente la diferencia total)."))
    appOne(tr, TWDS._('MENU_RES_MELEE_SHORT', 'Res_Cont.'),
      TWDS._('MENU_RES_MELEE_LONG',
        'La resistencia contra armas contundentes (Tenacidad más el 25% de Reflejo).'))
    appOne(tr, TWDS._('MENU_RES_SHOT_SHORT', 'Res_Fuego'),
      TWDS._('MENU_RES_MELEE_LONG',
        'La resistencia contra armas de fuego (Reflejo más 25% de Tenacidad).'))
    appOne(tr, TWDS._('MENU_DAMAGE_SHORT', 'Daño'),
      TWDS._('MENU_DAMAGE_LONG',
        'El daño medio hecho.'))
    appOne(tr, TWDS._('MENU_DELETE_SHORT', 'Eliminar'))
  }
  const newstuff = TWDS.getEquipmentData()
  const key = newstuff[0]
  const data = newstuff[1]
  const div = document.createElement('div')

  if (window.localStorage.getItem(key) !== null) {
    window.localStorage.setItem(key, data) // update it.
  } else {
    const b = TWDS.createButton(
      TWDS._('EQUIPMENT_TAKEOVER_BUTTON', 'Agregar equipo actual'),
      {
        classList: ['TWDS_specialequipment_button'],
        id: 'TWDS_equipment_takeover',
        dataSet: {
          key: key,
          edata: data
        }
      })
    div.appendChild(b)
  }

  const tab = document.createElement('table')
  div.appendChild(tab)
  tab.id = 'TWDS_equipment'
  addHeadRow(tab)
  const n = TWDS.fillEquipmentTab(tab)
  if (n >= 12) { addHeadRow(tab) }

  TWDS.getEquipmentContent.specialButtons(div)
  return div
}
TWDS.getEquipmentContent.specialButtons = function (div) {
  const but = function (text, key1, key2) {
    return TWDS.createButton(text, {
      classList: ['TWDS_specialequipment_button'],
      dataSet: {
        key1: key1,
        key2: key2
      }
    })
  }
  const appendOneBlock = function (container, specials, classAdd = '', doTranslate = true, doSort = true) {
    if (doTranslate) {
      for (let i = 0; i < specials.length; i++) {
        specials[i][1] = TWDS._(specials[i][0], specials[i][1])
      }
    }
    if (doSort) {
      specials.sort(function (a, b) {
        return a[1].localeCompare(b[1])
      })
    }
    let p
    if (container.nodeName === 'TABLE') {
      p = TWDS.createEle('tr', { className: classAdd })
    } else {
      p = TWDS.createEle('p', { className: classAdd })
    }
    container.appendChild(p)
    for (let i = 0; i < specials.length; i++) {
      const b = but(specials[i][1], specials[i][2], specials[i][3])
      if (container.nodeName === 'TABLE') {
        const td = TWDS.createEle('td')
        p.appendChild(td)
        td.appendChild(b)
      } else {
        p.appendChild(b)
      }
    }
  }

  let h = document.createElement('h3')
  h.textContent = TWDS._('SPECIAL_EQUIPMENT_HELPER', 'Ayudante equipos especiales')
  div.appendChild(h)

  let p = document.createElement('p')
  p.textContent = TWDS._('SPECIAL_EQUIPMENT_INFO', 'Para calcular una combinación de equipos con buenos valores de bonificación, utilice los siguientes botones. En computadoras lentas, esto puede llevar mucho tiempo, especialmente si tiene muchos conjuntos.')
  div.appendChild(p)

  h = document.createElement('h4')
  h.textContent = TWDS._('SPECIAL_BONUS', 'Bonus')
  div.appendChild(h)

  const specials = [
    ['SPECIAL_BUTTON_SPEED', 'Velocidad', 'special', 'speed'],
    ['SPECIAL_BUTTON_XP', 'EXP', 'special', 'xp'],
    ['SPECIAL_BUTTON_REGEN', 'Regeneración', 'special', 'regen'],
    ['SPECIAL_BUTTON_LUCK', 'Suerte', 'special', 'luck'],
    ['SPECIAL_BUTTON_PRAY', 'Rezar', 'special', 'pray'],
    ['SPECIAL_BUTTON_DOLLAR', 'Dinero', 'special', 'dollar'],
    ['SPECIAL_BUTTON_DROP', 'Tasa salida', 'special', 'drop']
  ]
  appendOneBlock(div, specials, 'TWDS_SPEC_spec')

  h = document.createElement('h4')
  h.textContent = TWDS._('SPECIAL_SKILLS', 'Habilidades')
  div.appendChild(h)

  const tab = TWDS.createEle('table', { className: 'TWDS_SPEC_SKILLS' })
  div.appendChild(tab)
  for (const a of CharacterSkills.allAttrKeys.values()) {
    const skills = []
    for (const b of CharacterSkills.getSkillKeys4Attribute(a).values()) {
      const c = CharacterSkills.getSkill(b)
      const d = {}
      d[b] = 1
      skills.push(['', c.name, 'skill', JSON.stringify(d)])
    }
    appendOneBlock(tab, skills, 'TWDS_spec_' + a, false, false)
  }

  h = document.createElement('h4')
  h.textContent = TWDS._('SPECIAL_DUELS', 'Duelos')
  div.appendChild(h)

  p = document.createElement('p')
  p.textContent = TWDS._('SPECIAL_DUELS_INFO', "Estas funciones buscan un equipo más o menos aceptable, pero no reemplazan el pensamiento y no pueden encontrar el 'mejor' equipo (ya que no conocen a tus oponentes).")
  div.appendChild(p)

  h = document.createElement('h5')
  h.textContent = TWDS._('SPECIAL_DUELS_DMG', 'Repartiendo daño')
  div.appendChild(h)
  let skills = [
    ['SPECIAL_DUELS_DMG_R_A', 'Duelista Fuego, ataque', 'range',
      JSON.stringify({ aim: 3, appearance: 1, shot: 3, dodge: 2 })],
    ['SPECIAL_DUELS_DMG_R_D', 'Duelista Fuego, defensa', 'range',
      JSON.stringify({ aim: 3, tactic: 1, shot: 3, dodge: 2 })],
    ['SPECIAL_DUELS_DMG_M_A', 'Duelista Contundente, ataque', 'melee',
      JSON.stringify({ aim: 3, appearance: 1, tough: 3, dodge: 2 })],
    ['SPECIAL_DUELS_DMG_M_D', 'Duelista Contundente, defensa', 'melee',
      JSON.stringify({ aim: 3, tactic: 1, tough: 3, dodge: 2 })]
  ]
  appendOneBlock(div, skills, 'TWDS_SPEC_duel_dmg', true, false)

  h = document.createElement('h5')
  h.textContent = TWDS._('SPECIAL_DUELS_DODGING', 'Esquivando daño')
  div.appendChild(h)
  skills = [
    ['SPECIAL_DUELS_DODGE_R_A', 'Duelista Fuego, ataque', 'range',
      JSON.stringify({ aim: 2, appearance: 1, shot: 1, dodge: 4 })],
    ['SPECIAL_DUELS_DODGE_R_D', 'Duelista Fuego, defensa', 'range',
      JSON.stringify({ aim: 2, tactic: 1, shot: 1, dodge: 4 })],
    ['SPECIAL_DUELS_DODGE_M_A', 'Duelista Contundente, ataque', 'melee',
      JSON.stringify({ aim: 2, appearance: 1, tough: 1, dodge: 4 })],
    ['SPECIAL_DUELS_DODGE_M_D', 'Duelista Contundente, defensa', 'melee',
      JSON.stringify({ aim: 2, tactic: 1, tough: 1, dodge: 4 })]
  ]
  appendOneBlock(div, skills, 'TWDS_SPEC_duel_dodge', true, false)

  h = document.createElement('h5')
  h.textContent = TWDS._('SPECIAL_DUELS_RES', 'Resistencia')
  div.appendChild(h)
  skills = [
    ['SPECIAL_DUELS_RES_AR_A', 'At. vs Duelista Fuego', 'skill',
      JSON.stringify({ aim: 1, appearance: 1, reflex: 4, tough: 1 })],
    ['SPECIAL_DUELS_RES_AR_D', 'Def. vs Duelista Fuego', 'skill',
      JSON.stringify({ aim: 1, tactic: 1, reflex: 4, tough: 1 })],
    ['SPECIAL_DUELS_RES_AM_A', 'At. vs Duelista Contundente', 'skill',
      JSON.stringify({ aim: 1, appearance: 1, reflex: 1, tough: 4 })],
    ['SPECIAL_DUELS_RES_AM_D', 'Def. vs Duelista Contundente', 'skill',
      JSON.stringify({ aim: 1, tactic: 1, reflex: 1, tough: 4 })],
    ['SPECIAL_DUELS_RES_D', 'Defensa contra Duelista', 'skill',
      JSON.stringify({ aim: 1, tactic: 1, reflex: 4, tough: 4 })]
  ]
  appendOneBlock(div, skills, 'TWDS_SPEC_duel_res', true, false)

  h = document.createElement('h4')
  h.textContent = TWDS._('SPECIAL_FB', 'Batallas de Fuerte')
  div.appendChild(h)

  p = document.createElement('p')
  p.textContent = TWDS._('SPECIAL_FB_INFO',
    "Estas funciones buscan un conjunto de equipamiento más o menos aceptable, pero no pueden tener en cuenta las bonificaciones de batalla de fuertes. Por lo tanto, casi nunca encontrarán el equipo 'perfecto'.")
  div.appendChild(p)

  skills = [
    ['SPECIAL_FB_TANK_ATT', 'Tanque, Ataque', 'fbtank',
      JSON.stringify({ health: 40, dodge: 15, hide: 25, aim: 10, pitfall: 0, leadership: 10 })],
    ['SPECIAL_FB_TANK_DEF', 'Tanque, Defensa', 'fbtank',
      JSON.stringify({ health: 40, dodge: 15, hide: 0, aim: 10, pitfall: 25, leadership: 10 })],
    ['SPECIAL_FB_DMG_ATT', 'Anti-tanque, Ataque', 'fbdamager',
      JSON.stringify({ health: -10, dodge: 10, hide: 30, aim: 30, pitfall: 0, leadership: 40 })],
    ['SPECIAL_FB_DMG_DEF', 'Anti-tanque, Defensa', 'fbdamager',
      JSON.stringify({ health: -10, dodge: 10, hide: 0, aim: 30, pitfall: 30, leadership: 40 })]
  ]
  appendOneBlock(div, skills, 'TWDS_SPEC_duel_dmg', true, false)
}

TWDS.activateEquipmentTab = function () {
  TWDS.activateTab('equipment')
}
TWDS.equipmenttab.specialbuttonhandler = function (ele) {
  const key1 = ele.dataset.key1
  const key2 = ele.dataset.key2
  let items = null
  if (key1 === 'special') {
    if (key2 === 'speed') items = TWDS.speedcalc.openwindow()
    else if (key2 === 'xp') items = TWDS.genCalc({ experience: 1 }, {})
    else if (key2 === 'regen') items = TWDS.genCalc({ regen: 1 }, { })
    else if (key2 === 'luck') items = TWDS.genCalc({ luck: 1 }, {})
    else if (key2 === 'pray') items = TWDS.genCalc({ pray: 1 }, {})
    else if (key2 === 'dollar') items = TWDS.genCalc({ dollar: 1 }, {})
    else if (key2 === 'drop') items = TWDS.genCalc({ drop: 1 }, {})
  } else if (key1 === 'skill') {
    const p = JSON.parse(key2)
    items = TWDS.genCalc({}, p)
  } else if (key1 === 'fbtank') {
    const p = JSON.parse(key2)
    items = TWDS.genCalc({
      fboffense: 10,
      fbdefense: 200,
      fbdamage: 10,
      fbresistance: 30
    }, p)
  } else if (key1 === 'fbdamager') {
    const p = JSON.parse(key2)
    items = TWDS.genCalc({
      fboffense: 200,
      fbdefense: 10,
      fbdamage: 30,
      fbresistance: 10
    }, p)
  } else if (key1 === 'range') {
    const p = JSON.parse(key2)
    items = TWDS.genCalc({ range: 100 }, p)
  } else if (key1 === 'melee') {
    const p = JSON.parse(key2)
    items = TWDS.genCalc({ melee: 100 }, p)
  }
  if (items !== null) { // null: speed set calc
    TWDS.wearItemsHandler(items)
  }
}

TWDS.registerStartFunc(function () {
  TWDS.registerTab('equipment',
    TWDS._('TABNAME_EQUIPMENT', 'Equipación'),
    TWDS.getEquipmentContent,
    TWDS.activateEquipmentTab,
    false)
  $(document).on('click', '#TWDS_equipment_takeover', function () {
    window.localStorage.setItem(this.dataset.key, this.dataset.edata)
    TWDS.clothcache.recalcItemUsage()
    TWDS.activateEquipmentTab()
    this.parentNode.removeChild(this)
  })
  $(document).on('click', '.TWDS_specialequipment_button', function () {
    TWDS.equipmenttab.specialbuttonhandler(this)
  })
  $(document).on('click', '.TWDS_wear', function () {
    const tr = this.closest('tr')
    const key = tr.dataset.key
    const tmp = window.localStorage.getItem(key)
    if (!tmp) return
    const o = JSON.parse(tmp)
    TWDS.wearItemsHandler(o.item_ids)
  })
})

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab
;(function () {
  const save = TWDS.fbdata
  TWDS.fbdata = {}
  TWDS.fbdata.fbw = (save ? save.fbw : false) || {}
})()
// TDWDS.fbdata.fbw[fortid]=fortbattlewindow
// fortbattlewindow:
// .fortId
// .characters=[
//   id: westPlayerId
//   characterid: index in .charIcons
//   name:
//   pos:
//   causeddamage
//   health
// ]
// .charIcons:[
//   .charId: jQuery[canvas or such thing]
// }
// .TWDS_hp: [team0hp, team1hp]

TWDS.fbdata.roundhandlerreal = function (that, roundno) {
  console.log('FBRHR', that, roundno)
  const fortid = that.fortId
  TWDS.fbdata.fbw[fortid] = that
  const a = []
  for (let i = 0; i < that.characters.length; i++) {
    a.push({
      id: that.characters[i].westPlayerId,
      name: that.characters[i].name,
      pos: that.characters[i].position,
      done: 0,
      causeddamage: that.characters[i].causeddamage,
      health: that.characters[i].health
    })
  }

  window.sessionStorage.TWDS_fbplayers = JSON.stringify(a)

  const hp = [0, 0]
  for (let i = 0; i < that.characters.length; i++) {
    const c = that.characters[i]
    if (c.team >= 0 && c.team <= 1) {
      hp[c.team] += c.health
    }
  }
  let hpd0 = -1
  let hpd1 = -1
  if (that.TWDS_hp && that.TWDS_hp[1]) {
    hpd0 = that.TWDS_hp[0] - hp[0]
    hpd1 = that.TWDS_hp[1] - hp[1]
  }
  that.TWDS_hp = [hp[0], hp[1]]
  // post the number diffs to the chat:
  TWDS.fbchat.roundhandler(fortid, roundno, hp[0], hp[1], hpd0, hpd1)
}
TWDS.fbdata.playerhandler = function (playerinfo) { // start of the battle
  window.FortBattleWindow._TWDS_backup_handlePlayerInfoSignal.call(this, playerinfo)
  TWDS.fbdata.roundhandlerreal(this, 0)
}
TWDS.fbdata.roundhandler = function (roundinfo) { // start of a round
  window.FortBattleWindow._TWDS_backup_handleRoundInfoSignal.call(this, roundinfo)
  TWDS.fbdata.roundhandlerreal(this, roundinfo.roundnumber)
}

TWDS.fbdata.cleanup = function () {
  for (let fortid of Object.keys(TWDS.fbdata.fbw)) {
    fortid = parseInt(fortid)
    if (TWDS.fbdata.fbw[fortid].isWindowOpen(fortid)) { continue }
    delete TWDS.fbdata.fbw[fortid]
  }
}
TWDS.fbdata.startfunc = function () {
  if (!window.FortBattleWindow._TWDS_backup_handleRoundInfoSignal) {
    window.FortBattleWindow._TWDS_backup_handleRoundInfoSignal = window.FortBattleWindow.handleRoundInfoSignal
  }
  window.FortBattleWindow.handleRoundInfoSignal = TWDS.fbdata.roundhandler

  if (!window.FortBattleWindow._TWDS_backup_handlePlayerInfoSignal) {
    window.FortBattleWindow._TWDS_backup_handlePlayerInfoSignal = window.FortBattleWindow.handlePlayerInfoSignal
  }
  window.FortBattleWindow.handlePlayerInfoSignal = TWDS.fbdata.playerhandler

  setInterval(TWDS.fbdata.cleanup, 5000)
}

TWDS.registerStartFunc(function () {
  TWDS.fbdata.startfunc()
})
// vim: tabstop=2 shiftwidth=2 expandtab
//

TWDS.collections = {}
TWDS.collections.seen_items = {}
TWDS.collections.missing_items = {}
TWDS.collections.unfinished = {}
TWDS.collections.loaded = {}
TWDS.collections.missing_collectible_jobs = {}
TWDS.collections.collectible_jobs = {}
TWDS.collections.getMissingList = function () {
  return TWDS.collections.missing_collectible_jobs
}

TWDS.collections.dropdata = {
  50206000: 0, // grüne handtasche @ quest geschäftsidee
  50511000: 158, // geldbeutelchen @ wells fargo
  50512000: 132, // modische handtasche @ pianist
  50513000: 155, // indianische handt. @ handelsbüro
  50514000: 0, // perlenhandt. @ shop
  50515000: 0, // uralter geldbeutel @ quest henry im urlaub
  50516000: 147, // reisehandtasche @ bühne
  50517000: 0, // seidenhandtasche @ shop

  50518000: 0, // starker whiskey @ quest einsamer cowboy
  50519000: 116, // fruchtcocktail @ alk. transportieren
  50520000: 154, // honiglikör @ alk. destillieren
  50521000: 0, // weißwein @ quest das große Footballspiel
  50522000: 136, // mex. tequila @ armdrücken
  50523000: 133, // premiumrum @ greenhorns
  50524000: 0, // tokaier @ quest seefahrer
  50525000: 0, // bester schwarzgebrannter @ shop

  50279000: 0, // henry draper med. @ quest weltraum
  50526000: 159, // ehrenmedialle der marine @ pinkerton
  50527000: 140, // ehrenmedialle der armee @ kugeln einschmelzen
  50528000: 139, // freiheitsmed. @ personenschützer
  50529000: 157, // gold. verdienstmed. @ expedition
  50530000: 0, // silbersternmed, @ quest knastbrüder
  50531000: 0, // anerkennungsmed. @ quest leg. gold. säbel
  50532000: 0, // taperkeit auf see. @ shop

  50353000: 0, // indianertrommel: quest erneuere den geist
  50533000: 153, // shipibo-rassel @ alligatoren
  50534000: 160, // ind. flöte @ westen erkunden
  50535000: 143, // okarina @ reservat
  50536000: 0, // sansula @ quest kopfloser pferdemann
  50537000: 141, // koshi-glocke @ großwild
  50538000: 131, // chajchas @ fallensteller
  50539000: 0, // regenstab @sop

  52651000: 184, // bisonschädel @ nickel
  52652000: 164, // maultierhirsch @ reporter
  52653000: 198, // wolf @ bullen jagen
  52654000: 173, // adlerschädel @ historiker
  52655000: 0, // schlangenschädel @ quest
  52656000: 205, // eidechsenschädel @ füchse
  52657000: 193, // biber @ archaeloge
  52658000: 172, // kaninchenschädel @ hasen jagen

  52659000: 169, // goldadlereier @ büro
  52660000: 201, // montezuma wachtel eier @ antilopen
  52661000: 204, // wanderfalkeneier @ gerichtsmediziner
  52662000: 183, // purpurschnäpper @ kisten
  52663000: 0, // hausfinkeneier quest
  52664000: 175, // amerikanische kräheneier @ rinder stehlen
  52665000: 197, // amer. flamingo @ lagerfeuer
  52666000: 171, // baltimore-Trupial-Eier @barbier

  52667000: 165, // Rotkehlchen @ bahnkarten-verkäufer
  52668000: 163, // Gartenspottdrossel @ karotten
  52669000: 186, // Waldenteneier @ pferdezüchter
  52670000: 176, // ara @ ahornsirup
  52671000: 0, // groß-tinamu-eier @ quest
  52672000: 170, // eichelspecht @ richter
  52673000: 182, // eistaucher @ pferde verkaufen
  52674000: 187, // steinkauz @ barkeeper

  53146000: 185, // yucca @ banditenanführer
  53147000: 168, // steppenläufer @ büchsenmacher
  53148000: 203, // bleistiftstrauch @ regentanz
  53149000: 188, // fackellilie @ tierarzt
  53150000: 0, // ocotillo @ quest
  53151000: 199, // steppenkerze @ goldgräber ausrauben
  53152000: 161, // feigenkaktus @ fallen stellen
  53153000: 174, // aloe vera @ arzt

  53154000: 200, // amerikanische Zittelpappel @ kartograph
  53155000: 167, // nadelbaum @ schneider
  53156000: 179, // blaufichte @ zugmechaniker
  53157000: 195, // rocky mountain wacholder @ eis schneiden
  53158000: 0, // weißrinden-kiefer @ quest
  53159000: 181, // drehkiefer @ lebensmittel stehlen
  53160000: 190, // felsentanne @ händler bestehelen
  53161000: 189, // westliche rotzeder @ imker
  53162000: 178, // opuntie @ bankier
  53163000: 191, // drachenfrucht @ pilze
  53164000: 192, // pracht-himbeeren @ tipi
  53165000: 180, // pawpaws @ koch
  53166000: 0, // schwarze maulbeeren @ quest
  53167000: 162, // weiße maulbeeren @ kräuter
  53168000: 177, // vogenbeeren @ anwalt
  53169000: 166 // papaya @ gemischtwaren
}

TWDS.collections.openwindow = function () {
  const win = wman.open('TWDS_collections_window', 'Colecciones', 'TWDS_collections_window')
  win.setMiniTitle('Collections')

  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_collections_list'
  })
  TWDS.createEle('h2', { textContent: 'Colecciones', beforeend: content })
  const dl = TWDS.createEle('dl', { beforeend: content })
  console.log('unfinished', TWDS.collections.unfinished)

  for (const name of Object.keys(TWDS.collections.unfinished)) {
    const c = TWDS.collections.unfinished[name]
    TWDS.createEle('dt', { beforeend: dl, textContent: name })
    const dd = TWDS.createEle('dd', { beforeend: dl })
    for (let i = 0; i < c.length; i++) {
      const span = TWDS.createEle('span', { beforeend: dd })
      const itno = c[i]
      const it = ItemManager.get(itno)
      if (!it) continue
      const inside = new tw2widget.InventoryItem(it)
      span.appendChild(inside.getMainDiv()[0])
      const b = TWDS.createEle('b', { beforeend: span })
      if (it.auctionable) {
        const sl = TWDS.marketsearchlink(itno)
        if (sl) { b.appendChild(sl) }
      }
      if (it.tradeable && it.traderlevel !== 99) {
        if (window.TW_Calc && window.TW_Calc.openShopWindowByItemId) {
          const x = TWDS.createEle('i', { beforeend: b, textContent: '$', className: 'TWDS_collections_shoplink' })
          x.onclick = function () {
            window.TW_Calc.openShopWindowByItemId(itno)
          }
        }
      }
      if (itno in TWDS.collections.dropdata && TWDS.collections.dropdata[itno]) {
        const jobno = TWDS.collections.dropdata[itno]
        const jobdata = JobList.getJobById(jobno)
        b.innerHTML += MinimapWindow.getQuicklink(jobdata.name, 'task-finish-job')
      }
    }
  }
  sp.appendContent(content)

  win.appendToContentPane(sp.getMainDiv())
}

TWDS.collections.prepareNameCache = function () {
  const out = {}
  const all = ItemManager.getAll()
  for (const e of Object.values(all)) {
    out[e.name] = e.item_id
  }
  return out
}
TWDS.collections.findItemByName = function (name, cache) {
  const all = ItemManager.getAll()
  for (const e of Object.values(all)) {
    if (e.name === name && e.item_level === 0) { return e.item_id }
  }
  return -1
}
TWDS.collections.isMissing = function (ii) {
  if (ii in TWDS.collections.missing_items) return true
  return false
}
TWDS.collections.load = function () {
  Ajax.remoteCall('achievement', 'get_list', {
    folder: 'collections',
    playerid: Character.playerId
  }, function (x) {
    console.log(x)
    // i'm not going to parse HTML. No, i am not.
    // Even if this is slower than needed.
    const div = TWDS.createEle({ nodeName: 'div' })

    const namecache = TWDS.collections.prepareNameCache()

    const p = x.achievements.progress
    for (let i = 0; i < p.length; i++) {
      const a = p[i]
      TWDS.collections.unfinished[a.title] = []
      for (let j = 0; j < a.meta.length; j++) {
        div.innerHTML = a.meta[j]
        const spans = TWDS.q('span', div)
        const title = a.title
        for (let k = 0; k < spans.length; k++) {
          const span = spans[k]
          const name = span.title
          let ii = -1
          if (name in namecache) { ii = namecache[name] }
          if (span.classList.contains('locked')) {
            // missing shit.
            TWDS.collections.missing_items[ii] = title
            TWDS.collections.unfinished[title].push(ii)
            if (ii in TWDS.collections.dropdata && TWDS.collections.dropdata[ii]) {
              const jobno = TWDS.collections.dropdata[ii]
              TWDS.collections.missing_collectible_jobs[jobno] = ii
              TWDS.collections.collectible_jobs[jobno] = ii
            }
          } else {
            TWDS.collections.seen_items[ii] = title
          }
        }
      }
    }
    TWDS.collections.loaded = true
  })
}
TWDS.registerStartFunc(function () {
  // wait 2.5 seconds to avoid a thundering herd.
  setTimeout(TWDS.collections.load, 2500)
  TWDS.registerExtra('TWDS.collections.openwindow',
    TWDS._('EXTRAS_COLLECTIONS_TEXT', 'Colecciones'),
    TWDS._('EXTRAS_COLLECTIONS_HELP', 'Muestra los artículos de las colecciones que le faltan.')
  )
})
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.itemuse = { }
TWDS.itemuse.chests = { }
TWDS.itemuse.itemusehandler = function (itemid, resp) {
  console.log('item used', itemid, resp)
  if (resp.error) return
  const msg = resp.msg
  const effs = msg.effects
  let flagdidchest = false
  const loaded = window.localStorage.getItem('TWDS_itemuse_cache')
  if (!loaded) { TWDS.itemuse.chests = {} } else { TWDS.itemuse.chests = JSON.parse(loaded) }
  for (let i = 0; i < effs.length; i++) {
    const eff = effs[i]
    if (eff.type === 'learn_recipe') {
      TWDS.crafting.start()
      continue
    }
    if (eff.type !== 'lottery' && eff.type !== 'content') {
      console.log('TWDS.itemuse.handler', 'unhandled effect type', eff.type, 'in', resp)
      continue
    }
    if (!TWDS.itemuse.chests[itemid]) { TWDS.itemuse.chests[itemid] = { count: 0, items: {} } }
    if (!flagdidchest) {
      TWDS.itemuse.chests[itemid].count++
      flagdidchest++
    }
    for (let j = 0; j < eff.items.length; j++) {
      const found = eff.items[j].item_id
      if (!(found in TWDS.itemuse.chests[itemid].items)) {
        TWDS.itemuse.chests[itemid].items[found] = 0
      }
      TWDS.itemuse.chests[itemid].items[found] += eff.items[j].count
    }
  }
  window.localStorage.setItem('TWDS_itemuse_cache', JSON.stringify(TWDS.itemuse.chests))
}
TWDS.itemuse.adventhandler = function (calendarid, resp) {
  console.log('advent used', calendarid, resp)
  if (resp.error) return
  const msg = resp.msg
  const loaded = window.localStorage.getItem('TWDS_itemuse_cache')
  if (!loaded) { TWDS.itemuse.chests = {} } else { TWDS.itemuse.chests = JSON.parse(loaded) }
  if (!TWDS.itemuse.chests[calendarid]) { TWDS.itemuse.chests[calendarid] = { count: 0, items: {} } }
  const found = msg.item
  if (!(found in TWDS.itemuse.chests[calendarid].items)) {
    TWDS.itemuse.chests[calendarid].items[found] = 0
  }
  TWDS.itemuse.chests[calendarid].items[found] += msg.n
  TWDS.itemuse.chests[calendarid].count++
  window.localStorage.setItem('TWDS_itemuse_cache', JSON.stringify(TWDS.itemuse.chests))
}
TWDS.itemuse.wofhandler = function (container, resp) {
  let found = 0
  console.log('wofhandler used', container, resp)
  if (resp.error) return
  const loaded = window.localStorage.getItem('TWDS_itemuse_cache')
  if (!loaded) { TWDS.itemuse.chests = {} } else { TWDS.itemuse.chests = JSON.parse(loaded) }
  if (!TWDS.itemuse.chests[container]) { TWDS.itemuse.chests[container] = { count: 0, items: {} } }
  if ('picked' in resp) {
    found = resp.picked[0]
  } else if ('rewards' in resp) {
    found = resp.rewards.item
  } else if ('prize' in resp) {
    found = resp.prize.itemId
  } else if ('outcome' in resp) {
    found = resp.outcome.itemId
  } else if ('attribute' in resp) {
    found = resp.itemId
  }
  if (found) {
    if (!(found in TWDS.itemuse.chests[container].items)) {
      TWDS.itemuse.chests[container].items[found] = 0
    }
    TWDS.itemuse.chests[container].items[found] += 1
    TWDS.itemuse.chests[container].count++
  }
  window.localStorage.setItem('TWDS_itemuse_cache', JSON.stringify(TWDS.itemuse.chests))
}

TWDS.itemuse.openwindow = function () {
  const wid = 'TWDS_itemusewindow'
  const win = wman.open(wid, 'set', 'TWDS_itemuse')
  win.setTitle('Contenido Cofres')
  win.setMiniTitle('Cofres')
  const loaded = window.localStorage.getItem('TWDS_itemuse_cache')
  if (!loaded) { TWDS.itemuse.chests = {} } else { TWDS.itemuse.chests = JSON.parse(loaded) }

  const t = TWDS.createEle({
    nodeName: 'table'
  })
  const tb = TWDS.createEle({
    nodeName: 'tbody',
    beforeend: t,
    children: [
      {
        nodeName: 'tr',
        className: 'header',
        children: [
          { nodeName: 'th', textContent: 'Cofre' },
          { nodeName: 'th', textContent: 'Contenido' }
        ]
      }
    ]
  })

  const a = Object.keys(TWDS.itemuse.chests)
  a.sort(function (x, y) { return y - x })
  for (let i = 0; i < a.length; i++) {
    let chestid = a[i]
    const oldchestid = chestid // for onclick handler
    if (chestid === 2347000) { // fair kitten
      chestid = 40035000
    }
    const count = TWDS.itemuse.chests[chestid].count
    const items = TWDS.itemuse.chests[chestid].items
    const ci = ItemManager.get(chestid)
    const tr = TWDS.createEle('tr', { beforeend: tb, dataset: { chestid: oldchestid } })
    const outside = new tw2widget.InventoryItem(ci).setCount(count)
    TWDS.createEle({
      nodeName: 'th',
      beforeend: tr,
      children: [outside.getMainDiv()[0]]
    })
    const ic = TWDS.createEle({
      nodeName: 'td',
      beforeend: tr
    })
    const b = Object.keys(items)
    b.sort(function (x, y) { return y - x })
    for (let j = 0; j < b.length; j++) {
      const itno = b[j]
      const it = ItemManager.get(itno)
      if (!it) continue
      const inside = new tw2widget.InventoryItem(it).setCount(items[itno])
      ic.appendChild(inside.getMainDiv()[0])
    }
    TWDS.createEle({
      nodeName: 'button',
      textContent: 'borrar',
      title: 'Elimina los datos recopilados',
      last: ic,
      onclick: function () {
        let cid = this.closest('tr').dataset.chestid
        cid = parseInt(cid)
        if (cid in TWDS.itemuse.chests) {
          delete (TWDS.itemuse.chests[cid])
          this.closest('tr').remove()
          window.localStorage.setItem('TWDS_itemuse_cache', JSON.stringify(TWDS.itemuse.chests))
        }
      }
    })
  }

  const sp = new west.gui.Scrollpane()

  sp.appendContent(t)

  win.appendToContentPane(sp.getMainDiv())
}
TWDS.itemuse.prehandler = function (ev, xhr, settings) {
  if (xhr.status !== 200) return
  const url = settings.url
  if (url.search('window=itemuse') !== -1) {
    if (!TWDS.settings.misc_chestanalyzer) return
    const mat = settings.data.match('item_id=([0-9]+)')
    if (mat == null) return
    TWDS.itemuse.itemusehandler(parseInt(mat[1]), xhr.responseJSON)
  }
  if (url.search('window=advent') !== -1) {
    console.log('itemuse? advent', 1)
    if (!TWDS.settings.misc_chestanalyzer) return
    console.log('itemuse? advent', 2)
    if (url.search('action=open_door') === -1) return
    console.log('itemuse? advent', 3)
    TWDS.itemuse.adventhandler(12700000, xhr.responseJSON)
  }
  if (url.search('window=wheeloffortune') !== -1) {
    console.log('itemuse? wheel', 1)
    if (!TWDS.settings.misc_chestanalyzer) return
    console.log('itemuse? wheel', 2)
    if (url.search('action=gamble') === -1) return
    console.log('itemuse? wheel', 3)

    // dod: url contains action=gamble,  form data contains action=end&wofid=NNN
    let dod = 0
    let mat = settings.data.match('action=end')
    if (mat !== null) {
      mat = settings.data.match('wofid=')
      if (mat !== null) {
        dod = 1
      }
    }
    mat = settings.data.match('gametype=([a-z0-9_]+)')
    if (mat !== null) {
      console.log('itemuse? wheel', 3)
      const container = 2347000 // fair kitten
      TWDS.itemuse.wofhandler(container, xhr.responseJSON)
    } else if (dod) {
      TWDS.itemuse.wofhandler(2666000, xhr.responseJSON.stages[0]) // big flower pot
    } else if (xhr.responseJSON.prize && xhr.responseJSON.prize.itemId) {
      const container = 52361000 // valentine rose cake
      TWDS.itemuse.wofhandler(container, xhr.responseJSON)
    } else if (xhr.responseJSON.outcome && xhr.responseJSON.outcome.itemId) {
      let container = 2698000 // easter nest
      if (Game.sesData.Independence) {
        container = 51483000 // efficient firework container
      }
      TWDS.itemuse.wofhandler(container, xhr.responseJSON)
    } else if (xhr.responseJSON.attribute && xhr.responseJSON.itemId && Game.sesData.Octoberfest) {
      const container = 50691000 // pretzel bag
      TWDS.itemuse.wofhandler(container, xhr.responseJSON)
    }
  }
}
TWDS.registerStartFunc(function () {
  TWDS.registerSetting('bool', 'misc_chestanalyzer',
    TWDS._('MISC_SETTING_CHESTANALYZER', 'Analizar el contenido de los cofres.'),
    true)
  TWDS.registerExtra('TWDS.itemuse.openwindow',
    TWDS._('EXTRAS_CHESTS_TEXT', 'Contenido Cofres'),
    TWDS._('EXTRAS_CHESTS_HELP', 'Muestra el contenido de los cofres abiertos.')
  )

  // it's either this hack, or patching the original function.
  // this here isn't beautiful, but at least less prone to fuckups.
  $(document).ajaxComplete(function (event, request, settings) {
    TWDS.itemuse.prehandler(event, request, settings)
  })
})
// vim: tabstop=2 shiftwidth=2 expandtab
//
//
//
TWDS.crafting = {}
TWDS.crafting.mycraftableitems = {}
TWDS.crafting.mycraftresources = {}
TWDS.crafting.myrecipes = {}
TWDS.crafting.callback = null

TWDS.crafting.storemyrecipes = function (x) {
  const cb = TWDS.crafting.callback
  TWDS.crafting.callback = null
  if (x.error) return
  if (x.recipes_content) {
    for (let i = 0; i < x.recipes_content.length; i++) {
      const rid = x.recipes_content[i].item_id
      const r = ItemManager.get(rid)
      if (r) {
        TWDS.crafting.mycraftableitems[r.craftitem] = true
        for (let j = 0; j < r.resources.length; j++) {
          const ri = r.resources[j].item
          TWDS.crafting.mycraftresources[ri] = true
        }
      }
      TWDS.crafting.myrecipes[rid] = x.recipes_content[i].last_craft
    }
  }
  if (cb) {
    cb()
  }
}
TWDS.crafting.start = function (cb) {
  if (cb) { TWDS.crafting.callback = cb }
  if (!ItemManager.isLoaded()) {
    window.setTimeout(TWDS.crafting.start, 250)
    return
  }
  Ajax.remoteCall('crafting', '', {}, TWDS.crafting.storemyrecipes)
}

TWDS.registerStartFunc(function () {
  setTimeout(TWDS.crafting.start, 2500)
})

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.items = {}
TWDS.items.item2recipe = {} // itemid: recipeid
TWDS.items.data = {}
TWDS.items.date = 0

TWDS.items.popupenhancementReal = function () {
  let t

  if (TWDS.settings.itempopup_enable) {
    if (TWDS.settings.itempopup_bonuscharlevel) {
      this.options.character = {
        level: Character.level
      }
    }
  }

  const orig = window.ItemPopup._twds_backup_getXHTML.call(this)
  if (!TWDS.settings.itempopup_enable) return orig

  if (document.activeElement && document.activeElement.nodeName === 'IFRAME') return orig // band-aid for the forum.php iframe

  const wrapper = TWDS.createEle('div')
  wrapper.innerHTML = orig

  const item = this.item_obj
  const ii = item.item_id

  TWDS.items.origpopup = orig // iteminfo... debugging

  const istwir = TWDS.q('.inventory_popup > table', wrapper).length
  if (istwir) {
    // TWIR makes a mess out of the popup, removing structure.
    return orig
  }

  const ip = TWDS.q1('.inventory_popup', wrapper)
  if (!ip) return orig
  ip.classList.add('TWDS_enhanced')

  const head = TWDS.q1('.invPopup_head', wrapper)
  if (head) {
    if (TWDS.settings.itempopup_count) {
      t = TWDS.q1('.inventory_popup_icon', wrapper)
      if (t) {
        let c = Bag.getItemCount(ii)
        if (Wear.wear[item.type] && Wear.wear[item.type].getId() === ii) { c += 1 }
        TWDS.createEle({
          nodeName: 'div.twds_count',
          last: t,
          textContent: c
        })
        if (item.item_level) {
          TWDS.createEle({
            nodeName: 'div.item_level',
            last: t,
            textContent: item.item_level
          })
        }
      }
      const t2 = TWDS.q1('.invPopup_body .item_level', wrapper)
      if (t2) t2.remove()
    }
    if (TWDS.settings.itempopup_itemid) {
      t = TWDS.q1('.invPopup_head > div:last-child', wrapper)
      if (t) {
        TWDS.createEle({
          nodeName: 'div.TWDS_id',
          last: head,
          textContent: '[item=' + ii + ']'
        })
      }
    }
  }
  t = TWDS.q1('.inventory_popup_type', wrapper)
  if (t) {
    if (item.type === 'right_arm') {
      const span = TWDS.q1('span', t)
      if (span) {
        t.textContent = t.textContent.replace(/\(/, ' (')
      }
    }
  }

  t = TWDS.q1('.inventory_popup_damage', wrapper)
  if (t) {
    if (t) {
      const spans = TWDS.q('span', t)
      if (spans.length === 2) {
        let v = parseInt(spans[0].textContent) + parseInt(spans[1].textContent)
        v = Math.round(v / 2)
        TWDS.createEle({
          nodeName: 'span.TWDS_avgdamage',
          textContent: v,
          afterend: spans[1]
        })
      }
    }
  }

  if (TWDS.settings.itempopup_eventinfo) {
    const setinfo = TWDS.itemsettab.classifyset(item.set)
    if (setinfo) {
      TWDS.createEle({
        nodeName: 'div.TWDS_eventdata',
        last: head,
        children: [
          { nodeName: 'span.year', dataset: { year: setinfo.year }, textContent: setinfo.year },
          {
            nodeName: 'span.event',
            dataset: { year: setinfo.eventname },
            textContent:
            TWDS._('ITEMPOPUP_EVENTNAME_' + setinfo.eventname, setinfo.eventname)
          }
        ]
      })
    }
  }

  // wrap the item set infos.
  const isb = TWDS.q1('.item_set_bonus', wrapper)
  const isn = TWDS.q1('.item_set_names', wrapper)

  if (isb && isn) {
    ip.classList.add('TWDS_with_set_bonus')
    const setarea = TWDS.createEle('div.itemsetinfo', { last: ip })
    // .item_set_names is empty, followed by a <span> containing the name of the set.
    // which is insane, of course.
    const n = isn.nextSibling
    if (n && n.nodeName === 'SPAN') {
      TWDS.createEle({
        nodeName: 'h2.setname',
        textContent: n.textContent,
        last: setarea
      })
      n.remove()
      isn.remove()
    }
    t = TWDS.q1('.inventory_popup_item_set_names', wrapper)
    if (t) {
      setarea.appendChild(t)
    }

    setarea.appendChild(isb)
  }

  t = TWDS.q1('.inventory_popup_requirement_text', wrapper)
  if (t) {
    t.className = 'requirements'
    const sp = TWDS.q1('.inventory_popup_level', t)
    if (sp) {
      if (sp.textContent.trim().match(/ 1$/)) {
        sp.remove()
      }
      if (sp.textContent.trim().match(/ 1 \(1\)$/)) {
        sp.remove()
      }
    }
    const t2 = TWDS.q1('.inventory_popup_recipe', wrapper)
    if (t2) { t.appendChild(t2) }

    const spans = TWDS.q('span', t)
    if (!spans.length) { t.remove() }
  }

  // clean up the footer
  const foot = TWDS.q1('.invPopup_foot', wrapper)
  t = TWDS.q('br', foot)
  for (let i = 0; i < t.length; i++) t[i].remove()

  if (TWDS.settings.itempopup_showtime) {
    if (ii in TWDS.items.data) {
      const d = TWDS.items.data[ii]
      const ti = d.time * 3600
      // console.log('IPST', d, ti)
      let str = ''
      if (d.crafteditems > 0) {
        if (d.founditems) {
          str += TWDS._('ITEMPOPUP_CRAFTED', 'Elaborado')
          str += TWDS._('ITEMPOPUP_CRAFTED_FOUNDITEMS', ', $n$ artículos a encontrar (<= $time$)', {
            n: d.founditems,
            time: ti.formatDuration()
          })
        }
        if (d.shopitems > 0) { str += TWDS._('ITEMPOPUP_SHOPITEMS', ', $n$ artículos a comprar', { n: d.shopitems }) }
      } else {
        str += TWDS._('ITEMPOPUP_FOUNDITEM_WORKTIME', 'Encontrado, <= $time$ para recolectar', {
          time: ti.formatDuration()
        })
      }

      TWDS.createElement({
        nodeName: 'div',
        className: 'timeinfo',
        last: foot,
        textContent: str
      })
      if (d.crafteditems === 0) {
        if (d.jobs && d.jobs.length) {
          const a = []
          for (let i = 0; i < d.jobs.length; i++) {
            a.push(TWDS.createEle({
              nodeName: 'span',
              className: 'onejob',
              dataset: { id: d.jobs[i][0] },
              children: [
                { nodeName: 'span.name', textContent: JobList.getJobById(d.jobs[i][0]).name },
                { nodeName: 'span.yield', textContent: (100 * d.jobs[i][1]).toFixed(0) + '%' }
              ]
            }))
          }
          TWDS.createElement({
            nodeName: 'div',
            className: 'jobinfo',
            last: foot,
            children: a
          })
        }
      }
      if (ii in TWDS.items.item2recipe) {
        console.log('XXXX', TWDS.items.item2recipe[ii])
        const ri = ItemManager.get(TWDS.items.item2recipe[ii])
        console.log('XXXX', ri)
        const ele = TWDS.createEle({
          nodeName: 'div.recipeinfo',
          last: foot,
          children: [{
            nodeName: 'div.profinfo.profession_' + ri.profession_id,
            title: ri.profession,
            dataset: {
              level: ri.min_level
            }
          }]
        })
        const pa = TWDS.createEle({
          nodeName: 'div.rsinfo',
          last: ele
        })
        for (let i = 0; i < ri.resources.length; i++) {
          const x = ri.resources[i].item
          const y = ri.resources[i].count
          const xi = ItemManager.get(x)
          const z = new tw2widget.InventoryItem(xi).setCount(y)
          TWDS.createEle({
            nodeName: 'div.oneitem',
            last: pa,
            children: [z.getMainDiv()[0]]
          })
        }
      }
    }
  }

  if (TWDS.settings.itempopup_showjobicon) {
    if (ii in TWDS.collections.dropdata) {
      const jid = TWDS.collections.dropdata[ii]
      const jd = JobList.getJobById(jid)
      if (jd) {
        TWDS.createElement({
          nodeName: 'img',
          className: 'TWDS_popup_enhance2',
          src: '/images/jobs/' + jd.shortname + '.png',
          afterbegin: head
        })
      }
    }
  }

  return wrapper.innerHTML
}

TWDS.items.popupenhancement = function () {
  return TWDS.items.popupenhancementReal.call(this)
}
TWDS.items.makedata = function () {
  TWDS.items.data = {} // for debugging.

  const items = ItemManager.getAll()
  const recipes = {}
  const done = {} // rs-id => worktime in hours
  const proto = {
    time: 0,
    shopitems: 0,
    founditems: 0,
    crafteditems: 0,
    crafts: 0,
    jobs: [],
    err: false
  }

  const getiteminfo = function (itemid) {
    const it = ItemManager.get(itemid)
    const out = Object.assign({}, proto)
    out.jobs = []
    if (itemid in done) {
      return done[itemid]
    }
    if (it.spec_type === 'mapdrop') {
      const jobs = JobList.getJobsByItemId(itemid)
      let perhour = -1
      if (jobs.length) {
        for (let j = 0; j < jobs.length; j++) {
          let x = -1
          try {
            x = jobs[j].yields[itemid].prop
          } catch (e) {
          }
          perhour = Math.max(perhour, x)
          out.jobs.push([jobs[j].id, x * 6]) // 5 bronze stars
        }
        // perhour is % at 0 stars
        perhour = perhour * 6 // 5 bronze stars
      }
      if (perhour < 0) {
        console.log('strange, no job for', it.spec_type, 'with', it.name)
        out.err = true
      }
      out.time = 1 / perhour
      out.founditems = 1
    } else if (it.spec_type === 'crafting') {
      if (itemid in done) {
        return done[itemid]
      }
    } else if (it.spec_type === 'none') {
      // habaneros and cogwheels are none, but should be jobdrop
      // empty jar is rightly here.
      out.shopitems = 1
    } else if (it.spec_type === 'jobdrop') {
      // cobra teeth and cossack saddle blanket
      out.shopitems = 1
    } else {
      console.log('unhandled spec_type', it.spec_type, 'with', it.name)
      out.err = true
    }
    return out
  }

  for (const it of Object.values(items)) {
    if (it.type === 'recipe') {
      TWDS.items.item2recipe[it.craftitem] = it.item_id
      recipes[it.item_id] = it
    }
    if (it.type === 'yield' && it.spec_type === 'mapdrop') {
      const info = getiteminfo(it.item_id)
      TWDS.items.data[it.item_id] = info
      done[it.item_id] = info
    }
  }
  let loopcount = 0
  while (true) {
    loopcount++
    let didone = false
    for (const rid of Object.keys(recipes)) {
      const crafted = recipes[rid].craftitem
      if (crafted in done) { continue }
      const res = recipes[rid].resources
      const out = Object.assign({}, proto)
      out.crafts = recipes[rid].profession_id

      for (let i = 0; i < res.length; i++) {
        const thing = res[i].item
        const count = res[i].count
        const info = getiteminfo(thing)
        if (info.err) {
          out.err = true
        } else {
          out.time += info.time * count
          out.shopitems += info.shopitems * count
          out.founditems += info.founditems * count
          out.crafteditems += info.crafteditems * count
          out.crafts |= info.crafts
        }
      }
      if (!out.err) {
        out.crafteditems += 1
        done[crafted] = out
        TWDS.items.data[crafted] = out
        // if (loopcount>1) console.log("did r",rid,recipes[rid].name)
        didone = true
      }
    }
    if (!didone) {
      break
    }
    if (loopcount > 9) {
      console.log('loopcount', loopcount, 'break', didone)
      break
    }
  }
}
TWDS.items.start = function () {
  if (TWDS.items.date === 0) {
    let x = window.localStorage.getItem('TWDS_items_date')
    if (x) {
      TWDS.items.date = parseInt(x)
      try {
        x = window.localStorage.getItem('TWDS_items_data')
        TWDS.items.data = JSON.parse(x)
      } catch (e) {
        TWDS.items.date = 0
      }
    }
  }
  if (TWDS.items.date < (new Date()).getTime() - 86400 * 1000) {
    TWDS.items.makedata()
    window.localStorage.setItem('TWDS_items_data', JSON.stringify(TWDS.items.data))
    TWDS.items.date = (new Date()).getTime()
    window.localStorage.setItem('TWDS_items_date', TWDS.items.date)
  }

  if (!window.ItemPopup._twds_backup_getXHTML) { window.ItemPopup._twds_backup_getXHTML = window.ItemPopup.getXHTML }
  window.ItemPopup.getXHTML = TWDS.items.popupenhancement
}

TWDS.registerStartFunc(function () {
  TWDS.registerSetting('bool', 'itempopup_enable',
    TWDS._('SETTING_ITEMPOPUP_ENABLE',
      'Mostrar ventana emergente artículos mejorada. ###Conflicto varios scripts###'),
    false, null, 'Elementos Flotantes', null, 0)
  TWDS.registerSetting('bool', 'itempopup_eventinfo',
    TWDS._('SETTING_ITEMPOPUP_EVENTINFO',
      'Mostrar información del evento en la ventana emergente del elemento.'),
    true, null, 'Elementos Flotantes')
  TWDS.registerSetting('bool', 'itempopup_showjobicon',
    TWDS._('SETTING_ITEMPOPUP_SHOWJOBICON',
      'Mostrar el icono del trabajo con la tasa de salida del producto.'),
    true, null, 'Elementos Flotantes')
  TWDS.registerSetting('bool', 'itempopup_showtime',
    TWDS._('SETTING_ITEMPOPUP_SHOWTIME',
      'Mostrar el tiempo necesario para recolectar un artículo, o los ingredientes de un artículo elaborado, utilizando las tasas de obtención básicas.'),
    true, null, 'Elementos Flotantes')
  TWDS.registerSetting('bool', 'itempopup_count',
    TWDS._('SETTING_ITEMPOPUP_COUNT', 'Mostrar el recuento de artículos que posee.'),
    true, null, 'Elementos Flotantes')
  TWDS.registerSetting('bool', 'itempopup_itemid',
    TWDS._('SETTING_ITEMPOPUP_ID', 'Mostrar la ID del artículo.'),
    true, null, 'Elementos Flotantes')
  TWDS.registerSetting('bool', 'itempopup_bonuscharlevel',
    TWDS._('SETTING_ITEMPOPUP_BONUS_CHARLEVEL', 'Mostrar siempre el artículo/conjunto que coincida con el nivel del personaje.'),
    true, null, 'Elementos Flotantes')

  setTimeout(TWDS.items.start, 2500)
})

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab
//

TWDS.questlist = {}

TWDS.questlist.employerclick = function (that, ev) {
  window.QuestEmployerWindow.showEmployer(that.dataset.key, that.dataset.x, that.dataset.y)
}
TWDS.questlist.questclick = function (that, ev) {
  window.QuestEmployerWindow.showEmployer(that.dataset.key, that.dataset.x, that.dataset.y, that.dataset.questid)
}
TWDS.questlist.questgroupclick = function (that, ev) {
  window.QuestGroupWindow.open(parseInt(that.dataset.groupid), null)
}
TWDS.questlist.openwindow2 = function (all) {
  const updateone = function (dl, giver, employer) {
    TWDS.createEle({
      nodeName: 'dt',
      className: 'TWDS_questlist_employerlink',
      textContent: employer.name,
      beforeend: dl,
      title: employer.description,
      dataset: {
        key: employer.key,
        x: employer.x,
        y: employer.y
      }
    })
    const o = []
    for (let i = 0; i < employer.open.length; i++) {
      o.push(employer.open[i])
    }
    o.sort(function (a, b) {
      const x = a.groupTitle.localeCompare(b.groupTitle)
      if (x) return x
      return a.soloTitle.localeCompare(b.soloTitle)
    })
    for (let i = 0; i < o.length; i++) {
      const q = o[i]
      let cl = ''
      if (q.accepted) cl += ' accepted'
      if (q.acceptable) cl += ' acceptable'
      if (q.finishable) cl += ' finishable'
      console.log('OPEN', employer, q, cl)
      TWDS.createEle({
        nodeName: 'dd',
        beforeend: dl,
        className: cl,
        children: [
          {
            nodeName: 'span',
            className: 'TWDS_questlist_questlink' + cl,
            textContent: q.title,
            dataset: {
              key: employer.key,
              x: employer.x,
              y: employer.y,
              questid: q.id
            }
          }, {
            nodeName: 'span',
            textContent: ' ('
          }, {
            nodeName: 'span',
            className: 'TWDS_questlist_questgrouplink',
            textContent: TWDS._('QUESTLIST_VIEW_QUESTGROUP', 'Ver grupo de búsquedas'),
            dataset: {
              key: employer.key,
              x: employer.x,
              y: employer.y,
              groupid: q.group,
              questid: q.id
            }
          }, {
            nodeName: 'span',
            textContent: ')'
          }
        ]
      })
    }
  }

  const updater = function (dl, all, idx) {
    const pw = TWDS.q1('.TWDS_questlist_please_wait')
    if (idx >= all.length) {
      if (pw) pw.remove()
      return
    }
    let giver = all[idx]
    while (!giver.visible) {
      idx++
      if (idx >= all.length) {
        if (pw) pw.remove()
        return
      }
      giver = all[idx]
    }
    Ajax.remoteCall('quest_employer', '', {
      employer: giver.key,
      x: giver.x,
      y: giver.y
    }, function (json) {
      if (json.error) return new UserMessage(json.error).show()
      if (json.employer.open.length) console.log('updateone', json)
      if (json.employer.open.length) updateone(dl, giver, json.employer)
      updater(content, all, idx + 1)
    })
  }

  const win = wman.open('TWDS_questlist_window', 'Lista dadores búsquedas', 'TWDS_questlist_window')
  win.setMiniTitle('Questgivers')

  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_questgivers_list'
  })
  TWDS.createEle('h2', { textContent: TWDS._('QUESTLIST_TITLE', 'Búsquedas por empleadores'), beforeend: content })
  TWDS.createEle('p', {
    className: 'TWDS_questlist_please_wait',
    textContent: TWDS._('QUESTLIST_PLEASE_WAIT', 'Por favor, espere'),
    beforeend: content
  })

  const dl = TWDS.createEle('dl', { beforeend: content })

  console.log('all1', all)
  all.sort(function (a, b) {
    if (a.x === undefined && b.x === undefined) {
      if (a.key === 'paper') return 1
      if (b.key === 'paper') return -1
      return a.name.localeCompare(b.name)
    }
    if (a.x === undefined) return -1
    if (b.x === undefined) return 1
    return a.name.localeCompare(b.name)
  })
  console.log('all2', all)
  updater(dl, all, 0)

  sp.appendContent(content)

  win.appendToContentPane(sp.getMainDiv())
}
TWDS.questlist.openwindow = function () {
  // minimap gives us quest locations
  Ajax.get('map', 'get_minimap', {}, function (json) {
    if (json.error) return new UserMessage(json.error).show()
    const qll = json.quest_locations
    const tiles = []
    for (const i in qll) {
      const ql = qll[i]
      if (!ql) continue
      if (!ql[0]) continue
      tiles.push([
        parseInt(ql[0][0] / Map.tileSize),
        parseInt(ql[0][1] / Map.tileSize)
      ])
    }
    Ajax.get('map', 'get_complete_data', {
      tiles: JSON.stringify(tiles)
    }, function (json) {
      if (json.error) return new UserMessage(json.error).show()
      const all = []

      const quests = json.quests
      for (const x in quests) {
        for (const y in quests[x]) {
          if ('employer' in quests[x][y][0][1]) {
            for (let i = 0; i < quests[x][y][0][1].employer.length; i++) {
              const e = quests[x][y][0][1].employer[i]
              const f = Object.assign({}, e)
              f.x = quests[x][y][0][1].x // real coords, not tiles
              f.y = quests[x][y][0][1].y
              all.push(f)
            }
          }
        }
      }

      Ajax.remoteCallMode('building_quest', '', {}, function (json) {
        if (json.error) return new UserMessage(json.error).show()
        for (let i = 0; i < json.questEmployer.length; i++) {
          const f = {
            key: json.questEmployer[i].key,
            name: json.questEmployer[i].name,
            visible: true,
            x: undefined,
            y: undefined,
            activate: null,
            deactivate: null
          }
          all.push(f)
          console.log('pushed', f, all.length)
        }
        TWDS.questlist.openwindow2(all)
      }, window.QuestWindow)
    })
  })
}

TWDS.registerStartFunc(function () {
  TWDS.registerExtra('TWDS.questlist.openwindow',
    TWDS._('EXTRAS_QUESTS_TEXT', 'Búsquedas por dadores'),
    TWDS._('EXTRAS_QUESTS_HELP', 'Muestra las búsquedas disponibles en los diversos dadores.')
  )

  // wait 2.5 seconds to avoid a thundering herd.
  // setTimeout(TWDS.collections.load, 2500)
  TWDS.delegate(document.body, 'click', '.TWDS_questlist_employerlink', function (ev) {
    TWDS.questlist.employerclick(this, ev)
  })
  TWDS.delegate(document.body, 'click', '.TWDS_questlist_questlink', function (ev) {
    TWDS.questlist.questclick(this, ev)
  })
  TWDS.delegate(document.body, 'click', '.TWDS_questlist_questgrouplink', function (ev) {
    TWDS.questlist.questgroupclick(this, ev)
  })
})
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.alliances = {}
TWDS.alliances.id2name = {}
TWDS.alliances.townid2allianceid = {}
TWDS.alliances.ready = false

TWDS.alliances.getdata = function () {
  Ajax.get('map', 'get_minimap', {}, function (json) {
    // console.log("MM",json);
    if (json.error) {
      return new UserMessage(json.msg).show()
    }
    const todo = []
    for (const t of Object.values(json.towns)) {
      if (t.member_count && !t.npctown) {
        const a = t.alliance_id || 0
        TWDS.alliances.townid2allianceid[t.town_id] = a
        if (a) {
          if (!TWDS.alliances.id2name[a]) {
            if (!todo.includes(a)) {
              todo.push(a)
            }
          }
        }
      }
    }
    let run = 0
    const doone = function (i) {
      if (i > todo.length) {
        TWDS.alliances.ready = true
        return
      }
      const id = todo[i]
      Ajax.remoteCallMode('alliance', 'get_data', {
        alliance_id: id
      }, function (r) {
        if (r.error === false && r.data && r.data.allianceName) {
          TWDS.alliances.id2name[id] = r.data.allianceName
        }
        let delay = 250
        run++
        if ((run % 20) === 0) {
          delay += 1500
        }
        setTimeout(doone, delay, i + 1)
      })
    }
    doone(0)
  })
}
TWDS.alliances.startfunc = function () {
  TWDS.alliances.getdata()
}

TWDS.registerStartFunc(TWDS.alliances.startfunc)

// vim: tabstop=2 shiftwidth=2 expandtab
// um Doppelzählungen zu vermeiden
TWDS.getLastKnownDuel = function getLastKnownDuel () {
  const tmp = window.localStorage.getItem('TWDS_lastknown')
  if (tmp === null) return {}
  return JSON.parse(tmp)
}

TWDS.clearDuels = function () {
  const toDelete = []
  for (let i = 0; i < window.localStorage.length; i++) {
    const k = window.localStorage.key(i)
    if (!k.match(/^TWDS_p_/)) {
      continue
    }
    toDelete.push(k)
  }
  for (let i = 0; i < toDelete.length; i++) {
    window.localStorage.removeItem(toDelete[i])
  }
  window.localStorage.removeItem('TWDS_lastknown')
}
// idea and algorithm takes from clothcalc. RIP.
TWDS.getServerPause = function () {
  if (!('last' in TWDS.getServerPause)) {
    TWDS.getServerPause.last = 0
    TWDS.getServerPause.shortCounter = 0
    TWDS.getServerPause.longCounter = 0
  }
  const now = new Date().getTime()
  if (now - TWDS.getServerPause.last < 2e3) {
    TWDS.getServerPause.shortCounter++
  } else {
    TWDS.getServerPause.shortCounter = 0
  }
  if (now - TWDS.getServerPause.last < 6e4) {
    TWDS.getServerPause.longCounter++
  } else {
    TWDS.getServerPause.longCounter = 0
  }
  TWDS.getServerPause.last = now
  let t = 0
  if (TWDS.getServerPause.longCounter > 50) {
    t = 6e4
  }
  if (TWDS.getServerPause.shortCounter < 20) {
    return t + 200
  }
  return t + 2e3
}
TWDS.readDuels = function () {
  const rxWinner = TWDS._('REGEX_DUEL_WON', '>([^>]+) ganó el duelo')
  const rxWages = TWDS._('REGEX_DUEL_WAGES', 'Dinero" .><.th><td>([^<]+)')
  const rxXP = TWDS._('REGEX_DUEL_XP', 'Puntos Experiencia" .><.th><td>([^<]+)')
  const rxDamage = TWDS._('REGEX_DUEL_DAMAGE', 'Daño" .><.th><td>([^<]+)')
  const rxMeHasAttacked = TWDS._('REGEX_DUEL_ME_HAS_ATTACKED', '^Duelo: $me$ vs. (.+)',
    { me: Character.name })
  const rxMeWasAttacked = TWDS._('REGEX_DUEL_ME_WAS_ATTACKED', '^Duelo: (.*) vs. $me$',
    { me: Character.name })
  const lastKnown = TWDS.getLastKnownDuel()
  const firstReadDuel = {}
  const handleOneLoad = function (pageno) {
    console.log('H1L', pageno)
    const info = document.getElementById('TWDS_peoplelist_import_info')
    info.textContent = ' (#' + pageno + ')'
    Ajax.remoteCall('reports', 'get_reports', {
      page: pageno,
      folder: 'duel'
    }, function (json) {
      console.log('H1L got', json, json.page < json.count)
      const found = parseIt(json.reports)
      console.log('found?', found)
      if ('hash' in firstReadDuel) {
        const tmp = JSON.stringify(firstReadDuel)
        window.localStorage.setItem('TWDS_lastknown', tmp)
      }
      let doDeleteInfo = 1
      if (!found) {
        if (json.page < json.count) {
          const pause = TWDS.getServerPause()
          console.log('pausing', pause, 'ms')
          if (pause > 1000) {
            info.textContent = ' (#' + pageno + ', ' + Math.round(pause / 1000) + 's)'
          }
          setTimeout(function () {
            handleOneLoad(json.page + 1)
          }, pause)
          doDeleteInfo = 0
        }
      }
      if (doDeleteInfo) {
        info.textContent = ''
        TWDS.activatePeopleTab()
      }
    }, MessagesWindow)
  }
  // this is a really bad localization, but i hope it's enough. Otherwise we need another translation...
  const mangleDate = function (d) {
    const rxToday = TWDS._('REGEX_DUELREPORT_TODAY', ':')
    d = d.replace(/\./g, '')
    if (!(d.match(rxToday))) return d
    return new Date().toLocaleDateString('de', { year: '2-digit', month: 'short', day: 'numeric' })
  }
  const getCmpDate = function (d) {
    const pad = function (number) {
      if (number < 10) {
        return '0' + number
      }
      return number
    }
    const dt = new Date(d)

    return dt.getFullYear() +
    '-' + pad(dt.getMonth() + 1) +
    '-' + pad(dt.getDate())
  }
  const handleDuel = function (report, ti) {
    const p = report.popupData
    let win = p.match(rxWinner)
    win = win[1]
    let lohn = p.match(rxWages)
    lohn = lohn[1]
    let xp = p.match(rxXP)
    xp = xp[1]
    let schaden = p.match(rxDamage)
    schaden = schaden[1].match(/([0-9]+) -- ([0-9]+)/)
    let sch1 = schaden[1]
    let sch2 = schaden[2]

    const me = Character.name
    let other = ti.match(rxMeHasAttacked)
    let iAmAttacker = 1
    if (!other) {
      other = ti.match(rxMeWasAttacked)
      iAmAttacker = 0
    }
    if (!other) return
    other = other[1]

    lohn = lohn.replace(/\./g, '')
    lohn = lohn.replace(/,/g, '')
    lohn = parseInt(lohn)
    sch1 = sch1.replace(/\./g, '')
    sch1 = parseInt(sch1)
    sch2 = sch2.replace(/\./g, '')
    sch2 = parseInt(sch2)
    xp = xp.replace(/\./g, '')
    xp = parseInt(xp)

    const key = 'TWDS_p_' + other
    let s = window.localStorage.getItem(key)
    if (!s) {
      s = {
        win_me: 0,
        win_other: 0,
        dollars_won_me: 0,
        dollars_won_other: 0,
        dmg_done_me: 0,
        dmg_done_other: 0,
        xp_got_me: 0,
        xp_got_other: 0,
        me_has_attacked: 0,
        me_won_attacking: 0,
        me_won_defending: 0,
        list: []
      }
    } else {
      s = JSON.parse(s)
    }
    if (!('list' in s)) {
      s.list = []
    }
    // we have a sorted list after the first import:
    // push:     [12. Jan, 11. Jan, 10. Jan, 10. Jan]
    // unshift:  [10, 10, 11, 12]
    // because we appended older duels to the list during the import.
    // Now we read new ones: 15, 14, 13
    // push:     [12, 11, 10, 10, 15, 14, 13]
    // unshift:  [13, 14, 15, 12, 11, 10, 10]
    // clearly both simple solutions might be disputed.

    // we could read und store everything in memory, then process the entries in reverse order.
    // i just hate it. i want to get rid of the data ASAP, and not wait for 500 pages of duels.

    // so we "simply" store another date, in numerical representation, and sort the fucking duel
    // list during presentation.

    const dueldate = mangleDate(report.date_received)
    const cmpdate = getCmpDate(dueldate)
    const one = {
      date: dueldate,
      cmpdate: cmpdate,
      report_id: report.report_id,
      hash: report.hash,
      iAmAttacker: iAmAttacker,
      iAmWinner: me === win,
      DollarsIWon: (me === win ? lohn : 0),
      DollarsOpponentWon: (me === win ? 0 : lohn),
      iMadeDamage: (iAmAttacker ? sch2 : sch1),
      OppMadeDamage: (iAmAttacker ? sch1 : sch2),
      iGotXP: (me === win ? xp : 0),
      OppGotXP: (me === win ? 0 : xp)
    }
    s.list.push(one)

    if (win === me) {
      s.win_me++
      s.dollars_won_me += lohn
      s.xp_got_me += xp
    } else {
      s.win_other++
      s.dollars_won_other += lohn
      s.xp_got_other += xp
    }
    if (iAmAttacker) {
      s.dmg_done_me += sch2
      s.dmg_done_other += sch1
      s.me_has_attacked += 1
      if (win === me) {
        s.me_won_attacking += 1
      }
    } else {
      s.dmg_done_me += sch1
      s.dmg_done_other += sch2
      if (win === me) {
        s.me_won_defending += 1
      }
    }
    s = JSON.stringify(s)
    window.localStorage.setItem(key, s)
    console.log('Jout', key, s)
  }
  const parseIt = function (reps) {
    const rx = /^Duel/
    console.log('parseIt', reps)
    for (const r of Object.values(reps)) {
      const ti = r.title
      if (lastKnown.report_id === r.report_id || lastKnown.hash === r.hash) {
        console.log('id', r.report_id, 'or hash', r.hash, 'known')
        return true
      }
      console.log('parseIt1', ti, r)
      if (rx.exec(ti)) {
        console.log('may be duell', ti, r)
        handleDuel(r, ti)
        if (!('hash' in firstReadDuel)) {
          firstReadDuel.hash = r.hash
          firstReadDuel.report_id = r.report_id
        }
      }
    }
    return false
  }
  handleOneLoad(1)
}
window.dust = TWDS.readDuels
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.people = {}
TWDS.people.getmon = function (str) {
  switch (str) {
    case 'Jan':
    case 'Jan.':
      return 0
    case 'Feb':
    case 'Feb.':
      return 1
    case 'Mar':
    case 'Mar.':
    case 'Mär':
    case 'Mär.':
    case 'März':
      return 2
    case 'Apr':
    case 'Apr.':
      return 3
    case 'May':
    case 'May.':
    case 'Mai':
    case 'Mai.':
      return 4
    case 'Jun':
    case 'Jun.':
      return 5
    case 'Jul':
    case 'Jul.':
      return 6
    case 'Aug':
    case 'Aug.':
      return 7
    case 'Sep':
    case 'Sep.':
      return 8
    case 'Oct':
    case 'Oct.':
    case 'Okt':
    case 'Okt.':
      return 9
    case 'Nov':
    case 'Nov.':
      return 10
    case 'Dec':
    case 'Dec.':
    case 'Dez':
    case 'Dez.':
      return 11
  }
  return -1
}
TWDS.people.getbyname = function (name) {
  const getCmpDate = function (d) {
    const pad = function (number) {
      if (number < 10) {
        return '0' + number
      }
      return number
    }
    const dt = new Date(d)

    return dt.getFullYear() +
  '-' + pad(dt.getMonth() + 1) +
  '-' + pad(dt.getDate())
  }
  const key = 'TWDS_p_' + name
  let histdata = window.localStorage.getItem(key)

  if (!histdata) return false
  try {
    histdata = JSON.parse(histdata)
  } catch (e) {
    TWDS.error('people.getbyname', 'no se pudieron analizar los datos para', name)
    return false
  }
  let fixed = false
  for (let i = 0; i < histdata.list.length; i++) {
    const d = histdata.list[i]
    // we need to fix that somewhere, why not directly here?
    if (d.cmpdate.includes('NaN')) {
      // i really screwed up here.
      // 9 Dez 22
      // 16. Dez. 22
      // 19 Mär 23 (even on the int servers)
      // 061223
      // 28042023
      const s = d.date
      let ts = null
      if (s.length === 6) {
        ts = new Date('20' + s.substr(4, 2),
          parseInt(s.substr(2, 2)) - 1,
          parseInt(s.substr(0, 2)))
      }
      if (s.length === 8) {
        ts = new Date(s.substr(4, 4),
          parseInt(s.substr(2, 2)) - 1,
          parseInt(s.substr(0, 2)))
      }
      if (!ts) {
        let t = s.match(/^([0-9]+)\.?\s+(\S+)\s+(\d+)$/)
        if (!t) {
          t = s.match(/^ ([0-9])\.?\s+(\S+)\s+(\d+)$/)
        }
        if (t) {
          const mon = TWDS.people.getmon(t[2])
          if (mon === -1) {
            console.log('bad mon', t[2])
          } else {
            ts = new Date('20' + t[3],
              mon,
              t[1])
            // console.log("FIX",s,t,t[3],mon,t[1],"=>",ts);
          }
        } else {
          console.log('t bad', t)
        }
      }

      if (ts) {
        d.cmpdate = getCmpDate(ts)
      }
    }
    if (d.cmpdate.includes('NaN')) {
      console.log('unfixed cmpdate', name, d)
    } else {
      fixed = true
    }
  }
  if (fixed) {
    // console.log("FIXED",name,histdata);
  }
  return histdata
}

TWDS.peopleSort = function (tab, key) {
  if (tab == null) { // for ease of debugging
    tab = document.querySelector('#TWDS_people')
  }
  const tbody = tab.querySelector('tbody')
  const rowColl = tab.querySelectorAll('tbody .datarow')
  const rows = []
  for (let i = 0; i < rowColl.length; i++) {
    const row = rowColl[i]
    const td = row.querySelector('[data-field=' + key + ']')
    if (key === 'name') {
      row.sortval = td.textContent
    } else {
      row.sortval = parseFloat(td.textContent)
    }
    rows.push(row)
  }

  rows.sort(function (a, b) {
    if (key === 'name') {
      return a.sortval.localeCompare(b.sortval)
    } else {
      return b.sortval - a.sortval
    }
  })

  tbody.textContent = ''
  for (let i = 0; i < rows.length; i++) {
    tbody.appendChild(rows[i])
  }
}

TWDS.initPeopleList = function (tab) {
  const appOneHead = function (tr, ti, dn, cs = 0, mouseover = '') {
    const td = document.createElement('th')
    td.textContent = ti
    td.dataset.field = dn
    tr.appendChild(td)
    if (cs) {
      td.colspan = cs.toString()
      td.setAttribute('colspan', cs.toString())
    }
    if (mouseover > '') { td.title = mouseover }
  }
  const appOneBody = function (tr, ti, dn, mouseover = '') {
    const td = document.createElement('td')
    td.textContent = ti
    td.dataset.field = dn
    tr.appendChild(td)
    if (mouseover > '') { td.title = mouseover }
  }
  tab.innerHTML = ''
  const thead = document.createElement('thead')
  tab.appendChild(thead)

  const tr0 = document.createElement('tr')
  const tr1 = document.createElement('tr')
  tr1.className = 'sortTriggerRow'
  thead.appendChild(tr0)
  thead.appendChild(tr1)
  appOneHead(tr0, '', '')
  appOneHead(tr1, TWDS._('PEOPLETAB_MENU_OPPONENT', 'Oponente'), 'name', 0,
    TWDS._('PEOPLETAB_MENU_OPPONENT_MOUSEOVER', 'El nombre del oponente.'))
  appOneHead(tr0, TWDS._('PEOPLETAB_MENU_DUELS', 'Duelos'), '', 4)
  appOneHead(tr1, TWDS._('PEOPLETAB_MENU_TOTAL', 'Total'), 'num', 0,
    TWDS._('PEOPLETAB_MENU_TOTAL_MOUSEOVER', 'El número total de duelos.'))
  appOneHead(tr1, TWDS._('PEOPLETAB_MENU_VICTORIES', 'Victorias'), 'won', 0,
    TWDS._('PEOPLETAB_MENU_VICTORIES_MOUSEOVER', 'El número de duelos ganados.'))
  appOneHead(tr1, TWDS._('PEOPLETAB_MENU_LOSSES', 'Derrotas'), 'lost', 0,
    TWDS._('PEOPLETAB_MENU_LOSSES_MOUSEOVER', 'El número de duelos perdidos.'))
  appOneHead(tr1, TWDS._('PEOPLETAB_MENU_PLUSMINUS', '+-'), 'plusminus', 0,
    TWDS._('PEOPLETAB_MENU_PLUSMINUS_MOUSEOVER', 'La diferencia entre victorias/derrotas.'))
  appOneHead(tr0, TWDS._('PEOPLETAB_MENU_DOLLAR', 'Dinero'), '')
  appOneHead(tr1, TWDS._('PEOPLETAB_MENU_DOLLARSUM', 'Suma'), 'dollar', 0,
    TWDS._('PEOPLETAB_MENU_DOLLARSUM_MOUSEOVER', 'La suma de los dólares ganados por tí menos la suma de los dólares ganados por el oponente. Esto no tiene en cuenta la pérdida adicional por KO.'))
  appOneHead(tr0, TWDS._('PEOPLETAB_MENU_DMG_DONE', 'Daño hecho'), '', 3)
  appOneHead(tr1, TWDS._('PEOPLETAB_MENU_DMG_BY_ME', 'Yo'), 'dmg_done_me', 0,
    TWDS._('PEOPLETAB_MENU_DMG_BY_ME_MOUSEOVER', 'El daño hecho por tí.'))
  appOneHead(tr1, TWDS._('PEOPLETAB_MENU_DMG_BY_OTHER', 'Oponente'), 'dmg_done_other', 0,
    TWDS._('PEOPLETAB_MENU_DMG_BY_OTHER_MOUSEOVER', 'El daño que te ha hecho (tu oponente).'))
  appOneHead(tr1, TWDS._('PEOPLETAB_MENU_DMG_DIFF', 'Dif.'), 'dmg_done_diff', 0,
    TWDS._('PEOPLETAB_MENU_DMG_DIFF_MOUSEOVER', 'La diferencia de daño hecho y recibido.'))
  appOneHead(tr0, TWDS._('PEOPLETAB_MENU_XP', 'EXP'), '', 2)
  appOneHead(tr1, TWDS._('PEOPLETAB_MENU_XP_ME', 'Yo'), 'xp_got_me', 0,
    TWDS._('PEOPLETAB_MENU_XP_ME_MOUSEOVER', 'La experiencia obtenida por tí.'))
  appOneHead(tr1, TWDS._('PEOPLETAB_MENU_XP_OTHER', 'Oponente'), 'xp_got_other', 0,
    TWDS._('PEOPLETAB_MENU_XP_OTHER_MOUSEOVER', 'La experiencia obtenida por tu oponente.'))
  const tbody = document.createElement('tbody')
  tab.appendChild(tbody)
  for (let i = 0; i < window.localStorage.length; i++) {
    const k = window.localStorage.key(i)

    let other = k.match(/^TWDS_p_(.*)/)
    if (!other) {
      continue
    }
    other = other[1]
    const o = TWDS.people.getbyname(other)
    if (!o) continue // cant happen

    const tr = document.createElement('tr')
    tr.classList.add('datarow')
    const th = document.createElement('th')
    th.dataset.field = 'name'
    th.textContent = other
    tr.appendChild(th)

    appOneBody(tr, o.win_me + o.win_other, 'num',
      TWDS._('PEOPLETAB_NUM_INFO', '$num$ ataques míos', { num: o.me_has_attacked }))
    appOneBody(tr, o.win_me, 'won',
      TWDS._('PEOPLETAB_NUM_ATTACKS_WON', '$num$ ataques ganados', { num: o.me_won_attacking }))
    appOneBody(tr, o.win_other, 'lost',
      TWDS._('PEOPLETAB_NUM_DEFENCES_WON', '$num$ defensas ganadas', { num: o.me_won_defending }))
    appOneBody(tr, o.win_me - o.win_other, 'plusminus')

    appOneBody(tr, o.dollars_won_me - o.dollars_won_other, 'dinero',
      TWDS._('PEOPLETAB_DOLLARS_INFO', '$$dollars_me$ ganados por mí<br>$$dollars_other$ ganados por $opponent$', {
        dollars_me: o.dollars_won_me,
        dollars_other: o.dollars_won_other,
        opponent: other
      }))

    appOneBody(tr, o.dmg_done_me, 'dmg_done_me')
    appOneBody(tr, o.dmg_done_other, 'dmg_done_other')
    appOneBody(tr, o.dmg_done_me - o.dmg_done_other, 'dmg_done_diff',
      TWDS._('PEOPLETAB_DAMAGE_INFO', '$dmg_done_me$ daño hecho por mí<br>$dmg_done_other$ daño hecho por $opponent$', {
        dmg_done_me: o.dmg_done_me,
        dmg_done_other: o.dmg_done_other,
        opponent: other
      }))

    appOneBody(tr, o.xp_got_me, 'xp_got_me')
    appOneBody(tr, o.xp_got_other, 'xp_got_other')

    tbody.appendChild(tr)
  }
  TWDS.peopleSort(tab, 'num')
}

TWDS.getPeopleContent = function () {
  const tab = document.createElement('table')
  tab.id = 'TWDS_people'
  TWDS.initPeopleList(tab)

  const div = document.createElement('div')
  const p = document.createElement('p')
  p.id = 'TWDS_people_info'
  div.appendChild(p)
  const div2 = document.createElement('div')
  div.appendChild(div2)
  div2.id = 'TWDS_peoplelist_functions'

  let b = document.createElement('button')
  b.id = 'TWDS_peoplelist_delete'
  b.textContent = TWDS._('PEOPLETAB_DELETE_DATA', 'Eliminar datos')
  div2.appendChild(b)

  b = document.createElement('button')
  b.id = 'TWDS_peoplelist_import'
  b.textContent = TWDS._('PEOPLETAB_IMPORT', 'Importar nuevos duelos')
  const sp = document.createElement('span')
  sp.id = 'TWDS_peoplelist_import_info'
  b.appendChild(sp)
  div2.appendChild(b)

  div.appendChild(tab)
  return div
}
TWDS.appendSubtable = function (container, dd, other) {
  const tab = document.createElement('table')
  container.appendChild(tab)

  const tr = document.createElement('tr')
  tab.appendChild(tr)

  let th = document.createElement('th')
  tr.appendChild(th)
  th.textContent = TWDS._('PEOPLE_SUB_DATE', 'Fecha')

  th = document.createElement('th')
  tr.appendChild(th)
  th.textContent = TWDS._('PEOPLE_SUB_ATTACKER', 'Atacante')

  th = document.createElement('th')
  tr.appendChild(th)
  th.textContent = TWDS._('PEOPLE_SUB_VICTOR', 'Ganador')

  th = document.createElement('th')
  tr.appendChild(th)
  th.textContent = TWDS._('PEOPLE_SUB_DOLLAR', '$ ganados')

  th = document.createElement('th')
  tr.appendChild(th)
  th.textContent = TWDS._('PEOPLE_SUB_DMG_ATTACKER_MADE', 'Daño por at.')
  th.title = TWDS._('PEOPLE_SUB_DMG_ATTACKER_MADE_MOUSEOVER', 'El daño hecho por el atacante')

  th = document.createElement('th')
  tr.appendChild(th)
  th.textContent = TWDS._('PEOPLE_SUB_DMG_DEFENDER_MADE', 'Daño por def.')
  th.title = TWDS._('PEOPLE_SUB_DMG_DEFENDER_MADE_MOUSEOVER', 'El daño hecho por el defensor')

  th = document.createElement('th')
  tr.appendChild(th)
  th.textContent = TWDS._('PEOPLE_SUB_XP', 'EXP ganada')

  // console.log("unsorted",JSON.stringify(dd.list))
  dd.list.sort(function (a, b) {
    return b.cmpdate.localeCompare(a.cmpdate)
  })
  // console.log("sorted",dd);

  for (let i = 0; i < dd.list.length; i++) {
    const d = dd.list[i]

    const tr = document.createElement('tr')
    tab.appendChild(tr)

    let td = document.createElement('td')
    tr.appendChild(td)
    td.textContent = d.date
    td.dataset.cmpdate = d.cmpdate
    td.className = 'openreport'
    td.dataset.hash = d.hash
    td.dataset.report_id = d.report_id

    td = document.createElement('td')
    td.className = 'attacker'
    tr.appendChild(td)
    if (d.iAmAttacker) td.textContent = Character.name
    else td.textContent = other

    td = document.createElement('td')
    td.className = 'winner'
    tr.appendChild(td)
    if (d.iAmWinner) td.textContent = Character.name
    else td.textContent = other

    td = document.createElement('td')
    tr.appendChild(td)
    if (d.iAmWinner) td.textContent = d.DollarsIWon
    else td.textContent = d.DollarsOpponentWon

    td = document.createElement('td')
    tr.appendChild(td)
    td.textContent = d.iMadeDamage

    td = document.createElement('td')
    tr.appendChild(td)
    td.textContent = d.OppMadeDamage

    td = document.createElement('td')
    tr.appendChild(td)
    td.textContent = d.iGotXP ? d.iGotXP : d.OppGotXP
  }
}
TWDS.activatePeopleTab = function () {
  TWDS.activateTab('people')
}

TWDS.registerStartFunc(function () {
  TWDS.registerTab('people',
    TWDS._('TABNAME_PEOPLE', 'Personas'),
    TWDS.getPeopleContent,
    TWDS.activatePeopleTab,
    true)
  $(document).on('click', '#TWDS_peoplelist_delete', function () {
    if (window.confirm(TWDS._('PROMPT_DELETE_DUEL_DATA', '¿De verdad, quiere borrar los datos de duelos?'))) {
      console.log('yes, delete')
      TWDS.clearDuels()
      document.getElementById('TWDS_people').innerHTML = ''
    }
  })
  $(document).on('click', '#TWDS_peoplelist_import', function () {
    document.getElementById('TWDS_people_info')
      .textContent = TWDS._('PEOPLE_WAITINFO', 'Esto se ejecuta en segundo plano y lleva algún tiempo. Espere por favor.')
    TWDS.readDuels()
    TWDS.activatePeopleTab()
  })
  $(document).on('click', '#TWDS_people thead tr.sortTriggerRow th', function () {
    const key = this.dataset.field
    if (typeof key !== 'undefined') {
      TWDS.peopleSort(null, key)
    }
  })
  $(document).on('click', '#TWDS_people_subtab .openreport', function () {
    const hash = this.dataset.hash
    const id = this.dataset.report_id
    ReportWindow.open(id, hash, 0)
  })
  $(document).on('click', '#TWDS_people .datarow [data-field="name"]', function () {
    // this is the th.name
    const d = TWDS.people.getbyname(this.textContent)
    if (!d) return
    const dr = this.closest('.datarow')
    const id = 'TWDS_people_subtab'
    const ele = document.getElementById(id)
    if (ele) ele.parentNode.removeChild(ele)
    const tr = document.createElement('tr')
    tr.id = id
    const td = document.createElement('td')
    td.setAttribute('colspan', 11)
    tr.appendChild(td)
    dr.insertAdjacentElement('afterend', tr)
    TWDS.appendSubtable(td, d, this.textContent)
  })
})
// vim: tabstop=2 shiftwidth=2 expandtab

TWDS.jobdebug = 0
TWDS.joblist = {}
TWDS.joblist.calcBruttoJobPoints = function (jobId, items) {
  const job = JobList.getJobById(jobId)
  const bo = TWDS.getComboBonus(items)
  let jp = 0
  for (const [skillName, mult] of Object.entries(job.skills)) {
    const sk = CharacterSkills.getSkill(skillName)
    let v = 0
    if (skillName in bo) {
      v += bo[skillName][0]
      if (TWDS.jobdebug) console.log(skillName, 'wear bonus', bo[skillName][0], '=>', v)
    }
    v += sk.points
    if (TWDS.jobdebug) console.log(skillName, 'char skill', sk.points, '=>', v)
    if (sk.attr_key in bo) {
      v += bo[sk.attr_key][0]
      if (TWDS.jobdebug) console.log(skillName, 'char attr', bo[sk.attr_key][0], '=>', v)
    }
    v *= mult
    jp += v
    if (TWDS.jobdebug) console.log('after', skillName, 'mult', mult, 'v', v, 'jp', jp)
  }
  if ('job_all' in bo) {
    jp += bo.job_all[0]
    if (TWDS.jobdebug) console.log('after', 'job_all', '=', bo.job_all[0], 'jp', jp)
  }
  const t = 'job_' + jobId
  if (t in bo) {
    jp += bo[t][0]
    if (TWDS.jobdebug) console.log('after', t, '=', bo[t][0], 'jp', jp)
  }
  return jp
}
TWDS.joblist.calcNettoJobPoints = function (jobId, items) {
  const job = JobList.getJobById(jobId)
  const jp = TWDS.joblist.calcBruttoJobPoints(jobId, items)
  return jp - job.malus - 1
}

// the functions with TWDB in their name have been taken from tw-db.info (web site, not cloth calc)
// RIP, tw-db. You are missed.
TWDS.TWDBcalcStepFormula = function (r1, r2, formula, points, malus, magic, mot, factor, freezeBronze) {
  /* by steps until silver, then formula
  *  r1, r2 - what type of rounding is used on the calculated value
  *  formula - function(lp, stars) for calcing silver and gold (5 <= stars <= 15)
  *  pts - skill points towards job
  *  malus - difficulty-1
  *  mot - motivation in [0 - 100], if NOT affected by motivation, put 100
  *  factor - other stuff to multiply by before rounding
  *  freezeBronze - if set, bronze is constant magic */
  const step = Math.ceil((malus + 1) / 5); const stars = Math.min(Math.floor(points / step), 15); const dmot = Math.ceil(mot / 25) * 0.25
  return points < 5 * step || points <= malus
    ? Math[r1](({ 0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6.25 })[freezeBronze ? 0 : stars] * magic * dmot * factor)
    : Math[r2](formula(points - malus, stars) * magic * dmot * factor)
}
TWDS.TWDBcalcWage = function (pts, mal, magic, mot, fac) {
  return TWDS.TWDBcalcStepFormula('ceil', 'round', function (lp) { return 6.25 * Math.pow(lp, 0.05) }, pts, mal, magic, mot, fac)
}
TWDS.TWDBcalcExp = function (pts, mal, magic, mot, fac) {
  return TWDS.TWDBcalcStepFormula('ceil', 'ceil', function (lp) { return 6.25 }, pts, mal, magic, mot, fac)
}
TWDS.TWDBcalcLuck = function (pts, mal, magic, mot, fac) {
  return TWDS.TWDBcalcStepFormula('floor', 'floor',
    function (lp) { return 6.25 * Math.pow(lp, 0.2) },
    pts, mal, (0.9 * magic + 5) / 1.25, 100, fac)
}
TWDS.TWDBcalcExp = function (pts, mal, magic, mot, fac) {
  return TWDS.TWDBcalcStepFormula('ceil', 'ceil', function (lp) { return 6.25 }, pts, mal, magic, mot, fac)
}
TWDS.TWDBcalcDanger = function (pts, mal, magic, mot, fac) {
  return TWDS.TWDBcalcStepFormula('round', 'round', function (lp) { return Math.pow(lp, -0.2) }, pts, mal, magic, 100, fac, true)
}
TWDS.TWDBcalcProductRate = function (pts, mal, magic, mot, fac) {
  return TWDS.TWDBcalcStepFormula('round', 'round', function (lp, stars) { return stars < 15 ? 6.25 : 9.375 }, pts, mal, magic, 100, fac)
}
TWDS.joblist.initDisplay = function (container, serverdata, isupdate) {
  const charPremium = Number(Premium.hasBonus('character'))
  const moneyPremium = Number(Premium.hasBonus('money'))
  const duration = TWDS.joblist.curJobDuration
  let durationIdx = 0
  if (duration === 600) durationIdx = 1
  if (duration === 3600) durationIdx = 2
  const _ = TWDS._

  const eqmode = TWDS.settings.joblist_modeselect

  TWDS.minimap.loadcache()
  const silvers = {}
  const golds = {}
  for (const poskey in TWDS.minimap.cache) {
    for (const j in TWDS.minimap.cache[poskey]) {
      if (TWDS.minimap.cache[poskey][j].silver) {
        silvers[j] = true
      }
      if (TWDS.minimap.cache[poskey][j].gold) {
        golds[j] = true
      }
    }
  }

  const row = function (tab, jobId, best) {
    const jobdata = JobList.getJobById(jobId)

    let tr
    if (isupdate) {
      tr = TWDS.q1('tr.job' + jobId, tab)
      tr.textContent = ''
    } else {
      tr = document.createElement('tr')
      tr.classList.add('job' + jobId)
      tab.appendChild(tr)
    }
    tr.classList.remove('gold')
    tr.classList.remove('silver')
    if (jobId in golds) {
      tr.classList.add('gold')
    }
    if (jobId in silvers) {
      tr.classList.add('silver')
    }
    tr.dataset.jobid = jobId
    let td
    let bestNetto
    let bestBrutto
    const difficulty = jobdata.malus
    const mot = serverdata.jobs[jobId].motivation * 100
    let curNetto = serverdata.jobs[jobId].workpoints - 1
    let curBrutto = serverdata.jobs[jobId].jobSkillPoints

    if (best !== null) {
      bestNetto = TWDS.joblist.calcNettoJobPoints(jobId, best.items)
      bestBrutto = bestNetto + jobdata.malus + 1
      if (eqmode === 'best') {
        curNetto = bestNetto
        curBrutto = bestBrutto
      }
    }

    let jc = new JobCalculator(curBrutto, jobdata.malus + 1)
    jc.calcStars((curBrutto / (jobdata.malus + 1)))
    const curStars = jc.getJobstarsValue()

    jc = new JobCalculator(bestBrutto, jobdata.malus + 1)
    jc.calcStars((bestBrutto / (jobdata.malus + 1)))
    const bestStars = jc.getJobstarsValue()

    td = document.createElement('td')
    tr.appendChild(td)
    td.textContent = jobId
    td.dataset.field = 'no'

    td = document.createElement('td')
    td.dataset.field = 'date'
    tr.appendChild(td)
    if (best !== null) {
      const dt = new Date(best.timestamp)
      if (dt.toLocaleDateString() === new Date().toLocaleDateString()) {
        let lc = Game.locale.replace('_', '-')
        if (lc === 'en-DK') lc = 'en-GB' // en-dk: 16.52.04, en-GB: 16:52:04
        td.textContent = dt.toLocaleTimeString(lc)
      } else {
        td.textContent = dt.toLocaleDateString(Game.locale.replace('_', '-'))
      }
    }

    td = document.createElement('td')
    tr.appendChild(td)
    td.textContent = jobdata.name
    if (best !== null) { td.title = TWDS.describeItemCombo(best.items) }
    td.dataset.field = 'name'

    td = document.createElement('td')
    tr.appendChild(td)
    td.dataset.field = 'lp'
    td.textContent = curNetto
    if (best !== null && curNetto !== bestNetto) {
      td.title = bestNetto + ' ' + _('JOBLIST_IN_BEST_CLOTHES', '(in best clothes)')
    }
    if (curNetto < 0) {
      td.classList.add('TWDS_job_negative')
    } else if (best !== null && curStars !== bestStars) {
      td.classList.add('TWDS_job_less')
    }

    td = document.createElement('td')
    tr.appendChild(td)
    td.textContent = curStars
    td.dataset.field = 'stars'
    td.dataset.sortval = curStars
    if (best !== null && bestStars !== curStars) {
      td.title = bestStars + '* ' + _('JOBLIST_IN_BEST_CLOTHES', '(in best clothes)')
    }
    if (curStars < 6) {
      td.classList.add('TWDS_job_negative')
    } else if (best !== null && curStars !== bestStars) {
      td.classList.add('TWDS_job_less')
    }

    td = document.createElement('td')
    tr.appendChild(td)
    td.dataset.field = 'xp'
    if (eqmode === 'best') {
      let xp3600 = TWDS.TWDBcalcExp(curBrutto, difficulty, TWDS.jobData['job_' + jobId].job_exp, mot, 1)
      const xp600 = Math.ceil(xp3600 * 0.47)
      const xp15 = Math.ceil(xp3600 / 10)
      if (Character.charClass === 'worker') {
        if (charPremium) { xp3600 *= 1.1 } else { xp3600 *= 1.05 }
      }
      td.textContent = Math.round(duration === 3600 ? xp3600 : (duration === 15 ? xp15 : xp600))
      td.title = '$' + xp15 + '/' + xp600 + '/' + xp3600 +
          ' ' + _('JOBLIST_15101', ' (15s/10m/1h)')
    } else if (eqmode === 'current') {
      td.textContent = serverdata.jobs[jobId].durations[durationIdx].xp
      td.title = serverdata.jobs[jobId].durations[0].xp + '/' +
        serverdata.jobs[jobId].durations[1].xp + '/' +
        serverdata.jobs[jobId].durations[2].xp +
          ' ' + _('JOBLIST_XP', 'experience points') +
          ' ' + _('JOBLIST_15101', ' (15s/10m/1h)')
    } else {
      td.textContent = TWDS.jobData['job_' + jobId].job_exp.toFixed(1)
    }

    td = document.createElement('td')
    tr.appendChild(td)
    td.dataset.field = 'money'
    if (eqmode === 'best') {
      let wage3600 = TWDS.TWDBcalcWage(curBrutto, difficulty, TWDS.jobData['job_' + jobId].job_wages, mot, 1)
      if (moneyPremium) wage3600 *= 1.5
      const wage15 = Math.ceil(wage3600 / 10)
      const wage600 = Math.ceil(wage3600 * 0.471) // Uh. magic constant.
      td.textContent = Math.round(duration === 3600 ? wage3600 : (duration === 15 ? wage15 : wage600))
      td.title = '$' + wage15 + '/' + wage600 + '/' + wage3600 +
          ' ' + _('JOBLIST_15101', ' (15s/10m/1h)')
    } else if (eqmode === 'current') {
      td.textContent = serverdata.jobs[jobId].durations[durationIdx].money
      td.title = '$' + serverdata.jobs[jobId].durations[0].money + '/' +
        serverdata.jobs[jobId].durations[1].money + '/' +
        serverdata.jobs[jobId].durations[2].money +
          ' ' + _('JOBLIST_15101', ' (15s/10m/1h)')
    } else {
      td.textContent = TWDS.jobData['job_' + jobId].job_wages.toFixed(1)
    }

    td = document.createElement('td')
    tr.appendChild(td)
    td.dataset.field = 'luck'
    let lucktoshow
    let lucktitle
    if (eqmode === 'best') {
      let luck1 = TWDS.TWDBcalcLuck(curBrutto, difficulty, TWDS.jobData['job_' + jobId].job_luck, mot, 1)
      if (charPremium) luck1 *= 1.5
      const luck2 = Math.round(luck1 * 3)
      lucktoshow = luck2
      lucktitle = Math.round(luck1) + ' - ' + luck2
    } else if (eqmode === 'current') {
      const luck1 = serverdata.jobs[jobId].minMaxItemVal[0]
      const luck2 = serverdata.jobs[jobId].minMaxItemVal[1]
      lucktoshow = luck2
      lucktitle = luck1 + ' - ' + luck2
    } else { // raw mode
      lucktitle = TWDS.jobData['job_' + jobId].job_luck
      lucktoshow = lucktitle.toFixed(1)
    }
    td.textContent = lucktoshow
    td.title = lucktitle
    if (eqmode !== 'raw') {
      if (best !== null && curBrutto !== bestBrutto && eqmode !== 'raw') {
        let luck3 = TWDS.TWDBcalcLuck(bestBrutto, difficulty, TWDS.jobData['job_' + jobId].job_luck, mot, 1)
        if (charPremium) luck3 *= 1.5
        td.title += '<br>' + Math.round(luck3) + ' -' + Math.round(luck3 * 3) +
          +' ' + _('JOBLIST_IN_BEST_CLOTHES', '(in best clothes)')
      }
      td.title += '<br>' + serverdata.jobs[jobId].durations[0].luck + '/' +
        serverdata.jobs[jobId].durations[1].luck + '/' +
        serverdata.jobs[jobId].durations[2].luck +
          '' + _('JOBLIST_LUCK_MOD', ' luck modification in 15s/10m/1h')
    }

    td = document.createElement('td')
    tr.appendChild(td)
    td.textContent = Math.round(100 * serverdata.jobs[jobId].motivation)
    td.dataset.field = 'motivation'

    td = document.createElement('td')
    tr.appendChild(td)
    td.dataset.field = 'danger'
    let dang
    if (eqmode === 'raw') {
      td.textContent = TWDS.jobData['job_' + jobId].job_danger.toFixed(0)
      const maxInj = TWDS.jobData['job_' + jobId].job_maxdmg
      td.title = TWDS.jobData['job_' + jobId].job_danger.toFixed(0) + '% probabilidad de lesión ' +
        'costing up to ' + maxInj + '% of the then current max health'
    } else {
      dang = TWDS.TWDBcalcDanger(curBrutto, difficulty, TWDS.jobData['job_' + jobId].job_danger, mot, 1)
      if (Character.charClass === 'adventurer') {
        if (charPremium) dang *= 0.8
        else dang *= 0.9
      }
      td.textContent = Math.round(dang * 10) / 10
      td.title = dang + '% ' + _('JOBLIST_INJURY_CHANCE', 'probabilidad de lesión')
      if (best !== null) {
        let dang2 = TWDS.TWDBcalcDanger(bestBrutto, difficulty, TWDS.jobData['job_' + jobId].job_danger, mot, 1)
        if (Character.charClass === 'adventurer') {
          if (charPremium) dang2 *= 0.8
          else dang2 *= 0.9
        }
        dang2 = Math.round(dang2 * 10) / 10
        td.title += '<br>' + dang2 + '% ' + _('JOBLIST_INJURY_CHANCE_IBC', 'probabilidad de lesión con las mejores ropas')
      }
      const mh = Character.getMaxHealth()
      const maxInj = Math.round((TWDS.jobData['job_' + jobId].job_maxdmg) / 100 * mh)
      const h = Character.health
      td.title += '<br>'
      td.title += _('JOBLIST_INJURY_COST',
        'Una lesión cuesta $maxhp$ puntos salud ($percent$% de la máxima salud).',
        { maxhp: maxInj, percent: TWDS.jobData['job_' + jobId].job_maxdmg })
      // td.title += _("JOBLIST_INJURY_COST",'An injury costs up to ' + maxInj + ' health points (' + TWDS.jobData['job_' + jobId].job_maxdmg + '% of max. health).'

      const worstJobs = parseInt((h + 1) / maxInj)
      td.title += '<br>' + _('JOBLIST_MIGHT_LAST', 'Podría durar $worst$ trabajos en el peor caso.',
        { worst: worstJobs })
    }

    td = document.createElement('td')
    tr.appendChild(td)
    td.dataset.field = 'dangercombined'
    if (eqmode === 'raw') {
      td.textContent = TWDS.jobData['job_' + jobId].job_maxdmg
    } else {
      let dang = TWDS.TWDBcalcDanger(eqmode === 'current' ? curBrutto : bestBrutto, difficulty, TWDS.jobData['job_' + jobId].job_danger, mot, 1)
      if (Character.charClass === 'adventurer') {
        if (charPremium) dang *= 0.8
        else dang *= 0.9
      }
      const maxdmg = TWDS.jobData['job_' + jobId].job_maxdmg
      td.textContent = (dang * maxdmg / 100.0).toFixed(0)
      td.title = _('JOBLIST_DANGER_MULT', '$value$%: probabilidad de lesión ($ic$%) multiplicada por el daño máximo ($md$% de la salud máxima actual)', {
        value: (dang * maxdmg / 100.0).toFixed(1),
        ic: dang.toFixed(1),
        md: TWDS.jobData['job_' + jobId].job_maxdmg.toFixed(1)
      })
    }

    td = document.createElement('td')
    tr.appendChild(td)

    td.innerHTML += MinimapWindow.getQuicklink(jobdata.name, 'task-finish-job')
    const b = TWDS.jobOpenButton(jobId)
    if (b != null) {
      td.innerHTML += b.outerHTML
    }
    if (Premium.hasBonus('automation')) {
      const but = document.createElement('button')
      but.textContent = '>>'
      but.classList.add('TWDS_joblist_startbutton')
      but.dataset.jobid = jobId
      but.title = _('JOBLIST_START_NEAREST', 'Iniciar el trabjo en la posición más cercana posible.')
      td.appendChild(but)
    }
    const xx = 'BJHLC_' + jobId
    let oldcolor = '#ff3197'
    if (xx in TWDS.settings) {
      oldcolor = TWDS.settings[xx]
    }

    td = document.createElement('td')
    TWDS.createEle({
      nodeName: 'input.check',
      type: 'checkbox',
      value: jobId,
      checked: !!TWDS.settings['BJHL_' + jobId],
      last: td,
      style: {
        accentColor: oldcolor
      },
      onchange: function () {
        console.log('change', this, this.checked)
        const v = this.value
        if (this.checked) {
          TWDS.settings['BJHL_' + v] = true
        } else {
          delete TWDS.settings['BJHL_' + v]
        }
        TWDS.saveSettings()
      }
    })
    TWDS.createEle({
      nodeName: 'input.color',
      type: 'color',
      last: td,
      value: oldcolor,
      oninput: function (ev) {
        if (td) {
          const e = TWDS.q1('input.check', td)
          if (e) {
            e.style.accentColor = this.value
          }
        }
      },
      onchange: function (ev) {
        const td = this.closest('td')
        if (td) {
          const e = TWDS.q1('input.check', td)
          if (e) {
            e.style.accentColor = this.value
            TWDS.settings['BJHLC_' + jobId] = this.value
            TWDS.saveSettings()
          }
        }
      }
    })
    tr.appendChild(td)
  }
  const headrow = function (tab) {
    const thead = document.createElement('thead')
    tab.appendChild(thead)
    const tr = document.createElement('tr')
    thead.appendChild(tr)

    let th

    th = document.createElement('th')
    tr.appendChild(th)
    th.dataset.field = 'no'
    th.textContent = TWDS._('JOBLIST_NUMBER', 'Nº')

    th = document.createElement('th')
    tr.appendChild(th)
    th.dataset.field = 'date'
    th.textContent = TWDS._('JOBLIST_DATE', 'Fecha')
    th.title = TWDS._('JOBLIST_DATE_TITLE', "La fecha con las 'mejores' ropas fueron calculadas.")

    th = document.createElement('th')
    tr.appendChild(th)
    th.dataset.field = 'name'
    th.textContent = TWDS._('JOBLIST_NAME', 'Nombre')

    th = document.createElement('th')
    tr.appendChild(th)
    th.dataset.field = 'lp'
    th.textContent = TWDS._('JOBLIST_LABORPOINTS', 'PT')

    th = document.createElement('th')
    tr.appendChild(th)
    th.dataset.field = 'stars'
    th.textContent = TWDS._('JOBLIST_STARS', 'Estrellas')

    th = document.createElement('th')
    tr.appendChild(th)
    th.dataset.field = 'xp'
    th.textContent = TWDS._('JOBLIST_XP', 'EXP')
    th.title = TWDS._('JOBLIST_XP_TITLE', 'Puntos experiencia')

    th = document.createElement('th')
    tr.appendChild(th)
    th.dataset.field = 'money'
    th.textContent = TWDS._('JOBLIST_MONEY', 'Dinero')

    th = document.createElement('th')
    tr.appendChild(th)
    th.dataset.field = 'luck'
    // th.textContent = TWDS._('JOBLIST_LUCK', 'luck')
    th.innerHTML = '&#9752;'
    th.title = TWDS._('JOBLIST_LUCK_TITLE', 'El valor máximo de los artículos que puede encontrar.')

    th = document.createElement('th')
    tr.appendChild(th)
    th.dataset.field = 'motivation'
    th.textContent = TWDS._('JOBLIST_MOTIVATION', 'Mot.')
    th.title = TWDS._('JOBLIST_MOTIVATION_TITLE', 'Motivación actual para este trabajo.')

    th = document.createElement('th')
    tr.appendChild(th)
    th.dataset.field = 'danger'
    // th.textContent = TWDS._('JOBLIST_DANGER', 'Danger')
    th.innerHTML = '&#9829;'
    th.title = TWDS._('JOBLIST_DANGER_TITLE', 'La probabilidad de tener un accidente.')

    th = document.createElement('th')
    tr.appendChild(th)
    th.dataset.field = 'dangercombined'
    th.innerHTML = '&#9829;&#9829;'
    th.title = TWDS._('JOBLIST_DANGERCOMBINED_TITLE', 'La probabilidad de tener un accidente multiplicada por el daño máximo en porcentaje de la salud máxima actual.')

    th = document.createElement('th')
    tr.appendChild(th)
    th = document.createElement('th')
    th.textContent = 'Mark'
    th.title = TWDS._('JOBLIST_HIGHLIGHT_TITLE', 'Marcar trabajos con bonus conocidos en el minimapa.')
    tr.appendChild(th)
  }

  const jl = JobList.getSortedJobs()
  let tab = null
  let tbody
  if (isupdate) {
    tab = TWDS.q1('#TWDS_jobs')
    if (tab) { tbody = TWDS.q1('tbody', tab) }
  }
  if (!tab) {
    isupdate = false
    tab = document.createElement('table')
    container.appendChild(tab)
    tab.id = 'TWDS_jobs'
    headrow(tab)
    tbody = document.createElement('tbody')
    tab.appendChild(tbody)
  }
  for (const job of jl) {
    const best = TWDS.getJobBestFromCache(job.id)
    row(tbody, job.id, best)
  }
}

TWDS.joblist.sort = function (tab, key) {
  if (tab == null) { // for ease of debugging
    tab = document.querySelector('#TWDS_jobs')
  }
  let cursort
  if ('cursort' in tab.dataset) {
    cursort = tab.dataset.cursort
  }
  const tbody = tab.querySelector('tbody')
  const rowColl = tab.querySelectorAll('tbody tr')
  const rows = []
  for (let i = 0; i < rowColl.length; i++) {
    const row = rowColl[i]
    const td = row.querySelector('[data-field=' + key + ']')
    if (key === 'name') {
      row.sortval = td.textContent
    } else if ('sortval' in td.dataset) {
      row.sortval = parseFloat(td.dataset.sortval)
    } else {
      row.sortval = parseFloat(td.textContent)
    }
    if (key === 'luck') {
      const td2 = row.querySelector('[data-field=money')
      row.sortval2 = parseFloat(td2.textContent)
    } else {
      const td2 = row.querySelector('[data-field=luck')
      row.sortval2 = parseFloat(td2.textContent)
    }
    rows.push(row)
  }
  if (cursort === key) {
    rows.sort(function (a, b) {
      if (key === 'name') {
        return b.sortval.localeCompare(a.sortval)
      } else if (b.sortval === a.sortval) {
        return a.sortval2 - b.sortval2
      } else {
        return a.sortval - b.sortval
      }
    })
    tab.dataset.cursort = '-' + key
  } else {
    rows.sort(function (a, b) {
      if (key === 'name') {
        return a.sortval.localeCompare(b.sortval)
      } else if (b.sortval === a.sortval) {
        return b.sortval2 - a.sortval2
      } else {
        return b.sortval - a.sortval
      }
    })
    tab.dataset.cursort = key
  }

  tbody.textContent = ''
  for (let i = 0; i < rows.length; i++) {
    tbody.appendChild(rows[i])
  }
}
TWDS.joblist.getcurrentdata = function (cb) {
  Ajax.remoteCallMode('work', 'index', {}, function (x) {
    TWDS.joblist.currentList = x
    if (cb) cb(x)
  })
}

TWDS.joblist.curJobDuration = 15
TWDS.joblist.getcontent = function () {
  const _ = TWDS._
  const x = window.localStorage.getItem('TWDS_job_duration')
  if (x !== null) { TWDS.joblist.curJobDuration = parseInt(x) }

  const div = document.createElement('div')
  div.id = 'TWDS_joblist_container'
  const p = document.createElement('p')
  div.appendChild(p)

  const fig = document.createElement('span')
  p.appendChild(fig)
  fig.id = 'TWDS_job_filtergroup'

  const modearea = document.createElement('span')
  p.appendChild(modearea)
  modearea.id = 'TWDS_job_modearea'

  const modeselect = document.createElement('select')
  modearea.appendChild(modeselect)
  modeselect.id = 'TWDS_job_modeselect'
  modeselect.type = 'checkbox'
  modeselect.title = TWDS._('JOBLIST_MODE_TITLE',
    'Seleccionar entre 3 modos de visualización: "actual" usa el equipo que lleva actualmente y muestra todos los valores, incluida la bonificación del equipo por suerte, XP y dinero. "mejor" utiliza la combinación de equipo con la mayor cantidad de puntos de trabajo, si se sabe, pero actualmente no incluye bonificación de equipo por suerte, XP y dinero. "raw" muestra los datos básicos de suerte, XP, dinero y peligro, sin tener en cuenta el equipo o los puntos de trabajo.')
  let active = 'current'
  if (TWDS.settings.joblist_modecheckbox) {
    active = 'best'
  }
  if (TWDS.settings.joblist_modeselect) {
    active = TWDS.settings.joblist_modeselect // overwrites the old checkbox
  }
  TWDS.createEle('option',
    {
      last: modeselect,
      value: 'current',
      selected: active === 'current',
      textContent: TWDS._('JOBLIST_MODE_CURRENT', 'equipo actual')
    })
  TWDS.createEle('option',
    {
      last: modeselect,
      value: 'best',
      selected: active === 'best',
      textContent: TWDS._('JOBLIST_MODE_BEST', 'equipo con mejores PT')
    })
  TWDS.createEle('option',
    {
      last: modeselect,
      value: 'raw',
      selected: active === 'raw',
      textContent: TWDS._('JOBLIST_MODE_RAW', 'mostrar datos en crudo')
    })
  modeselect.onchange = function () {
    const valkey = 'joblist_modeselect'
    TWDS.settings[valkey] = this.value
    TWDS.saveSettings()
    const pa = document.querySelector('#TWDS_joblist_container').parentNode
    pa.innerHTML = ''
    pa.appendChild(TWDS.joblist.getcontent())
    // TWDS.joblist.refilter()
  }

  /*
  const modetext = document.createElement('span')
  modearea.appendChild(modetext)
  modetext.textContent = _('JOBLIST_ASSUME_BEST', 'assume best clothes')
  modetext.title = _('JOBLIST_ASSUME_BEST_TITLE', 'otherwise the current equipment is used')
*/
  const sig = document.createElement('span')
  p.appendChild(sig)
  sig.id = 'TWDS_job_searchgroup'

  const input = document.createElement('input')
  sig.appendChild(input)
  input.id = 'TWDS_job_search'
  input.placeholder = _('SEARCH', 'buscar')
  input.type = 'search'

  const button = document.createElement('button')
  sig.appendChild(button)
  button.id = 'TWDS_job_searchx'
  button.textContent = 'x'

  const sel = document.createElement('select')
  p.appendChild(sel)
  sel.id = 'TWDS_job_duration'

  let opt = document.createElement('option')
  sel.appendChild(opt)
  opt.setAttribute('value', 15)
  opt.textContent = '15s'
  if (TWDS.joblist.curJobDuration === 15) opt.setAttribute('selected', 'selected')

  opt = document.createElement('option')
  sel.appendChild(opt)
  opt.setAttribute('value', 600)
  opt.textContent = '10m'
  if (TWDS.joblist.curJobDuration === 600) opt.setAttribute('selected', 'selected')

  opt = document.createElement('option')
  sel.appendChild(opt)
  opt.setAttribute('value', 3600)
  opt.textContent = '1h'
  if (TWDS.joblist.curJobDuration === 3600) opt.setAttribute('selected', 'selected')

  TWDS.joblist.getcurrentdata(function (x) {
    TWDS.joblist.initDisplay(div, x, false)
    fig.appendChild(TWDS.joblist.addFilters())
    TWDS.joblist.refilter(div)
    const oldsort = window.localStorage.getItem('TWDS_job_cursort')
    if (oldsort !== null) {
      const tab = document.querySelector('#TWDS_jobs')
      const key = window.localStorage.getItem('TWDS_job_cursort')
      if (key !== null) {
        if (key[0] === '-') {
          TWDS.joblist.sort(tab, key.substring(1))
          TWDS.joblist.sort(tab, key.substring(1))
        } else {
          TWDS.joblist.sort(tab, key)
        }
      }
    }
  })

  return div
}
TWDS.joblist.refilter = function (main) {
  if (typeof main === 'undefined') { main = document }
  const tab = main.querySelector('#TWDS_jobs')
  const rowColl = tab.querySelectorAll('tbody tr')
  for (let i = 0; i < rowColl.length; i++) {
    const tr = rowColl[i]
    tr.classList.remove('hidden')
  }

  const container = main.querySelector('#TWDS_joblist_filter_container')
  const opsels = container.querySelectorAll('.TWDS_joblist_filter_op')
  for (let opidx = 0; opidx < opsels.length; opidx++) {
    const opsel = opsels[opidx]
    const key = opsel.dataset.key
    const valsel = opsel.parentNode.querySelector('.TWDS_joblist_filter_val')
    const op = opsel.value
    let cmpVal = valsel.value
    if (op === '' || cmpVal === '') continue
    cmpVal = parseInt(cmpVal)
    for (let i = 0; i < rowColl.length; i++) {
      const tr = rowColl[i]
      const td = tr.querySelector('[data-field=' + key + ']')
      let v
      if ('sortval' in td.dataset) {
        v = parseFloat(td.dataset.sortval)
      } else {
        v = parseFloat(td.textContent)
      }
      let good = false
      if (op === 'gte') {
        if (v >= cmpVal) good = true
      }
      if (op === 'gt') {
        if (v > cmpVal) good = true
      }
      if (op === 'eq') {
        if (v === cmpVal) good = true
      }
      if (op === 'lt') {
        if (v < cmpVal) good = true
      }
      if (op === 'lte') {
        if (v <= cmpVal) good = true
      }
      if (!good) { tr.classList.add('hidden') }
    }
  }
}
TWDS.joblist.addFilters = function () {
  const tab = document.querySelector('#TWDS_jobs')
  const minmax = function (tab, key) {
    let min = 9999999
    let max = -9999999
    const rowColl = tab.querySelectorAll('tbody tr')
    for (let i = 0; i < rowColl.length; i++) {
      const row = rowColl[i]
      const td = row.querySelector('[data-field=' + key + ']')
      let v
      if ('sortval' in td.dataset) {
        v = parseFloat(td.dataset.sortval)
      } else {
        v = parseFloat(td.textContent)
      }
      if (v > max) max = v
      if (v < min) min = v
    }
    return [min, max]
  }
  const keys = [
    ['lp', 'pt'],
    ['xp', 'exp'],
    ['money', '$'],
    ['luck', 'suerte'],
    ['motivation', 'motiv.'],
    ['danger', 'peligro']
  ]
  const container = TWDS.createElement({
    nodeName: 'div',
    id: 'TWDS_joblist_filter_container'
  })
  const _ = TWDS._
  for (const key of keys) {
    const opkey = 'obtab_filter_op_' + key[0]
    const valkey = 'obtab_filter_value_' + key[0]
    const mm = minmax(tab, key[0])
    const curop = TWDS.settings[opkey] || 'gte'
    const curval = TWDS.settings[valkey] || 0

    const fs = TWDS.createElement({
      nodeName: 'fieldset',
      childNodes: [
        {
          nodeName: 'legend',
          textContent: _('JOBLIST_LEGEND_' + key[1], key[1])
        },
        {
          nodeName: 'select',
          className: 'TWDS_joblist_filter_op',
          dataset: { key: key[0] },
          childNodes: [
            {
              nodeName: 'option',
              selected: curop === 'gte',
              value: 'gte',
              textContent: '>='
            },
            {
              nodeName: 'option',
              selected: curop === 'gt',
              value: 'gt',
              textContent: '>'
            },
            {
              nodeName: 'option',
              selected: curop === 'eq',
              value: 'eq',
              textContent: '='
            },
            {
              nodeName: 'option',
              selected: curop === 'lt',
              value: 'lt',
              textContent: '<'
            },
            {
              nodeName: 'option',
              selected: curop === 'lte',
              value: 'lte',
              textContent: '<='
            }
          ]
        },
        {
          nodeName: 'input',
          type: 'number',
          className: 'TWDS_joblist_filter_val',
          dataset: { key: key[0] },
          value: curval,
          min: mm[0],
          max: mm[1]
        }
      ]
    })
    container.appendChild(fs)
  }
  return container
}

TWDS.joblist.startFunction = function () {
  $(document).on('click', '#TWDS_jobs thead th', function () {
    const key = this.dataset.field
    if (typeof key !== 'undefined') {
      const tab = document.querySelector('#TWDS_jobs')
      TWDS.joblist.sort(tab, key)
      window.localStorage.setItem('TWDS_job_cursort', tab.dataset.cursort)
    }
  })
  $(document).on('click', '.TWDS_joblist_openbutton', function (ev) {
    const id = this.dataset.job_id
    if (!id || !Premium.hasBonus('automation')) { return false }
    Ajax.remoteCall('work', 'get_nearest_job', {
      job_id: id
    }, function (json) {
      if (json.error) { return new UserMessage(json.msg).show() }
      JobWindow.open(id, json.x, json.y)
    })
  })
  $(document).on('click', '.TWDS_joblist_startbutton', function (ev) {
    const id = this.dataset.jobid
    if (!id || !Premium.hasBonus('automation')) { return false }
    Ajax.remoteCall('work', 'get_nearest_job', {
      job_id: id
    }, function (json) {
      if (json.error) { return new UserMessage(json.msg).show() }
      const x = document.querySelector('#TWDS_job_duration')
      JobWindow.startJob(id, json.x, json.y, parseInt(x.value))
    })
  })
  $(document).on('change', '#TWDS_job_duration', function (ev) {
    if (typeof TWDS.joblist.currentList !== 'undefined') {
      const ele = document.querySelector('#TWDS_job_duration')
      TWDS.joblist.curJobDuration = parseInt(ele.value)
      window.localStorage.setItem('TWDS_job_duration', TWDS.joblist.curJobDuration)

      const t = document.querySelector('#TWDS_jobs')
      const pa = t.parentNode

      TWDS.joblist.initDisplay(pa, TWDS.joblist.currentList, true)
    }
  })
  $(document).on('click', '#TWDS_job_filter', function (ev) {
    TWDS.joblist.handleFilter()
  })
  $(document).on('change', '.TWDS_joblist_filter_op', function (ev) {
    const key = this.dataset.key
    const opkey = 'obtab_filter_op_' + key
    TWDS.settings[opkey] = this.value
    TWDS.saveSettings()
    TWDS.joblist.refilter()
  })
  $(document).on('change', '.TWDS_joblist_filter_val', function (ev) {
    const key = this.dataset.key
    const valkey = 'obtab_filter_value_' + key
    TWDS.settings[valkey] = this.value
    TWDS.saveSettings()
    TWDS.joblist.refilter()
  })
  $(document).on('click', '#TWDS_job_searchx', function (ev) {
    document.querySelector('#TWDS_job_search').value = ''
    $('#TWDS_job_search').trigger('change')
  })
  $(document).on('change', '#TWDS_job_modeselect', function (ev) {
    const valkey = 'joblist_modeselect'
    console.log('MS change', ev, this.value)
    TWDS.settings[valkey] = this.value
    TWDS.saveSettings()
    const pa = document.querySelector('#TWDS_joblist_container').parentNode
    pa.innerHTML = ''
    pa.appendChild(TWDS.joblist.getcontent())
    // TWDS.joblist.refilter()
  })
  $(document).on('change', '#TWDS_job_search', function (ev) {
    const fi = document.querySelector('#TWDS_job_search')
    const rows = document.querySelectorAll('#TWDS_jobs tbody tr')
    if (!JobsModel.Jobs.length) { JobsModel.initJobs() }

    const search = fi.value.trim()
    if (search === '') {
      for (const row of Object.values(rows)) {
        row.classList.remove('hidden')
      }
    } else {
      const m = JobsModel.searchJobsByPattern(fi.value)
      for (const row of Object.values(rows)) {
        row.classList.add('hidden')
      }
      for (const found of Object.values(m)) {
        const id = found.id
        const ele = document.querySelector('#TWDS_jobs tbody tr[data-jobid="' + id + '"]')
        ele.classList.remove('hidden')
      }
    }
  })
  window.EventHandler.listen(['wear_changed'], TWDS.joblist.wearchangehandler)
}
TWDS.joblist.wearchangehandler = function () { TWDS.joblist.wearchangehandlerOverloadFix() }
TWDS.joblist.wearchange_timestamp = 0
TWDS.joblist.wearchange_timeout = -1

TWDS.joblist.wearchangehandlerOverloadFix = function () {
  TWDS.joblist.wearchange_timestamp = (new Date()).getTime()
  if (TWDS.joblist.wearchange_timeout > -1) {
    window.clearTimeout(TWDS.joblist.wearchange_timeout)
    TWDS.joblist.wearchange_timeout = -1
  }
  TWDS.joblist.wearchange_timeout = window.setTimeout(function () {
    TWDS.joblist.wearchange_timeout = -1
    TWDS.joblist.wearchangehandlerReal()
  }, 1000)
}
TWDS.joblist.wearchangehandlerReal = function () {
  const wid = 'TWDS_joblist_window'
  if (wman.isWindowCreated(wid)) {
    TWDS.joblist.getcurrentdata(function () {
      const t = document.querySelector('#TWDS_jobs')
      if (t) {
        const pa = t.parentNode
        TWDS.joblist.initDisplay(pa, TWDS.joblist.currentList, true)
      }
    })
  }
}
TWDS.joblist.openwindow = function () {
  const wid = 'TWDS_joblist_window'
  const win = wman.open(wid, 'set', 'TWDS_joblist')
  win.setTitle(TWDS._('JOBLIST_WINDOW_TITLE', 'Lista trabajos'))
  win.setMiniTitle(TWDS._('JOBLIST_MINITITLE', 'Lista trabajos'))
  const sp = new west.gui.Scrollpane()
  const content = TWDS.joblist.getcontent(win)
  sp.appendContent(content)

  win.appendToContentPane(sp.getMainDiv())
}

TWDS.registerExtra('TWDS.joblist.openwindow',
  TWDS._('JOBLIST_TITLE', 'Lista trabajos'),
  TWDS._('JOBLIST_DESC', 'Lista de trabajos')
)
TWDS.registerStartFunc(TWDS.joblist.startFunction)

TWDS.getSettingsContentReal = function () {
  const createVersionThing = function () {
    const thing = document.createElement('p')
    thing.classList.add('TWDS_VERSIONINFO')
    thing.textContent = 'Version: v0.73-0-ga1f4088-dirty'
    return thing
  }
  const createCacheThing = function () {
    const thing = document.createElement('div')
    thing.className = 'TWDS_settings_cache'
    let button
    let p

    const h = document.createElement('h2')
    thing.appendChild(h)
    h.textContent = 'Caché de Ropas'

    p = document.createElement('p')
    thing.appendChild(p)
    p.textContent = TWDS._('CLOTHECACHE_SETTING_INTRO', 'Los resultados de los cálculos de la ropa de trabajo se almacenan en un caché y se pueden reutilizar en la ventana de trabajo. Aquí puede borrar, completar o actualizar muchos trabajos a la vez, aunque volver a calcular todos los trabajos llevará bastante tiempo en computadoras lentas.')

    p = document.createElement('p')
    const info = document.createElement('p')
    info.id = 'TWDS_job_reload_info'
    thing.appendChild(info)
    TWDS.clothcache.info(info)

    p = document.createElement('p')
    thing.appendChild(p)
    button = document.createElement('button')
    p.appendChild(button)
    button.textContent = TWDS._('CLOTHCACHE_BUTTON_CLEAR', 'Borrar caché de ropa')
    button.onclick = TWDS.clothcache.clear

    p = document.createElement('p')
    thing.appendChild(p)
    p.textContent = TWDS._('CLOTHCACHE_RELOAD_QUESTION', '¿Recalcular la caché?')

    button = document.createElement('button')
    thing.appendChild(button)
    button.textContent = TWDS._('CLOTHCACHE_RELOAD_ALL', 'Todos')
    button.title = TWDS._('CLOTHCACHE_RELOAD_ALL_MOUSEOVER', 'Recarga la caché de ropas para todos los trabajos.')
    button.classList.add('TWDS_job_reload')
    button.dataset.reloadmode = 'all'

    button = document.createElement('button')
    thing.appendChild(button)
    button.textContent = TWDS._('CLOTHCACHE_RELOAD_MISSING', 'Perdidos')
    button.title = TWDS._('CLOTHCACHE_RELOAD_MISSING_MOUSEOVER', 'Rellena la caché de ropas para todos los trabajos que no tienen una.')
    button.classList.add('TWDS_job_reload')
    button.dataset.reloadmode = 'missing'

    button = document.createElement('button')
    thing.appendChild(button)
    button.textContent = TWDS._('CLOTHCACHE_RELOAD_1D', '1d')
    button.title = TWDS._('CLOTHCACHE_RELOAD_1D_MOUSEOVER', 'Recarga la caché de ropas para todos los trabajos que tengan más de 1 día.')
    button.classList.add('TWDS_job_reload')
    button.dataset.reloadmode = '1d'

    button = document.createElement('button')
    thing.appendChild(button)
    button.textContent = TWDS._('CLOTHCACHE_RELOAD_1W', '1s')
    button.title = TWDS._('CLOTHCACHE_RELOAD_1W_MOUSEOVER', 'Recarga la caché de ropas para todos los trabajos que tengan más de 1 semana.')
    button.classList.add('TWDS_job_reload')
    button.dataset.reloadmode = '1w'

    button = document.createElement('button')
    thing.appendChild(button)
    button.textContent = TWDS._('CLOTHCACHE_RELOAD_30D', '30d')
    button.title = TWDS._('CLOTHCACHE_RELOAD_30D_MOUSEOVER', 'Recarga la caché de ropas para todos los trabajos que tengan más de 30 días.')
    button.classList.add('TWDS_job_reload')
    button.dataset.reloadmode = '30d'

    return thing
  }
  const createMainThing = function () {
    const thing = document.createElement('div')
    thing.className = 'TWDS_settings_main'
    const table = TWDS.createEle({
      nodeName: 'table.settings',
      last: thing
    })

    let lastgroup = ''
    const a = []
    for (const x of TWDS.settingList.values()) {
      a.push(x)
    }
    a.sort(function (a, b) {
      if (a.group === 'misc') {
        if (b.group !== 'misc') {
          return 1
        }
      }
      if (b.group === 'misc') {
        return -1
      }
      if (a.group === b.group && (a.subgroup !== '' || b.subgroup !== '')) {
        // subgroups to the end.
        if (a.subgroup !== '' && b.subgroup === '') {
          return 1
        }
        if (b.subgroup !== '' && a.subgroup === '') {
          return -1
        }
        const t = a.subgroup.toLocaleLowerCase().localeCompare(b.subgroup.toLocaleLowerCase())
        if (t) return t
      }
      const t = a.group.toLocaleLowerCase().localeCompare(b.group.toLocaleLowerCase())
      if (t) return t
      if (a.ordervalue !== b.ordervalue) { return a.ordervalue - b.ordervalue }
      return a.name.toLocaleLowerCase().localeCompare(b.name.toLocaleLowerCase())
    })
    let tbody = null
    for (const one of a) {
      const mode = one.mode
      const name = one.name
      const text = one.text
      const group = one.group
      const opts = one.opts
      if ((group !== lastgroup && group !== '') || tbody === null) {
        tbody = TWDS.createEle({
          nodeName: 'tbody',
          last: table
        })
        TWDS.createEle({
          nodeName: 'tr.head',
          last: tbody,
          children: [
            { nodeName: 'th', colSpan: 2, textContent: group }
          ]
        })
        lastgroup = group
      }
      if (mode === 'info') {
        TWDS.createEle({
          nodeName: 'tr.info',
          last: tbody,
          children: [
            { nodeName: 'td', textContent: text }
          ]
        })
        continue
      }

      const tr = TWDS.createEle({
        nodeName: 'tr.settings',
        last: tbody
      })
      const td = TWDS.createEle({
        nodeName: 'td',
        last: tr
      })

      if (mode === 'bool') {
        const ele = TWDS.createEle({
          nodeName: 'input.TWDS_setting_bool.TWDS_setting',
          type: 'checkbox',
          value: 1,
          dataset: { settingName: name },
          last: td
        })
        if (TWDS.settings[name]) { ele.setAttribute('checked', 'checked') }
      }
      if (mode === 'int') {
        const ele = TWDS.createEle({
          nodeName: 'input.TWDS_setting_int.TWDS_setting',
          type: 'number',
          value: TWDS.settings[name],
          dataset: { settingName: name },
          last: td
        })
        if ('min' in opts) ele.setAttribute('min', opts.min)
        if ('max' in opts) ele.setAttribute('max', opts.max)
      }
      if (mode === 'string') {
        TWDS.createEle({
          nodeName: 'input.TWDS_setting_string.TWDS_setting',
          type: 'text',
          value: TWDS.settings[name],
          dataset: { settingName: name },
          last: td
        })
      }
      TWDS.createEle({
        nodeName: 'span',
        textContent: text,
        last: td
      })
      TWDS.createEle({
        nodeName: 'td.settingname',
        textContent: name,
        last: tr
      })
    }

    return thing
  }
  const div = document.createElement('div')
  div.id = 'TWDS_settings'
  div.appendChild(createVersionThing())
  div.appendChild(createCacheThing())
  div.appendChild(createMainThing())
  return div
}
TWDS.activateSettingsTab = function () {
  TWDS.activateTab('settings')
}
TWDS.getSettingsContent = function () {
  return TWDS.getSettingsContentReal()
}

TWDS.settingsStartFunction = function () {
  TWDS.registerTab('settings',
    TWDS._('TABNAME_SETTINGS', 'Ajustes'),
    TWDS.getSettingsContent,
    TWDS.activateSettingsTab,
    true)

  $(document).on('change', '.TWDS_setting', function () {
    const name = this.dataset.settingName
    let v = this.value
    if (this.type === 'checkbox') {
      if (!this.checked) { v = false } else { v = true }
    }
    TWDS.settings[name] = v
    console.log('changed setting', name, 'to', v)
    window.localStorage.setItem('TWDS_settings', JSON.stringify(TWDS.settings))
    for (const x of TWDS.settingList.values()) {
      const n = x.name
      if (name === n) {
        const cb = x.callback
        if (cb) cb(v)
      }
    }
    TWDS.saveSettings()
  })
  const t = window.localStorage.getItem('TWDS_setting_jobCacheSeconds')
  if (t !== null) { TWDS.jobCacheSecondsSetting = parseInt(t) }

  $(document).on('click', '.TWDS_job_reload', function () {
    let mode = this.dataset.reloadmode
    if (mode === 'all') {
      TWDS.clothcache.clear()
      mode = 'missing'
    }
    TWDS.clothcache.reload(mode)
  })
}
TWDS.registerStartFunc(TWDS.settingsStartFunction)
// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab

TWDS.getJobBestFromCache = function (id) {
  const k = 'TWDS_j_' + id
  let d = window.localStorage.getItem(k)
  if (d !== null) {
    d = JSON.parse(d)
    return d
  }
  return null
}
TWDS.jobCacheSecondsSetting = 3600 // 1h
TWDS.getBestSetWrapper = function (skills, id, returnFull = false) {
  const k = 'TWDS_j_' + id

  const best = west.item.Calculator._TWDS_backup_getBestSet(skills, id)
  const one = {
    timestamp: new Date().getTime(),
    id: id,
    level: Character.level
  }
  one.items = [...best.items] // clone that
  for (let i = 0; i < best.sets.length; i++) {
    for (let j = 0; j < best.sets[i].items.length; j++) {
      one.items.push(best.sets[i].items[j])
    }
  }
  window.localStorage.setItem(k, JSON.stringify(one))
  TWDS.clothcache.recalcItemUsage()
  if (returnFull) { return one }
  return best
}
TWDS.clothcache = {}
TWDS.clothcache.clear = function () {
  const jl = JobList.getSortedJobs()
  for (const job of jl) {
    const k = 'TWDS_j_' + job.id
    window.localStorage.removeItem(k)
  }
  TWDS.clothcache.recalcItemUsage()
}
TWDS.clothcache.info = function (ele) {
  const jl = JobList.getSortedJobs()
  let total = 0
  let found = 0
  let agesum = 0
  const now = new Date().getTime()
  for (const job of jl) {
    const old = TWDS.getJobBestFromCache(job.id)
    total++
    if (old === null) {
      continue
    }
    agesum += now - old.timestamp
    found++
  }
  let t = TWDS._('CLOTHCACHE_STATUS_INFO_TEXT',
    '$found$ / $total$ trabajos tienen las mejores ropas almacenadas en la caché.',
    { found: found, total: total })

  if (found) {
    const avg = (agesum / found) / 1000
    let agestr
    if (avg > 2 * 86400) {
      agestr = (avg / 86400).toFixed(1)
      agestr = TWDS._('CLOTHCACHE_STATUS_AGE_DAYS', '$n$ Días', { n: agestr })
    } else if (avg > 2 * 3600) {
      agestr = (avg / 3600).toFixed(1)
      agestr = TWDS._('CLOTHCACHE_STATUS_AGE_HOURS', '$n$ Horas', { n: agestr })
    } else {
      agestr = (avg / 60).toFixed(1)
      agestr = TWDS._('CLOTHCACHE_STATUS_AGE_MINUTES', '$n$ Minutos', { n: agestr })
    }
    t += ' '
    t += TWDS._('CLOTHCACHE_STATUS_AGE_TEXT', 'La antigüedad media es de $age$ días.', { age: agestr })
  }
  ele.textContent = t
}

TWDS.clothcache.reload = function (mode) {
  const jl = JobList.getSortedJobs()
  const info = document.querySelector('#TWDS_job_reload_info')
  for (const job of jl) {
    const old = TWDS.getJobBestFromCache(job.id)
    if (old !== null) {
      const ts = old.timestamp
      if (mode === '1d') {
        if (ts > new Date().getTime() - 1 * 86400 * 1000) { continue }
      }
      if (mode === '2d') {
        if (ts > new Date().getTime() - 2 * 86400 * 1000) { continue }
      }
      if (mode === '1w') {
        if (ts > new Date().getTime() - 7 * 86400 * 1000) { continue }
      }
      if (mode === '30d') {
        if (ts > new Date().getTime() - 30 * 86400 * 1000) { continue }
      }
      if (mode === 'missing') { continue }
    }
    // console.log('calc', job.id, job.name, mode, old)
    const out = TWDS.getBestSetWrapper(job.skills, job.id, true)
    info.textContent = job.id + '/' + jl.length + ' ' +
    job.name + ' ' + TWDS.describeItemCombo(out.items)
    TWDS.clothcache.recalcItemUsage()
    setTimeout(function () { TWDS.clothcache.reload(mode) }, 500)
    return
  }
  TWDS.clothcache.recalcItemUsage()
  TWDS.activateSettingsTab() // layering violation
  info.textContent = ''
}

TWDS.clothcache.recalcItemUsage = function () {
  const items = {}
  const add2item = function (item, key, num) {
    if (!(item in items)) {
      items[item] = {
        job: [],
        eq: [],
        ds: [],
        dyn: []
      }
    }
    items[item][key].push(num)
  }

  const jl = JobList.getSortedJobs()
  for (const job of jl) {
    const b = TWDS.getJobBestFromCache(job.id)
    if (b === null) continue // should not happen
    for (const item of b.items) {
      add2item(item, 'job', job.id)
    }
  }
  for (let i = 0; i < window.localStorage.length; i++) {
    const k = window.localStorage.key(i)
    if (!k.match(/^TWDS_h_/)) {
      continue
    }
    const s = window.localStorage.getItem(k)
    const o = JSON.parse(s)
    for (const ii of o.item_ids) {
      add2item(ii, 'ds', o.name)
    }
  }
  for (const [id, users] of Object.entries(TWDS.quickequipment.getused())) {
    for (let i = 0; i < users.length; i++) {
      add2item(id, 'dyn', users[i])
    }
  }

  window.localStorage.setItem('TWDS_itemusage', JSON.stringify(items))

  Ajax.remoteCallMode('inventory', 'show_equip', {}, function (data) {
    const eql = data.data
    for (const eq of Object.values(eql)) {
      for (const slot of Wear.slots) {
        const it = eq[slot]
        add2item(it, 'eq', eq.name)
      }
    }
    window.localStorage.setItem('TWDS_itemusage', JSON.stringify(items))
  })
}

TWDS.clothcache.invItemInitDisplay = function () {
  tw2widget.InventoryItem.prototype._TWDS_backup_initDisplay.apply(this, arguments)

  const ii = this.obj.item_id
  this.divMain[0].dataset.twds_item_id = ii // for ease of scripting

  let iu = window.localStorage.getItem('TWDS_itemusage')
  if (iu !== null) {
    iu = JSON.parse(iu)

    let title = ''
    let count = 0
    if (ii in iu) {
      iu = iu[ii]
      if (iu.job.length) {
        title = title + TWDS._('CLOTHCACHE_JOBS', '$n$ trabajos', { n: iu.job.length })
        count += iu.job.length
      }
      if (iu.eq.length) {
        if (title > '') title += ', '
        title = title + TWDS._('CLOTHCACHE_TW_EQ_SETS', '$n$ Conjunto equipos', { n: iu.eq.length })
        count += iu.eq.length
      }
      if (iu.ds.length) {
        if (title > '') title += ', '
        title = title + TWDS._('CLOTHCACHE_DS_EQ_SETS', '$n$ $s$ Conjuntos equipos', { n: iu.ds.length, s: TWDS.scriptname })
        count += iu.ds.length
      }
      if (iu.dyn.length) {
        if (title > '') title += ', '
        title = title + TWDS._('CLOTHCACHE_DYN_EQ_SETS', '$n$ $s$ Conjuntos equipos dinámicos', { n: iu.dyn.length, s: TWDS.scriptname })
        count += iu.dyn.length
      }
    }
    let twcalc = window.localStorage.getItem('TWCalc_Wardrobe')
    if (twcalc !== null) {
      twcalc = JSON.parse(twcalc)
      let wcnt = 0
      for (let i = 0; i < twcalc.length; i++) {
        for (let j = 0; j < 10; j++) {
          if (twcalc[i].items[j] === ii) { wcnt++ }
        }
      }
      if (wcnt) {
        if (title > '') title += ', '
        title = title + TWDS._('CLOTHCACHE_TC_EQ_SETS', '$n$ Conjuntos equipos TW-Calc', { n: wcnt })
        count += wcnt
      }
    }
    if (count) {
      title += TWDS._('CLOTHCACHE_SHIFT_CLICK_FOR', '. Puede encontrar más información presionando Shift y haciendo clic en el número.')
      const span = document.createElement('span')
      span.classList.add('TWDS_itemusageinfo')
      span.dataset.item_id = ii
      this.divMain[0].appendChild(span)
      span.textContent = count
      span.title = title
      if (TWDS.settings.saleProtection) {
        this.divMain[0].classList.add('not_auctionable')
        this.divMain[0].classList.add('not_sellable')
      }
    }
  }
  const st = TWDS.storage.iteminfo(ii)
  const want = parseInt(st[0])
  if (want > 0) {
    const countele = TWDS.q1('.count', this.divMain[0])
    countele.textContent = countele.textContent + ' / ' + want
  }
}

TWDS.clothcache.startFunction = function () {
  try {
    west.item.Calculator._TWDS_backup_getBestSet = west.item.Calculator.getBestSet
    west.item.Calculator.getBestSet = TWDS.getBestSetWrapper
  } catch (e) {
  }

  try {
    tw2widget.InventoryItem.prototype._TWDS_backup_initDisplay = tw2widget.InventoryItem.prototype.initDisplay
    tw2widget.InventoryItem.prototype.initDisplay = TWDS.clothcache.invItemInitDisplay
    document.addEventListener('click', function (ev) {
      if (ev.target.classList.contains('TWDS_itemusageinfo')) {
        if (ev.shiftKey) {
          let sel = "#TWDS_wuw [data-itemid='"
          sel += ev.target.dataset.item_id
          sel += "']"
          TWDS.wuw.openwindow(sel)
        }
        return false
      }
    })
  } catch (e) {
  }

  try {
    JobWindow.prototype._TWDS_getBestWearButton = JobWindow.prototype._TWDS_getBestWearButton ||
      JobWindow.prototype.getBestWearButton

    JobWindow.prototype.getBestWearButton = function () {
      const jw = JobWindow.prototype._TWDS_getBestWearButton.apply(this, arguments)
      // var n = this;
      const jobId = this.job.id
      const d = TWDS.getJobBestFromCache(jobId)
      if (d === null) return jw

      const now = new Date().getTime()
      const age = now - d.timestamp
      let agestr = ''
      if (age > 2 * 24 * 3600 * 1000) {
        agestr = Math.round(age / (24 * 3600 * 1000)) + 'd'
      } else if (age > 2 * 3600 * 1000) {
        agestr = Math.round(age / (3600 * 1000)) + 'h'
      } else {
        agestr = Math.round(age / (60 * 1000)) + 'm'
      }

      const but = TWDS.createButton(
        TWDS._('CLOTHCACHE_BUTTON', 'Caché [$agestr$]', { agestr: agestr }), {
          classList: ['TWDS_getbestwear'],
          title: TWDS._('CLOTHCACHE_BUTTON_MOUSEOVER', 'Usar un equipo de ropas previamente calculado')
        }
      )
      /*
      const but = document.createElement('button')
      but.className = 'TWDS_getbestwear'
      but.textContent = 'cached [' + agestr + ']'
      but.title = 'Use a previously calculated coth set'
      */

      jw[0].appendChild(but) // jw is a jQuery.
      but.onclick = function (e) {
        e.stopImmediatePropagation()

        const d = TWDS.getJobBestFromCache(jobId)
        TWDS.wearItemsHandler(d.items)
      }
      return jw
    }
  } catch (e) {
  }
}
TWDS.registerStartFunc(TWDS.clothcache.startFunction)
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.speedcalc = {}
TWDS.speedcalc.openwindow = function () {
  const myname = 'TWDS_speedcalc_window'
  const win = wman.open(myname, TWDS._('SPEEDCALC_TITLE', 'Speedset-Calculator'), 'TWDS_speedcalc_window')
  win.setMiniTitle(TWDS._('SPEEDCALC_MINITITLE', 'Speedcalc'))

  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_speedcalc_container'
  })
  const container = TWDS.createEle('dl', { beforeend: content })
  const clicker = function () {
    const mode = parseInt(this.dataset.par)
    const keephp = parseInt(this.dataset.heephp)
    let out
    if (mode === 2) { out = TWDS.speedcalc.confirm() } else { out = TWDS.speedcalc.doit(mode, keephp) }
    console.log('WIH calling')
    TWDS.wearItemsHandler(out)
  }
  const block = function (mode, hpmode, text, desc) {
    const dt = TWDS.createEle({
      nodeName: 'dt',
      beforeend: container
    })
    TWDS.createEle({
      nodeName: 'button',
      className: 'TWDS_button',
      dataset: {
        par: mode,
        keephp: hpmode
      },
      textContent: text,
      beforeend: dt,
      onclick: clicker
    })
    TWDS.createEle({
      nodeName: 'dd',
      beforeend: container,
      textContent: desc
    })
  }
  TWDS.createEle({
    nodeName: 'dt.head',
    textContent: 'HP ignoring',
    last: container
  })
  block(0, 0, 'basic', 'Quite fast speedset calculation. Likely to give a good, but most often not perfect result')
  block(1, 0, 'extended', 'A compromise between the two extremes, not taking all speed bonus giving equipment into account')
  block(2, 0, 'full', "This calculation will take a long time, and will block the browser. 2 minutes have been observed, and it's easy to imagine even longer times with more sets or items giving speed bonus.")
  TWDS.createEle({
    nodeName: 'dt.head',
    textContent: 'Mantener Salud',
    last: container
  })
  block(0, 1, 'basic', 'Quite fast speedset calculation. Likely to give a good, but most often not perfect result')
  block(1, 1, 'extended', 'A compromise between the two extremes, not taking all speed bonus giving equipment into account')
  block(2, 1, 'full', "This calculation will take a long time, and will block the browser. 2 minutes have been observed, and it's easy to imagine even longer times with more sets or items giving speed bonus.")

  sp.appendContent(content)

  win.appendToContentPane(sp.getMainDiv())
  return null
}

TWDS.speedcalc.confirm = function () {
  if (window.confirm("The speed set calculation can take a long time, and will block the browser. 2 minutes have been observed, and it's easy to imagine even longer times with more sets or items giving speed bonus. Do you want to calculate the speed set now?")) {
    return TWDS.speedcalc.doit(2)
  }
  return []
}
TWDS.speedcalc.doit3 = function () {
  console.time('SpeedCalc3')

  // for the list of useful things we need the set boni
  const setvalues = {}
  const calcsetvalues = function () {
    const avs = west.item.Calculator.filterUnavailableSets(west.storage.ItemSetManager.getAll())
    for (let i = 0; i < avs.length; i++) {
      const sv = TWDS.speedcalc.getSetSpeedyValues(avs[i])
      const k = avs[i].key
      setvalues[k] = sv
    }
    console.log('doit3', 'setvalues', setvalues)
  }
  calcsetvalues()

  const bestItems = TWDS.speedcalc.getBestItems() // a heuristical baseline,
  const bestItemsArray = []
  const bestItemValueBySlot = []
  const bestItemBySlot = []
  for (const it of Object.values(bestItems)) {
    bestItemsArray.push(it.item_id)
    const slot = it.type
    bestItemValueBySlot[slot] = TWDS.speedcalc.getSpeedyValues(it)
    bestItemBySlot[slot] = it
  }

  const baseline = TWDS.bonuscalc.getSpeed(bestItemsArray)
  console.log('doit3', 'bi', TWDS.describeItemCombo(bestItemsArray), baseline)

  const itemsBySlot = {}

  const highestBonusBySlot = []
  const highestRideBySlot = []

  const additemifusefull = function (it) {
    const slot = it.type
    if (!it.wearable()) return
    const value = TWDS.speedcalc.getSpeedyValues(it)
    /* a useful item is one which has:
     * - a higher ride+speed as anything else in the slot,
     * - or has the best speedbonus for the slot, because that is a multiplier
     * - or is part of a set with ride/speed above the bestitem in the slot
     * - or is part of a set with speed multiplier
    */

    let flag = 0

    let sval = value.ride
    if (value.speed) {
      sval += 100 / value.speed - 100
    }
    if (sval > highestRideBySlot[slot]) {
      highestRideBySlot[slot] = sval
      flag += 1
    }
    if (value.speedbonus > highestBonusBySlot[slot]) {
      highestBonusBySlot[slot] = value.speedbonus
      flag += 2
    }
    if (it.set !== null) {
      if (setvalues[it.set]) { // paranoida
        const v = setvalues[it.set].ride + setvalues[it.set].speed
        const cmp = bestItemValueBySlot[slot].ride + bestItemValueBySlot[slot].speed
        if (v > cmp) {
          flag += 4
        }
        if (setvalues[it.set].speedbonus) {
          flag += 8
        }
      }
    }
    if (flag) {
      console.log('ADDITEM', it.name, flag)
      itemsBySlot[slot].push(it)
    }
  }
  // init counters
  for (let i = 0; i < Wear.slots.length; i++) {
    const slot = Wear.slots[i]
    itemsBySlot[slot] = []
    highestBonusBySlot[slot] = 0
    highestRideBySlot[slot] = 0
  }

  for (const it of Object.values(bestItems)) {
    additemifusefull(it)
  }

  for (let i = 0; i < Wear.slots.length; i++) {
    const slot = Wear.slots[i]
    const it = Wear.get(slot)
    additemifusefull(it.obj)
  }
  const baglist = Bag.getItemsIdsByBaseItemIds()
  const ba = []
  for (const a of Object.values(baglist)) {
    const it = ItemManager.get(a[0])
    ba.push(it)
    additemifusefull(it)
  }
  console.log('BA', ba)
  // reverse, assuming newer things are faster.
  for (let i = ba.length - 1; i >= 0; i--) {
    additemifusefull(ba[i])
  }
  console.log('doit3', 'base list', itemsBySlot)

  const out = []
  const slots = Wear.slots
  const work = []
  let bestspd = 0
  let cnt = 0
  const rec = function (idx) {
    const slot = slots[idx]
    const items = itemsBySlot[slot]
    for (let i = 0; i < items.length; i++) {
      work[idx] = items[i].item_id
      if (idx < 9) {
        rec(idx + 1)
      } else {
        const copy = []
        for (let j = 0; j < work.length; j++) { copy[j] = work[j] }

        const spd = TWDS.bonuscalc.getSpeedFast(copy)
        if (spd > bestspd) {
          bestspd = spd
          for (let j = 0; j < work.length; j++) { out[j] = work[j] }
          console.log('doit3', 'rec', spd, TWDS.describeItemCombo(copy))
        }
        cnt++
        if (cnt % 5000 === 0) {
          console.log('cnt', cnt)
          break
        }
      }
    }
  }
  let p = 1
  for (let i = 0; i < slots.length; i++) {
    const slot = slots[i]
    p *= itemsBySlot[slot].length
  }
  TWDS.bonuscalc.getSpeedFast(true) // init the caches
  console.log('oh, ', p, 'possibilities')
  rec(0)

  console.timeEnd('SpeedCalc3')
  return out
}
TWDS.speedcalc.doit = function (mode, keephp) {
  if (mode === null) mode = 0
  const skills = { ride: 1 }
  const start = (new Date()).getTime()
  console.time('SpeedCalc')

  const curhealth = Character.health
  let healthmult = 10
  if (Character.charClass === 'soldier') {
    healthmult = 15
    if (Premium.hasBonus('character')) { healthmult = 20 }
  }

  const basehealth = (Character.level + 9) * 10 + CharacterSkills.skills.health.points * healthmult
  let needhp = 0
  if (curhealth > basehealth && keephp) {
    needhp = Math.ceil((curhealth - basehealth) / healthmult)
    console.log('cur health', curhealth, 'basehealth', basehealth, 'need points in set', needhp)
  }

  const availableSets = west.item.Calculator.filterUnavailableSets(west.storage.ItemSetManager.getAll())
  const bestItems = TWDS.speedcalc.getBestItems(skills)
  console.log('bestItems', TWDS.describeItemCombo(bestItems))

  let bonusItems = []
  if (mode) {
    bonusItems = TWDS.speedcalc.getBonusItems()
    console.log('#bonusItems-all', bonusItems.length, TWDS.describeItemCombo(bonusItems))
    const merk = {}
    for (let i = 0; i < bonusItems.length; i++) {
      const item = bonusItems[i]
      const tp = item.getType()
      const value = TWDS.speedcalc.getSpeedyValues(item)
      if (!(tp in merk)) {
        merk[tp] = []
      }
      merk[tp].push([value.speedBonus, item])
    }
    for (const tp in merk) {
      const a = merk[tp]
      a.sort(function (a, b) {
        return b[0] - a[0]
      })
    }
    console.log('MERK', merk)
    bonusItems = []
    for (const tp in merk) {
      const limit = (mode === 1) ? 1 : 3
      for (let i = 0; i < merk[tp].length && i < limit; i++) {
        if (i > 0 && merk[tp][i][0] < merk[tp][0][0] * 0.33) { break }
        bonusItems.push(merk[tp][i][1])
      }
    }
    console.log('#bonusItems-filtered', bonusItems.length)
  }

  const bestItemsContainer = new west.item.ItemSetContainer()
  for (let i = 0; i < bestItems.length; i++) { bestItemsContainer.addItem(bestItems[i].getId()) }

  TWDS.dolog('info', 'SpeedCalc: starting mode', mode)
  let m0 = null
  if (window.performance.memory) {
    m0 = window.performance.memory
    TWDS.dolog('info', 'SpeedCalc: totalHeapSize @start', m0.totalJSHeapSize)
    TWDS.dolog('info', 'SpeedCalc: usedHeapSize @start', m0.usedJSHeapSize)
  }

  TWDS.dolog('info', 'SpeedCalc: available sets:', availableSets.length)
  let sets = TWDS.speedcalc.createSubsets(availableSets, bestItems, bonusItems)
  TWDS.dolog('info', 'SpeedCalc: subsets:', sets.length)
  console.log('#sets', sets.length, sets)

  sets = TWDS.speedcalc.filterUneffectiveSets(sets, mode, false)
  TWDS.dolog('info', 'SpeedCalc: filtered sets:', sets.length)
  console.log('#fsets', sets.length, sets)

  sets = west.item.Calculator.combineSets(sets)
  TWDS.dolog('info', 'SpeedCalc: subsets:', sets.length)
  console.log('#csets', sets.length, sets)

  sets = west.item.Calculator.fillEmptySlots(sets, bestItems)
  sets.push(bestItemsContainer)
  TWDS.dolog('info', 'SpeedCalc: filled sets:', sets.length)
  console.log('SpeedCalc: filled sets', sets.length)

  let bestPoints = -1
  let best = null
  for (let i = 0; i < sets.length; i++) {
    if (sets.length > 100000) {
      if ((i % 100000) === 0) {
        console.log('state', i, '/', sets.length)
      }
    }
    const spd = TWDS.speedcalc.calcCombinedSet(sets[i])
    if (spd > bestPoints) {
      const sethp = TWDS.speedcalc.getcombohealthpoints(sets[i])
      if (sethp >= needhp) {
        bestPoints = spd
        best = sets[i]
        /*
        console.log('better:', TWDS.describeItemCombo(TWDS.speedcalc.getItems(sets[i])), sets[i],
          TWDS.speedcalc.getItems(sets[i]), spd)
        */
      /*
      } else {
        console.log('better/nothp:', TWDS.describeItemCombo(TWDS.speedcalc.getItems(sets[i])), sets[i],
          TWDS.speedcalc.getItems(sets[i]), spd, 'hp', sethp, '<', needhp)
      */
      }
    }
  }

  let bi = []
  if (!best) {
    for (let i = 0; i < Wear.slots.length; i++) {
      const sl = Wear.slots[i]
      const it = Wear.get(sl)
      if (it) {
        bi.push(it.obj.item_id)
      }
    }
  } else {
    bi = TWDS.speedcalc.getItems(best)
  }
  console.timeEnd('SpeedCalc')
  const end = (new Date()).getTime()
  if (window.performance.memory) {
    const m1 = window.performance.memory
    TWDS.dolog('info', 'SpeedCalc: totalHeapSize @end', m1.totalJSHeapSize, 'delta', m1.totalJSHeapSize - m0.totalJSHeapSize)
    TWDS.dolog('info', 'SpeedCalc: usedHeapSize @end', m1.usedJSHeapSize, 'delta', m1.usedJSHeapSize - m0.usedJSHeapSize)
  }
  TWDS.dolog('info', 'SpeedCalc: took ' + (end - start) + ' ms')
  // console.log("returning bi",bi);
  return bi
}
TWDS.speedcalc.getcombohealthpoints = function (combo) {
  const itemids = TWDS.speedcalc.getItems(combo)
  const bo = TWDS.bonuscalc.getComboBonus(itemids)
  return (bo.health || 0) + (bo.strength || 0)
}
TWDS.speedcalc.fillempty = function (sets, bestItems, bonusItems) {
  let usedSlots; let container; const pimpedSets = []
  let i; let j
  let did1 = 0; let did2 = 0
  bonusItems.sort(function (a, b) {
    let asb = 0
    let bsb = 0
    if (a._memo && a._memo.TWDSspeedy && a._memo.TWDSspeedy.speedBonus) asb = a._memo.TWDSspeedy.speedBonus
    if (b._memo && b._memo.TWDSspeedy && b._memo.TWDSspeedy.speedBonus) bsb = b._memo.TWDSspeedy.speedBonus
    return bsb - asb
  })
  console.log('SORT', bonusItems)
  console.log('SETS#', sets.length)
  for (let i = 0; i < bonusItems.length; i++) {
    if (usedSlots.indexOf(bestItems[j].getType()) !== -1) continue
  }

  for (i = 0; i < sets.length; i++) {
    usedSlots = sets[i].getUsedSlots()
    console.log('FE', i, sets[i], sets[i].items.length, usedSlots, sets[i].items.length + usedSlots.length)
    container = new west.item.ItemSetContainer(sets[i])
    for (j = 0; j < bestItems.length; j++) {
      if (usedSlots.indexOf(bestItems[j].getType()) !== -1) continue
      container.addItem(bestItems[j].getId())
      if (i === 1) { console.log('PUSH1', bestItems[j]) }
      did1++
    }
    pimpedSets.push(container)
    const container2 = new west.item.ItemSetContainer(sets[i])
    for (j = 0; j < bonusItems.length; j++) {
      const us = container2.getUsedSlots()
      if (us.indexOf(bonusItems[j].getType()) !== -1) continue
      container = new west.item.ItemSetContainer(sets[i])
      container.addItem(bonusItems[j].getId())
      container2.addItem(bonusItems[j].getId())
      pimpedSets.push(container)
      if (i === 1) { console.log('PUSH', bonusItems[j]) }
      did2++
    }
    pimpedSets.push(container2)
    if (i === 1) { console.log('PUSH2', container2) }
  }
  console.log('FE', bonusItems, did1, did2)
  return pimpedSets
}

TWDS.speedcalc.filterUneffectiveSets = function (sets, mode) {
  const r = []
  const bestBySlots = {}
  for (let i = 0; i < sets.length; i++) {
    // setValue = sets[i].getSetValue(skills, jobId);
    const tmp = TWDS.speedcalc.getSetSpeedyValues(sets[i])
    const speed = TWDS.speedcalc.calc3(tmp.speed, tmp.ride, tmp.speedBonus)
    if (speed < 1) { continue }
    const slots = JSON.stringify(sets[i].getUsedSlots().sort())
    if (!bestBySlots[slots]) {
      bestBySlots[slots] = []
    }
    bestBySlots[slots].push([speed, sets[i], tmp.speedBonus])
  }
  for (const sl in bestBySlots) {
    bestBySlots[sl].sort(function (a, b) {
      return b[0] - a[0]
    })
  }
  const limit = (mode === 0) ? 1 : ((mode === 1) ? 2 : 6)

  for (const sl in bestBySlots) {
    const bestspeed = bestBySlots[sl][0]
    let bestbonus = 0
    for (let i = 0; i < bestBySlots[sl].length; i++) {
      if (bestBySlots[sl][i][2] > bestbonus) { bestbonus = bestBySlots[sl][i][2] }
    }
    for (let i = 0; i < bestBySlots[sl].length; i++) {
      if (bestBySlots[sl][i][2] > 0) { // must not throw away anything with a speed bonus that early.
        if (bestBySlots[sl][i][2] > 0.1 * bestbonus) {
          r.push(bestBySlots[sl][i][1])
          continue
        }
      } else if (i < limit || bestBySlots[sl][i][0] > 0.5 * bestspeed) {
        r.push(bestBySlots[sl][i][1])
      }
    }
  }
  return r
}

TWDS.speedcalc.getItems = function (set) {
  const it = []
  for (let i = 0; i < set.items.length; i++) { it.push(set.items[i]) }
  for (const oneset of Object.values(set.sets)) {
    for (let i = 0; i < oneset.items.length; i++) { it.push(oneset.items[i]) }
  }
  return it
}
TWDS.speedcalc.calcSet = function (set) {
  const tmp = TWDS.speedcalc.getSetSpeedyValues(set)
  return TWDS.speedcalc.calc3(tmp.speed, tmp.ride, tmp.speedBonus)
}
TWDS.speedcalc.calcCombinedSet = function (set) {
  const tmp = TWDS.speedcalc.getCombinedSetSpeedyValues(set)
  return TWDS.speedcalc.calc3(tmp.speed, tmp.ride, tmp.speedBonus)
}

TWDS.speedcalc.createCombinations = function (items, k) {
  let i, j, combs, head, tailcombs
  if (k > items.length || k <= 0) {
    return []
  }
  if (k === items.length) {
    return [items]
  }
  if (k === 1) {
    combs = []
    for (i = 0; i < items.length; i++) {
      combs.push([items[i]])
    }
    return combs
  }
  combs = []
  for (i = 0; i < items.length - k + 1; i++) {
    head = items.slice(i, i + 1)
    tailcombs = TWDS.speedcalc.createCombinations(items.slice(i + 1), k - 1)
    for (j = 0; j < tailcombs.length; j++) {
      combs.push(head.concat(tailcombs[j]))
    }
  }
  return combs
}
TWDS.speedcalc.createSubsets = function (fullSets, bestItems, bonusItems) {
  let set
  let permutations
  let tmpSet
  const sets = []
  for (let i = 0; i < fullSets.length; i++) {
    set = fullSets[i]
    if (set.key === 'set_dotd_2015_2_weapon') console.log('HARD', set)
    // sets.push(set)
    for (let j = set.items.length; j > 0; j--) {
      let k, l
      if (!Object.prototype.hasOwnProperty.call(set.bonus, j)) { continue }
      // if (!set.bonus.hasOwnProperty(j)) { continue }
      permutations = TWDS.speedcalc.createCombinations(set.items, j)
      for (k = 0, l = permutations.length; k < l; k++) {
        if (!west.item.Calculator.itemsCombineable(permutations[k])) { continue }
        tmpSet = new west.item.ItemSet({
          key: set.key,
          items: permutations[k],
          bonus: set.bonus
        })
        if (!TWDS.speedcalc.beatsBestItems(tmpSet, bestItems)) { continue }
        sets.push(tmpSet)
        if (set.key === 'set_dotd_2015_2_weapon') console.log('HARD pushed', tmpSet)
      }
    }
  }
  for (let i = 0; i < bonusItems.length; i++) {
    tmpSet = new west.item.ItemSet({
      key: 'BI_' + bonusItems[i].name,
      items: [bonusItems[i].item_id],
      bonus: []
    })
    sets.push(tmpSet)
  }
  return sets
}

TWDS.speedcalc.beatsBestItems = function (set, bestItems, skills, jobId) {
  // find out what the best items give us.
  let bestItemBase = 0
  let bestItemRide = 0
  let bestItemSpeedBonus = 0

  const setSlots = set.getUsedSlots()
  for (let i = 0; i < bestItems.length; i++) {
    if (setSlots.indexOf(bestItems[i].getType()) === -1) { continue }
    const v = TWDS.speedcalc.getSpeedyValues(bestItems[i])
    if (v.speed > bestItemBase) bestItemBase = v.speed
    bestItemRide += v.ride
    bestItemSpeedBonus += v.speedBonus
  }
  const biSpeed = TWDS.speedcalc.calc3(bestItemBase, bestItemRide, bestItemSpeedBonus)
  const setData = TWDS.speedcalc.getSetSpeedyValues(set)
  const setSpeed = TWDS.speedcalc.calc3(setData.speed, setData.ride, setData.speedBonus)
  // console.log("bi values",biSpeed,bestItemBase, bestItemRide, bestItemSpeedBonus)
  // console.log("set values",setSpeed,setData.speed, setData.ride, setData.speedBonus)
  return setSpeed > biSpeed // || setData.speedBonus > bestItemSpeedBonus
}

TWDS.speedcalc.getBonusItems = function () {
  const result = []
  const itemsByBase = Bag.getItemsIdsByBaseItemIds()
  west.common.forEach(itemsByBase, function (items, baseId) {
    const item = ItemManager.get(items[0])
    const value = TWDS.speedcalc.getSpeedyValues(item)
    // take all items with a speed bonus - and all animals, because their base speed without bonus might be faster.
    if ((value.speedBonus || value.speed) && item.wearable()) {
      result.push(item)
    }
  })
  west.common.forEach(Wear.slots, function (sl) {
    const it = Wear.get(sl)
    if (!it) return
    const value = TWDS.speedcalc.getSpeedyValues(it.obj)
    if ((value.speedBonus || value.ride || value.speed) && it.obj.wearable()) {
      result.push(it.obj)
    }
  })
  return result
}

TWDS.speedcalc.getBestItems = function () {
  const bestItems = {}
  const result = []
  const itemsByBase = Bag.getItemsIdsByBaseItemIds()
  west.common.forEach(itemsByBase, function (items, baseId) {
    const item = ItemManager.get(items[0])
    const type = item.getType()
    // const value = item.getValue(skills)
    bestItems[type] = bestItems[type] || []
    const value = TWDS.speedcalc.getSpeedyValues(item)
    if ((value.ride || value.speedBonus || value.speed) && item.wearable()) {
      bestItems[type].push({
        item: item,
        id: item.getId(),
        base_id: baseId,
        value: value
      })
    }
  })
  west.common.forEach(bestItems, function (items, type) {
    let wearItem = Wear.get(type)
    if (wearItem) {
      wearItem = ItemManager.get(wearItem.getId())
      items.push({
        item: wearItem,
        id: wearItem.getId(),
        base_id: wearItem.getItemBaseId(),
        value: TWDS.speedcalc.getSpeedyValues(wearItem)
      })
    }
    // return (100 + 100 * tmp.speed + tmp.ride) * (1 + tmp.speedBonus)
    bestItems[type] = items.sort(function (a, b) {
      const aSpeed = TWDS.speedcalc.calc3(a.value.speed, a.value.ride, a.value.speedBonus)
      const bSpeed = TWDS.speedcalc.calc3(b.value.speed, b.value.ride, b.value.speedBonus)
      return (bSpeed - aSpeed)
    })
    if (bestItems[type].length) {
      console.log('type', type, bestItems[type][0])
      result.push(bestItems[type][0].item)
    }
  })
  return result
}
TWDS.speedcalc.calc3 = function (animalSpeed, ride, speedBonus) {
  const tmp = Math.round(1 / (animalSpeed || 1) * 100 - 100)
  // Math.round(Character.defaultSpeed / (Character.defaultSpeed * 0.28) * 100 - 100)
  const spd = (100 + tmp + ride) * (1 + speedBonus)
  return spd
}

// a modified version of west.item.Item.getValue
// -jobPoints
// +speed bonus
TWDS.speedcalc.getSpeedyValues = function (item) {
  const skills = { ride: 1 }
  let value = 0
  let speedBonus = 0
  const attributes = {}
  let skill
  let attr
  const skillAddition = {}
  let skillArr
  let i
  const memo = 'TWDSspeedy'
  let bonusExtractor
  let affectedSkills

  if (item._memo[memo]) { return item._memo[memo] }

  for (skill in skills) {
    if (!skills[skill]) { continue }
    attr = CharacterSkills.getAttributeKey4Skill(skill)
    attributes[attr] = (attributes[attr] || 0) + 1
  }
  for (attr in item.bonus.attributes) {
    if (!attributes[attr]) { continue }
    skillArr = CharacterSkills.getSkillKeys4Attribute(attr)
    for (i = 0; i < skillArr.length; i++) {
      if (skills[skillArr[i]]) { skillAddition[skillArr[i]] = item.bonus.attributes[attr] }
    }
  }
  if (item.hasItemBonus()) {
    bonusExtractor = new west.item.BonusExtractor(Character, item.getItemLevel())
    for (i = 0; i < item.bonus.item.length; i++) {
      const b = bonusExtractor.getExportValue(item.bonus.item[i])
      if (b.key === 'speed') { speedBonus += b.value }
      affectedSkills = bonusExtractor.getAffectedSkills(item.bonus.item[i])
      for (skill in affectedSkills) {
        if (!(skill in skills)) { continue }
        value += skills[skill] * affectedSkills[skill]
      }
    }
  }
  for (skill in skills) {
    if (item.bonus.skills[skill] || skillAddition[skill]) {
      value += skills[skill] * ((item.bonus.skills[skill] || 0) + (skillAddition[skill] || 0))
    }
  }
  if (item.usebonus || item.action) { value = 0 }
  const out = {
    speed: item.speed !== null ? item.speed : 0,
    ride: value,
    speedBonus: speedBonus
  }
  item._memo[memo] = out
  return out
}

TWDS.speedcalc.getCombinedSetSpeedyValues = function (combo) {
  const boni = {
    speed: 0,
    ride: 0,
    speedBonus: 0
  }
  for (let i = 0; i < combo.sets.length; i++) {
    const v = TWDS.speedcalc.getSetSpeedyValues(combo.sets[i])
    if (v.speed) boni.speed = v.speed
    boni.ride += v.ride
    boni.speedBonus += v.speedBonus
  }
  for (let i = 0; i < combo.items.length; i++) {
    const item = ItemManager.get(combo.items[i])
    const v = TWDS.speedcalc.getSpeedyValues(item)
    if (v.speed) boni.speed = v.speed // this assumes we'll never see a set with two horses...
    boni.ride += v.ride
    boni.speedBonus += v.speedBonus
  }
  return boni
}

TWDS.speedcalc.getSetSpeedyValues = function (set) {
  const boni = {
    speed: 0,
    ride: 0,
    speedBonus: 0
  }
  const v = TWDS.speedcalc.getSetBonusSpeedyValues(set)
  boni.speed = v.speed
  boni.ride = v.ride
  boni.speedBonus = v.speedBonus
  let i
  for (i = 0; i < set.items.length; i++) {
    const item = ItemManager.get(set.items[i])
    const v = TWDS.speedcalc.getSpeedyValues(item)
    if (v.speed) boni.speed = v.speed // this assumes we'll never see a set with two horses...
    boni.ride += v.ride
    boni.speedBonus += v.speedBonus
  }
  return boni
}
TWDS.speedcalc.getSetBonusSpeedyValues = function (set) {
  const boni = {
    speed: 0, // stays that way
    ride: 0,
    speedBonus: 0
  }
  const bonus = set.getMergedBonus()
  const memo = 'speedy'
  // console.log("merge",set,bonus)

  if (!('_memo' in set)) set._memo = {} // this happens for merged sets.

  if (set._memo[memo]) { return set._memo[memo] }
  if (bonus.skill.ride) { boni.ride += bonus.skill.ride }
  const attr = CharacterSkills.getAttributeKey4Skill('ride')
  if (bonus.attribute[attr]) { boni.ride += bonus.attribute[attr] }
  boni.speedBonus = bonus.speed
  set._memo[memo] = boni
  return boni
}
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.marketwindow = {}
TWDS.marketwindow.item = null
TWDS.marketwindow.bulkmodeactive = false
TWDS.marketwindow.bulkmodetimeout = -1
TWDS.marketwindow.createMarketOffer = function (source) {
  // MarketWindow._TWDS_backup_createMarketOffer.apply(this, arguments)
  MarketWindow._TWDS_backup_createMarketOffer(source)
  const itemid = (typeof source === 'number' ? source : $(source).data('itemId'))
  console.log('createMarketWindow this', this, 'source', source, '#', itemid)
  TWDS.marketwindow.item = ItemManager.get(itemid)
}
TWDS.marketwindow.enhanceit = function (thing) {
  thing.divMain[0].classList.add('TWDS_enhanced') // for utils.js
  const te = TWDS.q1('.tw2gui_inner_window_title .textart_title', thing.divMain)
  if (te) {
    te.textContent = TWDS.marketwindow.item.name
  }

  // description.
  const savedesc = TWDS.createElement('div', {
    className: 'tw2gui-iconset tw2gui-icon-save TWDS_marketwindow_save',
    title: TWDS._('AUCTION_SAVE_FOR_FUTURE_SALES', 'Guardar para futuras ventas.'),
    dataset: {
      sel: '#auction_description',
      name: 'TWDS_marketwindow_description'
    },
    style: {
      display: 'inline-block'
    }
  })
  document.querySelector('#auction_description').parentNode.appendChild(savedesc)
  if (window.localStorage.TWDS_marketwindow_description !== null) {
    $('#auction_description').val(window.localStorage.TWDS_marketwindow_description)
  }

  // min and max price handling
  const makeit = function (name) {
    const cur = window.localStorage['TWDS_marketwindow_' + name] || ''
    const t = TWDS.createEle('select', {
      id: 'TWDS_marketwindow_select_base_' + name,
      title: TWDS._('AUCTION_SAVE_FOR_FUTURE_SALES', 'Guardar para futuras ventas.'),
      style: {
        backgroundColor: 'gainsboro',
        borderColor: 'dimgray'
      },
      children: [
        {
          nodeName: 'option',
          textContent: '---',
          value: '',
          selected: cur === ''
        },
        {
          nodeName: 'option',
          value: 'min',
          textContent: TWDS._('AUCTION_PRICE_MINIMUM', 'Precio mínimo'),
          selected: cur === 'min'
        },
        {
          nodeName: 'option',
          textContent: TWDS._('AUCTION_PRICE_REGULAR', 'Regular'),
          value: 'regular',
          selected: cur === 'regular'
        }
      ]
    })
    return t
  }
  const minpricesel = makeit('min')
  const maxpricesel = makeit('max')

  const pricerow = TWDS.createEle('tr', {
    children: [
      {
        nodeName: 'td',
        colSpan: '2',
        style: {
          textAlign: 'right'
        },
        children: [minpricesel,
          {
            nodeName: 'div',
            className: 'tw2gui-iconset tw2gui-icon-save TWDS_marketwindow_save',
            id: 'TWDS_marketwindow_save_base_min',
            title: TWDS._('AUCTION_SAVE_FOR_FUTURE_SALES', 'Guardar para futuras ventas.'),
            dataset: {
              sel: '#TWDS_marketwindow_select_base_min',
              name: 'TWDS_marketwindow_min'
            },
            style: {
              display: 'inline-block'
            }
          }]
      },
      {
        nodeName: 'td',
        colSpan: '2',
        style: {
          textAlign: 'right'
        },
        children: [maxpricesel,
          {
            nodeName: 'div',
            className: 'tw2gui-iconset tw2gui-icon-save TWDS_marketwindow_save',
            id: 'TWDS_marketwindow_save_base_max',
            title: TWDS._('AUCTION_SAVE_FOR_FUTURE_SALES', 'Guardar para futuras ventas.'),
            dataset: {
              sel: '#TWDS_marketwindow_select_base_max',
              name: 'TWDS_marketwindow_max'
            },
            style: {
              display: 'inline-block'
            }
          }]
      }
    ]
  })
  const table = document.querySelector('#market_min_bid').closest('table')
  table.insertBefore(pricerow, table.firstChild)
  const changebaseprice = function (ele, target) {
    const v = ele.value
    if (v === '') { document.querySelector(target).value = '' }
    if (v === 'min') { document.querySelector(target).value = TWDS.marketwindow.item.sell_price || Math.round(TWDS.marketwindow.item.price / 2) }
    if (v === 'regular') { document.querySelector(target).value = TWDS.marketwindow.item.price || 1 }
  }
  document.querySelector('#TWDS_marketwindow_select_base_min').onchange = function () {
    changebaseprice(this, '#market_min_bid')
    $('#market_min_bid').change()
    $('#market_min_bid').keyup()
  }
  document.querySelector('#TWDS_marketwindow_select_base_max').onchange = function () {
    changebaseprice(this, '#market_max_price')
    $('#market_max_price').change()
    $('#market_max_price').keyup()
  }

  const mindefault = window.localStorage.TWDS_marketwindow_min || ''
  const maxdefault = window.localStorage.TWDS_marketwindow_max || ''
  let e = $('#market_min_bid', thing.divMain)
  if (e.length) {
    e[0].type = 'number'
    if (mindefault === 'min') {
      e[0].value = TWDS.marketwindow.item.sell_price || Math.round(TWDS.marketwindow.item.price / 2)
      e.change()
    }
    if (mindefault === 'regular') {
      e[0].value = TWDS.marketwindow.item.price || 1
      e.change()
    }
  }
  e = $('#market_max_price', thing.divMain)
  if (e.length) {
    e[0].type = 'number'
    if (maxdefault === 'min') {
      e[0].value = TWDS.marketwindow.item.sell_price || Math.round(TWDS.marketwindow.item.price / 2)
      e.change()
    }
    if (maxdefault === 'regular') {
      e[0].value = TWDS.marketwindow.item.price || 1
      e.change()
    }
  }

  e = $('#market_sell_itemStack', thing.divMain)
  if (e.length) {
    e[0].type = 'number'
    e[0].min = 1

    e[0].max = Bag.getItemByItemId(TWDS.marketwindow.item.item_id).count

    const x = TWDS.createElement('input', {
      type: 'checkbox',
      id: 'TWDS_marketwindow_multiplier',
      value: 1,
      checked: false,
      style: {
        backgroundImage: 'url(/images/ranking/town_ranking_icons.png)',
        display: 'inline-block',
        height: '16px',
        width: '16px',
        backgroundPosition: '0px -80px',
        cursor: 'pointer',
        appearance: 'none'
      }
    })
    x.onclick = function () {
      this.checked = false
      const stack = document.querySelector('#market_sell_itemStack')
      const count = stack.value
      const max = document.querySelector('#market_max_price')
      if (max && parseInt(max.value) > 0) {
        max.value = max.value * count
        $(max).keyup()
      }
      const min = document.querySelector('#market_min_bid')
      if (min && parseInt(min.value.trim()) > 0) {
        min.value = min.value * count
        $(min).keyup()
      }
    }
    e[0].parentNode.parentNode.appendChild(x)
  }
  e = $('#market_sell_itemAuctions', thing.divMain)
  if (e.length) {
    e[0].type = 'number'
    e[0].min = 1
    e[0].max = Bag.getItemByItemId(TWDS.marketwindow.item.item_id).count
  }

  // bulk mode
  const h4 = TWDS.q1('#market_createoffer_window .txcenter > span')
  if (h4) {
    const prev = h4.previousSibling
    if (prev.nodeType === 1 && prev.nodeName === 'BR') {
      prev.remove()
    }
    TWDS.createEle({
      nodeName: 'div',
      beforebegin: h4,
      className: 'TWDS_market_bulkmode_container ' + (TWDS.marketwindow.bulkmodeactive ? 'TWDS_market_bulkmode_active' : ''),
      children: [
        {
          nodeName: 'input',
          type: 'checkbox',
          checked: TWDS.marketwindow.bulkmodeactive,
          onchange: function (x) {
            TWDS.marketwindow.bulkmodeactive = this.checked
            if (this.checked) {
              this.parentNode.classList.add('TWDS_market_bulkmode_active')
            } else {
              this.parentNode.classList.remove('TWDS_market_bulkmode_active')
              TWDS.marketwindow.bulkmodetimeoutfn()
            }
          },
          id: 'TWDS_market_bulkmode_input'
        }, {
          nodeName: 'b',
          textContent: TWDS._('MARKETWINDOW_BULKMODE', 'modo masivo')
        }
      ]
    })
  }
  const oo = document.querySelector('#mps_otheroffers')
  if (oo) {
    const p = oo.parentNode
    if (!TWDS.settings.market_bulkmode_help_read) {
      TWDS.createEle({
        nodeName: 'div',
        className: 'TWDS_market_bulkmode_help',
        last: p,
        style: { border: '1px solid #000' },
        children: [
          {
            nodeName: 'div',
            innerHTML: TWDS._('MARKETWINDOW_BULKMODE_HELP', 'modo masivo: el inventario y la lista de ventas se actualizarán después de una pausa de algunos segundos.<br>Esto reduce seriamente la cantidad de rachas de eventos de mala suerte.')
          },
          {
            nodeName: 'button',
            textContent: TWDS._('MARKETWINDOW_BULKMODE_READ', 'lea y comprenda, ahora elimine el texto de ayuda'),
            onclick: function () {
              this.closest('.TWDS_market_bulkmode_help').remove()
              TWDS.settings.market_bulkmode_help_read = true
              TWDS.saveSettings()
            }
          }
        ]
      })
    }
  }
  // +1/2 feature
  const mmb = document.querySelector('#market_min_bid')
  if (mmb) {
    const tr = mmb.closest('tr')
    const addfn = function (mod, ele) {
      console.log('ADD', mod, ele, ele.value)
      ele.value = ele.value * (1.0 + parseFloat(mod))
      $(ele).trigger('change')
      console.log('ADD-END', mod, ele, ele.value)
    }
    const addfn1 = function () {
      const i = TWDS.q1('#market_min_bid')
      if (i) {
        addfn(this.dataset.mod, i)
      }
    }
    const addfn2 = function () {
      const i = TWDS.q1('#market_max_price')
      if (i) {
        addfn(this.dataset.mod, i)
      }
    }
    TWDS.createEle({
      after: tr,
      nodeName: 'tr',
      className: 'TWDS_surcharge_line',
      children: [
        { nodeName: 'td', textContent: TWDS._('MARKETWINDOW_SURCHARGE', 'Recargo:') },
        {
          nodeName: 'td',
          children: [
            { nodeName: 'span', textContent: '+100%', dataset: { mod: 1 }, onclick: addfn1 },
            { nodeName: 'span', textContent: '+200%', dataset: { mod: 2 }, onclick: addfn1 }
          ]
        },
        { nodeName: 'td', textContent: '' },
        {
          nodeName: 'td',
          children: [
            { nodeName: 'span', textContent: '+50%', dataset: { mod: 0.5 }, onclick: addfn2 },
            { nodeName: 'span', textContent: '+100%', dataset: { mod: 1 }, onclick: addfn2 }
          ]
        }
      ]
    })
  }

  // save button: auction length
  const savedays = TWDS.createElement('div', {
    id: 'TWDS_marketwindow_save_days',
    className: 'tw2gui-iconset tw2gui-icon-save TWDS_marketwindow_save',
    title: TWDS._('AUCTION_SAVE_FOR_FUTURE_SALES', 'Guardar para futuras ventas'),
    style: {
      cursor: 'pointer',
      display: 'inline-block'
    },
    dataset: {
      sel: '#market_days_value',
      name: 'TWDS_marketwindow_days'
    }
  })
  document.querySelector('#msd_days').appendChild(savedays)
  if (window.localStorage.TWDS_marketwindow_days !== null) {
    const t = window.localStorage.TWDS_marketwindow_days
    console.log('T', t, t || 1)
    $('#market_days').guiElement().select(t || 1)
  }

  // save button: auction rights
  const saverights = TWDS.createElement('div', {
    id: 'TWDS_marketwindow_save_rights',
    className: 'tw2gui-iconset tw2gui-icon-save TWDS_marketwindow_save',
    title: TWDS._('AUCTION_SAVE_FOR_FUTURE_SALES', 'Guardar para futuras ventas'),
    style: {
      cursor: 'pointer',
      display: 'inline-block'
    },
    dataset: {
      sel: '#market_rights_value',
      name: 'TWDS_marketwindow_rights'
    }
  })
  const r = document.querySelector('#msd_rights')
  if (r) {
    document.querySelector('#msd_rights').appendChild(saverights)
    if (window.localStorage.TWDS_marketwindow_rights !== null) {
      const t = window.localStorage.TWDS_marketwindow_rights
      console.log('changing rights', t, typeof t)
      $('#market_rights').guiElement().select(t)
    }
    const items = $('span#market_rights.tw2gui_combobox', r).guiElement().items
    if (items.length === 3) {
      const modes = ['home', 'flag', 'world']
      for (let i = 0; i < items.length; i++) {
        items[i].node[0].innerHTML = '<span class="tw2gui-iconset tw2gui-icon-' +
            modes[items[i].value] +
            '" style="display: inline-block;position: relative;top: 4px;"></span>&nbsp;' +
            items[i].node[0].innerHTML
      }
      const ve = TWDS.q1('#market_rights_value')
      if (ve) {
        const v = parseInt(ve.value)
        for (let i = 0; i < items.length; i++) {
          if (items[i].value === v) {
            const str = items[i].node[0].innerHTML
            const te = TWDS.q1('#market_rights .tw2gui_combobox_text span')
            te.innerHTML = str
          }
        }
      }
    }
  }

  $('.TWDS_marketwindow_save').on('click', function () {
    const sel = this.dataset.sel
    const name = this.dataset.name
    window.localStorage[name] = document.querySelector(sel).value;
    (new UserMessage(TWDS._('AUCTION_DATA_SAVED', 'guardado'), UserMessage.TYPE_SUCCESS)).show()
  })
  $('#market_min_bid').trigger('keyup')

  // remove TWDB stuff if active
  window.setTimeout(function () { // why does clothcalc does that?
    const ele = document.querySelector('#twdb_msd_mult_cc')
    if (ele) ele.remove()
  }, 75)
}

TWDS.marketwindow.showwrapper = function () {
  const thing = this._TWDS_marketwindow_backup_show()
  if (TWDS.settings.marketwindow_enhancements) {
    if (this.divMain.attr('id') === 'market_createoffer_window') {
      window.setTimeout(function () { // why does clothcalc does that?
        TWDS.marketwindow.enhanceit(thing)
      }, 25)
    }
  }
  return thing
}

TWDS.marketwindow.hasBonus = function (item) {
  const bonusExtractor = new west.item.BonusExtractor(Character, item.getItemLevel())

  let fbs = item.bonus.fortbattle
  if (fbs.offense || fbs.defense || fbs.resistance) {
    return true
  }
  fbs = item.bonus.fortbattlesector
  if (fbs.damage || fbs.offense || fbs.defense) {
    return true
  }
  for (let k = 0; k < item.bonus.item.length; k++) {
    if (typeof item.bonus.item[k] === 'undefined') continue
    if (item.bonus.item[k].type === 'character') continue
    if (item.bonus.item[k].type === 'fortbattle') {
      if (bonusExtractor.getValue(item.bonus.item[k]) > 0) return true
      continue
    }
    const bt = item.bonus.item[k].type
    if (['speed', 'regen', 'luck', 'pray', 'experience', 'dollar', 'damage', 'drop'].indexOf(bt) !== -1) {
      if (bonusExtractor.getValue(item.bonus.item[k]) > 0) return true
    }
  }
  if (item.usebonus && item.usebonus.length) {
    return true
  }
  return false
}

TWDS.marketwindow.filtermode = 'none'
TWDS.marketwindow.filter = function (mode, cat) {
  console.time('FILTER')
  console.log('FILTERING', mode, cat)
  const p = $('#mpb_' + cat + '_content p')
  p.show()
  if (mode === 'none') {
    console.timeEnd('FILTER')
    return
  }

  for (let i = 0; i < TWDS.marketwindow[cat].length; i++) {
    const item = ItemManager.get(TWDS.marketwindow[cat][i])
    if (!item) { // ECANTHAPPEN
      $(p[i]).hide()
      continue
    }
    // if the thing has a usebonus, then it has to match that bonus or "bonus".
    if (item.usebonus) {
      if (mode !== 'missing') {
        if (mode === 'bonus') continue
        if (!TWDS.quickusables.match(item, mode)) {
          $(p[i]).hide()
        }
        continue
      }
    }
    if (mode === 'bonus') {
      if (!TWDS.marketwindow.hasBonus(item)) { $(p[i]).hide() }
    } else if (mode === 'set') {
      if (!item.set) { $(p[i]).hide() }
    } else if (mode === 'noset') {
      if (item.set) { $(p[i]).hide() }
    } else if (mode === 'craft') {
      if (!(item.item_id in TWDS.crafting.mycraftresources)) {
        $(p[i]).hide()
      }
    } else if (mode === 'collect') {
      if (!TWDS.collections.isMissing(item.item_id)) {
        $(p[i]).hide()
      }
    } else if (mode === 'missing') {
      const x = Bag.getItemsByBaseItemId(item.item_base_id)
      if (x.length) {
        $(p[i]).hide()
      }
    } else {
      $(p[i]).hide()
    }
  }
  console.timeEnd('FILTER')
}
TWDS.marketwindow.handleFilterChange = function () {
  const x = document.querySelector('#mpb_marketoffers .tw2gui_accordion_categorybar.accordion_opened')
  if (!x) return
  const id = x.id
  const m = id.match(/^mpb_(.*)/)
  let combo = document.getElementById('TWDS_marketwindow_filters_value')
  if (combo && m) {
    const col1 = document.getElementById('buyFilterIsCollect')
    const col2 = document.getElementById('buyFilterIsCollect2')
    if (col1) col1.guiElement.setSelected(false, true)
    if (col2) col2.guiElement.setSelected(false, true)
    let e = TWDS.q1('#buyFilterIsCollect')
    if (e) e.style.display = 'none'
    e = TWDS.q1('#buyFilterIsCollect2')
    if (e) e.style.display = 'none'
    combo = combo.value
    TWDS.marketwindow.filtermode = combo
    TWDS.marketwindow.filter(combo, m[1])
  }
}
TWDS.marketwindow.updateCategory = function (category, data) {
  return TWDS.marketwindow.updateCategoryReal(category, data)
}
TWDS.marketwindow.updateCategoryReal = function (category, data) {
  TWDS.marketwindow[category] = data
  console.log('updateCategory-2', category, data)
  const old = document.getElementById('TWDS_marketwindow_filters')
  if (!old) {
    const combo = new west.gui.Combobox('TWDS_marketwindow_filters')
    combo.addItem('none', TWDS._('MARKETWINDOW_FILTER_NONE', 'none'))
    combo.addItem('bonus', TWDS._('MARKETWINDOW_FILTER_BONUS', 'bonus equipment'))
    combo.addItem('set', TWDS._('MARKETWINDOW_FILTER_SET', 'set items'))
    combo.addItem('noset', TWDS._('MARKETWINDOW_FILTER_NOSET', 'items without set '))
    combo.addItem('collect', TWDS._('MARKETWINDOW_FILTER_COLLECT', 'collect'))
    combo.addItem('craft', TWDS._('MARKETWINDOW_FILTER_CRAFT', 'crafting'))
    combo.addItem('missing', TWDS._('MARKETWINDOW_FILTER_MISSING', 'missing'))
    const qc = TWDS.quickusables.getcategories(1) // kind 1: market
    for (let i = 0; i < qc.length; i++) {
      combo.addItem(qc[i], TWDS.quickusables.getcatdesc(qc[i]))
    }
    combo.addListener(TWDS.marketwindow.handleFilterChange)

    const sb = document.querySelector('.market-buy .searchbox')
    sb.appendChild(combo.divMain[0])
    sb.style.marginTop = '-5px'
    combo.select('none')
    /*
    let chb = new west.gui.Checkbox("bonus only", false, TWDS.market.handleFilter)
    chb.setSelected(false);
    chb.setId('TWDS_market_bonusfilter_chb');
    chb.setTooltip('filter for special bonus');
    old=chb.getMainDiv()[0]
    */
  }
  const ret = MarketWindow.Buy._TWDS_backup_updateCategory(category, data)
  if (old) {
    TWDS.marketwindow.filter(TWDS.marketwindow.filtermode, category)
  }
  const x = TWDS.q('#mpb_' + category + '_content .tw2gui_scrollpane_clipper_contentpane p')
  if (x && x.length === data.length) {
    for (let i = 0; i < data.length; i++) {
      const ii = data[i]
      const c = Bag.getItemCount(ii)
      x[i].dataset.bagitemcount = c
      if (TWDS.storage.isMissing(ii)) {
        const si = TWDS.storage.iteminfo(ii)
        x[i].classList.add('TWDS_storage_missing')
        x[i].dataset.want = si[0]
        x[i].dataset.have = si[1]
      }
      if (TWDS.collections.isMissing(ii)) {
        x[i].classList.add('TWDS_collection_missing')
      }
      /*
      const d = TWDS.items.data[ii]
      if (d) {
        if (d.time) {
          let border=300*d.time*60;
        }
        x[i].classList.add('TWDS_collection_missing')
      }
      */
      // x[i].textContent+= " ["+c+"]";
    }
  }
  return ret
}
TWDS.marketwindow.buyupdateTable = function (data) {
  return TWDS.marketwindow.buyupdateTableReal(data)
}
TWDS.marketwindow.buyupdateTableReal = function (data) {
  console.log('data is', data)
  const ret = MarketWindow.Buy._TWDS_backup_updateTable(data)
  console.log('orig returned', ret)
  const tab = MarketWindow.buyTable.getMainDiv()[0]
  for (let i = 0; i < data.length; i++) {
    const offer = data[i]
    const moid = offer.market_offer_id
    const ii = offer.item_id
    const sp = offer.singleMaxPrice

    //    let x= e(MarketWindow.offerTable.getMainDiv()).children().find(".marketBidsData_" + r.market_offer_id).append(i);
    const x = TWDS.q1('.marketOffersData_' + moid + ' .mpb_buynow span', tab)
    if (!x) continue
    const d = TWDS.items.data[ii]
    if (d && sp) {
      if (d.time) {
        const g = parseFloat(TWDS.settings.market_buy_perhour_green) || 1500.0
        const b = parseFloat(TWDS.settings.market_buy_perhour_blue) || 2000.0
        const r = parseFloat(TWDS.settings.market_buy_perhour_red) || 2500.0
        const perhour = sp / (d.time)
        x.title = '$' + sp + '/unit, $' + perhour.toFixed(1) + '/h'
        if (r || g || b) {
          if (g && perhour < g) {
            x.classList.add('TWDS_market_buy_green')
          } else if (b && perhour < b) {
            x.classList.add('TWDS_market_buy_blue')
          } else if (r && perhour > r) {
            x.classList.add('TWDS_market_buy_red')
          }
        }
      }
    }
  }
  /*
for (var n = 0; n < da.length; n++) {
var r = t[n];
var i = e('<div class="mpo_alert" />');
e(MarketWindow.offerTable.getMainDiv()).children().find(".marketBidsData_" + r.market_offer_id).append(i);
if (!r.isFinished) {
              i.append(f(r))
          }
}

  MarketWindow.Buy._TWDS_backup_updateCategory = MarketWindow.Buy.updateCategory
  */
  return ret
}
TWDS.marketwindow.sellupdateTableReal = function (data) {
  console.log('SELL', 'data', data)
  const ret = MarketWindow.Sell._TWDS_backup_updateTable(data)
  console.log('SELL', 'ret', ret)
  const stat = {
    num_sold: 0,
    num_bid: 0,
    num_unbid: 0,
    dollar_sold: 0,
    dollar_bid: 0,
    dollar_unbid: 0
  }
  for (let i = 0; i < data.length; i++) {
    const d = data[i]
    const id = d.item_id
    const it = ItemManager.get(id)
    const bidder = d.bidder_player_id
    if (bidder) {
      if (d.auction_ends_in) {
        stat.num_bid++
        stat.dollar_bid += d.current_bid
      } else {
        stat.num_sold++
        stat.dollar_sold += d.current_bid
      }
    } else {
      stat.num_unbid++
      if (it.sellable) {
        stat.dollar_unbid += it.sell_price * d.item_count
      }
    }
  }
  console.log('posten: ', data.length)
  console.log('mit gebot: ', stat.w_bid)
  console.log('ohne gebot: ', stat.wo_bid)
  console.log('summe gebote: ', stat.dollar_bid)
  console.log('summe rest: ', stat.dollar_unsold)
  console.log('this', this, MarketWindow)
  // paranoia?
  if (TWDS.settings.market_sellstat && data.length) {
    if (MarketWindow && MarketWindow.sellTable && MarketWindow.sellTable.divMain && MarketWindow.sellTable.divMain[0]) {
      const rf = TWDS.q1('.row_foot', MarketWindow.sellTable.divMain[0])
      if (rf) {
        let ss = TWDS.q1('.TWDS_sellstat', rf)
        if (!ss) {
          for (let i = 0; i < 8; i++) {
            const t = TWDS.q1('.cell_' + i, rf)
            if (t) t.remove()
          }
          ss = TWDS.createEle({
            nodeName: 'div.cell_0.TWDS_sellstat',
            colSpan: 8,
            first: rf
          })
        }
        ss.textContent = TWDS._('MARKETWINDOW_SELLSTAT',
          '$entries$ entries. $num_sold$ sold, $num_bid$ w/ bid, $num_unbid$ w/o bid. $$dollar_sold$ sold, $$dollar_bid$ bids, $$dollar_unbid$ rest.', {
            entries: data.length,
            num_sold: stat.num_sold,
            num_bid: stat.num_bid,
            num_unbid: stat.num_unbid,
            dollar_sold: stat.dollar_sold,
            dollar_bid: stat.dollar_bid,
            dollar_unbid: stat.dollar_unbid
          }
        )
      }
    }
  }
  return ret
}
TWDS.marketwindow.sellupdateTable = function (data) {
  return TWDS.marketwindow.sellupdateTableReal(data)
}

TWDS.registerStartFunc(function () {
  MarketWindow.Buy._TWDS_backup_updateCategory = MarketWindow.Buy.updateCategory
  MarketWindow.Buy.updateCategory = TWDS.marketwindow.updateCategory
  MarketWindow.Buy._TWDS_backup_updateTable = MarketWindow.Buy.updateTable
  MarketWindow.Buy.updateTable = TWDS.marketwindow.buyupdateTable
  MarketWindow.Sell._TWDS_backup_updateTable = MarketWindow.Sell.updateTable
  MarketWindow.Sell.updateTable = TWDS.marketwindow.sellupdateTable
  TWDS.registerSetting('int', 'market_buy_perhour_green',
    'Marcar oferta en verde si un artículo cuesta menos de ... dólares por hora de tiempo base de recolección.',
    0, null, 'Mercado')
  TWDS.registerSetting('int', 'market_buy_perhour_blue',
    'Marcar oferta en azul si un artículo cuesta menos de ... dólares por hora de tiempo base de recolección.',
    0, null, 'Mercado')
  TWDS.registerSetting('int', 'market_buy_perhour_red',
    'Marcar oferta en rojo si un artículo cuesta más de ... dólares por hora de tiempo base de recolección.',
    0, null, 'Mercado')
  TWDS.registerSetting('bool', 'market_sellstat',
    'Agregar una estadística a la ventana de venta.',
    true, null, 'Mercado')
})

TWDS.trader = {}
TWDS.trader.currenttrader = null
TWDS.trader.inventory = []
TWDS.trader.open = function (type, townid, coordX, coordY) {
  TWDS.trader.currenttrader = type
  TWDS.trader.inventory = []
  const retcode = window.Trader._twds_backup_open(type, townid, coordX, coordY)
  if (type !== 'general' && type !== 'gunsmith' && type !== 'tailor') {
    return retcode
  }
  const w = wman.getById(type)
  if (!w) {
    return retcode
  }
  const cp = TWDS.q1('.tw2gui_window_content_pane', w.divMain)
  console.log('ts', cp)
  if (cp) {
    if (TWDS.settings.town_shop_collect_switch) {
      TWDS.createEle({
        nodeName: 'input',
        className: 'TWDS_trader_filter_collectibles',
        type: 'checkbox',
        title: TWDS._('MARKET_TOWN_SHOP_FILTER_COLLECTIBLES', 'mostrar solo coleccionables'),
        beforeend: cp
      })
    }
    if (TWDS.settings.town_shop_search) {
      TWDS.createEle({
        nodeName: 'input',
        className: 'TWDS_trader_town_shop_search',
        type: 'text',
        title: TWDS._('MARKET_TOWN_SHOP_SEARCH', 'Buscar'),
        placeholder: 'search',
        beforeend: cp
      })
    }
  }
  return retcode
}

TWDS.trader.addItemToInv = function (itemid) {
  TWDS.trader.inventory.push(itemid)
  window.Trader._twds_backup_addItemToInv(itemid)
}
TWDS.trader.filterchange = function () {
  const search = TWDS.q1('.TWDS_trader_town_shop_search')
  let searchstr
  if (search) { searchstr = search.value.toLocaleLowerCase() }
  const col = TWDS.q1('.TWDS_trader_filter_collectibles')
  let checked = false
  if (col) { checked = col.checked }
  window.Trader.inv = {} // no other way to do it.
  for (let i = 0; i < TWDS.trader.inventory.length; i++) {
    const itemid = TWDS.trader.inventory[i]
    if (searchstr > '') {
      const it = ItemManager.get(itemid)
      if (it.name.toLocaleLowerCase().search(searchstr) === -1) { continue }
    }
    if (!checked || !TWDS.collections.loaded) {
      window.Trader._twds_backup_addItemToInv(itemid)
    } else {
      if (TWDS.collections.isMissing(itemid)) {
        window.Trader._twds_backup_addItemToInv(itemid)
      }
    }
  }
  window.Trader.drawInventory(1)
}

TWDS.registerSetting('bool', 'marketwindow_enhancements',
  TWDS._('AUCTION_SETTING', 'Mejorar la ventana de ofertas.'),
  false, null, 'Mercado')
TWDS.registerSetting('bool', 'saleProtection',
  TWDS._('CLOTHCACHE_PROTECT', 'Marcar los mejores artículos para cualquier trabajo y los artículos para los equipos administrados (juego, tw-calc, ' + TWDS.scriptname + ') como no vendibles ni subastables. Después de los cambios, se necesita recargar la página.'),
  true, null, 'Mercado')
TWDS.marketwindow.offersend = function (obj) {
  if (!TWDS.marketwindow.bulkmodeactive) {
    MarketWindow.Offer._TWDS_backup_send(obj)
    return
  }
  const params = obj
  Ajax.remoteCall('building_market', 'putup', params, function (resp) {
    if (resp.error) { return new UserMessage(resp.msg).show() } else {
      Character.setMoney(resp.msg.money)
      Character.setDeposit(resp.msg.deposit)
      new UserMessage(
        TWDS._('MARKETWINDOW_OFFERED_MSG', 'Los bienes se ofrecen a la venta; la tarifa es $ $fee$', { fee: resp.msg.costs }), UserMessage.TYPE_SUCCESS).show()
      clearTimeout(TWDS.marketwindow.bulkmodetimeout)
      TWDS.marketwindow.bulkmodetimeout = setTimeout(TWDS.marketwindow.bulkmodetimeoutfn, 8 * 1000)
    }
  }, MarketWindow)
}
TWDS.marketwindow.bulkmodetimeoutfn = function () {
  clearTimeout(TWDS.marketwindow.bulkmodetimeout)
  TWDS.marketwindow.bulkmodetimeout = -1
  EventHandler.signal('inventory_changed')
  MarketWindow.Sell.initData()
}
TWDS.marketwindow.fillmap3 = function (map, table, all) {
  window.MarketWindow.window.hideLoader()
  const additem = function (pa, it, count, fini, withpopup) {
    if (typeof it === 'number' || typeof it === 'string') {
      it = ItemManager.get(it)
    }
    let popup = it.name
    if (withpopup) { popup = new ItemPopup(it, {}).popup.getXHTML() }
    TWDS.createEle({
      nodeName: 'div.item.item_inventory',
      last: pa,
      style: {
        opacity: fini ? 1.0 : 0.65
      },
      childNodes: [
        {
          nodeName: 'img',
          className: 'tw_item item_inventory_img dnd_draggable dnd_dragElem',
          src: it.image,
          alt: it.name,
          title: popup
        },
        {
          nodeName: 'span.count',
          textContent: count,
          style: {
            display: 'block'
          }
        }
      ]
    })
  }

  const towns = []
  for (const town of Object.values(all)) {
    const wt = window.Map.calcWayTime(window.Character.position, { x: town.x, y: town.y })
    town.wt = wt
    town.wtf = wt.formatDuration()
    towns.push(town)
  }
  towns.sort(function (a, b) {
    return a.wt - b.wt
  })
  for (let idx = 0; idx < towns.length; idx++) {
    const town = towns[idx]

    let allfinished = 0
    for (let i = 0; i < town.sales.length; i++) {
      allfinished |= town.sales[i].finished
    }
    for (let i = 0; i < town.bids.length; i++) {
      allfinished |= town.bids[i].finished
    }

    let r = 0
    let g = 0
    if (town.bids.length) r = 10
    if (town.sales.length) g = 10
    if (allfinished) {
      r *= 1.5
      g *= 1.5
    }
    let color = '#'
    color += r.toString(16)
    color += g.toString(16)
    color += '0'

    const ti = TWDS.createEle('div.TWDS_marketmap_town')
    TWDS.createEle('b', {
      textContent: town.name,
      last: ti
    })
    if (town.bids.length) {
      const be = TWDS.createEle('div.bids', { last: ti })
      for (let j = 0; j < 2; j++) {
        for (let i = 0; i < town.bids.length; i++) {
          const b = town.bids[i]
          if ((b.finished && j === 0) || (!b.finished && j > 0)) {
            additem(be, b.item_id, b.item_count, j === 0, false)
          }
        }
      }
    }
    let sold = 0
    let solditems = 0
    let unsold = 0
    let unsolditems = 0
    let openwith = 0
    let openwithitems = 0
    let openwithout = 0
    let openwithoutitems = 0
    let money = 0
    let saleinfo = ''

    if (town.sales.length) {
      for (let i = 0; i < town.sales.length; i++) {
        const b = town.sales[i]
        if (b.finished) {
          if (b.current_bid === b.max_price) {
            sold++
            solditems += b.item_count
            money += b.current_bid
          } else {
            unsold++
            unsolditems += b.item_count
          }
        } else {
          if (b.current_bid) {
            openwith++
            openwithitems += b.item_count
          } else {
            openwithout++
            openwithoutitems += b.item_count
          }
        }
      }
      if (money) {
        saleinfo += TWDS._('MARKETMAP_SALEINFO_SOLD',
          '$$money$ para $offers$ ventas de $items$ artículos.',
          { money: money, offers: sold, items: solditems })
      }
      if (unsold) {
        if (saleinfo !== '') { saleinfo += ' ' }
        saleinfo += TWDS._('MARKETMAP_SALEINFO_UNSOLD',
          '$offers$ ofertas con $items$ artículos.',
          { offers: unsold, items: unsolditems })
      }
      if (openwith) {
        if (saleinfo !== '') { saleinfo += ' ' }
        saleinfo += TWDS._('MARKETMAP_SALEINFO_OPENWITH',
          '$open$ ofertas con $items$ artículos tienen pujas.',
          { open: openwith, items: openwithitems })
      }
      if (openwithout) {
        if (saleinfo !== '') { saleinfo += ' ' }
        saleinfo += TWDS._('MARKETMAP_SALEINFO_OPENWITHOUT',
          '$open$ ofertas con $items$ artículos no tienen pujas.',
          { open: openwithout, items: openwithoutitems })
      }
      TWDS.createEle('div', {
        last: ti,
        innerHTML: saleinfo
      })
    }

    const box = TWDS.maphelper.drawbox(map, town.x, town.y, 7, ti.outerHTML, color, 0, 'town linklike')
    box.onclick = function () {
      TownWindow.open(town.x, town.y)
    }

    let tr = TWDS.createEle('tr.townline', { last: table })
    const td = TWDS.createEle('td', {
      last: tr
    })
    TWDS.createEle('a.townline_name', {
      last: td,
      textContent: town.name,
      title: TWDS._('MARKET_OPEN_TOWNWINDOW', 'Abrir ventana ciudad'),
      style: { fontWeight: 'bold' },
      onclick: function () {
        TownWindow.open(town.x, town.y)
      }
    })
    TWDS.createEle('a.townline_center', {
      last: td,
      title: TWDS._('MARKETMAP_SHOW_TOWN', 'Mostrar ciudad en mapa'),
      onclick: function () {
        console.log('OC', this)
        Map.center(town.x, town.y)
      },
      children: [{
        nodeName: 'img',
        src: Game.cdnURL + '/images/icons/center.png'
      }]
    })
    TWDS.createEle('span.townline_dist', {
      last: td,
      title: TWDS._('MARKETMAP_MOVE_TO_TOWN', 'Mover a la ciudad'),
      onclick: function () {
        console.log('OC', this)
        Map.center(town.x, town.y)
      },
      children: [
        {
          nodeName: 'span',
          textContent: TWDS._('MARKETMAP_DISTANCE', 'Distancia:')
        },
        {
          nodeName: 'span.linklike',
          innerHTML: town.wtf,
          onclick: function () {
            TaskQueue.add(new window.TaskWalk(town.id, 'town'))
          }
        }
      ]
    })
    if (money) {
      TWDS.createEle('span.money', {
        last: td,
        textContent: '$' + money
      })
    }

    if (town.bids.length) {
      tr = TWDS.createEle('tr', { last: table })
      const td = TWDS.createEle('td', {
        last: tr
      })
      for (let j = 0; j < 2; j++) {
        for (let i = 0; i < town.bids.length; i++) {
          const b = town.bids[i]
          if ((b.finished && j === 0) || (!b.finished && j > 0)) {
            additem(td, b.item_id, b.item_count, j === 0, true)
          }
        }
      }
    }
    if (saleinfo !== '') {
      tr = TWDS.createEle('tr', { last: table })
      TWDS.createEle('td', {
        last: tr,
        textContent: saleinfo
      })
    }
  }
}
TWDS.marketwindow.fillmap2 = function (map, table, all) {
  console.log('filling map with offers')
  Ajax.remoteCall('building_market', 'fetch_offers', {}, function (json) {
    const results = json.msg.search_result
    console.log('results', results)
    for (let i = 0; i < results.length; i++) {
      const r = results[i]
      r.issale = true
      if (r.auction_ends_in < 0 || r.current_bid === r.max_price) {
        // got it.
        r.finished = true
      }
      const t = r.market_town_id
      if (!(t in all)) {
        all[t] = {
          id: t,
          x: r.market_town_x,
          y: r.market_town_y,
          name: r.market_town_name,
          bids: [],
          sales: []
        }
      }
      all[t].sales.push(r)
    }
    TWDS.marketwindow.fillmap3(map, table, all)
  })
}

TWDS.marketwindow.fillmap1 = function (map, table, all) {
  console.log('filling map with bids')
  Ajax.remoteCall('building_market', 'fetch_bids', {}, function (json) {
    if (json.error) { return (new UserMessage(json.msg, UserMessage.TYPE_ERROR)).show() }

    const results = json.msg.search_result
    console.log('results', results)
    for (let i = 0; i < results.length; i++) {
      const r = results[i]
      r.issale = false
      if (r.auction_ends_in < 0 || r.current_bid === r.max_price) {
        // got it.
        r.finished = true
      }
      const t = r.market_town_id
      if (!(t in all)) {
        all[t] = {
          id: t,
          x: r.market_town_x,
          y: r.market_town_y,
          name: r.market_town_name,
          bids: [],
          sales: []
        }
      }
      all[t].bids.push(r)
    }
    TWDS.marketwindow.fillmap2(map, table, all)
  })
}

TWDS.marketwindow.open = function () {
  MarketWindow._TWDS_backup_open.apply(this, arguments)
  const mmt = TWDS._('MARKETMAP_TITLE', 'Marketmap')
  MarketWindow.window.addTab(mmt, 'TWDS_marketmap', function () {
    if (!MarketWindow.window) return

    const p = TWDS.q('div.tw2gui_window_content_pane > *', MarketWindow.window.divMain)
    p.forEach(function (ele) { $(ele).hide() })
    const tab = TWDS.q1('div.tw2gui_window_content_pane > .TWDS_market_map', MarketWindow.window.divMain)

    tab.innerHTML = ''
    const sp = new west.gui.Scrollpane()
    sp.getMainDiv().style.height = '368px'
    sp.getMainDiv().style.marginLeft = '2px'
    tab.appendChild(sp.getMainDiv())

    const wrapper = TWDS.createEle('div')
    sp.appendContent(wrapper)

    const map = TWDS.maphelper.getmap(1.36)
    wrapper.appendChild(map)

    const table = TWDS.createEle('table')
    wrapper.appendChild(table)

    TWDS.maphelper.drawme(map)
    window.MarketWindow.window.setTitle(mmt)
    window.MarketWindow.window.activateTab('TWDS_marketmap')
    window.MarketWindow.window.showLoader()
    TWDS.marketwindow.fillmap1(map, table, {})

    $(tab).show()
  }).appendToContentPane($('<div class="TWDS_market_map"/>'))
}

TWDS.registerStartFunc(function () {
  MarketWindow._TWDS_backup_createMarketOffer = MarketWindow.createMarketOffer
  MarketWindow.createMarketOffer = TWDS.marketwindow.createMarketOffer
  MarketWindow.Offer._TWDS_backup_send = MarketWindow.Offer.send
  MarketWindow.Offer.send = TWDS.marketwindow.offersend
  MarketWindow._TWDS_backup_open = MarketWindow._TWDS_backup_open || MarketWindow.open
  MarketWindow.open = TWDS.marketwindow.open

  west.gui.Dialog.prototype._TWDS_marketwindow_backup_show = west.gui.Dialog.prototype.show
  west.gui.Dialog.prototype.show = TWDS.marketwindow.showwrapper
  const datalist = TWDS.createEle('datalist', {
    id: 'TWDS_marketwindow_bases',
    children: [
      {
        nodeName: 'option',
        value: '',
        textContent: ''
      },
      {
        nodeName: 'option',
        value: 'min',
        textContent: 'min'
      },
      {
        nodeName: 'option',
        value: 'regular',
        textContent: 'regular'
      }
    ],
    style: {
      display: 'none'
    }
  })
  document.body.appendChild(datalist)
  window.Trader._twds_backup_open = window.Trader.open
  window.Trader.open = function (a, b, c, d) { return TWDS.trader.open(a, b, c, d) }
  window.Trader._twds_backup_addItemToInv = window.Trader.addItemToInv
  window.Trader.addItemToInv = function (a) { return TWDS.trader.addItemToInv(a) }
  TWDS.delegate(document.body, 'change', '.TWDS_trader_filter_collectibles', function () {
    TWDS.trader.filterchange()
  })
  TWDS.delegate(document.body, 'change', '.TWDS_trader_town_shop_search', function () {
    TWDS.trader.filterchange()
  })
  TWDS.registerSetting('bool', 'town_shop_collect_switch',
    TWDS._('MARKET_TOWN_SHOP_COLLECT_SWITCH_SETTING',
      'Agregar un interruptor en los comerciantes de las ciudades, para mostrar solo los coleccionables que nos faltan.'),
    true, null, 'Mercado')
  TWDS.registerSetting('bool', 'town_shop_search',
    TWDS._('MARKET_TOWN_SHOP_SEARCH_SETTING',
      'Agregar un campo de búsqueda en los comerciantes de las ciudades.'),
    true, null, 'Mercado')
})

// used when reloading, so the update code will be used.
if ('_TWDS_backup_createMarketOffer' in MarketWindow) {
  MarketWindow.createMarketOffer = TWDS.marketwindow.createMarketOffer
  MarketWindow.Offer.send = TWDS.marketwindow.offersend
  west.gui.Dialog.prototype.show = TWDS.marketwindow.showwrapper
  console.log('auction.js reloaded')
}

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab

TWDS.itemsettab = {}

TWDS.itemsettab.sort = function (e) {
  const colidx = Array.prototype.indexOf.call(this.parentNode.children, this)
  let sortmode = 'a'
  if (this.dataset.sortmode === '1') { sortmode = '1' }

  let table = this.parentNode
  while (table.nodeName !== 'TABLE' && table) {
    table = table.parentNode
  }
  if (!table) return
  const tbody = TWDS.q1('tbody', table)

  const rowColl = tbody.querySelectorAll('tr')
  const rows = []
  for (let i = 0; i < rowColl.length; i++) {
    const row = rowColl[i]
    const td = row.children[colidx]

    if ('sortvalue' in td.dataset) {
      row.sortval = td.dataset.sortvalue.trim()
    } else {
      row.sortval = td.textContent.trim()
    }
    if (sortmode === '1') { row.sortval = parseFloat(row.sortval > '' ? row.sortval : '0') }
    if (!('origsortindex' in row)) {
      row.origsortindex = i
    }
    rows.push(row)
  }
  let sortdir
  if (tbody.sortmode === sortmode) {
    sortdir = tbody.sortdir * -1
  } else {
    sortdir = 1
  }
  rows.sort(function (a, b) {
    if (sortmode === 'a') {
      return sortdir * a.sortval.localeCompare(b.sortval)
    } else if (b.sortval === a.sortval) {
      return sortdir * (b.origsortindex - a.origsortindex)
    } else {
      return sortdir * (b.sortval - a.sortval)
    }
  })
  tbody.textContent = ''
  for (let i = 0; i < rows.length; i++) {
    tbody.appendChild(rows[i])
  }
  tbody.sortmode = sortmode
  tbody.sortdir = sortdir
}
TWDS.itemsettab.createfilters = function (allsets, checkedWithItems) {
  let checkedHide = false
  if (TWDS.settings.itemsettab_hide_columns) {
    checkedHide = true
  }
  const years = {}
  const events = {}
  for (let i = 0; i < allsets.length; i++) {
    const s = allsets[i]
    const y = s.year
    const e = s.eventcode
    if (!(y in years)) { years[y] = y }
    if (!(e in events)) { events[e] = s.eventname }
  }
  const yearsoptions = [{
    nodeName: 'option',
    value: '',
    textContent: TWDS._('ITEMSETS_FILTER_ANY_YEAR', 'Cualquier Año')
  }]
  for (const y of Object.values(years)) {
    const o = {
      nodeName: 'option'
    }
    if (y > '') { o.value = y } else { o.value = 'perdidos' }
    o.textContent = o.value
    yearsoptions.push(o)
  }
  const eventoptions = [{
    nodeName: 'option',
    value: '',
    textContent: TWDS._('ITEMSETS_FILTER_ANY_EVENT', 'Cualquier Evento')
  }]
  for (const code of Object.keys(events)) {
    const name = events[code]
    const o = {
      nodeName: 'option'
    }
    o.value = code
    o.textContent = name
    eventoptions.push(o)
  }
  console.log('years', years, 'options', yearsoptions, 'events', eventoptions)

  const p = TWDS.createEle({
    nodeName: 'p',
    className: 'TWDS_itemsets_filterline',
    children: [{
      nodeName: 'div',
      children: [
        {
          nodeName: 'span',
          textContent: TWDS._('ITEMSETS_FILTER_FOR', 'Filtrar por …')
        },
        {
          nodeName: 'select',
          id: 'TWDS_itemsets_filter_function',
          children: [
            { nodeName: 'option', value: '', textContent: TWDS._('ITEMSETS_ANY_BONUS', 'Cualquier Bonus') },
            // { nodeName: 'option', value: 'attr', textContent: 'Attributes (useless)' },
            // { nodeName: 'option', value: 'skill', textContent: 'Skills (useless)' },
            { nodeName: 'option', value: 'dollar', textContent: TWDS._('ITEMSETS_FILTER_MONEY', 'Dinero') },
            { nodeName: 'option', value: 'drop', textContent: TWDS._('ITEMSETS_FILTER_DROP', 'Tasa salida') },
            { nodeName: 'option', value: 'job', textContent: TWDS._('ITEMSETS_FILTER_JOBPOINTS', 'Puntos Trabajo') },
            { nodeName: 'option', value: 'luck', textContent: TWDS._('ITEMSETS_FILTER_LUCK', 'Suerte') },
            { nodeName: 'option', value: 'pray', textContent: TWDS._('ITEMSETS_FILTER_PRAY', 'Rezar') },
            { nodeName: 'option', value: 'regen', textContent: TWDS._('ITEMSETS_FILTER_REGEN', 'Regeneración') },
            { nodeName: 'option', value: 'speed', textContent: TWDS._('ITEMSETS_FILTER_SPEED', 'Velocidad') },
            { nodeName: 'option', value: 'xp', textContent: TWDS._('ITEMSETS_FILTER_XP', 'EXP') },
            { nodeName: 'option', value: 'fb', textContent: TWDS._('ITEMSETS_FILTER_FB', 'Batalla Fuerte') }
          ]
        },
        {
          nodeName: 'select',
          id: 'TWDS_itemsets_filter_year',
          children: yearsoptions
        },
        {
          nodeName: 'select',
          id: 'TWDS_itemsets_filter_event',
          children: eventoptions
        }
      ]
    },
    {
      nodeName: 'label',
      children: [
        { nodeName: 'input', type: 'checkbox', id: 'TWDS_itemsets_filter_clothes', value: 1 },
        { nodeName: 'span', textContent: TWDS._('ITEMSETS_CLOTHES', 'ropas') }
      ]
    },
    {
      nodeName: 'label',
      children: [
        { nodeName: 'input', type: 'checkbox', id: 'TWDS_itemsets_filter_weapons', value: 1 },
        { nodeName: 'span', textContent: TWDS._('ITEMSETS_WEAPONS', 'armas') }
      ]
    },
    {
      nodeName: 'label',
      children: [
        { nodeName: 'input', type: 'checkbox', id: 'TWDS_itemsets_filter_animals', value: 1 },
        { nodeName: 'span', textContent: TWDS._('ITEMSETS_ANIMALYIELD', 'animal/producto') }
      ]
    },
    {
      nodeName: 'label',
      children: [{
        nodeName: 'input',
        type: 'checkbox',
        checked: checkedHide,
        onchange: function (v) {
          v = v.target.checked
          console.log('hide changed to', v)
          TWDS.settings.itemsettab_hide_columns = v
          // the table download needs to know this.
          if (!v) {
            document.body.classList.remove('TWDS_itemsettable_hidemany')
            TWDS.q1('#TWDS_itemsettable_th_attr').colSpan = 5
            TWDS.q1('#TWDS_itemsettable_th_skills').colSpan = 21
          } else {
            document.body.classList.add('TWDS_itemsettable_hidemany')
            TWDS.q1('#TWDS_itemsettable_th_attr').colSpan = 1
            TWDS.q1('#TWDS_itemsettable_th_skills').colSpan = 1
          }
          TWDS.saveSettings()
        }
      }, {
        nodeName: 'span',
        textContent: TWDS._('ITEMSETS_HIDE_MANY', 'Ocultar muchas columnas')
      }]
    }
    ]
  })
  return p
}
TWDS.itemsettab.fixinfo = {
  set_goodnight: { year: 1, event: 'friendship' },
  set_meischdas: { year: 1, event: 'friendship' },
  set_snowi: { year: 1, event: 'friendship' },
  set_akoya: { year: 1, event: 'friendship' },
  set_dark_templar: { year: 1, event: 'friendship' },
  set_giony4you: { year: 1, event: 'friendship' },
  set_matsacolthan: { year: 1, event: 'friendship' },
  set_multi_account: { year: 1, event: 'friendship' },
  set_orichyto: { year: 1, event: 'friendship' },
  set_ilpresidento: { year: 1, event: 'friendship' },
  set_stelladelwest: { year: 1, event: 'friendship' },
  set_merlin: { year: 1, event: 'friendship' },
  set_svetlanaili: { year: 1, event: 'friendship' },
  set_lucabadoer: { year: 1, event: 'friendship' },
  set_luckyday: { year: 1, event: 'friendship' },
  set_texasladys: { year: 1, event: 'friendship' },
  set_meta: { year: 1, event: 'friendship' },
  set_hassan: { year: 1, event: 'friendship' },
  set_dorafix: { year: 1, event: 'friendship' },
  set_lordlamar: { year: 1, event: 'friendship' },
  set_txankete: { year: 1, event: 'friendship' },
  set_chinski: { year: 1, event: 'friendship' },
  set_xque69: { year: 1, event: 'friendship' },
  set_montxi: { year: 1, event: 'friendship' },
  set_gogoboom: { year: 1, event: 'friendship' },
  set_sar_pepita: { year: 1, event: 'friendship' },
  set_r0mpehues0s: { year: 1, event: 'friendship' },
  set_damed: { year: 1, event: 'friendship' },
  set_flopsinchen: { year: 1, event: 'friendship' },
  set_kolac015: { year: 1, event: 'friendship' },
  set_deanie_obanion: { year: 1, event: 'friendship' },
  set_mrs_dreamer: { year: 1, event: 'friendship' },
  set_wolfskin: { year: 1, event: 'friendship' },
  set_childerich: { year: 1, event: 'friendship' },
  set_killstreak1: { year: 1, event: 'friendship' },
  set_olga: { year: 1, event: 'friendship' },
  set_jerznero: { year: 1, event: 'friendship' },
  set_gobnit: { year: 1, event: 'friendship' },
  set_rambo: { year: 1, event: 'friendship' },
  set_volka: { year: 1, event: 'friendship' },
  set_rompehuesos: { year: 1, event: 'friendship' },
  set_agetn_pinky: { year: 1, event: 'friendship' },
  set_agent_brain: { year: 1, event: 'friendship' },
  set_ninja123: { year: 1, event: 'friendship' },

  set_veteran_horse: { year: 2014, event: 'outgame' },

  fireworker_set: { year: 1, event: 'ingame' }, // der Eimer
  tw_times_set: { year: 1, event: 'outgame' }, // Gewinnspiele der Times
  wooden_magician_set: { year: 2012, event: 'shop' }, // Gewinnspiele der Times

  curling_set_1: { year: 2021, event: 'sale' },
  curling_set_2: { year: 2021, event: 'sale' },
  set_free_to_use_dummy: { year: 2021, event: 'ingame' },
  legendary_set_1: { year: 2021, event: 'ingame' },
  legendary_set_2: { year: 2021, event: 'ingame' },
  set_duelist: { year: 2012, event: 'xmas' },
  set_fort: { year: 2012, event: 'xmas' },
  set_fortunehunter: { year: 2012, event: 'xmas' },
  set_duelist_gun: { year: 2012, event: 'xmas' },
  set_fort_gun: { year: 2012, event: 'xmas' },
  set_fortunehunter_gun: { year: 2012, event: 'xmas' },
  set_meleeduelist: { year: 2013, event: 'easter' },
  set_rangedduelist: { year: 2013, event: 'easter' },
  set_proworker: { year: 2013, event: 'easter' },
  set_meleeduelist_horse: { year: 2013, event: 'easter' },
  set_rangedduelist_horse: { year: 2013, event: 'easter' },
  set_proworker_horse: { year: 2013, event: 'easter' },
  set_independence_1: { year: 2013, event: 'independence' },
  set_independence_2: { year: 2013, event: 'independence' },
  set_independence_3: { year: 2013, event: 'independence' },
  set_independence_gun_1: { year: 2013, event: 'independence' },
  set_independence_gun_2: { year: 2013, event: 'independence' },
  set_independence_gun_3: { year: 2013, event: 'independence' },
  set_octoberfest_4: { year: 2013, event: 'oktoberfest' },
  set_octoberfest_3: { year: 2013, event: 'oktoberfest' },
  set_octoberfest_2: { year: 2013, event: 'oktoberfest' },
  set_octoberfest_1: { year: 2013, event: 'oktoberfest' },
  set_octoberfest_gun_3: { year: 2013, event: 'oktoberfest' },
  set_octoberfest_gun_2: { year: 2013, event: 'oktoberfest' },
  set_octoberfest_gun_1: { year: 2013, event: 'oktoberfest' },
  set_octoberfest_gun_winner: { year: 2013, event: 'oktoberfest' },

  set_shop_soldier: { year: 1, event: 'shop' },
  set_shop_work: { year: 1, event: 'shop' },
  set_shop_duel: { year: 1, event: 'shop' },
  set_shop_adventure: { year: 1, event: 'shop' },
  set_shop_high: { year: 1, event: 'shop' },
  set_shop_mid: { year: 1, event: 'shop' },
  set_shop_low: { year: 1, event: 'shop' },
  bubby_set: { year: 2013, event: 'shop' },

  set_dancer: { year: 1, event: 'ingame' },
  set_farmer: { year: 1, event: 'ingame' },
  set_gentleman: { year: 1, event: 'ingame' },
  set_indian: { year: 1, event: 'ingame' },
  set_mexican: { year: 1, event: 'ingame' },
  set_pilgrim_male: { year: 1, event: 'ingame' },
  set_pilgrim_female: { year: 1, event: 'ingame' },
  set_quackery: { year: 1, event: 'ingame' },
  set_sleeper: { year: 1, event: 'ingame' },
  season_set: { year: 1, event: 'ingame' },
  set_walker: { year: 1, event: 'ingame' },
  gold_set: { year: 1, event: 'ingame' },
  greenhorn_set: { year: 1, event: 'ingame' },
  collector_set: { year: 1, event: 'ingame' },
  set_party: { year: 1, event: 'ingame' },
  set_parade: { year: 1, event: 'ingame' },
  green_set_2021: { year: 1, event: 'ingame' },
  fancy_set_2021: { year: 1, event: 'ingame' },

  malachite_set_1: { year: 1, event: 'otherevent' },

  set_st_patrick: { year: 1, event: 'ingame' },

  instance_set_1: { year: 1, event: 'adventures' },
  set_veteran_2017_1: { year: 2017, event: 'adventures' },
  set_veteran_animal_cook: { year: 2017, event: 'adventures' },

  set_xmas2013_cloth: { year: 2013, event: 'xmas' },
  set_xmas2013_tool: { year: 2013, event: 'xmas' },
  set_dedmoroz_2016_weapon: { year: 2016, event: 'xmas' },
  set_dedmoroz_2016_animal: { year: 2016, event: 'xmas' },
  set_dedmoroz_2016: { year: 2016, event: 'xmas' },

  harvets_set_2021_1: { year: 2021, event: 'ingame' },

  set_fair: { year: 1, event: 'fair' },

  set_soap: { year: 1, event: 'shop' },
  labor_day: { year: 1, event: 'ingame' },
  set_cupid: { year: 1, event: 'shop' },
  bunny_set: { year: 1, event: 'shop' },

  set_colcord: { year: 2016, event: 'sale' },
  set_wrightbrothers: { year: 2016, event: 'sale' },
  set_wright_brothers_clothes: { year: 2017, event: 'sale' },
  set_prisonbrothers_august_2017: { year: 2017, event: 'sale' },
  set_prisonbrothers_august_2017_animal: { year: 2017, event: 'sale' },
  set_carnival_2018_1: { year: 2018, event: 'ingame' },
  set_carnival_2018_2: { year: 2018, event: 'ingame' }, // one piece for bonds.
  '2018_achievement_set': { year: 2018, event: 'ingame' }, // still not complete
  '2018_10th_set_1': { year: 2018, event: 'outgame' },
  '2018_10th_set_2': { year: 2018, event: 'outgame' },
  '2018_10th_set_3': { year: 2018, event: 'outgame' },
  '2018_soccer_event': { year: 2018, event: 'ingame' },
  '2018_doldenset': { year: 2018, event: 'ingame' }, // dolden.
  gold_rush_animal: { year: 2018, event: 'outgame' }, // Gringo
  gold_rush_clothes: { year: 2018, event: 'outgame' }, // Gringo
  gold_rush_weapons: { year: 2018, event: 'outgame' }, // Gringo
  chef_set_1: { year: 2018, event: 'sale' },
  chef_set_2: { year: 2018, event: 'sale' },
  community_events_set: { year: 2018, event: 'otherevent' },
  lucille_animal_set: { year: 2018, event: 'sale' },
  lucille_weapon_set: { year: 2018, event: 'sale' },
  black_friday_set: { year: 2018, event: 'sale' },
  spring_1_2019: { year: 2019, event: 'sale' },
  spring_2_2019: { year: 2019, event: 'sale' },
  summer_spirit: { year: 2019, event: 'sale' },
  western_friday_weapon_set: { year: 2019, event: 'sale' },
  western_friday_horse_set: { year: 2019, event: 'sale' },
  firefighter_set_1: { year: 2020, event: 'sale' },
  firefighter_set_2: { year: 2020, event: 'sale' },
  west_fun_animal_set: { year: 2020, event: 'ingame' },
  fan_collector_set: { year: 2020, event: 'ingame' },
  unique_rare_set: { year: 2020, event: 'sale' },
  harvets_2021_set_1: { year: 2020, event: 'ingame' },
  harvester_set_animal: { year: 2020, event: 'sale' },
  harvester_set_clothing: { year: 2020, event: 'sale' },
  harvester_set_weapon: { year: 2020, event: 'sale' },
  set_halloween: { year: 2020, event: 'ingame' },
  creativity_set: { year: 2020, event: 'ingame' },
  creative_set: { year: 1, event: 'outgame' },
  birthay_set_2021: { year: 2021, event: 'outgame' }, // birthay, really.
  set_halloween_clown: { year: 2023, event: 'outgame' },

  '15_b_day_set_weapon': { year: 2023, event: 'outgame' },
  '15_b_day_set_animal': { year: 2023, event: 'outgame' },
  '15_b_day_set': { year: 2023, event: 'outgame' }

}
TWDS.itemsettab.classifyset = function (key) {
  TWDS.itemsettab.classifyallsets()
  const allsets = west.storage.ItemSetManager.getAll()
  for (let i = 0; i < allsets.length; i++) {
    if (allsets[i].key === key) { return allsets[i]._memo.TWDS_classification }
  }
  return null
}
TWDS.itemsettab.classifyallsets_done = false
TWDS.itemsettab.classifyallsets = function () {
  if (TWDS.itemsettab.classifyallsets_done) return
  const allsets = west.storage.ItemSetManager.getAll()
  for (let i = 0; i < allsets.length; i++) {
    const s = allsets[i]
    const k = s.key
    let year = ''
    let eventcode = k
    let t = k.match(/_(\d\d\d\d)_/)
    allsets[i].year = 0
    allsets[i].eventcode = ''
    if (t && t.length) {
      year = parseInt(t[1])
    } else {
      t = k.match(/(\d\d\d\d)/)
      if (t && t.length) {
        year = parseInt(t[1])
      }
    }

    // there is a set with the number 6679 in it's key:
    if (year > 2099 || year < 2012) year = 0

    eventcode = eventcode.replace('set', '')
    eventcode = eventcode.replace('__', '_')
    eventcode = eventcode.replace(/_/g, ' ')
    eventcode = 'unknown'
    // dod, dotd, dodt ... */
    if (k.match(/(^|_)dot?dt?_/)) {
      eventcode = 'dod'
    }
    if (k.match(/_dayofthedead/)) {
      eventcode = 'dod'
    }
    // a... really.
    if (k.match(/(^|_)indep[ae]nd[ae]nce_/)) {
      eventcode = 'independence'
    }
    if (k.match(/_4july_/)) {
      eventcode = 'independence'
    }
    if (k.match(/(^|_)o[ck]toberfest[-_]/)) {
      eventcode = 'oktoberfest'
    }
    if (k.match(/_october_/)) {
      eventcode = 'oktoberfest'
    }
    if (k.match(/^okt_setwof_/)) {
      eventcode = 'oktoberfest'
    }
    if (k.match(/(^|_)easter_/)) {
      eventcode = 'easter'
    }
    if (k.match(/(^|_)valentine?s?(day)?_/)) {
      eventcode = 'valentine'
    }
    if (k.match(/(^|_)(holiday|christmas|xmas\d+)_/)) {
      eventcode = 'xmas'
    }
    if (k.match(/(^|_)sale(_|$)/)) {
      eventcode = 'sale'
    }
    if (k.match(/(^|_)fair_/)) {
      eventcode = 'fair'
    }
    if (k.match(/(^|_)(ifbc\d*|speedworld)_/)) {
      eventcode = 'outgame'
    }
    if (k.match(/(^|_)friendship(_|$)/)) {
      eventcode = 'friendship'
    }
    if (k.match(/(^|_)eire/)) {
      eventcode = 'ingame'
    }
    if (k.match(/^community_event_.*_march/)) {
      eventcode = 'ingame'
    }
    // allsets[i].eventcode = eventcode
    if (k in TWDS.itemsettab.fixinfo) {
      eventcode = TWDS.itemsettab.fixinfo[k].event
      year = TWDS.itemsettab.fixinfo[k].year
    }
    allsets[i].eventname = 'Unknown'
    const memo = {
      year: year,
      eventcode: eventcode,
      eventname: ''
    }
    switch (eventcode) {
      case 'oktoberfest': memo.eventname = 'Oktoberfest'; break
      case 'dod': memo.eventname = 'Day of the dead'; break
      case 'independence': memo.eventname = '4th of july'; break
      case 'easter': memo.eventname = 'Easter'; break
      case 'valentine': memo.eventname = 'Valentine day'; break
      case 'sale': memo.eventname = 'Sale'; break
      case 'shop': memo.eventname = 'Shop'; break
      case 'xmas': memo.eventname = 'Christmas'; break
      case 'ingame': memo.eventname = 'Ingame'; break
      case 'otherevent': memo.eventname = 'Other events'; break
      case 'adventures': memo.eventname = 'Adventures'; break
      case 'fair': memo.eventname = 'Fair'; break
      case 'outgame': memo.eventname = 'Outgame'; break
      case 'friendship': memo.eventname = 'Friendship'; break
      default:
        console.log('no event match for', k, s.name, s.items, memo)
    }
    allsets[i]._memo.TWDS_classification = memo
  }
  let last = 0
  for (let i = 0; i < allsets.length; i++) {
    const memo = allsets[i]._memo.TWDS_classification
    memo.lastyear = last
    if (memo.year) {
      last = memo.year
    }
  }
  let next = 0
  for (let i = allsets.length - 1; i >= 0; i--) {
    const memo = allsets[i]._memo.TWDS_classification
    memo.nextyear = next
    if (memo.year) {
      next = memo.year
    }
  }
  for (let i = allsets.length - 1; i >= 0; i--) {
    const memo = allsets[i]._memo.TWDS_classification
    if (memo.year === 0) {
      if (memo.lastyear > 0 && memo.lastyear === memo.nextyear) {
        memo.year = memo.lastyear
      }
    }
  }
  TWDS.itemsettab.classifyallsets_done = true
}
TWDS.itemsettab.fixallsets = function (allsets) {
  for (let i = 0; i < allsets.length; i++) {
    const s = allsets[i]
    const k = s.key
    let year = ''
    let eventcode = k
    let t = k.match(/_(\d\d\d\d)_/)
    allsets[i].year = 0
    allsets[i].eventcode = ''
    if (t && t.length) {
      year = parseInt(t[1])
    } else {
      t = k.match(/(\d\d\d\d)/)
      if (t && t.length) {
        year = parseInt(t[1])
      }
    }

    // there is a set with the number 6679 in it's key:
    if (year === 0 || (year >= 2012 && year <= 2099)) {
      allsets[i].year = year
    }
    eventcode = eventcode.replace('set', '')
    eventcode = eventcode.replace('__', '_')
    eventcode = eventcode.replace(/_/g, ' ')
    eventcode = 'unknown'
    // dod, dotd, dodt ... */
    if (k.match(/(^|_)dot?dt?_/)) {
      eventcode = 'dod'
    }
    if (k.match(/_dayofthedead/)) {
      eventcode = 'dod'
    }
    // a... really.
    if (k.match(/(^|_)indep[ae]nd[ae]nce_/)) {
      eventcode = 'independence'
    }
    if (k.match(/_4july_/)) {
      eventcode = 'independence'
    }
    if (k.match(/(^|_)o[ck]toberfest[-_]/)) {
      eventcode = 'oktoberfest'
    }
    if (k.match(/_october_/)) {
      eventcode = 'oktoberfest'
    }
    if (k.match(/^okt_setwof_/)) {
      eventcode = 'oktoberfest'
    }
    if (k.match(/(^|_)easter_/)) {
      eventcode = 'easter'
    }
    if (k.match(/(^|_)valentine?s?(day)?_/)) {
      eventcode = 'valentine'
    }
    if (k.match(/(^|_)(holiday|christmas|xmas\d+)_/)) {
      eventcode = 'xmas'
    }
    if (k.match(/(^|_)sale(_|$)/)) {
      eventcode = 'sale'
    }
    if (k.match(/(^|_)fair_/)) {
      eventcode = 'fair'
    }
    if (k.match(/(^|_)(ifbc\d*|speedworld)_/)) {
      eventcode = 'outgame'
    }
    if (k.match(/(^|_)friendship(_|$)/)) {
      eventcode = 'friendship'
    }
    if (k.match(/(^|_)eire/)) {
      eventcode = 'ingame'
    }
    if (k.match(/^community_event_.*_march/)) {
      eventcode = 'ingame'
    }
    allsets[i].eventcode = eventcode
    if (k in TWDS.itemsettab.fixinfo) {
      allsets[i].eventcode = TWDS.itemsettab.fixinfo[k].event
      allsets[i].year = TWDS.itemsettab.fixinfo[k].year
    }
    allsets[i].eventname = 'Unknown'
    switch (allsets[i].eventcode) {
      case 'oktoberfest': allsets[i].eventname = 'Oktoberfest'; break
      case 'dod': allsets[i].eventname = 'Day of the dead'; break
      case 'independence': allsets[i].eventname = '4th of july'; break
      case 'easter': allsets[i].eventname = 'Easter'; break
      case 'valentine': allsets[i].eventname = 'Valentine day'; break
      case 'sale': allsets[i].eventname = 'Sale'; break
      case 'shop': allsets[i].eventname = 'Shop'; break
      case 'xmas': allsets[i].eventname = 'Christmas'; break
      case 'ingame': allsets[i].eventname = 'Ingame'; break
      case 'otherevent': allsets[i].eventname = 'Other events'; break
      case 'adventures': allsets[i].eventname = 'Adventures'; break
      case 'fair': allsets[i].eventname = 'Fair'; break
      case 'outgame': allsets[i].eventname = 'Outgame'; break
      case 'friendship': allsets[i].eventname = 'Friendship'; break
      default:
        console.log('no event match for', k, s.name, s.items)
    }
  }
  let last = 0
  for (let i = 0; i < allsets.length; i++) {
    allsets[i].lastyear = last
    if (allsets[i].year) {
      last = allsets[i].year
    }
  }
  let next = 0
  for (let i = allsets.length - 1; i >= 0; i--) {
    allsets[i].nextyear = next
    if (allsets[i].year) {
      next = allsets[i].year
    }
  }
  for (let i = allsets.length - 1; i >= 0; i--) {
    if (allsets[i].year === 0) {
      if (allsets[i].lastyear > 0 && allsets[i].lastyear === allsets[i].nextyear) {
        allsets[i].year = allsets[i].lastyear
      }
    }
  }
  return allsets
}
TWDS.itemsettab.getContent1 = function () {
  let allsets = west.storage.ItemSetManager._setArray.slice(0)
  const div = TWDS.createEle({
    nodeName: 'div'
  })
  const but = TWDS.createEle({
    nodeName: 'button',
    id: 'TWDS_itemsettable_download',
    style: {
      float: 'right'
    },
    textContent: TWDS._('ITEMSETS_DOWNLOAD_TABLE', 'Descargar tabla sin filtrar')
  })
  div.appendChild(but)
  const butplus = TWDS.createEle({
    nodeName: 'button',
    id: 'TWDS_itemsettable_plus',
    style: {
      float: 'right'
    },
    textContent: '+',
    title: TWDS._('INCREASE_FONT_SIZE', 'Incrementar tamaño fuente')
  })
  div.appendChild(butplus)
  const butminus = TWDS.createEle({
    nodeName: 'button',
    id: 'TWDS_itemsettable_minus',
    style: {
      float: 'right'
    },
    textContent: '-',
    title: TWDS._('DECREASE_FONT_SIZE', 'Reducir tamaño fuente')
  })
  div.appendChild(butminus)
  let checkedHand = false
  let checkedShot = false
  if (TWDS.settings.itemsettab_use_hand) {
    checkedHand = true
  } else {
    checkedShot = true
  }
  let checkedWithItems = false
  if (TWDS.settings.itemsettab_with_items) {
    checkedWithItems = true
  }

  const h3 = TWDS.createEle({
    nodeName: 'h3',
    textContent: TWDS._('ITEMSETS_ALL_ITEM_SETS', 'Todos los conjuntos')
  })
  div.appendChild(h3)

  TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_itemsets_options',
    last: div,
    children: [
      {
        nodeName: 'span',
        textContent: TWDS._('ITEMSETS_INFLUENCE_OPTIONS',
          'Opciones que influyen en el cálculo: ')
      }, {
        nodeName: 'select',
        style: {
          border: '1px dotted #aaa',
          padding: '2px 3px'
        },
        last: div,
        children: [
          {
            nodeName: 'option',
            textContent: TWDS._('HANDWEAPON', 'Arma Contundente'),
            selected: checkedHand,
            value: 'hand'
          },
          {
            nodeName: 'option',
            textContent: TWDS._('SHOTWEAPON', 'Arma de Fuego'),
            selected: checkedShot,
            value: 'shot'
          }
        ],
        onchange: function (ev) {
          const v = this.value
          if (v === 'shot') {
            checkedShot = true
            checkedHand = false
            TWDS.settings.itemsettab_use_hand = false
          } else {
            checkedHand = true
            checkedShot = false
            TWDS.settings.itemsettab_use_hand = true
          }
          TWDS.saveSettings()
          console.log('before0')
          if (!wman.isWindowCreated('TWDS')) return
          console.log('before1')
          if (!TWDS.window) return
          console.log('activate')
          TWDS.activateTab('itemsets')
        }
      },
      {
        nodeName: 'label',
        children: [{
          nodeName: 'input',
          type: 'checkbox',
          checked: checkedWithItems,
          onchange: function (v) {
            console.log('checkbox change', v)
            TWDS.settings.itemsettab_with_items = this.checked
            TWDS.saveSettings()
            TWDS.activateTab('itemsets')
          }
        }, {
          nodeName: 'span',
          textContent: TWDS._('ITEMSETS_INCLUDE_ITEMS', 'Incluir artículos')
        }
        ]
      }
    ]
  })

  if (TWDS.settings.itemsettab_hide_columns) {
    document.body.classList.add('TWDS_itemsettable_hidemany')
  }

  allsets = TWDS.itemsettab.fixallsets(allsets)
  div.appendChild(TWDS.itemsettab.createfilters(allsets, checkedWithItems))

  const table = TWDS.createEle({
    nodeName: 'table',
    id: 'TWDS_itemset_table'
  })
  div.appendChild(table)

  const thead = TWDS.createEle({
    nodeName: 'thead'
  })
  table.appendChild(thead)
  const tbody = TWDS.createEle({
    nodeName: 'tbody'
  })
  table.appendChild(tbody)
  const makehead = function () {
    const sorter = TWDS.itemsettab.sort
    const h1 = TWDS.createEle({
      nodeName: 'tr',
      className: 'colspanrow',
      children: [
        { nodeName: 'th' },
        { nodeName: 'th', colSpan: 2, textContent: '' },
        { nodeName: 'th', className: 'maybehidden' }, // #
        {
          nodeName: 'th',
          colSpan: 5,
          dataset: {
            fullColSpan: 5
          },
          textContent: TWDS._('ATTRIBUTES', 'Atributos'),
          id: 'TWDS_itemsettable_th_attr'
        },
        {
          nodeName: 'th',
          colSpan: 21,
          dataset: {
            fullColSpan: 21
          },
          textContent: TWDS._('SKILLS', 'Habilidades'),
          id: 'TWDS_itemsettable_th_skills'
        },
        { nodeName: 'th' }, // $
        { nodeName: 'th' }, //
        { nodeName: 'th' }, //
        { nodeName: 'th' }, //
        { nodeName: 'th' }, //
        { nodeName: 'th' }, //
        { nodeName: 'th' }, //
        { nodeName: 'th' }, //
        { nodeName: 'th', colSpan: 3, textContent: TWDS._('FORTBATTLE', 'Batalla de Fuerte') },
        { nodeName: 'th', colSpan: 3, textContent: TWDS._('FORTBATTLE_SECTORBONUS', 'Bonus de Sector en Batalla') },
        { nodeName: 'th' } //
      ]
    })
    const doattr = function (no) {
      const key = window.CharacterSkills.allAttrKeys[no]
      const name = window.CharacterSkills.keyNames[key]
      const out = {
        nodeName: 'th',
        textContent: name,
        className: 'maybehidden',
        dataset: { sortmode: '1' },
        onclick: sorter
      }
      return out
    }
    const doskill = function (no) {
      const key = window.CharacterSkills.allSkillKeys[no]
      const name = window.CharacterSkills.keyNames[key]
      const out =
        {
          nodeName: 'th',
          textContent: name,
          className: 'maybehidden',
          dataset: { sortmode: '1' },
          onclick: sorter
        }
      return out
    }
    const h2 = TWDS.createEle({
      nodeName: 'tr',
      children: [
        {
          nodeName: 'th',
          textContent: TWDS._('ITEMSETS_SETNAME', 'Nombre'),
          className: 'sortable',
          dataset: { sortmode: 'a' },
          onclick: sorter
        },
        {
          nodeName: 'th',
          textContent: TWDS._('YEAR', 'Año'),
          className: 'sortable',
          dataset: { sortmode: '1' },
          onclick: sorter
        },
        {
          nodeName: 'th',
          textContent: TWDS._('EVENT', 'Evento'),
          title: TWDS._('ITEMSETS_OR_SET_KEY', 'Ya sea un nombre o abreviatura del evento, o la clave interna del evento.'),
          dataset: { sortmode: 'a' },
          onclick: sorter
        },
        {
          nodeName: 'th',
          textContent: '#',
          title: TWDS._('ITEMSETS_NUMBER_OF_ITEMS', 'Número de artículos'),
          dataset: { sortmode: '1' },
          onclick: sorter,
          className: 'maybehidden'
        },
        {
          nodeName: 'th',
          innerHTML: '&#x2211;',
          title: TWDS._('ITEMSETS_TOTAL_BONUS_ATTR', 'Bonus total Atributos.'),
          dataset: { sortmode: '1' },
          onclick: sorter
        },
        doattr(0),
        doattr(1),
        doattr(2),
        doattr(3),
        {
          nodeName: 'th',
          innerHTML: '&#x2211;',
          title: TWDS._('ITEMSETS_TOTAL_BONUS_SKILLS', 'Bonus total Habilidades.'),
          dataset: { sortmode: '1' },
          onclick: sorter
        },
        doskill(0),
        doskill(1),
        doskill(2),
        doskill(3),
        doskill(4),
        doskill(5),
        doskill(6),
        doskill(7),
        doskill(8),
        doskill(9),
        doskill(10),
        doskill(11),
        doskill(12),
        doskill(13),
        doskill(14),
        doskill(15),
        doskill(16),
        doskill(17),
        doskill(18),
        doskill(19),
        {
          nodeName: 'th',
          textContent: '$',
          title: TWDS._('ITEMSETS_FILTER_MONEY', 'Dinero'),
          dataset: { sortmode: '1' },
          onclick: sorter
        },
        {
          nodeName: 'th',
          dataset: { sortmode: '1' },
          onclick: sorter,
          textContent: TWDS._('ITEMSETS_TH_DROP', 'Tasa salida'),
          title: TWDS._('ITEMSETS_TH_DROP_TITLE', 'Mejora la tasa de salida del producto')
        },
        {
          nodeName: 'th',
          textContent: TWDS._('ITEMSETS_TH_JP', 'PT'),
          title: TWDS._('ITEMSETS_TH_JP_TITLE',
            'Puntos de trabajo para todos los trabajos. Los puntos de particulares no se cuentan.'),
          dataset: { sortmode: '1' },
          onclick: sorter
        },
        {
          nodeName: 'th',
          textContent: TWDS._('ITEMSETS_TH_LUCK', 'Suerte'),
          dataset: { sortmode: '1' },
          onclick: sorter
        },
        {
          nodeName: 'th',
          textContent: TWDS._('ITEMSETS_TH_PRAY', 'Rezar'),
          dataset: { sortmode: '1' },
          onclick: sorter
        },
        {
          nodeName: 'th',
          textContent: TWDS._('ITEMSETS_TH_REGEN', 'Regen.'),
          title: TWDS._('ITEMSETS_TH_REGEN_TITLE', 'Regeneración más rápida.'),
          dataset: { sortmode: '1' },
          onclick: sorter
        },
        {
          nodeName: 'th',
          textContent: TWDS._('ITEMSETS_TH_SPEED', 'Velocidad'),
          title: TWDS._('ITEMSETS_TH_SPEED_TITLE', 'Mayor velocidad.'),
          dataset: { sortmode: '1' },
          onclick: sorter
        },
        {
          nodeName: 'th',
          textContent: TWDS._('ITEMSETS_TH_XP', 'Exp'),
          title: TWDS._('ITEMSETS_TH_XP_TITLE', 'Experiencia.'),
          dataset: { sortmode: '1' },
          onclick: sorter
        },
        {
          nodeName: 'th',
          textContent: TWDS._('ITEMSETS_TH_FB_OFF', 'Ataq.'),
          title: TWDS._('ITEMSETS_TH_FB_OFF_TITLE', 'Ataque (Bonus Batalla)'),
          dataset: { sortmode: '1' },
          onclick: sorter
        },
        {
          nodeName: 'th',
          textContent: TWDS._('ITEMSETS_TH_FB_DEF', 'Def.'),
          title: TWDS._('ITEMSETS_TH_FB_DEF_TITLE', 'Defensa (Bonus Batalla)'),
          dataset: { sortmode: '1' },
          onclick: sorter
        },
        {
          nodeName: 'th',
          textContent: TWDS._('ITEMSETS_TH_FB_RES', 'Resist.'),
          title: TWDS._('ITEMSETS_TH_FB_RES_TITLE', 'Resistencia (Bonus Batalla)'),
          dataset: { sortmode: '1' },
          onclick: sorter
        },
        {
          nodeName: 'th',
          textContent: TWDS._('ITEMSETS_TH_FBS_OFF', 'Ataq.'),
          title: TWDS._('ITEMSETS_TH_FBS_OFF_TITLE', 'Ataque (Bonus Sector Batalla)'),
          dataset: { sortmode: '1' },
          onclick: sorter
        },
        {
          nodeName: 'th',
          textContent: TWDS._('ITEMSETS_TH_FBS_DEF', 'Def.'),
          title: TWDS._('ITEMSETS_TH_FBS_DEF_TITLE', 'Defensa (Bonus Sector Batalla)'),
          dataset: { sortmode: '1' },
          onclick: sorter
        },
        {
          nodeName: 'th',
          textContent: TWDS._('ITEMSETS_TH_FBS_DMG', 'Daño'),
          title: TWDS._('ITEMSETS_TH_FBS_DMG_TITLE', 'Daño (Bonus Sector Batalla)'),
          dataset: { sortmode: '1' },
          onclick: sorter
        },
        {
          nodeName: 'th',
          textContent: '?',
          title: 'Aquí se mostrará una pista si hay algún problema..',
          dataset: { sortmode: 'a' },
          onclick: sorter
        }
      ]
    })
    return [h1, h2]
  }
  const heads = makehead()
  thead.appendChild(heads[0])
  thead.appendChild(heads[1])
  const logged = {}
  for (let i = allsets.length - 1; i >= 0; i--) {
    const s = allsets[i]
    const k = s.key
    const year = allsets[i].year
    const eventcode = allsets[i].eventcode
    const eventname = allsets[i].eventname
    const itemSet = west.storage.ItemSetManager.get(k)
    const setBonuses = itemSet.getMergedStages(s.items.length)
    const items = s.items
    const fuddle = {
      fixed: 0,
      perlevel: 0,
      rounding: '',
      total: 0
    }
    const sum = {
      drop: Object.assign({}, fuddle),
      dollar: Object.assign({}, fuddle),
      job: Object.assign({}, fuddle),
      jobmisc: Object.assign({}, fuddle),
      luck: Object.assign({}, fuddle),
      pray: Object.assign({}, fuddle),
      regen: Object.assign({}, fuddle),
      speed: Object.assign({}, fuddle),
      experience: Object.assign({}, fuddle),
      fb_resistance: Object.assign({}, fuddle),
      fb_defense: Object.assign({}, fuddle),
      fb_offense: Object.assign({}, fuddle),
      fb_damage: Object.assign({}, fuddle),
      fbs_defense: Object.assign({}, fuddle),
      fbs_offense: Object.assign({}, fuddle),
      fbs_damage: Object.assign({}, fuddle),
      damage: Object.assign({}, fuddle)
    }
    for (let j = 0; j < window.CharacterSkills.allAttrKeys.length; j++) {
      const y = window.CharacterSkills.allAttrKeys[j]
      sum[y] = Object.assign({}, fuddle)
    }
    for (let j = 0; j < window.CharacterSkills.allSkillKeys.length; j++) {
      const y = window.CharacterSkills.allSkillKeys[j]
      sum[y] = Object.assign({}, fuddle)
    }
    const handleonesetbonus = function (bonus) {
      let onenote = ''
      if (bonus.type === 'character') {
        const type = bonus.bonus.type

        if (bonus.key !== 'level') {
          onenote = 'unknown bonus.key ' + bonus.key + '.'
        } else if (type === 'attribute' || type === 'skill') {
          const name = bonus.bonus.name
          sum[name].perlevel += bonus.bonus.value
          sum[name].rounding = bonus.roundingMethod
        } else if (type === 'job' && bonus.bonus.job === 'all') {
          sum.job.perlevel += bonus.bonus.value
          sum.job.rounding = bonus.roundingMethod
        } else if (type === 'job') {
          sum.jobmisc.perlevel += bonus.bonus.value
          sum.jobmisc.rounding = bonus.roundingMethod
        } else if (type === 'damage') {
          sum.damage.perlevel += bonus.bonus.value
          sum.damage.rounding = bonus.roundingMethod
        } else if (type === 'fortbattle') {
          let k3
          if (bonus.bonus.isSector) {
            k3 = 'fbs_' + bonus.bonus.name
          } else {
            k3 = 'fb_' + bonus.bonus.name
          }
          if (k3 in sum) {
            sum[k3].perlevel += bonus.bonus.value
            sum[k3].rounding = bonus.roundingMethod
          } else {
            onenote += 'unkn. fortbattle bonus.bonus.name ' + bonus.bonus.name + '.'
          }
        } else if (type in sum) {
          sum[type].perlevel += bonus.bonus.value
          sum[type].rounding = ''
        } else {
          onenote += 'unkn. bonus.bonus.type ' + type + '.'
        }
      } else if (bonus.type === 'fortbattle') {
        let k2
        if (bonus.isSector) {
          k2 = 'fbs_' + bonus.name
        } else {
          k2 = 'fb_' + bonus.name
        }
        if (k2 in sum) {
          sum[k2].fixed += bonus.value
        } else {
          onenote += 'unkn. fortbattle bonus.name ' + bonus.name + '.'
        }
      } else if (bonus.type === 'job') {
        if (bonus.job === 'all') { // do not yount labor points for special jobs
          sum.job.fixed += bonus.value
        } else {
          sum.jobmisc.fixed += bonus.value
        }
      } else if (bonus.type === 'skill' || bonus.type === 'attribute') {
        sum[bonus.name].fixed += bonus.value
      } else if (bonus.type in sum) {
        sum[bonus.type].fixed += bonus.value
      } else {
        onenote += 'unkn. bonus.type ' + bonus.type + '.'
      }
      if (onenote > '') {
        const h = TWDS.cyrb53(onenote)
        if (!(h in logged)) {
          logged[h] = true
          console.log('failed to understand bonus.', onenote, k, bonus)
        }
      }
      if (notice > '') notice += ' '
      notice += onenote
    }
    const handleitembonus = function (bonus) {
      for (let i = 0; i < bonus.item.length; i++) {
        const it = bonus.item[i]
        handleonesetbonus(it)
        continue
      }
      // ToDO
    }

    let notice = ''
    for (let j = 0; j < setBonuses.length; j++) {
      const bonus = setBonuses[j]
      handleonesetbonus(bonus)
    }
    if (checkedWithItems) {
      for (let j = 0; j < items.length; j++) {
        const iid = items[j]
        const item = ItemManager.getByBaseId(iid)
        if (item.type === 'right_arm') {
          if (item.sub_type === 'hand' && !checkedHand) {
            continue
          } else if (item.sub_type === 'shot' && !checkedShot) {
            continue
          }
        }
        if (item && item.bonus) {
          handleitembonus(item.bonus)
        }
        if (item.bonus.attributes.length) {
          if (notice > '') notice += ' '
          notice += 'unhandled item.bonus.attributes: ' +
            JSON.stringify(item.bonus.attributes)
        }
        if (item.bonus.skills.length) {
          if (notice > '') notice += ' '
          notice += 'unhandled item.bonus.skills: ' +
            JSON.stringify(item.bonus.skills)
        }
        if (item.bonus.fortbattle.offense) {
          sum.fb_offense.fixed += item.bonus.fortbattle.offense
        }
        if (item.bonus.fortbattle.defense) {
          sum.fb_defense.fixed += item.bonus.fortbattle.defense
        }
        if (item.bonus.fortbattle.resistance) {
          sum.fb_resistance.fixed += item.bonus.fortbattle.resistance
        }
        if (item.bonus.fortbattlesector.offense) {
          sum.fbs_offense.fixed += item.bonus.fortbattlesector.offense
        }
        if (item.bonus.fortbattlesector.defense) {
          sum.fbs_defense.fixed += item.bonus.fortbattlesector.defense
        }
        if (item.bonus.fortbattlesector.damage) {
          sum.fbs_damage.fixed += item.bonus.fortbattlesector.damage
        }
      }
    }

    for (const f of Object.keys(sum)) {
      let method = sum[f].rounding
      const vario = sum[f].perlevel
      const fixed = sum[f].fixed
      if (method === 'floatceil') { method = 'ceil' }
      if (method > '') {
        sum[f].total = fixed + Math[method](Character.level * vario)
      } else {
        sum[f].total = fixed + (Character.level * vario)
      }
    }

    let sumattributes = 0
    for (let j = 0; j < window.CharacterSkills.allAttrKeys.length; j++) {
      const y = window.CharacterSkills.allAttrKeys[j]
      sumattributes += sum[y].total
    }
    let sumskills = 0
    for (let j = 0; j < window.CharacterSkills.allSkillKeys.length; j++) {
      const y = window.CharacterSkills.allSkillKeys[j]
      sumskills += sum[y].total
    }

    // filter out the sets for one person
    if (k === 'set_damed') {
      console.log('damed', s, sum)
    }
    if (k.match(/^friendship_set_/)) {
      continue
    }
    if (s.items.length === 10) {
      if (sumattributes === 20 && sumskills === 53 && Math.abs(sum.speed.total - 0.2) < 0.01) {
        continue
      }
      if (sumattributes === 20 && sumskills === 73 && sum.speed.total < 0.01) {
        continue
      }
    }

    const muddle = function (data, post, factor, fnkey, cladd) {
      const text = (factor * data.total * 1.0).toFixed(1) + '' + post
      let title = '<b>' + (factor * data.total * 1.0).toFixed(2) + '' + post + '</b>'
      let cn = ''
      if (cladd) { cn += cladd }
      if (data.perlevel) {
        title += '<hr>'
        title += (factor * data.perlevel * 1.0).toFixed(2) + '' + post + ' per level.'
        cn += ' perlevel'
        if (data.fixed) {
          title += (factor * data.fixed * 1.0).toFixed(2) + '' + post + ' fixed.'
        }
      }

      const out = {
        nodeName: 'td',
        textContent: text,
        title: title,
        className: cn,
        dataset: {
          sortvalue: data.total,
          fn: fnkey
        }
      }
      return out
    }
    const muddlea = function (total, data, keys, post, factor, fnkey, cladd) {
      const text = (factor * total) + '' + post
      let title = '<b>' + (factor * total * 1.0).toFixed(2) + '' + post + '</b>'
      let cn = ''
      if (cladd) { cn += cladd }
      let didhr = 0
      for (let j = 0; j < keys.length; j++) {
        const y = keys[j]
        if (!didhr) {
          title += '<hr>'
          didhr = 1
        }
        if (data[y].perlevel) {
          title += (factor * data[y].perlevel).toFixed(2) + '' + post + ' ' + y + ' por nivel.<br>'
        }
        if (data[y].fixed) {
          title += (factor * data[y].fixed).toFixed(2) + '' + post + ' ' + y + '<br>'
        }
      }

      const out = {
        nodeName: 'td',
        textContent: text,
        title: title,
        className: cn,
        dataset: {
          sortvalue: data.total,
          fn: fnkey
        }
      }
      return out
    }
    if (k === 'instance_set_1') {
      console.log('Bandit', sum)
    }
    let hasw = false
    let hasa = false
    let hasc = false
    for (let j = 0; j < items.length; j++) {
      const iid = items[j]
      const item = ItemManager.getByBaseId(iid)
      if (item.type === 'animal' || item.type === 'yield') {
        hasa = true
      } else if (item.type === 'left_arm' || item.type === 'left_arm') {
        hasw = true
      } else if (item.type === 'head' || item.type === 'neck' || item.type === 'body' || item.type === 'foot' || item.type === 'belt' || item.type === 'pants') {
        hasc = true
      }
    }

    const tr = TWDS.createEle({
      nodeName: 'tr',
      dataset: {
        year: year,
        event: eventcode,
        hasweapon: hasw,
        hasanimal: hasa,
        hasclothes: hasc
      },
      children: [
        {
          nodeName: 'th',
          textContent: s.name,
          className: 'setname',
          dataset: {
            setkey: k
          }
        },
        { nodeName: 'td', textContent: year },
        { nodeName: 'td', textContent: eventname, title: k },
        { nodeName: 'td', textContent: s.items.length, className: 'maybehidden' },
        muddlea(sumattributes, sum, window.CharacterSkills.allAttrKeys, '', 1, 'attr'),
        muddle(sum.strength, '', 1, 'strength', 'maybehidden'),
        muddle(sum.flexibility, '', 1, 'flexibility', 'maybehidden'),
        muddle(sum.dexterity, '', 1, 'dexterity', 'maybehidden'),
        muddle(sum.charisma, '', 1, 'charisma', 'maybehidden'),
        muddlea(sumskills, sum, window.CharacterSkills.allSkillKeys, '', 1, 'skill'),

        muddle(sum.build, '', 1, 'build', 'maybehidden'),
        muddle(sum.punch, '', 1, 'punch', 'maybehidden'),
        muddle(sum.tough, '', 1, 'tough', 'maybehidden'),
        muddle(sum.endurance, '', 1, 'endurance', 'maybehidden'),
        muddle(sum.health, '', 1, 'health', 'maybehidden'),

        muddle(sum.ride, '', 1, 'ride', 'maybehidden'),
        muddle(sum.reflex, '', 1, 'reflex', 'maybehidden'),
        muddle(sum.dodge, '', 1, 'dodge', 'maybehidden'),
        muddle(sum.hide, '', 1, 'hide', 'maybehidden'),
        muddle(sum.swim, '', 1, 'swim', 'maybehidden'),

        muddle(sum.aim, '', 1, 'aim', 'maybehidden'),
        muddle(sum.shot, '', 1, 'shot', 'maybehidden'),
        muddle(sum.pitfall, '', 1, 'pitfall', 'maybehidden'),
        muddle(sum.finger_dexterity, '', 1, 'finger_dexterity', 'maybehidden'),
        muddle(sum.repair, '', 1, 'repair', 'maybehidden'),

        muddle(sum.leadership, '', 1, 'leadership', 'maybehidden'),
        muddle(sum.tactic, '', 1, 'tactic', 'maybehidden'),
        muddle(sum.trade, '', 1, 'trade', 'maybehidden'),
        muddle(sum.animal, '', 1, 'animal', 'maybehidden'),
        muddle(sum.appearance, '', 1, 'appearance', 'maybehidden'),

        muddle(sum.dollar, '%', 100, 'dollar'),
        muddle(sum.drop, '%', 100, 'drop'),
        muddle(sum.job, '', 1, 'job'),
        muddle(sum.luck, '%', 100, 'luck'),
        muddle(sum.pray, '', 100, 'pray'),
        muddle(sum.regen, '%', 100, 'regen'),
        muddle(sum.speed, '%', 100, 'speed'),
        muddle(sum.experience, '%', 100, 'xp'),
        muddle(sum.fb_offense, '', 1, 'fb'),
        muddle(sum.fb_defense, '', 1, 'fb'),
        muddle(sum.fb_resistance, '', 1, 'fb'),
        muddle(sum.fbs_offense, '', 1, 'fb'),
        muddle(sum.fbs_defense, '', 1, 'fb'),
        muddle(sum.fbs_damage, '', 1, 'fb'),
        {
          nodeName: 'td',
          style: {
            color: 'red'
          },
          textContent: (notice > '' ? '!' : ''),
          title: notice
        }
      ]
    })
    tbody.appendChild(tr)
    /*
     * west.storage.ItemSetManager.get(item.set);
     * var cnt = itemSet.getWornItems().length;
     * var setBonuses = itemSet.getMergedStages(cnt);
     */
  }
  console.log('itemsettable created')
  TWDS.q1('#TWDS_itemsets_filter_year', div).addEventListener('change', function (e) {
    TWDS.itemsettab.dofilter()
  })
  TWDS.q1('#TWDS_itemsets_filter_function', div).addEventListener('change', function (e) {
    TWDS.itemsettab.dofilter()
  })
  TWDS.q1('#TWDS_itemsets_filter_event', div).addEventListener('change', function (e) {
    TWDS.itemsettab.dofilter()
  })
  TWDS.q1('#TWDS_itemsets_filter_weapons', div).addEventListener('change', function (e) {
    TWDS.itemsettab.dofilter()
  })
  TWDS.q1('#TWDS_itemsets_filter_clothes', div).addEventListener('change', function (e) {
    TWDS.itemsettab.dofilter()
  })
  TWDS.q1('#TWDS_itemsets_filter_animals', div).addEventListener('change', function (e) {
    TWDS.itemsettab.dofilter()
  })
  TWDS.q1('#TWDS_itemsettable_download', div).addEventListener('click', function (e) {
    TWDS.download_table('itemsets', '#TWDS_itemset_table')
  })
  TWDS.q1('#TWDS_itemsettable_plus', div).addEventListener('click', function (e) {
    TWDS.itemsets_fontsize(+1)
  })
  TWDS.q1('#TWDS_itemsettable_minus', div).addEventListener('click', function (e) {
    TWDS.itemsets_fontsize(-1)
  })
  TWDS.q1('#TWDS_itemset_table', div).addEventListener('click', function (e) {
    const t = e.target
    if (t.classList.contains('setname')) {
      TWDS.showset.open(t.dataset.setkey)
    }
  })
  console.log('itemsettab done, dofilter version')
  const h4 = TWDS.createEle({
    nodeName: 'h4',
    textContent: 'Un poco de documentación'
  })
  div.appendChild(h4)
  const ul = TWDS.createEle('ul')
  div.appendChild(ul)
  let li = TWDS.createEle({
    nodeName: 'li',
    textContent: 'La tabla muestra información sobre los conjuntos de elementos del juego. ' +
     "Puede dar cuenta de los artículos. La mayoría de los datos se actualizan tan pronto como se actualiza el servidor, por lo que están bastante actualizados. Las únicas excepciones son el año y el nombre del evento, ya que estos se deducen de la clave configurada (algo bastante difícil si no se sigue ningún esquema). Por lo tanto, es posible que falte el año o que se desconozca el evento. Lo siento, agregaré una excepción al código en el futuro."
  })
  ul.appendChild(li)
  li = TWDS.createEle({
    nodeName: 'li',
    textContent: 'La tabla no muestra los conjuntos personales o de amistad hechos para una sola persona (estos son conjuntos de honor, no útiles en la práctica).'
  })
  ul.appendChild(li)
  li = TWDS.createEle({
    nodeName: 'li',
    textContent: 'Su nivel se utilizará para cálculos dependientes del nivel.'
  })
  ul.appendChild(li)
  li = TWDS.createEle({
    nodeName: 'li',
    textContent: 'El redondeo de atributos y habilidades no sigue el estándar del juego. El número que se muestra es la suma redondeada de atributos/habilidades, no la suma de los atributos/habilidades redondeados. Podría cambiarlo en el futuro.'
  })
  ul.appendChild(li)
  li = TWDS.createEle({
    nodeName: 'li',
    textContent: 'Los filtros funcionan de manera sustractiva: si filtra por dólares y 2017, obtendrá los conjuntos de bonificación en dólares de 2017, no todos los conjuntos de bonificación en dólares más todos los conjuntos de 2017.'
  })
  ul.appendChild(li)
  if (TWDS.settings.itemsettab_hide_columns) {
    TWDS.q1('#TWDS_itemsettable_th_attr', div).colSpan = 1
    TWDS.q1('#TWDS_itemsettable_th_skills', div).colSpan = 1
  }
  return div
}
TWDS.itemsets_fontsize = function (delta) {
  const t = window.getComputedStyle(TWDS.q1('#TWDS_itemset_table td'))
  let fs = 0
  if ('fontSize' in t) {
    fs = parseInt(t.fontSize)
  } else {
    fs = 13
  }
  fs += delta
  if (fs < 9) fs = 9
  if (fs > 29) fs = 29
  TWDS.q1('#TWDS_itemset_table').style.fontSize = fs + 'px'
}
// this is for TWDS.reload. getContent is referenced, genContent1 is accessed by name,
// so we can exchange it at runtime.
TWDS.itemsettab.getContent = function () {
  return TWDS.itemsettab.getContent1()
}
TWDS.itemsettab.dofilter = function () {
  const wantyear = TWDS.q1('#TWDS_itemsets_filter_year').value
  const wantfunction = TWDS.q1('#TWDS_itemsets_filter_function').value
  const wantevent = TWDS.q1('#TWDS_itemsets_filter_event').value
  const wantweapons = TWDS.q1('#TWDS_itemsets_filter_weapons').checked
  const wantclothes = TWDS.q1('#TWDS_itemsets_filter_clothes').checked
  const wantanimals = TWDS.q1('#TWDS_itemsets_filter_animals').checked
  const tr = TWDS.q('#TWDS_itemset_table tbody tr')
  console.log('filtering', wantfunction, wantyear)
  for (let i = 0; i < tr.length; i++) {
    tr[i].style.display = 'table-row'
    if (wantweapons) {
      if (tr[i].dataset.hasweapon !== 'true') {
        tr[i].style.display = 'none'
        continue
      }
    }
    if (wantclothes) {
      if (tr[i].dataset.hasclothes !== 'true') {
        tr[i].style.display = 'none'
        continue
      }
    }
    if (wantanimals) {
      if (tr[i].dataset.hasanimal !== 'true') {
        tr[i].style.display = 'none'
        continue
      }
    }
    if (wantyear === 'missing') {
      const y = parseInt(tr[i].dataset.year)
      if (y !== 0) {
        tr[i].style.display = 'none'
        continue
      }
    } else if (wantyear > '') {
      const y = parseInt(tr[i].dataset.year)
      if (parseInt(wantyear) !== y) {
        tr[i].style.display = 'none'
        continue
      }
    }
    if (wantevent > '') {
      if (tr[i].dataset.event !== wantevent) {
        tr[i].style.display = 'none'
        continue
      }
    }
    if (wantfunction > '') {
      const td = TWDS.q1('td[data-fn=' + wantfunction + ']', tr[i])
      if (!td) {
        // huh?
        continue
      }
      const v = parseFloat(td.textContent)
      if (v === 0.0) {
        tr[i].style.display = 'none'
        continue
      }
    }
  }
}
TWDS.itemsettab.activate = function () {
  TWDS.activateTab('itemsets')
  const tab = TWDS.q1('#TWDS_itemset_table')
  tab.addEventListener('click', function (e) {
    const t = e.target
    if (t.classList.contains('setname')) {
      TWDS.showset.open(t.dataset.setkey)
    }
  })
}
TWDS.itemsettab.openwindow = function (paraitems) {
  const myname = 'TWDS_itemset_window'
  const win = wman.open(myname, TWDS._('ITEMSETS_TITLE', 'Conjuntos'), 'TWDS_wide_window')
  win.setMiniTitle('Conjuntos')
  const sp = new west.gui.Scrollpane()
  const content = TWDS.itemsettab.getContent()
  sp.appendContent(content)
  win.appendToContentPane(sp.getMainDiv())
}

TWDS.registerStartFunc(function () {
  TWDS.registerExtra('TWDS.itemsettab.openwindow', 'Conjuntos', 'Lista todos los conjuntos')
})
// vim: tabstop=2 shiftwidth=2 expandtab

TWDS.genCalc = function (bonusNames, skills, include) {
  const o = TWDS.genCalc.exec(bonusNames, skills, include)
  return o.combos[0][1]
}
TWDS.genCalc.exec = function (bonusNames, skills, include) {
  if (!include) include = 1 // owned
  const availableSets = TWDS.genCalc.setfilter(include)

  const bires = TWDS.genCalc.getBestItems(bonusNames, skills, include)
  const bestItems = bires[0]
  const goodItems = bires[1]
  // console.log('bestItems', bestItems)
  // console.log('goodItems', goodItems)

  for (let i = 0; i < bestItems.length; i++) {
    bestItems[i] = ItemManager.get(bestItems[i])
  }
  // console.log('bestItems', TWDS.describeItemCombo(bestItems))

  const bestItemsContainer = new west.item.ItemSetContainer()
  for (let i = 0; i < bestItems.length; i++) { bestItemsContainer.addItem(bestItems[i].getId()) }

  // console.log('availableSets', availableSets)
  let sets = TWDS.genCalc.createSubsets(availableSets, bestItems, bonusNames, skills)
  // console.log('subsets', sets)
  // klappt nichts, so kann man speed nicht optimieren
  // MUSS man aber vielleicht?
  sets = TWDS.genCalc.filterUneffectiveSets(sets, bonusNames, skills)
  // console.log('subsets after filter', sets)
  if (sets.length > 1000) { return }

  // Was fehlt: FillEmpty(combinesets, BestItems,AllItemsWithSpeedBonus)

  sets = west.item.Calculator.fillEmptySlots(west.item.Calculator.combineSets(sets), bestItems)
  sets.push(bestItemsContainer)
  // console.log('mergedsets', sets)

  let bestPoints = -1
  // let best = null
  const setsandpoints = []
  for (let i = 0; i < sets.length; i++) {
    const spd = TWDS.genCalc.calcCombinedSet(sets[i], bonusNames, skills)
    setsandpoints[i] = [spd, sets[i]]
    if (spd > bestPoints) {
      bestPoints = spd
      // best = sets[i]
      // console.log(TWDS.describeItemCombo(TWDS.genCalc.getItems(sets[i])), sets[i], TWDS.genCalc.getItems(sets[i]), spd)
    }
  }
  setsandpoints.sort(function (a, b) {
    return (b[0] - a[0])
  })
  // console.log('best', bestPoints, best)
  // console.log('bestx', setsandpoints)
  // console.log('bestItems', bestItems)
  for (let i = 0; i < bestItems.length; i++) {
    bestItems[i] = bestItems[i].getId()
  }
  const ret = {
    combos: [],
    items: goodItems
  }
  const merk = {}
  for (let i = 0; i < setsandpoints.length; i++) {
    const one = setsandpoints[i][1]
    const pts = setsandpoints[i][0]
    const items = TWDS.genCalc.getItems(one)
    // console.log("S&P",one,pts,items);
    let flag = 0
    for (let j = 0; j < items.length; j++) {
      const k = items[j]
      if (k in merk) {
        flag++
      }
    }
    let limit = 10 - ret.combos.length
    if (limit < 4) limit = 4
    //     console.log('CHECK', pts, one, items, merk, 'check', flag, '<', limit)
    if (flag < limit) {
      ret.combos.push([pts, items])
      for (let j = 0; j < items.length; j++) {
        const itno = items[j]
        if (!(itno in merk)) merk[itno] = 0
        merk[itno]++
      }
    }
  }
  return ret
}
TWDS.genCalc.blacklist = {}
TWDS.genCalc.fillblacklist = function () {
  const a = [
    51266000, // goldener westenland reiter,
    51267000, // silberner westenland reiter,
    51268000, // bronze westenland reiter,
    51461000, // goldmedaille 2019
    51462000, // silberj 2019
    51463000, // bronze 2019
    53368000, // goldenes ticket
    52116000, // IFBC 3 shirt
    1017000, // creativity weapon
    1018000, // creativity weapon
    53364000, // goldenes eventwelt pferd
    53365000, // goldenes eventwelt pferd
    53366000, // goldenes eventwelt pferd
    53367000 // goldenes eventwelt pferd
  ]
  if (a[0] in TWDS.genCalc.blacklist) return
  const whitesets = {
    gold_set: true, // old golden set
    '2018_doldenset': true, // new golden set, (sic)
    malachit_set_1: true, // malachit-set, gab es bei Speedwelten?
    community_event_2020_march_2: true, // clover, event-set
    eire_set_3: true // event
  }
  for (let i = 0; i < a.length; i++) {
    TWDS.genCalc.blacklist[a[i]] = 1
  }
  west.storage.ItemSetManager.getAll().forEach(cl => {
    if (cl.items.length === 3 && !(cl.key in whitesets)) {
      let isweaponset = true
      let anyauctionable = false
      for (let j = 0; j < cl.items.length; j++) {
        const it = ItemManager.getByBaseId(cl.items[j])
        if (it.type !== 'right_arm' && it.type !== 'left_arm') {
          isweaponset = false
        }
        anyauctionable |= it.auctionable
      }
      if (isweaponset && !anyauctionable) {
        for (let j = 0; j < cl.items.length; j++) {
          const it = ItemManager.getByBaseId(cl.items[j])
          TWDS.genCalc.blacklist[it.item_id] = 2
        }
      }
    }
  })
}
TWDS.genCalc.blacklistwindow = function () {
  const myname = 'TWDS_gencalc_blackwindow'
  const win = wman.open(myname, TWDS._('GENCALC_BLACKLIST_TITLE', 'Lista negra'), 'TWDS_gencalc_blackwindow')
  win.setMiniTitle('Blacklist')
  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_gencalc_blackcontainer'
  })
  TWDS.createEle('p', {
    innerHTML: 'Esta lista negra incluye una serie de elementos que solo puede obtener/ganar en mundos de eventos, y no conjuntos de armas subastables, es decir, conjuntos de ganadores de eventos en el juego (pago para ganar) y personales. Elimina mucho ruido de la ventana de la calculadora.<br>Las entradas de la lista negra se ignoran si eres propietario del artículo, por lo que los pocos que ganaron un evento no deben preocuparse.',
    last: content
  })
  const dl = TWDS.createEle('table', {
    last: content
  })
  TWDS.genCalc.fillblacklist()
  for (const [id, d] of Object.entries(TWDS.genCalc.blacklist)) {
    const it = ItemManager.get(id)
    const tr = TWDS.createEle('tr', { last: dl })
    const w = new tw2widget.InventoryItem(it).setCharacter(Character).getMainDiv()
    TWDS.createEle('th', {
      children: [w[0]],
      last: tr
    })
    TWDS.createEle('th', {
      textContent: it.name,
      last: tr
    })
    TWDS.createEle('td', {
      textContent: d === 1 ? 'artículo codificado en la lista negra' : 'nconjunto de armas no subastables',
      last: tr
    })
  }
  sp.appendContent(content)

  win.appendToContentPane(sp.getMainDiv())
}

TWDS.genCalc.setfilter = function (include) {
  // console.log('INC', include)
  const availableSets = []
  TWDS.genCalc.fillblacklist()
  const allSets = west.storage.ItemSetManager.getAll()
  for (let i = 0; i < allSets.length; i++) {
    const set = allSets[i]
    const items = set.items
    const o = []
    for (let j = 0; j < items.length; j++) {
      const itemId = items[j] // base item ids
      const item = ItemManager.getByBaseId(itemId)
      if ((include & 16) || item.wearable()) {
        if (include & 1) { // owned
          const x = Bag.getItemsIdsByBaseItemId(itemId)
          if (x.length) {
            o.push(x[0]) // itemid
            continue
          }
          if (Wear.carries(itemId)) {
            o.push(Wear.getByBaseId(itemId).getId())
            continue
          }
        }
        if (include & 2) { // autionable
          if (item.auctionable) {
            o.push(item.getId())
            continue
          }
        }
        if (include & 4) {
          if (item.tradeable && item.traderlevel < 66 && item.traderlevel !== null) {
            o.push(item.getId())
            continue
          }
        }
        if (include & 8) { // not auctionable stuff
          if (!item.auctionable) {
            let blacklisted = false
            if (!(include & 32)) {
              if (item.getId() in TWDS.genCalc.blacklist) {
                blacklisted = true
              }
            }
            if (!blacklisted) { o.push(item.getId()) }
            continue
          }
        }
      }
    }
    if (o.length) {
      availableSets.push(new west.item.ItemSet({
        key: set.key,
        items: o,
        bonus: set.bonus
      }))
    }
  }
  return availableSets
}

TWDS.genCalc.filterUneffectiveSets = function (sets, bonusNames, skills) {
  const r = []
  const bestBySlots = {}
  for (let i = 0; i < sets.length; i++) {
    // setValue = sets[i].getSetValue(skills, jobId);
    const tmp = TWDS.genCalc.getSetGenValues(sets[i], bonusNames, skills)
    const speed = TWDS.genCalc.calc2(tmp.theBonus, tmp.theSecondary)
    if (speed < 0.001) { continue }
    const slots = JSON.stringify(sets[i].getUsedSlots().sort())
    if (!bestBySlots[slots]) {
      bestBySlots[slots] = [speed, sets[i]]
    } else {
      if (bestBySlots[slots][0] < speed) { bestBySlots[slots] = [speed, sets[i]] }
    }
  }
  for (const i in bestBySlots) {
    r.push(bestBySlots[i][1])
  }
  return r
}

TWDS.genCalc.getItems = function (set) {
  const it = []
  for (let i = 0; i < set.items.length; i++) { it.push(set.items[i]) }
  for (const oneset of Object.values(set.sets)) {
    for (let i = 0; i < oneset.items.length; i++) { it.push(oneset.items[i]) }
  }
  const o = []
  const slots = Wear.slots
  for (let i = 0; i < slots.length; i++) {
    const sl = slots[i]
    for (let j = 0; j < it.length; j++) {
      const one = ItemManager.get(it[j])
      if (one.type === sl) {
        o.push(it[j])
      }
    }
  }

  return o
}

TWDS.genCalc.calcCombinedSet = function (set, bonusNames, skills) {
  const tmp = TWDS.genCalc.getCombinedSetGenValues(set, bonusNames, skills)
  return TWDS.genCalc.calc2(tmp.theBonus, tmp.theSecondary)
}

TWDS.genCalc.createCombinations = function (items, k) {
  let i, j, combs, head, tailcombs
  if (k > items.length || k <= 0) {
    return []
  }
  if (k === items.length) {
    return [items]
  }
  if (k === 1) {
    combs = []
    for (i = 0; i < items.length; i++) {
      combs.push([items[i]])
    }
    return combs
  }
  combs = []
  for (i = 0; i < items.length - k + 1; i++) {
    head = items.slice(i, i + 1)
    tailcombs = TWDS.genCalc.createCombinations(items.slice(i + 1), k - 1)
    for (j = 0; j < tailcombs.length; j++) {
      combs.push(head.concat(tailcombs[j]))
    }
  }
  return combs
}
TWDS.genCalc.createSubsets = function (fullSets, bestItems, bonusNames, skills) {
  let i; const sets = []; let set; let j; let permutations; let k; let l; let tmpSet
  for (i = 0; i < fullSets.length; i++) {
    set = fullSets[i]
    let items
    if (('range' in bonusNames) || ('melee' in bonusNames)) {
      items = []
      for (j = 0; j < set.items.length; j++) {
        const it = ItemManager.get(set.items[j])
        if (it.type === 'right_arm') {
          if ('melee' in bonusNames && it.sub_type !== 'hand') continue
          if ('range' in bonusNames && it.sub_type !== 'shot') continue
        }
        items.push(set.items[j])
      }
    } else {
      items = set.items
    }
    for (j = items.length; j > 0; j--) {
      if (!Object.prototype.hasOwnProperty.call(set.bonus, j)) { continue }
      // if (!set.bonus.hasOwnProperty(j)) { continue }
      permutations = TWDS.genCalc.createCombinations(items, j)
      for (k = 0, l = permutations.length; k < l; k++) {
        if (!west.item.Calculator.itemsCombineable(permutations[k])) { continue }
        tmpSet = new west.item.ItemSet({
          key: set.key,
          items: permutations[k],
          bonus: set.bonus
        })
        if (!TWDS.genCalc.beatsBestItems(tmpSet, bestItems, bonusNames, skills)) { continue }
        sets.push(tmpSet)
      }
    }
  }
  return sets
}

TWDS.genCalc.beatsBestItems = function (set, bestItems, bonusNames, skills) {
  // find out what the best items give us.
  let bestItemBonus = 0
  let bestItemSecondary = 0

  const setSlots = set.getUsedSlots()
  for (let i = 0; i < bestItems.length; i++) {
    if (setSlots.indexOf(bestItems[i].getType()) === -1) { continue }
    const v = TWDS.genCalc.getGenValues(bestItems[i], bonusNames, skills)
    bestItemBonus += v.theBonus
    bestItemSecondary += v.theSecondary
  }
  const biSpeed = TWDS.genCalc.calc2(bestItemBonus, bestItemSecondary)
  const setData = TWDS.genCalc.getSetGenValues(set, bonusNames, skills)
  if (isNaN(setData.theBonus)) {
    console.log('isNaN trap', 'bBI', set, bonusNames, skills)
  }
  const setSpeed = TWDS.genCalc.calc2(setData.theBonus, setData.theSecondary, bestItems)
  return setSpeed > biSpeed // || setData.speedBonus > bestItemSpeedBonus
}

TWDS.genCalc.getBestItems = function (bonusNames, skills, include) {
  const bestItems = {}
  const result = []
  const itemsByBase = {}
  TWDS.genCalc.fillblacklist()
  const add = function (base, lng) {
    const x = ItemManager.getByBaseId(base)
    if (!x) return
    if (!x.wearable() && !(include & 16)) return
    lng = parseInt(lng) // some come as strings.
    if (base in itemsByBase) {
      // keep the _highest_ leveled item only
      if (itemsByBase[base] < lng) { itemsByBase[base] = lng }
    } else {
      itemsByBase[base] = lng
    }
  }

  const all = ItemManager.getAll()
  for (const bid in all) {
    if (include & 1) {
      const y = Bag.getItemsIdsByBaseItemId(bid)
      if (y.length) {
        add(bid, y[0])
      }
    }
    const item = all[bid]
    if (include & 2) { // auction
      if (item.auctionable) {
        add(bid, item.item_id)
      }
    }
    if (include & 4) { // trader
      if (item.tradeable && item.traderlevel < 66 && item.traderlevel !== null) {
        add(bid, item.item_id)
      }
    }
    if (include & 8) {
      if (!item.auctionable) {
        let blacklisted = false
        if (!(include & 32)) {
          if (item.item_id in TWDS.genCalc.blacklist) {
            blacklisted = true
          }
        }
        if (!blacklisted) {
          add(bid, all[bid].item_id)
        }
      }
    }
  }
  if (include & 1) { // owned shall include worn
    const slots = Wear.slots
    for (let i = 0; i < slots.length; i++) {
      const sl = slots[i]
      const it = Wear.get(sl)
      if (it) {
        // console.log('ADD8', it.obj.name,it)
        add(it.obj.item_base_id, it.obj.item_id)
      }
    }
  }

  delete itemsByBase[41999] // allmighty ...
  delete itemsByBase[1337] // sword of a thousand truths
  // console.log("TMP",itemsByBase);

  west.common.forEach(itemsByBase, function (itemid, baseId) {
    const item = ItemManager.get(itemid)
    const type = item.getType()
    if (type === 'right_arm') {
      if ('range' in bonusNames && item.sub_type !== 'shot') {
        return
      }
      if ('melee' in bonusNames && item.sub_type !== 'hand') {
        return
      }
    }
    bestItems[type] = bestItems[type] || []
    // const value = item.getValue(skills)
    const value = TWDS.genCalc.getGenValues(item, bonusNames, skills)
    if (item.getId() === 229000 || item.getId() === 229001) {
      // console.log('I', item, item.getId, value)
    }

    if ((value.theBonus || value.theSecondary) && (item.wearable() || (include & 16))) {
      bestItems[type].push({
        item: item,
        id: item.getId(),
        base_id: baseId,
        value: value
      })
    }
  })
  // console.log("BI",bestItems);

  const other = {}
  const slots = Wear.slots
  for (let i = 0; i < slots.length; i++) {
    const type = slots[i]
    if (type in bestItems) {
      bestItems[type].sort(function (a, b) {
        const aSpeed = TWDS.genCalc.calc2(a.value.theBonus, a.value.theSecondary)
        const bSpeed = TWDS.genCalc.calc2(b.value.theBonus, b.value.theSecondary)
        return (bSpeed - aSpeed)
      })
      other[type] = []
      if (bestItems[type].length) { // "recipe" has length 0
        result.push(bestItems[type][0].item.getId())
        for (let i = 0; i < bestItems[type].length && i < 10; i++) {
          other[type].push(bestItems[type][i].item.getId())
        }
      }
    }
  }
  return [result, other]
}
TWDS.genCalc.calc2 = function (theBonus, theSecondary) {
  return theBonus + theSecondary
}

// a modified version of west.item.Item.getValue
// -jobPoints
// +speed bonus
TWDS.genCalc.getGenValues = function (item, bonusNames, skills) {
  let value = 0
  let theBonus = 0
  const attributes = {}
  let skill
  let attr
  const skillAddition = {}
  let skillArr
  let i
  let memo = 'TWDSgC'
  const debug = false
  // if (item.item_id === 51006000) { debug = true; console.log('GG', item) }
  for (const bonusname in bonusNames) {
    bonusNames[bonusname] = parseInt(bonusNames[bonusname])
    if (bonusNames[bonusname]) {
      memo = memo + '.' + bonusname + '=' + bonusNames[bonusname]
    }
  }
  for (const skillname in skills) {
    skills[skillname] = parseInt(skills[skillname])
    if (skills[skillname]) {
      memo = memo + '.' + skillname + '=' + skills[skillname]
    }
  }

  let bonusExtractor
  let affectedSkills

  if (!('_memo' in item)) item._memo = {} // this happens.
  if (debug) item._memo = {}
  if (item._memo[memo]) { return item._memo[memo] }

  for (skill in skills) {
    if (!skills[skill]) { continue }
    attr = CharacterSkills.getAttributeKey4Skill(skill)
    attributes[attr] = (attributes[attr] || 0) + 1
  }

  for (attr in item.bonus.attributes) {
    if (!attributes[attr]) { continue }
    skillArr = CharacterSkills.getSkillKeys4Attribute(attr)
    for (i = 0; i < skillArr.length; i++) {
      if (skills[skillArr[i]]) { skillAddition[skillArr[i]] = item.bonus.attributes[attr] }
    }
  }

  if (debug) console.log('HIB?', item.hasItemBonus())
  if (item.hasItemBonus()) {
    bonusExtractor = new west.item.BonusExtractor(Character, item.getItemLevel())
    for (i = 0; i < item.bonus.item.length; i++) {
      const b = bonusExtractor.getExportValue(item.bonus.item[i])

      if (debug) console.log('IB', i, b.key, b.value)
      if (b.key in bonusNames) { theBonus += b.value * bonusNames[b.key] } else {
        const old = theBonus
        if (b.key === 'fort_defense' && 'fbdefense' in bonusNames) {
          theBonus += b.value * bonusNames.fbdefense
        }
        if (b.key === 'fort_defense_sector' && 'fbdefense_sector' in bonusNames) {
          theBonus += b.value * bonusNames.fbdefense
        }
        if (b.key === 'fort_offense' && 'fboffense' in bonusNames) {
          theBonus += b.value * bonusNames.fboffense
        }
        if (b.key === 'fort_offense_sector' && 'fboffense_sector' in bonusNames) {
          theBonus += b.value * bonusNames.fboffense
        }
        if (b.key === 'fort_resistance' && 'fbresistance' in bonusNames) {
          theBonus += b.value * bonusNames.fbresistance
        }
        if (b.key === 'fort_damage_sector' && 'fbdamage' in bonusNames) {
          theBonus += b.value * bonusNames.fbdamage
        }
        if (isNaN(theBonus)) {
          console.log('isNaN trap', b.key, b.value, old, item, bonusNames)
          break
        }
      }
      affectedSkills = bonusExtractor.getAffectedSkills(item.bonus.item[i])
      for (skill in affectedSkills) {
        if (!(skill in skills)) { continue }
        value += skills[skill] * affectedSkills[skill]
      }
    }
  }
  if ('fortbattle' in item.bonus) {
    if (item.bonus.fortbattle.offense && 'fboffense' in bonusNames) {
      theBonus += item.bonus.fortbattle.offense * bonusNames.fboffense
    }
    if (item.bonus.fortbattle.defense && 'fbdefense' in bonusNames) {
      theBonus += item.bonus.fortbattle.defense * bonusNames.fbdefense
    }
    if (item.bonus.fortbattle.resistance && 'fbresistance' in bonusNames) {
      theBonus += item.bonus.fortbattle.resistance * bonusNames.fbresistance
    }
  }
  if ('fortbattlesector' in item.bonus) {
    if (item.bonus.fortbattlesector.offense && 'fboffense_sector' in bonusNames) {
      theBonus += item.bonus.fortbattlesector.offense * bonusNames.fboffense_sector
    }
    if (item.bonus.fortbattlesector.defense && 'fbdefense_sector' in bonusNames) {
      theBonus += item.bonus.fortbattlesector.defense * bonusNames.fbdefense_sector
    }
    if (item.bonus.fortbattlesector.damage && 'fbdamage' in bonusNames) {
      theBonus += item.bonus.fortbattlesector.damage * bonusNames.fbdamage
    }
  }
  /*
  for (const [k, factor] of Object.entries(bonusNames)) {
    if (k === 'fbdefense') {
      if ('fortbattle' in bonus && 'defense' in bonus.fortbattle) { boni.theBonus += bonus.fortbattle.defense * factor }
    } else if (k === 'fboffense') {
      if ('fortbattle' in bonus && 'offense' in bonus.fortbattle) { boni.theBonus += bonus.fortbattle.offense * factor }
    } else if (k === 'fbdefense_sector') {
      if ('fortbattlesector' in bonus && 'defense' in bonus.fortbattlesector) { boni.theBonus += bonus.fortbattlesector.defense * factor }
    } else if (k === 'fboffense_sector') {
      // console.log('NOT IMPL', 'gsBGV0', k, bonus,set, set.key)
      // console.log('NOT IMPL', 'gsBGV0', k, bonus)
      if ('fortbattlesector' in bonus && 'offense' in bonus.fortbattlesector) { boni.theBonus += bonus.fortbattlesector.offense * factor }
    } else if (k === 'fbdamage') {
      if ('fortbattle' in bonus && 'damage' in bonus.fortbattle) { boni.theBonus += bonus.fortbattle.damage * factor }
    } else if (k === 'fbresistance') {
      if ('fortbattle' in bonus && 'resistance' in bonus.fortbattle) { boni.theBonus += bonus.fortbattle.resistance * factor }
    } else if (k === 'joball') {
      if ('job' in bonus && 'all' in bonus.job) { boni.theBonus += bonus.job.all * factor }
    } else if (k === 'melee') { // do nothing
    } else if (k === 'range') { // do nothing
    } else {
      boni.theBonus += bonus[k] * factor
    }
    if (isNaN(boni.theBonus)) {
      console.log('isNaN trap', 'gsBGV0', k, bonus)
      break
    }
  }
  */
  for (skill in skills) {
    if (item.bonus.skills[skill] || skillAddition[skill]) {
      value += skills[skill] * ((item.bonus.skills[skill] || 0) + (skillAddition[skill] || 0))
    }
  }
  if (item.usebonus || item.action) { value = 0 }
  const out = {
    theBonus: theBonus,
    theSecondary: value
  }
  item._memo[memo] = out
  return out
}

TWDS.genCalc.getCombinedSetGenValues = function (combo, bonusNames, skills) {
  const boni = {
    theBonus: 0,
    theSecondary: 0
  }
  for (let i = 0; i < combo.sets.length; i++) {
    const v = TWDS.genCalc.getSetGenValues(combo.sets[i], bonusNames, skills)
    boni.theBonus += v.theBonus
    boni.theSecondary += v.theSecondary
  }
  for (let i = 0; i < combo.items.length; i++) {
    const item = ItemManager.get(combo.items[i])
    const v = TWDS.genCalc.getGenValues(item, bonusNames, skills)
    boni.theBonus += v.theBonus
    boni.theSecondary += v.theSecondary
  }
  return boni
}

TWDS.genCalc.getSetGenValues = function (set, bonusNames, skills) {
  const boni = {
    theBonus: 0,
    theSecondary: 0
  }
  const v = TWDS.genCalc.getSetBonusGenValues(set, bonusNames, skills)
  boni.theBonus = v.theBonus
  boni.theSecondary = v.theSecondary
  let i
  for (i = 0; i < set.items.length; i++) {
    const item = ItemManager.get(set.items[i])
    const v = TWDS.genCalc.getGenValues(item, bonusNames, skills)
    boni.theBonus += v.theBonus
    boni.theSecondary += v.theSecondary
  }
  return boni
}
TWDS.genCalc.getSetBonusGenValues = function (set, bonusNames, skills) {
  const boni = {
    theBonus: 0,
    theSecondary: 0
  }
  const bonus = TWDS.genCalc.ItemSet.getMergedBonus(set)
  const memo = 'TWDS.gSBGV.' + JSON.stringify(bonusNames) + '.' + JSON.stringify(skills)

  if (!('_memo' in set)) set._memo = {} // this happens for merged sets.
  //  if (set.key === "set_oktoberfest_2016_1") { console.log("CC",set.key,set,bonusNames,bonus); }
  // if (set.key === 'dod_2018_set_6') { console.log('CC', set.key, set, bonusNames, bonus) }

  // if (!(memo in set._memo)) console.log("merge",set,bonus)

  if (set._memo[memo]) { return set._memo[memo] }

  if (skills) {
    for (const skill in skills) {
      if (bonus.skill[skill]) { boni.theSecondary += bonus.skill[skill] * skills[skill] }
      const attr = CharacterSkills.getAttributeKey4Skill(skill)
      if (bonus.attribute[attr]) { boni.theSecondary += bonus.attribute[attr] * skills[skill] }
    }
  }
  for (const [k, factor] of Object.entries(bonusNames)) {
    if (k === 'fbdefense') {
      if ('fortbattle' in bonus && 'defense' in bonus.fortbattle) { boni.theBonus += bonus.fortbattle.defense * factor }
    } else if (k === 'fboffense') {
      if ('fortbattle' in bonus && 'offense' in bonus.fortbattle) { boni.theBonus += bonus.fortbattle.offense * factor }
    } else if (k === 'fbdefense_sector') {
      if ('fortbattlesector' in bonus && 'defense' in bonus.fortbattlesector) { boni.theBonus += bonus.fortbattlesector.defense * factor }
    } else if (k === 'fboffense_sector') {
      // if (set.key === "set_oktoberfest_2016_1") console.log('NOT IMPL', 'gsBGV0', k, bonus,set, set.key)
      // console.log('NOT IMPL', 'gsBGV0', k, bonus)
      if ('fortbattlesector' in bonus && 'offense' in bonus.fortbattlesector) { boni.theBonus += bonus.fortbattlesector.offense * factor }
    } else if (k === 'fbdamage') {
      if ('fortbattle' in bonus && 'damage' in bonus.fortbattle) { boni.theBonus += bonus.fortbattle.damage * factor }
      if ('fortbattlesector' in bonus && 'damage' in bonus.fortbattlesector) { boni.theBonus += bonus.fortbattlesector.damage * factor }
    } else if (k === 'fbresistance') {
      if ('fortbattle' in bonus && 'resistance' in bonus.fortbattle) { boni.theBonus += bonus.fortbattle.resistance * factor }
    } else if (k === 'joball') {
      if ('job' in bonus && 'all' in bonus.job) { boni.theBonus += bonus.job.all * factor }
    } else if (k.startsWith('job_')) {
      const jid = parseInt(k.substring(4))
      if ('job' in bonus && jid in bonus.job) { boni.theBonus += bonus.job[jid] * factor }
    } else if (k === 'melee') { // do nothing
    } else if (k === 'range') { // do nothing
    } else {
      boni.theBonus += bonus[k] * factor
    }
    if (isNaN(boni.theBonus)) {
      console.log('isNaN trap', 'gsBGV0', k, bonus)
      break
    }
  }

  if (isNaN(boni.theBonus)) {
    console.log('isNaN trap', 'gSBGV', boni, set, bonusNames, skills)
  }
  set._memo[memo] = boni
  return boni
}

// copy of ItemSet.getMergedBonus, with dollar/damage init fixed, and this replaced by set para
TWDS.genCalc.ItemSet = {}

TWDS.genCalc.ItemSet.getMergedBonus = function (set) {
  if (set._mergedBonus) { return set._mergedBonus }
  const bonus = {
    damage: 0,
    dollar: 0,
    attribute: {},
    skill: {},
    job: {},
    speed: 0,
    regen: 0,
    luck: 0,
    pray: 0,
    drop: 0,
    fortbattle: {},
    experience: 0
  }; const bonusObjects = TWDS.genCalc.ItemSet.getMergedStages(set); let i; let b; const bonusExtractor = new west.item.BonusExtractor(Character)
  const merge = function (b, value) {
    // if (set.key === 'set_oktoberfest_2016_1') console.log('MERGE', b, value)
    switch (b.type) {
      case 'skill':
      case 'attribute':
      case 'fortbattle':
        if (b.isSector) {
          if (!('fortbattlesector' in bonus)) {
            bonus.fortbattlesector = {}
          }
          bonus.fortbattlesector[b.name] = (bonus.fortbattlesector[b.name] || 0) + value
        } else {
          bonus[b.type][b.name] = (bonus[b.type][b.name] || 0) + value
        }
        break
      case 'job':
        bonus.job[b.job] = (bonus.job[b.job] || 0) + value
        break
      case 'speed':
      case 'regen':
      case 'luck':
      case 'pray':
      case 'drop':
      case 'experience':
      case 'damage':
      case 'dollar':
        bonus[b.type] += value
        break
      case 'character':
        merge(b.bonus, bonusExtractor.getCharacterItemValue(b))
        break
      default:
        if (window.DEBUG) { console.log('ItemSet: unknown bonus to merge: ', b.type) }
        break
    }
  }
  for (i = 0; i < bonusObjects.length; i++) {
    b = bonusObjects[i]
    merge(b, b.value)
  }
  return (set._mergedBonus = bonus)
}

TWDS.genCalc.ItemSet.getMergedStages = function (set, cntPar) {
  let stage
  const bonus = []
  let bb
  const cnt = cntPar !== undefined ? cntPar : set.items.length
  let i
  let b
  const merge = function (b, value) {
    let found = false
    let bLen = bonus.length
    while (bLen--) {
      bb = bonus[bLen]
      if (b.type !== bb.type) { continue }
      if (b.type === 'character' && b.roundingMethod === bb.roundingMethod && b.key === bb.key && b.bonus.type === bb.bonus.type && b.bonus.name === bb.bonus.name) {
        found = true
        bb.bonus.value += b.bonus.value
      } else if (b.type === 'job' && b.job === bb.job) {
        found = true
        bb.value += b.value
      } else if (['speed', 'regen', 'luck', 'pray', 'experience', 'dollar', 'damage', 'drop'].indexOf(b.type) !== -1) {
        found = true
        bb.value += b.value
      } else if (['skill', 'attribute', 'fortbattle'].indexOf(b.type) !== -1 && b.name === bb.name && bb.isSector === b.isSector) {
        found = true
        bb.value += b.value
      }
    }
    if (found) { return }
    bonus.push(window.clone(b))
  }
  for (stage in set.bonus) {
    if (parseInt(stage, 10) > cnt) { continue }
    for (i = 0; i < set.bonus[stage].length; i++) {
      b = set.bonus[stage][i]
      merge(b, b.value)
    }
  }
  return bonus
}
TWDS.storage = {}

TWDS.storage.data = {}
TWDS.storage.dropperhour = {}
TWDS.storage.reload = function () {
  const d = window.localStorage.getItem('TWDS_storage') || '{}'
  TWDS.storage.data = JSON.parse(d) || {}
  const aj = JobsModel.Jobs
  for (let i = 0; i < aj.length; i++) {
    const job = aj[i]
    const yields = job.jobObj.yields
    for (const [itemid, d] of Object.entries(yields)) {
      const n = TWDS.TWDBcalcProductRate(300, 50, d.prop * 63.98, 100, 1)
      if (!(itemid in TWDS.storage.dropperhour)) {
        TWDS.storage.dropperhour[itemid] = n
      } else if (n > TWDS.storage.dropperhour[itemid]) {
        TWDS.storage.dropperhour[itemid] = n
      }
    }
  }
}
TWDS.storage.save = function () {
  const d = JSON.stringify(TWDS.storage.data)
  window.localStorage.setItem('TWDS_storage', d)
}

TWDS.registerSetting('bool', 'storageMapIcon',
  TWDS._('STORAGE_MARK_JOBGROUPS', 'Marcar en el mapa los grupos de trabajos de los artículos que nos faltan.'),
  true, null, 'Mapa')

TWDS.storage.startSearch = function (name) {
  // var amount = parseInt($('#WTKExtendedItemFinder_searchDialog_targetAmount').val());
  const ssc = document.getElementById('TWDS_storage_select_container')
  const all = ItemManager.getAll()
  const lowToSearch = name.toLowerCase()
  TWDS.storage.reload()
  if (name > '') {
    ssc.innerHTML = '<tr><th><th>Name<th>Count<th>ID<th>'
    ssc.innerHTML = ''
    TWDS.createEle({
      nodeName: 'tr',
      children: [
        { nodeName: 'th' },
        { nodeName: 'th', textContent: TWDS._('STORAGE_NAME', 'Nombre') },
        { nodeName: 'th', textContent: TWDS._('STORAGE_COUNT', 'Cuenta') },
        { nodeName: 'th', textContent: TWDS._('STORAGE_ID', 'Id') }
      ],
      last: ssc
    })
    let count = 0

    for (const it of Object.values(all)) {
      if (it.item_level !== 0) continue
      if (it.item_id in TWDS.storage.data) continue

      if (it.name.toLowerCase().indexOf(lowToSearch) >= 0) {
        ssc.classList.add('active')
        const popup = new ItemPopup(it, {}).popup.getXHTML()

        const tr = TWDS.createElement({
          nodeName: 'tr',
          dataSet: { item_id: it.item_id },
          childNodes: [
            {
              nodeName: 'td',
              childNodes: [
                { nodeName: 'img', className: 'tw_item inventory_item', src: it.image, alt: it.name, title: popup }
              ]
            },
            { nodeName: 'td', textContent: it.name, title: popup },
            { nodeName: 'td', textContent: Bag.getItemCount(it.item_id) },
            { nodeName: 'td', textContent: it.item_id },
            {
              nodeName: 'td',
              childNodes: [
                {
                  nodeName: 'button',
                  textContent: TWDS._('STORAGE_ADD_THIS', 'Agregar esto'),
                  classList: ['TWDS_button', 'TWDS_storage_addthis']
                }
              ]
            }
          ]
        })
        ssc.appendChild(tr)
        count++
      }
    }
    const ss = document.getElementById('TWDS_storage_select')
    if (count) {
      ss.classList.add('visible')
    } else {
      ss.classList.remove('visible')
    }
  } else {
    ssc.innerHTML = ''
  }
  // and now for the main list
  $('#TWDS_storage_list .datarow').each(function (idx, row) {
    const iid = row.dataset.item_id
    const item = ItemManager.get(iid)
    if (item.name.toLowerCase().indexOf(lowToSearch) >= 0) {
      row.style.display = 'table-row'
    } else {
      row.style.display = 'none'
    }
  })
}

TWDS.storage.sortList = function (key) {
  const tab = document.querySelector('#TWDS_storage_list')
  let cursort
  if ('cursort' in tab.dataset) {
    cursort = tab.dataset.cursort
  }
  const tbody = tab.querySelector('tbody')
  const rowColl = tab.querySelectorAll('tbody tr')
  const rows = []
  for (let i = 0; i < rowColl.length; i++) {
    const row = rowColl[i]
    const td = row.querySelector('[data-key=' + key + ']')
    row.sortval = td.dataset.sortval
    rows.push(row)
  }
  if (cursort === key) {
    rows.sort(function (a, b) {
      if (key === 'name') {
        return a.sortval.localeCompare(b.sortval)
      } else if (b.sortval === a.sortval) {
        return b.sortval2 - a.sortval2
      } else {
        return b.sortval - a.sortval
      }
    })
    tab.dataset.cursort = ''
  } else {
    rows.sort(function (a, b) {
      if (key === 'name') {
        return b.sortval.localeCompare(a.sortval)
      } else if (b.sortval === a.sortval) {
        return a.sortval2 - b.sortval2
      } else {
        return a.sortval - b.sortval
      }
    })
    tab.dataset.cursort = key
  }

  tbody.textContent = ''
  for (let i = 0; i < rows.length; i++) {
    tbody.appendChild(rows[i])
  }
}
TWDS.storage.initListArea = function (container) {
  const h = TWDS.createElement({ nodeName: 'h2', textContent: 'Lista' })
  container.appendChild(h)

  const tab = TWDS.createElement({ nodeName: 'table', id: 'TWDS_storage_list' })
  container.appendChild(tab)
  const thead = TWDS.createElement({ nodeName: 'thead' })
  tab.appendChild(thead)

  TWDS.storage.reload()
  if (!JobsModel.Jobs.length) {
    JobsModel.initJobs()
  }
  const tbody = TWDS.createElement({ nodeName: 'tbody' })
  tab.appendChild(tbody)
  const tr = TWDS.createElement({
    nodeName: 'tr',
    className: 'headrow',
    childNodes: [
      { nodeName: 'th', dataset: { key: 'item_id' }, textContent: '' },
      { nodeName: 'th', dataset: { key: 'name' }, textContent: TWDS._('STORAGE_NAME', 'Nombre') },
      { nodeName: 'th', dataset: { key: 'percent' }, textContent: '%' },
      { nodeName: 'th', dataset: { key: 'count' }, textContent: TWDS._('STORAGE_IN_BAG', 'En Bolsa') },
      { nodeName: 'th', dataset: { key: 'target' }, textContent: TWDS._('STORAGE_TARGET', 'Objetivo') },
      { nodeName: 'th', dataset: {}, textContent: TWDS._('STORAGE_COMMENT', 'Comentario') },
      { nodeName: 'th', dataset: {}, textContent: '' },
      { nodeName: 'th', dataset: {}, textContent: TWDS._('STORAGE_TRACKING', 'Seguimiento') }
    ]
  })
  tbody.appendChild(tr)

  TWDS.minimap.loadcache()
  const silvers = {}
  const golds = {}
  for (const poskey in TWDS.minimap.cache) {
    for (const j in TWDS.minimap.cache[poskey]) {
      if (TWDS.minimap.cache[poskey][j].silver) {
        silvers[j] = true
      }
      if (TWDS.minimap.cache[poskey][j].gold) {
        golds[j] = true
      }
    }
  }

  for (const ii of Object.keys(TWDS.storage.data)) {
    const tr = TWDS.storage.initListArea.element(ii, silvers, golds)
    if (tr !== null) { tbody.appendChild(tr) }
  }
  TWDS.createEle({
    nodeName: 'p',
    innerHTML: '<br>Puede utilizar el <b>Comentario</b> como desee, pero las funciones importar, remover líneas de comentarios seleccionados y recalcular el objetivo esperan que las líneas de los comentarios tengan este formato:<br><br>NUMERO algo de texto, por ejemplo:<br>50 para misiones diarias.',
    last: container
  })
}
TWDS.storage.getitemdata = function (itemid) {
  const have = Bag.getItemCount(itemid)
  let want = 0
  if (itemid in TWDS.storage.data) {
    want += parseInt(TWDS.storage.data[itemid][0])
  }
  return {
    have: have,
    want: want
  }
}
TWDS.storage.getsummary = function () {
  const s = {
    current: 0,
    required: 0
  }
  for (const itemid of Object.keys(TWDS.storage.dropperhour)) {
    const t = TWDS.storage.getitemdata(itemid)
    s.current += (t.have > t.want ? t.want : t.have)
    s.required += t.want
  }
  // things not found during work
  for (const itemid of Object.keys(TWDS.storage.data)) {
    if (!(itemid in TWDS.storage.dropperhour)) {
      const t = TWDS.storage.getitemdata(itemid)
      s.current += (t.have > t.want) ? t.want : t.have
      s.required += t.want
    }
  };

  return s
}
TWDS.storage.initListArea.element = function (ii, silvers, golds) {
  let e = TWDS.storage.data[ii]
  const classlist = ['datarow']
  const it = ItemManager.get(ii)
  if (!it) return null
  const popup = new ItemPopup(it, {}).popup.getXHTML()
  let searchthings = ''
  if (JobsModel.Jobs.length) {
    const jl = JobList.getJobsByItemId(ii)
    let best = null
    for (const job of jl) {
      // NOTE: habaneros and such things are found be getJobsByItemId, but are NOT mentioned in job.yields
      if (best === null || !(ii in job.yields)) {
        best = job
      } else if (job.yields[ii].prop > best.yields[ii].prop) {
        best = job
      }
    }

    if (best !== null) {
      searchthings += MinimapWindow.getQuicklink(it.item_id, 'inventory_changed')
      const b = TWDS.jobOpenButton(best.id)
      if (b != null) { // null if !automation
        searchthings += b.outerHTML
      }
      if (best.id in silvers) {
        classlist.push('silver')
      }
      if (best.id in golds) {
        classlist.push('gold')
      }
    }
  }
  const b = TWDS.itemBidButton(ii)
  if (b !== null) { // null if !found || !auctionable
    searchthings += b.outerHTML
  }
  const craft = TWDS.itemCraftButton(ii)
  if (craft !== null) { // null if !found || !auctionable
    searchthings += craft.outerHTML
  }
  const mydata = TWDS.storage.getitemdata(it.item_id)
  if (e === null || typeof e === 'undefined') {
    e = [0, '']
  }

  const count = mydata.have
  const rawpercent = count / (mydata.want ? mydata.want : 1) * 100
  const percent = Math.round(rawpercent) + '%'

  const tr = TWDS.createElement({
    nodeName: 'tr',
    classList: classlist,
    dataset: { item_id: ii },
    childNodes: [
      {
        nodeName: 'td',
        className: 'TWDS_storage_image',
        dataset: { key: 'item_id', sortval: ii },
        childNodes: [
          { nodeName: 'img', className: 'tw_item inventory_item', src: it.image, alt: it.name, title: popup }
        ]
      },
      {
        nodeName: 'td',
        className: 'TWDS_storage_name',
        childNodes: [
          { nodeName: 'div', textContent: it.name, title: popup },
          { nodeName: 'span', innerHTML: searchthings }
        ],
        dataset: { key: 'name', sortval: it.name }
      },
      { nodeName: 'td', textContent: percent, className: 'TWDS_storage_percent', dataset: { key: 'por ciento', sortval: rawpercent } },
      { nodeName: 'td', textContent: count, className: 'TWDS_storage_count', dataset: { key: 'contar', sortval: count } },
      {
        nodeName: 'td',
        dataset: { key: 'target', sortval: mydata.want },
        childNodes: [
          { nodeName: 'input', type: 'number', size: 5, min: 0, value: e[0], classList: ['TWDS_storage_countinput'] }
        ],
        onchange: function () {
          EventHandler.signal('twds_storage_tracking_changed', [this.parentNode.dataset.item_id])
        }
      },
      {
        nodeName: 'td',
        childNodes: [
          { nodeName: 'textarea', type: 'text', min: 0, textContent: e[1], value: e[1], classList: ['TWDS_storage_textinput'] }
        ]
      },
      {
        nodeName: 'td',
        childNodes: [
          {
            nodeName: 'button',
            textContent: TWDS._('STORAGE_REMOVE', 'Eliminar'),
            title: TWDS._('STORAGE_REMOVE_TITLE', 'Elimina esta línea, no los productos.'),
            className: 'TWDS_button TWDS_storage_removethis'
          }
        ]
      },
      {
        nodeName: 'td',
        childNodes: [
          {
            nodeName: 'input',
            type: 'checkbox',
            title: TWDS._('STORAGE_TRACKING_TITLE', 'Agrega este producto al rastreador, si está activo.'),
            checked: e[2],
            className: 'TWDS_button TWDS_storage_trackthis'
          }
        ]
      }
    ]
  })
  return tr
}

TWDS.storage.initSearchArea = function (container) {
  const div = TWDS.createElement({ nodeName: 'div', id: 'TWDS_storage_search_container' })
  container.appendChild(div)
  const nameInput = new west.gui.Textfield('TWDS_storage_search_name').setSize(10).setClass4Input('input_layout')
  div.appendChild(nameInput.getMainDiv()[0])
  div.querySelector('#TWDS_storage_search_name').placeholder = TWDS._('STORAGE_SEARCH_PLACEHOLDER', 'Buscar artículos')
  div.querySelector('#TWDS_storage_search_name').type = 'search'
  div.querySelector('#TWDS_storage_search_name').style.boxSizing = 'content-box'
  div.appendChild(TWDS.createElement({
    nodeName: 'button',
    id: 'TWDS_storage_export',
    textContent: TWDS._('STORAGE_EXPORT', 'Exportar'),
    title: TWDS._('STORAGE_EXPORT_TITLE', 'Exportar toda la lista al portapapeles')
  }))
  div.appendChild(TWDS.createElement({
    nodeName: 'button',
    id: 'TWDS_storage_export_selected',
    textContent: TWDS._('STORAGE_EXPORT_SELECTED', 'Exportar seleccionado'),
    title: TWDS._('STORAGE_EXPORT_SELECTED_TITLE', 'Se le pedirá una cadena de búsqueda y los artículos con observaciones coincidentes se exportarán al portapapeles.')
  }))
  div.appendChild(TWDS.createElement({
    nodeName: 'button',
    id: 'TWDS_storage_import',
    textContent: TWDS._('STORAGE_IMPORT', 'Importar'),
    title: TWDS._('STORAGE_IMPORT_TITLE', 'Importar registros desde el portapapeles. Tendrá la oportunidad de revisar cualquier cambio antes de que suceda.')
  }))
  div.appendChild(TWDS.createElement({
    nodeName: 'button',
    id: 'TWDS_storage_remove_selected',
    textContent: TWDS._('STORAGE_REMOVE_SELECTED', 'Eliminar seleccionado'),
    title: TWDS._('STORAGE_REMOVE_SELECTED_TITLE', 'Se le pedirá una cadena de búsqueda, luego las entradas de comentarios que coincidan se eliminarán y sus números objetivo se calcularán nuevamente.')
  }))
  div.appendChild(TWDS.createElement({
    nodeName: 'button',
    id: 'TWDS_storage_recalc_sums',
    innerHTML: TWDS._('STORAGE_RECALC_SUMS', '&sum;'),
    title: TWDS._('STORAGE_RECALC_SUMS_TITLE', 'Recalcular los números objetivo a partir de las entradas en los comentarioss.')
  }))

  const sdiv = TWDS.createElement({
    nodeName: 'div',
    id: 'TWDS_storage_select',
    childNodes: [
      { nodeName: 'h3', textContent: 'Seleccionar el artículo' },
      { nodeName: 'table', id: 'TWDS_storage_select_container' }
    ]
  })
  div.appendChild(sdiv)
}

TWDS.storage.calcCrafting = function () {
  CharacterWindow.Crafting.init()
  const x = {}
  for (const e of Object.values(Crafting.recipes)) {
    for (const r of e.resources) {
      if (!(r.item in x)) { x[r.item] = 0 }
      x[r.item] += r.count
    }
  }
  for (const [i, e] of Object.entries(x)) {
    const it = ItemManager.get(i)
    console.log(i, it.name, e)
  }
}
TWDS.storage.gettarget = function (pr) {
  const t = TWDS.storage.getitemdata(pr)
  if (t.want) return t.want
  return null
}
TWDS.storage.reload()
TWDS.storage.isMissing = function (ii) {
  const id = parseInt(ii)
  const t = TWDS.storage.getitemdata(id)
  if (t.want > t.have) return true
  return false
}
TWDS.storage.iteminfo = function (ii) {
  const id = parseInt(ii)
  const t = TWDS.storage.getitemdata(id)
  return [t.want, t.have]
}
TWDS.storage.getMissingList = function () {
  const out = {}
  for (const id of Object.keys(TWDS.storage.data)) {
    const t = TWDS.storage.getitemdata(id)
    if (t.want > t.have) {
      if (JobsModel.Jobs.length) {
        const jl = JobList.getJobsByItemId(id)
        for (const job of jl) {
          out[job.id] = id
        }
      }
    }
  }
  return out
}
TWDS.storage.gettracked = function () {
  const out = []
  for (const id of Object.keys(TWDS.storage.data)) {
    if (TWDS.storage.data[id][2] && TWDS.storage.data[id][1]) { out.push(id) }
  }
  return out
}
TWDS.storage.changetracking = function (pr, mode) {
  if (pr in TWDS.storage.data) {
    TWDS.storage.data[pr][2] = mode
  }
  EventHandler.signal('twds_storage_tracking_changed', [pr])
}
TWDS.storage.istracked = function (pr) {
  if (pr in TWDS.storage.data && 2 in TWDS.storage.data[pr]) {
    return TWDS.storage.data[pr][2]
  }
  return false
}
TWDS.storage.untrack = function (pr) {
  TWDS.storage.changetracking(pr, false)
  TWDS.storage.save()
}

TWDS.storage.getContent = function () {
  const div = document.createElement('div')
  div.id = 'TWDS_storage'
  TWDS.storage.initSearchArea(div)
  TWDS.storage.initListArea(div)
  return div
}
TWDS.storage.activateTab = function () {
  TWDS.activateTab('storage')
  TWDS.storage.sortList('percent')
  document.getElementById('TWDS_storage_search_name').focus()
}
TWDS.storage.recalcsums = function () {
  TWDS.storage.reload()
  let did = 0
  let alerts = ''
  const rx1 = /(\d+)\s+/
  for (const [k, v] of Object.entries(TWDS.storage.data)) {
    const comment = v[1]
    const lines = comment.split('\n')
    let sum = 0
    let okay = 1
    for (let i = 0; i < lines.length; i++) {
      const m = lines[i].match(rx1)
      if (m !== null) {
        sum += parseInt(m[1])
      } else if (lines[i] > '') {
        okay = 0
      }
    }
    if (okay) {
      if (parseInt(v[0]) !== sum) {
        console.log('changing', ItemManager.get(k), 'from', v[0], 'to', sum, v[1])
        v[0] = sum
        did = 1
      }
    } else {
      alerts += ItemManager.get(k).name + '\n'
    }
  }
  if (did) {
    TWDS.storage.save()
    TWDS.storage.activateTab()
  }
  if (alerts > '') {
    window.alert('I failed to understand one or more entries, and left them alone:\n' + alerts)
  }
}
TWDS.storage.removeselected = function (term) {
  TWDS.storage.reload()
  let report = ''
  const indent = function (text) {
    const lines = text.split('\n')
    let out = ''
    for (let i = 0; i < lines.length; i++) {
      out += '  ' + lines[i] + '\n'
    }
    return out
  }

  let x
  if (term) { // debug hack
    x = term
  } else {
    x = window.prompt('searchterm (case insensitive prefix search)')
  }
  if (x === null || x.trim() === '') { return }
  x = x.toLocaleLowerCase()

  const rx1 = new RegExp('(\\d+)\\s*' + x)
  const rx2 = new RegExp('\\W' + x + '\\W')
  const overwrites = {}
  for (const [k, v] of Object.entries(TWDS.storage.data)) {
    const old = v[1]
    const lines = old.split('\n')
    let comment = ''
    let done = 0
    for (let i = 0; i < lines.length; i++) {
      let doit = 0
      const tmp = lines[i].toLocaleLowerCase()

      let m = tmp.match(rx1)
      if (m !== null) doit = 1
      m = tmp.match(rx2)
      if (m !== null) doit = 2

      if (lines[i] === '') doit = 3
      if (!doit) {
        if (comment > '') comment += '\n'
        comment += lines[i]
      } else if (doit !== 3) {
        console.log('MATCH', lines[i], doit)
        done++
      }
    }
    if (done) {
      if (!report) { report = 'Please check:\n' }
      report += 'Old entry for item ' + ItemManager.get(k).name + ':\n'
      report += indent(old)
      report += 'New entry:\n' + indent(comment)
      v[1] = comment
      overwrites[k] = v
    }
  }
  if (report) {
    if (window.confirm(report)) {
      for (const [k, v] of Object.entries(overwrites)) {
        TWDS.storage.data[k] = v
      }
      TWDS.storage.save()
      TWDS.storage.recalcsums()
      TWDS.storage.activateTab()
    }
  }
}

TWDS.storage.importhandler = function () {
  const doit = function (str) {
    console.log('trying to import', str)
    console.log('trying to import', '#' + str + '#')
    TWDS.storage.reload()
    let t
    try {
      t = JSON.parse(str)
    } catch (e) {
      console.error('Unable to parse JSON', e, str)
    }
    let report = 'Please check:\n'
    const overwrites = {}
    for (const [k, v] of Object.entries(t)) {
      if (!(k in TWDS.storage.data)) {
        report += 'new: ' + k + '=' + JSON.stringify(v) + '\n'
        overwrites[k] = v
      } else {
        const old = TWDS.storage.data[k]
        report += 'old: ' + k + '=' + JSON.stringify(old) + '\n'
        if (old[1].includes(v[1])) {
          report += '  leaving it alone\n'
        } else {
          const x = []
          x[0] = Number(old[0]) + Number(v[0])
          x[1] = old[1] + '\n' + v[1]
          report += 'new: ' + k + '=' + JSON.stringify(x)
          overwrites[k] = x
        }
      }
    }
    if (window.confirm(report)) {
      for (const [k, v] of Object.entries(overwrites)) {
        TWDS.storage.data[k] = v
      }
      TWDS.storage.save()
      TWDS.storage.activateTab()
    }
  }
  // firefox: navigator.clipboard has no .readText().
  // documentation talks about permission queries, but clipboard-read perm is unknown.
  try {
    navigator.clipboard.readText().then(function (str) {
      doit(str)
    }, function (e) {
      // Promise rejected.
      console.log(e)
      throw (e)
    })
  } catch (e) {
    console.log('e', e)
    const textarea = $('<textarea />').css({
      width: '400px',
      minHeight: '100px'
    });
    (new west.gui.Dialog('Import', textarea)).addButton('ok', function () {
      doit(textarea.val())
    }).addButton('cancel').show()
  }
}

TWDS.storageStartFunction = function () {
  TWDS.registerTab('storage',
    TWDS._('TABNAME_STORAGE', 'Almacenamiento'),
    TWDS.storage.getContent,
    TWDS.storage.activateTab,
    true)
  $(document).on('change', '#TWDS_storage_search_name', function () {
    const v = this.value.trim()
    TWDS.storage.startSearch(v)
  })
  $(document).on('click', '#TWDS_storage_select_container button.TWDS_storage_addthis', function () {
    const tr = this.closest('tr')
    const ii = tr.dataset.item_id
    TWDS.storage.data[ii] = [Bag.getItemCount(ii) + 100, '']
    TWDS.storage.save()
    if (tr.parentNode) {
      tr.parentNode.removeChild(tr)
      const n = TWDS.storage.initListArea.element(ii)
      const tbody = document.querySelector('#TWDS_storage_list tbody')
      tbody.insertBefore(n, tbody.firstChild)
    }
  })
  $(document).on('click', '#TWDS_storage_list button.TWDS_storage_removethis', function () {
    const tr = this.closest('tr')
    const ii = tr.dataset.item_id
    delete TWDS.storage.data[ii]
    TWDS.storage.save()
    tr.parentNode.removeChild(tr)
  })
  $(document).on('click', '#TWDS_storage_list input.TWDS_storage_trackthis', function () {
    const tr = this.closest('tr')
    const ii = tr.dataset.item_id
    TWDS.storage.changetracking(ii, this.checked)
    TWDS.storage.save()
  })
  $(document).on('change', '#TWDS_storage_list input.TWDS_storage_countinput', function () {
    const tr = this.closest('tr')
    const ii = tr.dataset.item_id
    TWDS.storage.data[ii][0] = this.value
    if (TWDS.storage.data[ii][2]) { EventHandler.signal('twds_storage_tracking_changed', [ii]) }
    TWDS.storage.save()
  })
  $(document).on('change', '#TWDS_storage_list .TWDS_storage_textinput', function () {
    const tr = this.closest('tr')
    const ii = tr.dataset.item_id
    TWDS.storage.data[ii][1] = this.value
    TWDS.storage.save()
  })
  $(document).on('click', '.TWDS_storage_market_button', function () {
    const ii = this.dataset.item_id
    const it = ItemManager.get(ii)
    MarketWindow.open(Character.homeTown.town_id, 1, '???')
    document.querySelector('.tw2gui_window_tab._tab_id_buy').click()
    document.querySelector('[name=market_search_search]').value = it.name
    document.querySelector('.market-buy .tw2gui_iconbutton.iconBut_mpb_refresh').click()
  })
  $(document).on('click', '.TWDS_storage_craft_button', function () {
    const ii = this.dataset.item_id
    if ('TW_Calc' in window) {
      window.TW_Calc.openCraftRecipeWindow(ii)
    } else {
      CharacterWindow.open('crafting')
    }
  })
  $(document).on('click', '#TWDS_storage_list th[data-key]', function () {
    TWDS.storage.sortList(this.dataset.key)
  })

  $(document).on('click', '#TWDS_storage_export', function () {
    TWDS.storage.reload()
    const t = JSON.stringify(TWDS.storage.data)
    navigator.clipboard.writeText(t).then(function () {
      // Promise resolved successfully.
      console.log('Copied to clipboard successfully!')
    }, function () {
      // Promise rejected.
      console.error('Unable to write to clipboard. :-(')
    })
  })
  $(document).on('click', '#TWDS_storage_export_selected', function () {
    TWDS.storage.reload()
    const x = window.prompt('searchterm')
    if (x === null || x.trim() === '') { return }
    const rx1 = new RegExp('(\\d+)\\s*' + x)
    const rx2 = new RegExp('\\W' + x + '\\W')
    let t = {}
    for (const [k, v] of Object.entries(TWDS.storage.data)) {
      let m = v[1].match(rx1)
      if (m !== null) {
        t[k] = [m[1], m[0]]
        continue
      }
      m = v[1].match(rx2)
      if (m !== null) {
        t[k] = v
      }
    }
    t = JSON.stringify(t)
    navigator.clipboard.writeText(t).then(function () {
      // Promise resolved successfully.
      console.log('¡Copiado correctamente al portapapeles!')
    }, function () {
      // Promise rejected.
      console.error('Incapaz de escribir en el portapapeles. :-(')
    })
  })
  $(document).on('click', '#TWDS_storage_remove_selected', function () {
    TWDS.storage.removeselected()
  })
  $(document).on('click', '#TWDS_storage_recalc_sums', function () {
    TWDS.storage.recalcsums()
  })
  $(document).on('click', '#TWDS_storage_import', function () {
    TWDS.storage.importhandler()
  })

  Map.Component.JobGroup.TWDS_backup_getMarkers = Map.Component.JobGroup.getMarkers
  Map.Component.JobGroup.getMarkers = function (groupId) {
    let s = Map.Component.JobGroup.TWDS_backup_getMarkers(groupId)
    if (!TWDS.settings.saleProtection) {
      return s
    }

    const jobs = JobList.getJobsByGroupId(groupId)
    const itemnames = []
    for (const job of jobs) {
      for (const y of Object.keys(job.yields)) {
        if (y in TWDS.storage.data && Bag.getItemCount(y) < TWDS.storage.data[y][0]) {
          const it = ItemManager.get(y)
          itemnames.push(it.name.escapeHTML())
        }
      }
    }
    if (itemnames.length) {
      s += '<div class="item-job TWDS_storage_needs_item" title="' + itemnames.join(', ') + '">!</div>'
    }
    return s
  }
  TWDS.storage.reload() // so the map hack has the data
}
TWDS.registerStartFunc(TWDS.storageStartFunction)

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.chat = {}

// mark some strings in the chat as soon as they come.
TWDS.chat.init = function () { // really old stuff
  TWDS.registerSetting('string', 'chat_highlight',
    'Una expresión regular de JavaScript. Se resaltarán las partes coincidentes de los mensajes de chat entrantes.', ''
  )
  let rx, rx2
  const chatcfg = {
    attributes: false,
    childList: true,
    characterData: false,
    subtree: true
  }

  const recurse = function (n) {
    if (n.nodeType === 3) {
      if (!n.textContent.match(rx)) return

      const e = document.createElement('span')
      n.parentNode.insertBefore(e, n)
      n.remove()

      const s = n.textContent.split(rx)
      for (let i = 0; i < s.length; i++) {
        const t = s[i]
        let f
        if (t.match(rx2)) {
          f = document.createElement('span')
          f.className = 'TWDS_blinking TWDS_chat_highlight' // blinks for 60 seconds
          f.textContent = t
        } else {
          f = document.createTextNode(t)
        }
        e.appendChild(f)
      }
    } else if (n.nodeType === 1) {
      for (let i = 0; i < n.childNodes.length; i++) {
        recurse(n.childNodes[i])
      }
    }
  }
  let chatcontainer
  const chatobserver = new window.MutationObserver(function (mutations) {
    const tohighlight = TWDS.settings.chat_highlight.trim()
    if (tohighlight === '') return
    rx = new RegExp('(' + tohighlight + ')', 'i')
    rx2 = new RegExp('^(' + tohighlight + ')$', 'i')
    chatobserver.disconnect()
    mutations.forEach(function (mut) {
      if (mut.type !== 'childList') return
      if (mut.addedNodes.length === 0) return
      for (let i = 0; i < mut.addedNodes.length; i++) {
        const n = mut.addedNodes[i]
        if (n.nodeName !== 'TABLE') continue
        const tn = n.querySelector('.chat_text') // this might contain some divs.
        recurse(tn)
      }
    })
    chatobserver.observe(chatcontainer, chatcfg)
  })

  // first we need to find a chat window. do that with an observer
  const windowscfg = {
    attributes: false,
    childList: true,
    characterData: false,
    subtree: false
  }

  const windows = document.querySelector('#windows')
  if (!windows) {
    setTimeout(TWDS.chatInit, 1000)
    return
  }
  const windowsobserver = new window.MutationObserver(function (mutations) {
    mutations.forEach(function (mut) {
      if (mut.type !== 'childList') return
      for (let i = 0; i < mut.addedNodes.length; i++) {
        const n = mut.addedNodes[i]
        if (n.nodeName !== 'DIV') continue
        for (i = 0; i < n.classList.length; i++) {
          if (n.classList[i].substring(0, 5) === 'chat_') {
            chatcontainer = n
            chatobserver.observe(n, chatcfg)
          }
        }
      }
      for (let i = 0; i < mut.removedNodes.length; i++) {
        const n = mut.removedNodes[i]
        if (n.nodeName !== 'DIV') continue
        for (i = 0; i < n.classList.length; i++) {
          if (n.classList[i].substring(0, 5) === 'chat_') {
            chatobserver.disconnect(n)
          }
        }
      }
    })
  })
  windowsobserver.observe(windows, windowscfg)
}
TWDS.chat.init2 = function () {
  TWDS.registerSetting('bool', 'chat_nostranger',
    TWDS._('CHAT_SETTING_NOSTRANGER', 'Mostrar el estado en línea/inactivo incluso para extraños.'),
    false
  )
  Chat.Resource.Client.prototype.TWDS_backup_isStranger = Chat.Resource.Client.prototype.isStranger
  Chat.Resource.Client.prototype.isStranger = function () {
    if (TWDS.settings.chat_nostranger) { return false }
    return Chat.Resource.Client.prototype.TWDS_backup_isStranger.apply(this, arguments)
  }
}
TWDS.chat.localanswer = function (room, msg) {
  const ti = window.Chat.Formatter.formatTime(new Date().getTime(), false)
  msg = Chat.Formatter.formatText(msg, true)
  const ret = TWDS.createEle({
    nodeName: 'div',
    children: [
      { nodeName: 'span', textContent: ti },
      { nodeName: 'span', textContent: ' ' },
      { nodeName: 'span', innerHTML: msg }
    ]
  }).outerHTML
  room.addMessage(ret)
}
TWDS.chat.init3 = function () {
  const localanswer = TWDS.chat.localanswer

  Chat.Operations['^\\/active(.*)'] = {
    cmd: 'active',
    shorthelp: TWDS._('CHAT_ACTIVE_SHORTHELP', 'Lista de jugadores activos (puntos verdes).'),
    help: TWDS._('CHAT_ACTIVE_HELP', 'Lista de jugadores no activos en este canal. Esto puede enumerar todos los jugadores o aquellos cuyos nombres coincidan con una cadena de búsqueda.'),
    usage: '/active searchstring | /active (for all)',
    func: function (room, msg, param) {
      const clients = room.clients
      const out = []
      console.log('param', param)
      const search = param[1].trim().toLocaleLowerCase()
      console.log('search', search)
      for (let i = 0; i < clients.length; i++) {
        const contact = TWDS.q1('.contact_' + clients[i])
        if (!contact) continue
        const x = TWDS.q1('.client_status img[src*=status_online]', contact)
        const cn = TWDS.q1('.client_name', contact)
        if (x && cn) {
          const name = cn.textContent
          if (search === '' || name.toLocaleLowerCase().includes(search)) {
            out.push(name)
          }
        }
      }
      out.sort(function (a, b) {
        return a.toLocaleLowerCase().localeCompare(b.toLocaleLowerCase())
      })
      const ti = window.Chat.Formatter.formatTime(new Date().getTime(), false)
      const text = TWDS._('CHAT_ACTIVE_TEXT', 'active: $list$', {
        list: out.join(', ')
      })
      const ret = '<div>[' + ti + ']</span> ' + text + '</div>'
      room.addMessage(ret)
    }
  }
  Chat.Operations['^\\/ping(.*)'] = {
    cmd: 'ping',
    shorthelp: TWDS._('CHAT_PING_SHORTHELP', 'hacer ping a un jugador.'),
    help: TWDS._('CHAT_PING_HELP', 'Llama a ese jugador a este canal.'),
    usage: '/ping player name',
    func: function (room, msg, param) {
      const clients = room.clients
      let roomname = ''
      let addon = ''
      if (room.room === 'general') {
        roomname = 'Saloon ' + room.generalId // room.title is empty
      } else if (room.room === 'custom') {
        roomname = room.title
      } else if (room.room === 'alliance') {
        roomname = room.title
        addon = TWDS._('CHAT_ALLIANCE_ROOM', '(alliance chat)')
      } else if (room.room === 'town') {
        roomname = room.title
        addon = TWDS._('CHAT_TOWN_ROOM', '(town chat)')
      } else if (room.room === 'fortbattle') {
        roomname = room.title
        addon = TWDS._('CHAT_FB_ROOM', '(fortbattle chat)')
      } else if (room.room === 'client') {
        localanswer(room, "that doesn't work.")
        return
      } else {
        console.log('room', room)
        localanswer(room, 'tipo de habitación desconocido. Necesitamos depurar esto.: ' + room.room)
        return
      }
      const search = param[1].trim().toLocaleLowerCase()
      if (search === '') {
        localanswer(room, 'pong (usage: /ping some-player-name)')
        return
      }

      for (let i = 0; i < clients.length; i++) {
        const contact = TWDS.q1('.contact_' + clients[i])
        if (!contact) continue
        const cn = TWDS.q1('.client_name', contact)
        if (cn) {
          const name = cn.textContent.toLocaleLowerCase()
          if (name === search) {
            const text = TWDS._('CHAT_PING_TEXT', 'Por favor ven a $roomname$ $info$', {
              roomname: roomname,
              info: addon
            })
            Chat.Request.Tell(search, text)
            localanswer(room, TWDS._('CHAT_PINGED_MESSAGE', 'pinged $search$', { search: search }))
            return
          }
        }
      }
      localanswer(room, TWDS._('CHAT_PING_NOTFOUND', 'no se encontró $search$', {
        search: search
      }))
    }
  }
}
TWDS.chat.tabsend = function () {
  let val = this.input[0].value
  const firstchar = val.substr(0, 1)
  if (firstchar !== '/') {
    const color = window.localStorage.TWDS_chat_color
    if (color) { val = '/' + color + val }
    this.input[0].value = val
  }
  Chat.Layout.Tab.TWDS_backup_send.apply(this, arguments)
}
TWDS.chat.digitstohex = function (digits) {
  const rgb = digits.match(/^(\d)(\d)(\d)$/)
  if (!rgb) return false
  return Math.floor(rgb[1] * 15 / 9).toString(16) +
        Math.floor(rgb[2] * 15 / 9).toString(16) +
        Math.floor(rgb[3] * 15 / 9).toString(16)
}
TWDS.chat.init4 = function () {
  Chat.Operations['^\\/defaultcolor(.*)'] = {
    cmd: 'defaultcolor',
    shorthelp: TWDS._('CHAT_COLOR_SHORTHELP', 'Establecer color por defecto.'),
    help: TWDS._('CHAT_COLOR_HELP', 'Establece un color predeterminado para todas las salas y en ésta y futuras sesiones.'),
    usage: '/defaultcolor (RGB | - | nothing). RGB = Red/Green/Blue , each 0..9. - to unset. nothing to show current value',
    func: function (room, msg, param) {
      const color = param[1].trim().toLocaleLowerCase()
      if (!color) {
        const color = window.localStorage.TWDS_chat_color
        if (!color) {
          TWDS.chat.localanswer(room, 'sin conjunto predeterminado de colores')
        } else {
          TWDS.chat.localanswer(room, '/' + color + 'el color por defecto es ' + color)
        }
        return
      } else if (color === '-') {
        delete window.localStorage.TWDS_chat_color
        TWDS.chat.localanswer(room, 'color predeterminado no configurado')
        return
      }
      const hex = TWDS.chat.digitstohex(color)
      if (!hex) {
        TWDS.chat.localanswer(room, 'no se pudo analizar ' + color + ' como color')
        return
      }
      window.localStorage.TWDS_chat_color = color
      TWDS.chat.localanswer(room, '/' + color + 'conjunto de colores predeterminado')
    }
  }
  Chat.Layout.Tab.TWDS_backup_send = Chat.Layout.Tab.TWDS_backup_send || Chat.Layout.Tab.prototype.send
  Chat.Layout.Tab.prototype.send = TWDS.chat.tabsend
}
TWDS.chat.playernocolor = {}
TWDS.chat.formatResponse = function (room, from, message, time) {
  if (from && from.pname) {
    const t = from.pname.toLocaleLowerCase()
    if (TWDS.chat.playernocolor[t]) {
      message = message.split(/[\s\u2060](?=\/\d\d\d)/).map(function (v) {
        const rgb = v.match(/^\/(\d\d\d)(\s*)(.*?)(\s*)$/)
        if (rgb) { return rgb[3] + rgb[4] } else { return v }
      }).join('')
    }
  }
  return Chat.Formatter.TWDS_backup_formatResponse.call(this, room, from, message, time)
}
TWDS.chat.init5 = function () {
  TWDS.chat.playernocolor = {}
  try {
    TWDS.chat.playernocolor = JSON.parse(window.localStorage.TWDS_chat_playernocolor || '{}')
  } catch (e) {
    console.log('exception', e)
    TWDS.chat.playernocolor = {}
  }
  Chat.Operations['^\\/uncolor(.*)'] = {
    cmd: 'uncolor',
    shorthelp: TWDS._('CHAT_UNCOLOR_SHORTHELP', 'Eliminar color del chat de mensajes.'),
    help: TWDS._('CHAT_UNCOLOR_HELP', 'Eliminar (+) o permitir (-) colores a los mensajes de un jugador.'),
    usage: TWDS._('CHAT_UNCOLOR_USAGE', '/uncolor ( + | -) playername. + to remove, - to allow. Anything not matching that will list the current state'),
    func: function (room, msg, param) {
      const parsed = param[1].match(/\s+([-+])\s+(.+)$/)
      if (!parsed) {
        const a = Object.keys(TWDS.chat.playernocolor)
        if (a.length) {
          TWDS.chat.localanswer(room, '/990 ' +
            TWDS._('CHAT_UNCOLOR_LIST', 'Eliminas colores de estos jugadores.:'))
          a.sort(function (c, d) { return c.localeCompare(d) })
          for (let i = 0; i < a.length; i++) {
            TWDS.chat.localanswer(room, ' - ' + a[i])
          }
        } else {
          TWDS.chat.localanswer(room, '/990 ' +
            TWDS._('CHAT_UNCOLOR_NONE', 'No eliminas colores de ningún jugador..'))
        }
        console.log('XX')
        TWDS.chat.localanswer(room, '/990 ' +
            TWDS._('CHAT_UNCOLOR_EXAMPLE1', 'Para eliminar colores de todos los mensajes provenientes de un jugador: /removecolors + PLAYER NAME.'))
        TWDS.chat.localanswer(room, '/990 ' +
            TWDS._('CHAT_UNCOLOR_EXAMPLE2', 'Para permitir colores en todos los mensajes provenientes de un jugador: /removecolors - PLAYER NAME.'))
        return
      }
      const plus = parsed[1] === '+'
      const player = parsed[2].trim().toLocaleLowerCase()
      if (plus) {
        TWDS.chat.playernocolor[player] = 1
        TWDS.chat.localanswer(room, '/990' +
          TWDS._('CHAT_UNCOLOR_ADDED', 'eliminar colores de los mensajes provenientes de $player$.',
            { player: player }))
      } else {
        delete TWDS.chat.playernocolor[player]
        TWDS.chat.localanswer(room, '/990' +
          TWDS._('CHAT_UNCOLOR_NOTREMOVINGCOLORS', 'No eliminar colores de los mensajes provenientes de $player$.',
            { player: player }))
      }
      window.localStorage.TWDS_chat_playernocolor = JSON.stringify(TWDS.chat.playernocolor)
    }
  }
  Chat.Formatter.TWDS_backup_formatResponse = Chat.Formatter.TWDS_backup_formatResponse ||
    Chat.Formatter.formatResponse
  Chat.Formatter.formatResponse = TWDS.chat.formatResponse
}

TWDS.registerStartFunc(function () {
  TWDS.chat.init()
  TWDS.chat.init2()
  TWDS.chat.init3()
  TWDS.chat.init4()
  TWDS.chat.init5()
})

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab
//

TWDS.injuryWarningModelFlag = false
TWDS.injuryWarningHandler = function () {
  if (!JobsModel.Jobs.length) { // JobsModel.initialized is not set in every case.
    if (!TWDS.injuryWarningModelFlag) {
      TWDS.injuryWarningModelFlag++
      setTimeout(function () {
        JobsModel.initJobs()
        TWDS.injuryWarningHandler()
      }, 500)
      return
    }
    setTimeout(TWDS.injuryWarningHandler, 1000)
    return
  }
  const container = $('#ui_workcontainer')
  container[0].style.backgroundColor = 'transparent'
  container[0].style.boxShadow = 'none'
  const warnNegative = TWDS.settings.taskqueue_warn_negative
  const warnLow = TWDS.settings.taskqueue_warn_low
  const warnKnockout = TWDS.settings.taskqueue_warn_one_injury_knockout
  const warnSuboptimal = TWDS.settings.taskqueue_warn_suboptimal
  const warnOrange = TWDS.settings.taskqueue_orange_on_warning
  const warnAvg = parseInt(TWDS.settings.taskqueue_warn_avg_injury_knockout)

  let expinj = 0
  const maxHP = Character.maxHealth
  const curHP = Character.health

  let anyWarning = false

  for (let i = 0; i < TaskQueue.queue.length; i++) {
    if (TaskQueue.queue[i].type !== 'job') { // not walking or riding or duelling or ff
      continue
    }
    const jid = TaskQueue.queue[i].data.job.id
    const jp = TaskQueue.queue[i].data.job_points
    const jd = TWDS.jobData['job_' + jid]
    // console.log('JobsModel.g()', JobsModel.getById(jid))
    const malus = JobsModel.getById(jid).jobObj.malus
    const dang = TWDS.TWDBcalcDanger(jp + malus - 1, malus - 1, jd.job_danger, 100, 1)
    const maxdmg = jd.job_maxdmg

    expinj += dang / 100 * maxdmg / 100.0 * maxHP / 4 // assume that the average injury is 25% of the maxinj.

    // console.log('jid', jid, 'dang', dang, 'maxdmg', maxdmg, 'maxinj', maxinj, 'expinj', expinj)

    let flag = 0
    let msg = ''

    if (warnNegative && jp < 0) {
      if (flag === 0) flag = 3
      msg += 'negative job points.\n'
      anyWarning = true
    }
    if (warnLow && jp < malus / 5 && !flag) { // no silver star
      if (flag === 0) flag = 2
      msg = msg + 'low job points.\n'
      anyWarning = true
    }
    if (warnKnockout && maxdmg / 100 * maxHP >= curHP) {
      // 'mark a job in the taskqueue orange if the maximum injury can knock you out.', true,
      if (flag === 0) {
        // some jobs can kill you. undertaker for example. treat them differently.
        if (maxdmg === 100) {
          flag = 1
        } else {
          flag = 2
          anyWarning = true
        }
      }
      msg = msg + 'one accident might knock you out.\n'
    }
    if (warnSuboptimal) {
      const best = TWDS.getJobBestFromCache(jid)
      if (best !== null) {
        const bestnetto = TWDS.joblist.calcNettoJobPoints(jid, best.items)
        if (bestnetto > jp) {
          if (flag === 0) flag = 1
          anyWarning = true
          msg = msg + 'not the best equipment (currently ' + jp + ' points, best has ' + bestnetto + ')\n'
        }
      }
    }
    if (flag > 0) {
      const n = west.gui.Icon.get('exclamation-priority-' + flag, msg)
      $('.task-queuePos-' + i + ' > div.icon', container).children('.TWDS_lp_hint').remove().end().append($('<div class="TWDS_lp_hint" />').toggleClass('tw2gui-iconset tw2gui-icon-star').append(n))
    }
  }
  if (warnOrange && anyWarning) {
    container[0].style.backgroundColor = 'orange'
    container[0].style.boxShadow = '-1px -1px 10px 3px ' + 'orange'
  }
  if (warnAvg) {
    let w = 0
    if (expinj / curHP * 100 >= warnAvg) w++
    if (expinj / curHP * 100 >= 100) w++
    if (w) {
      let c = 'orange'
      if (w === 2) c = 'red'
      container[0].style.backgroundColor = c
      container[0].style.boxShadow = '-1px -1px 10px 3px ' + c
    }
  }
}

TWDS.registerStartFunc(function () {
  TWDS.registerSetting('bool', 'taskqueue_warn_negative',
    'Marcar en rojo el trabajo en la cola si los puntos trabajo son negativos.', true,
    function (v) {
      TWDS.injuryWarningHandler()
    }, 'Cola de Tareas'
  )
  TWDS.registerSetting('bool', 'taskqueue_warn_low',
    'Marcar en amarillo el trabajo en la cola si el nº puntos trabajo es bajo.', true,
    function (v) {
      TWDS.injuryWarningHandler()
    }, 'Cola de Tareas'
  )
  TWDS.registerSetting('bool', 'taskqueue_warn_one_injury_knockout',
    'Marcar en naranja el trabajo en la cola si el daño puede noquearte.', true,
    function (v) {
      TWDS.injuryWarningHandler()
    }, 'Cola de Tareas'
  )
  TWDS.registerSetting('bool', 'taskqueue_warn_suboptimal',
    'Marcar en azul el trabajo en la cola si se realiza sin tener los puntos completos.', true,
    function (v) {
      TWDS.injuryWarningHandler()
    }, 'Cola de Tareas'
  )
  TWDS.registerSetting('bool', 'taskqueue_orange_on_warning',
    'Colorear la cola de tareas en naranja si se muestra una de las advertencias siguientes.', true,
    function (v) {
      TWDS.injuryWarningHandler()
    }, 'Cola de Tareas'
  )
  TWDS.registerSetting('int', 'taskqueue_warn_avg_injury_knockout',
    'Colorear la cola en rojo si el daño por las lesiones esperadas juntas alcanzan un nivel del  ...  por ciento de la salud actual. Tenga en cuenta que las expectativas pueden estar equivocadas. Este script espera el número promedio de lesiones con un 25% del daño máximo cada una.', '50',
    function (v) {
      TWDS.injuryWarningHandler()
    }, 'Cola de Tareas'
  )
  EventHandler.listen(['taskqueue-updated', 'taskqueue-ready'], TWDS.injuryWarningHandler)
})
// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab

TWDS.banking = {}
TWDS.banking.deposithelper = function (t) {
  if (Character.money <= 0) { return }
  window.BankWindow.townid = t
  window.BankWindow.DOM = (new west.gui.Textfield('tb_balance_input_' + t))
    .setSize(10).setValue(window.Character.money).getMainDiv()
  window.BankWindow.Balance.add()
}
TWDS.banking.depositinit = function () {
  const deposit = TWDS.q1('#deposit')
  if (deposit) {
    if (TWDS.settings.banking_deposit_button) {
      $(deposit).addMousePopup(
        TWDS._('BANKING_DEPOSIT_YOUR_CASH', 'Depositar tu efectivo.'))
      deposit.onclick = function (e) {
        if (Character.money <= 0) {
          return
        }
        const textDepo = TWDS._('BANKING_DEPOSIT_YOUR_CASH', 'Depositar tu efectivo.')
        const textYes = TWDS._('YES', 'yes')
        const textNo = TWDS._('NO', 'no')
        let textOIT = TWDS._('BANKING_ONLY_IN_TOWN', 'Esto solo es posible si tú estás en una ciudad.')
        textOIT = '<div>' + textOIT + '</div>';

        (new west.gui.Dialog(textDepo,
          jQuery("<span class='TWDS_banking'>$: " + Character.money + '</span>' + textOIT))).setIcon(west.gui.Dialog.SYS_QUESTION).setModal(true, false).addButton(textYes, function () {
          TWDS.banking.deposithelper(1)
        }).addButton(textNo).show()
      }
    } else {
      delete deposit.onclick
    }
  }
}
TWDS.banking.autohome_check = function () {
  const textNo = TWDS._('NO', 'no')
  const textYes = TWDS._('YES', 'yes')
  if (Character.homeTown.town_id === 0 || Character.money <= 0) {
    return
  }
  if (Character.position.x !== Character.homeTown.x ||
    Character.position.y !== Character.homeTown.y) {
    return
  }

  (new west.gui.Dialog('Deposit your Cash',
    jQuery("<span class='TWDS_autodeposit'>" +
      TWDS._('BANKING_ARRIVED_HOME',
        'Ha llegado a su ciudad natal. ¿Le gustaría depositar su efectivo?') +
      '<br />$: ' + Character.money + '</span>')))
    .setIcon(west.gui.Dialog.SYS_QUESTION).setModal(true, false)
    .addButton(textYes, function () {
      TWDS.banking.deposithelper(Character.homeTown.town_id)
    }).addButton(textNo).show()
}

TWDS.banking.autohome_toggle = function (v) {
  if (!v) {
    window.EventHandler.unlisten('position_change', TWDS.banking.autohome_check)
  } else {
    window.EventHandler.listen('position_change', TWDS.banking.autohome_check)
    TWDS.banking.autohome_check()
  }
}
TWDS.registerStartFunc(function () {
  TWDS.registerSetting('bool', 'banking_deposit_button',
    TWDS._('BANKING_SETTING_DEPOSIT_BUTTON',
      'Al hacer clic en la cuenta bancaria en la fila superior, se abre un cuadro de diálogo para depositar su efectivo.'),
    true, TWDS.banking.depositinit,
    'Banca'
  )
  TWDS.registerSetting('bool', 'banking_auto_hometown',
    TWDS._('BANKING_SETTING_AUTOHOME',
      'Abrir el diálogo de depósito al llegar a su ciudad.'),
    false, TWDS.banking.autohome_toggle,
    'Banca'
  )
})
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.finished_task_handler = function () {
  if (Character.playerId === 0) {
    setTimeout(TWDS.finished_task_handler, 100)
    return
  }
  if (!TWDS.settings.misc_daily_activities_warning) {
    document.body.classList.remove('TWDS_daily_tasks_open')
    return
  }
  // the bloody signal is sent *before* the counter is updated,
  // *and* setFinishedTasks4CurrentDay does not reset the counter, before it adds to it.
  Character.setFinishedTasks(0)
  Character.setFinishedTasks4CurrentDay()
  if (Character.finishedTasks < 3) {
    document.body.classList.add('TWDS_daily_tasks_open')
  } else {
    document.body.classList.remove('TWDS_daily_tasks_open')
  }
}
TWDS.registerStartFunc(function () {
  EventHandler.listen('activity_changed', function () {
    TWDS.finished_task_handler()
    Character.setFinishedTasks(0) // because set...4current is called again, and counts again.
  })
  TWDS.registerSetting('bool', 'misc_daily_activities_warning',
    TWDS._('MISC_DAILY_ACTIVITIES_SETTING',
      'Mostrar un recordatorio de que aún no has terminado tres actividades diarias.'), true, function () {
      EventHandler.signal('activity_changed') // TW ignores missing key
    })
  TWDS.finished_task_handler()
})
TWDS.finishable_quest_handler = function () {
  if (!window.QuestLog.quests_loaded) { // yes, quests_loaded. quest_loaded is unused
    setTimeout(TWDS.finishable_quest_handler, 100)
    return
  }
  if (!TWDS.settings.misc_mark_tracker_when_finishable) {
    document.body.classList.remove('TWDS_quest_finishable')
    return
  }
  let f = false
  for (const id in window.QuestLog.quests) {
    const q = window.QuestLog.quests[id]
    if (q.finishable) {
      f = true
      break
    }
  }
  if (f) {
    document.body.classList.add('TWDS_quest_finishable')
  } else {
    document.body.classList.remove('TWDS_quest_finishable')
  }
}

TWDS.registerStartFunc(function () {
  const events = ['quest_tracking_changed', 'quest_solved', 'quest_update', 'quest_removed', 'quest_added', 'linearquest_added', 'linearquest_removed', 'linearquest_update', 'TWDS_quest_check']
  EventHandler.listen(events, function () {
    TWDS.finishable_quest_handler()
  })
  TWDS.registerSetting('bool', 'misc_mark_tracker_when_finishable',
    TWDS._('MISC_MARK_QUEST_FINISHABLE',
      'Marcar en el rastreador de búsquedas si la búsqueda se puede completar.'), true, function () {
      EventHandler.signal('TWDS_queck_check') // TW ignores missing key
    })
})

// duel protection.
TWDS.duelprotection = {}
TWDS.duelprotection.interval = 0
TWDS.duelprotection.hack = null
TWDS.duelprotection.updateMouseover = function () {
  const mand = Character.getMandatoryDuelProtection(true)
  const opt = Character.getDuelProtection(true)
  const now = (new window.ServerDate()).getTime()
  let str = ''
  let vgl = -1
  if (mand > now) {
    str = 'Duel suspension until ' + (new Date(mand)).toLocaleString()
    if (TWDS.duelprotection.hack) {
      TWDS.duelprotection.hack.css({
        'background-color': '#f446'
      })
    }
    vgl = mand
  } else if (opt > now) {
    str = 'Duel protection until ' + (new Date(opt)).toLocaleString()
    vgl = opt
    if (TWDS.duelprotection.hack) {
      TWDS.duelprotection.hack.css({
        'background-color': '#cc46'
      })
    }
  } else {
    if (TWDS.duelprotection.hack) {
      TWDS.duelprotection.hack.css({
        'background-color': '#4a43'
      })
    }
  }
  if (vgl !== -1) {
    const remain = Math.max((vgl - now) / 1000, 0) // ms
    const remainstr = remain.formatDuration()
    if (remain > 0) {
      str += ' (' + remainstr + ')'
    }
    str += '.\n'
  }
  const mot1 = Character.duelMotivation
  const mot2 = Character.npcDuelMotivation
  str += '<p>Duel motivation</p>'
  str += '<table>'
  str += '<tr><th>PC'
  str += '<td><meter min="0" low="0" optimum="1" high="1" max="1" value="' + mot1 + '"></meter>'
  str += '<td>' + parseInt(100 * mot1)
  str += '<tr><th>NPC'
  str += '<td><meter min="0" low="0" optimum="1" high="1" max="1" value="' + mot2 + '"></meter>'
  str += '<td>' + parseInt(100 * mot2)
  str += '</table>'
  str += '<p>The duel motivation is valid after you opened the duels menu. Unfortunately the data is not updated earlier.</p>'
  if (TWDS.duelprotection.hack) {
    TWDS.duelprotection.hack.addMousePopup(str)
  }
}
TWDS.duelprotection.init = function (active) {
  if (!active) {
    if (TWDS.duelprotection.interval) {
      clearInterval(TWDS.duelprotection.interval)
      TWDS.duelprotection.interval = 0
    }
    if (TWDS.duelprotection.hack !== null) {
      TWDS.duelprotection.hack.removeMousePopup()
      TWDS.duelprotection.hack.remove()
    }
    return
  }

  if (TWDS.settings.misc_duelprotection_display) {
    const cl = $('#ui_character_container')
    const hack = $("<div id='TWDS_duelprotection_hack' />")
    hack.css({
      position: 'relative',
      background: "url('" + Game.cdnURL + "/images/interface/dock_icons.png?4')",
      width: '52px',
      height: '52px',
      cursor: 'pointer',
      'background-size': 'auto',
      display: 'inline-block',
      right: '-4px',
      top: '24px',
      'background-position-x': '-52px',
      'background-position-y': '-52px',
      'border-radius': '50%',
      'background-color': '#7776'
    })
    $(cl).append(hack)
    $(hack).on('mouseenter', TWDS.duelprotection.updateMouseover)
    TWDS.duelprotection.hack = hack
    // update the bg color, too.
    TWDS.duelprotection.updateMouseover()
    TWDS.duelprotection.interval = setInterval(TWDS.duelprotection.updateMouseover, 60 * 1000)
  }
}
TWDS.registerStartFunc(function () {
  TWDS.registerSetting('bool', 'misc_duelprotection_display',
    TWDS._('MISC_SETTING_DUELPROTECTION_DISPLAY', 'Mostrar la protección de duelo superpuesta en tu imagen.'),
    true, TWDS.duelprotection.init)
  TWDS.registerSetting('bool', 'misc_profile_text_click',
    TWDS._('MISC_SETTING_PROFILE_TEXT_CLICK',
      'Un clic en el texto de su perfil abre los ajustes del perfil.'), true)
  // the itemmanager_loaded is sent after Character.init is called.
  EventHandler.listen('itemmanager_loaded', function () {
    TWDS.delegate(document, 'click', '.tw2gui_window.playerprofile-' + Character.playerId + ' .profile-desc', function () {
      if (TWDS.settings.misc_profile_text_click) {
        /* eslint-disable no-new */
        new window.OptionsWindow()
      }
    })
    return EventHandler.ONE_TIME_EVENT
  })
})

TWDS.map = {}
TWDS.map.radialmenu_open = function () {
  this._TWDS_map_backup_open(true)
}
TWDS.map.radialmenu_close = function () {
  this._TWDS_map_backup_close(true)
}
TWDS.registerStartFunc(function () {
  window.Map.Helper.imgPath._TWDS_backup_lookForModification = window.Map.Helper.imgPath.lookForModification
  window.Map.Helper.imgPath.lookForModification = function (path, ongameload) {
    if (TWDS.settings.misc_normal_water_color) {
      return path
    }
    return window.Map.Helper.imgPath._TWDS_backup_lookForModification(path, ongameload)
  }
  // we may already be too late… the damage may be done.
  TWDS.registerSetting('bool', 'misc_normal_water_color',
    'Mostrar los colores normales del agua en lugar de los rosados/rojos/verdes de los eventos. Debe recargar la página después de cambiar.', false, null, 'Mapa')
  if (TWDS.settings.misc_normal_water_color) {
    Map.Helper.imgPath.clearCache()
  }

  window.Map.Radialmenu.prototype._TWDS_map_backup_close = window.Map.Radialmenu.prototype.close
  window.Map.Radialmenu.prototype._TWDS_map_backup_open = window.Map.Radialmenu.prototype.open
  TWDS.registerSetting('bool', 'no_jobgroup_animation',
    TWDS._('TWDS_SETTING_no_jobgroup_animation',
      'No animar la apertura y cierre de los grupos de trabajo.'),
    false, function (v) {
      if (v) {
        window.Map.Radialmenu.prototype.close = TWDS.map.radialmenu_close
        window.Map.Radialmenu.prototype.open = TWDS.map.radialmenu_open
      } else {
        window.Map.Radialmenu.prototype.close = window.Map.Radialmenu.prototype._TWDS_map_backup_close
        window.Map.Radialmenu.prototype.open = window.Map.Radialmenu.prototype._TWDS_map_backup_open
      }
    }, 'Mapa')
  TWDS.registerSetting('bool', 'misc_trader_show_max_button',
    TWDS._('MISC_SETTING_SHOW_MAX_BUTTON',
      'Mostrar el botón "max" mientras vendes al comerciante ambulante.'),
    false, function (v) {
      if (v) {
        document.body.classList.add('TWDS_show_trader_max_value')
      } else {
        document.body.classList.remove('TWDS_show_trader_max_value')
      }
    }, 'Miscelánea')
})

TWDS.registerSetting('bool', 'fixRecruitHealth',
  TWDS._('RECRUIT_HEALTH_FIX', 'Arreglar filas demasiado largas en la pantalla de reclutamiento de batalla.'),
  false, function (val) {
    const old = document.getElementById('TWDS_fix_recruit_health')
    if (old) old.parentNode.removeChild(old)
    if (val) {
      const sty = document.createElement('style')
      sty.id = 'TWDS_fix_recruit_health'
      sty.textContent = '.fort_battle_recruitlist_list .tbody .healthpoints p { font-size:smaller}'
      document.body.appendChild(sty)
    }
  })
TWDS.registerSetting('bool', 'fixGraveyardtable',
  TWDS._('RECRUIT_HEALTH_FIX', 'Arreglar filas demasiado largas en el cuadro de batallas recientes.'),
  false, function (val) {
    if (val) {
      document.body.classList.add('TWDS_fix_graveyard')
    } else {
      document.body.classList.remove('TWDS_fix_graveyard')
    }
  })

TWDS.friendrequestcounter = {}
TWDS.friendrequestcounter.update = function () {
  const pa = TWDS.q1('#ui_bottombar .dock-image.friends')
  if (!pa) return
  let ele = TWDS.q1('.TWDS_requestcounter', pa)
  if (!TWDS.settings.friendrequestcounter) {
    if (ele) ele.remove()
    return
  }
  if (!ele) {
    ele = TWDS.createEle('div.TWDS_requestcounter', {
      textContent: '',
      last: pa,
      style: {
        position: 'absolute',
        bottom: '5px',
        right: '5px',
        border: '1px solid ###',
        backgroundColor: '#ae9c6888',
        color: 'black',
        display: 'none',
        fontSize: 'small',
        boxShadow: '-1px -1px 2px #000'
      }
    })
  }
  const n = window.FriendslistWindow.OpenRequestsCounter
  if (n) {
    ele.style.display = 'block'
    ele.textContent = n
  } else {
    ele.style.display = 'none'
  }
}
TWDS.friendrequestcounter.setopenrequests = function (n) {
  window.FriendslistWindow.TWDS_backup_setOpenRequests.call(this, n)
  TWDS.friendrequestcounter.update()
}
TWDS.registerStartFunc(function () {
  window.FriendslistWindow.TWDS_backup_setOpenRequests = window.FriendslistWindow.TWDS_backup_setOpenRequests || window.FriendslistWindow.setOpenRequests
  window.FriendslistWindow.setOpenRequests = TWDS.friendrequestcounter.setopenrequests
  let startupdelay = 7 // avoid thundering heard at the start of the game
  TWDS.registerSetting('bool', 'friendrequestcounter',
    TWDS._('SHOW_FRIENDREQUEST_COUNTER', 'Mostrar el nº de solicitudes de amistad abiertas en la barra inferior.'),
    true, function (val) {
      if (val) {
        Ajax.remoteCallMode('character', 'get_friends', {}, function (json) {
          setTimeout(function () {
            window.FriendslistWindow.OpenRequestsCounter = json.open_requests
            TWDS.friendrequestcounter.update()
            EventHandler.listen('friend_invitation_sent', TWDS.friendrequestcounter.update)
            startupdelay = 0
          }, startupdelay * 1000 + 10)
        })
      } else {
        TWDS.friendrequestcounter.update() // turn off
        EventHandler.unlisten('friend_invitation_sent', TWDS.friendrequestcounter.update)
      }
    })

  // update the open requests counter every 15 minutes. it's not updated when you invite someone or get an invitation.
  setInterval(function () {
    Ajax.remoteCallMode('character', 'get_friends', {}, function (json) {
      window.FriendslistWindow.OpenRequestsCounter = json.open_requests
      TWDS.friendrequestcounter.update()
    })
  }, 15 * 60 * 1000)
  /*
  // update the display every minute, because we are not informed
  setInterval(function() {
    Ajax.remoteCallMode('character', 'get_friends', {}, function(json) {
      window.FriendslistWindow.OpenRequestsCounter=json["open_requests"];
      TWDS.updatefriendrequestcounter();
    });
  }, 1*60*1000);
  */
})

TWDS.registerStartFunc(function () {
  west.gui.payHandler.prototype._TWDS_backup_addPayOption = west.gui.payHandler.prototype.addPayOption
  west.gui.payHandler.prototype.addPayOption = function (e) {
    this._TWDS_backup_addPayOption.apply(this, arguments)
    if (TWDS.settings.misc_avoid_nuggets) {
      if (e === false || e === 'nugget' || e === 2 || e.id === 2) {
        return this
      }
      this.setSelectedPayId(e.id || e)
      return this
    }
    return this
  }

  TWDS.registerSetting('bool', 'misc_avoid_nuggets',
    TWDS._('MISC_AVOID_NUGGETS',
      'Utilizar por defecto otros metodos de pago distintos de las pepitas, si es posible.'),
    false)
})
TWDS.highlightTeles = function () {
  if (!('read' in Character)) return
  const x = TWDS.q1('#ui_bottombar .button.message')
  x.style.outline = 'none'
  if (TWDS.settings.misc_highlight_telegrams) {
    if (!Character.read.messages) return
    x.style.outline = '2px solid red'
  }
}
TWDS.registerStartFunc(function () {
  setInterval(TWDS.highlightTeles, 5000) // to delete the outline
  EventHandler.listen('player-toread-messages', TWDS.highlightTeles)
  TWDS.registerSetting('bool', 'misc_highlight_telegrams',
    TWDS._('MISC_HIGHLIGHT_TELEGRAMS',
      'Resaltar el botón de mensajes con borde rojo si tiene telegramas no leídos.'),
    false)
  const donotibar = function (v) {
    if (WestUi && WestUi.NotiBar && WestUi.NotiBar.main) {
      WestUi.NotiBar.main.setMaxView(TWDS.settings.misc_notibar_main_max)
      return
    }
    window.setTimeout(donotibar, 500)
  }
  TWDS.registerSetting('int', 'misc_notibar_main_max',
    TWDS._('MISC_SETTING_NOTIBAR_MAIN_MAX',
      'Fijar la cantidad de elementos que se muestran en la barra de notificaciones principal (salón y demás).'),
    { default: 4, min: 2, max: 8 }, donotibar)

  WestUi.NotiBar.TWDS_backup_add = WestUi.NotiBar.TWDS_backup_add || WestUi.NotiBar.add
  WestUi.NotiBar.add = function (entry) {
    console.log('NotiBar.add', entry)
    if (TWDS.settings.misc_notibar_remove_sale) {
      if (entry.element) {
        const found = TWDS.q1('.image.shop_sale', entry.element[0])
        if (found) {
          return
        }
      }
    }
    WestUi.NotiBar.TWDS_backup_add.call(this, entry)
  }
  const doremovesale = function (v) {
    if (WestUi && WestUi.NotiBar && WestUi.NotiBar.main) {
      if (v) {
        WestUi.NotiBar.getBar().list.forEach(function (a) {
          const found = TWDS.q1('.image.shop_sale', a.element[0])
          if (found) WestUi.NotiBar.remove(a)
        })
      }

      WestUi.NotiBar.main.setMaxView(TWDS.settings.misc_notibar_main_max)
      return
    }
    window.setTimeout(doremovesale, 500)
  }

  TWDS.registerSetting('bool', 'misc_notibar_remove_sale',
    TWDS._('MISC_SETTING_NOTIBAR_REMOVE_SALE',
      'Eliminar el botón de venta de la barra de notificaciones principal (bar y demás).'),
    { default: false }, doremovesale)
})
TWDS.registerSetting('bool', 'misc_tailor_scrollbar_fix',
  TWDS._('MISC_SETTING_TAILOR_SCROLLBAR_FIX',
    'Arreglar en el sastre el desbordamiento de la barra de desplazamiento.'),
  true, function (v) {
    if (v) {
      document.body.classList.add('TWDS_fix_tailor_scrollbar')
    } else {
      document.body.classList.remove('TWDS_fix_tailor_scrollbar')
    }
  })

TWDS.misc_sheriffwindow_open = function (townId, tabId, wanted) {
  window.SheriffWindow._TWDS_backup_open.call(this, townId, tabId, wanted)
  if (wanted) {
    TWDS.misc_sheriff_bounty_namechange2(wanted)
  }
}

TWDS.misc_sheriff_bounty_namechange2 = function (name) {
  if (!TWDS.settings.misc_sheriff_minbounty) return false
  name = name.trim().toLocaleLowerCase()
  Ajax.remoteCallMode('ranking', 'get_data', { search: name, tab: 'experience', rank: 'NaN' }, function (d) {
    for (let i = 0; i < d.ranking.length; i++) {
      if (d.ranking[i].name.toLocaleLowerCase() === name) {
        Ajax.remoteCallMode('profile', 'init', { playerId: d.ranking[i].player_id }, function (e) {
          const container = TWDS.q1('#windows .sheriff .sheriff-create')
          if (container) {
            const rewinput = TWDS.q1('#tbsh_iReward')
            if (rewinput) {
              const reward = parseInt(rewinput.value)
              if (reward < e.level * 10 || isNaN(reward)) {
                rewinput.value = e.level * 10
              }
            }
          }
        })
      }
    }
  })
}
TWDS.misc_sheriff_bounty_namechange = function () {
  TWDS.misc_sheriff_bounty_namechange2(this.value)
}
TWDS.registerStartFunc(function () {
  window.SheriffWindow._TWDS_backup_open = window.SheriffWindow.open
  window.SheriffWindow.open = TWDS.misc_sheriffwindow_open
  TWDS.registerSetting('bool', 'misc_sheriff_minbounty',
    TWDS._('MISC_SETTING_SHERIFF_MINBOUNTY',
      'En la pestaña "ofrecer recompensa" de la ventana del sheriff, fijar la recompensa ofrecida al mínimo para el nivel de duelo del personaje buscado.'),
    true)
  TWDS.delegate(document.body, 'change', '#windows .sheriff .sheriff-create #tbsh_iCharname',
    TWDS.misc_sheriff_bounty_namechange)
})
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.backup_minimap_cache = TWDS.minimap ? TWDS.minimap.cache : {}

TWDS.minimap = {}
TWDS.minimap.cache = TWDS.backup_minimap_cache || {}
TWDS.minimap.isDefined = function (variable) {
  if (typeof variable === 'undefined' || variable == null) { return false } else { return true }
}
TWDS.minimap.savecache = function () {
  // store in localstorage
  const x = {}
  x.data = TWDS.minimap.cache
  x.time = (new Date()).getTime()
  window.localStorage.setItem('TWDS_silvergold', JSON.stringify(x))
}
TWDS.minimap.loadcache = function () {
  TWDS.minimap.cache = {}
  const stored = window.localStorage.getItem('TWDS_silvergold')
  if (stored) {
    const data = JSON.parse(stored).data
    // i thought the invalidation date was 01:30 UTC, but clothcalc uses 1:15.
    // clothcache got many things right, so use that.
    const cmp = new Date()
    cmp.setUTCHours(1)
    cmp.setMinutes(15)
    cmp.setSeconds(0)
    cmp.setMilliseconds(0)
    let stich = cmp.getTime()
    if (window.get_server_date < stich) {
      stich = stich - 86400 * 1000 // back one day
    }
    TWDS.minimap.cache = {}
    for (const oneposkey in data) {
      const oneposdata = data[oneposkey]
      for (const onejobkey in oneposdata) {
        const onejobdata = oneposdata[onejobkey]
        if (onejobdata.silver) {
          if (onejobdata.time < stich) { continue }
        }
        if (!(oneposkey in TWDS.minimap.cache)) { TWDS.minimap.cache[oneposkey] = {} }
        TWDS.minimap.cache[oneposkey][onejobkey] = onejobdata
      }
    }
  }
}
TWDS.minimap.findsilverjob = function (id) {
  TWDS.minimap.loadcache()
  id = parseInt(id)
  const out = []
  for (const poskey in TWDS.minimap.cache) {
    for (let j in TWDS.minimap.cache[poskey]) {
      j = parseInt(j)
      if (j === id) {
        if (TWDS.minimap.cache[poskey][j].silver) {
          out.push(TWDS.minimap.cache[poskey][j])
        }
      }
    }
  }
  return out
}

TWDS.minimap.deletefromcache = function (silver, gold) {
  for (const oneposkey in TWDS.minimap.cache) {
    const oneposdata = TWDS.minimap.cache[oneposkey]
    for (const onejobkey in oneposdata) {
      const onejobdata = oneposdata[onejobkey]
      if (silver && onejobdata.silver) {
        delete TWDS.minimap.cache[oneposkey][onejobkey]
      }
      if (gold && onejobdata.gold) {
        delete TWDS.minimap.cache[oneposkey][onejobkey]
      }
    }
    let count = 0
    for (const onejobkey in oneposdata) {
      if (Object.prototype.hasOwnProperty.call(oneposdata, onejobkey)) {
        count++
      }
    }
    if (count === 0) {
      delete TWDS.minimap.cache[oneposkey]
    }
  }
}

TWDS.minimap.radialmenu = function (e) {
  const t = window.Map.Helper.getPosition(e.parent)
  if (!t || !('x' in t) || !('y' in t)) {
    return
  }
  const key = t.x + '-' + t.y
  if (!TWDS.minimap.isDefined(window.Map.JobHandler.Featured[key])) {
    // gold job gone?
    delete TWDS.minimap.cache[key]
  } else {
    const marked = {}
    for (const i in TWDS.minimap.cache[key]) {
      if (TWDS.minimap.cache[key][i].marked) { marked[TWDS.minimap.cache[key][i].job_id] = true }
    }
    const r = window.Map.JobHandler.Featured[t.x + '-' + t.y]
    TWDS.minimap.cache[key] = {}
    for (const i in r) {
      if (!Object.prototype.hasOwnProperty.call(r, i)) {
        continue
      }
      TWDS.minimap.cache[key][i] = r[i]
      if (marked[r[i].job_id]) { TWDS.minimap.cache[key][i].marked = true }
      TWDS.minimap.cache[key][i].time = (new Date()).getTime()
    }
  }
  TWDS.minimap.updateIfOpen()
  TWDS.minimap.savecache()
}
TWDS.minimap.updateWhenOpen = function () {
  if (!TWDS.minimap.isOpen()) {
    window.setTimeout(TWDS.minimap.updateWhenOpen, 100)
    return
  }
  TWDS.minimap.updateReal()
}
TWDS.minimap.updateIfOpen = function () {
  if (!TWDS.minimap.isOpen()) {
    return
  }
  TWDS.minimap.updateReal()
}
TWDS.minimap.findjob = function (jname) {
  jname = jname.toUpperCase()
  if (!window.JobsModel) return null
  if (!window.JobsModel.Jobs) return null
  if (!window.JobsModel.Jobs.length) return null
  for (let i = 0, len = JobsModel.Jobs.length; i < len; ++i) {
    if (JobsModel.Jobs[i] && JobsModel.Jobs[i].name.toUpperCase() === jname) {
      return JobsModel.Jobs[i].id
    }
  }
  return null
}
TWDS.minimap.gettrackedjobs = function () {
  const tracked = {}
  for (const q of Object.values(window.QuestTrackerWindow.trackedQuests)) {
    for (let i = 0; i < q.requirements.length; i++) {
      const r = q.requirements[i]
      if (r.solved === false && r.jsInfo) {
        if (r.jsInfo.type === 'task-finish-job') {
          tracked[r.jsInfo.id] = true
        }
        if (r.jsInfo.type === 'inventory_changed') {
          const x = JobList.getJobsIdsByItemId(r.jsInfo.id)
          for (let y = 0; y < x.length; y++) { tracked[x[y]] = true }
        }
      }
    }
  }
  return tracked
}

TWDS.minimap.updateReal = function () {
  TWDS.minimap.uiinit()

  const handleonebonusposition = function (x, y, withgold, markflag, a, withtracked, withsearched,
    withmissing, withalways, withcollection, alwayscolor) {
    const o = 0.00513
    const x1 = parseInt(x * o, 10) - 3
    const y1 = parseInt(y * o, 10) + 2
    let mayrotate = ''
    if (a.length > 1) {
      mayrotate = 'transform:rotate(45deg);'
    }
    let cl = ''
    if (withgold) { cl += ' gold' }
    if (withtracked) { cl += ' tracked' }
    if (withsearched) { cl += ' searched' }
    if (withmissing) { cl += ' storagemissing' }
    if (withalways) { cl += ' hl_always' }
    if (withcollection) { cl += ' collection' }
    if (markflag) { cl += ' marked' }
    let style = 'left:' + x1 + 'px;top:' + y1 + 'px;' + mayrotate
    if (alwayscolor !== '') {
      style += ';border-color:' + alwayscolor
    }
    const str = "<div class='TWDS_bonusjob " + cl + "' style='" + style + "' />"
    const ele = $(str)
    ele.addMousePopup('<div style="min-width:60px;text-align:center">' +
        a.join('<div class="marker_popup_divider"></div>') + '</div>')
    ele[0].dataset.posx = x
    ele[0].dataset.posy = y

    ele.click(function (e, t) {
      window.Map.center(
        e.target.dataset.posx,
        e.target.dataset.posy
      )
    })
    $('#minimap_worldmap').append(ele)
  }
  const handleonemarketposition = function (x, y, a) {
    const o = 0.00513
    const x1 = parseInt(x * o, 10) - 3
    const y1 = parseInt(y * o, 10) + 2
    let mayrotate = ''
    if (a > 1) {
      mayrotate = 'transform:rotate(45deg);'
    }
    const style = 'z-index:7 ;position:absolute; display:block; width:4px; height:4px; ' +
              'background-color:' + 'blue' +
               ';left:' + x1 + 'px;top:' + y1 + 'px;' + mayrotate + 'border:1px solid ' +
               'black' + ";'"

    const str = "<div class='TWDS_mm_markethack' style='" + style + "'/>"
    const ele = $(str)
    ele.addMousePopup('<div style="min-width:60px;text-align:center">' +
        a + ' ' + TWDS._('ITEMS', 'items') + '</div>')
    ele[0].dataset.posx = x
    ele[0].dataset.posy = y

    ele.click(function (e, t) {
      window.Map.center(
        e.target.dataset.posx,
        e.target.dataset.posy
      )
    })
    $('#minimap_worldmap').append(ele)
  }
  let tracked = {}
  if (TWDS.settings.minimap_silvergold && TWDS.settings.minimap_silvergold_trackerhelper) {
    tracked = TWDS.minimap.gettrackedjobs()
  }

  // $("#minimap_worldmap").css("position","relative"); not good, messes up map
  $('#minimap_worldmap .TWDS_bonusjob').remove()
  $('#minimap_worldmap .TWDS_storagejob').remove()
  if (TWDS.settings.minimap_silvergold) {
    let missingStorage = {}
    let missingCollections = {}
    if (TWDS.settings.minimap_silvergold_storagehelper) { missingStorage = TWDS.storage.getMissingList() } // object jobId->someItemId
    if (TWDS.settings.minimap_silvergold_collecthelper) { missingCollections = TWDS.collections.getMissingList() } // object jobId->someItemId

    const jobname = $('.minimap .tw2gui_jobsearch_string').val()
    let jobid = null
    if (jobname) { jobid = TWDS.minimap.findjob(jobname) }

    for (const oneposkey in TWDS.minimap.cache) {
      const oneposdata = TWDS.minimap.cache[oneposkey]
      const a = []
      let x = -1
      let y = -1
      let withgold = false
      let withtracked = false
      let withsearched = false
      let withmissing = false
      let withalways = false
      let withcollection = false
      let marked = false
      let alwayscolor = ''
      for (const onejobkey in oneposdata) {
        const onejob = oneposdata[onejobkey]
        x = onejob.x
        y = onejob.y
        // let silver=onejob.silver
        const gold = onejob.gold
        const jid = onejob.job_id
        const job = JobList.getJobById(jid)
        if (gold) withgold = true
        if (onejob.marked) marked = true
        if (jid in tracked) { withtracked = true }
        if (jid === jobid) withsearched = true
        if (jid in missingStorage) withmissing = true
        if (jid in missingCollections) withcollection = true
        if ('BJHL_' + jid in TWDS.settings && TWDS.settings['BJHL_' + jid]) withalways = true
        if ('BJHLC_' + jid in TWDS.settings && TWDS.settings['BJHLC_' + jid]) { alwayscolor = TWDS.settings['BJHLC_' + jid] }

        let str = "<div style='min-width:60px;text-align:center' >"
        str += "<span style='font-weight:bold;display:block;'>" + job.name + '</span>' +
               "<div class='job' style='position:relative;left:50%;margin:10px -25px;'>" +
               "<div class='featured " + (gold ? 'gold' : 'silver') + "'></div>" +
               "<img src='" + Game.cdnURL + '/images/jobs/' + job.shortname + ".png' class='job_icon' >" +
               '</div>'
        str += '</div>'
        a.push(str)
      }
      if (a.length > 0) {
        handleonebonusposition(x, y, withgold, marked, a, withtracked, withsearched, withmissing,
          withalways, withcollection, alwayscolor)
      }
    }
  }

  $('#minimap_worldmap .TWDS_mm_markethack').remove()
  if (TWDS.settings.minimap_worldmapmarket_active) {
    const mmapdata = window.localStore4Minimap.minimapData
    if (mmapdata) {
      const marketdata = mmapdata.market_locations
      if (marketdata) {
        for (const i in marketdata) {
          if (!Object.prototype.hasOwnProperty.call(marketdata, i)) continue
          const x = marketdata[i].x
          const y = marketdata[i].y
          handleonemarketposition(x, y, marketdata[i].amount)
        }
      }
    }
  }
  // we are running in an ajaxcomplete-handler, _before_ anything real is done...
  setTimeout(function () {
    TWDS.minimap.county15extras()
  }, 25)
}
TWDS.minimap.county15extras = function () {
  try {
    const cb = TWDS.q1('#mmap_countybox_15')
    if (cb) {
      const old = TWDS.q1('div.TWDS_c15extras')
      if (old) old.remove()
      const d = TWDS.createEle('div.TWDS_c15extras', {
        last: cb.parentNode
      })
      if (Object.keys(window.Markers.markers).length > 0) {
        TWDS.createEle('button.deleteallmarks.TWDS_button', {
          textContent: 'delete all markers',
          last: d,
          onclick: function () {
            let timeout = 0
            window.Markers.each(function (m) {
              timeout += 1000
              setTimeout(function () {
                window.Markers.remove(m)
              }, timeout)
            })
            return false
          }
        })
      }
    }
  } catch (e) {
    // ignored.
  }
}

TWDS.minimap.showtaskjobgroups = function () {
  const ls4mm = window.localStore4Minimap
  let countyno = ls4mm.minimapData.current_county
  const div = TWDS.q1('.mmap_countybox', '#mmap_countymap')
  if (!div || !div.id) return
  const mat = div.id.match(/^mmap_countybox_(\d+)$/)
  if (mat) {
    countyno = mat[1]
  }

  const displayedCounty = Map.Counties.getCounty(countyno)
  const layer = TWDS.q1('#mmap_layer_' + countyno + '_jobs')
  if (!layer) {
    return
  }

  const tracked = TWDS.minimap.gettrackedjobs()
  console.log('tracked jobs', tracked)
  const trackedgroups = []
  Object.keys(tracked).forEach(jid => {
    const jd = JobList.getJobById(jid)
    const gid = jd.groupid
    if (!trackedgroups[gid]) { trackedgroups[gid] = [jd.name, [jid], gid] } else {
      trackedgroups[gid][0] += ', ' + jd.name
      trackedgroups[gid][1].push(jid)
    }
  })
  console.log('tracked groups', trackedgroups)

  trackedgroups.forEach(gd => {
    const gid = gd[2]
    const gplaces = ls4mm.minimapData.job_groups[gid]
    // console.log("handle g",gid,gplaces);
    for (let i = 0; i < gplaces.length; i++) {
      const coord = displayedCounty.calcCoord4Map([gplaces[i][0], gplaces[i][1]])
      if (coord) {
        // console.log("TG ADD",gid,gd,i,coord);
        TWDS.createEle({
          nodeName: 'div',
          style: {
            left: coord.x + 'px',
            top: coord.y + 'px',
            position: 'absolute',
            border: '1px solid red',
            backgroundColor: '#4448',
            color: '#fff',
            fontSize: 'smaller'
          },
          last: layer,
          textContent: gid,
          title: gd[0]
        })
      }
    }
  })
}

TWDS.minimap.importtext = function (text) {
  const isnum = function (n) {
    return !isNaN(parseFloat(n)) && isFinite(n)
  }
  const lines = text.split(/[\n,\r,\r\n]/)
  for (let i = 0; i < lines.length; i++) {
    // Railroad Ticket Agent; silver; 4815-1121; 165
    const parts = lines[i].split(';', 4)
    if (parts.length !== 4 || !isnum(parts[3]) || !JobsModel.getById(Number(parts[3]))) {
      continue
    }
    const pos = String(parts[2]).split('-', 2)
    if (pos.length !== 2 || !isnum(pos[0]) || !isnum(pos[1])) {
      continue
    }
    const jid = Number(parts[3])
    const entry = {
      gold: $.trim(parts[1]) === 'gold',
      group_id: JobsModel.getById(jid).groupid,
      job_id: jid,
      silver: $.trim(parts[1]) !== 'gold',
      x: Number(pos[0]),
      y: Number(pos[1]),
      time: (new Date()).getTime()
    }
    const key = Number(pos[0]) + '-' + Number(pos[1])
    if (!(key in TWDS.minimap.cache)) {
      TWDS.minimap.cache[key] = {}
    }
    TWDS.minimap.cache[key][jid] = entry
  }
  TWDS.minimap.savecache()
  TWDS.minimap.updateIfOpen()
}

TWDS.minimap.import = function () {
  const textarea = $('<textarea />').css({
    width: '400px',
    minHeight: '100px'
  })
  const doit = function () {
    TWDS.minimap.importtext(textarea.val())
  };
  (new west.gui.Dialog('Bonus-Jobs Import', textarea)).addButton('ok', doit).addButton('cancel').show()
}

TWDS.minimap.export = function () {
  const bonusjobs = []
  for (const pos in TWDS.minimap.cache) {
    for (const jid in TWDS.minimap.cache[pos]) {
      const jd = JobsModel.getById(jid)
      const o = TWDS.minimap.cache[pos][jid]
      let county = Math.ceil(o.x / 6635) + (o.y > 10176 ? 7 : 0)
      if (o.x >= 3 * 6635 && o.x < 4 * 6635) {
        if (o.y > 6635 && o.y < 2 * 6635) {
          county = 15
        }
      }
      bonusjobs.push({
        name: jd.name,
        bonus: o.gold ? 'gold' : 'silver',
        county: county,
        x: o.x,
        y: o.y,
        id: jid
      })
    }
  }
  const maketextarea = function (id) {
    const ta = $('<span>').css({
      width: '500px',
      'min-height': '40px',
      'background-color': 'transparent',
      border: '1px solid block',
      'white-space': 'pre',
      cursor: 'pointer',
      display: 'block',
      'max-height': '25vh',
      overflow: 'scroll',
      '-webkit-user-select': 'text',
      '-moz-user-select': 'text',
      'user-select': 'text'
    }).attr('id', id).click(function () {
      const selection = window.getSelection()
      selection.selectAllChildren(this)
    })
    return ta
  }
  const downloader = function () {
    const id = this.dataset.contentid
    const desc = this.dataset.desc
    const content = $('#' + id).text()
    let dt = (new Date()).toISOString()
    dt = dt.replaceAll(/[^0-9]/, '')

    const fn = 'bonusjobs_' + Game.worldName.replace(/ /g, '_') + '_' + desc +
        '_' + dt + '.txt'

    const a = document.createElement('a')
    const blob = new Blob([content], { type: 'text/plain' })
    const url = URL.createObjectURL(blob)
    a.setAttribute('href', url)
    a.setAttribute('download', fn)
    a.click()
    URL.revokeObjectURL(url)
  }

  const cmp1 = function (a, b) {
    return a.name > b.name ? 1 : -1
  }
  bonusjobs.sort(cmp1)
  const ta1 = maketextarea('TWDS_minimap_joblist_abc')

  let out = ''
  for (let i = 0; i < bonusjobs.length; i++) {
    const o = bonusjobs[i]
    out += '[marker ' + o.x + ' ' + o.y + ' '
    out += o.name + ']; ' + o.bonus + '; '
    out += "<span class='TWDS_minimap_export_pos'>" + o.x + '-' + o.y + '</span>; '
    out += o.id + '\n'
  }
  ta1.html(out)

  const cmp2 = function (a, b) {
    if (a.county !== b.county) { return a.county > b.county ? 1 : -1 }
    return a.name > b.name ? 1 : -1
  }
  bonusjobs.sort(cmp2)
  const ta2 = maketextarea('TWDS_minimap_joblist_123')

  out = ''
  let lastcounty = ''
  for (let i = 0; i < bonusjobs.length; i++) {
    const o = bonusjobs[i]
    if (o.county !== lastcounty) {
      lastcounty = o.county
      out += '-- ?county ' + o.county
      if (o.county === 15) {
        out += ' (center)'
      }
      out += ' --' + '\n'
    }
    out += '[marker ' + o.x + ' ' + o.y + ' '
    out += o.name + ']; ' + o.bonus + '; '
    out += "<span class='TWDS_minimap_export_pos'>" + o.x + '-' + o.y + '</span>; '
    out += o.id + '\n'
  }
  ta2.html(out)

  const content = $('<div />')
  content.css({
    width: '500px',
    'min-height': '22px'
  })
  const headabc = $('<h2>ABC...</h2>')
  const head123 = $('<h2>123...</h2>')

  const download123 = $('<a>download</a>')
  download123[0].dataset.contentid = 'TWDS_minimap_joblist_123'
  download123[0].dataset.desc = 'bycounty'
  download123.css({
    float: 'right'
  })
  download123.click(downloader)

  const downloadabc = $('<a>download</a>')
  downloadabc[0].dataset.contentid = 'TWDS_minimap_joblist_abc'
  downloadabc[0].dataset.desc = 'byname'
  downloadabc.css({
    float: 'right'
  })
  downloadabc.click(downloader)

  content.append(downloadabc)
  content.append(headabc)
  content.append(ta1)
  content.append(download123)
  content.append(head123)
  content.append(ta2);

  (new west.gui.Dialog('Bonus-Jobs Export', $('<div />').append(content))).addButton('ok').show()
}
TWDS.minimap.export_center_handler = function () {
  const pos = this.textContent.split('-', 2)
  Map.center(pos[0], pos[1])
}
TWDS.minimap.ajaxCompletehandler = function (event, xhr, settings) {
  const url = settings.url
  if (url.search('window=map') !== -1) {
    if (url.search('ajax=get_minimap') !== -1) {
      TWDS.minimap.updateIfOpen()
    }
  }
}

TWDS.minimap.interval = -1
TWDS.minimap.isOpen = function () {
  const x = document.querySelector('#minimap_worldmap')
  if (!x) return false
  return true
}

TWDS.minimap.init = function () {
  TWDS.delegate(document.body, 'click', '.TWDS_minimap_export_pos',
    TWDS.minimap.export_center_handler)
  // Radial Menu can tell us about gold/silver jobs
  try {
    if (!window.Map.Radialmenu.prototype._twds_minimap_open) {
      window.Map.Radialmenu.prototype._twds_minimap_radial_open = window.Map.Radialmenu.prototype.open
      window.Map.Radialmenu.prototype.open = function (e) {
        try {
          this._twds_minimap_radial_open(e)
          TWDS.minimap.radialmenu(this)
        } catch (n) {
          console.error('caught exception handling radialmenu', n)
        }
      }
    }
  } catch (t) {
    console.error('caught around radialmenu', t)
  }

  try {
    if (!MinimapWindow._open) {
      MinimapWindow._twds_minimap_window_open = MinimapWindow.open
      MinimapWindow.open = function (e) {
        try {
          MinimapWindow._twds_minimap_window_open(e)
          TWDS.minimap.updateWhenOpen()
        } catch (t) {
          console.error(t, 'MinimapWindow.open')
        }
      }
    }
  } catch (t) {
    console.error(t, 'manipulate MinimapWindow.open')
  }
  try {
    if (!MinimapWindow._twds_minimap_refreshWindow) {
      MinimapWindow._twds_minimap_refreshWindow = MinimapWindow.refreshWindow
      MinimapWindow.refreshWindow = function () {
        try {
          console.log('inrefresh')
          MinimapWindow._twds_minimap_refreshWindow()
          window.setTimeout(TWDS.minimap.updateIfOpen, 2100)
        } catch (e) {
          console.error(e, 'MinimapWindow.refreshWindow')
        }
      }
    }
  } catch (t) {
    console.error(t, 'manipulate MinimapWindow.refreshWindow')
  }
  // MinimapWindow.refreshWindow() uses setTimeout and an ajax request in it, and updating the minimap after that is painful, unless ajaxcomplete is used. oh well.
  $(document).on('ajaxComplete', function (a, b, c) { TWDS.minimap.ajaxCompletehandler(a, b, c) })
}

TWDS.minimap.opacityhandler = function (ev) {
  if (this.checked) { document.body.classList.add('TWDS_searchmode') } else { document.body.classList.remove('TWDS_searchmode') }
}
TWDS.minimap.arrowclickhandler = function (ev) {
  TWDS.minimap.arrowclickhandler2(ev)
}
TWDS.minimap.arrowclickhandler2 = function (ev) {
  const w = Map.width
  const h = Map.height
  let xmod = 0
  let ymod = 0
  if (ev.target.classList.contains('left')) {
    xmod = -w
  } else if (ev.target.classList.contains('right')) {
    xmod = +w
  } else if (ev.target.classList.contains('up')) {
    ymod = -h
  } else if (ev.target.classList.contains('down')) {
    ymod = +h
  } else {
    return
  }
  const cur = Map.getCurrentMid()
  cur.x += xmod
  cur.y += ymod
  if (cur.x < 0) cur.x = w / 2
  if (cur.y < 0) cur.y = h / 2
  if (cur.x > Map.mapWidth) { cur.x = Map.mapWidth - w / 2 }
  if (cur.y > Map.mapHeight) { cur.y = Map.mapHeight - h / 2 }
  Map.center(cur.x, cur.y)
}
TWDS.minimap.arrowinit = function () {
  const v = TWDS.settings.minimap_add_navigation
  if (!v) {
    return
  }
  const old = TWDS.q1('.TWDS_minimap_navcontainer')
  if (old) { return } // just being careful
  const mmr = TWDS.q1('.minimap .tw2gui_window_content_pane')
  if (!mmr) return

  TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_minimap_navcontainer',
    children: [{
      nodeName: 'span',
      innerHTML: '&#x2190;',
      className: 'TWDS_minimap_nav left ArrowLeft'
    }, {
      nodeName: 'span',
      innerHTML: '&#x2191;',
      className: 'TWDS_minimap_nav up ArrowUp'
    }, {
      nodeName: 'span',
      innerHTML: '&#x2193;',
      className: 'TWDS_minimap_nav down ArrowDown'
    }, {
      nodeName: 'span',
      innerHTML: '&#x2192;',
      className: 'TWDS_minimap_nav right ArrowRight'
    }, {
      nodeName: 'input',
      type: 'checkbox',
      className: 'TWDS_minimap_opacity_checkbox',
      title: TWDS._('MINIMAP_OPACITY_CHECKBOX_TITLE', 'hacer que la interfaz de usuario sea mayoritariamente transparente')
    }],
    last: mmr
  })
}
TWDS.minimap.uiinit = function () {
  TWDS.minimap.arrowinit()
  const simplebutton = function (text, title, css, cb) {
    const label = $('<label />')
    const sel = $('<span>' + text + '</span>')
    sel.attr('title', title)
    sel.click(cb)
    sel.css(css)
    label.append(sel)
    return label
  }

  $('#TWDS_minimap_silvergold').remove()
  if (TWDS.settings.minimap_silvergold) {
    const container = $("<div id='TWDS_minimap_silvergold' />")
    $('#mmap_cbbox_jobs').before(container)
    let legend = ''
    legend += "<b class='TWDS_bonusjob noabs gold'></b>Gold bonus job.<br>"
    legend += "<b class='TWDS_bonusjob noabs silver'></b>Silver bonus job.<br>"
    legend += "<b class='TWDS_bonusjob noabs storagemissing'></b>Job drops products needed in the storage.<br>"
    legend += "<b class='TWDS_bonusjob noabs collection'></b>Job can drop item needed for a collection.<br>"
    legend += "<b class='TWDS_bonusjob noabs hl_always'></b>Job marked as always highlighted bonus job.<br>"
    legend += "<b class='TWDS_bonusjob noabs tracked'></b>Job tracked in the quest tracker.<br>"
    legend += "<b class='TWDS_bonusjob noabs searched'></b>The currently searched job.<br>"
    legend += 'Note: silver jobs have a white center, gold jobs a yellow one.'
    const q = $('<span>?</span>')
    q[0].title = legend
    container.append(q)

    container.append(simplebutton('#', 'show/hide coordinates', {
      'background-color': 'white'
    }, function () {
      const n = $('.display-tile-coords')
      if (n.length) {
        Map.hideCoords()
      } else {
        Map.showCoords()
      }
    }))

    container.append(simplebutton('x', '<div>clear the silver jobs</div>', {
      'background-color': 'silver'
    }, function () {
      if (window.confirm('clear the stored silver job data?')) {
        TWDS.minimap.deletefromcache(true, false)
        TWDS.minimap.savecache()
        TWDS.minimap.updateIfOpen()
      }
    }))
    container.append(simplebutton('x', 'clear the gold jobs', {
      'background-color': 'gold'
    }, function () {
      if (window.confirm('clear the stored gold job data?')) {
        TWDS.minimap.deletefromcache(false, true)
        TWDS.minimap.savecache()
        TWDS.minimap.updateIfOpen()
      }
    }))

    container.append(simplebutton('export', 'export the gold and silver jobs', {
      'background-color': 'white'
    }, function () {
      TWDS.minimap.export()
    }))

    container.append(simplebutton('import', 'import the gold and silver jobs', {
      'background-color': 'white'
    }, function () {
      TWDS.minimap.import()
    }))
  }
  $('#TWDS_minimap_worldmapmarketcontainer').remove()
  if (TWDS.settings.minimap_use_worldmapmarket) {
    let v = TWDS.settings.minimap_worldmapmarket_active
    if (v === 'undefined') v = 0
    const checked = (v ? 'checked' : '')
    const style = 'display:inline-block; width:4px; height:4px; margin:0 5px;' +
              'background-color: blue; ' +
              'border:1px solid black;'
    const str = "<div style='" + style + "'></div>"
    const e = $("<span id='TWDS_minimap_worldmapmarketcontainer' class='hasMousePopup' style='display:block'>" +
           "<input type='checkbox' value='1' " + checked + '>' +
       str +
       TWDS._('MINIMAP_MARKET_ITEMS_ON_WORLDMAP', 'Market items on world map') +
       '</span>')
    $('.mmap_others').append(e)
    $('#TWDS_minimap_worldmapmarketcontainer input').on('change', function (e) {
      TWDS.settings.minimap_worldmapmarket_active = this.checked ? 1 : 0
      TWDS.saveSettings()
      TWDS.minimap.updateIfOpen()
    })
  }
  $('.TWDS_minimap_taskjob_button').remove()
  if (TWDS.settings.minimap_use_taskjobdisplay) {
    const pa = TWDS.q1('.mmap_others')
    if (pa) {
      TWDS.createEle('div', {
        className: 'TWDS_minimap_taskjob_button',
        textContent: TWDS._('MINIMAP_TASKJOB_BUTTON', 'Show task job groups'),
        last: TWDS.q1('.mmap_others'),
        onclick: function (x) {
          TWDS.minimap.showtaskjobgroups()
        }
      })
    }
  }
  if (TWDS.settings.minimap_coordinput) {
    $('.tw2gui_jobsearch_string').on('keyup', function (e) {
      if (e.keyCode === 13) {
        const inp = e.target
        const rx = /^\s*(\d+)\s*[-,x]\s*(\d+)\s*$/
        let found = inp.value.match(rx)
        if (found !== null) {
          const x = found[1]
          const y = found[2]
          window.Map.center(x, y)
          inp.value = ''
        }
        const rx2 = /^\s*(\d+)\s*$/
        found = inp.value.match(rx2)
        if (found !== null) {
          let county = parseInt(found[1])
          if (county > 0 && county <= 15) {
            county--
            let x = county * 6635 + 3317
            let y = 5088
            if (county > 7) {
              x = x - 7 * 6635
              y += 10176
            }
            if (county === 14) { // center
              x = 3 * county * 6635 + 3317
              y = 10176
            }
            window.Map.center(x, y)
            inp.value = ''
          }
        }
        const rx3 = /^\s*(ghost|g|indian|i|center|c|home|h)\s*$/i
        found = inp.value.toLowerCase().match(rx3)
        if (found !== null) {
          if (found[1] === 'ghost' || found[1] === 'g') { window.Map.center(1920, 2176) }
          if (found[1] === 'indian' || found[1] === 'i') { window.Map.center(28060, 16768) }
          if (found[1] === 'center' || found[1] === 'c') { window.Map.center(3.5 * 6635, 10176) }
          if (found[1] === 'home' || found[1] === 'h') { window.Map.center(Character.homeTown.x, Character.homeTown.y) }
          inp.value = ''
          $('.tw2gui_jobsearchbar_results').hide()
        }
      }
    })
  }
}
TWDS.minimap.keyup = function (ev) {
  if (!document.body.classList.contains('TWDS_searchmode')) { return }
  const k = ev.key
  const x = TWDS.q1('.TWDS_minimap_nav.' + k)
  if (x) {
    const event = new window.MouseEvent('click', {
      view: window,
      bubbles: true,
      cancelable: true
    })
    x.dispatchEvent(event)
  }
}
// middle click on a bonus job adds a mark (outline dotted red) or deletes it
TWDS.minimap.mousedownhandlerReal = function (ev) {
  const workaround = (ev.which !== 0)
  const x = ev.target.dataset.posx
  const y = ev.target.dataset.posy
  const poskey = x + '-' + y
  if (ev.which !== 2) return
  const oneposdata = TWDS.minimap.cache[poskey]
  for (const onejobkey in oneposdata) {
    const onejobdata = oneposdata[onejobkey]
    onejobdata.marked = !onejobdata.marked
    oneposdata[onejobkey] = onejobdata
    if (workaround) { break }
  }
  TWDS.minimap.savecache()
  TWDS.minimap.updateIfOpen()
}
TWDS.minimap.mousedownhandler = function (ev) {
  TWDS.minimap.mousedownhandlerReal(ev)
}

TWDS.registerStartFunc(function () {
  TWDS.minimap.init()
  TWDS.minimap.loadcache()

  // do not show silvergold when TWDB silvergold is active.
  let defaultval = true
  if ('TWDB' in window) {
    if (!window.TWDB.Settings.get('showbonusjobs', true)) {
      defaultval = false
    }
  }

  TWDS.registerSetting('bool', 'minimap_silvergold',
    TWDS._('MINIMAP_SETTING_SILVERGOLD', 'Mostrar trabajos de plata/oro conocidos en el minimapa.'),
    defaultval, function (v) {
      TWDS.minimap.uiinit()
    },
    'Minimapa'
  )
  TWDS.registerSetting('bool', 'minimap_silvergold_trackerhelper',
    TWDS._('MINIMAP_SETTING_SILVERGOLD_TRACKERHELPER',
      'Resaltar los trabajos con bonus rastreados en las búsquedas.'), false, function (v) {
      TWDS.minimap.uiinit(v)
    },
    'Minimapa'
  )
  TWDS.registerSetting('bool', 'minimap_silvergold_collecthelper',
    TWDS._('MINIMAP_SETTING_SILVERGOLD_COLLECTHELPER',
      'Resaltar los trabajos con bonus que proporcionan coleccionables que nos faltan.'), false, function (v) {
      TWDS.minimap.uiinit(v)
    },
    'Minimapa'
  )
  TWDS.registerSetting('bool', 'minimap_silvergold_storagehelper',
    TWDS._('MINIMAP_SETTING_SILVERGOLD_STORAGEHELPER',
      'Resaltar los trabajos con bonus para los artículos que no tenemos en la pestaña de almacenamiento.'), false, function (v) {
      TWDS.minimap.uiinit(v)
    },
    'Minimapa'
  )
  TWDS.registerSetting('bool', 'minimap_coordinput',
    TWDS._('MINIMAP_SETTING_COORDINPUT', 'Hacer mal uso del campo de entrada del trabajo con la entrada de coordenadas.'),
    defaultval, function (v) {
      TWDS.minimap.uiinit()
    },
    'Minimapa'
  )
  TWDS.registerSetting('bool', 'minimap_use_worldmapmarket',
    TWDS._('MINIMAP_SETTING_WORLDMAPMARKET',
      'Agregar una casilla de verificación que permita mostrar los artículos del mercado en el minimapa mundial.'), true, function (v) {
      TWDS.minimap.uiinit()
    },
    'Minimapa'
  )
  TWDS.registerSetting('bool', 'minimap_use_taskjobdisplay',
    TWDS._('MINIMAP_SETTING_TASKJOBDISPLAY',
      'Agregar un botón para mostrar los grupos de trabajos activos en el mapa del condado.'), true, function (v) {
      TWDS.minimap.uiinit()
    },
    'Minimapa'
  )
  TWDS.registerSetting('bool', 'minimap_add_navigation',
    TWDS._('MINIMAP_SETTING_NAVIGATION',
      'Agregar flechas para navegar por el mapa.'), false, function (v) {
      TWDS.minimap.arrowinit(v)
    },
    'Minimapa'
  )
  TWDS.delegate(document.body, 'click', '.TWDS_minimap_nav', TWDS.minimap.arrowclickhandler)
  TWDS.delegate(document.body, 'change', '.TWDS_minimap_opacity_checkbox', TWDS.minimap.opacityhandler)
  EventHandler.listen('window_closed_minimap', function () {
    document.body.classList.remove('TWDS_searchmode')
  })
  document.addEventListener('keyup', function (ev) {
    TWDS.minimap.keyup(ev)
  })
  TWDS.delegate(document.body, 'change', '.minimap .tw2gui_jobsearch_string',
    function () { TWDS.minimap.updateIfOpen() }
  )
  TWDS.delegate(document.body, 'mousedown', '#minimap_worldmap .TWDS_bonusjob', TWDS.minimap.mousedownhandler)
})

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab
//
$(document).on('click', '.TWDS_wearset', function () {
  const key = this.dataset.setkey
  const tmp = window.localStorage.getItem(key)
  if (tmp) {
    const o = JSON.parse(tmp)
    if (Premium.hasBonus('automation')) {
      Wear.open()
      for (const i in o.item_ids) {
        const ii = o.item_ids[i]
        const b = Bag.getItemByItemId(Number(ii))
        if (b) {
          Wear.carry(b)
        }
      }
    } else {
      if (!wman.getById(Inventory.uid)) {
        Inventory.open()
      }
      Wear.open()
      const items = Bag.getItemsByItemIds(o.item_ids)
      Inventory.showSearchResult(items)
    }
    return
  }
  Ajax.remoteCallMode('inventory', 'show_equip', {}, function (data) {
    const eql = data.data
    for (const eq of Object.values(eql)) {
      if (eq.name === key) {
        window.EquipManager.switchEquip(eq.equip_manager_id)
      }
    }
  })
})
TWDS.jobwindow = {}

TWDS.jobwindow.initView = function () {
  this._TWDS_backup_initView()
  return TWDS.jobwindow.initView2.call(this)
} // for TWDS.reload()
TWDS.jobwindow.initView2 = function () {
  const d = this.window.divMain
  if (!d) return // often exists even though the window is closed
  const innertitle = TWDS.q1('.tw2gui_inner_window_title', d)
  if (!innertitle) return // but this isn't there then.
  const old = TWDS.q1('.TWDS_jobwindow_setbuttons', d)
  if (old) {
    old.remove()
  }
  let haveone = false
  for (let i = 0; i < 10; i++) {
    const idx = 'jobwindow_set' + i
    if (TWDS.settings[idx] > '') {
      haveone = true
    }
  }
  if (haveone) {
    const p = TWDS.q1('.job_premium_button', d)
    if (p) {
      p.style.display = 'none'
      const ct = TWDS.createEle({
        nodeName: 'div',
        className: 'TWDS_jobwindow_setbuttons'
      })
      p.parentNode.insertBefore(ct, p)
      for (let i = 0; i < 10; i++) {
        const idx = 'jobwindow_set' + i
        if (TWDS.settings[idx] > '') {
          const b = TWDS.createElement({
            nodeName: 'button',
            className: 'TWDS_button TWDS_wearset',
            textContent: TWDS.settings[idx],
            dataset: {
              setkey: TWDS.settings[idx]
            },
            title: 'Usar este conjunto'
          })
          ct.appendChild(b)
        }
      }
    }
  } else {
    const p = TWDS.q1('.job_premium_button', d)
    if (p) {
      p.style.display = 'block'
    }
  }

  // luck %
  if (TWDS.settings.jobwindow_show_luckp) {
    const hack = function (what, basis) {
      const b = TWDS.q1('.job_durationbar_' + what, d)
      if (!b) return // too few labor points.
      const e = TWDS.createEle({
        nodeName: 'div',
        className: 'TWDS_jw_luck',
        textContent: (100 * basis[what].p_luck).toFixed(0) + '%'
      })
      b.appendChild(e)
    }
    hack('short', this.job.basis)
    hack('middle', this.job.basis)
    hack('long', this.job.basis)
  }

  if (TWDS.settings.jobwindow_show_collectibles) {
    const ii = TWDS.collections.collectible_jobs[this.jobId]
    if (ii) {
      const it = ItemManager.get(ii)
      let ins = new tw2widget.InventoryItem(it)
      const out = TWDS.q1('.tw2gui_inner_window_title', d)
      ins = ins.getMainDiv()[0]
      ins.classList.add('TWDS_jobwindow_collectible')
      out.appendChild(ins)
    }
  }
  // annotation
  if (TWDS.settings.jobwindow_offer_note) {
    const out = TWDS.q1('.tw2gui_window_content_pane', d)
    const key = 'TWDS_jw_freetext_' + this.jobId
    const str = window.localStorage[key] || ''
    let classadd = ''
    if (str === '') classadd = ' emptyeditable'
    TWDS.createEle({
      nodeName: 'div',
      className: 'TWDS_jw_editable' + classadd,
      contentEditable: true,
      textContent: str,
      last: out,
      oninput: function (ev) {
        const text = this.innerHTML.trim()
        window.localStorage[key] = text
        ev.preventDefault()
        if (text === '') {
          this.classList.add('emptyeditable')
        } else {
          this.classList.remove('emptyeditable')
        }
        return true
      }
    })
  }

  const longdurationbar = TWDS.q1('.job_durationbar_long', d)
  if (TWDS.settings.jobwindow_smart_start && longdurationbar) { // we might have too few jobpoints
    const o = TWDS.q('.TWDS_smartstart', d)
    if (o) {
      for (let i = 0; i < o.length; i++) { o[i].remove() }
    }
    const c = function (en, pa, that) {
      let dur = 15
      if (en === 5) {
        dur = that.job.basis.middle.duration
      } else if (en === 12) {
        dur = that.job.basis.long.duration
      } else {
        dur = that.job.basis.short.duration
      }
      return TWDS.createEle({
        nodeName: 'button',
        title: TWDS._('JOBWINDOW_SSB12_TITLE',
          'Iniciar tantos trabajos como sea posible con la misma clase de motivación.'),
        textContent: 'dummy',
        className: 'TWDS_smartstart',
        dataset: {
          x: that.x,
          y: that.y,
          jobid: that.jobId,
          base: en,
          duration: dur
        },
        beforeend: pa,
        onclick: function (e) {
          return TWDS.jobwindow.smartstart(e)
        }
      })
    }
    // i tried west.gui.button, but the onclick handler doesn't get the event, and so i can't prevent
    // a click on the parent column, which has a click handler.
    TWDS.jobwindow.ssb1 = c(1, TWDS.q1('.job_durationbar_short', d), this)
    TWDS.jobwindow.ssb2 = c(5, TWDS.q1('.job_durationbar_middle', d), this)
    TWDS.jobwindow.ssb3 = c(12, TWDS.q1('.job_durationbar_long', d), this)
    TWDS.jobwindow.ssb3.title = TWDS._('JOBWINDOW_SSB12_TITLE',
      'Iniciar tantos trabajos como sea posible con la misma clase de motivación.')
  }
  if (TWDS.settings.jobwindow_quickequipment) {
    const gen = d.querySelector('.job_bestwearbutton')
    if (gen) {
      TWDS.createEle({
        nodeName: 'div.TWDS_quickequipment_shirt.linklike',
        onclick: function (e) { TWDS.quickequipment.handlemainclick(e); console.log('false'); e.stopPropagation(); return false },
        children: [
          new west.gui.Icon('shirt').divMain[0]
        ],
        last: gen
      })
    }
  }
  if (TWDS.settings.jobwindow_show_jobpoints) {
    const progressthing = d.querySelector('.job_progress_jobstars')
    const m = TWDS.createElement({
      nodeName: 'span',
      className: 'TWDS_jobpoints_display',
      title: 'Muestra los puntos de trabajo.'
    })
    m.style.display = 'block'
    m.style.position = 'absolute'
    m.style.width = '5em'
    m.style.height = '16px'
    m.style.textAlign = 'center'
    m.style.bottom = '7px'
    m.style.backgroundColor = '#deb88780'
    m.style.border = '1px solid #deb887'
    m.style.visibility = 'visible'
    m.style.left = 'calc( ( 285px - 5em ) / 2 )'
    if (progressthing) { progressthing.appendChild(m) }
  }
  if (TWDS.settings.jobwindow_show_maxdmg) {
    const id = this.jobId
    const x = TWDS.jobData['job_' + id]
    if (d && x && x.job_maxdmg) {
      const mh = Character.maxHealth
      const h = Character.health
      const m = TWDS.createElement({
        nodeName: 'meter',
        min: 0,
        optimum: 0,
        low: h / mh * 100 / 4,
        high: h / mh * 100,
        max: 100,
        value: x.job_maxdmg,
        className: 'TWDS_maxdmg_meter'
      })
      m.style.display = 'block'
      m.style.position = 'absolute'
      m.style.width = '100px'
      m.style.transform = 'translate(-75px, 42px) rotate(270deg)'
      m.title = 'an injury costs up to ' + x.job_maxdmg + '% of your maximum health.'
      const dan = d.querySelector('.cprog_danger')
      if (dan) {
        dan.appendChild(m)
      }
      const m2 = TWDS.createElement({
        nodeName: 'meter',
        min: 0,
        optimum: 0,
        max: Character.health / Character.maxHealth * 100,
        className: 'TWDS_9jobdanger_meter',
        title: 'Nivel de lesión esperado en relación con su salud actual para 9 trabajos.'
      })
      m2.style.display = 'block'
      m2.style.width = '100px'
      m2.style.position = 'absolute'
      m2.style.transform = 'translate(-65px, 42px) rotate(270deg)'
      if (dan) {
        dan.appendChild(m2)
      }
    }
  }
  if (TWDS.settings.jobwindow_show_motivation) {
    const d = this.window.divMain
    const m = TWDS.createElement({
      nodeName: 'meter',
      min: 0,
      max: 25,
      value: this.jobmotivation,
      className: 'TWDS_jobmotivation_meter'
    })
    m.style.display = 'block'
    m.style.width = '100px'
    m.style.transform = 'translate(65px, 42px) rotate(270deg)'
    const par = d.querySelector('.tprog_jobmotivation')
    if (par) {
      par.appendChild(m)
    }
    const s = TWDS.createElement({
      nodeName: 'span',
      className: 'TWDS_jobmotivation_info'
    })
    s.style.display = 'inline-block'
    s.style.position = 'absolute'
    s.style.width = '24px'
    s.style.height = '16px'
    s.style.top = '45px'
    s.style.left = '41px'
    s.style.backgroundColor = 'wheat'
    s.style.fontSize = '125%'
    s.style.borderRadius = '4px'
    s.style.border = '1px solid gold'
    s.style.textAlign = 'center'
    if (par) {
      par.appendChild(s)
    }
  }
  TWDS.jobwindow.updateMotivationMeter(this, false)
}
TWDS.jobwindow.updateMotivationMeter = function (o, overcount) {
  const mot = o.jobmotivation
  const jpdisplay = $('.TWDS_jobpoints_display', o.DOM)
  const dangermeter = $('.TWDS_maxdmg_meter', o.DOM)
  let jp = 0
  let malus = 0
  if ('job_points' in o) {
    jp = o.job_points
    malus = o.job.malus
  } else if ('job' in o && o.job && 'workpoints' in o.job) {
    jp = o.job.jobpoints - o.job.workpoints
    malus = o.job.jobObj.malus
  }
  if (jpdisplay.length) {
    jpdisplay[0].textContent = jp
    jpdisplay[0].title = 'With the current equipment you have ' + jp + ' job points. The work has a difficulty of ' + malus
  }
  if (dangermeter.length) {
    const mh = Character.maxHealth
    const h = Character.health
    dangermeter[0].low = h / mh * 100 / 4
    dangermeter[0].high = h / mh * 100
  }
  const combined = $('.TWDS_9jobdanger_meter', o.DOM)
  if (combined.length) {
    const id = o.jobId
    const x = TWDS.jobData['job_' + id]
    const danger = x.job_danger
    const dang = TWDS.TWDBcalcDanger(jp + malus - 1, malus - 1, danger, mot, 1)
    // assume an injury in average is 25% of maxdmg
    let p = x.job_maxdmg * 9 / 4.0 * dang / 100
    combined[0].value = p
    let max = x.job_maxdmg * 9
    p = Math.round(p)
    max = Math.round(max)
    const hx = Math.round(p / 100 * Character.maxHealth)
    combined[0].title = 'For 9 jobs expect a damage of ' + p +
        '% (' + hx + ') of your maximum HP. If murphy hates you, you might lose ' + max + '%.'
  }
  const info = $('.TWDS_jobmotivation_info', o.DOM)
  if (info.length) { info[0].textContent = mot }
  const met = $('.TWDS_jobmotivation_meter', o.DOM)

  if (met.length) {
    let tonextborder = mot % 25
    tonextborder -= 1
    if (tonextborder < 0) tonextborder = 25
    met.value = mot
    // that oh so good designed <meter> element doesn't allow me to change the colors
    // without a lot of browser dependend overhead (meter::--webkit-meter-...).
    //
    // Logic: 0..25 are shown.
    // 76 is shown as 0, 100 as 25
    // 51 is shown as 0, 75 as 25
    // 26 is shown as 0, 50 as 25
    //  1 is shown as 0, 25 as 25
    //  0..
    met[0].value = tonextborder
    met[0].min = 0
    met[0].max = 25
  }
  if (TWDS.jobwindow.ssb3) {
    const hasa = Premium.hasBonus('automation')
    let maxpossible = 4
    if (hasa) { maxpossible = 9 }
    // now the smart buttons.
    let motwithq = mot
    for (let i = 0; i < TaskQueue.queue.length; i++) {
      if (TaskQueue.queue[i].type !== 'job') { // not walking or riding or duelling or ff
        continue
      }
      const qjid = TaskQueue.queue[i].data.job.id
      const qdur = TaskQueue.queue[i].data.duration
      if (qjid === o.jobId) {
        if (qdur === 3600) {
          motwithq -= 12
        } else if (qdur === 600) {
          motwithq -= 5
        } else {
          motwithq--
        }
      }
    }
    if (motwithq < 0) motwithq = 0 // mot may be 0, with jobs in the queue
    if (overcount && motwithq !== mot) {
      motwithq++
    }
    let tonextborder = motwithq % 25
    if (tonextborder === 0) { tonextborder = 25 }
    let t = Math.min(maxpossible, tonextborder, Character.energy)
    if (Math.floor((motwithq - 1) / 25) !== Math.floor((mot - 1) / 25)) {
      // we will leave the current mot. class with the things in the queue
      t = 0
    }
    if (mot === 0) t = 9 // special case that.
    TWDS.jobwindow.ssb1.textContent = t + 'x'
    TWDS.jobwindow.ssb1.dataset.smartstart = t

    t = Math.min(maxpossible, Math.ceil(tonextborder / 5), Math.floor(Character.energy / 5))
    if (mot === 0) t = 9 // special case that.
    TWDS.jobwindow.ssb2.textContent = t + 'x'
    TWDS.jobwindow.ssb2.dataset.smartstart = t

    t = Math.min(maxpossible, Math.ceil(tonextborder / 12), Math.floor(Character.energy / 12))
    if (mot === 0) t = 9 // special case that.
    TWDS.jobwindow.ssb3.textContent = t + 'x'
    TWDS.jobwindow.ssb3.dataset.smartstart = t
  }
}
TWDS.jobwindow.smartstart = function (e, y) {
  e.preventDefault()
  e.stopPropagation()
  const ds = e.target.dataset
  let amount = ds.smartstart
  const dur = parseInt(ds.duration)
  const tasks = []
  while (amount--) {
    tasks.push(new window.TaskJob(ds.jobid, ds.x, ds.y, dur))
  }
  TaskQueue.add(tasks)
  return false
}
TWDS.jobwindow.updateMotivation = function (jobdata) {
  JobWindow.prototype._TWDS_backup_updateMotivation.apply(this, arguments)
  let overcount = 0
  if (jobdata && jobdata.job.id === this.jobId) {
    overcount = 1
  }
  TWDS.jobwindow.updateMotivationMeter(this, overcount)
}
TWDS.registerSetting('bool', 'jobwindow_show_maxdmg',
  'Mostrar el daño máximo en la ventana de trabajo.', true, null, 'Ventana Trabajo')
TWDS.registerSetting('bool', 'jobwindow_show_motivation',
  'Mostrar la motivación actual exacta en la ventana de trabajo.', true, null, 'Ventana Trabajo')
TWDS.registerSetting('bool', 'jobwindow_show_jobpoints',
  'Mostrar los puntos de trabajo en la ventana de trabajo.', true, null, 'Ventana Trabajo')
TWDS.registerSetting('bool', 'jobwindow_smart_start',
  'Agregar botones para iniciar múltiples trabajos.', true, null, 'Ventana Trabajo')
TWDS.registerSetting('bool', 'jobwindow_show_luckp',
  'Mostrar la probabilidad de conseguir un hallazgo fortuito.', true, null, 'Ventana Trabajo')
TWDS.registerSetting('bool', 'jobwindow_offer_note',
  TWDS._('JOBWINDOW_SETTING_NOTEPAD', 'Implementar un bloc de notas en la ventana de trabajo.'), false, null, 'Ventana Trabajo')

TWDS.registerStartFunc(function () {
  TWDS.registerSetting('info', 'AAAAA',
    'Los nombres del conjunto para ofrecer en lugar del botón de mayores ingresos. Esto sólo funciona si tiene el premium de más sueldo y si los nombres son los internos del juego o los conjuntos de la ' + TWDS.scriptname + '.',
    '', null, 'Ventana Trabajo', 'Setnames')

  for (let i = 0; i < 10; i++) {
    TWDS.registerSetting('string', 'jobwindow_set' + i, 'Conjunto #' + (i + 1), '', null, 'Ventana Trabajo', 'Setnames')
  }
  JobWindow.prototype._TWDS_backup_initView = JobWindow.prototype.initView
  JobWindow.prototype.initView = TWDS.jobwindow.initView
  JobWindow.prototype._TWDS_backup_updateMotivation = JobWindow.prototype.updateMotivation
  JobWindow.prototype.updateMotivation = TWDS.jobwindow.updateMotivation
  TWDS.registerSetting('bool', 'jobwindow_show_collectibles',
    TWDS._('JOBWINDOW_SHOW_COLLECTIBLES', 'Mostrar los artículos coleccionables que salen en el trabajo.'), true, null, 'Ventana Trabajo')

  // - this is done to update the smartstart counter.
  // - JobWindow.updateMotivation, the original function, is not free of side effects, it will decrease the
  //   shown motivation by 1/5/12, depending on the duration, so we set duration to 0.
  EventHandler.listen('taskqueue-task-canceling',
    function (data) {
      if (data.job) {
        data.data.duration = 0
        EventHandler.signal('jobmotivation_change', data.data)
      }
    })
  EventHandler.listen('taskqueue-task-adding taskqueue-updated taskqueue-updated',
    function () { EventHandler.signal('jobmotivation_change') })
  TWDS.registerSetting('bool', 'jobwindow_quickequipment',
    TWDS._('JOBWINDOW_SETTING_QUICKEQUIPMENT', 'Agregar un cambio rápido de equipo en la ventana de trabajo.'), false, null, 'Ventana Trabajo')
})
if (JobWindow.prototype._TWDS_backup_initView) {
  // helper for the reload
  JobWindow.prototype.initView = TWDS.jobwindow.initView
  JobWindow.prototype.updateMotivation = TWDS.jobwindow.updateMotivation
}

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.quest = {}
// can't reliably use Quest.getMinimaplink, because TW-Calc uses that, and doesn't call the original/backup function.
TWDS.quest.renderRequirement = function (req, cls) {
  const li = Quest.prototype._TWDS_backup_renderRequirement.apply(this, arguments)
  const jsinfo = req.jsInfo

  if (TWDS.settings.quest_add_util_buttons && jsinfo) {
    li.addClass('TWDS_questentry_functions')
    const cfg = {
      craft: ['inventory_changed', 'wear_changed'],
      bid: ['inventory_changed', 'wear_changed'],
      shop: ['inventory_changed', 'wear_changed'],
      wear: ['wear_changed'],
      count: ['inventory_changed', 'wear_changed']
    }
    for (const [what, types] of Object.entries(cfg)) {
      if (types.includes(jsinfo.type)) {
        if (what === 'craft') {
          const x = TWDS.itemAnyCraftButton(jsinfo.id)
          if (x) {
            li.append(x)
            li.addClass('with_craftlink')
          }
        }
        if (what === 'bid') {
          const x = TWDS.itemBidButton(jsinfo.id)
          if (x) {
            li.append(x)
            li.addClass('with_bidbutton')
          }
        }
        if (what === 'shop') {
          const x = TWDS.shopsearch.button(jsinfo.id)
          if (x) {
            li.append(x)
            li.addClass('with_shopsearchbutton')
          }
        }
        if (what === 'wear') {
          const bagitem = Bag.getItemByItemId(jsinfo.id)
          if (bagitem) {
            const x = TWDS.itemWearButton(jsinfo.id)
            if (x) {
              li.append(x)
              li.addClass('with_wearbutton')
            }
          }
        }
        if (what === 'count') {
          const bagitem = Bag.getItemByItemId(jsinfo.id)
          if (bagitem && TWDS.settings.quest_show_itemcount) {
            let str = bagitem.count
            const si = TWDS.storage.iteminfo(jsinfo.id)
            if (si[0]) { // want <> 0
              str += '/' + si[0]
            }
            const ele = TWDS.createEle({
              nodeName: 'span',
              className: 'TWDS_quest_itemcount',
              textContent: '[' + str + ']'
            })
            li.append(ele)
          }
        }
      }
    }

    /*
    if (jsinfo.type === 'inventory_changed') {
    } else if (jsinfo.type === 'wear_changed') {

    } else if (jsinfo.type === 'task-finish-job') {
      const id = jsinfo.id
      const x = TWDS.jobOpenButton2(id)
      if (x) { li.appendChild(x) }
      const jobdata = JobList.getJobById(id)
      let ql=MinimapWindow.getQuicklink(jobdata.name, 'task-finish-job')
      if (ql>"") {
        let y=TWDS.createEle({
          nodeName:"span",
          innerHTML: ql
        });
        li.append(y.firstChild);
      }
    } else if (jsinfo.type === 'task-finish-walk') {
      let x=TWDS.employerOpenButton(jsinfo.value);
      if (x) { li.append(x) }
    } else {
      console.log('unhandled', jsinfo, jsinfo.type);
    }
  */
  }
  return li
}

TWDS.quest.getQuestTrackerEl = function () {
  const x = Quest.prototype._TWDS_backup_getQuestTrackerEl.apply(this)
  if (TWDS.settings.questtracker_show_booklinks) {
    const remover = TWDS.q1('.quest-list.remove', x[0])
    if (remover) {
      TWDS.createEle({
        nodeName: 'span',
        className: 'TWDS-quest-list-to-book',
        innerHTML: '&#128366;',
        before: remover,
        title: TWDS._('QUESTS_OPEN_BOOK', 'Abrir en el libro búsquedas'),
        dataset: {
          questid: this.id,
          questgroup: this.group
        },
        onclick: function (ev) {
          const that = this
          EventHandler.listen('questlog_loaded', function () {
            window.QuestWindow.switchToQuest(that.dataset.questid)
            return EventHandler.ONE_TIME_EVENT
          }, this)
          window.QuestWindow.open()
        }
      })
    }
  }
  return x
}
TWDS.quest.cancelQuest = function (id) {
  (new west.gui.Dialog(
    TWDS._('QUEST_CANCEL_QUESTION_TITLE', '¿Cancelar búsqueda?'),
    TWDS._('QUEST_CANCEL_QUESTION',
      '¿Está seguro de que quiere cancelar esta búsqueda?'))
    .setIcon(west.gui.Dialog.SYS_QUESTION).setModal(true, false, {
      bg: Game.cdnURL + '/images/curtain_bg.png',
      opacity: 0.4
    }).addButton(
      TWDS._('YES', 'yes'), function () {
        window.QuestWindow._TWDS_backup_cancelQuest(id)
      }).addButton(TWDS._('NO', 'no'), function () {}).show()
  )
}
TWDS.quest.buildquestlog = function (emp) {
  QuestEmployerView.TWDS_backup_buildQuestLog.apply(this, arguments)
  for (let i = 0; i < emp.open.length; i++) {
    const q = emp.open[i]
    const req = q.requirements
    let allsolved = true
    for (let j = 0; j < req.length; j++) {
      if (req[j].solved !== true) { allsolved = false }
    }

    if (q.finishable || allsolved) {
      if (TWDS.settings.quest_color_finishable) {
        const link = TWDS.q1('#open_quest_employerlink_' + q.id)
        if (!link) continue
        link.classList.add('finishable')
      }
    }
  }
}

TWDS.registerSetting('bool', 'quest_cancel_question',
  TWDS._('QUESTS_SETTING_CANCEL', 'Agregar pregunta de seguridad antes de cancelar búsqueda.'),
  true, null, 'Búsquedas', null, 1)
TWDS.registerSetting('bool', 'quest_show_itemcount',
  TWDS._('QUESTS_SETTING_SHOW_ITEMCOUNT', 'Agregar cantidad artículos en su inventario en ventana de búsqueda.'),
  false, null, 'Búsquedas', null, 2)
TWDS.registerSetting('bool', 'quest_add_util_buttons',
  TWDS._('QUESTS_SETTING_ADD_UTIL_BUTTONS', 'Agregar funciones útiles en la ventana de búsquedas (artesanía, mercado, visualización de números).'),
  false, null, 'Búsquedas', null, 3)
TWDS.registerSetting('bool', 'questtracker_show_itemcount',
  TWDS._('QUESTS_SETTING_SHOW_ITEMCOUNT_TRACKER', 'Mostrar cantidad artículos en su inventario en rastreador de búsquedas.'),
  false, null, 'Búsquedas', null, 4)
TWDS.registerSetting('bool', 'questtracker_show_booklinks',
  TWDS._('QUESTS_SETTING_ADD_BOOK_LINK', 'Agregar enlaces del libro búsquedas en rastreador de búsquedas.'),
  true, null, 'Búsquedas', null, 5)
TWDS.registerSetting('bool', 'quest_color_finishable',
  TWDS._('QUESTS_SETTING_COLOR_FINISHABLE', 'Cambiar color de las búsquedas que pueden completarse.'),
  true, null, 'Búsquedas', null, 6)

TWDS.quest.startfunc = function () {
  Quest.prototype._TWDS_backup_getQuestTrackerEl = Quest.prototype._TWDS_backup_getQuestTrackerEl ||
    Quest.prototype.getQuestTrackerEl
  Quest.prototype.getQuestTrackerEl = TWDS.quest.getQuestTrackerEl

  Quest.prototype._TWDS_backup_renderRequirement = Quest.prototype._TWDS_backup_renderRequirement ||
    Quest.prototype.renderRequirement
  Quest.prototype.renderRequirement = TWDS.quest.renderRequirement

  QuestWindow._TWDS_backup_cancelQuest = QuestWindow._TWDS_backup_cancelQuest ||
    QuestWindow.cancelQuest
  QuestWindow.cancelQuest = TWDS.quest.cancelQuest

  QuestEmployerView.TWDS_backup_buildQuestLog = QuestEmployerView.TWDS_backup_buildQuestLog ||
    QuestEmployerView.buildQuestLog
  QuestEmployerView.buildQuestLog = TWDS.quest.buildquestlog

  TWDS.delegate(document.body, 'click', '.quest_requirement.shorten', function () {
    this.classList.remove('shorten')
  })
}
TWDS.registerStartFunc(TWDS.quest.startfunc)

// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.wuw = {}
TWDS.wuw.initWUWDisplay = function (container) {
  const intro = document.createElement('p')
  intro.textContent = TWDS._('WUW_INTRO',
    'Esta página muestra qué elementos se utilizan para qué trabajos con los mejores puntos de trabajo posibles.')
  container.appendChild(intro)

  const label = document.createElement('label')
  label.title = 'El modo elegante muestra imágenes, en caso contrario se usa texto puro.'
  const checkbox = document.createElement('input')
  label.appendChild(checkbox)
  checkbox.type = 'checkbox'
  checkbox.id = 'TWDS_WUW_fancycb'
  const labeltext = document.createElement('span')
  label.appendChild(labeltext)
  labeltext.textContent = 'Modo elegante'
  container.appendChild(label)

  const ls = window.localStorage.TWDS_itemusage
  if (typeof ls === 'undefined') {
    const p = document.createElement('p')
    p.textContent = 'No hay datos en el caché. Es posible que desee actualizar los datos en la pestaña de configuración.'
    container.appendChild(p)
    return
  }

  const tab = document.createElement('table')
  tab.id = 'TWDS_wuw_table'
  container.appendChild(tab)

  const headline = document.createElement('tr')
  tab.appendChild(headline)
  let th = document.createElement('th')
  th.textContent = 'Equipo'
  headline.appendChild(th)
  th = document.createElement('th')
  th.textContent = 'Conjuntos y Trabajos'
  headline.appendChild(th)

  const data = JSON.parse(ls)
  for (const [id, one] of Object.entries(data)) {
    const count = one.ds.length + one.eq.length + one.job.length + one.dyn.length
    if (count === 0) { continue }
    const item = ItemManager.get(id)
    if (!item) { continue }

    const tr = document.createElement('tr')
    tab.appendChild(tr)

    let td = document.createElement('td')
    let h = "<span class='TWDS_wuw_item' " +
         "style='font-weight:bold; display:inline-block; text-align:left;'" +
         ' data-itemid=' + id +
         ' data-name=' + item.name +
         '>' + item.name + '</span>'
    if (count > 4) {
      h += "<br style='clear:both'>"
      let flag = 0
      if (one.job.length) {
        h += one.job.length + ' jobs'
        flag = 1
      }
      if (one.eq.length) {
        if (flag) { h += ', ' }
        h += one.eq.length + ' tw equipment sets'
        flag = 1
      }
      if (one.ds.length) {
        if (flag) { h += ', ' }
        h += one.ds.length + ' ' + TWDS.scriptname + ' sets'
        flag = 1
      }
      if (one.dyn.length) {
        if (flag) { h += ', ' }
        h += one.dyn.length + ' ' + TWDS.scriptname + ' dynamic sets'
        flag = 1
      }
      td.innerHTML = h
    }
    td.innerHTML = h
    tr.appendChild(td)

    td = document.createElement('td')
    tr.appendChild(td)
    let counteq = 0

    if (one.job.length) {
      for (const jid of one.job) {
        if (counteq > 0) {
          const comma = document.createElement('span')
          comma.textContent = ', '
          td.appendChild(comma)
        }
        const jd = JobList.getJobById(jid)
        const span = document.createElement('span')
        if (!jd) {
          span.textContent = jid
        } else {
          span.className = 'TWDS_wuw_job'
          span.dataset.jid = jid
          span.dataset.name = jd.name
          span.textContent = jd.name
        }
        td.appendChild(span)
        counteq++
      }
    }
    if (one.eq.length) {
      for (const eq of one.eq) {
        // some name or number (that last is an old duelstat bug)
        if (counteq > 0) {
          const comma = document.createElement('span')
          comma.textContent = ', '
          td.appendChild(comma)
        }
        const span = document.createElement('span')
        span.textContent = eq
        span.title = 'tw equipment set'
        td.appendChild(span)
        counteq++
      }
    }
    if (one.ds.length) {
      for (const ds of one.ds) {
        // some name or hash
        if (counteq > 0) {
          const comma = document.createElement('span')
          comma.textContent = ', '
          td.appendChild(comma)
        }
        const span = document.createElement('span')
        span.textContent = ds
        span.title = TWDS.scriptname + ' equipment set'
        td.appendChild(span)
        counteq++
      }
    }
    if (one.dyn.length) {
      for (const dyn of one.dyn) {
        // some name
        if (counteq > 0) {
          const comma = document.createElement('span')
          comma.textContent = ', '
          td.appendChild(comma)
        }
        const span = document.createElement('span')
        span.textContent = dyn
        span.title = TWDS.scriptname + ' dynamic equipment set'
        td.appendChild(span)
        counteq++
      }
    }
  }
  $(checkbox).on('change', function () {
    const checked = this.checked
    $('#TWDS_wuw_table .TWDS_wuw_job').each(function () {
      if (checked) {
        const jid = this.dataset.jid
        const jd = JobList.getJobById(jid)
        const html = '<img class="jobimg" title="' + this.dataset.name + '" src="' + Game.cdnURL + '/images/jobs/' + jd.shortname + '.png" />'
        this.innerHTML = html
      } else {
        this.textContent = this.dataset.name
      }
    })
    $('#TWDS_wuw_table .TWDS_wuw_item').each(function () {
      if (checked) {
        const id = this.dataset.itemid
        const x = new tw2widget.Item(window.ItemManager.get(id))
        if (x) {
          // x.initDisplay();
          this.innerHTML = ''
          this.appendChild(x.getMainDiv()[0])
        }
      } else {
        this.textContent = this.dataset.name
      }
    })
  })
}
TWDS.wuw.openwindow = function (scrollto) {
  const wid = 'TWDS_wuw_window'
  const win = wman.open(wid, 'set', 'TWDS_wuw')
  win.setTitle("¿Qué se usa y dónde?")
  win.setMiniTitle('WUW')

  const div = document.createElement('div')
  div.id = 'TWDS_wuw'
  TWDS.wuw.initWUWDisplay(div)

  const sp = new west.gui.Scrollpane()

  sp.appendContent(div)

  win.appendToContentPane(sp.getMainDiv())

  if (scrollto) {
    const x = TWDS.q1(scrollto, win.divMain)
    if (x) {
      x.scrollIntoView(true)
    }
  }
}

TWDS.registerStartFunc(function () {
  TWDS.registerExtra('TWDS.wuw.openwindow',
    TWDS._('EXTRAS_WUW_TEXT', '¿Qué se usa y dónde?'),
    TWDS._('EXTRAS_WUW_HELP', 'Muestra que equipo se usa para cada trabajo / conjunto de equipo.')
  )
})

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab

TWDS.updatetab = {}
TWDS.updateinfo = `
<dl>
<dt>0.73 - 2024-05-22
<dd>Nuevo: un nuevo extra: gestionar la lista de destinatarios de telegramas grupales.
<dd>Corrección de error: la clasificación de miembros de la ventana miembros de la ciudad por nombre no funcionó para su propia ciudad.
<dd>Corrección de error: el cuadro de selección del derecho de mercado en el diálogo de venta a veces mostraba el texto incorrecto (creo que en uno de tres casos, pero eso puede depender del idioma).
<dd>Mejora: el asistente de la ventana de misiones para crear un objeto no se mostró para las cuatro cosas nuevas (estofado de vaquero, silla de montar, etc.). Estas cosas tienen el subtipo incorrecto en la base de datos de los servidores del juego. Agregué una solución alternativa.
<dt>0.72 - 2024-04-08
<dd>Corrección de error: mapa de duelos no podía mostrar todos los resultados si una fecha no se podía analizar.
<dt>0.71 - 2024-04-03 - Nombre en clave "odio a jerry" (#1).
<dd>Nuevo: mejorada la pantalla de reclutamiento de batalla del fuerte con información de distancia/HP (clasificable).
<dd>Mejora: incluya iconos de ciudad/alianza/mundo en el diálogo mejorado de venta en el mercado.
<dt>0.70 - 2024-03-29
<dd>corrección de error: desactivar el contador de solicitudes de amistad provocó un error. Observado por Belle Bernice.
<dt>0.69 - 2024-03-29
<dd>Nuevo: Mapa de mercado implementado.
<dd>Nuevo: Mapa de duelo implementado.
<dd>Nuevo: un nuevo extra, un planificador de recursos de construcción de fuertes muy tosco.
<dd>Nuevo: un nuevo extra para mostrar interesantes pueblos fantasmas: aquellos con los puntos de construcción más bajos y más altos.
<dd>Nuevo: "jugadores en esta ubicación" se ha aumentado con un botón de "resumen", para mostrar un desglose de los jugadores por alianzas y ciudades (sí, esto es para peleas de fuertes).
<dd>Mejora: la característica número uno de esta versión: la capacidad de eliminar colores de los mensajes de chat de ciertas personas. "/uncolor + buchstabensuppe" eliminará cualquier color de los mensajes de chat, "/uncolor - buchstabensuppe" me permitirá ver colores nuevamente.
<dd>Mejora: "/cambia buchstabensuppe con otro jugador" generará "buchstabensuppe cambia 2 derecha 3 arriba con otro jugador"
<dd>Mejora: la exportación de trabajos de bonificación del minimapa ahora exporta el nombre del trabajo como marcador.
<dd>Mejora: la lista de trabajos ahora tiene un modo de datos sin procesar.
<dd>Mejora: la búsqueda de tiendas ahora tiene un modo para buscar solo en ciudades de la alianza.
<dd>Mejora: también capacidad de fijar elementos en el inventario (use la casilla de verificación en la ventana de fijación).
<dd>Mejora: la calculadora ahora puede guardar búsquedas.
<dd>Mejora: una nueva opción para eliminar la información de venta de la tienda de la barra de notificaciones.
<dd>Mejora: agrega una solución para el desbordamiento de la pantalla del cementerio en la batalla del fuerte.
<dd>Mejora: opción para mostrar los filtros de inventario en un inventario pequeño y tradicional. No es hermoso, pero está ahí.
<dd>Mejora: en la tienda de Union Pacific muestra la cantidad de artículos en tu bolso y el estado de recolección.
<dd>Mejora: ahora puedes ordenar la ventana de residentes de la ciudad por rango (predeterminado) y nombre.
<dd>Corrección de error: la representación previa a la batalla sobrescribió el propio icono de personaje y la imagen del objetivo cuando otro jugador había establecido el mismo lugar.
<dd>Mejora: muestra si varios jugadores están en el mismo lugar en la ventana previa a la batalla.
<dd>Corrección de errores: también muestra funciones de ayuda en misiones cuando el requisito es wear_changed.
<dd>Corrección de error: speedcalc no funcionaba cuando una ranura de ropa puesta estaba vacía.
<dd>Corrección de error: el manejo de fechas de personas/lista de duelos no funcionaba.
<dd>Corrección de error: la visualización del valor de batalla del fuerte en la superposición no incluía el factor 1,15 para el valor de ataque.

<dd>???: se agregaron varias traducciones al alemán que faltaban.
</dl>
`

TWDS.updatetab.getContent1 = function () {
  const d = TWDS.createEle({
    nodeName: 'div',
    children: [
      { nodeName: 'h3', textContent: 'Actualizaciones' },
      { nodeName: 'div', innerHTML: TWDS.updateinfo }
    ]
  })
  return d
}
// this is for TWDS.reload. getContent is referenced, genContent1 is accessed by name,
// so we can exchange it at runtime.
TWDS.updatetab.getContent = function () {
  return TWDS.updatetab.getContent1()
}
TWDS.updatetab.activate = function () {
  TWDS.activateTab('updates')
}

TWDS.updatetab.startFunction = function () {
  TWDS.registerTab('updates',
    TWDS._('TABNAME_UPDATES', 'Actualizaciones'),
    TWDS.updatetab.getContent,
    TWDS.updatetab.activate,
    true)
}
TWDS.registerStartFunc(TWDS.updatetab.startFunction)
// vim: tabstop=2 shiftwidth=2 expandtab

// a hack for the developer
if (TWDS.fbs && TWDS.fbs.data) {
  TWDS.fbstmp = TWDS.fbs.data
}
TWDS.fbs = {}
TWDS.fbs.data = {}
if ('fbstmp' in TWDS) {
  TWDS.fbs.data = TWDS.fbstmp
}
TWDS.fbs.bsw = null
TWDS.fbs.graphs = ['healthandguns', 'damage', 'kills', 'moves', 'bumps',
  'shotrate', 'online', 'bonus', 'hits', 'distance']

TWDS.fbs.makepersonstats = function (a, r, extra) {
  const fuddle2 = {
    value: 0,
    by: []
  }
  const fuddle = {
    count: 0,
    charlevel: 0,
    crithits: 0,
    dodgecount: 0,
    finishedhp: 0,
    hitcount: 0,
    ko_count: 0,
    maxhp: 0,
    misscount: 0,
    playdeadcount: 0,
    starthp: 0,
    takendamage: 0,
    takenhits: 0,
    totalcauseddamage: 0,
    weaponmaxdmg: 0,
    weaponmindmg: 0,
    onlinecount: 0,
    // derived
    personroundsalive: 0,
    personroundsalive54: 0,
    personlevelroundsalive: 0,
    personlevelroundsalive54: 0,
    survived: 0,
    hitquote: 0.0,
    dodgequote: 0.0,

    //
    moves: 0,
    fieldsmoved: 0,
    sectorsmoved: 0,

    //
    highest_charlevel: Object.assign({}, fuddle2),
    highest_crithits: Object.assign({}, fuddle2),
    highest_dodgecount: Object.assign({}, fuddle2),
    highest_hitcount: Object.assign({}, fuddle2),
    highest_ko_count: Object.assign({}, fuddle2),
    highest_playdeadcount: Object.assign({}, fuddle2),
    highest_starthp: Object.assign({}, fuddle2),
    highest_takenhits: Object.assign({}, fuddle2),
    highest_totalcauseddamage: Object.assign({}, fuddle2),

    highest_maxdamage: Object.assign({}, fuddle2),
    highest_hitquote: Object.assign({}, fuddle2),
    highest_dodgequote: Object.assign({}, fuddle2),
    highest_moves: Object.assign({}, fuddle2),
    highest_fieldsmoved: Object.assign({}, fuddle2),
    highest_sectorsmoved: Object.assign({}, fuddle2)
  }

  const o = Object.assign({}, fuddle)
  o.byclass = []
  // deep copy.
  o.byclass[0] = JSON.parse(JSON.stringify(fuddle))
  o.byclass[1] = JSON.parse(JSON.stringify(fuddle))
  o.byclass[2] = JSON.parse(JSON.stringify(fuddle))
  o.byclass[3] = JSON.parse(JSON.stringify(fuddle))
  o.byclass[4] = JSON.parse(JSON.stringify(fuddle))

  const mosthelper = function (d, k) {
    const cl = d.charclass + 1
    const k2 = 'highest_' + k
    if (d[k] > o[k2].value) {
      o[k2].value = d[k]
      o[k2].by = [d.name]
    } else if (d[k] === o[k2].value && d[k]) {
      o[k2].by.push(d.name)
    }
    if (d[k] > o.byclass[cl][k2].value) {
      o.byclass[cl][k2].value = d[k]
      o.byclass[cl][k2].by = [d.name]
    } else if (d[k] === o.byclass[cl][k2].value && d[k]) {
      o.byclass[cl][k2].by.push(d.name)
    }
  }

  for (let i = 0; i < a.length; i++) {
    const d = a[i]
    const cl = d.charclass + 1
    const id = d.westid

    // fix some things
    d.finishedhp = Math.max(0, d.finishedhp)
    d.shotsfired = (d.hitcount + d.misscount)
    // -1, because in 55 rounds play we can shoot 54 times.
    d.personroundsalive = (d.diedwhen === 0 ? r : d.diedwhen)
    d.personroundsonline = (d.diedwhen === 0 ? r : d.diedwhen)
    d.personlevelroundsalive = ((d.diedwhen === 0 ? r : d.diedwhen)) * d.charlevel
    d.personroundsalive54 = (d.diedwhen === 0 ? r : d.diedwhen) - 1
    d.personlevelroundsalive54 = ((d.diedwhen === 0 ? r : d.diedwhen) - 1) * d.charlevel
    d.ko_count = d.ko_shots.length
    d.hitquote = d.hitcount / (d.hitcount + d.misscount + 0.0) * 100
    d.dodgequote = d.dodgecount / (d.dodgecount + d.takenhits + 0.0) * 100
    d.survived = (d.killedby === -1 ? 1 : 0)
    //
    if (id in extra) {
      d.moves = extra[id].moves
      d.fieldsmoved = extra[id].fieldsmoved
      d.sectorsmoved = extra[id].sectorsmoved
    }
    for (const f of Object.keys(d)) {
      if (f in o) {
        o[f] += d[f]
        o.byclass[cl][f] += d[f]
      }
    }
    o.count++
    o.byclass[cl].count++

    mosthelper(d, 'charlevel')
    mosthelper(d, 'crithits')
    mosthelper(d, 'dodgecount')
    mosthelper(d, 'hitcount')
    mosthelper(d, 'ko_count')
    mosthelper(d, 'playdeadcount')
    mosthelper(d, 'starthp')
    mosthelper(d, 'takenhits')
    mosthelper(d, 'totalcauseddamage')
    mosthelper(d, 'maxdamage')
    if (d.hitcount + d.misscount >= r / 2 - 1) {
      mosthelper(d, 'hitquote')
    }
    if (d.takenhits + d.dodgecount >= 10) {
      mosthelper(d, 'dodgequote')
    }
    mosthelper(d, 'moves')
    mosthelper(d, 'sectorsmoved')
    mosthelper(d, 'fieldsmoved')
  }
  return o
}
TWDS.fbs.parselog = function () {
  const l = TWDS.fbs.data.result.log
  const lt = TWDS.fbs.data.result.logtypes
  const map = TWDS.fbs.data.result.map
  const cells = map.cells
  const sectors = map.sectors
  const state = {
  }
  const fillstate = function (cl, at) {
    for (let i = 0; i < cl.length; i++) {
      const id = cl[i].westid
      state[id] = Object.assign({}, cl[i])
      state[id]._curpos = cl[i].startposidx
      state[id]._attacker = at
      state[id]._moves = 0
      state[id]._bumps = 0
    }
  }
  fillstate(TWDS.fbs.data.result.attackerlist, true)
  fillstate(TWDS.fbs.data.result.defenderlist, false)

  let round = 0
  let curchar = 0
  let chartarget = -1
  let charmoved = -1
  let charonline = 0
  let charhealth = 0
  let shootat = 0
  let killed = 0
  let hit = 0
  const rounddata = []
  const dataset = {
    online: 0,
    fighters: 0,
    health: 0,
    moved: 0,
    bumps: 0,
    onbonusposition: 0,
    killed: 0,
    damagedone: 0,
    shots: 0,
    hits: 0,
    misses: 0,
    totaldistance: 0
  }
  const extradatatemplate = {
    moves: 0,
    sectorsmoved: 0,
    fieldsmoved: 0
  }
  const extradata = {
    at: { },
    def: { }
  }

  const calcdist = function (a, b) {
    const ay = parseInt(a / map.width)
    const ax = a - ay * map.width
    const by = parseInt(b / map.width)
    const bx = b - by * map.width
    return Math.sqrt((ax - bx) * (ax - bx) + (ay - by) * (ay - by))
  }

  const finishchar = function () {
    const key = state[curchar]._attacker ? 'at' : 'def'
    if (!(curchar in extradata[key])) {
      extradata[key][curchar] = Object.assign({}, extradatatemplate)
    }
    if (charmoved > -1) {
      extradata[key][curchar].moves++
      extradata[key][curchar].fieldsmoved += calcdist(charmoved,
        state[curchar]._curpos)

      const sectorreached = cells[charmoved]
      const oldsector = cells[state[curchar]._curpos]
      if (sectorreached !== oldsector) {
        extradata[key][curchar].sectorsmoved++
      }

      state[curchar]._moves++
      rounddata[round][key].moved++

      if (chartarget !== charmoved) {
        const targetsector = cells[chartarget]
        if (sectorreached === targetsector && charonline) {
          state[curchar]._bumps++
          rounddata[round][key].bumps++
        }
      }
    }
    let shootpos
    if (key === 'at') {
      // attacker moves and shoots
      if (charmoved !== -1) { shootpos = charmoved } else { shootpos = state[curchar]._curpos }
    } else {
      // defender shoots and moves
      shootpos = state[curchar]._curpos
    }
    if (shootpos !== -1) {
      const sector = cells[shootpos]
      const s = sectors[sector]
      if (key === 'at') {
        if (s.attackerBonus > 0) { rounddata[round][key].onbonusposition++ }
      }
      if (key === 'def') {
        if (s.defenderBonus > 0) { rounddata[round][key].onbonusposition++ }
      }
    }
    if (shootat) {
      const targetpos = state[shootat]._curpos
      const dist = calcdist(shootpos, targetpos)
      rounddata[round][key].shots++
      rounddata[round][key].totaldistance += dist
    }
    if (killed) {
      rounddata[round][key].killed++
      rounddata[round][key].hits++
      rounddata[round][key].damagedone += killed
    } else if (hit) {
      rounddata[round][key].hits++
      rounddata[round][key].damagedone += hit
    } else {
      rounddata[round][key].misses++
    }

    if (charonline) {
      rounddata[round][key].online++
    }
    rounddata[round][key].fighters++
    rounddata[round][key].health += charhealth
    if (charmoved !== -1) {
      state[curchar]._curpos = charmoved
    }
    curchar = 0
    chartarget = -1
    charmoved = -1
    charonline = 0
    charhealth = 0
    shootat = 0
    killed = 0
    hit = 0
  }
  for (let i = 0; i < l.length; i += 2) {
    const code = l[i]
    const para = l[i + 1]
    const type = lt[code]
    switch (type) {
      case 'ROUNDSTART': // 0
        if (curchar) { finishchar() }
        round = para
        rounddata[round] = {
          at: Object.assign({}, dataset),
          def: Object.assign({}, dataset)
        }
        curchar = 0
        break
      case 'CHARTURN': // 1
        if (curchar) { finishchar() }
        curchar = para
        break
      case 'CHARTARGET': // 2
        chartarget = para
        break
      case 'CHARHEALTH': // 3
        charhealth = para
        break
      case 'CHARONLINE': // 4
        charonline = para
        break
      case 'SHOOTAT': // 5
        shootat = para
        break
      case 'KILLED': // 6
        killed = para
        break
      case 'HIT': // 7
        hit = para
        break
      case 'MOVED': // 8
        charmoved = para
        break
    }
  }
  return [rounddata, extradata]
}
TWDS.fbs.makebasestats = function () {
  const _ = TWDS._
  this.bsw = wman.open('TWDS_fbs_basestats').setMiniTitle(_('FBS_TITLE', 'Estadísticas'))
  this.bsw.setTitle(_('FBS_TITLE', 'Estadísticas'))
  this.bsw.setSize(700, 400)
  const content = TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_fbs_basestats_content'
  })

  const [rdata, extradata] = TWDS.fbs.parselog()

  TWDS.q1('.tw2gui_window_content_pane', this.bsw.getMainDiv()).appendChild(content)
  TWDS.q1('.tw2gui_window_content_pane', this.bsw.getMainDiv()).classList.add('TWDS_scrollbar')

  let outcome = 'Unknown result (' + this.data.battle_outcome + ')'
  switch (this.data.battle_outcome) {
    case 'FINALROUND': outcome = _('FBS_OUTCOME_DEFENDED', 'Fuerte defendido'); break
    case 'FLAGLOST': outcome = _('FBS_OUTCOME_FLAGLOST', 'Bandera capturada'); break
    case 'ATTACKER_WIPED': outcome = _('FBS_OUTCOME_ATTACKERS_BEATEN', 'Atacantes derrotados'); break
    case 'DEFENDER_WIPED': outcome = _('FBS_OUTCOME_DEFENDERS_BEATEN', 'Defensores derrotados'); break
  }
  let lc = Game.locale.replace('_', '-')
  if (lc === 'en-DK') lc = 'en-GB' // en-dk: 16.52.04, en-GB: 16:52:04

  let dt = new Date(this.data.result_date * 1000)
  dt = dt.toLocaleString(lc)

  const h3 = TWDS.createEle({
    nodeName: 'h3',
    textContent: _('FBS_THE_FIGHT_FOR', 'La lucha por: ') + this.data.result.fortname
  })
  content.appendChild(h3)

  const p = TWDS.createEle({
    nodeName: 'p',
    textContent: outcome + ' @ ' + dt
  })
  content.appendChild(p)

  const tab = TWDS.createEle({
    nodeName: 'table'
  })
  content.appendChild(tab)

  const thead = TWDS.createEle({
    nodeName: 'thead',
    children: [
      {
        nodeName: 'tr',
        children: [
          { nodeName: 'th', textContent: _('FBS_ATT_SIDE', 'Atacante'), className: 'tw_red' },
          { nodeName: 'th', textContent: '' },
          { nodeName: 'th', textContent: _('FBS_DEF_SIDE', 'Defensor'), className: 'tw_blue' }
        ]
      }
    ]
  })
  tab.appendChild(thead)

  const tbody = TWDS.createEle({
    nodeName: 'tbody'
  })
  tab.appendChild(tbody)

  const rounds = this.data.result.roundsplayed - 1

  const atall = this.makepersonstats(this.data.result.attackerlist, rounds, extradata.at)
  const dfall = this.makepersonstats(this.data.result.defenderlist, rounds, extradata.def)

  tbody.appendChild(TWDS.createEle({
    nodeName: 'tr',
    children: [
      { nodeName: 'td', textContent: this.data.result.attackertownname },
      { nodeName: 'th', textContent: 'Town' },
      { nodeName: 'td', textContent: this.data.result.defendertownname }
    ]
  }))

  const subhead = function (t) {
    const e = TWDS.createEle({
      nodeName: 'tr',
      children: [
        { nodeName: 'th', className: 'subhead', colSpan: 3, textContent: t }
      ]
    })
    return e
  }
  const r = function (t, a, d, transform, hint) {
    const dotnull = "<span class='dotnull'>&nbsp;&nbsp;</span>"
    if (a instanceof Array) {
      a = a.join(', ')
      d = d.join(', ')
      if (a === '' && d === '') { return }
    } else {
      if (a === 0 && d === 0) return // soldiers ghosting :-)
    }
    if (transform) {
      if (isNaN(a) || !isFinite(a)) {
        a = '-' + dotnull
      } else {
        a = a.toFixed(1)
      }
      if (isNaN(d) || !isFinite(d)) {
        d = '-' + dotnull
      } else {
        d = d.toFixed(1)
      }
    } else {
      if (typeof a === 'number') {
        if (isNaN(a) || !isFinite(a)) {
          a = '-'
        }
        if (isNaN(d) || !isFinite(d)) {
          d = '-'
        }
      }
      a += dotnull
      d += dotnull
    }
    if (hint === null) hint = ''
    const e = TWDS.createEle({
      nodeName: 'tr',
      children: [
        { nodeName: 'td', innerHTML: a },
        { nodeName: 'th', textContent: t },
        { nodeName: 'td', innerHTML: d }
      ]
    })
    if (hint > '') {
      TWDS.q1('th', e).title = hint
    }
    tbody.appendChild(e)
  }
  const q = function (t, a, d, transform, hint) {
    const dotnull = "<span class='dotnull'>&nbsp;&nbsp;</span>"
    // a, d are objects
    if (a.value === 0 || isNaN(a.value) || !isFinite(a.value)) {
      if (d.value === 0 || isNaN(d.value) || !isFinite(d.value)) {
        return
      }
    }
    let av = a.value
    let dv = d.value
    if (isNaN(av) || !isFinite(av)) {
      if (transform) {
        av = '-' + dotnull
      } else {
        av = '-' + dotnull
      }
    } else {
      if (transform) {
        av = av.toFixed(1)
      } else {
        av += dotnull
      }
    }
    if (isNaN(dv) || !isFinite(dv)) {
      if (transform) {
        dv = '-' + dotnull
      } else {
        dv = '-' + dotnull
      }
    } else {
      if (transform) {
        dv = dv.toFixed(1)
      } else {
        dv += dotnull
      }
    }
    if (a.by.length === 1 && d.by.length === 1) {
      av = a.by[0] + ': ' + av
      dv = d.by[0] + ': ' + dv
    }
    if (hint === null) hint = ''
    const e = TWDS.createEle({
      nodeName: 'tr',
      children: [
        { nodeName: 'td', innerHTML: av },
        { nodeName: 'th', textContent: t },
        { nodeName: 'td', innerHTML: dv }
      ]
    })
    if (hint > '') {
      TWDS.q1('th', e).title = hint
    }
    tbody.appendChild(e)
    if (a.by.length !== 1 || d.by.length !== 1) {
      const f = TWDS.createEle({
        nodeName: 'tr',
        children: [
          { nodeName: 'td', innerHTML: a.by.join(', ') },
          { nodeName: 'th', textContent: _('FBS_DOTDOT_BY', '... por') },
          { nodeName: 'td', innerHTML: d.by.join(', ') }
        ]
      })
      tbody.appendChild(f)
    }
  }
  const clname = ['greenhorn', 'adventurer', 'duelist', 'worker', 'soldier']
  for (let i = -1; i < 5; i++) {
    let at
    let df
    if (i === -1) {
      at = atall
      df = dfall
    } else {
      at = atall.byclass[i]
      df = dfall.byclass[i]
    }
    if (at.count + df.count === 0) { continue }
    if (i === -1) {
      tbody.appendChild(subhead(_('FBS_OVER_ALL_CLASSES', 'Sobre todas las clases de personajes')))
    } else {
      tbody.appendChild(subhead(Game.InfoHandler.getLocalString4Charclass(clname[i])))
    }
    r(_('FBS_FIGHTERS', 'Luchadores'), at.count, df.count, false,
      'El número de luchadores al inicio de la batalla.')
    r(_('FBS_SURVIVORS', 'Supervivientes'), at.survived, df.survived, false,
      'El número de luchadores que quedan en pie al final de la batalla.')
    r(_('FBS_AVERAGE_ALIVE', 'Número promedio de luchadores vivos.'), at.personroundsalive / rounds, df.personroundsalive / rounds, true,
      'Contado en el tiempo, no un simple promedio.')

    r(_('FBS_HP_AT_START', 'Vida al inicio'), at.starthp, df.starthp, false)
    r(_('FBS_HP_AT_END', 'Vida al final'), at.finishedhp, df.finishedhp, false)
    q(_('FBS_MOST_HP', 'Mayor Vida'), at.highest_starthp, df.highest_starthp, false)
    r(_('FBS_MISSING_HP', 'Vida perdida al inicio'), at.maxhp - at.starthp, df.maxhp - df.starthp, false,
      'La cantidad de vida no rellenada')
    r(_('FBS_HP_LOST', 'Vida perdida'), at.starthp - at.finishedhp, df.starthp - df.finishedhp, false)
    r(_('FBS_HP_AVERAGE', 'Vida promedio'), at.starthp / at.count, df.starthp / df.count, true, 'Total vida al inicio dividida por luchadores.')

    // sr('totalcauseddamage', 'Damage caused')
    r(_('FBS_TOTAL_DAMAGE_DONE', 'Total daño hecho'), at.totalcauseddamage, df.totalcauseddamage, false, 'por luchador')
    r(_('FBS_AVERAGE_DAMAGE_DONE', 'Promedio daño hecho'), at.totalcauseddamage / at.count, df.totalcauseddamage / df.count, true, 'por luchador')
    r(_('FBS_AVERAGE_DAMAGE_PER_HIT', '... por tiro'), at.totalcauseddamage / at.hitcount, df.totalcauseddamage / df.hitcount, true)
    r(_('FBS_AVERAGE_HITS_DONE', 'Promedio de aciertos hechos'), at.hitcount / at.count, df.hitcount / df.count, true)
    r(_('FBS_AVERAGE_MISSED_SHOTS', 'Promedio de tiros fallidos'), at.misscount / at.count, df.misscount / df.count, true)

    r(_('FBS_AVERAGE_DAMAGE_TAKEN', 'Promedio de daño tomado'), df.totalcauseddamage / at.count, at.totalcauseddamage / df.count, true)
    r(_('FBS_AVERAGE_DODGED_SHOTS', 'Promedio de tiros eludidos'), at.dodgecount / at.count, df.dodgecount / df.count, true)
    r(_('FBS_AVERAGE_HITS_TAKEN', 'Promedio de tiros tomados'), at.takenhits / at.count, df.takenhits / df.count, true)

    r(_('FBS_KOS_ACHIEVED', 'KOs conseguidos'), at.ko_count, df.ko_count)
    r(_('FBS_CRITICAL_HITS', 'Críticos'), at.crithits, df.crithits)
    r(_('FBS_GHOSTS', 'Fantasma'), at.playdeadcount, df.playdeadcount)

    r(_('FBS_TOTAL_LEVELS', 'Niveles total'), at.charlevel, df.charlevel)
    r(_('FBS_AVERAGE_LEVEL', 'Nivel promedio'), at.charlevel / at.count, df.charlevel / df.count, true)
    q(_('FBS_HIGHEST_LEVEL', 'Nivel más alto'), at.highest_charlevel, df.highest_charlevel, true)
    // r('Highest level by', at.highest_charlevel.by, df.highest_charlevel.by, false)
    // r('Avg. # of levels alive.', at.personlevelroundsalive/rounds, df.personlevelroundsalive/rounds, true)

    r(_('FBS_AVERAGE_MAX_WEAPON_DMG', 'Promedio máximo daño arma'), at.weaponmaxdmg / at.count, df.weaponmaxdmg / df.count, true)
    r(_('FBS_AVERAGE_MIN_WEAPON_DMG', 'Promedio mínimo daño arma'), at.weaponmindmg / at.count, df.weaponmindmg / df.count, true)
    //
    q(_('FBS_HIGHEST_DMG_BY_1', 'Mayor daño hecho por un luchador'), at.highest_totalcauseddamage,
      df.highest_totalcauseddamage, false)
    q(_('FBS_HIGHEST_SINGLE_SHOT_DMG', 'Mayor daño en un solo disparo'), at.highest_maxdamage, df.highest_maxdamage, false)
    q(_('FBS_MOST_HITS', 'Mayoría aciertos'), at.highest_hitcount, df.highest_hitcount, false)
    q(_('FBS_HIGHEST_HIT_PERCENT', '% aciertos más alto'), at.highest_hitquote, df.highest_hitquote, true)

    q(_('FBS_MOST_DODGES', 'Mayoría eludidos'), at.highest_dodgecount, df.highest_dodgecount, false)
    q(_('FBS_HIGHEST_DODGE_PERCENT', '% eludidos más alto'), at.highest_dodgequote, df.highest_dodgequote, true)
    q(_('FBS_MOST_HITS_TAKEN', 'Mayoría de tiros tomados'), at.highest_takenhits, df.highest_takenhits, false)

    q(_('FBS_MOST_KOS', 'Mayor KOs'), at.highest_ko_count, df.highest_ko_count, false)
    q(_('FBS_MOST_CRITS', 'Mayoría críticos'), at.highest_crithits, df.highest_crithits, false)
    q(_('FBS_MOST_GHOSTS', 'Mayoría fantasma'), at.highest_playdeadcount, df.highest_playdeadcount, false)
    q(_('FBS_MOST_MOVES', 'Mayoría movimientos'), at.highest_moves, df.highest_moves, false)
    q(_('FBS_MOST_FIELDS_MOVED', 'Mayoría campos movidos'), at.highest_fieldsmoved, df.highest_fieldsmoved, true)
    q(_('FBS_MOST_SECTORS_MOVED', 'Mayoría sectores movidos'), at.highest_sectorsmoved, df.highest_sectorsmoved, false)

    r(_('FBS_SHOTS_FIRED', 'Disparos hechos'), at.hitcount + at.misscount, df.hitcount + df.misscount)
    r(_('FBS_SHOTS_FIRED_PERCENT', '% disparos hechos'),
      100.0 * (at.hitcount + at.misscount) / at.personroundsalive54,
      100.0 * (df.hitcount + df.misscount) / df.personroundsalive54, true,
      'Porcentaje de posibles disparos hechos (asumiendo al menos un objetivo en la línea de visión en cada ronda.)')
    r(_('FBS_ONLINE_PERCENT', '% en línea'),
      100.0 * (at.onlinecount) / at.personroundsalive54,
      100.0 * (df.onlinecount) / df.personroundsalive54, true,
      'Contando cada ronda en línea, dicvidido por el número de luchadores vivos.')
  }

  TWDS.fbs.addgraphs(content, rdata)
}
TWDS.fbs.addgraphs = function (content, rdata) {
  const h3 = TWDS.createEle({
    nodeName: 'h3',
    textContent: 'Graphs'
  })
  content.appendChild(h3)
  // content.appendChild(can)
  for (let i = 0; i < TWDS.fbs.graphs.length; i++) {
    const k = 'graph_' + TWDS.fbs.graphs[i]
    try {
      const can = TWDS.fbs[k](rdata)
      content.appendChild(can)
    } catch (e) {
      console.log('fail', k, e)
    }
  }
}
TWDS.fbs.preparecanvas = function (h1, h2, title) {
  const xmain = 550
  const ymain = 250
  const xhead = (636 - xmain) / 3 * 2
  const yhead = 30
  const xfooter = (636 - xmain) / 3 * 1
  const yfooter = 20
  const can = TWDS.createEle({
    nodeName: 'canvas',
    width: xhead + xmain + xfooter,
    height: yhead + ymain + yfooter
  })
  const ctx = can.getContext('2d')
  ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'
  ctx.fillRect(0, 0, can.width, can.height)
  ctx.fillStyle = 'rgba(220, 220, 220, 0.5)'
  ctx.fillRect(xhead, yhead, xmain, ymain)

  ctx.fillStyle = '#000000'

  ctx.font = '17px sans-serif'
  ctx.textAlign = 'left'
  ctx.fillText(title, xhead + 20, yhead - 5)

  ctx.font = '14px sans-serif'
  const sizedata = ctx.measureText('ABC123!')
  const lineheight = Math.abs(sizedata.actualBoundingBoxDescent - sizedata.actualBoundingBoxAscent)
  ctx.textBaseline = 'middle'
  ctx.textAlign = 'right'
  const ylabel = function (f) {
    let y = ymain / 100 * f
    y = yhead + ymain - y
    let v = Math.round(h1 / 100 * f)
    ctx.fillStyle = '#000000'
    ctx.textAlign = 'right'
    ctx.fillText(v, xhead - 1, y, xhead - 1)
    if (h2 !== null && h2 !== 0) {
      v = Math.round(h2 / 100 * f)
      ctx.textAlign = 'left'
      ctx.fillText(v, xhead + xmain + 1, y, xhead - 1)
    }

    ctx.strokeStyle = '#cccccc'
    if (f > 0.1 && f < 99.9) {
      ctx.beginPath()
      ctx.moveTo(xhead, y)
      ctx.lineTo(xhead + xmain - 1, y)
      ctx.stroke()
    }
  }
  const xlabel = function (rd) {
    const y = ymain + yhead + lineheight + 1
    const x = xhead + (rd - 2) * 10
    ctx.fillStyle = '#000000'
    ctx.textAlign = 'center'
    ctx.fillText(rd, x, y)
    ctx.strokeStyle = '#cccccc'
    if (rd > 2 && rd < 56) {
      ctx.beginPath()
      ctx.moveTo(x, y)
      ctx.lineTo(x, yhead)
      ctx.stroke()
    }
  }
  for (let i = 8; i >= 0; i--) {
    ylabel(100 / 8 * i)
  }
  xlabel(2)
  for (let i = 5; i < 55; i += 5) {
    xlabel(i)
  }
  xlabel(55)
  can._twds_xhead = xhead
  can._twds_yhead = yhead
  can._twds_xmain = xmain
  can._twds_ymain = ymain
  return can
}

TWDS.fbs.fillcanvas = function (can, rdata, who, k, vgl, xoff, sz, color, mode) {
  mode = mode || 'dot'
  const ctx = can.getContext('2d')
  const ybase = can._twds_ymain + can._twds_yhead
  const ymain = can._twds_ymain
  if (mode === 'line') {
    ctx.beginPath()
    ctx.strokeStyle = color
    ctx.lineWidth = sz
    if (sz === 1) {
      ctx.setLineDash([1, 1])
    }
  }

  for (let rd = 2; rd < rdata.length; rd++) {
    const xpos = can._twds_xhead + (rd - 2) * 10 + xoff
    const v = rdata[rd][who][k]
    const f = v / vgl
    const y = ybase - ymain * f
    ctx.fillStyle = color
    if (mode === 'dot') {
      if (v > 0) {
        ctx.fillRect(xpos, y, sz, sz)
      }
    } else if (mode === 'bar') {
      ctx.fillRect(xpos, y, sz, ybase - y)
    } else if (mode === 'line') {
      if (rd === 2) {
        ctx.moveTo(xpos, y)
      } else {
        ctx.lineTo(xpos, y)
      }
    }
  }
  if (mode === 'line') {
    ctx.stroke()
  }
}

TWDS.fbs.graph_healthandguns = function (rdata) {
  const h = Math.max(rdata[2].at.health, rdata[2].def.health)
  const f = Math.max(rdata[2].at.fighters, rdata[2].def.fighters)
  const can = TWDS.fbs.preparecanvas(h, f,
    TWDS._('FBS_GRAPHTITLE_HEALTH', 'Health (solid) and Guns (dotted)'))
  TWDS.fbs.fillcanvas(can, rdata, 'at', 'health', h, 0, 2, '#900', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'def', 'health', h, 0, 2, '#009', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'at', 'fighters', f, 0, 1, '#900', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'def', 'fighters', f, 0, 1, '#009', 'line')
  return can
}
TWDS.fbs.graph_damage = function (rdata) {
  let md = 0
  for (let rd = 2; rd < rdata.length; rd++) {
    md = Math.max(md, rdata[rd].at.damagedone)
    md = Math.max(md, rdata[rd].def.damagedone)
  }
  const can = TWDS.fbs.preparecanvas(md, null,
    TWDS._('FBS_GRAPHTITLE_DAMAGE', 'Damage done per round'))
  TWDS.fbs.fillcanvas(can, rdata, 'at', 'damagedone', md, 0, 5, '#900', 'bar')
  TWDS.fbs.fillcanvas(can, rdata, 'def', 'damagedone', md, 5, 5, '#009', 'bar')
  return can
}
TWDS.fbs.graph_kills = function (rdata) {
  let mk = 0
  for (let rd = 2; rd < rdata.length; rd++) {
    mk = Math.max(mk, rdata[rd].at.killed)
    mk = Math.max(mk, rdata[rd].def.killed)
  }
  const can = TWDS.fbs.preparecanvas(mk, null,
    TWDS._('FBS_GRAPHTITLE_KILLS', 'Kills'))
  TWDS.fbs.fillcanvas(can, rdata, 'at', 'killed', mk, 0, 5, '#900', 'bar')
  TWDS.fbs.fillcanvas(can, rdata, 'def', 'killed', mk, 5, 5, '#009', 'bar')
  return can
}
TWDS.fbs.graph_moves = function (rdata) {
  let md = 0
  for (let rd = 2; rd < rdata.length; rd++) {
    md = Math.max(md, rdata[rd].at.moved)
    md = Math.max(md, rdata[rd].def.moved)
  }
  const can = TWDS.fbs.preparecanvas(md, null,
    TWDS._('FBS_GRAPHTITLE_MOVES', 'Moves'))
  TWDS.fbs.fillcanvas(can, rdata, 'at', 'moved', md, 0, 5, '#900', 'bar')
  TWDS.fbs.fillcanvas(can, rdata, 'def', 'moved', md, 5, 5, '#009', 'bar')
  return can
}
TWDS.fbs.graph_bumps = function (rdata) {
  let m = 0
  for (let rd = 2; rd < rdata.length; rd++) {
    m = Math.max(m, rdata[rd].at.bumps)
    m = Math.max(m, rdata[rd].def.bumps)
  }
  const can = TWDS.fbs.preparecanvas(m, null,
    TWDS._('FBS_GRAPHTITLE_BUMPS', 'Bumps'))
  TWDS.fbs.fillcanvas(can, rdata, 'at', 'bumps', m, 0, 5, '#900', 'bar')
  TWDS.fbs.fillcanvas(can, rdata, 'def', 'bumps', m, 5, 5, '#009', 'bar')
  return can
}
TWDS.fbs.graph_shots = function (rdata) {
  let m = 0
  for (let rd = 2; rd < rdata.length; rd++) {
    m = Math.max(m, rdata[rd].at.shots)
    m = Math.max(m, rdata[rd].def.shots)
  }
  const can = TWDS.fbs.preparecanvas(m, null,
    TWDS._('FBS_GRAPHTITLE_SHOTS', 'Shots'))
  TWDS.fbs.fillcanvas(can, rdata, 'at', 'shots', m, 0, 5, '#900', 'bar')
  TWDS.fbs.fillcanvas(can, rdata, 'def', 'shots', m, 5, 5, '#009', 'bar')
  return can
}
TWDS.fbs.graph_shotrate = function (rdata) {
  let m = 0
  for (let rd = 2; rd < rdata.length; rd++) {
    rdata[rd].at.shotrate = 100 * rdata[rd].at.shots / Math.max(1, rdata[rd].at.fighters)
    rdata[rd].def.shotrate = 100 * rdata[rd].def.shots / Math.max(1, rdata[rd].def.fighters)
    m = Math.max(m, rdata[rd].at.shots)
    m = Math.max(m, rdata[rd].def.shots)
  }
  const can = TWDS.fbs.preparecanvas(m, null,
    TWDS._('FBS_GRAPHTITLE_SHOTPERCENTAGE', 'Shots (solid) and Shot percentage (dotted)'))
  TWDS.fbs.fillcanvas(can, rdata, 'at', 'shots', m, 0, 2, '#900', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'def', 'shots', m, 0, 2, '#009', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'at', 'shotrate', 100, 0, 1, '#900', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'def', 'shotrate', 100, 0, 1, '#009', 'line')
  return can
}
TWDS.fbs.graph_bonus = function (rdata) {
  let m = 0
  for (let rd = 2; rd < rdata.length; rd++) {
    rdata[rd].at.bonusp = 100 * rdata[rd].at.onbonusposition / Math.max(1, rdata[rd].at.fighters)
    rdata[rd].def.bonusp = 100 * rdata[rd].def.onbonusposition / Math.max(1, rdata[rd].def.fighters)
    m = Math.max(m, rdata[rd].at.onbonusposition)
    m = Math.max(m, rdata[rd].def.onbonusposition)
  }
  const can = TWDS.fbs.preparecanvas(m, 100,
    TWDS._('FBS_GRAPHTITLE_BONUS', 'Fighters on bonus positions (solid) and percentage thereof (dotted)'))
  TWDS.fbs.fillcanvas(can, rdata, 'at', 'onbonusposition', m, 0, 2, '#900', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'def', 'onbonusposition', m, 0, 2, '#009', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'at', 'bonusp', 100, 0, 1, '#900', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'def', 'bonusp', 100, 0, 1, '#009', 'line')
  return can
}
TWDS.fbs.graph_online = function (rdata) {
  let m = 0
  for (let rd = 2; rd < rdata.length; rd++) {
    rdata[rd].at.onlinep = 100 * rdata[rd].at.online / Math.max(1, rdata[rd].at.fighters)
    rdata[rd].def.onlinep = 100 * rdata[rd].def.online / Math.max(1, rdata[rd].def.fighters)
    m = Math.max(m, rdata[rd].at.online)
    m = Math.max(m, rdata[rd].def.online)
  }
  const can = TWDS.fbs.preparecanvas(m, 100,
    TWDS._('FBS_GRAPHTITLE_BONUS', 'Onliners (solid) and percentage thereof (dotted)'))
  TWDS.fbs.fillcanvas(can, rdata, 'at', 'online', m, 0, 2, '#900', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'def', 'online', m, 0, 2, '#009', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'at', 'onlinep', 100, 0, 1, '#900', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'def', 'onlinep', 100, 0, 1, '#009', 'line')
  return can
}
TWDS.fbs.graph_hits = function (rdata) {
  let m = 0
  for (let rd = 2; rd < rdata.length; rd++) {
    rdata[rd].at.hitp = 100 * rdata[rd].at.hits / Math.max(1, rdata[rd].at.shots)
    rdata[rd].def.hitp = 100 * rdata[rd].def.hits / Math.max(1, rdata[rd].def.shots)
    m = Math.max(m, rdata[rd].at.hits)
    m = Math.max(m, rdata[rd].def.hits)
  }
  const can = TWDS.fbs.preparecanvas(m, 100,
    TWDS._('FBS_GRAPHTITLE_BONUS', 'Hits (solid) and hit percentage (dotted)'))
  TWDS.fbs.fillcanvas(can, rdata, 'at', 'hits', m, 0, 2, '#900', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'def', 'hits', m, 0, 2, '#009', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'at', 'hitp', 100, 0, 1, '#900', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'def', 'hitp', 100, 0, 1, '#009', 'line')
  return can
}
TWDS.fbs.graph_distance = function (rdata) {
  let m = 0
  for (let rd = 2; rd < rdata.length; rd++) {
    rdata[rd].at.hitp = 100 * rdata[rd].at.hits / Math.max(1, rdata[rd].at.shots)
    rdata[rd].def.hitp = 100 * rdata[rd].def.hits / Math.max(1, rdata[rd].def.shots)
    rdata[rd].at.avgdist = rdata[rd].at.totaldistance / Math.max(1, rdata[rd].at.shots)
    rdata[rd].def.avgdist = rdata[rd].def.totaldistance / Math.max(1, rdata[rd].def.shots)

    m = Math.max(m, rdata[rd].at.avgdist)
    m = Math.max(m, rdata[rd].def.avgdist)
  }
  const can = TWDS.fbs.preparecanvas(m, 100,
    TWDS._('FBS_GRAPHTITLE_BONUS', 'Average distance (solid) and hit percentage (dotted)'))
  TWDS.fbs.fillcanvas(can, rdata, 'at', 'avgdist', m, 0, 2, '#900', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'def', 'avgdist', m, 0, 2, '#009', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'at', 'hitp', 100, 0, 1, '#900', 'line')
  TWDS.fbs.fillcanvas(can, rdata, 'def', 'hitp', 100, 0, 1, '#009', 'line')
  return can
}

TWDS.fbs.showStatUpdateTable = function (data) {
  if (!TWDS.settings.misc_fortbattle_statistics) {
    return CemeteryWindow._TWDS_backup_showStatUpdateTable.apply(this, arguments)
  }
  TWDS.fbs.data = data
  const ret = CemeteryWindow._TWDS_backup_showStatUpdateTable.apply(this, arguments)
  const container = TWDS.createEle({
    nodeName: 'div',
    style: {
      position: 'absolute',
      left: '-12px',
      top: '50px',
      display: 'inline-block'
    }
  })
  const b1 = TWDS.createEle({
    nodeName: 'button',
    textContent: 'FBS',
    id: 'TWDS_fbs_f',
    className: 'TWDS_button',
    title: 'Basic fort battle statistics'
  })
  container.appendChild(b1)
  const cp = TWDS.q1('.tw2gui_window.cemetery .tw2gui_window_content_pane')
  if (cp) {
    cp.appendChild(container)
  }
  b1.onclick = function () {
    TWDS.fbs.makebasestats.apply(TWDS.fbs, arguments)
  }
  return ret
}

TWDS.registerStartFunc(function () {
  TWDS.registerSetting('bool', 'misc_fortbattle_statistics',
    TWDS._('FBS_SETTING', 'Agregar un botón al cementerio para mostrar estadísticas del fuerte.'), true, null, 'Miscelánea')
  // give TW Toolkit time to patch the original functions. Yes, it patches them.
  window.setTimeout(function () {
    CemeteryWindow._TWDS_backup_showStatUpdateTable = CemeteryWindow.showStatUpdateTable
    CemeteryWindow.showStatUpdateTable = TWDS.fbs.showStatUpdateTable
  }, 10 * 1000)
})

// used when reloading, so the updated code will be used.
if ('_TWDS_backup_showStatUpdateTable' in CemeteryWindow) {
  CemeteryWindow.showStatUpdateTable = TWDS.fbs.showStatUpdateTable
  console.log('fbs.js reloaded')
}

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab

TWDS.sleep = {}
TWDS.sleep.sb = {}
// taken from clothcalc, there
TWDS.sleep.getLastPosition = function () {
  const pos = {
    x: Character.position.x,
    y: Character.position.y
  }
  const q = TaskQueue.queue
  for (let n = 0; n < q.length; n++) {
    const r = q[n].wayData
    if (r.x) {
      pos.x = r.x
      pos.y = r.y
    }
  }
  return pos
}

TWDS.sleep.openwrapper = function (eventdata) {
  return TWDS.sleep.open(eventdata)
}
TWDS.sleep.open = function (eventdata) {
  const translatehotelroom = ['', 'cubby', 'bedroom', 'hotel_room', 'apartment', 'luxurious_apartment']

  let cache = window.localStorage.getItem('TWDS_sleep_cache')
  let ts = 0
  if (cache !== null) {
    try {
      cache = JSON.parse(cache)
      ts = cache.timestamp
    } catch (e) {
      cache = null
    }
  }
  if (cache === null) {
    cache = {
      towns: {},
      forts: {}
    }
  }
  const now = (new Date()).getTime()
  let needexpire = false
  if (now - ts >= 86400 * 1000) {
    needexpire = true
  }
  TWDS.sleep.cache = cache

  Ajax.get('map', 'get_minimap', {}, function (json) {
    if (json.error) {
      return new UserMessage(json.msg).show()
    }
    const forts = []
    const towns = []

    for (const xi of Object.keys(json.forts)) {
      const x = parseInt(xi)
      if (x > 0) {
        for (const yi of Object.keys(json.forts[xi])) {
          const y = parseInt(yi)
          if (y > 0) {
            const loc = json.forts[xi][yi]
            if (typeof loc !== 'object') {
              continue
            }
            if (needexpire) {
              const id = loc.fort.fort_id
              if (id in cache.forts) {
                if (cache.forts[id] !== loc.fort.type * 2 + 2) {
                  // 0=small=max. barrack level 2
                  // 1=medium=max. barrack level 4
                  // 2=medium=max. barrack level 6
                  // if the level in the cache is smaller we remove the record, as someone may have build it further.
                  delete cache.forts[id]
                }
              }
            }
            if (Map.Helper.isForeignFort(loc.fort, loc.townIds, json.towns)) {
              continue
            }
            if (Map.Helper.isAllianceFort(loc.fort, loc.townIds, json.towns)) {
              forts.push(loc.fort)
            } else if (Map.Helper.isOwnFort(loc.fort, loc.townIds, json.towns)) {
              forts.push(loc.fort)
            } else {
              console.log('fort', loc.fort, 'with towns', loc.townIds, 'in the void')
            }
          }
        }
      }
    }
    const mypos = TWDS.sleep.getLastPosition()

    for (const i of Object.keys(json.towns)) {
      if (needexpire) {
        if (i in cache.towns && cache.towns[i] !== 5) {
          delete cache.towns[i]
        }
      }
      if (json.towns[i].member_count > 0) {
        json.towns[i]._twds_waytime = Map.calcWayTime(json.towns[i], mypos)
        towns.push(json.towns[i])
      }
    }
    for (let i = 0; i < forts.length; i++) {
      forts[i]._twds_waytime = Map.calcWayTime(forts[i], mypos)
    }
    forts.sort(function (a, b) {
      if (a._twds_waytime < b._twds_waytime) return -1
      if (a._twds_waytime > b._twds_waytime) return 1
      return 0
    })

    towns.sort(function (a, b) {
      if (a._twds_waytime < b._twds_waytime) return -1
      if (a._twds_waytime > b._twds_waytime) return 1
      return 0
    })

    const sb = (new west.gui.Selectbox(true)).addListener(function (e) {
      const fort = e.match(/^fort-(\d+)-(\d+)-(\d+)/)
      if (fort !== null) {
        window.TaskQueue.add(new window.TaskFortSleep(fort[1], fort[2], fort[3]))
        return
      }
      const town = e.match(/^town-(\d+)-(\d+)/)
      if (town !== null) {
        window.TaskQueue.add(new window.TaskSleep(town[1], translatehotelroom[town[2]]))
      }
    })
    sb.addClass('TWDS_sleephelper')
    TWDS.sleep.sb = sb
    const addit = function (sel, wt, place, building, stars) {
      const s = "<span class='stars" + stars + "'>" + '******'.substring(0, stars) + '</span>'
      sb.addItem(sel, wt.formatDuration() + ' ' + place + ' ' + building + s)
    }
    const todos = []
    if (Character.homeTown.town_id) {
      todos.push({
        town_id: Character.homeTown.town_id,
        name: 'Hometown',
        waytime: Map.calcWayTime(Character.homeTown, mypos)
      })
    }
    for (let i = 0; i < forts.length; i++) {
      todos.push({
        fort_id: forts[i].fort_id,
        x: forts[i].x,
        y: forts[i].y,
        name: forts[i].name,
        waytime: forts[i]._twds_waytime
      })
    }
    if (Character.homeTown.town_id > 0 || Character.homeTown.town_id === 0) {
      for (let i = 0; i < 5; i++) {
        todos.push({
          town_id: towns[i].town_id,
          name: towns[i].name,
          waytime: towns[i]._twds_waytime
        })
      }
    }

    // the following uses a cache for barrack / hotel levels.

    for (let i = 0; i < todos.length; i++) {
      const todo = todos[i]
      todo.done = false
      if (todo.town_id) {
        if (todo.town_id in cache.towns) {
          todo.done = true
        }
      }
      if (todo.fort_id) {
        if (todo.fort_id in cache.forts) {
          todo.done = true
        }
      }
    }
    let todoidx = 0
    let hotellevelreached = 0
    const handletodos = function () {
      if (todoidx >= todos.length) {
        cache.timestamp = (new Date()).getTime()
        window.localStorage.setItem('TWDS_sleep_cache', JSON.stringify(cache))
        sb.show(eventdata)
        return
      }
      const todo = todos[todoidx]
      todoidx++
      if (todo.done) {
        if (todo.town_id) {
          const lv = cache.towns[todo.town_id]
          if (lv > hotellevelreached) {
            addit('town-' + todo.town_id + '-' + lv,
              todo.waytime,
              todo.name,
              TWDS._('SLEEP_HOTEL', 'Hotel'), lv)
            hotellevelreached = lv
          }
        }
        if (todo.fort_id) {
          const lv = cache.forts[todo.fort_id]
          if (lv) {
            addit('fort-' + todo.fort_id + '-' + todo.x + '-' + todo.y,
              todo.waytime,
              todo.name,
              TWDS._('SLEEP_BARRACK', 'Barracón'), lv)
          }
        }
        handletodos() // recursion. Urks.
        return
      }
      // so we don't have the data in the cache. get it.
      if (todo.town_id) {
        if (hotellevelreached < 5) {
          Ajax.remoteCallMode('building_hotel', 'get_data', {
            town_id: todo.town_id
          }, function (data) {
            if (data.error) return (new UserMessage(data.msg)).show()
            const lv = data.hotel_level
            cache.towns[todo.town_id] = lv
            if (lv > hotellevelreached) {
              addit('town-' + todo.town_id + '-' + lv,
                todo.waytime,
                todo.name,
                'Hotel', lv)
              hotellevelreached = lv
            }
            handletodos() // recursion. Urks.
          })
        } else {
          handletodos() // recursion. Urks.
        }
      }
      if (todo.fort_id) {
        Ajax.remoteCallMode('fort_building_barracks', 'index', {
          fort_id: todo.fort_id
        }, function (data) {
          if (data.error) {
            (new UserMessage(data.error)).show()
            return
          }
          if ('barrackStage' in data) {
            cache.forts[todo.fort_id] = data.barrackStage
            addit('fort-' + todo.fort_id + '-' + todo.x + '-' + todo.y,
              todo.waytime,
              todo.name,
              'Barrack', data.barrackStage)
          } else {
            cache.forts[todo.fort_id] = 0
          }
          handletodos() // recursion. Urks.
        })
      }
    }
    if (todos.length) {
      handletodos()
    }
  })
}
TWDS.sleep.settingchanged = function (v) {
  const bar = TWDS.q1('#ui_character_container .health_bar')
  if (!bar) return
  if (v) {
    bar.addEventListener('click', TWDS.sleep.openwrapper)
    bar.classList.add('TWDS_clickable')
  } else {
    bar.removeEventListener('click', TWDS.sleep.openwrapper)
    bar.classList.remove('TWDS_clickable')
  }
}
TWDS.registerStartFunc(function () {
  TWDS.registerSetting('bool', 'sleephelper',
    TWDS._('SLEEP_SETTING',
      'Permite seleccionar un hotel o barracón para dormir haciendo clic en la barra de puntos de salud.'),
    true, TWDS.sleep.settingchanged, 'Miscelánea', null)
})
// vim: tabstop=2 shiftwidth=2 expandtab

TWDS.quickusables = {}
TWDS.quickusables.sb = {}

TWDS.quickusables.openwrapper = function (eventdata) {
  return TWDS.quickusables.open(eventdata)
}

TWDS.quickusables.usables = null
TWDS.quickusables.catnames = {
  energy: TWDS._('QUICKUSABLES_ENERGY', 'Energía'),
  health: TWDS._('QUICKUSABLES_HEALTH', 'Salud'),
  workmotivation: TWDS._('QUICKUSABLES_WMOT', 'Motivación trabajo'),
  duelmotivation: TWDS._('QUICKUSABLES_DMOT', 'Motivación duelo'),
  drop: TWDS._('QUICKUSABLES_DROP', 'Tasa salida'),
  experience: TWDS._('QUICKUSABLES_XP', 'Experiencia'),
  experiencelevel: TWDS._('QUICKUSABLES_XPLEVEL', 'Exp. como % del nivel'),
  luck: TWDS._('QUICKUSABLES_LUCK', 'Suerte'),
  money: TWDS._('QUICKUSABLES_MONEY', 'Dinero'),
  duel: TWDS._('QUICKUSABLES_DUEL', 'Duelo'),
  fortbattle: TWDS._('QUICKUSABLES_FB', 'Batallas'),
  multiplayer: TWDS._('QUICKUSABLES_MPI', 'Aventuras'),
  movement: TWDS._('QUICKUSABLES_MOVEMENT', 'Velocidad'),
  openunpack: TWDS._('QUICKUSABLES_OPENUNPACK', 'Abrir/desempaquetar'),
  laborpoints: TWDS._('QUICKUSABLES_LP', 'Puntos trabajo'),
  bonds: TWDS._('QUICKUSABLES_BONDS', 'Bonos'),
  cempasuchils: TWDS._('QUICKUSABLES_CEMPASUCHILS', 'Cempasúchils'),
  eastereggs: TWDS._('QUICKUSABLES_EASTEREGGS', 'Huevos de Pascua'),
  fireworks: TWDS._('QUICKUSABLES_FIREWORKS', 'Fuegos artificiales'),
  hearts: TWDS._('QUICKUSABLES_HEARTS', 'Corazones'),
  pretzels: TWDS._('QUICKUSABLES_PRETZELS', 'Pretzels'),
  regeneration: TWDS._('QUICKUSABLES_REGENERATION', 'Regeneración'),
  skillpoints: TWDS._('QUICKUSABLES_SKILLPOINTS', 'Puntos de Habilidad'),
  premium: TWDS._('QUICKUSABLES_PREMIUM', 'Premium'),
  debuff: TWDS._('QUICKUSABLES_DEBUFF', 'Quitar buff'),
  quest: TWDS._('QUICKUSABLES_QUEST', 'Búsqueda'),
  other: TWDS._('QUICKUSABLES_OTHER', 'Otros')
}
TWDS.quickusables.getcatdesc = function (cat) {
  if (cat in TWDS.quickusables.catnames) { return TWDS.quickusables.catnames[cat] }
  return cat
}
TWDS.quickusables.hascat = function (cat) {
  return (cat in TWDS.quickusables.catnames)
}
TWDS.quickusables.getcategories = function (kind) {
  if (TWDS.quickusables.usables === null) {
    TWDS.quickusables.initusables()
  }
  const out = []
  for (const i of Object.keys(TWDS.quickusables.usables)) {
    if (i.match(/_x$/)) continue
    if (kind === 0 || TWDS.quickusables.flags[i] & kind) { out.push(i) }
  }
  return out
}
TWDS.quickusables.addcat = function (what, where) {
  TWDS.quickusables.usables[what] = {}
  TWDS.quickusables.flags[what] = where
}
TWDS.quickusables.initusables = function () {
  // 1 is market, 2 is event currency
  TWDS.quickusables.flags = {
    energy: 1,
    health: 1,
    workmotivation: 1,
    duelmotivation: 1,
    drop: 1,
    experience: 1,
    experiencelevel: 0,
    money: 1,
    luck: 1,
    duel: 1,
    fortbattle: 1,
    laborpoints: 1,
    multiplayer: 1,
    openunpack: 1,
    movement: 1,
    bonds: 0,
    pretzels: 2,
    hearts: 2,
    fireworks: 2,
    cempasuchils: 2,
    eastereggs: 2,
    regeneration: 1,
    skillpoints: 1,
    premium: 0,
    debuff: 0,
    quest: 0,
    other: 0
  }
  TWDS.quickusables.usables = {}
  for (const i of Object.keys(TWDS.quickusables.flags)) {
    TWDS.quickusables.usables[i] = []
  }

  const clean = function (str) {
    if (str.search(/Avatar.*:/) !== -1) {
      str = str.replace(/:.*/, '')
    }
    // TWIR touppercases \d :-(
    str = str.replace('+', '')
    str = str.replace(/([0-9]+)/g, '[0-9]+')
    str = str.replace('$', '\\$')
    str = str.replace('(', '\\(')
    str = str.replace(')', '\\)')
    return str // .replace(/%/, '')
  }
  const doit = function (id, key, idx) {
    const it = ItemManager.getByBaseId(id)
    try {
      TWDS.quickusables.usables[key].push(clean(it.usebonus[idx || 0]))
    } catch (e) {
      console.log('strange', 'no item for #', id, 'needed for quickusable', key, idx)
    }
  }
  doit(1943, 'energy')
  doit(1974, 'health')
  doit(1891, 'workmotivation')
  doit(1882, 'duelmotivation')
  doit(2465, 'luck')
  doit(2466, 'drop')
  doit(2467, 'experience')
  doit(2468, 'money')
  doit(2559, 'money', 0)
  doit(2204, 'money', 0)
  doit(2741, 'multiplayer', 1)
  doit(2741, 'multiplayer', 2)
  doit(1926, 'movement')
  doit(1927, 'movement')
  doit(1940, 'laborpoints')
  doit(1946, 'health', 1)
  doit(1901, 'duel')
  doit(1863, 'duel', 0)
  doit(1863, 'duel', 1)
  doit(1864, 'duel', 0)
  doit(1864, 'duel', 1)
  doit(1871, 'duel', 1)
  doit(1872, 'duel', 1)
  doit(51125, 'duel', 0)
  doit(51125, 'duel', 1)
  doit(2741, 'fortbattle', 0)
  doit(1873, 'fortbattle', 1) // gemüsetasche, leiten
  doit(1946, 'fortbattle', 0) // amulett, ausweichen
  doit(1946, 'fortbattle', 1) // amulett, lp
  doit(2525, 'fortbattle', 1) // zaubertinte, fallen stellen
  doit(2525, 'fortbattle', 2) // zaubertinte, verstecken
  doit(51775, 'openunpack', 0) // Motivationsbox, "Etwas zum Auspacken".
  doit(51595, 'openunpack', 0) // Metallschädel,  "Enthält eine der folgenden Sammelkarten"
  doit(374, 'openunpack', 0) // Osterkiste,  "Enthält einen der folgenden Gegenstände
  doit(2136, 'bonds', 0) // bonds
  doit(2196, 'experiencelevel', 0) // experience to your next level
  doit(371, 'pretzels', 0)
  doit(2562, 'hearts', 0)
  doit(2675, 'cempasuchils', 0)
  doit(2619, 'fireworks', 0)
  doit(51981, 'eastereggs', 0)
  doit(51599, 'regeneration', 0)
  doit(21340, 'premium', 0)
  doit(21341, 'premium', 0)
  doit(21342, 'premium', 0)
  doit(21343, 'premium', 0)
  doit(50991, 'premium', 0)
  doit(2482, 'premium', 0) // nuggetbeutel
  doit(2472, 'premium', 0) // versicherung
  doit(1977, 'debuff', 0)
  doit(1978, 'debuff', 0)
  doit(1979, 'debuff', 0)
  doit(51871, 'debuff', 0)
  doit(53454, 'debuff', 0)
  doit(2486, 'other', 0) // tent
  doit(50086, 'other', 0) // avatar stuff

  // skill and attribute points
  // +2 Stärke / strength
  // +15 Handeln / trading
  // +15 Arbeitpunkte auf Handeln (look, a false positive...)
  const a = []
  for (const some of Object.values(CharacterSkills.keyNames)) {
    a.push(clean(some))
  }
  const collected = '(' + a.join('|') + ')'
  let str = ItemManager.get(1879000).usebonus[0] // strength
  str = clean(str)
  str = str.replace(CharacterSkills.keyNames.strength, collected)
  TWDS.quickusables.usables.skillpoints.push(str)
}
TWDS.quickusables.classifymatchstring = function (item, cat) {
  if (!('usetype' in item)) return false
  if (item.usetype === 'none') return false
  const ub = item.usebonus
  const searchstrings = TWDS.quickusables.usables[cat]
  if (searchstrings === undefined) { // no known cat
    return false
  }
  let found = false
  for (let i = 0; i < ub.length; i++) {
    const b = ub[i]
    if (b === null) continue
    for (let j = 0; j < searchstrings.length; j++) {
      if (b.search(searchstrings[j]) !== -1) {
        found = true
        break
      }
    }
  }
  if (!found) return false
  if ((cat + '_x') in TWDS.quickusables.usables) {
    const exclusions = TWDS.quickusables.usables[cat + '_x']
    for (let k = 0; k < ub.length; k++) {
      for (let x = 0; x < exclusions.length; x++) {
        if (ub[k].toLocaleLowerCase().search(exclusions[x].toLocaleLowerCase()) !== -1) {
          return false
        }
      }
    }
  }
  return true
}
TWDS.quickusables.classify = function (item) {
  if (typeof item === 'number') { item = ItemManager.get(item) }
  const cats = []
  if ('TWDS.classification' in item._memo) { return item._memo.TWDS_classification }
  for (const catname of Object.keys(TWDS.quickusables.catnames)) {
    if (TWDS.quickusables.classifymatchstring(item, catname)) {
      cats.push(catname)
    }
  }
  if (item.quest) {
    cats.push('quest')
  }
  item._memo.TWDS_classification = cats
  return cats
}
TWDS.quickusables.check = function () {
  const all = ItemManager.getAll()
  let n = 0
  for (const it of Object.values(all)) {
    if (it.type !== 'yield') continue
    if (it.spec_type === 'mapdrop') continue
    if (it.spec_type === 'crafting') continue
    if (it.usebonus === null && it.usetype === 'none') continue
    if (it.set) continue

    if (it.usebonus[0].search('Avatargegenstand:') === 0) continue // german
    const cats = TWDS.quickusables.classify(it)
    if (cats.length) continue
    console.log(it.item_id, it.name, 'no classification', cats, it)
    n++
    if (n === 20) {
      break
    }
  }
}
TWDS.quickusables.match = function (item, cat) {
  if (typeof item === 'number') { item = ItemManager.get(item) }
  if (TWDS.quickusables.usables === null) {
    TWDS.quickusables.initusables()
  }

  const cats = TWDS.quickusables.classify(item)
  if (cats.includes(cat)) return true
  return false
}
TWDS.quickusables.matchnumber = function (item, cat) {
  if (TWDS.quickusables.usables === null) {
    TWDS.quickusables.initusables()
  }
  const cats = TWDS.quickusables.classify(item)
  if (!cats.includes(cat)) return false

  if (!('usetype' in item)) return 0
  if (item.usetype === 'none') return 0
  const ub = item.usebonus
  const searchstrings = TWDS.quickusables.usables[cat]
  if (searchstrings === undefined) { // no known cat
    return 0
  }
  let found = false
  let num = 0
  for (let i = 0; i < ub.length; i++) {
    const b = ub[i]
    if (b === null) continue
    for (let j = 0; j < searchstrings.length; j++) {
      if (b.search(searchstrings[j]) !== -1) {
        found = true
        const rx = /(\d+)/
        const t = b.match(rx)
        if (t !== null) {
          num += parseFloat(t[1])
        }
      }
    }
  }
  if (!found) return 0
  return num
}
TWDS.quickusables.showusables = function (choice) {
  Inventory.open() // TWIR needs that if the inventory hasn't been opened
  if (TWDS.quickusables.usables === null) {
    TWDS.quickusables.initusables()
  }
  if (!(choice in TWDS.quickusables.usables)) {
    console.log('choice', choice, 'not in', TWDS.quickusables.usables)
    return
  }
  const translatedchoices = TWDS.quickusables.usables[choice]
  if (translatedchoices.length === 0) {
    console.log('choice', choice, 'has empty translation', TWDS.quickusables.usables)
    return
  }

  const filtered = []
  for (let j = 0; j < translatedchoices.length; j++) {
    const found = Bag.search(translatedchoices[j])
    for (let i = 0; i < found.length; i++) {
      if ('usetype' in found[i].obj && found[i].obj.usetype !== 'none') {
        const v = TWDS.quickusables.matchnumber(found[i].obj, choice)
        filtered.push([found[i], v])
      }
      /*
      if ('usetype' in found[i].obj && found[i].obj.usetype !== 'none') {
        console.log('SEARCH', j, translatedchoices[j], 'FOUND', found[i])
        let exclude = false
        if ((choice + '_x') in TWDS.quickusables.usables) {
          const ub = found[i].obj.usebonus
          const exclusions = TWDS.quickusables.usables[choice + '_x']
          console.log('XX', exclusions)
          for (let k = 0; k < ub.length; k++) {
            for (let x = 0; x < exclusions.length; x++) {
              if (ub[k].toLocaleLowerCase().search(exclusions[x].toLocaleLowerCase()) !== -1) {
                console.log('SEARCH', j, translatedchoices[j], 'EXCLUSE', found[i])
                exclude = true
              }
            }
          }
        }
        if (!exclude) {
          filtered.push(found[i])
        }
      }
      */
    }
  }
  console.log('QU', filtered[0], filtered[1])
  filtered.sort(function (a, b) { return a[1] - b[1] })
  console.log('QS', filtered[0], filtered[1])
  for (let i = 0; i < filtered.length; i++) {
    console.log('sort #', i, filtered[i][1], filtered[i][0].obj.name)
    filtered[i] = filtered[i][0]
  }
  Inventory.open()
  Inventory.showSearchResult(filtered)
}
TWDS.quickusables.open = function (eventdata) {
  console.log('quickusables.open')
  const sb = (new west.gui.Selectbox(true))
    .setHeight('347px')
    .addListener(function (choice) {
      TWDS.quickusables.showusables(choice)
    })
  sb.addClass('TWDS_quickusableshelper')
  sb.addItem('energy', TWDS._('QUICKUSABLES_ENERGY', 'Energy'))
  sb.addItem('health', TWDS._('QUICKUSABLES_HEALTH', 'Health'))
  sb.addItem('workmotivation', TWDS._('QUICKUSABLES_WMOT', 'Work motivation'))
  sb.addItem('duelmotivation', TWDS._('QUICKUSABLES_DMOT', 'Duel motivation'))

  const x = [
    ['drop', TWDS._('QUICKUSABLES_DROP', 'Drop chance')],
    ['experience', TWDS._('QUICKUSABLES_XP', 'Experience')],
    ['luck', TWDS._('QUICKUSABLES_LUCK', 'Luck')],
    ['luck', TWDS._('QUICKUSABLES_MONEY', 'Money')],
    ['duel', TWDS._('QUICKUSABLES_DUEL', 'Duel')],
    ['fortbattle', TWDS._('QUICKUSABLES_FB', 'Fort battle')],
    ['multiplayer', TWDS._('QUICKUSABLES_MPI', 'Multiplayer')],
    ['movement', TWDS._('QUICKUSABLES_MOVEMENT', 'Movement')],
    ['laborpoints', TWDS._('QUICKUSABLES_LP', 'Labor points')]
  ]
  x.sort(function (a, b) {
    return a[1].toLocaleLowerCase().localeCompare(b[1].toLocaleLowerCase())
  })
  for (let i = 0; i < x.length; i++) {
    sb.addItem(x[i][0], x[i][1])
  }
  sb.show(eventdata)
}

TWDS.quickusables.settingchanged = function (v) {
  const bar = TWDS.q1('#ui_character_container .energy_bar')
  if (!bar) return
  if (v) {
    bar.addEventListener('click', TWDS.quickusables.openwrapper)
    bar.classList.add('TWDS_clickable')
  } else {
    bar.removeEventListener('click', TWDS.quickusables.openwrapper)
    bar.classList.remove('TWDS_clickable')
  }
}
TWDS.registerStartFunc(function () {
  TWDS.registerSetting('bool', 'quickusables',
    TWDS._('QUICKUSABLES_SETTING',
      'Un clic en la barra de energía abre una seleccion de buffs.'),
    true, TWDS.quickusables.settingchanged, 'Miscelánea', null)
})
// vim: tabstop=2 shiftwidth=2 expandtab
//
// i'd have liked to use <progress>, but i can't style it as i want it (background-color is a must, for i
// want to add a text to the meter, and i need to know the colors to get contrast).
//

if ('trackbar' in TWDS) {
  console.log('eliminando cosas viejas de la barra de seguimiento')
  window.clearInterval(TWDS.trackbar.interval)
  TWDS.trackbar.settingchanged(false)
  setTimeout(TWDS.trackbar.settingchanged, 250)
}
TWDS.trackbar = {}
TWDS.trackbar.container = null
TWDS.trackbar.status = 0
TWDS.trackbar.interval = -1
TWDS.trackbar.last_background_run = 0

TWDS.trackbar.datachange_listener = function (x) {
  TWDS.trackbar.status = 2
}
TWDS.trackbar.setuplisteners = function (x) {
  let fn = 'listen'
  if (x === false) { fn = 'unlisten' }
  const events = ['inventory_changed', 'trader_item_selled', 'bad_add',
    'character_tracking_achievement_changed', 'character_exp_changed',
    'character_level_up',
    'twds_storage_tracking_changed']

  for (let i = 0; i < events.length; i++) {
    EventHandler[fn](events[i], TWDS.trackbar.datachange_listener)
  }
}

TWDS.trackbar.setonetrackerdata = function (ele, have, want) {
  ele.dataset.have = have
  if (want !== null) { ele.dataset.want = want }
}
TWDS.trackbar.createOneTracker = function (cl, have, want, name) {
  const m = TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_trackbar_tracker ' + cl,
    dataset: {
      progress: 0,
      name: name
    }
  })
  m.onclick = TWDS.trackbar.click
  TWDS.trackbar.setonetrackerdata(m, have, want)
  return m
}

TWDS.trackbar.backgroundjob = function () {
  const updateOneTracker = function (ele) {
    const have = ele.dataset.have
    const want = ele.dataset.want
    if (typeof want === 'string' && isNaN(parseInt(want))) {
      // infinity image for XP… Character.getMaxExperience4Level() does that.
      ele.dataset.text = ''
      ele.title = want
      ele.style = '--twds-progress: ' + 100 + '%'
      return
    }
    const percent = (100 * have / want).toFixed(1)
    let todo
    if (want === have) todo = ''
    else todo = ' (' + (want - have) + ')'

    ele.title = percent + '%: ' + have + ' / ' + want + ' ' + ele.dataset.name + todo
    ele.style = '--twds-progress: ' + percent + '%'
    ele.dataset.text = percent + '%' + todo
  }

  if (!TWDS.settings.trackbar) { return }
  if (TWDS.trackbar.status === 0) {
    const stich = new Date().getTime() - 60 * 10000
    if (TWDS.trackbar.last_background_run > stich) {
      return
    }
  } else {
    TWDS.trackbar.status--
  }

  // check if all trackers exist.
  let e = TWDS.q1('.TWDS_trackbar_achievement')
  const status = Character.getTrackingAchievement()
  if (status !== undefined) {
    if (!e) {
      e = TWDS.trackbar.createOneTracker('TWDS_trackbar_achievement',
        status.current, status.required, status.title)
      const xp = TWDS.q1('.TWDS_trackbar_xp', TWDS.trackbar.container)
      if (xp) {
        // we might run really early!
        xp.insertAdjacentElement('afterend', e)
      }
    }
  } else {
    if (e) {
      e.remove()
    }
  }

  let st = TWDS.q1('.TWDS_trackbar_storage', TWDS.trackbar.container)
  const withstorage = TWDS.settings.trackbar_storage
  if (withstorage) {
    if (!st) {
      const sum = TWDS.storage.getsummary()
      if (sum.required) {
        st = TWDS.trackbar.createOneTracker('TWDS_trackbar_storage',
          sum.current, sum.required, 'products')
        const ac = TWDS.q1('.TWDS_trackbar_achievement', TWDS.trackbar.container)
        if (ac) {
          ac.insertAdjacentElement('afterend', st)
        } else {
          const xp = TWDS.q1('.TWDS_trackbar_xp', TWDS.trackbar.container)
          if (xp) {
            // we might run really early!
            xp.insertAdjacentElement('afterend', st)
          }
        }
      }
    }
  } else {
    if (st) st.remove()
  }

  const plist = TWDS.storage.gettracked()
  for (let i = 0; i < plist.length; i++) {
    const id = plist[i]
    const want = TWDS.storage.gettarget(id)
    const count = Bag.getItemCount(id)
    let e = TWDS.q(".TWDS_trackbar_product[data-product='" + id + "']")
    if (!e.length) {
      e = TWDS.trackbar.createOneTracker('TWDS_trackbar_product',
        count, want, ItemManager.get(id).name)
      e.dataset.product = id
      TWDS.trackbar.container.appendChild(e)
    }
  }
  const all = TWDS.q('.TWDS_trackbar_tracker', TWDS.trackbar.container)

  // update the displayed data
  for (let i = 0; i < all.length; i++) {
    const e = all[i]
    if (e.classList.contains('TWDS_trackbar_xp')) {
      TWDS.trackbar.setonetrackerdata(e,
        Character.getExperience4Level(), Character.getMaxExperience4Level())
    } else if (e.classList.contains('TWDS_trackbar_achievement')) {
      const status = Character.getTrackingAchievement()
      if (status !== undefined) {
        TWDS.trackbar.setonetrackerdata(e, status.current, status.required)
      } else {
        e.remove()
        continue
      }
    } else if (e.classList.contains('TWDS_trackbar_storage')) {
      const sum = TWDS.storage.getsummary()
      TWDS.trackbar.setonetrackerdata(e, sum.current, sum.required)
    } else if (e.classList.contains('TWDS_trackbar_product')) {
      const id = e.dataset.product
      const count = Bag.getItemCount(id)
      TWDS.trackbar.setonetrackerdata(e, count, null)
    } else {
      continue // something else.
    }
    updateOneTracker(e)
  }
}

TWDS.trackbar.click = function (e) {
  if (this.classList.contains('TWDS_trackbar_xp')) { return }
  if (this.classList.contains('TWDS_trackbar_storage')) { TWDS.opentab('storage') }
  if (this.classList.contains('TWDS_trackbar_achievement')) {
    // Character.untrackAchievement
    const status = Character.getTrackingAchievement()
    if (status !== undefined) {
      const c = 'Estás a punto de dejar de seguir este logro: ' + status.title
      new west.gui.Dialog(TWDS._('TRACKBAR_UNTRACK_TITLE', '¿Parar el seguimiento?'),
        '', west.gui.Dialog.SYS_WARNING).setText(c).addButton('¿Parar?', function () {
        Character.untrackAchievement()
      }).addButton('Cancelar').show()
    } else {
      this.remove() // achievement tracking endet externally.
    }
  }
  if (this.classList.contains('TWDS_trackbar_product')) {
    // Character.untrackAchievement
    const pr = this.dataset.product
    let name
    try {
      name = ItemManager.get(pr).name
    } catch (e) {
      name = 'some product'
    }
    if (TWDS.storage.istracked(pr)) {
      const c = 'Estás a punto de dejar de seguir este producto: ' + name
      new west.gui.Dialog(TWDS._('TRACKBAR_UNTRACK_TITLE', '¿Parar el seguimiento?'),
        '', west.gui.Dialog.SYS_WARNING).setText(c).addButton('¿Parar?', function () {
        TWDS.storage.untrack(pr)
      }).addButton('Cancelar').show()
    } else {
      this.remove() // achievement tracking endet externally.
    }
  }
}

TWDS.trackbar.settingchanged = function (v) {
  if (!ItemManager.isLoaded()) {
    window.setTimeout(TWDS.trackbar.settingchanged, 100)
    return
  }
  if (v === undefined || v === null) {
    v = TWDS.settings.trackbar
  }
  // first cleanup.
  const ui = TWDS.q1('#user-interface') // a container
  ui.classList.remove('TWDS_trackbar_active')
  const origele = TWDS.q1('#ui_experience_bar') // the original exp bar
  origele.style.display = 'block'

  const forget = TWDS.q1('#TWDS_trackbar_container')
  if (forget) { forget.remove() }
  TWDS.trackbar.container = null

  window.clearInterval(TWDS.trackbar.interval)
  if (v) {
    TWDS.trackbar.setuplisteners(true)
  } else {
    TWDS.trackbar.setuplisteners(false)
  }
  console.log('SC', v)

  if (v) {
    origele.style.display = 'none'
    const e = TWDS.createEle({
      nodeName: 'div',
      id: 'TWDS_trackbar_container'
    })
    TWDS.trackbar.container = e
    ui.appendChild(e)
    ui.classList.add('TWDS_trackbar_active')
    const m = TWDS.trackbar.createOneTracker('TWDS_trackbar_xp',
      Character.getExperience4Level(), Character.getMaxExperience4Level(), 'XP')
    e.appendChild(m)

    TWDS.trackbar.backgroundjob()
    TWDS.trackbar.interval = window.setInterval(TWDS.trackbar.backgroundjob, 200)
  }
}

TWDS.registerStartFunc(function () {
  TWDS.registerSetting('bool', 'trackbar_storage',
    TWDS._('TRACKBAR_SETTING',
      'Agregar una barra de seguimiento capaz de rastrear la experiencia, los logros y los productos juntos.'),
    true, function () { TWDS.trackbar.settingchanged() }, 'Miscelánea', 'Barra de seguimiento')
  TWDS.registerSetting('bool', 'trackbar_storage',
    TWDS._('TRACKBAR_SETTING_STORAGESUMMARY',
      'Mostrar un resumen del almacenamiento (pestaña) en la barra de seguimiento.'),
    true, null, 'Miscelánea', 'Barra de seguimiento')
  TWDS.trackbar.setuplisteners(true)
})
// vim: tabstop=2 shiftwidth=2 expandtab
//

TWDS.quicksilver = {}

TWDS.quicksilver.getAdditionalClasses = function (tileX, tileY) {
  const jobs = JobList.getJobsByGroupId(this.groupId)
  const tileSize = Map.tileSize
  const pos = {
    x: tileX * tileSize + this.left,
    y: tileY * tileSize + this.top
  }
  const xtra = Map.JobHandler.Featured[pos.x + '-' + pos.y] || {}
  let flag = 0
  for (const i in jobs) {
    if (!Object.prototype.hasOwnProperty.call(jobs, i)) { continue }
    const dyn = xtra[jobs[i].id]
    if (dyn) {
      if (dyn.silver) flag |= 1
      if (dyn.gold) flag |= 2
    }
  }
  let add = ''
  if (flag & 2) add += ' TWDS_gold'
  if (flag & 1) add += ' TWDS_silver'
  return 'posx-' + pos.x +
         ' posy-' + pos.y +
         ' jobgroup jobgroup-' + this.groupId +
         add
}
TWDS.registerStartFunc(function () {
  if (!('_twds_backup_getAdditionalClasses' in Map.Component.JobGroup.prototype)) {
    Map.Component.JobGroup.prototype._twds_backup_getAdditionalClasses =
      Map.Component.JobGroup.prototype.getAdditionalClasses
  }
  TWDS.registerSetting('bool', 'quicksilver',
    TWDS._('QUICKSILVER_SETTING',
      'Marcar los trabajos de plata y oro en el mapa mundial.'),
    false, function (v) {
      if (v) {
        Map.Component.JobGroup.prototype.getAdditionalClasses = TWDS.quicksilver.getAdditionalClasses
      } else {
        Map.Component.JobGroup.prototype.getAdditionalClasses =
          Map.Component.JobGroup.prototype._twds_backup_getAdditionalClasses
      }
    }, 'Mapa', null)
  TWDS.registerSetting('bool', 'quicksilver_exclamation_mark',
    TWDS._('QUICKSILVER_SETTING_EXCLAMATION',
      'Al marcar trabajos de plata y oro, utilice un signo de exclamación.'),
    false, function (v) {
      if (v) {
        document.body.classList.add('TWDS_quicksilver_exclamation')
      } else {
        document.body.classList.remove('TWDS_quicksilver_exclamation')
      }
    }, 'Mapa', null)
})
// vim: tabstop=2 shiftwidth=2 expandtab

TWDS.showset = {}
TWDS.showset.getExportValueWithJob = function (extractor, bon) {
  const x = extractor.getExportValue(bon)
  // getExportValue is stupid
  if (x.key === 'job') {
    if (bon.type === 'character') {
      x.key = 'job_' + bon.bonus.job
    } else {
      x.key = 'job_' + bon.job
    }
  }
  return x
}
TWDS.showset.getcontent = function (win) {
  const key = win._TWDS_key
  const level = parseInt(win._TWDS_level)
  const set = west.storage.ItemSetManager.get(key)
  const subtype = win._TWDS_sub_type // shot, hand

  const content = TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_showset_content'
  })
  const selectors = TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_showset_selectors',
    last: content
  })
  const levelselector = TWDS.createEle({
    nodeName: 'select',
    onchange: function () {
      win._TWDS_level = this.value
      TWDS.showset.reload(win)
    },
    style: {
      display: 'block'
    },
    last: selectors
  })
  TWDS.createEle({
    nodeName: 'select',
    onchange: function () {
      win._TWDS_sub_type = this.value
      TWDS.showset.reload(win)
    },
    style: {
      display: 'block'
    },
    last: selectors,
    children: [
      { nodeName: 'option', value: 'shot', selected: subtype === 'shot', textContent: TWDS._('SHOTWEAPON', 'Arma Fuego') },
      { nodeName: 'option', value: 'hand', selected: subtype !== 'shot', textContent: TWDS._('HANDWEAPON', 'Arma Contundente') }
    ]
  })

  const selopts = []
  selopts[0] = TWDS._('SHOWSET_SELECT_LEVEL', 'Seleccionar nivel')
  selopts[100] = '100'
  selopts[125] = '125'
  selopts[150] = '150'
  selopts[250] = '250'
  selopts[Character.level] = Character.level
  for (let i = 0; i <= 250; i++) {
    const str = selopts[i]
    if (str) {
      let selected = false
      if (i === level) { selected = true }
      levelselector.appendChild(TWDS.createElement({
        nodeName: 'option',
        value: i,
        textContent: str,
        selected: selected
      }))
    }
  }
  let dummyChar = null
  if (level) {
    dummyChar = {
      level: level
    }
  }

  const topcontainer = TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_topcontainer',
    last: content
  })
  const theresult = TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_resultcontainer',
    last: topcontainer
  })
  const theset = TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_setcontainer',
    last: topcontainer
  })

  function fixDescNumber (r) {
    if (r.type === 'character') {
      r.desc = r.desc.replace(/([0-9.]+)/, r.bonus.value.toFixed(2))
    }
  }

  const extractor = new west.item.BonusExtractor(dummyChar)
  const extractor1 = new west.item.BonusExtractor({ level: 1 })
  let numitems = 0
  for (let i = 0; i < set.items.length; i++) {
    const checkvalue = Math.pow(2, i)
    const item = ItemManager.getByBaseId(set.items[i])
    if (item.type === 'right_arm') {
      if (item.sub_type !== subtype) { continue }
    }
    if (win._TWDS_items & checkvalue) { numitems++ }
  }

  const setbonuses = set.getMergedStages(numitems)
  const leveledresult = {}
  //
  setbonuses.sort(function (a, b) {
    const isSomething = function (b, x) {
      return (b.bonus ? b.bonus.type : b.type) === x ? (b.bonus ? b.bonus.name : b.name) : false
    }
    const aIsAttr = isSomething(a, 'attribute')
    const bIsAddr = isSomething(b, 'attribute')
    const aIsSkill = isSomething(a, 'skill')
    const bIsSkill = isSomething(b, 'skill')
    if (aIsAttr && bIsAddr) {
      return aIsAttr < bIsAddr ? -1 : 1
    }
    if (aIsAttr) return -1
    if (bIsAddr) return 1
    if (aIsSkill && bIsSkill) return 0
    if (aIsSkill) return -1
    if (bIsSkill) return 1
    return 0
  })
  if (setbonuses !== null && setbonuses.length > 0) {
    TWDS.createEle({ nodeName: 'br', last: theset })
    TWDS.createEle({ nodeName: 'br', last: theset })
    TWDS.createEle({
      nodeName: 'div',
      className: 'item_set_bonus',
      children: [
        {
          nodeName: 'span',
          className: 'text_bold',
          textContent: 'Set Bonus: ' + numitems
        },
        { nodeName: 'br' }
      ],
      last: theset
    })
    const ul = TWDS.createEle(
      {
        nodeName: 'ul',
        className: 'inventory_popup_bonus_skills',
        last: theset
      })
    for (let i = 0; i < setbonuses.length; i++) {
      fixDescNumber(setbonuses[i])
      TWDS.createEle({
        nodeName: 'li',
        className: 'tw_green',
        textContent: extractor.getDesc(setbonuses[i]),
        last: ul
      })
      // getExportValue is stupid
      const x = TWDS.showset.getExportValueWithJob(extractor, setbonuses[i])
      if (x.key in leveledresult) {
        leveledresult[x.key] += x.value
      } else {
        leveledresult[x.key] = x.value
      }
    }
  }

  content.appendChild(TWDS.createEle({ nodeName: 'hr' }))
  const ct = TWDS.createEle({ nodeName: 'div', className: 'TWDS_itemcontainer' })
  content.appendChild(ct)

  const result = JSON.parse(JSON.stringify(setbonuses)) // deep clone

  const merge = function (b) {
    let found = false
    for (let i = 0; i < result.length; i++) {
      const r = result[i]
      if (r.type !== b.type) continue
      if (b.type === 'character') {
        if (r.key !== b.key) continue
        if (r.bonus.type !== b.bonus.type) continue
        if (r.bonus.name !== b.bonus.name) continue
        r.bonus.value += b.bonus.value
        found = true
        break
      }
      if (b.type !== r.type) continue
      r.value += b.value
      found = true
    }
    if (!found) {
      result.push(JSON.parse(JSON.stringify(b)))
    }
  }

  for (let i = 0; i < set.items.length; i++) {
    const itemlevel = win._TWDS_itemlevels[i] || 0
    const leveledid = itemlevel + 1000 * set.items[i]
    const item = ItemManager.get(leveledid)
    if (item.type === 'right_arm') {
      if (item.sub_type !== subtype) { continue }
    }
    const p = new ItemPopup(item, {
      character: dummyChar
    })
    const tmp = TWDS.createEle({
      nodeName: 'div',
      className: 'TWDS_item',
      innerHTML: p.popup.text
    })

    const checkvalue = Math.pow(2, i)
    const checked = win._TWDS_items & checkvalue

    TWDS.createEle({
      nodeName: 'input',
      type: 'checkbox',
      value: checkvalue,
      checked: checked,
      onchange: function (ev) {
        const v = this.value
        if (this.checked) {
          win._TWDS_items |= v
        } else {
          win._TWDS_items &= ~v
        }
        TWDS.showset.reload(win)
      },
      first: tmp
    })
    TWDS.createEle({
      nodeName: 'select',
      type: 'checkbox',
      value: itemlevel,
      dataset: {
        idx: i
      },
      children: [
        { nodeName: 'option', value: 0, textContent: 0, selected: itemlevel === 0 },
        { nodeName: 'option', value: 1, textContent: 1, selected: itemlevel === 1 },
        { nodeName: 'option', value: 2, textContent: 2, selected: itemlevel === 2 },
        { nodeName: 'option', value: 3, textContent: 3, selected: itemlevel === 3 },
        { nodeName: 'option', value: 4, textContent: 4, selected: itemlevel === 4 },
        { nodeName: 'option', value: 5, textContent: 5, selected: itemlevel === 5 }
      ],
      onchange: function (ev) {
        const v = parseInt(this.value)
        win._TWDS_itemlevels[i] = v
        TWDS.showset.reload(win)
      },
      first: tmp
    })
    ct.appendChild(tmp)
    if (win._TWDS_items & checkvalue) {
      const ex = new west.item.BonusExtractor(dummyChar, win._TWDS_itemlevels[i])
      if (item.bonus.item.length) {
        for (let k = 0; k < item.bonus.item.length; k++) {
          const b = item.bonus.item[k]
          if (b.type === 'damage' || (b.type === 'character' && b.bonus.type === 'damage')) { continue }
          merge(b)
          // getExportValue is stupid
          const x = TWDS.showset.getExportValueWithJob(ex, b)
          if (x.key in leveledresult) {
            leveledresult[x.key] += x.value
          } else {
            leveledresult[x.key] = x.value
          }
        }
      }
    }
  }

  TWDS.createEle({
    nodeName: 'div',
    className: 'item_set_bonus',
    children: [
      {
        nodeName: 'span',
        className: 'text_bold',
        textContent: 'Total Bonus:'
      },
      { nodeName: 'br' }
    ],
    last: theresult
  })

  result.sort(function (a, b) {
    const isSomething = function (b, x) {
      return (b.bonus ? b.bonus.type : b.type) === x ? (b.bonus ? b.bonus.name : b.name) : false
    }
    const aIsAttr = isSomething(a, 'attribute')
    const bIsAddr = isSomething(b, 'attribute')
    const aIsSkill = isSomething(a, 'skill')
    const bIsSkill = isSomething(b, 'skill')
    if (aIsAttr && bIsAddr) {
      return aIsAttr < bIsAddr ? -1 : 1
    }
    if (aIsAttr) return -1
    if (bIsAddr) return 1
    if (aIsSkill && bIsSkill) return 0
    if (aIsSkill) return -1
    if (bIsSkill) return 1
    return 0
  })
  if (result !== null && result.length > 0) {
    const ul = TWDS.createEle(
      {
        nodeName: 'ul',
        className: 'inventory_popup_bonus_skills',
        last: theresult
      })
    for (let i = 0; i < result.length; i++) {
      // getExportValue is stupid
      const x = TWDS.showset.getExportValueWithJob(extractor, result[i])
      let output
      if (level === 0) {
        fixDescNumber(result[i])
        output = extractor.getDesc(result[i])
      } else {
        if ('value' in result[i]) {
          result[i].value = leveledresult[x.key]
        } else {
          result[i].bonus.value = leveledresult[x.key]
        }
        output = extractor1.getDesc(result[i])
      }
      TWDS.createEle({
        nodeName: 'li',
        className: 'tw_green',
        textContent: output,
        last: ul
      })
    }
  }
  return content
}
TWDS.showset.open = function (key, checkowned) {
  const set = west.storage.ItemSetManager.get(key)
  const wid = 'TWDS_showset_' + key
  const win = wman.open(wid, 'set', 'TWDS_showset')
  win.setTitle(set.name)
  if (!win._TWDS_key) {
    win._TWDS_key = key
    win._TWDS_level = Character.level
    win._TWDS_items = 65535
    win._TWDS_sub_type = 'shot'
    win._TWDS_itemlevels = []
  }
  if (checkowned) {
    win._TWDS_items = 0
    for (let i = 0; i < set.items.length; i++) {
      const checkvalue = Math.pow(2, i)
      const blist = Bag.getItemsByBaseItemId(set.items[i])
      win._TWDS_itemlevels[i] = 0
      if (blist.length) {
        win._TWDS_items |= checkvalue
        win._TWDS_itemlevels[i] = blist[0].obj.item_level
      }
    }
  } else {
    for (let i = 0; i < set.items.length; i++) {
      win._TWDS_itemlevels[i] = 0
    }
  }

  const sp = new west.gui.Scrollpane()
  const content = TWDS.showset.getcontent(win)
  sp.appendContent(content)

  win.appendToContentPane(sp.getMainDiv())
}
TWDS.showset.reload = function (win) {
  const content = TWDS.showset.getcontent(win)
  const old = TWDS.q1('.TWDS_showset_content', win.getMainDiv())
  const sp = old.parentNode
  sp.innerHTML = ''
  sp.appendChild(content)
}
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.overlay = {}
TWDS.overlay.eq = null
TWDS.overlay.getEquipmentData = function (noskills) {
  TWDS.overlay.eq = null // for now
  if (TWDS.overlay.eq === null) {
    const data = TWDS.getEquipmentData(noskills)
    TWDS.overlay.eq = JSON.parse(data[1])
  }
  return TWDS.overlay.eq
}
TWDS.overlay.interpret = function (work) {
  TWDS.overlay.eq = null
  for (let i = 0; i < TWDS.overlay.patterns.length; i++) {
    const triple = TWDS.overlay.patterns[i]
    work = work.replace(triple[0], triple[2])
  }
  return work
}
TWDS.overlay.show = function () {
  while (true) {
    const x = TWDS.q1('.TWDS_overlay')
    if (x) x.remove()
    else break
  }
  const windows = TWDS.q1('#windows')

  let pos = window.localStorage.TWDS_overlay_pos
  if (pos) pos = JSON.parse(pos)
  else {
    pos = {
      left: 210,
      top: 10
    }
  }
  TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_overlay',
    draggable: true,
    children: [
      { nodeName: 'div', className: 'basedata' },
      { nodeName: 'div', className: 'dueldata' },
      { nodeName: 'div', className: 'bonusdata' },
      { nodeName: 'div', className: 'battledata' },
      { nodeName: 'div', className: 'event' },
      { nodeName: 'div', className: 'note', contentEditable: true }
    ],
    beforeend: windows
  })
  TWDS.overlay.reposition(pos)
  TWDS.overlay.update()
}
TWDS.overlay.getbasedata = function () {
  let s =
      Game.InfoHandler.getLocalString4Charclass(Character.charClass) +
   ' ' + Character.level + ', ' +
      Game.InfoHandler.getLocalString4ProfessionId(Character.professionId)
  if (Character.professionId !== null) { s += ' ' + Character.professionSkill }
  s += ', ' + TWDS._('SPEED', 'Speed') + ' ' + Math.round(TWDS.bonuscalc.getSpeed()) + '%'
  return s
}
/*
TWDS.overlay.getregendata = function () {
  let dur = ((Character.maxEnergy - Character.energy) / (Character.energyRegen * Character.maxEnergy) * 3600)
  const now = new Date().getTime()
  let d1, d2
  if (dur > 12 * 3600) {
    d1 = new Date(now + dur * 1000).toLocaleString()
  } else {
    d1 = new Date(now + dur * 1000).toLocaleTimeString()
  }
  dur = ((Character.maxHealth - Character.health) / (Character.healthRegen * Character.maxHealth) * 3600)
  if (dur > 12 * 3600) {
    d2 = new Date(now + dur * 1000).toLocaleString()
  } else {
    d2 = new Date(now + dur * 1000).toLocaleTimeString()
  }
  let s = TWDS._('OVERLAY_FULL_HEALTH', 'Salud completa') + ': ' + d2 + '<br>'
  s += TWDS._('OVERLAY_FULL_ENERGY', 'Energía completa') + ': ' + d1
  return s
}
*/
TWDS.overlay.getbattledata = function () {
  const getone = function (x) {
    const y = CharacterSkills.getSkill(x)
    return y.bonus + y.points // bonus: skill. points: attr
  }

  const prem = Number(Premium.hasBonus('character'))

  const health = Character.maxHealth
  const level = Character.level

  const dodge = getone('dodge')
  const aim = getone('aim')
  let lead = getone('leadership')
  const hide = getone('hide')
  const trap = getone('pitfall')
  const bo = TWDS.bonuscalc.getComboBonus()
  let multiplayerAttack = 0
  let multiplayerDefense = 0
  let sectorAttack = 0
  let sectorDefense = 0
  let sectorDamage = 0
  let fortResistance = 0

  if ('fort_attack' in bo) {
    multiplayerAttack += bo.fort_attack
  }
  if ('fortbattle_offense' in bo) {
    multiplayerAttack += bo.fortbattle_offense
  }

  if ('fort_defense' in bo) {
    multiplayerDefense += bo.fort_defense
  }
  if ('fortbattle_defense' in bo) {
    multiplayerDefense += bo.fortbattle_defense
  }

  if ('fort_offense_sector' in bo) {
    sectorAttack += bo.fort_offense_sector
  }
  if ('fortbattlesector_offense' in bo) {
    sectorAttack += bo.fortbattlesector_offense
  }

  if ('fort_defense_sector' in bo) {
    sectorDefense += bo.fort_defense_sector
  }
  if ('fortbattlesector_defense' in bo) {
    sectorDefense += bo.fortbattlesector_defense
  }

  if ('fort_resistance' in bo) {
    fortResistance += bo.fort_resistance
  }

  if ('fort_damage_sector' in bo) {
    sectorDamage += bo.fort_damage_sector
  }
  if ('fortbattlesector_damage' in bo) {
    sectorDamage += bo.fortbattlesector_damage
  }

  if (Character.charClass === 'soldier') {
    if (prem) { lead = lead * 1.5 } else { lead = lead * 1.25 }
  }

  const beginnerBonus = 15 * (1 - level / 250.0)

  let attAttack = Math.pow(lead, 0.5) +
    Math.pow(aim, 0.5) +
    Math.pow(hide, 0.6) +
    multiplayerAttack +
    sectorAttack +
    beginnerBonus +
    10
  attAttack *= 1.15
  let attDefend = Math.pow(lead, 0.5) +
    Math.pow(dodge, 0.5) +
    Math.pow(hide, 0.6) +
    multiplayerDefense +
    sectorDefense +
    beginnerBonus +
    10
  let defAttack = Math.pow(lead, 0.5) +
    Math.pow(aim, 0.5) +
    Math.pow(trap, 0.6) +
    multiplayerAttack +
    sectorAttack +
    beginnerBonus +
    10
  defAttack *= 1.15
  let defDefend = Math.pow(lead, 0.5) +
    Math.pow(dodge, 0.5) +
    Math.pow(trap, 0.6) +
    multiplayerDefense +
    sectorDefense +
    beginnerBonus +
    10
  const attPrimaryRes = 300 * hide / health
  const defPrimaryRes = 300 * trap / health
  const secondaryRes = fortResistance
  if (Character.charClass === 'worker') {
    let f
    if (prem) {
      f = 1.4
    } else {
      f = 1.2
    }
    attAttack *= f
    attDefend *= f
    defAttack *= f
    defDefend *= f
  }

  const la = Wear.get('left_arm')
  let dmg = {
    min: 0,
    max: 0
  }
  const basedmg = {
    min: 0,
    max: 0
  }
  if (la) {
    dmg = la.obj.getDamage(Character)
    basedmg.min = dmg.min
    basedmg.max = dmg.max
  }
  dmg.min += sectorDamage
  dmg.max += sectorDamage
  // console.log('DMG', dmg.min, lead, health, dmg.min * lead / health)
  dmg.min += dmg.min * lead / health
  dmg.max += dmg.max * lead / health

  let s = '<b>' + TWDS._('OVERLAY_FB_VALUES', 'Valores Batallas Fuerte') + '</b><br>'
  s += "<table class='TWDS_overlay_battledata'><tr>"
  s += '<td>' + TWDS._('OVERLAY_FB_ATT', 'Ataque')
  s += '<td>' + TWDS._('OVERLAY_FB_HIT', 'Acierto')
  s += '<td>' + Math.round(attAttack * 10) / 10
  s += '<td>' + TWDS._('OVERLAY_FB_DODGE', 'Eludir')
  s += '<td>' + Math.round(attDefend * 10) / 10
  s += '<td>' + TWDS._('OVERLAY_FB_RESISTANCE1', 'Habilidad Resist.')
  s += '<td>' + Math.round(attPrimaryRes * 10) / 10
  s += '<td>' + TWDS._('OVERLAY_FB_RESISTANCE2', 'Ropa Resist.')
  s += '<td>' + Math.round(secondaryRes * 10) / 10
  s += '<tr>'
  s += '<td>' + TWDS._('OVERLAY_FB_DEF', 'Defensa')
  s += '<td>' + TWDS._('OVERLAY_FB_HIT', 'Acierto')
  s += '<td>' + Math.round(defAttack * 10) / 10
  s += '<td>' + TWDS._('OVERLAY_FB_DODGE', 'Eludir')
  s += '<td>' + Math.round(defDefend * 10) / 10
  s += '<td>' + TWDS._('OVERLAY_FB_RESISTANCE1', 'Habilidad Resist.')
  s += '<td>' + Math.round(defPrimaryRes * 10) / 10
  s += '<td>' + TWDS._('OVERLAY_FB_RESISTANCE2', 'Ropa Resist.')
  s += '<td>' + Math.round(secondaryRes * 10) / 10
  s += '<tr>'
  s += "<td colspan='5'>" + TWDS._('OVERLAY_FB_DAMAGE', 'Daño')
  s += "<td colspan='4'>"
  s += Math.round(dmg.min) + '-' + Math.round(dmg.max)
  s += TWDS._('OVERLAY_FB_AVG', ', average') + ' '
  s += Math.round((dmg.min + dmg.max) / 2)
  s += '<tr>'
  s += "<td colspan='5'>" + TWDS._('OVERLAY_FB_BASE_DAMAGE', 'Daño no afectado por la resistencia de la ropa/conjunto')
  s += "<td colspan='4'>"
  s += Math.round(basedmg.min) + '-' + Math.round(basedmg.max)
  s += TWDS._('OVERLAY_FB_AVG', ', average') + ' '
  s += Math.round((basedmg.min + basedmg.max) / 2)
  s += '<tr>'
  s += '<td>' + TWDS._('OVERLAY_FB_SECT', 'Bonus Sector')
  s += '<td>' + TWDS._('OVERLAY_FB_DAMAGE', 'Daño')
  s += '<td>' + sectorDamage
  s += '<td>' + TWDS._('OVERLAY_FB_HIT', 'Acierto')
  s += '<td>' + sectorAttack
  s += '<td>' + TWDS._('OVERLAY_FB_DODGE', 'Eludir')
  s += '<td>' + sectorDefense
  s += '<td colspan="2">'
  s += '</table>'
  return s
}
TWDS.overlay.getdueldata = function () {
  const eq = TWDS.overlay.getEquipmentData(TWDS.settings.overlay_duel_noskills)
  let s
  s = TWDS._('DUEL_LEVEL', 'Duel level') + ' ' + Character.duelLevel +
    ' (' + Math.ceil(5 * Character.duelLevel / 7) + '-' + Math.ceil(7 * Character.duelLevel / 5) + ')'
  s += '<br>'
  s += TWDS.classifyEquipment(eq)
  s += '<table>'
  s += '<tr>'
  s += '<th>' + CharacterSkills.keyNames.appearance + '<td>' + eq.auft
  s += '<th>' + CharacterSkills.keyNames.tactic + '<td>' + eq.takt
  s += '<tr>'
  s += '<th>' + CharacterSkills.keyNames.aim + '<td>' + eq.ziel
  s += '<th>' + CharacterSkills.keyNames.dodge + '<td>' + eq.ausw
  s += '<tr>'
  s += '<th>' + CharacterSkills.keyNames[eq.shot ? 'shot' : 'punch']
  s += '<td>' + (eq.shot ? eq.schuss : eq.schlag)
  s += '<th>' + TWDS._('OVERLAY_RES_MELEE', 'Resist./Contundente') + '<td>' + eq.wid_schlag
  s += '<tr>'
  const dmg = ((eq.dmg_min + eq.dmg_max) / 2).toFixed(1)
  s += '<th>' + TWDS._('DAMAGE', 'Daño') + '<td>' + dmg
  s += '<th>' + TWDS._('OVERLAY_RES_SHOT', 'Resist./Fuego') + '<td>' + eq.wid_schuss
  s += '<tr>'
  s += '<th title="'
  s += TWDS._('OVERLAY_LEVELEQ_TITLE',
    'Necesitarías aproximadamente este nivel para alcanzar los valores mostrados sin equipo. Los puntos de vida no se tienen en cuenta.')
  s += '">'
  s += TWDS._('OVERLAY_LEVELEQ', '~Nivel')
  if (eq.leveleq_attack === eq.leveleq_defense) {
    s += '<td>'
    s += eq.leveleq_attack
  } else {
    s += '<td>' + eq.leveleq_attack
    s += '<th>'
    s += '<td>' + eq.leveleq_defense
  }
  s += '</table>'
  return s
}
TWDS.overlay.getbonusdata = function () {
  const bo = TWDS.bonuscalc.getComboBonus()
  const a = []
  if (bo.luck) a.push([bo.luck * 100, true, TWDS._('BONUS_LUCK', 'Suerte')])
  if (bo.dollar) a.push([bo.dollar * 100, true, TWDS._('BONUS_DOLLAR', 'Dinero')])
  if (bo.regen) a.push([bo.regen * 100, true, TWDS._('BONUS_REGEN', 'Regeneración')])
  if (bo.pray) a.push([bo.regen * 100, false, TWDS._('BONUS_PRAY', 'Rezar')])
  // if (bo.speed) a.push([bo.speed*100, 'speed'])
  if (bo.experience) a.push([bo.experience * 100, true, TWDS._('BONUS_EXPERIENCE', 'Experiencia')])
  if (bo.drop) a.push([bo.drop * 100, true, TWDS._('BONUS_DROP', 'Tasa salida producto')])

  a.sort(function (x, y) {
    return y[0] - x[0]
  })
  const b = []
  for (let i = 0; i < a.length; i++) {
    let perc = ''
    if (a[i][1]) { perc = '%' }

    b.push('+' + Math.round(a[i][0]) + perc + ' ' + a[i][2])
  }
  return b.join(', ')
}
TWDS.overlay.getnote = function () {
  let text = window.localStorage.TWDS_overlay_free
  if (!text) { text = 'clic para editar' }
  return text
}
TWDS.overlay.eventdata = null
TWDS.overlay.event_item_changed = function (payload) {
  console.log('overlay item_changed', payload)
  if (!TWDS.overlay.eventdata) return
  for (let i = 0; i < TWDS.overlay.eventdata.length; i++) {
    const d = TWDS.overlay.eventdata[i]
    if (d.item_id === payload.item_id) {
      d.limited_count = payload.limited_count
      d.limited_time = payload.limited_time
      TWDS.info('overlay: updated item', payload.item_id)
      TWDS.overlay.update()
      return
    }
  }
  if ((Date.now() / 1000) < payload.start_time) { return }
  TWDS.overlay.eventdata.push({
    item_id: payload.item_id,
    limited_count: payload.limited_count,
    limited_time: payload.limited_time
  })
  TWDS.info('overlay: new item', payload.item_id)
  TWDS.overlay.update()
}
TWDS.overlay.event_item_changed_wrapper = function (x) { TWDS.overlay.event_item_changed(x) }
TWDS.overlay.event_item_removed = function (itemid) {
  if (!TWDS.overlay.eventdata) return
  for (let i = 0; i < TWDS.overlay.eventdata.length; i++) {
    const d = TWDS.overlay.eventdata[i]
    if (d.item_id === itemid) {
      TWDS.overlay.eventdata.splice(i, 1)
      TWDS.overlay.update()
      TWDS.info('overlay: removed item', itemid)
      return
    }
  }
  TWDS.info('overlay: received item_removed for ', itemid, ', which was not in our list')
  console.log('overlay: received item_removed for ', itemid, ', which was not found in', TWDS.overlay.eventdata)
  TWDS.overlay.update()
}
TWDS.overlay.event_item_removed_wrapper = function (x) { TWDS.overlay.event_item_removed(x) }
TWDS.overlay.loadeventdatarunning = false
TWDS.overlay.loadeventdata = function () {
  if (TWDS.overlay.loadeventdatarunning) return
  TWDS.overlay.loadeventdatarunning = true
  Ajax.remoteCallMode('shop_trader', 'index', {
    source: 'bottom_bar'
  }, function (json) {
    TWDS.overlay.loadeventdatarunning = false
    if (json.error) {
      return
    }
    if (!json.inventory) return
    if (!json.inventory.hot) return
    const a = []
    for (let i = 0; i < json.inventory.hot.length; i++) {
      const d = json.inventory.hot[i]
      if (d.limited_time && d.limited_count) {
        a.push({
          item_id: d.item_id,
          limited_time: d.limited_time,
          limited_count: d.limited_count
        })
      }
    }
    TWDS.overlay.eventdata = a
    TWDS.overlay.update()
    TWDS.info('overlay: loaded event data')
  })
}
TWDS.overlay.getevent = function () {
  if (!TWDS.overlay.eventdata) {
    TWDS.overlay.loadeventdata()
    return
  }
  const out = TWDS.createEle('div', {})
  for (let i = 0; i < TWDS.overlay.eventdata.length; i++) {
    const d = TWDS.overlay.eventdata[i]
    const it = ItemManager.get(d.item_id)
    if (!it) continue
    const ts = new Date(d.limited_time * 1000).toDateTimeString()
    if (out.children.length === 0) {
      TWDS.createEle({
        nodeName: 'span',
        textContent: 'Shop:',
        last: out
      })
    }
    TWDS.createEle({
      nodeName: 'span.iteminfo',
      textContent: it.name,
      title: d.limited_count + ' left, until ' + ts,
      last: out
    })
  }
  return out.innerHTML
}
TWDS.overlay.update = function () {
  const cfg = [
    ['overlay_basics', '.TWDS_overlay .basedata', TWDS.overlay.getbasedata],
    ['overlay_duel', '.TWDS_overlay .dueldata', TWDS.overlay.getdueldata],
    ['overlay_bonus', '.TWDS_overlay .bonusdata', TWDS.overlay.getbonusdata],
    ['overlay_fortbattle', '.TWDS_overlay .battledata', TWDS.overlay.getbattledata],
    ['overlay_event', '.TWDS_overlay .event', TWDS.overlay.getevent],
    ['overlay_note', '.TWDS_overlay .note', TWDS.overlay.getnote]
  ]
  for (let i = 0; i < cfg.length; i++) {
    const sn = cfg[i][0]
    const sel = cfg[i][1]
    const cb = cfg[i][2]
    const e = TWDS.q1(sel)
    if (e) { // the thing might not be in the dom.
      if (TWDS.settings[sn]) {
        e.innerHTML = cb()
        e.style.display = 'block'
      } else {
        e.style.display = 'none'
      }
    }
  }
}
TWDS.overlay.blur = function (ev) {
}
TWDS.overlay.reposition = function (pos) {
  const ele = TWDS.q1('.TWDS_overlay')
  if (!ele) { return }
  ele.style.left = ''
  ele.style.top = ''
  ele.style.bottom = ''
  ele.style.right = ''
  if (pos.top) ele.style.top = pos.top + 'px'
  if (pos.bottom) ele.style.bottom = pos.bottom + 'px'
  if (pos.left) ele.style.left = pos.left + 'px'
  if (pos.right) ele.style.right = pos.right + 'px'
}
TWDS.overlay.inputevent = function (ev) {
  const text = TWDS.q1('.TWDS_overlay .note').innerHTML
  window.localStorage.TWDS_overlay_free = text
  ev.preventDefault()
  return true
}
TWDS.overlay.click = function (ev) {
  if (ev.target.closest('.TWDS_overlay .note')) { return }
  TWDS.opentab('settings', "[data-setting-name='overlay_use']")
}
TWDS.overlay.dragstart = function (ev) {
  TWDS.overlay.xoff = ev.offsetX
  TWDS.overlay.yoff = ev.offsetY
}
TWDS.overlay.cbchange = function () {
  TWDS.overlay.update()
}
TWDS.overlay.dragend = function (ev) {
  const ele = TWDS.q1('.TWDS_overlay')
  const bound = ele.getBoundingClientRect()
  const x = ev.clientX - TWDS.overlay.xoff
  const y = ev.clientY - TWDS.overlay.yoff
  const pos = { }
  if (x > window.innerWidth / 2) {
    pos.right = window.innerWidth - x - bound.width
  } else {
    pos.left = x
  }
  if (y > window.innerHeight / 2) {
    pos.bottom = window.innerHeight - y - bound.height
  } else {
    pos.top = y
  }
  window.localStorage.TWDS_overlay_pos = JSON.stringify(pos)
  TWDS.overlay.reposition(pos)
}

TWDS.overlay.settingchanged = function () {
  const ele = TWDS.q1('.TWDS_overlay')
  if (!TWDS.settings.overlay_use) {
    if (ele) ele.remove()
    return
  }
  if (!ele) {
    TWDS.overlay.show()
  }
  TWDS.overlay.update()
}

TWDS.registerStartFunc(function () {
  TWDS.registerSetting('bool', 'overlay_use', 'Mostrar una información transparente en la pantalla.',
    false, TWDS.overlay.settingchanged, 'Transparencia', null, 1)
  TWDS.registerSetting('bool', 'overlay_basics', 'Mostrar información básica en la transparencia (Clase, profesión, niveles).',
    true, TWDS.overlay.settingchanged, 'Transparencia', null, 2)
  TWDS.registerSetting('bool', 'overlay_duel', 'Mostrar información de duelo en la transparencia (sus valores con el equipo actual).',
    true, TWDS.overlay.settingchanged, 'Transparencia', null, 3)
  TWDS.registerSetting('bool', 'overlay_duel_noskills', 'Mostrar información de duelo sin habilidades (equipo puro).',
    true, TWDS.overlay.settingchanged, 'Transparencia', null, 4)
  TWDS.registerSetting('bool', 'overlay_bonus', 'Mostrar información de bonus en la transparencia (bonus del equipo actual).',
    true, TWDS.overlay.settingchanged, 'Transparencia', null, 5)
  TWDS.registerSetting('bool', 'overlay_fortbattle', 'Mostrar los valores de batalla en la transparencia (valores de batalla con equipo actual).',
    false, TWDS.overlay.settingchanged, 'Transparencia', null, 6)
  TWDS.registerSetting('bool', 'overlay_event', 'Mostrar información específica del evento (trabajo en curso).',
    false, TWDS.overlay.settingchanged, 'Transparencia', null, 7)
  TWDS.registerSetting('bool', 'overlay_note', 'Mostrar un bloc de notas editable en la transparencia.',
    true, TWDS.overlay.settingchanged, 'Transparencia', null, 8)

  let utimeout = 0
  // inventory_changed is called after crafting, when the craft skill may have changed.
  window.EventHandler.listen(['wear_changed', 'inventory_changed', 'character_level_up'], function () {
    // avoid calculating 10 times during a wear change
    if (utimeout) clearTimeout(utimeout)
    utimeout = setTimeout(function () {
      TWDS.overlay.update()
    }, 500)
  })
  window.EventHandler.listen(['pshop_item_changed'], function (payload) {
    TWDS.overlay.event_item_changed_wrapper(payload)
  })
  window.EventHandler.listen(['pshop_item_removed'], function (payload) {
    TWDS.overlay.event_item_removed_wrapper(payload)
  })

  TWDS.delegate(document, 'click', '.TWDS_overlay', function (ev) {
    TWDS.overlay.click(ev)
  })
  TWDS.delegate(document, 'click', '.TWDS_overlay input[type=checkbox]', function (ev) {
    TWDS.overlay.cbchange(ev)
  })
  TWDS.delegate(document, 'input', '.TWDS_overlay [contenteditable]', function (ev) {
    TWDS.overlay.inputevent(ev)
  })
  TWDS.delegate(document, 'dragstart', '.TWDS_overlay', function (ev) {
    TWDS.overlay.dragstart(ev)
  })
  TWDS.delegate(document, 'dragend', '.TWDS_overlay', function (ev) {
    TWDS.overlay.dragend(ev)
  })
})
// vim: tabstop=2 shiftwidth=2 expandtab

TWDS.craftcalc = {}
TWDS.craftcalc.searchitem = function (str) {
}
TWDS.craftcalc.getcontent = function (win) {
  const content = TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_craftcalc_content'
  })
  const inputarea = TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_craftcalc_inputarea',
    last: content
  })
  TWDS.createEle({
    nodeName: 'input',
    type: 'number',
    onchange: function () {
      win._TWDS_number = this.value
      TWDS.craftcalc.reload(win)
    },
    style: {
      display: 'inline-block'
    },
    placeholder: TWDS._('CRAFTCALC_NUMBER', '#'),
    title: TWDS._('CRAFTCALC_NUMBER_TITLE', 'Número de artículos que quiere crear'),
    value: win._TWDS_number,
    last: inputarea
  })
  const itemselector = TWDS.createEle({
    nodeName: 'select',
    onchange: function () {
      console.log('CHANGE', this, this.value)
      if (this.value) {
        win._TWDS_item = this.value
        win._TWDS_split = []
        TWDS.craftcalc.reload(win)
      }
    },
    style: {
      display: 'inline-block'
    },
    value: '',
    title: TWDS._('CRAFTCALC_ITEM_TITLE', 'Seleccione el artículo que quiere crear'),
    last: inputarea
  })
  console.log('DEREF is', win._TWDS_deref)
  const deref = parseInt(win._TWDS_deref)
  TWDS.createEle({
    nodeName: 'span',
    last: inputarea,
    style: {
      display: 'inline-block'
    },
    children: [
      {
        nodeName: 'select',
        children: [
          {
            nodeName: 'option',
            value: 0,
            textContent: TWDS._('CRAFTCALC_DEREF_BASE', 'a artículos básicos'),
            selected: deref === 0
          },
          {
            nodeName: 'option',
            value: 1,
            textContent: TWDS._('CRAFTCALC_DEREF_OTHER', 'a articulos que más a menudo tienen que elaborarse'),
            selected: deref === 1
          },
          {
            nodeName: 'option',
            value: 2,
            textContent: TWDS._('CRAFTCALC_DEREF_CRAFTED', 'a artículos elaborados'),
            selected: deref === 2
          }
        ],
        onchange: function () {
          win._TWDS_deref = this.value
          win._TWDS_split = []
          TWDS.craftcalc.reload(win)
        },
        style: {
          display: 'inline-block'
        }
      }
    ]
  })
  const a = win._TWDS_recipes
  const b = []
  const did = {}
  for (const recid of Object.keys(a)) {
    const itemid = a[recid]
    if (itemid in did) continue
    did[itemid] = true
    b.push([itemid, ItemManager.get(itemid).name, recid])
  }
  b.sort(function (a, b) {
    return a[1].trim().localeCompare(b[1].trim())
  })
  TWDS.createEle({
    nodeName: 'option',
    value: '',
    textContent: TWDS._('PLEASE_SELECT', 'por favor, seleccione'),
    last: itemselector
  })
  for (let i = 0; i < b.length; i++) {
    const n = b[i][1]
    const r = b[i][2]
    TWDS.createEle({
      nodeName: 'option',
      value: r,
      textContent: n,
      selected: win._TWDS_item === r,
      last: itemselector
    })
  }

  const count = win._TWDS_number
  const r = win._TWDS_item
  if (count <= 0 || parseInt(r) <= 0) {
    return content
  }
  const resultarea = TWDS.createEle({
    nodeName: 'table',
    className: 'TWDS_craftcalc_resultarea',
    last: content
  })

  const things = {}

  const handlerecipe = function (r, count) {
    const it = ItemManager.get(r)
    if (!it) {
      console.log('strange: handlerecipe got nothing for recipe', r)
      return
    }
    if (it.type !== 'recipe') {
      console.log('strange: handlerecipe got != recipe', r, it)
      return
    }
    for (let i = 0; i < it.resources.length; i++) {
      const itemid = it.resources[i].item
      if (itemid in win._TWDS_craftitems) {
        if (deref === 0) {
          handlerecipe(win._TWDS_craftitems[itemid], count * it.resources[i].count)
          continue
        }
        if (deref === 1) {
          if ((itemid in TWDS.crafting.mycraftableitems)) {
            handlerecipe(win._TWDS_craftitems[itemid], count * it.resources[i].count)
            continue
          }
        }
      }
      console.log('splitcheck', '_TWDS_split' in win)
      if ('_TWDS_split' in win) {
        if (win._TWDS_split.includes(itemid)) {
          handlerecipe(win._TWDS_craftitems[itemid], count * it.resources[i].count)
          continue
        }
      }
      if (!(itemid in things)) {
        things[itemid] = 0
      }
      things[itemid] += count * it.resources[i].count
      // console.log("for",count, it.name, ":", it.resources[i].count,item.name, "=",things[itemid]);
    }
  }
  handlerecipe(r, count)
  const allitems = []
  console.log('things', things)
  for (const i of Object.keys(things)) {
    const item = ItemManager.get(i)
    allitems.push([i, things[i], item.name])
  }
  allitems.sort(function (a, b) {
    return a[2].trim().localeCompare(b[2].trim())
  })

  const cid = win._TWDS_recipes[win._TWDS_item]
  const cit = ItemManager.get(cid)
  TWDS.createEle({
    nodeName: 'h1',
    textContent: cit.name,
    last: resultarea
  })
  const popup = new ItemPopup(cit, {}).popup.getXHTML()
  TWDS.createEle({
    nodeName: 'p',
    last: resultarea,
    childNodes: [
      {
        nodeName: 'img',
        className: 'tw_item inventory_item',
        src: cit.image,
        alt: cit.name,
        title: popup
      }, {
        nodeName: 'span',
        className: 'result_in_inventory',
        textContent: TWDS._('CRAFTCALC_PRODUCT_IN_BAG', '$count$ en bolsa.', {
          count: Bag.getItemCount(cid)
        })
      }
    ]
  })

  TWDS.createEle({ nodeName: 'hr', last: resultarea })
  TWDS.createEle({
    nodeName: 'h2',
    textContent: TWDS._('CRAFTCALC_RESOURCES_NEEDED', 'Recursos necesarios'),
    last: resultarea
  })

  const resulttable = TWDS.createEle({
    nodeName: 'table',
    className: 'needed',
    last: resultarea
  })
  TWDS.createEle({
    nodeName: 'thead',
    last: resulttable,
    children: [
      {
        nodeName: 'tr',
        children: [
          { nodeName: 'th', textContent: TWDS._('CRAFTCALC_ITEM', 'producto') },
          { nodeName: 'th', textContent: TWDS._('CRAFTCALC_ITEM_NAME', 'nombre') },
          { nodeName: 'th', textContent: TWDS._('CRAFTCALC_ITEM_NEEDED', 'necesito') },
          { nodeName: 'th', textContent: TWDS._('CRAFTCALC_ITEM_AVAILABLE', 'disponibles') },
          { nodeName: 'th', textContent: TWDS._('CRAFTCALC_ITEM_FUNCTIONS', 'funciones') }
        ]
      }
    ]
  })
  const tbody = TWDS.createEle({
    nodeName: 'tbody',
    last: resulttable
  })

  for (let i = 0; i < allitems.length; i++) {
    const itemid = allitems[i][0]
    const it = ItemManager.get(itemid)
    const popup = new ItemPopup(it, {}).popup.getXHTML()
    const tr = TWDS.createEle({
      nodeName: 'tr',
      last: tbody
    })
    TWDS.createEle({
      nodeName: 'td',
      last: tr,
      childNodes: [
        {
          nodeName: 'img',
          className: 'tw_item inventory_item',
          src: it.image,
          alt: it.name,
          title: popup
        }
      ]
    })
    const bb = TWDS.itemBidButton(allitems[i][0])
    TWDS.createEle({
      nodeName: 'td',
      textContent: allitems[i][2], // name
      last: tr
    })
    TWDS.createEle({
      nodeName: 'td',
      textContent: allitems[i][1], // number needed
      last: tr
    })

    // const count = Bag.getItemCount(allitems[i][0])
    const sd = TWDS.storage.getitemdata(allitems[i][0])
    const haveele = TWDS.createEle({
      nodeName: 'td',
      children: [{
        nodeName: 'span',
        textContent: sd.have,
        className: sd.have < allitems[i][1] ? 'available red' : 'available green'
      }],
      last: tr
    })
    if (sd.want) {
      TWDS.createEle({
        nodeName: 'span',
        textContent: ' / ',
        last: haveele
      })
      TWDS.createEle({
        nodeName: 'span',
        textContent: sd.want,
        last: haveele
      })
    }
    // functions
    const td = TWDS.createEle({
      nodeName: 'td',
      className: 'functions',
      last: tr
    })
    if (bb) {
      td.appendChild(bb)
    }

    const sb = TWDS.itemSellButton(allitems[i][0], allitems[i][1], cit.name)
    if (sb) {
      td.appendChild(sb)
    }

    if (it.item_id in win._TWDS_craftitems) {
      TWDS.createEle({
        nodeName: 'span',
        textContent: TWDS._('CRAFTCALC_SPLIT', 'split'),
        className: 'TWDS_clickable',
        title: TWDS._('CRAFTCALC_SPLIT_TITLE', 'split into components'),
        last: td,
        dataset: {
          itemid: it.item_id
        },
        onclick: function () {
          if (!('_TWDS_split' in win)) {
            win._TWDS_split = []
          }
          if (!win._TWDS_split.includes(this.dataset.itemid)) {
            win._TWDS_split.push(parseInt(this.dataset.itemid))
            console.log('split: ', win._TWDS_split)
            TWDS.craftcalc.reload(win)
          }
        }
      })
    }
  }
  /* damned, only one sell dialog possible.
  if (allitems.length && allsellable) {
    TWDS.createEle({
      nodeName: 'p',
      last: resultarea,
      textContent: "sell all this",
      className: "TWDS_clickable",
      dataset: {
        allitems: JSON.stringify(allitems),
        name: cit.name
      },
      onclick: function() {
        let allitems=JSON.parse(this.dataset.allitems);
        console.log("OC AI",this,allitems,this.dataset.name);
        for (let i = 0; i < allitems.length; i++) {
          const sb = TWDS.itemSellButton(allitems[i][0], allitems[i][1], this.dataset.name)
          console.log("OC I",i,allitems[i],sb);
          if (sb) {
             TWDS.market_item_sell_handler.apply(sb);
          }
        }
      }
    })
  }
  */
  TWDS.createEle({ nodeName: 'hr', last: resultarea })
  TWDS.createEle({
    nodeName: 'h2',
    textContent: TWDS._('CRAFTCALC_CHAT_MESSAGES', 'Para el chat y mensajes'),
    last: resultarea
  })
  const resultchat = TWDS.createEle({
    nodeName: 'div',
    className: 'forcopying',
    last: resultarea
  })
  TWDS.createEle('span', { last: resultchat, textContent: win._TWDS_number })
  TWDS.createEle('span', { last: resultchat, textContent: ' [item=' + cid + '] = ' })
  for (let i = 0; i < allitems.length; i++) {
    if (i) {
      TWDS.createEle('span', { last: resultchat, textContent: ' + ' })
    }
    TWDS.createEle('span.have', { last: resultchat, style: { display: 'none' }, textContent: Bag.getItemCount(allitems[i][0]) + '/' })
    TWDS.createEle('span', { last: resultchat, textContent: allitems[i][1] })
    TWDS.createEle('span', { last: resultchat, textContent: ' [item=' + allitems[i][0] + ']' })
  }
  TWDS.createEle('span', { last: resultchat, textContent: '  ' })
  TWDS.createEle('button', {
    last: resultchat,
    textContent: 'Modo Matori',
    style: { display: 'block' },
    onclick: function () {
      resultchat.classList.toggle('matori')
      const visible = resultchat.classList.contains('matori')
      const spans = TWDS.q('span.have', resultchat)
      for (let i = 0; i < spans.length; i++) {
        if (visible) {
          spans[i].style.display = 'inline'
        } else {
          spans[i].style.display = 'none'
        }
      }
    }
  })
  TWDS.createEle({ nodeName: 'hr', last: resultarea })
  TWDS.createEle({
    nodeName: 'h2',
    textContent: TWDS._('CRAFTCALC_PLAINTEXT', 'En texto plano'),
    last: resultarea
  })
  const resultplain = TWDS.createEle({
    nodeName: 'div',
    className: 'forcopying',
    last: resultarea
  })
  resultplain.textContent = win._TWDS_number
  resultplain.textContent += ' ' + cit.name + ' = '
  for (let i = 0; i < allitems.length; i++) {
    const itemid = allitems[i][0]
    const it = ItemManager.get(itemid)
    if (i) { resultplain.textContent += ' + ' }
    resultplain.textContent += allitems[i][1] + ' ' + it.name
  }

  TWDS.createEle({ nodeName: 'hr', last: resultarea })
  TWDS.createEle({
    nodeName: 'h2',
    textContent: TWDS._('CRAFTCALC_COPY_EXPORT', 'Copiar / Exportart'),
    last: resultarea
  })
  const resultstorage = TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_craftcalc_storagearea forcopying',
    last: resultarea
  })
  const tmp = {}

  for (let i = 0; i < allitems.length; i++) {
    const id = allitems[i][0]
    tmp[id] = [allitems[i][1],
      allitems[i][1] + ' ' + TWDS._('CRAFTCALC_FOR', 'for') + ' ' + count + ' ' + cit.name]
  }
  resultstorage.textContent = JSON.stringify(tmp)

  return content
}
TWDS.craftcalc.open = function (key) {
  const wid = 'TWDS_craftcalc_' + key
  const win = wman.open(wid, 'set', 'TWDS_craftcalc')
  win.setTitle(TWDS._('CRAFTCALC_WINDOW_TITLE', 'Calculadora artesanal'))
  if (!('_TWDS_number' in win)) {
    win._TWDS_number = 1
    win._TWDS_item = 0
    win._TWDS_deref = 0
    const a = ItemManager.getAll()
    win._TWDS_recipes = {}
    win._TWDS_craftitems = {}
    for (const iid of Object.keys(a)) {
      const it = a[iid]
      if ('craftitem' in it) {
        win._TWDS_recipes[it.item_id] = it.craftitem
        win._TWDS_craftitems[it.craftitem] = it.item_id
      }
    }
  }
  const sp = new west.gui.Scrollpane()
  const content = TWDS.craftcalc.getcontent(win)
  sp.appendContent(content)

  win.appendToContentPane(sp.getMainDiv())
}
TWDS.craftcalc.reload = function (win) {
  const content = TWDS.craftcalc.getcontent(win)
  const old = TWDS.q1('.TWDS_craftcalc_content', win.getMainDiv())
  const sp = old.parentNode
  sp.innerHTML = ''
  sp.appendChild(content)
}
TWDS.registerExtra('TWDS.craftcalc.open',
  TWDS._('CRAFTCALC_TITLE', 'Calculadora artesanal'),
  TWDS._('CRAFTCALC_DESC', 'Calcula los artículos necesarios para hacer elaboraciones.')
)
// vim: tabstop=2 shiftwidth=2 expandtab

TWDS.altinv = {}
TWDS.altinv.searchwordforset = function (sd) {
  const a = {}
  const b = []
  // longest common substring
  for (let i = 0; i < sd.items.length; i++) {
    const id = sd.items[i]
    const it = ItemManager.getByBaseId(id)
    const w = it.name.split(' ')
    for (let j = 0; j < w.length; j++) {
      const v = w[j]
      if (!(v in a)) {
        a[v] = 0
      }
      a[v]++
    }
  }
  const id = sd.items[0]
  const it = ItemManager.getByBaseId(id)
  const w = it.name.split(' ')
  for (let j = 0; j < w.length; j++) {
    const v = w[j]
    if (a[v] === sd.items.length) {
      b.push(v)
    }
  }
  return b.join(' ')
}
TWDS.altinv.openwindow = function () {
  const ls = window.localStorage.TWDS_itemusage
  let usedata
  if (typeof ls === 'undefined') {
    usedata = {}
  } else {
    usedata = JSON.parse(ls)
  }

  const marketsearchword = function (sd) {
    return TWDS.altinv.searchwordforset(sd)
  }
  const setusage = function (sd) {
    let n = 0
    for (let i = 0; i < sd.items.length; i++) {
      const x = Bag.getItemsByBaseItemId(sd.items[i])
      if (x && x.length) {
        for (let j = 0; j < x.length; j++) {
          const id = x[j].obj.item_id
          if (usedata[id]) {
            const u = usedata[id]
            if (u.job.length) {
              n += u.job.length
            }
            if (u.eq.length) {
              n += u.eq.length
            }
            if (u.ds.length) {
              n += u.ds.length
            }
          }
        }
      }
    }
    return n
  }

  const win = wman.open('TWDS_altinv_window', 'Inventory', 'TWDS_altinv_window')
  win.setMiniTitle('Inventory')

  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_altinv_container'
  })
  TWDS.createEle('h2', { textContent: 'Inventory', beforeend: content })
  const table = TWDS.createEle('table', { beforeend: content })
  table.addEventListener('click', function (e) {
    const t = e.target
    if (t.classList.contains('setname')) {
      TWDS.showset.open(t.dataset.setkey, true)
    }
    console.log('click', t)
    if (t.classList.contains('TWDS_altinv_sell_away')) {
      west.window.shop.open().openSellInventory()
      Inventory.search(t.dataset.itemname)
    }
    if (t.classList.contains('TWDS_altinv_auction_away')) {
      Ajax.remoteCallMode('town', 'get_town', {
        x: Character.position.x,
        y: Character.position.y
      }, function (json) {
        if (json.error) {
          return new UserMessage(json.msg).show()
        }
        MarketWindow.open(json.town_id, json.allBuildings.market.stage, json.town_name)
        MarketWindow.showTab('sell')
        Inventory.search(t.dataset.itemname)
      })
    }
    if (t.classList.contains('TWDS_altinv_market_search')) {
      MarketWindow.open(Character.homeTown.town_id, 1, '???')
      document.querySelector('.tw2gui_window_tab._tab_id_buy').click()
      document.querySelector('[name=market_search_search]').value = t.dataset.itemname
      document.querySelector('.market-buy .tw2gui_iconbutton.iconBut_mpb_refresh').click()
    }
    if (t.classList.contains('TWDS_altinv_usage')) {
      let sel = "#TWDS_wuw [data-itemid='"
      sel += t.dataset.item_id
      sel += "']"
      TWDS.wuw.openwindow(sel)
      return false
    }
  })
  const thead = TWDS.createEle('thead', { beforeend: table })
  thead.appendChild(TWDS.createEle({
    nodeName: 'tr',
    children: [
      { nodeName: 'th', textContent: '#' },
      { nodeName: 'th', textContent: 'Nombre', className: 'itemname' },
      { nodeName: 'th', textContent: 'Número' },
      { nodeName: 'th', textContent: 'Uso' },
      { nodeName: 'th', textContent: 'Comprar' },
      { nodeName: 'th', textContent: 'Vender' }
    ]
  }))
  const tbody = TWDS.createEle('tbody', { beforeend: table })
  const all = []
  for (let id of Object.keys(Bag.items_by_id)) {
    id = parseInt(id)
    const it = Bag.items_by_id[id].obj
    const n1 = it.name
    let n2 = ''
    if (it.set) {
      const sd = west.storage.ItemSetManager.get(it.set)
      if (sd) {
        n2 = sd.name
      }
    }
    all.push({
      itemid: id,
      n1: n1,
      n2: n2
    })
  }
  // sorts set first and by name, then items by name
  all.sort(function (a, b) {
    if (b.n2 !== a.n2) {
      if (b.n2 === '') return -1
      if (a.n2 === '') return 1
      return a.n2.localeCompare(b.n2)
    }
    return a.n1.localeCompare(b.n1)
  })

  let lastset = ''
  for (const ele of Object.values(all)) {
    let id = ele.itemid
    id = parseInt(id)
    const it = Bag.items_by_id[id].obj
    if (it.set !== lastset && it.set === null) {
      lastset = it.set
      const tr = TWDS.createEle('tr', { beforeend: tbody, className: 'setrow' })
      const td = TWDS.createEle('td', {
        beforeend: tr,
        className: 'nosets',
        textContent: 'Not in sets'
      })
      td.colSpan = 5
    }
    if (it.set !== lastset) {
      lastset = it.set
      const tr = TWDS.createEle('tr', { beforeend: tbody, className: 'setrow' })
      const sd = west.storage.ItemSetManager.get(it.set)
      let td = TWDS.createEle('td', {
        beforeend: tr,
        textContent: ''
      })
      td.colSpan = 2
      TWDS.createEle({
        nodeName: 'span',
        className: 'setname',
        textContent: sd.name,
        dataset: {
          setkey: it.set
        },
        beforeend: td
      })
      const sw = marketsearchword(sd)
      TWDS.createEle({
        nodeName: 'span',
        className: 'searchword',
        textContent: sw ? '(' + sw + ')' : '(conjunto no buscable)',
        beforeend: td
      })

      let found = 0
      for (let i = 0; i < sd.items.length; i++) {
        const x = Bag.getItemsByBaseItemId(sd.items[i])
        if (x && x.length) { found++ }
      }

      td = TWDS.createEle('td', {
        beforeend: tr,
        className: 'setitemcount',
        textContent: found + '/' + sd.items.length
      })

      const su = setusage(sd)
      td = TWDS.createEle('td', {
        beforeend: tr,
        className: su ? 'usado' : 'no usado',
        textContent: su > 0 ? 'used' : 'unused'
      })

      let ac = TWDS.createEle('td', { beforeend: tr, className: 'buy' })
      if (sw) {
        TWDS.createEle({
          nodeName: 'span',
          title: 'buscar artículos de este conjunto en el mercado',
          innerHTML: '?',
          dataset: {
            itemname: sw || ''
          },
          classList: ['TWDS_altinv_market_search'],
          beforeend: ac
        })
      }
      ac = TWDS.createEle('td', { beforeend: tr, className: 'sell' })
      TWDS.createEle({
        nodeName: 'span',
        title: 'subastar los artículos de este conjunto',
        alt: 'auction',
        // textContent: '&#9752;'
        innerHTML: '&#128200;',
        dataset: {
          itemname: sd ? sd.name : '???'
        },
        classList: ['TWDS_altinv_auction_away'],
        beforeend: ac
      })
      TWDS.createEle({
        nodeName: 'span',
        title: 'vender artículos de este conjunto al comerciante ambulante',
        innerHTML: '&#9784;',
        dataset: {
          itemname: sd ? sd.name : '???'
        },
        classList: ['TWDS_altinv_sell_away'],
        beforeend: ac
      })
    }
    const tr = TWDS.createEle('tr', { beforeend: tbody, className: 'itemrow' })
    const count = Bag.items_by_id[id].count
    const lv = it.item_level
    TWDS.createEle('td', { beforeend: tr, textContent: id })
    // const x = new tw2widget.Item(window.ItemManager.get(id))
    const td = TWDS.createEle('td', { className: 'itemname', beforeend: tr, textContent: it.name })
    if (it.upgradeable && lv > 0) {
      td.textContent += '^' + lv
    }

    TWDS.createEle('td', { beforeend: tr, className: 'count', textContent: count })

    if (usedata[id]) {
      // <span class="TWDS_itemusageinfo hasMousePopup" data-item_id="51193000">2</span>
      const x = TWDS.createEle('td', {
        beforeend: tr,
        className: 'TWDS_altinv_usage',
        dataset: {
          item_id: id
        }
      })
      let str = ''
      const u = usedata[id]
      if (u.job.length) {
        str += u.job.length + ' jobs'
      }
      if (u.eq.length) {
        if (str > '') { str += ', ' }
        str += u.eq.length + ' TW equipment sets'
      }
      if (u.ds.length) {
        if (str > '') { str += ', ' }
        str += u.ds.length + ' ' + TWDS.scriptname + ' equipment sets'
      }
      x.title = str
      x.textContent = 'used'
      x.classList.add('used')
    } else {
      TWDS.createEle('td', { beforeend: tr, textContent: 'unused', className: 'unused' })
    }

    let ac = TWDS.createEle('td', { beforeend: tr, className: 'buy' })
    let offerauction = it.auctionable
    if (lv > 0) {
      const bid = it.item_base_id
      const bi = ItemManager.getByBaseId(bid)
      if (bi && bi.auctionable) {
        offerauction = true
      }
    }
    if (offerauction) {
      TWDS.createEle({
        nodeName: 'span',
        title: 'buscar este artículo en el mercado',
        innerHTML: '?',
        dataset: {
          itemname: it.name
        },
        classList: ['TWDS_altinv_market_search'],
        beforeend: ac
      })
    }

    ac = TWDS.createEle('td', { beforeend: tr, className: 'sell' })
    const sb = TWDS.itemSellButton(id, 1, '')
    if (sb) { ac.appendChild(sb) }
    if (it.sellable) {
      const b = TWDS.createEle({
        nodeName: 'span',
        title: 'vender este artículo al comerciante ambulante',
        innerHTML: '&#9784;',
        dataset: {
          itemid: id,
          itemname: it.name
        },
        classList: ['TWDS_altinv_sell_away']
      })
      ac.appendChild(b)
    }
  }
  sp.appendContent(content)

  win.appendToContentPane(sp.getMainDiv())
}
TWDS.registerStartFunc(function () {
  TWDS.registerExtra('TWDS.altinv.openwindow',
    TWDS._('EXTRAS_ALTINV_TEXT', 'Inventario Tabular'),
    TWDS._('EXTRAS_ALTINV_HELP', 'Muestra tu inventario como una gran tabla, ordenada por conjunto y nombre.')
  )
})
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.friends = {}
TWDS.translation_de.FRIENDS_NO_FRIENDS = 'Du hast hier keine Freunde.'
TWDS.translation_de.FRIENDS_COUNT_TEXT = 'Du hast hier $count$ Freunde.'
TWDS.translation_de.FRIENDS = 'Freunde'
TWDS.translation_de.FRIENDS_TH_NAME = 'Name'
TWDS.translation_de.FRIENDS_TH_LEVEL = 'Stufe'
TWDS.translation_de.FRIENDS_TH_CLASS = 'Klasse'
TWDS.translation_de.FRIENDS_TH_PROF = 'Beruf'

TWDS.friends.openwindow = function () {
  const win = wman.open('TWDS_friends_window', TWDS._('FRIENDS', 'Amigos'), 'TWDS_friends_window')
  win.setMiniTitle(TWDS._('FRIENDS', 'Amigos'))

  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_friends_container'
  })
  const info = TWDS.createEle('p', { beforeend: content })
  const functions = TWDS.createEle('p', { beforeend: content })
  const table = TWDS.createEle('table', { beforeend: content, className: 'TWDS_with_border TWDS_padded TWDS_sortable' })
  const thead = TWDS.createEle('thead', { beforeend: table })
  const tbody = TWDS.createEle('tbody', { beforeend: table })

  sp.appendContent(content)

  win.appendToContentPane(sp.getMainDiv())
  Ajax.remoteCallMode('friendsbar', 'search', {
    search_type: 'friends'
  }, function (response) {
    if (response.error) {
      return new UserMessage(response.msg).show()
    }
    const pl = response.players
    if (pl.length < 2) {
      TWDS.createEle('tr', {
        children: [
          { nodeName: 'td', textContent: TWDS._('FRIENDS_NO_FRIENDS', 'sin amigos') }
        ]
      })
      return
    }
    info.textContent = TWDS._('FRIENDS_COUNT_TEXT', 'Tiene $count$ amigos.', { count: pl.length - 1 })
    for (const eventName in Game.sesData) {
      const ev = Game.sesData[eventName]
      if (!ev.friendsbar || (window.buildTimestamp(ev.meta.end, true) <= new window.ServerDate().getTime())) {
        continue
      }
      TWDS.createEle({
        nodeName: 'button',
        textContent: ev.friendsbar.label,
        dataset: { event: eventName },
        onclick: function () {
          new west.storage.FriendsBar('friends', function () {}, function () {}, function () {})
            .activateEventAll(this.dataset.eventName)
        },
        last: functions
      })
    }
    thead.appendChild(TWDS.createEle({
      nodeName: 'tr',
      children: [
        { nodeName: 'th', textContent: TWDS._('FRIENDS_TH_NAME', 'Nombre'), className: 'TWDS_clicktarget', dataset: { colsel: '.name' } },
        {
          nodeName: 'th',
          textContent: TWDS._('FRIENDS_TH_LEVEL', 'Nivel'),
          className: 'TWDS_clicktarget',
          dataset: { colsel: '.lv', sortmode: 'number', secondsel: '.name' }
        },
        { nodeName: 'th', textContent: TWDS._('FRIENDS_TH_CLASS', 'Clase'), className: 'TWDS_clicktarget', dataset: { colsel: '.class', secondsel: '.name' } },
        { nodeName: 'th', textContent: TWDS._('FRIENDS_TH_PROF', 'Oficio'), className: 'TWDS_clicktarget', dataset: { colsel: '.prof', secondsel: '.name' } }
      ]
    }))
    for (let i = 0; i < pl.length; i++) {
      if (pl[i].name === Character.name) continue
      TWDS.createEle('tr', {
        children: [
          { nodeName: 'td', className: 'name TWDS_clicktarget', dataset: { player_id: pl[i].player_id }, textContent: pl[i].name },
          { nodeName: 'td', className: 'lv ra', textContent: pl[i].level },
          { nodeName: 'td', className: 'class', textContent: Game.InfoHandler.getLocalString4Charclass(pl[i].class) },
          { nodeName: 'td', className: 'prof', textContent: Game.InfoHandler.getLocalString4ProfessionId(pl[i].profession_id) }
        ],
        last: tbody
      })
    }
    $('th:first-child', $(thead)).trigger('click')
  })
  TWDS.delegate(table, 'click', 'tbody .name', function (x) {
    window.PlayerProfileWindow.open(parseInt(this.dataset.player_id))
  })
  TWDS.delegate(table, 'click', 'thead th', function (x) {
    const tab = this.closest('table')
    const sel = this.dataset.colsel
    const secondsel = this.dataset.secondsel
    const sortmode = this.dataset.sortmode || 'text'
    const rows = [...TWDS.q('tbody tr', tab)]
    const cursort = tab.dataset.cursort || ''
    let mult = 1
    if (cursort === sel) {
      mult = -1
      tab.dataset.cursort = ''
    } else { tab.dataset.cursort = sel }

    const sortfunc = function (a, b, sel) {
      const tda = TWDS.q1(sel, a)
      const tdb = TWDS.q1(sel, b)
      let va
      let vb
      if ('sortval' in tda.dataset) {
        va = tda.dataset.sortval
      } else {
        va = tda.textContent
      }
      if ('sortval' in tdb.dataset) {
        vb = tdb.dataset.sortval
      } else {
        vb = tdb.textContent
      }
      let res = 0
      if (sortmode === 'number') {
        res = va - vb
      } else {
        res = va.localeCompare(vb)
      }
      if (res) return mult * res
      if (secondsel && sel !== secondsel) {
        return sortfunc(a, b, secondsel)
      }
      return 0
    }
    rows.sort(function (a, b) { return sortfunc(a, b, sel) })
    tbody.textContent = ''
    for (let i = 0; i < rows.length; i++) {
      tbody.appendChild(rows[i])
    }
  })
}
TWDS.friends.fastclick = function () {
  for (const eventName in Game.sesData) {
    const ev = Game.sesData[eventName]
    if (!ev.friendsbar || (window.buildTimestamp(ev.meta.end, true) <= new window.ServerDate().getTime())) {
      continue
    }
    new west.storage.FriendsBar('friends', function () {}, function () {}, function () {})
      .activateEventAll(eventName)
  }
}
// this is not translated, because it runs quite early
TWDS.registerExtra('TWDS.friends.openwindow', 'Amigos', 'Mostrar amigos')
TWDS.registerStartFunc(function () {
  TWDS.delegate(document.body, 'click', '.custom_unit_counter .icon:not(.help)', function () {
    TWDS.friends.fastclick()
  })
})
// vim: tabstop=2 shiftwidth=2 expandtab

TWDS.calculator = {}
TWDS.calculator.presets = [
  { name: 'duel', disabled: true },
  // { name: 'tmpl',                    punch: 0, tough: 1, health: 1, reflex: 1, dodge: 1, aim: 1, shot: 0, appearance: 1, tactic: 1},

  { name: 'atacar dañando/fuego', punch: 0, tough: 1, health: 1, reflex: 1, dodge: 6, aim: 12, shot: 12, appearance: 12, tactic: 1, type: 'duel', alias: 'Vaquero / Jaguar / Pearl', range: 1 },
  { name: 'atacar dañando/contundente', punch: 12, tough: 1, health: 1, reflex: 1, dodge: 6, aim: 12, shot: 0, appearance: 12, tactic: 1, type: 'duel', alias: 'Cowgirl / Legba', melee: 1 },
  { name: 'defender dañando/fuego', punch: 0, tough: 1, health: 1, reflex: 1, dodge: 6, aim: 12, shot: 12, appearance: 0, tactic: 12, type: 'duel', range: 1 },
  { name: 'defender dañando/contundente', punch: 12, tough: 1, health: 1, reflex: 1, dodge: 6, aim: 12, shot: 0, appearance: 0, tactic: 12, type: 'duel', melee: 1 },
  { name: 'defender+ dañando/fuego', punch: 0, tough: 1, health: 1, reflex: 1, dodge: 6, aim: 10, shot: 10, appearance: 0, tactic: 15, type: 'duel', range: 1 },
  { name: 'defend+ dañando/contundente', punch: 10, tough: 1, health: 1, reflex: 1, dodge: 6, aim: 10, shot: 0, appearance: 0, tactic: 15, type: 'duel', melee: 1 },

  { name: 'atacar eludiendo/fuego', punch: 0, tough: 1, health: 1, reflex: 1, dodge: 12, aim: 6, shot: 3, appearance: 12, tactic: 1, type: 'duel', range: 1 },
  { name: 'atacar eludiendo/fuego', punch: 3, tough: 1, health: 1, reflex: 1, dodge: 12, aim: 6, shot: 0, appearance: 12, tactic: 1, type: 'duel', alias: 'Josephine', melee: 1 },
  { name: 'defender eludiendo/fuego', punch: 0, tough: 1, health: 1, reflex: 1, dodge: 12, aim: 9, shot: 3, appearance: 0, tactic: 12, type: 'duel', range: 1 },
  { name: 'defender eludiendo/contundente', punch: 3, tough: 1, health: 1, reflex: 1, dodge: 12, aim: 9, shot: 0, appearance: 0, tactic: 12, type: 'duel', melee: 1 },

  { name: 'atacar fuego con resist. fuego', punch: 0, tough: 3, health: 1, reflex: 12, dodge: 2, aim: 4, shot: 6, appearance: 12, tactic: 1, type: 'duel', range: 1 },
  { name: 'atacar fuego con resist. contundente', punch: 0, tough: 12, health: 1, reflex: 3, dodge: 2, aim: 4, shot: 6, appearance: 12, tactic: 1, type: 'duel', range: 1 },
  { name: 'atacar contundente con resist. fuego', punch: 6, tough: 1, health: 1, reflex: 12, dodge: 2, aim: 4, shot: 0, appearance: 12, tactic: 1, type: 'duel', melee: 1 },
  { name: 'atacar contundente con resist. contundente', punch: 6, tough: 12, health: 1, reflex: 3, dodge: 2, aim: 4, shot: 0, appearance: 12, tactic: 1, type: 'duel', melee: 1 },
  { name: 'defender fuego con resist. fuego', punch: 0, tough: 3, health: 1, reflex: 12, dodge: 2, aim: 4, shot: 3, appearance: 0, tactic: 12, type: 'duel', range: 1 },
  { name: 'defender fuego con resist. contundente', punch: 0, tough: 12, health: 1, reflex: 3, dodge: 2, aim: 4, shot: 3, appearance: 0, tactic: 12, type: 'duel', range: 1 },
  { name: 'defender fuego con resist. mezclada', punch: 0, tough: 12, health: 1, reflex: 12, dodge: 10, aim: 4, shot: 3, appearance: 0, tactic: 12, type: 'duel', range: 1 },
  { name: 'defender contundente con resist. fuego', punch: 2, tough: 1, health: 1, reflex: 12, dodge: 2, aim: 3, shot: 0, appearance: 0, tactic: 12, type: 'duel', melee: 1 },
  { name: 'defender contundente con resist. fuego', punch: 2, tough: 12, health: 1, reflex: 3, dodge: 2, aim: 3, shot: 0, appearance: 0, tactic: 12, type: 'duel', melee: 1 },
  { name: 'defender contundente con resist. mezclada', punch: 2, tough: 12, health: 1, reflex: 12, dodge: 10, aim: 3, shot: 0, appearance: 0, tactic: 12, type: 'duel', melee: 1 },
  { name: 'Sable de oficial del trébol de la suerte', punch: 54, tough: 34, health: 10, reflex: 38, dodge: 65, aim: 79, shot: 0, appearance: 57, tactic: 61, type: 'duel', melee: 1 },
  { name: 'Derringer de bolsillo del trébol de la suerte', punch: 0, tough: 34, health: 10, reflex: 30, dodge: 64, aim: 72, shot: 88, appearance: 64, tactic: 62, type: 'duel', range: 1 },
    //
  { name: 'batallas de fuerte', disabled: true },
  { name: 'tanque/ataque', health: 5, aim: 1, dodge: 5, hide: 6, leadership: 5, fboffense: 1, fboffense_sector: 2, fbdefense: 50, fbdefense_sector: 50, fbresistance: 5, fbdamage: 1, type: 'battle' },
  { name: 'tanque/defensa', health: 5, aim: 1, dodge: 10, pitfall: 12, leadership: 10, fboffense: 2, fboffense_sector: 4, fbdefense: 20, fbdefense_sector: 40, fbresistance: 10, fbdamage: 1, type: 'battle' },
  { name: 'anti/ataque', health: -1, aim: 5, dodge: 0, hide: 6, leadership: 6, fboffense: 10, fboffense_sector: 10, fbdefense: 1, fbdefense_sector: 2, fbresistance: 1, fbdamage: 5, type: 'battle' },
  { name: 'anti/defensa', health: -1, aim: 5, dodge: 0, pitfall: 6, leadership: 6, fboffense: 10, fboffense_sector: 10, fbdefense: 1, fbdefense_sector: 2, fbresistance: 1, fbdamage: 5, type: 'battle' },
  { name: 'impulsor/daño', health: 0, dodge: 0, hide: 3, aim: 3, pitfall: 3, leadership: 3, fboffense: 0, fboffense_sector: 20, fbdefense_sector: 20, fbdamage: 150, type: 'battle' },
  { name: 'impulsor/genérico', health: 0, dodge: 0, hide: 3, aim: 3, pitfall: 3, leadership: 4, fboffense_sector: 500, fbdefense_sector: 500, fbdamage: 5, type: 'battle' }
]
TWDS.calculator.data = [
  { kind: 'group', name: 'weapontype', cls: 'boostgroup' },
  { kind: 'weaponselect' },
  { kind: 'group', name: 'fortbattle', cls: 'boostgroup' },
  {
    kind: 'bonus',
    name: 'fboffense',
    img: '/images/fort/battle/button_attack.png',
    title: TWDS._('CALCULATOR_MP_ATTACK', 'ataque multijugador')
  },
  {
    kind: 'bonus',
    name: 'fboffense_sector',
    img: '/images/fort/battle/help01.png',
    title: TWDS._('CALCULATOR_SECTOR_ATTACK', 'ataque multijugador (bonus sector)')
  },
  {
    kind: 'bonus',
    name: 'fbdefense',
    img: '/images/fort/battle/button_defend.png',
    title: TWDS._('CALCULATOR_MP_DEFENSE', 'defensa multijugador')
  },
  {
    kind: 'bonus',
    name: 'fbdefense_sector',
    img: '/images/fort/battle/help01.png',
    title: TWDS._('CALCULATOR_SECTOR_DEFENSE', 'defensa multijugador (bonus sector)')
  },
  {
    kind: 'bonus',
    name: 'fbresistance',
    img: '/images/icons/Hearts.png',
    title: TWDS._('CALCULATOR_RESISTANCE', 'resistencia')
  },
  {
    kind: 'bonus',
    name: 'fbdamage',
    img: '/images/items/left_arm/golden_rifle.png',
    title: TWDS._('CALCULATOR_SECTOR_DAMAGE', 'daño sector')
  },
  { kind: 'group', name: 'boost1', cls: 'boostgroup' },
  {
    kind: 'bonus',
    name: 'experience',
    img: '/images/items/yield/xp_boost.png',
    title: TWDS._('CALCULATOR_EXPERIENCE', 'experiencia')
  },
  {
    kind: 'bonus',
    name: 'dollar',
    img: '/images/items/yield/dollar_boost.png',
    title: TWDS._('CALCULATOR_DOLLAR', 'dinero')
  },
  {
    kind: 'bonus',
    name: 'luck',
    img: '/images/items/yield/luck_boost.png',
    title: TWDS._('CALCULATOR_LUCK', 'suerte')
  },
  {
    kind: 'bonus',
    name: 'drop',
    img: '/images/items/yield/product_boost.png',
    title: TWDS._('CALCULATOR_DROP', 'tasa salida')
  },
  {
    kind: 'bonus',
    name: 'joball',
    img: 'images/window/job/jobstar_small_gold.png',
    title: TWDS._('CALCULATOR_JP', 'jpuntos trabajo (todos los trabajos solo)')
  },
  { kind: 'group', name: 'boost2', cls: 'boostgroup' },
  {
    kind: 'bonus',
    name: 'speed',
    img: '/images/jobs/walk.png',
    title: TWDS._('CALCULATOR_SPEED', 'velocidad (use la calculadora en la pestaña de equipo en su lugar)')
  },
  {
    kind: 'bonus',
    name: 'regen',
    img: '/images/jobs/sleep.png',
    title: TWDS._('CALCULATOR_REGEN', 'regeneración')
  },
  {
    kind: 'bonus',
    name: 'pray',
    img: '/images/jobs/pray.png',
    title: TWDS._('CALCULATOR_PRAY', 'rezar')
  },
  { kind: 'group', name: 'red', cls: 'attrgroup' },
  { kind: 'skill', name: 'build', img: '/images/window/skills/skillicon_build.png' },
  { kind: 'skill', name: 'punch', img: '/images/window/skills/skillicon_punch.png' },
  { kind: 'skill', name: 'tough', img: '/images/window/skills/skillicon_tough.png' },
  { kind: 'skill', name: 'endurance', img: '/images/window/skills/skillicon_endurance.png' },
  { kind: 'skill', name: 'health', img: '/images/window/skills/skillicon_health.png' },
  { kind: 'group', name: 'green', cls: 'attrgroup' },
  { kind: 'skill', name: 'ride', img: '/images/window/skills/skillicon_ride.png' },
  { kind: 'skill', name: 'reflex', img: '/images/window/skills/skillicon_reflex.png' },
  { kind: 'skill', name: 'dodge', img: '/images/window/skills/skillicon_dodge.png' },
  { kind: 'skill', name: 'hide', img: '/images/window/skills/skillicon_hide.png' },
  { kind: 'skill', name: 'swim', img: '/images/window/skills/skillicon_swim.png' },
  { kind: 'group', name: 'blue', cls: 'attrgroup' },
  { kind: 'skill', name: 'aim', img: '/images/window/skills/skillicon_aim.png' },
  { kind: 'skill', name: 'shot', img: '/images/window/skills/skillicon_shot.png' },
  { kind: 'skill', name: 'pitfall', img: '/images/window/skills/skillicon_pitfall.png' },
  { kind: 'skill', name: 'finger_dexterity', img: '/images/window/skills/skillicon_finger_dexterity.png' },
  { kind: 'skill', name: 'repair', img: '/images/window/skills/skillicon_repair.png' },
  { kind: 'group', name: 'yellow', cls: 'attrgroup' },
  { kind: 'skill', name: 'leadership', img: '/images/window/skills/skillicon_leadership.png' },
  { kind: 'skill', name: 'tactic', img: '/images/window/skills/skillicon_tactic.png' },
  { kind: 'skill', name: 'trade', img: '/images/window/skills/skillicon_trade.png' },
  { kind: 'skill', name: 'animal', img: '/images/window/skills/skillicon_animal.png' },
  { kind: 'skill', name: 'appearance', img: '/images/window/skills/skillicon_appearance.png' }
  /*
    const bonus = {
          damage: 0,
          fortbattle: {},
          job: {},
  */
]

TWDS.calculator.showbonus = function (all, area) {
  const one = function (all, k, str, tr, mult, pre, post) {
    if (mult === undefined) mult = 1
    if (pre === undefined) pre = ''
    if (post === undefined) post = ''
    if (str === '-') {
      if (k in CharacterSkills.attributes) { str = CharacterSkills.attributes[k].name } else if (k in CharacterSkills.skills) { str = CharacterSkills.skills[k].name }
    }
    TWDS.createEle('th', {
      last: tr,
      textContent: all[k] ? str : ''
    })
    let v = all[k]
    if (mult !== 1) {
      v = (mult * all[k]).toFixed(1)
    }
    TWDS.createEle('td', {
      last: tr,
      textContent: all[k] ? pre + v + post : ''
    })
  }
  const tab = TWDS.createEle('table', { last: area, className: 'TWDS_with_border' })
  let tr = TWDS.createEle('tr', { last: tab })
  one(all, 'strength', CharacterSkills.attributes.strength.name, tr)
  one(all, 'build', '-', tr)
  one(all, 'punch', '-', tr)
  one(all, 'tough', '-', tr)
  one(all, 'endurance', '-', tr)
  one(all, 'health', '-', tr)
  tr = TWDS.createEle('tr', { last: tab })
  one(all, 'flexibility', CharacterSkills.attributes.flexibility.name, tr)
  one(all, 'ride', '-', tr)
  one(all, 'reflex', '-', tr)
  one(all, 'dodge', '-', tr)
  one(all, 'hide', '-', tr)
  one(all, 'swim', '-', tr)
  tr = TWDS.createEle('tr', { last: tab })
  one(all, 'dexterity', CharacterSkills.attributes.dexterity.name, tr)
  one(all, 'aim', '-', tr)
  one(all, 'shot', '-', tr)
  one(all, 'pitfall', '-', tr)
  one(all, 'finger_dexterity', '-', tr)
  one(all, 'repair', '-', tr)
  tr = TWDS.createEle('tr', { last: tab })
  one(all, 'charisma', CharacterSkills.attributes.charisma.name, tr)
  one(all, 'leadership', '-', tr)
  one(all, 'tactic', '-', tr)
  one(all, 'trade', '-', tr)
  one(all, 'animal', '-', tr)
  one(all, 'appearance', '-', tr)
  tr = TWDS.createEle('tr', { last: tab })
  let flag = 0
  if (all.experience) { one(all, 'experience', 'Exp', tr, 100, '+', '%'); flag = 1 }
  if (all.dollar) { one(all, 'dollar', 'Money', tr, 100, '+', '%'); flag = 1 }
  if (all.luck) { one(all, 'luck', 'Luck', tr, 100, '+', '%'); flag = 1 }
  if (all.drop) { one(all, 'drop', 'Drop', tr, 100, '+', '%'); flag = 1 }
  if (flag) {
    flag = 0
    tr = TWDS.createEle('tr', { last: tab })
  }
  if (all.speed) { one(all, 'speed', 'Speed', tr, 100, '+', '%'); flag = 1 }
  if (all.regen) { one(all, 'regen', 'Regen.', tr, 100, '+', '%'); flag = 1 }
  if (all.pray) { one(all, 'pray', 'Pray', tr); flag = 1 }
  if (flag) {
    flag = 0
    tr = TWDS.createEle('tr', { last: tab })
  }
  if (all.fort_offense) { one(all, 'fort_offense', 'Off', tr); flag = 1 }
  if (all.fort_defense) { one(all, 'fort_defense', 'Def', tr); flag = 1 }
  if (all.fort_resistance) { one(all, 'fort_resistance', 'Res', tr); flag = 1 }
  if (flag) {
    flag = 0
    tr = TWDS.createEle('tr', { last: tab })
  }
  if (all.fort_offense_sector) { one(all, 'fort_offense_sector', 'SectorOff', tr); flag = 1 }
  if (all.fort_defense_sector) { one(all, 'fort_offense_sector', 'SectorDef', tr); flag = 1 }
  if (all.fort_damage_sector) { one(all, 'fort_damage_sector', 'SectorDmg', tr); flag = 1 }
}
TWDS.calculator.getselections = function (selectarea) {
  const skillweights = { }
  const bonusweights = { }
  for (let i = 0; i < TWDS.calculator.data.length; i++) {
    const d = TWDS.calculator.data[i]
    // console.log('d', i, d)
    if (d.kind === 'group') continue
    if (d.kind === 'bonus') {
      const inp = TWDS.q1('.onebonus.bonus.' + d.name + ' input.value', selectarea)
      const val = parseFloat(inp.value) || 0
      if (val !== 0) {
        bonusweights[d.name] = val
      }
      if (d.name === 'joball') {
        if (inp.dataset.jobid) {
          const j = parseInt(inp.dataset.jobid)
          if (j) {
            bonusweights['job_' + j] = val
          }
        }
      }
    }
    if (d.kind === 'skill') {
      let inp = TWDS.q1('.onebonus.skill.' + d.name + ' input.value', selectarea)
      inp = parseFloat(inp.value) || 0
      if (inp !== 0) {
        skillweights[d.name] = inp
      }
    }
  }
  const w = TWDS.q1('.TWDS_calc_wgroup input:checked')
  if (w.value === 'shot') bonusweights.range = 1
  if (w.value === 'melee') bonusweights.melee = 1
  return {
    skills: skillweights,
    bonus: bonusweights
  }
}
TWDS.calculator.exec = function (filterarea, selectarea, resultarea) {
  const sels = TWDS.calculator.getselections()

  let include = 0
  const x = TWDS.q('.TWDS_calc_filterarea input:checked')
  for (let i = 0; i < x.length; i++) {
    include |= parseInt(x[i].value)
  }

  console.log('PARA', sels.bonus, sels.skills, include)
  resultarea.textContent = ''
  TWDS.createEle({
    nodeName: 'h2',
    textContent: TWDS._('CALCULATOR_RESULT', 'Result'),
    last: resultarea
  })

  const gc = TWDS.genCalc.exec(sels.bonus, sels.skills, include)
  for (let i = 0; i < gc.combos.length; i++) {
    TWDS.createEle({
      nodeName: 'p',
      last: resultarea,
      textContent: TWDS._('CALCULATOR_RESULTLINE', 'Esta combinación da $p$ puntos', { p: gc.combos[i][0] })
    })
    const o = gc.combos[i][1]
    for (let j = 0; j < o.length; j++) {
      const id = o[j]
      if (id === undefined) continue
      const t = new tw2widget.InventoryItem(ItemManager.get(id)).setCharacter(Character).getMainDiv()[0]
      resultarea.appendChild(t)
    }
    if (i < 10) {
      TWDS.createEle('button', {
        textContent: TWDS._('CALCULATOR_WEAR', 'usar'),
        dataset: {
          ids: JSON.stringify(o)
        },
        onclick: function () {
          const x = JSON.parse(this.dataset.ids)
          TWDS.wearItemsHandler(x)
        },
        last: resultarea
      })
      TWDS.createEle('button', {
        textContent: TWDS._('CALCULATOR_SIMULATE', 'simular'),
        dataset: {
          ids: JSON.stringify(o)
        },
        onclick: function () {
          const x = JSON.parse(this.dataset.ids)
          // TWDS.wearItemsHandler(x)
          TWDS.simulator.openwindow(x)
        },
        last: resultarea
      })
    }
    const t = TWDS.bonuscalc.getComboBonus(o, true)
    TWDS.calculator.showbonus(t, resultarea)

    TWDS.createEle('hr', { last: resultarea, style: { clear: 'both' } })
  }
  TWDS.createEle({
    nodeName: 'h2',
    textContent: TWDS._('CALCULATOR_ITEMS', 'Artículos (c/s bonus conjunto)'),
    last: resultarea
  })
  for (let slno = 0; slno < Wear.slots.length; slno++) {
    const slot = Wear.slots[slno]
    if (!(slot in gc.items)) continue
    const o = gc.items[slot]
    for (let i = 0; i < o.length; i++) {
      const id = o[i]
      const t = new tw2widget.InventoryItem(ItemManager.get(id)).setCharacter(Character).getMainDiv()[0]
      resultarea.appendChild(t)
    }
    TWDS.createEle('hr', { last: resultarea, style: { clear: 'both' } })
  }
}
TWDS.calculator.buildjob = function () {
  return new west.job.Build({
    name: 'Construcciónn',
    id: 1000,
    skills: {
      build: 3,
      leadership: 1,
      repair: 1
    }
  })
}
TWDS.calculator.findpreset = function (name) {
  let preset = null
  for (let i = 0; i < TWDS.calculator.presets.length; i++) {
    const n = TWDS.calculator.presets[i].name
    if (n === name) {
      preset = TWDS.calculator.presets[i]
    }
  }
  return preset
}
TWDS.calculator.findsaved = function (name) {
  const saved = JSON.parse(window.localStorage.TWDS_calculator_saved || '{}')
  if (name in saved) return saved[name]
  return null
}
TWDS.calculator.getsavedlist = function () {
  const saved = JSON.parse(window.localStorage.TWDS_calculator_saved || '{}')
  const savedkeys = Object.keys(saved)
  savedkeys.sort(function (a, b) {
    return a.localeCompare(b)
  })
  return savedkeys
}
TWDS.calculator.openmaintainwindow = function () {
  const myname = 'TWDS_calcmaintain_window'
  const win = wman.open(myname, TWDS._('CALCULATOR_MAINTAINTITLE', 'Mantener búsquedas guardadas'))
  win.setMiniTitle('Maintain')
  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_calc_container'
  })
  sp.appendContent(content)
  win.appendToContentPane(sp.getMainDiv())

  const saved = JSON.parse(window.localStorage.TWDS_calculator_saved || '{}')
  const savedkeys = Object.keys(saved)
  if (!savedkeys.length) {
    TWDS.createEle('p', {
      last: content,
      textContent: TWDS._('CALCULATOR_NOSAVEDSEARCHES', 'No tiene búsquedas guardadas.')
    })
    return
  }
  savedkeys.sort(function (a, b) {
    return a.localeCompare(b)
  })
  TWDS.createEle('p', {
    last: content,
    textContent: TWDS._('CALCULATOR_SAVEDSEARCHES', 'Tiene las siguientes búsquedas guardadas:')
  })
  const ol = TWDS.createEle('ol', {
    last: content
  })
  for (let i = 0; i < savedkeys.length; i++) {
    const k = savedkeys[i]
    const li = TWDS.createEle('li', {
      last: ol
    })
    TWDS.createEle('span.linklike', {
      last: li,
      dataset: {
        key: k
      },
      title: TWDS._('CALCULATOR_CLICKTOUSE', 'Clic para usarlo en la calculadora'),
      textContent: k,
      onclick: function () {
        TWDS.calculator.openwindow('saved/' + this.dataset.key)
      }
    })
    TWDS.createEle('button', {
      last: li,
      textContent: TWDS._('CALCULATOR_DELETESAVE', 'Borrar esta búsqueda guardada'),
      onclick: function () {
        if (window.confirm(
          TWDS._('CALCULATOR_DELETECONFIRM', '¿Realmente quiere borrar la búsqueda guardada $name$?', { name: k }))) {
          delete saved[k]
          window.localStorage.TWDS_calculator_saved = JSON.stringify(saved)
          TWDS.calculator.openmaintainwindow()
        }
      }
    })
  }
  TWDS.createEle('p', {
    last: content,
    textContent: TWDS._('CALCULATOR_MAINTAIN_INFO', 'Hacer clic en un nombre para ver la búsqueda en la calculadora.')
  })
}
TWDS.calculator.openwindow = function (calledpreset) {
  const myname = 'TWDS_calc_window'
  const win = wman.open(myname, TWDS._('CALCULATOR_TITLE', 'Calculadora'), 'TWDS_calc_window')
  win.setMiniTitle('Calculadora')

  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_calc_container'
  })
  const presetarea = TWDS.createEle('div', {
    className: 'TWDS_calc_presetarea',
    last: content
  })
  const filterarea = TWDS.createEle('div', {
    className: 'TWDS_calc_filterarea',
    last: content
  })
  TWDS.createEle('hr', { last: content })
  const selectarea = TWDS.createEle('div', {
    className: 'TWDS_calc_selectarea',
    last: content
  })
  const mainchangecb = function () {
    TWDS.q1(".jobselect option[value='0']", presetarea).selected = true
    TWDS.q1(".presetselect option[value='0']", presetarea).selected = true
  }

  const jobselect = TWDS.createEle('select.jobselect', { last: presetarea })
  TWDS.createEle('option', {
    last: jobselect,
    value: 0,
    textContent: '---'
  })
  const allJobs = JobList.getSortedJobs('name')
  allJobs.push(TWDS.calculator.buildjob())
  allJobs.sort(function (a, b) {
    return a.name.toLocaleLowerCase().localeCompare(b.name.toLocaleLowerCase())
  })
  for (let i = 0; i < allJobs.length; i++) {
    TWDS.createEle('option', {
      last: jobselect,
      value: allJobs[i].id,
      textContent: allJobs[i].name
    })
  }
  jobselect.onchange = function () {
    let job = JobList.getJobById(this.value)
    if (!job && parseInt(this.value) === 1000) { // "Build"
      job = TWDS.calculator.buildjob()
    }
    console.log('S', this.value, job)
    const c = this.closest('.TWDS_calc_container')
    const inp = TWDS.q('.TWDS_calc_selectarea input', c)
    for (let i = 0; i < inp.length; i++) {
      if (inp[i].type !== 'radio') {
        inp[i].value = 0
      }
      if (job !== undefined) {
        const bo = inp[i].parentNode.dataset.bonusname
        if (job.skills[bo]) { inp[i].value = job.skills[bo] }
      }
    }
    const jpi = TWDS.q1('.joball input', c)
    if (jpi) jpi.dataset.jobid = 0
    if (jpi && job && job.id) jpi.dataset.jobid = job.id
    if (job !== 'undefined') {
      if (jpi) {
        jpi.value = 1
      }
    }
  }

  const presetselect = TWDS.createEle('select.presetselect', { last: presetarea })
  TWDS.createEle('option', {
    last: presetselect,
    value: 0,
    textContent: '---'
  })
  for (let i = 0; i < TWDS.calculator.presets.length; i++) {
    const n = TWDS.calculator.presets[i].name
    const dis = TWDS.calculator.presets[i].disabled || false
    TWDS.createEle('option', {
      last: presetselect,
      value: n,
      textContent: n,
      disabled: dis
    })
  }
  const saved = JSON.parse(window.localStorage.TWDS_calculator_saved || '{}')
  const savedkeys = Object.keys(saved)
  if (savedkeys.length) {
    savedkeys.sort(function (a, b) {
      return a.localeCompare(b)
    })
    TWDS.createEle('option', {
      last: presetselect,
      value: 0,
      textContent: 'Save searches',
      disabled: true
    })
    for (let i = 0; i < savedkeys.length; i++) {
      const k = savedkeys[i]
      TWDS.createEle('option', {
        last: presetselect,
        value: 'saved/' + k,
        textContent: k,
        disabled: false
      })
    }
  }
  presetselect.onchange = function () {
    const c = this.closest('.TWDS_calc_container')

    const inp = TWDS.q('.TWDS_calc_selectarea input', c)
    for (let i = 0; i < inp.length; i++) {
      if (inp[i].type === 'number') {
        inp[i].value = 0
      }
    }
    const jpi = TWDS.q1('.joball input', c)
    if (jpi) jpi.dataset.jobid = 0

    let preset = TWDS.calculator.findpreset(this.value)
    if (preset === null && this.value.startsWith('saved/')) {
      preset = TWDS.calculator.findsaved(this.value.substr(6))
    }

    if (preset !== null) {
      console.log('PRES', preset)
      if (preset.shot) {
        TWDS.q1(".TWDS_calc_wgroup input[value='shot'", selectarea).checked = true
      } else if (preset.melee) {
        TWDS.q1(".TWDS_calc_wgroup input[value='melee'", selectarea).checked = true
      } else {
        TWDS.q1(".TWDS_calc_wgroup input[value='egal'", selectarea).checked = true
      }
      for (const k in preset) {
        if (k !== 'name') {
          for (let i = 0; i < inp.length; i++) {
            if (inp[i].parentNode.dataset.bonusname === k) {
              inp[i].value = preset[k]
            }
          }
        }
      }
    }
  }

  TWDS.createEle({ nodeName: 'span', textContent: TWDS._('CALCULATOR_INCLUDE', 'include '), beforeend: filterarea })
  TWDS.createEle({
    nodeName: 'label',
    children: [
      { nodeName: 'input', type: 'checkbox', value: 1, checked: true },
      { nodeName: 'span', textContent: TWDS._('CALCULATOR_OWNED', 'owned, ') }
    ],
    id: 'TWDS_CALC_include_owned',
    beforeend: filterarea
  })
  TWDS.createEle({
    nodeName: 'label',
    children: [
      { nodeName: 'input', type: 'checkbox', value: 4 },
      { nodeName: 'span', textContent: TWDS._('CALCULATOR_TOWN_TRADERS', 'town traders, ') }
    ],
    id: 'TWDS_CALC_include_tradeable',
    beforeend: filterarea
  })
  TWDS.createEle({
    nodeName: 'label',
    children: [
      { nodeName: 'input', type: 'checkbox', value: 2 },
      { nodeName: 'span', textContent: TWDS._('CALCULATOR_AUCTIONABLE', 'auctionable, ') }
    ],
    id: 'TWDS_CALC_include_auctionable',
    beforeend: filterarea
  })
  TWDS.createEle({
    nodeName: 'label',
    children: [
      { nodeName: 'input', type: 'checkbox', value: 8 },
      { nodeName: 'span', textContent: TWDS._('CALCULATOR_NOTAUCTIONABLE', 'not auctionable') }
    ],
    id: 'TWDS_CALC_include_else',
    beforeend: filterarea
  })
  TWDS.createEle({
    nodeName: 'label',
    children: [
      { nodeName: 'span', textContent: ' (' },
      { nodeName: 'input', type: 'checkbox', value: 32 },
      {
        nodeName: 'a',
        href: '#',
        onclick: function () { TWDS.genCalc.blacklistwindow(); return false },
        textContent: TWDS._('CALCULATOR_BLACKLISTED', 'incl. blacklisted items')
      },
      { nodeName: 'span', textContent: '), ' }
    ],
    id: 'TWDS_CALC_include_blacklisted',
    beforeend: filterarea
  })
  TWDS.createEle({
    nodeName: 'label',
    children: [
      { nodeName: 'span', textContent: TWDS._('CALCULATOR_AND', 'and ') },
      { nodeName: 'input', type: 'checkbox', value: 16 },
      { nodeName: 'span', textContent: TWDS._('CALCULATOR_UNWEARABLE', 'unwearable items') }
    ],
    id: 'TWDS_CALC_include_unwearable',
    beforeend: filterarea
  })

  const boncb = function (desc, g) {
    const div = TWDS.createEle('div', {
      className: 'onebonus ' + desc.kind + ' ' + desc.name,
      dataset: { bonusname: desc.name, bonuskind: desc.kind },
      last: g
    })
    if (desc.title) div.title = desc.title
    else if (desc.kind === 'skill') {
      div.title = CharacterSkills.skills[desc.name].name
    }
    TWDS.createEle('img', {
      src: desc.img,
      alt: desc.name,
      last: div
    })
    TWDS.createEle('input', {
      type: 'number',
      className: 'value',
      value: 0,
      last: div,
      onchange: mainchangecb
    })
  }
  let g = null
  for (let i = 0; i < TWDS.calculator.data.length; i++) {
    const x = TWDS.calculator.data[i]
    if (x.kind === 'group') {
      g = TWDS.createEle('div', { className: 'TWDS_calc_group ' + x.cls, last: selectarea })
      continue
    }
    if (x.kind === 'weaponselect') {
      const ct = TWDS.createEle('div', { className: 'TWDS_calc_wgroup ', last: g, style: { verticalAlign: 'top' } })
      TWDS.createEle('label', {
        last: ct,
        children: [
          { nodeName: 'input', type: 'radio', name: 'wtype', value: 'egal', checked: true },
          { nodeName: 'span', textContent: '?', alt: 'any weapon type', style: { fontSize: '45px' } }
        ]
      })
      TWDS.createEle('label', {
        last: ct,
        children: [
          { nodeName: 'input', type: 'radio', name: 'wtype', value: 'shot' },
          { nodeName: 'img', src: '/images/items/right_arm/custom_special_revolver.png?5', alt: 'melee weapons', style: { width: '45px' } }
        ]
      })
      TWDS.createEle('label', {
        last: ct,
        children: [
          { nodeName: 'input', type: 'radio', name: 'wtype', value: 'melee' },
          { nodeName: 'img', src: '/images/items/right_arm/custom_special_tomahawk.png?5', alt: 'melee weapons', style: { width: '45px' } }
        ]
      })
      continue
    }
    if (x.kind === 'attr') {
      boncb(x, g)
    }
    if (x.kind === 'skill') {
      boncb(x, g)
    }
    if (x.kind === 'bonus') {
      boncb(x, g)
    }
  }
  const calcbutton = TWDS.createEle('button.doit', {
    textContent: TWDS._('CALCULATOR_DOIT', 'calculate'),
    last: selectarea
  })
  TWDS.createEle('span.savesearch', {
    last: selectarea,
    children: [
      {
        nodeName: 'input.name4save',
        type: 'text',
        placeholder: TWDS._('CALCULATOR_SAVENAME_PLACEHOLDER', 'name for the save'),
        value: ''
      },
      {
        nodeName: 'button.save',
        textContent: TWDS._('CALCULATOR_SAVE', 'save search'),
        onclick: function () {
          const sels = TWDS.calculator.getselections()
          let n = TWDS.q1('input.name4save', this.parentNode)
          n = n.value.trim()
          if (n === '') {
            new UserMessage(
              TWDS._('CALCULATOR_NEEDNAME', 'You need to specify a name for the saved search!'),
              UserMessage.TYPE_ERROR).show()
            return
          }
          const saved = JSON.parse(window.localStorage.TWDS_calculator_saved || '{}')
          saved[n] = { ...sels.bonus, ...sels.skills }
          window.localStorage.TWDS_calculator_saved = JSON.stringify(saved)
          new UserMessage(
            TWDS._('CALCULATOR_SAVEDAS', 'Saved as $name$', { name: n }), UserMessage.TYPE_SUCCESS).show()
        }
      }, {
        nodeName: 'button.maintainsaves',
        textContent: TWDS._('CALCULATOR_MAINTAINSAVES', 'maintain saved searches'),
        onclick: function () {
          TWDS.calculator.openmaintainwindow()
        }
      }
    ]
  })
  TWDS.createEle('hr', { last: content })
  const resultarea = TWDS.createEle('div', {
    last: content
  })
  calcbutton.onclick = function () {
    TWDS.calculator.exec(filterarea, selectarea, resultarea)
  }

  if (calledpreset !== null) {
    const found = TWDS.q1(".presetselect option[value='" + calledpreset + "']", presetarea)
    if (found) {
      found.selected = true
      presetselect.onchange()
    }
  }

  const e = []
  for (let i = 0; i < Wear.slots.length; i++) {
    const sl = Wear.slots[i]
    const item = Wear.get(sl)
    if (item !== undefined) {
      e.push(item.obj.item_id)
    }
  }
  TWDS.createEle('h3', { textContent: 'Your current equipment gives', last: resultarea })

  const t = TWDS.bonuscalc.getComboBonus(e, true)
  TWDS.calculator.showbonus(t, resultarea)

  sp.appendContent(content)

  win.appendToContentPane(sp.getMainDiv())
}
TWDS.registerStartFunc(function () {
  TWDS.delegate(document.body, 'click', '.TWDS_calc_window .item_inventory', function (ev) {
    const id = this.dataset.twds_item_id
    if (id) {
      const bi = Bag.getItemByItemId(id)
      if (bi) { // calculator may be used to find things to shop for.
        Wear.carry(bi)
      }
    }
  })
})

TWDS.registerExtra('TWDS.calculator.openwindow',
  TWDS._('CALCULATOR_EXTRA_TITLE', 'Calculadora'),
  TWDS._('CALCULATOR_EXTRA_DESC', 'Puntos trabajo / calculadora bonus.')
)
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.townlog = {}
TWDS.townlog.sum = {}
TWDS.townlog.from = ''
TWDS.townlog.to = ''
TWDS.townlog.breakadd = 50
TWDS.townlog.break = 50
TWDS.townlog.handleconstruct = function (name, building, time) {
  if (!(building in TWDS.townlog.sum)) {
    TWDS.townlog.sum[building] = {}
  }
  if (!(name in TWDS.townlog.sum[building])) {
    TWDS.townlog.sum[building][name] = 0
  }
  TWDS.townlog.sum[building][name] += time
}
TWDS.townlog.updategarbage = function (ele) {
  ele.textContent = ''
  for (const [building, v0] of Object.entries(TWDS.townlog.sum)) {
    let bname = building
    if (building === 'Church') bname = 'The unholy altar of the demon of gunpowder'
    if (building === 'Kirche') bname = 'Die unheilige Opferstätte des Dämonen des Schießpulvers'
    TWDS.createEle('h5', { textContent: bname, last: ele })
    const tab = TWDS.createEle('table', { last: ele, className: 'constructing' })
    const a = []
    for (const [u, t] of Object.entries(v0)) {
      a.push([u, t])
    }
    a.sort(function (a, b) {
      return b[1] - a[1]
    })
    for (let i = 0; i < a.length; i++) {
      const u = a[i][0]
      const t = a[i][1]
      const tr = TWDS.createEle('tr', { last: tab })
      TWDS.createEle('th', { last: tr, innerHTML: u })
      TWDS.createEle('th', { last: tr, textContent: t.toFixed(2) + 'h' })
    }
  }
}

TWDS.townlog.do = function () {
  Ajax.remoteCallMode('building_cityhall', 'list_log', {
    town_id: Character.homeTown.town_id,
    page: TWDS.townlog.pageno
  },
  function (json) {
    const x = TWDS.q1('.waitinfo', TWDS.townlog.win.divMain)
    if (x) {
      x.textContent = TWDS._('TOWNLOG_STATUS', 'Page $cur$ / $total$ read', { cur: json.page, total: json.count })
    }
    const useful = TWDS.q1('.useful', TWDS.townlog.win.divMain)
    const g = TWDS.q1('.garbage', TWDS.townlog.win.divMain)
    for (let i = 0; i < json.logs.length; i++) {
      const str = json.logs[i].data
      const dt = json.logs[i].log_date
      if (TWDS.townlog.pageno === 1 && i === 0) {
        TWDS.townlog.from = dt
      }
      TWDS.townlog.to = dt
      let m = str.match(/^(.*) hat (\d+) (\S+) das Gebäude (\S+) ausgebaut/)
      if (m) {
        let t = parseInt(m[2])
        if (m[3] === 'Minuten') {
          t = t / 60
        }
        TWDS.townlog.handleconstruct(m[1], m[4], t)
        continue
      }
      m = str.match(/^(.*) has constructed the building (\S+) for (\d+) (\S+)/)
      if (m) {
        let t = parseInt(m[3])
        if (m[4] === 'minutes') {
          t = t / 60
        }
        TWDS.townlog.handleconstruct(m[1], m[2], t)
        continue
      }
      TWDS.createEle('div', {
        last: useful,
        innerHTML: dt + ' ' + str
      })
    }
    const di = TWDS.q1('.dateinfo', TWDS.townlog.win.divMain)
    di.textContent = TWDS.townlog.to + ' - ' + TWDS.townlog.from
    TWDS.townlog.updategarbage(g)
    if (json.page < json.count && json.page < TWDS.townlog.break) {
      if ((TWDS.townlog.pageno % 10) === 0) {
        TWDS.townlog.pageno++
        window.setTimeout(TWDS.townlog.do, 1500)
      } else {
        TWDS.townlog.pageno++
        TWDS.townlog.do()
      }
    }
    if (json.page < json.count && json.page === TWDS.townlog.break) {
      const b = TWDS.q1('button', TWDS.townlog.win.divMain)
      b.style.display = 'block'
    }
  })
}
TWDS.townlog.openwindow = function () {
  const titlestr = TWDS._('TOWNLOG_TOWNLOG', 'Townlog')
  const win = wman.open('TWDS_townlog_window', titlestr, 'TWDS_townlog_window')
  win.setMiniTitle(titlestr)
  TWDS.townlog.win = win

  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_townlog_container',
    children: [
      { nodeName: 'p', className: 'waitinfo', textContent: TWDS._('TOWNLOG_PLEASE_WAIT', 'please wait') },
      { nodeName: 'button', className: 'TWDS_button', textContent: TWDS._('TOWNLOG_PAUSED', 'paused. click to continue') },
      { nodeName: 'h2', className: 'dateinfo' },
      { nodeName: 'h2', textContent: TWDS._('TOWNLOG_INFORMATION', 'Information') },
      { nodeName: 'p', className: 'useful', textContent: '' },
      { nodeName: 'h2', textContent: TWDS._('TOWNLOG_NOISE', 'Noise') },
      { nodeName: 'p', className: 'garbage', textContent: '' }
    ]

  })
  sp.appendContent(content)
  TWDS.townlog.pageno = 1
  TWDS.townlog.sum = {}
  TWDS.townlog.break = TWDS.townlog.breakadd
  TWDS.townlog.from = ''
  TWDS.townlog.to = ''

  win.appendToContentPane(sp.getMainDiv())
  TWDS.townlog.do()
  const b = TWDS.q1('button', content)
  b.style.display = 'none'
  b.onclick = function () {
    TWDS.townlog.break += TWDS.townlog.breakadd
    this.style.display = 'none'
    TWDS.townlog.do()
  }
}
// this is not translated, because it runs quite early
TWDS.registerExtra('TWDS.townlog.openwindow',
  TWDS._('TOWNLOG_EXTRA_TITLE', 'Registro ciudad'),
  TWDS._('TOWNLOG_EXTRA_DESC', 'Muestra resumen del registro de ciudad. ')
)
// vim: tabstop=2 shiftwidth=2 expandtab

TWDS.craftwindow = {}
TWDS.craftwindow.searchitem = function (str) {
}

TWDS.craftwindow.recalcmax = function (win) {
  // TWDS.delegate(content, 'change', '.search', function (ev) {
  const searchfilter = TWDS.q1('.head .searchfilter', win.divMain).value.trim()
  const quickfilter = TWDS.q1('.head .quickfilter', win.divMain).value.trim()
  const proffilter = parseInt(TWDS.q1('.head .proffilter', win.divMain).value)
  const pointfilter = TWDS.q1('.head input.pointfilter', win.divMain).checked
  const blocktimefilter = TWDS.q1('.head input.blocktimefilter', win.divMain).checked
  const allrows = TWDS.q('.recipeline', win.divMain)
  let rx
  if (searchfilter > '') {
    rx = new RegExp(searchfilter, 'i')
  }
  for (let i = 0; i < allrows.length; i++) {
    const tr = allrows[i]
    const recid = tr.dataset.recipeId
    const itemid = tr.dataset.itemId
    const item = ItemManager.get(itemid)
    const rec = ItemManager.get(recid)
    if (!rec) {
      continue
    }
    const rs = rec.resources
    let hide = false
    tr.style.display = ''
    tr.nextSibling.style.display = ''
    if (searchfilter > '') {
      hide = true
      if (rec.name.search(rx) > -1) {
        hide = false
      }
      if (item.name.search(rx) > -1) {
        hide = false
      }
      for (let j = 0; j < rs.length; j++) {
        const rid = rs[j].item
        const ritem = ItemManager.get(rid)
        if (ritem.name.search(rx) > -1) {
          hide = false
        }
      }
    }
    if (quickfilter > '') {
      if (!TWDS.quickusables.match(item, quickfilter)) { hide = true }
    }
    if (proffilter !== 0) {
      if (proffilter !== rec.profession_id) { hide = true }
    }
    if (pointfilter) {
      if (!(tr.classList.contains('cangetpoints'))) { hide = true }
    }
    if (blocktimefilter) {
      if (!(tr.classList.contains('hasblocktime'))) { hide = true }
    }
    if (hide) {
      tr.style.display = 'none'
      tr.nextSibling.style.display = 'none'
    }
    let max = -1
    for (let j = 0; j < rs.length; j++) {
      const rid = rs[j].item
      const count = rs[j].count
      if (!count) continue
      let inbag = Bag.getItemByItemId(rid)
      if (!inbag) {
        max = 0
        continue
      }
      inbag = inbag.count
      const x = Math.floor(parseInt(inbag) / parseInt(count))
      if (max === -1 || x < max) { max = x }
    }
    if (max === -1) max = 0
    if (rec.blocktime && max) { max = 1 }
    const blocktimeinfo = TWDS.q1('.blocktimeinfo', tr)
    let blocked = false
    blocktimeinfo.style.display = 'none'
    if (rec.blocktime) {
      const lastcraft = TWDS.crafting.myrecipes[recid]
      if (lastcraft) {
        blocktimeinfo.textContent = lastcraft.formatDurationBuffWay()
        blocktimeinfo.style.display = 'inline'
        blocked = true
      }
      tr.classList.add('hasblocktime')
    }
    const maxele = TWDS.q1('.max', tr)
    const inputele = TWDS.q1('.theinput', tr)
    maxele.textContent = '(' + max + ')'
    maxele.dataset.sortval = max
    inputele.max = max
    inputele.min = 0
    const v = parseInt(inputele.value)
    if (v > max) { inputele.value = max }
    let mid
    if (rec.skillcolor) {
      mid = rec.max_level
    } else {
      mid = rec.min_level + Math.round((rec.max_level - rec.min_level) / 2)
    }
    tr.classList.remove('cangetpoints')
    TWDS.q1('.levels', tr).dataset.sortval = rec.min_level
    TWDS.q1('.levels', tr).dataset.sortval2 = mid
    TWDS.q1('.levels .midlevel', tr).classList.remove('current')
    TWDS.q1('.levels .maxlevel', tr).classList.remove('current')
    if (Character.professionId === rec.profession_id &&
      Character.professionSkill >= rec.min_level &&
      Character.professionSkill <= rec.max_level) {
      if (Character.professionSkill <= mid) {
        TWDS.q1('.levels .minlevel', tr).classList.add('current')
      } else {
        TWDS.q1('.levels .maxlevel', tr).classList.add('current')
      }
      if (itemid in TWDS.crafting.mycraftableitems) {
        tr.classList.add('cangetpoints')
      }
    }
    const ib = TWDS.q1('.inbag', tr)
    const inbag = Bag.getItemByItemId(itemid)
    ib.textContent = ''
    ib.dataset.sortval = 0
    if (inbag && inbag.count) {
      ib.textContent = inbag.count
      ib.dataset.sortval = inbag.count
    }

    const craftbutton = TWDS.q1('.docraft', tr)
    const learnbutton = TWDS.q1('.dolearn', tr)
    const profinfo = TWDS.q1('.profinfo', tr)
    craftbutton.style.display = 'none'
    learnbutton.style.display = 'none'
    profinfo.style.display = 'inline'
    if (Character.professionId === rec.profession_id && !blocked) {
      if (itemid in TWDS.crafting.mycraftableitems) {
        craftbutton.style.display = 'inline'
        profinfo.style.display = 'none'
      } else if (Character.professionSkill >= rec.min_level) {
        const inbag = Bag.getItemByItemId(recid)
        if (inbag) {
          learnbutton.style.display = 'inline'
          profinfo.style.display = 'none'
        }
      }
    }
    if (blocked) {
      profinfo.style.display = 'none'
    }

    TWDS.craftwindow.updateresourceline(tr, tr.nextSibling)
  }
}

TWDS.craftwindow.getcontent = function (win) {
  const content = TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_craftwindow_content'
  })
  const myhead = TWDS.createEle({
    nodeName: 'div',
    className: 'head',
    last: content
  })
  const h3 = TWDS.createEle({
    nodeName: 'h3',
    last: myhead
  })
  TWDS.createEle({
    nodeName: 'span',
    textContent: Game.InfoHandler.getLocalString4ProfessionId(Character.professionId),
    last: h3
  })
  TWDS.createEle({
    nodeName: 'span',
    className: 'skill_level',
    textContent: Character.professionSkill,
    last: h3
  })

  TWDS.createEle({
    nodeName: 'label',
    className: 'pointfilter',
    last: myhead,
    title: TWDS._('CRAFTWINDOW_POINTS_TITLE', 'Mostar solo recetas que dan puntos de oficio'),
    children: [
      { nodeName: 'input', type: 'checkbox', value: 1, className: 'pointfilter' },
      { nodeName: 'span', textContent: TWDS._('CRAFTWINDOW_CHECKBOX_LABEL_POINTS', 'solo puntos oficio') }
    ]
  })
  TWDS.createEle({
    nodeName: 'label',
    className: 'blocktimefilter',
    last: myhead,
    title: TWDS._('CRAFTWINDOW_BLOCKTIMEFILTER_TITLE', 'Mostrar solo recetas con bloqueo tiempo (periodo expiración)'),
    children: [
      { nodeName: 'input', type: 'checkbox', value: 1, className: 'blocktimefilter' },
      { nodeName: 'span', textContent: TWDS._('CRAFTWINDOW_CHECKBOX_LABEL_BLOCKTIME', 'solo con bloqueo tiempo') }
    ]
  })
  const profsel = TWDS.createEle({
    nodeName: 'select',
    className: 'proffilter',
    placeholder: TWDS._('CRAFTWINDOW_PROF_FILTER', 'filtro oficio'),
    last: myhead
  })
  TWDS.createEle({ nodeName: 'option', value: 0, last: profsel, selected: Character.professionId === 0, textContent: TWDS._('CRAFTWINDOW_PROF_FILTER', 'Oficio') })
  for (let i = 1; i <= 4; i++) {
    TWDS.createEle({ nodeName: 'option', value: i, last: profsel, selected: i === Character.professionId, textContent: Game.InfoHandler.getLocalString4ProfessionId(i) })
  }

  const sel = TWDS.createEle({
    nodeName: 'select',
    className: 'quickfilter',
    last: myhead
  })
  const qc = TWDS.quickusables.getcategories(0)
  TWDS.createEle({
    nodeName: 'option',
    value: '',
    last: sel,
    textContent: TWDS._('CRAFTWINDOW_QUICK_FILTER', 'Efectos')
  })
  for (let i = 0; i < qc.length; i++) {
    TWDS.createEle({
      nodeName: 'option',
      value: qc[i],
      last: sel,
      textContent: TWDS.quickusables.getcatdesc(qc[i])
    })
  }

  TWDS.createEle({
    nodeName: 'input',
    type: 'text',
    className: 'searchfilter',
    placeholder: TWDS._('CRAFTWINDOW_SEARCH_FILTER', 'Buscar/Filtrar'),
    last: myhead
  })

  TWDS.createEle({ nodeName: 'div', className: 'TWDS_craftwindow_divider1', last: content })
  const table = TWDS.createEle({
    nodeName: 'table',
    className: 'TWDS_craftwindow_table TWDS_sortable',
    dataset: {
      TWDS_ordersavekey: 'TWDS_craftwindow_last_order'
    },
    last: content
  })
  TWDS.createEle({
    nodeName: 'thead',
    last: table,
    children: [
      {
        nodeName: 'tr',
        children: [
          { nodeName: 'th', textContent: '+/-' },
          { nodeName: 'th', textContent: TWDS._('CRAFTWINDOW_TH_PRODUCTNAME', 'Producto'), dataset: { colsel: '.name' } },
          {
            nodeName: 'th',
            textContent: TWDS._('CRAFTWINDOW_TH_POINTS', 'N. Oficio'),
            dataset: { sortmode: 'number', colsel: '.levels' },
            title: TWDS._('CRAFTWINDOW_TH_POINTS_TITLE', 'Niveles de oficio. Alta probabilidad de subir de nivel / baja probabilidad / ninguna posibilidad.')
          },
          {
            nodeName: 'th',
            textContent: TWDS._('CRAFTWINDOW_TH_INPUT', '# A crear'),
            dataset: { sortmode: 'number', colsel: '.numcraftable', sortdefaultorder: -1 },
            title: TWDS._('CRAFTWINDOW_TH_INPUT_TITLE',
              'El nº de elementos que desea crear y el nº de elementos que tiene en recursos para hacerlos')
          },
          {
            nodeName: 'th',
            textContent: TWDS._('CRAFTWINDOW_TH_CRAFTORJOB', 'Crear'),
            title: TWDS._('CRAFTWINDOW_TH_CRAFTORJOB_TITLE', 'Ya sea el botón de crear o el nombre de la artesanía necesaria para el trabajo. Si muestra el nombre de la artesanía, entonces la receta está pendiente de aprender.')
          },
          {
            nodeName: 'th',
            textContent: TWDS._('CRAFTWINDOW_TH_INBAG', '#'),
            dataset: { sortmode: 'number', colsel: '.inbag', sortdefaultorder: -1 },
            title: TWDS._('CRAFTWINDOW_TH_INBAG_TITLE', 'Número de artículos en su inventario')
          }
        ]
      }
    ]
  })
  const tbody = TWDS.createEle({
    nodeName: 'tbody',
    last: table
  })

  const a = win._TWDS_craftitems
  const b = []
  for (const itemid of Object.keys(a)) {
    const recid = a[itemid]
    b.push([itemid, ItemManager.get(itemid).name, recid])
  }
  b.sort(function (a, b) {
    return a[1].trim().localeCompare(b[1].trim())
  })
  /*
  TWDS.createEle({
    nodeName: 'option',
    value: '',
    textContent: TWDS._('PLEASE_SELECT', 'please select'),
    last: itemselector
  })
  */
  for (let i = 0; i < b.length; i++) {
    const it = b[i][0]
    const n = b[i][1]
    const r = b[i][2]
    const rec = ItemManager.get(r)
    let mid
    if (rec.skillcolor) {
      mid = rec.max_level
    } else {
      mid = rec.min_level + Math.round((rec.max_level - rec.min_level) / 2)
    }

    const tr = TWDS.createEle({
      nodeName: 'tr',
      className: 'recipeline',
      dataset: {
        recipeId: r,
        itemId: b[i][0]
      },
      last: tbody
    })
    TWDS.createEle({
      nodeName: 'td',
      textContent: '+',
      className: 'toggle TWDS_clicktarget',
      last: tr
    })
    TWDS.createEle({
      nodeName: 'th',
      className: 'name',
      textContent: n,
      last: tr
    })
    TWDS.createEle({
      nodeName: 'td',
      className: 'levels',
      last: tr,
      children: [
        { nodeName: 'span', className: 'minlevel', textContent: rec.min_level },
        { nodeName: 'span', textContent: '/' },
        { nodeName: 'span', className: 'midlevel', textContent: mid },
        { nodeName: 'span', textContent: '/' },
        { nodeName: 'span', className: 'maxlevel', textContent: rec.max_level }
      ]
    })
    TWDS.createEle({
      nodeName: 'td',
      last: tr,
      children: [
        { nodeName: 'input', type: 'number', value: 1, className: 'theinput' },
        {
          nodeName: 'span',
          textContent: '0',
          className: 'numcraftable max TWDS_clicktarget',
          title: TWDS._('CRAFTWINDOW_TITLE_MAX', 'Sets the maximum amount - 1 if the recipe has a cooldown')
        }
      ]
    })
    const ccon = TWDS.createEle({
      nodeName: 'td',
      last: tr
    })

    TWDS.createEle({
      nodeName: 'button',
      textContent: TWDS._('CRAFTWINDOW_CRAFT', 'crear'),
      className: 'docraft TWDS_clicktarget',
      last: ccon
    })
    TWDS.createEle({
      nodeName: 'button',
      textContent: TWDS._('CRAFTWINDOW_LEARN', 'aprender'),
      className: 'dolearn TWDS_clicktarget',
      dataset: {
        item_id: r
      },
      last: ccon
    })
    TWDS.createEle({
      nodeName: 'span',
      textContent: '',
      className: 'blocktimeinfo',
      title: TWDS._('CRAFTWINDOW_BLOCKTIME_INFO', 'Esta receta tiene u perido de expiración'),
      last: ccon
    })
    TWDS.createEle({
      nodeName: 'span',
      className: 'profinfo',
      textContent: Game.InfoHandler.getLocalString4ProfessionId(rec.profession_id),
      last: ccon
    })
    let inbag = Bag.getItemByItemId(it)
    if (inbag) {
      inbag = inbag.count
    } else {
      inbag = ''
    }
    TWDS.createEle({
      nodeName: 'td',
      last: tr,
      className: 'inbag',
      children: [{
        nodeName: 'span',
        textContent: inbag
      }]
    })

    TWDS.createEle({
      nodeName: 'tr',
      className: 'resourceline sortgrouped',
      dataset: {
        recipeId: r,
        itemId: b[i][0]
      },
      last: tbody
    })
  }
  TWDS.delegate(content, 'click', '.toggle, th.name', function (ev) {
    const tr0 = this.closest('tr')
    const tr1 = tr0.nextSibling
    tr1.classList.toggle('active')
    TWDS.craftwindow.updateresourceline(tr0, tr1)
  })
  TWDS.delegate(content, 'click', '.max', function (ev) {
    const tr = this.closest('tr')
    const input = TWDS.q1('.theinput', tr)
    if (input) {
      input.value = input.max
    }
    const recid = tr.dataset.recipeId
    const rec = ItemManager.get(recid)
    if (rec.blocktime) {
      input.value = 1
    }

    TWDS.craftwindow.updateresourceline(tr, tr.nextSibling)
  })
  TWDS.delegate(content, 'change', '.theinput', function (ev) {
    const tr = this.closest('tr')
    TWDS.craftwindow.updateresourceline(tr, tr.nextSibling)
  })
  TWDS.delegate(content, 'click', '.dolearn', function (ev) {
    window.ItemUse.use(this.dataset.item_id, null, 'recipe')
  })
  TWDS.delegate(content, 'click', '.docraft', function (ev) {
    const tr = this.closest('tr')
    const recid = tr.dataset.recipeId
    const amount = parseInt(TWDS.q1('.theinput', tr).value)
    if (amount && recid) {
      Ajax.remoteCall('crafting', 'start_craft', {
        recipe_id: recid,
        amount: amount
      }, function (resp) {
        const data = resp.msg
        if (resp.error) return new window.MessageError(data).show()

        const ct = tr.closest('.TWDS_craftwindow_content')
        const skl = TWDS.q1('.head .skill_level', ct)
        skl.textContent = data.profession_skill
        Character.setProfessionSkill(data.profession_skill)

        // CharacterWindow.window.$('#recipe_difficult_' + recipe_id).removeClass('middle hard easy').addClass(Crafting.getRecipeColor(ItemManager.get(recipe_id)));
        EventHandler.signal('inventory_changed')
        Character.updateDailyTask('crafts', data.count)

        TWDS.craftwindow.recalcmax(win)
        return new window.MessageSuccess(data.msg).show()
      })
    }
  })
  TWDS.delegate(content, 'click', '.TWDS_crafting_jump', function (ev) {
    const ii = this.dataset.itemid

    const r = TWDS.q1(".recipeline[data-item-id='" + ii + "']", content)
    if (r) {
      TWDS.q1('.head .searchfilter', win.divMain).value = ''
      TWDS.q1('.head .quickfilter', win.divMain).value = ''
      TWDS.q1('.head .proffilter', win.divMain).value = 0
      TWDS.q1('.head .pointfilter', win.divMain).checked = false
      TWDS.q1('.head .blocktimefilter', win.divMain).checked = false
      TWDS.craftwindow.recalcmax(win)
      r.scrollIntoView(true)
    }
  })
  TWDS.delegate(content, 'change', '.searchfilter', function (ev) {
    TWDS.craftwindow.recalcmax(win)
  })
  TWDS.delegate(content, 'change', '.quickfilter', function (ev) {
    TWDS.craftwindow.recalcmax(win)
  })
  TWDS.delegate(content, 'change', '.proffilter', function (ev) {
    TWDS.craftwindow.recalcmax(win)
  })
  TWDS.delegate(content, 'change', '.pointfilter', function (ev) {
    TWDS.craftwindow.recalcmax(win)
  })
  TWDS.delegate(content, 'change', '.blocktimefilter', function (ev) {
    TWDS.craftwindow.recalcmax(win)
  })
  if ('TWDS_craftwindow_last_order_mult' in localStorage) {
    if ('TWDS_craftwindow_last_order_sel' in localStorage) {
      const sel = localStorage.TWDS_craftwindow_last_order_sel
      const mul = parseInt(localStorage.TWDS_craftwindow_last_order_mult)
      const toclick = TWDS.q1("thead th[data-colsel='" + sel + "'", table)
      console.log('toclick', toclick, sel, mul)
      TWDS.sortable.doReal(toclick, mul)
    }
  }

  return content
}
TWDS.craftwindow.craftitemdisplay = function (rsitemid, flagproduct, itemid) {
  const it = ItemManager.get(rsitemid)
  const popup = new ItemPopup(it, {}).popup.getXHTML()
  const container = TWDS.createEle('section', {
    dataset: {
      itemid: rsitemid
    }
  })
  let inbag = Bag.getItemByItemId(rsitemid)
  if (inbag) {
    inbag = inbag.count
  } else {
    inbag = 0
  }
  TWDS.createEle({
    nodeName: 'div',
    className: 'imgwrapper',
    children: [{
      nodeName: 'img',
      className: 'tw_item inventory_item',
      src: it.image,
      alt: it.name,
      title: popup
    }],
    last: container
  })
  TWDS.createEle({
    nodeName: 'div',
    className: 'numbers',
    title: flagproduct
      ? TWDS._('CRAFTWINDOW_TITLE_NUMBERS_PROD', 'Number of products in your inventory.')
      : TWDS._('CRAFTWINDOW_TITLE_NUMBERS_RS', 'resources needed / resources in your inventory.'),
    last: container
  })
  // functions
  const fnc = TWDS.createEle({
    nodeName: 'div',
    className: 'functions',
    last: container
  })
  if (JobsModel.Jobs.length) {
    const jl = JobList.getJobsByItemId(rsitemid)
    let best = null
    for (const job of jl) {
      if (best === null || job.yields[rsitemid].prop > best.yields[rsitemid].prop) {
        best = job
      }
    }

    if (best !== null) {
      // getQuicklink appends &nbsp; - get rid of this
      const t = document.createElement('span')
      t.innerHTML = MinimapWindow.getQuicklink(rsitemid, 'inventory_changed')
      fnc.appendChild(TWDS.q1('span', t))
      const b = TWDS.jobOpenButton(best.id)
      if (b != null) { // null if !automation
        fnc.appendChild(b)
      }
    }
  }

  const bb = TWDS.itemBidButton(rsitemid)
  if (bb) { fnc.appendChild(bb) }
  if (it.spec_type === 'crafting' && !flagproduct) {
    const t = new west.gui.Icon('eye')
    t.setTitle('Jump to this recipe')
    const x = t.divMain[0]
    x.classList.add('TWDS_crafting_jump')
    x.dataset.itemid = rsitemid
    fnc.appendChild(x)
  }

  if (!flagproduct) {
    const it2 = ItemManager.get(itemid)
    const b = TWDS.itemSellButton(rsitemid, 1, it2.name)
    if (b) fnc.appendChild(b)
  } else {
    const b = TWDS.itemSellButton(rsitemid, 1, '')
    if (b) fnc.appendChild(b)
  }
  return container
}
TWDS.craftwindow.itemCraftButton = function (id) {
  const it = ItemManager.get(id)
  if (!it) return null

  if (it.type !== 'yield') return null
  if (it.spec_type !== 'crafting') return null
  if (!TWDS.crafting) return null
  if (!TWDS.crafting.mycraftableitems) return null
  if (!TWDS.crafting.mycraftableitems[id]) return null

  return TWDS.createElement({
    nodeName: 'span',
    className: 'TWDS_craftwindow_jump_button',
    title: TWDS._('TWDS_CRAFTWINDOW_JUMP', 'Jump to the recipe'),
    dataset: { item_id: id },
    childNodes: [
      {
        nodeName: 'img',
        src: Game.cdnURL + '/images/icons/icon_consumable.png',
        alt: ''
      }
    ]
  })
}
TWDS.craftwindow.updateresourceline = function (tr0, tr1) {
  if (!(tr1.classList.contains('active'))) {
    return
  }

  const recid = tr0.dataset.recipeId
  const rec = ItemManager.get(recid)
  const rs = rec.resources
  const l = tr0.children.length
  const itemid = tr0.dataset.itemId

  const value = TWDS.q1('.theinput', tr0).value
  if (tr1.children.length === 0) {
    const rsele = TWDS.createEle({
      nodeName: 'td',
      colSpan: l - 1,
      last: tr1
    })
    const itele = TWDS.createEle({
      nodeName: 'td',
      last: tr1
    })
    for (let j = 0; j < rs.length; j++) {
      rsele.appendChild(TWDS.craftwindow.craftitemdisplay(rs[j].item, 0, itemid))
    }
    itele.appendChild(TWDS.craftwindow.craftitemdisplay(itemid, true))
  }
  const itele = TWDS.q1('td:last-child', tr1)
  for (let j = 0; j < rs.length; j++) {
    const rsitemid = rs[j].item
    const count = rs[j].count
    let inbag = Bag.getItemByItemId(rsitemid)
    if (inbag) {
      inbag = inbag.count
    } else {
      inbag = 0
    }
    const e = TWDS.q1("section[data-itemid='" + rs[j].item + "']", tr1)
    const div = TWDS.q1('.numbers', e)
    let t
    if (value > 1) {
      t = value + '*' + count + '=' + (value * count)
    } else {
      t = count
    }
    div.textContent = ''
    TWDS.createEle({ nodeName: 'span', textContent: t, last: div })
    TWDS.createEle({ nodeName: 'span', textContent: ' / ', last: div })
    TWDS.createEle({ nodeName: 'span', textContent: inbag, last: div })
    const x = TWDS.q1('.TWDS_item_sell_button', e)
    if (x) { x.dataset.count = count * value }
  }
  const div = TWDS.q1('.numbers', itele)
  let inbag = Bag.getItemByItemId(itemid)
  if (inbag) {
    inbag = inbag.count
  } else {
    inbag = 0
  }
  div.textContent = inbag
}

TWDS.craftwindow.open = function (initialid) {
  // load recipes again
  TWDS.crafting.start(function () {
    TWDS.craftwindow.realopen(initialid)
  })
}
TWDS.craftwindow.realopen = function (initialid) {
  const wid = 'TWDS_craftwindow'
  const win = wman.open(wid, 'set', 'TWDS_craftwindow')
  win.setTitle(TWDS._('CRAFTWINDOW_TITLE', 'Elaboraciones'))
  win.setMiniTitle(TWDS._('CRAFTWINDOW_MINITITLE', 'Elaboraciones'))
  if (!('_TWDS_craftitems' in win)) {
    const a = ItemManager.getAll()
    win._TWDS_craftitems = {}
    const done = {}
    for (const iid of Object.keys(a)) {
      const it = a[iid]
      if ('craftitem' in it) {
        // 4 difference recipes for the same item, the 15th birthday cake. Make sure we show that of our profession.
        if (done[it.craftitem]) {
          if (it.profession_id !== Character.professionId) {
            continue
          }
        }
        win._TWDS_craftitems[it.craftitem] = it.item_id
        done[it.craftitem] = 1
      }
    }
  }
  const sp = new west.gui.Scrollpane()
  const content = TWDS.craftwindow.getcontent(win)
  sp.appendContent(content)

  win.appendToContentPane(sp.getMainDiv())
  TWDS.craftwindow.recalcmax(win)
  if (initialid) {
    const r = TWDS.q1(".recipeline[data-item-id='" + initialid + "']", content)
    if (r) {
      r.scrollIntoView(true)
    }
  }
}
TWDS.craftwindow.togglemenudone = false
TWDS.craftwindow.togglemenu = function (val) {
  const entry = $('.button.crafting.background')
  if (val) {
    entry.off('click').on('click', () => { TWDS.craftwindow.open() })
    TWDS.craftwindow.togglemenudone = true
  } else {
    if (TWDS.craftwindow.togglemenudone) { entry.off('click') }
  }
}
TWDS.craftwindow.sorter = function (ev) { TWDS.craftwindow.sorterReal(ev) }
TWDS.craftwindow.sorterReal = function (ev) {

}

TWDS.craftwindow.reload = function (win) {
  const content = TWDS.craftwindow.getcontent(win)
  const old = TWDS.q1('.TWDS_craftwindow_content', win.getMainDiv())
  const sp = old.parentNode
  sp.innerHTML = ''
  sp.appendChild(content)
}
TWDS.registerStartFunc(function () {
  TWDS.registerSetting('bool', 'craftwindow_replace',
    TWDS._('CRAFTWINDOW_SETTING_REPLACE',
      'Reemplazar la ventana de artesanía nativa en el menú por una nueva.'),
    false,
    TWDS.craftwindow.togglemenu,
    'Miscelánea'
  )
  TWDS.delegate(document, 'click', '.TWDS_craftwindow_table thead th[data-colsel]', TWDS.sortable.do)
  TWDS.delegate(document, 'click', '.TWDS_craft_button', function (ev) {
    const ii = this.dataset.item_id
    if (TWDS.settings.craftwindow_replace) {
      TWDS.craftwindow.open(ii)
    } else if ('TW_Calc' in window) {
      window.TW_Calc.openCraftRecipeWindow(ii)
    } else {
      CharacterWindow.open('crafting')
    }
  })
  const handler = function (x) {
    const win = wman.getById('TWDS_craftwindow')
    if (win) {
      setTimeout(function () {
        const win = wman.getById('TWDS_craftwindow')
        if (typeof (win) !== 'undefined') {
          TWDS.craftwindow.recalcmax(win)
        }
      }, 2500)
    }
  }
  EventHandler.listen('inventory_changed', function () { handler('inventory_changed') })
  EventHandler.listen('bag_add', function () { handler('bag_add') })
  EventHandler.listen('wear_changed', function () { handler('wear_changed') })
  /*
  EventHandler.listen(['bag_add', 'inventory_changed', 'wear_changed'], function (e) {
    const win = wman.getById('TWDS_craftwindow')
    if (win) {
      console.log("CHANGE", Bag.getItemByItemId(708000).count)
      setTimeout(function() {
        const win = wman.getById('TWDS_craftwindow')
        if (typeof (win) !== 'undefined') {
          console.log("CHANGE call recalcmax", Bag.getItemByItemId(708000).count)
          TWDS.craftwindow.recalcmax(win);
        }
      },500);
    }
  })
  */
})
TWDS.registerExtra('TWDS.craftwindow.open',
  TWDS._('CRAFTWINDOW_TITLE', 'Artesanal'),
  TWDS._('CRAFTWINDOW_DESC', 'Resumen elaboraciones por oficio.')
)
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.simulator = {}
TWDS.simulator.fillselectarea = function (area, slot, cur) {
  area.innerHTML = ''

  const all = ItemManager.getAll()
  const allthings = []
  for (const it of Object.values(all)) {
    if (it.type === slot) {
      if (it.usetype === 'none') {
        allthings.push([it.item_id, it.name.trim()])
      }
    }
  }
  allthings.sort(function (a, b) {
    return a[1].localeCompare(b[1])
  })

  const c = TWDS.createFilteredSelect('--- select an item to wear ---', allthings)
  area.appendChild(c)
  return c
}
TWDS.simulator.switchslot = function (area, sl, ii) {
  const div = TWDS.q1('.target.' + sl, area)
  div.textContent = ''
  let lv = 0
  let upg = false
  if (ii === 0) {
    TWDS.createEle({
      nodeName: 'div',
      className: 'item item_inventory ',
      children: [
        { nodeName: 'img', src: '/images/inventory/default/' + sl + '_blank.png' }
      ],
      last: div
    })
  } else {
    const it = ItemManager.get(ii)
    const t = new tw2widget.InventoryItem(it).setCharacter(Character).getMainDiv()[0]
    div.appendChild(t)
    lv = it.item_level
    if (it.upgradeable) { upg = true }
  }
  if (upg) {
    const levels = []
    for (let j = 0; j < 6; j++) {
      levels.push(TWDS.createEle({
        nodeName: 'option',
        value: j,
        textContent: j,
        selected: j === lv
      }))
    }
    TWDS.createEle({
      nodeName: 'select',
      className: 'leveling',
      last: div,
      children: levels
    })
  }
}
TWDS.simulator.getcombo = function (comboarea) {
  const out = []
  if (comboarea.classList.contains('disabled')) return out
  const ia = TWDS.q1('.itemarea', comboarea)
  if (!ia) { console.log('strange: .itemarea not found in', comboarea); return }
  const a = TWDS.q('.target .item', ia)
  for (let i = 0; i < a.length; i++) {
    out.push(parseInt(a[i].dataset.twds_item_id))
  }
  return out
}
TWDS.simulator.updatedescriptions = function (win) {
  const handleonecombo = function (ca) {
    const da = TWDS.q1('.descarea', ca)
    if (!da) { console.log('strange: .descarea not found in', ca); return }

    const items = TWDS.simulator.getcombo(ca)
    da.textContent = TWDS.describeItemCombo(items)
  }
  const combos = TWDS.q('.comboarea', win.divMain)
  console.log('COMBOS', combos)
  for (let i = 0; i < combos.length; i++) {
    handleonecombo(combos[i])
  }
}
TWDS.simulator.updateresult = function (win) {
  const charPremium = Number(Premium.hasBonus('character'))
  const moneyPremium = Number(Premium.hasBonus('money'))
  const start = new Date().getTime()
  TWDS.simulator.updatedescriptions(win)

  const ra = TWDS.q1('.resultarea', win.divMain)
  if (!ra) { console.log('strange: .resultarea not found in', win); return }

  const comboarea0 = TWDS.q1('.comboarea0', win.divMain)
  const comboarea1 = TWDS.q1('.comboarea1', win.divMain)
  const combo0 = TWDS.simulator.getcombo(comboarea0)
  const combo1 = TWDS.simulator.getcombo(comboarea1)

  const bo0 = TWDS.bonuscalc.getComboBonus(combo0, true)
  const bo1 = TWDS.bonuscalc.getComboBonus(combo1, true)
  bo0.speedresult = TWDS.bonuscalc.getSpeed(combo0)
  if (combo1.length) {
    bo1.speedresult = TWDS.bonuscalc.getSpeed(combo1)
  }

  ra.textContent = ''
  const tab = TWDS.createEle('table.results', { last: ra, style: { margin: '0 auto' } })
  const tbody = TWDS.createEle('tbody', { last: tab })

  const line = function (k, text, mult) {
    if (!bo0[k] && !bo1[k]) return
    const clhack = function (a, b) {
      if (combo1.length === 0) return ''
      if (a > b) return 'green'
      if (b > a) return 'red'
      return ''
    }
    const tr = TWDS.createEle('tr', { last: tbody })
    let v0 = ''
    let v1 = ''
    let have = 0
    if (k in bo0) {
      v0 = parseInt(bo0[k])
      if (mult) v0 = parseFloat(bo0[k] * mult).toFixed(0)
      have++
    }
    if (k in bo1) {
      v1 = parseInt(bo1[k])
      if (mult) v1 = parseFloat(bo1[k] * mult).toFixed(0)
      have++
    }
    if (have === 2) {
      TWDS.createEle('td', { textContent: v0 - v1, last: tr, className: 'delta' })
    } else {
      TWDS.createEle('td', { last: tr })
    }
    TWDS.createEle('td', { textContent: v0, last: tr, className: clhack(v0, v1) })
    TWDS.createEle('th', { textContent: text, last: tr })
    if (combo1.length === 0) {
      TWDS.createEle('td', { last: tr })
      TWDS.createEle('td', { last: tr })
    } else {
      TWDS.createEle('td', { textContent: v1, last: tr, className: clhack(v1, v0) })
      if (have === 2) {
        TWDS.createEle('td', { textContent: v1 - v0, last: tr, className: 'delta' })
      } else {
        TWDS.createEle('td', { last: tr })
      }
    }
  }
  for (let i = 0; i < CharacterSkills.allAttrKeys.length; i++) {
    const attr = CharacterSkills.allAttrKeys[i]
    line(attr, CharacterSkills.keyNames[attr])
  }
  for (let i = 0; i < CharacterSkills.allSkillKeys.length; i++) {
    const skill = CharacterSkills.allSkillKeys[i]
    line(skill, CharacterSkills.keyNames[skill])
  }
  line('experience', 'experience (+%)', 100)
  line('dollar', 'money (+%)', 100)
  line('luck', 'luck (+%)', 100)
  line('drop', 'drop (+%)', 100)
  line('speed', 'speed bonus (+%)', 100)
  line('speedresult', 'speed')
  line('regen', 'regeneration (+%)', 100)
  line('pray', 'pray (+)')
  line('fort_offense', 'fort battle offense')
  line('fort_defense', 'fort battle defense')
  line('fort_resistance', 'fort battle resistance')
  line('fort_offense_sector', 'offense sector bonus')
  line('fort_defense_sector', 'defense sector bonus')
  line('fort_damage_sector', 'damage sector bonus')

  const tab2 = TWDS.createEle('table.alljobs.TWDS_sortable', {
    last: ra,
    dataset: {
      searchfilter: '.searchfilter'
    }
  })

  TWDS.delegate(tab2, 'click', 'thead th[data-colsel]', TWDS.sortable.do)
  TWDS.createEle('thead', {
    last: tab2,
    children: [
      {
        nodeName: 'tr',
        children: [
          { nodeName: 'th', colSpan: 7, textContent: 'Combo #1' },
          {
            nodeName: 'th',
            colSpan: 2,
            children: [
              {
                nodeName: 'input',
                type: 'text',
                className: 'searchfilter',
                onchange: TWDS.sortable.search
              }
            ]
          },
          { nodeName: 'th', colSpan: 7, textContent: 'Combo #2, or best' }
        ]
      },
      {
        nodeName: 'tr',
        children: [

          { nodeName: 'th', textContent: 'LP', dataset: { colsel: '.c.laborpoints', sortmode: 'number' } },
          { nodeName: 'th', textContent: 'Job Points', dataset: { colsel: '.c.jobpoints', sortmode: 'number' } },
          { nodeName: 'th', textContent: '*', dataset: { colsel: '.c.stars', sortmode: 'number' } },
          { nodeName: 'th', textContent: 'XP', dataset: { colsel: '.c.xp', sortmode: 'number' } },
          { nodeName: 'th', textContent: '$', dataset: { colsel: '.c.dollar', sortmode: 'number' } },
          { nodeName: 'th', textContent: 'Luck', dataset: { colsel: '.c.luck', sortmode: 'number' } },
          { nodeName: 'th', textContent: 'Danger', dataset: { colsel: '.c.danger', sortmode: 'number' } },

          { nodeName: 'th', textContent: '#', dataset: { colsel: '.jobid', sortmode: 'number' } },
          { nodeName: 'th', textContent: 'Name', dataset: { colsel: '.name' } },

          { nodeName: 'th', textContent: 'LP', dataset: { colsel: '.b.laborpoints', sortmode: 'number' } },
          { nodeName: 'th', textContent: 'Job Points', dataset: { colsel: '.b.jobpoints', sortmode: 'number' } },
          { nodeName: 'th', textContent: '*', dataset: { colsel: '.b.stars', sortmode: 'number' } },
          { nodeName: 'th', textContent: 'XP', dataset: { colsel: '.b.xp', sortmode: 'number' } },
          { nodeName: 'th', textContent: '$', dataset: { colsel: '.b.dollar', sortmode: 'number' } },
          { nodeName: 'th', textContent: 'Luck', dataset: { colsel: '.b.luck', sortmode: 'number' } },
          { nodeName: 'th', textContent: 'Danger', dataset: { colsel: '.b.danger', sortmode: 'number' } }
        ]
      }
    ]
  })
  const tbody2 = TWDS.createEle('tbody', { last: tab2 })
  const calcit = function (jobid, bonusthing) {
    const job = JobList.getJobById(jobid)
    let laborpoints = 0
    for (const [skillname, mult] of Object.entries(job.skills)) {
      if (bonusthing[skillname]) {
        laborpoints += bonusthing[skillname] * mult
      }
      const attr = CharacterSkills.skills[skillname].attr_key
      if (attr && bonusthing[attr]) {
        laborpoints += bonusthing[attr] * mult
      }
      laborpoints += CharacterSkills.skills[skillname].points * mult
    }
    if (bonusthing.job) {
      laborpoints += bonusthing.job
    }
    const jc = new JobCalculator(laborpoints, job.malus + 1)
    jc.calcStars((laborpoints / (job.malus + 1)))
    const curstars = jc.getJobstarsValue()
    let stars = ''
    let color = '#CD7F32'
    let workstars = curstars
    if (workstars > 10) {
      color = 'gold'
      workstars -= 10
    } else if (workstars > 5) {
      color = 'silver'
      workstars -= 5
    }
    for (let j = 1; j < workstars + 1; j++) {
      stars += '*'
    }
    let tmoney = 1
    if (bonusthing.dollar) { tmoney = 1 + bonusthing.dollar }

    let charxpmult = 1
    if (Character.charClass === 'worker') {
      if (charPremium) charxpmult = 1.1
      else charxpmult = 1.05
    }
    let txpmult = 1
    if (bonusthing.xp) { txpmult = 1 + bonusthing.xp }
    let dangmult = 1
    if (Character.charClass === 'adventurer') {
      if (charPremium) dangmult = 0.8
      else charxpmult = 0.9
    }
    return {
      laborpoints: laborpoints,
      jobpoints: laborpoints - job.malus + 1,
      curstars: curstars,
      stars: stars,
      tmoney: tmoney,
      charxpmult: charxpmult,
      txpmult: txpmult,
      dangmult: dangmult,
      color: color,
      name: job.name,
      malus: job.malus,
      starcount: curstars
    }
  }
  for (let idx = 0; idx < JobsModel.Jobs.length; idx++) {
    const jobid = JobsModel.Jobs[idx].id
    const d = calcit(jobid, bo0)
    const best = TWDS.getJobBestFromCache(jobid)
    let e = null
    if (combo1.length) {
      e = calcit(jobid, bo1)
    } else if (best) {
      e = calcit(jobid, TWDS.bonuscalc.getComboBonus(best.items), true)
    }

    const tr = TWDS.createEle('tr', {
      children: [
        { nodeName: 'td.c.laborpoints', textContent: d.laborpoints },
        { nodeName: 'td.c.jobpoints', textContent: d.jobpoints },
        {
          nodeName: 'td.c.stars.ra',
          textContent: d.starcount
        },
        {
          nodeName: 'td.c.xp.ra',
          textContent:
            (TWDS.TWDBcalcExp(d.laborpoints, d.malus + 1,
              TWDS.jobData['job_' + jobid].job_exp, 100, 1) * d.charxpmult * d.txpmult).toFixed(0)
        },
        {
          nodeName: 'td.c.dollar.ra',
          textContent:
          Math.round(TWDS.TWDBcalcWage(d.laborpoints, d.malus + 1,
            TWDS.jobData['job_' + jobid].job_wages, 100, 1) * (moneyPremium ? 1.5 : 1) * d.tmoney)
        },
        {
          nodeName: 'td.c.luck.ra',
          textContent:
          Math.round(TWDS.TWDBcalcLuck(d.laborpoints, d.malus + 1,
            TWDS.jobData['job_' + jobid].job_luck, 100, 1) * 3 * (charPremium ? 1.5 : 1))
        },
        {
          nodeName: 'td.c.danger.ra',
          textContent:
          (TWDS.TWDBcalcDanger(d.laborpoints, d.malus + 1,
            TWDS.jobData['job_' + jobid].job_danger, 100, 1) * d.dangmult).toFixed(1) + '%'
        },

        { nodeName: 'th.jobid.ra', textContent: jobid },
        { nodeName: 'th.name', textContent: d.name },

        { nodeName: 'td.b.laborpoints.ra' },
        { nodeName: 'td.b.jobpoints.ra' },
        { nodeName: 'td.b.stars.ra' },
        { nodeName: 'td.b.xp.ra' },
        { nodeName: 'td.b.dollar.ra' },
        { nodeName: 'td.b.luck.ra' },
        { nodeName: 'td.b.danger.ra' }
      ],
      last: tbody2
    })
    if (e) {
      TWDS.q1('.b.laborpoints', tr).textContent = e.laborpoints
      TWDS.q1('.b.jobpoints', tr).textContent = e.jobpoints
      TWDS.q1('.b.stars', tr).textContent = e.starcount
      TWDS.q1('.b.xp', tr).textContent =
          (TWDS.TWDBcalcExp(e.laborpoints, e.malus + 1,
            TWDS.jobData['job_' + jobid].job_exp, 100, 1) * e.charxpmult * e.txpmult).toFixed(0)
      TWDS.q1('.b.dollar', tr).textContent =
          Math.round(TWDS.TWDBcalcWage(e.laborpoints, e.malus + 1,
            TWDS.jobData['job_' + jobid].job_wages, 100, 1) * (moneyPremium ? 1.5 : 1) * e.tmoney)
      TWDS.q1('.b.luck', tr).textContent =
          Math.round(TWDS.TWDBcalcLuck(d.laborpoints, d.malus + 1,
            TWDS.jobData['job_' + jobid].job_luck, 100, 1) * 3 * (charPremium ? 1.5 : 1))
      TWDS.q1('.b.danger', tr).textContent =
          (TWDS.TWDBcalcDanger(e.laborpoints, e.malus + 1,
            TWDS.jobData['job_' + jobid].job_danger, 100, 1) * e.dangmult).toFixed(1) + '%'
      let ar = []
      if (d.laborpoints > e.laborpoints) {
        ar = TWDS.q('.c', tr)
      } else if (d.laborpoints < e.laborpoints) {
        ar = TWDS.q('.b', tr)
      } else {
        ar = TWDS.q('.b, .c', tr)
      }
      for (let i = 0; i < ar.length; i++) {
        ar[i].style.color = 'green'
      }
    }
  }
  const now = new Date().getTime()
  console.log('simulator update took', (now - start), 'ms')

/*
  const tab = TWDS.q1('table', ra)
  TWDS.createEle('tr', {
    children: [
      { nodeName: 'th', textContent: 'total speed' },
      { nodeName: 'td', textContent: Math.round(sp) + '%' }
    ],
    last: tab
  })
  const tab2 = TWDS.createEle('table.alljobs.TWDS_sortable', {
    last: ra,
    dataset: {
      searchfilter: '.searchfilter'
    }
  })
  */
}
TWDS.simulator.windowclosedhandler = function () {
}
TWDS.simulator.openwindow = function (paraitems) {
  const myname = 'TWDS_simulator_window'
  const win = wman.open(myname, TWDS._('SIMULATOR_TITLE', 'Simulator'), 'TWDS_simulator_window')
  console.log('win', win)
  win.setMiniTitle('Simulator')

  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_simulator_container'
  })

  const createarrowarea = function (pa, par) {
    const area = TWDS.createEle('div.arrowarea', { last: pa })
    const out = {}
    out.right = TWDS.createEle({
      nodeName: 'div.right.linklike',
      last: area,
      textContent: '\u2192'
    })
    out.left = TWDS.createEle({
      nodeName: 'div.left.linklike',
      last: area,
      textContent: '\u2190'
    })
    out.both = TWDS.createEle({
      nodeName: 'div.leftright.linklike',
      last: area,
      textContent: '\u21c4'
    })
    return out
  }

  const createcomboarea = function (pa, par, itemstouse, comboindex) {
    const comboarea = TWDS.createEle('div.comboarea.comboarea' + comboindex, { last: pa, dataset: { comboindex: comboindex } })
    if (comboindex === 1) comboarea.classList.add('disabled')
    const h2 = TWDS.createEle('h2.rp_job_header', {
      last: comboarea,
      textContent: 'Combo #' + (comboindex + 1)
    })
    const checkuncheck = function (ele, flag) {
      const ca = ele.closest('.comboarea')
      console.log('checkuncheck', ele, flag, ca)
      if (flag) {
        ca.classList.remove('disabled')
      } else {
        ca.classList.add('disabled')
      }
    }
    let checkbox
    if (comboindex) {
      checkbox = TWDS.createEle({
        nodeName: 'input',
        type: 'checkbox',
        value: '1',
        last: h2,
        onchange: function () {
          checkuncheck(this, this.checked)
          TWDS.simulator.updateresult(win)
        }
      })
    }
    TWDS.createEle({
      nodeName: 'div.usecurrent.linklike',
      last: comboarea,
      textContent: '\u21ba',
      title: TWDS._('SIMULATOR_TAKE_CURRENT', 'Take the currently used equipment')
    })
    const setselectarea = TWDS.createEle('div', {
      className: 'setselectarea',
      last: comboarea
    })
    const itemarea = TWDS.createEle('div', {
      className: 'itemarea',
      last: comboarea
    })
    TWDS.createEle('div', {
      className: 'selectarea',
      last: comboarea
    })
    TWDS.createEle('div', {
      className: 'descarea',
      last: comboarea
    })
    const setselcontainer = TWDS.createFilteredSelect('--- select a set to wear ---', par)
    setselectarea.appendChild(setselcontainer)
    const setsel = TWDS.q1('select', setselcontainer)
    setsel.onchange = function () {
      const key = setsel.value
      if (key === '') return
      const d = west.storage.ItemSetManager.get(key)
      const items = d.items
      for (let j = 0; j < items.length; j++) {
        const bid = items[j]
        const it = ItemManager.getByBaseId(bid)
        TWDS.simulator.switchslot(itemarea, it.type, it.item_id)
      }
      TWDS.simulator.updateresult(win, comboindex)
    }

    const myslots = ['head', 'neck', 'body', 'belt', 'pants', 'foot', 'right_arm', 'left_arm', 'animal', 'yield']
    let wehaditems = false
    for (let i = 0; i < myslots.length; i++) {
      const sl = myslots[i]
      TWDS.createEle({
        nodeName: 'div',
        className: 'target ' + sl,
        dataset: {
          slot: sl
        },
        last: itemarea
      })
      const w = Wear.get(sl)
      if (itemstouse[sl]) {
        TWDS.simulator.switchslot(itemarea, sl, itemstouse[sl].item_id)
        wehaditems = true
      } else if (w) {
        TWDS.simulator.switchslot(itemarea, sl, w.obj.item_id)
      } else {
        TWDS.simulator.switchslot(itemarea, sl, 0)
      }
    }
    wehaditems = 0
    if (wehaditems && comboindex) {
      checkbox.click()
      checkuncheck(checkbox, true)
      console.log('checked it', wehaditems)
    }

    return comboarea
  }

  let allsets = west.storage.ItemSetManager._setArray.slice(0)
  allsets = TWDS.itemsettab.fixallsets(allsets)
  const par = []
  for (let i = 0; i < allsets.length; i++) {
    const k = allsets[i].key
    const n = allsets[i].name
    par.push([k, n])
  }

  const itemstouse1 = {}
  const itemstouse2 = {}
  if (paraitems === 'debug') {
    paraitems = null
    const ds1 = { head: 53468000, neck: 53469000, body: 53470000, belt: 53471000, pants: 53472000, foot: 53473000, right_arm: 53475000, left_arm: 53476000, animal: 53550000, yield: 53551000 }
    const ds2 = { head: 52248000, neck: 52249000, body: 52250000, belt: 52251000, pants: 52252000, foot: 52253000, right_arm: 52257000, left_arm: 52258000, animal: 52254000, yield: 52255000 }
    for (const sl of Object.keys(ds1)) {
      itemstouse1[sl] = ItemManager.get(ds1[sl])
    }
    for (const sl of Object.keys(ds2)) {
      itemstouse2[sl] = ItemManager.get(ds2[sl])
    }
  }
  if (paraitems) {
    for (let i = 0; i < paraitems.length; i++) {
      if (paraitems[i]) {
        const it = ItemManager.get(paraitems[i])
        if (it) { itemstouse1[it.type] = it }
      }
    }
  }
  const caparent = TWDS.createEle('div.comboareacontainer', { last: content })
  const ca0 = createcomboarea(caparent, par, itemstouse1, 0)
  const functions = createarrowarea(caparent, par)
  const ca1 = createcomboarea(caparent, par, itemstouse2, 1)

  TWDS.createEle('hr', {
    last: content
  })
  TWDS.createEle('div', {
    className: 'resultarea',
    last: content
  })
  TWDS.createEle('div.simhelp', {
    last: content,
    innerHTML: '<p>Here you can combine any equipment to see what would happen before you buy.' +
      '<p>When you click on an image a new selectbox will be shown where you can select anything which might be worn in that slot, ' +
      "even if gender, class or level wouldn't allow to wear it."
  })

  TWDS.delegate(content, 'click', '.target .item', function () {
    const comboarea = this.closest('.comboarea')
    const comboindex = comboarea.dataset.comboindex
    const itemarea = TWDS.q1('.itemarea', comboarea)
    const sl = this.parentNode.dataset.slot
    let cur = TWDS.q1('.target.' + sl + ' .item', itemarea)
    if (cur) cur = cur.dataset.twds_item_id
    const selectarea = TWDS.q1('.selectarea', comboarea)
    const selcontainer = TWDS.simulator.fillselectarea(selectarea, sl, cur)
    const sel = TWDS.q1('select', selcontainer)
    sel.onchange = function () {
      TWDS.simulator.switchslot(itemarea, sl, this.value)
      sel.closest('.filteredselectcontainer').remove()
      TWDS.simulator.updateresult(win, comboindex)
    }
  })
  TWDS.delegate(content, 'change', '.target .leveling', function () {
    const comboarea = this.closest('.comboarea')
    const comboindex = comboarea.dataset.comboindex
    const itemarea = TWDS.q1('.itemarea', comboarea)
    const sl = this.parentNode.dataset.slot
    let cur = TWDS.q1('.target.' + sl + ' .item', itemarea)
    if (!cur) return
    cur = cur.dataset.twds_item_id
    let it = ItemManager.get(cur)
    it = ItemManager.get(it.item_base_id * 1000 + parseInt(this.value))
    TWDS.simulator.switchslot(itemarea, it.type, it.item_id)
    TWDS.simulator.updateresult(win, comboindex)
  })
  TWDS.delegate(content, 'click', '.usecurrent', function () {
    const comboarea = this.closest('.comboarea')
    const itemarea = TWDS.q1('.itemarea', comboarea)

    const myslots = ['head', 'neck', 'body', 'belt', 'pants', 'foot', 'right_arm', 'left_arm', 'animal', 'yield']
    for (let i = 0; i < myslots.length; i++) {
      const sl = myslots[i]
      const w = Wear.get(sl)
      if (w) {
        TWDS.simulator.switchslot(itemarea, sl, w.obj.item_id)
      } else {
        TWDS.simulator.switchslot(itemarea, sl, 0)
      }
    }
  })

  functions.left.onclick = function () {
    const ia0 = TWDS.q1('.itemarea', ca0)
    const ia1 = TWDS.q1('.itemarea', ca1)
    const myslots = ['head', 'neck', 'body', 'belt', 'pants', 'foot', 'right_arm', 'left_arm', 'animal', 'yield']
    for (let i = 0; i < myslots.length; i++) {
      const sl = myslots[i]
      const id = TWDS.q1('.target.' + sl + ' .item_inventory', ia1).dataset.twds_item_id
      TWDS.simulator.switchslot(ia0, sl, id)
    }
    TWDS.simulator.updateresult(win, 0)
  }
  functions.right.onclick = function () {
    const ia0 = TWDS.q1('.itemarea', ca0)
    const ia1 = TWDS.q1('.itemarea', ca1)
    const myslots = ['head', 'neck', 'body', 'belt', 'pants', 'foot', 'right_arm', 'left_arm', 'animal', 'yield']
    for (let i = 0; i < myslots.length; i++) {
      const sl = myslots[i]
      const id = TWDS.q1('.target.' + sl + ' .item_inventory', ia0).dataset.twds_item_id
      TWDS.simulator.switchslot(ia1, sl, id)
    }
    TWDS.simulator.updateresult(win, 1)
  }
  functions.both.onclick = function () {
    const ia0 = TWDS.q1('.itemarea', ca0)
    const ia1 = TWDS.q1('.itemarea', ca1)
    const myslots = ['head', 'neck', 'body', 'belt', 'pants', 'foot', 'right_arm', 'left_arm', 'animal', 'yield']
    for (let i = 0; i < myslots.length; i++) {
      const sl = myslots[i]
      const id0 = TWDS.q1('.target.' + sl + ' .item_inventory', ia0).dataset.twds_item_id
      const id1 = TWDS.q1('.target.' + sl + ' .item_inventory', ia1).dataset.twds_item_id
      TWDS.simulator.switchslot(ia0, sl, id1)
      TWDS.simulator.switchslot(ia1, sl, id0)
    }
    TWDS.simulator.updateresult(win, 0)
    TWDS.simulator.updateresult(win, 1)
  }

  sp.appendContent(content)
  win.appendToContentPane(sp.getMainDiv())
  TWDS.simulator.windowclosedhandler()

  TWDS.simulator.updateresult(win, 0)
  TWDS.simulator.updatedescriptions(win, 0)
}
TWDS.registerStartFunc(function () {
  EventHandler.listen('WINDOW_CLOSED', function () { TWDS.simulator.windowclosedhandler() })
})

TWDS.registerExtra('TWDS.simulator.openwindow', 'Simulador', 'Combina virtualmente cualquier equipo.')
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.bufflist = {}
TWDS.bufflist.upsdata = {}

TWDS.bufflist.row = function (it, tbody, searchstrings) {
  const addprice = function (price, currency, td) {
    TWDS.createEle('div', { textContent: price + ' ' + currency, last: td })
  }
  const tr = TWDS.createEle({
    nodeName: 'tr',
    last: tbody
  })

  TWDS.createEle('th', { textContent: it.name, last: tr, className: 'name' })
  TWDS.createEle('td', { textContent: it.item_id, last: tr, className: 'item_id' })
  let td = TWDS.createEle('td', { className: 'effect', last: tr })
  let eff = 0
  for (let i = 0; i < it.usebonus.length; i++) {
    const st = {}
    for (let j = 0; j < searchstrings.length; j++) {
      if (it.usebonus[i].toLocaleLowerCase().search(searchstrings[j].toLocaleLowerCase()) !== -1) {
        st.fontWeight = 'bold'
        const myRegexp = /([0-9.,]+)/g
        const matches = myRegexp.exec(it.usebonus[i])
        if (matches && matches[1]) {
          eff += parseInt(matches[1])
        }
      }
    }
    TWDS.createEle('div', { textContent: it.usebonus[i], last: td, style: st })
  }
  td.dataset.sortval = eff
  TWDS.createEle('td', { className: 'count', last: tr, textContent: Bag.getItemCount(it.item_id) })
  td = TWDS.createEle('td', { className: 'price', last: tr, dataset: { sortval: 0 } })
  for (const list of Object.values(TWDS.bufflist.upsdata.inventory)) {
    let found = false
    for (let i = 0; i < list.length; i++) {
      if (list[i].item_id === it.item_id) {
        const e = list[i]
        let f = 1
        if (e.reduced_value) { f = 1.0 - (e.reduced_value / 100) }
        if (e.currency & 1) { addprice(f * e.price_bonds, 'bonds', td) }
        if (e.currency & 2) { addprice(f * e.price_nuggets, 'nuggets', td) }
        if (e.currency & 4) { addprice(f * e.price_dollar, 'dollar', td) }
        if (e.currency & 8) { addprice(f * e.price_veteran, 'veteran', td) }
        if (e.currency) found = true
      }
    }
    if (found) { break }
  }
  td = TWDS.createEle('td', { className: 'time', last: tr, dataset: { sortval: 9999 * 3600 } })
  if (it.spec_type === 'crafting') {
    const d = TWDS.items.data[it.item_id]
    if (d && d.time) {
      td.textContent = (3600 * d.time).formatDuration()
      td.dataset.sortval = d.time * 3600
    }
  }
  td = TWDS.createEle('td', { className: 'type', last: tr })
  td.textContent = it.usetype
  if (it.has_cooldown) {
    TWDS.createEle('span', {
      last: td,
      innerHTML: ' &#128337;',
      title: 'this item has a cooldown period'
    })
  }
  td = TWDS.createEle('td', { className: 'functions', last: tr })
  let t
  if (it.spec_type === 'crafting') {
    t = TWDS.itemAnyCraftButton(it.item_id)
    if (t) td.appendChild(t)
  }
  t = TWDS.itemBidButton(it.item_id)
  if (t) td.appendChild(t)
  if (Bag.getItemCount(it.item_id)) {
    t = TWDS.itemSellButton(it.item_id)
    if (t) td.appendChild(t)
  }
}
TWDS.bufflist.doit = function (container, effect) {
  const _ = function (x) {
    const Y = 'BUFFLIST_' + x.toLocaleUpperCase()
    return TWDS._(Y, x)
  }
  container.innerHTML = ''
  const tab = TWDS.createEle({
    nodeName: 'table',
    className: 'TWDS_bufflist_table TWDS_sortable',
    last: container
  })
  const thead = TWDS.createEle({
    nodeName: 'thead',
    last: tab
  })
  const tr = TWDS.createEle('tr', { last: thead })
  TWDS.createEle('th', { last: tr, textContent: _('nombre'), dataset: { colsel: '.name' } })
  TWDS.createEle('th', { last: tr, textContent: _('id'), dataset: { colsel: '.item_id', sortmode: 'number' } })
  TWDS.createEle('th', { last: tr, textContent: _('efectos'), dataset: { colsel: '.effect', sortmode: 'number' } })
  TWDS.createEle('th', { last: tr, textContent: '#', dataset: { colsel: '.count', sortmode: 'number' } })
  TWDS.createEle('th', { last: tr, textContent: _('precio'), dataset: { nocolsel: '.price', sortmode: 'number' } })
  TWDS.createEle('th', { last: tr, textContent: _('tiempo'), dataset: { colsel: '.time', sortmode: 'number' } })
  TWDS.createEle('th', { last: tr, textContent: _('tipos'), dataset: { colsel: '.type' } })
  TWDS.createEle('th', { last: tr, textContent: _('funciones') })
  const tbody = TWDS.createEle({
    nodeName: 'tbody',
    last: tab
  })
  const searchstrings = TWDS.quickusables.usables[effect]

  const items = ItemManager.getAll()
  for (const it of Object.values(items)) {
    if (it.type === 'yield' && (it.usetype === 'use' || it.usetype === 'buff')) {
      if (TWDS.quickusables.match(it, effect)) {
        TWDS.bufflist.row(it, tbody, searchstrings)
      }
    }
  }
}
TWDS.bufflist.openwindowReal = function () {
  const titlestr = TWDS._('BUFFLIST_TITLE', 'Buffs')
  const win = wman.open('TWDS_bufflist_window', titlestr)
  win.setMiniTitle(titlestr)
  TWDS.bufflist.win = win

  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_bufflist_container'
  })
  const myhead = TWDS.createEle('div', {
    className: 'TWDS_bufflist_header',
    last: content
  })
  const mymain = TWDS.createEle('div', {
    className: 'TWDS_bufflist_main',
    last: content
  })
  const sel = TWDS.createEle({
    nodeName: 'select',
    className: 'quickfilter_effect',
    last: myhead
  })
  const qc = TWDS.quickusables.getcategories(0)
  TWDS.createEle({
    nodeName: 'option',
    value: '',
    last: sel,
    textContent: TWDS._('BUFFLIST_QUICK_FILTER', 'Efectos')
  })
  for (let i = 0; i < qc.length; i++) {
    TWDS.createEle({
      nodeName: 'option',
      value: qc[i],
      last: sel,
      textContent: TWDS.quickusables.getcatdesc(qc[i])
    })
  }

  sp.appendContent(content)

  sel.onchange = function () {
    const h = this.closest('.TWDS_bufflist_header')
    if (!h) return
    const e = TWDS.q1('.quickfilter_effect', h).value
    if (e > '') { TWDS.bufflist.doit(mymain, e) }
  }
  TWDS.delegate(content, 'click', '.TWDS_bufflist_table thead th[data-colsel]', TWDS.sortable.do)

  win.appendToContentPane(sp.getMainDiv())
}
TWDS.bufflist.openwindow = function () {
  Ajax.get('shop_trader', 'index', {}, function (json) {
    TWDS.bufflist.upsdata = json
    TWDS.bufflist.openwindowReal()
  })
}
// this is not translated, because it runs quite early
TWDS.registerStartFunc(function () {
  TWDS.registerExtra('TWDS.bufflist.openwindow',
    TWDS._('BUFFLIST_EXTRA_TITLE', 'Buffs'),
    TWDS._('BUFFLIST_EXTRA_DESC', 'Muestra los buffs.')
  )
})
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.achievements = {}
TWDS.achievements.did = {}
TWDS.achievements.search = function (str, tab) {
  str = str.trim().toLocaleLowerCase()
  let rx
  if (str > '') {
    rx = new RegExp(str)
  }
  const rows = TWDS.q('tbody tr', tab)
  for (let i = 0; i < rows.length; i++) {
    const tr = rows[i]
    const text = TWDS.q1('.title', tr).textContent.toLocaleLowerCase()
    if (str === '') {
      tr.style.display = 'table-row'
    } else {
      if (text.search(rx) > -1) {
        tr.style.display = 'table-row'
      } else {
        tr.style.display = 'none'
      }
    }
  }
}
TWDS.achievements.openwindowReal = function (data) {
  const titlestr = TWDS._('ACHIEVEMENTS_TITLE', 'Logros')
  const win = wman.open('TWDS_achievements_window', titlestr)
  win.setMiniTitle(titlestr)
  TWDS.achievements.win = win

  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_achievements_container'
  })
  let total = 0
  for (let i = 0; i < data.menu.length; i++) {
    total++
    total += data.menu[i].sub.length
  }
  TWDS.createEle('div', {
    last: content,
    className: 'TWDS_achievements_search_wrapper',
    children: [
      { nodeName: 'input', type: 'text', className: 'TWDS_achievements_search', placeholder: 'search' }
    ]
  })
  TWDS.createEle('p', {
    className: 'TWDS_achievements_warning',
    last: content,
    children: [
      { nodeName: 'span', textContent: 'Please wait: ' },
      { nodeName: 'b', textContent: 1 }, // yes, we already did one request - and we'll skip the general cat-
      { nodeName: 'span', textContent: ' / ' + total }
    ]
  })
  TWDS.createEle('p', { last: content, className: 'TWDS_achievements_info' })
  const tab = TWDS.createEle('table', {
    className: 'TWDS_achievements_table TWDS_sortable',
    last: content
  })
  const thead = TWDS.createEle('thead', {
    last: tab
  })
  const tr = TWDS.createEle('tr', { last: thead })
  TWDS.createEle('th', { last: tr, textContent: 'title', dataset: { colsel: '.title' } })
  TWDS.createEle('th', { last: tr, textContent: 'folder', dataset: { colsel: '.folder', secondsel: '.sub' } })
  TWDS.createEle('th', { last: tr, textContent: 'sub', dataset: { colsel: '.sub', secondsel: '.title' } })
  TWDS.createEle('th', { last: tr, textContent: 'points', dataset: { colsel: '.points', sortmode: 'number' } })
  TWDS.createEle('th', { last: tr, textContent: 'date', dataset: { colsel: '.achieved', sortmode: 'number' } })
  const tbody = TWDS.createEle('tbody', {
    last: tab
  })
  sp.appendContent(content)

  win.appendToContentPane(sp.getMainDiv())
  TWDS.achievements.did = {}

  TWDS.achievements.doonecat(tbody, data.menu, 0, -1)
  TWDS.delegate(content, 'click', 'thead th[data-colsel]', TWDS.sortable.do)
  TWDS.delegate(content, 'click', 'tbody th', TWDS.achievements.openone)
  TWDS.delegate(content, 'change', '.TWDS_achievements_search', function () { TWDS.achievements.search(this.value, tab) })
}

TWDS.achievements.openone = function () {
  const idconst = 'TWDS_achievements_one'
  let win = wman.getById(idconst)
  if (win) {
    if (wman.isMinimized(idconst)) { wman.reopen(idconst) }
  } else {
    win = wman.open(idconst, 'Achievment', 'noreload nocloseall').setMiniTitle('A')
    const sp = new west.gui.Scrollpane()
    sp.appendContent("<div class='TWDS_achievements_show_one achievement'></div>")
    win.appendToContentPane(sp.getMainDiv())
  }
  console.log(win.getMainDiv(), TWDS.q1('.TWDS_achievements_show_one', win.getMainDiv()[0]))
  const y = TWDS.q1('.TWDS_achievements_show_one', win.getMainDiv()[0])
  const d = JSON.parse(this.closest('tr').dataset.qd)

  const a = tw2widget.achievement.create(d, null, true)
  y.textContent = ''
  y.innerHTML = a.divMain[0].innerHTML
  win.setTitle(0)
  win.setSize(y.scrollWidth + 90, y.scrollHeight + 100)
}
TWDS.achievements.append1 = function (tbody, json, fin, folder, sub) {
  const hackparsedate = function (s) {
    let x = /^ *(\d+) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d+)$/.exec(s)
    if (x) {
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
      let v = parseInt(x[3]) * 31 * 12 + parseInt(x[1])
      for (let i = 0; i < 12; i++) {
        if (months[i] === x[2]) {
          v += 31 * i
        }
      }
      return v
    }
    x = /^ *(\d+)\. (Jan|Feb|Mär|Apr|Mai|Jun|Jul|Aug|Sep|Okt|Nov|Dez) (\d+)$/.exec(s)
    if (x) {
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
        'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
      let v = parseInt(x[3]) * 31 * 12 + parseInt(x[1])
      for (let i = 0; i < 12; i++) {
        if (months[i] === x[2]) {
          v += 31 * i
        }
      }
      return v
    }
    return 0
  }
  if (!json) return
  for (let i = 0; i < json.length; i++) {
    // level 140 (reached) contains all sub levels
    // level 150 (no reached) contains all sub levels, too
    const id = json[i].id
    if (id in TWDS.achievements.did) continue
    TWDS.achievements.did[id] = true

    const tr = TWDS.createEle('tr', { last: tbody })
    if (fin) { tr.classList.add('finished') }
    tr.dataset.qd = JSON.stringify(json[i])
    TWDS.createEle('th', { last: tr, className: 'title', textContent: json[i].title })
    TWDS.createEle('td', { last: tr, className: 'folder', textContent: folder })
    TWDS.createEle('td', { last: tr, className: 'sub', textContent: sub })
    TWDS.createEle('td', { last: tr, className: 'points', textContent: json[i].points })
    const v = hackparsedate(json[i].achieved)
    TWDS.createEle('td', { last: tr, className: 'achieved', textContent: json[i].achieved, dataset: { sortval: v } })
    if (json[i].subs.length) {
      TWDS.achievements.append1(tbody, json[i].subs, fin, folder, sub)
    }
  }
}
TWDS.achievements.append = function (tbody, json, folder, sub) {
  TWDS.achievements.append1(tbody, json.finished, true, folder, sub)
  TWDS.achievements.append1(tbody, json.progress, false, folder, sub)
}
TWDS.achievements.doonecat = function (tbody, menu, i0, i1) {
  const warn = TWDS.q1('.TWDS_achievements_warning')
  const info = TWDS.q1('.TWDS_achievements_info')
  const sw = TWDS.q1('.TWDS_achievements_search_wrapper')
  const current = TWDS.q1('b', warn)
  const finish = function () {
    if (warn) { warn.remove() }
    info.textContent = 'Click on the table header to sort. Click on an achievement name to open it.'
    sw.style.display = 'block'
  }
  if (i0 >= menu.length) { finish(); return }
  if (i1 > -1) {
    if (i1 >= menu[i0].sub.length) {
      i0++
      i1 = -1
    }
  }
  if (i0 >= menu.length) { finish(); return }
  if (menu[i0].id === 'overall') {
    // skip most recents
    i0++
  }
  if (i0 >= menu.length) { finish(); return }

  if (i1 === -1) {
    Ajax.remoteCall('achievement', 'get_list', { playerid: Character.playerId, folder: menu[i0].id }, function (json) {
      current.textContent = parseInt(current.textContent) + 1
      TWDS.achievements.append(tbody, json.achievements, menu[i0].name, null)
      TWDS.achievements.doonecat(tbody, menu, i0, 0)
    })
  } else {
    Ajax.get('achievement', 'get_list', { playerid: Character.playerId, folder: menu[i0].sub[i1].id }, function (json) {
      current.textContent = parseInt(current.textContent) + 1
      TWDS.achievements.append(tbody, json.list.achievements, menu[i0].name, menu[i0].sub[i1].name)
      TWDS.achievements.doonecat(tbody, menu, i0, i1 + 1)
    })
  }
}
TWDS.achievements.openwindow = function () {
  Ajax.get('achievement', null, {}, function (json) {
    TWDS.achievements.openwindowReal(json)
  })
}
// this is not translated, because it runs quite early
TWDS.registerStartFunc(function () {
  TWDS.registerExtra('TWDS.achievements.openwindow',
    TWDS._('ACHIEVEMENTS_EXTRA_TITLE', 'Logros'),
    TWDS._('ACHIEVEMENTS_EXTRA_DESC', 'Una tabla con los logros.')
  )
})
// vim: tabstop=2 shiftwidth=2 expandtab

TWDS.iteminfo = {}
TWDS.iteminfo.searchitem = function (str) {
}
TWDS.iteminfo.getcontent = function (win) {
  const content = TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_iteminfo_content'
  })
  const inputarea = TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_iteminfo_inputarea',
    last: content
  })
  TWDS.createEle({
    nodeName: 'input',
    type: 'number',
    onchange: function () {
      win._TWDS_number = this.value
      TWDS.iteminfo.reload(win)
    },
    style: {
      display: 'inline-block'
    },
    placeholder: TWDS._('ITEMINFO_ITEMNO', '# (item id)'),
    title: TWDS._('ITEMINFO_ITEMNO_TITLE', 'The ItemId of the item'),
    value: win._TWDS_number ? win._TWDS_number : null,
    last: inputarea
  })

  const itemno = parseInt(win._TWDS_number)
  if (!itemno || itemno < 1000 || itemno > 2147483647) {
    TWDS.createEle('p', {
      innerHTML: "Here you can see all information about an item available to the frontend of the game (the browser). It's not meant to be beautiful.<br>" +
                'Usage: type the item number (the full one, not the basic one) in the input field and press enter',
      last: content
    })
    return content
  }

  const it = ItemManager.get(itemno, false)
  if (!it) {
    TWDS.createEle('div', {
      class: 'warning',
      textContent: 'no item with #' + itemno,
      last: content
    })
    return content
  }

  const ct = TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_iteminfo_resultcontainer',
    last: content
  })

  const p = new ItemPopup(it, {
    character: null,
    show_setboni: true
  })
  TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_iteminfo_popuparea TWDS_item',
    innerHTML: p.popup.text,
    last: ct
  })
  if (TWDS.items.origpopup) {
    TWDS.createEle({
      nodeName: 'div',
      className: 'TWDS_iteminfo_popuparea',
      innerHTML: TWDS.items.origpopup,
      last: ct
    })
  }

  const resultarea = TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_iteminfo_resultarea level0',
    last: ct
  })
  const toplevelextra = function (tr, k, v) {
    if (k === 'image') {
      if (it.image > '') {
        TWDS.createEle('div.extra', {
          last: tr,
          children: [
            { nodeName: 'img', src: it.image, alt: it.name }
          ]
        })
      }
      return
    }
    if (k === 'wear_image') {
      if (it.image > '') {
        TWDS.createEle('div.extra', {
          last: tr,
          children: [
            { nodeName: 'img', src: it.image, alt: it.name }
          ]
        })
      }
      return
    }
    if (k === 'set') {
      if (v > '') {
        TWDS.createEle('div.extra', {
          last: tr,
          children: [
            {
              nodeName: 'a',
              href: '#',
              dataset: { setkey: v },
              textContent: 'show set info',
              onclick: function (ev) {
                console.log('click', ev, this)
                TWDS.showset.open(this.dataset.setkey)
              }
            }
          ]
        })
      }
    }
  }
  const dump = function (elter, k, v, level) {
    const row = TWDS.createEle('div', { last: elter, className: 'row level' + level })
    TWDS.createEle('h6', {
      textContent: k,
      last: row
    })
    if (v === null) {
      TWDS.createEle('span', {
        textContent: 'null',
        last: row
      })
      return
    }
    if (typeof v !== 'object') {
      TWDS.createEle('span', {
        textContent: v,
        last: row
      })
      if (level === 0) {
        toplevelextra(row, k, v)
      }
      return
    }
    for (const [k2, v2] of Object.entries(v)) {
      dump(elter, k2, v2, level + 1)
    };
  }
  for (const [k, v] of Object.entries(it)) {
    dump(resultarea, k, v, 0)
  }

  return content
}
TWDS.iteminfo.open = function (key) {
  console.log('IIO', key)
  const wid = 'TWDS_craftcalc_' + key
  const win = wman.open(wid, 'set', 'TWDS_iteminfo')
  win.setTitle(TWDS._('ITEMINFO_WINDOW_TITLE', 'Iteminfo'))
  if (!('_TWDS_number' in win)) {
    win._TWDS_number = 0
  }
  const sp = new west.gui.Scrollpane()
  const content = TWDS.iteminfo.getcontent(win)
  sp.appendContent(content)

  win.appendToContentPane(sp.getMainDiv())
}
TWDS.iteminfo.reload = function (win) {
  if (!win) {
    return TWDS.iteminfo.open()
  }
  const content = TWDS.iteminfo.getcontent(win)
  const old = TWDS.q1('.TWDS_iteminfo_content', win.getMainDiv())
  const sp = old.parentNode
  sp.innerHTML = ''
  sp.appendChild(content)
}
TWDS.registerExtra('TWDS.iteminfo.open',
  TWDS._('ITEMINFO_TITLE', 'Información artículo'),
  TWDS._('ITEMINFO_DESC', 'Muestra información sobre un artículo.')
)
;(function () {
  const save = TWDS.fbchat
  TWDS.fbchat = {}
  TWDS.fbchat.fbw = (save ? save.fbw : false) || {}
})()
TWDS.fbchat.oldhp = null
TWDS.fbchat.characters = null
TWDS.fbchat.charIcons = null
TWDS.fbchat.lastmentioned = ''

TWDS.fbchat.sendmsg = function (fortid, msg) {
  const rooms = window.Chat.Resource.Manager.getRooms()
  fortid = parseInt(fortid)
  window.Chat.Formatter.formatResponse(null, 'system', 'test', new Date().getTime())
  for (const rid in rooms) {
    const r = rooms[rid]
    if (r.room === 'fortbattle' && r.fortId === fortid) {
      const ti = window.Chat.Formatter.formatTime(new Date().getTime(), false)
      const x = '<div>[' + ti + ']</span> ' + TWDS.scriptname + ': ' + msg + '</div>'
      r.addMessage(x)
      return
    }
  }

  console.log('strange: no fort battle chat found for id', fortid, 'in', rooms)
}
TWDS.fbchat.makemsg = function (roundno, defhp, atthp, defdelta, attdelta) {
  let pre = ''
  if (roundno) { pre = TWDS._('FBCHAT_ROUND', '--- Round $roundno$ ', { roundno: roundno }) }
  if (attdelta > 0 || defdelta > 0) {
    attdelta = -attdelta
    defdelta = -defdelta
    return pre + TWDS._('FBCHAT_WITH_DELTA',
      "--- HP: att. <span style='color:#ff2222'>$atthp$ ($attdelta$)</span>, def. <span style='color:#00ccff'>$defhp$ ($defdelta$)</span>",
      {
        atthp: atthp,
        defhp: defhp,
        attdelta: attdelta,
        defdelta: defdelta
      }
    )
  }
  return pre + TWDS._('FBCHAT_WITHOUT_DELTA',
    "--- HP: att. <span style='color:#ff2222'>$atthp$</span>, def. <span style='color:#00ccff'>$defhp$</span>",
    {
      atthp: atthp,
      defhp: defhp
    }
  )
}

// called from fbdata module
TWDS.fbchat.roundhandler = function (fortid, roundno, hp0, hp1, hpd0, hpd1) {
  if (TWDS.settings.misc_fortbattle_chatext) {
    const msg = TWDS.fbchat.makemsg(roundno, hp0, hp1, hpd0, hpd1)
    TWDS.fbchat.sendmsg(fortid, msg)
  }
}

TWDS.fbchat.findchar = function (searchname) {
  searchname = searchname.toLocaleLowerCase()
  const cand = []
  for (const fortid of Object.keys(TWDS.fbdata.fbw)) {
    const fbw = TWDS.fbdata.fbw[fortid]
    if (!fbw.characters) { continue }
    const chars = Object.values(fbw.characters)
    for (let i = 0; i < chars.length; i++) {
      const n = chars[i].name.toLocaleLowerCase()
      if (n === searchname) {
        return [
          { char: chars[i], battle: fbw }
        ]
      }
      if (n.includes(searchname)) {
        cand.push({ char: chars[i], battle: fbw })
      }
    }
  }
  return cand
}
TWDS.fbchat.clickhelper = function (ev) {
  const t = ev.target
  const name = t.textContent
  for (const fortid of Object.keys(TWDS.fbdata.fbw)) {
    const fbw = TWDS.fbdata.fbw[fortid]
    if (!fbw.characters) { continue }
    const icons = Object.values(fbw.charIcons)
    for (let i = 0; i < icons.length; i++) {
      icons[i][0].classList.remove('highlight')
    }
    for (let i = 0; i < fbw.characters.length; i++) {
      const r = fbw.characters[i]
      if (r.name === name) {
        const x = r.characterid
        if (fbw.charIcons && fbw.charIcons[x]) {
          const y = fbw.charIcons[x][0]
          let z = 50
          const interval = setInterval(function () {
            if (z % 2) {
              y.classList.add('highlight')
            } else {
              y.classList.remove('highlight')
            }
            z--
            if (z < 1) {
              clearInterval(interval)
            }
          }, 50)
        }
        break
      }
    }
  }
}

TWDS.fbchat.boosters = {}
TWDS.fbchat.getonebooster = function (data, finalize) {
  Ajax.remoteCallMode('profile', 'init', {
    playerId: data.id
  }, function (profdata) {
    console.log('profdata', data.id, profdata)
    const a = []
    for (const itemid of Object.values(profdata.wear)) {
      a.push(itemid)
    }
    const out = TWDS.bonuscalc.getComboBonus(a)
    if (out.fort_offense_sector || out.fort_defense_sector || out.fort_damage_sector ||
        out.fortbattlesector_defense || out.fort_defense_offense || out.fortbattlesector_damage) {
      console.log('out', out)
      TWDS.fbchat.boosters[data.id] = {
        name: data.name,
        id: data.id,
        off: (out.fort_offense_sector || 0) + (out.fort_defense_offsent || 0),
        def: (out.fort_defense_sector || 0) + (out.fortbattlesector_defense || 0),
        dmg: (out.fort_damage_sector || 0) + (out.fortbattlesector_damage || 0)
      }
      console.log('g1b', data.id, data.name, TWDS.fbchat.boosters[data.id])
    }
    if (finalize) { setTimeout(finalize, 2500) }
  })
}
TWDS.fbchat.markplayer = function (str) {

}
TWDS.fbchat.markboosters = function () {
  const data = JSON.parse(window.sessionStorage.TWDS_fbboosters)
  console.log('data', data)
  for (const fortid of Object.keys(TWDS.fbdata.fbw)) {
    const fbw = TWDS.fbdata.fbw[fortid]
    console.log('fbw', fbw)
    for (let id of Object.keys(data)) {
      id = parseInt(id)
      for (let j = 0; j < fbw.characters.length; j++) {
        if (parseInt(fbw.characters[j].westPlayerId) === id) {
          const cid = fbw.characters[j].characterid
          const icon = fbw.charIcons[cid]
          console.log('XX', id, j, cid, icon)
          if (icon && icon[0]) {
            let color1 = null
            let color2 = null
            let color3 = null
            if (data[id].dmg >= 200) {
              color2 = 'f'
            } else if (data[id].dmg >= 150) {
              color2 = 'c'
            } else if (data[id].dmg >= 100) {
              color2 = 'a'
            } else if (data[id].dmg >= 50) {
              color2 = '8'
            }
            if (data[id].off >= 15) {
              color1 = 'f'
            } else if (data[id].off >= 10) {
              color1 = 'c'
            } else if (data[id].off >= 5) {
              color1 = '8'
            }
            if (data[id].def >= 15) {
              color3 = 'f'
            } else if (data[id].def >= 10) {
              color3 = 'c'
            } else if (data[id].def >= 5) {
              color3 = '8'
            }
            console.log('icon', icon, 'colors', color1, color2, color3, 'data', data[id])
            if (color1 !== null || color2 !== null || color3 !== null) {
              let color = ''
              if (color1) { color += color1 } else { color += '0' };
              if (color2) { color += color2 } else { color += '0' };
              if (color3) { color += color3 } else { color += '0' };
              icon[0].style.outline = '2px solid #' + color
            }
          }
        }
      }
    }
  }
}
TWDS.fbchat.getboosters = function () {
  if (!('TWDS_fbplayers' in window.sessionStorage)) { return }
  const data = JSON.parse(window.sessionStorage.TWDS_fbplayers)
  const finalize = function () {
    console.log('all boosters', TWDS.fbchat.boosters)
    window.sessionStorage.TWDS_fbboosters = JSON.stringify(TWDS.fbchat.boosters)
    TWDS.fbchat.markboosters()
  }
  for (let i = 0; i < data.length; i++) {
    setTimeout(function () {
      TWDS.fbchat.getonebooster(data[i], i === data.length - 1 ? finalize : null)
    }, 125 * i + Math.floor(i / 10) * 1000)
  }
}

TWDS.fbchat.startfunc = function () {
  TWDS.registerSetting('bool', 'misc_fortbattle_chatext',
    TWDS._('FBCHAT_SETTING', 'Agregar información de puntos de salud en el chat de batalla del fuerte.'),
    true, null, 'Miscelánea')

  TWDS.delegate(document.body, 'click', '#windows .chat .chat_from .client_name', function (ev) {
    TWDS.fbchat.clickhelper(ev)
  })
  TWDS.delegate(document.body, 'click', '#windows .chat_contacts .contact_client .client_name', function (ev) {
    TWDS.fbchat.clickhelper(ev)
  })
}
// flashShowCharacterInfo: function(fortId, playerId, healthNow, healthMax, totalDmg, lastDmg, shotat, bonusdata, char)
TWDS.fbchat.findiconbyfortandplayer = function (fortid, pid) {
  const fbw = TWDS.fbdata.fbw[fortid]
  if (!fbw) return null
  for (let i = 0; i < fbw.characters.length; i++) {
    const ch = fbw.characters[i]
    if (ch.westPlayerId === pid) {
      const cid = ch.characterid
      const icon = fbw.charIcons[cid]
      if (icon && icon[0]) {
        return icon[0]
      }
    }
  }
}
TWDS.fbchat.getdirection = function (name1, name2) {
  const chlist1 = TWDS.fbchat.findchar(name1)
  if (chlist1.length === 0) {
    return [false, TWDS._('C_SOMESTRING_NOT_FOUND', '$string$ not found', { string: name1 })]
  }
  if (chlist1.length > 1) {
    return [false, TWDS._('FBCHAT_NOT_UNIQUE_MATCHES', '$string$ is not unique, matches $cand$',
      {
        string: name1,
        cand: chlist1.map(function (a, b) { return a.char.name }).join(', ')
      })]
  }
  const data1 = chlist1[0]
  const chlist2 = TWDS.fbchat.findchar(name2)
  if (chlist2.length === 0) {
    return [false, TWDS._('C_SOMESTRING_NOT_FOUND', '$string$ not found', { string: name2 })]
  }
  if (chlist2.length > 1) {
    return [false, TWDS._('FBCHAT_NOT_UNIQUE_MATCHES', '$string$ is not unique, matches $cand$',
      {
        string: name2,
        cand: chlist2.map(function (a, b) { return a.char.name }).join(', ')
      })]
  }
  const data2 = chlist2[0]
  if (data1.battle !== data2.battle) {
    return [false, TWDS._('FBCHAT_NOT_SAME_BATTLE', '$name$ and $name2$ are not in the same battle', {
      name1: data1.char.name,
      name2: data2.char.name
    })]
  }
  const ch1 = data1.char
  const battle1 = data1.battle
  const ch2 = data2.char

  const w = battle1.mapInfo.width
  const x1 = ch1.position % w
  const x2 = ch2.position % w
  const y1 = parseInt(ch1.position / w)
  const y2 = parseInt(ch2.position / w)

  let dir = ''
  if (x1 > x2) {
    dir += (x1 - x2) + ' ' + TWDS._('FBCHAT_LEFT', 'left')
  } else if (x1 < x2) {
    dir += (x2 - x1) + ' ' + TWDS._('FBCHAT_RIGHT', 'right')
  }
  if (y1 !== y2 && dir !== '') {
    dir += ' '
  }
  if (y1 > y2) {
    dir += (y1 - y2) + ' ' + TWDS._('FBCHAT_UP', 'up')
  } else if (y1 < y2) {
    dir += (y2 - y1) + ' ' + TWDS._('FBCHAT_DOWN', 'down')
  }
  return [true, dir]
}
TWDS.fbchat.swaphelper = function (name1, name2) {
  const res = TWDS.fbchat.getdirection(name1, name2)
  if (!res[0]) return res

  const str = TWDS._('FBCHAT_SWAPSTRING', '$name1$ swap $dir$ with $name2$', {
    name1: name1,
    name2: name2,
    dir: res[1]
  })

  return [true, str]
}
TWDS.fbchat.clickcharinfocolor = function (mode) {
  const fortid = parseInt(this.dataset.fortid)
  const playerid = parseInt(this.dataset.playerid)
  const icon = TWDS.fbchat.findiconbyfortandplayer(fortid, playerid)
  if (!icon) return
  const value = mode ? this.value : 'transparent'
  icon.style.outline = '2px solid ' + value
  if (mode) icon.dataset.currentcolor = value
  else delete icon.dataset.currentcolor
}
TWDS.fbchat.showcharinfo = function (...args) {
  window.FortBattle.TWDS_backup_flashShowCharacterInfo(...args)
  let old = TWDS.q1('#fort_battle_' + args[0] + '_infoarea .TWDS_charinfocolor')
  if (old) old.remove()
  old = TWDS.q1('#fort_battle_' + args[0] + '_infoarea .TWDS_charinfocolorclear')
  if (old) old.remove()
  old = TWDS.q1('#fort_battle_' + args[0] + '_infoarea .TWDS_copycharname')
  if (old) old.remove()
  const pa = TWDS.q1('#fort_battle_' + args[0] + '_infoarea')
  if (!pa) return
  const icon = TWDS.fbchat.findiconbyfortandplayer(args[0], args[1])
  let oldcolor = '#000000'
  if (icon) {
    oldcolor = icon.dataset.currentcolor || oldcolor
  }
  const colorele = TWDS.createEle({
    nodeName: 'input.TWDS_charinfocolor',
    type: 'color',
    last: pa,
    value: oldcolor,
    dataset: {
      fortid: args[0],
      playerid: args[1]
    },
    oninput: function (ev) {
      TWDS.fbchat.clickcharinfocolor.apply(this, [true])
    },
    onchange: function (ev) {
      TWDS.fbchat.clickcharinfocolor.apply(this, [true])
    }
  })
  TWDS.createEle({
    nodeName: 'button.TWDS_charinfocolorclear',
    textContent: 'clear',
    last: pa,
    dataset: {
      fortid: args[0],
      playerid: args[1]
    },
    onclick: function () {
      TWDS.fbchat.clickcharinfocolor.apply(this, [false])
      colorele.value = 'transparent'
    }
  })
  if (args[8]) {
    TWDS.createEle({
      nodeName: 'button.TWDS_copycharname',
      textContent: '...',
      last: pa,
      dataset: {
        charname: args[8].name,
        playerid: args[1]
      },
      onclick: function (ev) {
        const charname = this.dataset.charname
        const playerid = this.dataset.playerid
        const sb = (new west.gui.Selectbox(true))
          .setHeight('66px')
          .setWidth('60px')
          .addListener(function (choice) {
            console.log('choice', choice)
            if (choice === 'whisper') {
              const client = Chat.Resource.Manager.getClient('client_' + playerid)
              if (client) {
                const room = Chat.Resource.Manager.acquireRoom(client)
                if (room) {
                  room.openClick()
                }
              } else {
                new UserMessage("first 'copy name'!").show()
              }
            } else if (choice === 'name') {
              TWDS.fbchat.lastmentioned = charname
            } else if (choice === '+name' && !TWDS.fbchat.lastmentioned) {
              new UserMessage("first 'copy name'!").show()
            } else if (choice === '+name') {
              const out = TWDS.fbchat.swaphelper(TWDS.fbchat.lastmentioned, charname)
              if (!out[0]) {
                new UserMessage(out[1]).show()
              } else {
                const inputs = TWDS.q('.chat_room input.message')
                for (let i = 0; i < inputs.length; i++) {
                  const inp = inputs[i]
                  const cr = inp.closest('.chat_room')
                  if (cr && cr.style.display === 'block') {
                    inp.value += out[1]
                  }
                }
              }
            }
          })
        sb.addItem('name', TWDS._('FBCHAT_SWAP1', 'mark player1 for swap'))
        sb.addItem('+name', TWDS._('FBCHAT_SWAP2', 'swap player2'))
        sb.addItem('whisper', TWDS._('FBCHAT_WHISPER', 'whisper'))
        sb.show(ev)
      }
    })
  }
}
TWDS.fbchat.startfunc3 = function () {
  TWDS.delegate(document.body, 'click', '#windows .chat .chat_from .client_name', function (ev) {
    TWDS.fbchat.clickhelper(ev)
  })
  TWDS.delegate(document.body, 'click', '#windows .chat_contacts .contact_client .client_name', function (ev) {
    TWDS.fbchat.clickhelper(ev)
  })
  window.FortBattle.TWDS_backup_flashShowCharacterInfo = window.FortBattle.TWDS_backup_flashShowCharacterInfo ||
    window.FortBattle.flashShowCharacterInfo
  window.FortBattle.flashShowCharacterInfo = TWDS.fbchat.showcharinfo
}

TWDS.fbchat.startfunc2 = function () {
  const F = function (code, text, extra) {
    if (code) { text = TWDS._(code, text, extra) }
    return Chat.Formatter.formatMessage(Chat.Formatter.formatText(text, true),
      '<b>' + TWDS.scriptname + ':</b>', Date.now(), true, 'from_system')
  }
  Chat.Operations['^\\/swap\\s+(\\S+)\\s+(\\S+)$'] = {
    cmd: 'swap',
    shorthelp: TWDS._('CHAT_SWAP_SHORTHELP', 'Send swap command'),
    help: TWDS._('CHAT_SWAP_HELP', 'Generate a swap command for two players'),
    usage: '/swap search1 search2',
    func: function (room, msg, param) {
      console.log(room, msg, param)
      const out = TWDS.fbchat.swaphelper(param[1], param[2])
      if (!out[0]) {
        room.addMessage(F(null, out[1]))
        return
      }
      const color = window.localStorage.TWDS_chat_color
      if (color) { out[1] = '/' + color + ' ' + out[1] }
      Chat.sendMessage(out[1], room)
    }
  }
  Chat.Operations['^\\/(findplayer|f)\\s+(.*)$'] = {
    cmd: 'mark',
    shorthelp: TWDS._('CHAT_FINDPLAYER_SHORTHELP', 'find some player(s)'),
    help: TWDS._('CHAT_FINDPLAYER_HELP', 'Find players by name'),
    usage: TWDS._('CHAT_FINDPLAYER_USAGE', '/findplayer searchstring'),
    func: function (room, msg, param) {
      const fortid = room.fortId
      const fbw = TWDS.fbdata.fbw[fortid]
      if (!fbw) {
        console.log('FBW not found', TWDS.fbdata.fbw, fortid)
        room.addMessage(F('CHAT_FBW_WINDOW_NOT_FOUND', 'fortbattle window not found'))
        return
      }

      if (!('characters' in fbw)) {
        if ('preBattle' in fbw) {
          room.addMessage(F('CHAT_MARK_NOT_IN_PREBATTLE', "can't do that in a prebattle window"))
        } else {
          room.addMessage(F('CHAT_MARK_NO_CHARACTERS', 'characters not found'))
        }
        return
      }

      const search = param[2].trim().toLocaleLowerCase()
      let found = 0
      for (let i = 0; i < fbw.characters.length; i++) {
        const ch = fbw.characters[i]
        const name = ch.name.toLocaleLowerCase()
        if (name.includes(search)) {
          const cid = ch.characterid
          const icon = fbw.charIcons[cid]
          const dir = TWDS.fbchat.getdirection(Character.name, name)
          if (dir[0]) {
            room.addMessage(F(null, name + ': ' + dir[1]))
          }
          if (icon && icon[0]) {
            found++
            let z = 50
            const interval = setInterval(function () {
              if (z % 2) {
                icon[0].classList.add('highlight')
              } else {
                icon[0].classList.remove('highlight')
              }
              z--
              if (z < 1) {
                clearInterval(interval)
              }
            }, 50)
          }
        }
      }
      if (!found) {
        room.addMessage(F('CHAT_PLAYER_NOT_FOUND', 'player not found'))
      }
    }
  }
  Chat.Operations['^\\/mark\\s+([0-9]+|-)\\s+(.*)$'] = {
    cmd: 'mark',
    shorthelp: TWDS._('CHAT_MARK_SHORTHELP', 'Mark some player'),
    help: TWDS._('CHAT_MARK_HELP', 'Mark a player with a colored outline'),
    usage: TWDS._('CHAT_MARK_USAGE', '/mark colorcode searchstring'),
    func: function (room, msg, param) {
      const fortid = room.fortId
      const fbw = TWDS.fbdata.fbw[fortid]
      if (!fbw) {
        console.log('FBW not found', TWDS.fbdata.fbw, fortid)
        room.addMessage(F('CHAT_FBW_WINDOW_NOT_FOUND', 'fortbattle window not found'))
        return
      }

      if (!('characters' in fbw)) {
        if ('preBattle' in fbw) {
          room.addMessage(F('CHAT_MARK_NOT_IN_PREBATTLE', "can't do that in a prebattle window"))
        } else {
          room.addMessage(F('CHAT_MARK_NO_CHARACTERS', 'characters not found'))
        }
        return
      }

      const search = param[2].trim().toLocaleLowerCase()
      console.log('search', search)
      let color = param[1].trim()
      if (color === '-') {
        color = null
      } else {
        const rgb = color.match(/^(\d)(\d)(\d)$/)
        if (!rgb) {
          room.addMessage(F('CHAT_MARK_COLORFAIL', 'failed to parse color. use - for unmarking, or NNN for marking, where N is a number from 0 to 9.'))
          return
        }
        color = Math.floor(rgb[1] * 15 / 9).toString(16) +
                  Math.floor(rgb[2] * 15 / 9).toString(16) +
                  Math.floor(rgb[3] * 15 / 9).toString(16)
      }

      for (let i = 0; i < fbw.characters.length; i++) {
        const ch = fbw.characters[i]
        const name = ch.name.toLocaleLowerCase()
        if (name.includes(search)) {
          const cid = ch.characterid
          const icon = fbw.charIcons[cid]
          if (icon && icon[0]) {
            if (color) {
              icon[0].style.outline = '2px solid #' + color
              icon[0].dataset.currentcolor = '#' + color
              room.addMessage(F('CHAT_MARK_MARKED', 'marked $name$', { name: ch.name }))
            } else {
              icon[0].style.outline = 'none'
              delete icon[0].dataset.currentcolor
              room.addMessage(F('CHAT_MARK_UNMARKED', 'removed mark from $name$', { name: ch.name }))
            }
          }
        }
      }
    }
  }
}
TWDS.registerStartFunc(function () {
  TWDS.fbchat.startfunc()
  TWDS.fbchat.startfunc2()
  TWDS.fbchat.startfunc3()
})

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab

TWDS.invstat = {}
TWDS.invstat.openwindow = function () {
  const ls = window.localStorage.TWDS_itemusage
  let usedata
  if (typeof ls === 'undefined') {
    usedata = {}
  } else {
    usedata = JSON.parse(ls)
  }

  const win = wman.open('TWDS_invstat_window', 'Inventory Statistics', 'TWDS_invstat_window')
  win.setMiniTitle('InvStat')

  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_invstat_container'
  })
  TWDS.createEle('p', { beforeend: content, textContent: 'some statistics about your inventory' })
  const table = TWDS.createEle('table', { beforeend: content })
  const tbody = TWDS.createEle('tbody', { beforeend: table })
  const erg = {
    totalprice: 0,
    totalpriceunused: 0,
    sellprice: 0,
    sellpriceunused: 0,
    auctionprice: 0,
    auctionpriceunused: 0,
    fixedstuff: 0,
    distinctfixedstuff: 0,
    openunpack: 0,
    distinctopenunpack: 0,
    usable: 0,
    distinctusable: 0,
    sellable: 0,
    distinctsellable: 0,
    auctionable: 0,
    distinctauctionable: 0,
    buff: 0,
    distinctbuff: 0,
    totalitems: 0,
    distinctitems: 0,
    xplevel: 0,
    bonds: 0,
    pretzels: 0,
    hearts: 0,
    cempasuchils: 0,
    fireworks: 0,
    eastereggs: 0
  }
  let warncount = 0

  for (let id of Object.keys(Bag.items_by_id)) {
    let did = 0
    id = parseInt(id)
    const it = Bag.items_by_id[id].obj
    const count = Bag.items_by_id[id].count
    erg.totalitems += count
    erg.distinctitems += 1
    if ('sell_price' in it) {
      let m = it.sell_price
      if (it.sell_price === 0 && it.price > 0) m = it.price / 2
      if (it.sellable || it.auctionable) {
        erg.totalprice += count * m
        did = 1
      }
      if (it.sellable) {
        erg.sellprice += count * m
        erg.sellable += count
        erg.distinctsellable += 1
        did = 1
      }
      if (it.auctionable) {
        erg.auctionprice += count * m
        erg.auctionable += count
        erg.distinctauctionable += 1
        did = 1
      }
      let count2 = count
      if (it.item_id in usedata) {
        count2 = Math.min(count - 1, count2)
      }
      if (it.item_id in TWDS.storage) {
        count2 = Math.max(count - TWDS.storage[it.item_id][0], count2)
      }
      if (it.usetype !== 'none') {
        count2 = 0
      }
      if (it.sellable || it.auctionable) {
        if (count2 > 0) {
          erg.totalpriceunused += count2 * m
        }
      }
      if (it.sellable && count2 > 0) {
        erg.sellpriceunused += count2 * m
      }
      if (it.auctionable && count2 > 0) {
        erg.auctionpriceunused += count2 * m
      }
    }
    if (!it.sellable && !it.auctionable && it.usetype === 'none') {
      erg.fixedstuff += 1 * count
      erg.distinctfixedstuff += 1
      did = 1
    }
    if (it.usetype === 'use' && 'usebonus' in it && it.usebonus.length) {
      erg.usable += 1 * count
      erg.distinctusable += 1
      did = 1
    }
    if (it.usetype === 'buff' && 'usebonus' in it && it.usebonus.length) {
      erg.buff += 1 * count
      erg.distinctbuff += 1
      did = 1
    }
    if (TWDS.quickusables.match(it, 'openunpack')) {
      erg.openunpack += count
      erg.distinctopenunpack += 1
      did = 1
    }
    let n = TWDS.quickusables.matchnumber(it, 'bonds')
    if (n) {
      erg.bonds += n * count
      // console.log(it, n, '=>', erg.bonds)
      did = 1
    }
    n = TWDS.quickusables.matchnumber(it, 'experiencelevel')
    if (n) {
      erg.xplevel += n * count
      did = 1
    }
    if (!it.unique) { // "unique" catches things like the 24h heart bag
      n = TWDS.quickusables.matchnumber(it, 'pretzels')
      if (n) { erg.pretzels += n * count; did = 1 }
      n = TWDS.quickusables.matchnumber(it, 'hearts')
      if (n) { erg.hearts += n * count; did = 1 }
      n = TWDS.quickusables.matchnumber(it, 'cempasuchils')
      if (n) { erg.cempasuchils += n * count; did = 1 }
      n = TWDS.quickusables.matchnumber(it, 'fireworks')
      if (n) { erg.fireworks += n * count; did = 1 }
      n = TWDS.quickusables.matchnumber(it, 'eastereggs')
      if (n) { erg.eastereggs += n * count; did = 1 }
    }
    if (!did) {
      if (warncount++ < 10) {
        console.log('unhandled thing', it)
      }
    }
  }
  console.log('erg', erg)
  let tr
  const ra = { textAlign: 'right' }
  tr = TWDS.createEle('tr', { beforeend: tbody, className: '' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'worth' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'total' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.totalprice, style: ra })
  TWDS.createEle('th', { beforeend: tr, textContent: 'unused' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.totalpriceunused, style: ra })
  TWDS.createEle('td', { beforeend: tr, textContent: 'the minimal worth of the inventory' })
  tr = TWDS.createEle('tr', { beforeend: tbody, className: '' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'worth/sell' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'total' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.sellprice, style: ra })
  TWDS.createEle('th', { beforeend: tr, textContent: 'unused' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.sellpriceunused, style: ra })
  TWDS.createEle('td', { beforeend: tr, textContent: 'what the travelling merchant would pay' })
  tr = TWDS.createEle('tr', { beforeend: tbody, className: '' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'worth/auction' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'total' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.auctionprice, style: ra })
  TWDS.createEle('th', { beforeend: tr, textContent: 'unused' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.auctionpriceunused, style: ra })
  TWDS.createEle('td', { beforeend: tr, textContent: 'the minimum price achievable in auctions' })
  tr = TWDS.createEle('tr', { beforeend: tbody, className: '' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'items' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'all' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.totalitems, style: ra })
  TWDS.createEle('th', { beforeend: tr, textContent: 'distinct' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.distinctitems, style: ra })
  tr = TWDS.createEle('tr', { beforeend: tbody, className: '' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'sellable' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'total' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.sellable, style: ra })
  TWDS.createEle('th', { beforeend: tr, textContent: 'distinct' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.distinctsellable, style: ra })
  tr = TWDS.createEle('tr', { beforeend: tbody, className: '' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'auctionable' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'total' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.auctionable, style: ra })
  TWDS.createEle('th', { beforeend: tr, textContent: 'distinct' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.distinctauctionable, style: ra })
  tr = TWDS.createEle('tr', { beforeend: tbody, className: '' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'usable' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'total' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.usable, style: ra })
  TWDS.createEle('th', { beforeend: tr, textContent: 'distinct' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.distinctusable, style: ra })
  tr = TWDS.createEle('tr', { beforeend: tbody, className: '' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'buff' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'total' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.buff, style: ra })
  TWDS.createEle('th', { beforeend: tr, textContent: 'distinct' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.distinctbuff, style: ra })
  tr = TWDS.createEle('tr', { beforeend: tbody, className: '' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'fixed stuff' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'total' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.fixedstuff, style: ra })
  TWDS.createEle('th', { beforeend: tr, textContent: 'distinct' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.distinctfixedstuff, style: ra })
  TWDS.createEle('td', { beforeend: tr, textContent: 'neither usable nor sellable or auctionable. Quest items.' })
  tr = TWDS.createEle('tr', { beforeend: tbody, className: '' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'open/unpack' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'total' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.openunpack, style: ra })
  TWDS.createEle('th', { beforeend: tr, textContent: 'distinct' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.distinctopenunpack, style: ra })
  tr = TWDS.createEle('tr', { beforeend: tbody, className: '' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'bonds' })
  TWDS.createEle('th', { beforeend: tr, textContent: 'total' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.bonds + Character.upb, style: ra })
  TWDS.createEle('th', { beforeend: tr, textContent: 'in letters' })
  TWDS.createEle('td', { beforeend: tr, textContent: erg.bonds, style: ra })
  const trivial = function (t1, t2, val) {
    const tr = TWDS.createEle('tr', { beforeend: tbody, className: '' })
    TWDS.createEle('th', { beforeend: tr, textContent: t1 })
    TWDS.createEle('th', { beforeend: tr, textContent: t2 })
    TWDS.createEle('td', { beforeend: tr, textContent: val, style: ra })
    TWDS.createEle('th', { beforeend: tr, textContent: '' })
    TWDS.createEle('td', { beforeend: tr, textContent: '', style: ra })
  }
  trivial('Experience', 'in % of a level', erg.xplevel)
  trivial('Hearts', '', erg.hearts)
  trivial('Easter eggs', '', erg.eastereggs)
  trivial('Fireworks', '', erg.fireworks)
  trivial('Pretzels', '', erg.pretzels)
  trivial('Cempasúchil', '', erg.cempasuchils)

  sp.appendContent(content)

  win.appendToContentPane(sp.getMainDiv())
}

TWDS.registerStartFunc(function () {
  TWDS.registerExtra('TWDS.invstat.openwindow',
    TWDS._('EXTRAS_INVSTAT_TEXT', 'Estadísticas Inventario'),
    TWDS._('EXTRAS_INVSTAT_HELP', 'Muestra estadísticas de su inventario.')
  )
})
// vim: tabstop=2 shiftwidth=2 expandtab

// pinning mode
TWDS.pinning = {}
TWDS.pinning.cooldowninterval = 0
TWDS.pinning.cooldownhandler = function () {
  const d = TWDS.q1('#TWDS_pinning_cooldowninfo')
  if (d) {
    const now = new Date().getTime()
    const dt = Character.cooldown - now / 1000
    if (dt <= 0) {
      d.textContent = ''
    } else {
      d.textContent = dt.formatDurationBuffWay()
    }
  }

  const x = window.localStorage.TWDS_pinned_items || '[]'
  const list = JSON.parse(x)

  for (let i = 0; i < list.length; i++) {
    const itemid = list[i]
    const it = Bag.getItemByItemId(itemid) // that's where we get the count, and the _overaged_ coooldown info
    if (!it) continue
    const cd = Bag.itemCooldown[itemid] || 0 // current cooldown info
    if (cd) {
      const st = new window.ServerDate().getTime()
      const delta = (cd - st / 1000)
      if (delta > 0) {
        const ours = TWDS.q(".TWDS_pinning_container .item[data-twds_item_id='" + itemid + "'] .cooldown p")
        if (ours) {
          for (let j = 0; j < ours.length; j++) {
            ours[j].textContent = delta.formatDurationBuffWay()
            ours[j].parentNode.style.display = 'block'
          }
        }
        const old = TWDS.q1('#ui_notibar .TWDS_notibar_item_' + itemid)
        if (old) {
          old.dataset.obsolete = 1
          $(old).trigger('click') // crude signal, but i don't know any other way to signal the OngoingEntry
        }
      } else {
        TWDS.pinning.addnotification(itemid)
      }
    }
    const ours = TWDS.q(".TWDS_pinning_container .item[data-twds_item_id='" + itemid + "'] .count")
    if (ours) {
      for (let j = 0; j < ours.length; j++) {
        const old = parseInt(ours[j].textContent)
        if (old !== it.count) {
          ours[j].textContent = it.count
          ours[j].style.display = 'block'
        }
      }
    }
  }
}
TWDS.pinning.test = function () { TWDS.pinning.addnotification(2665000) }

TWDS.pinning.addnotification = function (itemid) {
  const old = TWDS.q1('#ui_notibar .TWDS_notibar_item_' + itemid)
  if (old) return

  const item = ItemManager.get(itemid)
  if (!item) return
  const bi = Bag.getItemByItemId(itemid)
  if (!bi) return

  const notification = new window.OnGoingEntry()
  notification.init(item.image, function () {
    const id = this.element[0].dataset.itemid
    const bi = Bag.getItemByItemId(id)
    const obsolete = parseInt(this.element[0].dataset.obsolete || '0')
    if (bi && !obsolete) {
      Inventory.clickHandler(id, {})
    }
  }, 11)

  notification.setTooltip('You can use this now')
  notification.highlightBorder()
  notification.element[0].dataset.itemid = itemid
  notification.element[0].classList.add('TWDS_notibar_item')
  notification.element[0].classList.add('TWDS_notibar_item_' + itemid)
  WestUi.NotiBar.add(notification)
}
TWDS.pinning.onclick = function () {
  const id = this.dataset.twds_item_id
  const bi = Bag.getItemByItemId(id)
  if (bi) {
    Inventory.clickHandler(id, {})
  }
}
TWDS.pinning.handledrop = function (ele, inbucket) {
  if (!ele) return false
  if (!ele[0]) return false
  if (!ele[0].parentNode) return false // paranoia, but i've seen this a long time ago.
  // need to return false, else the onclick handler is not run
  if (!inbucket && ele[0].classList.contains('TWDS_pinned_thing')) return false

  const id = parseInt(ele[0].parentNode.dataset.twds_item_id)
  const str = window.localStorage.TWDS_pinned_items || '[]'
  const list = JSON.parse(str)

  const idx = list.indexOf(id)
  if (inbucket) {
    if (idx > -1) {
      list.splice(idx, 1)
    }
  } else {
    if (idx === -1) { list.push(id) }
  }
  window.localStorage.TWDS_pinned_items = JSON.stringify(list)
  TWDS.pinning.getcontent()
}
TWDS.pinning.getitems = function () {
  const x = window.localStorage.TWDS_pinned_items || '[]'
  const list = JSON.parse(x)
  return list
}
TWDS.pinning.getinvitems = function (asobject) {
  const p = TWDS.pinning.getitems()
  let q = window.localStorage.TWDS_invpinned_items || '{}'
  q = JSON.parse(q)
  const res = []
  for (let i = 0; i < p.length; i++) {
    const id = p[i]
    if (q[id]) res.push(id)
  }
  return res
}
TWDS.pinning.threedots = function (ev) {
  console.log('...', this)
  ev.stopPropagation()
  const sb = (new west.gui.Selectbox(true))
    .setHeight('347px')
    .setWidth('260px')
    .addListener(function (choice) {
      console.log('CHOICE', choice, this)
      sb.hide()
    })
  for (let i = 0; i < 4; i++) {
    const c = TWDS.createEle('input.test' + i, {
      type: 'checkbox',
      onchange: function () {
        console.log('cb change')
        ev.stopPropagation()
        return false
      }
    })
    const u = TWDS.createEle('u', {
      children: [
        c,
        { nodeName: 'span', textContent: ' ' + i }
      ]
    })
    sb.addItem(i, u)
  }
  sb.show(ev)

  return true
}
TWDS.pinning.getcontent = function () {
  const x = window.localStorage.TWDS_pinned_items || '[]'
  const y = window.localStorage.TWDS_invpinned_items || '{}'
  const list = JSON.parse(x)
  const ilist = JSON.parse(y)

  const content = TWDS.q1('.TWDS_pinning_container')
  content.textContent = ''
  for (let i = 0; i < list.length; i++) {
    const id = list[i]
    const t = new tw2widget.Item(ItemManager.get(id)).setCharacter(Character).getMainDiv()[0]
    content.appendChild(t)
    t.style.display = 'inline-block'
    t.style.float = 'none'
    t.dataset.twds_item_id = id
    t.onclick = TWDS.pinning.onclick
    TWDS.createEle('span.cooldown', { last: t, children: [{ nodeName: 'p' }] })
    TWDS.createEle('input.invpin', {
      type: 'checkbox',
      last: t,
      checked: !!ilist[id],
      title: TWDS._('MISC_INVPINNING_TITLE', 'Pin this item to the inventory'),
      onclick: function (ev) {
        ev.stopPropagation()
        return true
      },
      onchange: function (ev) {
        ilist[id] = !ilist[id]
        window.localStorage.TWDS_invpinned_items = JSON.stringify(ilist)
        ev.stopPropagation()
        return false
      },
      children: [{ nodeName: 'b', textContent: '...' }]
    })
    const img = TWDS.q1('.tw_item', t)
    img.classList.add('TWDS_pinned_thing')
    $(img).setDraggable()
  }
  if (list.length === 0) {
    content.textContent = 'drag and drop'
  }
  let rows = Math.ceil((list.length) / 4)
  if (rows < 1) rows = 1
  const win = content.closest('.TWDS_pinning_window')
  win.style.height = (95 + rows * 62) + 'px'
}

TWDS.pinning.openwindow = function (ev) {
  const win = wman.open('TWDS_pinning_window', 'Pinned items', 'TWDS_pinning_window')
  win.setMiniTitle('Pinning')

  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_pinning_container',
    style: {
      minHeight: '62px'
    }
  })
  sp.appendContent(content)
  win.divMain.style.width = '295px'
  if (!ev || (ev && ev.clientX < 250 && ev.clientY < 250)) {
    win.divMain.style.top = '198px'
    win.divMain.style.left = '12px'
  } else {
    win.divMain.style.top = '44px'
    win.divMain.style.left = ev.clientX + 'px'
  }

  const ti = TWDS.q1('.textart_title', win.divMain)
  if (ti) {
    const obj = ItemManager.get(1760000)
    const img = TWDS.createEle('img', {
      src: obj.image,
      className: 'TWDS_pinning_bucket',
      style: {
        height: '32px',
        left: '8px',
        position: 'absolute',
        filter: 'brightness(2.0)'
      },
      first: ti
    })
    $(img).asDropzone('.tw_item.TWDS_pinned_thing', false, function (ele) {
      TWDS.pinning.handledrop(ele, true)
    })
    TWDS.createEle({
      nodeName: 'div',
      id: 'TWDS_pinning_cooldowninfo',
      last: ti
    })
  }

  $(content).asDropzone('.item_inventory_img', false, function (ele) {
    TWDS.pinning.handledrop(ele, false)
  })

  win.appendToContentPane(sp.getMainDiv())
  TWDS.pinning.getcontent()
}
TWDS.pinning.start = function () {
  if (!TWDS.settings.misc_pinning_bucket) {
    const old = TWDS.q1('#ui_topbar .TWDS_pinning_starter')
    if (old) old.remove()
    return
  }
  const tb = TWDS.q1('#ui_topbar')
  const obj = ItemManager.get(1761000)
  TWDS.createEle('img', {
    src: obj.image,
    className: 'TWDS_pinning_starter',
    style: {
      height: '32px',
      right: '22px',
      position: 'absolute',
      filter: 'brightness(2.0)',
      cursor: 'pointer'
    },
    onclick: TWDS.pinning.openwindow,
    last: tb
  })
}
TWDS.registerStartFunc(function () {
  TWDS.registerSetting('bool', 'misc_pinning_bucket',
    TWDS._('MISC_SETTING_PINNING', 'Muestra un cubo fijado en la barra superior. También puedes abrir la ventana de fijación si haces clic en la barra de motivación del duelo debajo de la información del personaje.'),
    true, TWDS.pinning.start)
  TWDS.pinning.cooldowninterval = window.setInterval(TWDS.pinning.cooldownhandler, 1000)
})
// vim: tabstop=2 shiftwidth=2 expandtab

// duel protection, duel motivation bar
TWDS.duelinfo = {}
TWDS.duelinfo.interval = 0
TWDS.duelinfo.updateafter = 0
TWDS.duelinfo.reloadafter = 0
TWDS.duelinfo.bar = null
TWDS.duelinfo.updateMouseover = function () {
  const mand = Character.getMandatoryDuelProtection(true)
  const opt = Character.getDuelProtection(true)
  const now = (new window.ServerDate()).getTime()
  let str = ''
  let vgl = -1
  if (mand > now) {
    str = TWDS._('DUELINFO_SUSPENSION', 'Duel suspension until') + ' ' + (new Date(mand)).toLocaleString()
    vgl = mand
  } else if (opt > now) {
    str = TWDS._('DUELINFO_PROTECTION', 'Duel protection until') + ' ' + (new Date(opt)).toLocaleString()
    vgl = opt
  }
  if (vgl !== -1) {
    const remain = Math.max((vgl - now) / 1000, 0) // ms
    const remainstr = remain.formatDuration()
    if (remain > 0) {
      str += ' (' + remainstr + ')'
    }
    str += '.\n'
  }
  const mot1 = Character.duelMotivation
  const mot2 = Character.npcDuelMotivation
  str += '<p>' + TWDS._('DUELINFO_DUEL_MOTIVATION', 'Duel motivation:') + '</p>'
  str += '<table>'
  str += '<tr><th>PC'
  str += '<td><meter min="0" low="0" optimum="1" high="1" max="1" value="' + mot1 + '"></meter>'
  str += '<td>' + Math.round(100 * mot1)
  str += '<tr><th>NPC'
  str += '<td><meter min="0" low="0" optimum="1" high="1" max="1" value="' + mot2 + '"></meter>'
  str += '<td>' + Math.round(100 * mot2)
  str += '</table>'
  $(TWDS.duelinfo.bar).addMousePopup(str)
}
TWDS.duelinfo.update = function (force) {
  if (!TWDS.duelinfo.bar) { TWDS.duelinfo.bar = TWDS.q1('#TWDS_duelinfo_bar') }
  const bar = TWDS.duelinfo.bar
  if (!TWDS.duelinfo.bar) return
  const now = (new window.ServerDate()).getTime()
  let left = Character.getDuelProtection(true) - now
  left /= 1000
  let str = ''
  bar.style.filter = ''
  if (left > 1) {
    if (left > 120 * 60) {
      str = Math.round(left / 3600) + 'h, '
      TWDS.duelinfo.updateafter = now + 60 * 1000
    } else if (left > 120) {
      str = Math.round(left / 60) + 'm, '
      TWDS.duelinfo.updateafter = now + 30 * 1000
    } else {
      str = Math.round(left) + 's, '
      TWDS.duelinfo.updateafter = now + 1 * 1000
    }
    if (left / 3600 > Game.duelProtectionHours - Game.duelProtectionEarly) {
      bar.style.backgroundPositionY = '-0px' // red
      console.log('red')
    } else {
      bar.style.backgroundPositionY = '-13px' // blue
    }
  } else {
    TWDS.duelinfo.updateafter = now + 10 * 60 * 1000
    bar.style.backgroundPositionY = '-25px' // green
    if (Character.homeTown.town_id === 0) {
      bar.style.filter = 'grayscale(1)'
    }
  }
  let m = Character.duelMotivation
  bar.style.backgroundPositionX = -(137 * (1 - m)) + 'px'
  str += Math.round(m * 100).toString() + '%'
  m = Character.npcDuelMotivation
  if (m < 1) {
    str += ' (' + Math.round(m * 100).toString() + '%)'
  }
  bar.textContent = str
  TWDS.duelinfo.updateMouseover()
}
TWDS.duelinfo.intervalhandler = function () {
  const now = (new window.ServerDate()).getTime()
  if (now > TWDS.duelinfo.reloadafter) {
    Ajax.remoteCall('duel', 'get_data', {}, function (d) {
      if (d.error) {
        return
      }
      TWDS.duelinfo.reloadafter = now + 15 * 60 * 1000
      Character.setDuelMotivation(d.motivation)
      Character.setNPCDuelMotivation(d.motivation_npc)
      TWDS.duelinfo.update()
    })
  }
  if (now > TWDS.duelinfo.updateafter) {
    TWDS.duelinfo.update()
  }
}
TWDS.duelinfo.init = function () {
  console.log('DI init')
  if (!TWDS.settings.misc_duelinfo_display) {
    if (TWDS.duelinfo.interval) {
      clearInterval(TWDS.duelinfo.interval)
      TWDS.duelinfo.interval = 0
    }
    if (TWDS.duelinfo.bar !== null) {
      $(TWDS.duelinfo.bar).removeMousePopup()
      TWDS.duelinfo.bar.remove()
    }
    return
  }
  // this is what clothcalc did, copied for compatibility
  if (Character.setDuelProtection.toString().search('duelprotection_changed') === -1) {
    Character.TWDS_setDuelProtection = Character.setDuelProtection
    Character.setDuelProtection = function (e) {
      if (e === 0) {
        e = 1
      }
      const t = e !== Character.duelProtection
      Character.TWDS_setDuelProtection.apply(this, arguments)
      if (t) {
        EventHandler.signal('duelprotection_changed', [])
      }
    }
  }
  EventHandler.listen('duelprotection_changed', TWDS.duelinfo.update)

  let old = TWDS.q1('#TWDS_duelinfo_bar')
  console.log('DI old', old)
  if (old) { old.remove() }

  old = TWDS.q1('#TWDS_ui_character_container_copy')
  if (old) { old.remove() }

  TWDS.duelinfo.bar = null
  const container = TWDS.q1('#ui_character_container')
  if (TWDS.settings.misc_duelinfo_display) {
    TWDS.createEle({
      nodeName: 'div',
      id: 'TWDS_ui_character_container_copy',
      first: container.parentNode
    })
    TWDS.duelinfo.bar = TWDS.createEle({
      nodeName: 'div',
      id: 'TWDS_duelinfo_bar',
      className: 'TWDS_duelinfo_bar status_bar',
      style: {
        backgroundPosition: '0px -12px',
        top: '175px',
        left: '3px'
      },
      textContent: '',
      onclick: TWDS.pinning.openwindow,
      last: container
    })
  }
  Ajax.remoteCall('duel', 'get_data', {}, function (d) {
    if (d.error) {
      return
    }
    Character.setDuelMotivation(d.motivation)
    Character.setNPCDuelMotivation(d.motivation_npc)
    TWDS.duelinfo.update()
    TWDS.duelinfo.interval = setInterval(TWDS.duelinfo.intervalhandler, 30 * 1000)
  })
}
/*
TWDS.duelinfo.ajaxCompletehandler = function (event, xhr, settings) {
  const url = settings.url
  if (url.search('window=duel') !== -1) {
    if (url.search('action=duel_npc') !== -1) {

    }
  }
}
*/
TWDS.registerStartFunc(function () {
  TWDS.registerSetting('bool', 'misc_duelinfo_display',
    TWDS._('MISC_SETTING_DUELINFO_DISPLAY', 'Mostrar una barra de estado de duelo con la información de su personaje.'),
    true, TWDS.duelinfo.init)
  EventHandler.listen('duelmotivation_changed', function () {
    TWDS.duelinfo.update()
  })
})
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.calendar = {}
TWDS.calendar.list = [
  ['e', '12-15', '12-22', '17-23d', 'Holiday Sale', '$/Bond/Nugget Sale'],
  ['e', '12-15', '12-21', '23d', 'Gift Hunt', 'Click Event'],
  ['e', '12-06', '12-26', '21d', 'Christmas', "Repeatable Quest: 1AP, 1FP. First year: also a Snowman's Hat"],
  ['e', '11-23', '11-29', '2d', 'Black Friday', 'Nugget Sale, with a discount'],

  ['e', '11-23', '12-07', '12-16d', 'Pumpkin Hunt', 'Click Event'],
  ['q', '11-23', '11-30', '7d', 'Thanksgiving', 'Repeatable Quest (1SP, 1AP). First year: 1AP, Thanksgiving boots.'],

  ['e', '10-27', '11-02', '2-6d', 'Halloween Sale', 'Bond/Nugget Sale (Fun Items)'],
  ['q', '10-25', '11-15', '15d', 'The three-day fiesta', 'Repeatable Quest (1SP).'],

  ['e', '10-27', '11-08', '20d', 'Day of the Dead', 'Regular Event'],
  ['q', '10-25', '11-15', '19d', 'Day of the Dead', 'Repeatable Quest (1SP)'],

  ['e', '09-12', '10-22', '26-28d', 'Octoberfest', 'Regular Event'],
  ['q', '09-12', '10-22', '21d', 'Octoberfest', 'Repeatable Quest (1SP).'],

  ['e', '08-15', '08-22', '14-23d', 'Harvest Event', 'Click Event'],
  ['e', '08-18', '09-05', '14-23d', 'Harvest Sale', 'Bond/nugget sale: Get your lemonade.'],

  ['q', '07-01', '07-29', '29d', 'West Point',
    'Repeatable Quest (1SP) event. First year: the medal of merit (collectible) and a golden letter.'],
  ['e', '06-23', '07-07', '21d', 'Independence Day', 'Regular event'],

  ['e', '06-07', '06-14', '21d', 'June click event', 'Click event, not every year'],

  ['e', '05-10', '05-25', '17-20d', 'Crafting Event', 'New recipes, birthday drinks', ''],
  ['e', '04-29', '05-07', '4d', 'Birthday Event', 'Mini Event: Large World Bonusses, Quests, whatever'],
  ['e', '03-23', '04-13', '24d', 'Easter', 'Regular Event'],
  ['q', '03-17', '04-09', '22d', 'Brewing bad', 'Repeatable Quest (1SP). First year: St. Patricks bow tie.'],
  ['e', '03-12', '03-17', '15d', 'St. Patrick', 'Alternatively a click event.'],

  ['e', '02-07', '02-17', '20-28d', 'Valentine', 'Regular Event'],
  ['q', '02-15', '03-06', '20d', "Gone with the Valentine's Day",
    'Repeatable Quest (1SP). First year: the night scarf'],
  ['q', '02-14', '03-03', '18d', 'One foolish Romeo',
    'Repeatable Quest (1SP). First year: the lakota blanket'],
  ['q', '01-31', '03-05', '34d', 'The provincial doctor', 'Repeatable Quest (1SP). First year: some boosts'],

  ['e', '01-30', '02-03', '14-15d', 'Winter Event', 'Click Event']
]
TWDS.calendar.openwindow = function () {
  const win = wman.open('TWDS_calendar_window', TWDS._('CALENDAR_WIN_TITLE', 'Calendario'))
  win.setMiniTitle(TWDS._('CALENDAR_MINI_TITLE', 'Calendario'))

  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_calendar_container'
  })
  const table = TWDS.createEle('table', { beforeend: content })
  const thead = TWDS.createEle('thead', { beforeend: table })
  thead.appendChild(TWDS.createEle({
    nodeName: 'tr',
    children: [
      { nodeName: 'th.start', textContent: 'Start' },
      { nodeName: 'th.term', textContent: 'Length' },
      { nodeName: 'th.name', textContent: 'Name' },
      { nodeName: 'th.desc', textContent: 'Description' }
    ]
  }))
  const tbody = TWDS.createEle('tbody', { beforeend: table })

  for (let i = 0; i < TWDS.calendar.list.length; i++) {
    const e = TWDS.calendar.list[i]
    TWDS.createEle({
      nodeName: 'tr',
      last: tbody,
      children: [
        { nodeName: 'td.start', textContent: e[1] + ' - ' + e[2] },
        { nodeName: 'td.term', textContent: e[3] },
        { nodeName: 'td.name', textContent: e[4] },
        { nodeName: 'td.desc', textContent: e[5] }
      ]
    })
  }
  const dl = TWDS.createEle('dl', { last: content })
  TWDS.createEle('dt', { last: dl, textContent: 'a' })
  TWDS.createEle('dd', { last: dl, textContent: 'description' })
  TWDS.createEle('dt', { last: dl, textContent: 'b' })
  TWDS.createEle('dd', { last: dl, textContent: 'description' })
  sp.appendContent(content)

  win.appendToContentPane(sp.getMainDiv())
}
TWDS.registerExtra('TWDS.calendar.openwindow',
  TWDS._('CALENDDR_TITLE', 'Calendario'),
  TWDS._('CALENDAR_DESC', 'Muestra un calendario de eventos.'))
// vim: tabstop=2 shiftwidth=2 expandtab

TWDS.vipendtime = {}
TWDS.vipendtime.element = null
TWDS.vipendtime.handler = function () {
  const now = new window.ServerDate().getTime()
  let dt = 0
  for (const p of Object.keys(Premium.endTimes)) {
    const e = Premium.endTimes[p]
    if (e > now / 1000) {
      if (dt === 0 || dt > e) { dt = e }
    }
  }
  if (dt) {
    dt = dt - now / 1000
    let ele = TWDS.q1('#buffbars .buffbar_vip .bag_item_mini .TWDS_vipendtime')
    if (!ele) {
      const bv = TWDS.q1('#buffbars .buffbar_vip .bag_item_mini')
      if (bv) {
        ele = TWDS.createEle({
          nodeName: 'div.TWDS_vipendtime',
          last: bv
        })
      }
    }
    if (ele) {
      ele.textContent = dt.formatDurationBuffWay()
    }
  }
}

TWDS.registerStartFunc(function () {
  TWDS.vipendtime.interval = 0

  TWDS.registerSetting('bool', 'vipendtime_show',
    TWDS._('VIPENDTIME_SETIING_SHOW', 'Mostrar la hora de finalización VIP sobre la pantalla VIP.'),
    false, function (v) {
      if (TWDS.vipendtime.interval) {
        window.clearInterval(TWDS.vipendtime.interval)
        TWDS.vipendtime.interval = 0
        if (TWDS.vipendtime.element) {
          TWDS.vipendtime.element.remove()
          TWDS.vipendtime.element = null
        }
      }
      if (v) {
        TWDS.vipendtime.handler()
        TWDS.vipendtime.interval = window.setInterval(TWDS.vipendtime.handler, 60 * 1000)
      }
    }
  )
})
// vim: tabstop=2 shiftwidth=2 expandtab
//

TWDS.inventory = {}
TWDS.inventory.handleallselect = function (choice) {
  let res = []
  const all = Bag.search('')
  console.log('ALLMODE')
  for (let i = 0; i < all.length; i++) {
    const o = all[i]
    res.push(o)
  }
  res = TWDS.inventory.filteritemlist(res)
  Inventory.showSearchResult(res)
}
TWDS.inventory.handleprofselect = function (prof) {
  const res = []
  const num = parseInt(prof)
  if (isNaN(num)) {
    const all = Bag.search('')
    for (let i = 0; i < all.length; i++) {
      const o = all[i]
      const it = o.obj
      if (it.type === 'recipe') {
        if (it.profession === prof) {
          res.push(o)
        }
      }
    }
  } else {
    const all = ItemManager.getAll()
    for (const it of Object.values(all)) {
      if (it.type === 'recipe') {
        if (it.craftitem && it.profession_id === num) {
          const found = Bag.getItemsByItemIds([it.craftitem])
          if (found.length) {
            res.push(found[0])
          }
        }
      }
    }
  }
  Inventory.showCustomItems(res)
  Inventory.DOM[0].classList.remove('instant_wear_enabled')
}
TWDS.inventory.handlecatselect = function (cat) {
  TWDS.quickusables.showusables(cat)
  Inventory.DOM[0].classList.remove('instant_wear_enabled')
}
TWDS.inventory.sortorders = {
  id: { text: 'Id', trans: 'INVENTORY_S_ID' },
  name: { text: 'Name', trans: 'INVENTORY_S_NAME' },
  count: { text: 'Count', trans: 'INVENTORY_S_COUNT' },
  price: { text: 'Price', trans: 'INVENTORY_S_PREIS' },
  stackprice: { text: 'Total price', trans: 'INVENTORY_S_STACKPRICE' },
  maxdmg: { text: 'Damage', trans: 'INVENTORY_S_DAMAGE' }
}
TWDS.inventory.filters = {
  auctionable: { value: 0, text: 'Auctionable', trans: 'INVENTORY_D_AUCTIONABLE' },
  sellable: { value: 0, text: 'Sellable', trans: 'INVENTORY_D_SELLABLE' },
  upgradeable: { value: 0, text: 'Upgradeable', trans: 'INVENTORY_D_UPGRADEABLE' },
  upgraded: { value: 0, text: 'Upgraded', trans: 'INVENTORY_D_UPGRADED' },
  duplicate: { value: 0, text: 'Duplicate', trans: 'INVENTORY_D_DUPLICATE' },
  dropable: { value: 0, text: 'Dropable', trans: 'INVENTORY_D_DROPABLE' },
  tradeable: { value: 0, text: 'Tradeable', trans: 'INVENTORY_D_TRADEABLE' },
  used: { value: 0, text: 'Used', trans: 'INVENTORY_D_USED' },
  set: { value: 0, text: 'Part of a set', trans: 'INVENTORY_D_SETPART' },
  quest: { value: 0, text: 'Questitem', trans: 'INVENTORY_D_QUEST' },
  classgender: { value: 0, text: 'Class/gender limited', trans: 'INVENTORY_D_CLASSGENDER' },
  named: { value: 0, text: 'Named', trans: 'INVENTORY_D_NAMED' }
}
TWDS.inventory.filteritemlist = function (all) {
  const tmp = []
  const filters = {}
  const findinbagandworn = function (baseid) {
    const res = Bag.getItemsIdsByBaseItemId(baseid)
    let x = Wear.getByBaseId(baseid)
    if (x) {
      x = x.obj.item_id.toString()
      if (!res.includes(x)) { res.push(x) }
    }
    return res
  }
  // .named is not well maintained.
  const findifitisnamed = function (it) {
    let isnamed = it.named
    if (!isnamed) {
      let it2 = it
      if (it.item_level) {
        it2 = ItemManager.getByBaseId(it.item_base_id)
      }
      if (!it2.set && it2.usebonus === null && it2.usetype === 'none') {
        if (it2.auctionable) {
          if (it2.dropable) {
            if (!it2.tradeable || it2.traderlevel > 98) {
              isnamed = true
            }
          }
        }
      }
    }
    return isnamed
  }
  const getdmg = function (it) {
    extractor.init(Character, it.item_level)
    let dmg = 0
    if (it.type === 'right_arm' || it.type === 'left_arm') {
      dmg = it.damage.damage_max
    }
    for (let i = 0; i < it.bonus.item.length; i++) {
      const bon = it.bonus.item[i]

      const v = extractor.getExportValue(bon)
      if (v.key === 'damage') {
        dmg += v.value
      }
    }
    return dmg
  }

  // no shortcuts, we return a copy of the list, as it may be Bag.items_by_type[x]

  for (const [k, d] of Object.entries(TWDS.inventory.filters)) {
    if (d.value === 0) continue
    filters[k] = d.value
  }

  const ls = window.localStorage.TWDS_itemusage
  let usedata
  if (typeof ls === 'undefined') {
    usedata = {}
  } else {
    usedata = JSON.parse(ls)
  }

  for (let i = 0; i < all.length; i++) {
    let id
    let it
    if (typeof all[i] === 'object') {
      it = all[i]
      if (it.obj) { it = it.obj }
      id = it.item_id
    } else {
      id = all[i]
      it = ItemManager.get(id)
      if (!it) continue
    }
    if ('auctionable' in filters) {
      if (filters.auctionable === 1 && !it.auctionable) continue
      if (filters.auctionable === -1 && it.auctionable) continue
    }
    if ('classgender' in filters) {
      if (filters.classgender === 1 && !it.characterSex && !it.characterClass) continue
      if (filters.classgender === -1 && (it.characterSex || it.characterClass)) continue
    }
    if ('dropable' in filters) {
      if (filters.dropable === 1 && !it.dropable) continue
      if (filters.dropable === -1 && it.dropable) continue
    }
    if ('duplicate' in filters) {
      const b = Bag.getItemByItemId(id)
      if (!b) continue
      const worn = Wear.carries(it.item_base_id)
      const count = b.getCount() + (worn ? 1 : 0)
      if (filters.duplicate === 1 && count < 2) continue
      if (filters.duplicate === -1 && count > 1) continue
    }
    if ('sellable' in filters) {
      if (filters.sellable === 1 && !it.sellable) continue
      if (filters.sellable === -1 && it.sellable) continue
    }
    if ('set' in filters) {
      if (filters.set === 1 && !it.set) continue
      if (filters.set === -1 && it.set) continue
    }
    if ('quest' in filters) {
      if (filters.quest === 1 && !it.quest) continue
      if (filters.quest === -1 && it.quest) continue
    }
    if ('tradeable' in filters) {
      if (filters.tradeable === 1 && !it.tradeable) continue
      if (filters.tradeable === -1 && it.tradeable) continue
    }
    if ('upgradeable' in filters) {
      if (filters.upgradeable === 1 && !it.upgradeable) continue
      if (filters.upgradeable === -1 && it.upgradeable) continue
    }
    if ('upgraded' in filters) {
      // non-upgraded items are treated as upgraded if there are upgraded items of the thing in the bag
      if (filters.upgraded === 1 && !it.item_level) {
        const inbag = findinbagandworn(it.item_base_id)
        if (inbag.length < 2) continue
      }
      if (filters.upgraded === -1 && !it.item_level) {
        const inbag = findinbagandworn(it.item_base_id)
        if (inbag.length > 1) continue
      }
      if (filters.upgraded === -1 && it.item_level) continue
    }
    if ('used' in filters) {
      const d = TWDS.storage.getitemdata(id)
      if (filters.used === 1 && !(id in usedata) && d.want < d.have) continue
      if (filters.used === -1 && ((id in usedata) || d.want >= d.have)) continue
    }
    if ('named' in filters) {
      const isnamed = findifitisnamed(it)
      if (filters.named === 1 && !isnamed) continue
      if (filters.named === -1 && isnamed) continue
    }
    tmp.push(all[i])
  }

  // now for the funny part.
  let dir = 1
  if (TWDS.inventory.sortorder.substring(0, 1) === '-') dir = -1
  const key = TWDS.inventory.sortorder.substring(1)

  const extractor = new west.item.BonusExtractor(Character)

  tmp.sort(function (a, b) {
    if (typeof a === 'object') {
      if (a.obj) { a = a.obj }
    } else {
      a = ItemManager.get(a)
      if (!a) return -1
    }
    if (typeof b === 'object') {
      if (b.obj) { b = b.obj }
    } else {
      b = ItemManager.get(b)
      if (!b) return 1
    }

    if (key === 'name') {
      const t = dir * a.name.localeCompare(b.name)
      if (t) return t
    }
    if (key === 'count') {
      const ac = Bag.getItemByItemId(a.item_id).count
      const bc = Bag.getItemByItemId(b.item_id).count
      const t = dir * (ac - bc)
      if (t) return t
    }
    if (key === 'price') {
      let aprice = a.price
      let bprice = b.price
      if (!a.auctionable && !a.sellable) aprice = 0
      if (!b.auctionable && !b.sellable) bprice = 0
      const t = dir * (aprice - bprice)
      if (t) return t
    }
    if (key === 'stackprice') {
      let aprice = a.price
      let bprice = b.price
      if (!a.auctionable && !a.sellable) aprice = 0
      if (!b.auctionable && !b.sellable) bprice = 0
      const acount = Bag.getItemByItemId(a.item_id).count
      const bcount = Bag.getItemByItemId(b.item_id).count
      const t = dir * (acount * aprice - bcount * bprice)
      if (t) return t
    }

    if (key === 'maxdmg') {
      const admg = getdmg(a)
      const bdmg = getdmg(b)
      const t = dir * (admg - bdmg)
      if (t) return t
    }
    return dir * (a.item_id - b.item_id)
  })

  return tmp
}
// Bag.getItemsIdsByType wrapper. The function is only called from the Inventory - after the patching in the startup
TWDS.inventory.getItemsIdsByType = function (type) {
  const all = Bag.items_by_type[type] || []
  const tmp = TWDS.inventory.filteritemlist(all)
  return tmp
}
TWDS.inventory.showfilterwarning = function () {
  let warn = 0
  for (const d of Object.values(TWDS.inventory.filters)) {
    if (d.value) warn = 1
  }
  const ele = TWDS.q1('.inventory')
  console.log('SFW', ele, warn)
  if (ele) {
    if (warn) { ele.classList.add('TWDS_filters_active') } else { ele.classList.remove('TWDS_filters_active') }
  }
}
TWDS.inventory.sortorder = '+id'
TWDS.inventory.handleconfigureclick = function (eventdata) {
  let container
  const changer = function (event) {
    TWDS.inventory.filters[this.name].value = parseInt(this.value)
  }
  const sortchanger = function (event) {
    TWDS.inventory.sortorder = this.value
    console.log('SC', this.value)
  }
  const done = function (event) {
    console.log('done')
    Inventory.update()
    if (container) container.remove()
    TWDS.inventory.showfilterwarning()
  }

  container = TWDS.q1('table.TWDS_inv_filterselect')
  if (container) container.remove()

  const fi = TWDS.q1('.filters', Inventory.window.divMain)
  container = TWDS.createEle('table.TWDS_inv_filterselect', {
    last: fi
  })
  let keys = Object.keys(TWDS.inventory.filters)
  console.log('keys', keys)
  let tr = TWDS.createEle('tr.filterhead', { last: container })
  const th = TWDS.createEle('th', {
    last: tr,
    colSpan: 4
  })
  TWDS.createEle('span', {
    textContent: TWDS._('INVENTORY_FILTER', 'Filter'),
    last: th
  })
  TWDS.createEle('button', {
    textContent: TWDS._('INVENTORY_RESET', 'Reset'),
    last: th,
    onclick: function () {
      for (const [k, d] of Object.entries(TWDS.inventory.filters)) {
        TWDS.q1("input[type='radio'][name='" + k + "'][value='0']", container).checked = true
        d.value = 0
      }
    }
  })

  for (let i = 0; i < keys.length; i++) {
    const key = keys[i]
    const d = TWDS.inventory.filters[key]
    const val = d.value

    const tr = TWDS.createEle('tr', { last: container })
    let td = TWDS.createEle('td', { last: tr })
    TWDS.createEle('label', {
      last: td,
      children: [
        { nodeName: 'input', type: 'radio', name: key, value: 1, onchange: changer, checked: val === 1 },
        { nodeName: 'span', textContent: TWDS._('INVENTORY_IS', 'is') }
      ]
    })
    td = TWDS.createEle('td', { last: tr })
    TWDS.createEle('label', {
      last: td,
      children: [
        { nodeName: 'input', type: 'radio', name: key, value: 0, onchange: changer, checked: val === 0 },
        { nodeName: 'span', textContent: TWDS._('INVENTORY_IGNORE', 'ignore') }
      ]
    })
    td = TWDS.createEle('td', { last: tr })
    TWDS.createEle('label', {
      last: td,
      children: [
        { nodeName: 'input', type: 'radio', name: key, value: -1, onchange: changer, checked: val === -1 },
        { nodeName: 'span', textContent: TWDS._('INVENTORY_ISNOT', 'is not') }
      ]
    })
    TWDS.createEle('td', { last: tr, textContent: TWDS._(d.trans, d.text) })
  }
  tr = TWDS.createEle('tr', { last: container })
  TWDS.createEle('th', {
    last: tr,
    colSpan: 4,
    textContent: TWDS._('INVENTORY_SORT', 'Sort')
  })

  keys = Object.keys(TWDS.inventory.sortorders)
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i]
    const d = TWDS.inventory.sortorders[key]

    const tr = TWDS.createEle('tr', { last: container })
    let td = TWDS.createEle('td', { last: tr })
    TWDS.createEle('label', {
      last: td,
      children: [
        { nodeName: 'input', type: 'radio', name: 'sortorder', value: '+' + key, onchange: sortchanger, checked: TWDS.inventory.sortorder === '+' + key },
        { nodeName: 'span', textContent: TWDS._('INVENTORY_UP', '+ / up') }
      ]
    })
    td = TWDS.createEle('td', { last: tr })
    td = TWDS.createEle('td', { last: tr })
    TWDS.createEle('label', {
      last: td,
      children: [
        { nodeName: 'input', type: 'radio', name: 'sortorder', value: '-' + key, onchange: sortchanger, checked: TWDS.inventory.sortorder === '-' + key },
        { nodeName: 'span', textContent: TWDS._('INVENTORY_DOWN', '- / down') }
      ]
    })
    TWDS.createEle('td', { last: tr, textContent: TWDS._(d.trans, d.text) })
  }

  tr = TWDS.createEle('tr', { last: container })
  TWDS.createEle('td', {
    last: tr,
    colSpan: 4,
    children: [
      { nodeName: 'button', textContent: 'done', onclick: done }
    ]
  })
}
TWDS.inventory.handlefilterclick = function (eventdata) {
  const filter = this.dataset.filter
  if (filter === 'recipe') {
    const sb = (new west.gui.Selectbox(true))
      .setHeight('347px')
      .setWidth('260px')
      .addListener(function (choice) {
        TWDS.inventory.handleprofselect(choice)
      })
    sb.addItem(null, '<i>--- ' + TWDS._('INVENTORY_RECIPES', 'Recipes') + ' ---</i>')
    for (let i = 1; i < 5; i++) {
      sb.addItem(Game.InfoHandler.getLocalString4ProfessionId(i), Game.InfoHandler.getLocalString4ProfessionId(i))
    }
    sb.addItem(null, '<i>--- ' + TWDS._('INVENTORY_PRODUCTS', 'Products') + ' ---</i>')
    for (let i = 1; i < 5; i++) {
      sb.addItem(i, Game.InfoHandler.getLocalString4ProfessionId(i))
    }
    sb.show(eventdata)
  }
  if (filter === 'useable') {
    const sb = (new west.gui.Selectbox(true))
      .setHeight('347px')
      .setWidth('260px')
      .addListener(function (choice) {
        TWDS.inventory.handlecatselect(choice)
      })
    sb.addClass('TWDS_inventory_xsel')
    const cats = TWDS.quickusables.getcategories(0)
    const ar = []
    for (let i = 0; i < cats.length; i++) {
      const cat = cats[i]
      ar.push([cat, TWDS.quickusables.getcatdesc(cat)])
    }
    ar.sort(function (a, b) {
      return a[1].localeCompare(b[1])
    })
    for (let i = 0; i < ar.length; i++) {
      sb.addItem(ar[i][0], ar[i][1])
    }
    sb.show(eventdata)
  }
}
TWDS.inventory.open2 = function (dw, clickhandler, opts) {
  const ret = Inventory.TWDS_backup_open.call(this, dw, clickhandler, opts)
  const filters = TWDS.q1('div.filters', ret.DOM[0])
  let found = 0
  if (filters) {
    if (TWDS.q1('div.TWDS_filter.TWDS_filter_recipe', filters)) { found = 1 }
  }
  const change = ['belt', 'body', 'foot', 'head', 'neck', 'pants', 'left_arm', 'right_arm', 'animal', 'yield']
  for (let i = 0; i < change.length; i++) {
    const ele = TWDS.q1('.filter_inventory.filter_' + change[i], filters)
    if (ele) {
      ele.classList.add('TWDS_maybefiltered')
    }
  }
  if (filters && !found && (TWDS.settings.inventory || TWDS.settings.inventory_add_filters)) {
    TWDS.createEle({
      nodeName: 'div.TWDS_filter.TWDS_filter_all.TWDS_maybefiltered',
      dataset: { filter: 'all' },
      title: TWDS._('INVENTORY_SHOW_ALL', 'Show all'),
      textContent: '',
      last: filters,
      onclick: TWDS.inventory.handleallselect
    })
    TWDS.createEle({
      nodeName: 'div.TWDS_filter.TWDS_filter_recipe',
      dataset: { filter: 'recipe' },
      title: TWDS._('INVENTORY_SHOW_RECIPES', 'Show recipes and crafted items'),
      textContent: '',
      last: filters,
      onclick: TWDS.inventory.handlefilterclick
    })
    TWDS.createEle({
      nodeName: 'div.TWDS_filter.TWDS_filter_useable',
      dataset: { filter: 'useable' },
      title: TWDS._('INVENTORY_SHOW_USABLES', 'Show usables'),
      textContent: '',
      last: filters,
      onclick: TWDS.inventory.handlefilterclick
    })
    TWDS.createEle({
      nodeName: 'div.TWDS_filter.TWDS_filter_configure',
      title: TWDS._('INVENTORY_FILTER_CONFIGURE', 'Configure filters'),
      textContent: '…',
      last: filters,
      onclick: TWDS.inventory.handleconfigureclick
    })
  }
  TWDS.inventory.showfilterwarning()
  return ret
}
TWDS.inventory.open = function (dw, clickhandler, opts) {
  const ret = TWDS.inventory.open2.call(this, dw, clickhandler, opts)
  return ret
}
TWDS.inventory.showcategory = function (category, data) {
  const ret = Inventory.TWDS_backup_showCategory.call(this, category, data)
  return ret
}
TWDS.inventory.showLastItems = function () { // reimplementation, not calling the original.
  $('#overlay_inv').show()
  const list = []
  const lastIds = Bag.getInventoryIds()
  const pinned = TWDS.pinning.getinvitems()
  let leftout = 0
  for (let i = 0; i < lastIds.length; i++) {
    const item = Bag.getItemByInvId(lastIds[i])
    if (item) {
      if (!pinned.includes(item.obj.item_id)) {
        list.push(item)
      } else {
        leftout++
      }
    }
  }
  let j = 0
  for (let i = 0; i < pinned.length; i++) {
    const item = Bag.getItemByItemId(pinned[i])
    if (item) {
      if (j < leftout) {
        list.unshift(item)
        j++
      } else {
        list[j++] = item
      }
    }
  }
  for (let i = 0; i < list.length; i++) {
    Inventory.addItemDivToInv(list[i])
  }
  Inventory.setNavigation('new', 1, 0)
}

// Biginventory touches the same variables, so be careful _NOT_ to change them "back" if we didn't set them.
TWDS.registerStartFunc(function () {
  Inventory.TWDS_backup_open = Inventory.open
  Inventory.open = TWDS.inventory.open
  Inventory.TWDS_backup_showLastItems = Inventory.showLastItems
  Inventory.showLastItems = TWDS.inventory.showLastItems
  Inventory.TWDS_backup_showCategory = Inventory.showCategory
  Inventory.showCategory = function (a, b) { return TWDS.inventory.showcategory(a, b) }
  Bag.TWDS_backup_i_getItemsIdsByType = Bag.getItemsIdsByType
  Bag.getItemsIdsByType = function (tp) { return TWDS.inventory.getItemsIdsByType(tp) }
  // these callers of getItemsIdsByType need to use the original function
  let t = Bag.getItemsByType.toString().replace(/this.getItemsIdsByType/, 'Bag.TWDS_backup_i_getItemsIdsByType')
  eval('Bag.getItemsByType=' + t) // eslint-disable-line  no-eval
  t = Bag.removeItem.toString().replace(/this.getItemsIdsByType/, 'Bag.TWDS_backup_i_getItemsIdsByType')
  eval('Bag.removeItem=' + t) // eslint-disable-line  no-eval

  const old = {
    size: -1,
    sizeSearch: -1,
    sizeCustom: -1,
    latestSize: -1,
    availableCategories: []
  }
  TWDS.registerSetting('bool', 'inventory',
    TWDS._('SETTING_INVENTORY', 'Proporcionar un inventario más grande.'),
    false, function (v) {
      if (v) {
        document.body.classList.add('TWDS_large_inventory')
        if (old.size === -1) {
          old.size = Inventory.size
          old.sizeSearch = Inventory.sizeSearch
          old.latestSize = Inventory.latestSize
          old.sizeCustom = Inventory.sizeCustom
          old.availableCategories = Inventory.availableCategories
        }
        Inventory.size = 66
        Inventory.sizeSearch = 55
        Inventory.sizeCustom = 55
        Inventory.availableCategories = ['new', 'belt', 'body', 'foot', 'head', 'neck', 'pants', 'animal', 'right_arm', 'left_arm', 'yield', 'upgradeable']
        Inventory.latestSize = 66
      } else {
        document.body.classList.remove('TWDS_large_inventory')
        if (old.size !== -1) {
          Inventory.size = old.size
          Inventory.sizeSearch = old.sizeSearch
          Inventory.sizeCustom = old.sizeCustom
          Inventory.latestSize = old.latestSize
          Inventory.availableCategories = old.availableCategories
        }
      }
    })
  TWDS.registerSetting('bool', 'inventory_add_filters',
    TWDS._('SETTING_INVENTORY_ADD_FILTERS', 'Agregar filtros incluso a un inventario de tamaño normal.'),
    false, function (v) {
      if (v) {
        document.body.classList.add('TWDS_normal_inventory_filters')
      } else {
        document.body.classList.remove('TWDS_normal_inventory_filters')
      }
    })
})
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.fbmisc = {}
TWDS.fbmisc.shownumberinterval = 0
TWDS.fbmisc.shownumber = function () {
  Ajax.remoteCall('fort_overview', '', {}, function (data) {
    const mp = TWDS.q1('#ui_bottombar .multiplayer')
    if (!mp) return

    let ele = TWDS.q1('.TWDS_fbcount', mp)

    let n = 0
    if (data.js) {
      for (let i = 0; i < data.js.length; i++) {
        if (data.js[i][3]) n++
      }
    }
    if (ele && !n) {
      ele.remove()
      return
    }
    if (!n) return
    if (!ele) {
      ele = TWDS.createEle({
        nodeName: 'span.TWDS_fbcount',
        last: mp
      })
    }
    ele.textContent = n
  })
}
TWDS.fbmisc.shownumberstarter = function () {
  if (TWDS.fbmisc.shownumberinterval) {
    window.clearInterval(TWDS.fbmisc.shownumberinterval)
    TWDS.fbmisc.shownumberinterval = 0
  }
  if (TWDS.settings.fbmisc_fbcount) {
    TWDS.fbmisc.shownumber()
    TWDS.fbmisc.shownumberinterval = window.setInterval(TWDS.fbmisc.shownumber, 5 * 60 * 1000)
  }
}
TWDS.fbmisc.renderPreBattle = function (a, b) {
  FortBattleWindow.TWDS_backup_renderPreBattle.apply(this, arguments)
  if (TWDS.settings.fbmisc_chattopic) {
    const fid = this.fortId
    const win = this.window
    const rooms = Chat.Resource.Manager.getRooms()
    for (const room of Object.values(rooms)) {
      if (room.id.includes('room_fortbattle_') && room.fortId === fid) {
        let topic = room.topic
        if (topic) topic = topic.trim()
        if (!topic) continue
        topic = Game.TextHandler.parse(topic)

        let gm = TWDS.q1('.gamemessages_container', win.divMain)
        if (!gm) {
          gm = TWDS.createEle({
            nodeName: 'div.gamemessages_container.selectable',
            children: [
              { nodeName: 'div.gamemessages_resizer' }
            ]
          })
          win.appendToWindowPane(gm)
        }
        let pane = TWDS.q1('.gamemessages_pane', gm)
        if (!pane) {
          pane = TWDS.createEle({
            nodeName: 'div.gamemessages_pane',
            last: gm
          })
        }
        TWDS.createEle({
          nodeName: 'div.TWDS_topicfromchat',
          innerHTML: topic,
          first: pane
        })
      }
    }
  }
}
TWDS.fbmisc.formatcharicon = function (p) {
  const ele = TWDS.createEle({
    nodeName: 'div.otherchar'
  })
  if (p.defender) { ele.classList.add('defender') } else { ele.classList.add('attacker') }
  if (p.freelancer) { ele.classList.add('freelancer') }
  ele.classList.add(p.class)
  return ele
}
TWDS.fbmisc.renderchars = function (data) {
  FortBattleWindow.TWDS_backup_renderChars.apply(this, arguments)
  if (TWDS.settings.fbmisc_charicons) {
    const cells = TWDS.q('.cell', this.battlegroundEl)
    if (cells) {
      for (let i = 0; i < cells.length; i++) {
        cells[i].classList.remove('TWDS_multiplechars')
        let o = TWDS.q('.otherchar', cells[i])
        for (let j = 0; j < o.length; j++) { o[j].remove() }

        cells[i].dataset.charcount = 0
        o = TWDS.q1('.ownchar', cells[i])
        if (o) { cells[i].dataset.charcount = 1 }
      }
    }
    if (data) { if (!this.preBattle.setPlayerlist(data.playerlist, true)) return }
    const playerlist = this.preBattle.battleData.playerlist
    for (let i = 0; i < playerlist.length; i++) {
      const pl = playerlist[i]
      if (pl.player_id === Character.playerId) continue
      if (pl.idx < 0) continue
      const el = TWDS.q1('.cell-' + pl.idx, this.battlegroundEl)
      if (!el) continue
      el.dataset.charcount = parseInt(el.dataset.charcount) + 1
      /*
      let own=TWDS.q1(".ownchar",el);
      if (own) continue; // more important: me.
      let target=TWDS.q1(".target",el);
      if (target) continue; // more important: me.
*/
      el.appendChild(TWDS.fbmisc.formatcharicon(pl))
    }
    if (cells) {
      for (let i = 0; i < cells.length; i++) {
        const n = parseInt(cells[i].dataset.charcount)
        if (n > 1) { cells[i].classList.add('TWDS_multiplechars') }
      }
    }
  }
}
TWDS.fbmisc.fortoverviewshowtab = function (id) {
  FortOverviewWindow.TWDS_backup_showTab.apply(this, arguments)
  const icons = TWDS.q('.fortoverview-currentbattles a img.fortOverviewIconScroll')
  for (let i = 0; i < icons.length; i++) {
    const icon = icons[i]
    const a = icon.parentNode
    if (a.nodeName !== 'A') continue // paranoia
    let oc = a.onclick
    if (!oc) continue
    oc = oc.toString()
    const m = oc.match(/Map.center\(([0-9]+),\s*([0-9]+)\)/)
    const wt = TWDS.q1('span[class^=wayTime]', a.parentNode)
    if (wt) {
      const id = wt.className.replace(/wayTime/, '')
      TWDS.createEle({
        nodeName: 'a',
        href: '#',
        dataset: {
          id: id,
          x: m[1],
          y: m[2]
        },
        onclick: function () {
          window.Guidepost.show(this.dataset.id, this.dataset.x, this.dataset.y, 'fort')
        },
        before: wt,
        textContent: wt.textContent
      })
      wt.remove()
    }
  }
}

TWDS.fbmisc.startfunc = function () {
  TWDS.registerSetting('bool', 'fbmisc_fbcount',
    TWDS._('FBMISC_SETTING_FCOUNT', 'Mostrar el número de batallas de fuertes declaradas.'),
    true, TWDS.fbmisc.shownumberstarter, 'Batallas de Fuerte')
  TWDS.registerSetting('bool', 'fbmisc_chattopic',
    TWDS._('FBMISC_SETTING_CHATTOPIC', 'Copiar tema del chat en ventana previa de batalla. ###Conflicto con TWIR###'),
    true, null, 'Batallas de Fuerte')
  TWDS.registerSetting('bool', 'fbmisc_charicons',
    TWDS._('FBMISC_SETTING_CHARICONS', 'Mostrar íconos específicos de clase en la ventana de preparación de la batalla.'),
    true, null, 'Batallas de Fuerte')
  TWDS.registerSetting('bool', 'fbmisc_walk',
    TWDS._('FBMISC_SETTING_WALK', 'Hacer clic en el tiempo de ida al fuerte para caminar hacia el fuerte.'),
    true, null, 'Batallas de Fuerte')

  FortBattleWindow.TWDS_backup_renderPreBattle = FortBattleWindow.TWDS_backup_renderPreBattle ||
    FortBattleWindow.renderPreBattle
  FortBattleWindow.renderPreBattle = TWDS.fbmisc.renderPreBattle

  FortBattleWindow.TWDS_backup_renderChars = FortBattleWindow.TWDS_backup_renderChars ||
    FortBattleWindow.renderChars
  FortBattleWindow.renderChars = TWDS.fbmisc.renderchars

  FortOverviewWindow.TWDS_backup_showTab = FortOverviewWindow.TWDS_backup_showTab ||
    FortOverviewWindow.showTab
  FortOverviewWindow.showTab = TWDS.fbmisc.fortoverviewshowtab
}
TWDS.registerStartFunc(function () {
  TWDS.fbmisc.startfunc()
})

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.townwindow = {}
TWDS.townwindow.hash = function (str) { // DJBs hash, with an additional &(2^32-1) since JS doesn't use 32bit floats.
  const len = str.length
  let hash = 5381
  for (let i = 0; i < len; i++) {
    hash = ((hash << 5) + hash + str.charCodeAt(i)) & 0xFFFFFFFF
  }
  return hash >>> 0
}
TWDS.townwindow.init = function (data, t) {
  TownWindow.TWDS_backup_init.apply(this, arguments)
  if (TWDS.settings.townwindow_alliance) {
    Ajax.remoteCallMode('building_cityhall', 'list_residents', {
      town_id: data.town_id
    }, function (residata) {
      if (residata.list && residata.list.data && residata.list.data[0]) {
        Ajax.remoteCallMode('profile', 'init', {
          playerId: residata.list.data[0].player_id
        }, function (profdata) {
          const an = profdata.town.alliance_name
          const ai = profdata.town.alliance_id
          const to = TWDS.q1('.town-overview', TownWindow.DOM)
          if (to && ai) {
            TWDS.createEle({
              nodeName: 'div.town-alliance.linklike',
              last: to,
              textContent: an,
              onclick: function () { AllianceWindow.open(ai) }
            })
          }
        })
      }
    })
  }
}

TWDS.townwindow.showrankingcrafters = function () {
  // this a bit complicated because the lacking (stupid) profile data doesn't contain the crafting level.
  // but we have the world crafting ranking, which, of course, doesn't contain the town info. Stupid.
  const titlestr = TWDS._('TOWNWINDOW_SRC_TITLE', 'Ranking crafters')
  const win = wman.open('TWDS_rankingcrafters', titlestr)
  win.setMiniTitle(TWDS._('TOWNWINDOW_SRC_MINITITLE', 'Crafters'))
  const sp = new west.gui.Scrollpane()

  const content = TWDS.createEle('div', {
    className: 'TWDS_achievements_container'
  })
  const state = TWDS.createEle('p.info', { last: content })

  state.textContent = 'please wait'
  sp.appendContent(content)
  win.appendToContentPane(sp.getMainDiv())

  Ajax.remoteCallMode('building_cityhall', 'list_residents', {
    town_id: this.dataset.townId
  }, function (residata) {
    const profs = [[], [], [], [], []]
    let profsdone = 0
    const allresidents = {}
    for (let i = 0; i < residata.list.data.length; i++) {
      const id = residata.list.data[i].player_id
      allresidents[id] = [-1, -1]
    }
    let playersfound = 0
    const playerscount = residata.list.data.length
    const limit = 3
    const finish = function () {
      state.textContent = ''
      const tab = TWDS.createEle({
        nodeName: 'table.rankingcrafters',
        last: content
      })
      let tr = TWDS.createEle('tr', { last: tab })
      TWDS.createEle('th', {
        last: tr,
        textContent: TWDS._('TOWNWINDOW_SRC_TH_PROF', 'Profession')
      })
      TWDS.createEle('th', {
        last: tr,
        textContent: TWDS._('TOWNWINDOW_SRC_TH_NUM', '#')
      })
      TWDS.createEle('th', {
        last: tr,
        textContent: TWDS._('TOWNWINDOW_SRC_TH_PLAYER', 'Player name')
      })
      TWDS.createEle('th', {
        last: tr,
        textContent: TWDS._('TOWNWINDOW_SRC_TH_POINTS', 'Points')
      })
      TWDS.createEle('th', {
        last: tr,
        textContent: TWDS._('TOWNWINDOW_SRC_TH_RECIPES', 'Recipes')
      })
      for (let i = 1; i <= 4; i++) {
        for (let j = 0; j < profs[i].length; j++) {
          tr = TWDS.createEle('tr', { last: tab })
          TWDS.createEle('th', {
            last: tr,
            textContent: j === 0 ? Game.InfoHandler.getLocalString4ProfessionId(i) : ''
          })
          TWDS.createEle('td', {
            last: tr,
            textContent: j + 1
          })
          TWDS.createEle('td', {
            last: tr,
            children: [
              {
                nodeName: 'a.charlink',
                href: 'javascript:void(PlayerProfileWindow.open(' + profs[i][j].player_id + '))',
                textContent: profs[i][j].name
              }
            ]
          })
          TWDS.createEle('td', {
            last: tr,
            textContent: profs[i][j].profession_skill
          })
          TWDS.createEle('td', {
            last: tr,
            textContent: profs[i][j].learnt_recipes
          })
        }
      }
    }
    state.textContent = 'found ' + playersfound + '/' + playerscount + ' players'
    const doone = function (pg) {
      Ajax.remoteCallMode('ranking', 'get_data', {
        page: pg,
        tab: 'craft'
      }, function (rankdata) {
        state.textContent = 'found ' + playersfound + '/' + playerscount + ' players on ' + rankdata.page + '/' + rankdata.pages + ' pages (' + profsdone + '/4 professions done)'
        for (let i = 0; i < rankdata.ranking.length; i++) {
          const d = rankdata.ranking[i]
          if (d.player_id in allresidents) {
            playersfound++
            const pid = d.profession_id
            if (profs[pid].length < limit) {
              profs[pid].push(d)
              if (profs[pid].length === limit) {
                profsdone++
              }
            }
          }
        }
        if (profsdone === 4) {
          finish()
          return
        }
        if (playersfound === playerscount) {
          finish()
          return
        }
        if (pg < rankdata.pages) {
          let to = 250
          if (pg % 10 === 0) { to += 1500 }
          if (pg % 30 === 0) { to += 5500 }
          setTimeout(function () {
            doone(pg + 1)
          }, to)
          return
        }
        finish()
      })
    }
    doone(1)
  })
}

TWDS.townwindow.residentsfillcontent = function () {
  const dosort = function () {
    let by = 'rank'
    if (this.classList.contains('name_foreign')) { by = 'name_foreign' }
    if (this.classList.contains('name')) { by = 'name' }

    const t = this.closest('.fancytable')
    let dir
    if (t.dataset.sortedby === by) {
      dir = parseInt(t.dataset.sortdir || 1) * -1
    } else {
      dir = 1
    }
    t.dataset.sortdir = dir
    t.dataset.sortedby = by
    if (!t) return
    const b = TWDS.q1('.tbody', t)
    if (!b) return
    const cp = TWDS.q1('.tw2gui_scrollpane_clipper_contentpane', b)
    if (!cp) return
    const tmp = TWDS.q('.row', cp)

    const rows = []
    for (let i = 0; i < tmp.length; i++) rows.push(tmp[i])
    rows.sort(function (a, b) {
      const av = TWDS.q1('.' + by, a).textContent
      const bv = TWDS.q1('.' + by, b).textContent
      if (by === 'rank') {
        return dir * (parseInt(bv) - parseInt(av))
      }
      return dir * (av.toLocaleLowerCase().localeCompare(bv.toLocaleLowerCase()))
    })
    cp.innerHTML = ''
    for (let i = 0; i < rows.length; i++) { cp.appendChild(rows[i]) }
  }
  CityhallWindow.Residents.TWDS_backup_fillContent.apply(this, arguments)

  if (!this.table.divMain) return

  const main = this.table.divMain[0]
  main.sortedby = 'rank'
  const thead = TWDS.q1('.trows .thead', main)

  const nf = TWDS.q1('.name_foreign, .name', thead)
  nf.classList.add('linklike')
  nf.onclick = dosort

  const lv = TWDS.q1('.rank', thead)
  lv.classList.add('linklike')
  lv.onclick = dosort
}
TWDS.townwindow.residentsinit = function () {
  CityhallWindow.Residents.TWDS_backup_init.apply(this, arguments)
  if (!TWDS.settings.townwindow_crafters) {
    return
  }
  const chr = TWDS.q1('.cityhall-residents', this.window.divMain[0])
  TWDS.createEle({
    nodeName: 'button.TWDS_button',
    last: chr,
    textContent: 'show ranking crafters',
    dataset: { townId: this.main.townId },
    onclick: TWDS.townwindow.showrankingcrafters
  })
}

TWDS.townwindow.startfunc = function () {
  TWDS.registerSetting('bool', 'townwindow_alliance',
    TWDS._('TOWNWINDOW_SETTING_ALLIANCE', 'Mostrar el nombre de la alianza en la ventana de la ciudad.'),
    true, null, 'Miscelánea')
  TownWindow.TWDS_backup_init = TownWindow.TWDS_backup_init || TownWindow.init
  TownWindow.init = TWDS.townwindow.init

  TWDS.registerSetting('bool', 'townwindow_crafters',
    TWDS._('TOWNWINDOW_SETTING_SHOW_RANKING_CRAFTERS', 'Mostrar los artesanos clasificados en la ventana de residentes.'),
    true, null, 'Miscelánea')
  CityhallWindow.Residents.TWDS_backup_init = CityhallWindow.Residents.TWDS_backup_init ||
    CityhallWindow.Residents.init
  CityhallWindow.Residents.init = TWDS.townwindow.residentsinit

  CityhallWindow.Residents.TWDS_backup_fillContent = CityhallWindow.Residents.TWDS_backup_fillContent ||
    CityhallWindow.Residents.fillContent
  CityhallWindow.Residents.fillContent = TWDS.townwindow.residentsfillcontent
}
TWDS.registerStartFunc(function () {
  TWDS.townwindow.startfunc()
})

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.profilewindow = {}
TWDS.profilewindow.showbonus = function (worn, level) {
  const bo = TWDS.bonuscalc.getComboBonus(worn, true, level)
  const firsttable = TWDS.createEle('table.TWDS_pwin_bonus1')
  const thead = TWDS.createEle('thead', { last: firsttable })
  TWDS.createEle('tr', {
    last: thead,
    children: [
      {
        nodeName: 'th',
        colSpan: 12,
        textContent: 'Bonusfrom items and sets'
      }
    ]
  })
  const tbody = TWDS.createEle('tbody', { last: firsttable })
  const oneattrskill = function (pa, prefix, k, v) {
    const td = TWDS.createEle('td', { last: pa })
    if (v) {
      TWDS.createEle('span.xx', {
        last: td,
        children: [
          {
            nodeName: 'img.attricon',
            src: '/images/window/skills/' + prefix + '_' + k + '.png'
          },
          {
            nodeName: 'span.yy',
            textContent: v
          }
        ]
      })
    }
    return td
  }
  for (const attr of CharacterSkills.allAttrKeys) {
    const tr = TWDS.createEle('tr', { last: tbody })
    oneattrskill(tr, 'circle', attr, bo[attr])
    delete bo[attr]
    for (const skill of CharacterSkills.skillKeys4Attr[attr]) {
      oneattrskill(tr, 'skillicon', skill, bo[skill])
      delete bo[skill]
    }
  }
  const line = function (pa, value, text) {
    if (!value) return
    const tr = TWDS.createEle('tr', {
      last: pa
    })
    TWDS.createEle('td', { last: tr, textContent: text })
    TWDS.createEle('td', { last: tr, textContent: value })
  }

  const secondtable = TWDS.createEle('table.TWDS_pwin_bonus2')
  const a = []
  if (bo.luck) a.push([bo.luck * 100, true, TWDS._('BONUS_LUCK', 'Luck')])
  if (bo.dollar) a.push([bo.dollar * 100, true, TWDS._('BONUS_DOLLAR', 'Money')])
  if (bo.regen) a.push([bo.regen * 100, true, TWDS._('BONUS_REGEN', 'Regeneration')])
  if (bo.pray) a.push([bo.pray * 100, false, TWDS._('BONUS_PRAY', 'Praying')])
  if (bo.experience) a.push([bo.experience * 100, true, TWDS._('BONUS_EXPERIENCE', 'Experience')])
  if (bo.drop) a.push([bo.drop * 100, true, TWDS._('BONUS_DROP', 'Product drop chance')])
  delete bo.luck
  delete bo.dollar
  delete bo.regen
  delete bo.experience
  delete bo.drop
  delete bo.pray
  a.sort(function (x, y) {
    return y[0] - x[0]
  })
  for (let i = 0; i < a.length; i++) {
    const one = a[i]
    line(secondtable, (one[0] + 0.0).toFixed(0) + (one[1] ? '%' : ''), one[2])
  }
  if (bo.job) {
    line(secondtable, bo.job, TWDS._('BONUS_JOB', 'Job points (all jobs)'))
  }
  for (const k of Object.keys(bo)) {
    if (k.startsWith('job_')) {
      console.log('MISHANDLED', k, bo[k])
      line(secondtable, bo[k], TWDS._('BONUS_JOB_XXX', 'Job points ' + k))
      delete bo[k]
    }
  }
  delete bo.job

  const thirdtable = TWDS.createEle('table.TWDS_pwin_bonus3')
  line(thirdtable, bo.fort_offense, 'fort battle offense')
  line(thirdtable, bo.fort_defense, 'fort battle defense')
  line(thirdtable, bo.fort_resistance, 'fort battle resistance')
  line(thirdtable, bo.fort_offense_sector, 'offense sector bonus')
  line(thirdtable, bo.fort_defense_sector, 'defense sector bonus')
  line(thirdtable, bo.fort_damage_sector, 'damage sector bonus')
  delete bo.fort_damage_sector
  delete bo.fort_offense_sector
  delete bo.fort_offense
  delete bo.fort_defense_sector
  delete bo.fort_defense
  delete bo.fort_resistance

  delete bo.speed
  delete bo.damage // whatever that is.
  if (Object.keys(bo).length) { console.log('bonus remaining', JSON.parse(JSON.stringify(bo))) }

  for (const k of Object.keys(bo)) {
    line(thirdtable, bo[k], k)
  }
  return [firsttable, secondtable, thirdtable]
}
TWDS.profilewindow.setWear = function (eq, ch) {
  PlayerProfileMain.TWDS_backup_setWear.apply(this, arguments)
  const a = []
  for (let i = 0; i < Wear.slots.length; i++) {
    const sl = Wear.slots[i]
    if (eq[sl]) {
      a.push(eq[sl])
    }
  }

  const av = TWDS.q1('.profileavatar', this.window[0])
  if (av) {
    TWDS.createEle('div.TWDS_profilewindow_show_bonus_button.tw2gui-iconset.tw2gui-icon-shirt', {
      last: av,
      // title: tab.outerHTML,
      title: TWDS._('PROFILEWINDOW_KLICK4BONUS', 'Click to display equipment bonus'),
      dataset: {
        // popup: tab.outerHTML,
        worn: JSON.stringify(a),
        level: ch.level
      },
      onclick: function () {
        const pm = this.closest('.playerprofile-main')
        const old = TWDS.q1('.TWDS_pp_hack', pm)
        if (old) {
          old.remove()
          return
        }
        const worn = JSON.parse(this.dataset.worn)
        const level = parseInt(this.dataset.level)
        TWDS.createEle({
          nodeName: 'div.TWDS_pp_hack',
          children: TWDS.profilewindow.showbonus(worn, level),
          last: pm
        })
      }
    })
  }
}

TWDS.profilewindow.init = function (data, t) {
  PlayerProfileMain.TWDS_backup_init.apply(this, arguments)
  const pid = this.playerid
  const name = this.resp.playername
  const that = this

  if (TWDS.settings.profilewindow_craftpoints && 1) {
    Ajax.remoteCallMode('ranking', 'get_data', {
      rank: 'NaN',
      search: name,
      tab: 'craft'
    }, function (rdata) {
      if (rdata.error) return
      for (let i = 0; i < rdata.ranking.length; i++) {
        const e = rdata.ranking[i]
        if (e.player_id === pid) {
          const pp = TWDS.q1('.pp-prof', that.window[0])
          if (pp) {
            TWDS.createEle({
              nodeName: 'div.TWDS_craftpoints',
              textContent: e.profession_skill,
              last: pp
            })
            pp.title = pp.title + ' ' + e.profession_skill
          }
        }
      }
    })
  }
}

TWDS.profilewindow.startfunc = function () {
  TWDS.registerSetting('bool', 'profilewindow_craftpoints',
    TWDS._('PROFILEWINDOW_SETTING_CRAFTPOINTS', 'Mostrar el nivel de elaboración en la ventana del perfil.'),
    true, null, 'Miscelánea')
  PlayerProfileMain.TWDS_backup_init = PlayerProfileMain.TWDS_backup_init || PlayerProfileMain.init
  PlayerProfileMain.init = TWDS.profilewindow.init
  TWDS.registerSetting('bool', 'profilewindow_wearbonus',
    TWDS._('PROFILEWINDOW_SETTING_CRAFTPOINTS', 'Mostrar el bonus del equipo en la ventana del perfil.'),
    true, null, 'Miscelánea')
  console.log('PWIN start', PlayerProfileMain.setWear)
  PlayerProfileMain.TWDS_backup_setWear = PlayerProfileMain.TWDS_backup_setWear || PlayerProfileMain.setWear
  PlayerProfileMain.setWear = TWDS.profilewindow.setWear
}
TWDS.registerStartFunc(function () {
  TWDS.profilewindow.startfunc()
})

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.buildwindow = {}
TWDS.buildwindow.buttonthing = function (elder) {
  TWDS.createEle({
    nodeName: 'button.TWDS_buildwindow_start',
    last: elder,
    title: TWDS._('BUILDWINDOW_CLOTH_TITLE', 'Change clothes'),
    children: [
      { nodeName: 'img', src: '/images/items/yield/item_52967.png', alt: 'construction' },
      { nodeName: 'img', src: '/images/items/yield/dynamite.png', alt: 'construction' }
    ],
    onclick: function () {
      const items = TWDS.genCalc({ job_1000: 1, joball: 1 }, { build: 3, repair: 1, leadership: 1, joball: 1, job_1000: 1 })
      if (items) { TWDS.wearItemsHandler(items) }
    }
  })
}
TWDS.buildwindow.init = function () {
  window.BuildWindow.TWDS_backup_init.apply(this, arguments)
  if (!TWDS.settings.misc_buildwindow) { return }

  // the original function did format town money, but not player money. Yeah.
  this.cbPaymentChanged = function (payer) {
    if (this.window.$('#build_cdPayment').data('value') === 'player') {
      this.window.$('div.row_build_dollar > span.rp_jobdata_text').text(
        '$' + window.format_money(Character.getCapital(true)))
    } else { this.window.$('div.row_build_dollar > span.rp_jobdata_text').text('$' + this.deposit) }
  }

  const drops = TWDS.q1('.build_drops', this.window.divMain)
  if (drops) { // wenn nicht vorhanden, dann eben nicht.
    TWDS.buildwindow.buttonthing(drops)
  }

  // fix <small> in the way time.
  const bw = TWDS.q1('.build_way', this.window.divMain)
  if (bw && bw.textContent.includes('<small>')) {
    bw.innerHTML = bw.textContent // what the fuck?
  }
  const bh = TWDS.q1('.build_head', this.window.divMain)
  if (bh.textContent.includes('beichten')) {
    bh.innerHTML = '<span>' + bh.textContent + '<br>' +
      "<span class='tw_red'>Echt jetzt? Beim Arbeiten?</span></span>"
  }
}
TWDS.buildwindow.fairopen = function () {
  west.wof.FairSiteWindow.TWDS_backup_open.apply(this, arguments)
  if (!TWDS.settings.misc_buildwindow_wof) { return }
  const wnd = west.wof.FairSiteWindow.window_.divMain
  const cp = TWDS.q1('.tw2gui_window_content_pane', wnd)
  if (cp) {
    TWDS.buildwindow.buttonthing(cp)
  }
}

TWDS.buildwindow.startfunc = function () {
  window.BuildWindow.TWDS_backup_init = window.BuildWindow.TWDS_backup_init ||
    window.BuildWindow.init
  window.BuildWindow.init = TWDS.buildwindow.init
  west.wof.FairSiteWindow.TWDS_backup_open = west.wof.FairSiteWindow.TWDS_backup_open || west.wof.FairSiteWindow.open
  west.wof.FairSiteWindow.open = TWDS.buildwindow.fairopen
  TWDS.registerSetting('bool', 'misc_buildwindow',
    TWDS._('BUILDWINDOW_SETTING', 'Agregar botón de ropa en la ventana de construcción.'),
    false, null, 'Miscelánea')
  TWDS.registerSetting('bool', 'misc_buildwindow_wof',
    TWDS._('BUILDWINDOW_SETTING_WOF', 'Agregar botón de ropa en la ventana de construcción de la feria.'),
    true, null, 'Miscelánea')
}

TWDS.registerStartFunc(function () {
  TWDS.buildwindow.startfunc()
})
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.shopsearch = {}

TWDS.shopsearch.gettowns = async function () {
  return new Promise(function (resolve, reject) {
    const now = (new Date().getTime()) / 1000
    const timestamp = parseInt(localStorage.TWDS_shopsearch_tc_ts || 0)

    if (timestamp > now - 86400) {
      resolve()
      return
    }

    Ajax.get('map', 'get_minimap', {}, function (resp) {
      if (resp.error) { reject(new Error(resp.msg)); return new UserMessage(resp.msg).show() }
      const towns = resp.towns
      const out = {}
      for (const town of Object.values(towns)) {
        const id = town.town_id
        if (!town.member_count) continue
        out[id] = {
          id: id,
          x: town.x,
          y: town.y,
          name: town.name,
          points: town.town_points,
          alliance_id: town.alliance_id
        }
      }
      localStorage.TWDS_shopsearch_tc_ts = now
      localStorage.TWDS_shopsearch_tc = JSON.stringify(out)
      resolve()
    })
  })
}

// works almost like the name implies... but starts at hometown/old hamburg for better caching
TWDS.shopsearch.townsbydistance = function (towndata) {
  const pos = {
    x: 44056,
    y: 17479
  }
  if (Character.homeTown.town_id) {
    pos.x = Character.homeTown.x
    pos.y = Character.homeTown.y
  }

  const a = []
  for (const town of Object.values(towndata)) {
    if (town.id === Character.town_id) {
      continue
    }
    a.push({
      id: town.id,
      wt: Map.calcWayTime(pos, town)
    })
  }
  a.sort(function (a, b) {
    return a.wt - b.wt
  })
  return a
}
/*
 * logic:
 * localStorage.TWDS_shopsearch_tsc = {
 *  townid: {
 *    tailor: {ts: timestamp, level:level, items:[]},
 *    gunsmith, general
 *  },
 * }
 */

TWDS.shopsearch.gettownshopdata = async function (townid, shoptype) {
  return new Promise(function (resolve, reject) {
    Ajax.remoteCallMode('building_' + shoptype + '&town_id=' + townid, '', {}, function (json) {
      const out = {
        level: json.level,
        items: [],
        ts: (new Date().getTime()) / 1000
      }
      if (json.error) { // town has no such shop
        resolve(out)
        return
      }
      out.level = json.level

      for (let i = 0; i < json.trader_inv.length; i++) {
        const io = json.trader_inv[i]
        if (io && io.item_id) {
          out.items.push(parseInt(io.item_id / 1000)) // base item ids. storage is cheap, but not that cheap.
        }
      }
      resolve(out)
    })
  })
}

TWDS.shopsearch.searchtownforitem = async function (townid, shoptype, baseitemid, maxlevels) {
  const oldmaxlevels = {
    tailor: 15,
    general: 15,
    gunsmith: 20
  }
  const cached = JSON.parse(localStorage.TWDS_shopsearch_tsc || '{}')
  const now = (new Date().getTime()) / 1000
  if (!(townid in cached)) {
    cached[townid] = {}
  }
  const tc = cached[townid]
  if (shoptype in tc) {
    const sc = tc[shoptype]

    let valid = (1 + sc.level * 5) * 3600 // level1: 6h, 15:81h (3d)
    if (sc.level === oldmaxlevels[shoptype]) {
      valid = 90 * 86400
    }
    if (sc.level === maxlevels[shoptype]) {
      valid = 365 * 86400
    }
    if (sc.ts < now - valid) {
      delete tc[shoptype]
    }
  }
  if (!(shoptype in tc)) {
    const data = await TWDS.shopsearch.gettownshopdata(townid, shoptype)
    tc[shoptype] = data
    localStorage.TWDS_shopsearch_tsc = JSON.stringify(cached)
  }
  const items = tc[shoptype].items
  for (let i = 0; i < items.length; i++) {
    const bii = items[i]
    if (bii === baseitemid) {
      return true
    }
  }
  return false
}

TWDS.shopsearch.searchforitem = async function (itemid, mode, allianceonly, townssearched) {
  mode = mode || 1
  const itemtypes2shops = {
    animal: 'general',
    belt: 'general',
    neck: 'general',
    body: 'tailor',
    foot: 'tailor',
    head: 'tailor',
    pants: 'tailor',
    left_arm: 'gunsmith',
    right_arm: 'gunsmith'
  }

  const it = ItemManager.get(itemid)
  if (!it) {
    // ECANTHAPPEN
    return
  }
  if (!(it.type in itemtypes2shops)) {
    // ECANTHAPPEN
    return
  }
  const shoptype = itemtypes2shops[it.type]
  await TWDS.shopsearch.gettowns()

  const towndata = JSON.parse(localStorage.TWDS_shopsearch_tc || {})

  const wts = TWDS.shopsearch.townsbydistance(towndata)

  console.log('sorted', wts)
  let maxlevels = {
    tailor: 25,
    gunsmith: 30,
    general: 25
  }

  const baseitemid = ItemManager.itemIdToBaseItemId(itemid)
  const out = []
  let nearest = -1
  for (let i = 0; i < wts.length; i++) {
    const townid = wts[i].id
    if (i === 0) {
      maxlevels = await TWDS.shopsearch.gettownshopmaxlevels(townid)
    }
    if (nearest !== -1) {
      if (wts[i].wt > nearest * 1.25 && out.length >= 5) {
        console.log('break at wt', wts[i].wt, nearest)
        break
      }
    }
    if (townssearched.length && !townssearched.includes(townid)) { continue }
    const found = await TWDS.shopsearch.searchtownforitem(townid, shoptype, baseitemid, maxlevels)
    // console.log('CHECKED', i, wts[i].wt, townid, 'found?', found)
    if (found) {
      out.push(wts[i].id)
      console.log('found it in', wts[i].id, 'with', wts[i].wt)
      if (mode === 1) { break }
      if (nearest === -1) {
        // homeTown is not a good benchmark, since it is sorted first by default
        if (i !== 0 || townid !== Character.homeTown.town_id) {
          nearest = wts[i].wt
          console.log('BENCHMARK!')
        }
      }
    }
  }
  return out
}
TWDS.shopsearch.gettownshopmaxlevels = async function (townid) {
  return await new Promise(function (resolve, reject) {
    Ajax.remoteCallMode('town', 'get_town', { town_id: townid }, function (json) {
      if (json.error) {
        reject(json.error[1])
        return
      }
      const ab = json.allBuildings
      const out = { }
      out.tailor = ab.tailor.maxStage
      out.gunsmith = ab.gunsmith.maxStage
      out.general = ab.general.maxStage
      resolve(out)
    })
  })
}

TWDS.shopsearch.factor = 1.33
TWDS.shopsearch.calccoords = function (x, y) {
  if (typeof x === 'object') {
    y = x.y
    x = x.x
  }
  return {
    x: x * window.WORLDMAP_COEFF_500 * TWDS.shopsearch.factor,
    y: y * window.WORLDMAP_COEFF_500 * TWDS.shopsearch.factor
  }
}

TWDS.shopsearch.drawicon = function (map, cladd, title, src, x, y) {
  const xy = TWDS.shopsearch.calccoords(x, y)
  return TWDS.createEle({
    nodeName: 'img',
    className: cladd,
    title: title,
    last: map,
    src: src,
    style: {
      cursor: 'pointer',
      position: 'absolute',
      width: '16px',
      height: 'auto',
      filter: 'drop-shadow(2px 2px 2px #222)',
      left: xy.x + 'px',
      top: xy.y + 'px'
    }
  })
}

TWDS.shopsearch.drawme = function (map) {
  TWDS.shopsearch.drawicon(map, 'me', 'you',
    '/images/map/minimap/icons/miniicon_pos.png',
    Character.getPosition())
}

TWDS.shopsearch.walkhelper = function () {
  const townid = this.dataset.townid
  if (!townid) return

  const towndata = JSON.parse(localStorage.TWDS_shopsearch_tc || {})
  const town = towndata[townid]
  if (!town) {
    return new UserMessage('Strange: town #' + townid + ' not found')
  }
  window.Guidepost.show(townid, town.x, town.y, 'town')
}

TWDS.shopsearch.updateresult = function (infoarea, table, map, item) {
  const wnd = wman.getById('TWDS_shopsearch_window')
  const iao = TWDS.q1('input.allianceonly', wnd.divMain)
  let allianceonly = 0
  if (iao && iao.checked) { allianceonly = 1 }

  if (allianceonly && Character.homeTown && Character.homeTown.alliance_id > 0) {
    Ajax.remoteCallMode('alliance', 'get_data', {
      alliance_id: Character.homeTown.alliance_id
    }, function (resp) {
      if (resp.error) {
        return new UserMessage(resp.msg).show()
      }
      const l = []
      for (let i = 0; i < resp.data.towns.length; i++) {
        const t = resp.data.towns[i]
        l.push(t.town_id)
      }
      return TWDS.shopsearch.updateresult2(infoarea, table, map, item, l)
    })
  } else {
    return TWDS.shopsearch.updateresult2(infoarea, table, map, item, [])
  }
}
TWDS.shopsearch.updateresult2 = function (infoarea, table, map, item, towns) {
  const wnd = wman.getById('TWDS_shopsearch_window')
  if (wnd) wnd.showLoader();

  (async function (itemid, wnd, infoarea, towns) {
    // the search starts around the hometown or old hamburg, to improve caching.
    const item = ItemManager.get(itemid)
    if (!item) {
      infoarea.textContent = 'item #' + itemid + ' not found in the ItemManager. This should not happen.'
      if (wnd) wnd.hideLoader()
      return
    }
    let mode = 1
    const allianceonly = 0
    const mele = TWDS.q1('input.multipleresults', wnd.divMain)
    if (mele && mele.checked) { mode = 2 }

    const townids = await TWDS.shopsearch.searchforitem(itemid, mode, allianceonly, towns)
    if (townids.length === 0) {
      infoarea.textContent = TWDS._('STORESEARCH_ITEM_NOT_IN_SHOPS', '$itemname$ not found in any town', { itemname: item.name })
      if (wnd) wnd.hideLoader()
      return
    }
    const towndata = JSON.parse(localStorage.TWDS_shopsearch_tc || {})
    const popup = new ItemPopup(item).popup.text

    for (let idx = 0; idx < townids.length; idx++) {
      const townid = townids[idx]
      if (!(townid in towndata)) {
        console.log('town not found: ', townid) // ECANTHAPPEN
        continue
      }

      const town = towndata[townid]
      let ic = TWDS.q1('.TWDS_shopsearch_content img.town' + townid)
      if (!ic) {
        let src = '/images/map/minimap/icons/miniicon_foreign_towns.png'
        let cladd = 'foreigntown'
        if (townid === Character.homeTown.town_id) {
          src = '/images/map/minimap/icons/miniicon_own_town.png'
          cladd = 'owntown'
        }

        ic = TWDS.shopsearch.drawicon(map, cladd + ' town' + townid, town.name, src, town.x, town.y)
        ic.dataset.townid = townid
        ic.classList.add('linklike')
        ic.title = ic.title + ': ' + item.name
        ic.onclick = function () {
          TownWindow.open(town.x, town.y)
        }
        // console.log('drew new icon', townid, item.name)
      } else {
        if (ic._mpopup) {
          ic._mpopup.text += ', ' + item.name
          // console.log('added to mpopup', townid, item.name, ic)
        } else {
          ic.title = ic.title + ', ' + item.name
          // console.log('added to title', townid, item.name, ic)
        }
      }
      let tr = TWDS.q1('tr.town' + townid, table)
      if (!tr) {
        if (table.children.length === 0) {
          TWDS.createEle({
            nodeName: 'tr.head',
            last: table,
            children: [
              { nodeName: 'th.name', textContent: TWDS._('STORESEARCH_TH_TOWN', 'town') },
              { nodeName: 'th.wt', textContent: TWDS._('STORESEARCH_TH_WAYTIME', 'waytime') },
              { nodeName: 'th.items', textContent: TWDS._('STORESEARCH_TH_ITEMS', 'items') }
            ]
          })
        }
        const wt = Map.calcWayTime(Character.position, town)
        tr = TWDS.createEle({
          nodeName: 'tr',
          className: 'town' + townid,
          last: table,
          children: [
            {
              nodeName: 'th.name.linklike',
              dataset: { townid: townid },
              textContent: town.name,
              onclick: function () {
                TownWindow.open(town.x, town.y)
              }
            },
            { nodeName: 'td.wt.linklike', dataset: { townid: townid, wt: wt }, innerHTML: wt.formatDuration(), onclick: TWDS.shopsearch.walkhelper },
            { nodeName: 'td.items', textContent: '' }
          ]
        })
        const complication = [] // element.children is something like an array, but not an actual array.
        for (let i = 0; i < table.children.length; i++) { complication.push(table.children[i]) }
        complication.sort(function (a, b) {
          if (a.classList.contains('head')) return -1
          if (b.classList.contains('head')) return +1

          a = parseFloat(TWDS.q1('.wt', a).textContent)
          b = parseFloat(TWDS.q1('.wt', b))
          return a - b
        })
        table.textContent = ''
        for (let i = 0; i < complication.length; i++) {
          table.appendChild(complication[i])
        }
      }
      const td = TWDS.q1('td.items', tr)
      const found = TWDS.q1('.item' + itemid, td)
      if (!found) {
        if (td.textContent !== '') {
          TWDS.createEle('span', { textContent: ', ', last: td })
        }
        TWDS.createEle('span.item.item' + itemid, {
          textContent: item.name,
          title: popup,
          last: td
        })
      }
    }
    const cc = TWDS.q1('button.clearcache', wnd.divMain)
    if (cc) {
      TWDS.shopsearch.cacheclearbuttontitle(cc)
    }
    if (wnd) wnd.hideLoader()
  })(item.item_id, wnd, infoarea, towns)
}
TWDS.shopsearch.cacheclearbuttontitle = function (ele) {
  let bytes = 0
  if (localStorage.TWDS_shopsearch_tsc) bytes += localStorage.TWDS_shopsearch_tsc.length
  if (localStorage.TWDS_shopsearch_tc) bytes += localStorage.TWDS_shopsearch_tc.length
  ele.title = TWDS._('STORESEARCH_CLEARCACHE_TITLE', 'Clear the cache ($b$ bytes)', { b: bytes })
}
TWDS.shopsearch.dosearch = function (inputarea, infoarea, table, search, map) {
  infoarea.textContent = ''
  const sel = TWDS.q1('select.specific', inputarea)
  sel.value = 0
  sel.disabled = true
  if (parseInt(search) > 0) {
    search = parseInt(search)
    if (search % 1000 <= 5) { search = parseInt(search / 1000) }
    const item = ItemManager.getByBaseId(search)

    if (!item) {
      infoarea.textContent = TWDS._('STORESEARCH_ID_NOT_FOUND', 'Item with base id #$bid$ not found', { bid: search })
      return
    }
    TWDS.shopsearch.updateresult(infoarea, table, map, item)
    return
  }

  // text search. don't we love it?
  const all = ItemManager.getAll()
  const lsearch = search.toLocaleLowerCase()
  const found = []
  for (const item of Object.values(all)) {
    const name = item.name
    const lname = name.toLocaleLowerCase()
    if (item.tradeable && item.traderlevel < 66 && item.item_id !== 0) {
      if (lname.includes(lsearch)) {
        found.push(item)
      }
    }
  }
  if (found.length === 1) {
    TWDS.shopsearch.updateresult(infoarea, table, map, found[0])
    return
  }
  if (!found.length) {
    infoarea.textContent = TWDS._('STORESEARCH_NAME_NOT_FOUND', 'Item with name $search$ not found', {
      search: search
    })
    return
  }
  if (found.length >= 50) {
    infoarea.textContent = TWDS._('STORESEARCH_TOO_MANY', 'Too many items match $search$. Please try a more specific search.', {
      search: search
    })
    return
  }
  // 2..50 elements in found
  found.sort(function (a, b) {
    return a.name.localeCompare(b.name)
  })

  sel.disabled = false
  sel.textContent = ''
  TWDS.createEle('option', {
    last: sel,
    value: 0,
    textContent: TWDS._('PLEASE_SELECT', 'please select')
  })
  for (let i = 0; i < found.length; i++) {
    TWDS.createEle({
      nodeName: 'option',
      value: found[i].item_id,
      textContent: found[i].name,
      last: sel
    })
  }
}

TWDS.shopsearch.getcontent = function (win) {
  const content = TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_shopsearch_content'
  })
  const inputarea = TWDS.createEle({
    nodeName: 'div',
    className: 'inputarea',
    last: content
  })
  const input = TWDS.createEle({
    nodeName: 'input.search',
    type: 'text',
    onchange: function () {
      TWDS.shopsearch.dosearch(inputarea, infoarea, table, this.value, map)
    },
    style: {
      display: 'inline-block'
    },
    placeholder: TWDS._('STORESEARCH_ITEM', 'Item name or #'),
    title: TWDS._('STORESEARCH_ITEM_TITLE', 'Name or Id of the item you are looking for'),
    last: inputarea,
    value: win._TWDS_search ? win._TWDS_search : ''
  })
  TWDS.createEle({
    nodeName: 'select.specific',
    onchange: function () {
      const v = parseInt(this.value)
      if (!v) return
      const item = ItemManager.get(v)
      if (item) { TWDS.shopsearch.updateresult(infoarea, table, map, item) }
    },
    style: {
      display: 'inline-block'
    },
    title: TWDS._('STORESEARCH_SELECT_TITLE', 'Select the name of the item you are looking for'),
    last: inputarea,
    value: win._TWDS_search ? win._TWDS_search : ''
  })
  TWDS.createEle('label', {
    title: TWDS._('STORESEARCH_MULTI_MODE_TITLE', 'Return multiple results, not just one shop.'),
    last: inputarea,
    children: [{
      nodeName: 'input.multipleresults',
      type: 'checkbox',
      checked: false,
      value: 0
    }, {
      nodeName: 'span',
      textContent: TWDS._('STORESEARCH_MULTI_MODE', 'Multiple')
    }]
  })
  TWDS.createEle('label', {
    title: TWDS._('STORESEARCH_ALLIANCE_MODE_TITLE', 'Search in your alliance only'),
    last: inputarea,
    children: [{
      nodeName: 'input.allianceonly',
      type: 'checkbox',
      checked: false,
      value: 0
    }, {
      nodeName: 'span',
      textContent: TWDS._('STORESEARCH_ALLIANCE_MODE', 'Alliance')
    }]
  })

  TWDS.createEle({
    nodeName: 'button.clearmap',
    textContent: TWDS._('STORESEARCH_CLEARMAP', 'clear'),
    title: TWDS._('STORESEARCH_CLEARMAP_TITLE', 'Clear the map and result list'),
    onclick: function () {
      table.textContent = ''
      const images = TWDS.q('img.foreigntown', map)
      for (let i = 0; i < images.length; i++) { images[i].remove() }
    },
    style: {
      display: 'inline-block'
    },
    last: inputarea
  })
  let bytes = 0
  if (localStorage.TWDS_shopsearch_tsc) bytes += localStorage.TWDS_shopsearch_tsc.length
  if (localStorage.TWDS_shopsearch_tc) bytes += localStorage.TWDS_shopsearch_tc.length
  const ccb = TWDS.createEle({
    nodeName: 'button.clearcache',
    textContent: TWDS._('STORESEARCH_CLEARCACHE', 'clear cache'),
    title: TWDS._('STORESEARCH_CLEARCACHE_TITLE', 'Clear the cache ($b$ bytes). Searching will take longer after that.', { b: bytes }),
    onclick: function () {
      delete localStorage.TWDS_shopsearch_tsc
      delete localStorage.TWDS_shopsearch_tc
      delete localStorage.TWDS_shopsearch_tc_ts
      TWDS.shopsearch.cacheclearbuttontitle(this)
    },
    style: {
      display: 'inline-block'
    },
    last: inputarea
  })
  TWDS.shopsearch.cacheclearbuttontitle(ccb)

  const infoarea = TWDS.createEle({
    nodeName: 'div',
    className: 'infoarea',
    last: content
  })
  const factor = 1.33
  const map = TWDS.createEle('div.map', {
    last: content,
    style: {
      width: Math.round(500 * factor) + 'px',
      height: Math.round(220 * factor) + 'px',
      background: 'url(/images/map/minimap/worldmap_500.jpg) no-repeat',
      backgroundSize: 'contain',
      position: 'relative'
    }
  })
  const table = TWDS.createEle({
    nodeName: 'table',
    last: content
  })
  TWDS.shopsearch.drawme(map)
  if (win._TWDS_search) {
    input.onchange()
  }
  return content
}

TWDS.shopsearch.openwindow = function (search) {
  const wid = 'TWDS_shopsearch_window'
  let win
  let searched = false
  if (wman.isWindowCreated(wid)) {
    win = wman.getById(wid)
    if (wman.isMinimized(wid)) {
      wman.reopen(wid, 'shopsearch')
    }
    win._TWDS_search = search || null
  } else {
    win = wman.open(wid, 'shopsearch')
    win.setTitle(TWDS._('STORESEARCH_WINDOW_TITLE', 'Storesearch'))
    win._TWDS_search = search || null

    const sp = new west.gui.Scrollpane()
    const content = TWDS.shopsearch.getcontent(win)
    sp.appendContent(content)
    win.appendToContentPane(sp.getMainDiv())
    searched = true
  }
  if (search) {
    const input = TWDS.q1('.TWDS_shopsearch_window input', win.divMain)
    if (input) {
      input.value = search
      if (!searched) {
        input.onchange()
      }
    }
  }
}
TWDS.shopsearch.button = function (id) {
  const it = ItemManager.get(id)
  if (!it) return null

  if (!it.tradeable) return null

  return TWDS.createElement({
    nodeName: 'span',
    className: 'TWDS_shopsearch_button',
    dataset: { item_id: id },
    title: TWDS._('SHOPSEARCHBUTTON_TITLE', 'Search in town shops'),
    childNodes: [
      new west.gui.Icon('home').divMain[0]
    ]
  })
}
TWDS.shopsearch.reload = function (win) {
  if (!win) {
    return TWDS.shopsearch.openwindow()
  }
  const content = TWDS.shopsearch.getcontent(win)
  const old = TWDS.q1('.TWDS_shopsearch_content', win.getMainDiv())
  const sp = old.parentNode
  sp.innerHTML = ''
  sp.appendChild(content)
}
TWDS.registerStartFunc(function () {
  TWDS.registerExtra('TWDS.shopsearch.openwindow',
    TWDS._('STORESEARCH_EXTRA', 'Búsqueda de tienda'),
    TWDS._('STORESEARCH_EXTRA_DESC', 'Buscar artículos en las tiendas.')
  )
  TWDS.delegate(document.body, 'click', '.TWDS_shopsearch_button', function () {
    const id = this.dataset.item_id
    TWDS.shopsearch.openwindow(id)
  })
})

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.ranking = {}
TWDS.ranking.config = [
  { key: 'Experience', fields: ['experience'], mainfield: 'experience' },
  { key: 'Duels', fields: ['experience', 'duel_win', 'duel_loss', 'difference'], mainfield: 'experience' },
  { key: 'FortBattles', fields: ['damage_dealt', 'score', 'dodges', 'hits_taken'], mainfield: 'score' },
  { key: 'Crafting', fields: ['items_created', 'learnt_recipes', 'score', 'profession_skill'] },
  { key: 'Construction', fields: ['fair_points', 'stage_ups', 'total_cp'], mainfield: 'total_cp' },
  { key: 'Adventures', fields: ['friendly_dmg', 'games_played', 'knockouts', 'total_actions', 'rage_quits'] },
  { key: 'Achievements', fields: ['achievements', 'points', 'worlds_first'], mainfield: 'points' },
  { key: 'Cities', fields: ['points', 'sum_points', 'fort_points', 'member_level_points', 'duel_diff_points', 'member_count', 'mean_level'], mainfield: 'sum_points' },
  { key: 'Skills', fields: ['skill_level'] }
]
/* just to document it: this cannot show the diff of the first player on page 2 to the last on page 1.... */
TWDS.ranking.manipulate = function (bedata, keys, mainfield) {
  if (!bedata.error && bedata.ranking) { // dodge, shoot comes without error or ranking, but with msg
    for (let j = 0; j < keys.length; j++) {
      let lastv
      for (let i = 0; i < bedata.ranking.length; i++) {
        const k = keys[j]
        const v = bedata.ranking[i][k]
        bedata.ranking[i][k] = window.format_number(v)
        if (k === mainfield && i) {
          bedata.ranking[i][k] = '<span' +
            " title='" + window.format_number(lastv - v) + "'" +
            '>' + window.format_number(v) + '</span>'
        }
        lastv = v
      }
    }
  }
}

TWDS.ranking.startfunc = function () {
  for (let i = 0; i < TWDS.ranking.config.length; i++) {
    const c = TWDS.ranking.config[i]
    if (!('TWDS_backup_updateTable' in window.RankingWindow[c.key])) {
      console.log('backing up', c.key, window.RankingWindow[c.key])
      window.RankingWindow[c.key].TWDS_backup_updateTable = window.RankingWindow[c.key].updateTable
    }
    window.RankingWindow[c.key].updateTable = function (bedata) {
      TWDS.ranking.manipulate(bedata, c.fields, c.mainfield)
      this.TWDS_backup_updateTable.apply(this, arguments)
    }
  }
}
TWDS.registerStartFunc(TWDS.ranking.startfunc)
// vim: tabstop=2 shiftwidth=2 expandtab
//
//

TWDS.quickequipment = {}
TWDS.quickequipment.eventdata = {}
TWDS.quickequipment.control = [
  { level: 0, key: 'TW', text: 'TW Equipment Sets', handler: 'handletwselect', hassubmenu: true },
  { level: 0, key: 'CC', text: 'Clothcache Equipment Sets', handler: 'handleccselect', hassubmenu: true },
  { level: 0, key: 'TC', text: 'TW Calc Equipment Sets', handler: 'handletcselect', hassubmenu: true },
  { level: 0, key: 'speed', text: 'speed set', keepcached: true },
  { level: 0, key: 'speed/health', text: 'speed set w/o health loss', nocache: true },
  { level: 0, key: 'skill/health', text: 'max health', keepcached: true },
  { level: 0, key: 'bonus/regen', text: 'best regeneration', keepcached: true },
  { level: 0, key: 'bonus', text: 'bonus equipment', hassubmenu: true },
  { level: 1, key: 'bonus/regen', text: 'regeneration', submenu: 'bonus', keepcached: true },
  { level: 1, key: 'bonus/luck+dollar', text: 'luck+money', submenu: 'bonus', keepcached: true },
  { level: 1, key: 'bonus/luck+drop', text: 'luck+drop', submenu: 'bonus', keepcached: true },
  { level: 1, key: 'bonus/luck', text: 'luck', submenu: 'bonus', keepcached: true },
  { level: 1, key: 'bonus/pray', text: 'pray', submenu: 'bonus', keepcached: true },
  { level: 1, key: 'bonus/dollar', text: 'money', submenu: 'bonus', keepcached: true },
  { level: 1, key: 'bonus/drop+dollar', text: 'drop+money', submenu: 'bonus', keepcached: true },
  { level: 1, key: 'bonus/drop', text: 'drop', submenu: 'bonus', keepcached: true },
  { level: 1, key: 'bonus/experience', text: 'experience', submenu: 'bonus', keepcached: true },
  { level: 1, key: 'bonus/experience+experience+dollar', text: 'experience*2+money', submenu: 'bonus', keepcached: true },

  { level: 0, key: 'skill', text: 'skills', hassubmenu: true },
  { level: 0, key: 'duel', text: 'duels', hassubmenu: true },
  { level: 0, key: 'battle', text: 'fort battles', hassubmenu: true },
  { level: 0, key: 'construction', text: 'construction', keepcached: true },
  { level: 0, key: 'saved', text: 'saved searches', hassubmenu: true },
  { level: 0, key: 'cacherebuild', text: 'rebuild cache' }
]
TWDS.quickequipment.fillcontrollist = function () {
  for (let i = 0; i < TWDS.quickequipment.control.length; i++) {
    if (TWDS.quickequipment.control[i].key === 'skill') {
      for (let j = 0; j < CharacterSkills.allSkillKeys.length; j++) {
        const sk = CharacterSkills.allSkillKeys[j]
        const n = CharacterSkills.keyNames[sk]
        TWDS.quickequipment.control.push({
          level: 1,
          key: 'skill/' + sk,
          text: n,
          submenu: 'skill'
        })
      }
    }
    if (TWDS.quickequipment.control[i].key === 'saved') {
      const sav = TWDS.calculator.getsavedlist()
      if (sav.length) {
        for (let j = 0; j < sav.length; j++) {
          const n = sav[j]
          TWDS.quickequipment.control.push({
            level: 1,
            key: 'saved/' + n,
            text: n,
            submenu: 'saved'
          })
        }
      }
    }
  }
  const presetlist = TWDS.calculator.presets
  for (let i = 0; i < presetlist.length; i++) {
    const pre = presetlist[i]
    if (pre.type === 'duel') {
      TWDS.quickequipment.control.push({
        level: 1,
        key: 'calculator/' + pre.name,
        text: pre.name,
        submenu: 'duel',
        keepcached: true
      })
    }
  }
  for (let i = 0; i < presetlist.length; i++) {
    const pre = presetlist[i]
    if (pre.type === 'battle') {
      TWDS.quickequipment.control.push({
        level: 1,
        key: 'calculator/' + pre.name,
        text: pre.name,
        submenu: 'battle',
        keepcached: true
      })
    }
  }
  console.log('CTRL', TWDS.quickequipment.control)
  // other variable stuff? like saved user searches?
}
TWDS.quickequipment.fillcontrollist()
TWDS.quickequipment.cache = { }
TWDS.quickequipment.used = { }

TWDS.quickequipment.calc = function (key) {
  const calcsub = function (preset) {
    const o = {}
    const p = {}
    for (const [k, v] of Object.entries(preset)) {
      if (k === 'name') continue
      if (k === 'type') continue
      if (k === 'alias') continue
      if (k in CharacterSkills.attributes ||
        k in CharacterSkills.skills) {
        o[k] = v
      } else {
        p[k] = v
      }
    }
    return TWDS.genCalc(p, o)
  }
  if (key === 'speed') {
    return TWDS.speedcalc.doit(1, 0)
  }
  if (key === 'speed/health') {
    return TWDS.speedcalc.doit(1, 1)
  }
  if (key.startsWith('skill/')) {
    const skill = key.substring(6)
    const p = {}
    p[skill] = 1
    return TWDS.genCalc({}, p)
  }
  if (key.startsWith('bonus/')) {
    const str = key.substring(6)
    const parts = str.split(/\+/)
    const p = {}
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i]
      if (!(part in p)) p[part] = 0
      p[part]++
    }
    return TWDS.genCalc(p, {})
  }
  if (key === 'construction') {
    return TWDS.genCalc({ job_1000: 1, joball: 1 }, { build: 3, repair: 1, leadership: 1, joball: 1, job_1000: 1 })
  }
  if (key.startsWith('saved/')) {
    const str = key.substring(6)
    const preset = TWDS.calculator.findsaved(str)
    if (!preset) return
    return calcsub(preset)
  }
  if (key.startsWith('calculator/')) {
    const str = key.substring(11)
    const preset = TWDS.calculator.findpreset(str)
    if (!preset) return
    return calcsub(preset)
  }
  return null
}
TWDS.quickequipment.cacheone = function (key, val) {
  TWDS.quickequipment.cache[key] = {
    value: val,
    invid: Bag.getLastInvId(),
    ts: (new Date()).getTime()
  }
}
TWDS.quickequipment.getfromcache = function (key) {
  if (!(key in TWDS.quickequipment.cache)) return null
  const e = TWDS.quickequipment.cache[key]
  if (e.invid === Bag.getLastInvId()) return e.value
  const ts = (new Date()).getTime()
  const delta = (ts - e.ts) / 1000
  if (delta > TWDS.settings.quickequipment_cachetime_minutes * 60) return null
  return e.value
}
TWDS.quickequipment.getused = function () {
  const u = {}
  for (const [k, e] of Object.entries(TWDS.quickequipment.cache)) {
    const ids = e.value
    for (let i = 0; i < ids.length; i++) {
      const id = ids[i]
      if (!(id in u)) { u[id] = [] }
      u[id].push(k)
    }
  }
  return u
}
TWDS.quickequipment.buildcache = function () {
  TWDS.quickequipment.cache = {}
  const myname = 'TWDS_qe_tmp'
  const win = wman.open(myname, TWDS._('QE_PROGRESS_TITLE', 'Progress'))
  win.setMiniTitle('Progress')
  const sp = new west.gui.Scrollpane()

  const div = TWDS.createEle('div')
  const p1 = TWDS.createEle('p', {
    last: div,
    textContent: 'Status: '
  })
  TWDS.createEle('p', {
    last: div,
    innerHTML: 'You usually do not need to rebuild the cache. The only reasons to do so are:' +
     '<ul><li>1. you got some seriously good equipment, and need to use it at once.' +
     "<li>2. you want to sell/auction some stuff and need to know what's really not useful.</ul>"
  })
  const sta = TWDS.createEle('span', { last: p1 })

  const tab = TWDS.createEle('table', {
    last: div,
    children: [
      {
        nodeName: 'tr',
        children: [
          { nodeName: 'th', textContent: 'ms' },
          { nodeName: 'th', textContent: 'set' }
        ]
      }
    ]
  })
  sp.appendContent(div)

  win.appendToContentPane(sp.getMainDiv())

  const ostart = (new Date()).getTime()
  const handler = function (i) {
    const e = TWDS.quickequipment.control[i]
    sta.textContent = i + ' / ' + TWDS.quickequipment.control.length
    const start = (new Date()).getTime()
    if (!e.nocache && e.keepcached) {
      const key = e.key
      const res = TWDS.quickequipment.calc(key)
      if (res !== null) {
        TWDS.quickequipment.cacheone(key, res)
      }
      const end = (new Date()).getTime()
      const tr = TWDS.createEle('tr', { last: tab })
      TWDS.createEle('td', {
        last: tr,
        textContent: end - start
      })
      TWDS.createEle('td', {
        last: tr,
        textContent: e.key
      })
    }
    const cur = (new Date()).getTime()
    if (i + 1 < TWDS.quickequipment.control.length && cur < ostart + 5 * 60 * 1000) {
      setTimeout(handler, 100, i + 1)
      return
    }
    TWDS.quickequipment.save()
    TWDS.clothcache.recalcItemUsage()
    const tr = TWDS.createEle('tr', { last: tab })
    TWDS.createEle('td', {
      last: tr,
      textContent: cur - ostart
    })
    TWDS.createEle('td', {
      last: tr,
      textContent: 'ms total runtime'
    })
    sta.textContent = 'finished.'
  }
  handler(0)
}
TWDS.quickequipment.save = function () {
  window.localStorage.TWDS_cache_quickequipment = JSON.stringify(TWDS.quickequipment.cache)
}
TWDS.quickequipment.load = function () {
  const t = window.localStorage.TWDS_cache_quickequipment || '{}'
  try {
    TWDS.quickequipment.cache = JSON.parse(t)
  } catch (e) {
    console.error('loading quickequipment cache', e)
    TWDS.quickequipment.cache = {}
  }
  TWDS.clothcache.recalcItemUsage()
}
TWDS.quickequipment.mayclearcache = function () {
  const last = Bag.getLastInvId()
  if (TWDS.quickequipment.cache.id === last) {
    return
  }
  const ids = Bag.getInventoryIds()
  const cleared = 0
  for (let i = 0; i < ids.length; i++) {
    const invid = ids[i]
    if (invid < TWDS.quickequipment.cache.id) continue
    const it = Bag.getItemByInvId(invid)
    if (it.usetype) continue // not wearable
    if (it.usebonus !== null) continue
    let withbonus = 0
    if (it.bonus.attributes.length) withbonus = 1
    if (it.bonus.skills.length) withbonus = 1
    if (it.bonus.item.length) withbonus = 1
    if (it.bonus.fortbattle.offense) withbonus = 1
    if (it.bonus.fortbattle.defense) withbonus = 1
    if (it.bonus.fortbattle.resistance) withbonus = 1
    if (it.bonus.fortbattlesector.offense) withbonus = 1
    if (it.bonus.fortbattlesector.defense) withbonus = 1
    if (it.bonus.fortbattlesector.damage) withbonus = 1
    if (!withbonus) continue

    TWDS.quickequipment.cache.data = {}
    console.log('QE', 'cleared cache because of', it)
    break
  }
  return cleared
}

TWDS.quickequipment.handleitemlistselect = function (cat) {
  const o = JSON.parse(cat)
  TWDS.wearItemsHandler(o)
}
TWDS.quickequipment.handletwselect = function (cat) {
  window.EquipManager.switchEquip(cat)
}

TWDS.quickequipment.handlecatselect = function (cat) {
  const submenu = function (names, handlername) {
    names.sort(function (a, b) {
      return a[0].localeCompare(b[0])
    })
    const sb = (new west.gui.Selectbox(true))
      .setHeight('347px')
      .setWidth('260px')
      .addListener(function (choice) {
        TWDS.quickequipment[handlername](choice)
        sb.hide()
      })
    for (let i = 0; i < names.length; i++) {
      sb.addItem(names[i][1], names[i][0])
    }
    sb.show(TWDS.quickequipment.eventdata)
  }

  if (cat === 'cacherebuild') {
    TWDS.quickequipment.buildcache()
    return
  }

  // show menu for TW equipment sets.
  if (cat === 'TW') {
    Ajax.remoteCallMode('inventory', 'show_equip', {}, function (data) {
      const names = []
      for (let i = 0; i < data.data.length; i++) {
        names.push([data.data[i].name, data.data[i].equip_manager_id])
      }
      submenu(names, 'handletwselect')
    })
    return
  }

  // show menu for CC equipment sets.
  if (cat === 'CC') {
    const names = []
    for (let i = 0; i < window.localStorage.length; i++) {
      const k = window.localStorage.key(i)
      if (!k.match(/^TWDS_h_/)) {
        continue
      }
      const s = window.localStorage.getItem(k)
      const o = JSON.parse(s)
      names.push([o.name, JSON.stringify(o.item_ids)])
    }
    submenu(names, 'handleitemlistselect')
    return
  }
  // show menu for TWCalc equipment sets.
  if (cat === 'TC') {
    const str = localStorage.TWCalc_Wardrobe
    if (str) {
      const js = JSON.parse(str)
      if (js) {
        const names = []
        for (let i = 0; i < js.length; i++) {
          const o = js[i]
          names.push([o.name, JSON.stringify(o.items)])
        }
        submenu(names, 'handleitemlistselect')
      }
    }
    return
  }

  // the calculated stuff. First the cache
  let res = TWDS.quickequipment.getfromcache(cat)
  if (res) {
    TWDS.wearItemsHandler(res)
    return
  }
  // recalc if needed
  res = TWDS.quickequipment.calc(cat)
  if (res !== null) {
    let nocache = 0
    const cs = TWDS.quickequipment.control
    for (let i = 0; i < cs.length; i++) {
      const c = cs[i]
      if (c.key === cat) {
        if (c.nocache) {
          nocache = 1
          break
        }
      }
    }
    if (!nocache) {
      TWDS.quickequipment.cacheone(cat, res)
      TWDS.quickequipment.save()
      TWDS.clothcache.recalcItemUsage()
    }
    TWDS.wearItemsHandler(res)
    return
  }

  if (cat === 'duel' || cat === 'battle' || cat === 'bonus' || cat === 'skill' || cat === 'saved') {
    const names = []
    const cs = TWDS.quickequipment.control
    for (let i = 0; i < cs.length; i++) {
      const c = cs[i]
      if (c.submenu === cat) {
        names.push([c.text, c.key])
      }
    }
    submenu(names, 'handlecatselect')
  }
}
TWDS.quickequipment.handlemainclick = function (eventdata) {
  const sb = (new west.gui.Selectbox(true))
    .setHeight('347px')
    .setWidth('260px')
    .addListener(function (choice) {
      TWDS.quickequipment.handlecatselect(choice)
      sb.hide()
    })
  for (let i = 0; i < TWDS.quickequipment.control.length; i++) {
    const c = TWDS.quickequipment.control[i]
    if (c.level) continue
    let t = c.text
    if (c.hassubmenu) { t += ' \u2192' }
    sb.addItem(c.key, t)
  }
  sb.show(eventdata)
  TWDS.quickequipment.eventdata = eventdata
}

TWDS.quickequipment.setcharmenulink = function () {
  const ucc = TWDS.q1('#ui_character_container')
  if (ucc) {
    const old = TWDS.q1('.TWDS_quickequipment_shirt', ucc)
    if (old) old.remove()
    if (TWDS.settings.quickequipment_charcontainer) {
      TWDS.createEle({
        nodeName: 'div.TWDS_quickequipment_shirt',
        children: [
          {
            nodeName: 'span.menulink.lfriends',
            onclick: function (e) { TWDS.quickequipment.handlemainclick(e) }
          }
        ],
        last: ucc
      })
    }
  }
}
TWDS.registerStartFunc(function () {
  TWDS.registerSetting('bool', 'quickequipment_charcontainer',
    TWDS._('QUICKEQUIPMENT_CHARCONTAINER',
      'Agregar un menú de cambio rápido de equipo en el contenedor de información del personaje, próximo al enlace tareas diarias.'),
    true, function () { TWDS.quickequipment.setcharmenulink() }, 'Miscelánea', 'quickequipment')
  TWDS.registerSetting('int', 'quickequipment_cachetime_minutes',
    TWDS._('QUICKEQUIPMENT_CACHETIME_MINUTES',
      'Almacenar en caché el "equipo rápido" durante esa cantidad de minutos.'),
    60, null, 'Miscelánea', 'quickequipment')
  TWDS.quickequipment.load()
})
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.allimap = {}

TWDS.allimap.factor = 1.33
TWDS.allimap.calccoords = function (x, y) {
  if (typeof x === 'object') {
    y = x.y
    x = x.x
  }
  return {
    x: x * window.WORLDMAP_COEFF_500 * TWDS.allimap.factor,
    y: y * window.WORLDMAP_COEFF_500 * TWDS.allimap.factor
  }
}

TWDS.allimap.drawbox = function (map, type, title, color, x, y, rot) {
  const xy = TWDS.allimap.calccoords(x, y)
  const sz = (type === 0) ? 5 : (type === 1 ? 6 : 8)
  return TWDS.createEle({
    nodeName: 'div',
    title: title,
    last: map,
    style: {
      cursor: 'pointer',
      position: 'absolute',
      width: sz + 'px',
      height: sz + 'px',
      filter: 'drop-shadow(2px 2px 2px #222)',
      left: xy.x + 'px',
      backgroundColor: color,
      top: xy.y + 'px',
      rotate: rot + 'deg'
    }
  })
}
TWDS.allimap.drawcircle = function (map, sz, opa, color, x, y, cladd) {
  cladd = cladd || ''
  const xy = TWDS.allimap.calccoords(x, y)
  return TWDS.createEle({
    nodeName: 'div',
    className: cladd,
    last: map,
    style: {
      position: 'absolute',
      width: (sz * 2) + 'px',
      height: (sz * 2) + 'px',
      filter: 'drop-shadow(2px 2px 2px #222)',
      left: (xy.x - sz) + 'px',
      backgroundColor: color,
      background: 'radial-gradient(' + color + ', ' + color + '00, #00000000)',
      top: (xy.y - sz) + 'px',
      opacity: opa,
      clipPath: 'circle(' + (sz) + 'px)'
    }
  })
}
TWDS.allimap.drawicon = function (map, cladd, title, src, x, y) {
  const xy = TWDS.allimap.calccoords(x, y)
  return TWDS.createEle({
    nodeName: 'img',
    className: cladd,
    title: title,
    last: map,
    src: src,
    style: {
      cursor: 'pointer',
      position: 'absolute',
      width: '16px',
      height: 'auto',
      filter: 'drop-shadow(2px 2px 2px #222)',
      left: xy.x + 'px',
      top: xy.y + 'px'
    }
  })
}
TWDS.allimap.drawcheckbox = function (map, title, x, y) {
  const xy = TWDS.allimap.calccoords(x, y)
  return TWDS.createEle({
    nodeName: 'input',
    type: 'checkbox',
    title: title,
    last: map,
    style: {
      cursor: 'pointer',
      position: 'absolute',
      width: '16px',
      height: 'auto',
      filter: 'drop-shadow(2px 2px 2px #222)',
      left: xy.x + 'px',
      top: xy.y + 'px'
    }
  })
}

TWDS.allimap.colors = ['#e6194B', // red
  '#3cb44b', // Green
  '#ffe119', // Yellow
  '#4363d8', // Blue
  '#f58231', // Orange
  '#911eb4', // Purple
  '#42d4f4', // Cyan
  '#f032e6', // Magenta
  '#bfef45', // Lime
  '#fabed4', // Pink
  '#469990', // Teal
  '#dcbeff', // Lavender
  '#9A6324', // Brown
  '#fffac8', // Beige
  '#800000', // Maroon
  '#aaffc3', // Mint
  '#808000', // Olive
  '#ffd8b1', // Apricot
  '#000075', // Navy
  '#a9a9a9', // Grey
  '#ffffff', // White
  '#000000' // Black
]
TWDS.allimap.drawit = function (map, table) {
  TWDS.allimap.drawicon(map, 'me', 'you',
    '/images/map/minimap/icons/miniicon_pos.png',
    Character.getPosition())

  Ajax.get('map', 'get_minimap', {}, function (json) {
    // console.log("MM",json);
    if (json.error) {
      return new UserMessage(json.msg).show()
    }

    const ainfo = { }
    const forts = []
    for (const xi of Object.keys(json.forts)) {
      for (const yi of Object.keys(json.forts[xi])) {
        const f = json.forts[xi][yi]
        let a = f.fort.alliance_id
        if (!a) a = 1e8 + f.fort.town_id // invent an alliance for a town.
        if (!ainfo[a]) ainfo[a] = { weight: 0, forts: [0, 0, 0], towns: 0, members: 0 }
        ainfo[a].weight += (f.fort.type + 1) * 200 // 200,400,600
        ainfo[a].forts[f.fort.type]++
        ainfo[a].workallianceid = a
        forts.push(f)
      }
    }
    for (const t of Object.values(json.towns)) {
      if (t.member_count && !t.npctown) {
        let a = t.alliance_id
        if (!a) a = 1e8 + t.town_id // invent an alliance for a town.
        if (!ainfo[a]) ainfo[a] = { weight: 0, forts: [0, 0, 0], towns: 0, members: 0 }
        ainfo[a].weight += Math.pow(t.town_points, 0.33) // 0..60?
        ainfo[a].weight += t.member_count * 2 // 2..100
        ainfo[a].towns++
        ainfo[a].members += t.member_count
      }
    }
    const tmp = []
    for (const [a, b] of Object.entries(ainfo)) {
      tmp.push([a, b])
    }

    tmp.sort(function (a, b) {
      return b[1].weight - a[1].weight
    })

    forts.sort(function (a, b) {
      if (b.fort.type !== a.fort.type) { return b.fort.type - a.fort.type }
      const ad = Math.sqrt((a.fort.x - 23000) * (a.fort.x - 23000) + (a.fort.y - 10000) * (a.fort.y - 10000))
      const bd = Math.sqrt((b.fort.x - 23000) * (b.fort.x - 23000) + (b.fort.y - 10000) * (b.fort.y - 10000))
      return bd - ad
    })

    const acolors = {}
    let delay = 100
    let first = 0
    for (let i = 0; i < tmp.length; i++) {
      const a = tmp[i][0]
      if (i < TWDS.allimap.colors.length) {
        if (!first++) {
          const tr = TWDS.createEle('tr.head', { last: table })
          TWDS.createEle('th', { last: tr, textContent: '#', title: 'Alliance Id' })
          TWDS.createEle('th', { last: tr, textContent: TWDS._('ALLIMAP_TH_ALLIANCE_ID', 'Alliance Name') })
          TWDS.createEle('th', { last: tr, textContent: TWDS._('ALLIMAP_TH_POINTS', 'Points') })
          TWDS.createEle('th', { last: tr, textContent: '' })
          TWDS.createEle('th', { last: tr, textContent: TWDS._('ALLIMAP_TH_TOWNS', 'Towns') })
          TWDS.createEle('th', { last: tr, textContent: TWDS._('ALLIMAP_TH_MEMBERS', 'Members') })
          TWDS.createEle('th', { last: tr, textContent: TWDS._('ALLIMAP_TH_LARGE', 'Large') })
          TWDS.createEle('th', { last: tr, textContent: TWDS._('ALLIMAP_TH_MEDIUM', 'Medium') })
          TWDS.createEle('th', { last: tr, textContent: TWDS._('ALLIMAP_TH_SMALL', 'Small forts') })
        }
        acolors[a] = TWDS.allimap.colors[i]
        const tr = TWDS.createEle({
          nodeName: 'tr',
          last: table
        })
        TWDS.createEle('td', {
          textContent: a > 1e8 ? -1 * (a - 1e8) : a,
          last: tr
        })
        const th = TWDS.createEle('th', {
          textContent: a,
          className: 'linklike',
          last: tr,
          onclick: function () {
            if (this.classList.contains('istown')) {
              const t = json.towns[a - 1e8]
              TownWindow.open(t.x, t.y)
            } else {
              AllianceWindow.open(a)
            }
          }
        })
        if (a > 1e8) {
          th.textContent = json.towns[a - 1e8].name
          th.classList.add('istown')
        }
        TWDS.createEle('td', {
          textContent: Math.round(ainfo[a].weight),
          style: {
            textAlign: 'right'
          },
          last: tr
        })
        TWDS.createEle('td', {
          textContent: '',
          style: {
            minWidth: '30px',
            backgroundColor: acolors[a]
          },
          last: tr
        })
        TWDS.createEle('td', {
          textContent: Math.round(ainfo[a].towns),
          style: {
            textAlign: 'right'
          },
          last: tr
        })
        TWDS.createEle('td', {
          textContent: Math.round(ainfo[a].members),
          style: {
            textAlign: 'right'
          },
          last: tr
        })
        for (let j = 2; j > -1; j--) {
          TWDS.createEle('td', {
            textContent: ainfo[a].forts[j],
            style: {
              textAlign: 'right'
            },
            last: tr
          })
        }
        setTimeout(function () {
          const id = parseInt(th.textContent)
          if (id > 1e8) {
            th.textContent = json.towns[id - 1e8].name
          } else {
            Ajax.remoteCallMode('alliance', 'get_data', {
              alliance_id: id
            }, function (r) {
              if (r.error === false && r.data && r.data.allianceName) {
                th.textContent = r.data.allianceName
              }
            })
          }
        }, delay)
        delay += 350
        if ((i + 1) % 20 === 0) {
          delay += 1500
        }
      }
    }
    // draw the nebulas
    for (let i = 0; i < forts.length; i++) {
      const loc = forts[i]
      if (typeof loc !== 'object') {
        continue
      }
      const a = loc.fort.alliance_id
      if (!a) continue
      const tp = loc.fort.type

      const sz = (tp === 0) ? 60 : (tp === 1 ? 100 : 170)
      TWDS.allimap.drawcircle(map, sz, 0.4 + 0.1 * loc.fort.type, acolors[a], loc.fort.x, loc.fort.y)
    }
    // draw the forts
    for (let i = 0; i < forts.length; i++) {
      const loc = forts[i]
      if (typeof loc !== 'object') {
        continue
      }
      let a = loc.fort.alliance_id
      if (!a) a = 1e8 + loc.fort.town_id // invent an alliance for a town.
      if (!a) continue
      let n = loc.fort.name + ', '
      if (loc.fort.type === 0) n += TWDS._('ALLIMAP_FS_0', 'small fort')
      if (loc.fort.type === 1) n += TWDS._('ALLIMAP_FS_1', 'medium fort')
      if (loc.fort.type === 2) n += TWDS._('ALLIMAP_FS_2', 'large fort')
      const x = TWDS.allimap.drawbox(map, loc.fort.type, n, acolors[a], loc.fort.x, loc.fort.y, 0)
      x.classList.add('linklike')
      x.onclick = function () {
        window.FortWindow.open(loc.fort.fort_id, loc.fort.x, loc.fort.y)
      }
    }
    for (const t of Object.values(json.towns)) {
      if (t.member_count && !t.npctown) {
        let a = t.alliance_id
        if (a === null) {
          a = 1e8 + t.town_id // invent an alliance for a town.
        }
        if (acolors[a]) {
          const x = TWDS.allimap.drawbox(map, 0, t.name, acolors[a], t.x, t.y, 45)
          x.classList.add('linklike')
          x.classList.add('TWDS_allimap_town')
          x.onclick = function () {
            TownWindow.open(t.x, t.y, t.town_id)
          }
        }
      }
    }
    const x = TWDS.allimap.drawcheckbox(map, TWDS._('ALLIMAP_HIDE_TOWNS', 'hide towns'), 21000, 9000)
    x.onchange = function () {
      const all = TWDS.q('.TWDS_allimap_town')
      for (let i = 0; i < all.length; i++) {
        if (this.checked) { all[i].style.display = 'none' } else { all[i].style.display = 'block' }
      }
    }
  })
}

TWDS.allimap.getcontent = function (win) {
  const content = TWDS.createEle({
    nodeName: 'div',
    className: 'TWDS_allimap_content'
  })
  const factor = 1.33
  const map = TWDS.createEle('div.map', {
    last: content,
    style: {
      width: Math.round(500 * factor) + 'px',
      height: Math.round(220 * factor) + 'px',
      background: 'url(/images/map/minimap/worldmap_500.jpg) no-repeat',
      backgroundSize: 'contain',
      position: 'relative',
      overflow: 'hidden'
    }
  })
  const table = TWDS.createEle('table.mapinfo', {
    last: content
  })
  TWDS.allimap.drawit(map, table)
  return content
}

TWDS.allimap.openwindow = function (search) {
  const wid = 'TWDS_allimap_window'
  let win
  if (wman.isWindowCreated(wid)) {
    win = wman.getById(wid)
    if (wman.isMinimized(wid)) {
      wman.reopen(wid, 'allimap')
    }
  } else {
    win = wman.open(wid, 'allimap')
    win.setTitle(TWDS._('ALLIMAP_WINDOW_TITLE', 'Alliance Map'))

    const sp = new west.gui.Scrollpane()
    const content = TWDS.allimap.getcontent(win)
    sp.appendContent(content)
    win.appendToContentPane(sp.getMainDiv())
  }
}
TWDS.registerStartFunc(function () {
  TWDS.registerExtra('TWDS.allimap.openwindow',
    TWDS._('ALLIMPA_EXTRA', 'Mapa mundial Alianzas'),
    TWDS._('ALLIMPA_EXTRA_DESC', 'Muestra un mapa con las alianzas más importantes.')
  )
})

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.stathist = {}
TWDS.stathist.getdatestring = function () {
  const t = new Date()
  const y = t.getFullYear()
  let m = t.getMonth() + 1
  if (m < 10) m = '0' + m
  let d = t.getDate()
  if (d < 10) d = '0' + d
  return y + '-' + m + '-' + d
}

TWDS.stathist.decompress = function (input, cb) {
  (async function (input, cb) {
    const b64decode = function (str) {
      const binarystring = window.atob(str)
      const len = binarystring.length
      const bytes = new Uint8Array(new ArrayBuffer(len))
      for (let i = 0; i < len; i++) {
        bytes[i] = binarystring.charCodeAt(i)
      }
      return bytes
    }
    const stream = new Blob([b64decode(input)], {
      type: 'application/json'
    }).stream()
    const ds = stream.pipeThrough(
      new window.DecompressionStream('gzip')
    )
    const resp = await new window.Response(ds)
    const blob = await resp.blob()
    blob.text().then(cb)
  })(input, cb)
}
TWDS.stathist.compress = function (input, cb) {
  (async function (input, cb) {
    const stream = new Blob([input]).stream()
    const cs = stream.pipeThrough(
      new window.CompressionStream('gzip')
    )
    const resp = await new window.Response(cs)
    const blob = await resp.blob()
    const ab = await blob.arrayBuffer()
    const b64 = window.btoa(
      String.fromCharCode(
        ...new Uint8Array(ab)
      )
    )
    cb(b64)
  })(input, cb)
}

TWDS.stathist.load = function (cb) {
  const basetemplate = '{"ts":0,"list":[]}'
  try {
    if ('TWDS_stathist_compressed' in window.localStorage) {
      TWDS.stathist.decompress(window.localStorage.TWDS_stathist_compressed, function (d) {
        // d is decompressed data
        const js = JSON.parse(d)
        console.log('load', 'mainpath', js)
        cb(js)
      })
    } else {
      const js = JSON.parse(basetemplate)
      console.log('load', 'else', js)
      cb(js)
    }
  } catch (e) {
    console.log('exception during stathist load', e)
    const js = JSON.parse(basetemplate)
    cb(js)
  }
}
TWDS.stathist.save = function (data) {
  const str = JSON.stringify(data)
  TWDS.stathist.compress(str, function (c) {
    window.localStorage.TWDS_stathist_compressed = c
  })
}

TWDS.stathist.ranklist = [
  { tab: 'experience', values: { counter: 'xp_rank', experience: 'xp_number' } },
  { tab: 'duels', values: { counter: 'duel_rank', duel_loss: 'duel_loss', duel_win: 'duel_win', experience: 'duel_xp' } },
  {
    tab: 'forts',
    values: { counter: 'fort_rank', damage_dealt: 'fort_dmg_dealt', dodges: 'fort_dodges', hits_taken: 'fort_hits_taken', score: 'fort_score' }
  },
  {
    tab: 'craft',
    values: { counter: 'craft_rank', learnt_recipes: 'craft_learnt_recipes', profession_skill: 'craft_skill', score: 'craft_diversity', items_created: 'craft_items' }
  },
  {
    tab: 'build',
    values: { counter: 'build_rank', fair_points: 'build_fair', stage_ups: 'build_stages', total_cp: 'build_total' }
  },
  {
    tab: 'mpi',
    values: {
      counter: 'mpi_rank',
      knockouts: 'mpi_knockouts',
      total_actions: 'mpi_actions',
      games_played: 'mpi_games',
      friendly_dmg: 'mpi_friendlyfire',
      rage_quits: 'mpi_rage_quits'
    }
  },
  {
    tab: 'achieve',
    values: { counter: 'achieve_rank', achievements: 'achieve_total', worlds_first: 'achieve_firsts', points: 'achieve_points' }
  }
]
TWDS.stathist.dorank = function (loaded, ts, work, idx) {
  const cfg = TWDS.stathist.ranklist[idx]
  // console.log("DORANK",idx);

  Ajax.remoteCallMode('ranking', 'get_data', {
    page: 0,
    tab: cfg.tab
  }, function (json) {
    if (json.error) {
      TWDS.error('stathist', 'failed to get ranking with mode', cfg.tab)
      return
    }
    console.log('looking for', Character.playerId, 'in', json.ranking)
    for (let i = 0; i < json.ranking.length; i++) {
      const d = json.ranking[i]
      // console.log("try",i,d,d.player_id, Character.playerId, d.player_id===Character.playerId);
      if (d.player_id === Character.playerId) {
        for (const [from, to] of Object.entries(cfg.values)) {
          const v = d[from]
          work[to] = v
        }
        idx++
        if (idx >= TWDS.stathist.ranklist.length) {
          loaded.list.push(work)
          loaded.ts = ts
          TWDS.stathist.save(loaded)
          return
        }
        TWDS.stathist.dorank(loaded, ts, work, idx)
        return
      }
    }
    TWDS.error('stathist', 'failed to find me in ranking with mode', cfg.tab)
  })
}
TWDS.stathist.update = function () {
  TWDS.stathist.load(function (loaded) {
    const s = TWDS.stathist.getdatestring()
    console.log('loaded', loaded, s)
    if (loaded.ts === s) {
      console.log('already have', s)
      return // we already have this day.
    }

    const d = {
      level: Character.level,
      duelLevel: Character.duelLevel,
      money: Character.deposit + Character.money,
      professionSkill: Character.professionSkill,
      upb: Character.upb,
      lastDied: Character.lastDied,
      experience: Character.experience,
      ts: s
    }
    TWDS.stathist.dorank(loaded, s, d, 0)
  })
}
TWDS.stathist.kv = [
  { key: 'ts', head: '', name: 'Date', headkey: '' },
  { key: 'level', head: 'General', name: 'Level', headkey: 'general' },
  { key: 'money', head: 'General', name: 'Money', headkey: 'general', format: 'money' },
  { key: 'upb', head: 'General', name: 'Bonds', headkey: 'general' },
  { key: 'xp_rank', head: 'XP', name: 'Rank', headkey: 'xp' },
  { key: 'xp_number', head: 'XP', name: 'points', headkey: 'xp', format: 'number' },
  { key: 'duel_rank', head: 'Duels', name: 'Rank', headkey: 'duel' },
  { key: 'duel_xp', head: 'Duels', name: 'XP', headkey: 'duel', format: 'number' },
  { key: 'duel_win', head: 'Duels', name: 'Won', headkey: 'duel' },
  { key: 'duel_loss', head: 'Duels', name: 'Lost', headkey: 'duel' },
  { key: 'fort_rank', head: 'Fort Battles', name: 'Rank', headkey: 'fort' },
  { key: 'fort_score', head: 'Fort Battles', name: 'Score', headkey: 'fort' },
  { key: 'fort_dmg_dealt', head: 'Fort Battles', name: 'DMG Dealt', headkey: 'fort', format: 'number' },
  { key: 'fort_dodges', head: 'Fort Battles', name: 'Dodged', headkey: 'fort' },
  { key: 'fort_hits_taken', head: 'Fort Battles', name: 'Hits taken', headkey: 'fort' },
  { key: 'craft_rank', head: 'Crafting', name: 'Rank', headkey: 'craft' },
  { key: 'craft_learnt_recipes', head: 'Crafting', name: 'Recipes', headkey: 'craft' },
  { key: 'craft_skill', head: 'Crafting', name: 'Skill', headkey: 'craft' },
  { key: 'craft_diversity', head: 'Crafting', name: 'Diversity', headkey: 'craft' },
  { key: 'craft_items', head: 'Crafting', name: 'Items', headkey: 'craft' },
  { key: 'build_rank', head: 'Construction', name: 'Rank', headkey: 'build' },
  { key: 'build_total', head: 'Construction', name: 'Points', headkey: 'build' },
  { key: 'build_fair', head: 'Construction', name: 'Fair', headkey: 'build' },
  { key: 'build_stages', head: 'Construction', name: 'Level Ups', headkey: 'build' },
  { key: 'mpi_rank', head: 'Adventures', name: 'Rank', headkey: 'mpi' },
  { key: 'mpi_knockouts', head: 'Adventures', name: 'KOs', headkey: 'mpi' },
  { key: 'mpi_actions', head: 'Adventures', name: 'Actions', headkey: 'mpi' },
  { key: 'mpi_games', head: 'Adventures', name: 'Games', headkey: 'mpi' },
  { key: 'mpi_friendlyfire', head: 'Adventures', name: 'Frn Fire', headkey: 'mpi' },
  { key: 'mpi_rage_quits', head: 'Adventures', name: 'Ragequits', headkey: 'mpi' },
  { key: 'achieve_rank', head: 'Achievements', name: 'Rank', headkey: 'achieve' },
  { key: 'achieve_total', head: 'Achievements', name: 'Total', headkey: 'achieve' },
  { key: 'achieve_firsts', head: 'Achievements', name: 'First', headkey: 'achieve' },
  { key: 'achieve_points', head: 'Achievements', name: 'Points', headkey: 'achieve' }
]

TWDS.stathist.filter = function (tab, shown) {
  const tbody = TWDS.q1('tbody', tab)
  const head1 = TWDS.q1('thead tr.head1', tab)
  const head2 = TWDS.q1('thead tr.head2', tab)

  TWDS.q('th', head1).forEach(function (ele) {
    ele.classList.add('hidden')
    ele.colSpan = 0
    ele.removeAttribute('colSpan')
  })

  let cols = TWDS.q('th', head2)
  for (let i = 0; i < cols.length; i++) {
    const key = cols[i].dataset.key
    const groupkey = cols[i].dataset.groupkey
    if (shown.includes(key)) {
      const g = TWDS.q1('.grp_' + groupkey, head1)
      //      console.log("H2",i,"G",g,"in",g.colSpan);
      if (g.classList.contains('hidden')) {
        g.classList.remove('hidden')
      } else {
        g.colSpan += 1
      }
      //      console.log("H2",i,"G",g,"after",g.colSpan);
      cols[i].classList.remove('hidden')
    } else {
      cols[i].classList.add('hidden')
    }
  }
  const rows = TWDS.q('tr', tbody)
  //  console.log("ROWS",rows);
  for (let j = 0; j < rows.length; j++) {
    const row = rows[j]
    cols = TWDS.q('td', row)
    for (let i = 0; i < cols.length; i++) {
      const key = cols[i].dataset.key
      if (shown.includes(key)) {
        cols[i].classList.remove('hidden')
      } else {
        cols[i].classList.add('hidden')
      }
    }
  }
}
TWDS.stathist.getcontent = function (data) {
  const div = TWDS.createEle('div')
  let lasthead = null

  let shown = localStorage.TWDS_stathist_fields
  if (shown) {
    shown = JSON.parse(shown)
  } else {
    shown = [
      'ts', 'level', 'xp_rank', 'xp_number', 'duel_rank', 'craft_rank', 'duel_xp', 'fort_rank', 'fort_score', 'craft_skill', 'achieve_rank', 'build_rank', 'build_total', 'mpi_rank', 'achieve_total'
    ]
    localStorage.TWDS_stathist_fields = JSON.stringify(shown)
  }
  const changer = function () {
    if (this.checked) {
      shown.push(this.value)
    } else {
      for (let i = 0; i < shown.length; i++) {
        if (shown[i] === this.value) {
          shown.splice(i, 1)
        }
      }
    }
    localStorage.TWDS_stathist_fields = JSON.stringify(shown)
    TWDS.stathist.filter(tab, shown)
  }

  lasthead = null
  for (let i = 0; i < TWDS.stathist.kv.length; i++) {
    const e = TWDS.stathist.kv[i]
    if (e.head === '') continue
    if (e.head !== lasthead) {
      TWDS.createEle('b', {
        last: div,
        textContent: e.head + ': '
      })
      lasthead = e.head
    }
    TWDS.createEle('label', {
      last: div,
      children: [
        {
          nodeName: 'input',
          type: 'checkbox',
          value: e.key,
          checked: shown.includes(e.key),
          onchange: changer
        }, {
          nodeName: 'span',
          textContent: e.name + ' '
        }
      ]
    })
  }

  const tab = TWDS.createEle('table.stathist', { last: div })
  const thead = TWDS.createEle('thead', { last: tab })
  const tbody = TWDS.createEle('tbody', { last: tab })
  let tr
  tr = TWDS.createEle('tr.head1', { last: thead })
  let lastth = null
  lasthead = null
  for (let i = 0; i < TWDS.stathist.kv.length; i++) {
    const d = TWDS.stathist.kv[i]
    if (d.head === lasthead) {
      continue
    }
    lastth = TWDS.createEle('th', { last: tr, textContent: d.head })
    lastth.classList.add('grp_' + d.headkey)
    lastth.dataset.groupkey = d.headkey
    lasthead = d.head
  }
  tr = TWDS.createEle('tr.head2', { last: thead })
  lasthead = null
  for (let i = 0; i < TWDS.stathist.kv.length; i++) {
    const d = TWDS.stathist.kv[i]
    const t = TWDS.createEle('th', { last: tr, textContent: d.name })
    t.dataset.groupkey = d.headkey
    t.dataset.key = d.key
    if (d.head !== lasthead) {
      t.classList.add('newgroup')
      lasthead = d.head
    }
    t.classList.add('grp_' + d.headkey)
  }
  for (let j = data.list.length - 1; j >= 0; j--) {
    const e = data.list[j]
    tr = TWDS.createEle('tr', { last: tbody })
    lasthead = null
    for (let i = 0; i < TWDS.stathist.kv.length; i++) {
      const d = TWDS.stathist.kv[i]
      let v = e[d.key]
      if (d.format) {
        const fn = 'format_' + d.format
        v = window[fn](v)
      }
      const t = TWDS.createEle('td', { last: tr, textContent: v })
      t.dataset.key = d.key
      t.dataset.groupkey = d.headkey
      if (d.head !== lasthead) {
        t.classList.add('newgroup')
        lasthead = d.head
      }
    }
  }
  TWDS.stathist.filter(tab, shown)

  const len = window.localStorage.TWDS_stathist_compressed.length
  TWDS.createEle('p', {
    last: div,
    textContent: 'This needs ' + len + ' bytes of localStorage.'
  })

  return div
}
TWDS.stathist.openwindow = function () {
  TWDS.stathist.load(function (data) {
    const myname = 'TWDS_stathist_window'
    const win = wman.open(myname, TWDS._('STATHIST_TITLE', 'History'), 'TWDS_wide_window')
    win.setMiniTitle('History')
    const sp = new west.gui.Scrollpane()
    sp.appendContent(TWDS.stathist.getcontent(data))
    win.appendToContentPane(sp.getMainDiv())
  })
}

TWDS.registerStartFunc(function () {
  setTimeout(TWDS.stathist.update, 2 * 60 * 1000)
  TWDS.registerExtra('TWDS.stathist.openwindow', 'Estadísticas', 'Una historia de tu clasificación.')
})
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.nightmode = {}
TWDS.nightmode.timeout = 0

// a little complicated to avoid manipulating body.style.filter directly (co-existance with over scripts),
TWDS.nightmode.stylehandler = function () {
  let val = TWDS.settings.nightmode_brightness

  let sh = TWDS.q1('#TWDS_nightmode_style_hack')
  if (val === 100) {
    if (sh) { sh.remove() }
    return
  }
  if (!sh) {
    sh = TWDS.createEle({
      nodeName: 'style',
      id: 'TWDS_nightmode_style_hack',
      textContent: '',
      last: document.body
    })
  }
  // min and max on input ele doesn't work quite as one might expect!
  // the input.value is invalid, the form fails validation - but we have no form.
  if (val < 25) val = 25 // otherwise to dark to see something
  if (val > 200) val = 200 // otherwise the screen is overly white
  val = (val / 100.0).toFixed(2)
  sh.textContent = 'body.TWDS_nightmode { filter:brightness(' + val + ') }'
}
TWDS.nightmode.setit = function (force) {
  const b = TWDS.q1('body')
  if (!b) return // whatever

  const h = (new Date()).getHours()
  let doit = 0
  const start = parseInt(TWDS.settings.nightmode_start)
  const end = parseInt(TWDS.settings.nightmode_end)

  if (h >= start && h < end) {
    doit = 1 // australia case - 9-18
  } else if (end < start) {
    // europe case 21-06
    if (h >= start) doit = 1 // subcase 21..23
    else if (h < end) doit = 1 // subcase 00..06
  }

  if (force !== undefined) {
    console.log('forcing it from', doit, 'to', force)
    doit = force
  }

  if (doit) b.classList.add('TWDS_nightmode')
  else b.classList.remove('TWDS_nightmode')
}
TWDS.nightmode.timer = function () {
  clearTimeout(TWDS.nightmode.timeout)
  TWDS.nightmode.setit()
  const d = new Date()
  const over = d.getMinutes() * 60 + d.getSeconds()
  let todo = 3600 - over
  if (todo < 0) todo = 0
  TWDS.nightmode.timeout = setTimeout(TWDS.nightmode.timer, todo * 1000 + 1000)
}
TWDS.registerStartFunc(function () {
  TWDS.registerSetting('int', 'nightmode_start',
    TWDS._('NIGHTMODE_START',
      'Iniciar el modo nocturno a esa hora. -1: (apagado)'),
    { default: -1, min: -1, max: 23 },
    function () { TWDS.nightmode.timer() }, 'Modo nocturno', null, 1)
  TWDS.registerSetting('int', 'nightmode_end',
    TWDS._('NIGHTMODE_END',
      'Finalizar el modo nocturno a esa hora. -1: (apagado)'),
    { default: -1, min: -1, max: 23 },
    function () { TWDS.nightmode.timer() }, 'Modo nocturno', null, 2)
  TWDS.registerSetting('int', 'nightmode_brightness',
    TWDS._('NIGHTMODE_BRIGHTNESS',
      'Establecer brillo modo nocturno (en %). 75 estaría bien.'),
    { default: 100, min: 33, max: 133 }
    , function () { TWDS.nightmode.stylehandler() }, 'Modo nocturno', null, 3)
  TWDS.nightmode.timer()
})
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.maphelper = {}

TWDS.maphelper.getmap = function (factor) {
  factor = factor || 1.33

  const map = TWDS.createEle('div.map', {
    dataset: {
      factor: factor
    },
    style: {
      width: Math.round(500 * factor) + 'px',
      height: Math.round(220 * factor) + 'px',
      background: 'url(/images/map/minimap/worldmap_500.jpg) no-repeat',
      backgroundSize: 'contain',
      position: 'relative',
      overflow: 'hidden'
    }
  })
  return map
}
TWDS.maphelper.calccoords = function (map, x, y) {
  const factor = parseFloat(map.dataset.factor)
  if (typeof x === 'object') {
    y = x.y
    x = x.x
  }
  return {
    x: x * window.WORLDMAP_COEFF_500 * factor,
    y: y * window.WORLDMAP_COEFF_500 * factor
  }
}

TWDS.maphelper.drawbox = function (map, x, y, sz, title, color, rot, cladd) {
  cladd = cladd || ''
  const xy = TWDS.maphelper.calccoords(map, x, y)
  return TWDS.createEle({
    nodeName: 'div',
    className: cladd,
    title: title,
    last: map,
    style: {
      cursor: 'pointer',
      position: 'absolute',
      width: sz + 'px',
      height: sz + 'px',
      filter: 'drop-shadow(2px 2px 2px #222)',
      left: xy.x + 'px',
      backgroundColor: color,
      top: xy.y + 'px',
      rotate: rot + 'deg'
    }
  })
}
TWDS.maphelper.drawicon = function (map, x, y, src, title, cladd) {
  cladd = cladd || ''
  const xy = TWDS.maphelper.calccoords(map, x, y)
  return TWDS.createEle({
    nodeName: 'img',
    className: cladd,
    title: title,
    last: map,
    src: src,
    style: {
      cursor: 'pointer',
      position: 'absolute',
      width: '16px',
      height: 'auto',
      filter: 'drop-shadow(2px 2px 2px #222)',
      left: xy.x + 'px',
      top: xy.y + 'px'
    }
  })
}
TWDS.maphelper.drawme = function (map) {
  return TWDS.maphelper.drawicon(map,
    Character.getPosition(), null,
    '/images/map/minimap/icons/miniicon_pos.png',
    'you', 'me')
}

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.fortbuild = {}
TWDS.fortbuild.data = {}
TWDS.fortbuild.dollarper15 = 60
TWDS.fortbuild.data.stages = {
  headquarter: {
    name: 'Headquarters',
    small: 10,
    medium: 10,
    756: [0, 4, 6, 8, 10, 12, 14, 16, 18, 20], // tool boxes
    742: [0, 8, 12, 16, 20, 24, 28, 32, 36, 40], // saw
    760: [0, 12, 18, 24, 30, 36, 42, 48, 54, 60], // map
    per15: {
      711: 10, // wood
      716: 3 // granite
    }
  },
  barracks: {
    name: 'Barracks',
    small: 2,
    medium: 4,
    715: [10, 20, 30, 40, 50, 60], // cloth
    704: [20, 40, 60, 80, 100, 120], // cotton
    747: [8, 16, 24, 32, 40, 48], // hammer
    per15: {
      711: 10, // wood
      790: 3 // iron rods
    }
  },
  wall: {
    name: 'Protective Barrier',
    small: 3,
    medium: 4,
    736: [6, 12, 18, 24, 30], // spade
    771: [10, 20, 30, 40, 50], // beaver trap
    711: [40, 80, 120, 160, 200], // wood,
    per15: {
      711: 5, // wood
      739: 2 // barbed wire
    }
  },
  flag: {
    name: 'Flag',
    758: [3], // union flag
    762: [2], // confederate flag
    749: [8], // lasso
    per15: {
      711: 10, // wood
      749: 1 // lasso
    }
  },
  fronttower: {
    name: 'Gates',
    small: 3,
    medium: 4,
    761: [6, 12, 18, 24, 30], // sledge hammer
    784: [10, 20, 30, 40, 50], // nails
    734: [40, 80, 120, 160, 200], // plane
    per15: {
      711: 10, // wood
      790: 3, // iron rods
      739: 2 // barbed wire
    }
  },
  tower1: { // advent
    name: "Adventurer's tower",
    small: 3,
    medium: 4,
    755: [10, 20, 30, 40, 50], // flag
    788: [8, 16, 24, 32, 40], // bell
    779: [10, 20, 30, 40, 50], // post horn
    per15: {
      711: 10, // wood
      790: 3, // iron rods
      739: 2 // barbed wire
    }
  },
  tower2: { // dueller
    name: "Duellers's tower",
    small: 3,
    medium: 4,
    755: [10, 20, 30, 40, 50], // flag
    788: [8, 16, 24, 32, 40], // bell
    780: [12, 24, 36, 48, 60], // rounds
    per15: {
      711: 10, // wood
      790: 3, // iron rods
      739: 2 // barbed wire
    }
  },
  tower3: { // worker
    name: "Workers's tower",
    small: 3,
    medium: 4,
    755: [10, 20, 30, 40, 50], // flag
    788: [8, 16, 24, 32, 40], // bell
    752: [10, 20, 30, 40, 50], // oil
    per15: {
      711: 10, // wood
      790: 3, // iron rods
      739: 2 // barbed wire
    }
  },
  tower4: { // soldier
    name: "Soldiers's tower",
    small: 3,
    medium: 4,
    755: [10, 20, 30, 40, 50], // flag
    788: [8, 16, 24, 32, 40], // bell
    1708: [9, 18, 27, 36, 45], // whiskey
    per15: {
      711: 10, // wood
      790: 3, // iron rods
      739: 2 // barbed wire
    }
  },
  storage: [
  ]
}

TWDS.fortbuild.updateInventory = function (data) {
  // un-private a few fields.
  const fortid = this.fortId
  window.FortStorageOverview.inventory = []
  window.FortStorageOverview.elInventory = $('#fortstoragedrop-' + fortid)
  window.FortStorageOverview.fortId = fortid
  const that = this

  Ajax.remoteCallMode('fort_building_headquarter', 'index', {
    fort_id: this.fortId
  }, function (resp) {
    if (typeof resp === 'string') { return new UserMessage(resp, UserMessage.TYPE_ERROR).show() }
    if (resp.page) { return new UserMessage('A guard stops you as you try to enter the fort.', UserMessage.TYPE_ERROR).show() }
    const buildings = resp.build.buildings
    const mats = {}
    const matstext = {}
    let totalstages = 0
    const totalstageinfo = []
    for (let i = 0; i < buildings.length; i++) {
      const b = buildings[i]
      const key = b.key
      const bmats = TWDS.fortbuild.data.stages[key]
      let stagesdone = false
      for (let [k, ar] of Object.entries(bmats)) {
        k = parseInt(k)
        if (!k) continue
        if (!mats[k]) {
          mats[k] = 0
          matstext[k] = []
        }
        let nstages = 0
        for (let j = b.stage; j < b.maxStage; j++) {
          if (j === b.stage && !b.yieldStageUpRequirement) continue // unlocked.
          const n = ar[j]
          mats[k] += n
          matstext[k].push(TWDS._('FORTBUILD_ONESTAGEINFO',
            '$mats$ for stage $stage$ of $bname$', {
              mats: n,
              stage: j,
              bname: b.name
            }))
          nstages++
        }
        if (nstages && !stagesdone) {
          stagesdone++
          totalstages += nstages
          totalstageinfo.push(TWDS._('FORTBUILD_TOTALSTAGEINFO', '$nstages$ of $bname$', {
            nstages: nstages,
            bname: b.name
          }))

          for (let [k15, n15] of Object.entries(bmats.per15)) {
            k15 = parseInt(k15)
            n15 = parseInt(n15)
            if (!mats[k15]) {
              mats[k15] = 0
              matstext[k15] = []
            }
            mats[k15] += n15 * nstages
            matstext[k15].push(
              TWDS._('FORTBUILD_ALLSTAGEINFO',
                'At least $mats$ for $nstages$ stages of $bname$', {
                  mats: n15 * nstages,
                  nstages: nstages,
                  bname: b.name
                }))
          }
        }
      }
    }
    const droparea = TWDS.q1('#fortstoragedrop-' + fortid)
    if (droparea) {
      droparea.dataset.matsneeded = JSON.stringify(mats)
      droparea.dataset.matstext = JSON.stringify(matstext)
      droparea.dataset.totalstages = JSON.stringify(totalstages)
      droparea.dataset.totalstageinfo = JSON.stringify(totalstageinfo)
      window.FortStorageOverview.TWDS_backup_updateInventory.apply(that, [data])
    }
  })
}
TWDS.fortbuild.addItem = function (id, count) {
  const ret = window.FortStorageOverview.TWDS_backup_addItem.apply(this, [id, count])
  const droparea = TWDS.q1('#fortstoragedrop-' + this.fortId)
  let mats = droparea.dataset.matsneeded
  // console.log('MATS', mats)
  if (mats) mats = JSON.parse(mats)
  const all = TWDS.q('.item_fortstorage', droparea)
  if (!all) return ret
  if (!all.length) return ret
  const last = all[all.length - 1]
  last.dataset.twds_itemid = id
  last.classList.add('TWDS_fortbuild_rs')
  // console.log('MATS', mats)
  if (mats && mats[id / 1000]) {
    const x = TWDS.q1("[data-twds_itemid='" + (id) + "'", droparea)
    // console.log('aI', id, count, x)
    if (x) {
      const c = TWDS.q1('.count-required', x)
      if (c) {
        c.classList.add('TWDS_has_required')
        // console.log('C add', c, c.classList)
        c.textContent = mats[id / 1000]
      }
    }
  }
  return ret
}
TWDS.fortbuild.maxPutInCount = function (item) {
  let x = item.count
  const mc = TWDS.q1('#fortstorage_putin_max_item')
  if (mc && mc.dataset.max) { x = mc.dataset.max }
  $('#fortstorage_popup_input').val(x)
}
TWDS.fortbuild.putin = function (el) {
  console.log('PUTIN', el, el[0].dataset, el.data('itemId'))
  const itemid = el.data('itemId')
  if (!itemid) return

  const bid = Math.round(itemid / 1000)
  const ret = window.FortStorageOverview.TWDS_backup_putin.apply(this, [el])
  const dia = TWDS.q1('.tw2gui_dialog')
  if (!dia) return ret
  const droparea = TWDS.q1('#fortstoragedrop-' + this.fortId)
  if (!droparea) return ret
  let mats = droparea.dataset.matsneeded
  if (!mats) return ret

  if (mats) mats = JSON.parse(mats)
  if (!mats[bid]) return ret
  const total = mats[bid]

  const ele = TWDS.q1(".item_fortstorage[data-twds_itemid='" + itemid + "'", droparea)
  let instore = 0
  if (ele) {
    const countele = TWDS.q1('.count', ele)
    if (countele) {
      instore = parseInt(countele.textContent)
    }
  }
  const max = total - instore
  console.log('MAX', max)

  const mc = TWDS.q1('#fortstorage_putin_max_item')
  if (!mc) return ret
  mc.dataset.max = max
  mc.textContent = '(' + max + ')'
}
TWDS.fortbuild.matinfowindow = function () {
  const fortid = window.FortStorageOverview.fortId
  const droparea = TWDS.q1('#fortstoragedrop-' + fortid)
  if (!droparea) return
  const matsneeded = JSON.parse(droparea.dataset.matsneeded)
  const matstext = JSON.parse(droparea.dataset.matstext)
  const totalstages = JSON.parse(droparea.dataset.totalstages)
  const totalstageinfo = JSON.parse(droparea.dataset.totalstageinfo)
  const w = droparea.closest('.tw2gui_window')
  if (!w) return
  let cash = TWDS.q1('.detail-cash', w)
  if (!cash) {
    cash = 0
  } else {
    cash = parseInt(cash.textContent)
  }

  const wid = 'TWDS_fbmatinfo_window'
  const win = wman.open(wid, 'Matinfo')
  win.setTitle(TWDS._('FORTBUILD_WINDOW_TITLE', 'Resources needed'))
  win.setMiniTitle(TWDS._('FORTBUILD_MINITITLE', 'Needed'))
  const sp = new west.gui.Scrollpane()
  win.appendToContentPane(sp.getMainDiv())

  const content = TWDS.createEle('div')
  const tab = TWDS.createEle('table', { last: content })
  let tr = TWDS.createEle('tr', { last: tab })
  TWDS.createEle('th.item', { last: tr, textContent: TWDS._('FORTBUILD_ITEM', 'Item') })
  TWDS.createEle('th.instock', { last: tr, textContent: TWDS._('FORTBUILD_INSTOCK', 'In Stock') })
  TWDS.createEle('th.brutto', { last: tr, textContent: TWDS._('FORTBUILD_BRUTTO', 'Brutto') })
  TWDS.createEle('th.netto', { last: tr, textContent: TWDS._('FORTBUILD_NETTO', 'Netto') })
  TWDS.createEle('th.info', { last: tr, textContent: TWDS._('FORTBUILD_INFO', 'Info') })
  let chattext = ''
  for (const k of Object.keys(matsneeded)) {
    if (!matsneeded[k]) continue
    const kfull = k * 1000
    const di = TWDS.q1(".item_fortstorage[data-twds_itemid='" + kfull + "']", droparea)

    let count = 0
    if (di) {
      const x = TWDS.q1('.count', di)
      if (x) count = parseInt(x.textContent)
    }
    const netto = matsneeded[k] - count

    TWDS.createEle('tr', { last: tab })
    const it = new tw2widget.Item(ItemManager.getByBaseId(k), 'item_fortstorage')

    it.setCount(count)
    TWDS.createEle('th.item', { last: tab, children: [it.getMainDiv()[0]] })
    TWDS.createEle('td.instock', { last: tab, textContent: count })
    TWDS.createEle('td.brutto', { last: tab, textContent: matsneeded[k] })
    TWDS.createEle('th.netto' + (netto < 0 ? '.overfilled' : ''),
      { last: tab, textContent: netto, style: { verticalAlign: 'top' } })
    const td = TWDS.createEle('td.info', { last: tab, textContent: '' })
    const info = matstext[k]
    for (let i = 0; i < info.length; i++) {
      TWDS.createEle('div', { last: td, textContent: info[i] })
    }
    if (netto > 0) {
      if (chattext > '') chattext += ' + '
      chattext += netto + ' [item=' + kfull + ']'
    }
  }
  tr = TWDS.createEle('tr', { last: tab })
  TWDS.createEle('th.item', { last: tr, textContent: '$' })
  TWDS.createEle('td.instock', { last: tr, textContent: cash })
  const cashbrutto = totalstages * TWDS.fortbuild.dollarper15
  const cashnetto = cashbrutto - cash
  TWDS.createEle('td.brutto', { last: tr, textContent: cashbrutto })
  TWDS.createEle('th.netto' + (cashnetto < 0 ? '.overfilled' : ''), { last: tr, textContent: cashnetto })
  if (cashnetto > 0) {
    if (chattext > '') chattext += ' + '
    chattext += '$' + cashnetto
  }
  const td = TWDS.createEle('td.info', { last: tr, textContent: '' })
  for (let i = 0; i < totalstageinfo.length; i++) {
    if (i === 0) {
      TWDS.createEle('div', {
        last: td,
        textContent: TWDS._('FORTBUILD_ALLSTAGEINFOTOTAL',
          'At least $$mats$ for $nstages$ stages:', {
            mats: cashbrutto,
            nstages: totalstages
          })
      })
    }
    TWDS.createEle('div', {
      last: td,
      textContent: totalstageinfo[i]
    })
  }
  if (chattext > '') {
    TWDS.createEle('h2', {
      last: content,
      textContent: 'Cut & Paste'
    })
    TWDS.createEle('p', {
      last: content,
      textContent: chattext
    })
  } else {
    TWDS.createEle('p', {
      last: content,
      textContent: TWDS._('FORTBUILD_ALLDONE', 'No further resources are needed in this fort.')
    })
  }

  sp.appendContent(content)
}
TWDS.fortbuild.overviewinit = function () {
  window.FortStorageOverview.TWDS_backup_init.apply(this, arguments)
  const fo = TWDS.q1('.tw2gui_window.fortstorage .fortstorage-overview')
  console.log('oi on', fo)
  if (!fo) return
  const b = TWDS.createButton(TWDS._('FORTBUILD_NEEDED', 'Needed'), {
    last: fo,
    onclick: function () {
      TWDS.fortbuild.matinfowindow()
    },
    style: {
      position: 'absolute',
      right: '0px',
      top: '-12px'
    }
  })
  console.log('b is', b)
}

TWDS.fortbuild.startfunc = function () {
  window.FortStorageOverview.TWDS_backup_updateInventory =
    window.FortStorageOverview.TWDS_backup_updateInventory || window.FortStorageOverview.updateInventory
  window.FortStorageOverview.updateInventory = TWDS.fortbuild.updateInventory
  window.FortStorageOverview.TWDS_backup_addItem =
    window.FortStorageOverview.TWDS_backup_addItem || window.FortStorageOverview.addItem
  window.FortStorageOverview.addItem = TWDS.fortbuild.addItem
  window.FortStorageOverview.TWDS_backup_putin =
    window.FortStorageOverview.TWDS_backup_putin || window.FortStorageOverview.putin
  window.FortStorageOverview.putin = TWDS.fortbuild.putin
  window.FortStorageOverview.TWDS_backup_maxPutInCount =
    window.FortStorageOverview.TWDS_backup_maxPutInCount || window.FortStorageOverview.maxPutInCount
  window.FortStorageOverview.maxPutInCount = TWDS.fortbuild.maxPutInCount
  window.FortStorageOverview.TWDS_backup_init =
    window.FortStorageOverview.TWDS_backup_init || window.FortStorageOverview.init
  window.FortStorageOverview.init = TWDS.fortbuild.overviewinit
}
TWDS.registerStartFunc(TWDS.fortbuild.startfunc)
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.playerlistwindow = {}
TWDS.playerlistwindow.output = function (players) {
  console.log('players', players)
  const ba = {}
  const bt = {}
  for (let i = 0; i < players.length; i++) {
    const p = players[i]
    const t = p.town_id || 0
    const T = p.town_name
    const a = p.alliance_id || 0
    const l = p.level
    const c = p.class
    if (!(a in ba)) {
      ba[a] = {
        id: a,
        players: 0,
        levels: 0,
        duelist: 0,
        worker: 0,
        soldier: 0,
        adventurer: 0,
        greenhorn: 0
      }
    }
    if (!(t in bt)) {
      bt[t] = {
        id: t,
        town_name: T,
        alliance_id: a,
        players: 0,
        levels: 0,
        duelist: 0,
        worker: 0,
        soldier: 0,
        adventurer: 0,
        greenhorn: 0
      }
    }
    ba[a].players++
    ba[a].levels += l
    ba[a][c]++
    bt[t].players++
    bt[t].levels += l
    bt[t][c]++
  }
  console.log(ba)
  console.log(bt)

  const tab = TWDS.createEle('table')
  const thead = TWDS.createEle('thead', { last: tab })
  const tr = TWDS.createEle('tr.alliance', { last: thead })
  TWDS.createEle('td', { last: tr, textContent: TWDS._('C_TOWN', 'town') })
  TWDS.createEle('td', { last: tr, textContent: TWDS._('C_ALLIANCE', 'alliance') })
  TWDS.createEle('td', { last: tr, textContent: TWDS._('C_PLAYERS', 'players') })
  TWDS.createEle('td', { last: tr, textContent: TWDS._('PLAYERLISTWINDOW_AVG_LV', 'avg. lv') })
  TWDS.createEle('td', { last: tr, textContent: Game.InfoHandler.getLocalString4Charclass('adventurer') })
  TWDS.createEle('td', { last: tr, textContent: Game.InfoHandler.getLocalString4Charclass('duelist') })
  TWDS.createEle('td', { last: tr, textContent: Game.InfoHandler.getLocalString4Charclass('soldier') })
  TWDS.createEle('td', { last: tr, textContent: Game.InfoHandler.getLocalString4Charclass('worker') })
  TWDS.createEle('td', { last: tr, textContent: Game.InfoHandler.getLocalString4Charclass('greenhorn') })

  const tbody = TWDS.createEle('tbody', { last: tab })
  let delay = 100
  for (const a of Object.values(ba)) {
    const tr = TWDS.createEle('tr.allianceline', { last: tbody })
    TWDS.createEle('td', {
      last: tr,
      textContent: a.id ? TWDS._('C_ALL', 'all') : TWDS._('PLAYERLISTWINDOW_ANY', 'any / no town'),
      style: { color: 'red' }
    })
    TWDS.createEle('td.name.alliance_' + a.id, {
      last: tr,
      textContent: a.id,
      dataset: { alliance_id: a.id }
    })
    TWDS.createEle('td.players', {
      last: tr,
      textContent: a.players
    })
    TWDS.createEle('td.level', {
      last: tr,
      textContent: (a.levels / a.players).toFixed(1)
    })
    TWDS.createEle('td.adventurer', { last: tr, textContent: a.adventurer })
    TWDS.createEle('td.duelist', { last: tr, textContent: a.duelist })
    TWDS.createEle('td.soldier', { last: tr, textContent: a.soldier })
    TWDS.createEle('td.worker', { last: tr, textContent: a.worker })
    TWDS.createEle('td.greenhorn', { last: tr, textContent: a.greenhorn })
  }
  const adone = {}
  let firsttownline = true
  for (const t of Object.values(bt)) {
    const tr = TWDS.createEle('tr.townline' + (firsttownline ? '.first' : ''), { last: tbody })
    firsttownline = false
    const td = TWDS.createEle('td.name.town_' + t.id, {
      last: tr,
      textContent: t.town_name
    })
    if (t.id === 0) {
      td.textContent = TWDS._('PLAYERLISTWINDOW_NOTOWN', 'no town')
      td.style.color = 'red'
    }
    TWDS.createEle('td.alliance.alliance_' + t.alliance_id, {
      last: tr,
      textContent: t.alliance_id,
      dataset: { alliance_id: t.alliance_id }
    })
    TWDS.createEle('td.players', {
      last: tr,
      textContent: t.players
    })
    TWDS.createEle('td.level', {
      last: tr,
      textContent: (t.levels / t.players).toFixed(1)
    })
    TWDS.createEle('td.adventurer', { last: tr, textContent: t.adventurer })
    TWDS.createEle('td.duelist', { last: tr, textContent: t.duelist })
    TWDS.createEle('td.soldier', { last: tr, textContent: t.soldier })
    TWDS.createEle('td.worker', { last: tr, textContent: t.worker })
    TWDS.createEle('td.greenhorn', { last: tr, textContent: t.greenhorn })
    const a = t.alliance_id
    if (!(a in adone)) {
      adone[a] = 1
      if (a) {
        setTimeout(function () {
          Ajax.remoteCallMode('alliance', 'get_data', {
            alliance_id: a
          }, function (r) {
            console.log('AGD', a, r)
            if (r.error === false && r.data && r.data.allianceName) {
              TWDS.q('.alliance_' + a, tab).forEach(function (ele) {
                ele.textContent = r.data.allianceName
              })
            }
          })
        }, delay)
        delay += 350
      }
    }
  }
  TWDS.q('.alliance_0', tab).forEach(function (ele) {
    ele.textContent = TWDS._('PLAYERLISTWINDOW_NOALLIANCE', 'no alliance')
    ele.style.color = 'red'
  })

  const wid = 'TWDS_playerliststat'
  const win = wman.open(wid, 'playerliststat')
  win.setTitle(TWDS._('PLAYERLISTWINDOW_STAT_TITLE', 'Summary of players at this location'))
  const sp = new west.gui.Scrollpane()
  sp.appendContent(tab)
  win.appendToContentPane(sp.getMainDiv())
}
TWDS.playerlistwindow.doit = function (page, players) {
  Ajax.remoteCallMode('players', 'get_data', {
    x: window.PlayerlistWindow.x,
    y: window.PlayerlistWindow.y,
    sortby: window.PlayerlistWindow.sort,
    page: page
  }, function (json) {
    if (json.error) return new UserMessage(json.error, UserMessage.TYPE_ERROR).show()
    console.log('json', json)
    for (let i = 0; i < json.players.length; i++) {
      players.push(json.players[i])
    }
    page++
    if (page < json.pages) {
      TWDS.playerlistwindow.doit(page, players)
      return
    }
    TWDS.playerlistwindow.output(players)
    // PlayerlistWindow.updateData(json);
  }, window.PlayerlistWindow)
}
TWDS.playerlistwindow.open = function () {
  console.log('test', this, arguments)
  window.PlayerlistWindow.TWDS_backup_open.apply(this, arguments)
  const dom = this.DOM[0]
  const tbar = TWDS.q1('.tw2gui_inner_window_title', dom)
  console.log('tbar', tbar)
  const that = this
  TWDS.createEle('div.TWDS_playerlistwindow_extra.linklike', {
    last: tbar,
    textContent: TWDS._('PLAYERLISTWINDOW_SUMMARY', 'Summary'),
    style: {
      position: 'absolute',
      right: '8px',
      top: '35px',
      padding: '2px',
      border: '1px solid #888',
      borderRadius: '8px',
      backgroundColor: '#400',
      color: 'white'
    },
    onclick: function () {
      console.log('that', that)
      TWDS.playerlistwindow.doit(0, [])
    }
  })
}
TWDS.playerlistwindow.startfunc = function () {
  window.PlayerlistWindow.TWDS_backup_open = window.PlayerlistWindow.TWDS_backup_open || window.PlayerlistWindow.open
  window.PlayerlistWindow.open = TWDS.playerlistwindow.open
}

TWDS.registerStartFunc(TWDS.playerlistwindow.startfunc)
// vim: tabstop=2 shiftwidth=2 expandtab
if (TWDS.nextaction && TWDS.nextaction.start) {
  TWDS.nextaction.start(true)
}
TWDS.nextaction = {}
TWDS.nextaction.taskqueue = function () {
  if (!TaskQueue.queue.length) {
    return []
  }
  const e = TaskQueue.queue[TaskQueue.queue.length - 1]
  return [e.data.date_done / 1000.0, 'TaskQueue']
}
TWDS.nextaction.events = function () {
  const now = new Date().getTime() / 1000.0
  const wofs = west.wof.WofManager.wofs
  if ('easterwof' in wofs && 'mode' in wofs.easterwof && 'cooldowns' in wofs.easterwof.mode) {
    let next = 0
    let nexttitle = ''
    const all = []
    const m = wofs.easterwof.mode
    for (const t of Object.values(m.cooldowns)) {
      if (t.cdstamp && t.cdstamp > now) {
        all.push([t.cdstamp, wofs.easterwof.title + ' (' + m.opponentNames[t.enhance] + ')']) // 0, 25
        if (t.cdstamp < next || next === 0) {
          next = t.cdstamp
          nexttitle = wofs.easterwof.title + ' (' + m.opponentNames[t.enhance] + ')'
        }
      }
    }
    if (next) {
      return [next, nexttitle, all]
    }
  }
  return []
}
TWDS.nextaction.items = function () {
  const now = new Date().getTime() / 1000.0
  let min = -1
  let mintext = ''
  const all = []
  for (const [id, t] of Object.entries(Bag.itemCooldown)) {
    if (!Bag.getItemByItemId(id)) continue
    if (t > now) {
      if (min === -1 || t < min) {
        min = t
        mintext = ItemManager.get(id).name
      }
      all.push([t, ItemManager.get(id).name])
    }
  }
  if (min === -1) { return [] }
  return [min, mintext, all]
}
TWDS.nextaction.friendscache = null
TWDS.nextaction.friends = function () {
  if (TWDS.nextaction.friendscache) {
    return TWDS.nextaction.friendscache
  }
  const p = new Promise(function (resolve, reject) {
    Ajax.remoteCallMode('friendsbar', 'search', { search_type: 'friends' }, function (json) {
      if (json.error) {
        reject(json.msg)
      }
      const f = {}
      const q = json.players
      for (let i = 0; i < q.length; i++) {
        f[q[i].player_id] = q[i]
      }

      const a = json.eventActivations
      const now = new Date().getTime() / 1000.0
      let mintime = -1
      let minfr = -1
      const stamps = {}
      for (let i = 0; i < a.length; i++) {
        const e = a[i]
        const fr = e.friend_id
        if (!(fr in f)) {
          continue // not in friend list
        }

        const t = e.activation_time + 23 * 3600
        if (t > now) {
          if (mintime === -1 || mintime > t) {
            mintime = t
            minfr = fr
          }
          const ts = Math.ceil(t)
          if (!stamps[ts]) { stamps[ts] = [] }
          stamps[ts].push(f[fr].name)
        }
      }
      const all = []
      for (let [ts, names] of Object.entries(stamps)) {
        const n = names.length
        if (n > 5) {
          names = names.splice(0, 5)
          names.push(n + ' total')
        }
        all.push([ts, names.join(', ')])
      }
      if (minfr === -1) {
        TWDS.nextaction.friendscache = []
        resolve([])
        return
      }
      TWDS.nextaction.friendscache = [mintime, 'Friend ' + f[minfr].name, all]
      resolve(TWDS.nextaction.friendscache)
    })
  })
  return p
}
TWDS.nextaction.get = function (ele, tbody) {
  const a = ['taskqueue', 'friends', 'items', 'events']
  const plist = []
  for (let i = 0; i < a.length; i++) {
    const t = TWDS.nextaction[a[i]]()
    plist.push(t)
  }
  Promise.all(plist).then(function (d) {
    let min = -1
    let mintext = ''
    if (tbody) {
      // all results!
      const tmp = []
      for (let i = 0; i < d.length; i++) {
        const e = d[i]
        if (e[2]) {
          for (let j = 0; j < e[2].length; j++) {
            tmp.push(e[2][j])
          }
        } else {
          tmp.push(e)
        }
      }
      d = tmp
    }
    d.sort(function (a, b) {
      if (a.length === 0) return 1
      if (b.length === 0) return -1
      return a[0] - b[0]
    })
    for (let i = 0; i < d.length; i++) {
      const e = d[i]
      if (e.length === 0) continue
      if (min === -1 || e[0] < min) {
        min = e[0]
        mintext = e[1]
      }
      if (tbody) {
        const tr = TWDS.createEle('tr', { last: tbody })
        TWDS.createEle('td', {
          last: tr,
          textContent: new Date(parseInt(e[0]) * 1000).toDateTimeStringNice()
        })
        TWDS.createEle('td', {
          last: tr,
          textContent: e[1]
        })
      }
    }
    if (ele) {
      if (min > 86400) {
        ele.textContent = new Date(parseInt(min) * 1000).toDateTimeStringNice()
        ele.title = mintext
      } else {
        ele.textContent = ''
        ele.title = ''
      }
    }
  })
}
TWDS.nextaction.update = function (remove) {
  let ele = TWDS.q1('#ui_bottomright #TWDS_nextaction')
  if (ele) {
    ele.remove()
    ele = null
  }
  if (!TWDS.settings.taskqueue_nextaction) { return }
  if (!ele) {
    ele = TWDS.createEle('div.linklike', {
      last: TWDS.q1('#ui_bottomright'),
      id: 'TWDS_nextaction',
      textContent: 'text',
      onclick: function () {
        TWDS.nextaction.openwindow()
      }
    })
  }
  TWDS.nextaction.get(ele)
}
TWDS.nextaction.openwindow = function () {
  const win = wman.open('TWDS_nextaction_window', 'Nextaction')
  win.setMiniTitle('Next')

  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_nextaction_container'
  })
  sp.appendContent(content)
  win.appendToContentPane(sp.getMainDiv())
  const table = TWDS.createEle('table.TWDS_simpleborder', { beforeend: content })
  const tbody = TWDS.createEle('tbody', { beforeend: table })
  TWDS.nextaction.get(null, tbody)
}
TWDS.nextaction.timeout = 0
TWDS.nextaction.queueupdate = function () {
  if (TWDS.nextaction.timeout) { window.clearTimeout(TWDS.nextaction.timeout) }
  TWDS.nextaction.timeout = window.setTimeout(TWDS.nextaction.update, 2000)
}
// ajaxComplete handler
TWDS.nextaction.ajaxcomplete = function (event, request, settings) {
  const url = settings.url
  if (url.includes('window=friendsbar')) {
    if (url.includes('action=event')) {
      TWDS.nextaction.friendscache = null // invalidate
      TWDS.nextaction.queueupdate()
    }
  }
}
TWDS.nextaction.start = function (remove) {
  TWDS.registerSetting('bool', 'taskqueue_nextaction',
    TWDS._('TASKQUEUE_NEXTACTION_SETTING', 'Mostrar, debajo de la cola de tareas, la hora de la siguiente acción manual.'), true, function (v) {
      TWDS.nextaction.update(!v)
    }, 'Cola de Tareas')
  let fn = 'listen'
  let fn2 = 'on'
  if (remove) {
    fn = 'unlisten'
    fn2 = 'off'
  }
  EventHandler[fn]('cooldown_changed', TWDS.nextaction.queueupdate)
  EventHandler[fn]('taskqueue-updated', TWDS.nextaction.queueupdate)
  EventHandler[fn]('taskqueue-task-adding', TWDS.nextaction.queueupdate)
  EventHandler[fn]('taskqueue-task-canceling', TWDS.nextaction.queueupdate)
  $(document)[fn2]('ajaxComplete', TWDS.nextaction.ajaxcomplete)
  setTimeout(TWDS.nextaction.queueupdate, 5000)
  console.log('nextaction started')
}
TWDS.registerStartFunc(TWDS.nextaction.start)
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.upshop = {}
TWDS.upshop.shoprender = function () {
  const thing = west.game.shop.item.view.prototype.TWDS_backup_render.apply(this)
  // console.log('shoprender', thing, this, this.getModel(), this.getModel().getId())
  const model = this.getModel()
  const iid = model.getId()
  const it = ItemManager.get(iid)
  if (TWDS.settings.upshop_show_count) {
    const have = Bag.getItemsByBaseItemId(it.item_base_id)
    let n = 0
    if (have && have[0]) {
      // go threw all leveled items..
      for (let i = 0; i < have.length; i++) {
        n += have[i].getCount()
      }
    }
    const worn = Wear.wear[it.type]
    if (worn) {
      if (worn.obj.item_base_id === it.item_base_id) { n++ }
    }
    if (n) {
      TWDS.createEle('div.TWDS_upshop_count', {
        textContent: n,
        last: thing[0],
        title: TWDS._('UPSHOP_COUNT_TITLE', 'The number of items you own')
      })
    }
  }
  if (TWDS.collections.isMissing(iid)) {
    TWDS.createEle('div.TWDS_upshop_collection.TWDS_collection_missing', {
      textContent: '',
      last: thing[0],
      title: TWDS._('UPSHOP_COLLECTION_TITLE', 'This item is needed to complete a collection')
    })
  }
  return thing
}
TWDS.upshop.startfunc = function () {
  west.game.shop.item.view.prototype.TWDS_backup_render = west.game.shop.item.view.prototype.TWDS_backup_render || west.game.shop.item.view.prototype.render
  west.game.shop.item.view.prototype.render = TWDS.upshop.shoprender

  TWDS.registerSetting('bool', 'upshop_show_count',
    TWDS._('UPSHOP_SETTING_SHOW_COUNT', 'En la tienda UPC mostrar el número de artículos poseídos.'), true, null, 'Mercado, tiendas y comerciantes', 'Union Pacific Shop')
  TWDS.registerSetting('bool', 'upshop_show_collections',
    TWDS._('UPSHOP_SETTING_SHOW_COLLECTIONS', 'En la tienda UPC marcar los artículos que nos faltan en las colecciones.'), true, null, 'Mercado, tiendas y comerciantes', 'Union Pacific Shop')
}

if (TWDS.didstartfuncs) {
  TWDS.upshop.startfunc()
} else {
  TWDS.registerStartFunc(TWDS.upshop.startfunc)
}

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.ghosttowns = {}
TWDS.ghosttowns.openwindow = function () {
  if (window.localStore4Minimap.minimapData === null) {
    MinimapWindow.open()
    setTimeout(TWDS.ghosttowns.openwindow, 1000)
    return
  }
  const win = wman.open('TWDS_ghosttowns_window', TWDS._('GHOSTTOWNS_WIN_TITLE', 'Ciudades fantasma'))
  win.setMiniTitle(TWDS._('GHOSTTOWNS_MINI_TITLE', 'Ciudades fantasma'))

  const sp = new west.gui.Scrollpane()
  const content = TWDS.createEle('div', {
    className: 'TWDS_ghosttowns_container'
  })
  const table1 = TWDS.createEle('table', { beforeend: content })
  const thead1 = TWDS.createEle('thead', { beforeend: table1 })
  const table2 = TWDS.createEle('table', { beforeend: content })
  const thead2 = TWDS.createEle('thead', { beforeend: table2 })
  TWDS.createEle({
    last: thead1,
    nodeName: 'tr',
    children: [
      { nodeName: 'th.name', textContent: TWDS._('GHOSTTOWNS_TOWN_NAME', 'Name') },
      { nodeName: 'th.points', textContent: TWDS._('GHOSTTOWNS_TOWN_POINTS', 'Points') },
      { nodeName: 'th.pos', textContent: TWDS._('GHOSTTOWNS_TOWN_POS', 'Position') }
    ]
  })
  TWDS.createEle({
    last: thead2,
    nodeName: 'tr',
    children: [
      { nodeName: 'th.name', textContent: TWDS._('GHOSTTOWNS_TOWN_NAME', 'Name') },
      { nodeName: 'th.points', textContent: TWDS._('GHOSTTOWNS_TOWN_POINTS', 'Points') },
      { nodeName: 'th.pos', textContent: TWDS._('GHOSTTOWNS_TOWN_POS', 'Position') }
    ]
  })

  const tbody1 = TWDS.createEle('tbody', { beforeend: table1 })
  const tbody2 = TWDS.createEle('tbody', { beforeend: table2 })

  const a = []
  for (let i = 0; i < window.localStore4Minimap.minimapData.ghostTowns.length; i++) {
    const t = window.localStore4Minimap.minimapData.ghostTowns[i]
    a.push(t)
  }
  a.sort(function (x, y) {
    const t = x.town_points - y.town_points
    if (t) return t
    return x.town_id - y.town_id
  })

  const append = function (pa, t) {
    TWDS.createEle({
      nodeName: 'tr',
      last: pa,
      children: [
        { nodeName: 'td.name', textContent: t.name > '' ? t.name : t.town_id },
        { nodeName: 'td.points', textContent: t.town_points },
        {
          nodeName: 'td.pos.linklike',
          textContent: t.x + '-' + t.y,
          title: TWDS._('GHOSTTOWNS_CENTER', 'Center town on the map'),
          onclick: function () {
            Map.center(t.x, t.y)
          }
        }
      ]
    })
  }
  const n = 50
  for (let i = 0, found = 0; i < a.length && found < n; i++) {
    if (a[i].npctown) continue
    found++
    append(tbody1, a[i])
  }
  for (let i = a.length - 1, found = 0; i >= 0 && found < n; i--) {
    if (a[i].npctown) continue
    found++
    append(tbody2, a[i])
  }
  TWDS.createEle('p', {
    content: 'This list can help you to find a town to build (left half) or a well build town to live in (right half).'
  })

  sp.appendContent(content)

  win.appendToContentPane(sp.getMainDiv())
}
TWDS.registerExtra('TWDS.ghosttowns.openwindow',
  TWDS._('GHOSTTOWNS_TITLE', 'Ciudades fantasma'),
  TWDS._('GHOSTTOWNS_DESC', 'Muestra ciudades fantasma con mayores/menores puntos de construcción.'))
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.duelmap = {}
TWDS.duelmap.data = {}
TWDS.duelmap.timestamp = 0
TWDS.duelmap.validseconds = 900 // 15 minutes

TWDS.duelmap.win = null
TWDS.duelmap.distancelimit = 10
TWDS.duelmap.playerlimit = 100
TWDS.duelmap.lastpageloaded = 0
TWDS.duelmap.morelimit = 20
TWDS.duelmap.friends = {}
TWDS.duelmap.friendsage = 0

TWDS.duelmap.forcetablesort = function () {
  if ('TWDS_duelmap_last_order_mult' in localStorage) {
    if ('TWDS_duelmap_last_order_sel' in localStorage) {
      const tab = TWDS.q1('table.TWDS_opponents', TWDS.duelmap.win.divMain)
      const sel = localStorage.TWDS_duelmap_last_order_sel
      const mul = parseInt(localStorage.TWDS_duelmap_last_order_mult)
      const toclick = TWDS.q1("thead th[data-colsel='" + sel + "'", tab)
      TWDS.sortable.doReal(toclick, mul)
    }
  }
}
TWDS.duelmap.history = function (id, name) {
  const d = TWDS.people.getbyname(name)
  if (!d) return
  const wid = 'TWDS_duelmap_history_' + id
  const win = TWDS.utils.stdwindow(wid, name, name)
  const container = TWDS.utils.getcontainer(win)
  container.innerHTML = ''
  TWDS.appendSubtable(container, d, name)
  TWDS.q('.tw2gui_window.TWDS_duelmap_history_' + id + ' .openreport').forEach(function (ele) {
    ele.classList.add('linklike')
    ele.onclick = function () {
      const hash = this.dataset.hash
      const rid = this.dataset.report_id
      ReportWindow.open(rid, hash, 0)
    }
  })
}

TWDS.duelmap.update = function (name) {
  const data = TWDS.duelmap.data[name]
  const container = TWDS.q1('.tw2gui_window_content_pane > div.duels-TWDS_DUELMAP_CONTAINER')
  const tbody = TWDS.q1('table tbody', container)

  // cleanup, this might be an update
  let old = TWDS.q1('.TWDS_pline_' + data.player_id, tbody)
  if (old) {
    old.remove()
    console.log('removed', name)
  }
  old = TWDS.q1('.TWDS_pbox_' + data.player_id, TWDS.duelmap.map)
  if (old) { old.remove() }

  let color = 'red'
  if (TWDS.duelmap.friends[data.player_id]) {
    color = '#0a0'
  }
  const box = TWDS.maphelper.drawbox(TWDS.duelmap.map, data.character_x, data.character_y, 6,
    name, color, 0, 'player linklike')
  box.onclick = function () {
    window.PlayerProfileWindow.open(data.player_id)
  }

  const tr = TWDS.createEle('tr', { last: tbody })
  tr.classList.add('TWDS_pline_' + data.player_id)

  box.onmouseenter = function () {
    tr.style.outline = '1px solid white'
  }
  box.onmouseleave = function () {
    tr.style.outline = 'none'
  }

  const nele = TWDS.createEle('th.linklike.name', {
    last: tr,
    textContent: name,
    onclick: function () {
      window.PlayerProfileWindow.open(data.player_id)
    },
    onmouseenter: function () {
      box.style.outline = '1px solid white'
    },
    onmouseleave: function () {
      box.style.outline = 'none'
    }
  })
  const getage = function (str) {
    try {
      const m = str.match(/^([0-9]+)-([0-9]+)-([0-9]+)$/)
      const then = new Date(m[1], parseInt(m[2]) - 1, m[3]).getTime()
      const now = new Date().getTime()
      const h = (now - then) / (3600 * 24 * 1000)
      return Math.round(h) + 'd'
    } catch (e) {
      console.error('getage', str, 'caused', e)
      return '???'
    }
  }
  if (TWDS.duelmap.friends[data.player_id]) {
    nele.classList.add('friend')
    nele.title = TWDS._('C_FRIEND', 'Friend')
  }
  const histdata = TWDS.people.getbyname(name)
  if (histdata) {
    let last = -1
    let lastcmp = ''
    for (let i = 0; i < histdata.list.length; i++) {
      if (last === -1) {
        lastcmp = histdata.list[i].cmpdate
        last = i
      } else {
        if (histdata.list[i].cmpdate.localeCompare(lastcmp) > 0) {
          last = i
          lastcmp = histdata.list[i].cmpdate
        }
      }
    }

    TWDS.createEle('td.hist', {
      last: tr,
      textContent: getage(lastcmp),
      dataset: { debug: JSON.stringify(TWDS.duelmap.data[name]), sortval: lastcmp },
      onclick: function () {
        TWDS.duelmap.history(data.player_id, name)
        console.log('debug', JSON.parse(this.dataset.debug))
      }
    })
  } else {
    TWDS.createEle('td.hist', { last: tr, dataset: { sortval: '1970-01-01' } })
  }
  TWDS.createEle('td.linklike.town', {
    last: tr,
    textContent: data.town_name,
    onclick: function () {
      TownWindow.open(data.town_x, data.town_y)
    }
  })

  let alli = ''
  let ti = ''
  const aid = data.alliance_id
  alli = TWDS.alliances.id2name[aid] || ''
  if (alli === '' && !TWDS.alliances.ready) {
    alli = aid
    ti = 'alliance names not loaded'
  }
  const aele = TWDS.createEle('td.alliance', { last: tr, textContent: alli, title: ti })
  if (aid) {
    aele.classList.add('linklike')
    aele.onclick = function () {
      AllianceWindow.open(aid)
    }
  }
  TWDS.createEle('td.level', { last: tr, textContent: data.level })
  TWDS.createEle('td.duellevel', { last: tr, textContent: data.duellevel })
  const dxp = Math.round((7 * data.duellevel - 5 * Character.duelLevel + 5) * Character.duelMotivation)
  const dxp100 = Math.round((7 * data.duellevel - 5 * Character.duelLevel + 5))
  TWDS.createEle('td.xp', {
    last: tr,
    textContent: dxp,
    title: TWDS._('TWDS_DUELMAP_XPINFO',
      '$dxp$ duel xp (or $ldxp$ in case you lose), $xp$ char xp (win only).<br>' +
      '$dxp100$ duell xp (or $ldxp100$), $xp100$ char xp, With 100% duell motivation.<br>' +
      'The char xp sum is increased by the item/itemset XP bonus.', {
        dxp: dxp,
        ldxp: Math.round(-dxp / 6),
        xp: dxp * 6,
        dxp100: dxp100,
        ldxp100: Math.round(-dxp100 / 6),
        xp100: dxp100 * 6
      }
    )

  })
  TWDS.createEle('td.class', { last: tr, textContent: data.class })
  const mypos = Map.getLastQueuePosition()
  const wt = window.Map.calcWayTime(mypos, {
    x: data.character_x,
    y: data.character_y
  }).formatDuration()
  const dist = Math.sqrt((data.character_x - mypos.x) * (data.character_x - mypos.x) + (data.character_y - mypos.y) * (data.character_y - mypos.y))
  TWDS.createEle('td.linklike.wt', {
    last: tr,
    innerHTML: wt,
    dataset: { sortval: dist },
    onclick: function () {
      Map.center(data.character_x, data.character_y)
    }

  })
}

TWDS.duelmap.updatestatus = function () {
  let e = TWDS.q1('span.loaded', TWDS.duelmap.win.divMain)
  if (e) {
    const n = Object.keys(TWDS.duelmap.data).length
    console.log('US', n, 'loaded')
    e.textContent = n + ' loaded'
  }
  e = TWDS.q1('span.loaddate', TWDS.duelmap.win.divMain)
  if (e) {
    e.textContent = TWDS.duelmap.timestamp.getFormattedTimeString4Timestamp()
  }
}

TWDS.duelmap.runplayersloaded = 0
TWDS.duelmap.runplayersmax = TWDS.duelmap.pagesperrun
TWDS.duelmap.getdata = function (mode) {
  const ts = (new Date()).getTime() / 1000
  if (mode === 'normal') {
    if (ts > TWDS.duelmap.friendsage) {
      TWDS.duelmap.friendsage = ts + 3600
      Ajax.remoteCallMode('friendsbar', 'search', { search_type: 'friends' },
        function (response) {
          if (response.error) {
            return new UserMessage(response.msg).show()
          }
          TWDS.duelmap.friends = {}
          for (let i = 0; i < response.players.length; i++) {
            const p = response.players[i]
            const n = p.name
            const id = p.player_id
            TWDS.duelmap.friends[id] = n
          }
          TWDS.duelmap.getdata(mode)
        })
      return
    }
  }
  if (TWDS.duelmap.runplayersloaded >= TWDS.duelmap.runplayersmax) {
    console.log('stopping, loaded ', TWDS.duelmap.runplayersloaded, '>=', TWDS.duelmap.runplayersmax)
    TWDS.duelmap.win.hideLoader()
    TWDS.duelmap.updatestatus()
    TWDS.duelmap.forcetablesort()
    return
  }
  let distlimit = TWDS.duelmap.distancelimit ? TWDS.duelmap.distancelimit * 60 : 6 * 3600 * 60
  if (mode === 'more') { distlimit = 6 * 3600 * 60 }
  Ajax.remoteCall('duel', 'search_op', {
    next: true,
    order_by: 'ASC',
    sort: 'range',
    page: TWDS.duelmap.lastpageloaded,
    distance: distlimit
  }, function (json) {
    TWDS.duelmap.lastpageloaded++
    const l = json.oplist.pclist.length
    for (let i = 0; i < l; i++) {
      const p = json.oplist.pclist[i].player_name
      TWDS.duelmap.runplayersloaded++
      TWDS.duelmap.data[p] = json.oplist.pclist[i]
      TWDS.duelmap.update(p)
    }
    if (json.oplist.next) {
      if (TWDS.duelmap.pagesloaded % 10 === 0) {
        setTimeout(TWDS.duelmap.getdata, 1000, mode)
      } else if (TWDS.duelmap.pagesloaded % 4 === 0) {
        setTimeout(TWDS.duelmap.getdata, 100, mode)
      } else {
        setTimeout(TWDS.duelmap.getdata, 50, mode)
      }
    } else {
      TWDS.duelmap.win.hideLoader()
      TWDS.duelmap.updatestatus()
      TWDS.duelmap.forcetablesort()
    }
  })
}
TWDS.duelmap.showTab = function (id) {
  window.DuelsWindow.TWDS_backup_showTab.call(this, id)
  window.DuelsWindow.window.removeClass('noreload').setSize(748, 472)
}

TWDS.duelmap.myshowtab = function (win, id) {
  TWDS.duelmap.win = win
  console.log('win', win, 'id', id)
  win.addClass('nocloseall noreload')
  win.dontCloseAll = true
  win.setTitle(TWDS._('DUELMAP', 'Duelmap'))
  win.activateTab(id)
  win.setSize(749, 655)
  const main = win.getMainDiv()
  console.log('main', main)
  console.log('active', TWDS.q('.tw2gui_window_tab_active', main))
  TWDS.q('.tw2gui_window_tab_active', main).forEach(function (ele) {
    ele.classList.remove('.tw2gui_window_tab_active')
  })
  TWDS.q1('.tw2gui_window_tab._tab_id_TWDS_DUELMAP', main).classList.add('.tw2gui_window_tab_active')
  TWDS.q('.tw2gui_window_content_pane > div', main).forEach(function (ele) {
    ele.style.display = 'none'
  })
  const container = TWDS.q1('.tw2gui_window_content_pane > div.duels-TWDS_DUELMAP_CONTAINER', main)
  container.style.display = 'block'
  container.innerHTML = ''
  const map = TWDS.maphelper.getmap(1.36)
  TWDS.duelmap.map = map
  TWDS.maphelper.drawme(TWDS.duelmap.map)

  container.appendChild(map)

  const sp = new west.gui.Scrollpane()
  console.log('sp', sp)
  const spmain = sp.getMainDiv()
  spmain.style.height = '245px'
  container.appendChild(spmain)
  const p = TWDS.createEle('p')

  TWDS.createEle('span.loaded', { last: p, textContent: '' })

  const more = TWDS.createButton(TWDS._('DUELMAP_MORE', 'more'), { last: p })
  more.onclick = function () {
    TWDS.duelmap.runplayersmax = TWDS.duelmap.morelimit
    TWDS.duelmap.runplayersloaded = 0
    TWDS.duelmap.win.showLoader()
    TWDS.duelmap.getdata('more')
  }

  TWDS.createEle('span.loaddate', { last: p, textContent: '' })
  const newsearch = TWDS.createButton(TWDS._('DUELMAP_NEWSEARCH', 'new search'), { last: p })

  const sel = TWDS.createEle('select.waytime', { last: p })
  const cur = parseInt(localStorage.TWDS_duelmap_filter_waytime) || 10
  TWDS.duelmap.distancelimit = cur
  TWDS.createEle('option', {
    last: sel,
    value: '10',
    textContent: TWDS._('DUELMAP_10m', '10 minutes'),
    selected: cur === 10
  })
  TWDS.createEle('option', {
    last: sel,
    value: '15',
    textContent: TWDS._('DUELMAP_15m', '15 minutes'),
    selected: cur === 15
  })
  TWDS.createEle('option', {
    last: sel,
    value: '30',
    textContent: TWDS._('DUELMAP_30m', '30 minutes'),
    selected: cur === 30
  })
  TWDS.createEle('option', {
    last: sel,
    value: '60',
    textContent: TWDS._('DUELMAP_60m', '60 minutes'),
    selected: cur === 60
  })
  TWDS.createEle('option', {
    last: sel,
    value: '120',
    textContent: TWDS._('DUELMAP_120m', '120 minutes'),
    selected: cur === 120
  })
  TWDS.createEle('option', {
    last: sel,
    value: '0',
    textContent: TWDS._('DUELMAP_UNLIMITED', '-- no limit --'),
    selected: cur === 0
  })
  sel.onchange = function () {
    localStorage.TWDS_duelmap_filter_waytime = this.value
    TWDS.duelmap.distancelimit = parseInt(this.value)
  }
  const sel2 = TWDS.createEle('select.wantplayers', { last: p })
  const cur2 = parseInt(localStorage.TWDS_duelmap_filter_wantplayers) || 100
  TWDS.duelmap.playerlimit = cur2
  for (let i = 20; i <= 200; i += 20) {
    TWDS.createEle('option', { last: sel2, value: i, textContent: i, selected: i === cur2 })
  }
  sel2.onchange = function () {
    localStorage.TWDS_duelmap_filter_wantplayers = this.value
    TWDS.duelmap.playerlimit = parseInt(this.value)
  }

  sp.appendContent(p)

  const tab = TWDS.createEle('table.TWDS_simpleborder.TWDS_opponents', {
    dataset: { TWDS_ordersavekey: 'TWDS_duelmap_last_order' }
  })
  sp.appendContent(tab)
  const thead = TWDS.createEle('thead', { last: tab })
  const tr = TWDS.createEle('tr', { last: thead })
  TWDS.createEle('th.linklike.name', {
    last: tr,
    textContent: TWDS._('C_NAME', 'Name'),
    dataset: { colsel: '.name' },
    onclick: TWDS.sortable.do
  })
  TWDS.createEle('th.linklike', {
    last: tr,
    textContent: TWDS._('DUELMAP_WHEN', 'When'),
    title: TWDS._('DUELMAP_WHEN_TITLE', 'Last duel ... days ago'),
    dataset: { colsel: '.hist', secondcolel: '.name' },
    onclick: TWDS.sortable.do
  })
  TWDS.createEle('th.linklike', {
    last: tr,
    textContent:
    TWDS._('C_TOWN', 'Town'),
    dataset: { colsel: '.town', secondcolsel: '.name' },
    onclick: TWDS.sortable.do
  })
  TWDS.createEle('th.linklike', {
    last: tr,
    textContent: TWDS._('C_ALLIANCE', 'Alliance'),
    dataset: { colsel: '.alliance', secondcolsel: '.name' },
    onclick: TWDS.sortable.do
  })
  TWDS.createEle('th.linklike', {
    last: tr,
    textContent: TWDS._('DUELMAP_LV', 'Lv'),
    title: TWDS._('DUELMAP_LV_TITLE', 'The opponents level'),
    dataset: { colsel: '.level', secondcolsel: '.name' },
    onclick: TWDS.sortable.do
  })
  TWDS.createEle('th.linklike', {
    last: tr,
    textContent: TWDS._('DUELMAP_DLV', 'D-Lv'),
    title: TWDS._('DUELMAP_DLV_TITLE', 'The opponents duelling level'),
    dataset: { colsel: '.duellevel', secondcolsel: '.name' },
    onclick: TWDS.sortable.do
  })
  TWDS.createEle('th.linklike', {
    last: tr,
    textContent: TWDS._('DUELMAP_XP', 'XP'),
    title: TWDS._('DUELMAP_XP_TITLE', 'The amount of duel experience you can get'),
    dataset: { colsel: '.xp', sortmode: 'number', secondcolsel: '.name' },
    onclick: TWDS.sortable.do
  })
  TWDS.createEle('th.linklike', {
    last: tr,
    textContent: TWDS._('DUELMAP_CLASS', 'class'),
    dataset: { colsel: '.class', secondcolsel: '.name' },
    onclick: TWDS.sortable.do
  })
  TWDS.createEle('th.linklike', {
    last: tr,
    textContent: TWDS._('DUELMAP_WAYTIME', 'Waytime'),
    title: TWDS._('DUELMAP_WAYTIME_TITLE', 'Click on it to center the map on the opponent'),
    dataset: { colsel: '.wt', sortmode: 'number', secondcolsel: '.name' },
    onclick: TWDS.sortable.do
  })
  const tbody = TWDS.createEle('tbody', { last: tab })

  const ts = (new Date()).getTime() / 1000
  if (ts > TWDS.duelmap.timestamp + TWDS.duelmap.validseconds) {
    TWDS.duelmap.timestamp = ts
    TWDS.duelmap.win.showLoader()
    TWDS.duelmap.runplayersmax = TWDS.duelmap.playerlimit
    TWDS.duelmap.runplayersloaded = 0
    TWDS.duelmap.lastpageloaded = 0
    TWDS.duelmap.getdata('normal')
  } else {
    for (const p of Object.keys(TWDS.duelmap.data)) {
      TWDS.duelmap.update(p)
      TWDS.duelmap.updatestatus()
      TWDS.duelmap.forcetablesort()
    }
  }

  newsearch.onclick = function () {
    TWDS.duelmap.data = {}
    TWDS.duelmap.timestamp = (new Date()).getTime() / 1000
    TWDS.duelmap.win.showLoader()
    TWDS.duelmap.runplayersmax = TWDS.duelmap.playerlimit
    TWDS.duelmap.runplayersloaded = 0
    TWDS.duelmap.lastpageloaded = 0
    // cleanup
    TWDS.duelmap.map.innerHTML = ''
    TWDS.maphelper.drawme(TWDS.duelmap.map)
    tbody.innerHTML = ''
    TWDS.duelmap.getdata('normal')
  }
}

TWDS.duelmap.open = function () {
  window.DuelsWindow.TWDS_backup_open.call(this)
  window.DuelsWindow.window.addTab(TWDS._('DUELMAP', 'Duelmap'), 'TWDS_DUELMAP', TWDS.duelmap.myshowtab)
  TWDS.createEle('div.duels-TWDS_DUELMAP_CONTAINER', {
    style: { display: 'block' },
    last: window.DuelsWindow.window.getContentPane()
  })
}
TWDS.duelmap.startfunc = function () {
  window.DuelsWindow.TWDS_backup_open = window.DuelsWindow.TWDS_backup_open || window.DuelsWindow.open
  window.DuelsWindow.open = TWDS.duelmap.open
  window.DuelsWindow.TWDS_backup_showTab = window.DuelsWindow.TWDS_backup_showTab || window.DuelsWindow.showTab
  window.DuelsWindow.showTab = TWDS.duelmap.showTab
}
TWDS.registerStartFunc(function () {
  TWDS.duelmap.startfunc()
})
// vim: tabstop=2 shiftwidth=2 expandtab
//
if (TWDS.plusminus) {
  document.body.removeEventListener('wheel', TWDS.plusminus.wheel)
}
TWDS.plusminus = {}
TWDS.plusminus.wheel = function (ev) {
  let sb = ev.target.closest('.pm_skillbox')
  let isattr = false
  if (!sb) {
    sb = ev.target.closest('.sk_attr_arrow')
    if (sb) { isattr = true }
  }
  if (sb) {
    let sel = ''
    if (ev.deltaY > 0) {
      sel = '.butMinus'
      if (isattr) {
        // i don't know why that this is done this way. Avoiding some default handling?
        const tmp = TWDS.q1('.sk_attr_minusbutton', sb.parentNode) // skills window
        if (tmp) {
          sb = sb.parentNode
          sel = '.sk_attr_minusbutton'
        }
      }
    } else if (ev.deltaY < 0) {
      sel = '.butPlus'
      if (isattr) {
        const tmp = TWDS.q1('.sk_attr_plusbutton', sb.parentNode) // shaman window
        if (tmp) {
          sb = sb.parentNode
          sel = '.sk_attr_plusbutton'
        }
      }
    }
    if (sel) {
      const ele = TWDS.q1(sel, sb)
      if (ele && 1) {
        const event = new window.Event('click', { bubbles: true })
        ele.dispatchEvent(event)
      }
    }
  }
}
TWDS.plusminus.startfunc = function () {
  document.body.removeEventListener('wheel', TWDS.plusminus.wheel)
  document.body.addEventListener('wheel', TWDS.plusminus.wheel)
}
TWDS.registerStartFunc(function () {
  TWDS.plusminus.startfunc()
})
// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab
//

TWDS.fbmisc.updateRecruitlist = function (arg) {
  FortBattleWindow.backup_updateRecruitlist.call(this, arg)
  if (!TWDS.settings.fbmisc_recruiting) return

  const that = this
  const iae = this.infoareaEl[0]
  const rcl = TWDS.q1('.fort_battle_recruitlist_list', iae)
  if (!rcl) return

  rcl.classList.add('TWDS_enhanced')
  const trows = TWDS.q1('.trows', rcl)
  const head = TWDS.q1('.thead .row_head', trows)
  const ev = TWDS.q1('.evaluated', head)
  const body = TWDS.q1('.tbody', trows)
  TWDS.createEle('div.cell.cell_7.hp', {
    textContent: 'HP',
    before: ev,
    onclick: function (ev) {
      const title = 'Sort by health'
      const sorting = TWDS.createEle('div')
      TWDS.createEle('div.linklike', {
        textContent: '0 1 ... 8 9',
        last: sorting,
        onclick: function () {
          that.preBattle.setSort('>hp')
          that.updateRecruitlist(true)
          mb.hide()
        }
      })
      TWDS.createEle('div.linklike', {
        textContent: '9 8 ... 1 0',
        last: sorting,
        onclick: function () {
          that.preBattle.setSort('<hp')
          that.updateRecruitlist(true)
          mb.hide()
        }
      })
      const mb = new west.gui.Dialog(title, sorting).addButton('cancel').show()
    }
  })
  TWDS.createEle('div.cell.cell_7.dist', {
    textContent: 'Dist.',
    before: ev,
    onclick: function (ev) {
      const title = 'Sort by distance'
      const sorting = TWDS.createEle('div')
      TWDS.createEle('div.linklike', {
        textContent: '0 1 ... 8 9',
        last: sorting,
        onclick: function () {
          that.preBattle.setSort('>dist')
          that.updateRecruitlist(true)
          mb.hide()
        }
      })
      TWDS.createEle('div.linklike', {
        textContent: '9 8 ... 1 0',
        last: sorting,
        onclick: function () {
          that.preBattle.setSort('<dist')
          that.updateRecruitlist(true)
          mb.hide()
        }
      })
      const mb = new west.gui.Dialog(title, sorting).addButton('cancel').show()
    }
  })
  const st = TWDS.q1('.cell_5 .sort-status', head)
  st.innerHTML = ''
  TWDS.createEle('img.sort.sort-status', {
    src: '/images/chat/servicegrade_general.png',
    last: st
  })

  const list = this.preBattle.battleData.playerlist
  for (let i = 0; i < list.length; i++) {
    const p = list[i]
    p.dist = 0
    const pid = p.player_id

    const a = TWDS.q1('.player-' + pid, body)
    if (!a) continue

    const r = a.closest('.row')
    if (!r) continue

    if (Game.gameURL.includes('/en15.') && p.town_id === 510 && p.townname.includes(' Thicc ')) {
      const townele = TWDS.q1('.town', r)
      if (townele && p.town_id === 510) {
        townele.textContent = 'Thicc'
      }
    }

    const ev = TWDS.q1('.evaluated', r)
    if (!ev) continue
    let str = p.currhealth
    let cladd = ''
    if (p.currhealth !== p.maxhealth) {
      str += '/' + p.maxhealth
      cladd = 'notfull'
    }
    TWDS.createEle('div.cell.cell_7.hp', {
      before: ev,
      textContent: str,
      className: cladd
    })
    let dist = (this.preBattle.battleData.fortCoords.x - p.coords.x) *
      (this.preBattle.battleData.fortCoords.x - p.coords.x) +
      (this.preBattle.battleData.fortCoords.y - p.coords.y) *
      (this.preBattle.battleData.fortCoords.y - p.coords.y)
    p.dist = dist
    dist = (Math.round(Math.sqrt(dist)) / 1000).toFixed(1)
    cladd = ''
    if (dist > 0.0) {
      cladd = 'away'
    }
    TWDS.createEle('div.cell.cell_7.dist', {
      before: ev,
      textContent: dist,
      className: cladd
    })
  }
}
TWDS.fbmisc.recruitingstartfunc = function () {
  TWDS.registerSetting('bool', 'fbmisc_recruiting',
    TWDS._('FBMISC_SETTING_RECRUITING', 'Mejorar la ventana de reclutamiento.'),
    true, null, 'Batallas de Fuerte')
  FortBattleWindow.backup_updateRecruitlist = FortBattleWindow.backup_updateRecruitlist ||
    FortBattleWindow.updateRecruitlist
  FortBattleWindow.updateRecruitlist = TWDS.fbmisc.updateRecruitlist

  window.PreBattle.recruitSorting.hp = function (a, b, eq) {
    return eq ? a.currhealth === b.currhealth : a.currhealth < b.currhealth
  }
  window.PreBattle.recruitSorting.dist = function (a, b, eq) {
    return eq ? a.dist === b.dist : a.dist < b.dist
  }
  window.PreBattle.recruitSorting.order = ['>town', '>name', '<level', '>class', '<rank', '<grader', '<hp', '<dist']
}
TWDS.registerStartFunc(TWDS.fbmisc.recruitingstartfunc)
// vim: tabstop=2 shiftwidth=2 expandtab
//
TWDS.grouptele = {}

TWDS.grouptele.resolve = function (g, cb) {
  const norm = function (str) {
    const out = []
    const parts = str.split(';')
    for (let i = 0; i < parts.length; i++) {
      const t = parts[i].trim().toLocaleLowerCase()
      if (t > '') { out.push(t) }
    }
    return out
  }
  const alliances = norm(g.alliances)
  const towns = norm(g.towns)
  const exceptions = norm(g.exceptions)
  const players = norm(g.players)
  // unfortunately there is no ranking with town name and alliance name...
  Ajax.remoteCallMode(
    'ranking',
    'get_data', {
      page: 0,
      tab: 'forts',
      entries_per_page: 1000000
    }, function (fr) {
      if (fr.error) {
        return new UserMessage(fr.msg, UserMessage.TYPE_ERROR).show()
      }
      const r = fr.ranking
      const matches = []
      const why = []
      for (let i = 0; i < r.length; i++) {
        const p = r[i]
        if (p.alliance_id) {
          if (alliances.includes(p.alliance_name.toLocaleLowerCase())) {
            matches.push(p.player_id)
            why.push([p.player_id, p.name, TWDS._('GROUPTELE_REASON_ALLIANCE_NAME', 'alliance_name') + ' ' + p.alliance_name])
            continue
          }
          if (alliances.includes(p.alliance_id)) {
            matches.push(p.player_id)
            why.push([p.player_id, p.name, TWDS._('GROUPTELE_REASON_ALLIANCE_ID', 'alliance_id') + ' ' + p.alliance_id])
            continue
          }
        }
        if (players.includes(p.name.toLocaleLowerCase())) {
          matches.push(p.player_id)
          why.push([p.player_id, p.name, TWDS._('GROUPTELE_REASON_PLAYER_NAME', 'player_name') + ' ' + p.name])
          continue
        }
        if (players.includes(p.player_id)) {
          matches.push(p.player_id)
          why.push([p.player_id, p.name, TWDS._('GROUPTELE_REASON_PLAYER_NAME', 'player_id') + ' ' + p.player_id])
          continue
        }
      }
      Ajax.remoteCallMode(
        'ranking',
        'get_data', {
          page: 0,
          tab: 'experience',
          entries_per_page: 1000000
        }, function (xp) {
          if (xp.error) {
            return new UserMessage(xp.msg, UserMessage.TYPE_ERROR).show()
          }
          const r = xp.ranking
          const exceptids = []
          for (let i = 0; i < r.length; i++) {
            const p = r[i]
            if (exceptions.includes(p.player_id)) {
              exceptids.push(p.player_id)
            }
            if (exceptions.includes(p.name.toLocaleLowerCase())) {
              exceptids.push(p.player_id)
            }
            if (matches.includes(p.player_id)) continue // already in list
            if (p.town_id) {
              if (towns.includes(p.town_name.toLocaleLowerCase())) {
                matches.push(p.player_id)
                why.push([p.player_id, p.name, TWDS._('GROUPTELE_REASOH_TOWN_NAME', 'town_name') + ' ' + p.town_name])
                continue
              }
              if (towns.includes(p.town_id)) {
                matches.push(p.player_id)
                why.push([p.player_id, p.name, TWDS._('GROUPTELE_REASOH_TOWN_ID', 'town_id') + ' ' + p.town_id])
                continue
              }
            }
          }
          const out = []
          for (let i = 0; i < why.length; i++) {
            if (exceptids.includes(why[i][0])) continue
            out.push(why[i])
          }
          cb(out)
        })
    })
}

TWDS.grouptele.tabclick = function (win, id) {
  const container = TWDS.utils.getcontainer(win)
  container.innerHTML = ''
  const ig = function (text, cl, type, value) {
    const p = TWDS.createEle('p.inputgroup', { last: container })
    const lab = TWDS.createEle('label', {
      last: p,
      children: [
        { nodeName: 'span', textContent: text }
      ]
    })
    const inp = TWDS.createEle('input', {
      className: cl,
      last: lab,
      type: type,
      value: value
    })
    return inp
  }
  const getvalues = function () {
    const g = {}
    g.alliances = TWDS.q1('.inputgroup input.alliances', win.divMain).value.trim()
    g.towns = TWDS.q1('.inputgroup input.towns', win.divMain).value.trim()
    g.players = TWDS.q1('.inputgroup input.players', win.divMain).value.trim()
    g.exceptions = TWDS.q1('.inputgroup input.exceptions', win.divMain).value.trim()
    g.info = TWDS.q1('.inputgroup input.info', win.divMain).value.trim()
    return g
  }
  win.activateTab(id)
  const num = id.substring(9)// grouptele

  TWDS.createEle('span.help', {
    last: container,
    textContent: '?',
    title: TWDS._('GROUPTELE_HELP', 'Ayuda'),
    onclick: function () {
      TWDS.utils.showhelp('grouptele')
    }
  })
  TWDS.createEle('h1', {
    last: container,
    textContent: TWDS._('GROUPTELE_TAB_H1', 'Telegrama grupal #') + num
  })
  let g = {}

  if (id in TWDS.settings) {
    g = JSON.parse(TWDS.settings[id])
  }
  const infoinput = ig('Información', 'info', 'text', g.info || '')
  infoinput.title = TWDS._('GROUPTELE_INFO_TITLE', 'Para su información / organización')

  const clearcheck = function () {
    table.textContent = ''
  }

  ig(TWDS._('GROUPTELE_ALLIANCES', 'Alianzas'), 'alliances', 'text', g.alliances ?? '').onchange = clearcheck
  ig(TWDS._('GROUPTELE_TOWNS', 'Ciudades'), 'towns', 'text', g.towns ?? '').onchange = clearcheck
  ig(TWDS._('GROUPTELE_PLAYERS', 'Jugadores'), 'players', 'text', g.players ?? '').onchange = clearcheck
  ig(TWDS._('GROUPTELE_EXCEPTIONS', 'Excepciones'), 'exceptions', 'text', g.exceptions ?? '').onchange = clearcheck
  const p = TWDS.createEle('p.inputgroup.functions', { last: container })

  let lab = TWDS.createEle('label', { last: p })
  TWDS.createEle('input.save', {
    last: lab,
    type: 'button',
    value: TWDS._('GROUPTELE_SAVE', 'Guardar'),
    onclick: function () {
      g = getvalues()
      console.log('g', g)
      TWDS.settings[id] = JSON.stringify(g)
      TWDS.saveSettings()
    }
  })

  lab = TWDS.createEle('label', { last: p })
  TWDS.createEle('input.check', {
    last: lab,
    type: 'button',
    value: TWDS._('GROUPTELE_CHECK', 'Verificar'),
    onclick: function () {
      g = getvalues()
      console.log('g', g)
      table.textContent = ''
      TWDS.grouptele.resolve(g, function (l) {
        l.sort(function (a, b) {
          return a[1].toLocaleLowerCase().localeCompare(b[1].toLocaleLowerCase())
        })
        const thead = TWDS.createEle('thead', { last: table })
        const tr = TWDS.createEle('tr', { last: thead })
        TWDS.createEle('th', { last: tr, textContent: '#' })
        TWDS.createEle('th', { last: tr, textContent: 'Name' })
        TWDS.createEle('th', { last: tr, textContent: 'Info' })
        const tbody = TWDS.createEle('tbody', { last: table })
        tbody.textContent = ''
        for (let i = 0; i < l.length; i++) {
          const tr = TWDS.createEle('tr', { last: tbody })
          TWDS.createEle('td', { last: tr, textContent: i + 1 })
          TWDS.createEle('th', { last: tr, textContent: l[i][1] })
          TWDS.createEle('td', { last: tr, textContent: l[i][2] })
        }
      })
    }
  })

  lab = TWDS.createEle('label', { last: p })
  TWDS.createEle('input.send', {
    last: lab,
    type: 'button',
    value: TWDS._('GROUPTELE_SEND', 'Enviar'),
    onclick: function () {
      g = getvalues()
      console.log('g', g)
      TWDS.grouptele.resolve(g, function (l) {
        l.sort(function (a, b) {
          return a[1].toLocaleLowerCase().localeCompare(b[1].toLocaleLowerCase())
        })
        let t = []
        for (let i = 0; i < l.length; i++) {
          t.push(l[i][1])
        }
        t = t.join(';')
        MessagesWindow.open('telegram', { insert_to: t })
        let n = 0
        const redcheckbox = function () {
          const gcb = TWDS.q1('.tw2gui_window.messages .groupcheckbox')
          n++
          if (!gcb) {
            if (n < 50) {
              setTimeout(redcheckbox, 100)
            }
            return
          }
          gcb.style.outline = '3px inset red'
        }
        redcheckbox()
      })
    }
  })

  TWDS.createEle('hr', { last: container })
  const table = TWDS.createEle('table', { last: container })
}
TWDS.grouptele.openwindow = function () {
  const win = TWDS.utils.stdwindow('TWDS_grouptele_window',
    TWDS._('GROUPTELE_WINDOW_TITLE', 'Telegramas grupales'),
    TWDS._('GROUPTELE_WINDOW_MINITITLE', 'Telegramas grupales'))
  for (let i = 1; i <= 8; i++) {
    const key = 'grouptele' + i
    if (win.tabIds[key]) continue
    win.addTab('#' + i, key, TWDS.grouptele.tabclick)
  }
  const container = TWDS.utils.getcontainer(win)
  container.innerHTML = ''
  TWDS.q1('._tab_id_grouptele1', win.divMain).click()
  return win
}

TWDS.grouptele.start = function () {
  TWDS.registerExtra('TWDS.grouptele.openwindow',
    TWDS._('GROUPTELE_EXTRA', 'Telegramas grupales'),
    TWDS._('GROUPTELE_EXTRA_HELP', 'Gestionar / enviar  telegramas grupales')
  )
}
TWDS.registerStartFunc(TWDS.grouptele.start)

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.sortable = {}
TWDS.sortable.search = function (ev) { TWDS.sortable.searchReal.apply(this, ev) }
TWDS.sortable.searchReal = function (ev) {
  const tab = this.closest('table')

  let searchstring = ''
  let colsel = 'td,th'
  if (tab.dataset.searchfilter) {
    const searchfilterselector = tab.dataset.searchfilter
    searchstring = TWDS.q1(searchfilterselector, tab).value.toLocaleLowerCase()
    colsel = tab.dataset.colsel || 'td,th'
  }

  const rows = [...TWDS.q('tbody tr', tab)]
  let state = 0
  for (let i = 0; i < rows.length; i++) {
    rows[i].style.display = 'table-row'
    if (rows[i].classList.contains('sortgrouped')) {
      if (state === 1) {
        rows[i].style.display = 'none'
      }
      continue
    }
    if (searchstring === '') {
      state = 0
    } else {
      const cols = [...TWDS.q(colsel, rows[i])]
      let found = 0
      for (let j = 0; j < cols.length; j++) {
        const t = cols[j].textContent
        if (t.toLocaleLowerCase().search(searchstring) !== -1) {
          found = 1
        }
      }
      if (!found) {
        state = 1
        rows[i].style.display = 'none'
      }
    }
  }
}

TWDS.sortable.do = function (ev, forcemul) { TWDS.sortable.doReal(this, forcemul) }
TWDS.sortable.doReal = function (clickedele, forcemul) {
  const tab = clickedele.closest('table')
  const tbody = TWDS.q1('tbody', tab)
  const sel = clickedele.dataset.colsel
  const secondsel = clickedele.dataset.secondsel
  const sortmode = clickedele.dataset.sortmode || 'text'
  const rows = [...TWDS.q('tbody tr:not(.sortgrouped)', tab)]
  const cursort = tab.dataset.cursort || ''
  const curmult = parseInt(tab.dataset.curmult) || 1
  let mult = 1

  forcemul = forcemul || 0
  if (forcemul) {
    mult = forcemul
  } else {
    if (cursort === sel) { // click on the same head: reverse sort order
      mult = curmult * -1
    } else {
      // click on another head: use default sort order
      if (clickedele.dataset.sortdefaultorder) {
        mult = parseInt(clickedele.dataset.sortdefaultorder)
        if (mult !== -1) mult = 1
      }
    }
    if (tab.dataset.TWDS_ordersavekey) {
      const k = tab.dataset.TWDS_ordersavekey
      localStorage[k + '_sel'] = sel
      localStorage[k + '_mult'] = mult
    }
  }
  tab.dataset.cursort = sel
  tab.dataset.curmult = mult
  const sortfunc = function (a, b, sel) {
    const tda = TWDS.q1(sel, a)
    const tdb = TWDS.q1(sel, b)
    if (!tda) return 0
    if (!tdb) return 0
    if (tda.classList.contains('sortgrouped')) return 0
    if (tdb.classList.contains('sortgrouped')) return 0
    let va
    let vb
    if ('sortval' in tda.dataset) {
      va = tda.dataset.sortval
    } else {
      va = tda.textContent
    }
    if ('sortval' in tdb.dataset) {
      vb = tdb.dataset.sortval
    } else {
      vb = tdb.textContent
    }
    let res = 0
    if (sortmode === 'number') {
      res = parseFloat(va) - parseFloat(vb)
    } else {
      res = va.localeCompare(vb)
    }
    if (res) return mult * res

    if ('sortval2' in tda.dataset || 'sortval2' in tda.dataset) {
      if ('sortval2' in tda.dataset) {
        va = tda.dataset.sortval2
      } else {
        va = tda.textContent
      }
      if ('sortval2' in tdb.dataset) {
        vb = tdb.dataset.sortval2
      } else {
        vb = tdb.textContent
      }
      let res = 0
      if (sortmode === 'number') {
        res = parseFloat(va) - parseFloat(vb)
      } else {
        res = va.localeCompare(vb)
      }
      if (res) return mult * res
    }

    if (secondsel && sel !== secondsel) {
      return sortfunc(a, b, secondsel)
    }
    return 0
  }
  rows.sort(function (a, b) { return sortfunc(a, b, sel) })
  const urows = [...TWDS.q('tbody tr', tab)] // unsorted, all rows -> to insert the grouped rows.
  tbody.textContent = ''
  for (let i = 0; i < rows.length; i++) {
    tbody.appendChild(rows[i])
    let state = 0
    for (let j = 0; j < urows.length; j++) {
      if (state === 0 && urows[j] === rows[i]) {
        state = 1
        continue
      }
      if (state === 1 && urows[j].classList.contains('sortgrouped')) {
        tbody.appendChild(urows[j])
        continue
      }
      if (state === 1) {
        break
      }
    }
  }
}
TWDS.extras = {}
TWDS.extras.button = function (fn, text, help) {
  const li = TWDS.createEle('li')
  TWDS.createEle({
    nodeName: 'button',
    className: 'TWDS_button TWDS_extras_button',
    dataset: {
      func: fn
    },
    textContent: text,
    beforeend: li
  })
  if (help) {
    TWDS.createEle({
      nodeName: 'span',
      textContent: help,
      beforeend: li
    })
  }
  return li
}
TWDS.extras.getTabContent = function () {
  const div = document.createElement('div')
  div.id = 'TWDS_extras'
  TWDS.createEle('h2', { beforeend: div, textContent: TWDS._('EXTRAS_TITLE', 'Extras') })
  const ul = TWDS.createEle('ul', { beforeend: div })

  const a = []
  for (let i = 0; i < TWDS.extraList.length; i++) {
    const e = TWDS.extraList[i]
    a.push([i, e.text.toLocaleLowerCase()])
  }
  a.sort(function (a, b) {
    return a[1].localeCompare(b[1])
  })
  for (let i = 0; i < TWDS.extraList.length; i++) {
    const j = a[i][0]
    const e = TWDS.extraList[j]
    ul.appendChild(TWDS.extras.button(e.fn, e.text, e.help))
  }
  return div
}
TWDS.extras.activateTab = function () {
  TWDS.activateTab('extras')
}
TWDS.registerStartFunc(function () {
  TWDS.registerTab('extras',
    TWDS._('TABNAME_EXTRAS', 'Extras'),
    TWDS.extras.getTabContent,
    TWDS.extras.activateTab,
    true)
  TWDS.delegate(document, 'click', '.TWDS_extras_button', function (ev) {
    const funcstring = this.dataset.func

    const parts = funcstring.split('.')
    const func = parts.pop()
    let context = window
    for (let i = 0; i < parts.length; i++) {
      context = context[parts[i]]
    }
    context[func].apply(context)
  })
})

// vim: tabstop=2 shiftwidth=2 expandtab
// vim: tabstop=2 shiftwidth=2 expandtab
TWDS.opentab = function (tabname, scrollto) {
  if (typeof (wman.getById('TWDS')) === 'undefined') {
    TWDS.window = null
  }
  if (TWDS.window == null) {
    // TWDS.updateData()
    TWDS.window = wman.open('TWDS', TWDS.scriptnameTitle, 'noreload nocloseall').setMiniTitle(TWDS.scriptnameMiniTitle)

    let defaultTab = ''
    for (const tabData of Object.values(TWDS.knownTabs)) {
      const t = TWDS.createTab(tabData.key)
      TWDS.window.addTab(tabData.title,
        tabData.key, tabData.activationFunc)
      const sp = new west.gui.Scrollpane()
      sp.appendContent(t)
      TWDS.window.appendToContentPane(sp.getMainDiv())
      if (tabData.isDefault && defaultTab === '') { defaultTab = tabData.key }
    }
    const lastseen = window.localStorage.TWDS_last_seen || ''
    if (lastseen !== TWDS.version) {
      defaultTab = 'updates'
      window.localStorage.TWDS_last_seen = TWDS.version
    }

    if (tabname === null) { tabname = defaultTab }
  }
  if (wman.isMinimized('TWDS')) {
    wman.reopen('TWDS')
  }
  TWDS.activateTab(tabname)
  if (scrollto) {
    const x = TWDS.q1(scrollto, TWDS.window.divMain)
    if (x) {
      x.scrollIntoView(true)
    }
  }
}
TWDS.createSideButton = function () {
  const d = document.createElement('div')
  d.classList.add('menulink')
  d.onClick = 'TWDS.open();'
  d.title = TWDS.scriptnameTitle
  d.style.backgroundImage = 'none !important'
  d.textContent = 'DS'
  d.id = 'TWDS_innerbutton'
  const mc = document.createElement('div')
  mc.classList.add('ui_menucontainer')
  mc.id = 'TWDS_button'
  mc.onClick = 'TWDS.open();'
  mc.appendChild(d)
  const mcb = document.createElement('div')
  mcb.classList.add('menucontainer_bottom')
  mc.appendChild(mcb)
  const mb = document.querySelector('#ui_menubar')
  mb.appendChild(mc)

  const ib = document.querySelector('#TWDS_innerbutton')
  ib.style.backgroundImage = 'none !important'
  ib.classList.add('test')
  ib.onclick = function () {
    if (typeof (wman.getById('TWDS')) === 'undefined') {
      TWDS.window = null
    }
    if (TWDS.window == null) {
      TWDS.opentab(null)
    } else if (wman.isMinimized('TWDS')) {
      wman.reopen('TWDS')
    } else {
      wman.close('TWDS')
      TWDS.window = null
    }
  }
}

window.TWDS = TWDS

TWDS.didstartfuncs = false
TWDS.wait2callstartfuncs = function () {
  if (TWDS.didstartfuncs) return
  const dostartfuncs = function () {
    TWDS.didstartfuncs = true
    try {
      for (const fn of Object.values(TWDS.startFunctions)) {
        fn()
      }
    } catch (e) {
      console.log('Caught exception', e)
      new UserMessage('Caught exception: ' + e).show()
      console.trace(e)
    }
  }
  if (!ItemManager.isLoaded()) {
    EventHandler.listen('itemmanager_loaded', TWDS.wait2callstartfuncs)
    return
  }
  if (!Character.playerId) {
    EventHandler.listen('char_avatar_changed', TWDS.wait2callstartfuncs)
    return
  }
  dostartfuncs()
  return EventHandler.ONE_TIME_EVENT
}
TWDS.main = function () {
  $(document).on('click', '.TWDS_nameeditTrigger', function () {
    const oldName = this.textContent
    const str = TWDS._('ENTER_NEW_NAME', 'Ingrese un nombre nuevo para la equipación $name$', {
      name: oldName
    })
    const newName = window.prompt(str)
    if (newName === false) return
    if (oldName === newName) {
      return
    }
    const tr = this.closest('tr')
    const key = tr.dataset.key
    let tmp = window.localStorage.getItem(key)
    const o = JSON.parse(tmp)
    o.name = newName
    tmp = JSON.stringify(o)
    window.localStorage.setItem(key, tmp)
    this.textContent = newName
  })
  $(document).on('click', '.TWDS_delete', function () {
    const tr = this.closest('tr')
    const n = $('.TWDS_nameeditTrigger', tr)[0].textContent
    const str = TWDS._('CONFIRM_REMOVE', '¿Realmente desea eliminar la equipación $name$?', {
      name: n
    })
    if (!window.confirm(str)) {
      return
    }
    const key = tr.dataset.key
    window.localStorage.removeItem(key)
    tr.remove()
    TWDS.clothcache.recalcItemUsage()
  })
  TWDS.createSideButton()
  TWDS.wait2callstartfuncs()
}

TWDS.preMain = function () {
  if (typeof $ === 'undefined') {
    window.setTimeout(TWDS.preMain, 100)
    return
  }
  if (typeof window.wman === 'undefined') {
    window.setTimeout(TWDS.preMain, 100)
    return
  }

  TWDS.main()
}

TWDS.waitready = function () {
  if (document.attachEvent ? document.readyState === 'complete' : document.readyState !== 'loading') {
    TWDS.preMain()
  } else {
    document.addEventListener('DOMContentLoaded', TWDS.preMain())
  }
}
TWDS.waitready()
});
