// ==UserScript==
// @name         Autodarts – MatchInsights
// @namespace    http://tampermonkey.net/
// @version      0.14.199
// @author       ThunderB
// @license      All Rights Reserved
// @description  Holt aus deiner Historie neue Innsights für dein Spiel!
// @match        https://play.autodarts.io/*
// @grant        GM_xmlhttpRequest
// @grant        GM_addStyle
// @grant        GM_openInTab
// @grant        unsafeWindow
// @connect      api.autodarts.io
// @downloadURL https://update.greasyfork.org/scripts/560943/Autodarts%20%E2%80%93%20MatchInsights.user.js
// @updateURL https://update.greasyfork.org/scripts/560943/Autodarts%20%E2%80%93%20MatchInsights.meta.js
// ==/UserScript==

// Debug toggle (manual): set to true for targeted ATC field pipeline logs
const DEBUG_ATC_FIELDS = false;

(function () {
    "use strict";


    // -------------------- Bulk collector special modes --------------------
    // ad_bulk_iframe=1 : our hidden collector iframe (script should not run inside, to avoid recursion / side-effects)
    // ad_bulk_bg=1     : background-tab collector (runs minimal code, sends results via BroadcastChannel, then closes)
    const AD__BULK_URL = (() => { try { return new URL(location.href); } catch { return null; } })();
    const AD__IS_IN_FRAME = (() => { try { return window.top !== window.self; } catch { return true; } })();
    const AD__BULK_IFRAME = (AD__BULK_URL?.searchParams?.get("ad_bulk_iframe") === "1");

    if (AD__IS_IN_FRAME && AD__BULK_IFRAME) {
        return;
    }

    const AD__BULK_BG = (AD__BULK_URL?.searchParams?.get("ad_bulk_bg") === "1");

    if (AD__BULK_BG) {
        (async () => {
            const BC_NAME = "ad_bulk";
            const sessionId = String(AD__BULK_URL?.searchParams?.get("ad_bulk_session") || "");
            const startedAt = Date.now();

            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            const isHistoryList = () => /^\/history\/matches\/?$/i.test(String(location.pathname || ""));
            const UUID_RE = /\/history\/matches\/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i;

            function collectIdsFromDoc(doc) {
                const ids = new Set();
                const sel = [
                    'a[href*="/history/matches/"]',
                    '[data-href*="/history/matches/"]',
                    '[to*="/history/matches/"]'
                ].join(",");

                for (const el of doc.querySelectorAll(sel)) {
                    const candidates = [
                        el.getAttribute?.("href"),
                        el.getAttribute?.("data-href"),
                        el.getAttribute?.("to"),
                        el.href,
                        el.dataset?.href
                    ];

                    for (const c of candidates) {
                        const s = String(c || "");
                        const m = s.match(UUID_RE);
                        if (m && m[1]) ids.add(String(m[1]));
                    }
                }
                return ids;
            }

            function sigOfIds(ids) {
                const arr = Array.from(ids);
                arr.sort();
                return arr.slice(0, 10).join("|");
            }

            function spaNavigateTo(url) {
                try { history.pushState({}, "", url); } catch {
                    try { location.href = url; } catch {}
                    return;
                }
                try { window.dispatchEvent(new PopStateEvent("popstate")); } catch {
                    try { window.dispatchEvent(new Event("popstate")); } catch {}
                }
            }

            async function waitForNewPageContent(prevSig, waitRenderMs, settleMs, stopFlagRef) {
                const t0 = Date.now();
                while (!stopFlagRef.stopped && (Date.now() - t0) < waitRenderMs) {
                    const ids = collectIdsFromDoc(document);
                    const sig = sigOfIds(ids);
                    if (ids.size > 0 && sig !== prevSig) {
                        await sleep(settleMs);
                        return { ids, sig, changed: true };
                    }
                    await sleep(200);
                }
                const ids = collectIdsFromDoc(document);
                return { ids, sig: sigOfIds(ids), changed: false };
            }

            const stopFlag = { stopped: false };

            let bc = null;
            try {
                if (typeof BroadcastChannel !== "undefined") bc = new BroadcastChannel(BC_NAME);
            } catch { bc = null; }

            const post = (msg) => {
                try { bc?.postMessage({ sessionId, ...msg }); } catch {}
            };

            try {
                bc?.addEventListener?.("message", (ev) => {
                    const m = ev?.data || {};
                    if (!m || m.sessionId !== sessionId) return;
                    if (m.type === "stop") stopFlag.stopped = true;
                });
            } catch {}

            try {
                // Ensure we are on history list (some setups might open a different url first)
                if (!isHistoryList()) {
                    const u = new URL("/history/matches", location.origin);
                    u.searchParams.set("page", String(0));
                    u.searchParams.set("ad_bulk_bg", "1");
                    if (sessionId) u.searchParams.set("ad_bulk_session", sessionId);
                    spaNavigateTo(u.pathname + u.search + u.hash);
                }

                const startPage = (() => {
                    const raw = AD__BULK_URL?.searchParams?.get("page");
                    const n = parseInt(String(raw ?? ""), 10);
                    return (Number.isFinite(n) && n >= 0) ? n : 0;
                })();

                const maxPages = (() => {
                    const raw = AD__BULK_URL?.searchParams?.get("ad_bulk_maxPages");
                    const n = parseInt(String(raw ?? ""), 10);
                    return (Number.isFinite(n) && n > 0) ? n : 5000;
                })();

                const waitRenderMs = (() => {
                    const raw = AD__BULK_URL?.searchParams?.get("ad_bulk_waitRenderMs");
                    const n = parseInt(String(raw ?? ""), 10);
                    return (Number.isFinite(n) && n > 0) ? n : 8000;
                })();

                const settleMs = (() => {
                    const raw = AD__BULK_URL?.searchParams?.get("ad_bulk_settleMs");
                    const n = parseInt(String(raw ?? ""), 10);
                    return (Number.isFinite(n) && n >= 0) ? n : 250;
                })();

                post({ type: "status", text: `BG Collect start page=${startPage}` });

                // Wait initial render
                const tInit = Date.now();
                while (!stopFlag.stopped && (Date.now() - tInit) < waitRenderMs) {
                    const idsNow = collectIdsFromDoc(document);
                    if (idsNow.size > 0 || document.readyState === "complete") break;
                    await sleep(200);
                }
                await sleep(settleMs);

                const collected = new Set();
                let page = startPage;
                let prevSig = null;
                let pagesVisited = 0;

                const firstIds = collectIdsFromDoc(document);
                const firstSig = sigOfIds(firstIds);
                for (const id of firstIds) collected.add(id);
                prevSig = firstSig;
                pagesVisited++;

                post({ type: "status", text: `BG Collect start page=${page}\nonPage=${firstIds.size} | total=${collected.size}` });

                for (let i = 0; i < maxPages && !stopFlag.stopped; i++) {
                    const nextPage = page + 1;
                    const u = new URL("/history/matches", location.origin);
                    u.searchParams.set("page", String(nextPage));
                    u.searchParams.set("ad_bulk_bg", "1");
                    if (sessionId) u.searchParams.set("ad_bulk_session", sessionId);

                    spaNavigateTo(u.pathname + u.search + u.hash);

                    const { ids, sig } = await waitForNewPageContent(prevSig, waitRenderMs, settleMs, stopFlag);

                    if (ids.size === 0) {
                        post({ type: "status", text: `BG Collect stop: page=${nextPage} leer.\nTotal IDs=${collected.size}` });
                        break;
                    }

                    if (sig === prevSig) {
                        post({ type: "status", text: `BG Collect stop: page=${nextPage} wiederholt letzte Seite.\nTotal IDs=${collected.size}` });
                        break;
                    }

                    const before = collected.size;
                    for (const id of ids) collected.add(id);
                    const newOnPage = collected.size - before;

                    pagesVisited++;
                    page = nextPage;
                    prevSig = sig;

                    post({
                        type: "status",
                        text:
                        `BG Collect page=${page}\n` +
                        `onPage=${ids.size} | new=${newOnPage} | total=${collected.size}\n` +
                        `pagesVisited=${pagesVisited}`
                    });

                    if (newOnPage === 0) {
                        post({ type: "status", text: `BG Collect stop: page=${page} brachte keine neuen IDs.\nTotal IDs=${collected.size}` });
                        break;
                    }
                }

                const idsArr = Array.from(collected);
                idsArr.sort();

                if (stopFlag.stopped) {
                    post({ type: "stopped", ids: idsArr, text: `BG Collect abgebrochen.\nIDs bisher=${idsArr.length}` });
                } else {
                    post({ type: "done", ids: idsArr, text: `BG Collect fertig.\nIDs=${idsArr.length}` });
                }
            } catch (e) {
                post({ type: "error", text: `BG Collect Fehler: ${e?.message || e}` });
            } finally {
                try { bc?.close?.(); } catch {}
                try { window.close(); } catch {}
                try {
                    if (Date.now() - startedAt > 1000) {
                        history.replaceState({}, "", "about:blank");
                    }
                } catch {}
            }
        })();

        return;
    }

    const SCRIPT_VERSION =
          (typeof GM_info !== "undefined" && GM_info && GM_info.script && GM_info.script.version) ? GM_info.script.version :
    (typeof GM !== "undefined" && GM && GM.info && GM.info.script && GM.info.script.version) ? GM.info.script.version :
    "0.14.199";
    // =========================
    // Settings
    // =========================
    const MIN_MATCHES_X01 = 4; // "mehr als 3x gespielt" => >=4
    const MIN_TOTAL_LEGS_X01 = 2; // mind. 2 Legs insgesamt (Einzel-Legs ausblenden)
    const MIN_LEGS_PLAYED_PLAYER_FILTER = 3; // "Ich"-Dropdown: nur Spieler mit >2 gespielten Legs (insg.)
    const MASTER_HOF_MIN_OPPONENT_MATCHES = 3; // Gesamt HoF (Variante C): Spieler mit <3 Matches werden in den Listen ausgeblendet (Matches bleiben für andere Spieler erhalten)
    const MATCH_URL_PREFIX = "https://play.autodarts.io/history/matches/";
    const AVG_TREND_MAX_PLAYERS = 6; // Liniengraph: max Spieler
    const AVG_TREND_MAX_LEGS = 70; // Liniengraph: letzte N Legs (für Übersicht)
    const HIGH_OUT_MIN = 100; // High Out = Checkout >= 100

    // Zeit-Tracker (Tab 3)
    const TIME_WEEKLY_GOAL_DEFAULT_HOURS = 5; // Default Ziel: 5h / Woche
    const TIME_TREND_MAX_WEEKS = 52; // Max. Wochen im Chart (bei ALL/Y1)


    // Training (Defaults beim Hinzufügen einer Aktivität im Trainingsplan; LEGS/Sessions)
    const TRAIN_DEF_LEGS_ATC = 1;
    const TRAIN_DEF_LEGS_COUNTUP = 1;
    const TRAIN_DEF_LEGS_CRICKET = 1;
    const TRAIN_DEF_LEGS_RANDOM_CHECKOUT = 1;
    const TRAIN_DEF_LEGS_SEGMENT_TRAINING = 6;
    const TRAIN_DEF_LEGS_X01_BOT = 2;
    const TRAIN_DEF_LEGS_X01_HUMAN = 2;


    // Training (Wochenauswahl im Trainings-Tab; Default-Bereich in Wochen)
    const TRAIN_WEEK_LOOKBACK_WEEKS_DEFAULT = 4;
    const TRAIN_WEEK_LOOKAHEAD_WEEKS_DEFAULT = 4;
    // =========================
    // UI Config (v0.14.19) – nur UI/UX (Auto-Save in localStorage)
    // =========================
    const AD_EXT_LS_KEY_CFG = "ad_ext_cfg";
    const AD_EXT_LS_KEY_CFG_SECTIONS = "ad_ext_cfg_sections";

    // Defaults entsprechen den bestehenden CONST-Settings (werden in diesem Schritt noch NICHT überall genutzt)
    const AD_EXT_DEFAULT_CFG = Object.freeze({
        MIN_MATCHES_X01,
        MIN_TOTAL_LEGS_X01,
        MIN_LEGS_PLAYED_PLAYER_FILTER,
        MASTER_HOF_MIN_OPPONENT_MATCHES,
        AVG_TREND_MAX_PLAYERS,
        AVG_TREND_MAX_LEGS,
        HIGH_OUT_MIN,
        TIME_WEEKLY_GOAL_DEFAULT_HOURS,
        TIME_TREND_MAX_WEEKS,
        TRAIN_DEF_LEGS_ATC,
        TRAIN_DEF_LEGS_COUNTUP,
        TRAIN_DEF_LEGS_CRICKET,
        TRAIN_DEF_LEGS_RANDOM_CHECKOUT,
        TRAIN_DEF_LEGS_SEGMENT_TRAINING,
        TRAIN_DEF_LEGS_X01_BOT,
        TRAIN_DEF_LEGS_X01_HUMAN,
        TRAIN_WEEK_LOOKBACK_WEEKS_DEFAULT,
        TRAIN_WEEK_LOOKAHEAD_WEEKS_DEFAULT,
    });

    let AD_EXT_CFG_CACHE = null;

    function AD_loadCfg() {
        if (AD_EXT_CFG_CACHE) return AD_EXT_CFG_CACHE;
        let saved = {};
        try {
            const raw = localStorage.getItem(AD_EXT_LS_KEY_CFG);
            if (raw) saved = JSON.parse(raw) || {};
        } catch { saved = {}; }

        const merged = { ...AD_EXT_DEFAULT_CFG };
        for (const k of Object.keys(AD_EXT_DEFAULT_CFG)) {
            const v = saved?.[k];
            if (typeof v === "number" && Number.isFinite(v)) merged[k] = v;
        }
        AD_EXT_CFG_CACHE = merged;
        return AD_EXT_CFG_CACHE;
    }

    function AD_saveCfg(cfg) {
        const merged = { ...AD_EXT_DEFAULT_CFG, ...(cfg || {}) };
        AD_EXT_CFG_CACHE = merged;
        try { localStorage.setItem(AD_EXT_LS_KEY_CFG, JSON.stringify(merged)); return true; } catch { return false; }
    }

    function AD_clearCfg() {
        try { localStorage.removeItem(AD_EXT_LS_KEY_CFG); } catch {}
        AD_EXT_CFG_CACHE = null;
    }

    // Zentraler Accessor (wird später die CONSTs ersetzen)
    function AD_getSetting(key, defaultValue) {
        try {
            const cfg = AD_loadCfg();
            return (cfg && Object.prototype.hasOwnProperty.call(cfg, key)) ? cfg[key] : defaultValue;
        } catch { return defaultValue; }
    }

    function AD_setSetting(key, value) {
        const cfg = AD_loadCfg();
        cfg[key] = value;
        AD_saveCfg(cfg);
        return value;
    }

    const AD_EXT_CFG_FIELDS = [
        { key: "MIN_MATCHES_X01", min: 1, max: 200 },
        { key: "MIN_TOTAL_LEGS_X01", min: 1, max: 500 },
        { key: "MIN_LEGS_PLAYED_PLAYER_FILTER", min: 0, max: 500 },
        { key: "MASTER_HOF_MIN_OPPONENT_MATCHES", min: 0, max: 200 },
        { key: "AVG_TREND_MAX_PLAYERS", min: 1, max: 20 },
        { key: "AVG_TREND_MAX_LEGS", min: 10, max: 300 },
        { key: "HIGH_OUT_MIN", min: 1, max: 170 },
        { key: "TIME_WEEKLY_GOAL_DEFAULT_HOURS", min: 0, max: 40 },
        { key: "TIME_TREND_MAX_WEEKS", min: 4, max: 260 },
        { key: "TRAIN_DEF_LEGS_ATC", min: 1, max: 999 },
        { key: "TRAIN_DEF_LEGS_COUNTUP", min: 1, max: 999 },
        { key: "TRAIN_DEF_LEGS_CRICKET", min: 1, max: 999 },
        { key: "TRAIN_DEF_LEGS_RANDOM_CHECKOUT", min: 1, max: 999 },
        { key: "TRAIN_DEF_LEGS_SEGMENT_TRAINING", min: 1, max: 999 },
        { key: "TRAIN_DEF_LEGS_X01_BOT", min: 1, max: 999 },
        { key: "TRAIN_DEF_LEGS_X01_HUMAN", min: 1, max: 999 },
        { key: "TRAIN_WEEK_LOOKBACK_WEEKS_DEFAULT", min: 0, max: 260 },
        { key: "TRAIN_WEEK_LOOKAHEAD_WEEKS_DEFAULT", min: 0, max: 260 },
    ];


    // =========================
    // IndexedDB Resolver
    // =========================
    const IDB_NAME = "autodarts_cache";
    const IDB_STORE = "match_stats";

    let _resolvedLoc = null;
    let _resolvePromise = null;

    function storeNames(db) {
        return Array.from(db.objectStoreNames || []);
    }
    function hasStore(db, storeName) {
        return storeNames(db).includes(storeName);
    }

    async function openExistingIdb(dbName) {
        return new Promise((resolve, reject) => {
            const req = indexedDB.open(dbName);

            req.onblocked = () => console.warn("[AD Ext] IDB open blocked", dbName);
            req.onerror = () => reject(req.error || new Error("IDB open failed: " + dbName));

            req.onupgradeneeded = () => {
                try { req.transaction.abort(); } catch {}
                try { req.result.close(); } catch {}
                reject(new Error("DB not found (would create new empty DB): " + dbName));
            };

            req.onsuccess = () => resolve(req.result);
        });
    }

    function looksLikeMatchStatsRecord(v) {
        return v && typeof v === "object"
        && (typeof v.matchId === "string" || typeof v.id === "string")
        && (v.payload || v.stats || v.state || v.data);
    }

    async function getStoreSample(db, storeName) {
        return new Promise((resolve) => {
            let tx;
            try { tx = db.transaction(storeName, "readonly"); } catch { resolve(null); return; }
            const store = tx.objectStore(storeName);
            const req = store.openCursor();
            req.onerror = () => resolve(null);
            req.onsuccess = () => {
                const cursor = req.result;
                resolve(cursor ? cursor.value : null);
            };
        });
    }

    async function resolveAutodartsIdbLocation() {
        if (_resolvedLoc) return _resolvedLoc;
        if (_resolvePromise) return _resolvePromise;

        _resolvePromise = (async () => {
            try {
                const db = await openExistingIdb(IDB_NAME);
                try {
                    if (hasStore(db, IDB_STORE)) {
                        const loc = { dbName: IDB_NAME, storeName: IDB_STORE };
                        db.close();
                        return (_resolvedLoc = loc);
                    }
                    for (const s of storeNames(db)) {
                        const sample = await getStoreSample(db, s);
                        if (looksLikeMatchStatsRecord(sample)) {
                            const loc = { dbName: IDB_NAME, storeName: s };
                            db.close();
                            console.warn("[AD Ext] Store-Name weicht ab. Nutze:", loc);
                            return (_resolvedLoc = loc);
                        }
                    }
                } finally {
                    try { db.close(); } catch {}
                }
            } catch (e) {
                console.warn("[AD Ext] Default DB/Store nicht nutzbar:", e?.message || e);
            }

            if (indexedDB.databases) {
                const dbs = await indexedDB.databases();
                for (const d of dbs) {
                    if (!d?.name) continue;
                    let db;
                    try { db = await openExistingIdb(d.name); } catch { continue; }

                    try {
                        if (hasStore(db, IDB_STORE)) {
                            const loc = { dbName: d.name, storeName: IDB_STORE };
                            console.warn("[AD Ext] Gefunden:", loc);
                            return (_resolvedLoc = loc);
                        }
                        for (const s of storeNames(db)) {
                            const sample = await getStoreSample(db, s);
                            if (looksLikeMatchStatsRecord(sample)) {
                                const loc = { dbName: d.name, storeName: s };
                                console.warn("[AD Ext] Gefunden via Sample:", loc);
                                return (_resolvedLoc = loc);
                            }
                        }
                    } finally {
                        try { db.close(); } catch {}
                    }
                }
            }

            throw new Error("Keine passende IndexedDB/Store gefunden. DevTools → Application → IndexedDB prüfen.");
        })();

        return _resolvePromise;
    }

    async function idbGetAll(dbName, storeName) {
        const db = await openExistingIdb(dbName);
        return new Promise((resolve, reject) => {
            let done = false;
            const finish = (fn, arg) => {
                if (done) return;
                done = true;
                try { db.close(); } catch {}
                fn(arg);
            };

            let tx;
            try { tx = db.transaction(storeName, "readonly"); } catch (e) { finish(reject, e); return; }

            tx.onerror = () => finish(reject, tx.error || new Error("IDB tx error"));
            const store = tx.objectStore(storeName);
            const req = store.getAll();
            req.onerror = () => finish(reject, req.error || new Error("IDB getAll error"));
            req.onsuccess = () => finish(resolve, Array.isArray(req.result) ? req.result : []);
        });
    }

    // =========================
    // Helpers
    // =========================
    const isObj = (v) => v && typeof v === "object" && !Array.isArray(v);
    function asArray(v) {
        if (!v) return [];
        if (Array.isArray(v)) return v;
        if (isObj(v)) return Object.values(v);
        return [];
    }
    function escapeHtml(s) {
        return String(s ?? "")
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#039;");
    }
    function fmtInt(n) {
        const x = Number(n);
        if (!Number.isFinite(x)) return "—";
        return String(Math.round(x));
    }
    function fmtDec(n, digits = 2) {
        const x = Number(n);
        if (!Number.isFinite(x)) return "—";
        return x.toFixed(digits);
    }
    function fmtPctFromRatio(ratio0to1) {
        if (!Number.isFinite(ratio0to1)) return "—";
        return (ratio0to1 * 100).toFixed(2) + " %";
    }
    function fmtPct(numer, denom) {
        if (!denom || denom <= 0) return "—";
        const v = (numer * 100) / denom;
        return Number.isFinite(v) ? v.toFixed(2) + " %" : "—";
    }
    // UI helper: progress bar (DOM)
    // pct: number (0..100+), hasGoal: goal > 0
    function createProgressBarDom(pct, hasGoal) {
        const has = !!hasGoal;
        const raw = Number(pct);
        const clamped = has && Number.isFinite(raw) ? Math.max(0, Math.min(100, raw)) : 0;

        const track = document.createElement("div");
        track.className = "ad-ext-progress";
        track.style.width = "100%";
        // In Tabellen: kein zusätzlicher Abstand nach oben
        try { track.style.marginTop = "0"; } catch {}

        const fill = document.createElement("div");
        fill.className = "ad-ext-progress-bar";
        fill.style.width = `${clamped.toFixed(0)}%`;

        track.appendChild(fill);
        return track;
    }

    function parseIsoDateToDayKey(iso) {
        const d = iso ? new Date(iso) : null;
        if (!d || !Number.isFinite(d.getTime())) return null;
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth() + 1).padStart(2, "0");
        const dd = String(d.getDate()).padStart(2, "0");
        return `${yyyy}-${mm}-${dd}`;
    }
    function dayKeyToGerman(dayKey) {
        if (!dayKey || !/^\d{4}-\d{2}-\d{2}$/.test(dayKey)) return "—";
        const [y, m, d] = dayKey.split("-");
        return `${d}.${m}.${y}`;
    }
    function germanDateFromIso(iso) {
        const k = parseIsoDateToDayKey(iso);
        return dayKeyToGerman(k);
    }
    function mmddFromIso(iso) {
        const d = iso ? new Date(iso) : null;
        if (!d || !Number.isFinite(d.getTime())) return "—";
        const mm = String(d.getMonth() + 1).padStart(2, "0");
        const dd = String(d.getDate()).padStart(2, "0");
        return `${mm}-${dd}`;
    }
    function dispName(name) {
        const s = String(name || "").trim();
        return s ? s.toUpperCase() : "UNKNOWN";
    }
    function matchUrl(matchId) {
        return MATCH_URL_PREFIX + encodeURIComponent(String(matchId || ""));
    }

    function modeToPrefix(mode) {
        const m = String(mode || "").toLowerCase();
        if (m.startsWith("double")) return "D";
        if (m.startsWith("triple")) return "T";
        if (m.startsWith("single")) return "S";
        if (m === "d") return "D";
        if (m === "t") return "T";
        if (m === "s") return "S";
        return "";
    }

    function normalizeVariantName(v) {
        return String(v || "").trim().toLowerCase();
    }
    function isSegmentTrainingPayload(payload) {
        const v = normalizeVariantName(payload?.variant || payload?.gameMode || payload?.mode);
        return v === "segment training" || v.includes("segment training");
    }
    function isX01Payload(payload) {
        const v = normalizeVariantName(payload?.variant || payload?.gameMode || payload?.mode);
        return v === "x01" || v.includes("x01");
    }
    function getRowPayload(r) {
        const root = r?.stats ?? r?.payload ?? r?.data ?? r;
        const payload = root?.payload ?? root;
        return payload && typeof payload === "object" ? payload : null;
    }

    function stablePlayerKeyFromPlayerObj(p) {
        const userId = p?.userId || p?.user?.id || null;
        const name = p?.name || p?.user?.name || null;
        return userId ? `uid:${String(userId)}` : `name:${String(name || "unknown").trim().toLowerCase()}`;
    }
    function stablePlayerDisplayNameFromPlayerObj(p) {
        return String(p?.name || p?.user?.name || "Unknown").trim() || "Unknown";
    }

    function parseDurationToSeconds(s) {
        const str = String(s || "").trim().toLowerCase();
        if (!str) return 0;
        const h = /(\d+)\s*h/.exec(str);
        const m = /(\d+)\s*m/.exec(str);
        const sec = /(\d+)\s*s/.exec(str);
        const hh = h ? Number(h[1]) : 0;
        const mm = m ? Number(m[1]) : 0;
        const ss = sec ? Number(sec[1]) : 0;
        return (Number.isFinite(hh) ? hh * 3600 : 0) + (Number.isFinite(mm) ? mm * 60 : 0) + (Number.isFinite(ss) ? ss : 0);
    }
    function fmtHours(seconds) {
        const s = Number(seconds);
        if (!Number.isFinite(s) || s < 0) return "—";
        const totalMin = Math.round(s / 60);
        const h = Math.floor(totalMin / 60);
        const m = totalMin % 60;
        if (h <= 0) return `${m}min`;
        return `${h}h${String(m).padStart(2, "0")}min`;
    }
    function fmtMinPerLeg(seconds) {
        const s = Number(seconds);
        if (!Number.isFinite(s) || s < 0) return "—";
        const totalSec = Math.round(s);
        const h = Math.floor(totalSec / 3600);
        const m = Math.floor((totalSec % 3600) / 60);
        const sec = totalSec % 60;
        if (h > 0) {
            return `${h}h${String(m).padStart(2, "0")}min${String(sec).padStart(2, "0")}sek`;
        }
        return `${m}min${String(sec).padStart(2, "0")}sek`;
    }

    // =========================
    // Date range helper
    // =========================
    function filterByDateRange(items, dateRange, getIsoFn) {
        const range = String(dateRange || "ALL").toUpperCase();
        if (range === "ALL") return items.slice();

        const now = new Date();
        let from = null;

        const daysBack = (n) => {
            const d = new Date(now);
            d.setDate(d.getDate() - n);
            return d;
        };
        const monthsBack = (n) => {
            const d = new Date(now);
            d.setMonth(d.getMonth() - n);
            return d;
        };

        if (range === "D7") from = daysBack(7);
        else if (range === "D14") from = daysBack(14);
        else if (range === "D30") from = daysBack(30);
        else if (range === "M3") from = monthsBack(3);
        else if (range === "M6") from = monthsBack(6);
        else if (range === "Y1") from = daysBack(365);

        if (!from) return items.slice();
        const fromTs = from.getTime();

        return items.filter((it) => {
            const iso = getIsoFn(it);
            const ts = iso ? new Date(iso).getTime() : NaN;
            if (!Number.isFinite(ts)) return false;
            return ts >= fromTs;
        });
    }

    function dayKeyFromLocalDate(d) {
        if (!d || !Number.isFinite(d.getTime())) return null;
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth() + 1).padStart(2, "0");
        const dd = String(d.getDate()).padStart(2, "0");
        return `${yyyy}-${mm}-${dd}`;
    }

    function parseDayKeyToLocalDate(dayKey) {
        if (!dayKey || typeof dayKey !== "string") return null;
        const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(dayKey.trim());
        if (!m) return null;
        const y = Number(m[1]);
        const mo = Number(m[2]) - 1;
        const d = Number(m[3]);
        const dt = new Date(y, mo, d);
        if (!Number.isFinite(dt.getTime())) return null;
        return dt;
    }

    function startOfWeekMonday(d) {
        const x = new Date(d);
        if (!Number.isFinite(x.getTime())) return null;
        const day = (x.getDay() + 6) % 7; // Mo=0 ... So=6
        x.setDate(x.getDate() - day);
        x.setHours(0, 0, 0, 0);
        return x;
    }

    function addDaysLocal(d, days) {
        const x = new Date(d);
        x.setDate(x.getDate() + (Number(days) || 0));
        return x;
    }

    // ISO-Kalenderwoche (KW) nach ISO-8601 (Mo..So, KW 1 enthält den 4. Januar)
    function isoWeekInfoLocal(d) {
        const x = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
        const day = x.getUTCDay() || 7; // So=7
        x.setUTCDate(x.getUTCDate() + 4 - day); // auf Donnerstag der Woche
        const isoYear = x.getUTCFullYear();
        const yearStart = new Date(Date.UTC(isoYear, 0, 1));
        const week = Math.ceil((((x - yearStart) / 86400000) + 1) / 7);
        return { isoYear, week };
    }

    function weekKeyFromDate(d) {
        const w = startOfWeekMonday(d);
        return w ? dayKeyFromLocalDate(w) : null;
    }

    function weekRangeFromWeekKey(weekKey) {
        const start = parseDayKeyToLocalDate(weekKey);
        if (!start) return null;
        const end = addDaysLocal(start, 6);
        return {
            startKey: dayKeyFromLocalDate(start),
            endKey: dayKeyFromLocalDate(end),
            start,
            end,
            ...isoWeekInfoLocal(start),
        };
    }

    function relativeDayKey(daysAgo = 0) {
        const d = new Date();
        d.setDate(d.getDate() - (Number(daysAgo) || 0));
        return dayKeyFromLocalDate(d);
    }

    function filterToDayKey(items, getIsoFn, dayKey) {
        if (!dayKey) return [];
        return items.filter((it) => parseIsoDateToDayKey(getIsoFn(it)) === dayKey);
    }

    function updateRelativeDayOptions(selectEl) {
        if (!selectEl) return;
        const defs = [
            { value: "TODAY", label: "Heute", daysAgo: 0 },
            { value: "YESTERDAY", label: "Gestern", daysAgo: 1 },
            { value: "DAY_BEFORE", label: "Vorgestern", daysAgo: 2 },
        ];
        for (const d of defs) {
            const opt = Array.from(selectEl.options).find(o => o.value === d.value);
            if (!opt) continue;
            const dk = relativeDayKey(d.daysAgo);
            opt.textContent = dk ? `${d.label} (${dayKeyToGerman(dk)})` : `${d.label} (—)`;
        }
    }


    // =========================
    // Segment Training: Extraction + Aggregation
    // =========================
    function extractSegmentTrainingSessionsFromRows(rows) {
        const sessions = [];

        for (const r of rows) {
            const payload = getRowPayload(r);
            if (!payload) continue;
            if (!isSegmentTrainingPayload(payload)) continue;

            const matchId = payload.id || r?.matchId || payload.matchId || null;

            const legStatsArr = asArray(payload.legStats);
            const legStatByGameId = new Map();
            for (const leg of legStatsArr) {
                const statsArr = asArray(leg?.stats);
                for (const st of statsArr) {
                    if (st?.gameId) legStatByGameId.set(st.gameId, st);
                }
            }

            const games = asArray(payload.games);
            for (const g of games) {
                const gVar = normalizeVariantName(g?.variant);
                if (gVar && !gVar.includes("segment training")) continue;

                const gameId = g?.id || null;
                const createdAt = g?.createdAt || payload.createdAt || null;
                const finishedAt = g?.finishedAt || g?.endedAt || payload.finishedAt || payload.endedAt || null;
                const dayKey =
                      parseIsoDateToDayKey(createdAt) ||
                      parseIsoDateToDayKey(finishedAt) ||
                      parseIsoDateToDayKey(payload.createdAt) ||
                      parseIsoDateToDayKey(payload.finishedAt);

                let durationSec = 0;
                const durRaw = g?.duration ?? payload?.duration ?? null;
                if (typeof durRaw === "number") {
                    durationSec = durRaw > 10000 ? durRaw / 1000 : durRaw;
                } else {
                    durationSec = parseDurationToSeconds(durRaw);
                }
                const t0 = createdAt ? new Date(createdAt).getTime() : NaN;
                const t1 = finishedAt ? new Date(finishedAt).getTime() : NaN;
                if (Number.isFinite(t0) && Number.isFinite(t1)) {
                    const diff = (t1 - t0) / 1000;
                    if (diff >= 0 && diff <= 6 * 3600) durationSec = diff;
                }

                const st = gameId ? legStatByGameId.get(gameId) : null;

                const mode = g?.settings?.mode || st?.mode || payload?.settings?.mode || "";
                const segRaw = g?.settings?.segment ?? st?.number ?? payload?.settings?.segment ?? null;
                const segStr = segRaw == null ? "" : String(segRaw).trim();
                const prefix = modeToPrefix(mode);
                const target = prefix && segStr ? `${prefix}${segStr}` : (segStr ? segStr : "—");

                const darts = Number(st?.dartsThrown ?? g?.settings?.throws ?? payload?.settings?.throws ?? 0);
                const hits = Number(st?.hits ?? 0);

                let points = 0;
                const turns = asArray(g?.turns);
                if (turns.length) {
                    for (const t of turns) {
                        const p = Number(t?.points);
                        if (Number.isFinite(p)) points += p;
                    }
                }
                if (!points && Number.isFinite(hits)) points = hits;

                sessions.push({
                    matchId,
                    gameId,
                    createdAt,
                    finishedAt,
                    durationSec,
                    dayKey,
                    mode: String(mode || ""),
                    target,
                    darts: Number.isFinite(darts) ? darts : 0,
                    hits: Number.isFinite(hits) ? hits : 0,
                    points: Number.isFinite(points) ? points : 0,
                });
            }
        }

        return sessions;
    }

    function segmentTypeOnlyFilter(sessions, segmentType) {
        let out = sessions.slice();
        const type = String(segmentType || "ALL").toUpperCase();
        if (type !== "ALL") {
            out = out.filter((s) => {
                const m = String(s.mode || "").toLowerCase();
                if (type === "SINGLE") return m.startsWith("single");
                if (type === "DOUBLE") return m.startsWith("double");
                if (type === "TRIPLE") return m.startsWith("triple");
                return true;
            });
        }
        return out;
    }

    function filterSessions(sessions, filters) {
        let out = segmentTypeOnlyFilter(sessions, filters.segmentType);

        const range = String(filters.dateRange || "ALL").toUpperCase();

        if (range === "TODAY" || range === "YESTERDAY" || range === "DAY_BEFORE") {
            const daysAgo = (range === "TODAY") ? 0 : (range === "YESTERDAY") ? 1 : 2;
            const dk = relativeDayKey(daysAgo);
            return out.filter((s) => (s.dayKey || parseIsoDateToDayKey(s.createdAt)) === dk);
        }

        out = filterByDateRange(out, filters.dateRange, (s) => s.createdAt);
        return out;
    }


    function aggregateByDay(sessions) {
        const m = new Map();
        for (const s of sessions) {
            const k = s.dayKey || "unknown";
            if (!m.has(k)) m.set(k, { dayKey: k, sessions: 0, darts: 0, hits: 0, points: 0 });
            const a = m.get(k);
            a.sessions += 1;
            a.darts += s.darts;
            a.hits += s.hits;
            a.points += s.points;
        }
        return Array.from(m.values())
            .filter((x) => x.dayKey !== "unknown")
            .sort((a, b) => (b.dayKey.localeCompare(a.dayKey)));
    }

    // ATC Fokus: Tages-Aggregation nach LEGS (ein ATC-Match kann mehrere Legs enthalten)
    function aggregateAtcByDayLegs(sessions) {
        const m = new Map();
        for (const s of (sessions || [])) {
            const k = s?.dayKey || "unknown";
            if (!m.has(k)) m.set(k, { dayKey: k, legs: 0, sessions: 0, darts: 0, hits: 0, points: 0 });
            const a = m.get(k);
            a.sessions += 1;
            const lg = Number(s?.legs ?? s?.count ?? 1);
            a.legs += (Number.isFinite(lg) && lg > 0) ? lg : 1;
            a.darts += Number(s?.darts || 0);
            a.hits += Number(s?.hits || 0);
            a.points += Number(s?.points || 0);
        }
        return Array.from(m.values())
            .filter((x) => x.dayKey !== "unknown")
            .sort((a, b) => (String(b.dayKey).localeCompare(String(a.dayKey))));
    }


    function aggregateByTarget(sessions) {
        const m = new Map();
        for (const s of sessions) {
            const k = s.target || "—";
            if (!m.has(k)) m.set(k, { target: k, sessions: 0, darts: 0, hits: 0, points: 0 });
            const a = m.get(k);
            a.sessions += 1;
            a.darts += s.darts;
            a.hits += s.hits;
            a.points += s.points;
        }
        const arr = Array.from(m.values());
        arr.sort((a, b) => {
            const ar = a.darts > 0 ? a.hits / a.darts : 0;
            const br = b.darts > 0 ? b.hits / b.darts : 0;
            if (br !== ar) return br - ar;
            if (b.sessions !== a.sessions) return b.sessions - a.sessions;
            return String(a.target).localeCompare(String(b.target));
        });
        return arr;
    }

    function variantKeyFromMode(mode) {
        const m = String(mode || "").trim().toLowerCase();
        if (!m) return "OTHER";
        if (m === "s" || m.startsWith("single")) return "SINGLE";
        if (m === "d" || m.startsWith("double")) return "DOUBLE";
        if (m === "t" || m.startsWith("triple")) return "TRIPLE";
        return "OTHER";
    }

    function variantLabelFromKey(k) {
        const key = String(k || "").toUpperCase();
        if (key === "SINGLE") return "Singles";
        if (key === "DOUBLE") return "Doubles";
        if (key === "TRIPLE") return "Triples";
        return "Andere";
    }

    function aggregateByVariant(sessions) {
        const m = new Map();
        for (const s of sessions) {
            const key = variantKeyFromMode(s?.mode);
            if (!m.has(key)) m.set(key, { key, label: variantLabelFromKey(key), sessions: 0, darts: 0, hits: 0, points: 0 });
            const a = m.get(key);
            a.sessions += 1;
            a.darts += Number(s?.darts || 0);
            a.hits += Number(s?.hits || 0);
            a.points += Number(s?.points || 0);
        }

        const order = ["SINGLE", "DOUBLE", "TRIPLE", "OTHER"];
        const out = order
        .map((k) => m.get(k) || { key: k, label: variantLabelFromKey(k), sessions: 0, darts: 0, hits: 0, points: 0 })
        .filter((x) => x.sessions > 0);

        return out;
    }


    // =========================
    // X01: Extraction + League + Combo
    // =========================
    function computeX01Legs(payload, playerCount) {
        const legsWon = new Array(playerCount).fill(0);
        let totalLegs = 0;

        const scores = asArray(payload?.scores);
        if (scores.length >= playerCount) {
            for (let i = 0; i < playerCount; i++) {
                const lw = Number(scores[i]?.legs ?? 0);
                legsWon[i] = Number.isFinite(lw) ? lw : 0;
                totalLegs += legsWon[i];
            }
            return { legsWon, totalLegs };
        }

        const games = asArray(payload?.games);
        for (const g of games) {
            const w = Number(g?.winner);
            if (Number.isFinite(w) && w >= 0 && w < playerCount) {
                legsWon[w] += 1;
                totalLegs += 1;
            }
        }
        if (!totalLegs) totalLegs = legsWon.reduce((a, b) => a + b, 0);
        return { legsWon, totalLegs };
    }

    function computeX01WinnerIndex(payload, legsWon) {
        const w0 = Number(payload?.winner);
        if (Number.isFinite(w0) && w0 >= 0) return w0;

        const games = asArray(payload?.games);
        for (let i = games.length - 1; i >= 0; i--) {
            const w = Number(games[i]?.winner);
            if (Number.isFinite(w) && w >= 0) return w;
        }

        let best = -1, bestV = -1;
        for (let i = 0; i < legsWon.length; i++) {
            if (legsWon[i] > bestV) { bestV = legsWon[i]; best = i; }
        }
        return best >= 0 ? best : null;
    }

    function extractX01MatchesFromRows(rows) {
        const matches = [];

        const detectOutMode = (payload) => {
            try {
                // boolean flags
                const b1 = payload?.settings?.doubleOut;
                const b2 = payload?.doubleOut;
                if (b1 === true || b2 === true) return { outMode: 'DOUBLE', isDoubleOut: true };

                const g0 = Array.isArray(payload?.games) ? payload.games[0] : null;
                const cand = [
                    payload?.settings?.outMode,
                    payload?.settings?.out,
                    payload?.settings?.checkoutMode,
                    payload?.settings?.checkout,
                    payload?.settings?.finishMode,
                    payload?.settings?.finish,
                    payload?.outMode,
                    payload?.out,
                    payload?.checkoutMode,
                    payload?.checkout,
                    payload?.finishMode,
                    payload?.finish,
                    g0?.settings?.outMode,
                    g0?.settings?.out,
                    g0?.settings?.checkoutMode,
                    g0?.settings?.checkout,
                    g0?.settings?.finishMode,
                    g0?.settings?.finish,
                ].filter(v => v != null);

                for (const v of cand) {
                    const s = String(v).toLowerCase();
                    if (!s) continue;
                    if (s.includes('double')) return { outMode: 'DOUBLE', isDoubleOut: true };
                    if (s.includes('master')) return { outMode: 'MASTER', isDoubleOut: false };
                    if (s.includes('triple')) return { outMode: 'TRIPLE', isDoubleOut: false };
                    if (s.includes('single') || s.includes('straight')) return { outMode: 'SINGLE', isDoubleOut: false };
                }
            } catch { /* ignore */ }
            return { outMode: 'UNKNOWN', isDoubleOut: false };
        };




        // Detect starting score for X01 (best-effort; falls back to 501) (0.14.190)
        const detectStartScore = (payload) => {
            try {
                const g0 = Array.isArray(payload?.games) ? payload.games[0] : null;
                const cand = [
                    payload?.settings?.startScore,
                    payload?.settings?.startingScore,
                    payload?.settings?.x01StartingScore,
                    payload?.settings?.x01Score,
                    payload?.settings?.score,
                    payload?.startScore,
                    payload?.startingScore,
                    payload?.x01Score,
                    payload?.score,
                    g0?.settings?.startScore,
                    g0?.settings?.startingScore,
                    g0?.settings?.x01Score,
                    g0?.settings?.score,
                ].filter(v => v != null);

                for (const v of cand) {
                    const n = Number(v);
                    if (Number.isFinite(n) && n >= 101 && n <= 2001) return Math.round(n);
                }

                // infer from first turns: start ~= scoreAfter + points (or scoreAfter on bust)
                const freq = new Map();
                const add = (n) => {
                    if (!Number.isFinite(n) || n < 101 || n > 2001) return;
                    const k = Math.round(n);
                    freq.set(k, (freq.get(k) || 0) + 1);
                };

                const games = Array.isArray(payload?.games) ? payload.games : [];
                const seen = new Set();
                for (const g of games) {
                    const turns = asArray(g?.turns);
                    for (const t of turns) {
                        const pid = t?.playerId;
                        if (pid == null) continue;
                        const sk = String(pid);
                        if (seen.has(sk)) continue;
                        seen.add(sk);

                        const pts = Number(t?.points);
                        const scRaw = (t?.score != null) ? t.score
                            : (t?.remaining != null) ? t.remaining
                            : (t?.restScore != null) ? t.restScore
                            : (t?.scoreAfter != null) ? t.scoreAfter
                            : null;
                        const sc = (scRaw != null) ? Number(scRaw) : NaN;
                        if (Number.isFinite(sc)) {
                            add(sc);
                            if (Number.isFinite(pts)) add(sc + pts);
                        }
                    }
                }

                const preferred = [301, 501, 701, 1001];
                let best = null;
                let bestCnt = -1;
                for (const k of preferred) {
                    const c = freq.get(k) || 0;
                    if (c > bestCnt) { bestCnt = c; best = k; }
                }
                if (bestCnt > 0 && best != null) return best;

                for (const [k, c] of freq.entries()) {
                    if (c > bestCnt) { bestCnt = c; best = k; }
                }
                if (best != null) return best;
            } catch { /* ignore */ }
            return 501;
        };

        // Parse a single dart throw (best-effort across payload variants) (0.14.190)
        const parseThrow = (thr) => {
            try {
                const seg = (thr && typeof thr === 'object')
                    ? (thr.segment ?? thr.field ?? thr.hit ?? thr)
                    : null;

                const mult = Number(seg?.multiplier ?? seg?.multi ?? thr?.multiplier ?? thr?.multi ?? 0) || 0;
                const num = Number(seg?.number ?? seg?.value ?? thr?.number ?? thr?.num ?? thr?.n ?? 0) || 0;
                const bed = seg?.bed ?? seg?.name ?? thr?.bed ?? thr?.name ?? '';

                const ptsDirect = (thr && typeof thr === 'object')
                    ? ((thr.points != null) ? Number(thr.points) : (thr.value != null) ? Number(thr.value) : NaN)
                    : NaN;

                const bedS = String(bed || '').toLowerCase();
                const isBull = (bedS.includes('bull') || num === 25);

                let pts = 0;
                let key = 'MISS';

                if (isBull) {
                    if (Number.isFinite(ptsDirect) && ptsDirect > 0) pts = ptsDirect;
                    else if (mult === 2) pts = 50;
                    else pts = 25;
                    key = (pts >= 50) ? 'BULL' : 'S25';
                    return {
                        key,
                        points: pts,
                        mult: (mult || (pts >= 50 ? 2 : 1)),
                        num: 25,
                        isDouble: (pts >= 50),
                        isTriple: false,
                        isBull: true,
                        bed,
                    };
                }

                if (Number.isFinite(ptsDirect) && ptsDirect > 0) pts = ptsDirect;
                else if (num > 0 && mult > 0) pts = num * mult;
                else if (num > 0) pts = num;
                else pts = 0;

                const pfx = (mult === 3) ? 'T' : (mult === 2) ? 'D' : 'S';
                if (num > 0) key = `${pfx}${num}`;
                else if (pts > 0) key = `P${Math.round(pts)}`;
                else key = 'MISS';

                return {
                    key,
                    points: pts,
                    mult,
                    num,
                    isDouble: (mult === 2),
                    isTriple: (mult === 3),
                    isBull: false,
                    bed,
                };
            } catch { /* ignore */ }
            return { key: 'MISS', points: 0, mult: 0, num: 0, isDouble: false, isTriple: false, isBull: false, bed: '' };
        };

        const isValidFinishDart = (thrParsed, outMode) => {
            const mode = String(outMode || '').toUpperCase();
            if (mode === 'DOUBLE') return !!thrParsed?.isDouble;
            if (mode === 'MASTER') return !!(thrParsed?.isDouble || thrParsed?.isTriple);
            if (mode === 'TRIPLE') return !!thrParsed?.isTriple;
            // SINGLE / UNKNOWN: allow any
            return true;
        };

        // Simulate a turn if the payload doesn't provide a reliable restscore field (0.14.190)
        const simulateX01Turn = (scoreBefore, throwsArr, pointsFallback, outMode) => {
            const sb = Number(scoreBefore) || 0;
            const parsed = (throwsArr || []).map(parseThrow);

            // no throws → fall back to points
            if (!parsed.length) {
                const pts = Number(pointsFallback) || 0;
                let after = sb - pts;
                let bust = false;
                const mode = String(outMode || '').toUpperCase();
                if (after < 0) { bust = pts > 0; after = sb; }
                if ((mode === 'DOUBLE' || mode === 'MASTER') && after === 1) { bust = pts > 0; after = sb; }
                return { scoreAfter: after, isBust: bust, parsed };
            }

            let score = sb;
            let bust = false;
            for (let i = 0; i < parsed.length; i++) {
                const p = parsed[i];
                score -= (Number(p?.points) || 0);
                if (score < 0) { bust = true; break; }

                const mode = String(outMode || '').toUpperCase();
                if ((mode === 'DOUBLE' || mode === 'MASTER') && score === 1) { bust = true; break; }

                if (score === 0) {
                    if (isValidFinishDart(p, outMode)) {
                        bust = false;
                    } else {
                        bust = true;
                    }
                    break;
                }
            }

            return { scoreAfter: bust ? sb : score, isBust: bust, parsed };
        };

        for (const r of rows) {
            // Some API/cache shapes keep timestamps on the wrapper (e.g. r.stats.createdAt) instead of payload.
            // We keep the extracted payload for gameplay data, but also retain a reference to the wrapper for timestamp fallbacks.
            const root = r?.stats ?? r?.payload ?? r?.data ?? r;
            const payload = getRowPayload(r);
            if (!payload) continue;
            if (!isX01Payload(payload)) continue;

            const playersRaw = asArray(payload?.players);
            if (!playersRaw.length) continue;

            const tmp = [];
            for (let i = 0; i < playersRaw.length; i++) {
                const p = playersRaw[i];
                const idx = Number.isFinite(Number(p?.index)) ? Number(p.index) : i;
                tmp.push({
                    index: idx,
                    key: stablePlayerKeyFromPlayerObj(p),
                    name: stablePlayerDisplayNameFromPlayerObj(p),
                    playerId: p?.id || null,
                });
            }
            tmp.sort((a, b) => a.index - b.index);

            const maxIdx = tmp.reduce((m, p) => Math.max(m, p.index), -1);
            const n = Math.max(tmp.length, maxIdx + 1);

            const players = new Array(n).fill(null).map((_, i) => ({
                index: i,
                key: `idx:${i}`,
                name: `Player ${i + 1}`,
                playerId: null,
            }));
            for (const p of tmp) {
                if (p.index >= 0 && p.index < n) players[p.index] = p;
            }

            const playerIdToIndex = new Map();
            for (const p of players) {
                if (p?.playerId) playerIdToIndex.set(p.playerId, p.index);
            }

            const matchId = payload.id || payload.matchId || root?.id || root?.matchId || r?.matchId || null;
            const createdAt = payload.createdAt || payload.startedAt || root?.createdAt || root?.startedAt || null;
            const finishedAt = payload.finishedAt || payload.endedAt || root?.finishedAt || root?.endedAt || null;
            const dayKey = parseIsoDateToDayKey(createdAt) || parseIsoDateToDayKey(finishedAt);

            const { outMode, isDoubleOut } = detectOutMode(payload);

            const { legsWon, totalLegs } = computeX01Legs(payload, n);
            const winnerIndex = computeX01WinnerIndex(payload, legsWon);

            // duration
            let durationSec = 0;
            const t0 = createdAt ? new Date(createdAt).getTime() : NaN;
            const t1 = finishedAt ? new Date(finishedAt).getTime() : NaN;
            if (Number.isFinite(t0) && Number.isFinite(t1) && t1 >= t0) {
                const diff = (t1 - t0) / 1000;
                if (diff >= 0 && diff <= 6 * 3600) durationSec = diff;
            }
            if (!durationSec) durationSec = parseDurationToSeconds(payload?.duration);

            // totals from turns
            const pointsFromTurns = new Array(n).fill(0);
            const dartsFromTurns = new Array(n).fill(0);


            // NEW: Derived X01 signals (Busts / Restscore leaves / Checkout routes) (0.14.190)
            const derivedStartScore = detectStartScore(payload);
            const derivedVisitsPerPlayer = new Array(n).fill(0);
            const derivedBustsPerPlayer = new Array(n).fill(0);
            const derivedBustPointsPerPlayer = new Array(n).fill(0);

            const derivedLeaveBucketsPerPlayer = new Array(n).fill(null).map(() => ({ le40: 0, le80: 0, le120: 0, le170: 0, gt170: 0 }));
            const derivedBogeyLeavesPerPlayer = new Array(n).fill(0);
            const derivedOneDartLeavesPerPlayer = new Array(n).fill(0);

            const derivedCheckoutOppsPerPlayer = new Array(n).fill(0);
            const derivedCheckoutHitsPerPlayer = new Array(n).fill(0);

            const derivedFirstDartCountsMap = new Array(n).fill(null).map(() => new Map());
            const derivedRouteCountsMap = new Array(n).fill(null).map(() => new Map());

            const BOGEY_SET = new Set([169, 168, 166, 165, 163, 162, 159]);
            const isBogeyLeave = (v) => { try { return BOGEY_SET.has(Number(v)); } catch { return false; } };
            const isOneDartFinishableLeave = (leave) => {
                const v = Number(leave);
                if (!Number.isFinite(v) || v <= 0) return false;
                const mode = String(outMode || '').toUpperCase();
                if (mode === 'DOUBLE') return (v === 50) || (v <= 40 && v >= 2 && (v % 2 === 0));
                if (mode === 'MASTER') {
                    if ((v === 50) || (v <= 40 && v >= 2 && (v % 2 === 0))) return true;
                    return (v <= 60 && v >= 3 && (v % 3 === 0) && (v / 3) <= 20);
                }
                if (mode === 'TRIPLE') return (v <= 60 && v >= 3 && (v % 3 === 0) && (v / 3) <= 20);
                // SINGLE / UNKNOWN
                return v <= 60;
            };

            // NEW: First 9 (per match, summed across legs)
            const first9PointsPerPlayer = new Array(n).fill(0);
            const first9DartsPerPlayer = new Array(n).fill(0);

            // NEW: Score brackets (per match, counts of turns/visits)
            const scores60PlusPerPlayer = new Array(n).fill(0);
            const scores100PlusPerPlayer = new Array(n).fill(0);
            const scores140PlusPerPlayer = new Array(n).fill(0);

            const scores170PlusPerPlayer = new Array(n).fill(0);
            const scores180PerPlayer = new Array(n).fill(0);

            // NEW: Longest leg duration per player (winner only)
            const longestLegSecPerPlayer = new Array(n).fill(0);

            // Top legs (winner only)
            const legWinners = [];

            // NEW: Leg winner sequence (chronological) – for Momentum "Legs"
            const legWinnerIdxSeq = [];
            const legWinnerKeySeq = [];

            // NEW: leg timeline for AVG trend (per leg, per player)
            const legTimeline = []; // each entry: {dateIso, dayKey, matchId, lineup, perAvg: Map(playerKey->avg)}

            const games = asArray(payload?.games);
            const gamesSorted = games
            .map((gg, ii) => {
                const iso = gg?.finishedAt || gg?.endedAt || gg?.createdAt || gg?.startedAt || null;
                const tt = iso ? new Date(iso).getTime() : NaN;
                return { gg, ii, tt: Number.isFinite(tt) ? tt : Number.POSITIVE_INFINITY };
            })
            .sort((a, b) => (a.tt === b.tt ? a.ii - b.ii : a.tt - b.tt))
            .map((x) => x.gg);

            const getGameWinnerIndex = (gg) => {
                if (!gg) return NaN;

                const wid =
                      gg.winnerPlayerId ?? gg.winnerId ?? gg.winner_player_id ?? gg.winner_user_id ?? gg.winnerUserId ??
                      (gg.winnerPlayer && (gg.winnerPlayer.id ?? gg.winnerPlayer.playerId ?? gg.winnerPlayer.userId)) ??
                      ((typeof gg.winner === "object" && gg.winner) ? (gg.winner.playerId ?? gg.winner.id ?? gg.winner.userId) : null);

                if (wid != null) {
                    if (playerIdToIndex.has(wid)) return Number(playerIdToIndex.get(wid));
                    const sw = String(wid);
                    if (playerIdToIndex.has(sw)) return Number(playerIdToIndex.get(sw));
                }

                const w0 = gg.winner;
                if (w0 == null) return NaN;

                // numeric index (or numeric string)
                const wi = Number(w0);
                if (Number.isFinite(wi) && wi >= 0) {
                    // Some payloads use winner = player array position instead of player.index
                    if (Array.isArray(playersRaw) && wi < playersRaw.length) {
                        const pr = playersRaw[wi];
                        const rid = pr?.id;
                        if (rid != null) {
                            if (playerIdToIndex.has(rid)) return Number(playerIdToIndex.get(rid));
                            const srid = String(rid);
                            if (playerIdToIndex.has(srid)) return Number(playerIdToIndex.get(srid));
                        }
                        const rIdx = Number(pr?.index);
                        if (Number.isFinite(rIdx) && rIdx >= 0 && rIdx < n) return rIdx;
                    }
                    if (wi < n) return wi;
                }

                // playerId string
                if (typeof w0 === "string" && (playerIdToIndex.has(w0) || playerIdToIndex.has(String(w0)))) {
                    return Number(playerIdToIndex.get(playerIdToIndex.has(w0) ? w0 : String(w0)));
                }

                return NaN;
            };

            for (const g of gamesSorted) {
                const turns = asArray(g?.turns);

                // per-leg points/darts per player
                const legPts = new Array(n).fill(0);
                const legDarts = new Array(n).fill(0);

                // NEW: first 9 tracking (per leg)
                const legF9Pts = new Array(n).fill(0);
                const legF9Darts = new Array(n).fill(0);
                const legF9SoFar = new Array(n).fill(0);

                const legScores = new Array(n).fill(derivedStartScore);

                for (const t of turns) {
                    const idx = playerIdToIndex.get(t?.playerId);
                    if (!Number.isFinite(Number(idx))) continue;

                    const pts = Number(t?.points) || 0;
                    const throwsArr = asArray(t?.throws);
                    const darts = throwsArr.length; // 60+/100+/140+ (PDC-style: inclusive/overlapping buckets)
                    //  - 60+ counts every visit >= 60 (includes 100+/140+/170+/180)
                    //  - 100+ counts every visit >= 100 (includes 140+/170+/180)
                    //  - 140+ counts every visit >= 140 (includes 170+/180)
                    if (pts >= 60) scores60PlusPerPlayer[idx] += 1;
                    if (pts >= 100) scores100PlusPerPlayer[idx] += 1;
                    if (pts >= 140) scores140PlusPerPlayer[idx] += 1;

                    // 170+ / 180 (also inclusive; 180 is exact)
                    if (pts >= 170) scores170PlusPerPlayer[idx] += 1;
                    if (pts === 180) scores180PerPlayer[idx] += 1;

                    pointsFromTurns[idx] += Number.isFinite(pts) ? pts : 0;
                    dartsFromTurns[idx] += Number.isFinite(darts) ? darts : 0;

                    legPts[idx] += Number.isFinite(pts) ? pts : 0;
                    legDarts[idx] += Number.isFinite(darts) ? darts : 0;


                    // Derived X01 (Bust / Leaves / Routes) (0.14.190)
                    derivedVisitsPerPlayer[idx] += 1;

                    const scoreBefore = Number(legScores[idx]) || derivedStartScore;
                    let scoreAfter = NaN;
                    let isBust = false;

                    const sRaw = (t?.score != null) ? t.score
                        : (t?.remaining != null) ? t.remaining
                        : (t?.restScore != null) ? t.restScore
                        : (t?.scoreAfter != null) ? t.scoreAfter
                        : null;
                    const sNum = (sRaw != null) ? Number(sRaw) : NaN;

                    if (Number.isFinite(sNum)) {
                        scoreAfter = sNum;
                        if (scoreAfter === scoreBefore && pts > 0 && scoreBefore > 0 && scoreAfter > 0) isBust = true;
                    } else {
                        const sim = simulateX01Turn(scoreBefore, throwsArr, pts, outMode);
                        scoreAfter = Number(sim?.scoreAfter);
                        isBust = !!sim?.isBust;
                    }

                    if (!Number.isFinite(scoreAfter)) {
                        scoreAfter = scoreBefore;
                        isBust = false;
                    }

                    if (isBust) {
                        derivedBustsPerPlayer[idx] += 1;
                        derivedBustPointsPerPlayer[idx] += pts;
                    }

                    legScores[idx] = scoreAfter;

                    // Restscore / leave profiling (exclude 0 = checkout)
                    if (scoreAfter > 0) {
                        const leave = Math.round(scoreAfter);
                        const b = derivedLeaveBucketsPerPlayer[idx];
                        if (leave <= 40) b.le40 += 1;
                        else if (leave <= 80) b.le80 += 1;
                        else if (leave <= 120) b.le120 += 1;
                        else if (leave <= 170) b.le170 += 1;
                        else b.gt170 += 1;

                        if (isBogeyLeave(leave)) derivedBogeyLeavesPerPlayer[idx] += 1;
                        if (isOneDartFinishableLeave(leave)) derivedOneDartLeavesPerPlayer[idx] += 1;
                    }

                    // Checkout routes (only when scoreBefore is in checkout range)
                    if (scoreBefore > 0 && scoreBefore <= 170) {
                        derivedCheckoutOppsPerPlayer[idx] += 1;

                        const firstKey = (throwsArr && throwsArr.length)
                            ? (parseThrow(throwsArr[0])?.key || 'UNKNOWN')
                            : 'UNKNOWN';
                        try {
                            const mfd = derivedFirstDartCountsMap[idx];
                            if (mfd) mfd.set(firstKey, (mfd.get(firstKey) || 0) + 1);
                        } catch {}

                        let routeStr = '';
                        try {
                            const keys = (throwsArr || []).map(th => (parseThrow(th)?.key || '')).filter(Boolean);
                            routeStr = keys.join(' ');
                        } catch {}
                        if (!routeStr) routeStr = `PTS${Math.round(pts || 0)}`;

                        try {
                            const rm = derivedRouteCountsMap[idx];
                            if (rm) {
                                const cur = rm.get(routeStr) || { count: 0, hits: 0, busts: 0 };
                                cur.count += 1;
                                if (scoreAfter === 0) cur.hits += 1;
                                if (isBust) cur.busts += 1;
                                rm.set(routeStr, cur);
                            }
                        } catch {}

                        if (scoreAfter === 0) derivedCheckoutHitsPerPlayer[idx] += 1;
                    }

                    if (scoreAfter === 0) {
                        // Leg finished → stop processing further turns for this game
                        break;
                    }

                    // First 9: count up to 9 darts per player/leg (points proportional if a turn crosses the limit)
                    if (Number.isFinite(darts) && darts > 0) {
                        const soFar = Number(legF9SoFar[idx]) || 0;
                        if (soFar < 9) {
                            const take = Math.min(darts, 9 - soFar);
                            if (take > 0) {
                                const ptsUsed = (Number.isFinite(pts) ? pts : 0) * (take / darts);
                                legF9Pts[idx] += Number.isFinite(ptsUsed) ? ptsUsed : 0;
                                legF9Darts[idx] += take;
                                legF9SoFar[idx] += take;
                            }
                        }
                    }
                }

                // add leg first9 to match totals
                for (let i = 0; i < n; i++) {
                    first9PointsPerPlayer[i] += Number(legF9Pts[i]) || 0;
                    first9DartsPerPlayer[i] += Number(legF9Darts[i]) || 0;
                }

                const legDateIso = g?.finishedAt || g?.createdAt || finishedAt || createdAt;
                const legDayKey = parseIsoDateToDayKey(legDateIso) || dayKey;

                // duration (per leg)
                let legDurationSec = 0;
                const lg0 = g?.createdAt || g?.startedAt || null;
                const lg1 = g?.finishedAt || g?.endedAt || null;
                const lt0 = lg0 ? new Date(lg0).getTime() : NaN;
                const lt1 = lg1 ? new Date(lg1).getTime() : NaN;
                if (Number.isFinite(lt0) && Number.isFinite(lt1) && lt1 >= lt0) {
                    const diff = (lt1 - lt0) / 1000;
                    if (diff >= 0 && diff <= 6 * 3600) legDurationSec = diff;
                }
                if (!legDurationSec) legDurationSec = parseDurationToSeconds(g?.duration);
                // fallback: distribute match duration across legs
                if (!legDurationSec && durationSec && totalLegs) legDurationSec = durationSec / totalLegs;

                const perAvg = new Map();
                const perF9Avg = new Map();
                for (let i = 0; i < n; i++) {
                    const dt = Number(legDarts[i]) || 0;
                    const sc = Number(legPts[i]) || 0;
                    if (dt > 0) perAvg.set(players[i].key, (sc * 3) / dt);

                    const f9dt = Number(legF9Darts[i]) || 0;
                    const f9sc = Number(legF9Pts[i]) || 0;
                    if (f9dt > 0) perF9Avg.set(players[i].key, (f9sc * 3) / f9dt);
                }
                legTimeline.push({
                    matchId,
                    dateIso: legDateIso,
                    dayKey: legDayKey,
                    lineup: players.map(p => dispName(p.name)).join(", "),
                    perAvg,
                    perF9Avg,
                });

                // winner leg record
                const wIdx = getGameWinnerIndex(g);
                if (Number.isFinite(wIdx) && wIdx >= 0 && wIdx < n) {
                    legWinnerIdxSeq.push(wIdx);
                    legWinnerKeySeq.push(players[wIdx]?.key ? String(players[wIdx].key) : "");
                    if (legDurationSec > 0 && legDurationSec > (Number(longestLegSecPerPlayer[wIdx]) || 0)) {
                        longestLegSecPerPlayer[wIdx] = legDurationSec;
                    }
                    const dt = Number(legDarts[wIdx]) || 0;
                    const sc = Number(legPts[wIdx]) || 0;
                    const legAvg = dt > 0 ? (sc * 3) / dt : 0;

                    legWinners.push({
                        matchId,
                        gameId: g?.id || null,
                        dateIso: legDateIso,
                        playerKey: players[wIdx]?.key,
                        playerName: players[wIdx]?.name,
                        darts: dt,
                        avg: legAvg,
                    });
                }
            }

            // per-player match stats: checkouts etc, but override points/darts from turns
            const perPlayerStats = new Array(n).fill(null).map(() => ({
                dartsThrown: 0,
                score: 0,
                checkouts: 0,
                checkoutsHit: 0,
                average: null,
            }));

            const msArr = asArray(payload?.matchStats);
            for (const ms of msArr) {
                const idx = playerIdToIndex.get(ms?.playerId);
                if (!Number.isFinite(Number(idx))) continue;

                const checkouts = Number(ms?.checkouts ?? 0);
                const checkoutsHit = Number(ms?.checkoutsHit ?? 0);
                const avg = (ms?.average != null) ? Number(ms.average) : null;

                perPlayerStats[idx] = {
                    dartsThrown: 0,
                    score: 0,
                    checkouts: Number.isFinite(checkouts) ? checkouts : 0,
                    checkoutsHit: Number.isFinite(checkoutsHit) ? checkoutsHit : 0,
                    average: (avg != null && Number.isFinite(avg)) ? avg : null,
                };
            }

            for (let i = 0; i < n; i++) {
                const dt = Number(dartsFromTurns[i] || 0);
                const sc = Number(pointsFromTurns[i] || 0);
                perPlayerStats[i].dartsThrown = Number.isFinite(dt) ? dt : 0;
                perPlayerStats[i].score = Number.isFinite(sc) ? sc : 0;
                if (perPlayerStats[i].average == null) {
                    perPlayerStats[i].average = dt > 0 ? (sc * 3) / dt : 0;
                }
            }

            // checkout max per player (per match) + High Out count per player
            const checkoutMaxPerPlayer = new Array(n).fill(0);
            const highOutCountPerPlayer = new Array(n).fill(0);
            const legStatsArr = asArray(payload?.legStats);
            for (const leg of legStatsArr) {
                const stArr = asArray(leg?.stats);
                for (const st of stArr) {
                    const idx = playerIdToIndex.get(st?.playerId);
                    if (!Number.isFinite(Number(idx))) continue;
                    const cp = Number(st?.checkoutPoints ?? 0);
                    if (!Number.isFinite(cp)) continue;
                    if (cp > checkoutMaxPerPlayer[idx]) checkoutMaxPerPlayer[idx] = cp;
                    if (cp >= HIGH_OUT_MIN) highOutCountPerPlayer[idx] += 1;
                }
            }



            // Serialize derived X01 signals for downstream analytics / GPT (0.14.190)
            const firstDartCountsPerPlayer = derivedFirstDartCountsMap.map((mp) => {
                const o = {};
                try {
                    for (const [k, v] of (mp?.entries?.() || [])) {
                        if (!k) continue;
                        o[String(k)] = Math.max(0, Math.round(Number(v || 0) || 0));
                    }
                } catch {}
                return o;
            });

            const topRoutesPerPlayer = derivedRouteCountsMap.map((mp) => {
                try {
                    const arr = [];
                    for (const [route, st] of (mp?.entries?.() || [])) {
                        const r = String(route || '').trim();
                        if (!r) continue;
                        arr.push({
                            route: r,
                            count: Math.max(0, Math.round(Number(st?.count || 0) || 0)),
                            hits: Math.max(0, Math.round(Number(st?.hits || 0) || 0)),
                            busts: Math.max(0, Math.round(Number(st?.busts || 0) || 0)),
                        });
                    }
                    arr.sort((a, b) => (b.count - a.count) || (b.hits - a.hits));
                    return arr.slice(0, 12);
                } catch { return []; }
            });

            const x01Derived = {
                startScore: derivedStartScore,
                visitsPerPlayer: derivedVisitsPerPlayer,
                bustsPerPlayer: derivedBustsPerPlayer,
                bustPointsPerPlayer: derivedBustPointsPerPlayer,
                leaveBucketsPerPlayer: derivedLeaveBucketsPerPlayer,
                bogeyLeavesPerPlayer: derivedBogeyLeavesPerPlayer,
                oneDartLeavesPerPlayer: derivedOneDartLeavesPerPlayer,
                checkoutOppsPerPlayer: derivedCheckoutOppsPerPlayer,
                checkoutHitsPerPlayer: derivedCheckoutHitsPerPlayer,
                firstDartCountsPerPlayer,
                topRoutesPerPlayer,
            };
            if (winnerIndex == null || !Number.isFinite(Number(winnerIndex)) || winnerIndex < 0) continue;
            if (!totalLegs || totalLegs <= 0) continue;

            matches.push({
                matchId,
                createdAt,
                finishedAt,
                dayKey,
                durationSec,
                outMode,
                isDoubleOut,
                players: players.map(p => ({ index: p.index, key: p.key, name: p.name })),
                legsWon,
                totalLegs,
                winnerIndex: Number(winnerIndex),
                perPlayerStats,
                legWinners,
                legWinnerIdxSeq,
                legWinnerKeySeq,
                checkoutMaxPerPlayer,
                highOutCountPerPlayer,
                first9PointsPerPlayer,
                first9DartsPerPlayer,
                scores60PlusPerPlayer,
                scores100PlusPerPlayer,
                scores140PlusPerPlayer,
                legTimeline,
                scores170PlusPerPlayer,
                scores180PerPlayer,
                longestLegSecPerPlayer,
                x01Derived,
            });
        }

        return matches;
    }


    // Trainingsmodi (andere als Segment Training / X01) – für Trainingsplan (Ist-Werte)
    function mapVariantToTrainingActivityKey(variantName) {
        const v = String(variantName || "").toLowerCase().trim();
        if (!v) return null;

        // Note: Segment Training & X01 werden separat extrahiert
        if (v.includes("segment")) return "SEGMENT_TRAINING";
        if (v.includes("x01")) return "X01";

        if (v === "atc" || v.includes("around the clock") || v.includes("around-the-clock")) return "ATC";
        if (v.includes("countup") || v.includes("count up") || v.includes("count-up")) return "COUNTUP";
        if (v.includes("cricket")) return "CRICKET";
        if (v.includes("random checkout") || v.includes("random-checkout")) return "RANDOM_CHECKOUT";

        return null;
    }

    const DEBUG_ATC_COUNT = false; // 0.14.82 debug: infer ATC legs/games count

    function extractOtherTrainingModeSessionsFromRows(rows) {
        const out = [];
        const seen = new Set();

        for (const r of rows) {
            const payload = getRowPayload(r);
            if (!payload) continue;
            if (isSegmentTrainingPayload(payload) || isX01Payload(payload)) continue;

            const variant = normalizeVariantName(payload?.variant || payload?.mode || payload?.gameMode || payload?.type || payload?.name || "");
            const key = mapVariantToTrainingActivityKey(variant);
            if (!key || key === "SEGMENT_TRAINING" || key === "X01") continue;

            const matchId = payload.id || r?.matchId || payload.matchId || null;
            if (!matchId) continue;

            const createdAt = payload.createdAt || payload.startedAt || null;
            const finishedAt = payload.finishedAt || payload.endedAt || null;
            const dayKey = parseIsoDateToDayKey(createdAt) || parseIsoDateToDayKey(finishedAt);

            // duration (best effort)
            let durationSec = 0;
            const t0 = createdAt ? new Date(createdAt).getTime() : NaN;
            const t1 = finishedAt ? new Date(finishedAt).getTime() : NaN;
            if (Number.isFinite(t0) && Number.isFinite(t1) && t1 >= t0) {
                const diff = (t1 - t0) / 1000;
                if (diff >= 0 && diff <= 6 * 3600) durationSec = diff;
            }
            if (!durationSec) durationSec = parseDurationToSeconds(payload?.duration);

            const sig = `${matchId}|${key}`;
            if (seen.has(sig)) continue;
            seen.add(sig);

            let count = 1;
            if (key === "RANDOM_CHECKOUT" || key === "ATC" || key === "COUNTUP" || key === "CRICKET") {
                const a = Number(payload?.totalLegs);
                if (Number.isFinite(a) && a > 0) count = a;
                else if (Array.isArray(payload?.legStats) && payload.legStats.length > 0) count = payload.legStats.length;
                else if (Array.isArray(payload?.games) && payload.games.length > 0) count = payload.games.length;
                else count = 1;

                if (DEBUG_ATC_COUNT && (key === "ATC" || key === "COUNTUP" || key === "CRICKET")) {
                    try {
                        console.debug("[AD Ext][ATC count]", {
                            matchId,
                            variant,
                            totalLegs: payload?.totalLegs,
                            legStatsLen: Array.isArray(payload?.legStats) ? payload.legStats.length : 0,
                            gamesLen: Array.isArray(payload?.games) ? payload.games.length : 0,
                            count,
                        });
                    } catch {}
                }
            }
            let hits = 0, darts = 0;
            let checkoutHits = 0, checkoutAttempts = 0;
            let atcMode = "FULL";
            let fieldsAgg = {};
            if (key === "ATC") {
                const normAtcMode = (raw) => {
                    const s0 = String(raw || "").trim();
                    if (!s0) return "FULL";
                    const s = s0.toUpperCase()
                        .replace(/[\s\-]+/g, "_")
                        .replace(/_+/g, "_")
                        .replace(/^_+|_+$/g, "");
                    if (s === "FULL" || s === "ALL" || s === "DEFAULT") return "FULL";
                    if (s === "OUTER_SINGLE" || s === "OUTERSINGLE") return "OUTER_SINGLE";
                    if (s.includes("OUTER") && s.includes("SINGLE")) return "OUTER_SINGLE";
                    if (s === "SINGLE" || s.endsWith("_SINGLE")) return "SINGLE";
                    if (s === "DOUBLE" || s.includes("DOUBLE")) return "DOUBLE";
                    if (s === "TRIPLE" || s.includes("TRIPLE")) return "TRIPLE";
                    return "FULL";
                };
                const rawMode =
                    payload?.mode ??
                    payload?.settings?.mode ??
                    payload?.settings?.variant ??
                    payload?.settings?.gameMode ??
                    payload?.settings?.type ??
                    payload?.settings?.name ??
                    payload?.variant ??
                    payload?.gameMode ??
                    payload?.type ??
                    payload?.name ??
                    null;
                atcMode = normAtcMode(rawMode);

                const getNumAny = (obj, keys) => {
                    if (!obj) return 0;
                    for (const k of keys) {
                        const v = obj?.[k];
                        if (Array.isArray(v)) return v.length;
                        const n = Number(v);
                        if (Number.isFinite(n)) return n;
                    }
                    return 0;
                };
                const addFrom = (obj) => {
                    if (!obj || typeof obj !== "object") return;
                    hits += getNumAny(obj, ["hits", "hit", "hitCount", "hit_count", "totalHits", "successfulHits", "successHits"]);
                    darts += getNumAny(obj, ["darts", "dartsThrown", "darts_thrown", "throws", "throwsThrown", "attempts", "totalDarts", "totalThrows"]);
                };
                const addLegStats = (legStats) => {
                    if (!Array.isArray(legStats) || !legStats.length) return;
                    for (const st of legStats) {
                        addFrom(st);
                        const ss = st?.stats;
                        if (Array.isArray(ss)) {
                            for (const s of ss) addFrom(s);
                        } else {
                            addFrom(ss);
                        }
                    }
                };
                try {
                    addLegStats(payload?.legStats);
                } catch {}
                if (!(darts > 0)) {
                    try { addFrom(payload?.stats); addFrom(payload); } catch {}
                }
                if (!(darts > 0)) {
                    try {
                        const games = payload?.games;
                        if (Array.isArray(games) && games.length) {
                            for (const g of games) {
                                addFrom(g);
                                addFrom(g?.stats);
                                addLegStats(g?.legStats);
                                darts += getNumAny(g?.settings, ["throws", "darts", "dartsThrown"]);
                            }
                        }
                    } catch {}
                }
                // last fallback: raw throws/darts arrays
                if (!(darts > 0)) {
                    try {
                        const arr =
                              (Array.isArray(payload?.throws) && payload.throws) ||
                              (Array.isArray(payload?.darts) && payload.darts) ||
                              (Array.isArray(payload?.dartsThrown) && payload.dartsThrown) ||
                              (Array.isArray(payload?.attempts) && payload.attempts) ||
                              null;
                        if (arr && arr.length) {
                            darts += arr.length;
                            for (const it of arr) {
                                if (it === true || it === 1) { hits += 1; continue; }
                                if (it && typeof it === "object") {
                                    const h = it.hit ?? it.success ?? it.isHit ?? it.isSuccess ?? it.ok;
                                    if (h === true || h === 1) hits += 1;
                                }
                            }
                        }
                    } catch {}
                }
                hits = (Number.isFinite(hits) ? Math.max(0, hits) : 0);
                darts = (Number.isFinite(darts) ? Math.max(0, darts) : 0);

                // Fields aggregation (best effort)
                const extractFieldsAgg = () => {
                    const out = {};

                    const add = (field, dAdd, hAdd) => {
                        const k = String(field || "").trim();
                        if (!k) return;
                        if (!out[k]) out[k] = { darts: 0, hits: 0 };
                        out[k].darts += Math.max(0, Number(dAdd) || 0);
                        out[k].hits += Math.max(0, Number(hAdd) || 0);
                    };

                    const normField = (raw) => {
                        if (raw == null) return null;
                        if (typeof raw === "number") {
                            if (raw === 25 || raw === 50) return "BULL";
                            if (raw >= 1 && raw <= 20) return String(raw);
                            return null;
                        }
                        const s0 = String(raw || "").trim();
                        if (!s0) return null;
                        const s = s0.toUpperCase();
                        if (s.includes("BULL") || s === "25" || s === "50" || s === "SB" || s === "DB") return "BULL";

                        const m = s.match(/(\d{1,2})/);
                        if (m) {
                            const n = parseInt(m[1], 10);
                            if (Number.isFinite(n) && n >= 1 && n <= 20) return String(n);
                        }
                        return null;
                    };

                    const getNumMaybe = (obj, keys) => {
                        if (!obj || typeof obj !== "object") return null;
                        for (const k of keys) {
                            const v = obj?.[k];
                            if (Array.isArray(v)) return v.length;
                            const n = Number(v);
                            if (Number.isFinite(n)) return n;
                        }
                        return null;
                    };

                    const tryAddFromRecord = (rec, fallbackField = null) => {
                        if (rec == null) return false;

                        let fieldRaw = null;
                        if (typeof rec === "string" || typeof rec === "number") fieldRaw = rec;
                        else if (typeof rec === "object") {
                            fieldRaw = rec.field ?? rec.target ?? rec.number ?? rec.value ?? rec.segment ?? rec.label ?? rec.name ?? null;
                            if (fieldRaw && typeof fieldRaw === "object") {
                                fieldRaw = fieldRaw.value ?? fieldRaw.number ?? fieldRaw.label ?? fieldRaw.name ?? fieldRaw.segment ?? fieldRaw.field ?? fieldRaw.target ?? null;
                            }
                        }
                        const field = normField(fieldRaw ?? fallbackField);
                        if (!field) return false;

                        let d = null, h = null;
                        if (rec && typeof rec === "object") {
                            d = getNumMaybe(rec, ["darts", "dartsThrown", "darts_thrown", "throws", "throwsThrown", "attempts", "totalDarts", "totalThrows", "count", "tries"]);
                            h = getNumMaybe(rec, ["hits", "hitCount", "hit_count", "totalHits", "successHits", "successfulHits"]);
                        }

                        const boolHit = (rec && typeof rec === "object") ? (rec.hit ?? rec.success ?? rec.isHit ?? rec.isSuccess ?? rec.ok) : null;
                        const hasBool = (boolHit === true || boolHit === false || boolHit === 1 || boolHit === 0);
                        if (d == null && hasBool) d = 1;
                        if (h == null && hasBool) h = (boolHit === true || boolHit === 1) ? 1 : 0;

                        if (typeof rec === "string" || typeof rec === "number") {
                            d = 1;
                            if (h == null) h = 0;
                        }

                        const dOk = Number.isFinite(Number(d)) && Number(d) > 0;
                        const hOk = Number.isFinite(Number(h)) && Number(h) >= 0;
                        if (!dOk && !hOk) return false;

                        add(field, dOk ? Number(d) : 0, hOk ? Number(h) : 0);
                        return true;
                    };

                    const scan = (node, depth = 0) => {
                        if (!node || depth > 4) return;

                        if (Array.isArray(node)) {
                            for (const it of node) scan(it, depth + 1);
                            return;
                        }

                        if (typeof node !== "object") {
                            tryAddFromRecord(node, null);
                            return;
                        }

                        const hasFieldish =
                            ("field" in node) || ("target" in node) || ("number" in node) || ("segment" in node) ||
                            ("label" in node) || ("name" in node) || ("value" in node);

                        if (!hasFieldish) {
                            try {
                                for (const [k, v] of Object.entries(node)) {
                                    const fk = normField(k);
                                    if (!fk) continue;
                                    if (v && typeof v === "object") {
                                        tryAddFromRecord(v, fk);
                                    }
                                }
                            } catch {}
                        }

                        tryAddFromRecord(node, null);

                        const nestedKeys = ["stats", "legStats", "games", "throws", "darts", "attempts"];
                        for (const k of nestedKeys) {
                            const v = node?.[k];
                            if (!v) continue;
                            if (Array.isArray(v) || typeof v === "object") scan(v, depth + 1);
                        }
                    };

                    try { scan(payload?.legStats); } catch {}
                    if (!Object.keys(out).length) { try { scan(payload?.stats); } catch {} }
                    if (!Object.keys(out).length) { try { scan(payload?.games); } catch {} }
                    if (!Object.keys(out).length) {
                        try {
                            const arr =
                                  (Array.isArray(payload?.throws) && payload.throws) ||
                                  (Array.isArray(payload?.darts) && payload.darts) ||
                                  (Array.isArray(payload?.dartsThrown) && payload.dartsThrown) ||
                                  (Array.isArray(payload?.attempts) && payload.attempts) ||
                                  null;
                            scan(arr);
                        } catch {}
                    }

                    // normalize numeric values
                    for (const k of Object.keys(out)) {
                        const v = out[k] || {};
                        const dd = Number(v?.darts);
                        const hh = Number(v?.hits);
                        out[k] = {
                            darts: Number.isFinite(dd) ? Math.max(0, dd) : 0,
                            hits: Number.isFinite(hh) ? Math.max(0, hh) : 0,
                        };
                    }

                    return out;
                };

                try { fieldsAgg = extractFieldsAgg(); } catch { fieldsAgg = {}; }
                if (!fieldsAgg || typeof fieldsAgg !== "object") fieldsAgg = {};

                if (DEBUG_ATC_COUNT) {
                    try {
                        const keys = Object.keys(fieldsAgg || {});
                        let sumD = 0, sumH = 0;
                        for (const k of keys) {
                            const v = fieldsAgg?.[k];
                            sumD += Math.max(0, Number(v?.darts) || 0);
                            sumH += Math.max(0, Number(v?.hits) || 0);
                        }
                        console.debug("[AD Ext][ATC fieldsAgg]", {
                            matchId,
                            mode: atcMode,
                            fieldsAggKeys: keys,
                            fieldsAggDarts: sumD,
                            fieldsAggHits: sumH,
                        });
                        if ((Number(darts) || 0) > 0 && (!keys || !keys.length)) {
                            console.debug("[AD Ext][ATC] field extraction failed", { matchId, mode: atcMode, darts, hits });
                        }
                    } catch {}
                }


                if (DEBUG_ATC_COUNT) {
                    try {
                        console.debug("[AD Ext][ATC hit%]", {
                            matchId,
                            variant,
                            count,
                            hits,
                            darts,
                            hitPct: darts ? (hits / darts * 100) : null,
                            legStatsType: typeof payload?.legStats,
                            sampleLeg0: payload?.legStats?.[0],
                            sampleLeg0Stats0: payload?.legStats?.[0]?.stats?.[0],
                        });
                        if ((Number(count) || 0) > 0 && darts === 0) {
                            console.debug("[AD Ext][ATC] ATC darts still 0 - extraction failed", { matchId, variant, count });
                        }
                    } catch {}
                }
            }

            if (key === "RANDOM_CHECKOUT") {
                // Best-effort: Hits/Darts + Checkout-Stats aus Payload lesen (keine Rohwurf-Rekonstruktion)
                const getNumAny = (obj, keys) => {
                    if (!obj) return 0;
                    for (const k of keys) {
                        const v = obj?.[k];
                        if (Array.isArray(v)) return v.length;
                        const n = Number(v);
                        if (Number.isFinite(n)) return n;
                    }
                    return 0;
                };

                const addFrom = (obj) => {
                    if (!obj || typeof obj !== "object") return;
                    hits += getNumAny(obj, ["hits", "hit", "hitCount", "hit_count", "totalHits", "successfulHits", "successHits"]);
                    darts += getNumAny(obj, ["darts", "dartsThrown", "darts_thrown", "throws", "throwsThrown", "attempts", "totalDarts", "totalThrows"]);
                    checkoutHits += getNumAny(obj, ["checkoutHits", "checkoutsHit", "checkoutMade", "coHits", "coHit"]);
                    checkoutAttempts += getNumAny(obj, ["checkoutAttempts", "checkoutChances", "checkouts", "coAttempts", "coOpps", "coOpp"]);
                };

                const addLegStats = (legStats) => {
                    if (!Array.isArray(legStats) || !legStats.length) return;
                    for (const st of legStats) {
                        addFrom(st);
                        const ss = st?.stats;
                        if (Array.isArray(ss)) {
                            for (const s of ss) addFrom(s);
                        } else {
                            addFrom(ss);
                        }
                    }
                };

                try { addLegStats(payload?.legStats); } catch {}
                if (!(darts > 0 || checkoutAttempts > 0)) {
                    try { addFrom(payload?.stats); addFrom(payload); } catch {}
                }
                if (!(darts > 0 || checkoutAttempts > 0)) {
                    try {
                        const games = payload?.games;
                        if (Array.isArray(games) && games.length) {
                            for (const g of games) {
                                addFrom(g);
                                addFrom(g?.stats);
                                addLegStats(g?.legStats);
                                darts += getNumAny(g?.settings, ["throws", "darts", "dartsThrown"]);
                            }
                        }
                    } catch {}
                }

                // last fallback: raw arrays (nur bool hits zählen, wenn vorhanden)
                if (!(darts > 0)) {
                    try {
                        const arr =
                              (Array.isArray(payload?.throws) && payload.throws) ||
                              (Array.isArray(payload?.darts) && payload.darts) ||
                              (Array.isArray(payload?.dartsThrown) && payload.dartsThrown) ||
                              (Array.isArray(payload?.attempts) && payload.attempts) ||
                              null;
                        if (arr && arr.length) {
                            darts += arr.length;
                            for (const it of arr) {
                                if (it === true || it === 1) { hits += 1; continue; }
                                if (it && typeof it === "object") {
                                    const h = it.hit ?? it.success ?? it.isHit ?? it.isSuccess ?? it.ok;
                                    if (h === true || h === 1) hits += 1;
                                }
                            }
                        }
                    } catch {}
                }

                hits = (Number.isFinite(hits) ? Math.max(0, hits) : 0);
                darts = (Number.isFinite(darts) ? Math.max(0, darts) : 0);
                checkoutHits = (Number.isFinite(checkoutHits) ? Math.max(0, checkoutHits) : 0);
                checkoutAttempts = (Number.isFinite(checkoutAttempts) ? Math.max(0, checkoutAttempts) : 0);
            }


            const obj = {
                matchId,
                activityKey: key,
                variant,
                createdAt,
                finishedAt,
                dayKey,
                durationSec,
                count,
            };
            if (key === "ATC") {
                obj.hits = hits;
                obj.darts = darts;
                obj.mode = atcMode;
                obj.fieldsAgg = fieldsAgg;
            }
            if (key === "RANDOM_CHECKOUT") {
                obj.hits = hits;
                obj.darts = darts;
                obj.checkoutHits = checkoutHits;
                obj.checkoutAttempts = checkoutAttempts;
            }
            out.push(obj);
        }

        return out;
    }

    function computeLegsPlayedTotalsByPlayerKey(x01Matches) {
        const totals = new Map();
        for (const m of x01Matches) {
            const tl = Number(m?.totalLegs ?? 0);
            if (!Number.isFinite(tl) || tl <= 0) continue;
            for (const p of m.players) {
                const k = p?.key;
                if (!k) continue;
                totals.set(k, (totals.get(k) || 0) + tl);
            }
        }
        return totals;
    }

    function chooseAutoPlayerKey(x01Matches, legsPlayedTotalsByKey = null, minLegsPlayed = 0) {
        const counts = new Map();
        for (const m of x01Matches) {
            for (const p of m.players) {
                const k = p?.key;
                if (!k) continue;
                if (legsPlayedTotalsByKey && (Number(minLegsPlayed) || 0) > 0) {
                    const lp = Number(legsPlayedTotalsByKey.get(k) || 0) || 0;
                    if (lp < (Number(minLegsPlayed) || 0)) continue;
                }
                counts.set(k, (counts.get(k) || 0) + 1);
            }
        }
        let bestKey = null, bestCnt = -1;
        for (const [k, c] of counts.entries()) {
            if (c > bestCnt) { bestCnt = c; bestKey = k; }
        }
        return bestKey;
    }

    function listPlayersFromMatches(x01Matches) {
        const m = new Map();
        for (const match of x01Matches) {
            for (const p of match.players) {
                if (!p?.key) continue;
                const cur = m.get(p.key);
                if (!cur) m.set(p.key, { key: p.key, name: p.name, count: 1 });
                else {
                    cur.count += 1;
                    if ((p.name || "").length > (cur.name || "").length && !/^Player\s+\d+$/i.test(p.name || "")) cur.name = p.name;
                }
            }
        }
        const arr = Array.from(m.values());
        arr.sort((a, b) => b.count - a.count || a.name.localeCompare(b.name));
        return arr;
    }

    function comboKeyFromMatch(match) {
        const keys = match.players.map(p => p.key).filter(Boolean);
        keys.sort((a, b) => String(a).localeCompare(String(b)));
        return keys.join("|");
    }

    function listCombosForPlayer(x01Matches, playerKey) {
        const combos = new Map();

        for (const match of x01Matches) {
            const hasPlayer = match.players.some(p => p.key === playerKey);
            if (!hasPlayer) continue;

            const keys = match.players.map(p => p.key).filter(Boolean);
            const keySet = new Set(keys);
            if (!keySet.has(playerKey)) continue;

            const sortedKeys = Array.from(keySet).sort((a, b) => String(a).localeCompare(String(b)));
            const cKey = sortedKeys.join("|");

            let rec = combos.get(cKey);
            if (!rec) {
                const nameByKey = new Map(match.players.map(p => [p.key, p.name]));
                const playerName = dispName(nameByKey.get(playerKey) || "Ich");

                const others = sortedKeys
                .filter(k => k !== playerKey)
                .map(k => ({ key: k, name: dispName(nameByKey.get(k) || k) }))
                .sort((a, b) => String(a.name).localeCompare(String(b.name)));

                const label = [playerName, ...others.map(o => o.name)].join(" | ");
                rec = { comboKey: cKey, count: 0, keys: sortedKeys, label };
                combos.set(cKey, rec);
            }
            rec.count += 1;
        }

        const arr = Array.from(combos.values());
        arr.sort((a, b) => b.count - a.count || a.label.localeCompare(b.label));
        return arr;
    }

    function computeLeagueTable(x01MatchesFiltered) {
        const table = new Map();

        for (const match of x01MatchesFiltered) {
            const totalLegs = Number(match.totalLegs) || 0;
            const wIdx = Number(match.winnerIndex);
            if (!Number.isFinite(wIdx) || wIdx < 0) continue;
            if (!totalLegs) continue;

            const psArr = asArray(match.perPlayerStats);
            const f9PtsArr = asArray(match.first9PointsPerPlayer);
            const f9DartsArr = asArray(match.first9DartsPerPlayer);

            for (const p of match.players) {
                const key = p.key;
                if (!key) continue;

                if (!table.has(key)) {
                    table.set(key, {
                        key,
                        name: p.name,
                        matches: 0,
                        wins: 0,
                        losses: 0,
                        pointsFor: 0,
                        pointsAgainst: 0,
                        legsFor: 0,
                        legsAgainst: 0,

                        // extra KPIs
                        scorePoints: 0, // total points scored (X01 score)
                        dartsThrown: 0, // total darts thrown
                        coAtt: 0, // checkout attempts
                        coHit: 0, // checkout hits
                        first9Points: 0, // points in first 9 darts (summed over legs)
                        first9Darts: 0, // darts counted for first 9 (<=9 per leg)
                    });
                }

                const s = table.get(key);
                s.name = s.name || p.name;

                s.matches += 1;

                const idx = Number(p.index);
                const legsWon = Number(match.legsWon?.[idx] ?? 0) || 0;
                const legsLost = Math.max(0, totalLegs - legsWon);

                s.legsFor += legsWon;
                s.legsAgainst += legsLost;

                // per-player stat totals (for new KPIs)
                const ps = psArr?.[idx] || {};
                s.scorePoints += Number(ps.score) || 0;
                s.dartsThrown += Number(ps.dartsThrown) || 0;
                s.coAtt += Number(ps.checkouts) || 0;
                s.coHit += Number(ps.checkoutsHit) || 0;

                s.first9Points += Number(f9PtsArr?.[idx]) || 0;
                s.first9Darts += Number(f9DartsArr?.[idx]) || 0;

                if (idx === wIdx) {
                    s.wins += 1;
                    s.pointsFor += 2;
                } else {
                    s.losses += 1;
                    s.pointsAgainst += 2;
                }
            }
        }

        const arr = Array.from(table.values()).map((s) => {
            const legDiff = (s.legsFor - s.legsAgainst);
            const pointsDiff = (s.pointsFor - s.pointsAgainst);

            const first9Avg = s.first9Darts > 0 ? (s.first9Points * 3) / s.first9Darts : NaN;
            const pointsPerDart = s.dartsThrown > 0 ? (s.scorePoints / s.dartsThrown) : NaN;
            const checkoutPct = s.coAtt > 0 ? (s.coHit / s.coAtt) : NaN;

            return {
                ...s,
                pointsDiff,
                legDiff,
                first9Avg,
                pointsPerDart,
                checkoutPct,
            };
        });

        // default league ordering (points, points diff, leg diff, legs, name)
        arr.sort((a, b) => {
            if (b.pointsFor !== a.pointsFor) return b.pointsFor - a.pointsFor;
            if (b.pointsDiff !== a.pointsDiff) return b.pointsDiff - a.pointsDiff;
            if (b.legDiff !== a.legDiff) return b.legDiff - a.legDiff;
            if (b.legsFor !== a.legsFor) return b.legsFor - a.legsFor;
            return String(a.name).localeCompare(String(b.name));
        });

        return arr;
    }



    // =========================
    // X01: League sorting (table)
    // =========================
    function leagueSortValue(row, sortKey) {
        const k = String(sortKey || "pointsFor");
        if (k === "name") return String(dispName(row?.name || "")).toLowerCase();

        if (k === "matches") return Number(row?.matches) || 0;
        if (k === "wins") return Number(row?.wins) || 0;
        if (k === "losses") return Number(row?.losses) || 0;

        if (k === "pointsFor") return Number(row?.pointsFor) || 0;
        if (k === "pointsDiff") return Number(row?.pointsDiff) || 0;
        if (k === "legsFor") return Number(row?.legsFor) || 0;
        if (k === "legDiff") return Number(row?.legDiff) || 0;

        if (k === "first9Avg") return Number(row?.first9Avg);
        if (k === "pointsPerDart") return Number(row?.pointsPerDart);
        if (k === "checkoutPct") return Number(row?.checkoutPct);

        // fallback
        return Number(row?.pointsFor) || 0;
    }

    function sortLeagueRows(league, sortKey, sortDir) {
        const key = String(sortKey || "pointsFor");
        const dir = (String(sortDir || "desc").toLowerCase() === "asc") ? 1 : -1;

        const arr = (league || []).slice();

        arr.sort((a, b) => {
            if (key === "name") {
                const sa = String(leagueSortValue(a, key) || "");
                const sb = String(leagueSortValue(b, key) || "");
                const cmp = sa.localeCompare(sb);
                if (cmp !== 0) return dir * cmp;
            } else {
                const va = Number(leagueSortValue(a, key));
                const vb = Number(leagueSortValue(b, key));
                const fa = Number.isFinite(va);
                const fb = Number.isFinite(vb);

                // unknown/NaN always to the bottom
                if (fa && !fb) return -1;
                if (!fa && fb) return 1;

                if (fa && fb && va !== vb) return dir * (va - vb);
            }

            // fallback: stable "league" order
            if (b.pointsFor !== a.pointsFor) return b.pointsFor - a.pointsFor;
            if (b.pointsDiff !== a.pointsDiff) return b.pointsDiff - a.pointsDiff;
            if (b.legDiff !== a.legDiff) return b.legDiff - a.legDiff;
            if (b.legsFor !== a.legsFor) return b.legsFor - a.legsFor;
            return String(a.name).localeCompare(String(b.name));
        });

        return arr;
    }

    function updateX01LeagueSortIndicators(panel) {
        const table = panel?.querySelector?.("#ad-ext-x01-league-table");
        if (!table) return;

        const key = String(cache?.filtersX01?.leagueSortKey || "pointsFor");
        const dir = (String(cache?.filtersX01?.leagueSortDir || "desc").toLowerCase() === "asc") ? "asc" : "desc";

        const ths = table.querySelectorAll("th[data-sort-key]");
        for (const th of ths) {
            const k = th.getAttribute("data-sort-key");
            if (k === key) th.setAttribute("data-sort-dir", dir);
            else th.removeAttribute("data-sort-dir");
        }
    }

    // =========================
    // X01: KPI aggregation
    // =========================
    function computeX01Kpis(matches, selectedPlayerKeyOrNull) {
        let matchesCount = 0;
        let legs = 0;
        let darts = 0;
        let points = 0;
        let coAtt = 0;
        let coHit = 0;
        let timeSec = 0;

        let first9Points = 0;
        let first9Darts = 0;

        let bestAvg = -Infinity;
        let bestPoints = -Infinity;

        for (const m of matches) {
            const psArr = asArray(m.perPlayerStats);
            const f9PtsArr = asArray(m.first9PointsPerPlayer);
            const f9DartsArr = asArray(m.first9DartsPerPlayer);

            if (!selectedPlayerKeyOrNull) {
                matchesCount += 1;
                timeSec += Number(m.durationSec) || 0;

                // total legs in match (sum of legsWon across players)
                legs += (m.legsWon || []).reduce((a, x) => a + (Number(x) || 0), 0);

                for (let i = 0; i < psArr.length; i++) {
                    const ps = psArr[i] || {};
                    const dt = Number(ps.dartsThrown) || 0;
                    const sc = Number(ps.score) || 0;
                    const ca = Number(ps.checkouts) || 0;
                    const ch = Number(ps.checkoutsHit) || 0;

                    darts += dt;
                    points += sc;
                    coAtt += ca;
                    coHit += ch;

                    first9Points += Number(f9PtsArr?.[i]) || 0;
                    first9Darts += Number(f9DartsArr?.[i]) || 0;

                    if (Number.isFinite(sc)) bestPoints = Math.max(bestPoints, sc);

                    const avg = (ps.average != null && Number.isFinite(Number(ps.average)))
                    ? Number(ps.average)
                    : (dt > 0 ? (sc * 3) / dt : 0);

                    if (Number.isFinite(avg)) bestAvg = Math.max(bestAvg, avg);
                }
            } else {
                const pl = m.players.find(p => p.key === selectedPlayerKeyOrNull);
                const idx = pl ? Number(pl.index) : NaN;
                if (!Number.isFinite(idx) || idx < 0) continue;

                matchesCount += 1;
                timeSec += Number(m.durationSec) || 0;

                legs += (m.legsWon || []).reduce((a, x) => a + (Number(x) || 0), 0);

                const ps = psArr?.[idx] || {};
                const dt = Number(ps.dartsThrown) || 0;
                const sc = Number(ps.score) || 0;
                const ca = Number(ps.checkouts) || 0;
                const ch = Number(ps.checkoutsHit) || 0;

                darts += dt;
                points += sc;
                coAtt += ca;
                coHit += ch;

                first9Points += Number(f9PtsArr?.[idx]) || 0;
                first9Darts += Number(f9DartsArr?.[idx]) || 0;

                if (Number.isFinite(sc)) bestPoints = Math.max(bestPoints, sc);

                const avg = (ps.average != null && Number.isFinite(Number(ps.average)))
                ? Number(ps.average)
                : (dt > 0 ? (sc * 3) / dt : 0);

                if (Number.isFinite(avg)) bestAvg = Math.max(bestAvg, avg);
            }
        }

        const avgOverall = darts > 0 ? (points * 3) / darts : NaN;
        const coRatio = coAtt > 0 ? (coHit / coAtt) : NaN;

        const first9Avg = first9Darts > 0 ? (first9Points * 3) / first9Darts : NaN;
        const pointsPerDart = darts > 0 ? (points / darts) : NaN;

        return {
            matches: matchesCount,
            legs,
            darts,
            points,
            bestPoints: Number.isFinite(bestPoints) && bestPoints > -Infinity ? bestPoints : NaN,
            coAtt,
            coHit,
            coRatio,
            avgOverall,
            bestAvg: Number.isFinite(bestAvg) && bestAvg > -Infinity ? bestAvg : NaN,
            first9Points,
            first9Darts,
            first9Avg,
            pointsPerDart,
            timeSec,
        };
    }

    // =========================
    // Styles
    // =========================
    function injectStyles() {
        if (document.getElementById("ad-ext-style")) return;

        const style = document.createElement("style");
        style.id = "ad-ext-style";
        style.textContent = `
      .ad-ext-root {
        /* Layout-Variablen (zentrale Layout-Schicht) */
        --ad-font-size: clamp(14px, 0.65vw, 16px);
        --ad-gap: 14px;
        --ad-padding: 18px 22px 26px;
        --ad-card-padding: 12px 14px;
        --ad-columns: 2;
        --ad-chart-height: 170px;
        --ad-table-font-size: 13px;
        --ad-chart-panel-height: 460px;
        --ad-grid-min: 420px;
        --ad-filter-min: 320px;

        padding: var(--ad-padding);
        color: rgba(255,255,255,0.92);
        font-size: var(--ad-font-size);
      }
      .ad-ext-title { font-size: 18px; font-weight: 800; margin-bottom: 10px; letter-spacing: 0.02em; }
      .ad-ext-subtitle { font-size: 12px; opacity: 0.82; text-transform: uppercase; letter-spacing: 0.10em; margin-bottom: 6px; }
      .ad-ext-source-label { font-size: 11px; opacity: 0.74; text-align: right; }

      .ad-ext-icon-btn {
        display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; height: 28px;
        background: rgba(30, 55, 110, 0.38);
        border: 1px solid rgba(120,160,255,0.35);
        border-radius: 10px; color: rgba(255,255,255,0.92); font-size: 12px; cursor: pointer;
        transition: all 0.15s ease; user-select: none;
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
      }
      .ad-ext-icon-btn:hover { background: rgba(40, 75, 150, 0.42); border-color: rgba(160,200,255,0.45); }
      .ad-ext-icon-btn:active { background: rgba(40, 75, 150, 0.46); border-color: rgba(160,200,255,0.45); transform: none; }
      .ad-ext-icon-btn:focus { outline: none; box-shadow: none; }
      .ad-ext-icon-btn:focus:not(:focus-visible) { outline: none; box-shadow: none; }
      .ad-ext-icon-btn:focus-visible { outline: 2px solid rgba(140,190,255,0.55); outline-offset: 2px; }

      .ad-ext-icon { font-size: 14px; line-height: 1; }

      /* Header: Settings Menü (Dropdown) */
      .ad-ext-header-actions { position: relative; display: inline-flex; align-items: center; justify-content: flex-end; gap: 6px; margin-bottom: 6px; }
      .ad-ext-settings-btn { width: 34px; padding: 0; justify-content: center; }
      .ad-ext-settings-page-btn[aria-pressed="true"] { background: rgba(40, 75, 150, 0.46); border-color: rgba(160,200,255,0.45); }

      .ad-ext-menu {
        position: absolute;
        top: 34px;
        right: 0;
        min-width: 260px;
        max-width: 340px;
        background: rgba(10,14,30,0.92);
        border: 1px solid rgba(140,190,255,0.45);
        box-shadow: 0 18px 60px rgba(0,0,0,0.35);
        border-radius: 14px;
        padding: 8px;
        z-index: 999999;
        overflow: visible;
      }
      .ad-ext-menu-panel { display: flex; flex-direction: column; gap: 8px; }

      /* Flyout submenu (Ansicht): do not replace main panel; show as side panel */
      .ad-ext-menu-panel[data-ad-ext-menu-panel="view"]{
        position: absolute;
        top: 0;
        right: calc(100% + 10px);
        min-width: 240px;
        max-width: 340px;
        background: rgba(10,14,30,0.92);
        border: 1px solid rgba(140,190,255,0.45);
        box-shadow: 0 18px 60px rgba(0,0,0,0.35);
        border-radius: 14px;
        padding: 8px;
      }
      .ad-ext-menu-item {
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 8px 10px;
        background: rgba(255,255,255,0.04);
        border: 1px solid rgba(255,255,255,0.10);
        border-radius: 12px;
        color: rgba(255,255,255,0.92);
        font-weight: 900;
        font-size: 12px;
        cursor: pointer;
        user-select: none;
      }
      .ad-ext-menu-item:hover { background: rgba(140,190,255,0.12); border-color: rgba(140,190,255,0.25); }
      .ad-ext-menu-btn { justify-content: flex-start; }
      .ad-ext-menu-row { cursor: default; }
      .ad-ext-menu-row:hover { background: rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.10); }
      .ad-ext-menu-text { opacity: 0.92; }

      .ad-ext-switch-wrap { display: inline-flex; align-items: center; gap: 8px; }
      .ad-ext-switch-label {
        font-size: 11px;
        font-weight: 900;
        letter-spacing: 0.02em;
        opacity: 0.72;
        min-width: 22px;
        text-align: right;
        user-select: none;
      }
      .ad-ext-switch-label[data-ad-ext-on="1"] { opacity: 0.92; }
      .ad-ext-menu-nav { justify-content: space-between; }
      .ad-ext-menu-chevron { opacity: 0.70; font-size: 16px; }
      .ad-ext-menu-back { justify-content: flex-start; }
      .ad-ext-menu-title {
        padding: 2px 10px 0;
        font-size: 11px;
        opacity: 0.78;
        letter-spacing: 0.10em;
        text-transform: uppercase;
        font-weight: 950;
      }
      .ad-ext-menu-hint { padding: 0 10px 2px; font-size: 11px; opacity: 0.75; }

      /* Switch (Toggle) */
      .ad-ext-switch {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        border: none;
        background: transparent;
        cursor: pointer;
      }
      .ad-ext-switch-track {
        width: 42px;
        height: 22px;
        border-radius: 999px;
        position: relative;
        background: rgba(255,255,255,0.10);
        border: 1px solid rgba(140,190,255,0.45);
        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.12);
      }
      .ad-ext-switch-thumb {
        width: 18px;
        height: 18px;
        border-radius: 999px;
        position: absolute;
        top: 1px;
        left: 1px;
        background: rgba(255,255,255,0.80);
        transition: transform 0.15s ease, background 0.15s ease;
      }
      .ad-ext-switch[aria-checked="true"] .ad-ext-switch-track {
        background: rgba(0,150,255,0.28);
        border-color: rgba(140,190,255,0.65);
      }
      .ad-ext-switch[aria-checked="true"] .ad-ext-switch-thumb {
        background: rgba(255,255,255,0.92);
        transform: translateX(20px);
      }

      /* Kompakt auf sehr schmalen Screens */
      @media (max-width: 420px) {
        .ad-ext-menu { min-width: 220px; }
      }

      .ad-ext-subnav { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; margin-bottom: 12px; border-bottom: 1px solid rgba(255,255,255,0.14); }
      .ad-ext-subnav-btn { border: none; background: transparent; color: rgba(255,255,255,0.72); padding: 4px 10px 8px; font-size: 13px; cursor: pointer; border-bottom: 2px solid transparent; user-select: none; font-weight: 900; letter-spacing: 0.02em; }
      .ad-ext-subnav-btn--active { color: rgba(255,255,255,0.98); border-color: rgba(140,190,255,0.95); }

      .ad-ext-kpi-grid { display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 14px; margin: 10px 0 12px; }
      .ad-ext-kpi-grid--x01 { grid-template-columns: repeat(3, minmax(0, 1fr)); margin-top: 10px; margin-bottom: 12px; }
      .ad-ext-kpi-tile {
        border-radius: 14px;
        padding: 14px 16px;
        min-height: 92px;
        background: linear-gradient(180deg, rgba(120, 170, 255, 0.16), rgba(18, 28, 62, 0.22));
        box-shadow: inset 0 0 0 1px rgba(170, 210, 255, 0.10), 0 12px 40px rgba(0,0,0,0.14);
        backdrop-filter: blur(6px);
      }
      .ad-ext-kpi-title { font-size: 12px; opacity: 0.90; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.10em; font-weight: 900; }
      .ad-ext-kpi-value { font-size: 30px; font-weight: 900; letter-spacing: 0.4px; line-height: 1.05; font-variant-numeric: tabular-nums; }
      .ad-ext-kpi-sub { margin-top: 7px; font-size: 12px; opacity: 0.78; font-weight: 900; letter-spacing: 0.02em; font-variant-numeric: tabular-nums; }

      

      /* Chrono-Tracker: KPI-Subtext fixe Hoehe (immer Platz fuer 3 Zeilen) */
      #ad-ext-time-kpi-thisweek-sub,
      #ad-ext-time-kpi-range-sub,
      #ad-ext-time-kpi-avg-sub,
      #ad-ext-time-kpi-best-sub{
        line-height: 1.25;
        min-height: calc(3 * 1.25em);
        max-height: calc(3 * 1.25em);
        overflow: hidden;
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
      }

      @media (max-width: 1100px) { .ad-ext-kpi-grid { grid-template-columns: 1fr 1fr; } .ad-ext-kpi-grid--x01 { grid-template-columns: 1fr 1fr; } }
      @media (max-width: 700px) { .ad-ext-kpi-grid { grid-template-columns: 1fr; } .ad-ext-kpi-grid--x01 { grid-template-columns: 1fr; } }

      /* X01 Hall of Fame: Grid wie KPI-Tiles (nur bei manuellem Override)
         Warum: Auto darf auf 1080px ruhig 2-spaltig bleiben; bei "Portrait erzwingen" soll es wie die KPI-Tiles sauber verteilen. */
      .ad-ext-hof-grid { margin: 10px 0 12px; }
      @media (min-width: 980px) {
        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-hof-grid,
        .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-hof-grid {
          grid-template-columns: repeat(3, minmax(0, 1fr)) !important;
        }
      }
      @media (min-width: 1800px) {
        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-hof-grid,
        .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-hof-grid {
          grid-template-columns: repeat(4, minmax(0, 1fr)) !important;
        }
      }


      .ad-ext-section-title { margin: 14px 0 8px; font-size: 13px; text-transform: uppercase; letter-spacing: 0.10em; opacity: 0.88; font-weight: 900; }


      .ad-ext-section-desc{
        margin: -4px 0 12px;
        font-size: 12px;
        line-height: 1.35;
        opacity: 0.78;
      }
.ad-ext-card {
        padding: var(--ad-card-padding);
        border-radius: 14px;
        background: linear-gradient(180deg, rgba(120, 170, 255, 0.10), rgba(18, 28, 62, 0.18));
        box-shadow: inset 0 0 0 1px rgba(170, 210, 255, 0.10), 0 12px 40px rgba(0,0,0,0.14);
        backdrop-filter: blur(6px);
      }

      .ad-ext-grid-2 { display: grid; grid-template-columns: repeat(var(--ad-columns), minmax(0, 1fr)); gap: var(--ad-gap); align-items: stretch; }
      .ad-ext-grid-2 > div { display:flex; flex-direction:column; min-height:0; }
      .ad-ext-grid-2 > div > .ad-ext-card { flex:1 1 auto; }

      @media (max-width: 1100px) { .ad-ext-grid-2 { grid-template-columns: 1fr; } }
      .ad-ext-grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 14px; align-items: stretch; margin-top: 12px; }
      .ad-ext-grid-3 > div { display:flex; flex-direction:column; min-height:0; }
      .ad-ext-grid-3 > div > .ad-ext-card { flex:1 1 auto; }
      @media (max-width: 1100px) { .ad-ext-grid-3 { grid-template-columns: 1fr; } }

      /* Segment Training: Charts Layout (Hits links, Spieltypen + Performance rechts untereinander) */
      .ad-ext-grid-seg {
        display: grid;
        grid-template-columns: minmax(0, 2fr) minmax(0, 1fr);
        grid-template-rows: 1fr 1fr;
        gap: 14px;
        align-items: stretch;
        margin-top: 12px;
        height: 460px;
      }
      .ad-ext-card-seg-hits { grid-column: 1; grid-row: 1 / span 2; }
      .ad-ext-card-seg-donut { grid-column: 2; grid-row: 1; }
      .ad-ext-card-seg-radar { grid-column: 2; grid-row: 2; }

      .ad-ext-grid-seg .ad-ext-card { display: flex; flex-direction: column; min-height: 0; }
      .ad-ext-grid-seg .ad-ext-chart-canvas,
      .ad-ext-grid-seg .ad-ext-chart-svg { flex: 1 1 auto; height: 100%; min-height: 0; }

      @media (max-width: 1100px) {
        .ad-ext-grid-seg { grid-template-columns: 1fr; grid-template-rows: auto; height: auto; }
        .ad-ext-card-seg-hits { grid-column: auto; grid-row: auto; }
        .ad-ext-card-seg-donut { grid-column: auto; grid-row: auto; }
        .ad-ext-card-seg-radar { grid-column: auto; grid-row: auto; }
        .ad-ext-grid-seg .ad-ext-chart-canvas,
        .ad-ext-grid-seg .ad-ext-chart-svg { height: 220px; }
      }


      /* X01 Liga: Charts Layout (W/L links groß, Leg-Diff + Momentum rechts) */
      .ad-ext-grid-x01 {
        display: grid;
        grid-template-columns: minmax(0, 2fr) minmax(0, 1fr);
        grid-template-rows: 1fr 1fr;
        gap: 14px;
        align-items: stretch;
        margin-top: 12px;
        height: 460px;
      }
      .ad-ext-card-x01-wl { grid-column: 1; grid-row: 1 / span 2; }
      .ad-ext-card-x01-legdiff { grid-column: 2; grid-row: 1; }
      .ad-ext-card-x01-momentum { grid-column: 2; grid-row: 2; }

      .ad-ext-grid-x01 .ad-ext-card { display: flex; flex-direction: column; min-height: 0; }
      .ad-ext-grid-x01 .ad-ext-chart-canvas,
      .ad-ext-grid-x01 .ad-ext-chart-svg { flex: 1 1 auto; height: 100%; min-height: 0; }

      @media (max-width: 1100px) {
        .ad-ext-grid-x01 { grid-template-columns: 1fr; grid-template-rows: auto; height: auto; }

      /* X01 Liga: AVG Trend in voller Breite (unter den Tabellen) */
      .ad-ext-card-x01-avgtrend-full .ad-ext-chart-canvas { height: 300px; }
      @media (max-width: 1100px) { .ad-ext-card-x01-avgtrend-full .ad-ext-chart-canvas { height: 240px; } }
      @media (max-width: 700px) { .ad-ext-card-x01-avgtrend-full .ad-ext-chart-canvas { height: 220px; } }

        .ad-ext-card-x01-wl { grid-column: auto; grid-row: auto; }
        .ad-ext-card-x01-legdiff { grid-column: auto; grid-row: auto; }
        .ad-ext-card-x01-momentum { grid-column: auto; grid-row: auto; }
        .ad-ext-grid-x01 .ad-ext-chart-canvas,
        .ad-ext-grid-x01 .ad-ext-chart-svg { height: 220px; }
      }

      /* Training Insights: Analysis Row (Weak doubles + Mini charts) (0.14.111) */
      .ad-ext-train-insights-analysis { margin-top: 12px; }
      .ad-ext-train-insights-leftcol { display:flex; flex-direction:column; gap: 12px; }
      .ad-ext-train-insights-leftcol .ad-ext-insights-left-fill { flex: 1 1 auto; }
      .ad-ext-train-insights-miniCharts { display:flex; flex-direction:column; gap: 12px; }
      .ad-ext-train-insights-analysis .ad-ext-mini-canvas { width: 100%; height: 180px; display:block; }
      .ad-ext-canvas-tooltip {
        position: absolute;
        display: none;
        pointer-events: none;
        padding: 6px 8px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(0,0,0,0.78);
        font-size: 12px;
        line-height: 1.2;
        font-weight: 800;
        white-space: nowrap;
        z-index: 3000;
        transform: translate(-50%, -120%);
        box-shadow: 0 10px 24px rgba(0,0,0,0.35);
      }



      .ad-ext-table { width: 100%; border-collapse: collapse; font-size: var(--ad-table-font-size); margin: 0; }
      .ad-ext-table th {
        padding: 12px 10px;
        text-align: left;
        font-weight: 900;
        letter-spacing: 0.02em;
        opacity: 0.95;
        border-bottom: 1px solid rgba(255,255,255,0.10);
        background: rgba(10, 18, 40, 0.18);
      }
      .ad-ext-table td { padding: 10px 10px; vertical-align: middle; }
      .ad-ext-table tbody tr:nth-child(even) { background: rgba(255, 255, 255, 0.03); }
      .ad-ext-table tbody tr:nth-child(odd) { background: rgba(0, 0, 0, 0.10); }
      .ad-ext-table tbody tr:hover { background: rgba(140, 190, 255, 0.08); }

      #ad-ext-view-segment #ad-ext-st-table-day tr[data-day-key],
      #ad-ext-view-segment #ad-ext-st-table-target tr[data-target] { cursor: pointer; }
      #ad-ext-train-atcfokus #ad-ext-atc-table-day tr[data-day-key],
      #ad-ext-train-atcfokus #ad-ext-atc-table-target tr[data-field] { cursor: pointer; }


      .ad-ext-table-value-right { text-align: right !important; font-weight: 900; font-variant-numeric: tabular-nums; }
      .ad-ext-table-num-right { text-align: right !important; font-variant-numeric: tabular-nums; }
      .ad-ext-table-nowrap { white-space: nowrap !important; }

      .ad-ext-table--fixed { table-layout: fixed; }

      /* Top10 Tabellen (Hall of Fame):
         Problem: bei schmalen Cards wird die "Spieler"-Überschrift auf einzelne Buchstaben umgebrochen.
         Fix: Tabelle bekommt min-width -> horizontal scroll im Wrapper; Spieler-Spalte nowrap + Ellipsis. */
      .ad-ext-table--top10 { min-width: 640px; margin-left: 0; }
      .ad-ext-table--top10 th, .ad-ext-table--top10 td { white-space: nowrap; }
      .ad-ext-table--top10 th:nth-child(2), .ad-ext-table--top10 td:nth-child(2) {
        min-width: 140px;
        overflow: hidden;
        text-overflow: ellipsis;
      }

/* X01 Liga Tabelle – bessere Verteilung/Überschriften + Scroll bei kleinen Screens */
.ad-ext-table-scroll { overflow-x: auto; -webkit-overflow-scrolling: touch; width: 100%; text-align: left; }
.ad-ext-table-scroll::-webkit-scrollbar { height: 10px; }
.ad-ext-table-scroll::-webkit-scrollbar-thumb { background: rgba(140,190,255,0.28); border-radius: 999px; }
.ad-ext-table-scroll::-webkit-scrollbar-track { background: rgba(0,0,0,0.12); border-radius: 999px; }

.ad-ext-table-scroll > table { margin-left: 0 !important; margin-right: auto !important; }

/* Top10 Tabellen: Date/Buttons nicht umbrechen (sonst sieht's im Portrait komisch aus) */
.ad-ext-table--top10 th:nth-child(5),
.ad-ext-table--top10 td:nth-child(5) { white-space: nowrap; }
.ad-ext-table--top10 td:nth-child(6),
.ad-ext-table--top10 th:nth-child(6) { white-space: nowrap; }


#ad-ext-x01-league-table { min-width: 980px; }
#ad-ext-x01-league-table th { padding: 12px 14px; white-space: nowrap; }
#ad-ext-x01-league-table td { padding: 12px 14px; }
#ad-ext-x01-league-table th:first-child,
#ad-ext-x01-league-table td:first-child { text-align: center; }

/* Portrait-Fix (Tabellen): Prozent-Colgroup deaktivieren (damit horizontales Scrollen statt Umbruch/Quetschen)
   + CO%-Spalte stabil halten (Sort-Pfeil bricht sonst gerne um) */
.ad-ext-root.ad-ext-layout--force-portrait .ad-ext-table.ad-ext-cols-percent colgroup col { width: auto !important; }
.ad-ext-root.ad-ext-layout--force-portrait #ad-ext-x01-league-table colgroup col:nth-child(12) { width: 80px !important; }
.ad-ext-root.ad-ext-layout--force-portrait #ad-ext-x01-league-table th[data-sort-key="checkoutPct"]{
  white-space: nowrap;
  word-break: keep-all;
  overflow-wrap: normal;
  padding-right: 22px; /* Platz für Sort-Pfeil */
}
.ad-ext-root.ad-ext-layout--force-portrait #ad-ext-x01-league-table th[data-sort-key="checkoutPct"][data-sort-dir]::after{
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  margin-left: 0;
  display: block;
}

@media (orientation: portrait) {
  .ad-ext-root.ad-ext-layout--auto .ad-ext-table.ad-ext-cols-percent colgroup col { width: auto !important; }
  .ad-ext-root.ad-ext-layout--auto #ad-ext-x01-league-table colgroup col:nth-child(12) { width: 80px !important; }
  .ad-ext-root.ad-ext-layout--auto #ad-ext-x01-league-table th[data-sort-key="checkoutPct"]{
    white-space: nowrap;
    word-break: keep-all;
    overflow-wrap: normal;
    padding-right: 22px; /* Platz für Sort-Pfeil */
  }
  .ad-ext-root.ad-ext-layout--auto #ad-ext-x01-league-table th[data-sort-key="checkoutPct"][data-sort-dir]::after{
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    margin-left: 0;
    display: block;
  }
}
      .ad-ext-td-player { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 900; letter-spacing: 0.06em; }

      .ad-ext-rowmark { position: relative; }
      .ad-ext-rowmark--best { box-shadow: inset 4px 0 0 rgba(60, 220, 140, 0.95); }
      .ad-ext-row--me { box-shadow: inset 4px 0 0 rgba(140, 190, 255, 0.95); }
      .ad-ext-row--selected {
        outline: 2px solid rgba(140, 190, 255, 0.65);
        outline-offset: -2px;
        background: rgba(140, 190, 255, 0.12) !important;
      }


      .ad-ext-row--hover {
        outline: 1px solid rgba(140, 190, 255, 0.35);
        outline-offset: -1px;
        background: rgba(140, 190, 255, 0.08) !important;
      }

      .ad-ext-filters {
        display: flex; gap: 14px; align-items: flex-end; flex-wrap: wrap;
        padding: 12px 14px; border-radius: 16px;
        background: linear-gradient(180deg, rgba(120, 170, 255, 0.10), rgba(18, 28, 62, 0.16));
        box-shadow: inset 0 0 0 1px rgba(170, 210, 255, 0.10);
        margin-bottom: 10px;
        backdrop-filter: blur(6px);
      }
      .ad-ext-filter-block { display: grid; gap: 6px; flex: 1 1 var(--ad-filter-min); min-width: 260px; }
      .ad-ext-filter-label { font-size: 11px; opacity: 0.78; text-transform: uppercase; letter-spacing: 0.10em; font-weight: 900; }
      .ad-ext-filter-row { display:flex; gap: 10px; align-items: center; width: 100%; }
      .ad-ext-filter-name { font-size: 12px; opacity: 0.9; width: 52px; font-weight: 900; }


      .ad-ext-filter-switch{
        display:flex;
        align-items:center;
        justify-content:flex-end;
        gap: 10px;
        width: 100%;
      }
      .ad-ext-filter-switch-text{
        font-size: 12px;
        font-weight: 900;
        opacity: 0.86;
        user-select: none;
      }
/* Filter: Controls sollen die Breite nutzen (Selects strecken, nicht "rechts kleben") */
      .ad-ext-filter-row .ad-ext-select-wrap { flex: 1 1 auto; min-width: 0; width: 100%; display: flex; }
      .ad-ext-filter-row .ad-ext-select { width: 100%; }



      .ad-ext-select {
        appearance: none;
        background: rgba(18, 28, 62, 0.55);
        border: 1px solid rgba(140, 190, 255, 0.45);
        border-radius: 14px;
        padding: 11px 40px 11px 12px;
        color: rgba(255,255,255,0.94);
        font-weight: 900;
        font-size: 13px;
        outline: none;
        cursor: pointer;
        min-width: 240px;
        position: relative;
      }
      .ad-ext-select:focus { box-shadow: 0 0 0 2px rgba(140,190,255,0.25); }
      .ad-ext-select-wrap { position: relative; display: inline-flex; }
      .ad-ext-select-wrap::after {
        content: "▾";
        position: absolute;
        right: 14px; top: 50%;
        transform: translateY(-50%);
        opacity: 0.9;
        pointer-events: none;
        cursor: default;
        font-size: 14px;
      }

      /* Checkbox (Master Hall of Fame: Bots ein/aus) */
      .ad-ext-checkbox-wrap{
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 8px 12px;
        border-radius: 14px;
        background: rgba(18, 28, 62, 0.45);
        border: 1px solid rgba(140, 190, 255, 0.35);
        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.10);
        cursor: pointer;
        user-select: none;
      }
      .ad-ext-checkbox-wrap:hover{
        background: rgba(18, 28, 62, 0.55);
        border-color: rgba(140, 190, 255, 0.45);
      }
      .ad-ext-checkbox{
        width: 18px;
        height: 18px;
        accent-color: rgba(140,190,255,0.95);
        cursor: pointer;
      }
      .ad-ext-checkbox-text{
        font-size: 12px;
        font-weight: 900;
        letter-spacing: 0.02em;
        opacity: 0.90;
      }
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-checkbox-wrap{
        width: 100%;
        justify-content: flex-start;
      }


      .ad-ext-view-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        height: 30px;
        padding: 0 14px;
        border-radius: 12px;
        background: rgba(140,190,255,0.20);
        border: 1px solid rgba(140,190,255,0.45);
        color: rgba(255,255,255,0.92);
        font-weight: 900;
        letter-spacing: 0.02em;
        text-decoration: none;
        user-select: none;
        cursor: pointer;
        white-space: nowrap;
      }
      .ad-ext-view-btn:hover { background: rgba(140,190,255,0.28); border-color: rgba(180,220,255,0.55); }
      .ad-ext-view-btn:active { transform: scale(0.98); }




.ad-ext-view-btn--xs { height: 24px; padding: 0 10px; border-radius: 10px; font-size: 12px; }

.ad-ext-tooltip-record { min-width: 260px; }
.ad-ext-tooltip-recline { margin-top: 6px; font-size: 12px; opacity: 0.92; }
.ad-ext-tooltip-recavg { margin-top: 2px; font-size: 13px; font-weight: 900; }
.ad-ext-tooltip-actions { margin-top: 8px; display:flex; justify-content:flex-end; }

.ad-ext-chart-canvas { width: 100%; height: var(--ad-chart-height); display:block; }

      .ad-ext-chart-svg { width: 100%; height: var(--ad-chart-height); display:block; }
      .ad-ext-chart-svg .recharts-sector { cursor: default; }
      .ad-ext-chart-title { font-size: 13px; font-weight: 900; margin-bottom: 8px; opacity: 0.97; letter-spacing: 0.03em; }
      .ad-ext-chart-title-row { display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom: 8px; }
      .ad-ext-chart-title-row .ad-ext-chart-title { margin:0; }
      .ad-ext-momentum-toggle .ad-ext-segbtn { height: 26px; padding: 0 10px; font-size: 12px; }

      .ad-ext-chart-sub { font-size: 11px; opacity: 0.82; margin-top: 8px; line-height: 1.35; }

      .ad-ext-legend { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; font-size: 12px; opacity: 0.92; }
      .ad-ext-legend-item { display:flex; gap: 8px; align-items:center; }
            .ad-ext-legend--center { justify-content: center; }

      /* Chrono-Tracker: Donut-Legende reserviert Platz fuer 2 Zeilen (verhindert Chart-Sprung) */
      #ad-ext-time-share.ad-ext-legend { min-height: 40px; }

.ad-ext-dot { width: 10px; height: 10px; border-radius: 50%; display:inline-block; box-shadow: 0 0 0 1px rgba(255,255,255,0.15); }
      .ad-ext-linekey { width: 14px; height: 3px; border-radius: 2px; display:inline-block; box-shadow: 0 0 0 1px rgba(255,255,255,0.12); }

      .ad-ext-pair { font-variant-numeric: tabular-nums; }
      .ad-ext-pair-a { font-weight: 900; }
      .ad-ext-pair-sep { opacity: 0.65; padding: 0 4px; font-weight: 900; }
      .ad-ext-pair-b { opacity: 0.78; font-weight: 900; }

      .ad-ext-diff-pos { color: rgba(60, 220, 140, 0.95); }
      .ad-ext-diff-neg { color: rgba(255, 80, 90, 0.95); }
      .ad-ext-diff-zero { opacity: 0.90; }

      .ad-ext-tooltip {
        position: fixed;
        z-index: 999999;
        display: none;
        pointer-events: none;
        cursor: default;
        max-width: 560px;
        background: rgba(10,14,30,0.92);
        border: 1px solid rgba(140,190,255,0.45);
        box-shadow: 0 18px 60px rgba(0,0,0,0.35);
        border-radius: 14px;
        padding: 10px 12px;
        color: rgba(255,255,255,0.92);
        font-size: 12px;
        line-height: 1.35;
      }
      .ad-ext-tooltip-title {
        font-weight: 900;
        margin-bottom: 6px;
        opacity: 0.95;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        font-size: 11px;
      }
      .ad-ext-tooltip-line {
        display: grid;
        grid-template-columns: 92px 1fr 86px;
        gap: 10px;
        padding: 4px 0;
        border-top: 1px solid rgba(255,255,255,0.06);
        font-variant-numeric: tabular-nums;
      }
      .ad-ext-tooltip-line:first-of-type { border-top: none; }
      .ad-ext-tooltip-date { opacity: 0.92; font-weight: 900; font-size: 15px; }
      .ad-ext-tooltip-lineup { opacity: 0.92; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      .ad-ext-tooltip-lineup--wrap { white-space: normal; overflow: visible; text-overflow: clip; word-break: break-word; }
      .ad-ext-tooltip-legs { text-align: right; font-weight: 900; opacity: 0.95; }

      .ad-ext-tooltip-kv { display:grid; grid-template-columns: 1fr auto; gap:10px; margin-top:6px; }
      .ad-ext-tooltip-k { opacity:0.82; }
      .ad-ext-tooltip-v { font-weight:900; font-variant-numeric: tabular-nums; }

      .ad-ext-tooltip-res { font-weight: 1000; letter-spacing: 0.02em; }
      .ad-ext-tooltip-res--win { color: rgba(60, 220, 140, 0.98); }
      .ad-ext-tooltip-res--loss { color: rgba(255, 80, 90, 0.98); }

      .ad-ext-version { margin-top: 12px; text-align: right; font-size: 11px; opacity: 0.65; }

  /* Sortierbare Spalten (X01 Liga) */
  .ad-ext-th-sortable { cursor: pointer; user-select: none; position: relative; padding-right: 0; white-space: nowrap; }
  .ad-ext-th-sortable:hover { color: rgba(255,255,255,0.92); }
  .ad-ext-th-sortable[data-sort-dir="asc"]::after {
    content: "▲";
    position: static;
    display: inline-block;
    margin-left: 6px;
    font-size: 10px;
    opacity: 0.75;
  }
  .ad-ext-th-sortable[data-sort-dir="desc"]::after {
    content: "▼";
    position: static;
    display: inline-block;
    margin-left: 6px;
    font-size: 10px;
    opacity: 0.75;
  }

  /* Zeit-Tracker (Tab 3) */
  .ad-ext-input {
    width: 130px;
    padding: 8px 10px;
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.10);
    background: rgba(255,255,255,0.04);
    color: inherit;
    outline: none;
  }
  .ad-ext-input:focus {
    border-color: rgba(255,255,255,0.20);
    box-shadow: 0 0 0 3px rgba(0,150,255,0.12);
  }
  .ad-ext-progress {
    height: 8px;
    border-radius: 999px;
    background: rgba(255,255,255,0.08);
    overflow: hidden;
    margin-top: 10px;
  }
  .ad-ext-progress-bar {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, rgba(0,150,255,0.85), rgba(0,200,160,0.85));
  }
  .ad-ext-card-title {
    font-weight: 650;
    font-size: 13px;
    margin: 2px 0 8px 0;
    opacity: 0.9;
  }
  .ad-ext-dot {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 999px;
    margin-right: 8px;
    background: rgba(255,255,255,0.35);
  }
  .ad-ext-dot--st { background: rgba(0,150,255,0.85); }
  .ad-ext-dot--x01 { background: rgba(0,200,160,0.85); }
  .ad-ext-dot--oth { background: rgba(200,140,255,0.85); }
  .ad-ext-dot--goal { background: rgba(255,200,0,0.85); }


  /* Trainingsplan Soll & Ist */
  .ad-ext-plan-top {
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 12px;
    flex-wrap: wrap;
  }
  .ad-ext-plan-week { display:flex; flex-direction:column; gap:2px; min-width: 220px; }
  .ad-ext-plan-week-label { font-weight: 950; letter-spacing: 0.02em; }
  .ad-ext-plan-week-sub { font-size: 11px; opacity: 0.78; line-height: 1.35; }
  .ad-ext-plan-week-select { margin-top: 6px; width: min(720px, 100%); max-width: 100%; white-space: nowrap; }

  /* X01 Liga: Sub-Panels (Liga | Hall of Fame) */
  .ad-ext-x01-subnav {
    margin: 8px 0 10px;
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
  }
  .ad-ext-x01-subnav .ad-ext-segcontrol { border-radius: 14px; }

  .ad-ext-segcontrol {
    display:inline-flex;
    background: rgba(18, 28, 62, 0.55);
    border: 1px solid rgba(140, 190, 255, 0.45);
    border-radius: 14px;
    padding: 3px;
    gap: 3px;
  }
  .ad-ext-segbtn {
    height: 30px;
    padding: 0 14px;
    border-radius: 12px;
    border: 1px solid transparent;
    background: transparent;
    color: rgba(255,255,255,0.86);
    font-weight: 900;
    letter-spacing: 0.01em;
    cursor: pointer;
    user-select: none;
  }
  .ad-ext-segbtn:hover { background: rgba(140,190,255,0.16); }
  .ad-ext-segbtn--active {
    background: rgba(140,190,255,0.22);
    border-color: rgba(140,190,255,0.38);
    color: rgba(255,255,255,0.94);
  }

  .ad-ext-check { display:inline-flex; align-items:center; gap:10px; font-weight: 900; font-size: 13px; opacity: 0.92; cursor:pointer; user-select:none; }
  .ad-ext-check-input { width: 16px; height: 16px; accent-color: rgba(140,190,255,0.95); }

  .ad-ext-plan-input {
    min-width: 90px;
    width: 110px;
    max-width: 140px;
    padding: 8px 10px;
    border-radius: 12px;
    font-weight: 950;
    text-align: right;
  }
  .ad-ext-plan-unit { opacity: 0.75; font-weight: 900; margin-left: 6px; }
  .ad-ext-plan-sollcell { display:flex; justify-content:flex-end; align-items:center; gap:0; }
  .ad-ext-plan-progress { display:flex; align-items:center; gap:10px; }
  .ad-ext-progress.ad-ext-progress--thin { height: 10px; border-radius: 999px; }
  .ad-ext-plan-pct { font-weight: 950; font-variant-numeric: tabular-nums; opacity: 0.92; text-align: left; }

  /* Training-Tab: Gesamt-Zeile im Trainingsdaten-Panel hervorheben */
  #ad-ext-view-training .ad-train-main tr.ad-ext-row-total td {
    background: rgba(140, 190, 255, 0.10) !important;
    border-top: 1px solid rgba(255,255,255,0.12);
    font-weight: 950;
  }

  /* Training-Tab: Trainingsdaten Tabelle – Accordion Details (0.14.59) */
  #ad-ext-view-training .ad-train-main tr.ad-ext-train-row { cursor: pointer; }
  #ad-ext-view-training .ad-train-main .ad-ext-rowexp { display:inline-block; width:16px; opacity:.8; margin-right:6px; }
  #ad-ext-view-training .ad-train-main tr.ad-ext-train-row-details td { padding: 10px 12px; }
  #ad-ext-view-training .ad-train-main .ad-ext-train-details-box {
    background: rgba(0,0,0,0.18);
    border: 1px solid rgba(255,255,255,0.10);
    border-radius: 12px;
    padding: 10px 12px;
    text-align: left;
  }
  #ad-ext-view-training .ad-train-main .ad-ext-train-details-summary { font-weight: 900; margin-bottom: 8px; }
  #ad-ext-view-training .ad-train-main .ad-ext-train-details-table { width: 100%; border-collapse: collapse; font-size: 12px; }
  #ad-ext-view-training .ad-train-main .ad-ext-train-details-table th,
  #ad-ext-view-training .ad-train-main .ad-ext-train-details-table td { padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.08); text-align: left; }
  #ad-ext-view-training .ad-train-main .ad-ext-train-details-table thead th { font-weight: 900; opacity: 0.9; }

  .ad-ext-train-row-details, .ad-ext-train-row-details * { text-align:left; }
  .ad-ext-train-row-details table th, .ad-ext-train-row-details table td { text-align:left; }
  #ad-ext-view-training .ad-train-main .ad-ext-train-details-perf { font-size: 11px; opacity: 0.82; margin: 0 0 8px; font-weight: 800; line-height: 1.25; }

  /* Training-Tab: Charts unter der Tabelle */
  #ad-ext-view-training .ad-ext-train-charts { display:flex; gap:12px; flex-wrap:wrap; margin: 0 0 12px; }
  #ad-ext-view-training .ad-ext-train-charts .ad-ext-card { flex: 1 1 320px; min-width: 260px; }
  #ad-ext-view-training .ad-ext-train-chart-title { font-weight: 900; margin: 0 0 8px; }
  #ad-ext-view-training svg.ad-ext-train-chart--placeholder { border: 1px dashed rgba(255,255,255,0.18); border-radius: 12px; background: rgba(0,0,0,0.10); }

  /* Training-Tab: Donut (Trainingsfortschritt) -> Tabellenzeilen markieren (0.14.79) */
  tr.ad-ext-train-row.ad-ext-tp-dim { opacity: .35; }
  tr.ad-ext-train-row.ad-ext-tp-mark { outline: 2px solid rgba(255,255,255,.18); outline-offset: -2px; background: rgba(140,190,255,.10); }
  tr.ad-ext-train-row.ad-ext-ts-dim { opacity: .35; }
  tr.ad-ext-train-row.ad-ext-ts-mark { outline: 2px solid rgba(255,255,255,.18); outline-offset: -2px; background: rgba(140,190,255,.10); }

  .ad-ext-plan-perfline{
    margin-top: 4px;
    font-size: 11px;
    opacity: 0.72;
    font-weight: 800;
    line-height: 1.25;
    display:flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  .ad-ext-plan-perfline span{ white-space: nowrap; }


  #ad-ext-time-week-body tr { cursor: pointer; }
  #ad-ext-time-week-body tr.ad-ext-row--selected td { background: rgba(140,190,255,0.12); }
  #ad-ext-time-week-body tr.ad-ext-row--selected td:first-child { box-shadow: inset 3px 0 0 rgba(140,190,255,0.65); }

  /* Chrono-Tracker: Aktivitaet-Fokus (Spalten abdunkeln) */
  #ad-ext-view-time [data-tt-col].ad-ext-tt-col--dim { opacity: .35; }


      /* Entfernt Fokus-Rahmen um Chart-Elemente (z.B. X01 Kacheln) */
      svg.ad-ext-chart-svg,
      svg.ad-ext-chart-svg:focus,
      svg.ad-ext-chart-svg:focus-visible {
        outline: none !important;
      }


      /* =========================
         Responsive Layout Layer (v2)
         - Auto-Erkennung über CSS (@media orientation)
         - Optionales Override via Root-Klasse (localStorage ad_viewer_layout_mode)
         ========================= */

      /* Gaps / Höhen zentral über Variablen */
      .ad-ext-filters { gap: var(--ad-gap); }
      .ad-ext-kpi-grid { gap: var(--ad-gap); }
      .ad-ext-grid-2, .ad-ext-grid-3, .ad-ext-grid-seg, .ad-ext-grid-x01 { gap: var(--ad-gap); }

      /* Große Chart-Grids: Höhe über Variable */
      .ad-ext-grid-seg { height: var(--ad-chart-panel-height); }
      .ad-ext-grid-x01 { height: var(--ad-chart-panel-height); }

      /* Layout Toggle (Header) */
      .ad-ext-layout-toggle { border-radius: 14px; }
      .ad-ext-layout-toggle .ad-ext-segbtn { height: 28px; padding: 0 12px; font-size: 12px; }

      /* (v0.14.13) Alte "Ansicht"-Steuerung im Header-Menü deaktiviert – zentrale Steuerung ist die Viewer-Kachel unten */
      #ad-ext-settings-menu [data-ad-ext-open-menu-panel="view"],
      #ad-ext-settings-menu [data-ad-ext-menu-panel="view"],
      #ad-ext-layout-toggle{
        display:none !important;
      }

      /* Ultra-wide (z.B. 3440×1440): etwas mehr Luft + größere Charts */
      @media (min-width: 1800px) and (orientation: landscape) {
        .ad-ext-root.ad-ext-layout--auto,
        .ad-ext-root.ad-ext-layout--force-landscape {
          --ad-font-size: clamp(14px, 0.55vw, 17px);
          --ad-gap: 16px;
          --ad-card-padding: 14px 16px;
          --ad-chart-height: 200px;
          --ad-chart-panel-height: 560px;
        }
        /* X01 KPI: 6 Kacheln in einer Reihe */
        .ad-ext-root.ad-ext-layout--auto .ad-ext-kpi-grid--x01,
        .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-kpi-grid--x01 {
          grid-template-columns: repeat(6, minmax(0, 1fr));
        }
      }


      /* Landscape: zentrale Regeln (forced)
         - wirkt auch auf Portrait-Devices (Override) */
      .ad-ext-root.ad-ext-layout--force-landscape {
        --ad-font-size: clamp(13px, 0.42vw, 15px);
        --ad-gap: 14px;
        --ad-padding: 18px 18px 24px;
        --ad-card-padding: 12px 14px;
        --ad-columns: 2;
        --ad-chart-height: 190px;
        --ad-table-font-size: 13px;
        --ad-chart-panel-height: 520px;
      }
      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-filters { flex-direction: row; align-items: flex-end; }
      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-filter-row { justify-content: flex-start; }
      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-filter-block { flex: 1 1 var(--ad-filter-min); min-width: var(--ad-filter-min); }
      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-filter-row .ad-ext-select-wrap { flex: 1 1 auto; min-width: 0; width: 100%; }
      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-select { width: 100%; min-width: 0; }

      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-grid-2 { grid-template-columns: repeat(2, minmax(0, 1fr)) !important; }
      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-grid-3 { grid-template-columns: repeat(3, minmax(0, 1fr)) !important; }

      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-grid-seg,
      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-grid-x01 {
        grid-template-columns: minmax(0, 2fr) minmax(0, 1fr) !important;
        grid-template-rows: 1fr 1fr !important;
        height: var(--ad-chart-panel-height) !important;
      }

      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-card-seg-hits { grid-column: 1 !important; grid-row: 1 / span 2 !important; }
      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-card-seg-donut { grid-column: 2 !important; grid-row: 1 !important; }
      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-card-seg-radar { grid-column: 2 !important; grid-row: 2 !important; }

      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-card-x01-wl { grid-column: 1 !important; grid-row: 1 / span 2 !important; }
      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-card-x01-legdiff { grid-column: 2 !important; grid-row: 1 !important; }
      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-card-x01-momentum { grid-column: 2 !important; grid-row: 2 !important; }

      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-grid-seg .ad-ext-chart-canvas,
      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-grid-seg .ad-ext-chart-svg,
      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-grid-x01 .ad-ext-chart-canvas,
      .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-grid-x01 .ad-ext-chart-svg {
        height: 100% !important;
      }

      @media (min-width: 1800px) {
        .ad-ext-root.ad-ext-layout--force-landscape { --ad-columns: 3; }
        .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-grid-2 { grid-template-columns: repeat(3, minmax(0, 1fr)) !important; }
        .ad-ext-root.ad-ext-layout--force-landscape .ad-ext-grid-3 { grid-template-columns: repeat(3, minmax(0, 1fr)) !important; }
      }

      /* Portrait: zentrale Regeln (forced) */
      .ad-ext-root.ad-ext-layout--force-portrait {
        --ad-font-size: 16px;
        --ad-gap: 12px;
        --ad-padding: 16px 14px 20px;
        --ad-card-padding: 14px 14px;
        --ad-columns: 1;
        --ad-chart-height: 260px;
        --ad-table-font-size: 13px;
        --ad-chart-panel-height: auto;
      }

      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-subnav {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        padding-bottom: 6px;
      }
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-subnav-btn {
        white-space: nowrap;
        font-size: 15px;
        padding: 10px 14px 10px;
      }
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-icon-btn { height: 38px; padding: 0 14px; font-size: 14px; }
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-check { font-size: 13px; }

      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-filters { flex-direction: column; align-items: stretch; }
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-filter-block { flex: 0 0 auto; min-width: 0; }
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-filter-row { justify-content: flex-start; }
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-filter-row .ad-ext-select-wrap { flex: 1 1 auto; min-width: 0; width: 100%; }
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-filter-name { width: auto; min-width: 60px; }
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-select { width: 100%; min-width: 0; }

      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-kpi-grid { grid-template-columns: 1fr 1fr; }
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-kpi-grid--x01 { grid-template-columns: 1fr 1fr; }

      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-2,
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-3,
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-seg,
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-x01 {
        grid-template-columns: 1fr !important;
        grid-template-rows: auto !important;
      }

      /* Forced Portrait: wie Auto-Portrait, aber unabhängig von orientation
         - schmal: 1 Spalte
         - ab ~980px: 2 Spalten + Desktop-Charts-Grid
         - ab ~1800px: 3 Spalten */
      @media (min-width: 980px) {
        .ad-ext-root.ad-ext-layout--force-portrait {
          --ad-columns: 2;
          --ad-gap: 14px;
          --ad-padding: 18px 18px 24px;
          --ad-card-padding: 12px 14px;
          --ad-chart-height: 190px;
          --ad-chart-panel-height: 520px;
        }

        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-filters { flex-direction: row; align-items: flex-end; }
        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-filter-row { justify-content: flex-start; }
        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-filter-block { flex: 1 1 var(--ad-filter-min); min-width: var(--ad-filter-min); }

        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-2 { grid-template-columns: repeat(2, minmax(0, 1fr)) !important; }
        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-3 { grid-template-columns: repeat(2, minmax(0, 1fr)) !important; }

        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-seg,
        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-x01 {
          grid-template-columns: minmax(0, 2fr) minmax(0, 1fr) !important;
          grid-template-rows: 1fr 1fr !important;
          height: var(--ad-chart-panel-height) !important;
        }

        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-card-seg-hits { grid-column: 1 !important; grid-row: 1 / span 2 !important; }
        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-card-seg-donut { grid-column: 2 !important; grid-row: 1 !important; }
        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-card-seg-radar { grid-column: 2 !important; grid-row: 2 !important; }

        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-card-x01-wl { grid-column: 1 !important; grid-row: 1 / span 2 !important; }
        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-card-x01-legdiff { grid-column: 2 !important; grid-row: 1 !important; }
        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-card-x01-momentum { grid-column: 2 !important; grid-row: 2 !important; }

        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-seg .ad-ext-chart-canvas,
        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-seg .ad-ext-chart-svg,
        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-x01 .ad-ext-chart-canvas,
        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-x01 .ad-ext-chart-svg {
          height: 100% !important;
        }

        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-kpi-grid { grid-template-columns: repeat(3, minmax(0, 1fr)); }
      }

      @media (min-width: 1800px) {
        .ad-ext-root.ad-ext-layout--force-portrait { --ad-columns: 3; }
        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-2 { grid-template-columns: repeat(3, minmax(0, 1fr)) !important; }
        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-3 { grid-template-columns: repeat(3, minmax(0, 1fr)) !important; }
        .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-kpi-grid { grid-template-columns: repeat(4, minmax(0, 1fr)); }
      }





      /* Wichtig: in 1-Spalten-Layout Grid-Positionen resetten (sonst "implizite Spalten") */
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-seg [class*="ad-ext-card-seg-"],
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-x01 [class*="ad-ext-card-x01-"] {
        grid-column: auto !important;
        grid-row: auto !important;
      }

      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-seg .ad-ext-chart-canvas,
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-seg .ad-ext-chart-svg,
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-x01 .ad-ext-chart-canvas,
      .ad-ext-root.ad-ext-layout--force-portrait .ad-ext-grid-x01 .ad-ext-chart-svg {
        height: var(--ad-chart-height) !important;
      }

      /* Portrait: zentrale Regeln (auto) */
      @media (orientation: portrait) {
        .ad-ext-root.ad-ext-layout--auto {
          --ad-font-size: 16px;
          --ad-gap: 12px;
          --ad-padding: 16px 14px 20px;
          --ad-card-padding: 14px 14px;
          --ad-columns: 1;
          --ad-chart-height: 260px;
          --ad-table-font-size: 13px;
          --ad-chart-panel-height: auto;
        }

        .ad-ext-root.ad-ext-layout--auto .ad-ext-subnav {
          overflow-x: auto;
          -webkit-overflow-scrolling: touch;
          padding-bottom: 6px;
        }
        .ad-ext-root.ad-ext-layout--auto .ad-ext-subnav-btn {
          white-space: nowrap;
          font-size: 15px;
          padding: 10px 14px 10px;
        }
        .ad-ext-root.ad-ext-layout--auto .ad-ext-icon-btn { height: 38px; padding: 0 14px; font-size: 14px; }
        .ad-ext-root.ad-ext-layout--auto .ad-ext-check { font-size: 13px; }

        .ad-ext-root.ad-ext-layout--auto .ad-ext-filters { flex-direction: column; align-items: stretch; }
        .ad-ext-root.ad-ext-layout--auto .ad-ext-filter-row { justify-content: space-between; }
        .ad-ext-root.ad-ext-layout--auto .ad-ext-filter-name { width: auto; min-width: 60px; }
        .ad-ext-root.ad-ext-layout--auto .ad-ext-select { width: 100%; min-width: 0; }

        .ad-ext-root.ad-ext-layout--auto .ad-ext-kpi-grid { grid-template-columns: 1fr 1fr; }
        .ad-ext-root.ad-ext-layout--auto .ad-ext-kpi-grid--x01 { grid-template-columns: 1fr 1fr; }

        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-2,
        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-3,
        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-seg,
        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-x01 {
          grid-template-columns: 1fr !important;
          grid-template-rows: auto !important;
        }

        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-seg [class*="ad-ext-card-seg-"],
        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-x01 [class*="ad-ext-card-x01-"] {
          grid-column: auto !important;
          grid-row: auto !important;
        }

        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-seg .ad-ext-chart-canvas,
        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-seg .ad-ext-chart-svg,
        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-x01 .ad-ext-chart-canvas,
        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-x01 .ad-ext-chart-svg {
          height: var(--ad-chart-height) !important;
        }
      }

      /* Kleine Viewports: Panel-Höhe automatisch (kompatibel mit bestehendem @media max-width) */
      @media (max-width: 1100px) {
        .ad-ext-root { --ad-chart-panel-height: auto; --ad-columns: 1; }
      }


      /* ============================
         X01 Liga: CO%-Spalte stabil (auch im Landscape)
         - colgroup hat inline 5% -> zu schmal, dann bricht "11.00 %" um
         ============================ */
      #ad-ext-x01-league-table colgroup col:nth-child(12) { width: 80px !important; }
      #ad-ext-x01-league-table th[data-sort-key="checkoutPct"] {
        white-space: nowrap;
        word-break: keep-all;
        overflow-wrap: normal;
        padding-left: 10px;
        padding-right: 22px; /* Platz für Sort-Pfeil */
      }
      #ad-ext-x01-league-table td:nth-child(12) {
        white-space: nowrap;
        word-break: keep-all;
        overflow-wrap: normal;
        padding-left: 10px;
        padding-right: 10px;
      }

      /* ============================
         Auto-Layout im Portrait:
         - schmale Portrait-Screens: 1 Spalte (mobile)
         - breite Portrait-Screens (z.B. Desktop-Fenster / Portrait-Monitor): 2–3 Spalten
         Fix: im 1-Spalten-Flex (column) darf flex-basis nicht --ad-filter-min (sonst riesige "Luft" pro Filterblock)
         ============================ */
      @media (orientation: portrait) {
        .ad-ext-root.ad-ext-layout--auto .ad-ext-filter-block {
          flex: 0 0 auto;  /* kein "320px Höhe" durch flex-basis */
          min-width: 0;
        }
      }

      @media (orientation: portrait) and (min-width: 980px) {
        /* Auto + Portrait aber genug Breite: wieder "Desktop" Layout nutzen */
        .ad-ext-root.ad-ext-layout--auto {
          --ad-columns: 2;
          --ad-gap: 14px;
          --ad-padding: 18px 18px 24px;
          --ad-card-padding: 12px 14px;
          --ad-chart-height: 190px;
          --ad-chart-panel-height: 520px;
        }

        .ad-ext-root.ad-ext-layout--auto .ad-ext-filters { flex-direction: row; align-items: flex-end; }
        .ad-ext-root.ad-ext-layout--auto .ad-ext-filter-row { justify-content: flex-start; }
        .ad-ext-root.ad-ext-layout--auto .ad-ext-filter-name { width: 52px; min-width: 52px; }

        /* Grid wieder mehrspaltig (überschreibt das 1-Spalten-Override aus dem Portrait-Block) */
        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-2 { grid-template-columns: repeat(2, minmax(0, 1fr)) !important; }
        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-3 { grid-template-columns: repeat(2, minmax(0, 1fr)) !important; }

        /* Segment / X01 Charts wieder wie Desktop */
        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-seg,
        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-x01 {
          grid-template-columns: minmax(0, 2fr) minmax(0, 1fr) !important;
          grid-template-rows: 1fr 1fr !important;
          height: var(--ad-chart-panel-height) !important;
        }

        .ad-ext-root.ad-ext-layout--auto .ad-ext-card-seg-hits { grid-column: 1 !important; grid-row: 1 / span 2 !important; }
        .ad-ext-root.ad-ext-layout--auto .ad-ext-card-seg-donut { grid-column: 2 !important; grid-row: 1 !important; }
        .ad-ext-root.ad-ext-layout--auto .ad-ext-card-seg-radar { grid-column: 2 !important; grid-row: 2 !important; }

        .ad-ext-root.ad-ext-layout--auto .ad-ext-card-x01-wl { grid-column: 1 !important; grid-row: 1 / span 2 !important; }
        .ad-ext-root.ad-ext-layout--auto .ad-ext-card-x01-legdiff { grid-column: 2 !important; grid-row: 1 !important; }
        .ad-ext-root.ad-ext-layout--auto .ad-ext-card-x01-momentum { grid-column: 2 !important; grid-row: 2 !important; }

        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-seg .ad-ext-chart-canvas,
        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-seg .ad-ext-chart-svg,
        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-x01 .ad-ext-chart-canvas,
        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-x01 .ad-ext-chart-svg {
          height: 100% !important;
        }

        /* KPI-Tiles: in Portrait-Desktop nicht zu hoch stapeln */
        .ad-ext-root.ad-ext-layout--auto .ad-ext-kpi-grid { grid-template-columns: repeat(3, minmax(0, 1fr)); }
      }

      @media (orientation: portrait) and (min-width: 1800px) {
        .ad-ext-root.ad-ext-layout--auto { --ad-columns: 3; }
        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-2 { grid-template-columns: repeat(3, minmax(0, 1fr)) !important; }
        .ad-ext-root.ad-ext-layout--auto .ad-ext-grid-3 { grid-template-columns: repeat(3, minmax(0, 1fr)) !important; }
        .ad-ext-root.ad-ext-layout--auto .ad-ext-kpi-grid { grid-template-columns: repeat(4, minmax(0, 1fr)); }
      }



  /* === UI: Filter-Controls heller (Selects/Inputs) ===
     Wunsch: Filter optisch "leichter" wie im Beispiel (mehr Kontrast / weniger dunkel). */
  .ad-ext-root{
    --ad-control-bg: rgba(55, 85, 150, 0.28);
    --ad-control-bg-hover: rgba(65, 95, 165, 0.32);
    --ad-control-border: rgba(170, 210, 255, 0.40);
    --ad-control-border-hover: rgba(200, 230, 255, 0.50);
    --ad-control-bg-focus: rgba(75, 110, 190, 0.34);
    --ad-control-border-focus: rgba(220, 240, 255, 0.55);
  }

  /* alle Filter-Selects + Inputs (zentral) */
  .ad-ext-root .ad-ext-select,
  .ad-ext-root .ad-ext-input{
    background: var(--ad-control-bg);
    border-color: var(--ad-control-border);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.08);
  }
  .ad-ext-root .ad-ext-select:hover,
  .ad-ext-root .ad-ext-input:hover{
    background: var(--ad-control-bg-hover);
    border-color: var(--ad-control-border-hover);
  }
  .ad-ext-root .ad-ext-select:focus,
  .ad-ext-root .ad-ext-input:focus{
    background: var(--ad-control-bg-focus);
    border-color: var(--ad-control-border-focus);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.09), 0 0 0 2px rgba(140,190,255,0.22);
  }

  /* Dropdown-Liste (geöffnet): dunkel wie im Beispiel */
  .ad-ext-root .ad-ext-select{
    color-scheme: dark;
  }
  .ad-ext-root .ad-ext-select option,
  .ad-ext-root .ad-ext-select optgroup{
    background-color: rgba(18, 28, 62, 0.98);
    color: rgba(255,255,255,0.92);
  }
  .ad-ext-root .ad-ext-select option:checked{
    background-color: rgba(140,190,255,0.28);
    color: rgba(255,255,255,0.98);
  }

  /* Arrow im Select etwas heller */
  .ad-ext-root .ad-ext-select-wrap::after{
    opacity: 0.92;
    text-shadow: 0 1px 0 rgba(0,0,0,0.25);
  }


/* Settings Seite (UI Grid) */
.ad-ext-settings-head{
  margin: 0 0 12px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.ad-ext-settings-title{
  font-size: 12px;
  font-weight: 950;
  letter-spacing: 0.10em;
  text-transform: uppercase;
  opacity: 0.82;
}
.ad-ext-settings-close{
  width: 30px;
  height: 30px;
  padding: 0;
  justify-content: center;
}

.ad-ext-settings-grid{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:16px;
  align-items:stretch;
  grid-auto-flow: row;
}

/* Option 1 Layout v0.14.21
   Row 1: Importer (links) | Bulk (rechts, spannt über 2 Reihen)
   Row 2: Viewer (links, kompakt) | Bulk (rechts)
   Row 3: Einstellungen (full width)
*/
.ad-ext-card--bulk{ grid-column: 2 / 3; grid-row: 1 / span 2; }
.ad-ext-card--viewer{ grid-column: 1 / 2; grid-row: 2; align-self: start; }
.ad-ext-card--viewer .ad-ext-card-body{ min-height: unset; padding-bottom: 8px; }
.ad-ext-card--config{ grid-column: 1 / -1; }

@media (max-width: 900px){
  .ad-ext-settings-grid{ grid-template-columns: 1fr; }
  .ad-ext-card--bulk{ grid-column: 1 / -1; grid-row: auto; }
  .ad-ext-card--viewer{ grid-column: 1 / -1; grid-row: auto; }
  .ad-ext-card--config{ grid-column: 1 / -1; }
}

/* Settings Cards */
.ad-ext-card-head{ display:flex; align-items:center; justify-content:space-between; margin-bottom: 10px; }
.ad-ext-card-body{ min-height: 60px; }

/* Settings Grid: Cards gleich hoch (Importer == Bulk) */
.ad-ext-settings-grid > .ad-ext-card{ display:flex; flex-direction:column; min-height:0; }
.ad-ext-settings-grid > .ad-ext-card .ad-ext-card-body{ flex:1 1 auto; min-height:0; }

/* Bulk Card: embedded panel darf strecken, Log wächst mit */
.ad-ext-card--bulk .ad-ext-card-body{ display:flex; flex-direction:column; min-height:0; }
#ad-ext-settings-slot-bulk{ flex:1 1 auto; min-height:0; height:100%; display:flex; }
#ad-ext-settings-slot-bulk > *{ flex:1 1 auto; min-height:0; }

/* Viewer (Segmented UI Placeholder) */
.ad-ext-viewmode{ display:flex; flex-direction:column; gap:10px; }
.ad-ext-viewmode-label{ font-size: 12px; font-weight: 900; opacity: .78; }
.ad-ext-seg{ display:flex; gap:8px; flex-wrap:wrap; }
.ad-ext-seg-btn{
  padding:8px 12px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.15);
  background: rgba(0,0,0,.15);
  cursor:pointer;
}
.ad-ext-seg-btn.is-active{ outline:2px solid rgba(255,255,255,.35); }
.ad-ext-viewmode-hint{ font-size: 12px; opacity:.75; }

/* Bulk placeholder */
.ad-ext-bulk-placeholder{ display:flex; flex-direction:column; gap:10px; }
.ad-ext-bulk-placeholder-text{ font-size: 12px; opacity:.78; }
.ad-ext-bulk-placeholder-actions{ display:flex; gap:8px; flex-wrap:wrap; }
.ad-ext-btn{
  padding:8px 12px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.15);
  background: rgba(0,0,0,.15);
  opacity:.7;
  cursor:pointer;
}
.ad-ext-btn:hover:not(:disabled){ opacity:.9; }
.ad-ext-btn--secondary{ opacity:.85; }
.ad-ext-btn--secondary:hover:not(:disabled){ opacity:1; }
.ad-ext-btn:disabled{ cursor:not-allowed; opacity:.45; }


/* Config (User Settings) */
.ad-ext-cfg-status{ font-size:12px; opacity:.85; margin-bottom:8px; }

/* Legacy group wrappers (v0.14.19) – bleiben harmless, falls noch irgendwo genutzt */
.ad-ext-cfg-group{ margin-top: 8px; }
.ad-ext-cfg-group-title{ margin-top:10px; font-weight:600; opacity:.9; }

/* Config Sections (Option 1): klare Formular-Blöcke */
.ad-ext-cfg-section{
  margin-top: 12px;
  padding: 12px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.10);
}
.ad-ext-card--config .ad-ext-cfg-section:first-of-type{ margin-top: 0; }

.ad-ext-cfg-section-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  margin-bottom: 8px;
}


/* Config Sections: Collapse Toggle (v0.14.100) */
.ad-ext-cfg-section.is-collapsed .ad-ext-cfg-section-body{ display:none; }

.ad-ext-cfg-section-toggle {
    border: 1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.10);
    border-radius: 10px;
    padding: 2px 10px;
    line-height: 1.2;
    font-weight: 900;
    cursor: pointer;
    opacity: .85;
}
.ad-ext-cfg-section-toggle:hover { opacity: 1; background: rgba(255,255,255,.06); }
.ad-ext-cfg-section-title{
  font-weight: 700;
  letter-spacing: .2px;
  opacity: .95;
}

/* Rows: weiter wie bisher, aber innerhalb Section sauber starten/enden */
.ad-ext-cfg-row{ display:flex; justify-content:space-between; gap:12px; align-items:center; padding:8px 0; border-top:1px solid rgba(255,255,255,.06); }
.ad-ext-cfg-section-body .ad-ext-cfg-row:first-child{ border-top:none; padding-top:0; }
.ad-ext-cfg-section-body .ad-ext-cfg-row:last-child{ padding-bottom:0; }

.ad-ext-cfg-row-left{ min-width: 0; }
.ad-ext-cfg-label{ font-size:13px; font-weight:600; opacity:.95; }
.ad-ext-cfg-help{ font-size:12px; opacity:.7; margin-top:2px; line-height:1.25; }
.ad-ext-cfg-input{ width: 110px; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.15); background: rgba(0,0,0,.12); color: inherit; text-align:right; }

.ad-ext-btn--danger{ border-color: rgba(255,90,90,.45); background: rgba(255,90,90,.10); opacity:.9; }
.ad-ext-btn--danger:hover{ opacity: 1; }

/* Reset Button: weniger dominant, aber gut erreichbar */
.ad-ext-card--config #adExtCfgReset.ad-ext-btn--danger{
  padding: 6px 10px;
  font-size: 12px;
  border-radius: 10px;
  opacity: .78;
}
.ad-ext-card--config #adExtCfgReset.ad-ext-btn--danger:hover{ opacity: .92; }

/* Importer-Konsole (API Panel) embedded */

#adApiPanel.adApiPanel--embedded{
  position: static !important;
  right: auto !important;
  bottom: auto !important;
  width: 100% !important;
  max-width: 420px !important;
  margin: 0 !important;
}

      /* Training: Plan-Sidebar Scaffold (UI-only) */
      .ad-train-head { display:flex; flex-direction:column; align-items:flex-start; gap: 10px; margin: 14px 0 8px; }
      .ad-train-controls { width: 100%; display:flex; flex-direction:column; align-items:flex-start; gap: 10px; }
      .ad-train-controls-row { width: 100%; display:flex; align-items:center; gap: 12px; flex-wrap: wrap; margin-top: 10px; }
      #ad-train-controls-row #ad-ext-plan-basis { margin-left:auto; }
      .ad-train-controls .ad-ext-plan-week { width: 100%; min-width: 0; }
      /* Breiter Week-Select im Training-Header */
      #ad-ext-plan-week-select { width: min(720px, 100%); max-width: 100%; }
      #ad-ext-view-training #ad-ext-plan-week-wrap { width: 100%; min-width: 0; margin: 0 0 12px 0; }
      /* Week-Select soll im Training-Header immer unter den Sub-Tabs stehen (volle Zeile) */
      #ad-train-week-host-top { width: 100%; flex-basis: 100%; }

      /* Nur Combobox sichtbar: Label/Sub (KW/Zeitraum) ausblenden */
      #ad-ext-view-training #ad-ext-plan-week-label { display:none; }
      #ad-ext-view-training #ad-ext-plan-week-sub { display:none; }



      .ad-train-layout { display: grid; grid-template-columns: 1fr; gap: 12px; }
      @media (min-width: 1100px) {
        /* Split-Layout nur wenn Plan offen – sonst volle Breite */
        .ad-train-layout { grid-template-columns: 1fr; align-items: start; }
        .ad-train-layout[data-plan-open="1"] { grid-template-columns: 1.7fr 0.9fr; }
      }

      /* Plan sichtbar/unsichtbar (Wrapper-State bevorzugt; data-open als Fallback) */
      .ad-train-side[data-open="0"] { display: none; }
      .ad-train-side[data-open="1"] { display: block; }
      .ad-train-layout[data-plan-open="0"] .ad-train-side { display: none; }
      .ad-train-layout[data-plan-open="1"] .ad-train-side { display: block; }

      /* Training View Switch (Trainingsdaten | Trainingsplan) */
      .ad-train-layout[data-train-view="DATA"] .ad-train-side { display:none; }
      .ad-train-layout[data-train-view="PLAN"] .ad-train-main { display:none; }
      .ad-train-layout[data-train-view="PLAN"] { grid-template-columns: 1fr !important; }
      .ad-train-layout[data-train-view="PLAN"] .ad-train-side { width:auto; max-width:none; }

      .ad-train-insights { display:none; }
      .ad-train-segfokus { display:none; }
      .ad-train-atcfokus { display:none; overflow-anchor: none; }
      .ad-train-chromo { display:none; }



      .ad-train-layout[data-train-view="INSIGHTS"] .ad-train-main { display:none !important; }
      .ad-train-layout[data-train-view="INSIGHTS"] .ad-train-side { display:none !important; }
      .ad-train-layout[data-train-view="INSIGHTS"] .ad-train-insights { display:block; }
      .ad-train-layout[data-train-view="INSIGHTS"] { grid-template-columns: 1fr !important; }

      .ad-train-layout[data-train-view="SEGFOCUS"] .ad-train-main { display:none !important; }
      .ad-train-layout[data-train-view="SEGFOCUS"] .ad-train-side { display:none !important; }
      .ad-train-layout[data-train-view="SEGFOCUS"] .ad-train-insights { display:none !important; }
      .ad-train-layout[data-train-view="SEGFOCUS"] .ad-train-segfokus { display:block; }
      .ad-train-layout[data-train-view="SEGFOCUS"] { grid-template-columns: 1fr !important; }
      .ad-train-layout[data-train-view="ATCFOCUS"] .ad-train-atcfokus { display:block; }
      .ad-train-layout[data-train-view="ATCFOCUS"] .ad-train-main,
      .ad-train-layout[data-train-view="ATCFOCUS"] .ad-train-side,
      .ad-train-layout[data-train-view="ATCFOCUS"] .ad-train-insights,
      .ad-train-layout[data-train-view="ATCFOCUS"] .ad-train-segfokus,
      .ad-train-layout[data-train-view="ATCFOCUS"] .ad-train-chromo { display:none !important; }
      .ad-train-layout[data-train-view="ATCFOCUS"] { grid-template-columns: 1fr !important; }

      .ad-train-layout[data-train-view="CHROMO"] .ad-train-chromo { display:block; }
      .ad-train-layout[data-train-view="CHROMO"] .ad-train-main,
      .ad-train-layout[data-train-view="CHROMO"] .ad-train-side,
      .ad-train-layout[data-train-view="CHROMO"] .ad-train-insights,
      .ad-train-layout[data-train-view="CHROMO"] .ad-train-segfokus { display:none !important; }
      .ad-train-layout[data-train-view="CHROMO"] { grid-template-columns: 1fr !important; }

      .ad-train-side {
        border-radius: 14px;
        border: 1px solid rgba(170, 210, 255, 0.10);
        background: linear-gradient(180deg, rgba(120, 170, 255, 0.10), rgba(18, 28, 62, 0.18));
        box-shadow: inset 0 0 0 1px rgba(170, 210, 255, 0.08), 0 12px 40px rgba(0,0,0,0.14);
        backdrop-filter: blur(6px);
        padding: var(--ad-card-padding);
      }


      .ad-train-side-head { display:flex; justify-content:space-between; align-items:flex-start; gap:10px; margin-bottom: 10px; }
      .ad-train-side-title { font-weight: 700; opacity: .95; }
      .ad-train-side-sub { font-size: 12px; opacity: .7; margin-top: 2px; }

      .ad-train-side-head-actions { display:flex; gap: 8px; align-items:center; flex-wrap: wrap; }

/* Training: Plan-Sidebar Actions Menu (Hamburger) (0.14.91) */
.ad-plan-menu { position: relative; display: inline-flex; align-items: center; }
.ad-plan-menu-btn {
  /* Button „≡“ soll wie Drawer-Close wirken */
  min-width: 38px;
  padding: 6px 10px;
  line-height: 1;
  font-weight: 900;
  border: 1px solid rgba(255,255,255,.15);
  background: rgba(255,255,255,.04);
  border-radius: 10px;
}
.ad-plan-menu-btn:hover { background: rgba(255,255,255,.06); }

.ad-plan-menu-dropdown{
  position: absolute;
  top: calc(100% + 6px);
  right: 0;
  min-width: 240px;

  /* === Drawer Look === */
  padding: 12px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(15,15,15,.96);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);

  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 2000;
  box-shadow: 0 10px 24px rgba(0,0,0,.35);
}
.ad-plan-menu-dropdown[hidden]{ display:none !important; }

.ad-plan-menu-dropdown .ad-ext-btn{
  width: 100%;
  justify-content: flex-start;
  text-align: left;

  padding: 10px 10px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.10);

  font-size: 13px;
  opacity: .95;
}
.ad-plan-menu-dropdown .ad-ext-btn:hover{
  background: rgba(255,255,255,.04);
  opacity: 1;
}
.ad-plan-menu-dropdown .ad-ext-btn:disabled,
.ad-plan-menu-dropdown .ad-ext-btn[disabled]{
  opacity: .45;
  cursor: not-allowed;
}

/* Training: ChatGPT Actions (Hamburger Menu in Trainingsdaten) (0.14.184) */
#ad-ext-ai-actions{
  display:flex;
  justify-content:flex-end;
  align-items:center;
  gap: 8px;
  margin: 0 0 10px 0;
  flex-wrap: wrap;
}
.ad-ai-menu-dropdown{ min-width: 320px; }
.ad-ai-menu-title{ font-weight: 900; font-size: 13px; opacity: .95; margin-bottom: 2px; }
.ad-ai-menu-field{ display:flex; flex-direction:column; gap: 6px; }
.ad-ai-menu-label{ font-size: 12px; font-weight: 800; opacity: .75; }
.ad-ai-menu-select{ width: 100%; }
.ad-ai-menu-custom{ display:flex; align-items:center; gap: 6px; }
.ad-ai-menu-custom .ad-ext-input{ width: 100%; }
.ad-ai-menu-dropdown .ad-ext-select,
.ad-ai-menu-dropdown .ad-ext-input{
  background: rgba(255,255,255,.06);
  border-color: rgba(255,255,255,.12);
}
.ad-ai-menu-status{ font-weight: 800; opacity: .9; }

/* ChatGPT Button in Trainingsdaten: use icon instead of "≡" */
.ad-ai-menu-btn{
  padding: 6px 8px;
  min-width: 38px;
  height: 34px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.ad-ai-menu-btn-icon{
  width: 18px;
  height: 18px;
  display:block;
  opacity: .95;
  /* make dark favicons readable on dark UI */
  filter: invert(1) brightness(1.1);
}
.ad-ai-menu-btn-fallback{
  font-weight: 900;
  font-size: 12px;
  line-height: 1;
  letter-spacing: .4px;
}

      .ad-train-side-placeholder { font-size: 13px; opacity: .85; display:flex; flex-direction:column; gap: 8px; }


      /* Training: Plan-Sidebar Controls (UI-only) */
      .ad-plan-controls { display:flex; flex-direction:column; gap: 10px; margin-bottom: 10px; }
      .ad-plan-row { display:flex; justify-content:space-between; align-items:center; gap: 10px; flex-wrap:wrap; }
      .ad-plan-label { font-size: 13px; opacity: .85; }
      .ad-plan-week-info { font-size: 13px; opacity: .9; }

      .ad-plan-select {
        min-width: 180px;
        padding: 8px 10px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,.15);
        background: rgba(255,255,255,.04);
        color: inherit;
      }
      .ad-plan-select option { background: #000; color: #fff; } /* best effort */

      .ad-plan-seg {
        display:flex;
        gap: 6px;
        padding: 4px;
        border-radius: 14px;
        border: 1px solid rgba(255,255,255,.12);
        background: rgba(18, 28, 62, 0.55);
      }
      .ad-plan-seg-btn {
        padding: 6px 10px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,.10);
        background: rgba(0,0,0,.10);
        color: inherit;
        cursor:pointer;
        opacity: .85;
      }
      .ad-plan-seg-btn.is-active {
        opacity: 1;
        border-color: rgba(255,255,255,.18);
        background: rgba(140,190,255,0.16);
      }
      .ad-plan-seg-btn:disabled{ cursor:not-allowed; opacity:.45; }

      .ad-plan-check { display:flex; align-items:center; gap: 8px; font-size: 13px; opacity: .85; }

      .ad-plan-summary {
        margin-top: 8px;
        padding: 10px;
        border-radius: 14px;
        border: 1px solid rgba(255,255,255,.08);
        background: rgba(255,255,255,.04);
        display:flex;
        flex-direction:column;
        gap: 8px;
      }
      .ad-plan-summary-item { display:flex; justify-content:space-between; align-items:center; }
      .ad-plan-summary-item span { font-size: 13px; opacity: .8; }
      .ad-plan-summary-item strong { font-size: 13px; }

      .ad-plan-table {
        margin-top: 10px;
        border-radius: 14px;
        overflow: hidden;
        border: 1px solid rgba(255,255,255,.08);
        background: linear-gradient(180deg, rgba(120, 170, 255, 0.08), rgba(18, 28, 62, 0.14));
      }

      .ad-plan-table .ad-plan-row {
        display: grid;
        justify-content: stretch;
        grid-template-columns: 1.35fr 0.55fr 0.65fr 0.75fr;
        gap: 8px;
        align-items: center;
        padding: 10px 10px;
        font-size: 13px;
      }
      .ad-plan-table .ad-plan-row--head {
        font-weight: 700;
        opacity: .9;
        background: rgba(140,190,255,0.08);
      }
      .ad-plan-table .ad-plan-row:nth-child(even):not(.ad-plan-row--head):not(.ad-plan-row--foot) {
        background: rgba(255,255,255,.03);
      }
      .ad-plan-table .ad-plan-row--foot {
        font-weight: 700;
        background: rgba(140,190,255,0.08);
      }

      .ad-plan-cell-right { justify-self: end; text-align: right; }

      .ad-plan-soll-head { justify-self:end; display:flex; align-items:center; gap:6px; }
      .ad-plan-soll-label { display:inline-block; width:86px; text-align:left; }
      .ad-plan-soll-unit { visibility:hidden; font-size:12px; opacity:.65; }

      .ad-plan-pill {
        justify-self: end;
        min-width: 86px;
        text-align: right;
        padding: 6px 10px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,.14);
        background: rgba(255,255,255,.04);
      }

      .ad-plan-input-wrap { justify-self:end; display:flex; align-items:center; gap:6px; }
      .ad-plan-unit { font-size:12px; opacity:.65; }
      .ad-plan-input { width: 86px; text-align:right; padding: 6px 10px; border-radius: 12px; border:1px solid rgba(255,255,255,.16); background: rgba(255,255,255,.04); color: inherit; }
      .ad-plan-est-cell{ justify-self:end; text-align:right; }
      .ad-plan-est-muted{ font-size:12px; opacity:.65; }
      .ad-plan-est-val{ font-variant-numeric: tabular-nums; }

      .ad-plan-perleg-cell{ justify-self:end; text-align:right; font-size:12px; opacity:.85; }
      .ad-plan-perleg-val{ font-variant-numeric: tabular-nums; }




      .ad-plan-activity { display:flex; align-items:center; gap: 8px; min-width:0; }
      .ad-plan-activity-main { display:flex; flex-direction:column; gap: 2px; min-width:0; }
      .ad-plan-activity-name { display:block; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
      .ad-plan-perf { font-size: 12px; opacity: .65; }

      @media(max-width: 520px){
        .ad-plan-table { overflow-x: auto; }
        .ad-plan-table .ad-plan-row { min-width: 640px; font-size: 12px; }
      }

      .ad-plan-actions {
        position: sticky;
        bottom: 0;
        margin-top: 12px;
        padding-top: 10px;
        display:flex;
        justify-content:space-between;
        align-items:center;
        gap: 10px;
        background: linear-gradient(to top, rgba(0,0,0,.22), rgba(0,0,0,0));
      }
      .ad-plan-actions-left { font-size: 12px; opacity: .8; }
      .ad-plan-actions-right { display:flex; gap: 8px; flex-wrap:wrap; }



      .ad-plan-status { margin-top: 10px; font-size: 12px; opacity: .8; }

      /* Training Plan Sidebar – Step 1 additions */
      .ad-ext-btn--primary{ border-color: rgba(255,255,255,.22); background: rgba(255,255,255,.06); opacity: .9; }
      .ad-ext-btn--primary:hover{ opacity: 1; }

      .ad-plan-activityline{ display:flex; align-items:center; justify-content:space-between; gap: 8px; }
      .ad-plan-activityline .ad-plan-activity{ min-width:0; }
      .ad-plan-mini-actions{ display:flex; gap: 6px; flex-shrink:0; }

      .ad-plan-perfline{
        font-size: 11px;
        opacity: .72;
        margin-top: 4px;
        display:flex;
        gap: 8px;
        flex-wrap: wrap;
        line-height: 1.25;
      }
      .ad-plan-perfline span{ white-space: nowrap; }


      .ad-plan-mini-btn{
        border: 1px solid rgba(255,255,255,.14);
        background: rgba(0,0,0,.10);
        color: inherit;
        border-radius: 10px;
        padding: 4px 7px;
        cursor: pointer;
        opacity: .75;
        line-height: 1;
      }
      .ad-plan-mini-btn:hover{ opacity: 1; }
      .ad-plan-mini-btn--danger{ border-color: rgba(255,90,90,.45); background: rgba(255,90,90,.10); opacity: .88; }

      /* Drawer */
      .ad-plan-drawer-overlay{
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,.45);
        z-index: 99998;
      }

      .ad-plan-drawer{
        position: fixed;
        top: 0;
        right: 0;
        height: 100vh;
        width: 360px;
        max-width: 92vw;
        z-index: 99999;
        border-left: 1px solid rgba(255,255,255,.12);
        background: rgba(15,15,15,.96);
        backdrop-filter: blur(6px);
        transform: translateX(100%);
        transition: transform .18s ease;
        padding: 12px;
        display:flex;
        flex-direction:column;
        gap: 10px;
      }
      .ad-plan-drawer[data-open="1"]{ transform: translateX(0); }

      .ad-plan-drawer-head{ display:flex; justify-content:space-between; align-items:flex-start; gap: 10px; }
      .ad-plan-drawer-title{ font-weight: 800; opacity: .95; }
      .ad-plan-drawer-sub{ font-size: 12px; opacity: .7; margin-top: 2px; }

      .ad-plan-drawer-close{
        border: 1px solid rgba(255,255,255,.15);
        background: rgba(0,0,0,.10);
        color: inherit;
        border-radius: 10px;
        padding: 6px 10px;
        cursor: pointer;
      }

      .ad-plan-drawer-body{ display:flex; flex-direction:column; gap: 10px; min-height: 0; }
      .ad-plan-drawer-search{
        width: 100%;
        padding: 10px 12px;
        border-radius: 14px;
        border: 1px solid rgba(255,255,255,.14);
        background: rgba(0,0,0,.14);
        color: inherit;
      }

      .ad-plan-drawer-list{
        display:flex;
        flex-direction:column;
        gap: 8px;
        overflow: auto;
        padding-right: 2px;
      }

      .ad-plan-drawer-item{
        display:flex;
        justify-content:space-between;
        align-items:center;
        gap: 10px;
        padding: 10px 10px;
        border-radius: 14px;
        border: 1px solid rgba(255,255,255,.10);
        background: rgba(0,0,0,.10);
        cursor:pointer;
      }
      .ad-plan-drawer-item:hover{ background: rgba(255,255,255,.04); }

      .ad-plan-drawer-item-left{ min-width: 0; }
      .ad-plan-drawer-item-name{ font-weight: 700; opacity: .95; }
      .ad-plan-drawer-item-meta{ font-size: 12px; opacity: .7; margin-top: 2px; }

      .ad-plan-drawer-add{
        padding: 7px 10px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,.14);
        background: rgba(255,255,255,.06);
        color: inherit;
        cursor: pointer;
        opacity: .85;
        flex-shrink:0;
      }
      .ad-plan-drawer-add:hover{ opacity: 1; }

      .ad-plan-drawer-empty{ padding: 10px; font-size: 13px; opacity: .75; }


`;
        document.head.appendChild(style);
    }

    // =========================
    // Tooltip
    // =========================
    function ensureTooltipEl() {
        let el = document.getElementById("ad-ext-tooltip");
        if (el) return el;
        el = document.createElement("div");
        el.id = "ad-ext-tooltip";
        el.className = "ad-ext-tooltip";
        document.body.appendChild(el);
        return el;
    }
    const tooltip = () => ensureTooltipEl();

    function tooltipMove(ev) {
        const el = tooltip();
        const pad = 14;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const rect = el.getBoundingClientRect();

        let x = ev.clientX + pad;
        let y = ev.clientY + pad;

        if (x + rect.width + 8 > vw) x = Math.max(8, ev.clientX - rect.width - pad);
        if (y + rect.height + 8 > vh) y = Math.max(8, ev.clientY - rect.height - pad);

        el.style.left = `${x}px`;
        el.style.top = `${y}px`;
    }
    function tooltipShow(ev, html, opts) {
        const el = tooltip();
        el.innerHTML = html;
        el.style.display = "block";

        const interactive = !!(opts && opts.interactive);
        const pinned = !!(opts && opts.pinned);
        const pinnedOwner = (opts && opts.pinnedOwner) ? String(opts.pinnedOwner) : "";

        el.style.pointerEvents = interactive ? "auto" : "none";
        if (pinned) {
            el.dataset.pinned = "1";
            if (pinnedOwner) el.dataset.pinnedOwner = pinnedOwner;
        } else {
            delete el.dataset.pinned;
            delete el.dataset.pinnedOwner;
        }

        if (ev) tooltipMove(ev);
    }

    function tooltipHide() {
        const el = tooltip();
        el.style.display = "none";
        el.style.pointerEvents = "none";
        delete el.dataset.pinned;
        delete el.dataset.pinnedOwner;
    }

    function tooltipMoveToRect(anchorRect) {
        const el = tooltip();
        if (!anchorRect) return;

        const pad = 10;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const rect = el.getBoundingClientRect();

        // Prefer bottom-center
        let x = anchorRect.left + anchorRect.width / 2 - rect.width / 2;
        let y = anchorRect.bottom + pad;

        // Clamp horizontally
        x = Math.max(8, Math.min(x, vw - rect.width - 8));

        // If bottom overflows, place above
        if (y + rect.height + 8 > vh) {
            y = anchorRect.top - rect.height - pad;
        }
        // Clamp vertically
        y = Math.max(8, Math.min(y, vh - rect.height - 8));

        el.style.left = `${Math.round(x)}px`;
        el.style.top = `${Math.round(y)}px`;
    }

    // =========================
    // Panel HTML
    // =========================
    function buildPanelHTML() {
        return `
      <div class="ad-ext-root ad-ext-layout ad-ext-layout--auto" data-ad-layout-mode="auto">
        <div style="display:flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
          <div>
            <div class="ad-ext-title">Erweiterte Statistiken</div>
            <div class="ad-ext-subtitle">🎯 Dein Match‑Radar: Trends, Stärken und Baustellen aus deiner Match‑History. Scoring, Checkouts, Gegnerstärke und Training‑Fokus – filterbar nach Zeitraum. Dazu Trainingsplan & Notizen pro Woche.</div>
          </div>
          <div style="text-align:right;">
            <div class="ad-ext-header-actions">

              <button id="ad-ext-refresh-btn" type="button" class="ad-ext-icon-btn ad-ext-settings-btn ad-ext-refresh-btn" title="Refresh">
                <span class="ad-ext-icon">⟳</span>
              </button>

              <button id="ad-ext-settings-btn" type="button" class="ad-ext-icon-btn ad-ext-settings-btn ad-ext-settings-page-btn" aria-haspopup="true" aria-expanded="false" title="Einstellungen" aria-pressed="false">
                <span class="ad-ext-icon">⚙</span>
              </button>

              <div id="ad-ext-settings-menu" class="ad-ext-menu" hidden>
                <div class="ad-ext-menu-panel" data-ad-ext-menu-panel="main">

                  <button type="button" class="ad-ext-menu-item ad-ext-menu-nav" data-ad-ext-open-menu-panel="view">
                    <span>Ansicht</span>
                    <span class="ad-ext-menu-chevron">›</span>
                  </button>

                  <div id="ad-ext-auto-refresh-hint" class="ad-ext-menu-hint" style="display:none;"></div>
                </div>

                <div class="ad-ext-menu-panel" data-ad-ext-menu-panel="view" hidden>
                  <button type="button" class="ad-ext-menu-item ad-ext-menu-back" data-ad-ext-open-menu-panel="main">← Zurück</button>
                  <div class="ad-ext-menu-title">Ansicht</div>
                  <div class="ad-ext-segcontrol ad-ext-layout-toggle" id="ad-ext-layout-toggle" title="Layout: Auto / Portrait / Landscape">
                    <button type="button" class="ad-ext-segbtn" data-ad-ext-layout="auto">Auto</button>
                    <button type="button" class="ad-ext-segbtn" data-ad-ext-layout="portrait">Hochformat</button>
                    <button type="button" class="ad-ext-segbtn" data-ad-ext-layout="landscape">Querformat</button>
                  </div>
                </div>
              </div>
            </div>

          </div>
        </div>

        <div id="ad-ext-dashboard-wrap">

        <div class="ad-ext-subnav">
          <button id="ad-ext-subnav-x01" type="button" class="ad-ext-subnav-btn ad-ext-subnav-btn--active">X01 Liga</button>
          <button id="ad-ext-subnav-training" type="button" class="ad-ext-subnav-btn">Training</button>
          <button id="ad-ext-subnav-masterhof" type="button" class="ad-ext-subnav-btn">Gesamt Hall Of Fame</button>
        </div>

        <div id="ad-ext-view-segment" style="display:none;">
          <div class="ad-ext-section-title">Segment Training</div>

          <div class="ad-ext-filters">
            <div class="ad-ext-filter-block">
              <div class="ad-ext-filter-label">Filter Segment-Typ</div>
              <div class="ad-ext-filter-row">
                <div class="ad-ext-filter-name">Typ</div>
                <div class="ad-ext-select-wrap">
                  <select id="ad-ext-filter-segtype" class="ad-ext-select">
                    <option value="ALL">Alle Segmente</option>
                    <option value="SINGLE">Singles</option>
                    <option value="DOUBLE">Doubles</option>
                    <option value="TRIPLE">Triples</option>
                  </select>
                </div>
              </div>
            </div>

            <div class="ad-ext-filter-block">
              <div class="ad-ext-filter-label">Datumsfilter</div>
              <div class="ad-ext-filter-row">
                <div class="ad-ext-filter-name">Zeit</div>
                <div class="ad-ext-select-wrap">
                  <select id="ad-ext-filter-daterange" class="ad-ext-select">                    <option value="TODAY">Heute (—)</option>
                    <option value="YESTERDAY">Gestern (—)</option>
                    <option value="DAY_BEFORE">Vorgestern (—)</option>
                    <option value="D7">Letzten 7 Tage</option>
                    <option value="D14">Letzten 14 Tage</option>
                    <option value="D30">Letzten 30 Tage</option>
                    <option value="M3">Letzten 3 Monate</option>
                    <option value="M6">Letzten 6 Monate</option>
                    <option value="Y1" selected>Letztes Jahr</option>
                    <option value="ALL">Gesamt</option>
                  </select>
                </div>
              </div>
            </div>
          </div>

          <div class="ad-ext-kpi-grid">
            <div class="ad-ext-kpi-tile">
              <div class="ad-ext-kpi-title">Sessions</div>
              <div class="ad-ext-kpi-value" id="ad-ext-st-kpi-sessions">—</div>
            </div>
            <div class="ad-ext-kpi-tile">
              <div class="ad-ext-kpi-title">GESPIELTE ZEIT</div>
              <div class="ad-ext-kpi-value" id="ad-ext-st-kpi-time">—</div>
              <div class="ad-ext-kpi-sub" id="ad-ext-st-kpi-time-sub">—</div>
            </div>
            <div class="ad-ext-kpi-tile">
              <div class="ad-ext-kpi-title">Ø Darts / Session</div>
              <div class="ad-ext-kpi-value" id="ad-ext-st-kpi-points">—</div>
            </div>
            <div class="ad-ext-kpi-tile">
              <div class="ad-ext-kpi-title">Ø Hit %</div>
              <div class="ad-ext-kpi-value" id="ad-ext-st-kpi-hitrate">—</div>
            </div>
          </div>

          <div class="ad-ext-grid-seg">
            <div class="ad-ext-card ad-ext-card-seg-hits">
              <div class="ad-ext-chart-title">Performance (Hit %)</div>
              <canvas id="ad-ext-chart-radar" class="ad-ext-chart-canvas" width="900" height="420"></canvas>
            </div>

            <div class="ad-ext-card ad-ext-card-seg-donut">
              <div class="ad-ext-chart-title">Spieltypen-Verhältnis – Anteil Singles / Doubles / Triples (Sessions).</div>
              <svg id="ad-ext-chart-donut" class="ad-ext-chart-svg" viewBox="0 0 520 220" role="img" aria-label="Spieltypen-Verhältnis"></svg>
            </div>

            <div class="ad-ext-card ad-ext-card-seg-radar">
              <div class="ad-ext-chart-title">Treffer je Target (Hits)</div>
              <canvas id="ad-ext-chart-bar" class="ad-ext-chart-canvas" width="520" height="220"></canvas>
            </div>
          </div>


          <div class="ad-ext-grid-2">
            <div>
              <div class="ad-ext-section-title">Sessions (Tagesbasis)</div>
              <div class="ad-ext-card" style="padding:0;">
                <table class="ad-ext-table">
                  <thead>
                    <tr>
                      <th>Datum</th>
                      <th class="ad-ext-table-value-right">Sessions</th>
                      <th class="ad-ext-table-value-right">Darts</th>
                      <th class="ad-ext-table-value-right">Hits</th>
                      <th class="ad-ext-table-value-right">Hit %</th>
                    </tr>
                  </thead>
                  <tbody id="ad-ext-st-table-day">
                    <tr><td colspan="5" style="opacity:.7; padding:10px 12px;">—</td></tr>
                  </tbody>
                </table>
              </div>
            </div>

            <div>
              <div class="ad-ext-section-title">Targets (Aggregiert)</div>
              <div class="ad-ext-card" style="padding:0;">
                <table class="ad-ext-table">
                  <thead>
                    <tr>
                      <th class="ad-ext-th-sortable" data-sort-key="target" title="Target (z.B. D8)">Target</th>
                      <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="sessions" title="Anzahl Sessions">Sessions</th>
                      <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="darts" title="Geworfene Darts">Darts</th>
                      <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="hits" title="Treffer (Hits)">Hits</th>
                      <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="hitPct" title="Trefferquote (Hits/Darts)">Hit %</th>
                    </tr>
                  </thead>
                  <tbody id="ad-ext-st-table-target">
                    <tr><td colspan="5" style="opacity:.7; padding:10px 12px;">—</td></tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>

                  </div>

        <div id="ad-ext-view-x01">

          <div class="ad-ext-filters">
                      <div class="ad-ext-filter-block">
                        <div class="ad-ext-filter-label">Spieler auswählen</div>
                        <div class="ad-ext-filter-row">
                          <div class="ad-ext-filter-name">Ich</div>
                          <div class="ad-ext-select-wrap">
                            <select id="ad-ext-x01-filter-player" class="ad-ext-select">
                              <option value="AUTO">Auto</option>
                            </select>
                          </div>
                        </div>
                      </div>

                      <div class="ad-ext-filter-block">
                        <div class="ad-ext-filter-label">Combo (nur echte Lineups)</div>
                        <div class="ad-ext-filter-row">
                          <div class="ad-ext-filter-name">Combo</div>
                          <div class="ad-ext-select-wrap">
                            <select id="ad-ext-x01-filter-combo" class="ad-ext-select">
                              <option value="AUTO_TOP">Häufigste</option>
                            </select>
                          </div>
                        </div>
                      </div>

                      <div class="ad-ext-filter-block">
                        <div class="ad-ext-filter-label">Datumsfilter</div>
                        <div class="ad-ext-filter-row">
                          <div class="ad-ext-filter-name">Zeit</div>
                          <div class="ad-ext-select-wrap">
                            <select id="ad-ext-x01-filter-daterange" class="ad-ext-select">                    <option value="TODAY">Heute (—)</option>
                              <option value="YESTERDAY">Gestern (—)</option>
                              <option value="DAY_BEFORE">Vorgestern (—)</option>
                              <option value="D7">Letzten 7 Tage</option>
                              <option value="D14">Letzten 14 Tage</option>
                              <option value="D30">Letzten 30 Tage</option>
                              <option value="M3">Letzten 3 Monate</option>
                              <option value="M6">Letzten 6 Monate</option>
                              <option value="Y1" selected>Letztes Jahr</option>
                              <option value="ALL">Gesamt</option>
                            </select>
                          </div>
                        </div>
                      </div>
                    </div>

          <div class="ad-ext-x01-subnav">
            <div class="ad-ext-segcontrol ad-ext-x01-tabs" id="ad-ext-x01-tabs">
              <button class="ad-ext-segbtn" data-ad-ext-x01panel="liga">Liga</button>
              <button class="ad-ext-segbtn" data-ad-ext-x01panel="hof">Hall of Fame</button>
            </div>
          </div>

          <div id="ad-ext-x01-panel-liga">
<div class="ad-ext-kpi-grid ad-ext-kpi-grid--x01">
            <div class="ad-ext-kpi-tile">
              <div class="ad-ext-kpi-title">Legs</div>
              <div class="ad-ext-kpi-value" id="ad-ext-x01-kpi-legs">—</div>
              <div class="ad-ext-kpi-sub" id="ad-ext-x01-kpi-legs-sub">—</div>
            </div>
            <div class="ad-ext-kpi-tile">
              <div class="ad-ext-kpi-title">First 9 Average</div>
              <div class="ad-ext-kpi-value" id="ad-ext-x01-kpi-f9">—</div>
              <div class="ad-ext-kpi-sub" id="ad-ext-x01-kpi-f9-sub">—</div>
            </div>
            <div class="ad-ext-kpi-tile">
              <div class="ad-ext-kpi-title">Ø Darts / Leg</div>
              <div class="ad-ext-kpi-value" id="ad-ext-x01-kpi-points">—</div>
              <div class="ad-ext-kpi-sub" id="ad-ext-x01-kpi-points-sub">—</div>
            </div>
            <div class="ad-ext-kpi-tile">
              <div class="ad-ext-kpi-title">Check-out Quote</div>
              <div class="ad-ext-kpi-value" id="ad-ext-x01-kpi-checkout">—</div>
              <div class="ad-ext-kpi-sub" id="ad-ext-x01-kpi-checkout-sub">—</div>
            </div>
            <div class="ad-ext-kpi-tile">
              <div class="ad-ext-kpi-title">GAMES AVERAGE</div>
              <div class="ad-ext-kpi-value" id="ad-ext-x01-kpi-avg">—</div>
              <div class="ad-ext-kpi-sub" id="ad-ext-x01-kpi-avg-sub">—</div>
            </div>
            <div class="ad-ext-kpi-tile">
              <div class="ad-ext-kpi-title">GESPIELTE ZEIT</div>
              <div class="ad-ext-kpi-value" id="ad-ext-x01-kpi-time">—</div>
              <div class="ad-ext-kpi-sub" id="ad-ext-x01-kpi-time-sub">—</div>
            </div>
          </div>
<div class="ad-ext-card" style="padding:0; margin-bottom:12px;">
  <div class="ad-ext-table-scroll">
    <table id="ad-ext-x01-league-table" class="ad-ext-table ad-ext-table--fixed">
      <colgroup>
        <col style="width:5%;">
        <col style="width:21%;">
        <col style="width:8%;">
        <col style="width:6%;">
        <col style="width:6%;">
        <col style="width:10%;">
        <col style="width:7%;">
        <col style="width:10%;">
        <col style="width:6%;">
        <col style="width:8%;">
        <col style="width:8%;">
        <col style="width:5%;">
      </colgroup>
      <thead>
        <tr>
          <th title="Rang">#</th>
          <th class="ad-ext-th-sortable" data-sort-key="name" title="Spielername">Spieler</th>
          <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="matches" title="Anzahl Matches">Matches</th>
          <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="wins" title="Gewonnen">W</th>
          <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="losses" title="Verloren">L</th>
          <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="pointsFor" title="Matchpunkte (für:gegen)">Punkte F/G</th>
          <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="pointsDiff" title="Punktedifferenz (für - gegen)">Pkt Diff</th>
          <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="legsFor" title="Legs (für:gegen)">Legs F/G</th>
          <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="legDiff" title="Leg-Differenz (für - gegen)">Leg Diff</th>
          <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="first9Avg" title="First 9 Average (Ø erste 9 Darts)">F9 Avg</th>
          <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="pointsPerDart" title="Ø Punkte pro Dart">Pkt/Dart</th>
          <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="checkoutPct" title="Checkout-Quote (Hits/Versuche)">CO%</th>
        </tr>
      </thead>
      <tbody id="ad-ext-x01-league-body">
        <tr><td colspan="12" style="opacity:.7; padding:10px 12px;">—</td></tr>
      </tbody>
    </table>
  </div>
</div>

          <div class="ad-ext-grid-x01" style="margin-top:0; margin-bottom:12px;">
            <div class="ad-ext-card ad-ext-card-x01-wl">
              <div class="ad-ext-chart-title">Wins vs. Losses</div>
              <svg id="ad-ext-x01-chart-wl" class="ad-ext-chart-svg" width="900" height="420"></svg>
            </div>

            <div class="ad-ext-card ad-ext-card-x01-legdiff">
              <div class="ad-ext-chart-title">Leg-Diff pro Match</div>
              <svg id="ad-ext-x01-chart-legdiff" class="ad-ext-chart-svg" width="520" height="220"></svg>
            </div>

            <div class="ad-ext-card ad-ext-card-x01-momentum">
              <div class="ad-ext-chart-title-row">
                <div class="ad-ext-chart-title">Momentum</div>
                <div class="ad-ext-segcontrol ad-ext-momentum-toggle" id="ad-ext-x01-momentum-toggle" title="Momentum-Modus">
                  <button class="ad-ext-segbtn" type="button" data-mode="match">Match</button>
                  <button class="ad-ext-segbtn" type="button" data-mode="legs">Legs</button>
                </div>
              </div>
              <svg id="ad-ext-x01-chart-momentum" class="ad-ext-chart-svg" width="520" height="240"></svg>
            </div>
          </div>

          <div class="ad-ext-grid-2" style="margin-top:0; margin-bottom:12px;">
            <div class="ad-ext-card" style="padding:0;">
              <div style="padding:12px 14px 8px;">
                <div class="ad-ext-section-title" style="margin:0;">Top 10 Legs</div>
              </div>
              <table class="ad-ext-table ad-ext-table--fixed ad-ext-table--top10">
                <colgroup>
                  <col style="width:54px;">
                  <col>
                  <col style="width:78px;">
                  <col style="width:92px;">
                  <col style="width:110px;">
                  <col style="width:132px;">
                </colgroup>
                <thead>
                  <tr>
                    <th>#</th>
                    <th>Spieler</th>
                    <th class="ad-ext-table-value-right">Darts</th>
                    <th class="ad-ext-table-value-right">Ø AVG</th>
                    <th class="ad-ext-table-value-right">Datum</th>
                    <th></th>
                  </tr>
                </thead>
                <tbody id="ad-ext-x01-toplegs-body">
                  <tr><td colspan="6" style="opacity:.7; padding:10px 12px;">—</td></tr>
                </tbody>
              </table>
            </div>

            <div class="ad-ext-card" style="padding:0;">
              <div style="padding:12px 14px 8px;">
                <div class="ad-ext-section-title" style="margin:0;">Top 10 Checkout (Match)</div>
              </div>
              <table class="ad-ext-table ad-ext-table--fixed ad-ext-table--top10">
                <colgroup>
                  <col style="width:54px;">
                  <col>
                  <col style="width:90px;">
                  <col style="width:92px;">
                  <col style="width:110px;">
                  <col style="width:132px;">
                </colgroup>
                <thead>
                  <tr>
                    <th>#</th>
                    <th>Spieler</th>
                    <th class="ad-ext-table-value-right">Checkout</th>
                    <th class="ad-ext-table-value-right">Ø AVG</th>
                    <th class="ad-ext-table-value-right">Datum</th>
                    <th></th>
                  </tr>
                </thead>
                <tbody id="ad-ext-x01-topcheckout-body">
                  <tr><td colspan="6" style="opacity:.7; padding:10px 12px;">—</td></tr>
                </tbody>
              </table>
            </div>
          </div>

          <div class="ad-ext-card ad-ext-card-x01-avgtrend-full" style="margin-top:0; margin-bottom:12px;">
            <div class="ad-ext-chart-title">AVG Verlauf (Legs)</div>
            <canvas id="ad-ext-x01-chart-avgtrend" class="ad-ext-chart-canvas" width="1200" height="320"></canvas>
            <div class="ad-ext-legend ad-ext-legend--center" id="ad-ext-x01-legend-avgtrend"></div>
          </div>
        </div>

          <div id="ad-ext-x01-panel-hof" style="display:none;">
            <div class="ad-ext-card">
              <div style="opacity:.7; padding:10px 12px;">—</div>
            </div>
          </div>

          </div>


        <div id="ad-ext-view-time" style="display:none;">
          <div class="ad-ext-section-title">Zeit Tracker</div>

          <div class="ad-ext-filters">
            <div class="ad-ext-filter">
              <div class="ad-ext-filter-label">Modus</div>
              <select id="ad-ext-time-mode" class="ad-ext-select">
                                <option value="ALL" selected>Alles</option>

              </select>
            </div>

            <div class="ad-ext-filter">
              <div class="ad-ext-filter-label">Zeitraum</div>
              <select id="ad-ext-time-range" class="ad-ext-select">
                <option value="THIS_WEEK">Diese Woche</option>
                <option value="LAST_WEEK">Letzte Woche</option>
                <option value="W4">Letzte 4 Wochen</option>
                <option value="W8">Letzte 8 Wochen</option>
                <option value="W12" selected>Letzte 12 Wochen</option>
                <option value="W24">Letzte 24 Wochen</option>
                <option value="Y1">Letztes Jahr</option>
                <option value="ALL">Gesamt</option>
              </select>
            </div>
</div>

          <div class="ad-ext-kpi-grid">
            <div class="ad-ext-kpi-tile">
              <div class="ad-ext-kpi-title">Diese Woche</div>
              <div id="ad-ext-time-kpi-thisweek" class="ad-ext-kpi-value">–</div>
              <div id="ad-ext-time-kpi-thisweek-sub" class="ad-ext-kpi-sub">–</div>
</div>

            <div class="ad-ext-kpi-tile">
              <div class="ad-ext-kpi-title">Im Zeitraum</div>
              <div id="ad-ext-time-kpi-range" class="ad-ext-kpi-value">–</div>
              <div id="ad-ext-time-kpi-range-sub" class="ad-ext-kpi-sub">–</div>
            </div>

            <div class="ad-ext-kpi-tile">
              <div class="ad-ext-kpi-title">Ø pro Woche</div>
              <div id="ad-ext-time-kpi-avg" class="ad-ext-kpi-value">–</div>
              <div id="ad-ext-time-kpi-avg-sub" class="ad-ext-kpi-sub">–</div>
            </div>

            <div class="ad-ext-kpi-tile">
              <div class="ad-ext-kpi-title">Beste Woche</div>
              <div id="ad-ext-time-kpi-best" class="ad-ext-kpi-value">–</div>
              <div id="ad-ext-time-kpi-best-sub" class="ad-ext-kpi-sub">–</div>
            </div>
          </div>

          <div class="ad-ext-grid-2">
            <div class="ad-ext-card">
              <div class="ad-ext-card-title">Wochenverlauf</div>
              <canvas id="ad-ext-time-chart" class="ad-ext-chart-canvas" width="1200" height="280"></canvas>
              <div class="ad-ext-legend">
                <div class="ad-ext-legend-item"><span class="ad-ext-dot" style="background:rgba(200,140,255,0.85);"></span><span>ATC</span></div>
                <div class="ad-ext-legend-item"><span class="ad-ext-dot" style="background:rgba(255,200,0,0.85);"></span><span>CountUp</span></div>
                <div class="ad-ext-legend-item"><span class="ad-ext-dot" style="background:rgba(255,90,90,0.85);"></span><span>Cricket</span></div>
                <div class="ad-ext-legend-item"><span class="ad-ext-dot" style="background:rgba(255,140,0,0.85);"></span><span>Random Checkout</span></div>
                <div class="ad-ext-legend-item"><span class="ad-ext-dot" style="background:rgba(0,150,255,0.85);"></span><span>Segment Training</span></div>
                <div class="ad-ext-legend-item"><span class="ad-ext-dot" style="background:rgba(0,200,160,0.85);"></span><span>X01 vs Bot</span></div>
</div>
            </div>

            <div class="ad-ext-card">
              <div class="ad-ext-card-title">Anteile im Zeitraum</div>
              <svg id="ad-ext-time-donut" class="ad-ext-chart-svg" width="520" height="280" viewBox="0 0 520 280" role="img" aria-label="Anteile im Zeitraum"></svg>
              <div id="ad-ext-time-share" class="ad-ext-legend" style="margin-top:8px;"><div class="ad-ext-muted">–</div></div>
            </div>
          </div>

          <div class="ad-ext-section-title">Wochenübersicht</div>
          <div class="ad-ext-card" style="padding:0;">
            <div class="ad-ext-table-scroll">
              <table class="ad-ext-table ad-ext-table--compact">
                <thead>
                  <tr>
                    <th style="width: 70px;">KW</th>
                    <th style="width: 200px;">Zeitraum</th>
                    <th style="width: 120px;" data-tt-col="TOTAL">Gesamt</th>
                    <th style="width: 120px;" data-tt-col="ATC">ATC</th>
                    <th style="width: 120px;" data-tt-col="COUNTUP">CountUp</th>
                    <th style="width: 120px;" data-tt-col="CRICKET">Cricket</th>
                    <th style="width: 160px;" data-tt-col="RANDOM_CHECKOUT">Random Checkout</th>
                    <th style="width: 120px;" data-tt-col="SEGMENT_TRAINING">Segment</th>
                    <th style="width: 120px;" data-tt-col="X01_BOT">X01 vs Bot</th>
                    <th style="width: 90px;">Sessions</th>
                  </tr>
                </thead>
                <tbody id="ad-ext-time-week-body">
                  <tr><td colspan="10" class="ad-ext-muted">–</td></tr>
                </tbody>
              </table>
            </div>
          </div>

        </div>

        <div id="ad-ext-view-training" style="display:none;">
          <div class="ad-train-head">
            <div class="ad-train-controls">
              

              <div id="ad-train-controls-row" class="ad-train-controls-row">
                <div class="ad-ext-segcontrol" id="ad-ext-train-view">
                  <button type="button" class="ad-ext-segbtn" data-view="DATA">Trainingsdaten</button>
                  <button type="button" class="ad-ext-segbtn" data-view="PLAN">Trainingsplan</button>
                                    <button type="button" class="ad-ext-segbtn" data-view="SEGFOCUS">Segment-Fokus</button>
                  <button type="button" class="ad-ext-segbtn" data-view="ATCFOCUS">ATC-Fokus</button>
            <button type="button" class="ad-ext-segbtn" data-view="CHROMO">Chrono-Tracker</button>
                </div>
              <div id="ad-train-week-host-top">
                <div class="ad-ext-plan-week" id="ad-ext-plan-week-wrap">
                                                <div class="ad-ext-plan-week-label" id="ad-ext-plan-week-label" style="display:none;">–</div>
                                                <select id="ad-ext-plan-week-select" class="ad-ext-select ad-ext-plan-week-select">
                                                  <option value="">—</option>
                                                </select>
                                                <div class="ad-ext-plan-week-sub" id="ad-ext-plan-week-sub" style="display:none;">—</div>
                                              </div>
              </div>

              </div>
            </div>
          </div>

          <div class="ad-train-layout" data-plan-open="0">
            <div class="ad-train-main">
<div class="ad-ext-ai-actions" id="ad-ext-ai-actions">
  <div class="ad-plan-menu ad-ai-menu" id="adAiMenu">
    <button id="adAiMenuBtn" class="ad-ext-btn ad-ext-btn--secondary ad-plan-menu-btn ad-ai-menu-btn" type="button" title="ChatGPT Analyse" aria-label="ChatGPT Analyse" aria-haspopup="menu" aria-expanded="false">
      <img class="ad-ai-menu-btn-icon" src="https://chatgpt.com/favicon.ico" alt="" referrerpolicy="no-referrer" onerror="this.style.display='none'; try{this.nextElementSibling.style.display='block'}catch{}" />
      <span class="ad-ai-menu-btn-fallback" aria-hidden="true" style="display:none;">GPT</span>
    </button>
    <div id="adAiMenuDropdown" class="ad-plan-menu-dropdown ad-ai-menu-dropdown" hidden>
      <div class="ad-ai-menu-title">ChatGPT Analyse</div>

      <div class="ad-ai-menu-field">
        <div class="ad-ai-menu-label">Zeitraum</div>
        <select id="ad-ext-ai-range" class="ad-ext-select ad-ai-menu-select">
          <option value="WEEK">Aktuelle KW (Filter)</option>
          <option value="W4">Letzte 4 Wochen</option>
          <option value="W8">Letzte 8 Wochen</option>
          <option value="W12">Letzte 12 Wochen</option>
          <option value="W16">Letzte 16 Wochen</option>
          <option value="CUSTOM">Benutzerdefiniert</option>
          <option value="ALL">Alles</option>
        </select>
        <div id="ad-ext-ai-range-custom" class="ad-ai-menu-custom" style="display:none;">
          <input id="ad-ext-ai-from" class="ad-ext-input" type="date" />
          <span class="ad-ext-muted">–</span>
          <input id="ad-ext-ai-to" class="ad-ext-input" type="date" />
        </div>
      </div>

      <div class="ad-ai-menu-field">
        <div class="ad-ai-menu-label">Prompt</div>
        <select id="ad-ext-ai-template" class="ad-ext-select ad-ai-menu-select">
          <option value="LONG">Lang</option>
          <option value="SHORT">Kurz</option>
        </select>
      </div>

      <button id="ad-ext-ai-copy" class="ad-ext-btn ad-ext-btn--primary" type="button" title="Kopiert eine Markdown-Analyse + Lite-JSON in die Zwischenablage">📋 Analyse kopieren</button>
      <button id="ad-ext-ai-open" class="ad-ext-btn ad-ext-btn--secondary" type="button" style="display:none;" title="Öffnet ChatGPT in einem neuen Tab">ChatGPT öffnen</button>
      <div id="ad-ext-ai-status" class="ad-ext-muted ad-ai-menu-status" style="display:none; margin-top:8px;">Kopiert ✅</div>
    </div>
  </div>
</div>

              <div class="ad-ext-kpi-grid ad-ext-kpi-grid--x01">
                <div class="ad-ext-kpi-tile">
                  <div class="ad-ext-kpi-title" title="Summe aller Trainingszeiten der Woche (inkl. Einheiten außerhalb des Plans bzw. außerhalb der geplanten Segment-Targets).">Trainingszeit (Gesamt)</div>
                  <div class="ad-ext-kpi-value" id="ad-ext-train-kpi-time">—</div>
                </div>
                <div class="ad-ext-kpi-tile">
                  <div class="ad-ext-kpi-title">Fortschritt</div>
                  <div class="ad-ext-kpi-value" id="ad-ext-train-kpi-progress">—</div>
                  <div class="ad-ext-progress">
                    <div class="ad-ext-progress-bar" id="ad-ext-train-kpi-progressbar" style="width:0%;"></div>
                  </div>
                </div>
                <div class="ad-ext-kpi-tile">
                  <div class="ad-ext-kpi-title">Planerfüllungsgrad</div>
                  <div class="ad-ext-kpi-value" id="adExtInsightsKpiPlanFulfill">—</div>
                  <div class="ad-ext-kpi-sub" id="adExtInsightsKpiPlanFulfillSub">—</div>
                </div>
                <div class="ad-ext-kpi-tile">
                  <div class="ad-ext-kpi-title">Ø Trainingsdauer / Woche</div>
                  <div class="ad-ext-kpi-value" id="adExtInsightsKpiAvgWeekDur">—</div>
                  <div class="ad-ext-kpi-sub" id="adExtInsightsKpiAvgWeekDurSub">—</div>
                </div>
                <div class="ad-ext-kpi-tile">
                  <div class="ad-ext-kpi-title">TRAININGSTAGE / WOCHE</div>
                  <div class="ad-ext-kpi-value" id="adExtInsightsKpiDaysPerWeek">—</div>
                  <div class="ad-ext-kpi-sub" id="adExtInsightsKpiDaysPerWeekSub">—</div>
                </div>
                <div class="ad-ext-kpi-tile">
                  <div class="ad-ext-kpi-title">TRAININGSMIX-INDEX</div>
                  <div class="ad-ext-kpi-value" id="adExtInsightsKpiTmi">—</div>
                  <div class="ad-ext-kpi-sub" id="adExtInsightsKpiTmiSub">—</div>
                </div>
              </div>

<div class="ad-ext-card" style="padding:0; margin-bottom:12px;">
                <div class="ad-ext-table-scroll">
                  <table class="ad-ext-table ad-ext-table--compact ad-ext-table--fixed">
                    <colgroup>
                      <col />
                      <col style="width: 160px;" />
                      <col style="width: 160px;" />
                      <col style="width: 160px;" />
                      <col style="width: 240px;" />
                    </colgroup>
                    <thead>
                      <tr>
                        <th>Aktivität</th>
                        <th class="ad-ext-table-num-right">Soll</th>
                        <th class="ad-ext-table-num-right">Ist</th>
                        <th class="ad-ext-table-num-right ad-ext-table-nowrap">Zeit</th>
                        <th>Fortschritt</th>
                      </tr>
                    </thead>
                    <tbody id="ad-ext-plan-main-body">
                      <tr><td colspan="5" class="ad-ext-muted">–</td></tr>
                    </tbody>
                  </table>
                </div>
              </div>

              <div class="ad-ext-train-charts" id="ad-ext-train-charts">
                <div class="ad-ext-card">
                  <div class="ad-ext-train-chart-title">Trainingsfortschritt</div>
                  <svg id="ad-ext-train-chart-sollist" class="ad-ext-chart-svg" viewBox="0 0 520 220" role="img" aria-label="Trainingsfortschritt"></svg>
                  <div id="ad-ext-train-legend-sollist" class="ad-ext-legend" style="margin-top:8px;"></div>
                </div>
                <div class="ad-ext-card">
                  <div class="ad-ext-train-chart-title">Trainingssortschritt</div>
                  <svg id="ad-ext-train-chart-placeholder" class="ad-ext-chart-svg ad-ext-train-chart--placeholder" viewBox="0 0 520 220" role="img" aria-label="Trainingssortschritt"></svg>
                  <div id="ad-ext-train-legend-soll" class="ad-ext-legend" style="margin-top:8px;"></div>
                </div>
              </div>


            </div>

            <div class="ad-train-insights" id="adTrainInsights">
                            <div class="ad-ext-grid-2 ad-ext-train-insights-analysis">
                <div class="ad-ext-train-insights-leftcol">
                  <div class="ad-ext-card" style="padding:0;">
                                    <div style="padding:12px 14px 8px;">
                                      <div class="ad-ext-section-title" style="margin:0;">Schwache Doppel (Segment Training)</div>
                                    </div>
                                    <table class="ad-ext-table ad-ext-table--fixed">
                                      <colgroup>
                                        <col style="width:72px;">
                                        <col style="width:84px;">
                                        <col style="width:70px;">
                                        <col style="width:70px;">
                                        <col style="width:70px;">
                                      </colgroup>
                                      <thead>
                                        <tr>
                                          <th>Doppel</th>
                                          <th class="ad-ext-table-value-right">Sessions</th>
                                          <th class="ad-ext-table-value-right">Darts</th>
                                          <th class="ad-ext-table-value-right">Hits</th>
                                          <th class="ad-ext-table-value-right">Hit %</th>
                                        </tr>
                                      </thead>
                                      <tbody id="ad-ext-insights-weakdoubles-body">
                                        <tr><td colspan="5" style="opacity:.7; padding:10px 12px;">—</td></tr>
                                      </tbody>
                                    </table>
                                  </div>
                  <div class="ad-ext-card ad-ext-insights-left-fill" style="padding:0;">
                    <div style="padding:12px 14px 8px;">
                      <div class="ad-ext-section-title" style="margin:0;">Platzhalter</div>
                    </div>
                    <div style="padding:0 14px 14px; opacity:.75;">Platzhalter</div>
                  </div>
                </div>
                <div class="ad-ext-train-insights-miniCharts">
                  <div class="ad-ext-card" style="padding:0;">
                    <div style="padding:12px 14px 8px;">
                      <div class="ad-ext-section-title" style="margin:0;">Platzhalter 1</div>
                    </div>
                    <div style="padding:0 14px 14px;">
                      <canvas id="ad-ext-insights-mini-p2" class="ad-ext-mini-canvas" width="520" height="180"></canvas>
                    </div>
                  </div>
                  <div class="ad-ext-card" style="padding:0;">
                    <div style="padding:12px 14px 8px;">
                      <div class="ad-ext-section-title" style="margin:0;">Platzhalter 2</div>
                    </div>
                    <div style="padding:0 14px 14px;">
                      <canvas id="ad-ext-insights-mini-p3" class="ad-ext-mini-canvas" width="520" height="180"></canvas>
                    </div>
                  </div>
                </div>
              </div>

            </div>

            <div class="ad-train-segfokus" id="ad-ext-train-segfokus"></div>
          <div class="ad-train-atcfokus" id="ad-ext-train-atcfokus"></div>
          <div class="ad-train-chromo" id="ad-ext-train-chromo"></div>

            <aside class="ad-train-side" data-open="0">
              <div class="ad-train-side-head">
                <div>
                  <div class="ad-train-side-title">Trainingsplan</div>
</div>
                <div class="ad-train-side-head-actions">
                  <div class="ad-plan-menu" id="adPlanMenu">
                    <button id="adPlanMenuBtn" class="ad-ext-btn ad-ext-btn--secondary ad-plan-menu-btn" type="button" title="Plan-Aktionen" aria-label="Plan-Aktionen" aria-haspopup="menu" aria-expanded="false">≡</button>
                    <div id="adPlanMenuDropdown" class="ad-plan-menu-dropdown" hidden>
                      <button id="adPlanAddActivityBtn" class="ad-ext-btn ad-ext-btn--primary" type="button">+ Aktivität</button>
                  <button id="adPlanCopyPrevWeekBtn" class="ad-ext-btn ad-ext-btn--secondary" type="button">Vorwoche kopieren</button>
                  <button id="adPlanResetWeekBtn" class="ad-ext-btn ad-ext-btn--danger" type="button">Woche zurücksetzen</button>
                  <button id="adPlanSavePlanBtn" class="ad-ext-btn ad-ext-btn--secondary" type="button" title="Trainingsplan speichern (kommt im nächsten Schritt)">Plan speichern</button>
                  <button id="adPlanLoadPlanBtn" class="ad-ext-btn ad-ext-btn--secondary" type="button" title="Trainingsplan laden (kommt im nächsten Schritt)">Plan laden</button>
                    </div>
                  </div>
                </div>
              </div>

              <div class="ad-train-side-body">
                <div class="ad-plan-summary" id="adPlanSummary" hidden>
                  <div class="ad-plan-summary-item"><span>Gesamt Soll</span><strong id="adPlanSumTarget">0 LEGS</strong></div>
                </div>



                <div class="ad-plan-table" id="adPlanTable">
                  <!-- rows injected by renderPlanTable() -->
                </div>
<div class="ad-plan-status" id="adPlanStatus">Bereit. (UI)</div>

                <div class="ad-plan-actions" id="adPlanActions" hidden>
                  <div class="ad-plan-actions-left" id="adPlanActionsStatus">Bereit.</div>
                  <div class="ad-plan-actions-right">
                    <button id="adPlanSave" class="ad-ext-btn ad-ext-btn--primary" type="button">Speichern</button>
                    <button id="adPlanCancel" class="ad-ext-btn ad-ext-btn--secondary" type="button">Abbrechen</button>
                    <button id="adPlanReset" class="ad-ext-btn ad-ext-btn--danger" type="button">Zurücksetzen</button>
                  </div>
                </div>

              </div>
            </aside>
          </div>
        </div>

<div id="ad-ext-view-masterhof" style="display:none;">
  <div class="ad-ext-section-title">Gesamt Hall Of Fame</div>
  <div class="ad-ext-section-desc" id="ad-ext-masterhof-desc"></div>

  <div class="ad-ext-filters">
    <div class="ad-ext-filter-block">
      <div class="ad-ext-filter-label">Spieler auswählen</div>

      <div class="ad-ext-filter-row">
        <div class="ad-ext-filter-name">Ich</div>
        <div class="ad-ext-select-wrap">
          <select id="ad-ext-master-filter-player" class="ad-ext-select">
            <option value="AUTO">Auto</option>
          </select>
        </div>
      </div>

      <div class="ad-ext-filter-row">
        <div class="ad-ext-filter-name">Bots</div>
        <div class="ad-ext-filter-switch" title="Bot-Spieler heißen immer „BOT LEVEL …“. Wenn aus, werden Matches mit Bots komplett ignoriert.">
          <span class="ad-ext-filter-switch-text">mitrechnen</span>
          <span id="ad-ext-master-bots-switch-label" class="ad-ext-switch-label" aria-hidden="true">Aus</span>
          <button id="ad-ext-master-include-bots" type="button" class="ad-ext-switch" role="switch" aria-checked="false" title="Bots mitrechnen ein/aus">
            <span class="ad-ext-switch-track"><span class="ad-ext-switch-thumb"></span></span>
          </button>
        </div>
      </div>
    </div>
  </div>

  <div id="ad-ext-master-panel-hof">
    <div class="ad-ext-card">
      <div style="opacity:.7; padding:10px 12px;">—</div>
    </div>
  </div>
</div>

<!-- Trainingsplan Drawer (Step 1) -->
<div id="adPlanDrawerOverlay" class="ad-plan-drawer-overlay" hidden></div>
<aside id="adPlanDrawer" class="ad-plan-drawer" data-open="0" aria-hidden="true">
  <div class="ad-plan-drawer-head">
    <div>
      <div class="ad-plan-drawer-title">Aktivität hinzufügen</div>
      <div class="ad-plan-drawer-sub">Vorlagen auswählen</div>
    </div>
    <button id="adPlanDrawerClose" type="button" class="ad-plan-drawer-close" title="Schließen" aria-label="Schließen">✕</button>
  </div>
  <div class="ad-plan-drawer-body">
    <input id="adPlanDrawerSearch" class="ad-plan-drawer-search" type="text" placeholder="Suchen…" />
    <div id="adPlanDrawerList" class="ad-plan-drawer-list"></div>
  </div>
</aside>

</div> <!-- /#ad-ext-dashboard-wrap -->

<div id="ad-ext-settings-page" class="ad-ext-settings-page" hidden>
  <div class="ad-ext-settings-head">
    <div class="ad-ext-settings-title">Einstellungen</div>
    <button id="ad-ext-settings-close" type="button" class="ad-ext-icon-btn ad-ext-settings-close" title="Schließen" aria-label="Einstellungen schließen">
      <span class="ad-ext-icon">✕</span>
    </button>
  </div>

  <div class="ad-ext-settings-grid">
    <!-- Kachel 1: Importer -->
    <section class="ad-ext-card ad-ext-card--importer">
      <header class="ad-ext-card-head">
        <div class="ad-ext-card-title">Importer-Konsole</div>
      </header>
      <div class="ad-ext-card-body">
        <div id="ad-ext-settings-slot-importer"></div>
      </div>
    </section>

    <!-- Kachel 2: Bulk (UI Placeholder) -->
    <section class="ad-ext-card ad-ext-card--bulk">
      <header class="ad-ext-card-head">
        <div class="ad-ext-card-title">Bulk Import</div>
      </header>
      <div class="ad-ext-card-body">
        <div id="ad-ext-settings-slot-bulk">
          <div class="ad-ext-bulk-placeholder">
            <div class="ad-ext-bulk-placeholder-title">Bulk Import</div>
            <div class="ad-ext-bulk-placeholder-text">
              (UI kommt als nächstes) – hier erscheint später die Bulk Import Konsole.
            </div>
            <div class="ad-ext-bulk-placeholder-actions">
              <button type="button" class="ad-ext-btn" disabled>History-Liste öffnen</button>
              <button type="button" class="ad-ext-btn" disabled>Collect IDs</button>
              <button type="button" class="ad-ext-btn" disabled>Start Import</button>
              <button type="button" class="ad-ext-btn" disabled>Stop</button>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Kachel 3: Viewer -->
    <section class="ad-ext-card ad-ext-card--viewer">
      <header class="ad-ext-card-head">
        <div class="ad-ext-card-title">Viewer</div>
      </header>
      <div class="ad-ext-card-body">
        <div id="ad-ext-settings-slot-viewer">
          <div class="ad-ext-viewmode">
            <div class="ad-ext-viewmode-label">Ansicht</div>
            <div class="ad-ext-seg" role="group" aria-label="Ansicht wählen">
              <button type="button" class="ad-ext-seg-btn is-active" data-ad-ext-viewmode="auto">Auto</button>
              <button type="button" class="ad-ext-seg-btn" data-ad-ext-viewmode="portrait">Hochformat</button>
              <button type="button" class="ad-ext-seg-btn" data-ad-ext-viewmode="landscape">Querformat</button>
            </div>
            <div class="ad-ext-viewmode-hint" id="ad-ext-viewmode-hint">
              Steuert das Dashboard-Layout (Auto/Hochformat/Querformat).
            </div>
          </div>
        </div>
      </div>
    </section>

<!-- Kachel 4: Einstellungen -->
<section class="ad-ext-card ad-ext-card--config">
  <header class="ad-ext-card-head">
    <div class="ad-ext-card-title">Modus-Einstellungen</div>
    <button id="adExtCfgReset" class="ad-ext-btn ad-ext-btn--danger" type="button">Auf Standard zurücksetzen</button>
  </header>
  <div class="ad-ext-card-body">
    <div id="adExtCfgStatus" class="ad-ext-cfg-status">Bereit.</div>

    <div class="ad-ext-cfg-section">
      <div class="ad-ext-cfg-section-head">
        <div class="ad-ext-cfg-section-title">X01 Filter</div>
      </div>
      <div class="ad-ext-cfg-section-body">

      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">Min. Matches (X01)</div>
          <div class="ad-ext-cfg-help">Blendet Spieler mit weniger Matches aus.</div>
        </div>
        <input class="ad-ext-cfg-input" type="number" id="cfg_MIN_MATCHES_X01" min="1" max="200" step="1"/>
      </div>

      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">Min. Legs gesamt (X01)</div>
          <div class="ad-ext-cfg-help">Mind. gespielte Legs insgesamt (Einzel-Legs ausblenden).</div>
        </div>
        <input class="ad-ext-cfg-input" type="number" id="cfg_MIN_TOTAL_LEGS_X01" min="1" max="500" step="1"/>
      </div>

      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">Min. Legs pro Spieler-Filter</div>
          <div class="ad-ext-cfg-help">Filtert Spieler mit sehr wenigen Legs (z.B. „Ich“-Details).</div>
        </div>
        <input class="ad-ext-cfg-input" type="number" id="cfg_MIN_LEGS_PLAYED_PLAYER_FILTER" min="0" max="500" step="1"/>
      </div>
      </div>
    </div>

    <div class="ad-ext-cfg-section">
      <div class="ad-ext-cfg-section-head">
        <div class="ad-ext-cfg-section-title">Hall of Fame</div>
      </div>
      <div class="ad-ext-cfg-section-body">

      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">Min. Gegner-Matches (Master HoF)</div>
          <div class="ad-ext-cfg-help">Wie viele Matches ein Gegner min. haben muss, um berücksichtigt zu werden.</div>
        </div>
        <input class="ad-ext-cfg-input" type="number" id="cfg_MASTER_HOF_MIN_OPPONENT_MATCHES" min="0" max="200" step="1"/>
      </div>
      </div>
    </div>

    <div class="ad-ext-cfg-section">
      <div class="ad-ext-cfg-section-head">
        <div class="ad-ext-cfg-section-title">Trends</div>
      </div>
      <div class="ad-ext-cfg-section-body">

      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">Max. Spieler im Trend</div>
          <div class="ad-ext-cfg-help">Begrenzt die Anzahl Spieler im Durchschnitts-Trend.</div>
        </div>
        <input class="ad-ext-cfg-input" type="number" id="cfg_AVG_TREND_MAX_PLAYERS" min="1" max="20" step="1"/>
      </div>

      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">Max. Legs im Trend</div>
          <div class="ad-ext-cfg-help">Begrenzt die Datenmenge (Performance/Lesbarkeit).</div>
        </div>
        <input class="ad-ext-cfg-input" type="number" id="cfg_AVG_TREND_MAX_LEGS" min="10" max="300" step="1"/>
      </div>

      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">High-Out Mindestwert</div>
          <div class="ad-ext-cfg-help">High-Outs ab diesem Score werden gelistet.</div>
        </div>
        <input class="ad-ext-cfg-input" type="number" id="cfg_HIGH_OUT_MIN" min="1" max="170" step="1"/>
      </div>
      </div>
    </div>

    <div class="ad-ext-cfg-section">
      <div class="ad-ext-cfg-section-head">
        <div class="ad-ext-cfg-section-title">Zeit-Tracker</div>
      </div>
      <div class="ad-ext-cfg-section-body">

      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">Wochenziel (Std.)</div>
          <div class="ad-ext-cfg-help">Default-Wert für das Wochenziel im Zeit-Tracker.</div>
        </div>
        <input class="ad-ext-cfg-input" type="number" id="cfg_TIME_WEEKLY_GOAL_DEFAULT_HOURS" min="0" max="40" step="1"/>
      </div>

      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">Max. Wochen im Zeit-Trend</div>
          <div class="ad-ext-cfg-help">Wie viele Wochen im Zeit-Trend angezeigt werden.</div>
        </div>
        <input class="ad-ext-cfg-input" type="number" id="cfg_TIME_TREND_MAX_WEEKS" min="4" max="260" step="1"/>
      </div>
      </div>
    </div>


    <div class="ad-ext-cfg-section">
      <div class="ad-ext-cfg-section-head">
        <div class="ad-ext-cfg-section-title">Training</div>
      </div>
      <div class="ad-ext-cfg-section-body">

      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">Default LEGS (ATC)</div>
          <div class="ad-ext-cfg-help">Standard-Sollwert beim Hinzufügen einer Aktivität im Trainingsplan.</div>
        </div>
        <input class="ad-ext-cfg-input" type="number" id="cfg_TRAIN_DEF_LEGS_ATC" min="1" max="999" step="1"/>
      </div>

      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">Default LEGS (Countup)</div>
          <div class="ad-ext-cfg-help">Standard-Sollwert beim Hinzufügen einer Aktivität im Trainingsplan.</div>
        </div>
        <input class="ad-ext-cfg-input" type="number" id="cfg_TRAIN_DEF_LEGS_COUNTUP" min="1" max="999" step="1"/>
      </div>

      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">Default LEGS (Cricket)</div>
          <div class="ad-ext-cfg-help">Standard-Sollwert beim Hinzufügen einer Aktivität im Trainingsplan.</div>
        </div>
        <input class="ad-ext-cfg-input" type="number" id="cfg_TRAIN_DEF_LEGS_CRICKET" min="1" max="999" step="1"/>
      </div>

      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">Default LEGS (Random Checkout)</div>
          <div class="ad-ext-cfg-help">Standard-Sollwert beim Hinzufügen einer Aktivität im Trainingsplan.</div>
        </div>
        <input class="ad-ext-cfg-input" type="number" id="cfg_TRAIN_DEF_LEGS_RANDOM_CHECKOUT" min="1" max="999" step="1"/>
      </div>

      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">Default LEGS (Segment Training)</div>
          <div class="ad-ext-cfg-help">Standard-Sollwert beim Hinzufügen einer Aktivität im Trainingsplan.</div>
        </div>
        <input class="ad-ext-cfg-input" type="number" id="cfg_TRAIN_DEF_LEGS_SEGMENT_TRAINING" min="1" max="999" step="1"/>
      </div>

      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">Default LEGS (X01 vs Bot)</div>
          <div class="ad-ext-cfg-help">Standard-Sollwert beim Hinzufügen einer Aktivität im Trainingsplan.</div>
        </div>
        <input class="ad-ext-cfg-input" type="number" id="cfg_TRAIN_DEF_LEGS_X01_BOT" min="1" max="999" step="1"/>
      </div>

      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">Default LEGS (X01 vs Human)</div>
          <div class="ad-ext-cfg-help">Standard-Sollwert beim Hinzufügen einer Aktivität im Trainingsplan.</div>
        </div>
        <input class="ad-ext-cfg-input" type="number" id="cfg_TRAIN_DEF_LEGS_X01_HUMAN" min="1" max="999" step="1"/>
      </div>


      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">Wochenfilter Vergangenheit (Training)</div>
          <div class="ad-ext-cfg-help">Wie viele Wochen der Trainings-Wochenfilter in die Vergangenheit anzeigen soll.</div>
        </div>
        <input type="number" class="ad-ext-cfg-input" id="cfg_TRAIN_WEEK_LOOKBACK_WEEKS_DEFAULT" min="0" max="260" step="1"/>
      </div>

      <div class="ad-ext-cfg-row">
        <div class="ad-ext-cfg-row-left">
          <div class="ad-ext-cfg-label">Wochenfilter Zukunft (Training)</div>
          <div class="ad-ext-cfg-help">Wie viele Wochen der Trainings-Wochenfilter in die Zukunft anzeigen soll.</div>
        </div>
        <input type="number" class="ad-ext-cfg-input" id="cfg_TRAIN_WEEK_LOOKAHEAD_WEEKS_DEFAULT" min="0" max="260" step="1"/>
      </div>

      </div>
    </div>

  </div>
</section>

  </div>
</div>

        <div class="ad-ext-version">ThunderB’s Match Insights for Autodarts (v${SCRIPT_VERSION})</div>
      </div>
    `;
    }

    // =========================
    // Charts (Canvas)
    // =========================
    const PALETTE = [
        "#7dd3fc", "#a7f3d0", "#fca5a5", "#c4b5fd", "#fde68a",
        "#f9a8d4", "#86efac", "#93c5fd", "#fdba74", "#67e8f9",
        "#fda4af", "#bef264",
    ];

    function clearCanvas(ctx, w, h) { ctx.clearRect(0, 0, w, h); }

    function drawEmpty(canvas, text) {
        const ctx = canvas.getContext("2d");
        clearCanvas(ctx, canvas.width, canvas.height);
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = "#ffffff";
        ctx.font = "800 14px system-ui, -apple-system, Segoe UI, Roboto";
        ctx.fillText(text || "Keine Daten", 16, 30);
    }

    function drawAtcWeeklyTrend(canvas, weeksAsc, thisWeekKey) {
        if (!canvas) return;
        const ctx = canvas.getContext("2d");
        if (!ctx) return;

        const weeks = Array.isArray(weeksAsc) ? weeksAsc : [];
        const maxShow = 16; // 12–16 Wochen (wir nehmen 16 als Obergrenze)
        const slice = weeks.slice(Math.max(0, weeks.length - maxShow));

        const labels = [];
        const vals = [];
        const hasVals = [];
        for (const w of slice) {
            const wk = String(w?.weekKey || "");
            if (!wk) continue;

            let v = NaN;
            let has = false;
            try {
                const agg = aggregateTrainingActualsForWeek(wk);
                const rec = agg?.byActivity?.get ? agg.byActivity.get("ATC") : null;
                const darts = Number(rec?.darts ?? 0) || 0;
                const hits = Number(rec?.hits ?? 0) || 0;
                v = (darts > 0) ? Number(((hits / darts) * 100).toFixed(1)) : NaN;
                v = Number.isFinite(v) ? Math.max(0, Math.min(100, v)) : NaN;
                has = (darts > 0);
            } catch {}

            vals.push(v);
            hasVals.push(!!has);

            const kw = (w && w.kw != null) ? String(w.kw).padStart(2, "0") : "";
            labels.push(kw ? `KW ${kw}` : wk);
        }

        const hasData = vals.some((x) => Number.isFinite(x));
        if (!vals.length || !hasData) {
            try { canvas.__adExtAtcPoints = []; } catch {}
            drawEmpty(canvas, "Keine Daten");
            return;
        }

        clearCanvas(ctx, canvas.width, canvas.height);

        const W = canvas.width, H = canvas.height;
        const padL = 44, padR = 10, padT = 14, padB = 28;
        const plotW = W - padL - padR;
        const plotH = H - padT - padB;

        const step = 20;


        const yMax = 100;

        // Grid (Y)
        ctx.save();
        ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto";
        ctx.fillStyle = "rgba(255,255,255,0.65)";
        ctx.strokeStyle = "rgba(255,255,255,0.10)";
        ctx.lineWidth = 1;
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";

        for (let yVal = 0; yVal <= yMax + 0.0001; yVal += step) {
            const y = padT + plotH - (yVal / yMax) * plotH;
            ctx.beginPath();
            ctx.moveTo(padL, y);
            ctx.lineTo(padL + plotW, y);
            ctx.stroke();
            ctx.fillText(String(Math.round(yVal)) + "%", 8, y);
        }

        // X axis
        ctx.strokeStyle = "rgba(255,255,255,0.22)";
        ctx.beginPath();
        ctx.moveTo(padL, padT + plotH);
        ctx.lineTo(padL + plotW, padT + plotH);
        ctx.stroke();

        const n = vals.length;
        const xStep = (n <= 1) ? 0 : (plotW / (n - 1));
        const xPos = (i) => padL + i * xStep;
        const yPos = (v) => padT + plotH - (v / yMax) * plotH;

        // X labels
        ctx.fillStyle = "rgba(255,255,255,0.55)";
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        const showEvery = (n > 12) ? 2 : 1;
        for (let i = 0; i < n; i += showEvery) {
            const lab = labels[i] || "";
            ctx.fillText(lab, xPos(i), padT + plotH + 8);
        }

        // Line
        const col = PALETTE[0] || "#7dd3fc";
        ctx.strokeStyle = col;
        ctx.lineWidth = 2;

        ctx.beginPath();
        let started = false;
        for (let i = 0; i < n; i++) {
            const vv = vals[i];
            if (!Number.isFinite(vv)) { continue; }
            const x = xPos(i);
            const y = yPos(vv);
            if (!started) { ctx.moveTo(x, y); started = true; }
            else ctx.lineTo(x, y);
        }
        ctx.stroke();

        const points = [];
        // Points
        ctx.fillStyle = col;
        for (let i = 0; i < n; i++) {
            const vv = vals[i];
            if (!Number.isFinite(vv)) continue;
            const x = xPos(i);
            const y = yPos(vv);
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
            try { points.push({ i, x, y, label: labels[i], value: (Number.isFinite(vv) ? (Number(vv).toFixed(1) + "%") : "—"), raw: vv }); } catch {}
        }


        try { canvas.__adExtAtcPoints = points; } catch {}

        // Tooltip: show KW + Hit% when hovering a point (canvas)
        try {
            if (!canvas.dataset.adExtAtcTipWired) {
                canvas.dataset.adExtAtcTipWired = "1";
                const parent = canvas.parentElement;
                if (parent) {
                    try {
                        const cs = window.getComputedStyle(parent);
                        if (cs && cs.position === "static") parent.style.position = "relative";
                    } catch {}
                    const tip = document.createElement("div");
                    tip.className = "ad-ext-canvas-tooltip";
                    tip.style.display = "none";
                    parent.appendChild(tip);
                    try { canvas.__adExtAtcTipEl = tip; } catch {}

                    const hide = () => { try { tip.style.display = "none"; } catch {} };
                    canvas.addEventListener("mouseleave", hide);
                    canvas.addEventListener("mousemove", (ev) => {
                        try {
                            const pts = canvas.__adExtAtcPoints || [];
                            if (!pts || !pts.length) { hide(); return; }

                            const rect = canvas.getBoundingClientRect();
                            if (!rect || !rect.width || !rect.height) { hide(); return; }

                            const mx = (ev.clientX - rect.left) * (canvas.width / rect.width);
                            const my = (ev.clientY - rect.top) * (canvas.height / rect.height);

                            let best = null;
                            let bestD2 = 1e18;
                            for (const p of pts) {
                                const dx = mx - p.x;
                                const dy = my - p.y;
                                const d2 = dx * dx + dy * dy;
                                if (d2 < bestD2) { bestD2 = d2; best = p; }
                            }
                            const r = 8;
                            if (!best || bestD2 > r * r) { hide(); return; }

                            const sx = rect.width / canvas.width;
                            const sy = rect.height / canvas.height;
                            const xCss = best.x * sx;
                            const yCss = best.y * sy;

                            let ox = 0, oy = 0;
                            try {
                                const pr = parent.getBoundingClientRect();
                                ox = rect.left - pr.left;
                                oy = rect.top - pr.top;
                            } catch {}

                            tip.textContent = `${best.label}: ${best.value}`;
                            tip.style.left = `${Math.round(ox + xCss)}px`;
                            tip.style.top = `${Math.round(oy + yCss)}px`;
                            tip.style.display = "block";
                        } catch { hide(); }
                    });
                }
            }
        } catch {}
        ctx.restore();
    }


    // =========================
    // SVG helpers (charts)
    // =========================
    const AD_SVG_NS = "http://www.w3.org/2000/svg";

    function svgEl(tag, attrs = {}, children = []) {
        const el = document.createElementNS(AD_SVG_NS, tag);
        for (const [k, v] of Object.entries(attrs || {})) {
            if (v === undefined || v === null) continue;
            el.setAttribute(k, String(v));
        }
        for (const ch of (children || [])) {
            if (!ch) continue;
            el.appendChild(ch);
        }
        return el;
    }

    function clearSvg(svg) {
        if (!svg) return;
        while (svg.firstChild) svg.removeChild(svg.firstChild);
    }

    function setupSvgSurface(svg, w, h) {
        if (!svg) return;
        svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
        svg.setAttribute("width", String(w));
        svg.setAttribute("height", String(h));
        svg.setAttribute("role", "application");
        // tabindex entfernt: verhindert weißen Fokus-Rahmen um SVG-Kacheln

        svg.setAttribute("preserveAspectRatio", "none");
    }

    function svgRectPath(x, y, w, h) {
        return `M ${x},${y} h ${w} v ${h} h -${w} Z`;
    }

    function drawEmptySvg(svg, text) {
        if (!svg) return;
        const w = Number(svg.getAttribute("width")) || 520;
        const h = Number(svg.getAttribute("height")) || 190;
        clearSvg(svg);
        setupSvgSurface(svg, w, h);
        svg.appendChild(svgEl("text", { "pointer-events": "none",
                                       x: 16,
                                       y: 30,
                                       fill: "#ffffff",
                                       "font-size": 14,
                                       "font-weight": 800,
                                       "font-family": "system-ui, -apple-system, Segoe UI, Roboto",
                                       "dominant-baseline": "hanging",
                                       opacity: 0.85
                                      }, [document.createTextNode(text || "Keine Daten")]));
    }



    function drawDonut(canvas, items, opts = {}) {
        const ctx = canvas.getContext("2d");
        const w = canvas.width, h = canvas.height;
        clearCanvas(ctx, w, h);

        const total = (items || []).reduce((a, x) => a + (Number(x?.value) || 0), 0);
        if (!total) {
            drawEmpty(canvas, "Keine Daten");
            return { type: "donut", slices: [], total: 0 };
        }

        const cx = Math.floor(w * (Number.isFinite(opts.cx) ? opts.cx : 0.50));
        const cy = Math.floor(h * (Number.isFinite(opts.cy) ? opts.cy : 0.52));

        const rOuter = Math.min(w, h) * (Number.isFinite(opts.rOuterFactor) ? opts.rOuterFactor : 0.38);
        const rInner = rOuter * (Number.isFinite(opts.rInnerFactor) ? opts.rInnerFactor : 0.62);

        const style = String(opts.style || "filled").toLowerCase(); // "filled" | "outline"
        const strokeWidth = Math.max(1, Number(opts.strokeWidth || 2));
        const alpha = Number.isFinite(opts.alpha) ? opts.alpha : 0.95;

        const outlineFillAlpha = Number.isFinite(opts.outlineFillAlpha) ? opts.outlineFillAlpha : 0;

        const gapDeg = Math.max(0, Number(opts.gapDeg || 0));
        const gapRad = (gapDeg * Math.PI) / 180;

        const centerLabel = String(opts.centerLabel || "Varianten");
        const centerSub = String(opts.centerSub || `${total} Sessions`);
        const showCenterText = opts.showCenterText !== false;
        const holeFill = opts.holeFill !== false; // default true for filled-style

        let a0 = -Math.PI / 2;
        const slices = [];

        for (let i = 0; i < (items || []).length; i++) {
            const it = items[i] || {};
            const v = Number(it.value) || 0;
            if (v <= 0) continue;

            const frac = v / total;
            const a1 = a0 + frac * Math.PI * 2;

            // apply gap
            const start = a0 + gapRad / 2;
            const end = a1 - gapRad / 2;
            if (end <= start) { a0 = a1; continue; }

            const color = String(it.color || PALETTE[i % PALETTE.length]);

            if (style === "outline") {
                // ring sector outline (stroke) + transparent fill (optional)
                ctx.beginPath();
                ctx.arc(cx, cy, rOuter, start, end, false);
                ctx.lineTo(cx + Math.cos(end) * rInner, cy + Math.sin(end) * rInner);
                ctx.arc(cx, cy, rInner, end, start, true);
                ctx.closePath();

                if (outlineFillAlpha > 0) {
                    ctx.globalAlpha = outlineFillAlpha;
                    ctx.fillStyle = color;
                    ctx.fill();
                }

                ctx.globalAlpha = alpha;
                ctx.strokeStyle = color;
                ctx.lineWidth = strokeWidth;
                ctx.stroke();
                ctx.globalAlpha = 1;
            } else {
                // filled donut
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.arc(cx, cy, rOuter, start, end);
                ctx.closePath();

                ctx.fillStyle = color;
                ctx.globalAlpha = 0.85;
                ctx.fill();

                // separator line
                ctx.globalAlpha = 0.40;
                ctx.strokeStyle = "rgba(10, 14, 30, 0.95)";
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            slices.push({
                index: i,
                label: String(it.label || ""),
                value: v,
                pct: frac,
                start,
                end,
                color,
                extra: it.extra || null,
            });

            a0 = a1;
        }

        // inner hole only for filled donut (optional)
        if (style !== "outline" && holeFill) {
            ctx.beginPath();
            ctx.arc(cx, cy, rInner, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(10, 14, 30, 0.85)";
            ctx.fill();
        }

        // center text
        if (showCenterText) {
            ctx.fillStyle = "rgba(255,255,255,0.92)";
            ctx.font = "900 18px system-ui, -apple-system, Segoe UI, Roboto";
            ctx.textAlign = "center";
            ctx.textBaseline = "alphabetic";
            ctx.fillText(centerLabel, cx, cy - 4);

            ctx.font = "800 12px system-ui, -apple-system, Segoe UI, Roboto";
            ctx.fillStyle = "rgba(255,255,255,0.75)";
            ctx.fillText(centerSub, cx, cy + 16);

            ctx.textAlign = "left";
            ctx.textBaseline = "alphabetic";
        }

        return { type: "donut", cx, cy, rOuter, rInner, total, slices };
    }


    // =========================
    // Donut (SVG) – für "Anteile im Zeitraum" (Time-Tab)
    // =========================
    function _adExtParseColorToRgba(color) {
        const s = String(color || "").trim();
        if (!s) return null;

        // rgba()/rgb()
        let m = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*([0-9.]+)\s*)?\)\s*$/i.exec(s);
        if (m) {
            const r = Math.max(0, Math.min(255, Number(m[1]) || 0));
            const g = Math.max(0, Math.min(255, Number(m[2]) || 0));
            const b = Math.max(0, Math.min(255, Number(m[3]) || 0));
            const a = (m[4] == null) ? 1 : Math.max(0, Math.min(1, Number(m[4]) || 0));
            return { r, g, b, a };
        }

        // #rgb / #rrggbb
        m = /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.exec(s);
        if (m) {
            const hex = m[1].toLowerCase();
            let r, g, b;
            if (hex.length === 3) {
                r = parseInt(hex[0] + hex[0], 16);
                g = parseInt(hex[1] + hex[1], 16);
                b = parseInt(hex[2] + hex[2], 16);
            } else {
                r = parseInt(hex.slice(0, 2), 16);
                g = parseInt(hex.slice(2, 4), 16);
                b = parseInt(hex.slice(4, 6), 16);
            }
            return { r, g, b, a: 1 };
        }

        return null;
    }

    function _adExtRgba(r, g, b, a = 1) {
        const aa = Math.max(0, Math.min(1, Number(a) || 0));
        return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${aa})`;
    }

    function _adExtColorWithAlpha(color, alphaMul = 1) {
        const c = _adExtParseColorToRgba(color);
        if (!c) return String(color || "");
        const a = Math.max(0, Math.min(1, (Number(c.a) || 1) * (Number(alphaMul) || 0)));
        return _adExtRgba(c.r, c.g, c.b, a);
    }

    function _adExtSvgEl(tag) {
        return document.createElementNS("http://www.w3.org/2000/svg", tag);
    }

    function _adExtSvgDonutSectorPath(cx, cy, rOuter, rInner, start, end) {
        // SVG arc flags
        const largeArc = (end - start) > Math.PI ? 1 : 0;

        const x0 = cx + Math.cos(start) * rOuter;
        const y0 = cy + Math.sin(start) * rOuter;

        const x1 = cx + Math.cos(end) * rOuter;
        const y1 = cy + Math.sin(end) * rOuter;

        const x2 = cx + Math.cos(end) * rInner;
        const y2 = cy + Math.sin(end) * rInner;

        const x3 = cx + Math.cos(start) * rInner;
        const y3 = cy + Math.sin(start) * rInner;

        const f = (n) => (Number.isFinite(n) ? Number(n).toFixed(3).replace(/\.0+$/, "").replace(/\.(\d*?)0+$/, ".$1").replace(/\.$/, "") : "0");

        // Outer arc: sweep=1 (clockwise). Inner arc: sweep=0 (counter-clockwise back).
        return [
            "M", f(x0), f(y0),
            "A", f(rOuter), f(rOuter), "0", String(largeArc), "1", f(x1), f(y1),
            "L", f(x2), f(y2),
            "A", f(rInner), f(rInner), "0", String(largeArc), "0", f(x3), f(y3),
            "Z",
        ].join(" ");
    }

    function drawDonutSvg(svg, items, opts = {}) {
        if (!svg) return { type: "donut", slices: [], total: 0 };

        const tag = String(svg.tagName || "").toLowerCase();
        // fallback (alte Version / falls doch Canvas)
        if (tag === "canvas") return drawDonut(svg, items, opts);
        if (tag !== "svg") return { type: "donut", slices: [], total: 0 };

        const wAttr = Number(svg.getAttribute("width") || 0);
        const hAttr = Number(svg.getAttribute("height") || 0);

        let w = wAttr, h = hAttr;

        const vb = (svg.viewBox && svg.viewBox.baseVal) ? svg.viewBox.baseVal : null;
        if (vb && Number.isFinite(vb.width) && Number.isFinite(vb.height) && vb.width > 0 && vb.height > 0) {
            w = vb.width;
            h = vb.height;
        } else if (w > 0 && h > 0) {
            svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
        } else {
            // last resort
            w = 520; h = 280;
            svg.setAttribute("width", String(w));
            svg.setAttribute("height", String(h));
            svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
        }

        // clear
        while (svg.firstChild) svg.removeChild(svg.firstChild);

        const total = (items || []).reduce((a, x) => a + (Number(x?.value) || 0), 0);
        if (!total) {
            const t = _adExtSvgEl("text");
            t.setAttribute("x", "16");
            t.setAttribute("y", "30");
            t.setAttribute("fill", "#ffffff");
            t.setAttribute("opacity", "0.85");
            t.setAttribute("style", "font: 800 14px system-ui, -apple-system, Segoe UI, Roboto;");
            t.textContent = "Keine Daten";
            svg.appendChild(t);
            return { type: "donut", slices: [], total: 0 };
        }

        const cx = (Number.isFinite(opts.cx) ? (w * opts.cx) : (w * 0.50));
        const cy = (Number.isFinite(opts.cy) ? (h * opts.cy) : (h * 0.52));

        const rOuter = Math.min(w, h) * (Number.isFinite(opts.rOuterFactor) ? opts.rOuterFactor : 0.38);
        const rInner = rOuter * (Number.isFinite(opts.rInnerFactor) ? opts.rInnerFactor : 0.62);

        const style = String(opts.style || "filled").toLowerCase(); // "filled" | "outline"
        const strokeWidth = Math.max(1, Number(opts.strokeWidth || 2));
        const alpha = Number.isFinite(opts.alpha) ? opts.alpha : 0.95;
        const outlineFillAlpha = Number.isFinite(opts.outlineFillAlpha) ? opts.outlineFillAlpha : 0;
        const gapDeg = Math.max(0, Number(opts.gapDeg || 0));
        const gapRad = (gapDeg * Math.PI) / 180;

        const centerLabel = String(opts.centerLabel || "Varianten");
        const centerSub = String(opts.centerSub || `${total} Sessions`);
        const showCenterText = opts.showCenterText !== false;
        const holeFill = opts.holeFill !== false; // default true for filled-style

        // root group with "recharts" classes (damit dein Template-Styling greift)
        svg.setAttribute("class", (svg.getAttribute("class") || "").includes("recharts-surface")
                         ? svg.getAttribute("class")
                         : (String(svg.getAttribute("class") || "") + " recharts-surface").trim());

        const gPie = _adExtSvgEl("g");
        gPie.setAttribute("class", "recharts-layer recharts-pie");
        svg.appendChild(gPie);

        const gWrap = _adExtSvgEl("g");
        gWrap.setAttribute("class", "recharts-layer");
        gPie.appendChild(gWrap);

        let a0 = -Math.PI / 2;
        const slices = [];

        for (let i = 0; i < (items || []).length; i++) {
            const it = items[i] || {};
            const v = Number(it.value) || 0;
            if (v <= 0) continue;

            const frac = v / total;
            const a1 = a0 + frac * Math.PI * 2;

            // apply gap
            const start = a0 + gapRad / 2;
            const end = a1 - gapRad / 2;
            if (end <= start) { a0 = a1; continue; }

            const color = String(it.color || PALETTE[i % PALETTE.length]);

            const d = _adExtSvgDonutSectorPath(cx, cy, rOuter, rInner, start, end);

            const gs = _adExtSvgEl("g");
            gs.setAttribute("class", "recharts-layer recharts-pie-sector");
            gWrap.appendChild(gs);

            const p = _adExtSvgEl("path");
            p.setAttribute("class", "recharts-sector");
            p.setAttribute("d", d);
            p.setAttribute("stroke-width", String(strokeWidth));
            p.setAttribute("data-ad-slice", String(i));
            p.setAttribute("data-recharts-item-index", String(i));
            p.setAttribute("data-recharts-item-data-key", "value");
            p.setAttribute("name", String(it.label || ""));
            p.setAttribute("color", String(color));
            p.style.cursor = "pointer";

            if (style === "outline") {
                p.setAttribute("fill", outlineFillAlpha > 0 ? _adExtColorWithAlpha(color, outlineFillAlpha) : "none");
                p.setAttribute("stroke", _adExtColorWithAlpha(color, alpha));
            } else {
                p.setAttribute("fill", _adExtColorWithAlpha(color, 0.85));
                p.setAttribute("stroke", "rgba(10, 14, 30, 0.55)");
                p.setAttribute("stroke-width", "2");
            }

            gs.appendChild(p);

            slices.push({
                index: i,
                label: String(it.label || ""),
                value: v,
                pct: frac,
                start,
                end,
                color,
                extra: it.extra || null,
            });

            a0 = a1;
        }

        // inner hole only for filled donut (optional)
        if (style !== "outline" && holeFill) {
            const c = _adExtSvgEl("circle");
            c.setAttribute("cx", String(cx));
            c.setAttribute("cy", String(cy));
            c.setAttribute("r", String(rInner));
            c.setAttribute("fill", "rgba(10, 14, 30, 0.85)");
            svg.appendChild(c);
        }

        // center text (optional)
        if (showCenterText) {
            const t1 = _adExtSvgEl("text");
            t1.setAttribute("x", String(cx));
            t1.setAttribute("y", String(cy - 4));
            t1.setAttribute("fill", "rgba(255,255,255,0.92)");
            t1.setAttribute("text-anchor", "middle");
            t1.setAttribute("style", "font: 900 18px system-ui, -apple-system, Segoe UI, Roboto;");
            t1.textContent = centerLabel;
            svg.appendChild(t1);

            const t2 = _adExtSvgEl("text");
            t2.setAttribute("x", String(cx));
            t2.setAttribute("y", String(cy + 16));
            t2.setAttribute("fill", "rgba(255,255,255,0.75)");
            t2.setAttribute("text-anchor", "middle");
            t2.setAttribute("style", "font: 800 12px system-ui, -apple-system, Segoe UI, Roboto;");
            t2.textContent = centerSub;
            svg.appendChild(t2);
        }

        return { type: "donut", cx, cy, rOuter, rInner, total, slices };
    }



    function drawRadar(canvas, labels, valuesPct0to100, opts = {}) {
        const ctx = canvas.getContext("2d");
        const w = canvas.width, h = canvas.height;
        clearCanvas(ctx, w, h);

        const n = (labels || []).length;
        if (!n) {
            drawEmpty(canvas, "Keine Daten");
            return { type: "radar", axes: [], labels: [], values: [], cx: 0, cy: 0, R: 0 };
        }

        const cx = Math.floor(w * 0.50);
        const cy = Math.floor(h * 0.50);
        const R = Math.min(w, h) * (Number.isFinite(Number(opts?.rFactor)) ? Number(opts.rFactor) : 0.45);
        const base = -Math.PI / 2;
        const labelOffset = (Number.isFinite(Number(opts?.labelOffset)) ? Number(opts.labelOffset) : 10);

        const values = (valuesPct0to100 || []).map((v) => {
            const x = Number(v);
            return Math.max(0, Math.min(100, Number.isFinite(x) ? x : 0));
        });

        const rawMax = values.reduce((m, v) => Math.max(m, v), 0);
        const autoScale = (opts?.autoScale === true) || (opts?.autoScale == null && rawMax > 0 && rawMax < 35);
        const optScaleMax = Number(opts?.scaleMax);
        const scaleMax = (Number.isFinite(optScaleMax) && optScaleMax > 0)
        ? optScaleMax
        : (autoScale ? Math.max(1, rawMax * 1.12) : 100);

        // Background grid rings
        ctx.strokeStyle = "rgba(255,255,255,0.12)";
        ctx.lineWidth = 1;
        for (let i = 1; i <= 4; i++) {
            const rr = (R * i) / 4;
            ctx.beginPath();
            ctx.arc(cx, cy, rr, 0, Math.PI * 2);
            ctx.stroke();
        }

        const axes = [];

        // Axes (Linien) + Positionsberechnung (Labels werden später über alles drüber gezeichnet)
        for (let i = 0; i < n; i++) {
            const ang = base + (i * 2 * Math.PI) / n;
            const ax = cx + Math.cos(ang) * R;
            const ay = cy + Math.sin(ang) * R;

            ctx.strokeStyle = "rgba(255,255,255,0.12)";
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(ax, ay);
            ctx.stroke();

            const lx = cx + Math.cos(ang) * (R + labelOffset);
            const ly = cy + Math.sin(ang) * (R + labelOffset);
            const align = (Math.cos(ang) > 0.2) ? "left" : (Math.cos(ang) < -0.2 ? "right" : "center");
            const baseline = (Math.sin(ang) > 0.2) ? "top" : (Math.sin(ang) < -0.2 ? "bottom" : "middle");

            const rrV = (values[i] / scaleMax) * R;
            const vx = cx + Math.cos(ang) * rrV;
            const vy = cy + Math.sin(ang) * rrV;

            axes.push({ index: i, ang, label: String(labels[i] ?? ""), value: values[i], ax, ay, lx, ly, align, baseline, vx, vy });
        }

        // Polygon
        ctx.beginPath();
        for (let i = 0; i < n; i++) {
            const a = axes[i];
            if (i === 0) ctx.moveTo(a.vx, a.vy);
            else ctx.lineTo(a.vx, a.vy);
        }
        ctx.closePath();
        ctx.fillStyle = "rgba(167, 243, 208, 0.16)";
        ctx.strokeStyle = "rgba(167, 243, 208, 0.82)";
        ctx.lineWidth = 2;
        ctx.fill();
        ctx.stroke();

        // Highlight line to currently selected axis (hover)
        const hiRaw = opts?.highlightIndex;
        const hi = (hiRaw === null || hiRaw === undefined)
        ? null
        : (Number.isFinite(Number(hiRaw)) ? Number(hiRaw) : null);
        if (hi !== null && hi >= 0 && hi < n) {
            const a = axes[hi];
            ctx.strokeStyle = "rgba(255,255,255,0.85)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(a.lx, a.ly);
            ctx.stroke();

            ctx.fillStyle = "rgba(255,255,255,0.92)";
            ctx.beginPath();
            ctx.arc(a.vx, a.vy, 3.6, 0, Math.PI * 2);
            ctx.fill();
        }

        // Labels zuletzt zeichnen, damit die Hover-Linie (bis zum Label) den Text nicht übermalt
        ctx.fillStyle = "rgba(255,255,255,0.82)";
        ctx.font = "800 11px system-ui, -apple-system, Segoe UI, Roboto";
        for (const a of axes) {
            ctx.textAlign = a.align;
            ctx.textBaseline = a.baseline;
            ctx.fillText(a.label, a.lx, a.ly);
        }

        // center dot
        ctx.beginPath();
        ctx.arc(cx, cy, 4, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(252, 165, 165, 0.9)";
        ctx.fill();

        return { type: "radar", cx, cy, R, scaleMax, labels: [...labels], values: [...values], axes };
    }

    function drawBarsVertical(canvas, labels, values, dataList, opts = {}) {
        const ctx = canvas.getContext("2d");
        const w = canvas.width, h = canvas.height;
        clearCanvas(ctx, w, h);

        const n = labels.length;
        if (!n) return drawEmpty(canvas, "Keine Daten");

        const showCategoryLabels = opts.showCategoryLabels !== false;
        const showValueLabels = opts.showValueLabels !== false;

        const padL = 36, padR = 14, padT = 14, padB = showCategoryLabels ? 42 : 18;
        const plotW = w - padL - padR;
        const plotH = h - padT - padB;

        const rawMaxV = Math.max(1, ...values.map((x) => Number(x || 0)));
        const headroom = Number(opts.headroom || 0);
        const maxV = Math.max(1, rawMaxV * (1 + (Number.isFinite(headroom) ? headroom : 0)));
        const barW = plotW / n;

        // optional persistent highlight (Index)
        const hiRaw = opts?.highlightIndex;
        const hi = (hiRaw === null || hiRaw === undefined)
        ? null
        : (Number.isFinite(Number(hiRaw)) ? Number(hiRaw) : null);

        ctx.strokeStyle = "rgba(255,255,255,0.14)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padL, padT);
        ctx.lineTo(padL, padT + plotH);
        ctx.lineTo(padL + plotW, padT + plotH);
        ctx.stroke();

        const strokeCol = "rgb(125, 211, 252)";
        const fillCol = _adExtColorWithAlpha(strokeCol, 0.16);
        const fillColHi = _adExtColorWithAlpha(strokeCol, 0.30);

        const bars = [];

        for (let i = 0; i < n; i++) {
            const v = Number(values[i] || 0);
            const hh = (v / maxV) * plotH;
            const x = padL + i * barW + barW * 0.16;
            const y = padT + plotH - hh;
            const bw = Math.max(2, barW * 0.68);
            const isHi = (hi !== null && hi === i);
            const useFill = isHi ? _adExtColorWithAlpha(strokeCol, 0.28) : fillCol;

            ctx.fillStyle = useFill;
            ctx.fillRect(x, y, bw, hh);

            ctx.strokeStyle = strokeCol;
            ctx.lineWidth = isHi ? 2 : 1;
            ctx.strokeRect(x + 0.5, y + 0.5, bw, hh);

            bars.push({
                x, y, w: bw, h: hh,
                data: (Array.isArray(dataList) && dataList[i]) ? dataList[i] : { label: labels[i], value: v },
                index: i,
            });

            if (showValueLabels) {
                ctx.fillStyle = "rgba(255,255,255,0.86)";
                ctx.font = "900 11px system-ui, -apple-system, Segoe UI, Roboto";
                ctx.textAlign = "center";
                ctx.textBaseline = "bottom";
                ctx.fillText(String(Math.round(v)), x + bw / 2, y - 3);
            }

            if (showCategoryLabels) {
                ctx.fillStyle = "rgba(255,255,255,0.80)";
                ctx.font = "900 11px system-ui, -apple-system, Segoe UI, Roboto";
                ctx.textAlign = "center";
                ctx.textBaseline = "top";
                ctx.fillText(labels[i], x + bw / 2, padT + plotH + 8);
            }
        }

        return {
            type: "bars",
            bars,
            total: Number(opts.total || 0),
            max: maxV,
        };
    }
    function drawBarsHorizontal(canvas, labels, values, dataList, opts = {}) {
        const ctx = canvas.getContext("2d");
        const w = canvas.width, h = canvas.height;
        clearCanvas(ctx, w, h);

        const n = labels.length;
        if (!n) return drawEmpty(canvas, "Keine Daten");

        const showCategoryLabels = opts.showCategoryLabels !== false; // Y-Achse (Targets)
        const showValueLabels = opts.showValueLabels === true; // optional: Wert am Bar-Ende

        // Linkes Padding dynamisch nach Label-Breite, damit nichts abgeschnitten wird
        let padL = 44;
        if (showCategoryLabels) {
            ctx.font = "900 11px system-ui, -apple-system, Segoe UI, Roboto";
            const maxLabelW = Math.max(...labels.map((l) => ctx.measureText(String(l || "")).width), 0);
            padL = Math.max(56, Math.min(160, Math.ceil(maxLabelW + 16)));
        }

        const padR = 14, padT = 14, padB = 32;
        const plotW = w - padL - padR;
        const plotH = h - padT - padB;

        const rawMaxV = Math.max(1, ...values.map((x) => Number(x || 0)));

        // Optional: etwas Luft rechts, damit der größte Balken nicht "am Ende klebt"
        const headroom = Number(opts.headroom || 0);
        const maxV = Math.max(1, rawMaxV * (1 + (Number.isFinite(headroom) ? headroom : 0)));

        // optional persistent highlight (Index)
        const hiRaw = opts?.highlightIndex;
        const hi = (hiRaw === null || hiRaw === undefined)
        ? null
        : (Number.isFinite(Number(hiRaw)) ? Number(hiRaw) : null);

        // Achsen
        ctx.strokeStyle = "rgba(255,255,255,0.14)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padL, padT);
        ctx.lineTo(padL, padT + plotH);
        ctx.lineTo(padL + plotW, padT + plotH);
        ctx.stroke();

        // X-Achse Ticks + Grid
        const tickCount = Math.max(2, Math.min(6, Number(opts.tickCount || 5)));
        ctx.font = "900 11px system-ui, -apple-system, Segoe UI, Roboto";
        ctx.textAlign = "center";
        ctx.textBaseline = "top";

        for (let t = 0; t < tickCount; t++) {
            const v = (maxV * t) / (tickCount - 1);
            const x = padL + (v / maxV) * plotW;

            // Gridline
            ctx.strokeStyle = "rgba(255,255,255,0.10)";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 0.5, padT);
            ctx.lineTo(x + 0.5, padT + plotH);
            ctx.stroke();

            // Tick
            ctx.strokeStyle = "rgba(255,255,255,0.80)";
            ctx.beginPath();
            ctx.moveTo(x + 0.5, padT + plotH);
            ctx.lineTo(x + 0.5, padT + plotH + 6);
            ctx.stroke();

            // Label
            ctx.fillStyle = "rgba(255,255,255,0.80)";
            ctx.fillText(fmtInt(v), x, padT + plotH + 8);
        }

        const strokeCol = String(opts.strokeCol || "rgb(125, 211, 252)");
        const fillCol = _adExtColorWithAlpha(strokeCol, 0.16);

        const bars = [];
        const rowH = plotH / n;
        const barH = Math.max(6, rowH * 0.62);

        for (let i = 0; i < n; i++) {
            const v = Number(values[i] || 0);
            const bw = (v / maxV) * plotW;

            const yMid = padT + i * rowH + rowH / 2;
            const y = yMid - barH / 2;
            const x = padL;

            const isHi = (hi !== null && i === hi);

            // Bar
            ctx.fillStyle = isHi ? _adExtColorWithAlpha(strokeCol, 0.28) : fillCol;
            ctx.fillRect(x, y, bw, barH);

            ctx.strokeStyle = isHi ? _adExtColorWithAlpha(strokeCol, 0.92) : strokeCol;
            ctx.lineWidth = isHi ? 2 : 1;
            ctx.strokeRect(x + 0.5, y + 0.5, bw, barH);



            // Hit-Test-Rect
            bars.push({
                x, y, w: bw, h: barH,
                data: (Array.isArray(dataList) && dataList[i]) ? dataList[i] : { label: labels[i], value: v },
                index: i,
            });

            // Y-Label
            if (showCategoryLabels) {
                ctx.fillStyle = isHi ? "rgba(255,255,255,0.92)" : "rgba(255,255,255,0.80)";
                ctx.font = "900 11px system-ui, -apple-system, Segoe UI, Roboto";
                ctx.textAlign = "end";
                ctx.textBaseline = "middle";
                ctx.fillText(String(labels[i] || ""), padL - 8, yMid);
            }

            // Optional: Wert am Ende
            if (showValueLabels) {
                ctx.fillStyle = "rgba(255,255,255,0.86)";
                ctx.font = "900 11px system-ui, -apple-system, Segoe UI, Roboto";
                ctx.textAlign = "start";
                ctx.textBaseline = "middle";
                const tx = Math.min(padL + plotW - 2, padL + bw + 6);
                ctx.fillText(fmtInt(v), tx, yMid);
            }
        }

        return {
            type: "bars",
            bars,
            total: Number(opts.total || 0),
            max: maxV,
        };
    }

    // =========================
    // X01 charts + hit-testing
    // =========================
    function canvasPoint(ev, canvas) {
        const rect = canvas.getBoundingClientRect();
        const sx = canvas.width / Math.max(1, rect.width);
        const sy = canvas.height / Math.max(1, rect.height);
        return { x: (ev.clientX - rect.left) * sx, y: (ev.clientY - rect.top) * sy };
    }
    function hitTestBars(layout, pt) {
        if (!layout?.bars?.length) return null;
        for (const b of layout.bars) {
            if (pt.x >= b.x && pt.x <= b.x + b.w && pt.y >= b.y && pt.y <= b.y + b.h) return b;
        }
        return null;
    }

    function hitTestTimeStackSegments(layout, pt) {
        if (!layout?.segments?.length) return null;
        // reverse = topmost segment first
        for (let i = layout.segments.length - 1; i >= 0; i--) {
            const s = layout.segments[i];
            if (pt.x >= s.x && pt.x <= s.x + s.w && pt.y >= s.y && pt.y <= s.y + s.h) return s;
        }
        return null;
    }

    function hitTestDonut(layout, pt) {
        if (!layout || layout.type !== "donut" || !layout.slices?.length) return null;

        const dx = pt.x - layout.cx;
        const dy = pt.y - layout.cy;
        const rr = Math.sqrt(dx * dx + dy * dy);

        if (rr < layout.rInner || rr > layout.rOuter) return null;

        const base = -Math.PI / 2;
        let a = Math.atan2(dy, dx); // [-pi, pi]
        while (a < base) a += Math.PI * 2;
        while (a >= base + Math.PI * 2) a -= Math.PI * 2;

        for (const s of layout.slices) {
            if (a >= s.start && a < s.end) return s;
        }


        return null;
    }

    function hitTestRadar(layout, pt) {
        if (!layout || layout.type !== "radar" || !layout.axes?.length) return null;

        let bestIdx = null;
        let bestDist = Infinity;

        const axes = layout.axes;
        for (let i = 0; i < axes.length; i++) {
            const a = axes[i];

            const dvx = pt.x - a.vx;
            const dvy = pt.y - a.vy;
            const dv = Math.sqrt(dvx * dvx + dvy * dvy);

            const dlx = pt.x - a.lx;
            const dly = pt.y - a.ly;
            const dl = Math.sqrt(dlx * dlx + dly * dly);

            const d = Math.min(dv, dl);
            if (d < bestDist) {
                bestDist = d;
                bestIdx = a.index;
            }
        }

        // Threshold in canvas units (tuned for 520x220 canvas)
        return bestDist <= 22 ? bestIdx : null;
    }

    function drawLegDiffTimeline(canvas, matches, playerKey) {
        const ctx = canvas.getContext("2d");
        const w = canvas.width, h = canvas.height;
        clearCanvas(ctx, w, h);

        if (!matches?.length || !playerKey) {
            drawEmpty(canvas, "Keine Daten");
            return { bars: [] };
        }

        const sorted = matches.slice().sort((a, b) => {
            const ta = new Date(a.finishedAt || a.createdAt || 0).getTime();
            const tb = new Date(b.finishedAt || b.createdAt || 0).getTime();
            return ta - tb;
        });

        const last = sorted.slice(Math.max(0, sorted.length - 30));

        const pts = [];
        for (const m of last) {
            const pl = m.players.find(p => p.key === playerKey);
            const idx = pl?.index;
            if (!Number.isFinite(Number(idx))) continue;

            const legsWon = Number(m.legsWon?.[Number(idx)] ?? 0) || 0;
            const total = Number(m.totalLegs) || 0;
            const legsLost = Math.max(0, total - legsWon);
            const diff = legsWon - legsLost;

            pts.push({
                match: m,
                diff,
                date: germanDateFromIso(m.finishedAt || m.createdAt),
                lineup: m.players.map(p => dispName(p.name)).join(", "),
                legsStr: m.players.map(p => String(Number(m.legsWon?.[Number(p.index)] ?? 0) || 0)).join("-"),
                playerName: dispName(pl?.name || "PLAYER"),
            });
        }

        if (!pts.length) {
            drawEmpty(canvas, "Keine Daten");
            return { bars: [] };
        }

        const padL = 34, padR = 12, padT = 16, padB = 42;
        const plotW = w - padL - padR;
        const plotH = h - padT - padB;
        const midY = padT + plotH / 2;

        const maxAbs = Math.max(1, ...pts.map(p => Math.abs(p.diff)));

        ctx.strokeStyle = "rgba(255,255,255,0.10)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padL, midY);
        ctx.lineTo(padL + plotW, midY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(padL, padT);
        ctx.lineTo(padL, padT + plotH);
        ctx.stroke();

        const n = pts.length;
        const barW = plotW / Math.max(1, n);
        const bars = [];

        for (let i = 0; i < n; i++) {
            const v = pts[i].diff;
            const hh = (Math.abs(v) / maxAbs) * (plotH * 0.44);
            const x = padL + i * barW + barW * 0.18;
            const bw = Math.max(2, barW * 0.64);

            let y, hbar;
            if (v >= 0) {
                ctx.fillStyle = "rgba(60, 220, 140, 0.62)";
                y = midY - hh;
                hbar = hh;
            } else {
                ctx.fillStyle = "rgba(255, 80, 90, 0.62)";
                y = midY;
                hbar = hh;
            }
            ctx.fillRect(x, y, bw, hbar);

            ctx.strokeStyle = "rgba(167, 243, 208, 0.55)";
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, bw, hbar);

            bars.push({ x, y, w: bw, h: hbar, data: pts[i] });

            if (n <= 12 || i === 0 || i === n - 1 || i % 5 === 0) {
                ctx.fillStyle = "rgba(255,255,255,0.78)";
                ctx.font = "900 10px system-ui, -apple-system, Segoe UI, Roboto";
                ctx.textAlign = "center";
                ctx.textBaseline = "top";
                ctx.fillText(pts[i].date, x + bw / 2, padT + plotH + 8);
            }
        }

        ctx.fillStyle = "rgba(255,255,255,0.75)";
        ctx.font = "900 11px system-ui, -apple-system, Segoe UI, Roboto";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillText(pts[0]?.playerName ? pts[0].playerName : "PLAYER", padL, 6);

        return { bars };
    }

    function drawStackedWL(canvas, league) {
        const ctx = canvas.getContext("2d");
        const w = canvas.width, h = canvas.height;
        clearCanvas(ctx, w, h);

        if (!league?.length) { drawEmpty(canvas, "Keine Daten"); return { bars: [] }; }

        const maxV = Math.max(1, ...league.map(s => Number(s.matches) || 0));

        const padL = 36, padR = 14, padT = 14, padB = 42;
        const plotW = w - padL - padR;
        const plotH = h - padT - padB;

        ctx.strokeStyle = "rgba(255,255,255,0.12)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padL, padT);
        ctx.lineTo(padL, padT + plotH);
        ctx.lineTo(padL + plotW, padT + plotH);
        ctx.stroke();

        const n = league.length;
        const barW = plotW / Math.max(1, n);
        const bars = [];

        for (let i = 0; i < n; i++) {
            const s = league[i];
            const matches = Number(s.matches) || 0;
            const wins = Number(s.wins) || 0;
            const losses = Number(s.losses) || 0;

            const totalH = (matches / maxV) * plotH;
            const x = padL + i * barW + barW * 0.16;
            const bw = Math.max(2, barW * 0.68);
            const yTop = padT + plotH - totalH;

            const winH = matches > 0 ? totalH * (wins / matches) : 0;
            const lossH = Math.max(0, totalH - winH);

            ctx.fillStyle = "rgba(60, 220, 140, 0.62)";
            ctx.fillRect(x, yTop, bw, winH);
            ctx.strokeStyle = "rgba(167, 243, 208, 0.55)";
            ctx.strokeRect(x, yTop, bw, winH);

            ctx.fillStyle = "rgba(255, 80, 90, 0.62)";
            ctx.fillRect(x, yTop + winH, bw, lossH);
            ctx.strokeStyle = "rgba(252, 165, 165, 0.55)";
            ctx.strokeRect(x, yTop + winH, bw, lossH);

            const label = dispName(s.name);

            ctx.fillStyle = "rgba(255,255,255,0.80)";
            ctx.font = "900 10px system-ui, -apple-system, Segoe UI, Roboto";
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            ctx.fillText(label, x + bw / 2, padT + plotH + 8);

            bars.push({
                x, y: yTop, w: bw, h: totalH,
                data: { playerKey: s.key, name: label, matches, wins, losses, winrate: matches > 0 ? (wins * 100) / matches : 0 }
            });
        }

        return { bars };
    }

    function drawAvgLegs(canvas, league) {
        const ctx = canvas.getContext("2d");
        const w = canvas.width, h = canvas.height;
        clearCanvas(ctx, w, h);

        if (!league?.length) { drawEmpty(canvas, "Keine Daten"); return { bars: [] }; }

        const vals = league.map(s => (Number(s.matches) > 0 ? (Number(s.legsFor) / Number(s.matches)) : 0));
        const maxV = Math.max(1, ...vals);

        const padL = 36, padR = 14, padT = 14, padB = 42;
        const plotW = w - padL - padR;
        const plotH = h - padT - padB;

        ctx.strokeStyle = "rgba(255,255,255,0.12)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padL, padT);
        ctx.lineTo(padL, padT + plotH);
        ctx.lineTo(padL + plotW, padT + plotH);
        ctx.stroke();

        const n = league.length;
        const barW = plotW / Math.max(1, n);
        const bars = [];

        for (let i = 0; i < n; i++) {
            const s = league[i];
            const label = dispName(s.name);
            const matches = Number(s.matches) || 0;
            const legsFor = Number(s.legsFor) || 0;
            const legsAgainst = Number(s.legsAgainst) || 0;

            const avgFor = matches > 0 ? legsFor / matches : 0;
            const avgAg = matches > 0 ? legsAgainst / matches : 0;

            const hh = (avgFor / maxV) * plotH;
            const x = padL + i * barW + barW * 0.16;
            const bw = Math.max(2, barW * 0.68);
            const y = padT + plotH - hh;

            ctx.fillStyle = "rgba(125, 211, 252, 0.62)";
            ctx.fillRect(x, y, bw, hh);
            ctx.strokeStyle = "rgba(167, 243, 208, 0.55)";
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, bw, hh);

            ctx.fillStyle = "rgba(255,255,255,0.80)";
            ctx.font = "900 10px system-ui, -apple-system, Segoe UI, Roboto";
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            ctx.fillText(label, x + bw / 2, padT + plotH + 8);

            bars.push({ x, y, w: bw, h: hh, data: { playerKey: s.key, name: label, matches, avgFor, avgAgainst: avgAg } });
        }

        return { bars };
    }

    // =========================
    // X01 SVG charts (bars)
    // =========================
    function drawLegDiffTimelineSvg(svg, matches, playerKey) {
        const w = Number(svg?.getAttribute?.("width")) || 520;
        const h = Number(svg?.getAttribute?.("height")) || 190;

        clearSvg(svg);
        setupSvgSurface(svg, w, h);

        if (!matches?.length || !playerKey) {
            drawEmptySvg(svg, "Keine Daten");
            return { bars: [] };
        }

        const sorted = matches.slice().sort((a, b) => {
            const ta = new Date(a.finishedAt || a.createdAt || 0).getTime();
            const tb = new Date(b.finishedAt || b.createdAt || 0).getTime();
            return ta - tb;
        });

        const last = sorted.slice(Math.max(0, sorted.length - 30));
        const pts = [];
        for (const m of last) {
            const pl = m.players.find(p => p.key === playerKey);
            const idx = pl?.index;
            if (!Number.isFinite(Number(idx))) continue;

            const legsWon = Number(m.legsWon?.[Number(idx)] ?? 0) || 0;
            const total = Number(m.totalLegs) || 0;
            const legsLost = Math.max(0, total - legsWon);
            const diff = legsWon - legsLost;

            pts.push({
                match: m,
                diff,
                date: germanDateFromIso(m.finishedAt || m.createdAt),
                lineup: m.players.map(p => dispName(p.name)).join(", "),
                legsStr: m.players.map(p => String(Number(m.legsWon?.[Number(p.index)] ?? 0) || 0)).join("-"),
                playerName: dispName(pl?.name || "PLAYER"),
            });
        }

        if (!pts.length) {
            drawEmptySvg(svg, "Keine Daten");
            return { bars: [] };
        }

        const maxAbs = Math.max(1, ...pts.map(p => Math.abs(Number(p.diff) || 0)));

        const padL = 34, padR = 12, padT = 16, padB = 42;
        const plotW = w - padL - padR;
        const plotH = h - padT - padB;
        const midY = padT + plotH / 2;

        // axes (y + mid line)
        svg.appendChild(svgEl("line", { "pointer-events": "none",
                                       x1: padL, y1: midY, x2: padL + plotW, y2: midY,
                                       stroke: "rgba(255,255,255,0.10)", "stroke-width": 1
                                      }));
        svg.appendChild(svgEl("line", { "pointer-events": "none",
                                       x1: padL, y1: padT, x2: padL, y2: padT + plotH,
                                       stroke: "rgba(255,255,255,0.10)", "stroke-width": 1
                                      }));

        const n = pts.length;
        const barW = plotW / Math.max(1, n);
        const bars = [];

        for (let i = 0; i < n; i++) {
            const v = Number(pts[i].diff) || 0;
            const hh = (Math.abs(v) / maxAbs) * (plotH * 0.44);
            const x = padL + i * barW + barW * 0.18;
            const bw = Math.max(2, barW * 0.64);

            let y, hbar, fill, stroke;
            if (v >= 0) {
                stroke = "rgb(60, 220, 140)";
                fill = _adExtColorWithAlpha(stroke, 0.16);
                y = midY - hh;
                hbar = hh;
            } else {
                stroke = "rgb(255, 80, 90)";
                fill = _adExtColorWithAlpha(stroke, 0.16);
                y = midY;
                hbar = hh;
            }

            const d = svgRectPath(x, y, bw, hbar);
            const path = svgEl("path", {
                d,
                fill,
                stroke: stroke,
                "stroke-width": 1,
                "data-ad-bar-index": i,
                class: "recharts-rectangle"
            });
            svg.appendChild(path);

            bars.push({ x, y, w: bw, h: hbar, data: pts[i] });

            if (n <= 12 || i === 0 || i === n - 1 || i % 5 === 0) {
                svg.appendChild(svgEl("text", { "pointer-events": "none",
                                               x: x + bw / 2,
                                               y: padT + plotH + 8, // baseline-ish
                                               fill: "rgba(255,255,255,0.78)",
                                               "font-size": 10,
                                               "font-weight": 900,
                                               "text-anchor": "middle",
                                               "dominant-baseline": "hanging",
                                               "font-family": "system-ui, -apple-system, Segoe UI, Roboto",
                                              }, [document.createTextNode(pts[i].date)]));
            }
        }

        // player label
        svg.appendChild(svgEl("text", { "pointer-events": "none",
                                       x: padL,
                                       y: 6 + 11,
                                       fill: "rgba(255,255,255,0.75)",
                                       "font-size": 11,
                                       "font-weight": 900,
                                       "text-anchor": "start",
                                       "dominant-baseline": "hanging",
                                       "font-family": "system-ui, -apple-system, Segoe UI, Roboto",
                                      }, [document.createTextNode(pts[0]?.playerName ? pts[0].playerName : "PLAYER")]));

        return { bars };
    }

    function drawStackedWLSvg(svg, league, selectedPlayerKeyOrNull) {
        const w = Number(svg?.getAttribute?.("width")) || 900;
        const h = Number(svg?.getAttribute?.("height")) || 420;

        clearSvg(svg);
        setupSvgSurface(svg, w, h);

        if (!league?.length) { drawEmptySvg(svg, "Keine Daten"); return { bars: [] }; }

        const rows = league.slice();
        const maxMatches = Math.max(1, ...rows.map(s => Number(s.matches) || 0));

        const padL = 130, padR = 18, padT = 18, padB = 34;
        const plotW = w - padL - padR;
        const plotH = h - padT - padB;

        // axes / grid
        svg.appendChild(svgEl("line", { "pointer-events": "none",
                                       x1: padL, y1: padT, x2: padL, y2: padT + plotH,
                                       stroke: "rgba(255,255,255,0.14)", "stroke-width": 1
                                      }));

        const tickCount = 5;
        for (let t = 0; t < tickCount; t++) {
            const frac = (tickCount <= 1) ? 0 : (t / (tickCount - 1));
            const x = padL + frac * plotW;

            svg.appendChild(svgEl("line", { "pointer-events": "none",
                                           x1: x, y1: padT, x2: x, y2: padT + plotH,
                                           stroke: "rgba(255,255,255,0.10)", "stroke-width": 1
                                          }));

            const val = Math.round(maxMatches * frac);
            svg.appendChild(svgEl("text", { "pointer-events": "none",
                                           x,
                                           y: padT + plotH + 6,
                                           fill: "rgba(255,255,255,0.70)",
                                           "font-size": 10,
                                           "font-weight": 900,
                                           "text-anchor": "middle",
                                           "dominant-baseline": "hanging",
                                           "font-family": "system-ui, -apple-system, Segoe UI, Roboto",
                                          }, [document.createTextNode(String(val))]));
        }

        const n = rows.length;
        const rowH = plotH / Math.max(1, n);
        const barH = Math.max(10, rowH * 0.56);

        const bars = [];

        const clipLabel = (s, max = 18) => {
            const str = String(s || "");
            if (str.length <= max) return str;
            return str.slice(0, Math.max(0, max - 1)) + "…";
        };

        for (let i = 0; i < n; i++) {
            const s = rows[i];
            const hasSel = !!selectedPlayerKeyOrNull;
            const isSel = hasSel && (String(s.key || "") === String(selectedPlayerKeyOrNull));
            const rowOpacity = hasSel ? (isSel ? 1 : 0.45) : 1;
            const matches = Number(s.matches) || 0;
            const wins = Number(s.wins) || 0;
            const losses = Number(s.losses) || 0;

            const totalW = (matches / maxMatches) * plotW;

            // stacked segments
            const winW = matches > 0 ? totalW * (wins / Math.max(1, matches)) : 0;
            const lossW = Math.max(0, totalW - winW);

            const yMid = padT + i * rowH + rowH / 2;
            const y = yMid - barH / 2;
            const x = padL;

            // name label
            const fullName = dispName(s.name);
            const label = clipLabel(fullName, 22);
            svg.appendChild(svgEl("text", { "pointer-events": "none",
                                           x: padL - 10,
                                           y: yMid,
                                           fill: "rgba(255,255,255,0.82)",
                                           opacity: rowOpacity,
                                           "font-size": 11,
                                           "font-weight": 900,
                                           "text-anchor": "end",
                                           "dominant-baseline": "middle",
                                           "font-family": "system-ui, -apple-system, Segoe UI, Roboto",
                                          }, [document.createTextNode(label)]));

            // wins (left)
            if (winW > 0.01) {
                svg.appendChild(svgEl("path", {
                    d: svgRectPath(x, y, winW, barH),
                    fill: _adExtColorWithAlpha("rgb(60, 220, 140)", isSel ? 0.28 : 0.16),
                    stroke: "rgb(60, 220, 140)",
                    "stroke-width": 1,
                    opacity: rowOpacity,
                    "data-ad-bar-index": i,
                    class: "recharts-rectangle"
                }));
            }

            // losses (right)
            if (lossW > 0.01) {
                svg.appendChild(svgEl("path", {
                    d: svgRectPath(x + winW, y, lossW, barH),
                    fill: _adExtColorWithAlpha("rgb(255, 80, 90)", isSel ? 0.28 : 0.16),
                    stroke: "rgb(255, 80, 90)",
                    "stroke-width": 1,
                    opacity: rowOpacity,
                    "data-ad-bar-index": i,
                    class: "recharts-rectangle"
                }));
            }

            const avgFor = matches > 0 ? (Number(s.legsFor) || 0) / matches : 0;
            const avgAg = matches > 0 ? (Number(s.legsAgainst) || 0) / matches : 0;

            bars.push({
                x, y, w: totalW, h: barH,
                data: {
                    playerKey: s.key,
                    name: fullName,
                    matches,
                    wins,
                    losses,
                    winrate: matches > 0 ? (wins * 100) / matches : 0,
                    avgFor,
                    avgAgainst: avgAg,
                }
            });
        }

        return { bars };
    }

    function drawAvgLegsSvg(svg, league) {
        const w = Number(svg?.getAttribute?.("width")) || 520;
        const h = Number(svg?.getAttribute?.("height")) || 190;

        clearSvg(svg);
        setupSvgSurface(svg, w, h);

        if (!league?.length) { drawEmptySvg(svg, "Keine Daten"); return { bars: [] }; }

        const vals = league.map(s => (Number(s.matches) > 0 ? (Number(s.legsFor) / Number(s.matches)) : 0));
        const maxV = Math.max(1, ...vals);

        const padL = 36, padR = 14, padT = 14, padB = 42;
        const plotW = w - padL - padR;
        const plotH = h - padT - padB;

        // axes
        svg.appendChild(svgEl("line", { "pointer-events": "none",
                                       x1: padL, y1: padT, x2: padL, y2: padT + plotH,
                                       stroke: "rgba(255,255,255,0.12)", "stroke-width": 1
                                      }));
        svg.appendChild(svgEl("line", { "pointer-events": "none",
                                       x1: padL, y1: padT + plotH, x2: padL + plotW, y2: padT + plotH,
                                       stroke: "rgba(255,255,255,0.12)", "stroke-width": 1
                                      }));

        const n = league.length;
        const barW = plotW / Math.max(1, n);
        const bars = [];

        for (let i = 0; i < n; i++) {
            const s = league[i];
            const label = dispName(s.name);
            const matches = Number(s.matches) || 0;
            const legsFor = Number(s.legsFor) || 0;
            const legsAgainst = Number(s.legsAgainst) || 0;

            const avgFor = matches > 0 ? legsFor / matches : 0;
            const avgAg = matches > 0 ? legsAgainst / matches : 0;

            const hh = (avgFor / maxV) * plotH;
            const x = padL + i * barW + barW * 0.16;
            const bw = Math.max(2, barW * 0.68);
            const y = padT + plotH - hh;

            svg.appendChild(svgEl("path", {
                d: svgRectPath(x, y, bw, hh),
                fill: _adExtColorWithAlpha("rgb(125, 211, 252)", 0.16),
                stroke: "rgb(125, 211, 252)",
                "stroke-width": 1,
                "data-ad-bar-index": i,
                class: "recharts-rectangle"
            }));

            svg.appendChild(svgEl("text", { "pointer-events": "none",
                                           x: x + bw / 2,
                                           y: padT + plotH + 8,
                                           fill: "rgba(255,255,255,0.80)",
                                           "font-size": 10,
                                           "font-weight": 900,
                                           "text-anchor": "middle",
                                           "font-family": "system-ui, -apple-system, Segoe UI, Roboto",
                                          }, [document.createTextNode(label)]));

            bars.push({ x, y, w: bw, h: hh, data: { playerKey: s.key, name: label, matches, avgFor, avgAgainst: avgAg } });
        }

        return { bars };
    }



    // =========================
    // NEW: AVG trend on LEGS (not days/months)
    // =========================
    function computeLegAvgTrend(matches, leagueByMatches, maxPlayers, maxLegs) {
        const top = leagueByMatches.slice(0, maxPlayers);
        const playerKeys = top.map(s => s.key);
        const playerNames = new Map(top.map(s => [s.key, dispName(s.name)]));

        // build unified leg timeline (each leg is one x-step, with perAvg map)
        const allLegs = [];
        const sortedMatches = matches.slice().sort((a, b) => {
            const ta = new Date(a.finishedAt || a.createdAt || 0).getTime();
            const tb = new Date(b.finishedAt || b.createdAt || 0).getTime();
            return ta - tb;
        });

        for (const m of sortedMatches) {
            const lt = asArray(m.legTimeline).slice().sort((a, b) => {
                const ta = new Date(a.dateIso || 0).getTime();
                const tb = new Date(b.dateIso || 0).getTime();
                return ta - tb;
            });
            for (const leg of lt) {
                allLegs.push({
                    matchId: m.matchId,
                    dateIso: leg.dateIso || m.finishedAt || m.createdAt,
                    dayKey: leg.dayKey || m.dayKey,
                    label: mmddFromIso(leg.dateIso || m.finishedAt || m.createdAt),
                    lineup: leg.lineup || m.players.map(p => dispName(p.name)).join(", "),
                    perAvg: leg.perAvg || new Map(),
                });
            }
        }

        const lastLegs = allLegs.slice(Math.max(0, allLegs.length - (maxLegs || 60)));

        // x-labels: show only when day changes (like screenshot), otherwise ""
        const xLabels = [];
        let prevDay = null;
        for (const leg of lastLegs) {
            const dk = leg.dayKey || parseIsoDateToDayKey(leg.dateIso) || null;
            if (dk && dk !== prevDay) {
                xLabels.push(leg.label);
                prevDay = dk;
            } else {
                xLabels.push("");
            }
        }

        const series = playerKeys.map((pk, i) => {
            const values = lastLegs.map(leg => {
                const v = leg.perAvg?.get(pk);
                return (v == null || !Number.isFinite(v)) ? null : v;
            });
            return { key: pk, name: playerNames.get(pk) || pk, color: PALETTE[i % PALETTE.length], values };
        });

        return { legs: lastLegs, xLabels, series };
    }


    // =========================
    // X01 Liga: Momentum (SVG)
    // =========================
    function _clampNum(min, v, max) {
        const x = Number(v);
        if (!Number.isFinite(x)) return min;
        return Math.max(min, Math.min(max, x));
    }
    /**
     * Baut Momentum-Daten aus den gefilterten Matches:
     * - Mode "match": Spalten = letzte N Matches (chronologisch), Zelle = Match gewonnen/verloren
     * - Mode "legs":  Spalten = letzte N Legs (chronologisch),   Zelle = Leg gewonnen/verloren
     *   (wenn legWinnerIdxSeq fehlt, wird die Leg-Reihenfolge best-effort aus dem Endstand (legsWon) abgeleitet)
     * - Reihen = Spieler aus der aktuellen Liga-Tabelle (Filter + Sortierung), max. M Spieler
     */
    function buildX01MomentumData(filteredMatches, leagueTable, opts = {}) {
        const maxMatches = Number.isFinite(Number(opts.maxMatches)) ? Number(opts.maxMatches) : 12;
        const maxPlayers = Number.isFinite(Number(opts.maxPlayers)) ? Number(opts.maxPlayers) : 6;
        const mode = (String((opts && opts.mode) || "match").toLowerCase() === "legs") ? "legs" : "match";

        // sort matches chronologically (oldest -> newest)
        const ms = (filteredMatches || []).slice()
        .filter(m => m && (m.finishedAt || m.createdAt))
        .sort((a, b) => new Date(a.finishedAt || a.createdAt).getTime() - new Date(b.finishedAt || b.createdAt).getTime());

        let cols = [];
        let xLabels = [];
        let dayBreaks = [];
        let matchBreaks = [];

        if (mode === "legs") {
            // Default: gleiche Breite wie Match-Momentum (12 Spalten)
            const maxLegs = Number.isFinite(Number(opts.maxLegs))
            ? Number(opts.maxLegs)
            : (Number.isFinite(Number(opts.maxMatches)) ? Number(opts.maxMatches) : 12);

            const legs = [];

            for (const m of ms) {
                const iso = m?.finishedAt || m?.createdAt;
                if (!iso) continue;

                const ps0 = Array.isArray(m?.players) ? m.players : [];
                if (!ps0.length) continue;

                const idxToKey = new Map();
                for (const pp of ps0) {
                    const idx = Number(pp?.index);
                    const k = pp?.key ? String(pp.key) : "";
                    if (!Number.isFinite(idx) || !k) continue;
                    idxToKey.set(idx, k);
                }
                if (!idxToKey.size) continue;

                let seqKeys = Array.isArray(m?.legWinnerKeySeq) ? m.legWinnerKeySeq.slice() : [];
                seqKeys = seqKeys.map(x => (x == null ? "" : String(x))).filter(Boolean);

                let seqIdx = Array.isArray(m?.legWinnerIdxSeq) ? m.legWinnerIdxSeq.slice() : [];
                seqIdx = seqIdx.map(x => Number(x)).filter(x => Number.isFinite(x));

                let approx = false;

                // If we only have index sequence, map idx -> key (robuster in 3+ Spieler Lineups)
                if (!seqKeys.length && seqIdx.length) {
                    const tmpKeys = [];
                    for (const ii of seqIdx) {
                        const k = idxToKey.get(ii);
                        if (k) tmpKeys.push(k);
                    }
                    seqKeys = tmpKeys;
                }

                if (!seqKeys.length) {
                    // Fallback: Reihenfolge unbekannt – wir verteilen nur "best-effort" anhand des Endstands (legsWon)
                    const derivedIdx = [];
                    for (const pp of ps0) {
                        const idx = Number(pp?.index);
                        if (!Number.isFinite(idx)) continue;
                        const cnt = Number(m?.legsWon?.[idx] ?? 0) || 0;
                        for (let t = 0; t < cnt; t++) derivedIdx.push(idx);
                    }
                    if (derivedIdx.length) {
                        const tmpKeys = [];
                        for (const ii of derivedIdx) {
                            const k = idxToKey.get(ii);
                            if (k) tmpKeys.push(k);
                        }
                        if (tmpKeys.length) {
                            seqKeys = tmpKeys;
                            approx = true;
                        }
                    }
                }

                if (!seqKeys.length) continue;

                const dk = parseIsoDateToDayKey(iso);
                const dayLbl = mmddFromIso(iso);

                for (let li = 0; li < seqKeys.length; li++) {
                    legs.push({
                        matchId: m?.matchId,
                        dateIso: iso,
                        dayKey: dk,
                        label: dayLbl,
                        match: m,
                        legNo: li + 1,
                        legsTotal: seqKeys.length,
                        legWinnerKey: seqKeys[li],
                        legApprox: approx ? 1 : 0,
                    });
                }
            }

            const timelineLegs = legs.slice(Math.max(0, legs.length - Math.max(1, maxLegs)));

            cols = timelineLegs.map(l => ({
                matchId: l?.matchId,
                dateIso: l?.dateIso,
                dayKey: l?.dayKey,
                label: l?.label || "",
                match: l?.match,
                legNo: l?.legNo,
                legsTotal: l?.legsTotal,
                legWinnerKey: l?.legWinnerKey,
                legApprox: l?.legApprox ? 1 : 0,
            }));

            // axis labels: show when day changes + always first/last
            xLabels = [];
            dayBreaks = [];
            matchBreaks = [];
            let prevDay = null;
            let prevMid = null;

            for (let i = 0; i < cols.length; i++) {
                const dk = cols[i]?.dayKey || null;
                const mid = String(cols[i]?.matchId || "");
                const isNewDay = (prevDay && dk && dk !== prevDay);
                const isNewMatch = (prevMid && mid && mid !== prevMid);

                if (isNewDay) dayBreaks.push(i);
                if (isNewMatch) matchBreaks.push(i);

                if (i === 0 || i === cols.length - 1 || isNewDay) xLabels.push(cols[i]?.label || "");
                else xLabels.push("");

                prevDay = dk;
                prevMid = mid;
            }
        } else {
            const timeline = ms.slice(Math.max(0, ms.length - Math.max(1, maxMatches)));

            cols = timeline.map(m => {
                const iso = m?.finishedAt || m?.createdAt;
                return {
                    matchId: m?.matchId,
                    dateIso: iso,
                    dayKey: parseIsoDateToDayKey(iso),
                    label: mmddFromIso(iso),
                    match: m,
                };
            });

            // axis labels: show when day changes + always first/last
            xLabels = [];
            dayBreaks = []; // index where a new day starts (vertical separator before this column)
            let prevDay = null;

            for (let i = 0; i < cols.length; i++) {
                const dk = cols[i]?.dayKey || null;
                if (!dk) { xLabels.push(""); continue; }

                const isNewDay = (prevDay && dk !== prevDay);
                if (isNewDay) dayBreaks.push(i);

                if (i === 0 || i === cols.length - 1 || isNewDay) xLabels.push(cols[i].label);
                else xLabels.push("");

                prevDay = dk;
            }
        }

        const ordered = (Array.isArray(leagueTable) && leagueTable.length)
        ? leagueTable
        : computeLeagueTable(filteredMatches);

        const players = [];
        const seen = new Set();
        for (const r of (ordered || [])) {
            const k = r?.key;
            if (!k || seen.has(k)) continue;
            seen.add(k);
            players.push({ key: k, name: dispName(r?.name) });
            if (players.length >= maxPlayers) break;
        }

        const rows = [];
        for (const p of players) {
            const cells = cols.map(c => {
                const m = c?.match;
                const ps = Array.isArray(m?.players) ? m.players : [];
                const mp = ps.find(pp => pp?.key === p.key);
                if (!mp) return null;

                const idx = Number(mp.index);
                if (!Number.isFinite(idx)) return null;

                // opponent (best-effort)
                const opp = ps.find(pp => pp?.key && pp.key !== p.key) || null;
                const oppName = opp?.name ? String(opp.name) : (opp?.key ? String(opp.key) : "");

                const lineup = ps.map(pp => dispName(pp?.name || pp?.key || "")).filter(Boolean).join(" | ");

                // Ergebnis (Legs) – wie im Leg-Diff Tooltip: LegsWon je Spieler
                const legsArr = ps.map(pp => Number(m?.legsWon?.[Number(pp.index)] ?? 0) || 0);
                const legsStr = legsArr.length ? legsArr.join("-") : "—";

                const psArr2 = asArray(m?.perPlayerStats);
                const st = psArr2?.[idx] || {};
                const score = Number(st.score) || 0;
                const darts = Number(st.dartsThrown) || 0;
                const avg = darts > 0 ? (score * 3) / darts : NaN;

                const legsWon = Number(m?.legsWon?.[idx] ?? 0) || 0;
                let legsLost = 0;
                for (const pp of ps) {
                    const j = Number(pp?.index);
                    if (!Number.isFinite(j) || j === idx) continue;
                    legsLost += Number(m?.legsWon?.[j] ?? 0) || 0;
                }
                const legsDiff = legsWon - legsLost;

                if (mode === "legs") {
                    const wKey = c?.legWinnerKey ? String(c.legWinnerKey) : "";
                    if (!wKey) return null;
                    const legWin = (String(p.key) === wKey);

                    return {
                        // win = Leg gewonnen/verloren
                        win: legWin,
                        legNo: Number(c?.legNo) || null,
                        legsTotal: Number(c?.legsTotal) || null,
                        legApprox: c?.legApprox ? 1 : 0,

                        legsWon,
                        legsLost,
                        legsDiff,

                        matchId: c?.matchId || m?.matchId || null,
                        dateIso: c?.dateIso || null,
                        dayKey: c?.dayKey || null,
                        opponent: dispName(oppName),
                        lineup,
                        combo: lineup,
                        legsStr,
                        avg,
                    };
                }

                const wIdx = Number(m?.winnerIndex);
                if (!Number.isFinite(wIdx) || wIdx < 0) return null;

                return {
                    win: idx === wIdx,
                    legsWon,
                    legsLost,
                    legsDiff,
                    matchId: c?.matchId || m?.matchId || null,
                    dateIso: c?.dateIso || null,
                    dayKey: c?.dayKey || null,
                    opponent: dispName(oppName),
                    lineup,
                    combo: lineup,
                    legsStr,
                    avg,
                };

            });

            // Skip rows that have no data for the shown timeline
            if (cells.some(v => v !== null)) {
                rows.push({ key: p.key, name: p.name, cells });
            }
        }

        return {
            mode,
            rows,
            colsCount: cols.length,
            xLabels,
            dayBreaks,
            matchBreaks,
            startIso: cols[0]?.dateIso || null,
            endIso: cols[cols.length - 1]?.dateIso || null,
        };
    }

    function drawMomentumSvg(svg, data, selectedKey = null, mode = "match") {
        const w = Number(svg?.getAttribute?.("width")) || 520;
        const h = Number(svg?.getAttribute?.("height")) || 240;

        clearSvg(svg);
        setupSvgSurface(svg, w, h);

        const rows = Array.isArray(data?.rows) ? data.rows.filter(r => r && r.name) : [];
        const nCols = Number(data?.colsCount) || (rows[0]?.cells?.length || 0);

        if (!rows.length || !nCols) { drawEmptySvg(svg, "Keine Daten"); return; }

        const xLabels = Array.isArray(data?.xLabels) ? data.xLabels : new Array(nCols).fill("");
        const dayBreaks = Array.isArray(data?.dayBreaks) ? data.dayBreaks : [];
        const matchBreaks = Array.isArray(data?.matchBreaks) ? data.matchBreaks : [];

        const momentumMode = (String(mode || data?.mode || "match").toLowerCase() === "legs") ? "legs" : "match";

        const padT = 18, padR = 14, padB = 46;

        // dynamic name column width
        const maxNameLen = Math.max(6, ...rows.map(r => String(r?.name || "").length));
        const nameCol = _clampNum(86, 28 + maxNameLen * 7.0, Math.floor(w * 0.36));
        const padL = nameCol + 14;

        const gap = 2; // minimal spacing
        const availW = w - padL - padR;

        const cellW = _clampNum(10,
                                Math.floor((availW - Math.max(0, (nCols - 1)) * gap) / Math.max(1, nCols)),
                                34
                               );

        // ruhiger: echte Quadrate
        const cellH = cellW;

        const plotH = h - padT - padB;
        const rowGap = _clampNum(10,
                                 Math.floor((plotH - rows.length * cellH) / Math.max(1, rows.length + 1)),
                                 34
                                );
        const startY = padT + rowGap;

        const gridW = (nCols * cellW) + Math.max(0, (nCols - 1)) * gap;

        const greenStroke = "rgb(60, 220, 140)";
        const redStroke = "rgb(255, 80, 90)";
        const emptyStroke = "rgba(255,255,255,0.14)";
        const emptyFill = "rgba(255,255,255,0.04)";
        const dayLine = "rgba(255,255,255,0.08)";
        const matchLine = "rgba(255,255,255,0.12)";

        const axisY = h - padB + 22;

        const rx = Math.min(6, Math.max(2, Math.round(cellW * 0.28)));

        // Rows + Cells
        for (let i = 0; i < rows.length; i++) {
            const r = rows[i];
            const y = startY + i * (cellH + rowGap);
            const yMid = y + cellH / 2;
            const isSel = !!selectedKey && String(r.key || "") === String(selectedKey);
            const rowOpacity = selectedKey ? (isSel ? 1.0 : 0.55) : 1.0;


            // player name (left)
            svg.appendChild(svgEl("text", {
                "pointer-events": "none",
                x: padL - 10,
                y: yMid,
                fill: isSel ? "rgba(255,255,255,0.98)" : "rgba(255,255,255,0.84)",
                opacity: rowOpacity,
                "font-size": 11,
                "font-weight": 900,
                "text-anchor": "end",
                "dominant-baseline": "middle",
                "font-family": "system-ui, -apple-system, Segoe UI, Roboto",
            }, [document.createTextNode(String(r.name))]));

            const arr = Array.isArray(r.cells) ? r.cells : [];

            for (let j = 0; j < nCols; j++) {
                const cell = (j < arr.length) ? arr[j] : null;
                let state = null;
                const w = (cell && typeof cell.win === "boolean") ? cell.win : null;
                if (w === true) state = 1;
                else if (w === false) state = -1;

                const neutralStroke = "rgba(255,255,255,0.38)";
                const stroke = (state === null) ? emptyStroke : (state === 0) ? neutralStroke : (state > 0 ? greenStroke : redStroke);
                const fill = (state === null) ? emptyFill : _adExtColorWithAlpha(stroke, (state === 0) ? 0.10 : 0.18);

                const x = padL + j * (cellW + gap);

                const rect = svgEl("rect", {
                    x, y,
                    width: cellW,
                    height: cellH,
                    rx, ry: rx,
                    stroke,
                    fill,
                    "stroke-width": 1,
                });
                // Tooltip + Interaction (nur wenn Daten)
                if (cell && cell.dateIso) {
                    rect.style.cursor = "pointer";
                    rect.setAttribute("data-momentum-cell", "1");
                    rect.setAttribute("data-player-key", String(r.key || ""));
                    if (cell.matchId) rect.setAttribute("data-match-id", String(cell.matchId));

                    const dateStr = germanDateFromIso(cell.dateIso);
                    const combo = cell.combo || cell.lineup || String(r.name || "—");
                    const avgStr = Number.isFinite(cell.avg) ? fmtDec(cell.avg, 2) : "—";

                    let title = (momentumMode === "legs") ? "Leg" : "Match";
                    let legsLine = cell.legsStr || "—";
                    let resKey = "Ergebnis";
                    let resText = "—";
                    let resCls = "ad-ext-tooltip-res";

                    let extraKvHtml = "";
                    if (momentumMode === "legs") {
                        const legNo = Number(cell.legNo);
                        const legsTotal = Number(cell.legsTotal);
                        legsLine = (Number.isFinite(legNo) && Number.isFinite(legsTotal) && legsTotal > 0)
                            ? `Leg ${legNo}/${legsTotal}`
                            : "Leg";

                        const win = (cell && typeof cell.win === "boolean") ? cell.win : null;
                        if (win === true) {
                            resText = "Gewonnen";
                            resCls = "ad-ext-tooltip-res ad-ext-tooltip-res--win";
                        } else if (win === false) {
                            resText = "Verloren";
                            resCls = "ad-ext-tooltip-res ad-ext-tooltip-res--loss";
                        } else {
                            resText = "—";
                            resCls = "ad-ext-tooltip-res";
                        }

                        const endstand = cell.legsStr || "—";
                        extraKvHtml += `<div class="ad-ext-tooltip-kv"><div class="ad-ext-tooltip-k">Endstand</div><div class="ad-ext-tooltip-v">${escapeHtml(endstand)}</div></div>`;
                        if (cell.legApprox) {
                            extraKvHtml += `<div class="ad-ext-tooltip-recline">Leg-Reihenfolge aus Endstand abgeleitet (Reihenfolge ggf. nicht korrekt).</div>`;
                        }
                    } else {
                        const win = !!cell.win;
                        resText = win ? "Sieg" : "Niederlage";
                        resCls = win ? "ad-ext-tooltip-res ad-ext-tooltip-res--win" : "ad-ext-tooltip-res ad-ext-tooltip-res--loss";
                    }

                    const html = `
                      <div class="ad-ext-tooltip-title">${escapeHtml(title)}</div>
                      <div class="ad-ext-tooltip-line">
                        <div class="ad-ext-tooltip-date">${escapeHtml(dateStr)}</div>
                        <div class="ad-ext-tooltip-lineup ad-ext-tooltip-lineup--wrap">${escapeHtml(combo)}</div>
                        <div class="ad-ext-tooltip-legs">${escapeHtml(legsLine)}</div>
                      </div>
                      <div class="ad-ext-tooltip-kv"><div class="ad-ext-tooltip-k">${escapeHtml(resKey)}</div><div class="ad-ext-tooltip-v"><span class="${resCls}">${escapeHtml(resText)}</span></div></div>
                      ${extraKvHtml}
                      <div class="ad-ext-tooltip-kv"><div class="ad-ext-tooltip-k">AVG</div><div class="ad-ext-tooltip-v">${escapeHtml(avgStr)}</div></div>
                    `;

                    rect.addEventListener("mouseenter", (ev) => tooltipShow(ev, html));
                    rect.addEventListener("mousemove", (ev) => tooltipMove(ev));
                    rect.addEventListener("mouseleave", () => tooltipHide());
                }
                svg.appendChild(rect);
            }
        }

        // Day separators (Spieltage) - on top (very subtle), but don't block hover
        for (const idx of dayBreaks) {
            if (!Number.isFinite(Number(idx)) || idx <= 0 || idx >= nCols) continue;
            const x = padL + idx * (cellW + gap) - (gap / 2);
            svg.appendChild(svgEl("line", {
                x1: x, y1: padT - 2,
                x2: x, y2: axisY + 6,
                stroke: dayLine,
                "stroke-width": 1,
                "pointer-events": "none",
            }));
        }


        // Match separators (dezent) – hilfreich im Legs-Modus
        if (momentumMode === "legs") {
            for (const idx of matchBreaks) {
                if (!Number.isFinite(Number(idx)) || idx <= 0 || idx >= nCols) continue;
                const x = padL + idx * (cellW + gap) - (gap / 2);
                svg.appendChild(svgEl("line", {
                    x1: x, y1: padT - 2,
                    x2: x, y2: axisY + 6,
                    stroke: matchLine,
                    "stroke-width": 1,
                    "pointer-events": "none",
                }));
            }
        }

        // Axis baseline
        svg.appendChild(svgEl("line", {
            x1: padL - 4,
            y1: axisY,
            x2: padL + gridW + 4,
            y2: axisY,
            stroke: "rgba(255,255,255,0.14)",
            "stroke-width": 1,
        }));

        const labelY = axisY + 13;

        for (let j = 0; j < nCols; j++) {
            const lbl = xLabels[j];
            if (!lbl) continue;

            const x = padL + j * (cellW + gap) + cellW / 2;

            svg.appendChild(svgEl("line", {
                x1: x, y1: axisY - 4,
                x2: x, y2: axisY + 4,
                stroke: "rgba(255,255,255,0.14)",
                "stroke-width": 1,
            }));

            svg.appendChild(svgEl("text", {
                "pointer-events": "none",
                x,
                y: labelY,
                fill: "rgba(255,255,255,0.78)",
                "font-size": 12,
                "font-weight": 900,
                "text-anchor": "middle",
                "dominant-baseline": "hanging",
                "font-family": "system-ui, -apple-system, Segoe UI, Roboto",
            }, [document.createTextNode(String(lbl))]));
        }
    }

    function drawLegLineTrend(canvas, xLabels, series, highlightKey) {
        const ctx = canvas.getContext("2d");
        const w = canvas.width, h = canvas.height;
        clearCanvas(ctx, w, h);

        const n = xLabels?.length || 0;
        if (!n || !series?.length) {
            drawEmpty(canvas, "Keine Daten");
            return { type: "legline", xPos: [], idxCount: 0, pointsLayout: [], legs: [] };
        }

        // y-range
        let minY = Infinity, maxY = -Infinity;
        for (const s of series) {
            for (const v of s.values) {
                if (v == null) continue;
                minY = Math.min(minY, v);
                maxY = Math.max(maxY, v);
            }
        }
        if (!Number.isFinite(minY) || !Number.isFinite(maxY)) {
            drawEmpty(canvas, "Keine Daten");
            return { type: "legline", xPos: [], idxCount: 0, pointsLayout: [], legs: [] };
        }

        // keep it similar to screenshot: ticks in 15-steps, at least up to 60
        const minBase = 0;
        const maxWanted = Math.max(60, maxY + 2);
        const tickStep = 15;
        const maxTick = Math.min(150, Math.ceil(maxWanted / tickStep) * tickStep);
        minY = minBase;
        maxY = maxTick;

        const padL = 54, padR = 16, padT = 18, padB = 44;
        const plotW = w - padL - padR;
        const plotH = h - padT - padB;

        const xPos = new Array(n).fill(0).map((_, i) => padL + (i * plotW) / Math.max(1, (n - 1)));

        function yOf(v) {
            const t = (v - minY) / Math.max(1e-9, (maxY - minY));
            return padT + plotH - t * plotH;
        }

        // axes + grid
        ctx.strokeStyle = "rgba(255,255,255,0.14)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padL, padT);
        ctx.lineTo(padL, padT + plotH);
        ctx.lineTo(padL + plotW, padT + plotH);
        ctx.stroke();

        // y ticks
        ctx.fillStyle = "rgba(255,255,255,0.78)";
        ctx.font = "900 11px system-ui, -apple-system, Segoe UI, Roboto";
        ctx.textAlign = "right";
        ctx.textBaseline = "middle";

        for (let t = 0; t <= maxTick; t += tickStep) {
            const y = yOf(t);
            ctx.strokeStyle = "rgba(255,255,255,0.10)";
            ctx.beginPath();
            ctx.moveTo(padL, y);
            ctx.lineTo(padL + plotW, y);
            ctx.stroke();

            ctx.fillText(String(t), padL - 8, y);
        }

        // x labels (only when non-empty)
        ctx.fillStyle = "rgba(255,255,255,0.80)";
        ctx.font = "900 11px system-ui, -apple-system, Segoe UI, Roboto";
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        for (let i = 0; i < n; i++) {
            if (!xLabels[i]) continue;
            ctx.fillText(xLabels[i], xPos[i], padT + plotH + 8);
        }

        // series
        const pointsLayout = [];
        for (const s of series) {
            const isHi = highlightKey && s.key === highlightKey;
            ctx.strokeStyle = s.color;
            ctx.lineWidth = isHi ? 3 : 2;
            ctx.globalAlpha = isHi ? 0.95 : 0.70;

            ctx.beginPath();
            let started = false;
            const pts = [];

            for (let i = 0; i < n; i++) {
                const v = s.values[i];
                if (v == null) { pts.push(null); started = false; continue; }
                const x = xPos[i];
                const y = yOf(v);
                pts.push({ x, y, v });

                if (!started) { ctx.moveTo(x, y); started = true; }
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // markers (like screenshot dots)
            ctx.fillStyle = s.color;
            ctx.globalAlpha = isHi ? 0.95 : 0.70;
            for (const p of pts) {
                if (!p) continue;
                ctx.beginPath();
                ctx.arc(p.x, p.y, isHi ? 3.4 : 2.8, 0, Math.PI * 2);
                ctx.fill();
            }

            pointsLayout.push({ key: s.key, name: s.name, color: s.color, pts });
        }

        ctx.globalAlpha = 1;

        return { type: "legline", xPos, idxCount: n, pointsLayout, padL, padT, plotW, plotH };
    }

    // =========================
    // Segment Training Rendering
    // =========================
    function setText(panel, sel, text) {
        const el = panel.querySelector(sel);
        if (el) el.textContent = text;
    }
    function setSourceLabel(panel, text) {
        const el = panel.querySelector("#ad-ext-source-label");
        if (el) el.textContent = text;
    }


    function applySelectedRowHighlightSegment(panel) {
        const segPanel = panel.querySelector("#ad-ext-view-segment");
        if (!segPanel) return;

        const selTarget = cache?.filters?.selectedTarget || null;
        const selDay = cache?.filters?.selectedDayKey || null;

        segPanel.querySelectorAll("#ad-ext-st-table-target tr[data-target]").forEach((tr) => {
            const t = tr.getAttribute("data-target");
            tr.classList.toggle("ad-ext-row--selected", !!selTarget && t === selTarget);
        });

        segPanel.querySelectorAll("#ad-ext-st-table-day tr[data-day-key]").forEach((tr) => {
            const dk = tr.getAttribute("data-day-key");
            tr.classList.toggle("ad-ext-row--selected", !!selDay && dk === selDay);
        });
    }


    function applySelectedRowHighlightAtc(panel) {
        const canonField = (v) => {
            const s = String(v || "").trim().toUpperCase();
            if (!s) return null;
            if (s.includes("BULL") || s === "25" || s === "50") return "BULL";
            const m = s.match(/(\d{1,2})/);
            if (m) {
                const n = parseInt(m[1], 10);
                if (Number.isFinite(n) && n >= 1 && n <= 20) return String(n);
            }
            return s;
        };

        const selField = canonField(cache?.filtersATC?.selectedField || null);
        const selDay = String(cache?.filtersATC?.selectedDayKey || "");

        panel.querySelectorAll("#ad-ext-atc-table-target tr[data-field]").forEach((tr) => {
            const f = canonField(tr.getAttribute("data-field"));
            tr.classList.toggle("ad-ext-row--selected", !!selField && f === selField);
        });

        panel.querySelectorAll("#ad-ext-atc-table-day tr[data-day-key]").forEach((tr) => {
            const dk = String(tr.getAttribute("data-day-key") || "");
            tr.classList.toggle("ad-ext-row--selected", !!selDay && dk === selDay);
        });
    }

    function renderTableDay(panel, dayAgg, limit = 10, selectedDayKey = null) {
        const body = panel.querySelector("#ad-ext-st-table-day");
        if (!body) return;

        const all = Array.isArray(dayAgg) ? dayAgg.slice() : [];
        let rows = all.slice(0, limit);

        // ensure selected row stays visible (similar to X01 selection behaviour)
        if (selectedDayKey && !rows.some(r => r?.dayKey === selectedDayKey)) {
            const selRow = all.find(r => r?.dayKey === selectedDayKey);
            if (selRow) {
                rows = [selRow, ...rows.slice(0, Math.max(0, limit - 1))];
            }
        }

        if (!rows.length) {
            body.innerHTML = `<tr><td colspan="5" style="opacity:.7; padding:10px 12px;">Keine Daten</td></tr>`;
            return;
        }

        body.innerHTML = rows.map((d) => `
      <tr data-day-key="${escapeHtml(String(d.dayKey || ""))}">
        <td>${escapeHtml(dayKeyToGerman(d.dayKey))}</td>
        <td class="ad-ext-table-value-right">${fmtInt(d.sessions)}</td>
        <td class="ad-ext-table-value-right">${fmtInt(d.darts)}</td>
        <td class="ad-ext-table-value-right">${fmtInt(d.hits)}</td>
        <td class="ad-ext-table-value-right">${fmtPct(d.hits, d.darts)}</td>
      </tr>
    `).join("");
    }

    function renderAtcTableDay(panel, dayAgg, limit = 10, selectedDayKey = null) {
        const body = panel.querySelector("#ad-ext-atc-table-day");
        if (!body) return;

        const all = Array.isArray(dayAgg) ? dayAgg.slice() : [];
        let rows = all.slice(0, limit);

        // keep selected day visible (like Segment-Fokus)
        if (selectedDayKey && !rows.some(r => r?.dayKey === selectedDayKey)) {
            const selRow = all.find(r => r?.dayKey === selectedDayKey);
            if (selRow) rows = [selRow, ...rows.slice(0, Math.max(0, limit - 1))];
        }

        if (!rows.length) {
            body.innerHTML = `<tr><td colspan="5" style="opacity:.7; padding:10px 12px;">Keine Daten</td></tr>`;
            return;
        }

        body.innerHTML = rows.map((d) => `
      <tr data-day-key="${escapeHtml(String(d.dayKey || ""))}">
        <td>${escapeHtml(dayKeyToGerman(d.dayKey))}</td>
        <td class="ad-ext-table-value-right">${fmtInt(d.legs ?? d.sessions ?? 0)}</td>
        <td class="ad-ext-table-value-right">${fmtInt(d.darts)}</td>
        <td class="ad-ext-table-value-right">${fmtInt(d.hits)}</td>
        <td class="ad-ext-table-value-right">${fmtPct(d.hits, d.darts)}</td>
      </tr>
    `).join("");
    }






    // =========================
    // ATC Fokus: sortierbare Felder-Tabelle ("Felder (Aggregiert)")
    // =========================
    function aggregateAtcByField(list) {
        // NOTE: Ab 0.14.137 wird "Felder (Aggregiert)" aus /stats targetStats gebaut (AtcDetail.targetStats).
        // Output: { field: "<bed>:<number>", sessions, darts, hits }
        const m = new Map();
        const arr = Array.isArray(list) ? list : [];

        const bedFrom = (t) => {
            const b0 = (t && t.bed != null) ? String(t.bed) : "";
            const b = b0.trim();
            return b || "Full";
        };

        const numLabelFrom = (t) => {
            const raw =
                  (t?.targetNumber != null) ? t.targetNumber :
                  (t?.number != null) ? t.number :
                  (t?.target != null) ? t.target :
                  (t?.value != null) ? t.value :
                  null;

            const rawStr = String(raw ?? "").trim();
            const rawUp = rawStr.toUpperCase();
            const bedUp = String(t?.bed ?? "").trim().toUpperCase();

            const n = Number(raw);

            // Bull-ish: keep numeric if present, else default to 25
            if (rawUp.includes("BULL") || bedUp.includes("BULL") || n === 25 || n === 50) {
                if (Number.isFinite(n) && (n === 25 || n === 50)) return String(Math.round(n));
                const ni = parseInt(rawUp.replace(/[^\d]/g, ""), 10);
                if (Number.isFinite(ni) && (ni === 25 || ni === 50)) return String(ni);
                return "25";
            }

            if (Number.isFinite(n)) return String(Math.round(n));

            const ni = parseInt(rawStr, 10);
            if (Number.isFinite(ni)) return String(ni);

            return null;
        };

        for (const d of arr) {
            const ts = Array.isArray(d?.targetStats) ? d.targetStats : null;

            if (ts && ts.length) {
                const seenFieldsThisMatch = new Set(); // max +1 sessions per matchId per field

                for (const t of ts) {
                    const bed = bedFrom(t);
                    const numLabel = numLabelFrom(t);
                    if (!numLabel) continue;

                    const field = `${bed}:${numLabel}`;

                    const darts = Math.max(0, Number(t?.darts ?? t?.count) || 0);
                    const hits = Math.max(0, Number(t?.hits) || 0);

                    // if there is literally no info for this target, skip (avoid counting all 1..20 as "sessions")
                    if (!(darts > 0 || hits > 0)) continue;

                    let row = m.get(field);
                    if (!row) {
                        row = { field, sessions: 0, darts: 0, hits: 0 };
                        m.set(field, row);
                    }

                    row.darts += darts;
                    row.hits += hits;

                    if (!seenFieldsThisMatch.has(field)) {
                        row.sessions += 1;
                        seenFieldsThisMatch.add(field);
                    }
                }

                continue;
            }

            // Backwards-compat: accept old session objects (fieldsAgg)
            const fa = d?.fieldsAgg;
            if (!fa || typeof fa !== "object") continue;

            const keys = Object.keys(fa);
            if (!keys.length) continue;

            const seenFieldsThisMatch = new Set();
            for (const k0 of keys) {
                const k = String(k0 || "").trim();
                if (!k) continue;

                const field = `Full:${k.toUpperCase() === "BULL" ? "25" : k}`;

                const rec = fa?.[k0] || {};
                const darts = Math.max(0, Number(rec?.darts) || 0);
                const hits = Math.max(0, Number(rec?.hits) || 0);

                if (!(darts > 0 || hits > 0)) continue;

                let row = m.get(field);
                if (!row) {
                    row = { field, sessions: 0, darts: 0, hits: 0 };
                    m.set(field, row);
                }

                row.darts += darts;
                row.hits += hits;

                if (!seenFieldsThisMatch.has(field)) {
                    row.sessions += 1;
                    seenFieldsThisMatch.add(field);
                }
            }
        }

        const out = Array.from(m.values());
        for (const r of out) {
            r.sessions = Math.max(0, Math.round(Number(r.sessions) || 0));
            r.darts = Math.max(0, Math.round(Number(r.darts) || 0));
            r.hits = Math.max(0, Math.round(Number(r.hits) || 0));
        }
        return out;
    }

    function atcFieldKeyParts(label) {
        const s0 = String(label || "").trim();

        // New format (>=0.14.137): "<bed>:<number>", keep old labels working too.
        const parts = s0.split(":");
        let bedPart = "";
        let numPart = s0;

        if (parts.length >= 2) {
            bedPart = String(parts[0] || "").trim();
            numPart = String(parts.slice(1).join(":") || "").trim();
        }

        const bedCanon = bedPart.toUpperCase().replace(/[\s-]+/g, "_");
        const bedGrp =
              (bedCanon === "FULL") ? 0 :
              (bedCanon === "OUTER_SINGLE") ? 1 :
              (bedCanon === "SINGLE") ? 2 :
              (bedCanon === "DOUBLE") ? 3 :
              (bedCanon === "TRIPLE") ? 4 :
              (bedPart ? 8 : 0);

        const base = bedGrp * 10;

        const numUp = String(numPart || "").trim().toUpperCase();
        const n = parseInt(numUp, 10);
        const isBull = numUp.includes("BULL") || n === 25 || n === 50 || bedCanon.includes("BULL");

        if (isBull) return { grp: base + 9, num: 999, txt: `${String(bedPart || "").toLowerCase()}:bull`, isBull: true };

        if (Number.isFinite(n)) return { grp: base + 0, num: n, txt: `${String(bedPart || "").toLowerCase()}:${n}`, isBull: false };

        // legacy: bare "BULL"
        if (String(s0 || "").trim().toUpperCase() === "BULL") return { grp: base + 9, num: 999, txt: "bull", isBull: true };

        return { grp: base + 5, num: 999, txt: s0.toLowerCase(), isBull: false };
    }

    function atcFieldSortValue(row, sortKey) {
        const k = String(sortKey || "hitPct");
        if (k === "field") return atcFieldKeyParts(row?.field);
        if (k === "legs" || k === "sessions") return Number(row?.legs ?? row?.sessions) || 0;
        if (k === "darts") return Number(row?.darts) || 0;
        if (k === "hits") return Number(row?.hits) || 0;
        if (k === "hitPct") {
            const d = Number(row?.darts) || 0;
            const h = Number(row?.hits) || 0;
            return d > 0 ? (h / d) : NaN;
        }
        return Number(row?.hits) || 0;
    }

    function sortATCFieldRows(fieldAgg, sortKey, sortDir) {
        const key = String(sortKey || "hitPct");
        const dir = (String(sortDir || "desc").toLowerCase() === "asc") ? 1 : -1;

        const arr = (Array.isArray(fieldAgg) ? fieldAgg : []).slice();

        arr.sort((a, b) => {
            if (key === "field") {
                const pa = atcFieldSortValue(a, "field");
                const pb = atcFieldSortValue(b, "field");

                // Bull always last (stable, independent of dir)
                if (!!pa.isBull !== !!pb.isBull) return pa.isBull ? 1 : -1;

                if (pa.grp !== pb.grp) return dir * (pa.grp - pb.grp);
                if (pa.num !== pb.num) return dir * (pa.num - pb.num);

                const cmp = String(pa.txt).localeCompare(String(pb.txt), "de");
                if (cmp !== 0) return dir * cmp;
            } else {
                const va = Number(atcFieldSortValue(a, key));
                const vb = Number(atcFieldSortValue(b, key));
                const fa = Number.isFinite(va);
                const fb = Number.isFinite(vb);

                // NaN / unknown always at bottom
                if (fa && !fb) return -1;
                if (!fa && fb) return 1;

                if (fa && fb && va !== vb) return dir * (va - vb);
            }

            // fallback (stable-ish): Hit% desc, Sessions desc, Field asc
            const ar = (Number(a?.darts) || 0) > 0 ? (Number(a?.hits) || 0) / (Number(a?.darts) || 1) : -Infinity;
            const br = (Number(b?.darts) || 0) > 0 ? (Number(b?.hits) || 0) / (Number(b?.darts) || 1) : -Infinity;
            if (br !== ar) return br - ar;
            if ((Number(b?.legs ?? b?.sessions) || 0) !== (Number(a?.legs ?? a?.sessions) || 0)) return (Number(b?.legs ?? b?.sessions) || 0) - (Number(a?.legs ?? a?.sessions) || 0);

            const fa2 = atcFieldKeyParts(a?.field);
            const fb2 = atcFieldKeyParts(b?.field);
            if (!!fa2.isBull !== !!fb2.isBull) return fa2.isBull ? 1 : -1;
            if (fa2.grp !== fb2.grp) return fa2.grp - fb2.grp;
            if (fa2.num !== fb2.num) return fa2.num - fb2.num;
            return String(fa2.txt).localeCompare(String(fb2.txt), "de");
        });

        return arr;
    }

    function updateATCFieldSortIndicators(panel) {
        const body = panel?.querySelector?.("#ad-ext-atc-table-target");
        const table = body?.closest?.("table");
        if (!table) return;

        let key = String(cache?.filtersATC?.fieldSortKey || "hitPct");
        if (key === "sessions") key = "legs";
        const dir = (String(cache?.filtersATC?.fieldSortDir || "desc").toLowerCase() === "asc") ? "asc" : "desc";

        const ths = table.querySelectorAll("th[data-sort-key]");
        for (const th of ths) {
            const k = th.getAttribute("data-sort-key");
            if (k === key) th.setAttribute("data-sort-dir", dir);
            else th.removeAttribute("data-sort-dir");
        }
    }

    // =========================
    // ATC-Fokus: Feld-Aggregation direkt aus IndexedDB match_stats (ohne ensureAtcDetail)
    // =========================
    function normalizeAtcBedKey(v) {
        return String(v || "").toLowerCase().replace(/[^a-z0-9]+/g, "");
    }

    function extractStatsPayloadFromIdbRecord(rec) {
        if (!rec) return null;
        const p = rec?.stats ?? rec?.data ?? rec?.payload ?? rec;
        return (p && typeof p === "object") ? p : null;
    }

    function getAtcStatsTimeIso(stats, rec) {
        const s = stats || {};
        return s.finishedAt || s.createdAt
            || s.match?.finishedAt || s.match?.createdAt
            || s.meta?.finishedAt || s.meta?.createdAt
            || rec?.finishedAt || rec?.createdAt
            || null;
    }

    function extractTargetStatsFromStatsPayload(stats) {
        const ms = asArray(stats?.matchStats);
        for (const p of ms) {
            const ts = p?.targetStats;
            if (Array.isArray(ts) && ts.length) return ts;
        }
        const legs = asArray(stats?.legStats);
        for (const leg of legs) {
            const stArr = asArray(leg?.stats);
            for (const st of stArr) {
                const ts = st?.targetStats;
                if (Array.isArray(ts) && ts.length) return ts;
            }
        }
        return [];
    }

    function isAtcStatsPayload(stats) {
        if (!stats || typeof stats !== "object") return false;

        const cand = [
            stats.variant, stats.variantName, stats.trainingVariant,
            stats.mode, stats.gameMode, stats.activityKey, stats.trainingMode, stats.type, stats.kind
        ].filter((x) => typeof x === "string" && x.trim());
        const hay = cand.join(" ").toLowerCase();
        if (hay.includes("atc")) return true;

        const ts = extractTargetStatsFromStatsPayload(stats);

        // Strong hint: settings + targetStats
        if (stats.settings && typeof stats.settings === "object" && !Array.isArray(stats.settings) && ts.length) return true;

        // Best-effort fallback: targetStats look like ATC (1..20 + optional Bull)
        if (ts.length >= 10) {
            try {
                const nums = new Set(ts.map((t) => Number(t?.targetNumber ?? t?.number)).filter((n) => Number.isFinite(n)));
                if (nums.has(1) && nums.has(20)) return true;
            } catch {}
        }

        return false;
    }

    async function loadAtcFieldAggFromIdb(dateRange, modeKey, opts) {
        try {
            opts = (opts && typeof opts === "object") ? opts : {};
            const allowedMatchIds = (opts.allowedMatchIds instanceof Set) ? opts.allowedMatchIds : null;
            const overrideDayKey = (typeof opts.dayKey === "string" && opts.dayKey.trim()) ? opts.dayKey.trim() : null;
            const wantFieldKey = (typeof opts.wantFieldKey === "string" && opts.wantFieldKey.trim()) ? opts.wantFieldKey.trim().toUpperCase() : null;
            const outFieldSet = (opts.outFieldSet instanceof Set) ? opts.outFieldSet : null;
            const onlyCollectFieldSet = !!opts.onlyCollectFieldSet;
            try { if (outFieldSet) outFieldSet.clear(); } catch {}


            const range = String(dateRange || "ALL").toUpperCase();
            const wantedBed = normalizeAtcBedKey(modeKey || "FULL");

            let wantDayKey = null;
            let fromTs = null;

            if (range === "TODAY" || range === "YESTERDAY" || range === "DAY_BEFORE") {
                const daysAgo = (range === "TODAY") ? 0 : (range === "YESTERDAY") ? 1 : 2;
                wantDayKey = relativeDayKey(daysAgo);
            } else if (range !== "ALL") {
                const now = new Date();
                const daysBack = (n) => { const d = new Date(now); d.setDate(d.getDate() - n); return d; };
                const monthsBack = (n) => { const d = new Date(now); d.setMonth(d.getMonth() - n); return d; };
                let from = null;

                if (range === "D7") from = daysBack(7);
                else if (range === "D14") from = daysBack(14);
                else if (range === "D30") from = daysBack(30);
                else if (range === "M3") from = monthsBack(3);
                else if (range === "M6") from = monthsBack(6);
                else if (range === "Y1") from = daysBack(365);

                if (from) fromTs = from.getTime();
            }


            if (overrideDayKey) {
                wantDayKey = overrideDayKey;
                fromTs = null; // explicit day overrides time-window
            }
            const loc = await resolveAutodartsIdbLocation();
            const db = await openExistingIdb(loc.dbName);

            const meta = { scanned: 0, atcFound: 0, afterTime: 0, afterMode: 0, loc };

            if (allowedMatchIds) meta.allowedMatchIds = allowedMatchIds.size;

            return await new Promise((resolve, reject) => {
                let done = false;
                const finish = (fn, arg) => {
                    if (done) return;
                    done = true;
                    try { db.close(); } catch {}
                    fn(arg);
                };

                let tx;
                try { tx = db.transaction(loc.storeName, "readonly"); } catch (e) { finish(reject, e); return; }
                tx.onerror = () => finish(reject, tx.error || new Error("IDB tx error"));

                const store = tx.objectStore(loc.storeName);
                const fieldMap = onlyCollectFieldSet ? null : new Map();

                const ensure = (field) => {
                    if (!fieldMap) return null;
                    const k = String(field);
                    let r = fieldMap.get(k);
                    if (!r) {
                        r = { field: k, darts: 0, hits: 0, legs: 0, sessionsSet: new Set() };
                        fieldMap.set(k, r);
                    }
                    return r;
                };

                const req = store.openCursor();
                req.onerror = () => finish(reject, req.error || new Error("IDB cursor error"));
                req.onsuccess = () => {
                    const cursor = req.result;
                    if (!cursor) {
                        if (onlyCollectFieldSet) {
                            finish(resolve, []);
                            return;
                        }
                        // export matchId set for a single selected field (optional)
                        try {
                            if (outFieldSet && wantFieldKey && fieldMap instanceof Map) {
                                outFieldSet.clear();
                                const rr = fieldMap.get(wantFieldKey);
                                if (rr && rr.sessionsSet && typeof rr.sessionsSet.forEach === "function") {
                                    rr.sessionsSet.forEach((id) => outFieldSet.add(id));
                                }
                            }
                        } catch {}

                        const rows = Array.from(fieldMap.values()).map((r) => ({
                            field: r.field,
                            legs: Math.max(0, Math.round(Number(r.legs) || 0)),
                            sessions: r.sessionsSet.size,
                            darts: Math.max(0, Math.round(Number(r.darts) || 0)),
                            hits: Math.max(0, Math.round(Number(r.hits) || 0)),
                        }));

                        try {
                            const root = (typeof unsafeWindow !== "undefined" && unsafeWindow)
                                ? unsafeWindow
                                : ((typeof window !== "undefined" && window) ? window : globalThis);
                            root.__adExtAtcDebug = root.__adExtAtcDebug || {};
                            root.__adExtAtcDebug.lastFieldRows = rows;
                            root.__adExtAtcDebug.meta = { ...meta, rows: rows.length, range, modeKey };
                        } catch {}

                        if (DEBUG_ATC_FIELDS) {
                            try {
                                console.debug("[AD Ext][ATC] loadAtcFieldAggFromIdb meta", meta);
                                console.table(rows.slice(0, 10));
                            } catch {}
                        }

                        finish(resolve, rows);
                        return;
                    }

                    meta.scanned++;

                    const rec = cursor.value;
                    const stats = extractStatsPayloadFromIdbRecord(rec);
                    if (!stats) { cursor.continue(); return; }

                    if (!isAtcStatsPayload(stats)) { cursor.continue(); return; }
                    meta.atcFound++;

                    const iso = getAtcStatsTimeIso(stats, rec);
                    if (wantDayKey) {
                        const dk = parseIsoDateToDayKey(iso);
                        if (String(dk || "") !== String(wantDayKey || "")) { cursor.continue(); return; }
                    } else if (fromTs && fromTs > 0) {
                        const ts = iso ? new Date(iso).getTime() : NaN;
                        if (!Number.isFinite(ts) || ts < fromTs) { cursor.continue(); return; }
                    }
                    meta.afterTime++;

                    const matchId = String(rec?.matchId || rec?.id || stats?.id || stats?.matchId || "");
                    if (allowedMatchIds) {
                        if (!matchId || !allowedMatchIds.has(matchId)) { cursor.continue(); return; }
                    }

                    const matchLegs = (() => {
                        const tl = Number(stats?.totalLegs ?? stats?.match?.totalLegs ?? stats?.meta?.totalLegs ?? 0);
                        if (Number.isFinite(tl) && tl > 0) return tl;
                        const ls = Array.isArray(stats?.legStats) ? stats.legStats.length : 0;
                        if (ls > 0) return ls;
                        const gs = Array.isArray(stats?.games) ? stats.games.length : 0;
                        if (gs > 0) return gs;
                        return 1;
                    })();

                    const tstats = extractTargetStatsFromStatsPayload(stats);
                    if (!tstats.length) { cursor.continue(); return; }

                    const seenFieldsThisMatch = new Set();
                    let anyModeHit = false;

                    for (const t of tstats) {
                        if (!t || typeof t !== "object") continue;

                        const bedRaw = t?.bed ?? null;
                        const bedCanon = normalizeAtcBedKey(bedRaw);

                        // Mode filter by bed (best-effort): allow missing bed only for FULL
                        if (wantedBed && bedCanon) {
                            if (bedCanon !== wantedBed) continue;
                        } else if (wantedBed && !bedCanon) {
                            if (wantedBed !== "full") continue;
                        }

                        const numRaw = t?.targetNumber ?? t?.number ?? t?.value ?? null;
                        const n = Number(numRaw);
                        const isBull = (n === 25 || n === 50) || String(bedRaw || "").toLowerCase().includes("bull") || String(t?.name || "").toLowerCase().includes("bull");
                        const fieldLabel = isBull ? "BULL" : (Number.isFinite(n) ? String(Math.round(n)) : null);
                        if (!fieldLabel) continue;

                        const darts = Number(t?.count ?? t?.darts ?? 0) || 0;
                        const hits = Number(t?.hits ?? 0) || 0;

                        if (darts <= 0 && hits <= 0) continue;

                        if (onlyCollectFieldSet) {
                            if (outFieldSet && wantFieldKey && String(fieldLabel).toUpperCase() === wantFieldKey) {
                                outFieldSet.add(matchId);
                            }
                            continue;
                        }

                        const row = ensure(fieldLabel);
                        row.darts += Math.max(0, darts);
                        row.hits += Math.max(0, hits);

                        if (matchId) {
                            if (!seenFieldsThisMatch.has(fieldLabel)) {
                                seenFieldsThisMatch.add(fieldLabel);
                                row.sessionsSet.add(matchId);
                                row.legs += (Number.isFinite(matchLegs) && matchLegs > 0) ? matchLegs : 1;
                            }
                        }

                        anyModeHit = true;
                    }

                    if (anyModeHit) meta.afterMode++;

                    cursor.continue();
                };
            });
        } catch (e) {
            console.error("[AD Ext][ATC] loadAtcFieldAggFromIdb failed", e);
            return [];
        }
    }

    function renderAtcTableFields(panel, fieldAgg) {
        const body = panel.querySelector("#ad-ext-atc-table-target");
        if (!body) return;

        const allUnsorted = (Array.isArray(fieldAgg) ? fieldAgg : []).slice();

        let sortKey = String(cache?.filtersATC?.fieldSortKey || "hitPct");

        // Backward compat: früher hieß das in ATC "sessions", jetzt "legs"
        if (sortKey === "sessions") sortKey = "legs";
        const sortDir = String(cache?.filtersATC?.fieldSortDir || "desc");

        const all = sortATCFieldRows(allUnsorted, sortKey, sortDir);

        updateATCFieldSortIndicators(panel);

        if (!all.length) {
            body.innerHTML = `<tr><td colspan="5" style="opacity:.7; padding:10px 12px;">Keine Daten</td></tr>`;
            return;
        }

        body.innerHTML = all.map((t) => `
      <tr data-field="${escapeHtml(String(t.field || ""))}">
        <td>${escapeHtml(t.field)}</td>
        <td class="ad-ext-table-value-right">${fmtInt(t.legs ?? t.sessions ?? 0)}</td>
        <td class="ad-ext-table-value-right">${fmtInt(t.darts)}</td>
        <td class="ad-ext-table-value-right">${fmtInt(t.hits)}</td>
        <td class="ad-ext-table-value-right">${fmtPct(t.hits, t.darts)}</td>
      </tr>
    `).join("");
    }



    // =========================
    // Segment Training: sortierbare Target-Tabelle ("Targets (Aggregiert)")
    // =========================
    function stTargetKeyParts(label) {
        const s = String(label || "").trim();
        const m = s.match(/^([DST])\s*(\d+)/i);
        if (!m) return { grp: 9, num: 999, txt: s.toLowerCase() };
        const g = String(m[1] || "").toUpperCase();
        const grp = (g === "D") ? 0 : (g === "S") ? 1 : (g === "T") ? 2 : 9;
        const num = parseInt(m[2], 10);
        return { grp, num: Number.isFinite(num) ? num : 999, txt: s.toLowerCase() };
    }

    function stTargetSortValue(row, sortKey) {
        const k = String(sortKey || "hitPct");
        if (k === "target") return stTargetKeyParts(row?.target);
        if (k === "legs" || k === "sessions") return Number(row?.legs ?? row?.sessions) || 0;
        if (k === "darts") return Number(row?.darts) || 0;
        if (k === "hits") return Number(row?.hits) || 0;
        if (k === "hitPct") {
            const d = Number(row?.darts) || 0;
            const h = Number(row?.hits) || 0;
            return d > 0 ? (h / d) : NaN;
        }
        return Number(row?.hits) || 0;
    }

    function sortSTTargetRows(targetAgg, sortKey, sortDir) {
        const key = String(sortKey || "hitPct");
        const dir = (String(sortDir || "desc").toLowerCase() === "asc") ? 1 : -1;

        const arr = (Array.isArray(targetAgg) ? targetAgg : []).slice();

        arr.sort((a, b) => {
            if (key === "target") {
                const pa = stTargetSortValue(a, "target");
                const pb = stTargetSortValue(b, "target");
                if (pa.grp !== pb.grp) return dir * (pa.grp - pb.grp);
                if (pa.num !== pb.num) return dir * (pa.num - pb.num);
                const cmp = String(pa.txt).localeCompare(String(pb.txt), "de");
                if (cmp !== 0) return dir * cmp;
            } else {
                const va = Number(stTargetSortValue(a, key));
                const vb = Number(stTargetSortValue(b, key));
                const fa = Number.isFinite(va);
                const fb = Number.isFinite(vb);

                // NaN / unknown always at bottom
                if (fa && !fb) return -1;
                if (!fa && fb) return 1;

                if (fa && fb && va !== vb) return dir * (va - vb);
            }

            // fallback (stable-ish): Hit% desc, Sessions desc, Target asc
            const ar = (Number(a?.darts) || 0) > 0 ? (Number(a?.hits) || 0) / (Number(a?.darts) || 1) : -Infinity;
            const br = (Number(b?.darts) || 0) > 0 ? (Number(b?.hits) || 0) / (Number(b?.darts) || 1) : -Infinity;
            if (br !== ar) return br - ar;
            if ((Number(b?.legs ?? b?.sessions) || 0) !== (Number(a?.legs ?? a?.sessions) || 0)) return (Number(b?.legs ?? b?.sessions) || 0) - (Number(a?.legs ?? a?.sessions) || 0);
            return String(a?.target || "").localeCompare(String(b?.target || ""), "de");
        });

        return arr;
    }

    function updateSTTargetSortIndicators(panel) {
        const body = panel?.querySelector?.("#ad-ext-st-table-target");
        const table = body?.closest?.("table");
        if (!table) return;

        const key = String(cache?.filters?.targetSortKey || "hitPct");
        const dir = (String(cache?.filters?.targetSortDir || "desc").toLowerCase() === "asc") ? "asc" : "desc";

        const ths = table.querySelectorAll("th[data-sort-key]");
        for (const th of ths) {
            const k = th.getAttribute("data-sort-key");
            if (k === key) th.setAttribute("data-sort-dir", dir);
            else th.removeAttribute("data-sort-dir");
        }
    }

    function renderTableTargets(panel, targetAgg, limit = 10, selectedTarget = null) {
        const body = panel.querySelector("#ad-ext-st-table-target");
        if (!body) return;

        const allUnsorted = (Array.isArray(targetAgg) ? targetAgg : [])
        .filter((t) => t && t.target !== "DRandom" && t.target !== "SRandom")
        .slice();

        const sortKey = String(cache?.filters?.targetSortKey || "hitPct");
        const sortDir = String(cache?.filters?.targetSortDir || "desc");

        const all = sortSTTargetRows(allUnsorted, sortKey, sortDir);

        updateSTTargetSortIndicators(panel);

        let rows = all.slice(0, limit);

        // ensure selected row stays visible
        if (selectedTarget && !rows.some(r => r?.target === selectedTarget)) {
            const selRow = all.find(r => r?.target === selectedTarget);
            if (selRow) {
                rows = [selRow, ...rows.slice(0, Math.max(0, limit - 1))];
            }
        }

        if (!rows.length) {
            body.innerHTML = `<tr><td colspan="5" style="opacity:.7; padding:10px 12px;">Keine Daten</td></tr>`;
            return;
        }

        body.innerHTML = rows.map((t) => `
      <tr data-target="${escapeHtml(String(t.target || ""))}">
        <td>${escapeHtml(t.target)}</td>
        <td class="ad-ext-table-value-right">${fmtInt(t.legs ?? t.sessions ?? 0)}</td>
        <td class="ad-ext-table-value-right">${fmtInt(t.darts)}</td>
        <td class="ad-ext-table-value-right">${fmtInt(t.hits)}</td>
        <td class="ad-ext-table-value-right">${fmtPct(t.hits, t.darts)}</td>
      </tr>
    `).join("");
    }

    function renderSegmentCharts(panel, targetAgg, variantAgg) {
        const selectedTarget = cache?.filters?.selectedTarget || null;
        const segType = String(cache?.filters?.segmentType || "ALL").toUpperCase();

        const donutCanvas = panel.querySelector("#ad-ext-chart-donut");
        const donutLegend = panel.querySelector("#ad-ext-legend-donut");
        if (donutCanvas) {
            const base = Array.isArray(variantAgg) ? variantAgg : [];
            const items = base.map((x, i) => ({
                typeKey: String(x?.key || "").toUpperCase(),
                label: x.label,
                value: x.sessions,
                color: PALETTE[i % PALETTE.length],
                extra: { darts: x.darts, hits: x.hits, typeKey: String(x?.key || "").toUpperCase() }
            }));

            const total = items.reduce((a, x) => a + (Number(x.value) || 0), 0);

            const layout = drawDonutSvg(donutCanvas, items, {
                style: "outline",
                gapDeg: 7, // sichtbare Zwischenräume
                strokeWidth: 2,
                outlineFillAlpha: 0.20,
                rInnerFactor: 0.78,
                showCenterText: false,
                holeFill: false,
            });

            cache._st_layouts = cache._st_layouts || {};
            cache._st_layouts.donut = layout;

            const highlightType = (segType && segType !== "ALL") ? segType : null;
            const hiIdx = highlightType ? items.findIndex(it => it.typeKey === highlightType) : -1;

            // Highlight slice visually (SVG)
            const paths = donutCanvas.querySelectorAll?.("path[data-ad-slice]") || [];
            paths.forEach((p) => {
                const idx = Number(p.getAttribute("data-ad-slice"));
                const isHi = (hiIdx >= 0 && idx === hiIdx);
                p.style.opacity = (hiIdx >= 0) ? (isHi ? "1" : "0.35") : "1";
            });

            if (donutLegend) {
                const denom = total || 1;
                donutLegend.innerHTML = items.map((it, idx) => {
                    const pct = total ? (Number(it.value) * 100) / total : 0;
                    const isHi = (hiIdx >= 0 && idx === hiIdx);
                    const op = (hiIdx >= 0 && !isHi) ? 0.55 : 1;
                    return `
    <div class="ad-ext-legend-item" data-ad-st-type="${escapeHtml(it.typeKey || "")}" style="cursor:pointer; opacity:${op};">
      <span class="ad-ext-dot" style="background:${escapeHtml(it.color)};"></span>
      <span style="font-weight:900;">${escapeHtml(it.label)}</span>
      <span style="opacity:.78; font-weight:800;">${fmtInt(it.value)} (${pct.toFixed(1)}%)</span>
    </div>
  `;
                }).join("");
            }
        }

        const radarCanvas = panel.querySelector("#ad-ext-chart-radar");
        if (radarCanvas) {
            let topBySessions = (Array.isArray(targetAgg) ? targetAgg : [])
            .filter((x) => x && x.target !== "DRandom" && x.target !== "SRandom")
            .slice()
            .sort((a, b) => b.sessions - a.sessions);

            // keep selected target visible in radar (even if not in top 12)
            if (selectedTarget && !topBySessions.slice(0, 12).some(x => x.target === selectedTarget)) {
                const selRow = topBySessions.find(x => x.target === selectedTarget);
                if (selRow) {
                    topBySessions = [selRow, ...topBySessions.filter(x => x.target !== selectedTarget)];
                }
            }

            topBySessions = topBySessions.slice(0, 12);

            // Order radar axes like a real dartboard (clockwise, 20 at top)
            const prevHoverLabel = (() => {
                const i = cache?._st_radar_hoverIndex;
                const old = cache?._st_layouts?.radar;
                if (i === null || i === undefined) return null;
                if (!old || old.type !== "radar") return null;
                return old.labels?.[i] || null;
            })();

            const DARTBOARD_ORDER = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];
            const DARTBOARD_POS = (() => {
                const m = new Map();
                DARTBOARD_ORDER.forEach((n, i) => m.set(n, i));
                return m;
            })();
            const dartKey = (label) => {
                const s = String(label || "").trim();
                const m = s.match(/^([DST])\s*(\d{1,2})$/i);
                if (!m) return { pos: 999, bed: 9, txt: s.toLowerCase() };
                const bedCh = String(m[1] || "").toUpperCase();
                const num = parseInt(m[2], 10);
                const pos = (Number.isFinite(num) && DARTBOARD_POS.has(num)) ? (DARTBOARD_POS.get(num)) : 999;
                const bed = (bedCh === "D") ? 0 : (bedCh === "S") ? 1 : (bedCh === "T") ? 2 : 9;
                return { pos: Number.isFinite(pos) ? pos : 999, bed, txt: s.toLowerCase() };
            };

            topBySessions.sort((a, b) => {
                const ka = dartKey(a?.target);
                const kb = dartKey(b?.target);
                if (ka.pos !== kb.pos) return ka.pos - kb.pos;
                if (ka.bed !== kb.bed) return ka.bed - kb.bed;
                return String(a?.target || "").localeCompare(String(b?.target || ""), "de");
            });

            const labels = topBySessions.map((x) => x.target);
            const values = topBySessions.map((x) => x.darts > 0 ? (x.hits * 100) / x.darts : 0);

            if (prevHoverLabel) {
                const nh = labels.findIndex(l => l === prevHoverLabel);
                cache._st_radar_hoverIndex = (nh >= 0 ? nh : null);
            }

            if (cache._st_radar_hoverIndex !== null && (cache._st_radar_hoverIndex < 0 || cache._st_radar_hoverIndex >= labels.length)) {
                cache._st_radar_hoverIndex = null;
            }

            const selectedIndex = selectedTarget ? labels.findIndex(l => l === selectedTarget) : -1;
            cache._st_radar_selectedIndex = (selectedIndex >= 0 ? selectedIndex : null);

            const hi = (cache._st_radar_hoverIndex !== null && cache._st_radar_hoverIndex !== undefined)
            ? cache._st_radar_hoverIndex
            : cache._st_radar_selectedIndex;

            const layout = drawRadar(radarCanvas, labels, values, { highlightIndex: hi, autoScale: true });
            layout.dataList = topBySessions;

            cache._st_layouts = cache._st_layouts || {};
            cache._st_layouts.radar = layout;
        }

        const barCanvas = panel.querySelector("#ad-ext-chart-bar");
        if (barCanvas) {
            // Treffer je Target (Hits) als vertikale Balken (Top N):
            // Y-Achse = Anzahl Hits, X-Achse = Target (z.B. D8, D12, ...)
            // Auswahl: Top N nach Hits (Random-Targets ausgeschlossen), Anzeige sortiert D -> S -> T, Zahl aufsteigend
            const TOP_N = 10;

            const keyOf = (label) => {
                const s = String(label || "").trim();
                const m = s.match(/^([DST])\s*(\d+)/i);
                if (!m) return { grp: 9, num: 999, txt: s };
                const g = String(m[1] || "").toUpperCase();
                const grp = (g === "D") ? 0 : (g === "S") ? 1 : (g === "T") ? 2 : 9;
                const num = parseInt(m[2], 10);
                return { grp, num: Number.isFinite(num) ? num : 999, txt: s };
            };

            const allItems = (Array.isArray(targetAgg) ? targetAgg : [])
            .filter((x) => x && x.target !== "DRandom" && x.target !== "SRandom")
            .slice();

            // total hits across all targets (for tooltip share)
            const totalHitsAll = allItems.reduce((a, x) => a + (Number(x.hits) || 0), 0);

            // pick Top N by hits (desc)
            const byHits = allItems
            .slice()
            .sort((a, b) => {
                const ha = Number(a?.hits) || 0;
                const hb = Number(b?.hits) || 0;
                if (hb !== ha) return hb - ha;
                return String(a?.target || "").localeCompare(String(b?.target || ""), "de");
            });

            let picked = byHits.slice(0, TOP_N);

            // pin selected target if not in Top N
            if (selectedTarget) {
                const sel = allItems.find(x => String(x?.target || "") === String(selectedTarget));
                if (sel && !picked.some(x => String(x?.target || "") === String(selectedTarget))) {
                    picked = picked.slice(0, Math.max(0, TOP_N - 1));
                    picked.push(sel);
                }
            }

            // display order: D -> S -> T, then number asc
            picked = picked
            .slice()
            .sort((a, b) => {
                const ka = keyOf(a.target);
                const kb = keyOf(b.target);
                if (ka.grp !== kb.grp) return ka.grp - kb.grp;
                if (ka.num !== kb.num) return ka.num - kb.num;
                return ka.txt.localeCompare(kb.txt, "de");
            });

            const labels = picked.map((x) => x.target);
            const values = picked.map((x) => x.hits);

            const hi = selectedTarget ? labels.findIndex(l => l === selectedTarget) : -1;

            const layout = drawBarsVertical(barCanvas, labels, values, picked, {
                showCategoryLabels: true,
                showValueLabels: false,
                total: totalHitsAll,
                headroom: 0.10,
                highlightIndex: (hi >= 0 ? hi : null),
            });

            cache._st_layouts = cache._st_layouts || {};
            cache._st_layouts.bar = layout;

        }
    }

    function renderSegmentTraining(panel, sessions, filters, meta) {
        const selRangeST = panel.querySelector("#ad-ext-filter-daterange");
        updateRelativeDayOptions(selRangeST);

        // 1) base filter (dropdowns)
        const baseFiltered = filterSessions(sessions, filters);

        // 2) sanitize selection (if selected day/target not present anymore -> clear)
        const dayAggAll = aggregateByDay(baseFiltered);
        const targetAggAll = aggregateByTarget(baseFiltered);

        if (filters?.selectedDayKey && !dayAggAll.some(d => d?.dayKey === filters.selectedDayKey)) {
            filters.selectedDayKey = null;
        }
        if (filters?.selectedTarget && !targetAggAll.some(t => t?.target === filters.selectedTarget)) {
            filters.selectedTarget = null;
        }

        // 3) selection subset for KPIs + donut (AND across selections)
        let kpiSessions = baseFiltered;
        if (filters?.selectedDayKey) {
            const dk = filters.selectedDayKey;
            kpiSessions = kpiSessions.filter((s) => (s.dayKey || parseIsoDateToDayKey(s.createdAt)) === dk);
        }
        if (filters?.selectedTarget) {
            const t = filters.selectedTarget;
            kpiSessions = kpiSessions.filter((s) => String(s.target || "") === String(t));
        }

        const totalSessions = kpiSessions.length;
        const totalDarts = kpiSessions.reduce((a, s) => a + (s.darts || 0), 0);
        const totalHits = kpiSessions.reduce((a, s) => a + (s.hits || 0), 0);
        const totalPoints = kpiSessions.reduce((a, s) => a + (s.points || 0), 0);

        const totalDurationSec = kpiSessions.reduce((a, s) => a + (Number(s.durationSec) || 0), 0);
        const dayKeysSet = new Set(
            kpiSessions
            .map((s) => (s.dayKey || parseIsoDateToDayKey(s.createdAt) || "unknown"))
            .filter((k) => k && k !== "unknown")
        );
        const daysCount = dayKeysSet.size;

        setText(panel, "#ad-ext-st-kpi-sessions", fmtInt(totalSessions));
        setText(panel, "#ad-ext-st-kpi-time", totalDurationSec > 0 ? fmtHours(totalDurationSec) : "—");
        if (totalDurationSec > 0 && daysCount > 0) {
            setText(panel, "#ad-ext-st-kpi-time-sub", `Ø ${fmtMinPerLeg(totalDurationSec / daysCount)} pro Tag`);
        } else {
            setText(panel, "#ad-ext-st-kpi-time-sub", "—");
        }

        const avgDartsPerSession = totalSessions > 0 ? (totalDarts / totalSessions) : NaN;
        setText(panel, "#ad-ext-st-kpi-points", Number.isFinite(avgDartsPerSession) ? fmtDec(avgDartsPerSession, 1).replace(/\.0$/, "") : "—");
        setText(panel, "#ad-ext-st-kpi-hitrate", fmtPct(totalHits, totalDarts));

        // 4) cross-filtering like in X01:
        //    - Target chart/table can be narrowed by selected day
        //    - Day table can be narrowed by selected target
        let sessionsForTargets = baseFiltered;
        if (filters?.selectedDayKey) {
            const dk = filters.selectedDayKey;
            sessionsForTargets = sessionsForTargets.filter((s) => (s.dayKey || parseIsoDateToDayKey(s.createdAt)) === dk);
        }

        let sessionsForDays = baseFiltered;
        if (filters?.selectedTarget) {
            const t = filters.selectedTarget;
            sessionsForDays = sessionsForDays.filter((s) => String(s.target || "") === String(t));
        }

        const targetAgg = aggregateByTarget(sessionsForTargets);
        const dayAgg = aggregateByDay(sessionsForDays);
        const variantAgg = aggregateByVariant(kpiSessions);

        // Charts zuerst, dann Tabellen (Layout: KPIs → Charts → Tabellen)
        renderSegmentCharts(panel, targetAgg, variantAgg);

        renderTableDay(panel, dayAgg, 10, filters?.selectedDayKey || null);
        renderTableTargets(panel, targetAgg, 10, filters?.selectedTarget || null);

        applySelectedRowHighlightSegment(panel);

        const src = meta?.sourceText || "IndexedDB";
        setSourceLabel(panel, `Datenquelle: ${src} (${meta?.totalRows ?? "?"} Matches, ${fmtInt(meta?.segmentSessions ?? 0)} Segment Sessions, ${fmtInt(meta?.x01Matches ?? 0)} X01 Matches)`);
    }

    // =========================
    // X01: rendering + tooltips + top tables
    // =========================
    function fmtPairHtml(a, b) {
        const aa = fmtInt(a);
        const bb = fmtInt(b);
        return `<span class="ad-ext-pair"><span class="ad-ext-pair-a">${aa}</span><span class="ad-ext-pair-sep">–</span><span class="ad-ext-pair-b">${bb}</span></span>`;
    }

    function lastMatchesForCombo(matches, limit = 10) {
        const m = matches
        .slice()
        .sort((a, b) => {
            const ta = new Date(a.finishedAt || a.createdAt || 0).getTime();
            const tb = new Date(b.finishedAt || b.createdAt || 0).getTime();
            return tb - ta;
        })
        .slice(0, limit);

        return m.map(mt => ({
            date: germanDateFromIso(mt.finishedAt || mt.createdAt),
            lineup: mt.players.map(p => dispName(p.name)).join(", "),
            legs: mt.players.map(p => String(Number(mt.legsWon?.[Number(p.index)] ?? 0) || 0)).join("-"),
        }));
    }

    function tooltipHtmlLastMatches(list) {
        const title = `<div class="ad-ext-tooltip-title">Letzte 10 Spiele</div>`;
        if (!list?.length) return title + `<div style="opacity:.75;">Keine Matches</div>`;
        const lines = list.map(x => `
      <div class="ad-ext-tooltip-line">
        <div class="ad-ext-tooltip-date">${escapeHtml(x.date)}</div>
        <div class="ad-ext-tooltip-lineup" title="${escapeHtml(x.lineup)}">${escapeHtml(x.lineup)}</div>
        <div class="ad-ext-tooltip-legs">${escapeHtml(x.legs)}</div>
      </div>
    `).join("");
        return title + lines;
    }

    function setSelectOptions(selectEl, options, keepValue) {
        if (!selectEl) return;
        const prev = keepValue ? selectEl.value : null;

        selectEl.innerHTML = options.map((o) =>
                                         `<option value="${escapeHtml(o.value)}">${escapeHtml(o.label)}</option>`
    ).join("");

        const wants = keepValue ? prev : null;
        if (wants && Array.from(selectEl.options).some((op) => op.value === wants)) {
            selectEl.value = wants;
        } else if (options.some((o) => o.selected)) {
            const firstSel = options.find((o) => o.selected);
            selectEl.value = firstSel.value;
        } else {
            selectEl.selectedIndex = 0;
        }
    }

    function renderX01Kpis(panel, matches, selectedKeyOrNull) {
        const k = computeX01Kpis(matches, selectedKeyOrNull);

        setText(panel, "#ad-ext-x01-kpi-legs", fmtInt(k.legs));
        setText(panel, "#ad-ext-x01-kpi-legs-sub", `Spiele: ${fmtInt(k.matches)}`);

        const f9Main = Number.isFinite(k.first9Avg) ? fmtDec(k.first9Avg, 2) : "—";
        setText(panel, "#ad-ext-x01-kpi-f9", f9Main);
        const f9Ppd = k.first9Darts > 0 ? (k.first9Points / k.first9Darts) : NaN;
        setText(panel, "#ad-ext-x01-kpi-f9-sub", Number.isFinite(f9Ppd) ? `Pkt/Dart: ${fmtDec(f9Ppd, 2)}` : "Pkt/Dart: —");

        const avgDartsPerLeg = k.legs > 0 ? (k.darts / k.legs) : NaN;
        setText(panel, "#ad-ext-x01-kpi-points", Number.isFinite(avgDartsPerLeg) ? fmtDec(avgDartsPerLeg, 1).replace(/\.0$/, "") : "—");
        setText(panel, "#ad-ext-x01-kpi-points-sub", `Gesamt: ${fmtInt(k.darts)} Darts`);

        const coMain = Number.isFinite(k.coRatio) ? fmtPctFromRatio(k.coRatio) : "—";
        setText(panel, "#ad-ext-x01-kpi-checkout", coMain);
        setText(panel, "#ad-ext-x01-kpi-checkout-sub", (k.coAtt > 0 ? `Hits: ${fmtInt(k.coHit)} / ${fmtInt(k.coAtt)}` : "—"));

        const avgMain = Number.isFinite(k.avgOverall) ? fmtDec(k.avgOverall, 2) : "—";
        setText(panel, "#ad-ext-x01-kpi-avg", avgMain);
        setText(panel, "#ad-ext-x01-kpi-avg-sub", Number.isFinite(k.pointsPerDart) ? `Pkt/Dart: ${fmtDec(k.pointsPerDart, 2)}` : "Pkt/Dart: —");

        const totalTimeTxt = fmtHours(k.timeSec);
        setText(panel, "#ad-ext-x01-kpi-time", totalTimeTxt);
        if (k.legs > 0 && Number.isFinite(k.timeSec)) {
            const avgLegTxt = fmtMinPerLeg(k.timeSec / k.legs);
            setText(panel, "#ad-ext-x01-kpi-time-sub", `Ø ${avgLegTxt} pro Leg`);
        } else {
            setText(panel, "#ad-ext-x01-kpi-time-sub", "—");
        }
    }



    function computeBestAvgRecord(matches, _playerKeyOrNull) {
        // Rekord der aktuellen Combo: bestes "Spiel-AVG" (Durchschnitt über alle Spieler im Match)
        // Basis: Sum(score) & Sum(dartsThrown) aus perPlayerStats (wie AVG KPI: points*3/darts)
        let best = null;

        for (const m of (matches || [])) {
            if (!m) continue;

            const psArr = asArray(m.perPlayerStats || m.playersStats || m.playerStats);
            if (!psArr?.length) continue;

            let totalDarts = 0;
            let totalScore = 0;

            for (const ps of psArr) {
                const dt = Number(ps?.dartsThrown) || 0;
                const sc = Number(ps?.score) || 0;
                totalDarts += dt;
                totalScore += sc;
            }

            if (totalDarts <= 0) continue;

            const avg = (totalScore * 3) / totalDarts;
            if (!Number.isFinite(avg)) continue;

            const players = Array.isArray(m.players) ? m.players : [];
            const lineup = players.map(p => dispName(p?.name || p?.key || "")).filter(Boolean).join(" | ");
            const dateIso = m.finishedAt || m.createdAt || null;

            if (!best || avg > best.avg) {
                best = { matchId: m.matchId, dateIso, avg, lineup };
            }
        }

        return best;
    }


    function computeBestFirst9Record(matches) {
        // Rekord der aktuellen Combo: bestes "First 9 AVG" pro Match (über alle Spieler im Match)
        // Basis: first9PointsPerPlayer / first9DartsPerPlayer (aus Turn-Analyse)
        let best = null;

        for (const m of (matches || [])) {
            if (!m) continue;

            const f9PtsArr = asArray(m.first9PointsPerPlayer);
            const f9DartsArr = asArray(m.first9DartsPerPlayer);
            if (!f9PtsArr?.length || !f9DartsArr?.length) continue;

            let pts = 0;
            let darts = 0;
            const n = Math.max(f9PtsArr.length, f9DartsArr.length);

            for (let i = 0; i < n; i++) {
                pts += Number(f9PtsArr[i]) || 0;
                darts += Number(f9DartsArr[i]) || 0;
            }

            if (darts <= 0) continue;

            const f9Avg = (pts * 3) / darts;
            if (!Number.isFinite(f9Avg)) continue;

            const players = Array.isArray(m.players) ? m.players : [];
            const lineup = players.map(p => dispName(p?.name || p?.key || "")).filter(Boolean).join(" | ");
            const dateIso = m.finishedAt || m.createdAt || null;

            if (!best || f9Avg > best.f9Avg) {
                best = { matchId: m.matchId, dateIso, f9Avg, lineup, pts, darts };
            }
        }

        return best;
    }

    function computeWinsTable(matches) {
        // Hall of Fame: Most wins (all-time) within the selected combo (ignores date range)
        // Returns sorted array [{playerKey, playerName, wins, matches, winRate}]
        const winByKey = new Map();
        const matchByKey = new Map();
        const nameByKey = new Map();

        for (const m of (matches || [])) {
            if (!m) continue;

            const players = Array.isArray(m.players) ? m.players : [];
            if (!players.length) continue;

            for (const p of players) {
                const k = p?.key;
                if (!k) continue;
                nameByKey.set(k, dispName(p?.name || k));
                matchByKey.set(k, (matchByKey.get(k) || 0) + 1);
            }

            const wIdx = Number(m?.winnerIndex);
            if (!Number.isFinite(wIdx) || wIdx < 0) continue;

            const wp = players.find(pp => Number(pp?.index) === wIdx) || players[wIdx] || null;
            const wk = wp?.key;
            if (!wk) continue;

            winByKey.set(wk, (winByKey.get(wk) || 0) + 1);
        }

        const rows = [];
        for (const [k, mc] of matchByKey.entries()) {
            const w = winByKey.get(k) || 0;
            const rate = mc > 0 ? (w / mc) : 0;
            rows.push({
                playerKey: k,
                playerName: nameByKey.get(k) || k,
                wins: w,
                matches: mc,
                winRate: rate,
            });
        }

        rows.sort((a, b) => {
            if (b.wins !== a.wins) return b.wins - a.wins;
            if (b.winRate !== a.winRate) return b.winRate - a.winRate;
            if (b.matches !== a.matches) return b.matches - a.matches;
            return String(a.playerName).localeCompare(String(b.playerName));
        });

        return rows;
    }

    function computeBestPlayerAvgInGameTable(matches) {
        // Hall of Fame: Best player AVG in a single game (all-time) within the selected combo (ignores date range)
        // Returns sorted array [{playerKey, playerName, bestAvg, matchId, dateIso}]
        const bestByKey = new Map();
        const nameByKey = new Map();

        for (const m of (matches || [])) {
            if (!m) continue;

            const players = Array.isArray(m.players) ? m.players : [];
            if (!players.length) continue;

            const psArr = asArray(m.perPlayerStats || m.playersStats || m.playerStats);
            const dateIso = m.finishedAt || m.createdAt || null;

            for (let i = 0; i < players.length; i++) {
                const p = players[i] || {};
                const k = p.key;
                if (!k) continue;

                const idx = Number.isFinite(Number(p.index)) ? Number(p.index) : i;
                nameByKey.set(k, dispName(p.name || k));

                let st = psArr?.[idx] || null;
                if (!st && psArr?.length) {
                    st = psArr.find(s => (s?.playerKey && s.playerKey === k) || (s?.key && s.key === k) || (s?.id && s.id === k)) || null;
                }

                const score = Number(st?.score) || 0;
                const darts = Number(st?.dartsThrown) || 0;
                if (darts <= 0) continue;

                const avg = (score * 3) / darts;
                if (!Number.isFinite(avg)) continue;

                const cur = bestByKey.get(k);
                if (!cur || avg > cur.bestAvg) {
                    bestByKey.set(k, { playerKey: k, playerName: nameByKey.get(k) || k, bestAvg: avg, matchId: m.matchId || null, dateIso });
                }
            }
        }

        const rows = Array.from(bestByKey.values());
        rows.sort((a, b) => {
            if (b.bestAvg !== a.bestAvg) return b.bestAvg - a.bestAvg;
            return String(a.playerName).localeCompare(String(b.playerName));
        });
        return rows;
    }

    function computeBestPlayerFirst9InGameTable(matches) {
        // Hall of Fame: Best player First-9 AVG in a single game (all-time) within the selected combo (ignores date range)
        // Returns sorted array [{playerKey, playerName, bestF9Avg, matchId, dateIso}]
        const bestByKey = new Map();
        const nameByKey = new Map();

        for (const m of (matches || [])) {
            if (!m) continue;

            const players = Array.isArray(m.players) ? m.players : [];
            if (!players.length) continue;

            const f9PtsArr = asArray(m.first9PointsPerPlayer);
            const f9DartsArr = asArray(m.first9DartsPerPlayer);
            if (!f9PtsArr?.length || !f9DartsArr?.length) continue;

            const dateIso = m.finishedAt || m.createdAt || null;

            for (let i = 0; i < players.length; i++) {
                const p = players[i] || {};
                const k = p.key;
                if (!k) continue;

                const idx = Number.isFinite(Number(p.index)) ? Number(p.index) : i;
                nameByKey.set(k, dispName(p.name || k));

                const pts = Number(f9PtsArr[idx]) || 0;
                const darts = Number(f9DartsArr[idx]) || 0;
                if (darts <= 0) continue;

                const f9Avg = (pts * 3) / darts;
                if (!Number.isFinite(f9Avg)) continue;

                const cur = bestByKey.get(k);
                if (!cur || f9Avg > cur.bestF9Avg) {
                    bestByKey.set(k, { playerKey: k, playerName: nameByKey.get(k) || k, bestF9Avg: f9Avg, matchId: m.matchId || null, dateIso });
                }
            }
        }

        const rows = Array.from(bestByKey.values());
        rows.sort((a, b) => {
            if (b.bestF9Avg !== a.bestF9Avg) return b.bestF9Avg - a.bestF9Avg;
            return String(a.playerName).localeCompare(String(b.playerName));
        });
        return rows;
    }


    function computeLegWinsTable(matches) {
        // Hall of Fame: Most LEG wins (all-time) within the selected combo (ignores date range)
        // Returns sorted array [{playerKey, playerName, legWins, matches}]
        const legByKey = new Map();
        const matchByKey = new Map();
        const nameByKey = new Map();

        for (const m of (matches || [])) {
            if (!m) continue;

            const players = Array.isArray(m.players) ? m.players : [];
            if (!players.length) continue;

            // match count per player
            for (const p of players) {
                const k = p?.key;
                if (!k) continue;
                nameByKey.set(k, dispName(p?.name || k));
                matchByKey.set(k, (matchByKey.get(k) || 0) + 1);
            }

            const lw = asArray(m.legsWon);
            for (let i = 0; i < lw.length; i++) {
                const k = players[i]?.key;
                if (!k) continue;
                const v = Number(lw[i]) || 0;
                if (v) legByKey.set(k, (legByKey.get(k) || 0) + v);
            }
        }

        const rows = [];
        for (const [k, mc] of matchByKey.entries()) {
            const legWins = legByKey.get(k) || 0;
            rows.push({
                playerKey: k,
                playerName: nameByKey.get(k) || k,
                legWins,
                matches: mc,
            });
        }

        rows.sort((a, b) => {
            if (b.legWins !== a.legWins) return b.legWins - a.legWins;
            if (b.matches !== a.matches) return b.matches - a.matches;
            return String(a.playerName).localeCompare(String(b.playerName));
        });

        return rows;
    }

    function computeBestPlayerAvgInLegTable(matches) {
        // Hall of Fame: Best player AVG in a single LEG (all-time) within the selected combo (ignores date range)
        // Returns sorted array [{playerKey, playerName, bestLegAvg, matchId, dateIso}]
        const bestByKey = new Map();
        const nameByKey = new Map();

        for (const m of (matches || [])) {
            if (!m) continue;

            const players = Array.isArray(m.players) ? m.players : [];
            if (players.length) {
                for (const p of players) {
                    const k = p?.key;
                    if (k) nameByKey.set(k, dispName(p?.name || k));
                }
            }

            const lt = asArray(m.legTimeline);
            for (const leg of lt) {
                const dateIso = leg?.dateIso || m.finishedAt || m.createdAt || null;
                const per = leg?.perAvg;
                if (!per || typeof per.forEach !== "function") continue;

                per.forEach((avg, pk) => {
                    const v = Number(avg);
                    if (!Number.isFinite(v)) return;

                    const cur = bestByKey.get(pk);
                    if (!cur || v > cur.bestLegAvg) {
                        bestByKey.set(pk, {
                            playerKey: pk,
                            playerName: nameByKey.get(pk) || pk,
                            bestLegAvg: v,
                            matchId: m.matchId || null,
                            dateIso,
                        });
                    }
                });
            }
        }

        const rows = Array.from(bestByKey.values());
        rows.sort((a, b) => {
            if (b.bestLegAvg !== a.bestLegAvg) return b.bestLegAvg - a.bestLegAvg;
            return String(a.playerName).localeCompare(String(b.playerName));
        });
        return rows;
    }

    function computeBestPlayerFirst9InLegTable(matches) {
        // Hall of Fame: Best player First-9 AVG in a single LEG (all-time) within the selected combo (ignores date range)
        // Returns sorted array [{playerKey, playerName, bestLegF9Avg, matchId, dateIso}]
        const bestByKey = new Map();
        const nameByKey = new Map();

        for (const m of (matches || [])) {
            if (!m) continue;

            const players = Array.isArray(m.players) ? m.players : [];
            if (players.length) {
                for (const p of players) {
                    const k = p?.key;
                    if (k) nameByKey.set(k, dispName(p?.name || k));
                }
            }

            const lt = asArray(m.legTimeline);
            for (const leg of lt) {
                const dateIso = leg?.dateIso || m.finishedAt || m.createdAt || null;
                const per = leg?.perF9Avg;
                if (!per || typeof per.forEach !== "function") continue;

                per.forEach((f9avg, pk) => {
                    const v = Number(f9avg);
                    if (!Number.isFinite(v)) return;

                    const cur = bestByKey.get(pk);
                    if (!cur || v > cur.bestLegF9Avg) {
                        bestByKey.set(pk, {
                            playerKey: pk,
                            playerName: nameByKey.get(pk) || pk,
                            bestLegF9Avg: v,
                            matchId: m.matchId || null,
                            dateIso,
                        });
                    }
                });
            }
        }

        const rows = Array.from(bestByKey.values());
        rows.sort((a, b) => {
            if (b.bestLegF9Avg !== a.bestLegF9Avg) return b.bestLegF9Avg - a.bestLegF9Avg;
            return String(a.playerName).localeCompare(String(b.playerName));
        });
        return rows;
    }


    function computeBestHighOutInGameTable(matches) {
        // Hall of Fame: Best (highest) High Out in a single game (all-time) within the selected combo (ignores date range)
        // Returns sorted array [{playerKey, playerName, bestHighOut, matchId, dateIso}]
        const bestByKey = new Map();
        const nameByKey = new Map();

        for (const m of (matches || [])) {
            if (!m) continue;

            const players = Array.isArray(m.players) ? m.players : [];
            if (!players.length) continue;

            const coMaxArr = asArray(m.checkoutMaxPerPlayer);
            const dateIso = m.finishedAt || m.createdAt || null;

            for (let i = 0; i < players.length; i++) {
                const p = players[i] || {};
                const k = p.key;
                if (!k) continue;

                const idx = Number.isFinite(Number(p.index)) ? Number(p.index) : i;
                nameByKey.set(k, dispName(p.name || k));

                const ho = Number(coMaxArr[idx] ?? coMaxArr[i] ?? 0) || 0;
                if (ho <= 0) continue;

                const cur = bestByKey.get(k);
                if (!cur || ho > cur.bestHighOut) {
                    bestByKey.set(k, { playerKey: k, playerName: nameByKey.get(k) || k, bestHighOut: ho, matchId: m.matchId || null, dateIso });
                }
            }
        }

        const rows = Array.from(bestByKey.values());
        rows.sort((a, b) => {
            if (b.bestHighOut !== a.bestHighOut) return b.bestHighOut - a.bestHighOut;
            return String(a.playerName).localeCompare(String(b.playerName));
        });
        return rows;
    }

    function computeHighOutsCountTable(matches) {
        // Hall of Fame: Number of High Outs (all-time) within the selected combo (ignores date range)
        // High Out = checkout >= HIGH_OUT_MIN (counted per leg, if legStats are available)
        // Returns sorted array [{playerKey, playerName, highOuts}]
        const cntByKey = new Map();
        const nameByKey = new Map();

        for (const m of (matches || [])) {
            if (!m) continue;

            const players = Array.isArray(m.players) ? m.players : [];
            if (!players.length) continue;

            for (const p of players) {
                const k = p?.key;
                if (!k) continue;
                nameByKey.set(k, dispName(p?.name || k));
            }

            const cntArr = asArray(m.highOutCountPerPlayer);
            const coMaxArr = asArray(m.checkoutMaxPerPlayer);

            for (let i = 0; i < players.length; i++) {
                const k = players[i]?.key;
                if (!k) continue;
                const idx = Number.isFinite(Number(players[i]?.index)) ? Number(players[i].index) : i;

                let c = Number(cntArr[idx] ?? 0);
                if (!Number.isFinite(c) || c < 0) c = 0;

                // Fallback (older cached data without highOutCountPerPlayer): count at least 1 if max checkout qualifies
                if (c === 0) {
                    const ho = Number(coMaxArr[idx] ?? 0) || 0;
                    if (ho >= HIGH_OUT_MIN) c = 1;
                }

                if (c > 0) cntByKey.set(k, (cntByKey.get(k) || 0) + c);
            }
        }

        const rows = [];
        for (const [k, c] of cntByKey.entries()) {
            rows.push({ playerKey: k, playerName: nameByKey.get(k) || k, highOuts: c });
        }

        rows.sort((a, b) => {
            if (b.highOuts !== a.highOuts) return b.highOuts - a.highOuts;
            return String(a.playerName).localeCompare(String(b.playerName));
        });

        return rows;
    }

    function computeBestCheckoutQuotaInMatchTable(matches) {
        // Hall of Fame: Best checkout quota in a single match (all-time) within the selected combo (ignores date range)
        // Returns sorted array [{playerKey, playerName, bestCoRatio, coHit, coAtt, matchId, dateIso}]
        const bestByKey = new Map();
        const nameByKey = new Map();

        for (const m of (matches || [])) {
            if (!m) continue;

            const players = Array.isArray(m.players) ? m.players : [];
            if (!players.length) continue;

            const psArr = asArray(m.perPlayerStats || m.playersStats || m.playerStats);
            const dateIso = m.finishedAt || m.createdAt || null;

            for (let i = 0; i < players.length; i++) {
                const p = players[i] || {};
                const k = p.key;
                if (!k) continue;

                const idx = Number.isFinite(Number(p.index)) ? Number(p.index) : i;
                nameByKey.set(k, dispName(p.name || k));

                let st = psArr?.[idx] || null;
                if (!st && psArr?.length) {
                    st = psArr.find(s => (s?.playerKey && s.playerKey === k) || (s?.key && s.key === k) || (s?.id && s.id === k)) || null;
                }

                const att = Number(st?.checkouts) || 0;
                const hit = Number(st?.checkoutsHit) || 0;
                if (att <= 0) continue;

                const ratio = hit / att;
                if (!Number.isFinite(ratio)) continue;

                const cur = bestByKey.get(k);
                if (
                    !cur ||
                    ratio > cur.bestCoRatio ||
                    (ratio === cur.bestCoRatio && att > cur.coAtt) ||
                    (ratio === cur.bestCoRatio && att === cur.coAtt && hit > cur.coHit)
                ) {
                    bestByKey.set(k, {
                        playerKey: k,
                        playerName: nameByKey.get(k) || k,
                        bestCoRatio: ratio,
                        coHit: hit,
                        coAtt: att,
                        matchId: m.matchId || null,
                        dateIso,
                    });
                }
            }
        }

        const rows = Array.from(bestByKey.values());
        rows.sort((a, b) => {
            if (b.bestCoRatio !== a.bestCoRatio) return b.bestCoRatio - a.bestCoRatio;
            if (b.coAtt !== a.coAtt) return b.coAtt - a.coAtt;
            if (b.coHit !== a.coHit) return b.coHit - a.coHit;
            return String(a.playerName).localeCompare(String(b.playerName));
        });
        return rows;
    }





    function computeNPlusCountTable(matches, propName) {
        // Hall of Fame: Number of X+ scores (all-time) within the selected combo (ignores date range)
        // propName: e.g. "scores60PlusPerPlayer" (counts of turns/visits per match & player)
        // Returns sorted array [{playerKey, playerName, count}]
        const cntByKey = new Map();
        const nameByKey = new Map();

        for (const m of (matches || [])) {
            if (!m) continue;

            const players = Array.isArray(m.players) ? m.players : [];
            if (!players.length) continue;

            for (const p of players) {
                const k = p?.key;
                if (k) nameByKey.set(k, dispName(p?.name || k));
            }

            const arr = asArray(m?.[propName]);
            for (let i = 0; i < players.length; i++) {
                const k = players[i]?.key;
                if (!k) continue;

                const idx = Number.isFinite(Number(players[i]?.index)) ? Number(players[i].index) : i;

                let vv = Number(arr?.[idx] ?? arr?.[i] ?? 0) || 0;

                // PDC-Banding: 60+ soll nur 60–99 sein, 100+ nur 100–139, 140+ nur 140–169, 170+ nur 170–179, 180 exakt.
                // Die Match-Extraktion zählt diese Buckets inklusiv (>=). Für Hall of Fame leiten wir hier disjunkte Bänder ab.
                if (propName === "scores60PlusPerPlayer") {
                    const a100 = asArray(m?.scores100PlusPerPlayer);
                    vv -= (Number(a100?.[idx] ?? a100?.[i] ?? 0) || 0);
                } else if (propName === "scores100PlusPerPlayer") {
                    const a140 = asArray(m?.scores140PlusPerPlayer);
                    vv -= (Number(a140?.[idx] ?? a140?.[i] ?? 0) || 0);
                } else if (propName === "scores140PlusPerPlayer") {
                    const a170 = asArray(m?.scores170PlusPerPlayer);
                    vv -= (Number(a170?.[idx] ?? a170?.[i] ?? 0) || 0);
                } else if (propName === "scores170PlusPerPlayer") {
                    const a180 = asArray(m?.scores180PerPlayer);
                    vv -= (Number(a180?.[idx] ?? a180?.[i] ?? 0) || 0);
                }

                const v = Math.max(0, vv);
                if (v > 0) cntByKey.set(k, (cntByKey.get(k) || 0) + v);
            }
        }

        const rows = [];
        for (const [k, v] of cntByKey.entries()) {
            if (!v) continue;
            rows.push({ playerKey: k, playerName: nameByKey.get(k) || k, count: v });
        }

        rows.sort((a, b) => {
            if (b.count !== a.count) return b.count - a.count;
            return String(a.playerName).localeCompare(String(b.playerName));
        });

        return rows;
    }


    function computeLongestLegTable(matches) {
        // Hall of Fame: Longest LEG duration (winner only, all-time) within the selected combo (ignores date range)
        // Returns sorted array [{playerKey, playerName, bestLegSec}]
        const bestByKey = new Map();
        const nameByKey = new Map();

        for (const m of (matches || [])) {
            if (!m) continue;

            const players = Array.isArray(m.players) ? m.players : [];
            if (!players.length) continue;

            for (const p of players) {
                const k = p?.key;
                if (k) nameByKey.set(k, dispName(p?.name || k));
            }

            const arr = asArray(m.longestLegSecPerPlayer);
            for (let i = 0; i < players.length; i++) {
                const k = players[i]?.key;
                if (!k) continue;

                const idx = Number.isFinite(Number(players[i]?.index)) ? Number(players[i].index) : i;
                const sec = Number(arr?.[idx] ?? arr?.[i] ?? 0) || 0;
                if (sec <= 0) continue;

                const cur = bestByKey.get(k) || 0;
                if (sec > cur) bestByKey.set(k, sec);
            }
        }

        const rows = [];
        for (const [k, sec] of bestByKey.entries()) {
            rows.push({ playerKey: k, playerName: nameByKey.get(k) || k, bestLegSec: sec });
        }

        rows.sort((a, b) => {
            if (b.bestLegSec !== a.bestLegSec) return b.bestLegSec - a.bestLegSec;
            return String(a.playerName).localeCompare(String(b.playerName));
        });

        return rows;
    }

    function computeLongestGameRecord(matches) {
        // Hall of Fame: Longest GAME duration (all-time) within the selected combo (ignores date range)
        // Returns {matchId, dateIso, durationSec} or null
        let best = null;
        for (const m of (matches || [])) {
            if (!m) continue;
            const sec = Number(m.durationSec) || 0;
            if (!Number.isFinite(sec) || sec <= 0) continue;
            // sanity: ignore absurd durations (likely bad data)
            if (sec > 6 * 3600) continue;

            if (!best || sec > best.durationSec) {
                best = {
                    matchId: m.matchId,
                    dateIso: m.finishedAt || m.createdAt || null,
                    durationSec: sec,
                };
            }
        }
        return best;
    }

    function computeShortestGameRecord(matches) {
        // Hall of Fame: Shortest GAME duration (all-time) within the selected combo (ignores date range)
        // Returns {matchId, dateIso, durationSec} or null
        let best = null;
        for (const m of (matches || [])) {
            if (!m) continue;
            const sec = Number(m.durationSec) || 0;
            if (!Number.isFinite(sec) || sec <= 0) continue;
            if (sec > 6 * 3600) continue;

            if (!best || sec < best.durationSec) {
                best = {
                    matchId: m.matchId,
                    dateIso: m.finishedAt || m.createdAt || null,
                    durationSec: sec,
                };
            }
        }
        return best;
    }


    function renderX01HallOfFame(panel, hofMatches, _selectedComboKey, _opts) {
        const opts = _opts || {};
        const root = panel.querySelector(opts.rootSelector || "#ad-ext-x01-panel-hof");
        if (!root) return;

        const totalGames = Array.isArray(hofMatches) ? hofMatches.length : 0;

        const winsRows = computeWinsTable(hofMatches);
        const bestAvgRows = computeBestPlayerAvgInGameTable(hofMatches);
        const bestF9Rows = computeBestPlayerFirst9InGameTable(hofMatches);
        const legWinsRows = computeLegWinsTable(hofMatches);
        const bestLegAvgRows = computeBestPlayerAvgInLegTable(hofMatches);
        const bestLegF9Rows = computeBestPlayerFirst9InLegTable(hofMatches);

        const bestHighOutRows = computeBestHighOutInGameTable(hofMatches);
        const highOutCountRows = computeHighOutsCountTable(hofMatches);
        const bestCheckoutRows = computeBestCheckoutQuotaInMatchTable(hofMatches);

        // 60+/100+/140+/170+/180 counts (all-time, within selected combo)
        // NOTE: computeNPlusCountTable applies PDC banding (60–99, 100–139, 140–169, 170–179, 180).
        const score60Rows = computeNPlusCountTable(hofMatches, "scores60PlusPerPlayer");
        const score100Rows = computeNPlusCountTable(hofMatches, "scores100PlusPerPlayer");
        const score140Rows = computeNPlusCountTable(hofMatches, "scores140PlusPerPlayer");
        const score170Rows = computeNPlusCountTable(hofMatches, "scores170PlusPerPlayer");
        const score180Rows = computeNPlusCountTable(hofMatches, "scores180PerPlayer");

        // Exclude a specific player from ranking (optional: exclude a specific player from ranking)
        const excludeKey = opts.excludePlayerKey ? String(opts.excludePlayerKey) : null;
        const allowSet = (() => {
            const a = opts.playerKeyAllowSet;
            if (!a) return null;
            try {
                if (a instanceof Set) return a;
                return new Set(Array.isArray(a) ? a : [a]);
            } catch {
                return null;
            }
        })();

        const _filterRows = (rows) => {
            let out = rows || [];
            if (excludeKey) out = out.filter(r => String(r?.playerKey || "") !== excludeKey);
            if (allowSet) out = out.filter(r => allowSet.has(String(r?.playerKey || "")));
            return out;
        };

        const winsRowsF = _filterRows(winsRows);
        const bestAvgRowsF = _filterRows(bestAvgRows);
        const bestF9RowsF = _filterRows(bestF9Rows);
        const legWinsRowsF = _filterRows(legWinsRows);
        const bestLegAvgRowsF = _filterRows(bestLegAvgRows);
        const bestLegF9RowsF = _filterRows(bestLegF9Rows);
        const bestHighOutRowsF = _filterRows(bestHighOutRows);
        const highOutCountRowsF = _filterRows(highOutCountRows);
        const bestCheckoutRowsF = _filterRows(bestCheckoutRows);

        const score60RowsF = _filterRows(score60Rows);
        const score100RowsF = _filterRows(score100Rows);
        const score140RowsF = _filterRows(score140Rows);
        const score170RowsF = _filterRows(score170Rows);
        const score180RowsF = _filterRows(score180Rows);

        const longestGameRec = computeLongestGameRecord(hofMatches);
        const shortestGameRec = computeShortestGameRecord(hofMatches);


        const fmtDecComma = (n, digits = 2) => fmtDec(n, digits).replace(".", ",");
        const fmtPctComma = (r) => fmtPctFromRatio(r).replace(".", ",");

        const emptyCard = (title, subtitle, msg) => `
      <div class="ad-ext-card" style="padding:12px; height:100%; min-height:148px; display:flex; flex-direction:column;">
        <div class="ad-ext-card-title" style="margin:0 0 4px 0;">${title}</div>
        <div style="opacity:.72; font-size:12px; margin-bottom:10px;">${subtitle}</div>
        <div style="opacity:.7; padding:8px 10px;">${msg || "Keine Daten"}</div>
      </div>
    `;

        const mkLinesCard = (title, subtitle, linesHtml) => `
      <div class="ad-ext-card" style="padding:12px; height:100%; min-height:148px; display:flex; flex-direction:column;">
        <div class="ad-ext-card-title" style="margin:0 0 4px 0;">${title}</div>
        <div style="opacity:.72; font-size:12px; margin-bottom:10px;">${subtitle}</div>
        <div style="display:flex; flex-direction:column; gap:8px; margin-top:6px;">
          ${linesHtml}
        </div>
      </div>
    `;

        const line = (emoji, textLeft, isBold) => `
      <div style="display:flex; align-items:center; gap:10px;">
        <div style="font-size:16px; line-height:1;">${emoji}</div>
        <div style="font-weight:${isBold ? 900 : 400}; font-size:13px;">
          ${textLeft}
        </div>
      </div>
    `;

        // Hall of Fame: Hover tooltip on player rows (date + "Spiel ansehen")
        const lineTip = (emoji, textLeft, isBold, rec, kind) => {
            const owner = `hof:${kind}:${String(rec?.playerKey || "")}:${String(rec?.matchId || "")}`;
            const dateIso = String(rec?.dateIso || "");
            const matchId = rec?.matchId ? String(rec.matchId) : "";
            return `
          <div class="ad-ext-hof-tip" data-hof-owner="${escapeHtml(owner)}" data-hof-date="${escapeHtml(dateIso)}" data-hof-match="${escapeHtml(matchId)}"
               style="display:flex; align-items:center; gap:10px; cursor:default;">
            <div style="font-size:16px; line-height:1;">${emoji}</div>
            <div style="font-weight:${isBold ? 900 : 400}; font-size:13px;">
              ${textLeft}
            </div>
          </div>
        `;
    };

        const ensureTooltipOpenMatchDelegate = () => {
            const tipEl = tooltip();
            if (!tipEl) return;
            if (tipEl.dataset.adExtOpenMatchWired === "1") return;
            tipEl.dataset.adExtOpenMatchWired = "1";
            tipEl.addEventListener("click", (ev) => {
                const btn = ev.target?.closest?.("[data-ad-open-match]");
                if (!btn) return;
                const matchId = btn.getAttribute("data-ad-open-match");
                if (!matchId) return;
                ev.preventDefault();
                ev.stopPropagation();
                try {
                    window.open(MATCH_URL_PREFIX + encodeURIComponent(String(matchId)), "_blank", "noopener");
                } catch (e) { }
                tooltipHide();
            });
        };

        const wireHofTooltips = (rootEl) => {
            ensureTooltipOpenMatchDelegate();
            if (!rootEl) return;

            const tipEl = tooltip();
            const st = cache._hofTipState || (cache._hofTipState = { overAnchor: false, overTip: false, hideT: null });

            const scheduleHide = (owner) => {
                if (st.hideT) clearTimeout(st.hideT);
                st.hideT = setTimeout(() => {
                    const curOwner = String(tooltip()?.dataset?.pinnedOwner || "");
                    if (curOwner !== String(owner || "")) return;
                    if (!st.overAnchor && !st.overTip) tooltipHide();
                }, 110);
            };

            if (tipEl && tipEl.dataset.adExtHofTipWired !== "1") {
                tipEl.dataset.adExtHofTipWired = "1";
                tipEl.addEventListener("mouseenter", () => {
                    const owner = String(tipEl.dataset.pinnedOwner || "");
                    if (!owner.startsWith("hof:")) return;
                    st.overTip = true;
                    if (st.hideT) { clearTimeout(st.hideT); st.hideT = null; }
                });
                tipEl.addEventListener("mouseleave", () => {
                    const owner = String(tipEl.dataset.pinnedOwner || "");
                    if (!owner.startsWith("hof:")) return;
                    st.overTip = false;
                    scheduleHide(owner);
                });
            }

            rootEl.querySelectorAll(".ad-ext-hof-tip").forEach(el => {
                if (el.dataset.hofWired === "1") return;
                el.dataset.hofWired = "1";

                const owner = String(el.getAttribute("data-hof-owner") || "");
                const dateIso = String(el.getAttribute("data-hof-date") || "");
                const matchId = String(el.getAttribute("data-hof-match") || "");

                const show = () => {
                    st.overAnchor = true;
                    if (st.hideT) { clearTimeout(st.hideT); st.hideT = null; }

                    const dateStr = dateIso ? germanDateFromIso(dateIso) : "—";
                    const btn = matchId
                    ? `<button type="button" class="ad-ext-view-btn" data-ad-open-match="${escapeHtml(matchId)}">Spiel ansehen</button>`
                    : "";

                    const html = `
                  <div class="ad-ext-tooltip-record">
                    <div class="ad-ext-tooltip-recline">🏆 Rekord am <span class="ad-ext-tooltip-date">${escapeHtml(dateStr)}</span></div>
                    ${btn ? `<div class="ad-ext-tooltip-actions">${btn}</div>` : ``}
                  </div>
                `;

                    tooltipShow(null, html, { interactive: true, pinned: true, pinnedOwner: owner || "hof:unknown" });
                    tooltipMoveToRect(el.getBoundingClientRect());
                };

                el.addEventListener("mouseenter", show);
                el.addEventListener("mouseleave", () => {
                    st.overAnchor = false;
                    scheduleHide(owner);
                });
            });
        };
        // MOST GAME-WINS (Top 1-3)
        const mostWinsCard = (() => {
            const top1 = winsRowsF[0] || null;
            if (!top1) return emptyCard("MOST GAME-WINS", "Meiste Siege aller Zeiten", "Keine Daten für diese Combo");

            const top2 = winsRowsF[1] || null;
            const top3 = winsRowsF[2] || null;

            const l1 = line("🥇", `${escapeHtml(top1.playerName)} — ${fmtInt(top1.wins)}`, true);
            const l2 = top2 ? line("🥈", `${escapeHtml(top2.playerName)} — ${fmtInt(top2.wins)}`, false) : "";
            const l3 = top3 ? line("🥉", `${escapeHtml(top3.playerName)} — ${fmtInt(top3.wins)}`, false) : "";

            return mkLinesCard(
                "MOST GAME-WINS",
                `Meiste Siege aller Zeiten`,
                `${l1}${l2 || ""}${l3 || ""}`
        );
    })();

        // BEST AVERAGE IN A GAME (Top 1-3 players)
        const bestAvgCard = (() => {
            const top1 = bestAvgRowsF[0] || null;
            if (!top1) return emptyCard("BEST AVERAGE IN A GAME", "Bester Average in einem Spiel", "Keine Daten für diese Combo");

            const top2 = bestAvgRowsF[1] || null;
            const top3 = bestAvgRowsF[2] || null;

            const l1 = lineTip("🥇", `${escapeHtml(top1.playerName)} — ${escapeHtml(fmtDecComma(top1.bestAvg, 2))}`, true, top1, "avg");
            const l2 = top2 ? lineTip("🥈", `${escapeHtml(top2.playerName)} — ${escapeHtml(fmtDecComma(top2.bestAvg, 2))}`, false, top2, "avg") : "";
            const l3 = top3 ? lineTip("🥉", `${escapeHtml(top3.playerName)} — ${escapeHtml(fmtDecComma(top3.bestAvg, 2))}`, false, top3, "avg") : "";

            return mkLinesCard(
                "BEST AVERAGE IN A GAME",
                "Bester Average in einem Spiel",
                `${l1}${l2 || ""}${l3 || ""}`
        );
        })();

        // BEST FIRST-9-AVERAGE IN A GAME (Top 1-3 players)
        const bestF9Card = (() => {
            const top1 = bestF9RowsF[0] || null;
            if (!top1) return emptyCard("BEST FIRST-9-AVERAGE IN A GAME", "Bester Average mit den ersten 9 Darts", "Keine Daten für diese Combo");

            const top2 = bestF9RowsF[1] || null;
            const top3 = bestF9RowsF[2] || null;

            const l1 = lineTip("🥇", `${escapeHtml(top1.playerName)} — ${escapeHtml(fmtDecComma(top1.bestF9Avg, 2))}`, true, top1, "f9");
            const l2 = top2 ? lineTip("🥈", `${escapeHtml(top2.playerName)} — ${escapeHtml(fmtDecComma(top2.bestF9Avg, 2))}`, false, top2, "f9") : "";
            const l3 = top3 ? lineTip("🥉", `${escapeHtml(top3.playerName)} — ${escapeHtml(fmtDecComma(top3.bestF9Avg, 2))}`, false, top3, "f9") : "";

            return mkLinesCard(
                "BEST FIRST-9-AVERAGE IN A GAME",
                "Bester Average mit den ersten 9 Darts",
                `${l1}${l2 || ""}${l3 || ""}`
        );
        })();


        // MOST LEG WINS (Top 1-3)
        const mostLegWinsCard = (() => {
            const top1 = legWinsRowsF[0] || null;
            if (!top1) return emptyCard("MOST LEG WINS", "Meiste Leg Siege aller Zeiten", "Keine Daten für diese Combo");

            const top2 = legWinsRowsF[1] || null;
            const top3 = legWinsRowsF[2] || null;

            const l1 = line("🥇", `${escapeHtml(top1.playerName)} — ${fmtInt(top1.legWins)}`, true);
            const l2 = top2 ? line("🥈", `${escapeHtml(top2.playerName)} — ${fmtInt(top2.legWins)}`, false) : "";
            const l3 = top3 ? line("🥉", `${escapeHtml(top3.playerName)} — ${fmtInt(top3.legWins)}`, false) : "";

            return mkLinesCard(
                "MOST LEG WINS",
                `Meiste Leg Siege aller Zeiten`,
                `${l1}${l2 || ""}${l3 || ""}`
        );
        })();

        // BEST AVERAGE IN A LEG (Top 1-3)
        const bestAvgLegCard = (() => {
            const top1 = bestLegAvgRowsF[0] || null;
            if (!top1) return emptyCard("BEST AVERAGE IN A LEG", "Bester Average in einem Leg", "Keine Daten für diese Combo");

            const top2 = bestLegAvgRowsF[1] || null;
            const top3 = bestLegAvgRowsF[2] || null;

            const l1 = lineTip("🥇", `${escapeHtml(top1.playerName)} — ${escapeHtml(fmtDecComma(top1.bestLegAvg, 2))}`, true, top1, "legavg");
            const l2 = top2 ? lineTip("🥈", `${escapeHtml(top2.playerName)} — ${escapeHtml(fmtDecComma(top2.bestLegAvg, 2))}`, false, top2, "legavg") : "";
            const l3 = top3 ? lineTip("🥉", `${escapeHtml(top3.playerName)} — ${escapeHtml(fmtDecComma(top3.bestLegAvg, 2))}`, false, top3, "legavg") : "";

            return mkLinesCard(
                "BEST AVERAGE IN A LEG",
                "Bester Average in einem Leg",
                `${l1}${l2 || ""}${l3 || ""}`
        );
        })();

        // BEST FIRST-9-AVERAGE IN A LEG (Top 1-3)
        const bestF9LegCard = (() => {
            const top1 = bestLegF9RowsF[0] || null;
            if (!top1) return emptyCard("BEST FIRST-9-AVERAGE IN A LEG", "Bester Average mit den ersten 9 Darts in einem Leg", "Keine Daten für diese Combo");

            const top2 = bestLegF9RowsF[1] || null;
            const top3 = bestLegF9RowsF[2] || null;

            const l1 = lineTip("🥇", `${escapeHtml(top1.playerName)} — ${escapeHtml(fmtDecComma(top1.bestLegF9Avg, 2))}`, true, top1, "legf9");
            const l2 = top2 ? lineTip("🥈", `${escapeHtml(top2.playerName)} — ${escapeHtml(fmtDecComma(top2.bestLegF9Avg, 2))}`, false, top2, "legf9") : "";
            const l3 = top3 ? lineTip("🥉", `${escapeHtml(top3.playerName)} — ${escapeHtml(fmtDecComma(top3.bestLegF9Avg, 2))}`, false, top3, "legf9") : "";

            return mkLinesCard(
                "BEST FIRST-9-AVERAGE IN A LEG",
                "Bester Average mit den ersten 9 Darts in einem Leg",
                `${l1}${l2 || ""}${l3 || ""}`
        );
        })();

        // BEST HIGH OUT (Top 1-3)
        const bestHighOutCard = (() => {
            const top1 = bestHighOutRowsF[0] || null;
            if (!top1) return emptyCard("BEST HIGH OUT", "Höchster High Out in einem Spiel", "Keine Daten für diese Combo");

            const top2 = bestHighOutRowsF[1] || null;
            const top3 = bestHighOutRowsF[2] || null;

            const l1 = lineTip("🥇", `${escapeHtml(top1.playerName)} — ${fmtInt(top1.bestHighOut)}`, true, top1, "ho");
            const l2 = top2 ? lineTip("🥈", `${escapeHtml(top2.playerName)} — ${fmtInt(top2.bestHighOut)}`, false, top2, "ho") : "";
            const l3 = top3 ? lineTip("🥉", `${escapeHtml(top3.playerName)} — ${fmtInt(top3.bestHighOut)}`, false, top3, "ho") : "";

            return mkLinesCard(
                "BEST HIGH OUT",
                "Höchster High Out in einem Spiel",
                `${l1}${l2 || ""}${l3 || ""}`
    );
    })();

        // NUMBER OF HIGH OUTS (Top 1-3)
        const highOutsCountCard = (() => {
            const top1 = highOutCountRowsF[0] || null;
            if (!top1) return emptyCard("NUMBER OF HIGH OUTS", `Anzahl der High Outs aller Zeiten`, "Keine Daten für diese Combo");

            const top2 = highOutCountRowsF[1] || null;
            const top3 = highOutCountRowsF[2] || null;

            const l1 = line("🥇", `${escapeHtml(top1.playerName)} — ${fmtInt(top1.highOuts)}`, true);
            const l2 = top2 ? line("🥈", `${escapeHtml(top2.playerName)} — ${fmtInt(top2.highOuts)}`, false) : "";
            const l3 = top3 ? line("🥉", `${escapeHtml(top3.playerName)} — ${fmtInt(top3.highOuts)}`, false) : "";

            return mkLinesCard(
                "NUMBER OF HIGH OUTS",
                `Anzahl der High Outs aller Zeiten`,
                `${l1}${l2 || ""}${l3 || ""}`
    );
        })();

        // BEST CHECKOUT QUOTE IN % (Top 1-3)
        const bestCheckoutQuotaCard = (() => {
            const top1 = bestCheckoutRowsF[0] || null;
            if (!top1) return emptyCard("BEST CHECKOUT QUOTE IN %", "Beste Checkoutquote in einem Match", "Keine Daten für diese Combo");

            const top2 = bestCheckoutRowsF[1] || null;
            const top3 = bestCheckoutRowsF[2] || null;

            const fmtLine = (r) => {
                const pct = (Number(r?.bestCoRatio) || 0) * 100;
                const pctTxt = Number.isFinite(pct) ? fmtDecComma(pct, 1) : "—";
                return `${escapeHtml(r.playerName)} — ${escapeHtml(pctTxt)}`;
            };

            const l1 = lineTip("🥇", fmtLine(top1), true, top1, "coq");
            const l2 = top2 ? lineTip("🥈", fmtLine(top2), false, top2, "coq") : "";
            const l3 = top3 ? lineTip("🥉", fmtLine(top3), false, top3, "coq") : "";

            return mkLinesCard(
                "BEST CHECKOUT QUOTE IN %",
                "Beste Checkoutquote in einem Match",
                `${l1}${l2 || ""}${l3 || ""}`
    );
        })();



        // NUMBER OF 60+ (Top 1-3)
        const n60Card = (() => {
            const top1 = score60RowsF[0] || null;
            if (!top1) return emptyCard("NUMBER OF 60+", `Anzahl der geworfenen 60+ (60–99) aller Zeiten`, "Keine Daten für diese Combo");

            const top2 = score60RowsF[1] || null;
            const top3 = score60RowsF[2] || null;

            const l1 = line("🥇", `${escapeHtml(top1.playerName)} — ${fmtInt(top1.count)}`, true);
            const l2 = top2 ? line("🥈", `${escapeHtml(top2.playerName)} — ${fmtInt(top2.count)}`, false) : "";
            const l3 = top3 ? line("🥉", `${escapeHtml(top3.playerName)} — ${fmtInt(top3.count)}`, false) : "";

            return mkLinesCard(
                "NUMBER OF 60+",
                `Anzahl der geworfenen 60+ (60–99) aller Zeiten`,
                `${l1}${l2 || ""}${l3 || ""}`
        );
    })();

        // NUMBER OF 100+ (Top 1-3)
        const n100Card = (() => {
            const top1 = score100RowsF[0] || null;
            if (!top1) return emptyCard("NUMBER OF 100+", `Anzahl der geworfenen 100+ (100–139) aller Zeiten`, "Keine Daten für diese Combo");

            const top2 = score100RowsF[1] || null;
            const top3 = score100RowsF[2] || null;

            const l1 = line("🥇", `${escapeHtml(top1.playerName)} — ${fmtInt(top1.count)}`, true);
            const l2 = top2 ? line("🥈", `${escapeHtml(top2.playerName)} — ${fmtInt(top2.count)}`, false) : "";
            const l3 = top3 ? line("🥉", `${escapeHtml(top3.playerName)} — ${fmtInt(top3.count)}`, false) : "";

            return mkLinesCard(
                "NUMBER OF 100+",
                `Anzahl der geworfenen 100+ (100–139) aller Zeiten`,
                `${l1}${l2 || ""}${l3 || ""}`
        );
        })();

        // NUMBER OF 140+ (Top 1-3)
        const n140Card = (() => {
            const top1 = score140RowsF[0] || null;
            if (!top1) return emptyCard("NUMBER OF 140+", `Anzahl der geworfenen 140+ (140–169) aller Zeiten`, "Keine Daten für diese Combo");

            const top2 = score140RowsF[1] || null;
            const top3 = score140RowsF[2] || null;

            const l1 = line("🥇", `${escapeHtml(top1.playerName)} — ${fmtInt(top1.count)}`, true);
            const l2 = top2 ? line("🥈", `${escapeHtml(top2.playerName)} — ${fmtInt(top2.count)}`, false) : "";
            const l3 = top3 ? line("🥉", `${escapeHtml(top3.playerName)} — ${fmtInt(top3.count)}`, false) : "";

            return mkLinesCard(
                "NUMBER OF 140+",
                `Anzahl der geworfenen 140+ (140–169) aller Zeiten`,
                `${l1}${l2 || ""}${l3 || ""}`
        );
        })();

        // NUMBERS OF 170+ (Top 1-3)
        const n170Card = (() => {
            const top1 = score170RowsF[0] || null;
            if (!top1) return emptyCard("NUMBERS OF 170+", `Anzahl der geworfenen 170+ (170–179) aller Zeiten`, "Keine Daten für diese Combo");

            const top2 = score170RowsF[1] || null;
            const top3 = score170RowsF[2] || null;

            const l1 = line("🥇", `${escapeHtml(top1.playerName)} — ${fmtInt(top1.count)}`, true);
            const l2 = top2 ? line("🥈", `${escapeHtml(top2.playerName)} — ${fmtInt(top2.count)}`, false) : "";
            const l3 = top3 ? line("🥉", `${escapeHtml(top3.playerName)} — ${fmtInt(top3.count)}`, false) : "";

            return mkLinesCard(
                "NUMBERS OF 170+",
                `Anzahl der geworfenen 170+ (170–179) aller Zeiten`,
                `${l1}${l2 || ""}${l3 || ""}`
        );
        })();

        // NUMBERS OF 180 (Top 1-3)
        const n180Card = (() => {
            const top1 = score180RowsF[0] || null;
            if (!top1) return emptyCard("NUMBERS OF 180", `Anzahl der geworfenen 180 aller Zeiten`, "Keine Daten für diese Combo");

            const top2 = score180RowsF[1] || null;
            const top3 = score180RowsF[2] || null;

            const l1 = line("🥇", `${escapeHtml(top1.playerName)} — ${fmtInt(top1.count)}`, true);
            const l2 = top2 ? line("🥈", `${escapeHtml(top2.playerName)} — ${fmtInt(top2.count)}`, false) : "";
            const l3 = top3 ? line("🥉", `${escapeHtml(top3.playerName)} — ${fmtInt(top3.count)}`, false) : "";

            return mkLinesCard(
                "NUMBERS OF 180",
                `Anzahl der geworfenen 180 aller Zeiten`,
                `${l1}${l2 || ""}${l3 || ""}`
        );
        })();

        // LONGEST & SHORTEST GAME (Combo, Top 1/Top 1)
        const longestShortestGameCard = (() => {
            const recLong = longestGameRec || null;
            const recShort = shortestGameRec || null;

            if (!recLong && !recShort) {
                return emptyCard("LONGEST & SHORTEST GAME", "Wie lange ging das längste / kürzeste Spiel?", "Keine Daten für diese Combo");
            }

            const fmtMin = (sec) => {
                const v = (Number(sec) || 0) / 60;
                if (!Number.isFinite(v) || v <= 0) return "—";
                const r = Math.round(v * 10) / 10;
                return fmtDecComma(r, 1).replace(/,0$/, "");
            };

            const mkNum = (rec, kind) => {
                const value = rec ? fmtMin(rec.durationSec) : "—";
                if (!rec || !rec.matchId) {
                    return `<span style="font-weight:900; font-size:24px; line-height:1;">${escapeHtml(value)}</span>`;
                }
                const owner = `hof:${kind}::${String(rec.matchId || "")}`;
                const dateIso = String(rec.dateIso || "");
                const matchId = String(rec.matchId || "");
                return `
              <span class="ad-ext-hof-tip"
                    data-hof-owner="${escapeHtml(owner)}"
                    data-hof-date="${escapeHtml(dateIso)}"
                    data-hof-match="${escapeHtml(matchId)}"
                    style="font-weight:900; font-size:24px; line-height:1; cursor:default;">
                ${escapeHtml(value)}
              </span>
            `;
        };

        const lineHtml = `
          <div style="display:flex; justify-content:flex-start; align-items:center; gap:10px; padding:6px 0;">
            ${mkNum(recLong, "LONGEST_GAME")}
            <span style="opacity:.65; font-weight:900; font-size:22px; line-height:1;">/</span>
            ${mkNum(recShort, "SHORTEST_GAME")}
          </div>
        `;

        return mkLinesCard(
            "LONGEST & SHORTEST GAME",
            `Längstes / kürzestes Match`,
            lineHtml
        );
    })();

        root.innerHTML = `
      <div class="ad-ext-kpi-grid ad-ext-kpi-grid--x01 ad-ext-hof-grid" style="margin-top:0;">
        <div>${mostWinsCard}</div>
        <div>${bestAvgCard}</div>
        <div>${bestF9Card}</div>

        <div>${mostLegWinsCard}</div>
        <div>${bestAvgLegCard}</div>
        <div>${bestF9LegCard}</div>

        <div>${bestHighOutCard}</div>
        <div>${highOutsCountCard}</div>
        <div>${bestCheckoutQuotaCard}</div>

        <div>${n60Card}</div>
        <div>${n100Card}</div>
        <div>${n140Card}</div>

        <div>${n170Card}</div>
        <div>${n180Card}</div>
        <div>${longestShortestGameCard}</div>
      </div>
    `;


        wireHofTooltips(root);
    }

    function applySelectedRowHighlightAll
    (panel) {
        const sel = cache.filtersX01.kpiSelectedKey || null;
        panel.querySelectorAll("#ad-ext-view-x01 tr[data-player-key]").forEach(tr => {
            tr.classList.toggle("ad-ext-row--selected", !!sel && tr.getAttribute("data-player-key") === sel);
        });
    }

    function computeTop10Legs(filteredMatches) {
        const rows = [];
        for (const m of filteredMatches) {
            for (const lr of asArray(m.legWinners)) {
                if (!lr?.playerKey) continue;
                if (!Number.isFinite(Number(lr.darts)) || Number(lr.darts) <= 0) continue;
                rows.push({
                    matchId: m.matchId,
                    dateIso: lr.dateIso || m.finishedAt || m.createdAt,
                    playerKey: lr.playerKey,
                    playerName: dispName(lr.playerName),
                    darts: Number(lr.darts) || 0,
                    avg: Number(lr.avg) || 0,
                });
            }
        }
        rows.sort((a, b) => {
            if (b.avg !== a.avg) return b.avg - a.avg;
            if (a.darts !== b.darts) return a.darts - b.darts;
            const ta = new Date(a.dateIso || 0).getTime();
            const tb = new Date(b.dateIso || 0).getTime();
            return tb - ta;
        });
        return rows.slice(0, 10);
    }

    function computeTop10Checkout(filteredMatches) {
        const rows = [];
        for (const m of filteredMatches) {
            const dateIso = m.finishedAt || m.createdAt;
            const checkoutMax = asArray(m.checkoutMaxPerPlayer);
            for (const p of m.players) {
                const idx = Number(p.index);
                if (!Number.isFinite(idx) || idx < 0) continue;
                const co = Number(checkoutMax[idx] ?? 0) || 0;
                if (co <= 0) continue;

                const ps = m.perPlayerStats?.[idx] || {};
                const dt = Number(ps.dartsThrown) || 0;
                const sc = Number(ps.score) || 0;
                const avg = (ps.average != null && Number.isFinite(Number(ps.average)))
                ? Number(ps.average)
                : (dt > 0 ? (sc * 3) / dt : 0);

                rows.push({
                    matchId: m.matchId,
                    dateIso,
                    playerKey: p.key,
                    playerName: dispName(p.name),
                    checkout: co,
                    avg,
                });
            }
        }
        rows.sort((a, b) => {
            if (b.checkout !== a.checkout) return b.checkout - a.checkout;
            if (b.avg !== a.avg) return b.avg - a.avg;
            const ta = new Date(a.dateIso || 0).getTime();
            const tb = new Date(b.dateIso || 0).getTime();
            return tb - ta;
        });
        return rows.slice(0, 10);
    }

    function renderTopTables(panel, filteredMatches) {
        const topLegsBody = panel.querySelector("#ad-ext-x01-toplegs-body");
        const topCheckoutBody = panel.querySelector("#ad-ext-x01-topcheckout-body");

        const topLegs = computeTop10Legs(filteredMatches);
        const topCo = computeTop10Checkout(filteredMatches);

        if (topLegsBody) {
            if (!topLegs.length) {
                topLegsBody.innerHTML = `<tr><td colspan="6" style="opacity:.7; padding:10px 12px;">Keine Daten</td></tr>`;
            } else {
                topLegsBody.innerHTML = topLegs.map((r, i) => `
          <tr data-player-key="${escapeHtml(r.playerKey)}">
            <td class="ad-ext-table-value-right">${i + 1}</td>
            <td class="ad-ext-td-player" title="${escapeHtml(r.playerName)}">${escapeHtml(r.playerName)}</td>
            <td class="ad-ext-table-value-right">${fmtInt(r.darts)}</td>
            <td class="ad-ext-table-value-right">${fmtDec(r.avg, 2)}</td>
            <td class="ad-ext-table-value-right">${escapeHtml(germanDateFromIso(r.dateIso))}</td>
            <td class="ad-ext-table-value-right">
              <a class="ad-ext-view-btn" data-no-rowclick="1" href="${escapeHtml(matchUrl(r.matchId))}" target="_blank" rel="noopener noreferrer">Spiel ansehen</a>
            </td>
          </tr>
        `).join("");
            }
        }

        if (topCheckoutBody) {
            if (!topCo.length) {
                topCheckoutBody.innerHTML = `<tr><td colspan="6" style="opacity:.7; padding:10px 12px;">Keine Daten</td></tr>`;
            } else {
                topCheckoutBody.innerHTML = topCo.map((r, i) => `
          <tr data-player-key="${escapeHtml(r.playerKey)}">
            <td class="ad-ext-table-value-right">${i + 1}</td>
            <td class="ad-ext-td-player" title="${escapeHtml(r.playerName)}">${escapeHtml(r.playerName)}</td>
            <td class="ad-ext-table-value-right">${fmtInt(r.checkout)}</td>
            <td class="ad-ext-table-value-right">${fmtDec(r.avg, 2)}</td>
            <td class="ad-ext-table-value-right">${escapeHtml(germanDateFromIso(r.dateIso))}</td>
            <td class="ad-ext-table-value-right">
              <a class="ad-ext-view-btn" data-no-rowclick="1" href="${escapeHtml(matchUrl(r.matchId))}" target="_blank" rel="noopener noreferrer">Spiel ansehen</a>
            </td>
          </tr>
        `).join("");
            }
        }
    }

    function renderWeakDoubles(panel, tbodyEl, fromWeekKey, toWeekKey) {
        const tbody = tbodyEl || (panel ? panel.querySelector("#ad-ext-insights-weakdoubles-body") : null);
        if (!tbody) return;

        if (!cache || !cache.loaded) {
            tbody.innerHTML = `<tr><td colspan="5" style="opacity:.7; padding:10px 12px;">—</td></tr>`;
            return;
        }

        const isDoubleTarget = (raw) => {
            const t = String(raw || "").trim().toUpperCase();
            if (t === "DB" || t === "D25") return true;
            return /^D(?:[1-9]|1\d|20)$/.test(t);
        };

        let rows = Array.isArray(cache.sessions) ? cache.sessions.slice() : [];

        // Date filter: use Training Insights week window (fromWeekKey..toWeekKey)
        const fromWk = String(fromWeekKey || "");
        const toWk = String(toWeekKey || "");
        const toEndExcl = (() => {
            const dt = parseDayKeyToLocalDate(toWk);
            return dt ? dayKeyFromLocalDate(addDaysLocal(dt, 7)) : "";
        })();

        if (fromWk || toWk) {
            rows = rows.filter((s) => {
                const dk = s.dayKey || (s.dayKey = (parseIsoDateToDayKey(s.createdAt) || parseIsoDateToDayKey(s.finishedAt)));
                const x = String(dk || "");
                if (!x) return false;
                if (fromWk && x < fromWk) return false;
                if (toEndExcl && x >= toEndExcl) return false;
                return true;
            });
        }

        // Mode filter: Segment Training – Double
        rows = rows.filter((s) => {
            const mode = String(s.mode || "").toLowerCase();
            const tgt = String(s.target || "").trim().toUpperCase();
            return mode.startsWith("double") || tgt.startsWith("D") || tgt === "DB" || tgt === "D25";
        });

        const agg = new Map();
        for (const s of rows) {
            const tgt = String(s.target || "").trim().toUpperCase();
            if (!isDoubleTarget(tgt)) continue;
            if (!agg.has(tgt)) agg.set(tgt, { target: tgt, sessions: 0, darts: 0, hits: 0 });
            const rec = agg.get(tgt);
            rec.sessions += 1;
            rec.darts += Number(s.darts) || 0;
            rec.hits += Number(s.hits) || 0;
        }

        const items = Array.from(agg.values()).map((r) => {
            const hitPct = (Number(r.darts) || 0) > 0 ? (Number(r.hits) || 0) / (Number(r.darts) || 1) : NaN;
            return { ...r, hitPct };
        });

        items.sort((a, b) => {
            const ap = Number.isFinite(a.hitPct) ? a.hitPct : 1;
            const bp = Number.isFinite(b.hitPct) ? b.hitPct : 1;
            if (ap !== bp) return ap - bp;
            if ((Number(b.darts) || 0) !== (Number(a.darts) || 0)) return (Number(b.darts) || 0) - (Number(a.darts) || 0);
            return String(a.target).localeCompare(String(b.target));
        });

        const top = items.slice(0, 10);
        if (!top.length) {
            tbody.innerHTML = `<tr><td colspan="5" style="opacity:.7; padding:10px 12px;">Keine Daten im Zeitraum.</td></tr>`;
            return;
        }

        tbody.innerHTML = top.map((r) => {
            const pctTxt = Number.isFinite(r.hitPct) ? `${(r.hitPct * 100).toFixed(1)}%` : "—";
            return `
          <tr>
            <td style="font-weight:900;">${escapeHtml(r.target)}</td>
            <td class="ad-ext-table-value-right">${fmtInt(r.sessions)}</td>
            <td class="ad-ext-table-value-right">${fmtInt(r.darts)}</td>
            <td class="ad-ext-table-value-right">${fmtInt(r.hits)}</td>
            <td class="ad-ext-table-value-right">${pctTxt}</td>
          </tr>
        `;
        }).join("");
    }

    function renderX01(panel) {
        syncX01SubPanels(panel);
        const activeSubPanel = String(cache.filtersX01.subPanel || "liga").toLowerCase();
        const body = panel.querySelector("#ad-ext-x01-league-body");
        const selPlayer = panel.querySelector("#ad-ext-x01-filter-player");
        const selCombo = panel.querySelector("#ad-ext-x01-filter-combo");
        const selRange = panel.querySelector("#ad-ext-x01-filter-daterange");

        const cLegDiff = panel.querySelector("#ad-ext-x01-chart-legdiff");
        const cWL = panel.querySelector("#ad-ext-x01-chart-wl");
        const cTrend = panel.querySelector("#ad-ext-x01-chart-avgtrend");
        const cMomentum = panel.querySelector("#ad-ext-x01-chart-momentum");

        const trendLegend = panel.querySelector("#ad-ext-x01-legend-avgtrend");

        const topLegsBody = panel.querySelector("#ad-ext-x01-toplegs-body");
        const topCheckoutBody = panel.querySelector("#ad-ext-x01-topcheckout-body");

        if (!cache.loaded) {
            if (body) body.innerHTML = `<tr><td colspan="12" style="opacity:.7; padding:10px 12px;">Lade…</td></tr>`;
            if (topLegsBody) topLegsBody.innerHTML = `<tr><td colspan="6" style="opacity:.7; padding:10px 12px;">Lade…</td></tr>`;
            if (topCheckoutBody) topCheckoutBody.innerHTML = `<tr><td colspan="6" style="opacity:.7; padding:10px 12px;">Lade…</td></tr>`;
            if (cLegDiff) drawEmptySvg(cLegDiff, "Lade…");
            if (cWL) drawEmptySvg(cWL, "Lade…");
            if (cMomentum) drawEmptySvg(cMomentum, "Lade…");
            if (cTrend) drawEmpty(cTrend, "Lade…");
            if (trendLegend) trendLegend.innerHTML = "";
            renderX01Kpis(panel, [], null);
            return;
        }

        // we build filters in this order:
        // 1) base (all matches)
        // 2) player + combo subset
        // 3) date range applied

        const baseMatches = cache.x01Matches.filter(m => (Number(m.totalLegs) || 0) >= MIN_TOTAL_LEGS_X01);
        const legsPlayedTotalsByKey = computeLegsPlayedTotalsByPlayerKey(baseMatches);

        const playersForDropdown = listPlayersFromMatches(baseMatches)
        .filter(p => (Number(legsPlayedTotalsByKey.get(p.key) || 0) || 0) >= MIN_LEGS_PLAYED_PLAYER_FILTER);

        const autoKey = chooseAutoPlayerKey(baseMatches, legsPlayedTotalsByKey, MIN_LEGS_PLAYED_PLAYER_FILTER);

        const playerOptions = [
            { value: "AUTO", label: `AUTO (${autoKey ? dispName(playersForDropdown.find(p => p.key === autoKey)?.name || "HÄUFIGSTER") : "—"})`, selected: cache.filtersX01.playerKey === "AUTO" },
            ...playersForDropdown.map((p) => ({ value: p.key, label: `${dispName(p.name)} (${p.count})`, selected: cache.filtersX01.playerKey === p.key })),
        ];
        setSelectOptions(selPlayer, playerOptions, true);

        const effectivePlayerKey = (selPlayer?.value && selPlayer.value !== "AUTO") ? selPlayer.value : autoKey;

        // combos depend on player
        const combosAll = effectivePlayerKey ? listCombosForPlayer(baseMatches, effectivePlayerKey) : [];
        const combos = combosAll.filter(c => c.count >= MIN_MATCHES_X01);
        const topCombo = combos[0] || null;

        const comboOptions = [];
        comboOptions.push({
            value: "AUTO_TOP",
            label: topCombo ? `HÄUFIGSTE (≥${MIN_MATCHES_X01}): ${topCombo.label} (${topCombo.count})` : `HÄUFIGSTE (≥${MIN_MATCHES_X01}): —`,
            selected: cache.filtersX01.comboKey === "AUTO_TOP" || !cache.filtersX01.comboKey
        });
        comboOptions.push({ value: "ALL", label: `ALLE COMBOS (GEMISCHT)`, selected: cache.filtersX01.comboKey === "ALL" });
        for (const c of combos) comboOptions.push({ value: c.comboKey, label: `${c.label} (${c.count})`, selected: cache.filtersX01.comboKey === c.comboKey });
        setSelectOptions(selCombo, comboOptions, true);

        const allowedValues = new Set(comboOptions.map(o => o.value));
        if (!allowedValues.has(selCombo.value)) {
            selCombo.value = "AUTO_TOP";
            cache.filtersX01.comboKey = "AUTO_TOP";
            localStorage.setItem("ad_ext_x01_comboKey", "AUTO_TOP");
        }

        cache.filtersX01.playerKey = selPlayer?.value || "AUTO";
        cache.filtersX01.comboKey = selCombo?.value || "AUTO_TOP";

        let selectedComboKey = null;
        if (cache.filtersX01.comboKey === "ALL") selectedComboKey = null;
        else if (cache.filtersX01.comboKey === "AUTO_TOP") selectedComboKey = topCombo ? topCombo.comboKey : null;
        else selectedComboKey = cache.filtersX01.comboKey;

        // apply player+combo subset first
        let subset = baseMatches.slice();
        if (effectivePlayerKey) subset = subset.filter(m => m.players.some(p => p.key === effectivePlayerKey));
        if (selectedComboKey) subset = subset.filter(m => comboKeyFromMatch(m) === selectedComboKey);

        // Hall of Fame ignores ALL date/player filters (all-time for selected combo)
        let hofMatches = baseMatches.slice();
        if (selectedComboKey) hofMatches = hofMatches.filter(m => comboKeyFromMatch(m) === selectedComboKey);
        renderX01HallOfFame(panel, hofMatches, selectedComboKey);
        if (activeSubPanel !== "liga") return;

        // date filter
        const range = String(cache.filtersX01.dateRange || "Y1").toUpperCase();
        let filteredMatches = subset.slice();

        // UX parity with the history list: for relative-day views (Today/Yesterday/Day before),
        // include also single-leg matches. Those are often played as quick practice games and
        // would otherwise be hidden by MIN_TOTAL_LEGS_X01 filtering applied to baseMatches.
        const subsetAllLegs = (() => {
            let s = Array.isArray(cache.x01Matches) ? cache.x01Matches.slice() : [];
            if (effectivePlayerKey) s = s.filter(m => m.players.some(p => p.key === effectivePlayerKey));
            if (selectedComboKey) s = s.filter(m => comboKeyFromMatch(m) === selectedComboKey);
            return s;
        })();

        if (range === "TODAY" || range === "YESTERDAY" || range === "DAY_BEFORE") {
            const daysAgo = (range === "TODAY") ? 0 : (range === "YESTERDAY") ? 1 : 2;
            const dk = relativeDayKey(daysAgo);
            filteredMatches = filterToDayKey(subsetAllLegs, (m) => m.finishedAt || m.createdAt, dk);
        } else {
            filteredMatches = filterByDateRange(subset, cache.filtersX01.dateRange, (m) => m.finishedAt || m.createdAt);
        }

        updateRelativeDayOptions(selRange);



        const totalLegsInFilter = filteredMatches.reduce((a, m) => a + (Number(m.totalLegs) || 0), 0);
        const enough = totalLegsInFilter >= MIN_TOTAL_LEGS_X01;

        cache._x01_context = {
            filteredMatches,
            effectivePlayerKey,
            last10: lastMatchesForCombo(filteredMatches, 10),
            legsTrendLegs: null,
        };

        if (!enough) {
            const msg = (filteredMatches.length === 0)
            ? "Keine X01 Matches im aktuellen Filter"
            : `Zu wenig Legs im Filter (min. ${MIN_TOTAL_LEGS_X01})`;

            if (body) body.innerHTML = `<tr><td colspan="12" style="opacity:.7; padding:10px 12px;">${msg}</td></tr>`;
            if (topLegsBody) topLegsBody.innerHTML = `<tr><td colspan="6" style="opacity:.7; padding:10px 12px;">${msg}</td></tr>`;
            if (topCheckoutBody) topCheckoutBody.innerHTML = `<tr><td colspan="6" style="opacity:.7; padding:10px 12px;">${msg}</td></tr>`;
            if (cLegDiff) drawEmptySvg(cLegDiff, msg);
            if (cWL) drawEmptySvg(cWL, msg);
            if (cMomentum) drawEmptySvg(cMomentum, msg);
            if (cTrend) drawEmpty(cTrend, msg);
            if (trendLegend) trendLegend.innerHTML = "";
            cache._x01_layouts = { legdiff: { bars: [] }, wl: { bars: [] }, trend: null };
            renderX01Kpis(panel, filteredMatches, cache.filtersX01.kpiSelectedKey || null);
            return;
        }

        const leagueBase = computeLeagueTable(filteredMatches);
        const leagueTable = sortLeagueRows(leagueBase, cache.filtersX01.leagueSortKey, cache.filtersX01.leagueSortDir);

        const selectedKey = cache.filtersX01.kpiSelectedKey || null;
        const legDiffPlayerKey = selectedKey || effectivePlayerKey;

        cache._x01_layouts = {
            legdiff: cLegDiff ? drawLegDiffTimelineSvg(cLegDiff, filteredMatches, legDiffPlayerKey) : { bars: [] },
            wl: cWL ? drawStackedWLSvg(cWL, leagueBase, selectedKey || null) : { bars: [] },
            trend: null,
        };

        // Momentum (letzte Matches im aktuellen Filter)
        const momentumToggle = panel.querySelector("#ad-ext-x01-momentum-toggle");
        const momentumModeRaw = String(localStorage.getItem("ad_ext_x01_momentumMode") || "match").toLowerCase();
        const momentumMode = (momentumModeRaw === "legs") ? "legs" : "match";

        if (momentumToggle) {
            if (!momentumToggle.dataset.bound) {
                momentumToggle.addEventListener("click", (ev) => {
                    const btn = ev.target && ev.target.closest ? ev.target.closest("button[data-mode]") : null;
                    if (!btn) return;
                    const mode = String(btn.getAttribute("data-mode") || "match").toLowerCase();
                    localStorage.setItem("ad_ext_x01_momentumMode", (mode === "legs") ? "legs" : "match");
                    renderX01(panel);
                });
                momentumToggle.dataset.bound = "1";
            }
            const btns = momentumToggle.querySelectorAll("button[data-mode]");
            btns.forEach(b => {
                const mode = String(b.getAttribute("data-mode") || "match").toLowerCase();
                const active = (mode === momentumMode);
                b.classList.toggle("ad-ext-segbtn--active", active);
            });
        }

        if (cMomentum) {
            const maxPlayers = Math.min(8, (leagueTable?.length || 0)) || 6;
            const data = buildX01MomentumData(filteredMatches, leagueTable, { maxMatches: 12, maxLegs: 12, maxPlayers, mode: momentumMode });
            drawMomentumSvg(cMomentum, data, selectedKey, momentumMode);
        }
        renderX01Kpis(panel, filteredMatches, selectedKey);
        renderTopTables(panel, filteredMatches);
        if (body) {
            if (!leagueTable.length) {
                body.innerHTML = `<tr><td colspan="12" style="opacity:.7; padding:10px 12px;">Keine X01 Matches im aktuellen Filter</td></tr>`;
            } else {
                body.innerHTML = leagueTable.map((s, i) => {
                    const isMe = effectivePlayerKey && s.key === effectivePlayerKey;

                    const pointsHtml = fmtPairHtml(s.pointsFor, s.pointsAgainst);
                    const legsHtml = fmtPairHtml(s.legsFor, s.legsAgainst);

                    const pDiffVal = (Number(s.pointsFor) || 0) - (Number(s.pointsAgainst) || 0);
                    const pDiffTxt = pDiffVal > 0 ? `+${pDiffVal}` : String(pDiffVal);
                    const pDiffCls = pDiffVal > 0 ? "ad-ext-diff-pos" : (pDiffVal < 0 ? "ad-ext-diff-neg" : "ad-ext-diff-zero");

                    const diffVal = Number(s.legDiff) || 0;
                    const diffTxt = diffVal > 0 ? `+${diffVal}` : String(diffVal);
                    const diffCls = diffVal > 0 ? "ad-ext-diff-pos" : (diffVal < 0 ? "ad-ext-diff-neg" : "ad-ext-diff-zero");

                    const f9 = (Number(s.first9Darts) || 0) > 0 ? ((Number(s.first9Points) || 0) * 3) / (Number(s.first9Darts) || 1) : NaN;
                    const ppd = (Number(s.dartsThrown) || 0) > 0 ? (Number(s.scorePoints) || 0) / (Number(s.dartsThrown) || 1) : NaN;
                    const co = (Number(s.coAtt) || 0) > 0 ? (Number(s.coHit) || 0) / (Number(s.coAtt) || 1) : NaN;

                    const f9Txt = Number.isFinite(f9) ? fmtDec(f9, 2) : "—";
                    const ppdTxt = Number.isFinite(ppd) ? fmtDec(ppd, 2) : "—";
                    const coTxt = Number.isFinite(co) ? fmtPctFromRatio(co) : "—";

                    const rowCls = [
                        (i === 0 ? "ad-ext-rowmark ad-ext-rowmark--best" : "ad-ext-rowmark"),
                        (isMe ? "ad-ext-row--me" : "")
                    ].filter(Boolean).join(" ");

                    const rank = (i === 0) ? `🏆 ${i + 1}` : String(i + 1);

                    return `
            <tr class="${rowCls}" data-x01-row="1" data-player-key="${escapeHtml(s.key)}">
              <td class="ad-ext-table-value-right">${escapeHtml(rank)}</td>
              <td class="ad-ext-td-player" title="${escapeHtml(dispName(s.name))}">${escapeHtml(dispName(s.name))}</td>
              <td class="ad-ext-table-value-right">${fmtInt(s.matches)}</td>
              <td class="ad-ext-table-value-right">${fmtInt(s.wins)}</td>
              <td class="ad-ext-table-value-right">${fmtInt(s.losses)}</td>
              <td class="ad-ext-table-value-right">${pointsHtml}</td>
              <td class="ad-ext-table-value-right ${pDiffCls}">${escapeHtml(pDiffTxt)}</td>
              <td class="ad-ext-table-value-right">${legsHtml}</td>
              <td class="ad-ext-table-value-right ${diffCls}">${escapeHtml(diffTxt)}</td>
              <td class="ad-ext-table-value-right">${escapeHtml(f9Txt)}</td>
              <td class="ad-ext-table-value-right">${escapeHtml(ppdTxt)}</td>
              <td class="ad-ext-table-value-right">${escapeHtml(coTxt)}</td>
            </tr>
          `;
                }).join("");
            }
}

        updateX01LeagueSortIndicators(panel);

        // AVG trend (LEGS)
        if (cTrend) {
            const leagueByMatches = leagueBase.slice().sort((a, b) => (b.matches - a.matches) || (b.pointsFor - a.pointsFor) || a.name.localeCompare(b.name));
            const trend = computeLegAvgTrend(filteredMatches, leagueByMatches, AVG_TREND_MAX_PLAYERS, AVG_TREND_MAX_LEGS);
            cache._x01_context.legsTrendLegs = trend.legs;

            cache._x01_layouts.trend = drawLegLineTrend(cTrend, trend.xLabels, trend.series, selectedKey);

            if (trendLegend) {
                trendLegend.innerHTML = trend.series.map(s => `
          <div class="ad-ext-legend-item">
            <span class="ad-ext-linekey" style="background:${s.color};"></span>
            <span style="font-weight:900;">${escapeHtml(s.name)}</span>
          </div>
        `).join("");
            }
        }

        applySelectedRowHighlightAll(panel);
    }


    // =========================
    // Segment Training interactions (Tooltips)
    // =========================

    // ---------------------------------------------------------------------------
    // Zeit-Tracker (Tab 3)
    // ---------------------------------------------------------------------------
    function buildTimeEntries(sessions, x01Matches, otherTrainingSessions) {
        const out = [];

        // Segment Training Sessions
        for (const s of (sessions || [])) {
            const dayKey = s?.dayKey || null;
            const dur = Number(s?.durationSec || 0);
            if (!dayKey) continue;
            out.push({
                type: "SEGMENT_TRAINING",
                dayKey,
                durationSec: Number.isFinite(dur) ? Math.max(0, dur) : 0,
                count: 1,
            });
        }

        // X01 Matches (nur X01 vs Bot)
        for (const m of (x01Matches || [])) {
            if (!m) continue;
            if (classifyX01MatchKind(m) !== "BOT") continue;

            const dayKey = parseIsoDateToDayKey(m?.dateIso || m?.finishedAt || m?.createdAt);
            const dur = Number(m?.durationSec || 0);
            if (!dayKey) continue;
            out.push({
                type: "X01_BOT",
                dayKey,
                durationSec: Number.isFinite(dur) ? Math.max(0, dur) : 0,
                count: 1,
            });
        }

        // Other training sessions (ATC / CountUp / Cricket / Random Checkout ...)
        for (const s of (otherTrainingSessions || [])) {
            const dayKey = s?.dayKey || parseIsoDateToDayKey(s?.createdAt) || parseIsoDateToDayKey(s?.finishedAt);
            if (!dayKey) continue;

            const type = String(s?.activityKey || "").toUpperCase().trim();
            if (!type) continue;
            if (type === "X01" || type === "X01_LIGA" || type === "X01_HUMAN") continue;

            const dur = Number(s?.durationSec || 0);
            let cnt = Number(s?.count || 0);
            if (!Number.isFinite(cnt) || cnt <= 0) cnt = 1;
            cnt = Math.round(cnt);

            out.push({
                type,
                dayKey,
                durationSec: Number.isFinite(dur) ? Math.max(0, dur) : 0,
                count: cnt,
            });
        }

        return out;
    }


    function clamp01(x) {
        if (!Number.isFinite(x)) return 0;
        return Math.max(0, Math.min(1, x));
    }

    function normalizeGoalHours(x) {
        const v = Number(x);
        if (!Number.isFinite(v) || v < 0) return TIME_WEEKLY_GOAL_DEFAULT_HOURS;
        // max 999h/Woche – nur als Schutz gegen UI-Fehler
        return Math.min(999, v);
    }

    function resolveTimeRange(range, timeEntries) {
        const now = new Date();
        const thisWeek = startOfWeekMonday(now);

        const r = String(range || "W12").toUpperCase().trim();
        const m = /^W(\d+)$/.exec(r);

        if (r === "THIS_WEEK") {
            return { from: thisWeek, to: null, weeksHint: 1 };
        }
        if (r === "LAST_WEEK") {
            return { from: addDaysLocal(thisWeek, -7), to: thisWeek, weeksHint: 1 };
        }
        if (m) {
            const n = Math.max(1, Math.min(260, parseInt(m[1], 10) || 1));
            return { from: addDaysLocal(thisWeek, -7 * (n - 1)), to: null, weeksHint: n };
        }
        if (r === "Y1") {
            return { from: addDaysLocal(thisWeek, -7 * 51), to: null, weeksHint: 52 };
        }
        if (r === "ALL") {
            // "ALL" = ab erster Woche, aber fürs Chart begrenzen wir später auf TIME_TREND_MAX_WEEKS
            // Falls keine Daten da sind: Default wie W12
            if (!timeEntries || timeEntries.length === 0) {
                return { from: addDaysLocal(thisWeek, -7 * 11), to: null, weeksHint: 12 };
            }
            // earliest dayKey
            let minKey = null;
            for (const e of timeEntries) {
                if (!e?.dayKey) continue;
                if (minKey === null || e.dayKey < minKey) minKey = e.dayKey;
            }
            const minDate = minKey ? parseDayKeyToLocalDate(minKey) : null;
            const minWeek = minDate ? startOfWeekMonday(minDate) : addDaysLocal(thisWeek, -7 * 11);
            return { from: minWeek, to: null, weeksHint: TIME_TREND_MAX_WEEKS };
        }

        // Fallback
        return { from: addDaysLocal(thisWeek, -7 * 11), to: null, weeksHint: 12 };
    }

    function filterTimeEntriesByRange(timeEntries, rangeInfo) {
        const from = rangeInfo?.from ? new Date(rangeInfo.from) : null;
        const to = rangeInfo?.to ? new Date(rangeInfo.to) : null;

        return (timeEntries || []).filter((e) => {
            const d = parseDayKeyToLocalDate(e.dayKey);
            if (!d) return false;
            if (from && d < from) return false;
            if (to && d >= to) return false;
            return true;
        });
    }

    function buildWeekSeries(rangeInfo) {
        const now = new Date();
        const thisWeek = startOfWeekMonday(now);

        const toWeek = rangeInfo?.to ? startOfWeekMonday(addDaysLocal(rangeInfo.to, -1)) : thisWeek;
        let fromWeek = rangeInfo?.from ? startOfWeekMonday(rangeInfo.from) : addDaysLocal(thisWeek, -7 * 11);

        // Bei ALL/Y1 kann die Range sehr groß sein – fürs Chart begrenzen wir auf TIME_TREND_MAX_WEEKS
        const maxWeeks = (String(cache?.filtersTime?.range || "").toUpperCase().trim() === "ALL")
        ? TIME_TREND_MAX_WEEKS
        : (String(cache?.filtersTime?.range || "").toUpperCase().trim() === "Y1" ? 52 : TIME_TREND_MAX_WEEKS);

        // Wenn die Differenz zu groß ist, schneide am Anfang ab
        const diffWeeks = Math.floor((toWeek - fromWeek) / (7 * 86400000)) + 1;
        if (diffWeeks > maxWeeks) {
            fromWeek = addDaysLocal(toWeek, -7 * (maxWeeks - 1));
        }

        const series = [];
        let cur = new Date(fromWeek);
        for (let i = 0; i < 400; i++) {
            if (cur > toWeek) break;
            series.push(dayKeyFromLocalDate(cur));
            cur = addDaysLocal(cur, 7);
        }
        return series;
    }
    function timeTrackerKeysOrdered() {
        // Order = TRAINING_ACTIVITIES, but without X01_HUMAN (Liga)
        return (TRAINING_ACTIVITIES || [])
            .filter(a => String(a?.key || "").trim() !== "X01_HUMAN")
            .map(a => String(a.key));
    }

    const TIME_TRACKER_RGB = {
        ATC: [200, 140, 255],
        COUNTUP: [255, 200, 0],
        CRICKET: [255, 90, 90],
        RANDOM_CHECKOUT: [255, 140, 0],
        SEGMENT_TRAINING: [0, 150, 255],
        X01_BOT: [0, 200, 160],
    };

    function timeTrackerRgb(key) {
        const k = String(key || "").toUpperCase().trim();
        const c = TIME_TRACKER_RGB[k];
        return Array.isArray(c) ? c : [200, 140, 255];
    }

    function timeTrackerColor(key, alpha = 0.85) {
        const c = timeTrackerRgb(key);
        const a = Number(alpha);
        const aa = Number.isFinite(a) ? Math.max(0, Math.min(1, a)) : 0.85;
        return `rgba(${c[0]},${c[1]},${c[2]},${aa})`;
    }

    function timeTrackerStroke(key) {
        const c = timeTrackerRgb(key);
        return `rgb(${c[0]},${c[1]},${c[2]})`;
    }

    function aggregateTimeWeeks(timeEntries, weekKeys) {
        const keys = timeTrackerKeysOrdered();
        const map = new Map();

        for (const wk of (weekKeys || [])) {
            const byKeySec = new Map();
            const byKeyCount = new Map();
            for (const k of keys) {
                byKeySec.set(k, 0);
                byKeyCount.set(k, 0);
            }
            map.set(wk, {
                weekKey: wk,
                totalSec: 0,
                totalCount: 0,
                byKeySec,
                byKeyCount,

                // legacy fields (robust fallback)
                stSec: 0,
                x01Sec: 0,
                otherSec: 0,
                stCount: 0,
                x01Count: 0,
                otherCount: 0,
            });
        }

        for (const e of (timeEntries || [])) {
            const d = parseDayKeyToLocalDate(e.dayKey);
            if (!d) continue;
            const wk = weekKeyFromDate(d);
            if (!wk || !map.has(wk)) continue;

            const slot = map.get(wk);

            const secRaw = Number(e?.durationSec || 0);
            const sec = Number.isFinite(secRaw) ? Math.max(0, secRaw) : 0;

            const tRaw = String(e?.type || "").toUpperCase().trim();
            let t = tRaw;
            if (t === "ST") t = "SEGMENT_TRAINING";
            if (t === "X01") t = "X01_BOT";

            // Liga / Mensch immer ignorieren
            if (t === "X01_LIGA" || t === "X01_HUMAN") continue;

            const cntRaw = Number(e?.count);
            let countInc = Number.isFinite(cntRaw) ? Math.round(cntRaw) : 1;
            if (!Number.isFinite(countInc) || countInc <= 0) countInc = 1;

            slot.totalSec += sec;
            slot.totalCount += countInc;

            if (!slot.byKeySec.has(t)) slot.byKeySec.set(t, 0);
            slot.byKeySec.set(t, Number(slot.byKeySec.get(t) || 0) + sec);

            if (!slot.byKeyCount.has(t)) slot.byKeyCount.set(t, 0);
            slot.byKeyCount.set(t, Number(slot.byKeyCount.get(t) || 0) + countInc);
        }

        // derive legacy fields + enrich with KW + range
        const out = [];
        for (const wk of (weekKeys || [])) {
            const slot = map.get(wk);

            const st = Number(slot?.byKeySec?.get?.("SEGMENT_TRAINING") || 0) || 0;
            const x01 = Number(slot?.byKeySec?.get?.("X01_BOT") || 0) || 0;

            let other = 0;
            try {
                for (const [k, v] of (slot?.byKeySec?.entries?.() || [])) {
                    const kk = String(k || "").toUpperCase().trim();
                    if (kk === "SEGMENT_TRAINING" || kk === "X01_BOT" || kk === "X01_HUMAN") continue;
                    other += Number(v || 0) || 0;
                }
            } catch {}

            slot.stSec = st;
            slot.x01Sec = x01;
            slot.otherSec = other;

            slot.stCount = Number(slot?.byKeyCount?.get?.("SEGMENT_TRAINING") || 0) || 0;
            slot.x01Count = Number(slot?.byKeyCount?.get?.("X01_BOT") || 0) || 0;

            let otherCount = 0;
            try {
                for (const [k, v] of (slot?.byKeyCount?.entries?.() || [])) {
                    const kk = String(k || "").toUpperCase().trim();
                    if (kk === "SEGMENT_TRAINING" || kk === "X01_BOT" || kk === "X01_HUMAN") continue;
                    otherCount += Number(v || 0) || 0;
                }
            } catch {}
            slot.otherCount = otherCount;

            const info = weekRangeFromWeekKey(wk);
            if (info) {
                slot.isoYear = info.isoYear;
                slot.kw = info.week;
                slot.rangeLabel = `${dayKeyToGerman(info.startKey)} – ${dayKeyToGerman(info.endKey)}`;
            } else {
                slot.isoYear = "";
                slot.kw = "";
                slot.rangeLabel = wk;
            }

            out.push(slot);
        }
        return out;
    }
function drawWeeklyTimeStacked(canvas, weeksAsc, opts = {}) {
        if (!canvas) return null;
        const ctx = canvas.getContext("2d");
        const W = canvas.width || 1200;
        const H = canvas.height || 280;

        ctx.clearRect(0, 0, W, H);

        const padL = 58;
        const padR = 14;
        const padT = 16;
        const padB = 34;

        const chartW = W - padL - padR;
        const chartH = H - padT - padB;

        const keys = timeTrackerKeysOrdered();

        const selWeekKey = String(opts?.selectedWeekKey || "");
        const selKey = String(opts?.selectedKey || "").toUpperCase().trim();

        const secOf = (w, key) => {
            try {
                if (w?.byKeySec?.get) return Number(w.byKeySec.get(key) || 0) || 0;
            } catch {}
            // legacy fallback
            const k = String(key || "").toUpperCase().trim();
            if (k === "SEGMENT_TRAINING") return Number(w?.stSec || 0) || 0;
            if (k === "X01_BOT") return Number(w?.x01Sec || 0) || 0;
            if (k === "OTHER") return Number(w?.otherSec || 0) || 0;
            return 0;
        };

        const valueWeek = (w) => selKey ? secOf(w, selKey) : Number(w?.totalSec || 0);

        let maxSec = 0;
        for (const w of (weeksAsc || [])) maxSec = Math.max(maxSec, valueWeek(w));
        const maxY = Math.max(1, maxSec * 1.15);

        const yOf = (sec) => padT + chartH - (sec / maxY) * chartH;

        // grid + labels
        ctx.strokeStyle = "rgba(255,255,255,0.08)";
        ctx.fillStyle = "rgba(255,255,255,0.55)";
        ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";

        for (let i = 0; i <= 4; i++) {
            const v = (maxY / 4) * i;
            const y = yOf(v);
            ctx.beginPath();
            ctx.moveTo(padL, y);
            ctx.lineTo(padL + chartW, y);
            ctx.stroke();
            ctx.fillText(fmtHours(v), 8, y);
        }

        const n = (weeksAsc || []).length;
        const gap = (n <= 8) ? 14 : ((n <= 16) ? 10 : (n > 30 ? 3 : 6));
        const barW = n > 0 ? Math.max(6, Math.floor((chartW - gap * (n - 1)) / n)) : 0;

        const bars = [];
        const segments = [];
        let x = padL;

        for (let i = 0; i < n; i++) {
            const w = weeksAsc[i];
            const wk = String(w?.weekKey || "");
            const isSelWeek = !!selWeekKey && wk && wk === selWeekKey;

            const yBase = padT + chartH;

            if (selKey) {
                const sec = secOf(w, selKey);
                const h = (sec / maxY) * chartH;
                if (h > 0.5) {
                    ctx.fillStyle = timeTrackerColor(selKey, isSelWeek ? 0.28 : 0.22);
                    ctx.fillRect(x, yBase - h, barW, h);

                    ctx.strokeStyle = timeTrackerStroke(selKey);
                    ctx.lineWidth = 1;
                    if (h > 6 && barW > 8) ctx.strokeRect(x + 0.5, yBase - h + 0.5, Math.max(1, barW - 1), Math.max(1, h - 1));

                    segments.push({ x, y: yBase - h, w: barW, h, key: selKey, data: w, weekKey: wk });
                }

                // outline of the selected bar (week focus)
                if (isSelWeek) {
                    ctx.strokeStyle = "rgba(140,190,255,0.75)";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x + 1.5, padT + 1.5, Math.max(1, barW - 3), Math.max(1, chartH - 3));
                }

                const hHit = Math.max(1, h);
                bars.push({ x, y: yBase - hHit, w: barW, h: hHit, data: w, weekKey: wk });

            } else {
                const total = Number(w?.totalSec || 0);
                const hTotal = (total / maxY) * chartH;

                let yTop = yBase;

                // stacked bars
                for (const k of keys) {
                    const sec = secOf(w, k);
                    const h = (sec / maxY) * chartH;
                    if (h > 0.5) {
                        const aFill = isSelWeek ? 0.20 : 0.16;
                        ctx.fillStyle = timeTrackerColor(k, aFill);
                        ctx.fillRect(x, yTop - h, barW, h);

                        // reduce visual clutter on tiny segments
                        if (h > 10 && barW > 10) {
                            ctx.strokeStyle = timeTrackerStroke(k);
                            ctx.lineWidth = 1;
                            ctx.strokeRect(x + 0.5, yTop - h + 0.5, Math.max(1, barW - 1), Math.max(1, h - 1));
                        }

                        segments.push({ x, y: yTop - h, w: barW, h, key: String(k).toUpperCase().trim(), data: w, weekKey: wk });
                        yTop -= h;
                    }
                }

                // outline (total)
                ctx.strokeStyle = "rgba(255,255,255,0.10)";
                ctx.lineWidth = 1;
                if (hTotal > 1) ctx.strokeRect(x + 0.5, yBase - hTotal + 0.5, Math.max(1, barW - 1), Math.max(1, hTotal - 1));

                // selected week overlay
                if (isSelWeek) {
                    ctx.strokeStyle = "rgba(140,190,255,0.75)";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x + 1.5, padT + 1.5, Math.max(1, barW - 3), Math.max(1, chartH - 3));
                }

                // x label: only every Nth on many points
                const showEvery = n > 45 ? 4 : (n > 30 ? 3 : (n > 20 ? 2 : 1));
                if (i % showEvery === 0) {
                    ctx.fillStyle = "rgba(255,255,255,0.70)";
                    ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "alphabetic";
                    const label = w?.kw ? `KW ${w.kw}` : "";
                    ctx.fillText(label, x + barW / 2, H - 10);
                }

                bars.push({ x, y: yBase - hTotal, w: barW, h: hTotal, data: w, weekKey: wk });
            }

            x += barW + gap;
        }

        // axis line
        ctx.strokeStyle = "rgba(255,255,255,0.15)";
        ctx.beginPath();
        ctx.moveTo(padL, padT);
        ctx.lineTo(padL, padT + chartH);
        ctx.lineTo(padL + chartW, padT + chartH);
        ctx.stroke();

        return { bars, segments, yOf };
    }
function renderMasterHallOfFame(panel) {
        const view = panel.querySelector("#ad-ext-view-masterhof");
        if (!view) return;

        const selPlayer = view.querySelector("#ad-ext-master-filter-player");
        if (!selPlayer) return;

        const btnBots = view.querySelector("#ad-ext-master-include-bots");
        const lblBots = view.querySelector("#ad-ext-master-bots-switch-label");

        // UI -> State (Bots)
        let includeBots = !!cache.filtersMasterHof.includeBots;
        if (btnBots) {
            btnBots.setAttribute("aria-checked", includeBots ? "true" : "false");
            btnBots.dataset.adExtChecked = includeBots ? "1" : "0";
        }
        if (lblBots) {
            lblBots.textContent = includeBots ? "An" : "Aus";
            lblBots.dataset.adExtOn = includeBots ? "1" : "0";
        }

        // Base: all X01 matches (all-time), ignore dateRange, but drop trivial single-leg noise
        const baseMatches = cache.x01Matches.filter(m => (Number(m.totalLegs) || 0) >= MIN_TOTAL_LEGS_X01);

        const legsPlayedTotalsByKey = computeLegsPlayedTotalsByPlayerKey(baseMatches);

        // Players for dropdown: never show BOT LEVEL … as "Ich"
        const playersAllRaw = listPlayersFromMatches(baseMatches);
        const keyToName = new Map(playersAllRaw.map(p => [String(p.key), p.name]));
        const playersAll = playersAllRaw.filter(p => !isBotLevelPlayerName(p?.name));

        const playersForDropdown = playersAll
        .filter(p => (Number(legsPlayedTotalsByKey.get(p.key) || 0) || 0) >= MIN_LEGS_PLAYED_PLAYER_FILTER);

        const pickBestNonBotKey = () => {
            const cands = (playersForDropdown || []).slice();
            cands.sort((a, b) => (Number(legsPlayedTotalsByKey.get(b.key) || 0) - Number(legsPlayedTotalsByKey.get(a.key) || 0)));
            return cands[0]?.key || null;
        };

        // AUTO: nimm die bestehende Heuristik, aber niemals einen BOT LEVEL …
        let autoKey = chooseAutoPlayerKey(baseMatches, legsPlayedTotalsByKey, MIN_LEGS_PLAYED_PLAYER_FILTER);
        if (autoKey && isBotLevelPlayerName(keyToName.get(String(autoKey)) || "")) autoKey = null;
        if (!autoKey) autoKey = pickBestNonBotKey();

        const autoName = autoKey ? (playersAllRaw.find(p => String(p.key) === String(autoKey))?.name || keyToName.get(String(autoKey)) || autoKey) : "—";

        const playerOptions = [
            { value: "AUTO", label: `AUTO (${autoKey ? dispName(autoName) : "—"})`, selected: cache.filtersMasterHof.playerKey === "AUTO" },
            ...playersForDropdown.map(p => ({
                value: p.key,
                label: `${dispName(p.name || p.key)} (${p.count})`,
                selected: cache.filtersMasterHof.playerKey === p.key,
            })),
        ];

        setSelectOptions(selPlayer, playerOptions, true);

        const effectiveIchKey = (selPlayer?.value && selPlayer.value !== "AUTO") ? selPlayer.value : autoKey;

        // persist current select (handles case where previous selection vanished)
        if (selPlayer?.value && selPlayer.value !== cache.filtersMasterHof.playerKey) {
            cache.filtersMasterHof.playerKey = selPlayer.value;
            localStorage.setItem("ad_ext_master_playerKey", cache.filtersMasterHof.playerKey);
        }

        if (!effectiveIchKey) {
            // no data
            renderX01HallOfFame(view, [], null, { rootSelector: "#ad-ext-master-panel-hof" });
            return;
        }

        const matchHasBotLevel = (m) => {
            const ps = Array.isArray(m?.players) ? m.players : [];
            return ps.some(p => isBotLevelPlayerName(p?.name));
        };

        // Only matches where "Ich" participated; Ranking shows everyone EXCEPT "Ich"
        let hofMatches = baseMatches.filter(m => {
            const ps = Array.isArray(m?.players) ? m.players : [];
            return ps.some(p => String(p?.key || "") === String(effectiveIchKey));
        });

        // Bots rausrechnen = Matches mit BOT LEVEL … komplett ignorieren (damit z.B. längstes/kürzestes Spiel nicht verfälscht wird)
        if (!includeBots) {
            hofMatches = hofMatches.filter(m => !matchHasBotLevel(m));
        }

        // Gegner-Minimum (Variante C): Spieler mit < N Matches werden in den Listen ausgeblendet.
        // Matches selbst bleiben für die übrigen Spieler erhalten (weniger Datenverlust, Rankings bleiben "sauber").
        let masterAllowSet = null;
        let masterExcludedCount = 0;
        if ((Number(MASTER_HOF_MIN_OPPONENT_MATCHES) || 0) > 1) {
            const minN = Number(MASTER_HOF_MIN_OPPONENT_MATCHES) || 0;
            const counts = new Map();

            for (const m of hofMatches) {
                const ps = Array.isArray(m?.players) ? m.players : [];
                for (const p of ps) {
                    const k = String(p?.key ?? p?.id ?? p?.name ?? "");
                    if (!k) continue;
                    counts.set(k, (counts.get(k) || 0) + 1);
                }
            }

            masterAllowSet = new Set();
            for (const [k, c] of counts.entries()) {
                if ((c || 0) >= minN) masterAllowSet.add(String(k));
            }
            // "Ich" immer erlauben, auch wenn Daten sehr dünn sind
            if (effectiveIchKey) masterAllowSet.add(String(effectiveIchKey));

            // Für Transparenz: wie viele Spieler würden rausfallen (nur Anzeige / nicht zwingend genutzt)
            for (const [k, c] of counts.entries()) {
                if (!masterAllowSet.has(String(k))) masterExcludedCount++;
            }
        }

        // Hinweistext (Transparenz) unter der Überschrift
        const desc = view.querySelector("#ad-ext-masterhof-desc");
        if (desc) {
            const minN = Number(MASTER_HOF_MIN_OPPONENT_MATCHES) || 0;
            const parts = [];
            if (minN > 1) {
                parts.push(`Variante C: Spieler mit weniger als ${minN} Matches werden in den Listen ausgeblendet (${masterExcludedCount} ausgeblendet).`);
            }
            parts.push(includeBots ? "Bots werden mitgerechnet." : "Bots werden ignoriert (BOT LEVEL …).");
            desc.textContent = parts.join(" ");
        }

        renderX01HallOfFame(view, hofMatches, null, {
            rootSelector: "#ad-ext-master-panel-hof",
            playerKeyAllowSet: masterAllowSet,
        });
    }
    function renderTimeTab(panel) {
        if (!panel) return;

        // read filters from cache (UI writes here)
        const f = cache.filtersTime || {
            mode: "ALL",
            range: "W12",
        };

        // Backward-compat + sanitize (alte Werte / ungültige Keys)
        {
            const rawMode = String(f.mode || "ALL");
            let m2 = rawMode.toUpperCase().trim();

            if (m2 === "X01" || m2 === "X01_LIGA") m2 = "X01_BOT";
            if (m2 === "ST") m2 = "SEGMENT_TRAINING";
            if (m2 === "X01_HUMAN") m2 = "ALL";

            const allowed = new Set(["ALL", ...TRAINING_ACTIVITIES.filter(a => a.key !== "X01_HUMAN").map(a => a.key)]);
            if (!allowed.has(m2)) m2 = "ALL";

            if (m2 !== rawMode) {
                f.mode = m2;
                cache.filtersTime = f;
                try { localStorage.setItem("ad_ext_time_mode", m2); } catch {}
            }
        }

        const labelByKey = new Map((TRAINING_ACTIVITIES || []).map(a => [String(a.key), String(a.label || a.key)]));
        const modeLabel = (k) => (k === "ALL") ? "Alles" : (labelByKey.get(String(k)) || String(k || ""));

        const keysAll = timeTrackerKeysOrdered();

        // sync inputs (once loaded)
        const selMode = panel.querySelector("#ad-ext-time-mode");
        const selRange = panel.querySelector("#ad-ext-time-range");

        if (selMode) {
            const modeOptions = [
                { value: "ALL", label: "Alles", selected: f.mode === "ALL" },
                ...TRAINING_ACTIVITIES
                    .filter(a => a.key !== "X01_HUMAN")
                    .map(a => ({ value: a.key, label: a.label, selected: f.mode === a.key })),
            ];
            setSelectOptions(selMode, modeOptions, false);
        }
        if (selRange && selRange.value !== f.range) selRange.value = f.range;

        const kThis = panel.querySelector("#ad-ext-time-kpi-thisweek");
        const kThisSub = panel.querySelector("#ad-ext-time-kpi-thisweek-sub");
        const kRange = panel.querySelector("#ad-ext-time-kpi-range");
        const kRangeSub = panel.querySelector("#ad-ext-time-kpi-range-sub");
        const kAvg = panel.querySelector("#ad-ext-time-kpi-avg");
        const kAvgSub = panel.querySelector("#ad-ext-time-kpi-avg-sub");
        const kBest = panel.querySelector("#ad-ext-time-kpi-best");
        const kBestSub = panel.querySelector("#ad-ext-time-kpi-best-sub");
        const tbody = panel.querySelector("#ad-ext-time-week-body");
        const share = panel.querySelector("#ad-ext-time-share");

        const timeEntriesAll = buildTimeEntries(
            cache.sessions || [],
            cache.x01Matches || [],
            cache.otherTrainingSessions || []
        );

        // Mode filter
        const matchMode = (e) => {
            const tRaw = String(e?.type || "").toUpperCase().trim();
            let t = tRaw;
            if (t === "ST") t = "SEGMENT_TRAINING";
            if (t === "X01") t = "X01_BOT";
            return t === String(f.mode || "").toUpperCase().trim();
        };

        const timeEntriesMode = (f.mode === "ALL")
            ? timeEntriesAll
            : timeEntriesAll.filter(matchMode);

        const rangeInfo = resolveTimeRange(f.range, timeEntriesMode);
        const timeEntries = filterTimeEntriesByRange(timeEntriesMode, rangeInfo);

        const weekKeys = buildWeekSeries(rangeInfo);
        const weeksAsc = aggregateTimeWeeks(timeEntries, weekKeys);
        cache._time_weeksAsc = weeksAsc;

        // Chrono-Tracker selection (wired via clicks in Chart/Donut/Table)
        let selWeekKey = String(cache.filtersTime?.selectedWeekKey || "");
        let selKey = String(cache.filtersTime?.selectedKey || "").toUpperCase().trim();

        // selection is only meaningful in ALL-mode (otherwise the mode already filters)
        if (String(f.mode || "").toUpperCase().trim() !== "ALL") {
            selKey = "";
            try { cache.filtersTime.selectedKey = ""; } catch {}
        }

        if (selKey && !keysAll.some(k => String(k).toUpperCase().trim() === selKey)) {
            selKey = "";
            try { cache.filtersTime.selectedKey = ""; } catch {}
        }

        if (selWeekKey && !weeksAsc.some(w => String(w?.weekKey || "") === selWeekKey)) {
            selWeekKey = "";
            try { cache.filtersTime.selectedWeekKey = ""; } catch {}
        }

        const secOf = (w, key) => {
            try { if (w?.byKeySec?.get) return Number(w.byKeySec.get(key) || 0) || 0; } catch {}
            return 0;
        };
        const cntOf = (w, key) => {
            try { if (w?.byKeyCount?.get) return Number(w.byKeyCount.get(key) || 0) || 0; } catch {}
            return 0;
        };

        const blankWeek = () => {
            const byKeySec = new Map();
            const byKeyCount = new Map();
            for (const k of keysAll) {
                byKeySec.set(k, 0);
                byKeyCount.set(k, 0);
            }
            return {
                weekKey: "",
                totalSec: 0,
                totalCount: 0,
                byKeySec,
                byKeyCount,
                kw: "",
                isoYear: "",
                rangeLabel: "",
            };
        };

        // KPIs
        const thisWeekKey = weekKeyFromDate(new Date());
        const thisWeek = weeksAsc.find((w) => w.weekKey === thisWeekKey) || blankWeek();
        const focusWeek = (selWeekKey ? (weeksAsc.find((w) => String(w.weekKey) === String(selWeekKey)) || null) : null) || thisWeek;

        const valWeek = (w) => selKey ? secOf(w, selKey) : (Number(w.totalSec || 0));
        const cntWeek = (w) => selKey ? cntOf(w, selKey) : (Number(w.totalCount || 0));

        const rangeTotal = weeksAsc.reduce((a, w) => a + valWeek(w), 0);
        const rangeTotalCount = weeksAsc.reduce((a, w) => a + cntWeek(w), 0);

        const rangeByKeySec = new Map(keysAll.map(k => [k, 0]));
        const rangeByKeyCount = new Map(keysAll.map(k => [k, 0]));
        for (const w of (weeksAsc || [])) {
            for (const k of keysAll) {
                rangeByKeySec.set(k, Number(rangeByKeySec.get(k) || 0) + secOf(w, k));
                rangeByKeyCount.set(k, Number(rangeByKeyCount.get(k) || 0) + cntOf(w, k));
            }
        }

        const weeksCount = Math.max(1, weeksAsc.length);
        const avgSec = rangeTotal / weeksCount;

        let best = weeksAsc[0] || null;
        for (const w of weeksAsc) {
            if (!best || (valWeek(w) > valWeek(best))) best = w;
        }

        const partsByKey = (getVal) => {
            const parts = [];
            for (const k of keysAll) {
                const v = Number(getVal(k) || 0) || 0;
                if (v > 0) parts.push(`${modeLabel(k)} ${fmtHours(v)}`);
            }
            return parts.length ? parts.join(" · ") : "—";
        };

        const subAllWeek = (w) => partsByKey((k) => secOf(w, k));
        const subAllRange = () => partsByKey((k) => rangeByKeySec.get(k));

        const countLabel = (k) => (String(k || "").toUpperCase().trim() === "X01_BOT") ? "Matches" : "Sessions";
        const subModeCount = (count) => `${fmtInt(Number(count || 0))} ${countLabel(f.mode)}`;

        const focusTotal = valWeek(focusWeek);
        const focusCount = cntWeek(focusWeek);

        if (kThis) kThis.textContent = fmtHours(focusTotal);
        if (kThisSub) {
            const prefix = (selWeekKey && focusWeek?.kw) ? (`KW ${focusWeek.kw}${focusWeek.isoYear ? "/" + focusWeek.isoYear : ""} · `) : "";
            if (f.mode === "ALL") {
                if (selKey) {
                    kThisSub.textContent = `${prefix}${modeLabel(selKey)} · ${fmtInt(Number(focusCount || 0))} ${countLabel(selKey)}`;
                } else {
                    kThisSub.textContent = prefix + subAllWeek(focusWeek);
                }
            } else {
                kThisSub.textContent = `${modeLabel(f.mode)} · ${subModeCount(focusWeek.totalCount || 0)}`;
            }
        }

        if (kRange) kRange.textContent = fmtHours(rangeTotal);
        if (kRangeSub) {
            if (f.mode === "ALL") {
                if (selKey) {
                    kRangeSub.textContent = `${modeLabel(selKey)} · ${fmtInt(Number(rangeTotalCount || 0))} ${countLabel(selKey)}`;
                } else {
                    kRangeSub.textContent = subAllRange();
                }
            } else {
                kRangeSub.textContent = `${modeLabel(f.mode)} · ${subModeCount(rangeTotalCount)}`;
            }
        }

        if (kAvg) kAvg.textContent = fmtHours(avgSec);
        if (kAvgSub) kAvgSub.textContent = `${weeksCount} Wochen`;

        if (kBest) kBest.textContent = fmtHours(valWeek(best || blankWeek()));
        if (kBestSub) {
            const kw = best?.kw ? `KW ${best.kw}` : "";
            const year = best?.isoYear ? `/${best.isoYear}` : "";
            kBestSub.textContent = `${kw}${year} · ${best?.rangeLabel || ""}`;
        }

        // Donut (Anteile)
        const donut = panel.querySelector("#ad-ext-time-donut");

        let donutItems = [];
        if (f.mode === "ALL") {
            let srcMap = rangeByKeySec;
            if (selWeekKey && focusWeek && focusWeek.weekKey) {
                srcMap = new Map(keysAll.map(k => [k, secOf(focusWeek, k)]));
            }
            donutItems = keysAll
                .map((k) => ({
                    label: modeLabel(k),
                    value: Number(srcMap.get(k) || 0) || 0,
                    color: timeTrackerColor(k, 0.85),
                    extra: { key: k },
                }))
                .filter((it) => (Number(it?.value) || 0) > 0);
        } else {
            donutItems = [{
                label: modeLabel(f.mode),
                value: rangeTotal,
                color: timeTrackerColor(f.mode, 0.85),
                extra: { key: f.mode },
            }];
        }

        cache._time_layouts = cache._time_layouts || {};
        cache._time_layouts.donut = drawDonutSvg(donut, donutItems, {
            style: "outline",
            gapDeg: 7,
            strokeWidth: 2,
            outlineFillAlpha: 0.20,
            rInnerFactor: 0.78,
            showCenterText: false,
            holeFill: false,
        });

        try { applyTimeTrackerDonutFocus(donut, cache._time_layouts?.donut, selKey); } catch {}


        // Legend (wie Segment Training)
        if (share) {
            const items = donutItems.filter((it) => (Number(it?.value) || 0) > 0);
            const total = items.reduce((a, it) => a + (Number(it?.value) || 0), 0);

            if (!total) {
                share.innerHTML = `<div class="ad-ext-muted">Keine Daten</div>`;
            } else {
                share.innerHTML = items.map((it) => {
                    const v = Number(it?.value) || 0;
                    const pct = total ? (v * 100) / total : 0;
                    const color = String(it?.color || "");
                    return `
          <div class="ad-ext-legend-item">
            <span class="ad-ext-dot" style="background:${escapeHtml(color)};"></span>
            <span style="font-weight:900;">${escapeHtml(String(it?.label || ""))}</span>
            <span style="opacity:.78; font-weight:800;">${escapeHtml(fmtHours(v))} (${pct.toFixed(1)}%)</span>
          </div>
        `;
                }).join("");
            }
        }

        // Weekly chart
        const chart = panel.querySelector("#ad-ext-time-chart");
        cache._time_layouts.weekChart = drawWeeklyTimeStacked(chart, weeksAsc, { selectedWeekKey: selWeekKey, selectedKey: selKey });

        // Table (desc)
        if (tbody) {
            const weeksDesc = [...weeksAsc].reverse();
            if (weeksDesc.length === 0) {
                tbody.innerHTML = `<tr><td colspan="10" class="ad-ext-muted">Keine Daten im Zeitraum.</td></tr>`;
            } else {
                tbody.innerHTML = weeksDesc
                    .map((w) => {
                        const kw = w.kw ? `KW ${w.kw}` : "–";
                        const wk = String(w?.weekKey || "");
                        const isSel = wk && wk === String(selWeekKey || "");
                        const cls = isSel ? "ad-ext-row--selected" : "";
                        const data = wk ? `data-week-key="${escapeHtml(wk)}"` : "";

                        const atc = secOf(w, "ATC");
                        const cu = secOf(w, "COUNTUP");
                        const cr = secOf(w, "CRICKET");
                        const rc = secOf(w, "RANDOM_CHECKOUT");
                        const st = secOf(w, "SEGMENT_TRAINING");
                        const x01 = secOf(w, "X01_BOT");

                        return `<tr ${data} class="${cls}">
              <td>${kw}</td>
              <td>${w.rangeLabel || "–"}</td>
              <td data-tt-col="TOTAL">${fmtHours(w.totalSec || 0)}</td>
              <td data-tt-col="ATC">${fmtHours(atc)}</td>
              <td data-tt-col="COUNTUP">${fmtHours(cu)}</td>
              <td data-tt-col="CRICKET">${fmtHours(cr)}</td>
              <td data-tt-col="RANDOM_CHECKOUT">${fmtHours(rc)}</td>
              <td data-tt-col="SEGMENT_TRAINING">${fmtHours(st)}</td>
              <td data-tt-col="X01_BOT">${fmtHours(x01)}</td>
              <td>${fmtInt(Number(w.totalCount || 0))}</td>
            </tr>`;
                    })
                    .join("");
            }
        }

        try { applyTimeTrackerColumnFocus(panel, selKey); } catch {}

        // Source label oben rechts (wie bei Segment/X01)
        setSourceLabel(
            panel,
            `Datenquelle: ${cache.meta?.sourceText || "IndexedDB"} (${cache.meta?.totalRows ?? "?"} Matches, ${fmtInt(cache.meta?.segmentSessions ?? 0)} Segment Sessions, ${fmtInt(cache.meta?.x01Matches ?? 0)} X01 Matches)`
        );
    }
// ---------------------------------------------------------------------------
    // Training (Tab 4)
    // ---------------------------------------------------------------------------

    function buildTrainingTimeEntriesAll() {
        // Für die Wochen-Auswahl im Trainingsplan: ST + X01 + (best effort) weitere Trainingsmodi
        const out = [];

        // Reuse existing builder for ST + X01
        for (const e of (buildTimeEntries(cache.sessions || [], cache.x01Matches || []) || [])) out.push(e);

        // Other training sessions (ATC / CountUp / Cricket / Random Checkout ...)
        for (const s of (cache.otherTrainingSessions || [])) {
            const dayKey = s?.dayKey || parseIsoDateToDayKey(s?.createdAt) || parseIsoDateToDayKey(s?.finishedAt);
            if (!dayKey) continue;

            const dur = Number(s?.durationSec || 0);
            out.push({
                type: "OTH",
                dayKey,
                durationSec: Number.isFinite(dur) ? Math.max(0, dur) : 0,
            });
        }

        return out;
    }

    function buildWeekSeriesMax(rangeInfo, maxWeeks = 260) {
        const now = new Date();
        const thisWeek = startOfWeekMonday(now);

        const toWeek = rangeInfo?.to ? startOfWeekMonday(addDaysLocal(rangeInfo.to, -1)) : thisWeek;
        let fromWeek = rangeInfo?.from ? startOfWeekMonday(rangeInfo.from) : addDaysLocal(thisWeek, -7 * 11);

        const mw = Math.max(1, Math.min(520, Math.round(Number(maxWeeks) || 260)));

        // Wenn die Differenz zu groß ist, schneide am Anfang ab
        const diffWeeks = Math.floor((toWeek - fromWeek) / (7 * 86400000)) + 1;
        if (diffWeeks > mw) {
            fromWeek = addDaysLocal(toWeek, -7 * (mw - 1));
        }

        const series = [];
        let cur = new Date(fromWeek);
        for (let i = 0; i < mw + 5; i++) {
            if (cur > toWeek) break;
            series.push(dayKeyFromLocalDate(cur));
            cur = addDaysLocal(cur, 7);
        }
        return series;
    }

    function computeTrainingWeeksAsc() {
        const timeEntries = buildTrainingTimeEntriesAll();

        const lookbackWeeks = Math.max(0, Math.min(260, Math.round(Number(
            AD_getSetting("TRAIN_WEEK_LOOKBACK_WEEKS_DEFAULT", TRAIN_WEEK_LOOKBACK_WEEKS_DEFAULT)
        ) || 0)));

        const lookaheadWeeks = Math.max(0, Math.min(260, Math.round(Number(
            AD_getSetting("TRAIN_WEEK_LOOKAHEAD_WEEKS_DEFAULT", TRAIN_WEEK_LOOKAHEAD_WEEKS_DEFAULT)
        ) || 0)));

        const thisWeek = startOfWeekMonday(new Date());
        const fromWeek = addDaysLocal(thisWeek, -7 * lookbackWeeks);

        // buildWeekSeriesMax() behandelt "to" als end-exklusiv (intern wird 1 Tag abgezogen),
        // daher +1 Woche, damit die letzte Zukunftswoche sauber eingeschlossen ist.
        const to = addDaysLocal(thisWeek, 7 * (lookaheadWeeks + 1));

        const maxWeeks = Math.min(260, lookbackWeeks + lookaheadWeeks + 2); // 2 = current + end
        const weekKeys = buildWeekSeriesMax({ from: fromWeek, to }, maxWeeks);
        return aggregateTimeWeeks(timeEntries, weekKeys);
    }

    function renderTrainingTab(panel) {
        if (!panel) return;
        const weeksAsc = computeTrainingWeeksAsc();
        cache._training_weeksAsc = weeksAsc;
        renderTrainingPlan(panel, weeksAsc);

        // Trainingsdaten nutzt auch Insights-KPIs → immer aktualisieren (Analysis nur im Insights-View)
        try { renderInsights(panel); } catch {}

        // Training Subview: Segment-Fokus / Chromo-Tracker (DOM-move + render, ohne eigenen Haupt-Tab)
        try {
            const layout = panel.querySelector(".ad-train-layout");
            const tv = String(layout?.dataset?.trainView || "").toUpperCase();


            // CHROMO: Zeit-Tracker wurde in den Trainings-Subview „Chromo-Tracker“ umgezogen
            if (tv === "CHROMO") {
                try { mountTimeIntoTrainChromo(panel); } catch {}
                try { if (cache?.loaded) renderTimeTab(panel); } catch {}
            }

            // ATCFOCUS: Wenn beim Laden bereits „ATC-Fokus“ aktiv ist, jetzt mit echten Daten füllen


            if (tv === "ATCFOCUS") {


                try {


                    if (typeof cache._adExt_setTrainView === "function") {


                        cache._adExt_setTrainView("ATCFOCUS");


                    } else {


                        const btn = panel.querySelector('#ad-ext-train-view .ad-ext-segbtn[data-view="ATCFOCUS"]');


                        if (btn) btn.click();


                    }


                } catch {}


            }



            // SEGFOCUS: Segment-Training Panel in Training-Subview anzeigen
            if (tv === "SEGFOCUS") {
                const wrap = panel.querySelector("#ad-ext-train-segfokus");
                const segPanel = panel.querySelector("#ad-ext-view-segment");
                if (wrap && segPanel && segPanel.parentElement !== wrap) wrap.appendChild(segPanel);
                try { if (segPanel) segPanel.style.display = ""; } catch {}
                try { if (cache?.loaded) renderSegmentTraining(panel, cache.sessions, cache.filters, cache.meta); } catch {}
            }
        } catch {}
    }

    function mountTimeIntoTrainChromo(panel) {
        try {
            const wrap = panel?.querySelector?.("#ad-ext-train-chromo");
            const timeView = panel?.querySelector?.("#ad-ext-view-time");
            if (!wrap || !timeView) return;

            // Move existing DOM (no duplicates / no cloned IDs)
            if (timeView.parentElement !== wrap) wrap.appendChild(timeView);

            // Neutralize legacy inline display:none from the old top-tab view
            try { timeView.style.display = ""; } catch {}

            // Align title with the new training subview label
            try {
                const t = timeView.querySelector(".ad-ext-section-title");
                if (t) t.textContent = "Chromo-Tracker";
            } catch {}
        } catch {}
    }


    function renderInsights(panel) {
        if (!panel) return;

        const kpiFulfill = panel.querySelector("#adExtInsightsKpiPlanFulfill");
        const kpiFulfillSub = panel.querySelector("#adExtInsightsKpiPlanFulfillSub");
        const kpiAvgDur = panel.querySelector("#adExtInsightsKpiAvgWeekDur");
        const kpiAvgDurSub = panel.querySelector("#adExtInsightsKpiAvgWeekDurSub");
        const kpiDays = panel.querySelector("#adExtInsightsKpiDaysPerWeek");
        const kpiDaysSub = panel.querySelector("#adExtInsightsKpiDaysPerWeekSub");
        const kpiTmi = panel.querySelector("#adExtInsightsKpiTmi");
        const kpiTmiSub = panel.querySelector("#adExtInsightsKpiTmiSub");

        const tmiTile = kpiTmi?.closest(".ad-ext-kpi-tile");

        const setTxt = (el, v) => { try { if (el) el.textContent = String(v ?? ""); } catch {} };

        const fmtPct1 = (p) => {
            const n = Number(p);
            if (!Number.isFinite(n)) return "—";
            return `${(Math.round(n * 10) / 10).toFixed(1)}%`;
        };

        const fmtNum1 = (v) => {
            const n = Number(v);
            if (!Number.isFinite(n)) return "—";
            return (Math.round(n * 10) / 10).toFixed(1);
        };

        const fmtIdx2 = (v) => {
            const n = Number(v);
            if (!Number.isFinite(n)) return "—";
            return (Math.round(n * 100) / 100).toFixed(2).replace(".", ",");
        };

        const tmiLabel = (v) => {
            const x = Number(v);
            if (!Number.isFinite(x)) return "—";
            if (x <= 0.0001) return "Du spielst immer dasselbe Training";
            if (x < 0.40) return "Leichte Variation";
            if (x < 0.70) return "Ausgewogener Mix";
            return "Sehr abwechslungsreich";
        };

        const normalizeTargetLocal = (raw) =>
        String(raw || "").trim().toUpperCase().replace(/\s+/g, "");

        let weeksAsc = [];
        try {
            const w = computeTrainingWeeksAsc();
            weeksAsc = Array.isArray(w) ? w : [];
        } catch {
            weeksAsc = [];
        }

        const thisMonday = startOfWeekMonday(new Date());
        const thisWeekKey = thisMonday ? dayKeyFromLocalDate(thisMonday) : "";

        // Erkenntnisse: nicht in die Zukunft rechnen (nur Wochen bis inkl. aktueller Woche)
        try {
            weeksAsc = (weeksAsc || []).filter((w) => String(w?.weekKey || w || "") <= String(thisWeekKey));
        } catch {}

        // Basis (für TMI Gewichtung) – aktuell sessions-only UI, aber robust halten
        let basis = "SESS";
        try { basis = normalizePlanBasis(loadTrainingPlanState()?.basis); } catch {}
        const isSessionsMode = basis === "SESS";

        // KPI 1: Planerfüllungsgrad (Ø über Wochen mit PlanGoal>0)
        let sumPct = 0;
        let cntPct = 0;
        let thisWeekPct = null;
        let thisWeekOvertrained = false;
        let anyOvertrained = false;

        const overtrainingTip = "Hinweis: Übertraining! Für die Statistik wird IST = SOLL gewertet.";

        for (const w of (weeksAsc || [])) {
            const weekKey = String(w?.weekKey || w || "");
            if (!weekKey) continue;

            const weekId = weekIdFromWeekKey(weekKey);
            const plan = weekId ? loadWeekPlan(weekId) : null;
            const itemsRaw = (plan && Array.isArray(plan.planItems)) ? plan.planItems : [];
            const items = sanitizePlanItemsForStorage(itemsRaw);

            // Nur Plan-Items mit Ziel > 0 (basis-abhängig)
            const planned = (items || []).filter((it) => {
                if (isSessionsMode) return clampSessions(Number(it?.targetSessions) || 0) > 0;
                return clampMinutes(Number(it?.targetMinutes) || 0) > 0;
            });

            let planGoalWeek = 0;
            for (const it of planned) {
                const g = isSessionsMode ? clampSessions(Number(it?.targetSessions) || 0) : clampMinutes(Number(it?.targetMinutes) || 0);
                if (g > 0) planGoalWeek += g;
            }
            planGoalWeek = Math.max(0, Math.round(planGoalWeek));
            if (!(planGoalWeek > 0)) {
                if (weekKey === thisWeekKey) thisWeekPct = null;
                continue;
            }

            let agg = null;
            try { agg = aggregateTrainingActualsForWeek(weekKey); } catch { agg = null; }
            const byActivity = agg?.byActivity || new Map();
            const stTargets = agg?.stTargets || new Map();

            let actualWeekRaw = 0;
            let creditedWeek = 0;

            // Deckelung pro Plan-Item (wie Trainingsdaten-Tabelle)
            for (const it of planned) {
                const type = String(it?.type || "").trim() || "CUSTOM";
                const trackerKey = PLANITEM_TYPE_TO_TRACKER_KEY[type] || type;

                const goalItem = isSessionsMode ? clampSessions(Number(it?.targetSessions) || 0) : clampMinutes(Number(it?.targetMinutes) || 0);

                let sec = 0;
                let cnt = 0;

                // Ist-Werte: Standard = nach Aktivität
                try {
                    const rec = (byActivity && byActivity.get) ? (byActivity.get(trackerKey) || { sec: 0, count: 0 }) : { sec: 0, count: 0 };
                    sec = Number(rec?.sec || 0) || 0;
                    cnt = Number(rec?.count || 0) || 0;
                } catch { sec = 0; cnt = 0; }

                // Sonderfall: Segment Training mit Targets -> Summe über Targets
                if (type === "SEGMENT_TRAINING") {
                    const targets = it?.params?.targets;
                    if (Array.isArray(targets) && targets.length && stTargets && stTargets.get) {
                        let secSum = 0;
                        let cntSum = 0;
                        for (const t of targets) {
                            const k = String(t || "").trim();
                            if (!k) continue;
                            const a = stTargets.get(k) || { sec: 0, count: 0 };
                            secSum += Number(a?.sec || 0) || 0;
                            cntSum += Number(a?.count || 0) || 0;
                        }
                        sec = secSum;
                        cnt = cntSum;
                    }
                }

                const actualItem = isSessionsMode ? Math.round(cnt || 0) : toIntMinutes(sec);
                const creditedItem = Math.min(actualItem, goalItem);

                actualWeekRaw += actualItem;
                creditedWeek += creditedItem;
            }

            actualWeekRaw = Math.max(0, Math.round(actualWeekRaw));
            creditedWeek = Math.max(0, Math.round(creditedWeek));

            const pctWeek = (creditedWeek / planGoalWeek) * 100;

            const overtrainedWeek = actualWeekRaw > creditedWeek + 1e-9;
            if (overtrainedWeek) anyOvertrained = true;

            if (Number.isFinite(pctWeek)) {
                sumPct += pctWeek;
                cntPct += 1;
            }

            if (weekKey === thisWeekKey) {
                thisWeekPct = pctWeek;
                thisWeekOvertrained = overtrainedWeek;
            }

            try {
                console.debug("[insights fulfill]", { weekKey, planGoalWeek, actualWeekRaw, creditedWeek, pctWeek, overtrainedWeek });
            } catch {}
        }

        const avgPct = (cntPct > 0) ? (sumPct / cntPct) : null;

        setTxt(kpiFulfill, (avgPct === null) ? "—" : fmtPct1(avgPct));
        try { if (kpiFulfill) kpiFulfill.title = ""; } catch {}

        setTxt(kpiFulfillSub, `Diese Woche: ${(thisWeekPct === null) ? "—" : fmtPct1(thisWeekPct)}`);
        try { if (kpiFulfillSub) kpiFulfillSub.title = ""; } catch {}

        // KPI 2: Durchschnittliche Trainingsdauer pro Woche
        let sumSec = 0;
        let cntSec = 0;
        let thisWeekSec = null;

        for (const w of (weeksAsc || [])) {
            const weekKey = String(w?.weekKey || w || "");
            if (!weekKey) continue;

            const weekId = weekIdFromWeekKey(weekKey);
            const plan = weekId ? loadWeekPlan(weekId) : null;
            const itemsRaw = (plan && Array.isArray(plan.planItems)) ? plan.planItems : [];
            const items = sanitizePlanItemsForStorage(itemsRaw);

            // Nur Wochen mit Plan-Items (Ziel > 0)
            const planned = (items || []).filter((it) => {
                if (isSessionsMode) return clampSessions(Number(it?.targetSessions) || 0) > 0;
                return clampMinutes(Number(it?.targetMinutes) || 0) > 0;
            });
            if (!planned.length) {
                if (weekKey === thisWeekKey) thisWeekSec = null;
                continue;
            }

            let agg = null;
            try { agg = aggregateTrainingActualsForWeek(weekKey); } catch { agg = null; }
            const byActivity = agg?.byActivity || new Map();
            const stTargets = agg?.stTargets || new Map();

            let secSumWeek = 0;

            // Summe: exakt wie Trainingsdaten-Tabelle (Plan-Items addieren)
            for (const it of planned) {
                const type = String(it?.type || "").trim() || "CUSTOM";
                const trackerKey = PLANITEM_TYPE_TO_TRACKER_KEY[type] || type;

                let sec = 0;

                // Ist-Werte: Standard = nach Aktivität
                try {
                    const rec = (byActivity && byActivity.get) ? (byActivity.get(trackerKey) || { sec: 0, count: 0 }) : { sec: 0, count: 0 };
                    sec = Number(rec?.sec || 0) || 0;
                } catch { sec = 0; }

                // Sonderfall: Segment Training mit Targets -> Summe über Targets
                if (type === "SEGMENT_TRAINING") {
                    const targets = it?.params?.targets;
                    if (Array.isArray(targets) && targets.length && stTargets && stTargets.get) {
                        let secSum = 0;
                        for (const t of targets) {
                            const k = String(t || "").trim();
                            if (!k) continue;
                            const a = stTargets.get(k) || { sec: 0, count: 0 };
                            secSum += Number(a?.sec || 0) || 0;
                        }
                        sec = secSum;
                    }
                }

                secSumWeek += Number(sec) || 0;
            }

            secSumWeek = Math.max(0, Number(secSumWeek) || 0);

            if (weekKey === thisWeekKey) thisWeekSec = secSumWeek > 0 ? secSumWeek : null;

            if (Number.isFinite(secSumWeek) && secSumWeek > 0) {
                sumSec += secSumWeek;
                cntSec += 1;
            }
        }

        const avgSec = (cntSec > 0) ? (sumSec / cntSec) : null;

        setTxt(kpiAvgDur, (avgSec === null) ? "—" : fmtHours(avgSec));
        setTxt(kpiAvgDurSub, `Diese Woche: ${(thisWeekSec === null) ? "—" : fmtHours(thisWeekSec)}`);



        // KPI 3: Trainingstage / Woche (unique local days mit Aktivitäten)
        let sumDays = 0;
        let cntDays = 0;
        let thisWeekDays = null;

        try {
            const allowedWeeks = new Set((weeksAsc || []).map(w => String(w?.weekKey || "")).filter(Boolean));
            const daysByWeek = new Map();
            for (const wk of allowedWeeks) daysByWeek.set(wk, new Set());

            const timeEntries = buildTrainingTimeEntriesAll();
            for (const e of (timeEntries || [])) {
                const dk = String(e?.dayKey || "").trim();
                if (!dk) continue;
                const d = parseDayKeyToLocalDate(dk);
                if (!d) continue;
                const wk = weekKeyFromDate(d);
                if (!wk || !daysByWeek.has(wk)) continue;
                daysByWeek.get(wk).add(dk);
            }

            for (const wk of allowedWeeks) {
                const n = daysByWeek.get(wk)?.size || 0;
                if (wk === thisWeekKey) thisWeekDays = n > 0 ? n : null;
                if (n > 0) {
                    sumDays += n;
                    cntDays += 1;
                }
            }
        } catch {}

        const avgDays = (cntDays > 0) ? (sumDays / cntDays) : null;
        setTxt(kpiDays, (avgDays === null) ? "—" : fmtNum1(avgDays));
        setTxt(kpiDaysSub, `Diese Woche: ${(thisWeekDays === null) ? "—" : (String(thisWeekDays) + " Tage")}`);

        // KPI 4: Trainingsmix-Index (TMI) – Ø über Wochen mit n>0 geplanten Items
        try {
            let sumTmi = 0;
            let cntTmi = 0;
            let thisWeekTmi = null;

            const weightFromRec = (rec) => {
                if (!rec) return 0;
                if (isSessionsMode) return Math.max(0, Math.round(Number(rec?.count || 0) || 0));
                return Math.max(0, Number(rec?.sec || 0) || 0);
            };

            const weightFromTargetRec = (rec) => {
                if (!rec) return 0;
                if (isSessionsMode) return Math.max(0, Math.round(Number(rec?.count || 0) || 0));
                return Math.max(0, Number(rec?.sec || 0) || 0);
            };

            for (const w of (weeksAsc || [])) {
                const weekKey = String(w?.weekKey || "");
                if (!weekKey) continue;

                const weekId = weekIdFromWeekKey(weekKey);
                const plan = weekId ? loadWeekPlan(weekId) : null;
                const itemsRaw = (plan && Array.isArray(plan.planItems)) ? plan.planItems : [];
                const items = sanitizePlanItemsForStorage(itemsRaw);

                const planned = (items || []).filter((it) => {
                    const t = String(it?.type || "");
                    if (isSessionsMode) return clampSessions(Number(it?.targetSessions) || 0) > 0;
                    return clampMinutes(Number(it?.targetMinutes) || 0) > 0;
                });

                const n = planned.length;
                if (n === 0) {
                    if (weekKey === thisWeekKey) thisWeekTmi = null;
                    continue;
                }

                let agg = null;
                try { agg = aggregateTrainingActualsForWeek(weekKey); } catch { agg = null; }
                const byActivity = agg?.byActivity || new Map();
                const stTargets = agg?.stTargets || new Map();

                // Total weights per tracker key
                const totalByKey = new Map();
                try {
                    for (const [k, rec] of (byActivity?.entries?.() || [])) {
                        totalByKey.set(String(k), weightFromRec(rec));
                    }
                } catch {}

                // Build weights for planned items
                const weights = [];
                const byKeyIdxs = new Map();
                const usedByKey = new Map(); // key -> sum weights already assigned (z.B. ST via Targets)

                const addUsed = (key, w) => {
                    const k = String(key || "");
                    if (!k) return;
                    usedByKey.set(k, (Number(usedByKey.get(k) || 0) || 0) + (Number(w) || 0));
                };

                for (const it of planned) {
                    const type = String(it?.type || "").trim();
                    const trackerKey = String(PLANITEM_TYPE_TO_TRACKER_KEY[type] || type).trim();

                    // Segment Training: wenn Targets vorhanden, Gewicht über Targets berechnen (präziser)
                    if (type === "SEGMENT_TRAINING" && Array.isArray(it?.params?.targets) && it.params.targets.length) {
                        let wSum = 0;
                        for (const t of it.params.targets) {
                            const k = normalizeTargetLocal(t);
                            const rec = stTargets.get(k) || stTargets.get(String(t || "").trim()) || { sec: 0, count: 0 };
                            wSum += weightFromTargetRec(rec);
                        }
                        weights.push({ key: trackerKey, weight: Math.max(0, wSum), source: "targets" });
                        addUsed(trackerKey, wSum);
                    } else {
                        const idx = weights.length;
                        weights.push({ key: trackerKey, weight: null, source: "byActivity" });
                        if (!byKeyIdxs.has(trackerKey)) byKeyIdxs.set(trackerKey, []);
                        byKeyIdxs.get(trackerKey).push(idx);
                    }
                }

                // Distribute shared byActivity weights among duplicates (und ggf. Rest bei ST)
                for (const [key, idxs] of byKeyIdxs.entries()) {
                    const total = Number(totalByKey.get(key) || 0) || 0;
                    const used = Number(usedByKey.get(key) || 0) || 0;
                    const eff = (key === "SEGMENT_TRAINING") ? Math.max(0, total - used) : total;
                    const per = idxs.length ? (eff / idxs.length) : 0;
                    for (const i of idxs) weights[i].weight = Math.max(0, per);
                }

                let totalWeight = 0;
                for (const wi of weights) totalWeight += Number(wi?.weight || 0) || 0;

                const uniform = 1 / n;
                let tmi = 0;

                if (totalWeight > 0) {
                    let sumAbs = 0;
                    for (const wi of weights) {
                        const p = (Number(wi?.weight || 0) || 0) / totalWeight;
                        sumAbs += Math.abs(p - uniform);
                    }
                    tmi = 1 - (sumAbs / 2);
                } else {
                    // n>0 aber keine Ist-Daten -> sichtbar 0.0
                    tmi = 0;
                }

                if (!Number.isFinite(tmi)) tmi = 0;
                tmi = Math.max(0, Math.min(1, tmi));

                sumTmi += tmi;
                cntTmi += 1;
                if (weekKey === thisWeekKey) thisWeekTmi = tmi;
            }

            const avgTmi = (cntTmi > 0) ? (sumTmi / cntTmi) : null;

            setTxt(kpiTmi, (avgTmi === null) ? "—" : fmtIdx2(avgTmi));
            setTxt(kpiTmiSub, `Diese Woche: ${(thisWeekTmi === null) ? "—" : fmtIdx2(thisWeekTmi)}`);

            try { if (tmiTile) tmiTile.dataset.tmiAvg = String(avgTmi ?? ""); } catch {}

            if (tmiTile && !tmiTile.dataset.tipWired) {
                tmiTile.dataset.tipWired = "1";

                tmiTile.addEventListener("mouseenter", (ev) => {
                    const v = Number(tmiTile.dataset.tmiAvg);
                    const cur = Number.isFinite(v) ? fmtIdx2(v) : "—";
                    const lab = Number.isFinite(v) ? tmiLabel(v) : "—";

                    const html = `
      <div class="ad-ext-tooltip-title">Trainingsmix-Index (TMI)</div>
      <div class="ad-ext-tooltip-line">Aktuell: <b>${cur}</b> – ${lab}</div>
      <div class="ad-ext-tooltip-recline" style="margin-top:8px">
        0,00: Du spielst immer dasselbe Training<br/>
        0,20–0,40: Leichte Variation<br/>
        0,40–0,70: Ausgewogener Mix<br/>
        0,70–1,00: Sehr abwechslungsreich
      </div>
    `;
                tooltipShow(ev, html);
            });
            tmiTile.addEventListener("mousemove", (ev) => tooltipMove(ev));
            tmiTile.addEventListener("mouseleave", () => tooltipHide());
        }
        } catch (e) {
            try { console.warn("[AD Ext][INSIGHTS] KPI4 TMI failed", e); } catch {}
            setTxt(kpiTmi, "—");
            setTxt(kpiTmiSub, "Diese Woche: —");
        }


        

        // KPIs werden auch im Trainingsdaten-Tab angezeigt; dort nur KPI-Teil aktualisieren
        try {
            const tv = String(panel?.querySelector?.(".ad-train-layout")?.dataset?.trainView || "DATA").toUpperCase();
            if (tv !== "INSIGHTS") return;
        } catch {}
// Insights: Analysis (Weak doubles + Mini charts) (0.14.111)
        try {
            const weakBody = panel.querySelector("#ad-ext-insights-weakdoubles-body");
            if (weakBody) {
                const fromKey = String((weeksAsc && weeksAsc[0] && weeksAsc[0].weekKey) || "");
                const toKey = String(thisWeekKey || "");
                if (!cache || !cache.loaded || !fromKey || !toKey) {
                    weakBody.innerHTML = `<tr><td colspan="5" style="opacity:.7; padding:10px 12px;">—</td></tr>`;
                } else {
                    try { renderWeakDoubles(panel, weakBody, fromKey, toKey); } catch {}
                }
            }
            const cMiniP2 = panel.querySelector("#ad-ext-insights-mini-p2");
            const cMiniP3 = panel.querySelector("#ad-ext-insights-mini-p3");
            if (cMiniP2) drawEmpty(cMiniP2, "Platzhalter");
            if (cMiniP3) drawEmpty(cMiniP3, "Platzhalter");
        } catch {}

    }
    function aggregateTrainingActualsForWeek(weekKey) {
        const wk = weekRangeFromWeekKey(weekKey);
        if (!wk) {
            return { wk: null, byActivity: new Map(), stTargets: new Map() };
        }

        const inWeek = (dk) => {
            const s = String(dk || "");
            return s && s >= wk.startKey && s <= wk.endKey;
        };

        const byActivity = new Map();
        for (const a of TRAINING_ACTIVITIES) byActivity.set(a.key, { sec: 0, count: 0, hits: 0, darts: 0, checkoutHits: 0, checkoutAttempts: 0 });

        const stTargets = new Map(); // target -> {sec,count,hits,darts}

        const add = (key, sec, cnt, hits = 0, darts = 0, coHit = 0, coAtt = 0) => {
            if (!byActivity.has(key)) byActivity.set(key, { sec: 0, count: 0, hits: 0, darts: 0, checkoutHits: 0, checkoutAttempts: 0 });
            const obj = byActivity.get(key);
            if (obj.hits === undefined) obj.hits = 0;
            if (obj.darts === undefined) obj.darts = 0;
            if (obj.checkoutHits === undefined) obj.checkoutHits = 0;
            if (obj.checkoutAttempts === undefined) obj.checkoutAttempts = 0;
            obj.sec += Number(sec) || 0;
            obj.count += Number(cnt) || 0;
            obj.hits += Number(hits) || 0;
            obj.darts += Number(darts) || 0;
            obj.checkoutHits += Number(coHit) || 0;
            obj.checkoutAttempts += Number(coAtt) || 0;
        };

        // Segment Training (sessions already extracted)
        for (const s of (cache.sessions || [])) {
            const dk = s.dayKey || (s.dayKey =
                                    parseIsoDateToDayKey(s.createdAt) || parseIsoDateToDayKey(s.finishedAt)
                                   );
            if (!inWeek(dk)) continue;

            const dSec = Number(s.durationSec) || 0;
            add("SEGMENT_TRAINING", dSec, 1, Number(s.hits) || 0, Number(s.darts) || 0);

            const target = String(s.target || "").trim();
            if (!target || target === "DRandom" || target === "SRandom") continue;

            if (!stTargets.has(target)) stTargets.set(target, { sec: 0, count: 0, hits: 0, darts: 0 });
            const t = stTargets.get(target);
            t.sec += dSec;
            t.count += 1;
            t.hits += Number(s.hits) || 0;
            t.darts += Number(s.darts) || 0;
        }

        // X01 Matches (already extracted)
        for (const m of (cache.x01Matches || [])) {
            const dk = m.dayKey || (m.dayKey =
                                    parseIsoDateToDayKey(m.createdAt) || parseIsoDateToDayKey(m.finishedAt)
                                   );
            if (!inWeek(dk)) continue;

            const dSec = Number(m.durationSec) || 0;
            const kind = classifyX01MatchKind(m);
            const legs = Number(m.totalLegs) ||
                  (Array.isArray(m.legsWon) ? m.legsWon.reduce((a, b) => a + (Number(b || 0) || 0), 0) : 0) ||
                  1;
            add(kind === "BOT" ? "X01_BOT" : "X01_HUMAN", dSec, legs);
        }

        // Other training modes (best-effort extraction)
        for (const s of (cache.otherTrainingSessions || [])) {
            const dk = s.dayKey || (s.dayKey =
                                    parseIsoDateToDayKey(s.createdAt) || parseIsoDateToDayKey(s.finishedAt)
                                   );
            if (!inWeek(dk)) continue;

            const key = String(s.activityKey || "").trim();
            if (!key) continue;

            const coHit = Number(s.checkoutHits ?? s.checkoutsHit ?? s.coHits ?? s.checkoutMade ?? s.coHit) || 0;
            const coAtt = Number(s.checkoutAttempts ?? s.checkoutChances ?? s.coAttempts ?? s.coOpps ?? s.checkouts ?? s.coOpp) || 0;
            add(key, Number(s.durationSec) || 0, Number(s.count) || 1, Number(s.hits) || 0, Number(s.darts) || 0, coHit, coAtt);
        }

        return { wk, byActivity, stTargets };
    }

    function aggregateTrainingActualsForDayKeyRange(startKey, endKey) {
        const sKey = String(startKey || '').trim();
        const eKey = String(endKey || '').trim();
        if (!sKey || !eKey) {
            return { startKey: sKey || null, endKey: eKey || null, byActivity: new Map(), stTargets: new Map() };
        }

        const inRange = (dk) => {
            const s = String(dk || '');
            return s && s >= sKey && s <= eKey;
        };

        const byActivity = new Map();
        for (const a of TRAINING_ACTIVITIES) byActivity.set(a.key, { sec: 0, count: 0, hits: 0, darts: 0, checkoutHits: 0, checkoutAttempts: 0 });

        const stTargets = new Map();

        const add = (key, sec, cnt, hits = 0, darts = 0, coHit = 0, coAtt = 0) => {
            if (!byActivity.has(key)) byActivity.set(key, { sec: 0, count: 0, hits: 0, darts: 0, checkoutHits: 0, checkoutAttempts: 0 });
            const obj = byActivity.get(key);
            if (obj.hits === undefined) obj.hits = 0;
            if (obj.darts === undefined) obj.darts = 0;
            if (obj.checkoutHits === undefined) obj.checkoutHits = 0;
            if (obj.checkoutAttempts === undefined) obj.checkoutAttempts = 0;
            obj.sec += Number(sec) || 0;
            obj.count += Number(cnt) || 0;
            obj.hits += Number(hits) || 0;
            obj.darts += Number(darts) || 0;
            obj.checkoutHits += Number(coHit) || 0;
            obj.checkoutAttempts += Number(coAtt) || 0;
        };

        // Segment Training
        for (const s of (cache.sessions || [])) {
            const dk = s.dayKey || (s.dayKey = parseIsoDateToDayKey(s.createdAt) || parseIsoDateToDayKey(s.finishedAt));
            if (!inRange(dk)) continue;
            const dSec = Number(s.durationSec) || 0;
            add('SEGMENT_TRAINING', dSec, 1, Number(s.hits) || 0, Number(s.darts) || 0);

            const target = String(s.target || '').trim();
            if (!target || target === 'DRandom' || target === 'SRandom') continue;
            if (!stTargets.has(target)) stTargets.set(target, { sec: 0, count: 0, hits: 0, darts: 0 });
            const t = stTargets.get(target);
            t.sec += dSec;
            t.count += 1;
            t.hits += Number(s.hits) || 0;
            t.darts += Number(s.darts) || 0;
        }

        // X01 Matches
        for (const m of (cache.x01Matches || [])) {
            const dk = m.dayKey || (m.dayKey = parseIsoDateToDayKey(m.createdAt) || parseIsoDateToDayKey(m.finishedAt));
            if (!inRange(dk)) continue;
            const dSec = Number(m.durationSec) || 0;
            const kind = classifyX01MatchKind(m);
            const legs = Number(m.totalLegs) || (Array.isArray(m.legsWon) ? m.legsWon.reduce((a, b) => a + (Number(b || 0) || 0), 0) : 0) || 1;
            add(kind === 'BOT' ? 'X01_BOT' : 'X01_HUMAN', dSec, legs);
        }

        // Other training modes
        for (const s of (cache.otherTrainingSessions || [])) {
            const dk = s.dayKey || (s.dayKey = parseIsoDateToDayKey(s.createdAt) || parseIsoDateToDayKey(s.finishedAt));
            if (!inRange(dk)) continue;
            const key = String(s.activityKey || '').trim();
            if (!key) continue;
            const coHit = Number(s.checkoutHits ?? s.checkoutsHit ?? s.coHits ?? s.checkoutMade ?? s.coHit) || 0;
            const coAtt = Number(s.checkoutAttempts ?? s.checkoutChances ?? s.coAttempts ?? s.coOpps ?? s.checkouts ?? s.coOpp) || 0;
            add(key, Number(s.durationSec) || 0, Number(s.count) || 1, Number(s.hits) || 0, Number(s.darts) || 0, coHit, coAtt);
        }

        return { startKey: sKey, endKey: eKey, byActivity, stTargets };
    }


    // 0.14.169: All-time aggregation (für Zeitschätzung im Trainingsplan)
    function aggregateTrainingActualsAllTime() {
        const byActivity = new Map();
        for (const a of TRAINING_ACTIVITIES) {
            byActivity.set(a.key, { sec: 0, count: 0, hits: 0, darts: 0, checkoutHits: 0, checkoutAttempts: 0 });
        }

        const stTargets = new Map();

        const add = (key, sec, cnt, hits = 0, darts = 0, coHit = 0, coAtt = 0) => {
            if (!byActivity.has(key)) byActivity.set(key, { sec: 0, count: 0, hits: 0, darts: 0, checkoutHits: 0, checkoutAttempts: 0 });
            const obj = byActivity.get(key);
            if (obj.hits === undefined) obj.hits = 0;
            if (obj.darts === undefined) obj.darts = 0;
            if (obj.checkoutHits === undefined) obj.checkoutHits = 0;
            if (obj.checkoutAttempts === undefined) obj.checkoutAttempts = 0;
            obj.sec += Number(sec) || 0;
            obj.count += Number(cnt) || 0;
            obj.hits += Number(hits) || 0;
            obj.darts += Number(darts) || 0;
            obj.checkoutHits += Number(coHit) || 0;
            obj.checkoutAttempts += Number(coAtt) || 0;
        };

        // Segment Training
        for (const s of (cache.sessions || [])) {
            const dSec = Number(s.durationSec) || 0;
            add("SEGMENT_TRAINING", dSec, 1, Number(s.hits) || 0, Number(s.darts) || 0);

            const target = String(s.target || "").trim();
            if (!target || target === "DRandom" || target === "SRandom") continue;

            if (!stTargets.has(target)) stTargets.set(target, { sec: 0, count: 0, hits: 0, darts: 0 });
            const t = stTargets.get(target);
            t.sec += dSec;
            t.count += 1;
            t.hits += Number(s.hits) || 0;
            t.darts += Number(s.darts) || 0;
        }

        // X01 Matches
        for (const m of (cache.x01Matches || [])) {
            const dSec = Number(m.durationSec) || 0;
            const kind = classifyX01MatchKind(m);
            const legs = Number(m.totalLegs) ||
                (Array.isArray(m.legsWon) ? m.legsWon.reduce((a, b) => a + (Number(b || 0) || 0), 0) : 0) ||
                1;
            add(kind === "BOT" ? "X01_BOT" : "X01_HUMAN", dSec, legs);
        }

        // Other training modes
        for (const s of (cache.otherTrainingSessions || [])) {
            const key = String(s.activityKey || "").trim();
            if (!key) continue;

            const coHit = Number(s.checkoutHits ?? s.checkoutsHit ?? s.coHits ?? s.checkoutMade ?? s.coHit) || 0;
            const coAtt = Number(s.checkoutAttempts ?? s.checkoutChances ?? s.coAttempts ?? s.coOpps ?? s.checkouts ?? s.coOpp) || 0;
            add(key, Number(s.durationSec) || 0, Number(s.count) || 1, Number(s.hits) || 0, Number(s.darts) || 0, coHit, coAtt);
        }

        return { byActivity, stTargets };
    }





    // ---------------------------------------------------------------------------
    // ChatGPT Copy (Training -> Trainingsdaten) (0.14.182)
    // - erzeugt Markdown + Lite-JSON (Balance: Spiel vs Training)
    // ---------------------------------------------------------------------------

    function adExt_fmtWeekLabel(wkKey) {
        try {
            const r = weekRangeFromWeekKey(wkKey);
            const isoYear = Number(r?.isoYear) || 0;
            const week = String(r?.week ?? "").padStart(2, "0");
            const s = dayKeyToGerman(r?.startKey);
            const e = dayKeyToGerman(r?.endKey);
            const sShort = String(s || "").replace(/\.\d{4}$/, ".");
            const eShort = String(e || "").replace(/\.\d{4}$/, ".");
            if (isoYear && week && sShort && eShort) return `KW ${week}/${isoYear} (${sShort}–${eShort})`;
        } catch { /* ignore */ }
        return String(wkKey || "");
    }

    function adExt_chooseAutoPlayerKeyNonBot(x01Matches) {
        const counts = new Map();
        for (const m of (x01Matches || [])) {
            for (const p of (m?.players || [])) {
                const key = p?.key;
                const name = String(p?.name || "").trim();
                if (!key) continue;
                // Bot-Spieler explizit ausschließen
                if (isBotLikePlayerName(name) || isBotLevelPlayerName(name)) continue;
                counts.set(key, (counts.get(key) || 0) + 1);
            }
        }
        let bestKey = null;
        let bestCnt = -1;
        for (const [k, c] of counts.entries()) {
            if (c > bestCnt) { bestCnt = c; bestKey = k; }
        }
        return bestKey;
    }

    function adExt_copyToClipboard(text) {
        const s = String(text || "");
        if (!s) return Promise.reject(new Error("empty"));

        // 1) Clipboard API
        try {
            if (navigator?.clipboard?.writeText) {
                return navigator.clipboard.writeText(s);
            }
        } catch { /* ignore */ }

        // 2) Fallback: textarea + execCommand
        return new Promise((resolve, reject) => {
            try {
                const ta = document.createElement("textarea");
                ta.value = s;
                ta.setAttribute("readonly", "");
                ta.style.position = "fixed";
                ta.style.left = "-9999px";
                ta.style.top = "-9999px";
                document.body.appendChild(ta);
                ta.select();
                const ok = document.execCommand("copy");
                document.body.removeChild(ta);
                if (ok) resolve();
                else reject(new Error("copy failed"));
            } catch (e) {
                reject(e);
            }
        });
    }

    function adExt_buildLiteJsonForTrainingWeek(weekKey) {
        const wk = weekRangeFromWeekKey(weekKey);
        const agg = aggregateTrainingActualsForWeek(weekKey);
        const byActivity = agg?.byActivity || new Map();

        const inWeekKey = (dk) => {
            const s = String(dk || "");
            return wk && s && s >= wk.startKey && s <= wk.endKey;
        };

        // --- X01 Matches: Bot vs Human (sessions + legs + time) ---
        const x01All = (cache?.x01Matches || []).filter((m) => {
            const dk = m?.dayKey || parseIsoDateToDayKey(m?.createdAt) || parseIsoDateToDayKey(m?.finishedAt);
            return inWeekKey(dk);
        });

        const play = {
            human: { sessions: 0, legs: 0, timeMin: 0 },
            bot: { sessions: 0, legs: 0, timeMin: 0 },
        };

        for (const m of x01All) {
            const kind = classifyX01MatchKind(m);
            const legs = Number(m?.totalLegs) || 0;
            const tmin = Math.max(0, Math.round((Number(m?.durationSec) || 0) / 60));
            if (kind === "BOT") {
                play.bot.sessions += 1;
                play.bot.legs += legs;
                play.bot.timeMin += tmin;
            } else {
                play.human.sessions += 1;
                play.human.legs += legs;
                play.human.timeMin += tmin;
            }
        }

        // --- Training (alles außer X01) ---
        const trainingBreakdown = {};
        let trainingTimeMin = 0;
        let trainingSessions = 0;

        try {
            for (const [k, rec] of (byActivity?.entries?.() || [])) {
                const key = String(k || "").toUpperCase();
                if (!key) continue;
                if (key === "X01_BOT" || key === "X01_HUMAN") continue;

                const sec = Number(rec?.sec || 0) || 0;
                const cnt = Number(rec?.count || 0) || 0;

                const tmin = Math.max(0, Math.round(sec / 60));
                trainingTimeMin += tmin;
                trainingSessions += Math.max(0, Math.round(cnt));

                if (tmin > 0 || cnt > 0) {
                    trainingBreakdown[key] = {
                        timeMin: tmin,
                        sessions: Math.max(0, Math.round(cnt)),
                    };
                }
            }
        } catch { /* ignore */ }

        // Segment Training sub-breakdown by segment type (Single/Double/Triple) for better Checkout-signal (0.14.189)
        let segmentTypeBreakdown = null;
        try {
            const segAll = (cache?.sessions || []).filter((s) => {
                const dk = s?.dayKey || parseIsoDateToDayKey(s?.createdAt) || parseIsoDateToDayKey(s?.finishedAt);
                return inPeriod(dk);
            });

            if (segAll && segAll.length) {
                const mk = () => ({ timeMin: 0, sessions: 0, dartsThrown: 0, attempts: 0, hits: 0, hitPct: null, avgDartsPerAttempt: null });
                const agg = { SINGLE: mk(), DOUBLE: mk(), TRIPLE: mk(), OTHER: mk() };

                const typeOf = (s) => {
                    const m = String(s?.mode || '').toLowerCase();
                    if (m.startsWith('single')) return 'SINGLE';
                    if (m.startsWith('double')) return 'DOUBLE';
                    if (m.startsWith('triple')) return 'TRIPLE';
                    return 'OTHER';
                };

                for (const s of segAll) {
                    const k = typeOf(s);
                    const r = agg[k] || agg.OTHER;
                    r.sessions += 1;
                    const tmin = Math.max(0, Math.round((Number(s?.durationSec || 0) || 0) / 60));
                    r.timeMin += tmin;
                    const darts = Math.max(0, Math.round(Number(s?.darts || 0) || 0));
                    const hits = Math.max(0, Math.round(Number(s?.hits || 0) || 0));
                    r.dartsThrown += darts;

                    // keep the same attempts/hits definition as the default training aggregation:
                    // attempts = dartsThrown, hits = hit-events (0.14.188)
                    r.attempts += darts;
                    r.hits += hits;
                }

                for (const r of Object.values(agg)) {
                    r.hitPct = (Number(r.attempts) || 0) > 0 ? ((Number(r.hits) || 0) / (Number(r.attempts) || 1)) : null;
                    r.avgDartsPerAttempt = (Number(r.attempts) || 0) > 0 ? ((Number(r.dartsThrown) || 0) / (Number(r.attempts) || 1)) : null;
                }

                segmentTypeBreakdown = agg;

                // Attach human-friendly labels for the LLM (copy/paste)
                try {
                    if (segmentTypeBreakdown?.SINGLE) { segmentTypeBreakdown.SINGLE.label = trainingNameShort.SEGMENT_SINGLE; segmentTypeBreakdown.SINGLE.coachLabel = trainingNameCoach.SEGMENT_SINGLE; }
                    if (segmentTypeBreakdown?.DOUBLE) { segmentTypeBreakdown.DOUBLE.label = trainingNameShort.SEGMENT_DOUBLE; segmentTypeBreakdown.DOUBLE.coachLabel = trainingNameCoach.SEGMENT_DOUBLE; }
                    if (segmentTypeBreakdown?.TRIPLE) { segmentTypeBreakdown.TRIPLE.label = trainingNameShort.SEGMENT_TRIPLE; segmentTypeBreakdown.TRIPLE.coachLabel = trainingNameCoach.SEGMENT_TRIPLE; }
                    if (segmentTypeBreakdown?.OTHER) { segmentTypeBreakdown.OTHER.label = 'Segment Training – OTHER'; segmentTypeBreakdown.OTHER.coachLabel = 'Segment Training – OTHER'; }
                } catch { /* ignore */ }

                if (trainingBreakdown?.SEGMENT_TRAINING) {
                    trainingBreakdown.SEGMENT_TRAINING.segmentTypeBreakdown = segmentTypeBreakdown;
                }
            }
        } catch { /* ignore */ }

        // Checkout-related training summary: Random Checkout + Segment Training (Double) (0.14.189)
        let checkoutRelatedTraining = null;
        try {
            const rc = trainingBreakdown?.RANDOM_CHECKOUT || null;
            const sd = segmentTypeBreakdown?.DOUBLE || null;

            const sumField = (a, b, k) => (Number(a?.[k] || 0) || 0) + (Number(b?.[k] || 0) || 0);
            const timeMin = sumField(rc, sd, 'timeMin');
            const sessions = sumField(rc, sd, 'sessions');
            const dartsThrown = sumField(rc, sd, 'dartsThrown');
            const attempts = sumField(rc, sd, 'attempts');
            const hits = sumField(rc, sd, 'hits');

            if (timeMin > 0 || sessions > 0 || dartsThrown > 0 || attempts > 0) {
                checkoutRelatedTraining = {
                    definition: 'Checkout-nahes Training = Random Checkout + Segment Training (Double).',
                    timeMin,
                    sessions,
                    dartsThrown,
                    attempts,
                    hits,
                    hitPct: (attempts > 0) ? (hits / attempts) : null,
                    avgDartsPerAttempt: (attempts > 0) ? (dartsThrown / attempts) : null,
                    sources: {
                        randomCheckout: rc || null,
                        segmentDouble: sd || null,
                    }
                };
            }
        } catch { /* ignore */ }

        // --- Player perf (auto, non-bot) ---
        const playerKey = adExt_chooseAutoPlayerKeyNonBot(x01All) || null;
        let x01Perf = null;

        try {
            if (playerKey) {
                const league = computeLeagueTable(x01All);
                const row = (league || []).find(r => String(r?.key || "") === String(playerKey));

                // Highscores / Brackets aus Match-Objekten summieren
                let s100 = 0, s140 = 0, s180 = 0;
                let legsPlayed = 0;
                let matchesPlayed = 0;

                for (const m of x01All) {
                    const idx = (m?.players || []).find(p => String(p?.key || "") === String(playerKey))?.index;
                    if (!Number.isFinite(Number(idx))) continue;
                    matchesPlayed += 1;
                    legsPlayed += Number(m?.totalLegs || 0) || 0;

                    const a100 = Array.isArray(m?.scores100PlusPerPlayer) ? m.scores100PlusPerPlayer : [];
                    const a140 = Array.isArray(m?.scores140PlusPerPlayer) ? m.scores140PlusPerPlayer : [];
                    const a180 = Array.isArray(m?.scores180PerPlayer) ? m.scores180PerPlayer : [];
                    s100 += Number(a100?.[idx] || 0) || 0;
                    s140 += Number(a140?.[idx] || 0) || 0;
                    s180 += Number(a180?.[idx] || 0) || 0;
                }

                if (row) {
                    const avg = (Number(row?.pointsPerDart) || 0) * 3;
                    const f9 = Number(row?.first9Avg);
                    const coAtt = Number(row?.coAtt) || 0;
                    const coHit = Number(row?.coHit) || 0;
                    const coPct = (coAtt > 0) ? (coHit / coAtt) : null;

                    x01Perf = {
                        playerKey,
                        playerName: String(row?.name || ""),
                        matches: Number(row?.matches) || matchesPlayed,
                        wins: Number(row?.wins) || 0,
                        losses: Number(row?.losses) || 0,
                        legsFor: Number(row?.legsFor) || 0,
                        legsAgainst: Number(row?.legsAgainst) || 0,
                        avg: Number.isFinite(avg) ? Math.round(avg * 100) / 100 : null,
                        first9Avg: Number.isFinite(f9) ? Math.round(f9 * 100) / 100 : null,
                        checkout: {
                            attempts: coAtt,
                            hits: coHit,
                            pct: (coPct == null) ? null : Math.round(coPct * 10000) / 100,
                        },
                        scoring: {
                            visits100Plus: s100,
                            visits140Plus: s140,
                            visits180: s180,
                        },
                    };
                }
            }
        } catch { /* ignore */ }

        let x01PerfSplit = null;
        try {
            if (playerKey) {
                const buildPerf = (matches, scopeLabel) => {
                    if (!Array.isArray(matches) || !matches.length) return null;
                    const league = computeLeagueTable(matches);
                    const row = (league || []).find(r => String(r?.key || "") === String(playerKey));

                    let s100 = 0, s140 = 0, s180 = 0;
                    let legsPlayed = 0;
                    let matchesPlayed = 0;

                    for (const m of matches) {
                        const idx = (m?.players || []).find(p => String(p?.key || "") === String(playerKey))?.index;
                        if (!Number.isFinite(Number(idx))) continue;
                        matchesPlayed += 1;
                        legsPlayed += Number(m?.totalLegs || 0) || 0;

                        const a100 = Array.isArray(m?.scores100PlusPerPlayer) ? m.scores100PlusPerPlayer : [];
                        const a140 = Array.isArray(m?.scores140PlusPerPlayer) ? m.scores140PlusPerPlayer : [];
                        const a180 = Array.isArray(m?.scores180PerPlayer) ? m.scores180PerPlayer : [];
                        s100 += Number(a100?.[idx] || 0) || 0;
                        s140 += Number(a140?.[idx] || 0) || 0;
                        s180 += Number(a180?.[idx] || 0) || 0;
                    }

                    if (!row) {
                        // fallback: if row missing, still provide scoring-only split
                        return {
                            scope: scopeLabel,
                            playerKey,
                            playerName: "",
                            matches: matchesPlayed,
                            wins: null,
                            losses: null,
                            legsFor: null,
                            legsAgainst: null,
                            avg: null,
                            first9Avg: null,
                            checkout: { attempts: null, hits: null, pct: null },
                            scoring: { visits100Plus: s100, visits140Plus: s140, visits180: s180 },
                            meta: { legsPlayed }
                        };
                    }

                    const avg = (Number(row?.pointsPerDart) || 0) * 3;
                    const f9 = Number(row?.first9Avg);
                    const coAtt = Number(row?.coAtt) || 0;
                    const coHit = Number(row?.coHit) || 0;
                    const coPct = (coAtt > 0) ? (coHit / coAtt) : null;

                    return {
                        scope: scopeLabel,
                        playerKey,
                        playerName: String(row?.name || ""),
                        matches: Number(row?.matches) || matchesPlayed,
                        wins: Number(row?.wins) || 0,
                        losses: Number(row?.losses) || 0,
                        legsFor: Number(row?.legsFor) || 0,
                        legsAgainst: Number(row?.legsAgainst) || 0,
                        avg: Number.isFinite(avg) ? Math.round(avg * 100) / 100 : null,
                        first9Avg: Number.isFinite(f9) ? Math.round(f9 * 100) / 100 : null,
                        checkout: {
                            attempts: coAtt,
                            hits: coHit,
                            pct: (coPct == null) ? null : Math.round(coPct * 10000) / 100,
                        },
                        scoring: {
                            visits100Plus: s100,
                            visits140Plus: s140,
                            visits180: s180,
                        },
                        meta: { legsPlayed }
                    };
                };

                const kinds = (cache?.x01MatchKinds || {});
                const kindOf = (m) => {
                    try {
                        const id = String(m?.matchId || m?.id || "");
                        const cached = kinds?.[id];
                        if (cached === 'BOT' || cached === 'HUMAN') return cached;
                    } catch {}
                    return classifyX01MatchKind(m);
                };

                const humanMatches = x01All.filter(m => kindOf(m) !== 'BOT');
                const botMatches = x01All.filter(m => kindOf(m) === 'BOT');

                x01PerfSplit = {
                    human: buildPerf(humanMatches, 'HUMAN'),
                    bot: buildPerf(botMatches, 'BOT'),
                };
            }
        } catch { /* ignore */ }

        // --- Opponent strength (AVG/Checkout/Bot level) (0.14.189) ---
        let x01OpponentPerf = null;
        let x01OpponentPerfSplit = null;
        try {
            if (playerKey) {
                const parseBotLevel = (name) => {
                    try {
                        const s = String(name || '');
                        const m = s.match(/bot\s*level\s*(\d+)/i);
                        if (m && m[1]) {
                            const n = Number(m[1]);
                            return Number.isFinite(n) ? n : null;
                        }
                    } catch {}
                    return null;
                };

                const buildOpp = (matches, scope) => {
                    try {
                        if (!matches || !matches.length) return null;
                        let oppDarts = 0, oppScore = 0, oppCoAtt = 0, oppCoHit = 0;
                        let opponents = 0;
                        const botLevels = [];

                        for (const m of matches) {
                            const my = (m?.players || []).find(p => String(p?.key || '') === String(playerKey));
                            const myIdx = Number(my?.index);
                            if (!Number.isFinite(myIdx)) continue;

                            const psArr = Array.isArray(m?.perPlayerStats) ? m.perPlayerStats : [];
                            for (const p of (m?.players || [])) {
                                const pi = Number(p?.index);
                                if (!Number.isFinite(pi) || pi == myIdx) continue;
                                opponents += 1;
                                const st = psArr?.[pi] || null;

                                const darts = Number(st?.dartsThrown || st?.darts || 0) || 0;
                                const score = Number(st?.score || st?.points || 0) || 0;
                                oppDarts += Math.max(0, darts);
                                oppScore += Math.max(0, score);

                                oppCoAtt += Math.max(0, Number(st?.checkouts || st?.checkoutAttempts || 0) || 0);
                                oppCoHit += Math.max(0, Number(st?.checkoutsHit || st?.checkoutHits || 0) || 0);

                                const lvl = parseBotLevel(p?.name || st?.name || '');
                                if (lvl != null) botLevels.push(lvl);
                            }
                        }

                        const avg = (oppDarts > 0) ? ((oppScore * 3) / oppDarts) : null;
                        const coPct = (oppCoAtt > 0) ? (oppCoHit / oppCoAtt) : null;

                        let botLevel = null;
                        if (botLevels.length) {
                            const s = botLevels.reduce((a, b) => a + b, 0);
                            botLevel = {
                                avg: Math.round((s / botLevels.length) * 100) / 100,
                                min: Math.min(...botLevels),
                                max: Math.max(...botLevels),
                                count: botLevels.length,
                            };
                        }

                        return {
                            playerKey,
                            scope,
                            opponents,
                            avg: Number.isFinite(avg) ? Math.round(avg * 100) / 100 : null,
                            checkout: {
                                attempts: oppCoAtt,
                                hits: oppCoHit,
                                pct: (coPct == null) ? null : Math.round(coPct * 10000) / 100,
                            },
                            botLevel,
                        };
                    } catch { return null; }
                };

                x01OpponentPerf = buildOpp(x01All, 'ALL');

                const humanMatches = x01All.filter(m => classifyX01MatchKind(m) !== 'BOT');
                const botMatches = x01All.filter(m => classifyX01MatchKind(m) === 'BOT');
                x01OpponentPerfSplit = {
                    human: buildOpp(humanMatches, 'HUMAN'),
                    bot: buildOpp(botMatches, 'BOT'),
                };
            }
        } catch { /* ignore */ }


        const lite = {
            schema: "ad-ext-lite-v1",
            period: {
                weekKey: String(weekKey || ""),
                label: adExt_fmtWeekLabel(weekKey),
                startDayKey: wk?.startKey || null,
                endDayKey: wk?.endKey || null,
            },
            playReference: {
                definition: "Alle X01 Spiele mit Double Out (sofern in der Historie vorhanden). Split: Gegner = Bot vs Human.",
                x01DoubleOut: {
                    human: play.human,
                    bot: play.bot,
                    total: {
                        sessions: play.human.sessions + play.bot.sessions,
                        legs: play.human.legs + play.bot.legs,
                        timeMin: play.human.timeMin + play.bot.timeMin,
                    },
                },
            },
            training: {
                definition: "Alle Trainingseinheiten (Segment Training, ATC, CountUp, Cricket, Random Checkout, …) ohne X01.",
                total: {
                    timeMin: trainingTimeMin,
                    sessions: trainingSessions,
                },
                breakdown: trainingBreakdown,
            },
            x01Performance: x01Perf,
            x01PerformanceSplit: x01PerfSplit,
            x01OpponentPerformance: x01OpponentPerf,
            x01OpponentPerformanceSplit: x01OpponentPerfSplit,
            x01DerivedSignals: x01DerivedSignals,
        };

        return lite;
    }

    function adExt_buildLiteJsonForTrainingPeriod(period) {
        const pType = String(period?.type || "WEEK").toUpperCase();
        const startKey = String(period?.startDayKey || "").trim();
        const endKey = String(period?.endDayKey || "").trim();
        const label = String(period?.label || "").trim();
        const weekKeyAnchor = String(period?.weekKeyAnchor || "").trim();

        const inPeriod = (dk) => {
            if (pType === "ALL") return true;
            const s = String(dk || "");
            if (!s) return false;
            if (!startKey || !endKey) return true;
            return s >= startKey && s <= endKey;
        };

        // --- X01 Matches in period ---
        const x01InRange = (cache?.x01Matches || []).filter((m) => {
            const dk = m?.dayKey || parseIsoDateToDayKey(m?.createdAt) || parseIsoDateToDayKey(m?.finishedAt);
            return inPeriod(dk);
        });

        const isDouble = (m) => {
            try {
                if (m?.isDoubleOut === true) return true;
                const s = String(m?.outMode || "").toLowerCase();
                if (s.includes('double')) return true;
            } catch {}
            return false;
        };

        let x01All = x01InRange.filter(isDouble);
        let outAssumed = false;
        if (!x01All.length && x01InRange.length) {
            // If we can't detect out mode reliably, fall back to all X01 in period and note it.
            x01All = x01InRange;
            outAssumed = true;
        }

        const playHuman = { sessions: 0, legs: 0, timeMin: 0 };
        const playBot = { sessions: 0, legs: 0, timeMin: 0 };

        for (const m of x01All) {
            const kind = classifyX01MatchKind(m);
            const legs = Number(m?.totalLegs) || 0;
            const tmin = Math.max(0, Math.round((Number(m?.durationSec) || 0) / 60));
            if (kind === "BOT") {
                playBot.sessions += 1;
                playBot.legs += legs;
                playBot.timeMin += tmin;
            } else {
                playHuman.sessions += 1;
                playHuman.legs += legs;
                playHuman.timeMin += tmin;
            }
        }

        // --- Training aggregation for period ---
        let agg = null;
        if (pType === 'ALL') {
            agg = aggregateTrainingActualsAllTime();
        } else {
            agg = aggregateTrainingActualsForDayKeyRange(startKey, endKey);
        }
        const byActivity = agg?.byActivity || new Map();

        // Extra task aggregation for ATC (fields attempted/solved), derived from best-effort fieldsAgg (0.14.188)
        let atcTaskAttempts = 0;
        let atcTaskHits = 0;
        try {
            for (const s of (cache?.otherTrainingSessions || [])) {
                const key = String(s?.activityKey || '').trim().toUpperCase();
                if (key !== 'ATC') continue;

                const dk = s?.dayKey || parseIsoDateToDayKey(s?.createdAt) || parseIsoDateToDayKey(s?.finishedAt);
                if (!inPeriod(dk)) continue;

                const fa = s?.fieldsAgg;
                if (fa && typeof fa === 'object') {
                    let a = 0;
                    let h = 0;
                    for (const v of Object.values(fa)) {
                        const d = Number(v?.darts || 0) || 0;
                        const hh = Number(v?.hits || 0) || 0;
                        if (d > 0) a += 1;
                        if (hh > 0) h += 1;
                    }
                    atcTaskAttempts += a;
                    atcTaskHits += h;
                }
            }
        } catch { /* ignore */ }

        const trainingBreakdown = {};
        let trainingTimeMin = 0;
        let trainingSessions = 0;
        let trainingDartsThrown = 0;
        let trainingAttempts = 0;
        let trainingHits = 0;

        // Training activity names MUST match the "Aktivität hinzufügen" templates in the Trainingsplan UI.
        const trainingActivityNames = (() => {
            const out = {};
            try {
                if (typeof PLAN_ACTIVITY_TEMPLATES !== "undefined" && Array.isArray(PLAN_ACTIVITY_TEMPLATES)) {
                    for (const tpl of PLAN_ACTIVITY_TEMPLATES) {
                        const t = String(tpl?.type || "").trim().toUpperCase();
                        const n = String(tpl?.name || "").trim();
                        if (t && n) out[t] = n;
                    }
                }
            } catch {}
            // Fallback defaults (keep in sync with PLAN_ACTIVITY_TEMPLATES)
            if (!out.ATC) out.ATC = "ATC";
            if (!out.COUNTUP) out.COUNTUP = "CountUp";
            if (!out.CRICKET) out.CRICKET = "Cricket";
            if (!out.RANDOM_CHECKOUT) out.RANDOM_CHECKOUT = "Random Checkout";
            if (!out.SEGMENT_TRAINING) out.SEGMENT_TRAINING = "Segment Training";
            if (!out.X01_BOT) out.X01_BOT = "X01 vs Bot";
            if (!out.X01_HUMAN) out.X01_HUMAN = "X01 vs Mensch";
            return out;
        })();

        // Training templates (for the LLM: use these names verbatim in the 7-day plan)
        const trainingActivityTemplates = (() => {
            try {
                if (typeof PLAN_ACTIVITY_TEMPLATES !== "undefined" && Array.isArray(PLAN_ACTIVITY_TEMPLATES)) {
                    return PLAN_ACTIVITY_TEMPLATES.map(t => ({
                        type: String(t?.type || "").trim(),
                        name: String(t?.name || "").trim(),
                        defaultLegs: getDefaultSessionsForPlanType(String(t?.type || "")),
                    })).filter(x => x.type && x.name);
                }
            } catch {}
            return null;
        })();

        // Training naming vocabulary for the LLM (labels in breakdowns)
        const trainingNameShort = {
            ATC: trainingActivityNames.ATC,
            COUNTUP: trainingActivityNames.COUNTUP,
            CRICKET: trainingActivityNames.CRICKET,
            RANDOM_CHECKOUT: trainingActivityNames.RANDOM_CHECKOUT,
            SEGMENT_TRAINING: trainingActivityNames.SEGMENT_TRAINING,
            X01_BOT: trainingActivityNames.X01_BOT,
            X01_HUMAN: trainingActivityNames.X01_HUMAN,
            SEGMENT_SINGLE: "Segment Training – SINGLE",
            SEGMENT_DOUBLE: "Segment Training – DOUBLE",
            SEGMENT_TRIPLE: "Segment Training – TRIPLE",
        };
        // Coach labels: keep EXACTLY the same strings as in the UI templates (copy/paste)
        const trainingNameCoach = {
            ATC: trainingActivityNames.ATC,
            COUNTUP: trainingActivityNames.COUNTUP,
            CRICKET: trainingActivityNames.CRICKET,
            RANDOM_CHECKOUT: trainingActivityNames.RANDOM_CHECKOUT,
            SEGMENT_TRAINING: trainingActivityNames.SEGMENT_TRAINING,
            SEGMENT_SINGLE: trainingActivityNames.SEGMENT_TRAINING,
            SEGMENT_DOUBLE: trainingActivityNames.SEGMENT_TRAINING,
            SEGMENT_TRIPLE: trainingActivityNames.SEGMENT_TRAINING,
            X01_BOT: trainingActivityNames.X01_BOT,
            X01_HUMAN: trainingActivityNames.X01_HUMAN,
        };

        try {
            for (const [k, rec] of (byActivity?.entries?.() || [])) {
                const key = String(k || '').toUpperCase();
                if (!key) continue;
                if (key === "X01_BOT" || key === "X01_HUMAN") continue;

                const sec = Number(rec?.sec || 0) || 0;
                const cnt = Number(rec?.count || 0) || 0;
                const tmin = Math.max(0, Math.round(sec / 60));

                const dartsThrown = Math.max(0, Math.round(Number(rec?.darts || 0) || 0));

                // Attempts/Hits definition per mode:
                // - RANDOM_CHECKOUT: attempts = checkout opportunities, hits = checkouts hit
                // - ATC: attempts/hits = fields attempted/solved (derived from fieldsAgg)
                // - default: attempts = dartsThrown, hits = rec.hits (hit events)
                let attempts = 0;
                let hits = 0;

                if (key === 'RANDOM_CHECKOUT') {
                    attempts = Math.max(0, Math.round(Number(rec?.checkoutAttempts || 0) || 0));
                    hits = Math.max(0, Math.round(Number(rec?.checkoutHits || 0) || 0));
                } else if (key === 'ATC') {
                    attempts = Math.max(0, Math.round(Number(atcTaskAttempts || 0) || 0));
                    hits = Math.max(0, Math.round(Number(atcTaskHits || 0) || 0));
                } else {
                    attempts = dartsThrown;
                    hits = Math.max(0, Math.round(Number(rec?.hits || 0) || 0));
                }

                const hitPct = attempts > 0 ? (hits / attempts) : null;
                const avgDartsPerAttempt = attempts > 0 ? (dartsThrown / attempts) : null;

                trainingTimeMin += tmin;
                trainingSessions += Math.max(0, Math.round(cnt));

                trainingDartsThrown += dartsThrown;
                trainingAttempts += attempts;
                trainingHits += hits;

                if (tmin > 0 || cnt > 0 || dartsThrown > 0 || attempts > 0) {
                    trainingBreakdown[key] = {
                        label: trainingNameShort[key] || key,
                        coachLabel: trainingNameCoach[key] || (trainingNameShort[key] || key),
                        timeMin: tmin,
                        sessions: Math.max(0, Math.round(cnt)),
                        dartsThrown,
                        attempts,
                        hits,
                        hitPct,
                        avgDartsPerAttempt,
                    };
                }
            }
        } catch { /* ignore */ }



        // Segment Training sub-breakdown by segment type (Single/Double/Triple) for better Checkout-signal (0.14.189)
        let segmentTypeBreakdown = null;
        try {
            const segAll = (cache?.sessions || []).filter((s) => {
                const dk = s?.dayKey || parseIsoDateToDayKey(s?.createdAt) || parseIsoDateToDayKey(s?.finishedAt);
                return inPeriod(dk);
            });

            if (segAll && segAll.length) {
                const mk = () => ({ timeMin: 0, sessions: 0, dartsThrown: 0, attempts: 0, hits: 0, hitPct: null, avgDartsPerAttempt: null });
                const agg = { SINGLE: mk(), DOUBLE: mk(), TRIPLE: mk(), OTHER: mk() };

                const typeOf = (s) => {
                    const m = String(s?.mode || '').toLowerCase();
                    if (m.startsWith('single')) return 'SINGLE';
                    if (m.startsWith('double')) return 'DOUBLE';
                    if (m.startsWith('triple')) return 'TRIPLE';
                    return 'OTHER';
                };

                for (const s of segAll) {
                    const k = typeOf(s);
                    const r = agg[k] || agg.OTHER;
                    r.sessions += 1;
                    const tmin = Math.max(0, Math.round((Number(s?.durationSec || 0) || 0) / 60));
                    r.timeMin += tmin;
                    const darts = Math.max(0, Math.round(Number(s?.darts || 0) || 0));
                    const hits = Math.max(0, Math.round(Number(s?.hits || 0) || 0));
                    r.dartsThrown += darts;

                    // keep the same attempts/hits definition as the default training aggregation:
                    // attempts = dartsThrown, hits = hit-events (0.14.188)
                    r.attempts += darts;
                    r.hits += hits;
                }

                for (const r of Object.values(agg)) {
                    r.hitPct = (Number(r.attempts) || 0) > 0 ? ((Number(r.hits) || 0) / (Number(r.attempts) || 1)) : null;
                    r.avgDartsPerAttempt = (Number(r.attempts) || 0) > 0 ? ((Number(r.dartsThrown) || 0) / (Number(r.attempts) || 1)) : null;
                }

                segmentTypeBreakdown = agg;
                if (trainingBreakdown?.SEGMENT_TRAINING) {
                    trainingBreakdown.SEGMENT_TRAINING.segmentTypeBreakdown = segmentTypeBreakdown;
                }
            }
        } catch { /* ignore */ }

        // Checkout-related training summary: Random Checkout + Segment Training (Double) (0.14.189)
        let checkoutRelatedTraining = null;
        try {
            const rc = trainingBreakdown?.RANDOM_CHECKOUT || null;
            const sd = segmentTypeBreakdown?.DOUBLE || null;

            const sumField = (a, b, k) => (Number(a?.[k] || 0) || 0) + (Number(b?.[k] || 0) || 0);
            const timeMin = sumField(rc, sd, 'timeMin');
            const sessions = sumField(rc, sd, 'sessions');
            const dartsThrown = sumField(rc, sd, 'dartsThrown');
            const attempts = sumField(rc, sd, 'attempts');
            const hits = sumField(rc, sd, 'hits');

            if (timeMin > 0 || sessions > 0 || dartsThrown > 0 || attempts > 0) {
                checkoutRelatedTraining = {
                    definition: 'Checkout-nahes Training = Random Checkout + Segment Training (Double).',
                    timeMin,
                    sessions,
                    dartsThrown,
                    attempts,
                    hits,
                    hitPct: (attempts > 0) ? (hits / attempts) : null,
                    avgDartsPerAttempt: (attempts > 0) ? (dartsThrown / attempts) : null,
                    sources: {
                        randomCheckout: rc || null,
                        segmentDouble: sd || null,
                    }
                };
            }
        } catch { /* ignore */ }

        // --- Player perf (auto, non-bot) ---
        const playerKey = adExt_chooseAutoPlayerKeyNonBot(x01All) || null;
        let x01Perf = null;
        try {
            if (playerKey) {
                const league = computeLeagueTable(x01All);
                const row = (league || []).find(r => String(r?.key || "") === String(playerKey));

                let s100 = 0, s140 = 0, s180 = 0;
                let legsPlayed = 0;
                let matchesPlayed = 0;

                for (const m of x01All) {
                    const idx = (m?.players || []).find(p => String(p?.key || "") === String(playerKey))?.index;
                    if (!Number.isFinite(Number(idx))) continue;
                    matchesPlayed += 1;
                    legsPlayed += Number(m?.totalLegs || 0) || 0;

                    const a100 = Array.isArray(m?.scores100PlusPerPlayer) ? m.scores100PlusPerPlayer : [];
                    const a140 = Array.isArray(m?.scores140PlusPerPlayer) ? m.scores140PlusPerPlayer : [];
                    const a180 = Array.isArray(m?.scores180PerPlayer) ? m.scores180PerPlayer : [];
                    s100 += Number(a100?.[idx] || 0) || 0;
                    s140 += Number(a140?.[idx] || 0) || 0;
                    s180 += Number(a180?.[idx] || 0) || 0;
                }

                if (row) {
                    const avg = (Number(row?.pointsPerDart) || 0) * 3;
                    const f9 = Number(row?.first9Avg);
                    const coAtt = Number(row?.coAtt) || 0;
                    const coHit = Number(row?.coHit) || 0;
                    const coPct = (coAtt > 0) ? (coHit / coAtt) : null;

                    x01Perf = {
                        playerKey,
                        playerName: String(row?.name || ""),
                        matches: Number(row?.matches) || matchesPlayed,
                        wins: Number(row?.wins) || 0,
                        losses: Number(row?.losses) || 0,
                        legsFor: Number(row?.legsFor) || 0,
                        legsAgainst: Number(row?.legsAgainst) || 0,
                        avg: Number.isFinite(avg) ? Math.round(avg * 100) / 100 : null,
                        first9Avg: Number.isFinite(f9) ? Math.round(f9 * 100) / 100 : null,
                        checkout: {
                            attempts: coAtt,
                            hits: coHit,
                            pct: (coPct == null) ? null : Math.round(coPct * 10000) / 100,
                        },
                        scoring: {
                            visits100Plus: s100,
                            visits140Plus: s140,
                            visits180: s180,
                        },
                        meta: {
                            legsPlayed,
                        }
                    };
                }
            }
        } catch { /* ignore */ }

        // --- Player perf split (vs Human / vs Bot) ---
        let x01PerfSplit = null;
        try {
            if (playerKey) {
                const humanMatches = x01All.filter(m => classifyX01MatchKind(m) !== 'BOT');
                const botMatches = x01All.filter(m => classifyX01MatchKind(m) === 'BOT');

                const buildPerf = (matches, scope) => {
                    try {
                        if (!matches || !matches.length) return null;
                        const league = computeLeagueTable(matches);
                        const row = (league || []).find(r => String(r?.key || '') === String(playerKey));
                        if (!row) return null;

                        let s100 = 0, s140 = 0, s180 = 0;
                        let legsPlayed = 0;
                        let matchesPlayed = 0;
                        for (const m of matches) {
                            const idx = (m?.players || []).find(p => String(p?.key || '') === String(playerKey))?.index;
                            if (!Number.isFinite(Number(idx))) continue;
                            matchesPlayed += 1;
                            legsPlayed += Number(m?.totalLegs || 0) || 0;
                            const a100 = Array.isArray(m?.scores100PlusPerPlayer) ? m.scores100PlusPerPlayer : [];
                            const a140 = Array.isArray(m?.scores140PlusPerPlayer) ? m.scores140PlusPerPlayer : [];
                            const a180 = Array.isArray(m?.scores180PerPlayer) ? m.scores180PerPlayer : [];
                            s100 += Number(a100?.[idx] || 0) || 0;
                            s140 += Number(a140?.[idx] || 0) || 0;
                            s180 += Number(a180?.[idx] || 0) || 0;
                        }

                        const avg = (Number(row?.pointsPerDart) || 0) * 3;
                        const f9 = Number(row?.first9Avg);
                        const coAtt = Number(row?.coAtt) || 0;
                        const coHit = Number(row?.coHit) || 0;
                        const coPct = (coAtt > 0) ? (coHit / coAtt) : null;

                        return {
                            playerKey,
                            playerName: String(row?.name || ''),
                            matches: Number(row?.matches) || matchesPlayed,
                            wins: Number(row?.wins) || 0,
                            losses: Number(row?.losses) || 0,
                            legsFor: Number(row?.legsFor) || 0,
                            legsAgainst: Number(row?.legsAgainst) || 0,
                            avg: Number.isFinite(avg) ? Math.round(avg * 100) / 100 : null,
                            first9Avg: Number.isFinite(f9) ? Math.round(f9 * 100) / 100 : null,
                            checkout: {
                                attempts: coAtt,
                                hits: coHit,
                                pct: (coPct == null) ? null : Math.round(coPct * 10000) / 100,
                            },
                            scoring: {
                                visits100Plus: s100,
                                visits140Plus: s140,
                                visits180: s180,
                            },
                            meta: { legsPlayed, scope }
                        };
                    } catch { return null; }
                };

                x01PerfSplit = {
                    human: buildPerf(humanMatches, 'HUMAN'),
                    bot: buildPerf(botMatches, 'BOT'),
                };
            }
        } catch { /* ignore */ }

        // --- Opponent strength (AVG/Checkout/Bot level) (0.14.189) ---
        let x01OpponentPerf = null;
        let x01OpponentPerfSplit = null;
        try {
            if (playerKey) {
                const parseBotLevel = (name) => {
                    try {
                        const s = String(name || '').trim();
                        if (!s) return null;
                        const m = s.match(/bot\s*level\s*(\d+)/i);
                        if (m && m[1]) {
                            const n = Number(m[1]);
                            return Number.isFinite(n) ? n : null;
                        }
                    } catch {}
                    return null;
                };

                const buildOpp = (matches, scope) => {
                    try {
                        if (!matches || !matches.length) return null;
                        let oppDarts = 0;
                        let oppScore = 0;
                        let oppCoAtt = 0;
                        let oppCoHit = 0;
                        let oppPlayers = 0;
                        const botLevels = [];

                        for (const m of matches) {
                            const my = (m?.players || []).find(p => String(p?.key || '') === String(playerKey));
                            const myIdx = Number(my?.index);
                            if (!Number.isFinite(myIdx)) continue;

                            const psArr = Array.isArray(m?.perPlayerStats) ? m.perPlayerStats : [];
                            for (const p of (m?.players || [])) {
                                const pi = Number(p?.index);
                                if (!Number.isFinite(pi) || pi === myIdx) continue;
                                oppPlayers += 1;

                                const st = psArr?.[pi] || null;
                                const darts = Math.max(0, Number(st?.dartsThrown || st?.darts || 0) || 0);
                                const score = Math.max(0, Number(st?.score || st?.points || 0) || 0);
                                oppDarts += darts;
                                oppScore += score;

                                oppCoAtt += Math.max(0, Number(st?.checkouts || st?.checkoutAttempts || 0) || 0);
                                oppCoHit += Math.max(0, Number(st?.checkoutsHit || st?.checkoutHits || 0) || 0);

                                const lvl = parseBotLevel(p?.name || st?.name || '');
                                if (lvl != null) botLevels.push(lvl);
                            }
                        }

                        const avg = (oppDarts > 0) ? ((oppScore * 3) / oppDarts) : null;
                        const coPct = (oppCoAtt > 0) ? (oppCoHit / oppCoAtt) : null;

                        let botLevel = null;
                        if (botLevels.length) {
                            const s = botLevels.reduce((a, b) => a + b, 0);
                            botLevel = {
                                avg: Math.round((s / botLevels.length) * 100) / 100,
                                min: Math.min(...botLevels),
                                max: Math.max(...botLevels),
                                count: botLevels.length,
                            };
                        }

                        return {
                            playerKey,
                            scope,
                            opponents: oppPlayers,
                            avg: Number.isFinite(avg) ? Math.round(avg * 100) / 100 : null,
                            checkout: {
                                attempts: Math.max(0, Math.round(oppCoAtt)),
                                hits: Math.max(0, Math.round(oppCoHit)),
                                pct: (coPct == null) ? null : Math.round(coPct * 10000) / 100,
                            },
                            botLevel,
                            meta: { oppDarts: Math.max(0, Math.round(oppDarts)), oppScore: Math.max(0, Math.round(oppScore)) },
                        };
                    } catch { return null; }
                };

                x01OpponentPerf = buildOpp(x01All, 'ALL');

                const humanMatches2 = x01All.filter(m => classifyX01MatchKind(m) !== 'BOT');
                const botMatches2 = x01All.filter(m => classifyX01MatchKind(m) === 'BOT');

                x01OpponentPerfSplit = {
                    human: buildOpp(humanMatches2, 'HUMAN'),
                    bot: buildOpp(botMatches2, 'BOT'),
                };
            }
        } catch { /* ignore */ }



        // --- Derived X01 signals: Busts / Restscore profile / Checkout routes (0.14.190) ---
        let x01DerivedSignals = null;
        try {
            if (playerKey) {
                let visits = 0;
                let busts = 0;
                let bustPoints = 0;

                let le40 = 0, le80 = 0, le120 = 0, le170 = 0, gt170 = 0;
                let bogey = 0;
                let oneDart = 0;

                let coOpp = 0;
                let coHit = 0;

                const firstDart = new Map();
                const routes = new Map();
                let startScore = null;

                for (const m of (x01All || [])) {
                    const idx = (m?.players || []).find(p => String(p?.key || '') === String(playerKey))?.index;
                    if (!Number.isFinite(Number(idx))) continue;

                    const dx = m?.x01Derived || null;
                    if (!dx) continue;

                    if (startScore == null && dx?.startScore != null && Number.isFinite(Number(dx.startScore))) {
                        startScore = Math.round(Number(dx.startScore));
                    }

                    visits += Math.max(0, Number(dx?.visitsPerPlayer?.[idx] || 0) || 0);
                    busts += Math.max(0, Number(dx?.bustsPerPlayer?.[idx] || 0) || 0);
                    bustPoints += Math.max(0, Number(dx?.bustPointsPerPlayer?.[idx] || 0) || 0);

                    const b = dx?.leaveBucketsPerPlayer?.[idx];
                    if (b && typeof b === 'object') {
                        le40 += Math.max(0, Number(b?.le40 || 0) || 0);
                        le80 += Math.max(0, Number(b?.le80 || 0) || 0);
                        le120 += Math.max(0, Number(b?.le120 || 0) || 0);
                        le170 += Math.max(0, Number(b?.le170 || 0) || 0);
                        gt170 += Math.max(0, Number(b?.gt170 || 0) || 0);
                    }
                    bogey += Math.max(0, Number(dx?.bogeyLeavesPerPlayer?.[idx] || 0) || 0);
                    oneDart += Math.max(0, Number(dx?.oneDartLeavesPerPlayer?.[idx] || 0) || 0);

                    coOpp += Math.max(0, Number(dx?.checkoutOppsPerPlayer?.[idx] || 0) || 0);
                    coHit += Math.max(0, Number(dx?.checkoutHitsPerPlayer?.[idx] || 0) || 0);

                    const fdObj = dx?.firstDartCountsPerPlayer?.[idx];
                    if (fdObj && typeof fdObj === 'object') {
                        for (const [k, v] of Object.entries(fdObj)) {
                            const kk = String(k || '').trim();
                            if (!kk) continue;
                            const vv = Math.max(0, Number(v || 0) || 0);
                            if (!vv) continue;
                            firstDart.set(kk, (firstDart.get(kk) || 0) + vv);
                        }
                    }

                    const rtArr = dx?.topRoutesPerPlayer?.[idx];
                    if (Array.isArray(rtArr)) {
                        for (const it of rtArr) {
                            const route = String(it?.route || '').trim();
                            if (!route) continue;
                            const cur = routes.get(route) || { count: 0, hits: 0, busts: 0 };
                            cur.count += Math.max(0, Number(it?.count || 0) || 0);
                            cur.hits += Math.max(0, Number(it?.hits || 0) || 0);
                            cur.busts += Math.max(0, Number(it?.busts || 0) || 0);
                            routes.set(route, cur);
                        }
                    }
                }

                const leavesTotal = le40 + le80 + le120 + le170 + gt170;
                const finishableLeaves = le40 + le80 + le120 + le170;
                const bustPct = (visits > 0) ? (busts / visits) : null;
                const coPct = (coOpp > 0) ? (coHit / coOpp) : null;

                const firstDartTop = Array.from(firstDart.entries())
                    .map(([k, v]) => ({ key: k, count: Math.max(0, Math.round(Number(v || 0) || 0)) }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 10);

                const topRoutes = Array.from(routes.entries())
                    .map(([route, st]) => ({
                        route,
                        count: Math.max(0, Math.round(Number(st?.count || 0) || 0)),
                        hits: Math.max(0, Math.round(Number(st?.hits || 0) || 0)),
                        busts: Math.max(0, Math.round(Number(st?.busts || 0) || 0)),
                    }))
                    .sort((a, b) => (b.count - a.count) || (b.hits - a.hits))
                    .slice(0, 12);

                if (visits > 0 || leavesTotal > 0 || coOpp > 0) {
                    x01DerivedSignals = {
                        playerKey,
                        startScore,
                        bust: {
                            visits: Math.max(0, Math.round(visits)),
                            busts: Math.max(0, Math.round(busts)),
                            bustPct: (bustPct == null) ? null : Math.round((bustPct * 100) * 100) / 100,
                            bustPoints: Math.max(0, Math.round(bustPoints)),
                            bustPointsPerBust: (busts > 0) ? Math.round((bustPoints / busts) * 100) / 100 : null,
                        },
                        restScore: {
                            leavesTotal: Math.max(0, Math.round(leavesTotal)),
                            buckets: { le40, le80, le120, le170, gt170 },
                            finishableLeaves: Math.max(0, Math.round(finishableLeaves)),
                            finishableLeavesPct: (leavesTotal > 0) ? Math.round(((finishableLeaves / leavesTotal) * 100) * 100) / 100 : null,
                            bogeyLeaves: Math.max(0, Math.round(bogey)),
                            bogeyLeavesPct: (leavesTotal > 0) ? Math.round(((bogey / leavesTotal) * 100) * 100) / 100 : null,
                            oneDartLeaves: Math.max(0, Math.round(oneDart)),
                            oneDartLeavesPct: (leavesTotal > 0) ? Math.round(((oneDart / leavesTotal) * 100) * 100) / 100 : null,
                        },
                        routes: {
                            checkoutOpps: Math.max(0, Math.round(coOpp)),
                            checkoutHits: Math.max(0, Math.round(coHit)),
                            checkoutPct: (coPct == null) ? null : Math.round((coPct * 100) * 100) / 100,
                            firstDartTop,
                            topRoutes,
                        }
                    };
                }
            }
        } catch { /* ignore */ }
        const periodObj = {
            type: pType,
            label: label || (pType === 'ALL' ? 'Alles' : '—'),
            weekKeyAnchor: weekKeyAnchor || null,
            startDayKey: (pType === 'ALL') ? null : (startKey || null),
            endDayKey: (pType === 'ALL') ? null : (endKey || null),
        };

        const balanceDef = {
            playReference: outAssumed ? 'X01 (Out-Mode nicht erkannt → alle X01 im Zeitraum verwendet)' : 'X01 Double Out',
            split: ['playHuman', 'playBot'],
            trainingReference: 'all non X01-DoubleOut',
            metricPriority: ['timeMin', 'sessions', 'legs'],
        };

        // Data availability flags to help the LLM avoid guessing and reduce "Datenlücken" chatter.
        const dataAvailability = {
            hasBustData: !!(x01DerivedSignals && (Number(x01DerivedSignals?.bust?.visits) || 0) > 0),
            hasRestScoreData: !!(x01DerivedSignals && (Number(x01DerivedSignals?.restScore?.leavesTotal) || 0) > 0),
            hasRouteData: !!(x01DerivedSignals && (Number(x01DerivedSignals?.routes?.checkoutOpps) || 0) > 0),
            hasBotHumanSplit: !!(x01PerfSplit && (x01PerfSplit.human || x01PerfSplit.bot)),
            hasTrainingOutcome: ((Number(trainingAttempts) || 0) > 0 || (Number(trainingDartsThrown) || 0) > 0),
            hasCheckoutTrainingSignal: !!(checkoutRelatedTraining && ((Number(checkoutRelatedTraining?.timeMin) || 0) > 0 || (Number(checkoutRelatedTraining?.sessions) || 0) > 0)),
            hasOpponentStrengthData: !!(x01OpponentPerf && (x01OpponentPerf.avg != null || (Number(x01OpponentPerf?.checkout?.attempts) || 0) > 0 || x01OpponentPerf.botLevel)),
            notes: [],
        };
        if (outAssumed) dataAvailability.notes.push('outModeAssumed');
        if (!x01Perf) dataAvailability.notes.push('noX01Performance');

        const lite = {
            schema: 'ad-ext-lite-v2',
            meta: {
                generatedAt: (new Date()).toISOString(),
                source: 'MatchInsights userscript',
                version: SCRIPT_VERSION,
                trainingNames: {
                    // Canonical activity names: MUST match "Aktivität hinzufügen" in Trainingsplan
                    activities: trainingActivityNames,
                    // Labels used in breakdowns (can include sub-modes like Segment DOUBLE)
                    breakdownLabels: trainingNameShort,
                    // Backwards-compat: coach labels (kept, but aligned with template names)
                    coach: trainingNameCoach,
                    note: 'Nutze meta.trainingActivityTemplates[].name (oder meta.trainingNames.activities) exakt als Trainingsnamen im 7-Tage-Plan (copy/paste). Wichtiger: Segment-Fokus (DOUBLE/SINGLE/TRIPLE) NICHT in den Namen schreiben, sondern in die Setup-Zeilen (z.B. "Modus: DOUBLE").',
                },
                trainingActivityTemplates: trainingActivityTemplates || undefined,
            },
            period: periodObj,
            balanceDefinition: balanceDef,
            dataAvailability,
            balance: {
                playHuman,
                playBot,
                training: {
                    timeMin: trainingTimeMin,
                    sessions: trainingSessions,
                    dartsThrown: trainingDartsThrown,
                    attempts: trainingAttempts,
                    hits: trainingHits,
                    hitPct: (Number(trainingAttempts) || 0) > 0 ? ((Number(trainingHits) || 0) / (Number(trainingAttempts) || 1)) : null,
                    avgDartsPerAttempt: (Number(trainingAttempts) || 0) > 0 ? ((Number(trainingDartsThrown) || 0) / (Number(trainingAttempts) || 1)) : null,
                    legs: null,
                    breakdown: trainingBreakdown,
                    checkoutRelated: checkoutRelatedTraining,
                }
            },
            x01Performance: x01Perf,
            x01PerformanceSplit: x01PerfSplit,
            x01OpponentPerformance: x01OpponentPerf,
            x01OpponentPerformanceSplit: x01OpponentPerfSplit,
        };

        return lite;
    }


    function adExt_buildMarkdownPrompt(liteJson, templateKey) {
        const tpl = String(templateKey || "LONG").toUpperCase();
        const jsonStr = JSON.stringify(liteJson, null, 2);

        const header = `# Autodarts Analyse (Match + Training)

` +
`Du bist Darts-Coach & Performance-Analyst. Analysiere die Daten objektiv und belege Aussagen immer mit Zahlen aus dem JSON.

` +
`## Ziele
` +
`1) Leistung & Schwächen erkennen (Scoring, Checkout, Konstanz, Fehler)
` +
`2) Konkrete Trainingsaufgaben ableiten (nächste 7 Tage)
` +
`3) Verhältnis Spielen vs Training bewerten (X01 Double-Out als Spiel-Referenz; Bot vs Human getrennt)

` +
`## Kontext
` +
`- Zeitraum: **${liteJson?.period?.label || "—"}**
` +
`- Spiel-Referenz: **X01 Double-Out** (Split: **vs Human** / **vs Bot**)
- Gegnerstärke: nutze **x01OpponentPerformance** / **x01OpponentPerformanceSplit** (Opponent AVG/Checkout/Bot-Level)
` +
`- Training: alle Trainingsmodi **ohne** X01

` +
`## Datenlage (wichtig)
` +
`Nutze im JSON das Objekt **dataAvailability** und halte dich strikt daran:
` +
`- Wenn **hasBustData/hasRestScoreData/hasRouteData = true**, nutze **x01DerivedSignals** (Busts/Restscore/Checkout-Routen) für direkte Aussagen.
- Wenn **hasBustData/hasRestScoreData/hasRouteData = false**, dann mache keine direkten Aussagen zu Busts/Restscore/Checkout-Routen. Nutze stattdessen Proxy-Indikatoren aus den vorhandenen Feldern (z.B. Checkout%, AVG, First9, 100+/140+/180).
` +
`- Wenn **hasBotHumanSplit = false**, dann bewerte das Verhältnis Spielen/Training nur gesamt und erwähne den fehlenden Split kurz in Abschnitt 6.
` +
`- Wenn **hasTrainingOutcome = true**, bewerte Training auch über **Volumen/Output/Effizienz** (dartsThrown, attempts, hits, hitPct, avgDartsPerAttempt).
- Für Checkout-Training nutze **balance.training.checkoutRelated** (Random Checkout + Segment Training **Double**).
- Trainingsnamen: Verwende **meta.trainingActivityTemplates[].name** (oder **meta.trainingNames.activities**) im Trainingsplan (Abschnitt 4) **wortwörtlich** als Übungsnamen (copy/paste wie im "Aktivität hinzufügen"). Segment-Fokus (DOUBLE/SINGLE/TRIPLE) gehört in die Setup-Zeilen, nicht in den Namen.
- Wenn **hasTrainingOutcome = false**, bewerte den Trainingsmix nach Zeitanteilen und nenne konkrete Messgrößen, die man künftig tracken sollte.
` +
`Abschnitt 6 (Warnungen/Datenlücken) bitte nur kurz und nur die wichtigsten Punkte.

`;

        const shortRules = (tpl === "SHORT")
            ? `**Kurzmodus:** Halte die Antworten sehr kompakt.
- Max. 5 Bulletpoints in Abschnitt 2
- Genau 3 Insights in Abschnitt 3
- Trainingsplan in Abschnitt 4: max. 20–30 Minuten/Tag oder klare Legs-Angaben
- Abschnitt 5: 3 Sätze + 1 Empfehlung

`
            : ``;

        const body = `## Output (bitte exakt so strukturieren)
` +
`### 1) Kurzfazit (3 Sätze)
` +
`- Was lief gut?
- Was limitiert aktuell am meisten?
- Größter Hebel für die nächste Woche?

` +
`### 2) Leistung im Überblick (Bulletpoints)
` +
`- Scoring
- Checkout/Doubles
- Konstanz
- Fehler/Risiken (nur wenn Daten vorhanden; sonst Proxy-Indikatoren)

` +
`### 3) 5 wichtigste Insights (mit Zahlen)
` +
`- Insight → Beleg (Zahl) → Bedeutung

` +
`### 4) Trainingsempfehlung (7 Tage, sehr konkret)
` +
`- 3 Schwerpunkte (priorisiert)
- pro Schwerpunkt: 2 Übungen (Dauer/Legs, Zielmetric)
- Erfolgskriterien (konkrete Zielwerte)

` +
`### 5) Spiele vs Training (Balance)
` +
`- Spiel-Referenz: X01 Double-Out
- getrennt: vs Human / vs Bot
- Bewertung + Empfehlung (wie viel Training vs Spiel, worauf fokussieren)

` +
`### 6) Warnungen / Datenlücken
` +
`- Was fehlt/unklar ist und welche Annahme du gemacht hast

`;

        let out = header + shortRules + body;
        if (tpl === "SHORT") {
            out = out.replace("### 3) 5 wichtigste Insights", "### 3) 3 wichtigste Insights");
        }

        return out +
`---

## Daten (Lite JSON)

\`\`\`json
${jsonStr}
\`\`\`
`;
    }

    function wireTrainingChatGptCopy(panel) {
        if (!panel) return;

        const btnCopy = panel.querySelector("#ad-ext-ai-copy");
        const btnOpen = panel.querySelector("#ad-ext-ai-open");
        const status = panel.querySelector("#ad-ext-ai-status");

        const selRange = panel.querySelector('#ad-ext-ai-range');
        const selTpl = panel.querySelector('#ad-ext-ai-template');
        const customWrap = panel.querySelector('#ad-ext-ai-range-custom');
        const inpFrom = panel.querySelector('#ad-ext-ai-from');
        const inpTo = panel.querySelector('#ad-ext-ai-to');

        if (btnCopy && btnCopy.dataset.wired === "1") return;
        if (!btnCopy) return;

        btnCopy.dataset.wired = "1";

        const LS_RANGE = 'ad_ext_ai_range_mode';
        const LS_TPL = 'ad_ext_ai_prompt_tpl';
        const LS_FROM = 'ad_ext_ai_range_from';
        const LS_TO = 'ad_ext_ai_range_to';

        let _aiStatusT = null;
        const setStatus = (msg, showOpen = false, autoHideMs = 0) => {
            try { if (_aiStatusT) clearTimeout(_aiStatusT); } catch {}
            try {
                if (status) {
                    status.textContent = String(msg || "");
                    status.style.display = msg ? "" : "none";
                }
            } catch {}
            try {
                if (btnOpen) btnOpen.style.display = showOpen ? "" : "none";
            } catch {}
            if (autoHideMs && msg) {
                _aiStatusT = setTimeout(() => {
                    try { if (status) status.style.display = "none"; } catch {}
                }, autoHideMs);
            }
        };

        const getSelectedWeekKey = () => {
            const sel = panel.querySelector("#ad-ext-plan-week-select");
            const v = String(sel?.value || "").trim();
            if (v) return v;
            const monday = startOfWeekMonday(new Date());
            return monday ? dayKeyFromLocalDate(monday) : "";
        };

        const ensureCustomDefaults = () => {
            try {
                if (!inpFrom || !inpTo) return;
                if (inpFrom.value && inpTo.value) return;
                const wk = weekRangeFromWeekKey(getSelectedWeekKey());
                if (!wk) return;
                inpFrom.value = wk.startKey;
                inpTo.value = wk.endKey;
            } catch {}
        };

        const syncCustomVisibility = () => {
            try {
                const mode = String(selRange?.value || 'WEEK').toUpperCase();
                if (customWrap) customWrap.style.display = (mode === 'CUSTOM') ? 'inline-flex' : 'none';
                if (mode === 'CUSTOM') ensureCustomDefaults();
            } catch {}
        };

        // init UI state
        try {
            if (selRange) {
                const saved = String(localStorage.getItem(LS_RANGE) || 'WEEK').toUpperCase();
                const allowed = new Set(['WEEK','W4','W8','W12','W16','CUSTOM','ALL']);
                selRange.value = allowed.has(saved) ? saved : 'WEEK';
            }
            if (selTpl) {
                const saved = String(localStorage.getItem(LS_TPL) || 'LONG').toUpperCase();
                const allowed = new Set(['LONG','SHORT']);
                selTpl.value = allowed.has(saved) ? saved : 'LONG';
            }
            if (inpFrom) inpFrom.value = String(localStorage.getItem(LS_FROM) || inpFrom.value || '');
            if (inpTo) inpTo.value = String(localStorage.getItem(LS_TO) || inpTo.value || '');
        } catch {}

        syncCustomVisibility();

        if (selRange && !selRange.dataset.wired) {
            selRange.dataset.wired = '1';
            selRange.addEventListener('change', () => {
                try { localStorage.setItem(LS_RANGE, String(selRange.value || 'WEEK')); } catch {}
                syncCustomVisibility();
            });
        }

        if (selTpl && !selTpl.dataset.wired) {
            selTpl.dataset.wired = '1';
            selTpl.addEventListener('change', () => {
                try { localStorage.setItem(LS_TPL, String(selTpl.value || 'LONG')); } catch {}
            });
        }

        if (inpFrom && !inpFrom.dataset.wired) {
            inpFrom.dataset.wired = '1';
            inpFrom.addEventListener('change', () => {
                try { localStorage.setItem(LS_FROM, String(inpFrom.value || '')); } catch {}
            });
        }
        if (inpTo && !inpTo.dataset.wired) {
            inpTo.dataset.wired = '1';
            inpTo.addEventListener('change', () => {
                try { localStorage.setItem(LS_TO, String(inpTo.value || '')); } catch {}
            });
        }

        const buildPeriodFromUi = () => {
            const weekKey = getSelectedWeekKey();
            const wk = weekRangeFromWeekKey(weekKey);
            const mode = String(selRange?.value || 'WEEK').toUpperCase();

            if (mode === 'ALL') {
                return { type: 'ALL', label: 'Alles', startDayKey: '', endDayKey: '', weekKeyAnchor: weekKey };
            }

            if (!wk) {
                return { type: 'WEEK', label: String(weekKey || ''), startDayKey: weekKey, endDayKey: weekKey, weekKeyAnchor: weekKey };
            }

            if (mode === 'CUSTOM') {
                const from = String(inpFrom?.value || '').trim();
                const to = String(inpTo?.value || '').trim();
                if (!/^\d{4}-\d{2}-\d{2}$/.test(from) || !/^\d{4}-\d{2}-\d{2}$/.test(to)) {
                    throw new Error('invalid custom range');
                }
                const sKey = (from <= to) ? from : to;
                const eKey = (from <= to) ? to : from;
                const lab = `Zeitraum ${dayKeyToGerman(sKey)}–${dayKeyToGerman(eKey)}`;
                return { type: 'CUSTOM', label: lab, startDayKey: sKey, endDayKey: eKey, weekKeyAnchor: weekKey };
            }

            if (mode === 'W4' || mode === 'W8' || mode === 'W12' || mode === 'W16') {
                const weeks = (mode === 'W16') ? 16 : (mode === 'W12') ? 12 : (mode === 'W8') ? 8 : 4;
                const deltaDays = -7 * (weeks - 1);
                const sDate = addDaysLocal(wk.start, deltaDays);
                const sKey = dayKeyFromLocalDate(sDate);
                const eKey = wk.endKey;
                const lab = `Letzte ${weeks} Wochen (bis ${adExt_fmtWeekLabel(weekKey)})`;
                return { type: mode, label: lab, startDayKey: sKey, endDayKey: eKey, weekKeyAnchor: weekKey };
            }

            // default: WEEK
            return { type: 'WEEK', label: adExt_fmtWeekLabel(weekKey), startDayKey: wk.startKey, endDayKey: wk.endKey, weekKeyAnchor: weekKey };
        };

        btnCopy.addEventListener("click", async () => {
            try {
                if (!cache?.loaded) {
                    setStatus("Daten laden…", false, 2500);
                    return;
                }

                const period = buildPeriodFromUi();
                const tpl = String(selTpl?.value || 'LONG').toUpperCase();

                const lite = adExt_buildLiteJsonForTrainingPeriod(period);
                const md = adExt_buildMarkdownPrompt(lite, tpl);

                await adExt_copyToClipboard(md);

                btnCopy.dataset.lastCopied = String(Date.now());
                setStatus("Kopiert ✅", true, 3500);
            } catch (e) {
                console.warn("[AD Ext] ChatGPT copy failed", e);
                if (String(e?.message || '').includes('invalid custom range')) {
                    setStatus("Zeitraum ungültig", false, 3500);
                } else {
                    setStatus("Kopieren fehlgeschlagen", false, 3500);
                }
            }
        });

        if (btnOpen) {
            btnOpen.addEventListener("click", () => {
                try {
                    if (typeof GM_openInTab === "function") {
                        GM_openInTab("https://chatgpt.com/", { active: true, insert: true, setParent: true });
                    } else {
                        window.open("https://chatgpt.com/", "_blank");
                    }
                } catch { window.open("https://chatgpt.com/", "_blank"); }
            });
        }
    }

    function wireTrainingChatGptMenu(panel) {
        try {
            if (!panel) return;
            const menuBtn = panel.querySelector("#adAiMenuBtn");
            const menuDd = panel.querySelector("#adAiMenuDropdown");
            const menuWrap = panel.querySelector("#adAiMenu");
            if (!menuBtn || !menuDd || !menuWrap) return;

            try { menuDd.hidden = true; } catch {}
            try { menuBtn.setAttribute("aria-expanded", "false"); } catch {}

            if (menuBtn.dataset.adExtAiMenuWired !== "1") {
                menuBtn.dataset.adExtAiMenuWired = "1";
                menuBtn.addEventListener("click", (ev) => {
                    try {
                        ev.preventDefault();
                        ev.stopPropagation();
                        const open = !menuDd.hidden;
                        menuDd.hidden = open;
                        try { menuBtn.setAttribute("aria-expanded", open ? "false" : "true"); } catch {}
                    } catch {}
                });
            }

            if (!window.__adExtAiMenuGlobalWired) {
                window.__adExtAiMenuGlobalWired = true;

                document.addEventListener("click", (ev) => {
                    try {
                        const dd = document.querySelector("#adAiMenuDropdown");
                        const btn = document.querySelector("#adAiMenuBtn");
                        const wrap = document.querySelector("#adAiMenu");
                        if (!dd || !btn || !wrap) return;
                        if (dd.hidden) return;
                        if (wrap.contains(ev.target)) return;
                        dd.hidden = true;
                        try { btn.setAttribute("aria-expanded", "false"); } catch {}
                    } catch {}
                }, true);

                document.addEventListener("keydown", (ev) => {
                    try {
                        if (ev.key !== "Escape") return;
                        const dd = document.querySelector("#adAiMenuDropdown");
                        const btn = document.querySelector("#adAiMenuBtn");
                        if (!dd || dd.hidden) return;
                        dd.hidden = true;
                        try { btn?.setAttribute("aria-expanded", "false"); } catch {}
                    } catch {}
                }, true);
            }
        } catch {}
    }

    // ---------------------------------------------------------------------------
    // Training Tracker Adapter (Step 3 – Trainingsplan Sidebar)
    // ---------------------------------------------------------------------------

    /**
     * WeekRange: start inklusiv, end exklusiv (empfohlen)
     * @typedef {{ start: Date, end: Date }} WeekRange
     *
     * TrackerWeekAgg:
     *  - minutesByActivity: Minuten pro Aktivität (Keys: PlanItem.type)
     *  - sessionsByActivity: Sessions pro Aktivität (Keys: PlanItem.type)
     *  - segmentTargetsMinutes: Minuten pro Segment-Target (z.B. D20, T20)
     * @typedef {{ minutesByActivity: Object.<string, number>, sessionsByActivity: Object.<string, number>, segmentTargetsMinutes: Object.<string, number>, segmentTargetsSessions?: Object.<string, number>, performanceByActivity?: Object.<string, { hitRate?: number, hitsPerMin?: number }>, performanceBySegmentTarget?: Object.<string, { hitRate?: number, hitsPerMin?: number }> }} TrackerWeekAgg
     */

    // Mapping: PlanItem.type → Tracker Keys (einmal zentral anpassen, falls Tracker anders benennt)
    const PLANITEM_TYPE_TO_TRACKER_KEY = Object.freeze({
        ATC: "ATC",
        COUNTUP: "COUNTUP",
        CRICKET: "CRICKET",
        RANDOM_CHECKOUT: "RANDOM_CHECKOUT",
        SEGMENT_TRAINING: "SEGMENT_TRAINING",
        X01_BOT: "X01_BOT",
        X01_HUMAN: "X01_HUMAN",
    });

    function toIntMinutes(sec) {
        const s = Number(sec) || 0;
        if (!Number.isFinite(s) || s <= 0) return 0;
        return Math.max(0, Math.round(s / 60));
    }

    // ---------------------------------------------------------
    // Performance-Formatierung (0.14.32)
    // - Nur Anzeige/Formatierung (keine Berechnung aus Rohwürfen)
    // ---------------------------------------------------------

    /** @param {any} hitRate @returns {number|null} Prozent 0..100 (gerundet) oder null */
    function normalizeHitRateToPctInt(hitRate) {
        const n = Number(hitRate);
        if (!Number.isFinite(n)) return null;
        if (n <= 1.0) return Math.round(n * 100);
        return Math.round(n);
    }

    /** @param {any} hitRate @returns {string} */
    function fmtHitRateMaybe(hitRate) {
        const pct = normalizeHitRateToPctInt(hitRate);
        return (pct === null) ? "—" : `${pct}%`;
    }

    /** @param {any} hitsPerMin @returns {string} */
    function fmtHitsPerMinMaybe(hitsPerMin) {
        const n = Number(hitsPerMin);
        if (!Number.isFinite(n)) return "—";
        return (Math.round(n * 10) / 10).toFixed(1);
    }


    /**
     * Aggregiert Ist-Minuten für eine Woche aus dem vorhandenen Tracker (IndexedDB Cache).
     * Wichtig: UI darf den Tracker NICHT direkt zusammenrechnen – nur über diese Funktion.
     * @param {WeekRange} weekRange
     * @returns {TrackerWeekAgg}
     */
    function getTrackerAggregationForWeek(weekRange) {
        /** @type {TrackerWeekAgg} */
        const out = { minutesByActivity: {}, sessionsByActivity: {}, segmentTargetsMinutes: {}, segmentTargetsSessions: undefined };

        // Defaults (alle bekannten Plan-Typen auf 0)
        for (const k of Object.keys(PLANITEM_TYPE_TO_TRACKER_KEY)) {
            out.minutesByActivity[k] = 0;
            out.sessionsByActivity[k] = 0;
        }

        const start = weekRange && weekRange.start ? new Date(weekRange.start) : null;
        if (!start || !Number.isFinite(start.getTime())) return out;

        // Normalisieren: auf Wochen-Montag (damit Adapter unabhängig vom UI-Format ist)
        const wkStart = startOfWeekMonday(start);
        const weekKey = wkStart ? dayKeyFromLocalDate(wkStart) : null;
        if (!weekKey) return out;

        const { byActivity, stTargets } = aggregateTrainingActualsForWeek(weekKey);

        // Optional (0.14.32): Performance nur durchreichen, wenn Tracker sie bereits liefert.
        // Keine Berechnung/Fake-Werte.
        /** @type {any|null} */ let perfByActivity = null;
        /** @type {any|null} */ let perfBySegmentTarget = null;

        // 0.14.33: Sessions pro Segment-Target (optional)
        // Nur setzen, wenn aus den Rohdaten eindeutig ableitbar (kein Multi-Target pro Event).
        /** @type {Record<string, number>} */ let segTargetsSessions = {};
        let segTargetsSessionsAmbiguous = false;


        // Minuten + Sessions pro Aktivität (PlanItem.type → Tracker-Key Mapping)
        for (const [planType, trackerKey] of Object.entries(PLANITEM_TYPE_TO_TRACKER_KEY)) {
            const rec = byActivity && byActivity.get ? (byActivity.get(trackerKey) || null) : null;
            out.minutesByActivity[planType] = toIntMinutes(rec ? rec.sec : 0);
            out.sessionsByActivity[planType] = Math.max(0, Math.round(Number(rec ? rec.count : 0) || 0));

            // best-effort pass-through (falls Tracker diese Felder bereits anbietet)
            const hr = rec ? rec.hitRate : undefined;
            const hpm = rec ? rec.hitsPerMin : undefined;
            if (Number.isFinite(Number(hr)) || Number.isFinite(Number(hpm))) {
                perfByActivity = perfByActivity || {};
                perfByActivity[planType] = {};
                if (Number.isFinite(Number(hr))) perfByActivity[planType].hitRate = Number(hr);
                if (Number.isFinite(Number(hpm))) perfByActivity[planType].hitsPerMin = Number(hpm);
            }
        }

        // Minuten pro Segment-Target (Sessions pro Target bleiben in diesem Step unverändert)
        if (stTargets && stTargets.forEach) {
            stTargets.forEach((rec, target) => {
                const t = String(target || "").trim();
                if (!t || t === "DRandom" || t === "SRandom") return;
                out.segmentTargetsMinutes[t] = toIntMinutes(rec ? rec.sec : 0);
                // 0.14.33: Sessions pro Target (Count pro Event, bereits im Tracker aggregiert)
                // Wenn Targets nicht eindeutig (z.B. "D20,D19"), deaktivieren wir segmentTargetsSessions komplett.
                if (t && t !== "—") {
                    if (/[\s,;|]/.test(t)) {
                        segTargetsSessionsAmbiguous = true;
                    } else {
                        segTargetsSessions[t] = Math.max(0, Math.round(Number(rec ? rec.count : 0) || 0));
                    }
                }


                // best-effort pass-through (falls Tracker diese Felder bereits anbietet)
                const hr = rec ? rec.hitRate : undefined;
                const hpm = rec ? rec.hitsPerMin : undefined;
                if (Number.isFinite(Number(hr)) || Number.isFinite(Number(hpm))) {
                    perfBySegmentTarget = perfBySegmentTarget || {};
                    perfBySegmentTarget[t] = {};
                    if (Number.isFinite(Number(hr))) perfBySegmentTarget[t].hitRate = Number(hr);
                    if (Number.isFinite(Number(hpm))) perfBySegmentTarget[t].hitsPerMin = Number(hpm);
                }
            });

            // 0.14.33: segmentTargetsSessions nur setzen, wenn keine Mehrfach-Targets erkannt wurden
            if (!segTargetsSessionsAmbiguous) {
                out.segmentTargetsSessions = segTargetsSessions;
            }

        }

        if (perfByActivity && Object.keys(perfByActivity).length) out.performanceByActivity = perfByActivity;
        if (perfBySegmentTarget && Object.keys(perfBySegmentTarget).length) out.performanceBySegmentTarget = perfBySegmentTarget;

        return out;
    }


    // =========================
    // Training-Tab: Donut (Trainingsfortschritt) -> Tabellenfilter (0.14.79)
    // =========================
    function applyTrainingProgressFilter(panel, filterKey) {
        try {
            if (!panel) return { marked: 0, dimmed: 0 };

            const svg = panel.querySelector("#ad-ext-train-chart-sollist");
            const rows = panel.querySelectorAll('#ad-ext-plan-main-body tr.ad-ext-train-row');
            const key = String(filterKey || "");

            let marked = 0;
            let dimmed = 0;

            if (!key) {
                for (const r of rows) {
                    r.classList.remove("ad-ext-tp-dim", "ad-ext-tp-mark");
                }
                if (svg) {
                    svg.dataset.adExtTpFilter = "";
                    const paths = svg.querySelectorAll('path.recharts-sector');
                    for (const p of paths) {
                        try { p.style.opacity = "1"; } catch {}
                    }
                }
                return { marked, dimmed };
            }

            for (const r of rows) {
                const st = String(r?.dataset?.status || "");
                if (!st) {
                    r.classList.remove("ad-ext-tp-dim", "ad-ext-tp-mark");
                    continue;
                }
                if (st === key) {
                    r.classList.add("ad-ext-tp-mark");
                    r.classList.remove("ad-ext-tp-dim");
                    marked++;
                } else {
                    r.classList.add("ad-ext-tp-dim");
                    r.classList.remove("ad-ext-tp-mark");
                    dimmed++;
                }
            }

            if (svg) {
                svg.dataset.adExtTpFilter = key;
                const paths = svg.querySelectorAll('path.recharts-sector');
                for (let i = 0; i < paths.length; i++) {
                    const p = paths[i];
                    const itemIdx = Number(p.getAttribute("data-recharts-item-index") || p.getAttribute("data-ad-slice") || "NaN");
                    const fk = (itemIdx === 0) ? "reached" : ((itemIdx === 1) ? "open" : "");
                    const isActive = fk && fk === key;
                    try { p.style.opacity = isActive ? "1" : "0.35"; } catch {}
                }
            }
            return { marked, dimmed };
        } catch {
            return { marked: 0, dimmed: 0 };
        }
    }

    // =========================
    // Training-Tab: Donut (Trainings-SOLL) -> Tabellenfilter (0.14.86)
    // =========================
    function applyTrainingSollSplitFilter(panel, planType) {
        try {
            if (!panel) return { marked: 0, dimmed: 0 };

            const svg = panel.querySelector("#ad-ext-train-chart-placeholder");
            const rows = panel.querySelectorAll('#ad-ext-plan-main-body tr.ad-ext-train-row');
            const key = String(planType || "");

            let marked = 0;
            let dimmed = 0;

            if (!key) {
                for (const r of rows) {
                    r.classList.remove("ad-ext-ts-dim", "ad-ext-ts-mark");
                }
                if (svg) {
                    const paths = svg.querySelectorAll('path.recharts-sector');
                    for (const p of paths) {
                        try { p.style.opacity = "1"; } catch {}
                    }
                }
                return { marked, dimmed };
            }

            for (const r of rows) {
                const pt = String(r?.dataset?.planType || r?.getAttribute?.("data-plan-type") || "");
                if (!pt) {
                    r.classList.remove("ad-ext-ts-dim", "ad-ext-ts-mark");
                    continue;
                }
                if (pt === key) {
                    r.classList.add("ad-ext-ts-mark");
                    r.classList.remove("ad-ext-ts-dim");
                    marked++;
                } else {
                    r.classList.add("ad-ext-ts-dim");
                    r.classList.remove("ad-ext-ts-mark");
                    dimmed++;
                }
            }

            if (svg) {
                const paths = svg.querySelectorAll('path.recharts-sector');
                for (const p of paths) {
                    const pt = String(p?.dataset?.adSollType || p?.getAttribute?.("data-ad-soll-type") || "");
                    const isActive = pt && pt === key;
                    try { p.style.opacity = isActive ? "1" : "0.35"; } catch {}
                }
            }

            try { console.debug("[AD Ext][TS] filter =", key, "marked =", marked, "dimmed =", dimmed); } catch {}

            return { marked, dimmed };
        } catch {
            return { marked: 0, dimmed: 0 };
        }
    }

    // =========================
    // Training-Tab: Tabelle -> Donut (Trainings-SOLL) filter (0.14.87)
    // =========================
    function ensureTrainingSollSplitTableWiring(panel) {
        try {
            if (!panel) return;

            const tbody = panel.querySelector("#ad-ext-plan-main-body");
            if (!tbody) return;

            if (String(tbody.dataset.adExtTsWired || "") === "1") return;
            tbody.dataset.adExtTsWired = "1";

            tbody.addEventListener("click", (ev) => {
                try {
                    // a) nur echte Aktivitätszeilen
                    const tr = ev?.target?.closest ? ev.target.closest("tr.ad-ext-train-row") : null;
                    if (!tr) return;

                    // b) NICHT triggern, wenn man auf Expand/Plus oder Buttons klickt
                    if (ev?.target?.closest?.("button, a")) return;
                    if (ev?.target?.closest?.(".ad-ext-rowexp, .ad-ext-train-expand, .ad-ext-expander")) return;

                    // c) planType ermitteln
                    const pt = String(tr.dataset.planType || tr.getAttribute("data-plan-type") || "").trim();
                    if (!pt) return;

                    // d) toggle wie beim Chart
                    const svg2 = panel.querySelector("#ad-ext-train-chart-placeholder");
                    const cur = String(svg2?.dataset?.adExtTsFilter || "");
                    const next = (cur === pt) ? "" : pt;

                    if (svg2) svg2.dataset.adExtTsFilter = next;

                    // e) reuse bestehende Funktion
                    applyTrainingSollSplitFilter(panel, next);

                    try { console.debug("[AD Ext][TS] filter (table)", { pt, next }); } catch {}
                } catch {}
            }, false);
        } catch {}
    }






    // =========================
    // Training-Tab: Charts unter Tabelle (Erreicht vs Offen)
    // =========================
    function renderTrainingProgressCharts(panel, totalGoal, totalCredited, totalIst, viewMode) {
        if (!panel) return;

        const svg = panel.querySelector("#ad-ext-train-chart-sollist");
        const legend = panel.querySelector("#ad-ext-train-legend-sollist");

        const g = Math.max(0, Number(totalGoal) || 0);
        const c = Math.min(g, Math.max(0, Number(totalCredited) || 0));
        const open = Math.max(0, g - c);
        const i = Math.max(0, Number(totalIst) || 0);

        const unitTxt = (String(viewMode || "").toLowerCase() === "time") ? "min" : "Sessions";
        const fmtVal = (v) => {
            const n = Math.max(0, Math.round(Number(v) || 0));
            return (unitTxt === "min") ? `${n}min` : `${n} ${unitTxt}`;
        };

        if (svg) {
            const items = [
                { label: "Erreicht", value: c, color: "rgba(96, 222, 132, 0.95)" },
                { label: "Offen", value: open, color: "rgba(255, 84, 84, 0.95)" },
            ];

            drawDonutSvg(svg, items, {
                style: "outline",
                gapDeg: 7,
                strokeWidth: 2,
                outlineFillAlpha: 0.20,
                rInnerFactor: 0.78,
                showCenterText: false,
                holeFill: false,
            });

            // Donut -> Tabelle: Klick auf Slices markiert offene/erreichte Aktivitäten (0.14.79)
            try {
                const clearTpFilter = (ev, source) => {
                    try { ev?.preventDefault?.(); ev?.stopPropagation?.(); } catch {}
                    const cur = String(svg.dataset.adExtTpFilter || "");
                    if (!cur) return;
                    svg.dataset.adExtTpFilter = "";
                    const res = applyTrainingProgressFilter(panel, "");
                    try { console.debug("[AD Ext][TP] filter =", "", "marked =", res.marked, "dimmed =", res.dimmed, "src=", source); } catch {}
                };

                const paths = svg.querySelectorAll('path.recharts-sector');
                for (let idx = 0; idx < paths.length; idx++) {
                    const p = paths[idx];
                    const itemIdx = Number(p.getAttribute("data-recharts-item-index") || p.getAttribute("data-ad-slice") || "NaN");
                    const filterKey = (itemIdx === 0) ? "reached" : ((itemIdx === 1) ? "open" : "");
                    if (!filterKey) continue;
                    p.dataset.adSlice = filterKey;
                    try { p.style.cursor = "pointer"; } catch {}
                    p.onclick = (ev) => {
                        try { ev.preventDefault(); ev.stopPropagation(); } catch {}
                        const cur = String(svg.dataset.adExtTpFilter || "");
                        const next = (cur === filterKey) ? "" : filterKey;
                        svg.dataset.adExtTpFilter = next;
                        const res = applyTrainingProgressFilter(panel, next);
                        try { console.debug("[AD Ext][TP] filter =", next, "marked =", res.marked, "dimmed =", res.dimmed); } catch {}
                    };
                }

                // Klick ins leere Donut-SVG => Filter AUS (0.14.80)
                try {
                    svg.onclick = (ev) => {
                        try {
                            const hit = ev?.target?.closest?.('path.recharts-sector');
                            if (hit) return; // slice click handled separately
                            clearTpFilter(ev, "svg");
                        } catch {}
                    };
                } catch {}

                // Klick in Legend / freie Card-Fläche => Filter AUS (0.14.81)
                try {
                    if (legend) {
                        legend.onclick = (ev) => clearTpFilter(ev, "legend");
                    }
                } catch {}
                try {
                    const card = svg.closest?.('.ad-ext-card');
                    if (card) {
                        card.onclick = (ev) => {
                            try {
                                // Ignore real slice clicks (handled above)
                                if (ev?.target?.closest?.('path.recharts-sector')) return;
                                // SVG/Legend handle their own "empty click" and stopPropagation
                                if (ev?.target?.closest?.('#ad-ext-train-chart-sollist')) return;
                                if (ev?.target?.closest?.('#ad-ext-train-legend-sollist')) return;
                                clearTpFilter(ev, "card");
                            } catch {}
                        };
                    }
                } catch {}

                // Restore current filter on rerender (no log)
                const cur = String(svg.dataset.adExtTpFilter || "");
                if (cur) applyTrainingProgressFilter(panel, cur);
            } catch {}

            if (legend) {
                const extra = (g > 0 && i > g)
                ? `<div class="ad-ext-muted" style="margin-top:6px;">Überschuss: ${escapeHtml(fmtVal(i - g))}</div>`
                    : "";

                legend.innerHTML = items.map((it) => {
                    const pct = (g > 0) ? (Number(it.value) * 100) / g : null;
                    const pctTxt = (pct === null) ? "—" : `${pct.toFixed(1)}%`;
                    return `
      <div class="ad-ext-legend-item" style="cursor:default;">
        <span class="ad-ext-dot" style="background:${escapeHtml(it.color)};"></span>
        <span style="font-weight:900;">${escapeHtml(it.label)}</span>
        <span style="opacity:.78; font-weight:800;">${escapeHtml(fmtVal(it.value))} (${escapeHtml(pctTxt)})</span>
      </div>
    `;
                }).join("") + extra;
            }
        }

        // Trainings-SOLL Donut (right slot) – Gruppierung nach Aktivität (0.14.85)
        const ph = panel.querySelector("#ad-ext-train-chart-placeholder");
        const phLegend = panel.querySelector("#ad-ext-train-legend-soll");
        if (ph) {
            // kein Platzhalter-Styling mehr
            try { ph.classList.remove("ad-ext-train-chart--placeholder"); } catch {}
            try { ph.onclick = null; } catch {}

            // Basis: bereits gerenderte Trainingsdaten-Tabelle
            const rows2 = panel.querySelectorAll('#ad-ext-plan-main-body tr.ad-ext-train-row');
            const sums = new Map();

            for (const r of rows2) {
                const type = String(r?.dataset?.planType || r?.getAttribute?.("data-plan-type") || "").trim();
                if (!type) continue;

                const goalNum = Number(r?.dataset?.goal ?? r?.getAttribute?.("data-goal") ?? 0) || 0;
                if (!(goalNum > 0)) continue;

                let rec = sums.get(type);
                if (!rec) {
                    let lab = type;

                    // bevorzugt: sichtbarer Label-Text aus der Tabelle (ohne leading "+")
                    try {
                        const td0 = r.querySelector("td");
                        if (td0) {
                            const raw = String(td0.textContent || "").trim();
                            const cleaned = raw.replace(/^\+\s*/, "").trim();
                            if (cleaned) lab = cleaned;
                        }
                    } catch {}

                    // fallback: Template-Label (falls vorhanden)
                    try {
                        if ((lab === type || !lab) && typeof PLAN_ACTIVITY_TEMPLATES !== "undefined" && Array.isArray(PLAN_ACTIVITY_TEMPLATES)) {
                            const tpl = PLAN_ACTIVITY_TEMPLATES.find(t => String(t?.type || "").trim() === type);
                            const tl = tpl?.label || tpl?.name;
                            if (tl) lab = String(tl);
                        }
                    } catch {}

                    rec = { type, label: lab || type, value: 0 };
                    sums.set(type, rec);
                }

                rec.value += goalNum;
            }

            const base = Array.from(sums.values()).filter(x => (Number(x?.value) || 0) > 0);

            const items2 = base.map((x, idx) => ({
                label: String(x.label || x.type || ""),
                value: Math.max(0, Math.round(Number(x.value) || 0)),
                color: PALETTE[idx % PALETTE.length],
                extra: { planType: String(x.type || "") }
            }));

            // Donut render (gleiches SVG-Format wie links)
            drawDonutSvg(ph, items2, {
                style: "outline",
                gapDeg: 7,
                strokeWidth: 2,
                outlineFillAlpha: 0.20,
                rInnerFactor: 0.78,
                showCenterText: false,
                holeFill: false,
            });

            // Interaktion: Slice klickt => Tabellenfilter nach planType (0.14.86)
            try {
                const paths2 = ph.querySelectorAll('path.recharts-sector');
                for (const p of paths2) {
                    const itemIdx = Number(p.getAttribute("data-recharts-item-index") || p.getAttribute("data-ad-slice") || "NaN");
                    const ptRaw = (Number.isFinite(itemIdx) && itemIdx >= 0) ? (items2[itemIdx]?.extra?.planType || "") : "";
                    const pt = String(ptRaw || "").trim();

                    p.dataset.adSollType = pt;
                    try { p.setAttribute("data-ad-soll-type", pt); } catch {}

                    try { p.style.cursor = pt ? "pointer" : "default"; } catch {}

                    try {
                        p.onclick = (ev) => {
                            try { ev?.preventDefault?.(); } catch {}
                            try { ev?.stopPropagation?.(); } catch {}

                            const cur = String(ph.dataset.adExtTsFilter || "");
                            const next = (pt && cur === pt) ? "" : pt;
                            ph.dataset.adExtTsFilter = next;
                            applyTrainingSollSplitFilter(panel, next);
                        };
                    } catch {}
                }
            } catch {}

            // Klick in leere Fläche im Donut-SVG => Filter AUS (0.14.86)
            try {
                ph.onclick = (ev) => {
                    try {
                        if (ev?.target?.closest?.('path.recharts-sector')) return;
                        ph.dataset.adExtTsFilter = "";
                        applyTrainingSollSplitFilter(panel, "");
                    } catch {}
                };
            } catch {}

            // Klick in Legend => Filter AUS (0.14.86)
            try {
                if (phLegend) {
                    phLegend.onclick = (ev) => {
                        try { ev?.preventDefault?.(); } catch {}
                        try { ev?.stopPropagation?.(); } catch {}
                        ph.dataset.adExtTsFilter = "";
                        applyTrainingSollSplitFilter(panel, "");
                    };
                }
            } catch {}
            // Legende (minimal, wie links)
            if (phLegend) {
                const total2 = items2.reduce((a, x) => a + (Number(x?.value) || 0), 0);
                const valTxt2 = (v) => {
                    const n = Math.max(0, Math.round(Number(v) || 0));
                    return (unitTxt === "min") ? `${n} min` : `${n} Sessions`;
                };

                if (!items2.length || !total2) {
                    phLegend.innerHTML = `<div class="ad-ext-muted">Keine Daten</div>`;
                } else {
                    phLegend.innerHTML = items2.map((it) => {
                        const pct = total2 ? (Number(it.value) * 100) / total2 : 0;
                        return `
  <div class="ad-ext-legend-item" style="cursor:default;">
    <span class="ad-ext-dot" style="background:${escapeHtml(it.color)};"></span>
    <span style="font-weight:900;">${escapeHtml(it.label)}</span>
    <span style="opacity:.78; font-weight:800;">${escapeHtml(valTxt2(it.value))} (${escapeHtml(pct.toFixed(1))}%)</span>
  </div>
`;
                }).join("");
            }
        }

        // Restore current TS filter on rerender (0.14.86)
        const cur = String(ph.dataset.adExtTsFilter || "");
        if (cur) applyTrainingSollSplitFilter(panel, cur);
    }
    }

    function renderTrainingPlan(panel, weeksAsc) {
        if (!panel) return;

        cache.trainingPlan = cache.trainingPlan || loadTrainingPlanState();
        const st = cache.trainingPlan;

        const basis = "SESS"; // sessions-only UI (0.14.75)
        st.basis = "SESS";

        const mainBody = panel.querySelector("#ad-ext-plan-main-body");
        const weekLabel = panel.querySelector("#ad-ext-plan-week-label");
        const weekSub = panel.querySelector("#ad-ext-plan-week-sub");
        // Woche wird im Select-Text angezeigt → Label/Sub im Header ausblenden
        if (weekLabel) { try { weekLabel.style.display = "none"; } catch {} }
        if (weekSub) { try { weekSub.style.display = "none"; } catch {} }
        const basisWrap = panel.querySelector("#ad-ext-plan-basis");

        // active state for segmented control
        if (basisWrap) {
            for (const b of basisWrap.querySelectorAll(".ad-ext-segbtn")) {
                const isOn = String(b?.dataset?.basis || "").toUpperCase() === basis;
                b.classList.toggle("ad-ext-segbtn--active", isOn);
            }
        }

        // selected week (shared with time overview table)
        const selWeekKey = ensurePlanSelectedWeekKey(weeksAsc);

        // week dropdown (Training-Tab)
        const weekSelect = panel.querySelector("#ad-ext-plan-week-select");
        if (weekSelect) {
            const list = Array.isArray(weeksAsc) ? [...weeksAsc] : [];
            const currentWeekKey = weekKeyFromDate(new Date());

            const opts = list.slice().reverse().map((w) => {
                const wk = String(w?.weekKey || "");
                if (!wk) return "";

                const isPast = !!currentWeekKey && wk < currentWeekKey;
                const isCurrent = !!currentWeekKey && wk === currentWeekKey;

                let styleAttr = "";
                let labelSuffix = "";

                if (isPast) styleAttr = ' style="color: rgba(255,255,255,0.45);"';
                if (isCurrent) {
                    styleAttr = ' style="font-weight: 950; color: rgba(255,255,255,0.95);"';
                    labelSuffix = " (aktuell)";
                }

                const kw = w?.kw ? `KW ${w.kw}${w.isoYear ? "/" + w.isoYear : ""}` : "Woche";
                const range = w?.rangeLabel || "";
                const label = range ? `${kw} · ${range}${labelSuffix}` : `${kw}${labelSuffix}`;
                return `<option value="${escapeHtml(wk)}"${styleAttr}>${escapeHtml(label)}</option>`;
            }).filter(Boolean);

            weekSelect.innerHTML = opts.length ? opts.join("") : `<option value="">–</option>`;
            if (selWeekKey) weekSelect.value = String(selWeekKey);
        }

        // header label
        const wObj = Array.isArray(weeksAsc) ? weeksAsc.find(w => String(w?.weekKey || "") === String(selWeekKey || "")) : null;
        if (weekLabel) {
            if (wObj?.kw) {
                const year = wObj?.isoYear ? `/${wObj.isoYear}` : "";
                weekLabel.textContent = `KW ${wObj.kw}${year} · ${wObj.rangeLabel || ""}`;
            } else {
                const wk = weekRangeFromWeekKey(selWeekKey);
                if (wk) {
                    weekLabel.textContent = `Woche · ${fmtDayKeyDE(wk.startKey)} – ${fmtDayKeyDE(wk.endKey)}`;
                } else {
                    weekLabel.textContent = "Woche · –";
                }
            }
        }
        if (weekSub) {
            // 0.14.47: Info-Text entfernt (UI aufräumen)
            weekSub.textContent = "";
            try { weekSub.style.display = "none"; } catch {}
        }

        const { byActivity, stTargets } = aggregateTrainingActualsForWeek(selWeekKey);


        const goals = (st.goals && st.goals[basis]) ? st.goals[basis] : {};
        const goalFor = (k) => Number(goals?.[k] ?? 0);

        const fmtSollInput = (v) => {
            if (basis === "TIME") return fmtNumCompact(v, 2);
            return String(Math.round(Number(v) || 0));
        };

        const fmtIst = (sec, cnt) => {
            if (basis === "TIME") return fmtHours(Number(sec) || 0);
            return String(Math.round(Number(cnt) || 0));
        };

        const unitsIst = (sec, cnt) => {
            if (basis === "TIME") return (Number(sec) || 0) / 3600;
            return Math.round(Number(cnt) || 0);
        };

        const unitsGoal = (v) => {
            if (basis === "TIME") return Number(v) || 0;
            return Math.round(Number(v) || 0);
        };

        const progressCell = (istVal, goalVal) => {
            const hasGoal = goalVal > 0;
            const ratio = hasGoal ? (istVal / goalVal) : 0;

            const pctNum = hasGoal
            ? Math.max(0, Math.min(100, (Number.isFinite(ratio) ? ratio : 0) * 100))
            : 0;
            const pctShow = hasGoal ? (Math.round(pctNum * 10) / 10) : 0;
            const pctTxt = hasGoal ? `${pctShow.toFixed(1)}%` : "–";

            return `
              <div class="ad-ext-plan-progresswrap" data-pct="${pctNum}" data-has-goal="${hasGoal ? 1 : 0}" style="display:flex;flex-direction:column;gap:4px;">
                <div class="ad-ext-plan-pct">${pctTxt}</div>
              </div>
            `;
        };

    if (mainBody) {
        const rows = [];

        const weekId = selWeekKey ? weekIdFromWeekKey(selWeekKey) : "";
        const wp = weekId ? loadWeekPlan(weekId) : null;

        const viewMode = (basis === "SESS") ? "sessions" : "time";
        const items = (wp && Array.isArray(wp.planItems)) ? sanitizePlanItemsForStorage(wp.planItems) : [];

        let totalGoal = 0;
        let totalIst = 0;
        let totalCredited = 0;
        let totalTimeSec = 0;

        const fmtGoal = (v) => {
            if (viewMode === "time") return `${clampMinutes(v)}min`;
            return String(clampSessions(v));
        };

        const fmtIstVal = (v) => {
            if (viewMode === "time") return `${Math.max(0, Math.round(Number(v) || 0))}min`;
            return String(Math.max(0, Math.round(Number(v) || 0)));
        };

        if (!wp || items.length === 0) {
            rows.push(`
            <tr>
              <td style="font-weight:950;">
                Kein Trainingsplan für diese Woche angelegt
                <div class="ad-ext-muted" style="margin-top:4px;">Rechts im Trainingsplan-Panel über <span style="font-weight:900;">+ Aktivität</span> anlegen.</div>
              </td>
              <td class="ad-ext-table-num-right">—</td>
              <td class="ad-ext-table-num-right">—</td>
              <td class="ad-ext-table-num-right ad-ext-table-nowrap">—</td>
              <td class="ad-ext-muted">—</td>
            </tr>
          `);
            } else {
                for (const it of items) {
                    const type = String(it?.type || "").trim() || "CUSTOM";
                    const lab = String(it?.name || "").trim() || type;

                    const trackerKey = PLANITEM_TYPE_TO_TRACKER_KEY[type] || type;

                    let goal = 0;
                    if (viewMode === "time") goal = clampMinutes(Number(it?.targetMinutes) || 0);
                    else goal = clampSessions(Number(it?.targetSessions) || 0);

                    let sec = 0;
                    let cnt = 0;

                    // Ist-Werte: Standard = nach Aktivität
                    const rec = byActivity.get(trackerKey) || { sec: 0, count: 0 };
                    sec = Number(rec?.sec || 0) || 0;
                    cnt = Number(rec?.count || 0) || 0;

                    // Sonderfall: Segment Training mit Targets -> Summe über Targets
                    if (type === "SEGMENT_TRAINING") {
                        const targets = it?.params?.targets;
                        if (Array.isArray(targets) && targets.length) {
                            let secSum = 0;
                            let cntSum = 0;
                            for (const t of targets) {
                                const k = String(t || "").trim();
                                if (!k) continue;
                                const a = stTargets.get(k) || { sec: 0, count: 0 };
                                secSum += Number(a?.sec || 0) || 0;
                                cntSum += Number(a?.count || 0) || 0;
                            }
                            sec = secSum;
                            cnt = cntSum;
                        }
                    }

                    const ist = (viewMode === "time") ? toIntMinutes(sec) : Math.round(cnt || 0);
                    const istNum = Math.max(0, Math.round(Number(ist) || 0));
                    const overtrainedRow = (Number(istNum) || 0) > (Number(goal) || 0) + 1e-9;
                    const istTxt = (viewMode === "time") ? `${overtrainedRow ? "⚠️ " : ""}${istNum}min` : `${overtrainedRow ? " ⚠️" : ""}${istNum}`;
                    try { if (overtrainedRow) console.debug("[trainingsdaten row]", { activityKey: trackerKey, goal, istRaw: istNum, istCredited: Math.min(istNum, goal), overtrained: overtrainedRow }); } catch {}

                    // Donut->Tabelle Filter (Trainingsfortschritt): Zeilen-Status (0.14.79)
                    const credited = Math.min(ist, goal);
                    const status = (goal > 0 && credited >= goal) ? "reached" : ((goal > 0) ? "open" : "");

                    totalGoal += goal;
                    totalIst += ist;
                    totalCredited += credited;

                    const timeTxt = fmtHours(Number(sec) || 0);

                    totalTimeSec += Number(sec) || 0;

                    rows.push(`
            <tr class="ad-ext-train-row" data-tracker-key="${escapeHtml(trackerKey)}" data-plan-type="${escapeHtml(type)}" data-plan-item-id="${escapeHtml(String(it?.id || ""))}" data-goal="${escapeHtml(String(goal))}" data-ist="${escapeHtml(String(ist))}" data-credited="${escapeHtml(String(credited))}" data-status="${escapeHtml(status)}">
              <td style="font-weight:950;" title="${escapeHtml(lab)}"><span class="ad-ext-rowexp">+</span>${escapeHtml(lab)}</td>
              <td class="ad-ext-table-num-right" style="font-weight:950; opacity:.9;">${escapeHtml(fmtGoal(goal))}</td>
              <td class="ad-ext-table-num-right" style="font-weight:950;"${overtrainedRow ? ' title="Hinweis: Übertraining! Für die Statistik wird IST = SOLL gewertet."' : ""}>${escapeHtml(istTxt)}</td>
              <td class="ad-ext-table-num-right ad-ext-table-nowrap" style="font-weight:950; opacity:.9;">${escapeHtml(timeTxt)}</td>
              <td>${progressCell(ist, goal)}</td>
            </tr>
          `);
                }
            }


            // total row
            const totalGoalTxt = (viewMode === "time") ? `${Math.round(totalGoal)}min` : String(Math.round(totalGoal));
            const totalIstRawTxt = (viewMode === "time") ? `${Math.round(totalIst)}min` : String(Math.round(totalIst));
            const totalCreditedTxt = (viewMode === "time") ? `${Math.round(totalCredited)}min` : String(Math.round(totalCredited));
            const overtrainingTip = "Hinweis: Übertraining! Für die Statistik wird IST = SOLL gewertet.";
            const istSumRaw = Number(totalIst) || 0;
            const creditedSum = Number(totalCredited) || 0;
            const overtrained = istSumRaw > creditedSum + 1e-9;
            const totalIstTxt = totalCreditedTxt;

            // KPI tiles (Training-View) – UI only (no wiring changes)
            const goalNum = Number(totalGoal) || 0;
            const istNum = Number(totalIst) || 0;
            const creditedNum = Number(totalCredited) || 0;
            const hasGoal = goalNum > 0;
            const pctNumRaw = hasGoal ? ((creditedNum / goalNum) * 100) : NaN;
            const pct = Number.isFinite(pctNumRaw) ? Math.max(0, Math.min(100, pctNumRaw)) : 0;

            // gesamte Trainingszeit der Woche (unabhängig vom Plan)
            let totalWeekSec = 0;
            try {
                for (const rec of (byActivity?.values?.() || [])) {
                    totalWeekSec += Number(rec?.sec || 0) || 0;
                }
            } catch {}

            try {
                const kpiSollEl = panel.querySelector("#ad-ext-train-kpi-soll");
                const kpiIstEl = panel.querySelector("#ad-ext-train-kpi-ist");
                const kpiTimeEl = panel.querySelector("#ad-ext-train-kpi-time");
                const kpiProgEl = panel.querySelector("#ad-ext-train-kpi-progress");
                const kpiBarEl = panel.querySelector("#ad-ext-train-kpi-progressbar");

                if (kpiSollEl) kpiSollEl.textContent = String(totalGoalTxt || "—");
                if (kpiIstEl) {
                    kpiIstEl.textContent = String(totalIstTxt || "—");
                    kpiIstEl.title = "";
                }
                if (kpiTimeEl) kpiTimeEl.textContent = String(fmtHours(Number(totalWeekSec) || 0) || "—");

                // Tooltip: Trainingszeit (Gesamt) – auf gesamter KPI-Kachel
                try {
                    const timeTile = kpiTimeEl?.closest(".ad-ext-kpi-tile");
                    if (timeTile) {
                        const tip = "Summe aller Trainingszeiten der Woche (inkl. Einheiten außerhalb des Plans).";
                        const applyTitleDeep = (el, text) => {
                            if (!el) return;
                            const t = String(text || "");
                            try { el.title = t; } catch {}
                            try { el.style.cursor = "default"; } catch {}
                            try {
                                for (const node of el.querySelectorAll("*")) {
                                    try { node.title = t; } catch {}
                                    try { node.style.cursor = "default"; } catch {}
                                }
                            } catch {}
                        };
                        applyTitleDeep(timeTile, tip);
                    }
                } catch {}
                if (kpiProgEl) kpiProgEl.textContent = hasGoal ? `${pct.toFixed(1)}%` : "—";
                if (kpiBarEl && kpiBarEl.style) kpiBarEl.style.width = `${pct}%`;
            } catch {}

            try {
                console.debug("[trainingsdaten sums]", { selWeekKey, totalGoal, istSumRaw, creditedSum });
            } catch {}

            const totalTimeTxt = fmtHours(Number(totalTimeSec) || 0);

            rows.push(`
          <tr class="ad-ext-row-total">
            <td style="font-weight:950;">Gesamt (Plan)</td>
            <td class="ad-ext-table-num-right" style="font-weight:950; opacity:.9;">${escapeHtml(totalGoalTxt)}</td>
            <td class="ad-ext-table-num-right" style="font-weight:950;">${escapeHtml(totalIstTxt)}</td>
            <td class="ad-ext-table-num-right ad-ext-table-nowrap" style="font-weight:950; opacity:.9;">${escapeHtml(totalTimeTxt)}</td>
            <td>${progressCell(totalCredited, totalGoal)}</td>
          </tr>
        `);

            mainBody.innerHTML = rows.join("");

            // Inject progress bars (DOM) into progress cells
            for (const wrap of mainBody.querySelectorAll(".ad-ext-plan-progresswrap")) {
                const pct = parseFloat(String(wrap.getAttribute("data-pct") || "0"));
                const hasGoal = String(wrap.getAttribute("data-has-goal") || "") === "1";
                wrap.appendChild(createProgressBarDom(pct, hasGoal));
            }

            // Charts (optional): Erreicht vs Offen (Fortschritt, nicht substituierbar)
            try { renderTrainingProgressCharts(panel, totalGoal, totalCredited, totalIst, viewMode); } catch {}
            // Tabelle -> SOLL Donut: Klick auf Aktivitätszeile toggelt SOLL-Filter (0.14.87)
            try { ensureTrainingSollSplitTableWiring(panel); } catch {}


        }


}


    function wireSegmentInteractions(panel) {
        const segPanel = panel.querySelector("#ad-ext-view-segment");
        if (!segPanel) return;

        const rerender = () => {
            tooltipHide();
            if (cache?.loaded) {
                renderSegmentTraining(panel, cache.sessions || [], cache.filters || {}, cache.meta || {});
            }
        };

        const toggleSelectedTarget = (target) => {
            const t = String(target || "").trim();
            if (!t) return;
            cache.filters = cache.filters || {};
            cache.filters.selectedTarget = (cache.filters.selectedTarget === t) ? null : t;
            cache._st_radar_hoverIndex = null;
            rerender();
        };

        const toggleSelectedDayKey = (dayKey) => {
            const dk = String(dayKey || "").trim();
            if (!dk) return;
            cache.filters = cache.filters || {};
            cache.filters.selectedDayKey = (cache.filters.selectedDayKey === dk) ? null : dk;
            cache._st_radar_hoverIndex = null;
            rerender();
        };

        const toggleSegmentType = (typeKey) => {
            const k = String(typeKey || "ALL").toUpperCase().trim();
            cache.filters = cache.filters || {};
            const cur = String(cache.filters.segmentType || "ALL").toUpperCase().trim();
            cache.filters.segmentType = (cur === k) ? "ALL" : k;

            // sync dropdown
            const selType = panel.querySelector("#ad-ext-filter-segtype");
            if (selType) selType.value = cache.filters.segmentType;

            cache._st_radar_hoverIndex = null;
            rerender();
        };

        segPanel.addEventListener("mousemove", (ev) => {
            const el = tooltip();
            if (el.style.display !== "none") tooltipMove(ev);
        });
        segPanel.addEventListener("mouseleave", () => {
            tooltipHide();
            if (cache._st_radar_hoverIndex !== null) {
                cache._st_radar_hoverIndex = null;
                const cRadar2 = segPanel.querySelector("#ad-ext-chart-radar");
                const layout = cache._st_layouts?.radar;
                const hi = cache?._st_radar_selectedIndex ?? null;
                if (cRadar2 && layout && layout.type === "radar") {
                    const next = drawRadar(cRadar2, layout.labels || [], layout.values || [], { highlightIndex: hi, autoScale: true });
                    next.dataList = layout.dataList || [];
                    cache._st_layouts = cache._st_layouts || {};
                    cache._st_layouts.radar = next;
                }
            }
        });

        // --- Donut (Spieltypen-Verhältnis) ---
        const cDonut = segPanel.querySelector("#ad-ext-chart-donut");
        const donutLegend = segPanel.querySelector("#ad-ext-legend-donut");
        if (cDonut) {
            const isSvg = String(cDonut.tagName || "").toLowerCase() === "svg";

            const showSliceTooltip = (ev, slice, total) => {
                const pct = total > 0 ? (Number(slice?.value || 0) * 100) / total : 0;
                const title = `<div class="ad-ext-tooltip-title">${escapeHtml(slice?.label || "")}</div>`;
                const line = `<div class="ad-ext-tooltip-kv"><div style="opacity:.78;">Sessions</div><div style="font-weight:900;">${fmtInt(slice?.value || 0)} <span style="opacity:.78; font-weight:800;">(${pct.toFixed(1)}%)</span></div></div>`;
                tooltipShow(ev, title + line);
            };

            const segTypeFromSlice = (slice) => {
                const ek = String(slice?.extra?.typeKey || "").toUpperCase();
                if (ek) return ek;
                const lbl = String(slice?.label || "").toLowerCase();
                if (lbl.startsWith("single")) return "SINGLE";
                if (lbl.startsWith("double")) return "DOUBLE";
                if (lbl.startsWith("triple")) return "TRIPLE";
                return "ALL";
            };

            if (isSvg) {
                // SVG: Event-Delegation über die <path data-ad-slice="..."> Elemente
                cDonut.addEventListener("mousemove", (ev) => {
                    const layout = cache._st_layouts?.donut;
                    if (!layout || layout.type !== "donut") { tooltipHide(); return; }

                    const p = ev.target?.closest?.("path[data-ad-slice]");
                    if (!p) { tooltipHide(); return; }

                    const idx = Number(p.getAttribute("data-ad-slice"));
                    const slice = layout.slices?.find(s => Number(s.index) === idx);
                    if (!slice) { tooltipHide(); return; }

                    showSliceTooltip(ev, slice, Number(layout.total || 0));
                });

                cDonut.addEventListener("click", (ev) => {
                    const layout = cache._st_layouts?.donut;
                    if (!layout || layout.type !== "donut") return;

                    const p = ev.target?.closest?.("path[data-ad-slice]");
                    if (!p) return;

                    const idx = Number(p.getAttribute("data-ad-slice"));
                    const slice = layout.slices?.find(s => Number(s.index) === idx);
                    if (!slice) return;

                    toggleSegmentType(segTypeFromSlice(slice));
                });
            } else {
                // Canvas (Fallback)
                cDonut.addEventListener("mousemove", (ev) => {
                    const layout = cache._st_layouts?.donut;
                    if (!layout || layout.type !== "donut") { tooltipHide(); return; }

                    const pt = canvasPoint(ev, cDonut);
                    const hit = hitTestDonut(layout, pt);
                    if (!hit) { tooltipHide(); return; }

                    showSliceTooltip(ev, hit, Number(layout.total || 0));
                });

                cDonut.addEventListener("click", (ev) => {
                    const layout = cache._st_layouts?.donut;
                    if (!layout || layout.type !== "donut") return;

                    const pt = canvasPoint(ev, cDonut);
                    const hit = hitTestDonut(layout, pt);
                    if (!hit) return;

                    toggleSegmentType(segTypeFromSlice(hit));
                });
            }

            cDonut.addEventListener("mouseleave", () => tooltipHide());
        }

        if (donutLegend) {
            donutLegend.addEventListener("click", (ev) => {
                const el = ev.target?.closest?.(".ad-ext-legend-item[data-ad-st-type]");
                if (!el) return;
                const k = el.getAttribute("data-ad-st-type");
                if (!k) return;
                toggleSegmentType(k);
            });
        }

        // --- Radar (Performance / Hit %) ---
        const cRadar = segPanel.querySelector("#ad-ext-chart-radar");
        if (cRadar) {
            const redrawRadar = (hi) => {
                const base = cache._st_layouts?.radar;
                if (!base || base.type !== "radar") return;

                const useHi = (hi !== null && hi !== undefined) ? hi : (cache?._st_radar_selectedIndex ?? null);

                const next = drawRadar(cRadar, base.labels || [], base.values || [], { highlightIndex: useHi, autoScale: true });
                next.dataList = base.dataList || [];
                cache._st_layouts = cache._st_layouts || {};
                cache._st_layouts.radar = next;
            };

            cRadar.addEventListener("mousemove", (ev) => {
                const layout = cache._st_layouts?.radar;
                if (!layout || layout.type !== "radar") { tooltipHide(); return; }

                const pt = canvasPoint(ev, cRadar);
                const idx = hitTestRadar(layout, pt);

                if (idx === null || idx === undefined) {
                    if (cache._st_radar_hoverIndex !== null) {
                        cache._st_radar_hoverIndex = null;
                        redrawRadar(null);
                    }
                    tooltipHide();
                    return;
                }

                if (cache._st_radar_hoverIndex !== idx) {
                    cache._st_radar_hoverIndex = idx;
                    redrawRadar(idx);
                }

                const row = layout.dataList?.[idx] || {};
                const label = row?.target || layout.labels?.[idx] || "";
                const hits = Number(row?.hits ?? 0);
                const darts = Number(row?.darts ?? 0);
                const sessions = Number(row?.sessions ?? row?.legs ?? 0);
                const hitPct = darts > 0 ? (hits * 100) / darts : Number(layout.values?.[idx] ?? 0);

                const line = `<div class="ad-ext-tooltip-title">${escapeHtml(label)}</div>
<div class="ad-ext-tooltip-kv"><div style="opacity:.78;">Sessions</div><div style="font-weight:900;">${fmtInt(sessions)}</div></div>
<div class="ad-ext-tooltip-kv"><div style="opacity:.78;">Hits / Darts</div><div style="font-weight:900;">${fmtInt(hits)} / ${fmtInt(darts)}</div></div>
<div class="ad-ext-tooltip-kv"><div style="opacity:.78;">Hit %</div><div style="font-weight:900;">${(Number.isFinite(hitPct) ? hitPct : 0).toFixed(2)}%</div></div>`;

                tooltipShow(ev, line);
            });

            cRadar.addEventListener("mouseleave", () => {
                tooltipHide();
                if (cache._st_radar_hoverIndex !== null) {
                    cache._st_radar_hoverIndex = null;
                    redrawRadar(null);
                }
            });

            cRadar.addEventListener("click", (ev) => {
                const layout = cache._st_layouts?.radar;
                if (!layout || layout.type !== "radar") return;

                const pt = canvasPoint(ev, cRadar);
                const idx = hitTestRadar(layout, pt);
                if (idx === null || idx === undefined) return;

                const label = layout.labels?.[idx] || "";
                if (!label) return;

                toggleSelectedTarget(label);
            });
        }

        // --- Bars (Treffer je Target / Hits) ---
        const cHits = segPanel.querySelector("#ad-ext-chart-bar");
        if (cHits) {
            const renderHitsTooltip = (d, total) => {
                const label = d?.target || d?.label || "";
                const hits = Number(d?.hits ?? d?.value ?? 0);
                const sessions = Number(d?.sessions || 0);
                const darts = Number(d?.darts || 0);
                const pct = total > 0 ? (hits * 100) / total : 0;

                return `
<div class="ad-ext-tooltip-title">${escapeHtml(label)}</div>
<div class="ad-ext-tooltip-kv"><div style="opacity:.78;">Hits</div><div style="font-weight:900;">${fmtInt(hits)} <span style="opacity:.78; font-weight:800;">(${pct.toFixed(1)}% Anteil)</span></div></div>
<div class="ad-ext-tooltip-kv"><div style="opacity:.78;">Sessions</div><div style="font-weight:900;">${fmtInt(sessions)}</div></div>
<div class="ad-ext-tooltip-kv"><div style="opacity:.78;">Darts</div><div style="font-weight:900;">${fmtInt(darts)}</div></div>
<div class="ad-ext-tooltip-kv"><div style="opacity:.78;">Hit %</div><div style="font-weight:900;">${fmtPct(hits, darts)}</div></div>
`.trim();
            };

            cHits.addEventListener("mousemove", (ev) => {
                const layout = cache._st_layouts?.bar;
                if (!layout || layout.type !== "bars") { tooltipHide(); return; }

                const pt = canvasPoint(ev, cHits);
                const hit = hitTestBars(layout, pt);
                if (!hit) { tooltipHide(); return; }

                tooltipShow(ev, renderHitsTooltip(hit.data, Number(layout.total || 0)));
            });

            cHits.addEventListener("mouseleave", () => tooltipHide());

            cHits.addEventListener("click", (ev) => {
                const layout = cache._st_layouts?.bar;
                if (!layout || layout.type !== "bars") return;

                const pt = canvasPoint(ev, cHits);
                const hit = hitTestBars(layout, pt);
                if (!hit) return;

                const label = hit.data?.target || hit.data?.label || "";
                if (!label) return;

                toggleSelectedTarget(label);
            });
        }

        // --- Targets-Tabelle: Sortierung per Header-Klick ---
        const tarBodyForSort = segPanel.querySelector("#ad-ext-st-table-target");
        const tarTable = tarBodyForSort ? tarBodyForSort.closest("table") : null;
        const tarHead = tarTable ? tarTable.querySelector("thead") : null;
        if (tarHead) {
            tarHead.addEventListener("click", (ev) => {
                const th = ev.target?.closest?.("th[data-sort-key]");
                if (!th) return;

                ev.preventDefault();
                ev.stopPropagation();

                const key = th.getAttribute("data-sort-key");
                if (!key) return;

                cache.filters = cache.filters || {};
                const curKey = String(cache.filters.targetSortKey || "hitPct");
                let dir = String(cache.filters.targetSortDir || "desc").toLowerCase();

                if (key === curKey) {
                    dir = (dir === "asc") ? "desc" : "asc";
                } else {
                    cache.filters.targetSortKey = key;
                    dir = (key === "target") ? "asc" : "desc";
                }

                cache.filters.targetSortDir = (dir === "asc") ? "asc" : "desc";
                localStorage.setItem("ad_ext_st_targetSortKey", String(cache.filters.targetSortKey || "hitPct"));
                localStorage.setItem("ad_ext_st_targetSortDir", String(cache.filters.targetSortDir || "desc"));

                rerender();
            });
        }

        // --- Tables (Day / Target) ---
        const dayBody = segPanel.querySelector("#ad-ext-st-table-day");
        if (dayBody) {
            dayBody.addEventListener("click", (ev) => {
                const tr = ev.target?.closest?.("tr[data-day-key]");
                if (!tr) return;
                const dk = tr.getAttribute("data-day-key");
                if (!dk) return;
                toggleSelectedDayKey(dk);
            });
        }

        const tarBody = segPanel.querySelector("#ad-ext-st-table-target");
        if (tarBody) {
            tarBody.addEventListener("click", (ev) => {
                const tr = ev.target?.closest?.("tr[data-target]");
                if (!tr) return;
                const t = tr.getAttribute("data-target");
                if (!t) return;
                toggleSelectedTarget(t);
            });
        }
    }

    // =========================
    // X01 interactions
    // =========================
    function wireX01Interactions(panel) {
        const x01Panel = panel.querySelector("#ad-ext-view-x01");
        if (!x01Panel) return;

        x01Panel.addEventListener("mousemove", (ev) => {
            const el = tooltip();
            if (el.style.display !== "none" && el.dataset.pinned !== "1") tooltipMove(ev);
        });
        x01Panel.addEventListener("mouseleave", () => {
            const el = tooltip();
            if (el.dataset.pinned === "1") return;
            tooltipHide();
        });

        // Sortierbare Liga-Spalten (Klick auf Tabellen-Header)
        const leagueTable = x01Panel.querySelector("#ad-ext-x01-league-table");
        const leagueHead = leagueTable ? leagueTable.querySelector("thead") : null;
        if (leagueHead) {
            leagueHead.addEventListener("click", (ev) => {
                const th = ev.target?.closest?.("th[data-sort-key]");
                if (!th) return;

                ev.preventDefault();
                ev.stopPropagation();

                const key = th.getAttribute("data-sort-key");
                if (!key) return;

                const curKey = String(cache.filtersX01.leagueSortKey || "pointsFor");
                let dir = String(cache.filtersX01.leagueSortDir || "desc").toLowerCase();

                if (key === curKey) {
                    dir = (dir === "asc") ? "desc" : "asc";
                } else {
                    cache.filtersX01.leagueSortKey = key;
                    dir = (key === "name") ? "asc" : "desc";
                }

                cache.filtersX01.leagueSortDir = (dir === "asc") ? "asc" : "desc";
                localStorage.setItem("ad_ext_x01_leagueSortKey", String(cache.filtersX01.leagueSortKey || "pointsFor"));
                localStorage.setItem("ad_ext_x01_leagueSortDir", String(cache.filtersX01.leagueSortDir || "desc"));

                renderX01(panel);
                renderTimeTab(panel);
            });
        }


        x01Panel.addEventListener("mouseover", (ev) => {
            const tr = ev.target?.closest?.("tr[data-x01-row='1']");
            if (!tr) return;
            const ctx = cache._x01_context;
            if (!ctx?.last10?.length) return;
            tooltipShow(ev, tooltipHtmlLastMatches(ctx.last10));
        });
        x01Panel.addEventListener("mouseout", (ev) => {
            const fromTr = ev.target?.closest?.("tr[data-x01-row='1']");
            const toTr = ev.relatedTarget?.closest?.("tr[data-x01-row='1']");
            if (fromTr && fromTr !== toTr) tooltipHide();
        });

        function setSelectedPlayerKey(keyOrNull) {
            cache.filtersX01.kpiSelectedKey = keyOrNull;
            const matches = cache._x01_context?.filteredMatches || [];
            renderX01Kpis(panel, matches, cache.filtersX01.kpiSelectedKey || null);
            renderX01(panel);
            renderTimeTab(panel);
            renderTrainingTab(panel);
            renderMasterHallOfFame(panel);

            // Trainingsplan Sidebar (Step 3): Wochen + Ist-Werte aktualisieren
            try { cache._planSidebarRefreshWeeks?.(); } catch {}
            try { cache._planSidebarRerender?.(); } catch {}
        }
        // AVG KPI: Tooltip mit Rekord (bestes AVG im aktuellen Filter) + "Zum Spiel" Button
        (function wireAvgKpiRecordTooltip() {
            const avgVal = x01Panel.querySelector("#ad-ext-x01-kpi-avg");
            const tile = avgVal ? avgVal.closest(".ad-ext-kpi-tile") : null;
            if (!tile) return;
            if (tile.dataset.adExtAvgRecWired === "1") return;
            tile.dataset.adExtAvgRecWired = "1";

            const tipEl = tooltip();

            // Delegate: Button "Zum Spiel"
            if (tipEl && tipEl.dataset.adExtOpenMatchWired !== "1") {
                tipEl.dataset.adExtOpenMatchWired = "1";
                tipEl.addEventListener("click", (ev) => {
                    const btn = ev.target?.closest?.("[data-ad-open-match]");
                    if (!btn) return;
                    const matchId = btn.getAttribute("data-ad-open-match");
                    if (!matchId) return;
                    ev.preventDefault();
                    ev.stopPropagation();
                    try {
                        window.open(MATCH_URL_PREFIX + encodeURIComponent(String(matchId)), "_blank", "noopener");
                    } catch (e) {}
                    tooltipHide();
                });
            }

            let overTile = false;
            let overTip = false;
            let hideT = null;

            const fmtDecComma = (n, digits = 2) => fmtDec(n, digits).replace(".", ",");
            const fmtPctComma = (r) => fmtPctFromRatio(r).replace(".", ",");

            const scheduleHide = () => {
                if (hideT) clearTimeout(hideT);
                hideT = setTimeout(() => {
                    const el = tooltip();
                    if (el.dataset.pinnedOwner !== "x01avg") return;
                    if (overTile || overTip) return;
                    tooltipHide();
                }, 120);
            };

            const show = () => {
                const ctx = cache._x01_context || {};
                const matches = ctx.filteredMatches || [];
                const recordKey = null; // best AVG within current filtered matches (any player)

                const rec = computeBestAvgRecord(matches, recordKey);

                let html = "";
                if (!rec) {
                    html = `
              <div class="ad-ext-tooltip-title">GAMES AVERAGE</div>
              <div style="opacity:.75; padding-top:4px;">Keine Daten</div>
            `;
                } else {
                    const lineup = rec.lineup || "—";
                    const dateStr = rec.dateIso ? germanDateFromIso(rec.dateIso) : "—";
                    const avgStr = Number.isFinite(rec.avg) ? fmtDecComma(rec.avg, 2) : "—";
                    const btn = rec.matchId
                    ? `<button type="button" class="ad-ext-view-btn ad-ext-view-btn--xs" data-ad-open-match="${escapeHtml(String(rec.matchId))}">Zum Spiel</button>`
              : "";

                    html = `
              <div class="ad-ext-tooltip-record">
                <div class="ad-ext-tooltip-lineup ad-ext-tooltip-lineup--wrap">${escapeHtml(lineup)}</div>
                <div class="ad-ext-tooltip-recline">🏆 Rekord am <span class="ad-ext-tooltip-date">${escapeHtml(dateStr)}</span></div>
                <div class="ad-ext-tooltip-recavg">🎯 <span class="ad-ext-tooltip-avg">${escapeHtml(avgStr)}</span> AVG</div>
                ${btn ? `<div class="ad-ext-tooltip-actions">${btn}</div>` : ``}
              </div>
            `;
        }

                tooltipShow(null, html, { interactive: true, pinned: true, pinnedOwner: "x01avg" });
                tooltipMoveToRect(tile.getBoundingClientRect());
            };

            tile.addEventListener("mouseenter", () => {
                overTile = true;
                show();
            });
            tile.addEventListener("mouseleave", () => {
                overTile = false;
                scheduleHide();
            });

            // Keep tooltip open when moving onto it (only for pinned tooltip owner)
            tipEl.addEventListener("mouseenter", () => {
                if (tipEl.dataset.pinnedOwner !== "x01avg") return;
                overTip = true;
            });
            tipEl.addEventListener("mouseleave", () => {
                if (tipEl.dataset.pinnedOwner !== "x01avg") return;
                overTip = false;
                scheduleHide();
            });
            // Auto-refresh tooltip when filters rerender KPI (so record follows current filter)
            if (avgVal && tile.dataset.adExtAvgRecObs !== "1") {
                tile.dataset.adExtAvgRecObs = "1";
                const mo = new MutationObserver(() => {
                    const el = tooltip();
                    if (el.style.display === "none") return;
                    if (el.dataset.pinnedOwner !== "x01avg") return;
                    if (!(overTile || overTip)) return;
                    show();
                });
                mo.observe(avgVal, { childList: true, characterData: true, subtree: true });
            }

        })();



        // First 9 KPI: Tooltip mit Rekord (bestes First 9 AVG im aktuellen Filter) + "Zum Spiel" Button
        (function wireFirst9KpiRecordTooltip() {
            const f9Val = x01Panel.querySelector("#ad-ext-x01-kpi-f9");
            const tile = f9Val ? f9Val.closest(".ad-ext-kpi-tile") : null;
            if (!tile) return;
            if (tile.dataset.adExtF9RecWired === "1") return;
            tile.dataset.adExtF9RecWired = "1";

            const tipEl = tooltip();

            // Delegate: Button "Zum Spiel" (shared)
            if (tipEl && tipEl.dataset.adExtOpenMatchWired !== "1") {
                tipEl.dataset.adExtOpenMatchWired = "1";
                tipEl.addEventListener("click", (ev) => {
                    const btn = ev.target?.closest?.("[data-ad-open-match]");
                    if (!btn) return;
                    const matchId = btn.getAttribute("data-ad-open-match");
                    if (!matchId) return;
                    ev.preventDefault();
                    ev.stopPropagation();
                    try {
                        window.open(MATCH_URL_PREFIX + encodeURIComponent(String(matchId)), "_blank", "noopener");
                    } catch (e) {}
                    tooltipHide();
                });
            }

            let overTile = false;
            let overTip = false;
            let hideT = null;

            const fmtDecComma = (n, digits = 2) => fmtDec(n, digits).replace(".", ",");
            const fmtPctComma = (r) => fmtPctFromRatio(r).replace(".", ",");

            const scheduleHide = () => {
                if (hideT) clearTimeout(hideT);
                hideT = setTimeout(() => {
                    const el = tooltip();
                    if (el.dataset.pinnedOwner !== "x01f9") return;
                    if (overTile || overTip) return;
                    tooltipHide();
                }, 120);
            };

            const show = () => {
                const ctx = cache._x01_context || {};
                const matches = ctx.filteredMatches || [];

                const rec = computeBestFirst9Record(matches);

                let html = "";
                if (!rec) {
                    html = `
              <div class="ad-ext-tooltip-title">First 9 Average</div>
              <div style="opacity:.75; padding-top:4px;">Keine Daten</div>
            `;
                } else {
                    const lineup = rec.lineup || "—";
                    const dateStr = rec.dateIso ? germanDateFromIso(rec.dateIso) : "—";
                    const f9Str = Number.isFinite(rec.f9Avg) ? fmtDecComma(rec.f9Avg, 2) : "—";
                    const btn = rec.matchId
                    ? `<button type="button" class="ad-ext-view-btn ad-ext-view-btn--xs" data-ad-open-match="${escapeHtml(String(rec.matchId))}">Zum Spiel</button>`
              : "";

                    html = `
              <div class="ad-ext-tooltip-record">
                <div class="ad-ext-tooltip-lineup ad-ext-tooltip-lineup--wrap">${escapeHtml(lineup)}</div>
                <div class="ad-ext-tooltip-recline">🏆 Rekord am <span class="ad-ext-tooltip-date">${escapeHtml(dateStr)}</span></div>
                <div class="ad-ext-tooltip-recavg">🎯 <span class="ad-ext-tooltip-avg">${escapeHtml(f9Str)}</span> F9 AVG</div>
                ${btn ? `<div class="ad-ext-tooltip-actions">${btn}</div>` : ``}
              </div>
            `;
        }

                tooltipShow(null, html, { interactive: true, pinned: true, pinnedOwner: "x01f9" });
                tooltipMoveToRect(tile.getBoundingClientRect());
            };

            tile.addEventListener("mouseenter", () => {
                overTile = true;
                show();
            });
            tile.addEventListener("mouseleave", () => {
                overTile = false;
                scheduleHide();
            });

            tipEl.addEventListener("mouseenter", () => {
                if (tipEl.dataset.pinnedOwner !== "x01f9") return;
                overTip = true;
            });
            tipEl.addEventListener("mouseleave", () => {
                if (tipEl.dataset.pinnedOwner !== "x01f9") return;
                overTip = false;
                scheduleHide();
            });

            // Auto-refresh tooltip when filters rerender KPI
            if (f9Val && tile.dataset.adExtF9RecObs !== "1") {
                tile.dataset.adExtF9RecObs = "1";
                const mo = new MutationObserver(() => {
                    const el = tooltip();
                    if (el.style.display === "none") return;
                    if (el.dataset.pinnedOwner !== "x01f9") return;
                    if (!(overTile || overTip)) return;
                    show();
                });
                mo.observe(f9Val, { childList: true, characterData: true, subtree: true });
            }

        })();


        x01Panel.addEventListener("click", (ev) => {
            if (ev.target?.closest?.('[data-no-rowclick="1"]')) return;
            const tr = ev.target?.closest?.("tr[data-player-key]");
            if (!tr) return;
            const key = tr.getAttribute("data-player-key");
            if (!key) return;
            const next = (cache.filtersX01.kpiSelectedKey === key) ? null : key;
            setSelectedPlayerKey(next);
        });

        const cLegDiff = panel.querySelector("#ad-ext-x01-chart-legdiff");
        const cWL = panel.querySelector("#ad-ext-x01-chart-wl");
        const cTrend = panel.querySelector("#ad-ext-x01-chart-avgtrend");
        const cMomentum = panel.querySelector("#ad-ext-x01-chart-momentum");

        function wireCanvasBars(canvas, layoutGetter, tooltipRenderer, clickSelectPlayer = false) {
            if (!canvas) return;

            canvas.addEventListener("mousemove", (ev) => {
                const layout = layoutGetter();
                const pt = canvasPoint(ev, canvas);
                const hit = hitTestBars(layout, pt);
                if (!hit) { tooltipHide(); return; }
                tooltipShow(ev, tooltipRenderer(hit.data));
            });

            canvas.addEventListener("mouseleave", () => tooltipHide());

            if (clickSelectPlayer) {
                canvas.addEventListener("click", (ev) => {
                    const layout = layoutGetter();
                    const pt = canvasPoint(ev, canvas);
                    const hit = hitTestBars(layout, pt);
                    if (!hit?.data?.playerKey) return;
                    const key = hit.data.playerKey;
                    const next = (cache.filtersX01.kpiSelectedKey === key) ? null : key;
                    setSelectedPlayerKey(next);
                });
            }
        }

        function wireSvgBars(svg, layoutGetter, tooltipRenderer, clickSelectPlayer = false) {
            if (!svg) return;

            const pick = (ev) => {
                const el = ev.target?.closest?.("[data-ad-bar-index]");
                if (!el) return null;
                const idx = Number(el.getAttribute("data-ad-bar-index"));
                if (!Number.isFinite(idx)) return null;
                const layout = layoutGetter?.();
                const bar = layout?.bars?.[idx];
                return bar || null;
            };

            svg.addEventListener("mousemove", (ev) => {
                const hit = pick(ev);
                if (!hit) { tooltipHide(); return; }
                tooltipShow(ev, tooltipRenderer(hit.data));
            });

            svg.addEventListener("mouseleave", () => tooltipHide());

            if (clickSelectPlayer) {
                svg.addEventListener("click", (ev) => {
                    const hit = pick(ev);
                    if (!hit?.data?.playerKey) return;
                    const key = hit.data.playerKey;
                    const next = (cache.filtersX01.kpiSelectedKey === key) ? null : key;
                    setSelectedPlayerKey(next);
                });
            }
        }
        // Momentum interaktiv: Klick selektiert Spieler (wie andere Charts) – kein Hover-Linking
        if (cMomentum) {
            cMomentum.addEventListener("click", (ev) => {
                const rect = ev.target?.closest?.('rect[data-momentum-cell="1"][data-player-key]');
                if (!rect) return;
                ev.preventDefault();
                ev.stopPropagation();
                const key = rect.getAttribute("data-player-key");
                if (!key) return;
                const next = (cache.filtersX01.kpiSelectedKey === key) ? null : key;
                setSelectedPlayerKey(next);
            });
        }




        wireSvgBars(
            cLegDiff,
            () => cache._x01_layouts?.legdiff || { bars: [] },
            (d) => {
                const diff = Number(d.diff) || 0;
                const diffTxt = diff > 0 ? `+${diff}` : String(diff);
                return `
          <div class="ad-ext-tooltip-title">Match</div>
          <div class="ad-ext-tooltip-line">
            <div class="ad-ext-tooltip-date">${escapeHtml(d.date)}</div>
            <div class="ad-ext-tooltip-lineup" title="${escapeHtml(d.lineup)}">${escapeHtml(d.lineup)}</div>
            <div class="ad-ext-tooltip-legs">${escapeHtml(d.legsStr)}</div>
          </div>
          <div class="ad-ext-tooltip-kv">
            <div class="ad-ext-tooltip-k">Leg-Diff</div>
            <div class="ad-ext-tooltip-v">${escapeHtml(diffTxt)}</div>
          </div>
        `;
            }
        );

        wireSvgBars(
            cWL,
            () => cache._x01_layouts?.wl || { bars: [] },
            (d) => `
        <div class="ad-ext-tooltip-title">W/L</div>
        <div class="ad-ext-tooltip-kv"><div class="ad-ext-tooltip-k">Spieler</div><div class="ad-ext-tooltip-v">${escapeHtml(d.name)}</div></div>
        <div class="ad-ext-tooltip-kv"><div class="ad-ext-tooltip-k">Matches</div><div class="ad-ext-tooltip-v">${escapeHtml(String(d.matches))}</div></div>
        <div class="ad-ext-tooltip-kv"><div class="ad-ext-tooltip-k">W / L</div><div class="ad-ext-tooltip-v">${escapeHtml(String(d.wins))} / ${escapeHtml(String(d.losses))}</div></div>
        <div class="ad-ext-tooltip-kv"><div class="ad-ext-tooltip-k">Winrate</div><div class="ad-ext-tooltip-v">${escapeHtml(String(Math.round(d.winrate)))}%</div></div>
        <div class="ad-ext-tooltip-kv"><div class="ad-ext-tooltip-k">Ø LegsFor</div><div class="ad-ext-tooltip-v">${escapeHtml(fmtDec(d.avgFor, 2))}</div></div>
        <div class="ad-ext-tooltip-kv"><div class="ad-ext-tooltip-k">Ø LegsAgainst</div><div class="ad-ext-tooltip-v">${escapeHtml(fmtDec(d.avgAgainst, 2))}</div></div>
      `,
            true
        );

        // Trend tooltip (nearest leg index)
        if (cTrend) {
            cTrend.addEventListener("mousemove", (ev) => {
                const layout = cache._x01_layouts?.trend;
                const legs = cache._x01_context?.legsTrendLegs || [];
                if (!layout || layout.type !== "legline" || !layout.xPos?.length) { tooltipHide(); return; }

                const pt = canvasPoint(ev, cTrend);

                let bestI = -1;
                let bestD = Infinity;
                for (let i = 0; i < layout.xPos.length; i++) {
                    const d = Math.abs(pt.x - layout.xPos[i]);
                    if (d < bestD) { bestD = d; bestI = i; }
                }
                if (bestI < 0 || bestI >= legs.length) { tooltipHide(); return; }

                const leg = legs[bestI];
                const title = `<div class="ad-ext-tooltip-title">${escapeHtml(mmddFromIso(leg.dateIso))} · Leg ${bestI + 1}</div>`;

                const lines = [];
                for (const s of layout.pointsLayout) {
                    const p = s.pts[bestI];
                    if (!p) continue;
                    lines.push(`<div class="ad-ext-tooltip-kv"><div class="ad-ext-tooltip-k">${escapeHtml(s.name)}</div><div class="ad-ext-tooltip-v">${escapeHtml(fmtDec(p.v, 2))}</div></div>`);
                }
                if (!lines.length) { tooltipHide(); return; }

                // optional: lineup hint
                const lineup = leg?.lineup ? `<div class="ad-ext-tooltip-kv"><div class="ad-ext-tooltip-k">Lineup</div><div class="ad-ext-tooltip-v">${escapeHtml(leg.lineup)}</div></div>` : "";

                tooltipShow(ev, `${title}${lines.join("")}${lineup}`);
            });
            cTrend.addEventListener("mouseleave", () => tooltipHide());
        }
    }

    // =========================
    // Data Cache
    // =========================
    const normalizeLegacyDateRange = (v, fallback = "Y1") => {
        const raw = String(v || "").trim();
        const up = raw.toUpperCase();
        if (!up) return fallback;
        if (up === "LAST_DAY" || up === "THIS_MONTH") return fallback;
        return raw;
    };


    // Trainingsplan Soll & Ist (Draft: LocalStorage)
    const TRAINING_PLAN_STORAGE_KEY = "ad_ext_training_plan_v1";

    const TRAINING_ACTIVITIES = [
        { key: "ATC", label: "ATC" },
        { key: "COUNTUP", label: "CountUp" },
        { key: "CRICKET", label: "Cricket" },
        { key: "RANDOM_CHECKOUT", label: "Random Checkout" },
        { key: "SEGMENT_TRAINING", label: "Segment Training" },
        { key: "X01_BOT", label: "X01 vs Bot" },
        { key: "X01_HUMAN", label: "X01 vs Mensch" },
    ];

    const TRAINING_PLAN_DEFAULT = {
        basis: "SESS", // TIME | SESS
        selectedWeekKey: null,
        goals: {
            TIME: { // hours per week
                ATC: 0.5,
                COUNTUP: 0.5,
                CRICKET: 0.5,
                RANDOM_CHECKOUT: 0.5,
                SEGMENT_TRAINING: 3,
                X01_BOT: 1,
                X01_HUMAN: 1,
            },
            SESS: { // sessions per week
                ATC: 3,
                COUNTUP: 3,
                CRICKET: 3,
                RANDOM_CHECKOUT: 3,
                SEGMENT_TRAINING: 15,
                X01_BOT: 8,
                X01_HUMAN: 5,
            },
        },
        targets: {
            TIME: { // hours per week
                T20: 1,
                T19: 0.5,
                D20: 0.5,
            },
            SESS: { // sessions per week
                T20: 5,
                T19: 3,
                D20: 3,
            },
        },
    };

    function deepMergeDefaults(def, obj) {
        if (obj == null || typeof obj !== "object" || Array.isArray(obj)) return JSON.parse(JSON.stringify(def));
        const out = JSON.parse(JSON.stringify(def));

        const merge = (dst, src) => {
            if (src == null || typeof src !== "object" || Array.isArray(src)) return;
            for (const k of Object.keys(src)) {
                const v = src[k];
                if (v != null && typeof v === "object" && !Array.isArray(v) && dst[k] != null && typeof dst[k] === "object" && !Array.isArray(dst[k])) {
                    merge(dst[k], v);
                } else {
                    dst[k] = v;
                }
            }
        };

        merge(out, obj);
        return out;
    }

    function normalizePlanBasis(v) {
        const up = String(v || "").toUpperCase().trim();
        return (up === "SESS" || up === "SESSIONS") ? "SESS" : "TIME";
    }

    function loadTrainingPlanState() {
        try {
            const raw = localStorage.getItem(TRAINING_PLAN_STORAGE_KEY);
            if (!raw) {
                const s = deepMergeDefaults(TRAINING_PLAN_DEFAULT, null);
                s.basis = "SESS";
                return s;
            }
            const parsed = JSON.parse(raw);
            const merged = deepMergeDefaults(TRAINING_PLAN_DEFAULT, parsed);
            merged.basis = "SESS";

            // sanitize numbers
            for (const k of TRAINING_ACTIVITIES.map(a => a.key)) {
                const h = Number(merged?.goals?.TIME?.[k] ?? 0);
                const c = Number(merged?.goals?.SESS?.[k] ?? 0);
                merged.goals.TIME[k] = Number.isFinite(h) && h >= 0 ? h : 0;
                merged.goals.SESS[k] = Number.isFinite(c) && c >= 0 ? Math.round(c) : 0;
            }
            for (const t of Object.keys(merged?.targets?.TIME || {})) {
                const h = Number(merged.targets.TIME[t] ?? 0);
                merged.targets.TIME[t] = Number.isFinite(h) && h >= 0 ? h : 0;
            }
            for (const t of Object.keys(merged?.targets?.SESS || {})) {
                const c = Number(merged.targets.SESS[t] ?? 0);
                merged.targets.SESS[t] = Number.isFinite(c) && c >= 0 ? Math.round(c) : 0;
            }

            merged.selectedWeekKey = merged.selectedWeekKey || null;
            try { delete merged.showPerf; } catch (e) {}
            return merged;
        } catch {
            const s = deepMergeDefaults(TRAINING_PLAN_DEFAULT, null);
            s.basis = "SESS";
            return s;
        }
    }

    function saveTrainingPlanState(state) {
        try {
            const s = (state && typeof state === "object") ? { ...state } : state;
            if (s && typeof s === "object") { try { delete s.showPerf; } catch (e) {} }
            localStorage.setItem(TRAINING_PLAN_STORAGE_KEY, JSON.stringify(s));
        } catch (e) {
            console.warn("[AD Ext] saveTrainingPlanState failed:", e);
        }
    }

    function parseFlexibleNumberInput(raw) {
        const s = String(raw || "").trim();
        if (!s) return 0;
        // allow partial decimals while typing: "1," or "1." -> return NaN
        if (/[\.,]$/.test(s)) return NaN;

        const cleaned = s.replace(/\s+/g, "").replace(",", ".");
        const v = Number(cleaned);
        if (!Number.isFinite(v)) return NaN;
        if (v < 0) return 0;
        return v;
    }

    function fmtNumCompact(n, maxDec = 2) {
        const v = Number(n);
        if (!Number.isFinite(v)) return "0";
        const f = v.toFixed(maxDec);
        return f.replace(/\.?0+$/, "");
    }

    function ensurePlanSelectedWeekKey(weeksAsc) {
        cache.trainingPlan = cache.trainingPlan || loadTrainingPlanState();
        const st = cache.trainingPlan;

        const __firstInit = !cache._planWeekInitDone;
        cache._planWeekInitDone = true;

        const available = (Array.isArray(weeksAsc) ? weeksAsc : [])
        .map(w => String(w?.weekKey || ""))
        .filter(Boolean);

        const thisKey = weekKeyFromDate(new Date());
        let sel = st.selectedWeekKey;

        if (__firstInit) {
            // Beim ersten Laden immer in die aktuelle Woche springen (wie gewünscht),
            // danach bleibt die Auswahl persistent wie bisher.
            if (thisKey) sel = thisKey;
        }

        if (available.length) {
            if (!sel || !available.includes(sel)) {
                sel = available.includes(thisKey) ? thisKey : available[available.length - 1];
            }
        } else {
            sel = sel || thisKey;
        }

        if (sel !== st.selectedWeekKey) {
            st.selectedWeekKey = sel;
            saveTrainingPlanState(st);
        }

        return sel;
    }

    function isBotLikePlayerName(name) {
        const s = String(name || "").toLowerCase();
        return /\b(bot|ai|cpu|computer)\b/.test(s) || s.includes("autodarts bot");
    }

    function isBotLevelPlayerName(name) {
        // Für die Bot-Checkbox gilt NUR dieses Muster: „BOT LEVEL …“
        return /^bot\s*level\b/i.test(String(name || "").trim());
    }


    function classifyX01MatchKind(match) {
        const players = Array.isArray(match?.players) ? match.players : [];
        if (players.length <= 1) return "BOT";
        for (const p of players) {
            if (isBotLikePlayerName(p?.name)) return "BOT";
        }
        return "HUMAN";
    }

    function fmtDayKeyDE(dayKey) {
        const d = parseDayKeyToLocalDate(dayKey);
        if (!d) return String(dayKey || "–");
        const dd = String(d.getDate()).padStart(2, "0");
        const mm = String(d.getMonth() + 1).padStart(2, "0");
        const yy = String(d.getFullYear());
        return `${dd}.${mm}.${yy}`;
    }

    const cache = {
        loaded: false,
        rows: [],
        sessions: [],
        x01Matches: [],
        meta: { totalRows: 0, segmentSessions: 0, x01Matches: 0, sourceText: "—" },
        filters: {
            segmentType: "ALL",
            dateRange: "Y1",
            selectedTarget: null,
            selectedDayKey: null,
            targetSortKey: localStorage.getItem("ad_ext_st_targetSortKey") || "hitPct",
            targetSortDir: localStorage.getItem("ad_ext_st_targetSortDir") || "desc",
        },
        filtersATC: {
            mode: "FULL",
            dateRange: "Y1",
            fieldSortKey: localStorage.getItem("ad_ext_atc_fieldSortKey") || "hitPct",
            fieldSortDir: localStorage.getItem("ad_ext_atc_fieldSortDir") || "desc",
        },
        // ATC Detail Cache (RAM only)
        atcDetailsByMatchId: new Map(),
        _atcDetailPromisesByMatchId: new Map(),
        filtersX01: {
            playerKey: localStorage.getItem("ad_ext_x01_playerKey") || "AUTO",
            dateRange: normalizeLegacyDateRange(localStorage.getItem("ad_ext_x01_dateRange"), "Y1"),
            comboKey: localStorage.getItem("ad_ext_x01_comboKey") || "AUTO_TOP",
            kpiSelectedKey: null,
            leagueSortKey: localStorage.getItem("ad_ext_x01_leagueSortKey") || "pointsFor",
            leagueSortDir: localStorage.getItem("ad_ext_x01_leagueSortDir") || "desc", subPanel: (localStorage.getItem("ad_ext_x01_subPanel") || "liga"),
        },
        filtersMasterHof: {
            playerKey: localStorage.getItem("ad_ext_master_playerKey") || "AUTO",
            includeBots: (localStorage.getItem("ad_ext_master_includeBots") === "1"),
        },

        // Tab 3: Zeit-Tracker
        filtersTime: {
            mode: (() => {
                const raw = localStorage.getItem("ad_ext_time_mode") || "ALL";
                const m = String(raw || "").toUpperCase().trim();
                if (m === "X01" || m === "X01_LIGA") return "X01_BOT";
                if (m === "ST") return "SEGMENT_TRAINING";
                if (m === "X01_HUMAN") return "ALL";
                const allowed = new Set(["ALL", ...TRAINING_ACTIVITIES.filter(a => a.key !== "X01_HUMAN").map(a => a.key)]);
                return allowed.has(m) ? m : "ALL";
            })(),
            range: localStorage.getItem("ad_ext_time_range") || "W12",
},
        timeEntries: [],
        _time_layouts: null,
        _st_layouts: null,
        _st_radar_hoverIndex: null,
        _x01_context: null,
        _x01_layouts: null,

        // Trainingsplan (Soll & Ist)
        trainingPlan: loadTrainingPlanState(),
        otherTrainingSessions: [],
        _time_weeksAsc: null,
        _training_weeksAsc: null,
        _plan_saveTimer: null,
    };

    async function loadFromDbOnce() {
        const loc = await resolveAutodartsIdbLocation();
        const rows = await idbGetAll(loc.dbName, loc.storeName);

        cache.rows = rows;
        cache.meta.totalRows = rows.length;
        cache.meta.sourceText = `IndexedDB (${loc.dbName}/${loc.storeName})`;

        const sessions = extractSegmentTrainingSessionsFromRows(rows);
        cache.sessions = sessions;
        cache.meta.segmentSessions = sessions.length;

        const x01Matches = extractX01MatchesFromRows(rows);
        cache.x01Matches = x01Matches;
        cache.meta.x01Matches = x01Matches.length;

        const otherTrainingSessions = extractOtherTrainingModeSessionsFromRows(rows);
        cache.otherTrainingSessions = otherTrainingSessions;

        // Zeit-Tracker: abgeleitete Einträge (für Wochen-Aggregation)
        cache.timeEntries = buildTimeEntries(sessions, x01Matches, otherTrainingSessions);

        cache.loaded = true;
    }

    async function refreshAll(panel) {
        const dayBody = panel.querySelector("#ad-ext-st-table-day");
        const tarBody = panel.querySelector("#ad-ext-st-table-target");
        const x01Body = panel.querySelector("#ad-ext-x01-league-body");
        const timeBody = panel.querySelector("#ad-ext-time-week-body");
        const planMainBody = panel.querySelector("#ad-ext-plan-main-body");
        const planFocusBody = panel.querySelector("#ad-ext-plan-focus-body");

        if (dayBody) dayBody.innerHTML = `<tr><td colspan="5" style="opacity:.7; padding:10px 12px;">Lade…</td></tr>`;
        if (tarBody) tarBody.innerHTML = `<tr><td colspan="5" style="opacity:.7; padding:10px 12px;">Lade…</td></tr>`;
        if (x01Body) x01Body.innerHTML = `<tr><td colspan="12" style="opacity:.7; padding:10px 12px;">Lade…</td></tr>`;
        if (timeBody) timeBody.innerHTML = `<tr><td colspan="10" style="opacity:.7; padding:10px 12px;">Lade…</td></tr>`;
        if (planMainBody) planMainBody.innerHTML = `<tr><td colspan="5" style="opacity:.7; padding:10px 12px;">Lade…</td></tr>`;
        if (planFocusBody) planFocusBody.innerHTML = `<tr><td colspan="6" style="opacity:.7; padding:10px 12px;">Lade…</td></tr>`;

        try {
            await loadFromDbOnce();
        } catch (e) {
            console.warn("[AD Ext] IDB read failed:", e);
            setSourceLabel(panel, "Datenquelle: IndexedDB nicht verfügbar");

            if (dayBody) dayBody.innerHTML = `<tr><td colspan="5" style="opacity:.7; padding:10px 12px;">IndexedDB nicht verfügbar</td></tr>`;
            if (tarBody) tarBody.innerHTML = `<tr><td colspan="5" style="opacity:.7; padding:10px 12px;">IndexedDB nicht verfügbar</td></tr>`;
            if (x01Body) x01Body.innerHTML = `<tr><td colspan="12" style="opacity:.7; padding:10px 12px;">IndexedDB nicht verfügbar</td></tr>`;

            setText(panel, "#ad-ext-st-kpi-sessions", "—");
            setText(panel, "#ad-ext-st-kpi-time", "—");
            setText(panel, "#ad-ext-st-kpi-time-sub", "—");
            setText(panel, "#ad-ext-st-kpi-points", "—");
            setText(panel, "#ad-ext-st-kpi-hitrate", "—");

            renderX01Kpis(panel, [], null);
            try { renderTimeTab(panel); } catch (e2) { console.warn("[AD Ext] renderTimeTab failed:", e2); }
            try { renderTrainingTab(panel); } catch (e2) { console.warn("[AD Ext] renderTrainingTab failed:", e2); }
            try { renderMasterHallOfFame(panel); } catch (e2) { console.warn("[AD Ext] renderMasterHallOfFame failed:", e2); }
            return;
        }

        try { renderSegmentTraining(panel, cache.sessions, cache.filters, cache.meta); } catch (e) { console.warn("[AD Ext] renderSegmentTraining failed:", e); }
        try { renderX01(panel); } catch (e) { console.warn("[AD Ext] renderX01 failed:", e); }
        try { renderTimeTab(panel); } catch (e) { console.warn("[AD Ext] renderTimeTab failed:", e); }
        try { renderTrainingTab(panel); } catch (e) { console.warn("[AD Ext] renderTrainingTab failed:", e); }

        // 0.14.174: Trainingsplan-Zeitschätzung sofort nach Daten-Load aktualisieren (ohne erneuten Tab/Toggle-Klick)
        try {
            const layout = panel.querySelector('.ad-train-layout');
            const tv = String(layout?.dataset?.trainView || localStorage.getItem(AD_EXT_TRAIN_VIEW_LS_KEY) || '').toUpperCase().trim();
            if (tv === 'PLAN' && typeof cache._planSidebarRerender === 'function') {
                setTimeout(() => {
                    try { cache._planSidebarRerender(); } catch {}
                }, 0);
            }
        } catch {}

        try { renderMasterHallOfFame(panel); } catch (e) { console.warn("[AD Ext] renderMasterHallOfFame failed:", e); }

    }

    // =========================
    // Wire Filters
    // =========================

    function applyTimeTrackerColumnFocus(panel, selectedKey) {
        const sel = String(selectedKey || "").toUpperCase().trim();
        const els = panel?.querySelectorAll?.('[data-tt-col]') || [];
        for (const el of els) {
            const col = String(el.getAttribute('data-tt-col') || '').toUpperCase().trim();
            const dim = !!sel && col && col !== 'TOTAL' && col !== sel;
            el.classList.toggle('ad-ext-tt-col--dim', dim);
        }
    }

    function applyTimeTrackerDonutFocus(donutSvg, donutLayout, selectedKey) {
        const sel = String(selectedKey || "").toUpperCase().trim();
        if (!donutSvg || String(donutSvg.tagName || "").toLowerCase() !== "svg") return;
        const paths = donutSvg.querySelectorAll('path[data-ad-slice]');
        for (const p of paths) {
            const idx = Number(p.getAttribute('data-ad-slice'));
            const slice = donutLayout?.slices?.find?.(s => Number(s.index) === idx);
            const key = String(slice?.extra?.key || "").toUpperCase().trim();
            if (sel && key && key !== sel) {
                p.style.opacity = "0.28";
            } else {
                p.style.opacity = "1";
            }
        }
    }

    function wireTimeFilters(panel) {
        if (!panel) return;
        if (panel.dataset.timeFiltersWired === "1") return;
        panel.dataset.timeFiltersWired = "1";

        const selMode = panel.querySelector("#ad-ext-time-mode");
        const selRange = panel.querySelector("#ad-ext-time-range");

        if (selMode) {
            selMode.addEventListener("change", () => {
                cache.filtersTime.mode = selMode.value || "ALL";
                localStorage.setItem("ad_ext_time_mode", cache.filtersTime.mode);
                try { cache.filtersTime.selectedWeekKey = ""; cache.filtersTime.selectedKey = ""; } catch {}
                renderTimeTab(panel);
            });
        }

        if (selRange) {
            selRange.addEventListener("change", () => {
                cache.filtersTime.range = selRange.value || "W12";
                localStorage.setItem("ad_ext_time_range", cache.filtersTime.range);
                try { cache.filtersTime.selectedWeekKey = ""; cache.filtersTime.selectedKey = ""; } catch {}
                renderTimeTab(panel);
            });
        }
    }

    function wireTimeInteractions(panel) {

        if (!panel) return;
        if (panel.dataset.timeInteractionsWired === "1") return;
        panel.dataset.timeInteractionsWired = "1";
        const chart = panel.querySelector("#ad-ext-time-chart");
        const donut = panel.querySelector("#ad-ext-time-donut");

        const labelByKey = new Map((TRAINING_ACTIVITIES || []).map(a => [String(a.key), String(a.label || a.key)]));
        const modeLabel = (k) => labelByKey.get(String(k)) || String(k || "");
        const keys = timeTrackerKeysOrdered();

        const secOf = (w, key) => {
            try { if (w?.byKeySec?.get) return Number(w.byKeySec.get(key) || 0) || 0; } catch {}
            return 0;
        };
        const cntOf = (w, key) => {
            try { if (w?.byKeyCount?.get) return Number(w.byKeyCount.get(key) || 0) || 0; } catch {}
            return 0;
        };
        const countLabel = (k) => (String(k || "").toUpperCase().trim() === "X01_BOT") ? "Matches" : "Sessions";

        const barHtml = (w) => {
            const kw = w?.kw ? `KW ${w.kw}${w.isoYear ? "/" + w.isoYear : ""}` : "Woche";
            const range = w?.rangeLabel || "";
            const total = fmtHours(Number(w?.totalSec || 0));

            const lines = [];
            for (const k of keys) {
                const sec = secOf(w, k);
                const cnt = cntOf(w, k);
                if (sec <= 0 && cnt <= 0) continue;

                const dot = timeTrackerColor(k, 0.85);
                const cntTxt = (Number(cnt) > 0) ? ` <span style="opacity:.75">(${fmtInt(cnt)} ${countLabel(k)})</span>` : "";
                lines.push(`<div><span class="ad-ext-dot" style="background:${escapeHtml(dot)}; margin-right:6px;"></span><b>${escapeHtml(modeLabel(k))}:</b> ${fmtHours(sec)}${cntTxt}</div>`);
            }
            if (!lines.length) lines.push(`<div class="ad-ext-muted">Keine Daten</div>`);

            return `
        <div style="font-weight:650; margin-bottom:6px;">${kw}</div>
        <div style="opacity:.85; margin-bottom:6px;">${range}</div>
        <div><b>Gesamt:</b> ${total}</div>
        ${lines.join("")}
      `;
        };

        if (chart) {
            chart.addEventListener("mousemove", (ev) => {
                const layout = cache._time_layouts?.weekChart;
                if (!layout) return tooltipHide();

                const pt = canvasPoint(ev, chart);
                const hit = hitTestBars(layout, pt);
                if (!hit) return tooltipHide();

                const html = barHtml(hit.data || hit);
                tooltipShow(ev, html);
            });
            chart.addEventListener("mouseleave", tooltipHide);

            chart.addEventListener("click", (ev) => {
                const layout = cache._time_layouts?.weekChart;
                if (!layout) return;

                const pt = canvasPoint(ev, chart);
                const seg = hitTestTimeStackSegments(layout, pt);
                if (seg && seg.weekKey) {
                    const wk = String(seg.weekKey || "");
                    const key = String(seg.key || "").toUpperCase().trim();
                    const same = (String(cache.filtersTime?.selectedWeekKey || "") === wk) && (String(cache.filtersTime?.selectedKey || "").toUpperCase().trim() === key);
                    cache.filtersTime.selectedWeekKey = same ? "" : wk;
                    cache.filtersTime.selectedKey = same ? "" : key;
                    renderTimeTab(panel);
                    return;
                }

                const b = hitTestBars(layout, pt);
                if (b && b.weekKey) {
                    const wk = String(b.weekKey || "");
                    const same = String(cache.filtersTime?.selectedWeekKey || "") === wk;
                    cache.filtersTime.selectedWeekKey = same ? "" : wk;
                    renderTimeTab(panel);
                }
            });
        }

        if (donut) {
            const isSvg = String(donut.tagName || "").toLowerCase() === "svg";

            if (isSvg) {
                // SVG: Event-Delegation über <path data-ad-slice>
                donut.addEventListener("mousemove", (ev) => {
                    const layout = cache._time_layouts?.donut;
                    if (!layout) return tooltipHide();

                    const p = ev.target?.closest?.('path[data-ad-slice]');
                    if (!p) return tooltipHide();

                    const idx = Number(p.getAttribute('data-ad-slice'));
                    const hit = layout.slices?.find(s => Number(s.index) === idx);
                    if (!hit) return tooltipHide();

                    const label = hit.label || "";
                    const value = fmtHours(Number(hit.value || 0));
                    const pct = Number.isFinite(hit.pct) ? (hit.pct * 100).toFixed(0) : "0";
                    tooltipShow(ev, `<div style="font-weight:650">${label}</div><div>${value} · ${pct}%</div>`);
                });
                donut.addEventListener("mouseleave", tooltipHide);

                donut.addEventListener("click", (ev) => {
                    const layout = cache._time_layouts?.donut;
                    if (!layout) return;

                    const p = ev.target?.closest?.('path[data-ad-slice]');
                    if (!p) return;

                    const idx = Number(p.getAttribute('data-ad-slice'));
                    const hit = layout.slices?.find(s => Number(s.index) === idx);
                    const key = String(hit?.extra?.key || "").toUpperCase().trim();
                    if (!key) return;

                    const same = String(cache.filtersTime?.selectedKey || "").toUpperCase().trim() === key;
                    cache.filtersTime.selectedKey = same ? "" : key;
                    renderTimeTab(panel);
                });
            } else {
                // Canvas (Fallback)
                donut.addEventListener("mousemove", (ev) => {
                    const layout = cache._time_layouts?.donut;
                    if (!layout) return tooltipHide();

                    const pt = canvasPoint(ev, donut);
                    const hit = hitTestDonut(layout, pt);
                    if (!hit) return tooltipHide();

                    const label = hit.label || "";
                    const value = fmtHours(Number(hit.value || 0));
                    const pct = Number.isFinite(hit.pct) ? (hit.pct * 100).toFixed(0) : "0";
                    tooltipShow(ev, `<div style="font-weight:650">${label}</div><div>${value} · ${pct}%</div>`);
                });
                donut.addEventListener("mouseleave", tooltipHide);

                donut.addEventListener("click", (ev) => {
                    const layout = cache._time_layouts?.donut;
                    if (!layout) return;

                    const pt = canvasPoint(ev, donut);
                    const hit = hitTestDonut(layout, pt);
                    const key = String(hit?.extra?.key || hit?.label || "").toUpperCase().trim();
                    if (!key) return;

                    const same = String(cache.filtersTime?.selectedKey || "").toUpperCase().trim() === key;
                    cache.filtersTime.selectedKey = same ? "" : key;
                    renderTimeTab(panel);
                });
            }
        }

        const tbody = panel.querySelector("#ad-ext-time-week-body");
        if (tbody) {
            tbody.addEventListener("click", (ev) => {
                const tr = ev.target?.closest?.('tr[data-week-key]');
                if (!tr) return;
                const wk = String(tr.getAttribute('data-week-key') || '');
                if (!wk) return;
                const same = String(cache.filtersTime?.selectedWeekKey || '') === wk;
                cache.filtersTime.selectedWeekKey = same ? '' : wk;
                renderTimeTab(panel);
            });
        }

    }


    // Trainingsplan: Bemerkungen (Richtext) - Sanitizing + Normalizing (0.14.195)
    // Speichert pro Woche HTML (Bullet-Listen, Fett, etc. aus GPT bleiben erhalten).
    function isNotesHtmlEmpty(rawHtml) {
        const s = String(rawHtml ?? "");
        if (!s) return true;
        const t = s
            .replace(/<br\s*\/?>(?:\s|&nbsp;)*/gi, "")
            .replace(/<\/?(div|p|span)[^>]*>/gi, " ")
            .replace(/&nbsp;/gi, " ")
            .replace(/<[^>]+>/g, " ")
            .replace(/\s+/g, " ")
            .trim();
        return !t;
    }

    function sanitizeNotesHtml(rawHtml) {
        const html = String(rawHtml ?? "");
        if (!html) return "";
        try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(`<div>${html}</div>`, "text/html");
            const root = (doc.body && doc.body.firstElementChild) ? doc.body.firstElementChild : doc.body;

            const ALLOWED = new Set(["DIV","P","BR","UL","OL","LI","B","STRONG","I","EM","U","S","CODE","PRE","SPAN","A"]);

            const unwrap = (el) => {
                const parent = el.parentNode;
                if (!parent) { try { el.remove(); } catch {} return; }
                while (el.firstChild) parent.insertBefore(el.firstChild, el);
                parent.removeChild(el);
            };

            const cleanEl = (el) => {
                const tag = String(el.tagName || "").toUpperCase();
                if (!tag) return;

                if (tag === "SCRIPT" || tag === "STYLE" || tag === "IFRAME" || tag === "OBJECT" || tag === "EMBED") {
                    try { el.remove(); } catch {}
                    return;
                }

                if (!ALLOWED.has(tag)) {
                    unwrap(el);
                    return;
                }

                const attrs = Array.from(el.attributes || []);
                for (const a of attrs) {
                    const n = String(a.name || "").toLowerCase();
                    if (!n) continue;

                    if (n.startsWith("on")) {
                        try { el.removeAttribute(a.name); } catch {}
                        continue;
                    }

                    if (tag === "A") {
                        if (n === "href") {
                            const href = String(el.getAttribute("href") || "");
                            if (/^\s*javascript:/i.test(href)) {
                                try { el.removeAttribute("href"); } catch {}
                            }
                        } else if (n === "target" || n === "rel") {
                            // keep
                        } else {
                            try { el.removeAttribute(a.name); } catch {}
                        }
                    } else {
                        try { el.removeAttribute(a.name); } catch {}
                    }
                }

                if (tag === "A") {
                    const target = String(el.getAttribute("target") || "");
                    const rel = String(el.getAttribute("rel") || "");
                    if (target && !rel) {
                        try { el.setAttribute("rel", "noopener noreferrer"); } catch {}
                    }
                }
            };

            const walk = (node) => {
                const children = Array.from(node.childNodes || []);
                for (const ch of children) {
                    if (!ch) continue;
                    if (ch.nodeType === 1) {
                        cleanEl(ch);
                        if (ch.parentNode) walk(ch);
                    } else if (ch.nodeType === 8) {
                        try { ch.remove(); } catch {}
                    }
                }
            };

            walk(root);

            let out = root.innerHTML || "";
            out = out.replace(/(?:<br\s*\/?>(?:\s|&nbsp;)*)+$/gi, "");
            return out;
        } catch (e) {
            return html;
        }
    }

    function normalizeNotesHtml(rawHtml) {
        const safe = sanitizeNotesHtml(rawHtml);
        return isNotesHtmlEmpty(safe) ? "" : safe;
    }


    // Training Plan Sidebar – Week Plans (0.14.34)
    // - weekMode + planItems werden pro ISO-Woche lokal gespeichert (LocalStorage)
    const WEEK_PLAN_STORAGE_PREFIX = "autodarts.segmentDash.plan.";

    /**
     * StoredWeekPlan (Storage)
     *   schemaVersion: 1;
     *   weekId: string; // z.B. "2026-W01"
     *   weekMode: "time" | "sessions";
     *   planItems: PlanItem[];
     */

    function weekIdFromWeekKey(weekKey) {
        const wr = weekRangeFromWeekKey(weekKey);
        const y = Number(wr?.isoYear);
        const w = Number(wr?.week);
        if (!Number.isFinite(y) || !Number.isFinite(w)) return String(weekKey || "");
        return `${y}-W${String(Math.max(1, Math.round(w))).padStart(2, "0")}`;
    }



    // Helper: Vorwoche berechnen (ISO-Woche, Format "YYYY-Www")
    // Muss Jahreswechsel korrekt behandeln (z.B. 2026-W01 -> 2025-W52/53)
    function getPreviousWeekId(weekId) {
        const m = /^(\d{4})-W(\d{2})$/i.exec(String(weekId || "").trim());
        if (!m) return "";
        const y = Number(m[1]);
        const w = Number(m[2]);
        if (!Number.isFinite(y) || !Number.isFinite(w) || w < 1) return "";

        // ISO-Woche -> lokales Datum (Montag) über "4. Januar ist immer in KW1"
        const jan4 = new Date(y, 0, 4);
        const week1Monday = startOfWeekMonday(jan4);
        if (!week1Monday) return "";

        const thisMonday = addDaysLocal(week1Monday, (Math.round(w) - 1) * 7);
        const prevMonday = addDaysLocal(thisMonday, -7);

        const info = isoWeekInfoLocal(prevMonday);
        const py = Number(info?.isoYear);
        const pw = Number(info?.week);
        if (!Number.isFinite(py) || !Number.isFinite(pw)) return "";

        return `${py}-W${String(Math.max(1, Math.round(pw))).padStart(2, "0")}`;
    }

    function normalizeWeekMode(m) {
        return (String(m || "") === "sessions") ? "sessions" : "time";
    }

    // Exakt die 3 Storage-Funktionen aus dem Spec:
    // loadWeekPlan, saveWeekPlan, deleteWeekPlan (optional)
    function loadWeekPlan(weekId) {
        const id = String(weekId || "").trim();
        if (!id) return null;
        const key = WEEK_PLAN_STORAGE_PREFIX + id;

        let raw = null;
        try { raw = localStorage.getItem(key); } catch (e) { return null; }
        if (!raw) return null;

        try {
            const obj = JSON.parse(raw);
            if (!obj || typeof obj !== "object") return null;
            const rawMode = String(obj.weekMode || "");
            const isLegacyTime = (rawMode === "time");

            // Sanitize planItems robust (IDs, strings, params etc.)
            let planItems = sanitizePlanItemsForStorage(Array.isArray(obj.planItems) ? obj.planItems : []);

            let notesHtml = normalizeNotesHtml(obj.notesHtml);

            // 0.14.75: UI unterstützt nur noch Sessions/Legs.
            // Legacy-Migration: weekMode "time" -> "sessions" + best-effort Conversion der Ziele.
            if (isLegacyTime) {
                const denom = Number(PLAN_SESSION_MINUTES) || 30;
                planItems = planItems.map((it) => {
                    const minutes = clampMinutes(Number(it?.targetMinutes) || 0);
                    const sess = minutes > 0 ? clampSessions(Math.max(1, Math.round(minutes / denom))) : 0;
                    return { ...it, targetSessions: sess };
                });

                // Persistiere Migration, damit "time" nicht wieder auftaucht
                try {
                    const migrated = { schemaVersion: 1, weekId: id, weekMode: "sessions", planItems, notesHtml };
                    localStorage.setItem(key, JSON.stringify(migrated));
                } catch {}
            }

            // Immer sessions nach außen
            return { schemaVersion: 1, weekId: id, weekMode: "sessions", planItems, notesHtml };
        } catch (e) {
            // Robustheit: Parse-Fehler -> null
            return null;
        }
    }

    function sanitizePlanItemForStorage(it) {
        const src = (it && typeof it === "object") ? it : {};

        const type = String(src.type || "CUSTOM").trim() || "CUSTOM";
        const id = String(src.id || "").trim() || makePlanId();
        const name = String(src.name || "").trim() || type;

        const targetMinutes = clampMinutes(Number(src.targetMinutes) || 0);

        // Migration / Defaults: targetSessions immer vorhanden (Default 1)
        let targetSessions = 1;
        if ("targetSessions" in src) {
            const n = Number(src.targetSessions);
            targetSessions = Number.isFinite(n) ? clampSessions(n) : 1;
        }

        let params = (src.params && typeof src.params === "object") ? { ...src.params } : undefined;

        // Migration / Defaults: Segment Training braucht params.targets (Array)
        if (type === "SEGMENT_TRAINING") {
            const p = params ? { ...params } : {};
            if (!Array.isArray(p.targets)) p.targets = [];
            p.targets = p.targets.map(x => String(x || "").trim()).filter(Boolean);
            params = p;
        } else if (params && Array.isArray(params.targets)) {
            params = { ...params, targets: params.targets.map(x => String(x || "").trim()).filter(Boolean) };
        }

        const out = { id, type, name, targetMinutes, targetSessions };
        if (params && typeof params === "object" && Object.keys(params).length) out.params = params;
        return out;
    }

    function sanitizePlanItemsForStorage(items) {
        const arr = Array.isArray(items) ? items : [];
        return arr.map(sanitizePlanItemForStorage);
    }

    function saveWeekPlan(plan) {
        const p = (plan && typeof plan === "object") ? plan : {};
        const weekId = String(p.weekId || "").trim();
        if (!weekId) return;

        const safe = {
            schemaVersion: 1,
            weekId,
            weekMode: normalizeWeekMode(p.weekMode),
            planItems: sanitizePlanItemsForStorage(p.planItems),
            notesHtml: normalizeNotesHtml(p.notesHtml || p.notes || ""),
        };

        const key = WEEK_PLAN_STORAGE_PREFIX + weekId;
        try {
            localStorage.setItem(key, JSON.stringify(safe));
            try { window.dispatchEvent(new CustomEvent("ad-ext-plan-changed", { detail: { weekId } })); } catch {}
            try {
                const ts = Date.now();
                _adPlanLastSavedAt = ts;
                window.dispatchEvent(new CustomEvent("ad-ext-plan-saved", { detail: { weekId, ts } }));
            } catch {}
        } catch (e) {
            // robust: ignore quota/private mode
        }
    }

    function deleteWeekPlan(weekId) {
        const id = String(weekId || "").trim();
        if (!id) return;
        const key = WEEK_PLAN_STORAGE_PREFIX + id;
        try { localStorage.removeItem(key); } catch (e) {}
        try { window.dispatchEvent(new CustomEvent("ad-ext-plan-changed", { detail: { weekId: id } })); } catch {}
    }

    // Internal: Save scheduling for the currently active week in the sidebar
    let _adPlanActiveWeekId = null;
    let _adPlanActiveWeekHasStoredPlan = false; // true wenn ein Plan aus Storage geladen wurde oder bereits gespeichert ist
    let _adPlanDirty = false; // wird erst bei User-Änderungen true (damit leere Wochen nicht auto-gespeichert werden)
    let _adPlanSaveTimer = null;
    let _adPlanLastSavedJson = null;
    let _adPlanLastSavedWeekId = null;
    let _adPlanLastSavedAt = 0;

    function saveCurrentWeekPlanNow() {
        const weekId = String(_adPlanActiveWeekId || "").trim();
        if (!weekId) return;

        // WICHTIG (0.14.42): Eine neue Woche ohne Plan soll NICHT automatisch gespeichert werden.
        // Speichern erst, wenn der User wirklich etwas geändert/angelegt hat.
        if (!_adPlanDirty) return;

        const safe = {
            schemaVersion: 1,
            weekId,
            weekMode: normalizeWeekMode(weekMode),
            planItems: sanitizePlanItemsForStorage(planItems),
            notesHtml: normalizeNotesHtml(planNotesHtml),
        };

        let json = "";
        try { json = JSON.stringify(safe); } catch (e) { return; }

        if (_adPlanLastSavedWeekId === weekId && _adPlanLastSavedJson === json) {
            // nothing to persist, but still emit a save event to clear UI hints (e.g. after clearing notes) (0.14.197)
            _adPlanDirty = false;
            try {
                const ts = Date.now();
                _adPlanLastSavedAt = ts;
                window.dispatchEvent(new CustomEvent("ad-ext-plan-saved", { detail: { weekId, ts } }));
            } catch (e) {}
            return;
        }

        const key = WEEK_PLAN_STORAGE_PREFIX + weekId;
        try {
            localStorage.setItem(key, json);
            try { window.dispatchEvent(new CustomEvent("ad-ext-plan-changed", { detail: { weekId } })); } catch {}
            try {
                const ts = Date.now();
                _adPlanLastSavedAt = ts;
                window.dispatchEvent(new CustomEvent("ad-ext-plan-saved", { detail: { weekId, ts } }));
            } catch {}
            _adPlanLastSavedWeekId = weekId;
            _adPlanLastSavedJson = json;
            _adPlanDirty = false;
            _adPlanActiveWeekHasStoredPlan = true;
        } catch (e) {
            // ignore
        }
    }

    function flushSaveCurrentWeekPlan() {
        if (_adPlanSaveTimer) {
            clearTimeout(_adPlanSaveTimer);
            _adPlanSaveTimer = null;
        }
        saveCurrentWeekPlanNow();
    }

    function scheduleSaveCurrentWeekPlan() {
        if (!_adPlanActiveWeekId) return;

        // mark dirty -> erst jetzt darf gespeichert werden
        _adPlanDirty = true;

        if (_adPlanSaveTimer) clearTimeout(_adPlanSaveTimer);
        _adPlanSaveTimer = setTimeout(() => {
            _adPlanSaveTimer = null;
            saveCurrentWeekPlanNow();
        }, 400);
    }

    let planOpen = false;
    let trainView = "DATA";
    const AD_EXT_TRAIN_VIEW_LS_KEY = "ad_ext_train_view";


    // UI Controls (Sidebar)
    let planWeek = weekKeyFromDate(new Date()) || "";
    let weekMode = "sessions"; // "time" | "sessions" (UI: sessions only since 0.14.75)

    // Drawer state (RAM)
    let planDrawerOpen = false;
    let planDrawerSearch = "";
    let statusTimer = null;

    // Auswahl (Step 2)
    let selectedPlanItemId = null;

    // Step 2: CSS für Auswahl + Detailbereich
    if (typeof GM_addStyle === "function") {
        GM_addStyle(`
          .ad-plan-table .ad-plan-row[data-plan-item-id] { cursor: pointer; }
          .ad-plan-table .ad-plan-row[data-plan-item-id]:active { cursor: pointer; }
          .ad-plan-table .ad-plan-drag-handle { display:inline-block; margin-right: 6px; opacity: .7; cursor: grab; }
          .ad-plan-table .ad-plan-drag-handle:hover { opacity: 1; }
          .ad-plan-table .ad-dragging .ad-plan-drag-handle { cursor: grabbing; }
          .ad-plan-table .ad-dragging { opacity: 0.5; }
          .ad-plan-table .ad-drop-target { outline: 2px dashed rgba(255,255,255,0.25); outline-offset: -2px; }
          .ad-plan-table .ad-plan-row--selected {
            background: rgba(0, 140, 255, 0.14) !important;
            box-shadow: inset 3px 0 0 rgba(0, 140, 255, 0.75);
          }

          .ad-plan-details { margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(0,0,0,.12); }
          /* 0.14.194: Trainingsplan – Bemerkungen (Platzhalter, Schritt 1) */
          .ad-plan-notes { margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(0,0,0,.12); }
          .ad-plan-notes + .ad-plan-details { border-top: none; padding-top: 0; }
          /* 0.14.198: Notes head layout (title + status left, clear button right) */
.ad-plan-notes-head-left { display:flex; flex-direction: column; gap: 4px; min-width: 0; }
.ad-plan-notes-head-right { display:flex; align-items:flex-start; gap: 8px; }
          .ad-plan-notes-saved { font-size: 11px; opacity: .75; line-height: 1.1; }
          .ad-plan-notes-saved.is-dirty { opacity: .95; }
          .ad-plan-notes-clear { white-space: nowrap; }
          .ad-plan-notes-editor {
            height: 180px;
            min-height: 180px;
            max-height: 180px;
            overflow-y: auto;
            overflow-x: hidden;
            box-sizing: border-box;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(0,0,0,.18);
            background: rgba(255,255,255,.06);
            outline: none;
            font-size: 13px;
            line-height: 1.35;
            white-space: pre-wrap;
          }
          .ad-plan-notes-editor:focus {
            border-color: rgba(0, 140, 255, 0.35);
            box-shadow: 0 0 0 2px rgba(0, 140, 255, 0.10);
          }
          .ad-plan-notes-editor:empty:before { content: attr(data-placeholder); opacity: .55; }
          .ad-plan-details-card { border: 1px solid rgba(0,0,0,.12); border-radius: 10px; padding: 10px; background: rgba(255,255,255,.04); }
          .ad-plan-details-head { display:flex; align-items:flex-start; justify-content:space-between; gap:10px; margin-bottom: 8px; }
          .ad-plan-details-title { font-weight: 800; font-size: 14px; line-height: 1.2; }
          .ad-plan-details-sub { opacity: .75; font-size: 12px; margin-top: 2px; }
          .ad-plan-details-badge { display:inline-flex; margin-top: 4px; padding: 2px 8px; border-radius: 999px; font-size: 11px; font-weight: 700; background: rgba(0,0,0,.10); opacity: .9; }

          /* 0.14.176: Trainingsplan – Details Layout (UX) */
          .ad-plan-details-grid { display:grid; grid-template-columns: minmax(0,1fr) minmax(0,1fr); gap: 10px; margin-top: 10px; align-items: stretch; }
          .ad-plan-details-grid .ad-plan-details-box { height: 100%; box-sizing: border-box; }
          .ad-plan-details-col { display:flex; flex-direction:column; gap: 10px; }
                    @media (max-width: 980px) {
            .ad-plan-details-grid { grid-template-columns: 1fr; }
          }
          .ad-plan-details-box { border: 1px solid rgba(0,0,0,.12); border-radius: 10px; padding: 10px; background: rgba(255,255,255,.03); }
          .ad-plan-details-box-title { display:flex; align-items:center; justify-content:space-between; gap: 10px; font-weight: 800; font-size: 12px; opacity: .95; margin-bottom: 8px; }
          .ad-plan-details-box-hint { font-size: 11px; font-weight: 700; opacity: .6; }
                    .ad-plan-est-formula { max-width: 100%; }


          .ad-plan-details-section { margin-top: 10px; }
          .ad-plan-details-label { display:block; font-size: 12px; opacity: .8; margin-bottom: 4px; }
          .ad-plan-details-name { width: 100%; box-sizing: border-box; padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(0,0,0,.18); background: rgba(255,255,255,.06); }

          .ad-plan-details-section-title { font-weight: 800; font-size: 12px; opacity: .9; margin-bottom: 6px; }

          /* 0.14.170: Trainingsplan – Zeitschätzung (Details) */
          .ad-plan-est-breakdown { display:grid; grid-template-columns: 1fr auto; gap: 4px 12px; font-size: 12px; }
          .ad-plan-est-breakdown .ad-plan-est-k { opacity: .8; }
          .ad-plan-est-breakdown .ad-plan-est-v { font-weight: 800; text-align: right; white-space: nowrap; }
          .ad-plan-est-formula { margin-top: 6px; font-size: 11px; opacity: .7; line-height: 1.25; }


          .ad-plan-chip-row { display:flex; flex-wrap: wrap; gap: 6px; }
          .ad-plan-chip {
            display:inline-flex; align-items:center; gap: 6px;
            padding: 4px 8px; border-radius: 999px;
            border: 1px solid rgba(0,0,0,.14); background: rgba(0,0,0,.08);
            font-size: 12px; line-height: 1;
          }
          .ad-plan-chip.ad-plan-chip--ghost { opacity: .55; }
          .ad-plan-chip.ad-plan-chip--ghost .ad-plan-chip-handle,
          .ad-plan-chip.ad-plan-chip--ghost .ad-plan-chip-x { display: none; }
          .ad-plan-details-box--targets .ad-ext-btn:disabled { opacity: .55; cursor: not-allowed; }
          .ad-plan-chip-x {
            border: none; background: transparent; cursor: pointer;
            font-weight: 900; opacity: .7; padding: 0 2px; line-height: 1;
          }
          .ad-plan-chip-x:hover { opacity: 1; }
          .ad-plan-chip-handle { cursor: grab; opacity: .7; user-select:none; }
          .ad-plan-chip-handle:hover { opacity: 1; }
          .ad-plan-chip.ad-dragging { opacity: .5; }
          .ad-plan-chip.ad-drop-target { outline: 2px dashed rgba(255,255,255,0.25); outline-offset: -2px; }
          .ad-plan-muted { opacity: .7; font-size: 12px; }
          .ad-plan-error { margin-top: 6px; font-size: 12px; color: #b00020; }

          .ad-plan-target-add { margin-top: 8px; }
          .ad-plan-target-add-row { display:flex; gap: 6px; align-items:center; flex-wrap: wrap; }
          .ad-plan-target-input {
            flex: 1 1 180px;
            padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(0,0,0,.18);
            background: rgba(255,255,255,.06);
          }

          .ad-plan-target-table-wrap { overflow:auto; }
          .ad-plan-target-table { width: 100%; border-collapse: collapse; font-size: 12px; }
          .ad-plan-target-table th, .ad-plan-target-table td { padding: 6px 8px; border-bottom: 1px solid rgba(0,0,0,.10); text-align: left; white-space: nowrap; }
          .ad-plan-target-table thead th { font-weight: 800; opacity: .9; background: rgba(0,0,0,.06); }
        `);
    }


    /**
     * PlanItem
     *   id: string
     *   type: string
     *   name: string
     *   targetMinutes: number
     *   targetSessions?: number
     *   params?: {
     *     targets?: string[]; // nur bei Segment Training
     *   }
     */
    const PLAN_ACTIVITY_TEMPLATES = [
        { type: "ATC", name: "ATC", defaultMinutes: 30 },
        { type: "COUNTUP", name: "CountUp", defaultMinutes: 30 },
        { type: "CRICKET", name: "Cricket", defaultMinutes: 30 },
        { type: "RANDOM_CHECKOUT", name: "Random Checkout", defaultMinutes: 30 },
        { type: "SEGMENT_TRAINING", name: "Segment Training", defaultMinutes: 180 },
        { type: "X01_BOT", name: "X01 vs Bot", defaultMinutes: 60 },
        { type: "X01_HUMAN", name: "X01 vs Mensch", defaultMinutes: 60 }
    ];


    // ---------------------------------------------------------
    // Plan targets: zentrale Validierung / Clamps (Step 4B / 0.14.31)
    // ---------------------------------------------------------
    const PLAN_TARGET_MAX_MINUTES = 24 * 60; // 1440
    const PLAN_TARGET_MAX_SESSIONS = 999;
    const PLAN_SESSION_MINUTES = 30; // Heuristik: 30 min pro Session

    /** @param {number} x @returns {number} */
    function clampMinutes(x) {
        let v = Number(x);
        if (!Number.isFinite(v)) v = 0;
        v = Math.round(v);
        if (v < 0) v = 0;
        if (v > PLAN_TARGET_MAX_MINUTES) v = PLAN_TARGET_MAX_MINUTES;
        return v;
    }

    /** @param {number} x @returns {number} */
    function clampSessions(x) {
        let v = Number(x);
        if (!Number.isFinite(v)) v = 0;
        v = Math.round(v);
        if (v < 0) v = 0;
        if (v > PLAN_TARGET_MAX_SESSIONS) v = PLAN_TARGET_MAX_SESSIONS;
        return v;
    }

    function makePlanId() {
        try {
            if (typeof crypto !== "undefined" && crypto && typeof crypto.randomUUID === "function") return crypto.randomUUID();
        } catch {}
        return String(Date.now()) + "_" + Math.random().toString(16).slice(2);
    }

    function stripNameSuffix(name) {
        const s = String(name || "").trim();
        const m = s.match(/^(.*)\s\((\d+)\)\s*$/);
        return m ? String(m[1] || "").trim() : s;
    }

    function escapeRegExp(s) {
        return String(s || "").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function nextUniqueName(baseName, items) {
        const base = String(baseName || "").trim() || "Aktivität";
        const names = new Set((Array.isArray(items) ? items : []).map(it => String(it?.name || "").trim()));
        if (!names.has(base)) return base;

        const re = new RegExp("^" + escapeRegExp(base) + "\\s\\((\\d+)\\)\\s*$");
        let maxN = 1;
        for (const n of names) {
            const m = String(n).match(re);
            if (m && m[1]) maxN = Math.max(maxN, parseInt(m[1], 10) || 1);
        }
        return `${base} (${maxN + 1})`;
    }


    // Training-Defaults (LEGS/Sessions) aus Settings pro PlanType (0.14.94)

    function getDefaultSessionsForPlanType(type) {

        const t = String(type || "").trim().toUpperCase();

        let v = 1;

        if (t === "ATC") v = AD_getSetting("TRAIN_DEF_LEGS_ATC", TRAIN_DEF_LEGS_ATC);

        else if (t === "COUNTUP") v = AD_getSetting("TRAIN_DEF_LEGS_COUNTUP", TRAIN_DEF_LEGS_COUNTUP);

        else if (t === "CRICKET") v = AD_getSetting("TRAIN_DEF_LEGS_CRICKET", TRAIN_DEF_LEGS_CRICKET);

        else if (t === "RANDOM_CHECKOUT") v = AD_getSetting("TRAIN_DEF_LEGS_RANDOM_CHECKOUT", TRAIN_DEF_LEGS_RANDOM_CHECKOUT);

        else if (t === "SEGMENT_TRAINING") v = AD_getSetting("TRAIN_DEF_LEGS_SEGMENT_TRAINING", TRAIN_DEF_LEGS_SEGMENT_TRAINING);

        else if (t === "X01_BOT") v = AD_getSetting("TRAIN_DEF_LEGS_X01_BOT", TRAIN_DEF_LEGS_X01_BOT);

        else if (t === "X01_HUMAN") v = AD_getSetting("TRAIN_DEF_LEGS_X01_HUMAN", TRAIN_DEF_LEGS_X01_HUMAN);


        // Safety: always >= 1 and clamped

        return clampSessions(Math.max(1, Number(v) || 0));

    }


    function createPlanItemFromTemplate(tpl, items) {
        const t = tpl || {};
        const base = String(t.name || "").trim() || "Aktivität";
        const type = String(t.type || base).trim() || "CUSTOM";


        const sessions = getDefaultSessionsForPlanType(type);
        const it = {
            id: makePlanId(),
            type,
            name: nextUniqueName(base, items),
            targetMinutes: clampMinutes(sessions * PLAN_SESSION_MINUTES),
            targetSessions: sessions
        };

        // Step 2: Segment Training bekommt params.targets (initial leer)
        if (type === "SEGMENT_TRAINING") {
            it.params = { targets: [] };
        }

        return it;
    }

    // Default-Initialisierung pro Woche (0.14.34):
    // Wenn kein gespeicherter Wochenplan existiert, wird daraus ein neuer Plan erzeugt.
    function createDefaultPlanItems() {
        let items = [];
        for (const tpl of PLAN_ACTIVITY_TEMPLATES) {
            items.push(createPlanItemFromTemplate(tpl, items));
        }
        return items;
    }

    // Start-State: wird beim Laden der Sidebar ggf. durch den gespeicherten Wochenplan überschrieben
    let planItems = [];

    let planNotesHtml = ""; // Richtext (HTML) pro Woche

    function wireTrainingPlanSidebarScaffold(panel) {
        if (!panel) return;


        // Plan-Sidebar: Aktionen ins Hamburger-Menü (0.14.91)
        try {
            const menuBtn = panel.querySelector("#adPlanMenuBtn");
            const menuDd = panel.querySelector("#adPlanMenuDropdown");
            const menuWrap = panel.querySelector("#adPlanMenu");
            if (menuBtn && menuDd && menuWrap) {
                // default: closed
                try { menuDd.hidden = true; } catch {}
                try { menuBtn.setAttribute("aria-expanded", "false"); } catch {}

                if (menuBtn.dataset.adExtPlanMenuWired !== "1") {
                    menuBtn.dataset.adExtPlanMenuWired = "1";
                    menuBtn.addEventListener("click", (ev) => {
                        try {
                            ev.preventDefault();
                            ev.stopPropagation();
                            const open = !menuDd.hidden;
                            menuDd.hidden = open;
                            try { menuBtn.setAttribute("aria-expanded", open ? "false" : "true"); } catch {}
                        } catch {}
                    });
                }

                if (!window.__adExtPlanMenuGlobalWired) {
                    window.__adExtPlanMenuGlobalWired = true;

                    document.addEventListener("click", (ev) => {
                        try {
                            const dd = document.querySelector("#adPlanMenuDropdown");
                            const btn = document.querySelector("#adPlanMenuBtn");
                            const wrap = document.querySelector("#adPlanMenu");
                            if (!dd || !btn || !wrap) return;
                            if (dd.hidden) return;
                            if (wrap.contains(ev.target)) return;
                            dd.hidden = true;
                            try { btn.setAttribute("aria-expanded", "false"); } catch {}
                        } catch {}
                    }, true);

                    document.addEventListener("keydown", (ev) => {
                        try {
                            if (ev.key !== "Escape") return;
                            const dd = document.querySelector("#adPlanMenuDropdown");
                            const btn = document.querySelector("#adPlanMenuBtn");
                            if (!dd || dd.hidden) return;
                            dd.hidden = true;
                            try { btn?.setAttribute("aria-expanded", "false"); } catch {}
                        } catch {}
                    }, true);
                }
            }
        } catch {}
        // Persisted view: DATA | PLAN | SEGFOCUS | ATCFOCUS | CHROMO
        try {
            const raw = String(localStorage.getItem(AD_EXT_TRAIN_VIEW_LS_KEY) || trainView || "DATA").toUpperCase();
            trainView = (raw === "PLAN") ? "PLAN"
            : (raw === "SEGFOCUS" || raw === "SEGFOKUS" || raw === "SEGMENT_FOCUS") ? "SEGFOCUS"
            : (raw === "ATCFOCUS" || raw === "ATCFOKUS" || raw === "ATC_FOCUS") ? "ATCFOCUS"
            : (raw === "CHROMO" || raw === "CHROMOTRACKER" || raw === "CHROMO_TRACKER") ? "CHROMO"
            : "DATA";
        } catch {
            trainView = trainView || "DATA";
        }

        const tabs = panel.querySelector("#ad-ext-train-view");
        const layout = panel.querySelector(".ad-train-layout");
        const side = panel.querySelector(".ad-train-side");
        const main = panel.querySelector(".ad-train-main");
        const segfocus = panel.querySelector("#ad-ext-train-segfokus");
        const trainViewRoot = panel.querySelector("#ad-ext-view-training");

        if (!tabs || !layout || !side || !main) return;

        // Week selector is only relevant for Trainingsdaten + Trainingsplan.
        // It is mounted into the active subview (DATA: above KPIs, PLAN: above Plan) and hidden otherwise. (0.14.161)
        const syncTrainWeekSelect = (forceView = null) => {
            try {
                const wrap = panel.querySelector("#ad-ext-plan-week-wrap");
                if (!wrap) return;

                const tv = String((forceView || layout?.dataset?.trainView || trainView || "DATA") || "DATA").toUpperCase();
                const hostTop = panel.querySelector("#ad-train-week-host-top");

                if (tv === "DATA" || tv === "PLAN") {
                    if (hostTop && wrap.parentElement !== hostTop) hostTop.appendChild(wrap);
                    try { wrap.style.display = ""; } catch {}
                } else {
                    try { wrap.style.display = "none"; } catch {}
                }
            } catch {}
        };


        // Insights warmup (v0.14.107): KPIs vorberechnen ohne View-Wechsel
        let _insightsWarmupT = null;
        const warmupInsights = () => {
            try { if (_insightsWarmupT) clearTimeout(_insightsWarmupT); } catch {}
            _insightsWarmupT = setTimeout(() => {
                try {
                    if (!panel || !panel.isConnected) return;
                    if (!cache?.loaded) return;
                    renderInsights(panel);
                } catch {}
            }, 0);
        };

        const ensureSegFocusMounted = () => {
            try {
                const wrap = segfocus || panel.querySelector("#ad-ext-train-segfokus");
                const segPanel = panel.querySelector("#ad-ext-view-segment");
                if (!wrap || !segPanel) return;
                if (segPanel.parentElement !== wrap) wrap.appendChild(segPanel);
                try { segPanel.style.display = ""; } catch {}
            } catch {}
        };

        function renderTrainAtcFocus(panel) {
          const wrap = panel.querySelector("#ad-ext-train-atcfokus");
          if (!wrap) return;

          cache.filtersATC = cache.filtersATC || {};
          if (!cache.filtersATC.mode) cache.filtersATC.mode = "FULL";
          if (!cache.filtersATC.dateRange) cache.filtersATC.dateRange = "Y1";
          if (!cache.filtersATC.fieldSortKey) cache.filtersATC.fieldSortKey = localStorage.getItem("ad_ext_atc_fieldSortKey") || "hitPct";
          if (!cache.filtersATC.fieldSortDir) cache.filtersATC.fieldSortDir = localStorage.getItem("ad_ext_atc_fieldSortDir") || "desc";
          if (!Object.prototype.hasOwnProperty.call(cache.filtersATC, "selectedDayKey")) cache.filtersATC.selectedDayKey = null;
          if (!Object.prototype.hasOwnProperty.call(cache.filtersATC, "selectedField")) cache.filtersATC.selectedField = null;

          const f = cache.filtersATC;

          if (wrap.dataset.filled !== "1") {
            wrap.dataset.filled = "1";

                        wrap.innerHTML = `
              <div class="ad-ext-section-title">ATC-Fokus</div>

              <div class="ad-ext-filters">
                <div class="ad-ext-filter-block">
                  <div class="ad-ext-filter-label">Modus</div>
                  <div class="ad-ext-filter-row">
                    <div class="ad-ext-filter-name">Modus</div>
                    <div class="ad-ext-select-wrap">
                      <select id="ad-ext-atc-filter-mode" class="ad-ext-select">
                        <option value="FULL">Full</option>
                        <option value="OUTER_SINGLE">Outer Single</option>
                        <option value="SINGLE">Single</option>
                        <option value="DOUBLE">Double</option>
                        <option value="TRIPLE">Triple</option>
                      </select>
                    </div>
                  </div>
                </div>

                <div class="ad-ext-filter-block">
                  <div class="ad-ext-filter-label">Datumsfilter</div>
                  <div class="ad-ext-filter-row">
                    <div class="ad-ext-filter-name">Zeit</div>
                    <div class="ad-ext-select-wrap">
                      <select id="ad-ext-atc-filter-daterange" class="ad-ext-select">
                        <option value="TODAY">Heute (—)</option>
                        <option value="YESTERDAY">Gestern (—)</option>
                        <option value="DAY_BEFORE">Vorgestern (—)</option>
                        <option value="D7">Letzten 7 Tage</option>
                        <option value="D14">Letzten 14 Tage</option>
                        <option value="D30">Letzten 30 Tage</option>
                        <option value="M3">Letzten 3 Monate</option>
                        <option value="M6">Letzten 6 Monate</option>
                        <option value="Y1" selected>Letztes Jahr</option>
                        <option value="ALL">Gesamt</option>
                      </select>
                    </div>
                  </div>
                </div>
              </div>

              <div class="ad-ext-kpi-grid">
                <div class="ad-ext-kpi-tile">
                  <div class="ad-ext-kpi-title">Legs</div>
                  <div class="ad-ext-kpi-value" id="ad-ext-atc-kpi-sessions">—</div>
                </div>
                <div class="ad-ext-kpi-tile">
                  <div class="ad-ext-kpi-title">GESPIELTE ZEIT</div>
                  <div class="ad-ext-kpi-value" id="ad-ext-atc-kpi-time">—</div>
                  <div class="ad-ext-kpi-sub" id="ad-ext-atc-kpi-time-sub">—</div>
                </div>
                <div class="ad-ext-kpi-tile">
                  <div class="ad-ext-kpi-title">Ø Darts / Leg</div>
                  <div class="ad-ext-kpi-value" id="ad-ext-atc-kpi-points">—</div>
                </div>
                <div class="ad-ext-kpi-tile">
                  <div class="ad-ext-kpi-title">Ø Hit %</div>
                  <div class="ad-ext-kpi-value" id="ad-ext-atc-kpi-hitrate">—</div>
                </div>
              </div>

              <div class="ad-ext-grid-seg">
                <div class="ad-ext-card ad-ext-card-seg-hits">
                  <div class="ad-ext-chart-title">Performance (Hit %)</div>
                  <canvas id="ad-ext-atc-chart-radar" class="ad-ext-chart-canvas" width="900" height="420"></canvas>
                </div>

                <div class="ad-ext-card ad-ext-card-seg-donut">
                  <div class="ad-ext-chart-title">Around the Clock (ATC) Fortschritt</div>
                  <canvas id="ad-ext-atc-chart-weektrend" class="ad-ext-chart-canvas" width="520" height="220"></canvas>
                </div>

                <div class="ad-ext-card ad-ext-card-seg-radar">
                  <div class="ad-ext-chart-title">Treffer je Target (Hits)</div>
                  <canvas id="ad-ext-atc-chart-bar" class="ad-ext-chart-canvas" width="520" height="220"></canvas>
                </div>
              </div>

              <div class="ad-ext-grid-2">
                <div>
                  <div class="ad-ext-section-title">LEGS (TAGESBASIS)</div>
                  <div class="ad-ext-card" style="padding:0;">
                    <table class="ad-ext-table">
                      <thead>
                        <tr>
                          <th>Datum</th>
                          <th class="ad-ext-table-value-right">Legs</th>
                          <th class="ad-ext-table-value-right">Darts</th>
                          <th class="ad-ext-table-value-right">Hits</th>
                          <th class="ad-ext-table-value-right">Hit %</th>
                        </tr>
                      </thead>
                      <tbody id="ad-ext-atc-table-day">
                        <tr><td colspan="5" style="opacity:.7; padding:10px 12px;">—</td></tr>
                      </tbody>
                    </table>
                  </div>
                </div>

                <div>
                  <div class="ad-ext-section-title">FELDER (AGGREGIERT)</div>
                  <div class="ad-ext-card" style="padding:0;">
                    <table class="ad-ext-table">
                      <thead>
                        <tr>
                          <th class="ad-ext-th-sortable" data-sort-key="field" title="Feld (1..20, BULL)">Feld</th>
                          <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="legs" title="Anzahl Legs">Legs</th>
                          <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="darts" title="Geworfene Darts">Darts</th>
                          <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="hits" title="Treffer (Hits)">Hits</th>
                          <th class="ad-ext-table-value-right ad-ext-th-sortable" data-sort-key="hitPct" title="Trefferquote (Hits/Darts)">Hit %</th>
                        </tr>
                      </thead>
                      <tbody id="ad-ext-atc-table-target">
                        <tr><td colspan="5" style="opacity:.7; padding:10px 12px;">—</td></tr>
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            `;
            try {
              const cBar = wrap.querySelector("#ad-ext-atc-chart-bar");
              const cRadar = wrap.querySelector("#ad-ext-atc-chart-radar");
              const cTrend = wrap.querySelector("#ad-ext-atc-chart-weektrend");
              if (cBar) drawEmpty(cBar, "—");
              if (cRadar) drawEmpty(cRadar, "—");
              if (cTrend) drawEmpty(cTrend, "—");
            } catch {}
          }

          const selMode = wrap.querySelector("#ad-ext-atc-filter-mode");
          const selRange = wrap.querySelector("#ad-ext-atc-filter-daterange");
          let atcUpdateSeq = 0;

          async function updateAtcFocus() {
            const seq = ++atcUpdateSeq;
            try {
              const f2 = cache.filtersATC || {};
              const all = Array.isArray(cache.otherTrainingSessions) ? cache.otherTrainingSessions : [];
              let atc = all.filter((s) => String(s?.activityKey || "").toUpperCase() === "ATC");

              // normalize to avoid NaN in aggregateByDay (points may be missing)
              atc = atc.map((s) => {
                const darts = Number(s?.darts) || 0;
                const hits = Number(s?.hits) || 0;
                let points = Number(s?.points);
                if (!Number.isFinite(points)) points = darts || 0;
                const dayKey = s?.dayKey || parseIsoDateToDayKey(s?.createdAt) || "unknown";
                const mode = s?.mode || "FULL";
                const legs = Number(s?.legs ?? s?.count ?? 1);
                return { ...s, darts, hits, points, dayKey, mode, legs: (Number.isFinite(legs) && legs > 0) ? legs : 1 };
              });

              // base filter (dropdowns)
              let baseFiltered = atc;
              const range = String(f2.dateRange || "ALL").toUpperCase();
              if (range === "TODAY" || range === "YESTERDAY" || range === "DAY_BEFORE") {
                const daysAgo = (range === "TODAY") ? 0 : (range === "YESTERDAY") ? 1 : 2;
                const dk = relativeDayKey(daysAgo);
                baseFiltered = baseFiltered.filter((s) => String(s?.dayKey || "") === String(dk || ""));
              } else {
                baseFiltered = filterByDateRange(baseFiltered, f2.dateRange, (s) => s.createdAt);
              }

              const canonMode = (v) => String(v || "").trim().toUpperCase().replace(/[\s-]+/g, "_");
              const wantedMode = canonMode(f2.mode || "FULL");
              baseFiltered = baseFiltered.filter((s) => canonMode(s?.mode || "FULL") === wantedMode);

              // Selection state (like Segment-Fokus)
              const normFieldKey = (v) => {
                const s = String(v || "").trim().toUpperCase();
                if (!s) return null;
                if (s.includes("BULL") || s === "25" || s === "50") return "BULL";
                const m = s.match(/(\d{1,2})/);
                if (m) {
                  const n = parseInt(m[1], 10);
                  if (Number.isFinite(n) && n >= 1 && n <= 20) return String(n);
                }
                return s;
              };

              let selectedDayKey = f2.selectedDayKey ? String(f2.selectedDayKey) : null;
              let selectedField = normFieldKey(f2.selectedField);

              // 2) sanitize selection (if selected day not present anymore -> clear)
              const dayAggAll = aggregateAtcByDayLegs(baseFiltered);
              if (selectedDayKey && !dayAggAll.some((d) => String(d?.dayKey || "") === String(selectedDayKey))) {
                selectedDayKey = null;
                f2.selectedDayKey = null;
              }

              // Build matchId sets from sessions (for IDB restriction)
              const baseMatchIds = new Set(
                baseFiltered.map((s) => String(s?.matchId || "")).filter((id) => id)
              );

              // 4) cross-filtering like Segment-Fokus:
              //    - Fields chart/table can be narrowed by selected day
              //    - Day table can be narrowed by selected field
              const sessionsForFields = selectedDayKey
                ? baseFiltered.filter((s) => String(s?.dayKey || "") === String(selectedDayKey))
                : baseFiltered;

              const allowedMatchIdsFields = new Set(
                sessionsForFields.map((s) => String(s?.matchId || "")).filter((id) => id)
              );

              // Field aggregation for "FELDER (AGGREGIERT)" (facet by day)
              const outFieldSetFacet = new Set();
              const idbOptsFields = {};
              if (allowedMatchIdsFields.size) idbOptsFields.allowedMatchIds = allowedMatchIdsFields;
              if (selectedDayKey) idbOptsFields.dayKey = selectedDayKey;
              if (selectedField) {
                idbOptsFields.wantFieldKey = selectedField;
                idbOptsFields.outFieldSet = outFieldSetFacet;
              }

              const fieldAggFacet = await loadAtcFieldAggFromIdb(f2.dateRange, f2.mode, idbOptsFields);
              if (seq !== atcUpdateSeq) return;

              // MatchIds for selectedField across ALL base sessions (needed to filter day-table like Segment-Fokus)
              let matchIdsForSelectedFieldAll = null;
              let matchIdsForSelectedFieldInDay = null;

              if (selectedField) {
                matchIdsForSelectedFieldInDay = outFieldSetFacet;

                if (selectedDayKey) {
                  const outAll = new Set();
                  const idbOptsFieldAll = {};
                  if (baseMatchIds.size) idbOptsFieldAll.allowedMatchIds = baseMatchIds;
                  idbOptsFieldAll.wantFieldKey = selectedField;
                  idbOptsFieldAll.outFieldSet = outAll;
                  idbOptsFieldAll.onlyCollectFieldSet = true;
                  await loadAtcFieldAggFromIdb(f2.dateRange, f2.mode, idbOptsFieldAll);
                  if (seq !== atcUpdateSeq) return;
                  matchIdsForSelectedFieldAll = outAll;
                } else {
                  matchIdsForSelectedFieldAll = matchIdsForSelectedFieldInDay;
                }

                // sanitize selectedField against baseFiltered (like Segment-Fokus sanitize against targetAggAll)
                if (!matchIdsForSelectedFieldAll || matchIdsForSelectedFieldAll.size === 0) {
                  selectedField = null;
                  f2.selectedField = null;
                  matchIdsForSelectedFieldAll = null;
                  matchIdsForSelectedFieldInDay = null;
                }
              }

              // Day facet table sessions (narrowed by selectedField; NOT narrowed by selectedDayKey)
              let sessionsForDays = baseFiltered;
              if (selectedField && matchIdsForSelectedFieldAll && matchIdsForSelectedFieldAll.size) {
                sessionsForDays = sessionsForDays.filter((s) => matchIdsForSelectedFieldAll.has(String(s?.matchId || "")));
              }
              const dayAggFacet = aggregateAtcByDayLegs(sessionsForDays);

              // KPI sessions (narrowed by BOTH selections)
              let focusSessions = baseFiltered;
              if (selectedDayKey) {
                focusSessions = focusSessions.filter((s) => String(s?.dayKey || "") === String(selectedDayKey));
              }
              if (selectedField) {
                const setToUse = selectedDayKey ? matchIdsForSelectedFieldInDay : matchIdsForSelectedFieldAll;
                if (setToUse && setToUse.size) {
                  focusSessions = focusSessions.filter((s) => setToUse.has(String(s?.matchId || "")));
                } else {
                  focusSessions = [];
                }
              }

              // KPIs (analog Segment-Fokus)
              try {
                const totalLegs = focusSessions.reduce((a, s) => a + (Number(s?.legs ?? s?.count ?? 1) || 1), 0);
                const totalSessions = focusSessions.length;
                const totalDarts = focusSessions.reduce((a, s) => a + (s.darts || 0), 0);
                const totalHits = focusSessions.reduce((a, s) => a + (s.hits || 0), 0);

                const totalDurationSec = focusSessions.reduce((a, s) => a + (Number(s.durationSec) || 0), 0);
                const dayKeysSet = new Set(
                  focusSessions
                    .map((s) => (s.dayKey || parseIsoDateToDayKey(s.createdAt) || "unknown"))
                    .filter((k) => k && k !== "unknown")
                );
                const daysCount = dayKeysSet.size;

                setText(panel, "#ad-ext-atc-kpi-sessions", fmtInt(totalLegs));
                setText(panel, "#ad-ext-atc-kpi-time", totalDurationSec > 0 ? fmtHours(totalDurationSec) : "—");
                if (totalDurationSec > 0 && daysCount > 0) {
                  setText(panel, "#ad-ext-atc-kpi-time-sub", `Ø ${fmtMinPerLeg(totalDurationSec / daysCount)} pro Tag`);
                } else {
                  setText(panel, "#ad-ext-atc-kpi-time-sub", "—");
                }

                const avgDartsPerSession = totalLegs > 0 ? (totalDarts / totalLegs) : NaN;
                setText(panel, "#ad-ext-atc-kpi-points", Number.isFinite(avgDartsPerSession) ? fmtDec(avgDartsPerSession, 1).replace(/\.0$/, "") : "—");
                setText(panel, "#ad-ext-atc-kpi-hitrate", fmtPct(totalHits, totalDarts));
              } catch {}

              if (DEBUG_ATC_FIELDS && seq === atcUpdateSeq) {
                try {
                  console.debug("[AD Ext][ATC] base sessions =", baseFiltered.length);
                  console.debug("[AD Ext][ATC] focus sessions =", focusSessions.length, { selectedDayKey, selectedField });
                } catch {}
              }

              // Render tables (single pass after async work -> prevents scroll-jank like Segment-Fokus)
              renderAtcTableDay(panel, dayAggFacet, 10, selectedDayKey);

              // Charts should reflect focusSessions (not just day facet).
              // If no field selection is active, focusSessions == sessionsForFields (day-filter only) => reuse facet aggregation.
              let fieldAggForCharts = fieldAggFacet;
              if (selectedField) {
                const allowedMatchIdsFocus = new Set(
                  focusSessions.map((s) => String(s?.matchId || "")).filter((id) => id)
                );
                const idbOptsFocus = {};
                if (allowedMatchIdsFocus.size) idbOptsFocus.allowedMatchIds = allowedMatchIdsFocus;
                if (selectedDayKey) idbOptsFocus.dayKey = selectedDayKey;

                fieldAggForCharts = await loadAtcFieldAggFromIdb(f2.dateRange, f2.mode, idbOptsFocus);
                if (seq !== atcUpdateSeq) return;
              }

              // Charts (Radar)
              try {
                const radarCanvas = wrap.querySelector("#ad-ext-atc-chart-radar");
                if (radarCanvas) {
                  const rows = Array.isArray(fieldAggForCharts) ? fieldAggForCharts : [];
                  const rowMap = new Map();
                  for (const r of rows) {
                    if (!r || typeof r !== "object") continue;
                    const k0 = String(r.field || "").trim();
                    if (!k0) continue;
                    const k = (String(k0).toUpperCase() === "BULL") ? "BULL" : k0;
                    rowMap.set(k, r);
                  }

                  // Order radar axes like a real dartboard (clockwise, 20 at top)
                  const DARTBOARD_ORDER = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];

                  const labels = [];
                  const values = [];
                  const dataList = [];

                  for (const n of DARTBOARD_ORDER) {
                    const key = String(n);
                    const r = rowMap.get(key) || null;
                    const hits = Number(r?.hits || 0);
                    const darts = Number(r?.darts || 0);
                    const hitPct = darts > 0 ? (hits * 100) / darts : 0;
                    labels.push(key);
                    values.push(hitPct);
                    dataList.push(r || { field: key, sessions: 0, darts: 0, hits: 0 });
                  }

                  // optional: BULL at end if present
                  if (rowMap.has("BULL")) {
                    const r = rowMap.get("BULL");
                    const hits = Number(r?.hits || 0);
                    const darts = Number(r?.darts || 0);
                    const hitPct = darts > 0 ? (hits * 100) / darts : 0;
                    labels.push("BULL");
                    values.push(hitPct);
                    dataList.push(r || { field: "BULL", sessions: 0, darts: 0, hits: 0 });
                  }

                  // highlight selection (if selectedField matches)
                  let hi = null;
                  if (selectedField) {
                    const sf = selectedField;
                    hi = labels.findIndex((l) => normFieldKey(l) === normFieldKey(sf));
                    if (hi < 0) hi = null;
                  }

                  const layout = drawRadar(radarCanvas, labels, values, { highlightIndex: hi, autoScale: true, valueIsPercent: true, maxValue: 100 });
                  layout.dataList = dataList;

                  cache._atc_layouts = cache._atc_layouts || {};
                  cache._atc_layouts.radar = layout;
                }
              } catch {}

              // Fields table (facet by day)
              renderAtcTableFields(panel, fieldAggFacet);
              applySelectedRowHighlightAtc(panel);

              // Weekly trend: moved from Erkenntnisse -> ATC-Fokus (replaces "Treffer % pro Feld")
              try {
                const cTrend = wrap.querySelector("#ad-ext-atc-chart-weektrend");
                if (cTrend) {
                  let weeksAsc = [];
                  try {
                    const cached = cache._training_weeksAsc;
                    const computed = computeTrainingWeeksAsc();
                    weeksAsc = Array.isArray(cached) ? cached : (Array.isArray(computed) ? computed : []);
                  } catch { weeksAsc = []; }

                  const thisMonday = startOfWeekMonday(new Date());
                  const thisWeekKey = thisMonday ? dayKeyFromLocalDate(thisMonday) : "";
                  try {
                    if (thisWeekKey) {
                      weeksAsc = (weeksAsc || []).filter((w) => String(w?.weekKey || w || "") <= String(thisWeekKey));
                    }
                  } catch {}

                  drawAtcWeeklyTrend(cTrend, weeksAsc, thisWeekKey);
                }
              } catch {}
            } catch (e) {
              console.error("[AD Ext][ATC] updateAtcFocus failed", e);
              try { renderAtcTableDay(panel, [], 10, null); } catch {}
              try { renderAtcTableFields(panel, []); } catch {}
              try { applySelectedRowHighlightAtc(panel); } catch {}
            }
          }

          // UI sync
          const curMode = String(f.mode || "FULL").toUpperCase();
          if (selMode && selMode.value !== curMode) selMode.value = curMode;

          if (selRange && selRange.value !== String(f.dateRange || "Y1")) selRange.value = String(f.dateRange || "Y1");
          try { updateRelativeDayOptions(selRange); } catch {}

          try { updateAtcFocus(); } catch {}

          if (wrap.dataset.wired === "1") return;
          wrap.dataset.wired = "1";
          if (selMode) {
            selMode.addEventListener("change", () => {
              try {
                const next = String(selMode.value || "FULL").toUpperCase();
                cache.filtersATC.mode = next || "FULL";
                if (selMode.value !== String(cache.filtersATC.mode || "FULL")) selMode.value = String(cache.filtersATC.mode || "FULL");
                try { updateAtcFocus(); } catch {}
              } catch {}
            });
          }

          if (selRange) {
            selRange.addEventListener("change", () => {
              try {
                cache.filtersATC.dateRange = String(selRange.value || "Y1");
                updateRelativeDayOptions(selRange);
                try { updateAtcFocus(); } catch {}
              } catch {}
            });
          }

          // Sorting: Felder (Aggregiert)
          try {
            const bodyFields = wrap.querySelector("#ad-ext-atc-table-target");
            const tblFields = bodyFields?.closest?.("table");
            const headFields = tblFields?.querySelector?.("thead");
            if (headFields) {
              headFields.addEventListener("click", (ev) => {
                const th = ev?.target?.closest ? ev.target.closest("th[data-sort-key]") : null;
                if (!th || !headFields.contains(th)) return;

                ev.preventDefault();
                ev.stopPropagation();

                const key = String(th.getAttribute("data-sort-key") || "hitPct");
                const curKey = String(cache?.filtersATC?.fieldSortKey || "hitPct");
                const curDir = (String(cache?.filtersATC?.fieldSortDir || "desc").toLowerCase() === "asc") ? "asc" : "desc";

                let nextDir = curDir;
                if (key === curKey) nextDir = (curDir === "asc") ? "desc" : "asc";
                else nextDir = (key === "field") ? "asc" : "desc";

                cache.filtersATC.fieldSortKey = key;
                cache.filtersATC.fieldSortDir = nextDir;

                try { localStorage.setItem("ad_ext_atc_fieldSortKey", key); } catch {}
                try { localStorage.setItem("ad_ext_atc_fieldSortDir", nextDir); } catch {}

                try { updateAtcFocus(); } catch {}
              });
            }


          // --- ATC Crossfilter: Day / Field selection (wie Segment-Fokus) ---
          try {
            const tbodyDay = wrap.querySelector("#ad-ext-atc-table-day");
            if (tbodyDay && tbodyDay.dataset.adExtAtcDayWired !== "1") {
              tbodyDay.dataset.adExtAtcDayWired = "1";
              tbodyDay.addEventListener("click", (ev) => {
                const tr = ev?.target?.closest ? ev.target.closest("tr[data-day-key]") : null;
                if (!tr || !tbodyDay.contains(tr)) return;

                ev.preventDefault();
                ev.stopPropagation();

                const dk = tr.getAttribute("data-day-key");
                const cur = cache?.filtersATC?.selectedDayKey || null;
                cache.filtersATC.selectedDayKey = (cur && dk && String(cur) === String(dk)) ? null : (dk || null);

                try { updateAtcFocus(); } catch {}
              });
            }

            const tbodyField = wrap.querySelector("#ad-ext-atc-table-target");
            if (tbodyField && tbodyField.dataset.adExtAtcFieldWired !== "1") {
              tbodyField.dataset.adExtAtcFieldWired = "1";
              tbodyField.addEventListener("click", (ev) => {
                const tr = ev?.target?.closest ? ev.target.closest("tr[data-field]") : null;
                if (!tr || !tbodyField.contains(tr)) return;

                ev.preventDefault();
                ev.stopPropagation();

                const f = tr.getAttribute("data-field");
                const cur = cache?.filtersATC?.selectedField || null;
                cache.filtersATC.selectedField = (cur && f && String(cur) === String(f)) ? null : (f || null);

                try { updateAtcFocus(); } catch {}
              });
            }
          } catch {}

          // --- ATC Radar Hover (Performance Hit %) ---
          try {
            const cRadar = wrap.querySelector("#ad-ext-atc-chart-radar");
            if (cRadar && cRadar.dataset.adExtAtcRadarWired !== "1") {
              cRadar.dataset.adExtAtcRadarWired = "1";

              const redrawRadar = (highlightIndex) => {
                try {
                  const base = cache._atc_layouts?.radar;
                  if (!base || base.type !== "radar") return;
                  const next = drawRadar(cRadar, base.labels, base.values, { highlightIndex, autoScale: true });
                  next.dataList = base.dataList || [];
                  cache._atc_layouts = cache._atc_layouts || {};
                  cache._atc_layouts.radar = next;
                } catch {}
              };

              cRadar.addEventListener("mousemove", (ev) => {
                const layout = cache._atc_layouts?.radar;
                if (!layout || layout.type !== "radar") { tooltipHide(); return; }

                const pt = canvasPoint(ev, cRadar);
                const idx = hitTestRadar(layout, pt);

                if (idx === null || idx === undefined) {
                  if (cache._atc_radar_hoverIndex !== null) {
                    cache._atc_radar_hoverIndex = null;
                    redrawRadar(null);
                  }
                  tooltipHide();
                  return;
                }

                if (cache._atc_radar_hoverIndex !== idx) {
                  cache._atc_radar_hoverIndex = idx;
                  redrawRadar(idx);
                }

                const row = layout.dataList?.[idx] || {};
                const label = row?.field || layout.labels?.[idx] || "";
                const hits = Number(row?.hits ?? 0);
                const darts = Number(row?.darts ?? 0);
                const legs = Number(row?.legs ?? row?.sessions ?? 0);
                const hitPct = darts > 0 ? (hits * 100) / darts : Number(layout.values?.[idx] ?? 0);

                const line = `<div class="ad-ext-tooltip-title">${escapeHtml(label)}</div>
<div class="ad-ext-tooltip-kv"><div style="opacity:.78;">Legs</div><div style="font-weight:900;">${fmtInt(legs)}</div></div>
<div class="ad-ext-tooltip-kv"><div style="opacity:.78;">Hits / Darts</div><div style="font-weight:900;">${fmtInt(hits)} / ${fmtInt(darts)}</div></div>
<div class="ad-ext-tooltip-kv"><div style="opacity:.78;">Hit %</div><div style="font-weight:900;">${(Number.isFinite(hitPct) ? hitPct : 0).toFixed(2)}%</div></div>`;
                tooltipShow(ev, line);
              });

              cRadar.addEventListener("click", (ev) => {
                const layout = cache._atc_layouts?.radar;
                if (!layout || layout.type !== "radar") return;

                const pt = canvasPoint(ev, cRadar);
                const idx = hitTestRadar(layout, pt);
                if (idx === null || idx === undefined) return;

                const lbl = String(layout.labels?.[idx] || "").trim();
                if (!lbl) return;

                const canonField = (v) => {
                  const s = String(v || "").trim().toUpperCase();
                  if (!s) return null;
                  if (s === "25" || s === "50" || s.includes("BULL")) return "BULL";
                  const m = s.match(/(\d{1,2})/);
                  if (m) {
                    const n = parseInt(m[1], 10);
                    if (Number.isFinite(n) && n >= 1 && n <= 20) return String(n);
                  }
                  return s;
                };

                const cur = cache?.filtersATC?.selectedField || null;
                const same = cur && canonField(cur) && canonField(cur) === canonField(lbl);

                cache.filtersATC.selectedField = same ? null : lbl;

                try { updateAtcFocus(); } catch {}
              });

              cRadar.addEventListener("mouseleave", () => {
                tooltipHide();
                if (cache._atc_radar_hoverIndex !== null) {
                  cache._atc_radar_hoverIndex = null;
                  redrawRadar(null);
                }
              });
            }
          } catch {}
          } catch {}
        }

// Re-render helper: Trainingsdaten-Panel neu zeichnen (Plan frisch aus Storage lesen)
        const rerenderTrainingMain = () => {
            try {
                if (!cache?.loaded) return;
                const weeks = computeTrainingWeeksAsc();
                cache._training_weeksAsc = weeks;
                renderTrainingPlan(panel, weeks);
                warmupInsights();
                try { renderInsights(panel); } catch {}
            } catch {}
        };

        // Plan-Änderungen aus dem Sidebar-Storage sofort in Trainingsdaten übernehmen
        if (!panel.__adExtPlanChangedListener) {
            panel.__adExtPlanChangedListener = true;
            window.addEventListener("ad-ext-plan-changed", () => {
                try {
                    const root = trainViewRoot || panel.querySelector("#ad-ext-view-training");
                    if (!root) return;
                    const isActive = (window.getComputedStyle(root).display !== "none");
                    if (!isActive) return;
                    // Nur sofort rerendern, wenn Trainingsdaten sichtbar sind
                    if (String(layout.dataset.trainView || "").toUpperCase() === "DATA") {
                        rerenderTrainingMain();
                    }
                } catch {}
            });
        }

        function setTrainView(view) {
            const v = String(view || "").toUpperCase();
            trainView = (v === "PLAN") ? "PLAN"
            : (v === "SEGFOCUS" || v === "SEGFOKUS" || v === "SEGMENT_FOCUS") ? "SEGFOCUS"
            : (v === "ATCFOCUS" || v === "ATCFOKUS" || v === "ATC_FOCUS") ? "ATCFOCUS"
            : (v === "CHROMO" || v === "CHROMOTRACKER" || v === "CHROMO_TRACKER") ? "CHROMO"
            : "DATA";
            try { localStorage.setItem(AD_EXT_TRAIN_VIEW_LS_KEY, trainView); } catch {}

            layout.dataset.trainView = trainView;

            // Mount / hide training week selector for this subview
            try { syncTrainWeekSelect(trainView); } catch {}

            // Trainingsdaten: ChatGPT Copy Bar nur im DATA-View zeigen
            try {
                const aiBar = panel.querySelector('#ad-ext-ai-actions');
                if (aiBar) aiBar.style.display = (trainView === 'DATA') ? 'flex' : 'none';
            } catch {}

            if (trainViewRoot) { try { trainViewRoot.dataset.trainView = trainView; } catch {} }

            // Keep existing open-state flags so legacy CSS/logic doesn't break
            const openFlag = (trainView === "PLAN") ? "1" : "0";
            side.dataset.open = openFlag;
            layout.dataset.planOpen = openFlag;

            // Segmented buttons UI
            for (const b of tabs.querySelectorAll(".ad-ext-segbtn")) {
                const isOn = String(b?.dataset?.view || "").toUpperCase() === trainView;
                try { b.classList.toggle("ad-ext-segbtn--active", isOn); } catch {}
                try { b.classList.toggle("is-active", isOn); } catch {}
                try { b.setAttribute("aria-pressed", isOn ? "true" : "false"); } catch {}
            }

            // Beim Umschalten immer Trainingsdaten neu berechnen (Plan aus Storage)
            if (trainView === "DATA") {
                rerenderTrainingMain();
            } else if (trainView === "PLAN") {
                // 0.14.173: Beim Öffnen des Trainingsplan-Subtabs Sidebar + Details sofort refreshen,
                // damit die Zeitschätzung-Spalte direkt die berechneten Werte zeigt.
                try { cache._planSidebarRerender?.(); } catch {}
                // SPA-Rewire: Sidebar-Wiring kann minimal später stattfinden → next tick nochmal.
                setTimeout(() => { try { cache._planSidebarRerender?.(); } catch {} }, 0);
            } else if (trainView === "ATCFOCUS") {
                try { renderTrainAtcFocus(panel); } catch {}
            } else if (trainView === "CHROMO") {
                // Zeit-Tracker im Training-Subview „Chromo-Tracker“
                try { mountTimeIntoTrainChromo(panel); } catch {}
                try { if (cache?.loaded) renderTimeTab(panel); } catch {}
            } else if (trainView === "SEGFOCUS") {
                try { ensureSegFocusMounted(); } catch {}
                try { if (cache?.loaded) renderSegmentTraining(panel, cache.sessions, cache.filters, cache.meta); } catch {}
            }
        }

        try { cache._adExt_setTrainView = setTrainView; } catch {}



        // Event delegation


        tabs.onclick = (ev) => {
            const btn = ev?.target?.closest ? ev.target.closest(".ad-ext-segbtn") : null;
            if (!btn || !tabs.contains(btn)) return;
            ev.preventDefault();
            ev.stopPropagation();

            // No-op: Klick auf bereits aktiven Tab soll nichts neu rendern (wie Segment-Fokus)
            const nextView = String(btn?.dataset?.view || "").toUpperCase();
            const curView = String(layout?.dataset?.trainView || "").toUpperCase();
            if (nextView && curView && nextView === curView) {
                // Mouse-click: kein dauerhafter Focus-Ring
                if (ev.detail && ev.detail > 0) { try { btn.blur(); } catch {} }
                return;
            }

            setTrainView(btn.dataset.view);
            // Mouse-click: kein dauerhafter Focus-Ring
            if (ev.detail && ev.detail > 0) { try { btn.blur(); } catch {} }
        };
        // Initial sync (wichtig nach SPA-Re-render)
        setTrainView(trainView);
    }



    function wireTrainingPlanSidebarControls(panel) {
        if (!panel) return;

        const side = panel.querySelector(".ad-train-side");
        if (!side) return;

        const activeWeekInfo = side.querySelector("#adPlanActiveWeekInfo");
        const btnTime = side.querySelector("#adPlanModeTime");
        const btnSessions = side.querySelector("#adPlanModeSessions");
        const chk = side.querySelector("#adPlanShowPerf");
        const btnAdd = side.querySelector("#adPlanAddActivityBtn");
        const btnCopyPrevWeek = side.querySelector("#adPlanCopyPrevWeekBtn");

        const btnResetWeek = side.querySelector("#adPlanResetWeekBtn");


        const btnSavePlan = side.querySelector("#adPlanSavePlanBtn");
        const btnLoadPlan = side.querySelector("#adPlanLoadPlanBtn");
        const statusEl = side.querySelector("#adPlanStatus");
        const sumTarget = side.querySelector("#adPlanSumTarget");
        const sumActual = side.querySelector("#adPlanSumActual");
        const sumProgress = side.querySelector("#adPlanSumProgress");

        const table = side.querySelector("#adPlanTable");

        // Drawer
        const drawer = panel.querySelector("#adPlanDrawer");
        const overlay = panel.querySelector("#adPlanDrawerOverlay");
        const drawerClose = panel.querySelector("#adPlanDrawerClose");
        const drawerSearch = panel.querySelector("#adPlanDrawerSearch");
        const drawerList = panel.querySelector("#adPlanDrawerList");

        if (!statusEl || !sumTarget || !table) return;

        // Step 2: Bemerkungen (Platzhalter, Schritt 1) + Detailbereich unterhalb der Liste (Plan-Items)
        let notes = side.querySelector("#adPlanNotes");
        if (!notes) {
            notes = document.createElement("div");
            notes.id = "adPlanNotes";
            notes.className = "ad-plan-notes";
            notes.innerHTML = `
              <div class="ad-plan-details-card ad-plan-notes-card">
                <div class="ad-plan-details-head ad-plan-notes-head">
                  <div class="ad-plan-notes-head-left">
                    <div class="ad-plan-details-title">Bemerkungen</div>
                    <div class="ad-plan-notes-saved" id="adPlanNotesSaved" aria-live="polite">Keine Änderungen vorhanden</div>
                  </div>
                  <div class="ad-plan-notes-head-right">
                    <button class="ad-ext-btn ad-ext-btn--secondary ad-plan-notes-clear" id="adPlanNotesClearBtn" type="button" title="Notizen leeren">🧹 Notizen leeren</button>
                  </div>
                </div>
                <div class="ad-plan-notes-editor" id="adPlanNotesEditor" contenteditable="true"></div>
              </div>
            `;
            table.insertAdjacentElement("afterend", notes);
        }

        // Bemerkungen: Speichern/Laden pro Woche (Richtext)
        const notesEditor = side.querySelector("#adPlanNotesEditor");
        if (notesEditor && notesEditor.dataset.adExtWired !== "1") {
            notesEditor.dataset.adExtWired = "1";

            const notesSavedEl = side.querySelector("#adPlanNotesSaved");
            const btnClearNotes = side.querySelector("#adPlanNotesClearBtn");

            const pad2 = (n) => String(n).padStart(2, "0");
            const fmtSavedTime = (ts) => {
                try {
                    const d = new Date(ts);
                    return `${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
                } catch (e) { return ""; }
            };

            const setNotesHint = (kind, ts) => {
                if (!notesSavedEl) return;
                notesSavedEl.classList.toggle("is-dirty", kind === "dirty");
                if (kind === "dirty") {
                    notesSavedEl.textContent = "Wird gespeichert…";
                } else if (kind === "saved") {
                    const t = fmtSavedTime(ts || Date.now());
                    notesSavedEl.textContent = `Letzte Änderung gespeichert: ${t}`;
                } else {
                    notesSavedEl.textContent = "Keine Änderungen vorhanden";
                }
            };

            setNotesHint("idle");

            // global: Save-Events -> update hint for active week
            if (!window.__adExtPlanSavedListenerInstalled) {
                window.__adExtPlanSavedListenerInstalled = true;
                window.addEventListener("ad-ext-plan-saved", (ev) => {
                    try {
                        const d = ev && ev.detail ? ev.detail : {};
                        const weekId = String(d.weekId || "").trim();
                        if (!weekId) return;
                        if (String(_adPlanActiveWeekId || "") !== weekId) return;

                        const el = document.querySelector("#adPlanNotesSaved");
                        if (!el) return;

                        const ts = Number(d.ts) || Date.now();
                        const t = (() => {
                            try {
                                const dd = new Date(ts);
                                return `${String(dd.getHours()).padStart(2, "0")}:${String(dd.getMinutes()).padStart(2, "0")}`;
                            } catch (e) { return ""; }
                        })();

                        el.classList.remove("is-dirty");
                        el.textContent = t ? `Letzte Änderung gespeichert: ${t}` : "Letzte Änderung gespeichert";
                    } catch (e) {}
                });
            }

            // Clear button
            if (btnClearNotes && btnClearNotes.dataset.adExtWired !== "1") {
                btnClearNotes.dataset.adExtWired = "1";
                btnClearNotes.addEventListener("click", () => {
                    try {
                        const cur = String(notesEditor.innerHTML || "");
                        const empty = isNotesHtmlEmpty(cur);
                        if (empty) return;

                        if (!confirm("Notizen wirklich leeren?")) return;

                        notesEditor.innerHTML = "";
                        planNotesHtml = "";
                        setNotesHint("dirty");
                        scheduleSaveCurrentWeekPlan();
                        flushSaveCurrentWeekPlan();
                        try { syncCopyPrevWeekButton(); } catch {}
                        try { syncResetWeekButton(); } catch {}
                        try { notesEditor.focus(); } catch {}
                    } catch (e) {}
                });
            }

            const captureNotes = () => {
                try { planNotesHtml = String(notesEditor.innerHTML || ""); } catch { planNotesHtml = ""; }
            };

            // Input: sofort merken + debounce-save
            notesEditor.addEventListener("input", () => {
                captureNotes();
                try { setNotesHint("dirty"); } catch {}
                scheduleSaveCurrentWeekPlan();
                try { syncCopyPrevWeekButton(); } catch {}
                try { syncResetWeekButton(); } catch {}
            });

            // Blur: sanitizen/normalisieren (ohne den Cursor waehrend des Tippens zu zerstoeren)
            notesEditor.addEventListener("blur", () => {
                try {
                    const safe = normalizeNotesHtml(notesEditor.innerHTML);
                    if (safe !== String(notesEditor.innerHTML || "")) {
                        notesEditor.innerHTML = safe;
                    }
                    planNotesHtml = safe;
                    try { setNotesHint("dirty"); } catch {}
                    scheduleSaveCurrentWeekPlan();
                    try { syncCopyPrevWeekButton(); } catch {}
                    try { syncResetWeekButton(); } catch {}
                } catch {}
            });
        }

        // Step 2: Detailbereich unterhalb der Liste (Plan-Items)

        let details = side.querySelector("#adPlanDetails");
        if (!details) {
            details = document.createElement("div");
            details.id = "adPlanDetails";
            details.className = "ad-plan-details";
            const anchor = side.querySelector("#adPlanNotes") || table;
            anchor.insertAdjacentElement("afterend", details);
        }

        // Step 2: Segment-Targets UI state (RAM)
        let targetAddOpen = false;
        let targetAddValue = "";
        let targetAddError = "";

        const ALL_DART_TARGETS = (() => {
            const out = ["SB", "DB"];
            for (let i = 1; i <= 20; i++) out.push(`S${i}`);
            for (let i = 1; i <= 20; i++) out.push(`D${i}`);
            for (let i = 1; i <= 20; i++) out.push(`T${i}`);
            return out;
        })();

        function getTypeLabel(type) {
            const t = String(type || "");
            const tpl = PLAN_ACTIVITY_TEMPLATES.find(x => String(x?.type || "") === t);
            if (tpl && tpl.name) return String(tpl.name);
            return t || "—";
        }

        function cssEscapeAttrValue(v) {
            const s = String(v || "");
            if (window.CSS && CSS.escape) return CSS.escape(s);
            // minimal fallback
            return s.replace(/["\\]/g, "\\$&");
        }

        function getPlanItemById(id) {
            const s = String(id || "");
            return (Array.isArray(planItems) ? planItems : []).find(x => String(x?.id || "") === s) || null;
        }

        function updatePlanItemById(id, updater) {
            const s = String(id || "");
            const idx = (Array.isArray(planItems) ? planItems : []).findIndex(x => String(x?.id || "") === s);
            if (idx < 0) return null;

            const next = typeof updater === "function" ? updater(planItems[idx]) : updater;
            planItems = planItems.slice();
            planItems[idx] = next;
            scheduleSaveCurrentWeekPlan();
            return next;
        }

        function normalizeTarget(raw) {
            return String(raw || "").trim().toUpperCase().replace(/\s+/g, "");
        }

        function validateTarget(raw, existing) {
            const t = normalizeTarget(raw);
            if (!t) return { ok: false, error: "Bitte ein Target eingeben." };

            if (t === "SB" || t === "DB") {
                if ((existing || []).some(x => normalizeTarget(x) === t)) return { ok: false, error: "Dieses Target ist bereits vorhanden." };
                return { ok: true, value: t };
            }

            const m = t.match(/^(S|D|T)(\d{1,2})$/);
            if (!m) return { ok: false, error: "Ungültiges Format. Erlaubt: S1..S20, D1..D20, T1..T20, SB, DB." };

            const n = Number(m[2]);
            if (!Number.isFinite(n) || n < 1 || n > 20) return { ok: false, error: "Zahl muss zwischen 1 und 20 liegen." };

            const value = `${m[1]}${n}`;
            if ((existing || []).some(x => normalizeTarget(x) === value)) return { ok: false, error: "Dieses Target ist bereits vorhanden." };

            return { ok: true, value };
        }

        function setSelectedPlanItemId(id) {
            const prevId = String(selectedPlanItemId || "");
            const nextId = id ? String(id) : "";

            if (!nextId) {
                selectedPlanItemId = null;
                targetAddOpen = false;
                targetAddValue = "";
                targetAddError = "";

                // remove highlight (no full table re-render -> keeps input focus)
                if (prevId) {
                    const prevRow = table.querySelector(`.ad-plan-row[data-plan-item-id="${cssEscapeAttrValue(prevId)}"]`);
                    if (prevRow) {
                        prevRow.classList.remove("ad-plan-row--selected");
                        prevRow.setAttribute("aria-selected", "false");
                    }
                }

                renderPlanDetails();
                return;
            }

            selectedPlanItemId = nextId;

            // Step 2: Beim Selektieren Segment-Item params.targets initialisieren
            const it = getPlanItemById(nextId);
            if (it && String(it.type || "") === "SEGMENT_TRAINING") {
                const hasTargets = it.params && Array.isArray(it.params.targets);
                if (!hasTargets) {
                    updatePlanItemById(nextId, (cur) => {
                        const p = cur && cur.params ? { ...cur.params } : {};
                        if (!Array.isArray(p.targets)) p.targets = [];
                        return { ...cur, params: p };
                    });
                }
            }

            // UI state reset (Add-Target)
            targetAddOpen = false;
            targetAddValue = "";
            targetAddError = "";

            // Update highlight (no full table re-render -> keeps input focus)
            if (prevId && prevId !== nextId) {
                const prevRow = table.querySelector(`.ad-plan-row[data-plan-item-id="${cssEscapeAttrValue(prevId)}"]`);
                if (prevRow) {
                    prevRow.classList.remove("ad-plan-row--selected");
                    prevRow.setAttribute("aria-selected", "false");
                }
            }
            const nextRow = table.querySelector(`.ad-plan-row[data-plan-item-id="${cssEscapeAttrValue(nextId)}"]`);
            if (nextRow) {
                nextRow.classList.add("ad-plan-row--selected");
                nextRow.setAttribute("aria-selected", "true");
            }

            renderPlanDetails();
        }
        function setStatusTemp(msg) {
            if (!statusEl) return;
            statusEl.textContent = String(msg || "");
            if (statusTimer) clearTimeout(statusTimer);
            statusTimer = setTimeout(() => {
                if (statusEl && statusEl.isConnected) statusEl.textContent = "Bereit.";
            }, 1200);
        }

        function clampHoursToMinutes(hours) {
            let h = Number(hours);
            if (!Number.isFinite(h)) h = 0;

            // UI: Viertelstunden (wie bisher)
            h = Math.round(h * 4) / 4;

            if (h < 0) h = 0;

            const maxH = PLAN_TARGET_MAX_MINUTES / 60;
            if (h > maxH) h = maxH;

            return clampMinutes(Math.round(h * 60));
        }

        function minutesToHours(mins) {
            const m = Number(mins) || 0;
            return m / 60;
        }

        function formatHoursNumber(hours) {
            let h = Number(hours) || 0;
            // keep quarter precision stable in UI
            h = Math.round(h * 4) / 4;

            const isInt = Math.abs(h - Math.round(h)) < 1e-9;
            if (isInt) return Math.round(h).toFixed(1);

            // up to 2 decimals, trim trailing zeros
            let s = h.toFixed(2);
            s = s.replace(/0+$/, "").replace(/\.$/, "");
            return s;
        }

        function formatHoursWithUnit(hours) {
            return formatHoursNumber(hours) + " h";
        }

        function totalTargetMinutes() {
            return (Array.isArray(planItems) ? planItems : []).reduce((a, it) => a + clampMinutes(Number(it?.targetMinutes)), 0);
        }


        // -------------------------------------------------------------------
        // Step 3: Ist-Minuten aus Tracker (Adapter) + Reaktivität
        // -------------------------------------------------------------------

        let _sidebarAggCache = null;
        let _sidebarAggWeekKey = null;
        let _sidebarAggFp = null;

        function sidebarTrackerFingerprint() {
            // minimal & stabil: ändert sich, wenn Tracker-Daten neu geladen wurden
            const a = Array.isArray(cache.sessions) ? cache.sessions.length : 0;
            const b = Array.isArray(cache.x01Matches) ? cache.x01Matches.length : 0;
            const c = Array.isArray(cache.otherTrainingSessions) ? cache.otherTrainingSessions.length : 0;
            const r = Number(cache?.meta?.totalRows ?? 0) || 0;
            return `${r}|${a}|${b}|${c}`;
        }

        function getSidebarWeeksAsc() {
            // Vor dem Laden NICHT computeTrainingWeeksAsc() ausführen (würde 260 Wochen füllen)
            if (Array.isArray(cache._training_weeksAsc) && cache._training_weeksAsc.length) return cache._training_weeksAsc;
            if (!cache.loaded) return [];
            const w = computeTrainingWeeksAsc();
            cache._training_weeksAsc = w;
            return w;
        }

        function weekRangeExclusiveFromWeekKey(weekKey) {
            const start = parseDayKeyToLocalDate(weekKey);
            if (!start) return null;
            const end = addDaysLocal(start, 7); // end exklusiv
            return { start, end };
        }

        function ensureSidebarSelectedWeekKey() {
            const weeksAsc = getSidebarWeeksAsc();
            const sel = ensurePlanSelectedWeekKey(weeksAsc);
            planWeek = String(sel || "") || (weekKeyFromDate(new Date()) || "");
            return planWeek;
        }

        function refreshSidebarWeekOptions() {
            // Sidepanel hat keine eigene Wochenwahl mehr -> zeigt nur Info zur aktiven Woche
            if (!activeWeekInfo) return;

            const wkKey = ensureSidebarSelectedWeekKey();
            const info = weekRangeFromWeekKey(wkKey);

            function dayKeyToGermanShort(dayKey) {
                if (!dayKey || !/^\d{4}-\d{2}-\d{2}$/.test(dayKey)) return "—";
                const [y, m, d] = dayKey.split("-");
                // dd.MM. (ohne Jahr)
                return `${d}.${m}.`;
            }

            if (!info) {
                activeWeekInfo.textContent = "Aktive Woche: —";
                return;
            }

            const kw = String(info.week || "").padStart(2, "0");
            const yr = String(info.isoYear || "");
            const s = dayKeyToGermanShort(info.startKey);
            const e = dayKeyToGermanShort(info.endKey);
            activeWeekInfo.textContent = `Aktive Woche: KW ${kw}/${yr} (${s}–${e})`;
        }

        function getTrackerAggForSelectedWeek() {
            const wk = ensureSidebarSelectedWeekKey();
            const fp = sidebarTrackerFingerprint();

            if (_sidebarAggCache && _sidebarAggWeekKey === wk && _sidebarAggFp === fp) return _sidebarAggCache;

            const wr = weekRangeExclusiveFromWeekKey(wk);
            _sidebarAggCache = wr ? getTrackerAggregationForWeek(wr) : { minutesByActivity: {}, sessionsByActivity: {}, segmentTargetsMinutes: {}, segmentTargetsSessions: undefined };
            _sidebarAggWeekKey = wk;
            _sidebarAggFp = fp;
            return _sidebarAggCache;
        }

        // 0.14.169: Zeitschätzung im Trainingsplan (All-time Ø Sekunden pro Leg/Session je Aktivität)
        let _planEstAllCache = null;
        let _planEstAllFp = null;

        function getPlanEstimatesAllTime() {
            const fp = sidebarTrackerFingerprint();
            if (_planEstAllCache && _planEstAllFp === fp) return _planEstAllCache;

            const out = {
                hasAnyHistory: false,
                avgSecPerLegByType: {},
                totalSecByType: {},
                totalLegsByType: {}
            };

            try {
                if (!cache || !cache.loaded) {
                    _planEstAllCache = out;
                    _planEstAllFp = fp;
                    return out;
                }

                const aggAll = aggregateTrainingActualsAllTime();
                const byActivity = aggAll?.byActivity || new Map();

                for (const [planType, trackerKey] of Object.entries(PLANITEM_TYPE_TO_TRACKER_KEY)) {
                    const rec = byActivity.get(String(trackerKey)) || null;
                    const sec = Math.max(0, Number(rec?.sec || 0) || 0);
                    const cnt = Math.max(0, Number(rec?.count || 0) || 0);

                    out.totalSecByType[planType] = sec;
                    out.totalLegsByType[planType] = cnt;

                    if (sec > 0 && cnt > 0) {
                        out.avgSecPerLegByType[planType] = sec / cnt;
                        out.hasAnyHistory = true;
                    } else {
                        out.avgSecPerLegByType[planType] = null;
                    }
                }
            } catch (e) {
                try { console.warn('[AD Ext][PLAN] getPlanEstimatesAllTime failed', e); } catch {}
            }

            _planEstAllCache = out;
            _planEstAllFp = fp;
            return out;
        }



        function getSidebarViewMode() {
            // UI: seit 0.14.75 nur noch Sessions/Legs. Time bleibt intern als Fallback erhalten.
            try { cache.trainingPlan = cache.trainingPlan || loadTrainingPlanState(); } catch {}
            const st = cache.trainingPlan || {};
            st.basis = "SESS";
            return "sessions";
        }

        function syncModeButtons() {
            const isSess = getSidebarViewMode() === "sessions";
            if (btnSessions) {
                btnSessions.classList.toggle("is-active", isSess);
                btnSessions.setAttribute("aria-pressed", isSess ? "true" : "false");
            }
            if (btnTime) {
                btnTime.classList.toggle("is-active", !isSess);
                btnTime.setAttribute("aria-pressed", !isSess ? "true" : "false");
            }
        }

        function ensureSidebarWeekPlanLoaded(force = false) {
            const wkKey = ensureSidebarSelectedWeekKey();
            const weekId = weekIdFromWeekKey(wkKey);
            if (!weekId) return;

            if (!force && String(_adPlanActiveWeekId || "") === String(weekId)) return;

            // Beim Wochenwechsel zuerst pending Saves des alten Plans flushen
            if (_adPlanActiveWeekId && String(_adPlanActiveWeekId) !== String(weekId)) {
                flushSaveCurrentWeekPlan();
            }

            const loaded = loadWeekPlan(weekId);

            if (loaded) {
                weekMode = "sessions"; // UI: sessions-only (0.14.75)
                planItems = sanitizePlanItemsForStorage(loaded.planItems);
                planNotesHtml = normalizeNotesHtml(loaded.notesHtml || "");
                _adPlanActiveWeekHasStoredPlan = true;
            } else {
                // 0.14.42: Keine Auto-Templates/Auto-Speicherung mehr.
                // Neue Wochen starten leer, bis der User aktiv etwas anlegt (z. B. +Aktivität).
                weekMode = "sessions"; // UI: sessions-only (0.14.75)
                planItems = [];
                planNotesHtml = "";
                _adPlanActiveWeekHasStoredPlan = false;
            }

            // Auswahl: erstes Item oder null
            selectedPlanItemId = (Array.isArray(planItems) && planItems.length) ? String(planItems[0].id || "") : null;

            // Segment-Details UI zurücksetzen
            targetAddOpen = false;
            targetAddValue = "";
            targetAddError = "";

            _adPlanActiveWeekId = weekId;

            // Save-Cache resetten (neue Woche)
            _adPlanLastSavedWeekId = null;
            _adPlanLastSavedJson = null;
            _adPlanDirty = false;

            syncModeButtons();

            // Notes-Editor: pro Woche laden
            try {
                const ed = side.querySelector("#adPlanNotesEditor");
                if (ed) ed.innerHTML = String(planNotesHtml || "");
            } catch (e) {}
            try {
                const hint = side.querySelector("#adPlanNotesSaved");
                if (hint) { hint.classList.remove("is-dirty"); hint.textContent = "Keine Änderungen vorhanden"; }
            } catch (e) {}
        }



        // Copy-Helper: gilt als "leer", wenn keine Items vorhanden ODER Plan exakt dem Default-Template entspricht
        function isDefaultTemplatePlan(items) {
            const arr = Array.isArray(items) ? items : [];
            if (arr.length !== PLAN_ACTIVITY_TEMPLATES.length) return false;

            for (let i = 0; i < PLAN_ACTIVITY_TEMPLATES.length; i++) {
                const tpl = PLAN_ACTIVITY_TEMPLATES[i] || {};
                const it = arr[i] || {};

                const tplType = String(tpl.type || "").trim();
                const itType = String(it.type || "").trim();
                if (tplType !== itType) return false;

                // Default-Initialisierung nutzt Template-Namen (unique), daher hier strikt
                const tplName = String(tpl.name || "").trim();
                const itName = String(it.name || "").trim();
                if (tplName !== itName) return false;

                const tplMin = clampMinutes(Number(tpl.defaultMinutes) || 0);
                const itMin = clampMinutes(Number(it.targetMinutes));
                if (tplMin !== itMin) return false;

                const itSess = clampSessions(Number(it.targetSessions));
                if (itSess !== 1) return false;

                if (tplType === "SEGMENT_TRAINING") {
                    const p = it && it.params ? it.params : {};
                    const targets = Array.isArray(p?.targets) ? p.targets : [];
                    if (targets.length !== 0) return false;
                }
            }

            return true;
        }

        function fmtWeekLabel(wkKey) {
            try {
                const r = weekRangeFromWeekKey(wkKey);
                const isoYear = Number(r?.isoYear) || 0;
                const week = String(r?.week ?? "").padStart(2, "0");
                const s = dayKeyToGerman(r?.startKey);
                const e = dayKeyToGerman(r?.endKey);
                const sShort = String(s || "").replace(/\.\d{4}$/, ".");
                const eShort = String(e || "").replace(/\.\d{4}$/, ".");
                if (isoYear && week && sShort && eShort) return `KW ${week}/${isoYear} (${sShort}–${eShort})`;
            } catch (e) { /* ignore */ }
            return String(wkKey || "");
        }

        function isPlanEmptyForCopy() {
            const arr = Array.isArray(planItems) ? planItems : [];
            return (((!arr.length) || isDefaultTemplatePlan(arr)) && isNotesHtmlEmpty(planNotesHtml));
        }

        function syncCopyPrevWeekButton() {
            if (!btnCopyPrevWeek) return;
            const wkKey = ensureSidebarSelectedWeekKey();
            const weekId = weekIdFromWeekKey(wkKey);
            const can = !!weekId && isPlanEmptyForCopy();
            btnCopyPrevWeek.disabled = !can;
            btnCopyPrevWeek.title = !weekId
                ? "Keine Woche gewählt"
            : (can ? "Übernimmt den Plan der Vorwoche" : "Aktuelle Woche hat bereits einen Plan");
        }



        function syncResetWeekButton() {
            if (!btnResetWeek) return;
            const wkKey = ensureSidebarSelectedWeekKey();
            const weekId = weekIdFromWeekKey(wkKey);

            const arr = Array.isArray(planItems) ? planItems : [];
            const isVirgin = (arr.length === 0) && isNotesHtmlEmpty(planNotesHtml) && (_adPlanActiveWeekHasStoredPlan === false) && (_adPlanDirty === false);

            const can = !!weekId && !isVirgin;
            btnResetWeek.disabled = !can;
            btnResetWeek.title = !weekId
                ? "Keine Woche gewählt"
            : (can ? `Löscht den Trainingsplan dieser Woche (${fmtWeekLabel(wkKey)})` : "Woche ist bereits leer");
        }
        function copyPrevWeekPlanIntoCurrent() {
            const wkKey = ensureSidebarSelectedWeekKey();
            const curWeekId = weekIdFromWeekKey(wkKey);

            if (!curWeekId) {
                setStatusTemp("Keine Woche gewählt.");
                return;
            }

            if (!isPlanEmptyForCopy()) {
                setStatusTemp("Aktuelle Woche hat bereits einen Plan.");
                syncCopyPrevWeekButton();
                syncResetWeekButton();
                return;
            }

            // pending Saves vorher flushen (nur zur Sicherheit)
            flushSaveCurrentWeekPlan();

            const prevWeekId = getPreviousWeekId(curWeekId);
            if (!prevWeekId) {
                setStatusTemp("Vorwoche nicht bestimmbar.");
                return;
            }

            const prevPlan = loadWeekPlan(prevWeekId);
            if (!prevPlan) {
                setStatusTemp("Kein Plan für Vorwoche vorhanden.");
                return;
            }

            const baseItems = sanitizePlanItemsForStorage(prevPlan.planItems);
            const copied = baseItems.map((src) => {
                const srcParams = (src && src.params) ? { ...src.params } : undefined;
                if (srcParams && Array.isArray(srcParams.targets)) srcParams.targets = srcParams.targets.slice();

                const out = {
                    id: makePlanId(),
                    type: String(src?.type || "CUSTOM"),
                    name: String(src?.name || src?.type || "Aktivität"),
                    targetMinutes: clampMinutes(Number(src?.targetMinutes)),
                    targetSessions: (Number.isFinite(Number(src?.targetSessions)) ? clampSessions(Number(src?.targetSessions)) : 1),
                    params: srcParams
                };

                // Segment Training immer params.targets haben
                if (String(out.type || "") === "SEGMENT_TRAINING") {
                    const p = out.params ? { ...out.params } : {};
                    if (!Array.isArray(p.targets)) p.targets = [];
                    out.params = p;
                }

                return out;
            });

            weekMode = normalizeWeekMode(prevPlan.weekMode);
            planItems = copied;
            planNotesHtml = normalizeNotesHtml(prevPlan.notesHtml || "");
            try { const ed = side.querySelector("#adPlanNotesEditor"); if (ed) ed.innerHTML = String(planNotesHtml || ""); } catch {}

            selectedPlanItemId = copied.length ? String(copied[0].id || "") : null;
            targetAddOpen = false;
            targetAddValue = "";
            targetAddError = "";

            const safe = { schemaVersion: 1, weekId: curWeekId, weekMode, planItems: sanitizePlanItemsForStorage(planItems), notesHtml: normalizeNotesHtml(planNotesHtml) };

            // Speichern (direkt)
            try { saveWeekPlan(safe); } catch (e) { /* ignore */ }

            // Save-Cache aktualisieren (damit der nächste Auto-Save nicht unnötig schreibt)
            try {
                _adPlanLastSavedWeekId = curWeekId;
                _adPlanLastSavedJson = JSON.stringify(safe);
            } catch (e) { /* ignore */ }

            _adPlanActiveWeekHasStoredPlan = true;
            _adPlanDirty = false;

            syncModeButtons();
            syncCopyPrevWeekButton();
            renderAll();
            setStatusTemp("Vorwoche kopiert.");
        }


        function resetCurrentWeekPlan() {
            const wkKey = ensureSidebarSelectedWeekKey();
            const weekId = weekIdFromWeekKey(wkKey);

            if (!weekId) {
                setStatusTemp("Keine Woche gewählt.");
                return;
            }

            const arr = Array.isArray(planItems) ? planItems : [];
            const isVirgin = (arr.length === 0) && isNotesHtmlEmpty(planNotesHtml) && (_adPlanActiveWeekHasStoredPlan === false) && (_adPlanDirty === false);

            if (isVirgin) {
                setStatusTemp("Woche ist bereits leer.");
                syncCopyPrevWeekButton();
                syncResetWeekButton();
                return;
            }

            if (!confirm(`${fmtWeekLabel(wkKey)} wirklich zurücksetzen? (Trainingsplan wird gelöscht)`)) return;

            // Pending Auto-Save stoppen, ohne zu flushen/speichern
            if (_adPlanSaveTimer) {
                clearTimeout(_adPlanSaveTimer);
                _adPlanSaveTimer = null;
            }

            // Dirty-State zurücksetzen, damit nichts gespeichert wird
            _adPlanDirty = false;
            _adPlanLastSavedWeekId = null;
            _adPlanLastSavedJson = null;

            // Storage-Key löschen
            deleteWeekPlan(weekId);

            // UI/Memory neu laden (leer)
            ensureSidebarWeekPlanLoaded(true);
            renderAll();
            setStatusTemp("Woche zurückgesetzt.");
        }




        function getItemActualMinutes(it, agg) {
            const type = String(it?.type || "");
            if (type === "SEGMENT_TRAINING") {
                const targets = it?.params && Array.isArray(it.params.targets) ? it.params.targets : [];
                if (targets.length) {
                    let sum = 0;
                    for (const t of targets) {
                        const k = normalizeTarget(t);
                        sum += Number(agg?.segmentTargetsMinutes?.[k] ?? agg?.segmentTargetsMinutes?.[t] ?? 0) || 0;
                    }
                    return Math.max(0, Math.round(sum));
                }
            }
            const m = agg && agg.minutesByActivity ? Number(agg.minutesByActivity[type] || 0) : 0;
            return Number.isFinite(m) ? Math.max(0, Math.round(m)) : 0;
        }

        function getProgressPct(ist, soll) {
            const goal = Number(soll) || 0;
            if (goal <= 0) return 0;
            const actual = Math.max(0, Number(ist) || 0);
            return Math.min(100, Math.round((actual / goal) * 100));
        }

        function getTargetSessions(it) {
            return clampSessions(Number(it?.targetSessions));
        }

        function getItemActualSessions(it, agg) {
            const type = String(it?.type || "");
            if (type === "SEGMENT_TRAINING") {
                const targets = it?.params && Array.isArray(it.params.targets) ? it.params.targets : [];
                const map = agg?.segmentTargetsSessions;
                if (targets.length && map && typeof map === "object") {
                    let sum = 0;
                    for (const t of targets) {
                        const k = normalizeTarget(t);
                        sum += Number(map?.[k] ?? map?.[t] ?? 0) || 0;
                    }
                    return Math.max(0, Math.round(sum));
                }
            }
            const s = agg && agg.sessionsByActivity ? Number(agg.sessionsByActivity[type] || 0) : 0;
            return Number.isFinite(s) ? Math.max(0, Math.round(s)) : 0;
        }

        function computeSidebarTotals(agg) {
            const items = Array.isArray(planItems) ? planItems : [];
            let goal = 0;
            let ist = 0;
            let credited = 0;

            if (getSidebarViewMode() === "sessions") {
                for (const it of items) {
                    const g = getTargetSessions(it);
                    const a = getItemActualSessions(it, agg);
                    goal += g;
                    ist += a;
                    credited += Math.min(a, g);
                }
            } else {
                for (const it of items) {
                    const g = clampMinutes(Number(it?.targetMinutes));
                    const a = getItemActualMinutes(it, agg);
                    goal += g;
                    ist += a;
                    credited += Math.min(a, g);
                }
            }

            const pct = getProgressPct(credited, goal);
            return { goal, ist, credited, progressPct: pct };
        }



        function renderSummary() {
            const agg = getTrackerAggForSelectedWeek();
            const totals = computeSidebarTotals(agg);

            const estAll = getPlanEstimatesAllTime();

            if (getSidebarViewMode() === "sessions") {
                sumTarget.textContent = `${Math.round(totals.goal)} LEGS`;
            } else {
                // legacy fallback
                sumTarget.textContent = `${Math.round(totals.goal)}min`;
            }
        }
        function renderPlanTable() {
            if (!table) return;

            const isSessions = getSidebarViewMode() === "sessions";

            const unit = isSessions ? "LEGS" : "min";

            const agg = getTrackerAggForSelectedWeek();
            const totals = computeSidebarTotals(agg);

            const estAll = getPlanEstimatesAllTime();

            const head = `
              <div class="ad-plan-row ad-plan-row--head">
                <div>Aktivität</div>
                <div class="ad-plan-cell-right" title="Geschätzte Zeit pro Leg">Ø Zeit / Leg</div>
                <div class="ad-plan-cell-right">Geschätzte Zeit</div>
                <div class="ad-plan-soll-head"><span class="ad-plan-soll-label">Soll</span><span class="ad-plan-soll-unit">${escapeHtml(unit)}</span></div>
              </div>
            `;

    const items = Array.isArray(planItems) ? planItems : [];

    const rows = items.length
    ? items.map((it) => {
        const id = String(it?.id || "");
        const name = String(it?.name || "");
        const selected = String(selectedPlanItemId || "") === id;

        const planType = String(it?.type || "");
        const avgSec = estAll ? estAll.avgSecPerLegByType?.[planType] : null;
        const hasAvg = Number.isFinite(Number(avgSec)) && Number(avgSec) > 0;

        const soll = isSessions ? getTargetSessions(it) : clampMinutes(Number(it?.targetMinutes));
        const inputValue = String(soll);

        const step = isSessions ? "1" : "5";
        const max = isSessions ? String(PLAN_TARGET_MAX_SESSIONS) : String(PLAN_TARGET_MAX_MINUTES);
        const inputmode = "numeric";
        const pattern = "[0-9]*";
        const unit = isSessions ? "LEGS" : "min";


        const plannedLegs = Math.max(0, Number(soll) || 0);
        let estCellHtml = "—";
        if (plannedLegs > 0) {
            if (hasAvg) {
                const estSec = Number(avgSec) * plannedLegs;
                estCellHtml = `<span class="ad-plan-est-val">${escapeHtml(fmtHours(estSec))}</span>`;
            } else {
                estCellHtml = `<span class="ad-plan-est-muted">noch kein Training gespielt</span>`;
            }
        }

        let perLegCellHtml = "—";
        if (hasAvg) {
            perLegCellHtml = `<span class="ad-plan-perleg-val">${escapeHtml(fmtMinPerLeg(Number(avgSec)))}</span>`;
        }

        return `
                  <div class="ad-plan-row${selected ? " ad-plan-row--selected" : ""}" data-plan-item-id="${escapeHtml(id)}" role="button" tabindex="0" aria-selected="${selected ? "true" : "false"}">
                    <div>
                      <div class="ad-plan-activityline">
                        <div class="ad-plan-activity">
                          <span class="ad-plan-drag-handle" title="Ziehen zum Sortieren" aria-hidden="true" draggable="true">≡</span>
                          <div class="ad-plan-activity-main">
                            <span class="ad-plan-activity-name" title="${escapeHtml(name)}">${escapeHtml(name)}</span>
                          </div>
                        </div>
                        <div class="ad-plan-mini-actions">
                          <button type="button" class="ad-plan-mini-btn" data-action="dup" data-id="${escapeHtml(id)}" title="Duplizieren">⎘</button>
                          <button type="button" class="ad-plan-mini-btn ad-plan-mini-btn--danger" data-action="del" data-id="${escapeHtml(id)}" title="Löschen">🗑</button>
                        </div>
                      </div>
                    </div>
                    <div class="ad-plan-perleg-cell">${perLegCellHtml}</div>
                    <div class="ad-plan-est-cell">${estCellHtml}</div>
                    <div class="ad-plan-input-wrap">
                      <input class="ad-plan-input" data-id="${escapeHtml(id)}" type="number" value="${escapeHtml(String(inputValue))}"
                        step="${escapeHtml(step)}" min="0" max="${escapeHtml(max)}" inputmode="${escapeHtml(inputmode)}" pattern="${escapeHtml(pattern)}" />
                      <span class="ad-plan-unit">${escapeHtml(unit)}</span>
                    </div>
                  </div>
                `;
                }).join("")
            : `
                  <div class="ad-plan-row ad-plan-row--empty">
                    <div style="font-weight:850;">
                      Kein Trainingsplan angelegt
                      <div class="ad-plan-muted" style="margin-top:4px;">Klicke auf <span style="font-weight:900;">+ Aktivität</span>.</div>
                    </div>
                    <div class="ad-plan-cell-right">—</div>
                    <div class="ad-plan-cell-right">—</div>
                    <div class="ad-plan-cell-right">—</div>
                  </div>
                `;
    const totalVal = Math.round(totals.goal);
    const totalUnit = isSessions ? "LEGS" : "min";

    let totalEstSec = 0;
    let totalEstLegs = 0;
    let anyPlanned = false;
    let anyEstimated = false;
    for (const it of items) {
        const pt = String(it?.type || "");
        const avg = estAll ? estAll.avgSecPerLegByType?.[pt] : null;
        const has = Number.isFinite(Number(avg)) && Number(avg) > 0;
        const goalLegs = isSessions ? getTargetSessions(it) : clampMinutes(Number(it?.targetMinutes));
        const planned = Math.max(0, Number(goalLegs) || 0);
        if (planned <= 0) continue;
        anyPlanned = true;
        if (!has) continue;
        anyEstimated = true;
        totalEstSec += Number(avg) * planned;
        totalEstLegs += planned;
    }

    let totalEstHtml = "—";
    if (anyPlanned) {
        totalEstHtml = anyEstimated
            ? `<span class="ad-plan-est-val">${escapeHtml(fmtHours(totalEstSec))}</span>`
            : `<span class="ad-plan-est-muted">noch kein Training gespielt</span>`;
    }

    let totalPerLegHtml = "—";
    if (anyEstimated && totalEstLegs > 0 && totalEstSec > 0) {
        totalPerLegHtml = `<span class="ad-plan-perleg-val">${escapeHtml(fmtMinPerLeg(totalEstSec / totalEstLegs))}</span>`;
    }


    const foot = `
              <div class="ad-plan-row ad-plan-row--foot">
                <div>Gesamt</div>
                <div class="ad-plan-perleg-cell">${totalPerLegHtml}</div>
                <div class="ad-plan-est-cell">${totalEstHtml}</div>
                <div class="ad-plan-input-wrap">
                  <span class="ad-plan-pill" id="adPlanTotalSoll">${escapeHtml(String(totalVal))}</span>
                  <span class="ad-plan-unit" id="adPlanTotalSollUnit">${escapeHtml(totalUnit)}</span>
                </div>
              </div>
            `;
    table.innerHTML = head + rows + foot;
}
            function renderPlanDetails() {
                if (!details) return;

                const id = String(selectedPlanItemId || "");
                const it = getPlanItemById(id);

                if (!it) {
                    details.innerHTML = `
                  <div class="ad-plan-details-card">
                    <div class="ad-plan-details-head">
                      <div>
                        <div class="ad-plan-details-title">Details</div>
                        <div class="ad-plan-details-sub">Wähle rechts ein Plan-Item aus.</div>
                      </div>
                    </div>
                  </div>
                `;
                return;
            }

    const type = String(it?.type || "");
    const typeLabel = getTypeLabel(type);
    const name = String(it?.name || "");
    const isSeg = type === "SEGMENT_TRAINING";
    const targets = (isSeg && it?.params && Array.isArray(it.params.targets)) ? it.params.targets : [];

    // 0.14.171: Details – Zeitschätzung Breakdown (aus historischer Ø Zeit pro Leg)
    const estAll = getPlanEstimatesAllTime();
    const planType = String(it?.type || "");
    const histLegs = Math.max(0, Math.round(Number(estAll?.totalLegsByType?.[planType] || 0)));
    const histSec = Math.max(0, Math.round(Number(estAll?.totalSecByType?.[planType] || 0)));
    const avgSec = Number(estAll?.avgSecPerLegByType?.[planType]);
    const hasAvg = Number.isFinite(avgSec) && avgSec > 0 && histLegs > 0 && histSec > 0;

    const plannedLegs = Math.max(0, getTargetSessions(it));
    const estSec = (hasAvg && plannedLegs > 0) ? (avgSec * plannedLegs) : 0;

    const histTxt = (histLegs > 0 && histSec > 0) ? `${histLegs} LEGS · ${fmtHours(histSec)}` : "—";
    const avgTxt = hasAvg ? fmtMinPerLeg(avgSec) : "—";
    const plannedTxt = `${plannedLegs} LEGS`;

    let estValHtml = "—";
    if (plannedLegs > 0) {
        if (hasAvg) estValHtml = `<span class="ad-plan-est-val">${escapeHtml(fmtHours(estSec))}</span>`;
        else estValHtml = `<span class="ad-plan-est-muted">noch kein Training gespielt</span>`;
    }

    let formulaTxt = "";
    if (plannedLegs > 0 && hasAvg) {
        formulaTxt = `Schätzung = ${plannedLegs} LEGS × Ø ${fmtMinPerLeg(avgSec)} pro Leg (Historie: ${histLegs} LEGS · ${fmtHours(histSec)})`;
    } else if (plannedLegs > 0 && !hasAvg) {
        formulaTxt = "Schätzung nicht möglich: noch kein Training gespielt.";
    } else {
        formulaTxt = "Setze Soll-LEGS > 0, um eine Schätzung zu sehen.";
    }

    const estBoxHtml = `
      <div class="ad-plan-details-box ad-plan-details-box--estimate">
        <div class="ad-plan-details-box-title">
          <span>Zeitschätzung</span>
          <span class="ad-plan-details-box-hint">aus Historie</span>
        </div>
        <div class="ad-plan-est-breakdown">
          <div class="ad-plan-est-k">Historie</div><div class="ad-plan-est-v">${escapeHtml(histTxt)}</div>
          <div class="ad-plan-est-k">Ø Zeit / Leg</div><div class="ad-plan-est-v">${escapeHtml(avgTxt)}</div>
          <div class="ad-plan-est-k">Geplant</div><div class="ad-plan-est-v">${escapeHtml(plannedTxt)}</div>
          <div class="ad-plan-est-k">Geschätzt</div><div class="ad-plan-est-v">${estValHtml}</div>
        </div>
        <div class="ad-plan-est-formula">${escapeHtml(formulaTxt)}</div>
      </div>
    `;


    const chipsHtml = isSeg
    ? (targets.length
       ? targets.map((t) => `
                        <span class="ad-plan-chip" data-target="${escapeHtml(String(t))}">
                          <span class="ad-plan-chip-handle" draggable="true" title="Ziehen zum Sortieren" aria-label="Target verschieben">≡</span>
                          <span class="ad-plan-chip-text">${escapeHtml(String(t))}</span>
                          <button type="button" class="ad-plan-chip-x" data-remove-target="${escapeHtml(String(t))}" title="Entfernen" aria-label="Target entfernen">×</button>
                        </span>
                      `).join("")
                   : `<div class="ad-plan-muted">Noch keine Targets. Füge unten welche hinzu.</div>`
                  )
            : "";

    const datalistHtml = isSeg
    ? `<datalist id="adPlanTargetSuggestions">${ALL_DART_TARGETS.map(t => `<option value="${escapeHtml(t)}"></option>`).join("")}</datalist>`
                : "";

    const addUiHtml = isSeg
    ? (!targetAddOpen
       ? `<button type="button" class="ad-ext-btn ad-ext-btn--secondary" data-action="open-add-target">+ Target hinzufügen</button>`
                    : `
                      <div class="ad-plan-target-add-row">
                        <input id="adPlanTargetInput" class="ad-plan-target-input" type="text"
                          placeholder="z. B. D20, T19, SB" value="${escapeHtml(String(targetAddValue || ""))}"
                          list="adPlanTargetSuggestions" autocomplete="off" />
                        <button type="button" class="ad-ext-btn ad-ext-btn--primary" data-action="confirm-add-target">Hinzufügen</button>
                        <button type="button" class="ad-ext-btn ad-ext-btn--secondary" data-action="cancel-add-target">Abbrechen</button>
                      </div>
                      ${targetAddError ? `<div class="ad-plan-error">${escapeHtml(String(targetAddError))}</div>` : ``}
                      ${datalistHtml}
                    `
                  )
            : "";

    const targetsBoxHtml = `
      <div class="ad-plan-details-box ad-plan-details-box--targets">
        <div class="ad-plan-details-box-title">
          <span>Targets</span>
          <span class="ad-plan-details-box-hint">${isSeg ? "ziehen zum Sortieren" : "Platzhalter"}</span>
        </div>
        <div class="ad-plan-chip-row">
          ${isSeg ? chipsHtml : `
            <span class="ad-plan-chip ad-plan-chip--ghost">
              <span class="ad-plan-chip-text">—</span>
            </span>
          `}
        </div>
        <div class="ad-plan-target-add">
          ${isSeg ? addUiHtml : `<button type="button" class="ad-ext-btn ad-ext-btn--secondary" disabled title="Targets kommen später auch für diesen Modus.">+ Target hinzufügen</button>`}
        </div>
      </div>
    `;

    details.innerHTML = `
              <div class="ad-plan-details-card">
                <div class="ad-plan-details-head">
                  <div>
                    <div class="ad-plan-details-title">Details</div>
                    <div class="ad-plan-details-badge">${escapeHtml(typeLabel)}</div>
                  </div>
                </div>

                <div class="ad-plan-details-grid">
                  ${targetsBoxHtml}
                  ${estBoxHtml}
                </div>

                <div class="ad-plan-details-box ad-plan-details-box--name">
                  <div class="ad-plan-details-box-title"><span>Anzeigename</span></div>
                  <input id="adPlanDetailName" class="ad-plan-details-name" type="text"
                    data-id="${escapeHtml(String(it.id || ""))}" value="${escapeHtml(name)}" />
                </div>
              </div>
            `;

    // Fokus, wenn Add-Target offen
    if (targetAddOpen) {
        setTimeout(() => {
            const inp = details.querySelector("#adPlanTargetInput");
            if (inp && inp.focus) inp.focus();
        }, 0);
    }
}


            function renderAll() {
                ensureSidebarWeekPlanLoaded(false);
                syncModeButtons();

                syncCopyPrevWeekButton();
                syncResetWeekButton();
                renderSummary();
                renderPlanTable();

                // 0.14.173: Beim Wechsel in den Trainingsplan sofort den ersten Eintrag selektieren,
                // damit Details + Zeitschätzung ohne Extra-Klick geladen sind.
                try {
                    const firstId = (Array.isArray(planItems) && planItems.length) ? String(planItems[0]?.id || "") : "";
                    if (!selectedPlanItemId && firstId) selectedPlanItemId = firstId;
                } catch {}
                setSelectedPlanItemId(selectedPlanItemId || null);
            }

            // Drawer helpers
            function setDrawerOpen(open) {
                planDrawerOpen = !!open;

                if (overlay) overlay.hidden = !planDrawerOpen;
                if (drawer) {
                    drawer.dataset.open = planDrawerOpen ? "1" : "0";
                    drawer.setAttribute("aria-hidden", planDrawerOpen ? "false" : "true");
                }

                if (planDrawerOpen) {
                    if (drawerSearch) drawerSearch.value = planDrawerSearch || "";
                    renderDrawerList();
                    try { drawerSearch?.focus?.(); } catch {}
                }
            }

            function renderDrawerList() {
                if (!drawerList) return;

                const q = String(planDrawerSearch || "").trim().toLowerCase();
                const filtered = PLAN_ACTIVITY_TEMPLATES.filter(t => {
                    const n = String(t?.name || "").toLowerCase();
                    return !q || n.includes(q);
                });

                if (!filtered.length) {
                    drawerList.innerHTML = `<div class="ad-plan-drawer-empty">Keine Treffer.</div>`;
                    return;
                }

                drawerList.innerHTML = filtered.map((t) => {
                    const type = String(t?.type || "");
                    const name = String(t?.name || "");
                    const defSess = getDefaultSessionsForPlanType(type);
                    const h = `${defSess} LEGS`;

                    return `
                  <div class="ad-plan-drawer-item" data-template="${escapeHtml(type)}" role="button" tabindex="0">
                    <div class="ad-plan-drawer-item-left">
                      <div class="ad-plan-drawer-item-name">${escapeHtml(name)}</div>
                      <div class="ad-plan-drawer-item-meta">Default: ${escapeHtml(h)}</div>
                    </div>
                    <button type="button" class="ad-plan-drawer-add" data-template-add="${escapeHtml(type)}">Hinzufügen</button>
                  </div>
                `;
            }).join("");
        }

            function addTemplateByType(type) {
                const t = PLAN_ACTIVITY_TEMPLATES.find(x => String(x?.type || "") === String(type || ""));
                if (!t) return;

                // 0.14.42: Wenn für die Woche noch kein Plan existiert, wird er erst bei der ersten User-Aktion angelegt.
                if (!_adPlanActiveWeekHasStoredPlan && (!Array.isArray(planItems) || planItems.length === 0)) {
                    weekMode = "sessions"; // UI: sessions-only (0.14.75)
                }

                const item = createPlanItemFromTemplate(t, planItems);
                planItems = Array.isArray(planItems) ? planItems.slice() : [];
                planItems.push(item);

                // Step 2: neu hinzugefügtes Item selektieren
                selectedPlanItemId = String(item.id || "") || null;
                targetAddOpen = false; targetAddValue = ""; targetAddError = "";

                scheduleSaveCurrentWeekPlan();
                renderAll();
                setDrawerOpen(false);
                focusPlanValueInput(selectedPlanItemId);
                setStatusTemp(`Hinzugefügt: ${item.name}`);
            }

            function duplicateItemById(id) {
                const idx = (Array.isArray(planItems) ? planItems : []).findIndex(x => String(x?.id || "") === String(id || ""));
                if (idx < 0) return;

                const src = planItems[idx];
                const base = stripNameSuffix(src?.name);

                const srcParams = (src && src.params) ? { ...src.params } : undefined;
                if (srcParams && Array.isArray(srcParams.targets)) srcParams.targets = srcParams.targets.slice();

                const copy = {
                    id: makePlanId(),
                    type: String(src?.type || "CUSTOM"),
                    name: nextUniqueName(base, planItems),
                    targetMinutes: clampMinutes(Number(src?.targetMinutes)),
                    targetSessions: (Number.isFinite(Number(src?.targetSessions)) ? clampSessions(Number(src?.targetSessions)) : 1),
                    params: srcParams
                };

                // Step 2: Segment Training immer params.targets haben
                if (String(copy.type || "") === "SEGMENT_TRAINING") {
                    const p = copy.params ? { ...copy.params } : {};
                    if (!Array.isArray(p.targets)) p.targets = [];
                    copy.params = p;
                }

                planItems = planItems.slice();
                planItems.splice(idx + 1, 0, copy);

                // Step 2: Duplikat selektieren
                selectedPlanItemId = String(copy.id || "") || null;
                targetAddOpen = false; targetAddValue = ""; targetAddError = "";

                scheduleSaveCurrentWeekPlan();
                renderAll();
                focusPlanValueInput(selectedPlanItemId);
                setStatusTemp("Dupliziert.");
            }

            function deleteItemById(id) {
                const arr = Array.isArray(planItems) ? planItems : [];
                const sId = String(id || "");
                const idx = arr.findIndex(x => String(x?.id || "") === sId);
                if (idx < 0) return;

                const next = arr.filter(x => String(x?.id || "") !== sId);
                planItems = next;

                // Step 2: Wenn selektiertes Item gelöscht wird -> nächstes, sonst vorheriges, sonst null
                if (String(selectedPlanItemId || "") === sId) {
                    const pick = next[idx] || next[idx - 1] || null;
                    selectedPlanItemId = pick ? String(pick.id || "") : null;
                    targetAddOpen = false; targetAddValue = ""; targetAddError = "";
                }

                scheduleSaveCurrentWeekPlan();
                renderAll();
                setStatusTemp("Gelöscht.");
            }

            // Initial render (Week-Pläne sind pro Woche gespeichert)
            refreshSidebarWeekOptions();
            ensureSidebarWeekPlanLoaded(true);

            statusEl.textContent = "Bereit.";
            renderAll();

            // Bind: "+ Aktivität"
            if (btnAdd) {
                btnAdd.onclick = () => setDrawerOpen(true);
            }


            // Bind: "Vorwoche kopieren"
            if (btnCopyPrevWeek) {
                btnCopyPrevWeek.onclick = () => copyPrevWeekPlanIntoCurrent();
            }

            // Bind: "Woche zurücksetzen"
            if (btnResetWeek) {
                btnResetWeek.onclick = () => resetCurrentWeekPlan();
            }

            // -------------------------------------------------------------------
            // Import / Export: Plan speichern & laden (0.14.75)
            // -------------------------------------------------------------------
            function buildExportFilenameFromWeekKey(wkKey) {
                try {
                    const r = weekRangeFromWeekKey(wkKey);
                    const y = Number(r?.isoYear);
                    const w = String(r?.week ?? "").padStart(2, "0");
                    if (Number.isFinite(y) && w) return `trainingplan-KW${w}-${y}.json`;
                } catch {}
                return "trainingplan.json";
            }

            function triggerTextDownload(filename, text, mime = "application/json") {
                try {
                    const blob = new Blob([String(text ?? "")], { type: mime + ";charset=utf-8" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = String(filename || "download.json");
                    a.style.display = "none";
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    setTimeout(() => { try { URL.revokeObjectURL(url); } catch {} }, 0);
                } catch (e) {
                    // ignore
                }
            }

            function pickJsonFile(cb) {
                try {
                    const inp = document.createElement("input");
                    inp.type = "file";
                    inp.accept = "application/json,.json";
                    inp.style.display = "none";
                    document.body.appendChild(inp);
                    inp.onchange = () => {
                        try {
                            const f = inp.files && inp.files[0];
                            inp.remove();
                            if (!f) return;
                            cb && cb(f);
                        } catch (e) {
                            try { inp.remove(); } catch {}
                        }
                    };
                    inp.click();
                } catch (e) {
                    // ignore
                }
            }

            function sanitizeImportedPlanItem(src) {
                const it = (src && typeof src === "object") ? src : {};
                const type = String(it.type || "CUSTOM").trim() || "CUSTOM";
                const name = String(it.name || "").trim() || type;
                const targetMinutes = clampMinutes(Number(it.targetMinutes) || 0);
                let targetSessions = 1;
                if ("targetSessions" in it) {
                    const n = Number(it.targetSessions);
                    targetSessions = Number.isFinite(n) ? clampSessions(n) : 1;
                }

                let params = (it.params && typeof it.params === "object") ? { ...it.params } : undefined;
                if (params && Array.isArray(params.targets)) {
                    const seen = new Set();
                    const out = [];
                    for (const raw of params.targets) {
                        const t = normalizeTarget(raw);
                        if (!t) continue;
                        if (seen.has(t)) continue;
                        seen.add(t);
                        out.push(t);
                    }
                    params = { ...params, targets: out };
                }

                if (type === "SEGMENT_TRAINING") {
                    const p = params ? { ...params } : {};
                    if (!Array.isArray(p.targets)) p.targets = [];
                    params = p;
                }

                const out = { id: makePlanId(), type, name, targetMinutes, targetSessions };
                if (params && typeof params === "object" && Object.keys(params).length) out.params = params;
                return out;
            }

            // Bind: "Plan speichern" (Export)
            if (btnSavePlan) {
                btnSavePlan.onclick = () => {
                    try {
                        const wkKey = ensureSidebarSelectedWeekKey();
                        const weekId = weekIdFromWeekKey(wkKey);
                        if (!wkKey || !weekId) return setStatusTemp("Keine Woche gewählt.");

                        ensureSidebarWeekPlanLoaded(false);

                        // ensure latest notes are included in export (0.14.197)
                        try {
                            const ed = side.querySelector("#adPlanNotesEditor");
                            if (ed) planNotesHtml = String(ed.innerHTML || "");
                        } catch (e) {}

                        const exportObj = {
                            kind: "autodarts-segmentdash-trainingplan",
                            schemaVersion: 1,
                            exportedAt: new Date().toISOString(),
                            weekMode: normalizeWeekMode(weekMode),
                            planItems: sanitizePlanItemsForStorage(planItems),
                            notesHtml: normalizeNotesHtml(planNotesHtml),
                        };

                        const json = JSON.stringify(exportObj, null, 2);
                        triggerTextDownload(buildExportFilenameFromWeekKey(wkKey), json, "application/json");
                        setStatusTemp("Plan exportiert.");
                    } catch (e) {
                        setStatusTemp("Export fehlgeschlagen.");
                    }
                };
            }

            // Bind: "Plan laden" (Import)
            if (btnLoadPlan) {
                btnLoadPlan.onclick = () => {
                    try {
                        const wkKey = ensureSidebarSelectedWeekKey();
                        const weekId = weekIdFromWeekKey(wkKey);
                        if (!wkKey || !weekId) return setStatusTemp("Keine Woche gewählt.");

                        if (!confirm("Plan laden? Aktueller Wochenplan wird überschrieben.")) return;

                        pickJsonFile((file) => {
                            const reader = new FileReader();
                            reader.onerror = () => setStatusTemp("Datei konnte nicht gelesen werden.");
                            reader.onload = () => {
                                let obj = null;
                                try {
                                    obj = JSON.parse(String(reader.result ?? ""));
                                } catch (e) {
                                    setStatusTemp("Ungültige Plan-Datei.");
                                    return;
                                }

                                const kind = String(obj?.kind || "");
                                const ver = Number(obj?.schemaVersion);
                                const wm = String(obj?.weekMode || "");
                                const itemsIn = Array.isArray(obj?.planItems) ? obj.planItems : null;

                                if (kind !== "autodarts-segmentdash-trainingplan" || ver !== 1 || !itemsIn || (wm !== "time" && wm !== "sessions")) {
                                    setStatusTemp("Ungültige Plan-Datei.");
                                    return;
                                }

                                try {
                                    // Ensure sidebar state ready
                                    ensureSidebarWeekPlanLoaded(false);

                                    // Replace in-memory plan
                                    weekMode = "sessions"; // UI: sessions-only (0.14.75)
                                    planItems = itemsIn.map(sanitizeImportedPlanItem);
                                    if (wm === "time") {
                                        const denom = Number(PLAN_SESSION_MINUTES) || 30;
                                        planItems = planItems.map((it) => {
                                            const minutes = clampMinutes(Number(it?.targetMinutes) || 0);
                                            const sess = minutes > 0 ? clampSessions(Math.max(1, Math.round(minutes / denom))) : 0;
                                            return { ...it, targetSessions: sess };
                                        });
                                    }
                                    selectedPlanItemId = planItems.length ? String(planItems[0].id || "") : null;
                                    targetAddOpen = false;
                                    targetAddValue = "";
                                    targetAddError = "";

                                    planNotesHtml = normalizeNotesHtml(obj?.notesHtml || "");
                                    try {
                                        const ed = side.querySelector("#adPlanNotesEditor");
                                        if (ed) ed.innerHTML = String(planNotesHtml || "");
                                    } catch (e) {}

                                    // Stop pending autosave & force-save now
                                    if (_adPlanSaveTimer) { try { clearTimeout(_adPlanSaveTimer); } catch {} _adPlanSaveTimer = null; }
                                    _adPlanLastSavedWeekId = null;
                                    _adPlanLastSavedJson = null;
                                    _adPlanDirty = true;
                                    _adPlanActiveWeekId = weekId;
                                    flushSaveCurrentWeekPlan();

                                    renderAll();
                                    setStatusTemp("Plan geladen.");
                                } catch (e) {
                                    setStatusTemp("Import fehlgeschlagen.");
                                }
                            };
                            reader.readAsText(file);
                        });
                    } catch (e) {
                        setStatusTemp("Import fehlgeschlagen.");
                    }
                };
            }
            // Helper: Fokus auf Soll-Input (nach Render), abhängig vom weekMode
            function focusPlanValueInput(id) {
                const sId = String(id || "");
                if (!sId) return;
                setTimeout(() => {
                    try {
                        const sel = `input.ad-plan-input[data-id="${cssEscapeAttrValue(sId)}"]`;
                        const inp = table.querySelector(sel);
                        if (inp && inp.focus) {
                            inp.focus();
                            if (inp.select) inp.select();
                        }
                    } catch (e) { /* no-op */ }
                }, 0);
            }

            // Helper: sanfte Konvertierung beim Umschalten (nur wenn Zielwert fehlt/0 ist)
            function assistConvertTargetsForMode(nextMode) {
                const nm = String(nextMode || "");
                const items = Array.isArray(planItems) ? planItems : [];
                if (!items.length) return;

                let any = false;
                const next = items.map((it) => {
                    if (!it) return it;

                    let changed = false;

                    const rawM = Number(it?.targetMinutes);
                    let minutes = clampMinutes(rawM);
                    if (!Number.isFinite(rawM) || minutes !== rawM) changed = true;

                    const rawS = Number(it?.targetSessions);
                    let sessions = clampSessions(rawS);
                    if (Number.isFinite(rawS) && sessions !== rawS) changed = true;

                    if (nm === "sessions") {
                        if (!Number.isFinite(rawS) || rawS <= 0) {
                            // 30 min pro Session (Heuristik)
                            sessions = clampSessions(Math.max(1, Math.round(minutes / PLAN_SESSION_MINUTES)));
                            changed = true;
                        }
                        // in sessions-mode legen wir targetSessions immer an
                        if (changed) {
                            any = true;
                            return { ...it, targetMinutes: minutes, targetSessions: sessions };
                        }
                        return it;
                    }

                    if (nm === "time") {
                        if (!Number.isFinite(rawM) || rawM <= 0) {
                            minutes = clampMinutes(sessions * PLAN_SESSION_MINUTES);
                            changed = true;
                        }
                        if (changed) {
                            any = true;
                            const out = { ...it, targetMinutes: minutes };
                            // targetSessions nur clamped zurückschreiben, wenn es existiert
                            if ("targetSessions" in (it || {}) || Number.isFinite(rawS)) out.targetSessions = sessions;
                            return out;
                        }
                        return it;
                    }

                    return it;
                });

                if (any) planItems = next;
            };

            // 0.14.41: Sidebar folgt globalen Controls (Hauptpanel) – Controls nur Anzeige
            try {
                if (btnTime) btnTime.disabled = true;
                if (btnSessions) btnSessions.disabled = true;
                if (chk) chk.disabled = true;
            } catch {}
            try { if (btnTime) btnTime.onclick = null; } catch {}
            try { if (btnSessions) btnSessions.onclick = null; } catch {}
            try { if (chk) chk.onchange = null; } catch {}



            // -------------------------------------------------------------------
            // Drag & Drop Sorting (0.14.46)
            // -------------------------------------------------------------------
            function arrayMove(arr, from, to) {
                const a = (Array.isArray(arr) ? arr : []).slice();
                if (from < 0 || to < 0 || from >= a.length || to >= a.length) return a;
                const [x] = a.splice(from, 1);
                a.splice(to, 0, x);
                return a;
            }

            function rerenderMainTrainingPlan() {
                try {
                    const weeks = cache._training_weeksAsc || computeTrainingWeeksAsc();
                    cache._training_weeksAsc = weeks;
                    renderTrainingPlan(panel, weeks);
                } catch {}
            }

            let _adPlanDraggedId = null;
            let _adPlanDraggedRowEl = null;
            let _adPlanDropTargetEl = null;

            function clearPlanDragStyles() {
                try { _adPlanDraggedRowEl?.classList?.remove("ad-dragging"); } catch {}
                try { _adPlanDropTargetEl?.classList?.remove("ad-drop-target"); } catch {}
                _adPlanDraggedId = null;
                _adPlanDraggedRowEl = null;
                _adPlanDropTargetEl = null;
            }

            let _adPlanTargetDragged = null;
            let _adPlanTargetDraggedEl = null;
            let _adPlanTargetDropEl = null;

            function clearTargetDragStyles() {
                try { _adPlanTargetDraggedEl?.classList?.remove("ad-dragging"); } catch {}
                try { _adPlanTargetDropEl?.classList?.remove("ad-drop-target"); } catch {}
                _adPlanTargetDragged = null;
                _adPlanTargetDraggedEl = null;
                _adPlanTargetDropEl = null;
            }



            // Table events: change Soll + row actions

            // Table events: change Soll + row actions
            table.oninput = (ev) => {
                const t = ev && ev.target;
                if (!t || !t.classList || !t.classList.contains("ad-plan-input")) return;

                const id = String(t.dataset.id || "");
                if (!id) return;

                const raw = String(t.value ?? "").trim();
                const cleaned = raw.replace(/\s+/g, "").replace(",", ".");

                const idx = planItems.findIndex(x => String(x?.id || "") === id);
                if (idx < 0) return;

                const agg = getTrackerAggForSelectedWeek();

                if (getSidebarViewMode() === "sessions") {
                    const v = clampSessions(Number(cleaned));

                    planItems = planItems.slice();
                    planItems[idx] = { ...planItems[idx], targetSessions: v };

                    // normalize visible input (UI-only)
                    if (String(v) !== String(raw)) t.value = String(v);

                    // Update footer total (Soll)
                    const totals = computeSidebarTotals(agg);
                    const totalValEl = side.querySelector("#adPlanTotalSoll");
                    const totalUnitEl = side.querySelector("#adPlanTotalSollUnit");
                    if (totalValEl) totalValEl.textContent = String(Math.round(totals.goal));
                    if (totalUnitEl) totalUnitEl.textContent = "LEGS";
                } else {
                    // legacy fallback
                    const mins = clampMinutes(parseInt(cleaned, 10) || 0);

                    planItems = planItems.slice();
                    planItems[idx] = { ...planItems[idx], targetMinutes: mins };

                    // normalize visible input (UI-only)
                    if (String(mins) !== String(raw)) t.value = String(mins);

                    // Update footer total (Soll)
                    const totals = computeSidebarTotals(agg);
                    const totalValEl = side.querySelector("#adPlanTotalSoll");
                    const totalUnitEl = side.querySelector("#adPlanTotalSollUnit");
                    if (totalValEl) totalValEl.textContent = String(Math.round(totals.goal));
                    if (totalUnitEl) totalUnitEl.textContent = "min";
                }

                scheduleSaveCurrentWeekPlan();
                renderSummary();

                // 0.14.170: Live-Update der Zeitschätzung (Row + Gesamt + Details)
                try {
                    const estAll2 = getPlanEstimatesAllTime();

                    // Update row estimate cell
                    const cur = planItems[idx];
                    const pt = String(cur?.type || "");
                    const avg2 = estAll2 ? estAll2.avgSecPerLegByType?.[pt] : null;
                    const has2 = Number.isFinite(Number(avg2)) && Number(avg2) > 0;
                    const planned2 = Math.max(0, getTargetSessions(cur));

                    const rowSel = `.ad-plan-row[data-plan-item-id="${cssEscapeAttrValue(id)}"]`;
                    const rowEl = table.querySelector(rowSel);
                    const cellEl = rowEl ? rowEl.querySelector('.ad-plan-est-cell') : null;
                    if (cellEl) {
                        if (planned2 <= 0) cellEl.innerHTML = "—";
                        else if (has2) cellEl.innerHTML = `<span class="ad-plan-est-val">${escapeHtml(fmtHours(Number(avg2) * planned2))}</span>`;
                        else cellEl.innerHTML = `<span class="ad-plan-est-muted">noch kein Training gespielt</span>`;
                    }

                    // Update row per-leg cell
                    const perLegEl = rowEl ? rowEl.querySelector('.ad-plan-perleg-cell') : null;
                    if (perLegEl) {
                        if (has2) perLegEl.innerHTML = `<span class="ad-plan-perleg-val">${escapeHtml(fmtMinPerLeg(Number(avg2)))}</span>`;
                        else perLegEl.innerHTML = "—";
                    }

                    // Update footer total estimate
                    let totalEstSec = 0;
                    let totalEstLegs = 0;
                    let anyPlanned = false;
                    let anyEstimated = false;
                    for (const it2 of (Array.isArray(planItems) ? planItems : [])) {
                        const pt2 = String(it2?.type || "");
                        const avgX = estAll2 ? estAll2.avgSecPerLegByType?.[pt2] : null;
                        const hasX = Number.isFinite(Number(avgX)) && Number(avgX) > 0;
                        const plannedX = Math.max(0, getTargetSessions(it2));
                        if (plannedX <= 0) continue;
                        anyPlanned = true;
                        if (!hasX) continue;
                        anyEstimated = true;
                        totalEstSec += Number(avgX) * plannedX;
                        totalEstLegs += plannedX;
                    }
                    const footCell = table.querySelector('.ad-plan-row--foot .ad-plan-est-cell');
                    if (footCell) {
                        if (!anyPlanned) footCell.innerHTML = "—";
                        else if (anyEstimated) footCell.innerHTML = `<span class="ad-plan-est-val">${escapeHtml(fmtHours(totalEstSec))}</span>`;
                        else footCell.innerHTML = `<span class="ad-plan-est-muted">noch kein Training gespielt</span>`;
                    }

                    
                    const footPerLegCell = table.querySelector('.ad-plan-row--foot .ad-plan-perleg-cell');
                    if (footPerLegCell) {
                        if (!anyPlanned) footPerLegCell.innerHTML = "—";
                        else if (anyEstimated && totalEstLegs > 0 && totalEstSec > 0) footPerLegCell.innerHTML = `<span class="ad-plan-perleg-val">${escapeHtml(fmtMinPerLeg(totalEstSec / totalEstLegs))}</span>`;
                        else footPerLegCell.innerHTML = "—";
                    }

                    // Details refresh if affected
                    if (String(selectedPlanItemId || "") === String(id || "")) {
                        renderPlanDetails();
                    }
                } catch (e) { /* ignore */ }

            };

            table.onclick = (ev) => {
                const btn = ev && ev.target && ev.target.closest ? ev.target.closest("button[data-action]") : null;

                // Row actions
                if (btn) {
                    const action = String(btn.getAttribute("data-action") || "");
                    const id = String(btn.getAttribute("data-id") || "");
                    if (!id) return;

                    if (action === "dup") { duplicateItemById(id); return; }
                    if (action === "del") { deleteItemById(id); return; }
                    return;
                }

                // Step 2: Row selection (click anywhere on the row)
                const row = ev && ev.target && ev.target.closest ? ev.target.closest('.ad-plan-row[data-plan-item-id]') : null;
                if (!row) return;

                const id = String(row.getAttribute("data-plan-item-id") || "");
                if (!id) return;

                setSelectedPlanItemId(id);
            };


            // Drag & Drop (Event Delegation on table)
            table.ondragstart = (ev) => {
                const t = ev && ev.target;
                // Don't start a drag from inputs/buttons
                if (t && t.closest && t.closest("input,button,textarea,select")) return;

                const handle = t && t.closest ? t.closest('.ad-plan-drag-handle') : null;

                // Drag & Drop nur über Handle starten
                if (!handle) return;

                const row = handle && handle.closest ? handle.closest('.ad-plan-row[data-plan-item-id]') : null;
                if (!row) return;

                const id = String(row.getAttribute("data-plan-item-id") || "");
                if (!id) return;

                _adPlanDraggedId = id;
                _adPlanDraggedRowEl = row;
                try { row.classList.add("ad-dragging"); } catch {}

                try {
                    if (ev.dataTransfer) {
                        ev.dataTransfer.setData("text/plain", id);
                        ev.dataTransfer.effectAllowed = "move";
                    }
                } catch {}
            };

            table.ondragover = (ev) => {
                if (!_adPlanDraggedId) return;

                const t = ev && ev.target;
                const row = t && t.closest ? t.closest('.ad-plan-row[data-plan-item-id]') : null;
                if (!row) return;

                ev.preventDefault(); // allow drop

                const id = String(row.getAttribute("data-plan-item-id") || "");
                if (!id || id === _adPlanDraggedId) return;

                try {
                    if (ev.dataTransfer) ev.dataTransfer.dropEffect = "move";
                } catch {}

                if (_adPlanDropTargetEl && _adPlanDropTargetEl !== row) {
                    try { _adPlanDropTargetEl.classList.remove("ad-drop-target"); } catch {}
                }
                _adPlanDropTargetEl = row;
                try { row.classList.add("ad-drop-target"); } catch {}
            };

            table.ondrop = (ev) => {
                if (!_adPlanDraggedId) return;

                ev.preventDefault();

                const t = ev && ev.target;
                const row = t && t.closest ? t.closest('.ad-plan-row[data-plan-item-id]') : null;

                const draggedId = (() => {
                    try {
                        const v = ev?.dataTransfer?.getData?.("text/plain");
                        return String(v || _adPlanDraggedId || "");
                    } catch {
                        return String(_adPlanDraggedId || "");
                    }
                })();

                const targetId = row ? String(row.getAttribute("data-plan-item-id") || "") : "";
                if (!draggedId || !targetId || draggedId === targetId) {
                    clearPlanDragStyles();
                    return;
                }

                const items = Array.isArray(planItems) ? planItems : [];
                const from = items.findIndex(x => String(x?.id || "") === draggedId);
                const to = items.findIndex(x => String(x?.id || "") === targetId);
                if (from < 0 || to < 0 || from === to) {
                    clearPlanDragStyles();
                    return;
                }

                planItems = arrayMove(items, from, to);

                // Save immediately (so main panel reflects order right away)
                scheduleSaveCurrentWeekPlan();
                flushSaveCurrentWeekPlan();

                clearPlanDragStyles();

                // Re-render: sidebar + main panel
                try { cache._planSidebarRerender?.(); } catch {}
                rerenderMainTrainingPlan();
            };

            table.ondragend = () => {
                clearPlanDragStyles();
            };



            // Step 2: Details events (Name + Segment Targets)
            if (details) {
                details.oninput = (ev) => {
                    const t = ev && ev.target;
                    if (!t) return;

                    // Name edit
                    if (t.id === "adPlanDetailName") {
                        const id = String(t.getAttribute("data-id") || "");
                        const value = String(t.value ?? "");

                        updatePlanItemById(id, (cur) => ({ ...cur, name: value }));

                        // Update name in table without full re-render (better UX)
                        const row = table.querySelector(`.ad-plan-row[data-plan-item-id="${cssEscapeAttrValue(id)}"]`);
                        const span = row ? row.querySelector(".ad-plan-activity-name") : null;
                        if (span) {
                            span.textContent = value;
                            span.setAttribute("title", value);
                        }
                        return;
                    }

                    // Target input (live)
                    if (t.id === "adPlanTargetInput") {
                        targetAddValue = String(t.value ?? "");
                        if (targetAddError) {
                            targetAddError = "";
                            renderPlanDetails();
                        }
                        return;
                    }
                };

                details.onclick = (ev) => {
                    const removeBtn = ev && ev.target && ev.target.closest ? ev.target.closest("button[data-remove-target]") : null;
                    if (removeBtn) {
                        const rawTarget = String(removeBtn.getAttribute("data-remove-target") || "");
                        const id = String(selectedPlanItemId || "");
                        if (!id || !rawTarget) return;

                        const it = getPlanItemById(id);
                        if (!it || String(it.type || "") !== "SEGMENT_TRAINING") return;

                        updatePlanItemById(id, (cur) => {
                            const p = cur && cur.params ? { ...cur.params } : {};
                            const arr = Array.isArray(p.targets) ? p.targets.slice() : [];
                            const norm = normalizeTarget(rawTarget);
                            p.targets = arr.filter(x => normalizeTarget(x) !== norm);
                            return { ...cur, params: p };
                        });

                        renderAll();
                        return;
                    }

                    const btn = ev && ev.target && ev.target.closest ? ev.target.closest("button[data-action]") : null;
                    if (!btn) return;

                    const action = String(btn.getAttribute("data-action") || "");
                    const id = String(selectedPlanItemId || "");
                    const it = getPlanItemById(id);

                    if (action === "open-add-target") {
                        targetAddOpen = true;
                        targetAddValue = "";
                        targetAddError = "";
                        renderPlanDetails();
                        return;
                    }

                    if (action === "cancel-add-target") {
                        targetAddOpen = false;
                        targetAddValue = "";
                        targetAddError = "";
                        renderPlanDetails();
                        return;
                    }

                    if (action === "confirm-add-target") {
                        if (!it || String(it.type || "") !== "SEGMENT_TRAINING") return;

                        const existing = (it.params && Array.isArray(it.params.targets)) ? it.params.targets : [];
                        const res = validateTarget(targetAddValue, existing);

                        if (!res.ok) {
                            targetAddError = String(res.error || "Ungültig.");
                            renderPlanDetails();
                            return;
                        }

                        updatePlanItemById(id, (cur) => {
                            const p = cur && cur.params ? { ...cur.params } : {};
                            const arr = Array.isArray(p.targets) ? p.targets.slice() : [];
                            arr.push(res.value);
                            p.targets = arr;
                            return { ...cur, params: p };
                        });

                        targetAddOpen = false;
                        targetAddValue = "";
                        targetAddError = "";
                        renderAll();
                        setStatusTemp(`Target hinzugefügt: ${res.value}`);
                        return;
                    }
                };

                details.onkeydown = (ev) => {
                    const t = ev && ev.target;
                    if (!t) return;

                    if (t.id === "adPlanTargetInput") {
                        if (ev.key === "Enter") {
                            ev.preventDefault();
                            const btn = details.querySelector('button[data-action="confirm-add-target"]');
                            if (btn && btn.click) btn.click();
                        }
                        if (ev.key === "Escape") {
                            ev.preventDefault();
                            targetAddOpen = false;
                            targetAddValue = "";
                            targetAddError = "";
                            renderPlanDetails();
                        }
                    }
                };

                // Drag & Drop: Segment Targets (Details only) (0.14.90)
                details.ondragstart = (ev) => {
                    const t = ev && ev.target;
                    const handle = t && t.closest ? t.closest(".ad-plan-chip-handle") : null;

                    // Drag startet nur über Handle
                    if (!handle) return;

                    const chip = handle && handle.closest ? handle.closest('.ad-plan-chip[data-target]') : null;
                    if (!chip) return;

                    const target = String(chip.dataset.target || "");
                    if (!target) return;

                    _adPlanTargetDragged = target;
                    _adPlanTargetDraggedEl = chip;
                    try { chip.classList.add("ad-dragging"); } catch {}

                    try {
                        if (ev.dataTransfer) {
                            ev.dataTransfer.setData("text/plain", target);
                            ev.dataTransfer.effectAllowed = "move";
                        }
                    } catch {}
                };

                details.ondragover = (ev) => {
                    if (!_adPlanTargetDragged) return;

                    const t = ev && ev.target;
                    const chip = t && t.closest ? t.closest('.ad-plan-chip[data-target]') : null;

                    ev.preventDefault(); // allow drop

                    try {
                        if (ev.dataTransfer) ev.dataTransfer.dropEffect = "move";
                    } catch {}

                    if (!chip || chip === _adPlanTargetDraggedEl) return;

                    if (_adPlanTargetDropEl && _adPlanTargetDropEl !== chip) {
                        try { _adPlanTargetDropEl.classList.remove("ad-drop-target"); } catch {}
                    }
                    _adPlanTargetDropEl = chip;
                    try { chip.classList.add("ad-drop-target"); } catch {}
                };

                details.ondrop = (ev) => {
                    if (!_adPlanTargetDragged) return;

                    ev.preventDefault();

                    const t = ev && ev.target;
                    const targetChip = t && t.closest ? t.closest('.ad-plan-chip[data-target]') : null;

                    const draggedTarget = (() => {
                        try {
                            const v = ev?.dataTransfer?.getData?.("text/plain");
                            return String(v || _adPlanTargetDragged || "");
                        } catch {
                            return String(_adPlanTargetDragged || "");
                        }
                    })();

                    const id = String(selectedPlanItemId || "");
                    const it = getPlanItemById(id);

                    if (!targetChip || !draggedTarget || !it || String(it.type || "") !== "SEGMENT_TRAINING" || !it.params || !Array.isArray(it.params.targets)) {
                        clearTargetDragStyles();
                        return;
                    }

                    const targets = it.params.targets;
                    const from = targets.findIndex(x => normalizeTarget(x) === normalizeTarget(draggedTarget));
                    const to = targets.findIndex(x => normalizeTarget(x) === normalizeTarget(String(targetChip.dataset.target || "")));

                    if (from < 0 || to < 0 || from === to) {
                        clearTargetDragStyles();
                        return;
                    }

                    updatePlanItemById(id, (cur) => {
                        const p = cur && cur.params ? { ...cur.params } : {};
                        const arr = Array.isArray(p.targets) ? p.targets.slice() : [];
                        p.targets = arrayMove(arr, from, to);
                        return { ...cur, params: p };
                    });

                    scheduleSaveCurrentWeekPlan();
                    flushSaveCurrentWeekPlan();
                    renderPlanDetails();

                    clearTargetDragStyles();
                };

                details.ondragend = () => {
                    clearTargetDragStyles();
                };

            }

            // Drawer wiring
            if (overlay) overlay.onclick = () => setDrawerOpen(false);
            if (drawerClose) drawerClose.onclick = () => setDrawerOpen(false);

            if (drawerSearch) {
                drawerSearch.oninput = () => {
                    planDrawerSearch = String(drawerSearch.value || "");
                    renderDrawerList();
                };
            }

            if (drawerList) {
                drawerList.onclick = (ev) => {
                    const addBtn = ev && ev.target && ev.target.closest ? ev.target.closest("button[data-template-add]") : null;
                    if (addBtn) {
                        ev.preventDefault();
                        ev.stopPropagation();
                        addTemplateByType(addBtn.getAttribute("data-template-add"));
                        return;
                    }

                    const item = ev && ev.target && ev.target.closest ? ev.target.closest("[data-template]") : null;
                    if (item) {
                        addTemplateByType(item.getAttribute("data-template"));
                    }
                };

                drawerList.onkeydown = (ev) => {
                    if (!ev || ev.key !== "Enter") return;
                    const item = ev.target && ev.target.closest ? ev.target.closest("[data-template]") : null;
                    if (item) addTemplateByType(item.getAttribute("data-template"));
                };
            }

            // Escape closes drawer (avoid duplicate global listeners by storing a flag on panel)
            if (!panel.__adPlanDrawerKeyHandler) {
                panel.__adPlanDrawerKeyHandler = true;
                panel.addEventListener("keydown", (ev) => {
                    if (!planDrawerOpen) return;
                    if (ev.key === "Escape") {
                        ev.preventDefault();
                        setDrawerOpen(false);
                    }
                });
            }

            // expose for refreshAll(): Tracker reload → Sidebar aktualisieren
            cache._planSidebarRefreshWeeks = refreshSidebarWeekOptions;
            cache._planSidebarRerender = () => { refreshSidebarWeekOptions(); renderAll(); };

            // Ensure drawer reflects current RAM state after SPA re-wires
            setDrawerOpen(planDrawerOpen);
        }


    function wireTrainingPlanInteractions(panel) {
        if (!panel) return;

        const inTimeView = (el) => !!(el && el.closest && el.closest("#ad-ext-view-time"));
        const inTrainingView = (el) => !!(el && el.closest && el.closest("#ad-ext-view-training"));

        const rerenderPlan = () => {
            const weeks = cache._training_weeksAsc || computeTrainingWeeksAsc();
            cache._training_weeksAsc = weeks;
            renderTrainingPlan(panel, weeks);
        };

        const rerenderPlanSidebar = () => {
            try { cache._planSidebarRerender?.(); } catch {}
        };

        const scheduleSaveAndRerender = (immediate = false) => {
            if (cache._plan_saveTimer) clearTimeout(cache._plan_saveTimer);
            const run = () => {
                cache._plan_saveTimer = null;
                saveTrainingPlanState(cache.trainingPlan);
                rerenderPlan();
            };
            if (immediate) run();
            else cache._plan_saveTimer = setTimeout(run, 300);
        };

        const parseCommit = (raw) => {
            const s = String(raw || "").trim();
            if (!s) return 0;
            let cleaned = s.replace(/\s+/g, "").replace(",", ".");
            cleaned = cleaned.replace(/[.,]$/, "");
            const v = Number(cleaned);
            if (!Number.isFinite(v)) return 0;
            if (v < 0) return 0;
            return v;
        };

        const commitPlanInput = (input, force = false) => {
            if (!input) return false;
            const type = String(input.dataset.planType || "").trim();
            if (!type) return false;

            cache.trainingPlan = cache.trainingPlan || loadTrainingPlanState();
            const st = cache.trainingPlan;

            const basis = "SESS"; // sessions-only UI (0.14.75)
            st.basis = "SESS";

            const raw = String(input.value || "");
            let v = parseFlexibleNumberInput(raw);

            if (!Number.isFinite(v)) {
                if (!force) return false;
                v = parseCommit(raw);
            }

            if (!Number.isFinite(v)) v = 0;
            if (v < 0) v = 0;

            if (basis === "SESS") v = Math.round(v);

            if (!st.goals) st.goals = { TIME: {}, SESS: {} };
            if (!st.goals.TIME) st.goals.TIME = {};
            if (!st.goals.SESS) st.goals.SESS = {};
            if (!st.targets) st.targets = { TIME: {}, SESS: {} };
            if (!st.targets.TIME) st.targets.TIME = {};
            if (!st.targets.SESS) st.targets.SESS = {};

            if (type === "activity") {
                const k = String(input.dataset.activityKey || "").trim();
                if (!k) return false;
                st.goals[basis][k] = v;
                return true;
            }
            if (type === "target") {
                const t = String(input.dataset.target || "").trim();
                if (!t) return false;
                st.targets[basis][t] = v;
                return true;
            }

            return false;
        };

        // Basis toggle + week selection
        panel.addEventListener("click", (ev) => {
            const t = ev.target;

            // segmented control (Training-Tab)
            const btn = t && t.closest ? t.closest(".ad-ext-segbtn") : null;
            if (btn && inTrainingView(btn) && btn.closest("#ad-ext-plan-basis")) {
                cache.trainingPlan = cache.trainingPlan || loadTrainingPlanState();
                const st = cache.trainingPlan;

                const basis = normalizePlanBasis(btn.dataset.basis);
                if (basis !== st.basis) {
                    st.basis = basis;
                    saveTrainingPlanState(st);
                }
                rerenderPlan();
                rerenderPlanSidebar();
                return;
            }

            // week row click (Zeit Tracker → Wochenübersicht)
            const tr = t && t.closest ? t.closest("#ad-ext-time-week-body tr[data-week-key]") : null;
            if (tr && inTimeView(tr)) {
                const wk = String(tr.getAttribute("data-week-key") || "").trim();
                if (!wk) return;

                cache.trainingPlan = cache.trainingPlan || loadTrainingPlanState();
                const st = cache.trainingPlan;
                st.selectedWeekKey = wk;
                saveTrainingPlanState(st);

                rerenderPlan();
                rerenderPlanSidebar();

                // Re-render time tab to update row highlight (Plan wird im Training-Tab gerendert)
                if (cache?.loaded) renderTimeTab(panel);
                return;
            }
        });

        // week select + checkbox
        panel.addEventListener("change", (ev) => {
            const t = ev.target;
            if (!t) return;

            if (t && t.id === "ad-ext-plan-week-select" && inTrainingView(t)) {
                const wk = String(t.value || "").trim();
                cache.trainingPlan = cache.trainingPlan || loadTrainingPlanState();
                const st = cache.trainingPlan;
                st.selectedWeekKey = wk || null;
                saveTrainingPlanState(st);
                rerenderPlan();
                rerenderPlanSidebar();
                return;
            }
        });

        // inputs (debounced save)
        panel.addEventListener("input", (ev) => {
            const t = ev.target;
            if (!t || !inTrainingView(t)) return;

            const inp = t && t.matches ? (t.matches("input.ad-ext-plan-input") ? t : null) : null;
            if (!inp) return;

            const changed = commitPlanInput(inp, false);
            if (changed) scheduleSaveAndRerender(false);
        });

        // commit on blur (capture), so "1," won't get stuck
        panel.addEventListener("blur", (ev) => {
            const t = ev.target;
            if (!t || !inTrainingView(t)) return;

            const inp = t && t.matches ? (t.matches("input.ad-ext-plan-input") ? t : null) : null;
            if (!inp) return;

            const changed = commitPlanInput(inp, true);
            if (changed) scheduleSaveAndRerender(true);
        }, true);

        // Enter key commits
        panel.addEventListener("keydown", (ev) => {
            const t = ev.target;
            if (!t || !inTrainingView(t)) return;

            const inp = t && t.matches ? (t.matches("input.ad-ext-plan-input") ? t : null) : null;
            if (!inp) return;

            if (ev.key === "Enter") {
                ev.preventDefault();
                inp.blur();
            }
        });

        // Trainingsdaten-Table: Accordion "Ist"-Details pro Aktivität (0.14.59)
        const planTbody = panel.querySelector("#ad-ext-plan-main-body");
        if (planTbody && !planTbody.__adExtTrainDetailsWired) {
            planTbody.__adExtTrainDetailsWired = true;

            // Detail-Render: robuste Numerik/Quoten (0.14.59)
            const getMaybeNum = (rec, keys) => {
                for (const k of (keys || [])) {
                    const v = rec?.[k];
                    const n = Number(v);
                    if (Number.isFinite(n)) return n;
                }
                return null;
            };
            const getNum = (rec, keys) => {
                const v = getMaybeNum(rec, keys);
                return (v === null) ? 0 : v;
            };

            const fmtPctMaybe01 = (pct) => {
                const n = Number(pct);
                if (!Number.isFinite(n)) return "—";
                const r = Math.round(n * 10) / 10;
                return `${r.toFixed(1).replace(/\.0$/, "")}%`;
            };

            const fmtNumMaybe01 = (val) => {
                const n = Number(val);
                if (!Number.isFinite(n)) return "—";
                const r = Math.round(n * 10) / 10;
                return r.toFixed(1).replace(/\.0$/, "");
            };

            const computePerfTexts = (rec) => {
                // Trefferquote
                const hrPref = getMaybeNum(rec, ["hitRatePct", "hitRate", "hitRatePercent", "hitRatePercentage"]);
                let hrPct = null;
                if (hrPref !== null) {
                    hrPct = (hrPref <= 1.0) ? (hrPref * 100) : hrPref;
                } else {
                    const hits = getMaybeNum(rec, ["hits", "hit", "hitCount", "totalHits"]);
                    const attempts = getMaybeNum(rec, ["attempts", "throws", "totalThrows", "darts", "total"]);
                    if (attempts !== null && attempts > 0 && hits !== null) hrPct = (hits / attempts) * 100;
                }

                // Hits/min
                const hpmPref = getMaybeNum(rec, ["hitsPerMin", "hitsPerMinute", "hpm", "hitsMin"]);
                let hpm = null;
                if (hpmPref !== null) {
                    hpm = hpmPref;
                } else {
                    const hits = getMaybeNum(rec, ["hits", "hit", "hitCount", "totalHits"]);
                    const sec = getMaybeNum(rec, ["sec", "seconds", "durationSec"]);
                    if (sec !== null && sec > 0 && hits !== null) hpm = hits / (sec / 60);
                }

                // Checkout-Quote
                const coPref = getMaybeNum(rec, ["checkoutRatePct", "checkoutRate", "checkoutRatePercent", "checkoutRatePercentage"]);
                let coPct = null;
                if (coPref !== null) {
                    coPct = (coPref <= 1.0) ? (coPref * 100) : coPref;
                } else {
                    const coMade = getMaybeNum(rec, ["checkoutHits", "checkouts", "checkoutMade", "coHits"]);
                    const coChances = getMaybeNum(rec, ["checkoutAttempts", "checkoutChances", "coAttempts", "coOpps"]);
                    if (coChances !== null && coChances > 0 && coMade !== null) coPct = (coMade / coChances) * 100;
                }

                return {
                    hitRate: (hrPct === null) ? "—" : fmtPctMaybe01(hrPct),
                    hitsPerMin: (hpm === null) ? "—" : fmtNumMaybe01(hpm),
                    checkoutRate: (coPct === null) ? "—" : fmtPctMaybe01(coPct),
                };
            };

            const closeAll = () => {
                try {
                    planTbody.querySelectorAll("tr.ad-ext-train-row-details").forEach((r) => r.remove());
                    planTbody.querySelectorAll("tr.ad-ext-train-row .ad-ext-rowexp").forEach((s) => { s.textContent = "+"; });
                } catch {}
            };

            planTbody.addEventListener("click", (e) => {
                const tr = e?.target?.closest ? e.target.closest("tr.ad-ext-train-row") : null;
                if (!tr || !planTbody.contains(tr)) return;

                const next = tr.nextElementSibling;
                const isOpen = !!(next && next.classList && next.classList.contains("ad-ext-train-row-details"));

                if (isOpen) {
                    try { next.remove(); } catch {}
                    const icon = tr.querySelector(".ad-ext-rowexp");
                    if (icon) icon.textContent = "+";
                    return;
                }

                closeAll();

                const trackerKey = String(tr.getAttribute("data-tracker-key") || tr.dataset?.trackerKey || "").trim();
                const planType = String(tr.getAttribute("data-plan-type") || tr.dataset?.planType || "").trim();
                const planItemId = String(tr.getAttribute("data-plan-item-id") || tr.dataset?.planItemId || "").trim();

                const weeks = cache._training_weeksAsc || computeTrainingWeeksAsc();
                cache._training_weeksAsc = weeks;
                const selWeekKey2 = ensurePlanSelectedWeekKey(weeks);

                // Segment Training: bei mehreren PlanItems pro Woche Details pro Zeile (0.14.69)
                let pitThisRow = null;
                let stTargetsThisItem = null;
                if (planItemId) {
                    try {
                        const weekId2 = weekIdFromWeekKey(selWeekKey2);
                        const wp2 = loadWeekPlan(weekId2);
                        const its2 =
                              Array.isArray(wp2?.planItems) ? wp2.planItems :
                        (Array.isArray(wp2?.items) ? wp2.items :
                         (Array.isArray(wp2) ? wp2 : []));
                        pitThisRow = its2.find(x => String(x?.id || "") === planItemId) || null;

                        if (planType === "SEGMENT_TRAINING") {
                            const raw = pitThisRow?.params?.targets;
                            if (Array.isArray(raw) && raw.length) {
                                const seen = new Set();
                                const out = [];
                                for (const t of raw) {
                                    const k = String(t || "").trim().toUpperCase().replace(/\s+/g, "");
                                    if (!k) continue;
                                    if (seen.has(k)) continue;
                                    seen.add(k);
                                    out.push(k);
                                }
                                if (out.length) stTargetsThisItem = out;
                            }
                        }
                    } catch {}
                }

                const agg = aggregateTrainingActualsForWeek(selWeekKey2);
                const byActivity2 = agg?.byActivity;
                const stTargets2 = agg?.stTargets;

                let rec = (byActivity2 && byActivity2.get) ? (byActivity2.get(trackerKey) || { sec: 0, count: 0 }) : { sec: 0, count: 0 };

                // Segment Training: Ist-Werte pro PlanItem (Targets) statt globaler Activity-Summe (0.14.69)
                if (planType === "SEGMENT_TRAINING" && Array.isArray(stTargetsThisItem) && stTargetsThisItem.length && stTargets2 && stTargets2.get) {
                    try {
                        let secSum = 0;
                        let cntSum = 0;
                        for (const t0 of stTargetsThisItem) {
                            const t = String(t0 || "").trim();
                            if (!t) continue;
                            const a = stTargets2.get(t) || { sec: 0, count: 0 };
                            secSum += Number(a?.sec || 0) || 0;
                            cntSum += Number(a?.count || 0) || 0;
                        }
                        rec = { sec: secSum, count: cntSum };
                    } catch {}
                }
                const min = toIntMinutes(rec?.sec);
                const sess = Math.max(0, Math.round(Number(rec?.count || 0) || 0));

                const isX01 = (planType === "X01_BOT" || planType === "X01_HUMAN" || trackerKey === "X01_BOT" || trackerKey === "X01_HUMAN");


                let perfRec = rec;
                if (!isX01 && planType === "SEGMENT_TRAINING") {
                    // Fallback: Segment-Targets liefern Hits/Darts → für Gesamt-Perf nutzen (wenn im Activity-Rec nicht vorhanden)
                    try {
                        const hasHits = getMaybeNum(rec, ["hits", "hit", "hitCount", "totalHits"]) !== null;
                        const hasAtt = getMaybeNum(rec, ["attempts", "throws", "totalThrows", "darts", "total"]) !== null;
                        const hasHr = getMaybeNum(rec, ["hitRatePct", "hitRate", "hitRatePercent", "hitRatePercentage"]) !== null;
                        const hasHpm = getMaybeNum(rec, ["hitsPerMin", "hitsPerMinute", "hpm", "hitsMin"]) !== null;

                        if (!hasHits || !hasAtt || (!hasHr && !hasHpm)) {
                            let sumHits = 0, sumDarts = 0, any = false;

                            if (Array.isArray(stTargetsThisItem) && stTargetsThisItem.length && stTargets2 && stTargets2.get) {
                                for (const target0 of stTargetsThisItem) {
                                    const t = String(target0 || "").trim();
                                    if (!t || t === "DRandom" || t === "SRandom") continue;
                                    const r = stTargets2.get(t);
                                    if (!r) continue;
                                    any = true;
                                    sumHits += getNum(r, ["hits", "hit", "hitCount", "totalHits"]);
                                    sumDarts += getNum(r, ["darts", "attempts", "throws", "totalThrows", "total"]);
                                }
                            } else if (stTargets2 && stTargets2.forEach) {
                                stTargets2.forEach((r, target) => {
                                    const t = String(target || "").trim();
                                    if (!t || t === "DRandom" || t === "SRandom") return;
                                    any = true;
                                    sumHits += getNum(r, ["hits", "hit", "hitCount", "totalHits"]);
                                    sumDarts += getNum(r, ["darts", "attempts", "throws", "totalThrows", "total"]);
                                });
                            }

                            if (any) {
                                perfRec = Object.assign({}, rec);
                                if (getMaybeNum(perfRec, ["hits", "hit", "hitCount", "totalHits"]) === null) perfRec.hits = sumHits;
                                if (getMaybeNum(perfRec, ["attempts", "throws", "totalThrows", "darts", "total"]) === null) perfRec.darts = sumDarts;
                            }
                        }
                    } catch {}
                }

                let inner = "";
                if (isX01) {
                    const legs = Math.max(0, Math.round(Number(rec?.count || 0) || 0));
                    inner = `<div class="ad-ext-train-details-summary">Ist gesamt: ${escapeHtml(String(min))}min · ${escapeHtml(String(legs))} Legs</div>`;

                    // X01 Ist-Details: Matches/Won/Lost/Checkout (0.14.60)
                    try {
                        const wk2 = agg?.wk || weekRangeFromWeekKey(selWeekKey2);
                        const inWeek2 = (dk) => {
                            const s = String(dk || "");
                            return s && wk2 && s >= wk2.startKey && s <= wk2.endKey;
                        };

                        const wantBot = (planType === "X01_BOT" || trackerKey === "X01_BOT");
                        const wantKind = wantBot ? "BOT" : "HUMAN";
                        const meKey = cache?._x01_context?.effectivePlayerKey || null;

                        let matchCount = 0;
                        let sumWon = 0;
                        let sumLost = 0;
                        let coOpp = 0;
                        let coHit = 0;
                        let botLvlCounts = wantBot ? new Map() : null;
                        const normBotLvl = (nm) => {
                            const s = String(nm || "").trim();
                            if (!s) return null;
                            const t = s.replace(/^bot\s*level\s*/i, "").trim();
                            return t || s;
                        };

                        for (const m of (cache.x01Matches || [])) {
                            if (!m) continue;
                            const dk = m.dayKey || parseIsoDateToDayKey(m.createdAt) || parseIsoDateToDayKey(m.finishedAt);
                            if (!inWeek2(dk)) continue;

                            const kind = classifyX01MatchKind(m);
                            if (wantKind === "BOT") {
                                if (kind !== "BOT") continue;
                            } else {
                                if (kind === "BOT") continue;
                            }

                            const players = Array.isArray(m.players) ? m.players : [];

                            if (botLvlCounts) {
                                const bp = players.find(p => isBotLevelPlayerName(p?.name));
                                const lvl = normBotLvl(bp?.name);
                                if (lvl) botLvlCounts.set(lvl, (botLvlCounts.get(lvl) || 0) + 1);
                            }

                            let meIdx = -1;
                            if (meKey) {
                                const i = players.findIndex(p => String(p?.key || "") === String(meKey));
                                if (i >= 0) meIdx = Number.isFinite(Number(players[i]?.index)) ? Number(players[i].index) : i;
                            }

                            if (meIdx < 0 && wantKind === "BOT" && players.length) {
                                const i = players.findIndex(p => !isBotLikePlayerName(p?.name));
                                if (i >= 0) meIdx = Number.isFinite(Number(players[i]?.index)) ? Number(players[i].index) : i;
                            }

                            if (meIdx < 0) meIdx = 0;

                            const totalLegs = Number(m.totalLegs) ||
                                  (Array.isArray(m.legsWon) ? m.legsWon.reduce((a, b) => a + (Number(b || 0) || 0), 0) : 0) ||
                                  0;

                            const legsWon = Number(m.legsWon?.[meIdx] || 0) || 0;
                            const legsLost = Math.max(0, totalLegs - legsWon);

                            matchCount += 1;
                            sumWon += legsWon;
                            sumLost += legsLost;

                            const psArr = asArray(m.perPlayerStats || m.playersStats || m.playerStats);
                            let st = psArr?.[meIdx] || null;
                            if (!st && psArr?.length) {
                                const mePlayerKey = players?.[meIdx]?.key || null;
                                if (mePlayerKey) {
                                    st = psArr.find(s => (s?.playerKey && s.playerKey === mePlayerKey) || (s?.key && s.key === mePlayerKey) || (s?.id && s.id === mePlayerKey)) || null;
                                }
                            }

                            coOpp += Number(st?.checkouts) || 0;
                            coHit += Number(st?.checkoutsHit) || 0;
                        }

                        let botLvl = null;
                        if (botLvlCounts && botLvlCounts.size) {
                            let best = null, bestC = -1;
                            for (const [k, c] of botLvlCounts.entries()) {
                                const cc = Number(c) || 0;
                                if (cc > bestC) { bestC = cc; best = k; }
                            }
                            botLvl = best;
                        }
                        const botLine = (wantBot && botLvl) ? `<div class="ad-ext-train-details-perf">Bot-Level: ${escapeHtml(String(botLvl))}</div>` : "";

                        const coPct = (coOpp > 0) ? ((coHit / coOpp) * 100) : null;
                        const coTxt = (coPct === null) ? "—" : `${(Math.round(coPct * 10) / 10).toFixed(1).replace(/\.0$/, "")}%`;

                        inner += `
                          ${botLine}
                          <div style="margin: 8px 0 6px; font-weight: 900; opacity: 0.92;">X01 (Ist)</div>
                          <table class="ad-ext-train-details-table">
                            <thead><tr>
                              <th>Min</th>
                              <th>Sessions</th>
                              <th>Gewonnen</th>
                              <th>Verloren</th>
                              <th>Checkout</th>
                            </tr></thead>
                            <tbody><tr>
                              <td>${escapeHtml(String(min))}</td>
                              <td>${escapeHtml(String(legs))}</td>
                              <td>${escapeHtml(String(sumWon))}</td>
                              <td>${escapeHtml(String(sumLost))}</td>
                              <td>${escapeHtml(String(coTxt))}</td>
                            </tr></tbody>
                          </table>
                        `;
                    } catch (err) {
                        inner += `<div class="ad-ext-muted" style="opacity:.78;">Keine X01 Details für diese Woche.</div>`;
                    }
                } else {
                    const perf = computePerfTexts(perfRec);
                    inner = `<div class="ad-ext-train-details-summary">Ist gesamt: ${escapeHtml(String(min))}min · ${escapeHtml(String(sess))} Sessions</div>`
                        + `<div class="ad-ext-train-details-perf">Leistung: Trefferquote ${escapeHtml(perf.hitRate)} · Hits/min ${escapeHtml(perf.hitsPerMin)} · Checkout ${escapeHtml(perf.checkoutRate)}</div>`;
                }

                if (planType === "SEGMENT_TRAINING") {
                    const tRows = [];
                    const hasPlanTargets = !!(Array.isArray(stTargetsThisItem) && stTargetsThisItem.length && stTargets2 && stTargets2.get);
                    try {
                        if (hasPlanTargets) {
                            for (const target0 of stTargetsThisItem) {
                                const t = String(target0 || "").trim();
                                if (!t || t === "DRandom" || t === "SRandom") continue;
                                const r = stTargets2.get(t) || { sec: 0, count: 0, hits: 0, darts: 0 };
                                const m = toIntMinutes(r?.sec);
                                const c = Math.max(0, Math.round(Number(r?.count || 0) || 0));
                                const p = computePerfTexts(r);
                                tRows.push({ target: t, min: m, sess: c, perf: p });
                            }
                        } else if (stTargets2 && stTargets2.forEach) {
                            stTargets2.forEach((r, target) => {
                                const t = String(target || "").trim();
                                if (!t || t === "DRandom" || t === "SRandom") return;
                                const m = toIntMinutes(r?.sec);
                                const c = Math.max(0, Math.round(Number(r?.count || 0) || 0));
                                if (m <= 0 && c <= 0) return;
                                const p = computePerfTexts(r);
                                tRows.push({ target: t, min: m, sess: c, perf: p });
                            });
                        }
                    } catch {}

                    if (!hasPlanTargets) {
                        tRows.sort((a, b) => (b.min - a.min) || (b.sess - a.sess) || String(a.target).localeCompare(String(b.target)));
                    }

                    if (!tRows.length) {
                        inner += `<div class="ad-ext-muted" style="opacity:.78;">Keine Segment-Details für diese Woche.</div>`;
                    } else {
                        inner += `
                          <div style="font-weight:900; margin: 6px 0 6px;">Targets (Ist)</div>
                          <table class="ad-ext-train-details-table">
                            <thead><tr>
                              <th>Target</th>
                              <th>Min</th>
                              <th>Sessions</th>
                              <th>Trefferquote</th>
                              <th>Hits/min</th>
                              <th>Checkout</th>
                            </tr></thead>
                            <tbody>
                              ${tRows.map(r => `
                                <tr>
                                  <td>${escapeHtml(r.target)}</td>
                                  <td>${escapeHtml(String(r.min))}</td>
                                  <td>${escapeHtml(String(r.sess))}</td>
                                  <td>${escapeHtml(String(r?.perf?.hitRate ?? "—"))}</td>
                                  <td>${escapeHtml(String(r?.perf?.hitsPerMin ?? "—"))}</td>
                                  <td>${escapeHtml(String(r?.perf?.checkoutRate ?? "—"))}</td>
                                </tr>
                              `).join("")}
                            </tbody>
                          </table>
                        `;
                    }
                }

                const colCount = Math.max(1, (tr.children && tr.children.length) ? tr.children.length : 4);

                const detailsTr = document.createElement("tr");
                detailsTr.className = "ad-ext-train-row-details";
                detailsTr.innerHTML = `<td colspan="${colCount}"><div class="ad-ext-train-details-box">${inner}</div></td>`;

                tr.insertAdjacentElement("afterend", detailsTr);

                const icon = tr.querySelector(".ad-ext-rowexp");
                if (icon) icon.textContent = "–";
            });
        }
}

    function wireSegmentFilters(panel) {
        const selType = panel.querySelector("#ad-ext-filter-segtype");
        const selRange = panel.querySelector("#ad-ext-filter-daterange");

        if (selType) {
            selType.value = cache.filters.segmentType;
            selType.addEventListener("change", () => {
                cache.filters.segmentType = selType.value;
                if (cache.loaded) renderSegmentTraining(panel, cache.sessions, cache.filters, cache.meta);
            });
        }

        if (selRange) {
            selRange.value = cache.filters.dateRange;
            selRange.addEventListener("change", () => {
                cache.filters.dateRange = selRange.value;
                if (cache.loaded) renderSegmentTraining(panel, cache.sessions, cache.filters, cache.meta);
            });
        }
    }

    function wireX01Filters(panel) {
        const selPlayer = panel.querySelector("#ad-ext-x01-filter-player");
        const selCombo = panel.querySelector("#ad-ext-x01-filter-combo");
        const selRange = panel.querySelector("#ad-ext-x01-filter-daterange");

        if (selRange) {
            selRange.value = cache.filtersX01.dateRange;
            selRange.addEventListener("change", () => {
                cache.filtersX01.dateRange = selRange.value;
                localStorage.setItem("ad_ext_x01_dateRange", cache.filtersX01.dateRange);
                cache.filtersX01.kpiSelectedKey = null;
                if (cache.loaded) renderX01(panel);
            });
        }

        if (selPlayer) {
            selPlayer.value = cache.filtersX01.playerKey;
            selPlayer.addEventListener("change", () => {
                cache.filtersX01.playerKey = selPlayer.value;
                localStorage.setItem("ad_ext_x01_playerKey", cache.filtersX01.playerKey);

                cache.filtersX01.comboKey = "AUTO_TOP";
                localStorage.setItem("ad_ext_x01_comboKey", "AUTO_TOP");
                if (selCombo) selCombo.value = "AUTO_TOP";

                cache.filtersX01.kpiSelectedKey = null;

                if (cache.loaded) renderX01(panel);
            });
        }

        if (selCombo) {
            selCombo.value = cache.filtersX01.comboKey || "AUTO_TOP";
            selCombo.addEventListener("change", () => {
                cache.filtersX01.comboKey = selCombo.value;
                localStorage.setItem("ad_ext_x01_comboKey", cache.filtersX01.comboKey);

                cache.filtersX01.kpiSelectedKey = null;

                if (cache.loaded) renderX01(panel);
            });
        }
    }


    function wireMasterHofFilters(panel) {
        const selPlayer = panel.querySelector("#ad-ext-master-filter-player");
        const btnBots = panel.querySelector("#ad-ext-master-include-bots");
        const lblBots = panel.querySelector("#ad-ext-master-bots-switch-label");

        const setBotsUI = (visible) => {
            if (!btnBots) return;
            const v = !!visible;
            btnBots.setAttribute("aria-checked", v ? "true" : "false");
            btnBots.dataset.adExtChecked = v ? "1" : "0";
            if (lblBots) {
                lblBots.textContent = v ? "An" : "Aus";
                lblBots.dataset.adExtOn = v ? "1" : "0";
            }
        };

        const getBotsUI = () => {
            if (!btnBots) return false;
            return btnBots.getAttribute("aria-checked") === "true" || btnBots.dataset.adExtChecked === "1";
        };

        if (btnBots) {
            setBotsUI(!!cache.filtersMasterHof.includeBots);
            btnBots.addEventListener("click", () => {
                const next = !getBotsUI();
                setBotsUI(next);
                cache.filtersMasterHof.includeBots = next;
                localStorage.setItem("ad_ext_master_includeBots", next ? "1" : "0");
                if (cache.loaded) renderMasterHallOfFame(panel);
            });
        }

        if (!selPlayer) return;

        selPlayer.value = cache.filtersMasterHof.playerKey || "AUTO";
        selPlayer.addEventListener("change", () => {
            cache.filtersMasterHof.playerKey = selPlayer.value;
            localStorage.setItem("ad_ext_master_playerKey", cache.filtersMasterHof.playerKey);

            if (cache.loaded) renderMasterHallOfFame(panel);
        });
    }





    function syncX01SubPanels(panel) {
        const x01Panel = panel.querySelector("#ad-ext-view-x01");
        if (!x01Panel) return;

        const key = String(cache.filtersX01.subPanel || "liga").toLowerCase();
        const liga = x01Panel.querySelector("#ad-ext-x01-panel-liga");
        const hof = x01Panel.querySelector("#ad-ext-x01-panel-hof");

        if (liga) liga.style.display = (key === "liga") ? "" : "none";
        if (hof) hof.style.display = (key === "hof") ? "" : "none";

        for (const b of x01Panel.querySelectorAll('[data-ad-ext-x01panel]')) {
            const k = String(b.dataset.adExtX01panel || "").toLowerCase();
            b.classList.toggle("ad-ext-segbtn--active", k === key);
        }

        if (key !== "liga") tooltipHide();
    }

    function wireX01SubPanels(panel) {
        const x01Panel = panel.querySelector("#ad-ext-view-x01");
        if (!x01Panel) return;

        for (const b of x01Panel.querySelectorAll('[data-ad-ext-x01panel]')) {
            b.addEventListener("click", () => {
                const k = String(b.dataset.adExtX01panel || "liga").toLowerCase();
                cache.filtersX01.subPanel = k;
                localStorage.setItem("ad_ext_x01_subPanel", k);
                syncX01SubPanels(panel);
                if (cache.loaded) renderX01(panel);
            });
        }

        syncX01SubPanels(panel);
    }


    // =========================
    // Auto-Refresh bei Cache-Update
    // =========================
    // Importer-Script dispatcht:
    //   1) window.dispatchEvent(new CustomEvent("ad-cache-updated", {detail:{matchId,fetchedAt}}))
    //   2) localStorage["ad_cache_updated"] = JSON.stringify({matchId,fetchedAt})
    // Damit kann der Viewer im gleichen Tab UND in anderen Tabs automatisch refreshen.
    const AD_EXT_CACHE_UPDATED_EVENT = "ad-cache-updated";
    const AD_EXT_CACHE_UPDATED_LS_KEY = "ad_cache_updated";
    const AD_EXT_AUTO_REFRESH_THROTTLE_MS = 1500; // 1–2s (De-Dupe)

    // =========================
    // Importer-UI Toggle (Konsole ein/aus)
    // =========================
    // Der Importer kann sein eigenes UI/Panel ausblenden, während der Tracker weiterläuft.
    // Viewer schreibt localStorage["ad_importer_ui_visible"] und dispatcht ein CustomEvent,
    // damit es im selben Tab sofort wirkt.
    const AD_EXT_IMPORTER_UI_VISIBLE_LS_KEY = "ad_importer_ui_visible";
    const AD_EXT_IMPORTER_UI_VISIBILITY_EVENT = "ad-importer-ui-visibility";
    // 0.14.05: Importer-Konsole immer eingeblendet (kein Toggle mehr)
    try { localStorage.setItem(AD_EXT_IMPORTER_UI_VISIBLE_LS_KEY, "1"); } catch {}
    try { window.dispatchEvent(new CustomEvent(AD_EXT_IMPORTER_UI_VISIBILITY_EVENT, { detail: { visible: true } })); } catch {}

    const AD_EXT_IMPORTER_UI_DEFAULT_VISIBLE = true;


    // =========================
    // Responsive Layout Mode (Auto / Portrait / Landscape)
    // =========================
    // Speichert Override in localStorage["ad_viewer_layout_mode"]
    const AD_EXT_LAYOUT_MODE_LS_KEY = "ad_viewer_layout_mode";
    const AD_EXT_LAYOUT_MODE_AUTO = "auto";
    const AD_EXT_LAYOUT_MODE_PORTRAIT = "portrait";
    const AD_EXT_LAYOUT_MODE_LANDSCAPE = "landscape";

    function AD_EXT_getLayoutMode() {
        try {
            const raw = String(localStorage.getItem(AD_EXT_LAYOUT_MODE_LS_KEY) || AD_EXT_LAYOUT_MODE_AUTO).toLowerCase();
            if (raw === AD_EXT_LAYOUT_MODE_PORTRAIT) return AD_EXT_LAYOUT_MODE_PORTRAIT;
            if (raw === AD_EXT_LAYOUT_MODE_LANDSCAPE) return AD_EXT_LAYOUT_MODE_LANDSCAPE;
            return AD_EXT_LAYOUT_MODE_AUTO;
        } catch {
            return AD_EXT_LAYOUT_MODE_AUTO;
        }
    }

    function AD_EXT_setLayoutMode(mode) {
        const m = String(mode || AD_EXT_LAYOUT_MODE_AUTO).toLowerCase();
        const v =
              (m === AD_EXT_LAYOUT_MODE_PORTRAIT) ? AD_EXT_LAYOUT_MODE_PORTRAIT :
        (m === AD_EXT_LAYOUT_MODE_LANDSCAPE) ? AD_EXT_LAYOUT_MODE_LANDSCAPE :
        AD_EXT_LAYOUT_MODE_AUTO;
        try { localStorage.setItem(AD_EXT_LAYOUT_MODE_LS_KEY, v); } catch {}
        return v;
    }

    function AD_EXT_applyLayoutMode(panel) {
        const root = panel?.querySelector?.(".ad-ext-root");
        if (!root) return;

        const mode = AD_EXT_getLayoutMode();

        root.classList.add("ad-ext-layout");
        root.classList.remove("ad-ext-layout--auto", "ad-ext-layout--force-portrait", "ad-ext-layout--force-landscape");

        if (mode === AD_EXT_LAYOUT_MODE_PORTRAIT) root.classList.add("ad-ext-layout--force-portrait");
        else if (mode === AD_EXT_LAYOUT_MODE_LANDSCAPE) root.classList.add("ad-ext-layout--force-landscape");
        else root.classList.add("ad-ext-layout--auto");

        root.dataset.adLayoutMode = mode;

        // UI sync (Buttons)
        const toggle = root.querySelector("#ad-ext-layout-toggle");
        if (toggle) {
            for (const b of toggle.querySelectorAll("button[data-ad-ext-layout]")) {
                const k = String(b.dataset.adExtLayout || "").toLowerCase();
                b.classList.toggle("ad-ext-segbtn--active", k === mode);
            }
        }

        // Settings-Viewer (Kachel unten)
        try { AD_EXT_syncSettingsViewerLayoutButtons(panel, mode); } catch {}
    }

    function AD_EXT_syncSettingsViewerLayoutButtons(panel, mode) {
        const m = String(mode || AD_EXT_getLayoutMode()).toLowerCase();
        const slot = panel?.querySelector?.("#ad-ext-settings-slot-viewer");
        if (!slot) return;

        const btns = slot.querySelectorAll?.("button[data-ad-ext-viewmode]") || [];
        for (const b of btns) {
            const k = String(b?.dataset?.adExtViewmode || "").toLowerCase();
            const active = (k === m);
            try { b.classList.toggle("is-active", active); } catch {}
            try { b.setAttribute("aria-pressed", active ? "true" : "false"); } catch {}
        }
    }

    function AD_EXT_wireLayoutMode(panel) {
        const root = panel?.querySelector?.(".ad-ext-root");
        if (!root) return;

        // Always sync current mode (idempotent)
        AD_EXT_applyLayoutMode(panel);

        // (v0.14.13) Viewer-Kachel Buttons (data-ad-ext-viewmode) → nutzt bestehende Layout-Logik
        const viewerSlot = panel?.querySelector?.("#ad-ext-settings-slot-viewer");
        if (viewerSlot && viewerSlot.dataset.adExtViewmodeWired !== "1") {
            viewerSlot.dataset.adExtViewmodeWired = "1";
            viewerSlot.addEventListener("click", (ev) => {
                const b = ev.target?.closest?.("button[data-ad-ext-viewmode]");
                if (!b) return;
                const k = String(b.dataset.adExtViewmode || AD_EXT_LAYOUT_MODE_AUTO).toLowerCase();
                AD_EXT_setLayoutMode(k);
                AD_EXT_applyLayoutMode(panel);
            });
        }

        // One-time wiring (storage listener)
        if (root.dataset.adExtLayoutWired === "1") return;
        root.dataset.adExtLayoutWired = "1";

        window.addEventListener("storage", (ev) => {
            if (!ev || ev.key !== AD_EXT_LAYOUT_MODE_LS_KEY) return;
            AD_EXT_applyLayoutMode(panel);
        });
    }



    // =========================
    // Settings Menü (Dropdown)
    // =========================
    let AD_EXT_settingsMenuDocWired = false;
    let AD_EXT_settingsMenuRefs = null;

    let AD_EXT_settingsPageDocWired = false;
    let AD_EXT_settingsPageRefs = null;

    function AD_EXT_wireSettingsMenu(panel) {
        const root = panel?.querySelector?.(".ad-ext-root");
        if (!root) return;

        const btn = root.querySelector("#ad-ext-settings-btn");
        const menu = root.querySelector("#ad-ext-settings-menu");
        if (!btn || !menu) return;

        if (root.dataset.adExtSettingsMenuWired === "1") return;
        root.dataset.adExtSettingsMenuWired = "1";

        const panelMain = menu.querySelector('[data-ad-ext-menu-panel="main"]');
        const panelView = menu.querySelector('[data-ad-ext-menu-panel="view"]');

        const showPanel = (name) => {
            // Keep main panel visible; open/close sub-panels as flyouts
            if (panelMain) panelMain.hidden = false;
            if (panelView) panelView.hidden = (name !== "view");
        };

        const openMenu = () => {
            menu.hidden = false;
            btn.setAttribute("aria-expanded", "true");
            showPanel("main");
        };

        const closeMenu = () => {
            menu.hidden = true;
            btn.setAttribute("aria-expanded", "false");
            showPanel("main");
        };

        // expose for document listeners
        AD_EXT_settingsMenuRefs = { root, btn, menu, closeMenu };

        // Dropdown: nur via Shift+Click oder Rechtsklick (normaler Click = Settings-Seite)
        btn.addEventListener("click", (ev) => {
            if (!ev.shiftKey) return;
            ev.preventDefault();
            ev.stopPropagation();
            if (menu.hidden) openMenu();
            else closeMenu();
            try { btn.blur(); } catch {}
        });

        btn.addEventListener("contextmenu", (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            if (menu.hidden) openMenu();
            else closeMenu();
            try { btn.blur(); } catch {}
        });

        // Prevent outside click close when interacting inside
        menu.addEventListener("click", (ev) => {
            ev.stopPropagation();

            const nav = ev.target?.closest?.("[data-ad-ext-open-menu-panel]");
            if (nav) {
                const dest = String(nav.dataset.adExtOpenMenuPanel || "main").toLowerCase();
                if (dest === "view") {
                    const isOpen = panelView && !panelView.hidden;
                    showPanel(isOpen ? "main" : "view");
                } else {
                    showPanel("main");
                }
                return;
            }

            // Close when picking a layout option
            if (ev.target?.closest?.('#ad-ext-layout-toggle button[data-ad-ext-layout]')) {
                closeMenu();
                return;
            }
        });

        // One-time global listeners to close on outside click / ESC
        if (!AD_EXT_settingsMenuDocWired) {
            AD_EXT_settingsMenuDocWired = true;

            document.addEventListener("click", (ev) => {
                const refs = AD_EXT_settingsMenuRefs;
                if (!refs || !refs.menu || !refs.btn) return;
                if (refs.menu.hidden) return;

                const t = ev.target;
                if (refs.menu.contains(t) || refs.btn.contains(t)) return;
                refs.closeMenu();
            }, true);

            document.addEventListener("keydown", (ev) => {
                const refs = AD_EXT_settingsMenuRefs;
                if (!refs || !refs.menu) return;
                if (refs.menu.hidden) return;

                if (ev.key === "Escape") {
                    refs.closeMenu();
                }
            }, true);
        }
    }

    // Tabellen: überall horizontal scroll ermöglichen (in Portrait wichtig, aber auch sonst harmless)
    function AD_EXT_ensureTablesScrollable(rootEl) {
        if (!rootEl) return;

        const tables = Array.from(rootEl.querySelectorAll("table.ad-ext-table"));
        for (const tbl of tables) {
            // Tag special tables (idempotent)
            try {
                const isTop10 = !!tbl.querySelector("#ad-ext-x01-toplegs-body, #ad-ext-x01-topcheckout-body");
                if (isTop10) tbl.classList.add("ad-ext-table--top10");
                else tbl.classList.remove("ad-ext-table--top10");

                // Detect percent-based colgroups (these are the ones that benefit from the portrait override)
                let hasPercentCols = false;
                const cols = tbl.querySelectorAll("colgroup col");
                for (const c of cols) {
                    const styleAttr = (c.getAttribute("style") || "");
                    const w = (c.style && c.style.width) ? String(c.style.width) : "";
                    if ((/width\s*:\s*[^;]*%/i.test(styleAttr)) || w.includes("%")) {
                        hasPercentCols = true;
                        break;
                    }
                }
                if (hasPercentCols) tbl.classList.add("ad-ext-cols-percent");
                else tbl.classList.remove("ad-ext-cols-percent");
            } catch { /* ignore */ }

            // Do not wrap tooltip tables (falls irgendwann)
            if (tbl.closest(".ad-ext-tooltip")) continue;

            const existingWrap = tbl.closest(".ad-ext-table-scroll");
            if (existingWrap) {
                // Ensure left-aligned start (some browsers keep scroll position)
                if (existingWrap.scrollLeft !== 0) existingWrap.scrollLeft = 0;
                continue;
            }

            const parent = tbl.parentElement;
            if (!parent) continue;

            const wrap = document.createElement("div");
            wrap.className = "ad-ext-table-scroll";
            parent.insertBefore(wrap, tbl);
            wrap.appendChild(tbl);

            // Always start at the left edge
            requestAnimationFrame(() => { try { wrap.scrollLeft = 0; } catch {} });
        }
    }



    // =========================
    // Settings "Seite" (Platzhalter) – Toggle Button rechts oben
    // =========================

    function AD_EXT_wireSettingsPageConsoles(panel) {
        const root = panel?.querySelector?.(".ad-ext-root");
        if (!root) return null;

        if (root.__adExtSettingsPageConsoles) return root.__adExtSettingsPageConsoles;

        const page = root.querySelector("#ad-ext-settings-page");
        const viewerSlot = page?.querySelector?.("#ad-ext-settings-slot-viewer");
        const importerSlot = page?.querySelector?.("#ad-ext-settings-slot-importer");

        const state = {
            root,
            page,
            viewerSlot,
            importerSlot,
            docked: false,
            menu: null,
            api: null,
        };

        const restoreTo = (el, parent, nextSibling) => {
            if (!el || !parent) return;
            try {
                if (nextSibling && nextSibling.parentNode === parent) parent.insertBefore(el, nextSibling);
                else parent.appendChild(el);
            } catch {
                try { parent.appendChild(el); } catch {}
            }
        };

        state.dock = () => {
            if (state.docked) return;
            state.docked = true;

            // Importer-Konsole (API Panel) -> Slot B
            try {
                if (!state.importerSlot) return;

                const apiPanel = document.getElementById("adApiPanel");
                if (!apiPanel) {
                    state.importerSlot.innerHTML = '<div class="ad-ext-muted">API‑Panel noch nicht verfügbar. (Importer noch nicht geladen.)</div>';
                    return;
                }

                state.api = {
                    el: apiPanel,
                    parent: apiPanel.parentNode,
                    nextSibling: apiPanel.nextSibling,
                };

                apiPanel.classList.add("adApiPanel--embedded");
                try { apiPanel.style.display = ""; } catch {}

                state.importerSlot.innerHTML = "";
                state.importerSlot.appendChild(apiPanel);
            } catch (e) {
                console.warn("[AD Ext] Importer-Konsole docking failed:", e);
            }
        };

        state.undock = () => {
            if (!state.docked) return;
            state.docked = false;


            // API Panel bleibt dauerhaft im Settings-Slot (kein Floating-Terminal mehr)
            try {
                // no-op
            } catch (e) {
                console.warn("[AD Ext] Importer-Konsole undocking noop failed:", e);
            } finally {
                state.api = null;
            }
        };

        root.__adExtSettingsPageConsoles = state;
        return state;
    }

    function AD_EXT_wireSettingsPageToggle(panel) {
        const root = panel?.querySelector?.(".ad-ext-root");
        if (!root) return;

        const btn = root.querySelector("#ad-ext-settings-btn");
        const dash = root.querySelector("#ad-ext-dashboard-wrap");
        const page = root.querySelector("#ad-ext-settings-page");
        if (!btn || !dash || !page) return;

        // de-dupe
        if (root.dataset.adExtSettingsPageWired === "1") return;
        root.dataset.adExtSettingsPageWired = "1";

        const iconEl = btn.querySelector(".ad-ext-icon");
        try { if (iconEl) iconEl.textContent = "⚙"; } catch {}
        const consoles = AD_EXT_wireSettingsPageConsoles(panel);
        const closeBtn = page.querySelector("#ad-ext-settings-close");

        const closeDropdownMenuIfOpen = () => {
            // Falls das Dropdown offen ist, schließen (damit es nicht "über" der Seite hängt)
            const menu = root.querySelector("#ad-ext-settings-menu");
            const gear = root.querySelector("#ad-ext-settings-btn");
            if (menu && !menu.hidden) {
                menu.hidden = true;
                gear?.setAttribute("aria-expanded", "false");
            }
            // Falls die globale Ref existiert, auch darüber schließen (sauber)
            try { AD_EXT_settingsMenuRefs?.closeMenu?.(); } catch {}
        };

        const apply = (open) => {
            const isOpen = !!open;
            dash.hidden = isOpen;
            page.hidden = !isOpen;

            // Settings-Seite offen? -> Consoles docken und Dropdown-Autoclose deaktivieren
            if (isOpen) {
                root.dataset.adExtSettingsPageOpen = "1";
                try { consoles?.dock?.(); } catch (e) { console.warn("[AD Ext] docking failed:", e); }
            } else {
                try { consoles?.undock?.(); } catch (e) { console.warn("[AD Ext] undocking failed:", e); }
                try { delete root.dataset.adExtSettingsPageOpen; } catch {}

                // Training Tab sofort aktualisieren, wenn Training gerade aktiv ist
                try {
                    const sub = String(localStorage.getItem("ad_ext_subview") || "").toLowerCase();
                    if (sub === "training" && cache?.loaded) {
                        cache._training_weeksAsc = null; // optional, aber sauber
                        renderTrainingTab(panel);
                    }
                } catch {}
            }

            btn.setAttribute("aria-pressed", isOpen ? "true" : "false");
            btn.title = isOpen ? "Einstellungen schließen" : "Einstellungen";
            if (iconEl) iconEl.textContent = "⚙";

            // Tooltip weg, falls offen
            try { tooltipHide(); } catch {}
        };

        // Global ESC handler: schließt Settings nur wenn offen
        AD_EXT_settingsPageRefs = { page, apply };
        if (!AD_EXT_settingsPageDocWired) {
            AD_EXT_settingsPageDocWired = true;
            document.addEventListener("keydown", (ev) => {
                const refs = AD_EXT_settingsPageRefs;
                if (!refs?.page || refs.page.hidden) return; // nur wenn Settings sichtbar
                if (ev.key !== "Escape") return;
                ev.preventDefault();
                ev.stopPropagation();
                try { refs.apply(false); } catch {}
            }, true);
        }


        const isOpenNow = () => !page.hidden;

        // Default: Dashboard sichtbar
        apply(false);

        // Close-Button (✕) in Settings-Header
        if (closeBtn && closeBtn.dataset.adExtWired !== "1") {
            closeBtn.dataset.adExtWired = "1";
            closeBtn.addEventListener("click", (ev) => {
                ev.preventDefault();
                ev.stopPropagation();
                closeDropdownMenuIfOpen();
                apply(false);
                try { closeBtn.blur(); } catch {}
                try { btn.blur(); } catch {}
            });
        }

        btn.addEventListener("click", (ev) => {
            if (ev.shiftKey) return;
            ev.preventDefault();
            ev.stopPropagation();
            closeDropdownMenuIfOpen();
            apply(!isOpenNow());
            // Mouse-click: kein dauerhafter Focus-Ring
            if (ev.detail && ev.detail > 0) { try { btn.blur(); } catch {} }
        });
    }

    function AD_EXT_wireConfigCard(panel) {
        const root = panel?.querySelector?.(".ad-ext-root");
        if (!root) return;

        const page = root.querySelector("#ad-ext-settings-page");
        if (!page) return;

        // de-dupe
        if (page.dataset.adExtCfgWired === "1") return;
        page.dataset.adExtCfgWired = "1";

        const statusEl = page.querySelector("#adExtCfgStatus");
        const resetBtn = page.querySelector("#adExtCfgReset");



        // Section collapse toggles (UI only) (v0.14.100)
        const loadCfgSectionState = () => {
            try {
                const raw = localStorage.getItem(AD_EXT_LS_KEY_CFG_SECTIONS);
                if (!raw) return {};
                const obj = JSON.parse(raw);
                return (obj && typeof obj === "object" && !Array.isArray(obj)) ? obj : {};
            } catch { return {}; }
        };

        const saveCfgSectionState = (obj) => {
            try { localStorage.setItem(AD_EXT_LS_KEY_CFG_SECTIONS, JSON.stringify(obj || {})); } catch {}
        };

        const ensureCfgSectionToggles = () => {
            const sections = Array.from(page.querySelectorAll(".ad-ext-cfg-section"));
            const state = loadCfgSectionState();

            const normalizeTitleToId = (title) => {
                const t0 = String(title || "").trim().toLowerCase();
                const t1 = t0.replace(/\s+/g, "-");
                const t2 = t1.replace(/[^a-z0-9-]/g, "");
                return "cfgsec_" + (t2 || "unknown");
            };

            for (const sec of sections) {
                const head = sec.querySelector(".ad-ext-cfg-section-head");
                if (!head) continue;

                const titleEl = sec.querySelector(".ad-ext-cfg-section-title");
                const id = normalizeTitleToId(titleEl?.textContent || "");
                try { sec.dataset.cfgSecId = id; } catch {}

                let btn = head.querySelector(".ad-ext-cfg-section-toggle");
                if (!btn) {
                    btn = document.createElement("button");
                    btn.type = "button";
                    btn.className = "ad-ext-cfg-section-toggle";
                    btn.setAttribute("aria-label", "Sektion ein-/ausklappen");
                    head.appendChild(btn);

                    btn.addEventListener("click", (ev) => {
                        ev.preventDefault();
                        ev.stopPropagation();

                        const collapsedNow = sec.classList.toggle("is-collapsed");
                        btn.textContent = collapsedNow ? "+" : "−";
                        btn.setAttribute("aria-expanded", collapsedNow ? "false" : "true");

                        state[id] = collapsedNow ? 1 : 0;
                        saveCfgSectionState(state);
                    });
                }

                const collapsed = (state?.[id] ?? 1) === 1;
                if (collapsed) sec.classList.add("is-collapsed");
                else sec.classList.remove("is-collapsed");

                btn.textContent = collapsed ? "+" : "−";
                btn.setAttribute("aria-expanded", collapsed ? "false" : "true");
            }
        };

        ensureCfgSectionToggles();
        const setStatus = (() => {
            let t = null;
            return (msg, ms = 2000) => {
                try { if (t) clearTimeout(t); } catch {}
                if (statusEl) statusEl.textContent = msg;
                if (ms > 0) {
                    t = setTimeout(() => { try { if (statusEl) statusEl.textContent = "Bereit."; } catch {} }, ms);
                }
            };
        })();

        const applyCfgToUI = (cfg) => {
            for (const f of AD_EXT_CFG_FIELDS) {
                const el = page.querySelector(`#cfg_${f.key}`);
                if (!el) continue;
                const v = cfg?.[f.key];
                const dv = AD_EXT_DEFAULT_CFG?.[f.key];
                const out = (typeof v === "number" && Number.isFinite(v)) ? v : dv;
                try { el.value = String(out); } catch {}
            }
        };
        const commitField = (key, el, { min, max }) => {
            const raw = (el?.value ?? "").toString().trim();
            const n = parseInt(raw, 10);
            if (!Number.isFinite(n)) {
                setStatus("Ungültiger Wert", 2000);
                applyCfgToUI(AD_loadCfg());
                return;
            }
            const clamped = Math.min(max, Math.max(min, n));
            const wasClamped = (clamped !== n);
            try { if (String(clamped) !== String(el.value)) el.value = String(clamped); } catch {}

            AD_setSetting(key, clamped);

            if (wasClamped) {
                let msg = `Wert wurde auf ${clamped} begrenzt.`;
                if (clamped === min) msg = `Wert wurde auf ${clamped} begrenzt. Minimum ist ${min}.`;
                else if (clamped === max) msg = `Wert wurde auf ${clamped} begrenzt. Maximum ist ${max}.`;
                setStatus(msg, 2000);
            } else {
                setStatus("Gespeichert.", 2000);
            }
        };

        // initial load
        applyCfgToUI(AD_loadCfg());

        // wire inputs
        for (const f of AD_EXT_CFG_FIELDS) {
            const el = page.querySelector(`#cfg_${f.key}`);
            if (!el) continue;
            const handler = () => commitField(f.key, el, f);
            el.addEventListener("change", handler);
            el.addEventListener("blur", handler);
        }

        // reset
        resetBtn?.addEventListener?.("click", () => {
            const ok = confirm("Alle Einstellungen auf Standard zurücksetzen?");
            if (!ok) return;
            AD_clearCfg();
            applyCfgToUI(AD_loadCfg());
            setStatus("Zurückgesetzt.", 2000);
        });
    }


    function AD_EXT_wireTableScrollObserver(panel) {
        const root = panel?.querySelector?.(".ad-ext-root");
        if (!root) return;
        if (root.dataset.adExtTableScrollObs === "1") return;
        root.dataset.adExtTableScrollObs = "1";

        let scheduled = false;
        const ensure = () => {
            if (scheduled) return;
            scheduled = true;
            requestAnimationFrame(() => {
                scheduled = false;
                AD_EXT_ensureTablesScrollable(root);
            });
        };

        ensure();

        const mo = new MutationObserver((mutList) => {
            for (const m of mutList) {
                if (m.type === "childList" && (m.addedNodes?.length || m.removedNodes?.length)) {
                    ensure();
                    break;
                }
            }
        });

        mo.observe(root, { childList: true, subtree: true });
    }

    function AD_EXT_readBoolLS(key, defVal) {
        try {
            const raw = localStorage.getItem(key);
            if (raw == null) return !!defVal;
            if (raw === "1" || raw === "true" || raw === "yes" || raw === "on") return true;
            if (raw === "0" || raw === "false" || raw === "no" || raw === "off") return false;
            return !!defVal;
        } catch {
            return !!defVal;
        }
    }

    function AD_EXT_wireImporterUiToggle(panel) {
        const el = panel?.querySelector?.("#ad-ext-toggle-importer-ui");
        const label = panel?.querySelector?.("#ad-ext-importer-switch-label");
        if (!el) return;

        const isInput = String(el.tagName || "").toUpperCase() === "INPUT";

        const setUI = (visible) => {
            const v = !!visible;
            if (isInput) {
                el.checked = v;
            } else {
                el.setAttribute("aria-checked", v ? "true" : "false");
                el.dataset.adExtChecked = v ? "1" : "0";
            }

            if (label) {
                label.textContent = v ? "An" : "Aus";
                label.dataset.adExtOn = v ? "1" : "0";
            }
        };

        const getUI = () => {
            if (isInput) return !!el.checked;
            return el.getAttribute("aria-checked") === "true" || el.dataset.adExtChecked === "1";
        };

        const applyFromLS = () => {
            setUI(AD_EXT_readBoolLS(AD_EXT_IMPORTER_UI_VISIBLE_LS_KEY, AD_EXT_IMPORTER_UI_DEFAULT_VISIBLE));
        };

        const commit = (visible) => {
            const v = !!visible;
            try { localStorage.setItem(AD_EXT_IMPORTER_UI_VISIBLE_LS_KEY, v ? "1" : "0"); } catch {}
            try { window.dispatchEvent(new CustomEvent(AD_EXT_IMPORTER_UI_VISIBILITY_EVENT, { detail: { visible: v } })); } catch {}
            console.debug("[AD Ext] Importer UI visibility set:", v);
            setUI(v);
        };

        applyFromLS();

        if (isInput) {
            el.addEventListener("change", () => commit(getUI()));
        } else {
            el.addEventListener("click", () => commit(!getUI()));
        }

        // Cross-Tab: wenn du im anderen Tab togglest
        window.addEventListener("storage", (e) => {
            if (e && e.key === AD_EXT_IMPORTER_UI_VISIBLE_LS_KEY) applyFromLS();
        });
    }

    let AD_EXT_autoRefreshWired = false;
    let AD_EXT_lastAutoRefreshAt = 0;
    let AD_EXT_pendingAutoRefreshT = null;
    let AD_EXT_pendingAutoRefreshInfo = null;
    let AD_EXT_lastAutoRefreshMarker = null;

    function AD_EXT_safeJsonParse(s) {
        if (!s) return null;
        try { return JSON.parse(s); } catch { return null; }
    }

    function AD_EXT_showAutoRefreshHint(panel, text) {
        const el = panel?.querySelector?.("#ad-ext-auto-refresh-hint");
        if (!el) return;

        el.textContent = String(text || "");
        el.style.display = "";

        const prev = Number(el.dataset.adExtHideT || 0);
        if (prev) clearTimeout(prev);

        const t = setTimeout(() => {
            el.style.display = "none";
            el.textContent = "";
            delete el.dataset.adExtHideT;
        }, 2500);

        el.dataset.adExtHideT = String(t);
    }

    function AD_EXT_scheduleAutoRefresh(panel, info, sourceLabel) {
        const now = Date.now();

        const matchId = info?.matchId ? String(info.matchId) : "";
        const fetchedAt = Number(info?.fetchedAt || 0) || 0;
        const marker = matchId ? `${matchId}|${fetchedAt}` : `t:${now}`;

        // De-dupe: exakt gleicher Marker → ignorieren
        if (marker && marker === AD_EXT_lastAutoRefreshMarker) return;
        AD_EXT_lastAutoRefreshMarker = marker;

        // Throttle
        if (now - AD_EXT_lastAutoRefreshAt < AD_EXT_AUTO_REFRESH_THROTTLE_MS) {
            // innerhalb des Fensters: wir schedulen EINEN Refresh am Ende
            AD_EXT_pendingAutoRefreshInfo = { matchId, fetchedAt, sourceLabel: sourceLabel || "" };
            if (!AD_EXT_pendingAutoRefreshT) {
                AD_EXT_pendingAutoRefreshT = setTimeout(() => {
                    AD_EXT_pendingAutoRefreshT = null;
                    AD_EXT_tryAutoRefresh(panel, AD_EXT_pendingAutoRefreshInfo);
                    AD_EXT_pendingAutoRefreshInfo = null;
                }, AD_EXT_AUTO_REFRESH_THROTTLE_MS);
            }
            return;
        }

        AD_EXT_tryAutoRefresh(panel, { matchId, fetchedAt, sourceLabel: sourceLabel || "" });
    }

    function AD_EXT_tryAutoRefresh(panel, info) {
        const now = Date.now();

        const p = panel || document.getElementById("ad-ext-panel");
        if (!p) {
            // Panel noch nicht da: pending speichern (wird beim nächsten wirePanel() consumed)
            AD_EXT_pendingAutoRefreshInfo = info || AD_EXT_pendingAutoRefreshInfo;
            return;
        }

        const btn = p.querySelector("#ad-ext-refresh-btn");
        if (!btn) return;

        if (now - AD_EXT_lastAutoRefreshAt < AD_EXT_AUTO_REFRESH_THROTTLE_MS) return;

        AD_EXT_lastAutoRefreshAt = now;
        try { btn.click(); } catch {}

        if (info?.matchId) {
            AD_EXT_showAutoRefreshHint(p, `Auto refreshed for match ${info.matchId}`);
        } else {
            AD_EXT_showAutoRefreshHint(p, "Auto refreshed.");
        }
    }

    function AD_EXT_wireAutoRefresh(panel) {
        if (AD_EXT_autoRefreshWired) {
            // Panel könnte später entstanden sein → pending konsumieren
            if (AD_EXT_pendingAutoRefreshInfo) {
                AD_EXT_tryAutoRefresh(panel, AD_EXT_pendingAutoRefreshInfo);
                AD_EXT_pendingAutoRefreshInfo = null;
            }
            return;
        }
        AD_EXT_autoRefreshWired = true;

        window.addEventListener(AD_EXT_CACHE_UPDATED_EVENT, (ev) => {
            const info = ev?.detail || null;
            AD_EXT_scheduleAutoRefresh(panel, info, "event");
        });

        // Cross-tab: storage Event feuert nur in anderen Tabs/Fenstern (nicht im gleichen Tab, der schreibt)
        window.addEventListener("storage", (ev) => {
            if (!ev || ev.key !== AD_EXT_CACHE_UPDATED_LS_KEY) return;
            const info = AD_EXT_safeJsonParse(ev.newValue);
            if (!info || !info.matchId) return;
            AD_EXT_scheduleAutoRefresh(panel, info, "storage");
        });

        // Falls beim Öffnen schon ein Marker da ist (z.B. Import in anderem Tab kurz vorher):
        try {
            const cur = AD_EXT_safeJsonParse(localStorage.getItem(AD_EXT_CACHE_UPDATED_LS_KEY));
            if (cur && cur.matchId) {
                // nur wenn es sehr frisch ist (<5min) – sonst nervt es beim Laden
                const age = cur.fetchedAt ? (Date.now() - Number(cur.fetchedAt || 0)) : Infinity;
                if (Number.isFinite(age) && age >= 0 && age < 5 * 60 * 1000) {
                    AD_EXT_scheduleAutoRefresh(panel, cur, "startup");
                }
            }
        } catch {}
    }

    // =========================
    // Wire Panel
    // =========================
    function wirePanel(panel) {
        // Auto-Refresh: reagiert auf Cache-Updates vom Importer
        AD_EXT_wireAutoRefresh(panel);
        // Importer UI/Panel ein-/ausblenden (Tracker läuft auch ohne UI)
        AD_EXT_wireImporterUiToggle(panel);
        // Layout: Auto/Portrait/Landscape (CSS Media Queries + optional Override)
        AD_EXT_wireLayoutMode(panel);
        // Settings Menü (Refresh/Importer/Layout)
        AD_EXT_wireSettingsMenu(panel);
        // Settings Seite (Platzhalter)
        AD_EXT_wireSettingsPageToggle(panel);
        AD_EXT_wireConfigCard(panel);
        AD_EXT_wireTableScrollObserver(panel);
        panel.querySelector("#ad-ext-refresh-btn")?.addEventListener("click", async () => {
            // Refresh-Button ist jetzt neben dem ⚙-Icon. Wenn Dropdown offen: schließen.
            try { AD_EXT_settingsMenuRefs?.closeMenu?.(); } catch {}
            cache.loaded = false;
            cache.rows = [];
            cache.sessions = [];
            cache.x01Matches = [];
            cache._x01_context = null;
            cache._x01_layouts = null;
            cache.timeEntries = [];
            cache._time_layouts = null;
            cache._st_layouts = null;
            cache.otherTrainingSessions = [];
            cache._time_weeksAsc = null;
            cache._training_weeksAsc = null;
            cache._st_radar_hoverIndex = null;
            cache._st_radar_selectedIndex = null;
            cache.filters = cache.filters || {};
            cache.filters.selectedTarget = null;
            cache.filters.selectedDayKey = null;
            cache.filtersX01.kpiSelectedKey = null;
            await refreshAll(panel);
        });

        const btnX01 = panel.querySelector("#ad-ext-subnav-x01");
        const btnTraining = panel.querySelector("#ad-ext-subnav-training");
        const btnMasterHof = panel.querySelector("#ad-ext-subnav-masterhof");

        const viewX01 = panel.querySelector("#ad-ext-view-x01");
        const viewTraining = panel.querySelector("#ad-ext-view-training");
        const viewMasterHof = panel.querySelector("#ad-ext-view-masterhof");

        // Zeit-Tracker wird als Trainings-Subview „Chromo-Tracker“ gemountet
        mountTimeIntoTrainChromo(panel);


        function setSubView(which) {
            let w = (String(which || localStorage.getItem("ad_ext_subview") || "x01")).toLowerCase();
            if (w === "segment") w = "x01";

            // Backward-Compat: altes Subview "time" -> Training / Chromo-Tracker
            if (w === "time") {
                w = "training";
                try { localStorage.setItem(AD_EXT_TRAIN_VIEW_LS_KEY, "CHROMO"); } catch {}
                // Best-effort sofortiger State, falls Training schon gerendert wird
                try {
                    const layout = panel.querySelector(".ad-train-layout");
                    if (layout && !layout.dataset.trainView) layout.dataset.trainView = "CHROMO";
                } catch {}
            }

            try { localStorage.setItem("ad_ext_subview", w); } catch {}

            const isX01 = w === "x01";
            const isTraining = w === "training";
            const isMasterHof = (w === "masterhof" || w === "master_hof" || w === "master");

            if (!(isX01 || isTraining || isMasterHof)) {
                return setSubView("x01");
            }

            if (viewX01) viewX01.style.display = isX01 ? "" : "none";
            if (viewTraining) viewTraining.style.display = isTraining ? "" : "none";
            if (viewMasterHof) viewMasterHof.style.display = isMasterHof ? "" : "none";

            btnX01?.classList.toggle("ad-ext-subnav-btn--active", isX01);
            btnTraining?.classList.toggle("ad-ext-subnav-btn--active", isTraining);
            btnMasterHof?.classList.toggle("ad-ext-subnav-btn--active", isMasterHof);

            if (!cache.loaded) {
                // Daten werden durch refreshAll() geladen (wird beim Öffnen ohnehin gestartet)
                return;
            }

            if (isX01) renderX01(panel);
            if (isTraining) renderTrainingTab(panel);
            renderMasterHallOfFame(panel);
        }

        btnX01?.addEventListener("click", () => setSubView("x01"));
        btnTraining?.addEventListener("click", () => setSubView("training"));
        btnMasterHof?.addEventListener("click", () => setSubView("masterhof"));

        setSubView(localStorage.getItem("ad_ext_subview") || "x01");
        wireSegmentFilters(panel);
        wireSegmentInteractions(panel);
        wireX01Filters(panel);
        wireMasterHofFilters(panel);
        wireX01SubPanels(panel);
        wireTimeFilters(panel);
        wireTimeInteractions(panel);
        wireTrainingPlanSidebarScaffold(panel);
        wireTrainingPlanSidebarControls(panel);
        wireTrainingPlanInteractions(panel);
        wireTrainingChatGptCopy(panel);
        wireTrainingChatGptMenu(panel);
        wireX01Interactions(panel);

        refreshAll(panel);
    }

    // =========================
    // Tab in /statistics einhängen
    // =========================
    function addExtendedStatsTabIfPossible() {
        injectStyles();
        if (document.getElementById("ad-ext-tab") || document.getElementById("ad-ext-panel")) return;

        const allTabs = Array.from(document.querySelectorAll('button[role="tab"]'));
        if (!allTabs.length) return;

        const anchorTab =
              allTabs.find((b) => (b.textContent || "").trim().toLowerCase() === "random checkout") ||
              allTabs[allTabs.length - 1];
        if (!anchorTab) return;

        const tablist = anchorTab.closest('[role="tablist"]');
        if (!tablist) return;

        const panelsWrapper = tablist.nextElementSibling;
        if (!panelsWrapper) return;

        const samplePanel = panelsWrapper.querySelector('[role="tabpanel"]');
        const panelClass = samplePanel ? samplePanel.className : "";

        const newTab = anchorTab.cloneNode(true);
        newTab.id = "ad-ext-tab";
        newTab.textContent = "Erweiterte Statistiken";
        newTab.setAttribute("aria-selected", "false");
        newTab.tabIndex = -1;

        const panel = document.createElement("div");
        panel.id = "ad-ext-panel";
        panel.className = panelClass;
        panel.style.display = "none";
        panel.innerHTML = buildPanelHTML();

        tablist.appendChild(newTab);
        panelsWrapper.parentNode.insertBefore(panel, panelsWrapper.nextSibling);

        const originalTabs = Array.from(tablist.querySelectorAll('button[role="tab"]')).filter((t) => t.id !== "ad-ext-tab");

        function showOurPanel() {
            originalTabs.forEach((t) => { t.setAttribute("aria-selected", "false"); t.tabIndex = -1; });
            newTab.setAttribute("aria-selected", "true");
            newTab.tabIndex = 0;

            panelsWrapper.style.display = "none";
            panel.style.display = "block";
        }

        function showOriginalPanels() {
            newTab.setAttribute("aria-selected", "false");
            newTab.tabIndex = -1;
            panel.style.display = "none";
            panelsWrapper.style.display = "";
        }

        newTab.addEventListener("click", () => showOurPanel());
        originalTabs.forEach((t) => t.addEventListener("click", () => showOriginalPanels()));
        try { wirePanel(panel); } catch (e) { console.warn("[AD Ext] wirePanel failed:", e); }
    }

    // =========================
    // Observer
    // =========================
    function startObserver() {
        let wasInStats = false;
        try { wasInStats = location.pathname.startsWith("/statistics"); } catch { wasInStats = false; }

        const obs = new MutationObserver(() => {
            let isInStats = false;
            try { isInStats = location.pathname.startsWith("/statistics"); } catch { isInStats = false; }

            // Reset default landing view when leaving /statistics
            if (wasInStats && !isInStats) {
                try { localStorage.setItem("ad_ext_subview", "x01"); } catch {}
            }
            wasInStats = isInStats;

            if (!isInStats) return;
            addExtendedStatsTabIfPossible();
        });
        obs.observe(document.body, { childList: true, subtree: true });
    }

    startObserver();
})();

// =========================
// Autodarts - Smart API + IndexedDB Cache (v1.1.1 integriert)
// =========================

(function () {
    "use strict";

    // -------------------- Config --------------------
    const LOG_PREFIX = "[AD-API]";
    const API_HOST = "https://api.autodarts.io";

    const DB_NAME = "autodarts_cache";
    const DB_VERSION = 1;

    // /stats (history) ist praktisch immutable -> kein TTL nötig
    // /state (live) ändert sich -> wir cachen nur kurz, um Spam zu vermeiden
    const LIVE_STATE_TTL_MS = 10_000;

    // -------------------- Auto-Import (History) --------------------
    // Auto-Import lädt automatisch /stats, sobald Autodarts nach Spielende auf
    // /history/matches/<MATCH_ID> navigiert. Einstellungen werden in localStorage gespeichert.
    const AD_AUTOIMPORT_DEFAULT_ENABLED = true;
    const AD_AUTOIMPORT_DEFAULT_ONLY_IF_NOT_CACHED = true;
    const AD_LS_KEY_AUTOIMPORT_ENABLED = "ad_api_autoImport_history";
    const AD_LS_KEY_AUTOIMPORT_ONLY_IF_NOT_CACHED = "ad_api_autoImport_onlyIfNotCached";



    // UI (Konsole/Panel) kann über den Viewer ein-/ausgeblendet werden.
    // Der Tracker (Auto-Import + Cache) läuft weiter, auch wenn das Panel versteckt ist.
    // Gesteuert über:
    //   - CustomEvent: "ad-importer-ui-visibility"  (gleiches Tab)
    //   - localStorage["ad_importer_ui_visible"]    (Tabs/Script-Grenzen)
    const AD_IMPORTER_UI_DEFAULT_VISIBLE = true;
    const AD_LS_KEY_IMPORTER_UI_VISIBLE = "ad_importer_ui_visible";
    const AD_IMPORTER_UI_VISIBILITY_EVENT = "ad-importer-ui-visibility";
    // 0.14.05: Panel immer sichtbar
    try { localStorage.setItem(AD_LS_KEY_IMPORTER_UI_VISIBLE, "1"); } catch {}

    const AD_AUTOIMPORT_DEBOUNCE_MS = 550; // 300–800ms (SPA kann schnell mehrfach "navigieren")
    const AD_STATS_RETRY_DELAYS_MS = [1000, 2000, 4000]; // 2–3 Retries mit Backoff
    const AD_LS_CACHE_UPDATED_KEY = "ad_cache_updated"; // Marker für Viewer/andere Tabs


    // -------------------- Logging --------------------
    const log = (...a) => console.debug(LOG_PREFIX, ...a);
    const warn = (...a) => console.warn(LOG_PREFIX, ...a);
    const err = (...a) => console.error(LOG_PREFIX, ...a);

    // -------------------- Route / MatchId --------------------
    function getMatchContextFromPath(pathname) {
        // /history/matches/<uuid>
        // /matches/<uuid>
        const m = pathname.match(
            /\/(?:history\/matches|matches)\/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i
        );

        const matchId = m ? m[1] : null;
        const isLive = /^\/matches\//i.test(pathname);
        const isHistory = /^\/history\/matches\//i.test(pathname);

        return {
            matchId,
            route: matchId ? (isLive ? "live" : (isHistory ? "history" : "unknown")) : "none",
            isLive: !!(matchId && isLive),
            isHistory: !!(matchId && isHistory),
        };
    }

    // -------------------- GM request helper --------------------
    function gmRequestJson(method, url) {
        return new Promise((resolve, reject) => {
            GM_xmlhttpRequest({
                method,
                url,
                withCredentials: true,
                timeout: 30_000,
                headers: { Accept: "application/json" },
                onload: (resp) => {
                    const text = resp.responseText || "";
                    log("HTTP", resp.status, url);

                    let json = null;
                    try { json = text ? JSON.parse(text) : null; } catch { /* ignore */ }

                    if (resp.status < 200 || resp.status >= 300) {
                        warn("Nicht OK:", resp.status, resp.statusText);
                        warn("Antwort (erste 300 Zeichen):", text.slice(0, 300));
                        const e = new Error(`HTTP ${resp.status} ${resp.statusText}`);
                        e.status = resp.status;
                        e.body = json ?? text;
                        reject(e);
                        return;
                    }

                    resolve(json);
                },
                onerror: (e) => reject(e),
                ontimeout: () => reject(new Error("Request timeout")),
            });
        });
    }

    // -------------------- IndexedDB (auto-create) --------------------
    function openDb() {
        return new Promise((resolve, reject) => {
            const req = indexedDB.open(DB_NAME, DB_VERSION);

            req.onupgradeneeded = () => {
                const db = req.result;

                // Store für /stats (History)
                if (!db.objectStoreNames.contains("match_stats")) {
                    const s = db.createObjectStore("match_stats", { keyPath: "matchId" });
                    s.createIndex("fetchedAt", "fetchedAt", { unique: false });
                }

                // Store für /state (Live)
                if (!db.objectStoreNames.contains("match_state")) {
                    const s = db.createObjectStore("match_state", { keyPath: "matchId" });
                    s.createIndex("fetchedAt", "fetchedAt", { unique: false });
                }

                // Optional: meta
                if (!db.objectStoreNames.contains("meta")) {
                    db.createObjectStore("meta", { keyPath: "key" });
                }
            };

            req.onblocked = () => {
                warn("DB upgrade blocked – schließe andere Autodarts-Tabs (falls offen).");
            };

            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        });
    }

    function idbGet(db, storeName, key) {
        return new Promise((resolve, reject) => {
            const tx = db.transaction(storeName, "readonly");
            const store = tx.objectStore(storeName);
            const req = store.get(key);
            req.onsuccess = () => resolve(req.result ?? null);
            req.onerror = () => reject(req.error);
        });
    }

    function idbPut(db, storeName, value) {
        return new Promise((resolve, reject) => {
            const tx = db.transaction(storeName, "readwrite");
            const store = tx.objectStore(storeName);
            const req = store.put(value);
            req.onsuccess = () => resolve(true);
            req.onerror = () => reject(req.error);
        });
    }

    function idbDelete(db, storeName, key) {
        return new Promise((resolve, reject) => {
            const tx = db.transaction(storeName, "readwrite");
            const store = tx.objectStore(storeName);
            const req = store.delete(key);
            req.onsuccess = () => resolve(true);
            req.onerror = () => reject(req.error);
        });
    }

    function idbClearStore(db, storeName) {
        return new Promise((resolve, reject) => {
            const tx = db.transaction(storeName, "readwrite");
            const store = tx.objectStore(storeName);
            const req = store.clear();
            req.onsuccess = () => resolve(true);
            req.onerror = () => reject(req.error);
        });
    }

    function deleteDatabase() {
        return new Promise((resolve, reject) => {
            const req = indexedDB.deleteDatabase(DB_NAME);
            req.onsuccess = () => resolve(true);
            req.onerror = () => reject(req.error);
            req.onblocked = () => warn("deleteDatabase blocked – schließe andere Autodarts-Tabs (falls offen).");
        });
    }

    // -------------------- Cache-aware loaders --------------------
    async function getStatsCached(matchId, { force = false } = {}) {
        const db = await openDb();

        if (!force) {
            const cached = await idbGet(db, "match_stats", matchId);
            if (cached?.stats) {
                return { data: cached.stats, source: "cache", fetchedAt: cached.fetchedAt ?? null };
            }
        }

        const url = `${API_HOST}/as/v0/matches/${encodeURIComponent(matchId)}/stats`;
        const stats = await gmRequestJson("GET", url);

        const fetchedAt = Date.now();

        await idbPut(db, "match_stats", {
            matchId,
            fetchedAt,
            stats,
        });

        return { data: stats, source: "api", fetchedAt };
    }

    async function getStateCached(matchId, { force = false } = {}) {
        const db = await openDb();

        if (!force) {
            const cached = await idbGet(db, "match_state", matchId);
            const age = cached?.fetchedAt ? (Date.now() - cached.fetchedAt) : Infinity;

            if (cached?.state && age <= LIVE_STATE_TTL_MS) {
                return { data: cached.state, source: "cache", fetchedAt: cached.fetchedAt ?? null, ageMs: age };
            }
        }

        const url = `${API_HOST}/gs/v0/matches/${encodeURIComponent(matchId)}/state`;
        const st = await gmRequestJson("GET", url);

        await idbPut(db, "match_state", {
            matchId,
            fetchedAt: Date.now(),
            state: st,
        });

        return { data: st, source: "api", fetchedAt: Date.now(), ageMs: 0 };
    }

    
    // =========================
    // ATC detail builder + RAM cache
    // =========================
    function isAtcStatsPayload(statsPayload) {
        const v = normalizeVariantName(statsPayload?.variant || statsPayload?.gameMode || statsPayload?.mode);
        if (v && (v === "atc" || v.includes("atc"))) return true;
        const s = statsPayload?.settings;
        // ATC /training payloads tend to have settings.order + targetStats
        if (s && (s.order || s.mode) && (asArray(statsPayload?.matchStats).length || asArray(statsPayload?.legStats).length)) return true;
        return false;
    }

    function buildAtcDetailFromStats(statsPayload, preferredPlayerId) {
        try {
            const matchId = String(statsPayload?.id || statsPayload?.matchId || "");
            if (!matchId) return null;

            const createdAt = statsPayload?.createdAt || null;
            const finishedAt = statsPayload?.finishedAt || statsPayload?.endedAt || null;

            let durationSec = 0;
            const t0 = createdAt ? new Date(createdAt).getTime() : NaN;
            const t1 = finishedAt ? new Date(finishedAt).getTime() : NaN;
            if (Number.isFinite(t0) && Number.isFinite(t1) && t1 >= t0) {
                const diff = (t1 - t0) / 1000;
                if (diff >= 0 && diff <= 6 * 3600) durationSec = diff;
            }

            const settingsRaw = statsPayload?.settings || null;
            const settings = {
                mode: (settingsRaw?.mode != null) ? String(settingsRaw.mode) : null,
                order: (settingsRaw?.order != null) ? String(settingsRaw.order) : null,
                hitsRequired: (settingsRaw?.hits != null && Number.isFinite(Number(settingsRaw.hits))) ? Number(settingsRaw.hits) : null,
            };

            // ---- summary ----
            const matchStatsArr = asArray(statsPayload?.matchStats);
            let summarySrc = null;

            if (preferredPlayerId != null) {
                const pid = String(preferredPlayerId);
                summarySrc = matchStatsArr.find(p => String(p?.playerId || "") === pid) || null;
            }
            if (!summarySrc) summarySrc = matchStatsArr[0] || null;

            if (!summarySrc) {
                // fallback: legStats[0].stats[0] (or first found)
                const legStatsArr = asArray(statsPayload?.legStats);
                for (const leg of legStatsArr) {
                    const statsArr = asArray(leg?.stats);
                    if (!statsArr.length) continue;
                    if (preferredPlayerId != null) {
                        const pid = String(preferredPlayerId);
                        summarySrc = statsArr.find(p => String(p?.playerId || "") === pid) || null;
                    }
                    if (!summarySrc) summarySrc = statsArr[0] || null;
                    if (summarySrc) break;
                }
            }

            const dartsThrown = Number(summarySrc?.dartsThrown ?? summarySrc?.darts ?? 0);
            const hits = Number(summarySrc?.hits ?? 0);
            const hitRate = Number(summarySrc?.hitRate ?? (dartsThrown > 0 ? (hits / dartsThrown) : 0));
            const playerId = (summarySrc?.playerId != null) ? String(summarySrc.playerId) : null;

            const summary = {
                playerId,
                dartsThrown: Number.isFinite(dartsThrown) ? dartsThrown : 0,
                hits: Number.isFinite(hits) ? hits : 0,
                hitRate: Number.isFinite(hitRate) ? hitRate : (Number.isFinite(dartsThrown) && dartsThrown > 0 ? (Number(hits) / dartsThrown) : 0),
            };

            // ---- targetStats ----
            let targetStatsRaw = asArray(summarySrc?.targetStats);

            if (!targetStatsRaw.length) {
                // fallback: first legStats.stats.targetStats found
                const legStatsArr = asArray(statsPayload?.legStats);
                for (const leg of legStatsArr) {
                    const statsArr = asArray(leg?.stats);
                    for (const st of statsArr) {
                        const ts = asArray(st?.targetStats);
                        if (ts.length) { targetStatsRaw = ts; break; }
                    }
                    if (targetStatsRaw.length) break;
                }
            }

            const targetStats = [];
            for (const t of targetStatsRaw) {
                const n = Number(t?.number ?? t?.targetNumber ?? t?.value ?? t?.target);
                if (!Number.isFinite(n)) continue;

                const darts = Number(t?.count ?? t?.darts ?? t?.throws ?? 0);
                const thits = Number(t?.hits ?? 0);
                const thr = Number(t?.hitRate ?? (darts > 0 ? (thits / darts) : NaN));

                targetStats.push({
                    targetNumber: n,
                    bed: (t?.bed != null) ? String(t.bed) : "",
                    darts: Number.isFinite(darts) ? darts : 0,
                    hits: Number.isFinite(thits) ? thits : 0,
                    hitRate: Number.isFinite(thr) ? thr : (Number.isFinite(darts) && darts > 0 ? (Number(thits) / darts) : NaN),
                });
            }

            // ---- throws ----
            const throwsOut = [];

            const turnsTop = asArray(statsPayload?.turns);
            const games = asArray(statsPayload?.games);

            let turns = turnsTop;
            if (!turns.length && games.length) {
                // flatten game turns (most /stats payloads)
                const tmp = [];
                for (const g of games) {
                    for (const t of asArray(g?.turns)) tmp.push(t);
                }
                turns = tmp;
            }

            for (let turnIndex = 0; turnIndex < turns.length; turnIndex++) {
                const turn = turns[turnIndex];
                const round = Number.isFinite(Number(turn?.round)) ? Number(turn.round) : null;
                const turnScoreAfter = Number.isFinite(Number(turn?.score)) ? Number(turn.score) : null;
                const turnPoints = Number.isFinite(Number(turn?.points)) ? Number(turn.points) : null;

                const ths = asArray(turn?.throws);
                for (const thr0 of ths) {
                    const dartIndex = Number.isFinite(Number(thr0?.throw)) ? Number(thr0.throw) : (Number.isFinite(Number(thr0?.dart)) ? Number(thr0.dart) : null);
                    const ts = thr0?.createdAt || null;

                    const seg0 = thr0?.segment;
                    const seg = (seg0 && typeof seg0 === "object") ? {
                        name: (seg0?.name != null) ? String(seg0.name) : "",
                        number: Number.isFinite(Number(seg0?.number)) ? Number(seg0.number) : 0,
                        bed: (seg0?.bed != null) ? String(seg0.bed) : "",
                        multiplier: Number.isFinite(Number(seg0?.multiplier)) ? Number(seg0.multiplier) : 0,
                    } : null;

                    const c0 = thr0?.coords;
                    const cx = Number(c0?.x);
                    const cy = Number(c0?.y);
                    const coords = (Number.isFinite(cx) && Number.isFinite(cy)) ? { x: cx, y: cy } : null;

                    throwsOut.push({
                        ts,
                        round,
                        turnIndex,
                        dartIndex,
                        segment: seg,
                        coords,
                        turnScoreAfter,
                        turnPoints,
                    });
                }
            }

            const detail = {
                matchId,
                createdAt,
                finishedAt,
                durationSec: Number.isFinite(durationSec) ? durationSec : 0,
                settings,
                summary,
                targetStats,
                throws: throwsOut,
            };

            // ---- consistency logging ----
            try {
                console.debug("[ATC detail]", {
                    matchId: detail.matchId,
                    mode: detail.settings?.mode ?? null,
                    order: detail.settings?.order ?? null,
                    dartsThrown: detail.summary?.dartsThrown ?? 0,
                    hits: detail.summary?.hits ?? 0,
                    targetStatsLen: Array.isArray(detail.targetStats) ? detail.targetStats.length : 0,
                    throwsLen: Array.isArray(detail.throws) ? detail.throws.length : 0,
                });

                const sumDarts = detail.targetStats.reduce((a, x) => a + (Number(x?.darts) || 0), 0);
                const sumHits = detail.targetStats.reduce((a, x) => a + (Number(x?.hits) || 0), 0);

                const d0 = Number(detail.summary?.dartsThrown || 0);
                const h0 = Number(detail.summary?.hits || 0);

                const dartsMismatch = (Number.isFinite(sumDarts) && Number.isFinite(d0)) ? (sumDarts !== d0) : false;
                const hitsMismatch = (Number.isFinite(sumHits) && Number.isFinite(h0)) ? (sumHits !== h0) : false;

                if ((d0 > 0 && dartsMismatch) || (h0 > 0 && hitsMismatch)) {
                    console.warn("[ATC detail mismatch]", {
                        matchId: detail.matchId,
                        mode: detail.settings?.mode ?? null,
                        order: detail.settings?.order ?? null,
                        summaryDarts: d0,
                        sumTargetDarts: sumDarts,
                        summaryHits: h0,
                        sumTargetHits: sumHits,
                    });
                }
            } catch { /* ignore */ }

            return detail;
        } catch {
            return null;
        }
    }

    
    let _adExtAtcEnsureNullTraceCount = 0;

    function _adExtAtcTraceEnsureNull(reason, extra) {
        if (!DEBUG_ATC_FIELDS) return;
        if (_adExtAtcEnsureNullTraceCount >= 3) return;
        _adExtAtcEnsureNullTraceCount += 1;
        try {
            console.debug("[AD Ext][ATC] ensureAtcDetail -> null:", reason, extra || {});
        } catch {}
    }

    // Local RAM cache for ATC detail loader (Smart-API IIFE scope)
    const cache = { atcDetailsByMatchId: new Map(), _atcDetailPromisesByMatchId: new Map() };
async function ensureAtcDetail(matchId, preferredPlayerId) {
        const mid = String(matchId || "");
        if (!mid) return null;


        if (DEBUG_ATC_FIELDS) {
            try { console.debug("[AD Ext][ATC] ensureAtcDetail called", mid); } catch {}
        }
        if (cache.atcDetailsByMatchId?.has?.(mid)) {
            if (DEBUG_ATC_FIELDS) {
                try { console.debug("[AD Ext][ATC] ensureAtcDetail cacheHit", mid); } catch {}
            }
            return cache.atcDetailsByMatchId.get(mid);
        }

        if (cache._atcDetailPromisesByMatchId?.has?.(mid)) return await cache._atcDetailPromisesByMatchId.get(mid);

        const p = (async () => {
            let statsPayload = null;

            let cachedRec = null;
            try {
                const db = await openDb();
                cachedRec = await idbGet(db, "match_stats", mid);

                // accept multiple cache shapes:
                // { matchId, fetchedAt, stats }, { matchId, fetchedAt, data }, { matchId, fetchedAt, payload }, or payload directly
                const candidate = cachedRec?.stats ?? cachedRec?.data ?? cachedRec?.payload ?? cachedRec ?? null;
                statsPayload = (candidate && typeof candidate === "object") ? candidate : null;
            } catch { statsPayload = null; }

            // best-effort fallback (if record missing)
            if (!statsPayload) {
                try {
                    const got = await getStatsCached(mid, { force: false });
                    statsPayload = got?.data ?? null;
                } catch { statsPayload = null; }
            }

            if (!statsPayload) {
                _adExtAtcTraceEnsureNull("no cached.stats", {
                    matchId: mid,
                    cachedKeys: (cachedRec && typeof cachedRec === "object") ? Object.keys(cachedRec).slice(0, 12) : null,
                });
                return null;
            }

            if (!isAtcStatsPayload(statsPayload)) {
                _adExtAtcTraceEnsureNull("not ATC payload", {
                    matchId: mid,
                    variant: (statsPayload && typeof statsPayload === "object") ? (statsPayload?.variant ?? statsPayload?.settings?.mode ?? statsPayload?.settings?.order ?? null) : null,
                    hasOrder: !!(statsPayload?.settings && statsPayload.settings.order),
                    keys: (typeof statsPayload === "object") ? Object.keys(statsPayload).slice(0, 12) : null,
                });
                return null;
            }

            const detail = buildAtcDetailFromStats(statsPayload, preferredPlayerId);
            if (!detail) {
                _adExtAtcTraceEnsureNull("build failed", { matchId: mid });
                return null;
            }

            const ts0 = Array.isArray(detail.targetStats) ? detail.targetStats : [];
            if (!ts0.length) {
                _adExtAtcTraceEnsureNull("no targetStats", {
                    matchId: mid,
                    mode: detail.settings?.mode ?? null,
                    order: detail.settings?.order ?? null,
                });
                return null;
            }

            try { cache.atcDetailsByMatchId.set(mid, detail); } catch {}
            return detail;
        })();

        try { cache._atcDetailPromisesByMatchId.set(mid, p); } catch {}
        try { return await p; }
        finally {
            try { cache._atcDetailPromisesByMatchId.delete(mid); } catch {}
        }
    }



    // Expose to Training/UI module (other IIFE)
    try {
        const root = (typeof globalThis !== "undefined") ? globalThis : window;
        root.__adExtAtcApi = root.__adExtAtcApi || {};
        root.__adExtAtcApi.ensureAtcDetail = ensureAtcDetail;

        // Mirror to page context (DevTools access) – userscript sandbox != page window
        try {
            if (typeof unsafeWindow !== "undefined" && unsafeWindow) {
                unsafeWindow.__adExtAtcApi = root.__adExtAtcApi;
            } else if (typeof window !== "undefined" && window) {
                // best-effort fallback
                window.__adExtAtcApi = root.__adExtAtcApi;
            }
        } catch {}

        if (DEBUG_ATC_FIELDS) {
            console.debug("[AD Ext][ATC] expose ensureAtcDetail =", typeof root.__adExtAtcApi?.ensureAtcDetail);
        }
    } catch (e) {
        console.warn("[AD Ext][ATC] expose failed", e);
    }
// -------------------- UI --------------------
    GM_addStyle(`
    /* NOTE: UI ist ausschließlich im Settings-Panel eingebettet (kein Floating-Terminal). */
    #adApiPanel,
    #adApiPanel.adApiPanel--embedded{
      position: static !important;
      right: auto !important;
      bottom: auto !important;
      left: auto !important;
      top: auto !important;
      width: 100% !important;
      max-width: none !important;
      margin: 0 !important;
      padding: 0 !important;
      background: transparent !important;
      border: none !important;
      border-radius: 0 !important;
      box-shadow: none !important;
      color: inherit;
      font-family: inherit;
      z-index: auto !important;
    }

    /* Kompakte Importer-UI (Settings-Kontext) */
    #ad-importer-settings.ad-importer-settings{
      display:flex;
      flex-direction:column;
      gap:10px;
      width:100%;
    }
    .ad-importer-row--opts{
      display:flex;
      gap:16px;
      flex-wrap:wrap;
      align-items:center;
    }
    .ad-importer-opt{
      display:flex;
      gap:8px;
      align-items:center;
      font-size:13px;
      user-select:none;
    }
    .ad-importer-opt input{ transform: translateY(1px); }

    .ad-importer-row--actions{
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .ad-importer-hint{
      font-size:12px;
      opacity:.8;
    }
    .ad-importer-hint code{
      font-size:12px;
      opacity:.9;
    }
    .ad-importer-btn{
      padding:8px 12px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.15);
      background: rgba(0,0,0,.2);
      cursor:pointer;
      user-select:none;
    }
    .ad-importer-btn:hover{ filter: brightness(1.05); }
    .ad-importer-btn:disabled{ opacity:.5; cursor:not-allowed; }
    .ad-importer-btn--danger{
      background: rgba(120,0,0,.25);
      border-color: rgba(255,80,80,.25);
    }

    .ad-importer-status{
      font-size:12px;
      opacity:.85;
    }
    .ad-importer-status.ok{ color: #9ef7b0; }
    .ad-importer-status.bad{ color: #ffb4b4; }
  `);

    GM_addStyle(`
  /* Sync Block (UI-only placeholder) */
  .ad-ext-sync{
    margin-top: 14px;
    padding: 12px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,.08);
    background: rgba(0,0,0,.10);
  }
  .ad-ext-sync-head{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
    margin-bottom: 10px;
  }
  .ad-ext-sync-title{ font-weight: 600; }
  .ad-ext-sync-meta{ opacity: .7; font-size: 12px; white-space: nowrap; }
  .ad-ext-sync-row{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
  }
  .ad-ext-sync-label{ opacity:.85; font-size: 13px; margin-right: 6px; }
  .ad-ext-sync-select{
  min-width: 200px;
  padding:8px 12px;
  height:34px;
  box-sizing: border-box;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,.15);
  background: rgba(0,0,0,.35);
  color: inherit;
  font-size: 13px;
  color-scheme: dark;
}
.ad-ext-sync-select option{
  background: #000;
  color: #fff;
}
.ad-ext-sync-btn{
  height:34px;
  box-sizing: border-box;
  padding:8px 12px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,.15);
  background: rgba(0,0,0,.35);
  color: inherit;
  font-size: 13px;
  font-weight: 700;
  cursor:pointer;
  opacity:.85;
}
.ad-ext-sync-btn:hover{ filter: brightness(1.05); }

  /* Shared Primary Button look (Sync + Bulk) */
  .ad-ext-btn-primary{
    background: rgba(140,190,255,.18);
    border-color: rgba(140,190,255,.35);
    font-weight: 900;
  }
  .ad-ext-btn-primary:hover{ filter: brightness(1.05); }

.ad-ext-sync-btn:disabled{ opacity:.55; cursor:not-allowed; }

  .ad-ext-sync-row--opts{ margin-top: 8px; }
  .ad-ext-sync-opt{
    display:flex;
    gap:8px;
    align-items:center;
    font-size: 13px;
    opacity:.85;
    user-select:none;
  }
  .ad-ext-sync-opt input{ transform: translateY(1px); }
  .ad-ext-sync-status{ margin-top: 10px; font-size: 12px; opacity: .85; }

@media (max-width: 520px){
  .ad-ext-sync-row{
    align-items: stretch;
  }
  .ad-ext-sync-select,
  .ad-ext-sync-btn{
    width: 100%;
    min-width: 0;
  }
  .ad-ext-sync-label{ margin-right: 0; }
}
`);



    const ui = {
        matchId: null,
        route: "none",
    };
    const panel = document.createElement("div");
    panel.id = "adApiPanel";
    panel.innerHTML = `
    <div id="ad-importer-settings" class="ad-importer-settings">
      <div class="ad-importer-row ad-importer-row--opts">
        <label class="ad-importer-opt">
          <input type="checkbox" id="adOptAutoImport" />
          <span>Auto-import bei History-Match</span>
        </label>

        <label class="ad-importer-opt">
          <input type="checkbox" id="adOptOnlyIfNotCached" />
          <span>Nur wenn nicht im Cache</span>
        </label>
      </div>

      <div class="ad-importer-row ad-importer-row--actions">
        <div class="ad-importer-hint" id="adImporterHint">
          Auto-Import läuft im Hintergrund bei <code>/history/matches/*</code>.
        </div>

        <button id="btnResetDb" class="ad-importer-btn ad-importer-btn--danger">
          Reset DB (alles)
        </button>
      </div>

      <div id="adStatus" class="ad-importer-status">Bereit.</div>

      <div class="ad-ext-sync">
        <div class="ad-ext-sync-head">
          <div class="ad-ext-sync-title">Synchronisation</div>
          <div class="ad-ext-sync-meta" id="ad-ext-sync-meta">(Logik folgt)</div>
        </div>

        <div class="ad-ext-sync-row">
          <label class="ad-ext-sync-label" for="adExtSyncRange">Zeitraum</label>
          <select id="adExtSyncRange" class="ad-ext-sync-select">
            <option value="7" selected>Letzte 7 Tage</option>
            <option value="14">Letzte 14 Tage</option>
            <option value="30">Letzte 30 Tage</option>
            <option value="90">Letzte 90 Tage</option>
          </select>

          <button id="adExtSyncStart" class="ad-ext-sync-btn ad-ext-btn-primary" type="button" disabled>
            Jetzt synchronisieren
          </button>
        </div>

        <div class="ad-ext-sync-row ad-ext-sync-row--opts">
          <label class="ad-ext-sync-opt">
            <input type="checkbox" id="adExtSyncOnlyMissing" checked disabled />
            <span>Nur fehlende Matches laden (empfohlen)</span>
          </label>
          <label class="ad-ext-sync-opt">
            <input type="checkbox" id="adExtSyncAuto" />
            <span>Automatisch synchronisieren (empfohlen)</span>
          </label>
        </div>

        <div class="ad-ext-sync-status" id="adExtSyncStatus">
          Bereit. (UI)
        </div>
      </div>
    </div>
  `;

    // Panel darf nie als Floating-Terminal erscheinen → default hidden + embedded
    panel.classList.add("adApiPanel--embedded");
    try { panel.style.display = "none"; } catch {}
    document.body.appendChild(panel);
    const statusEl = panel.querySelector("#adStatus");

    const optAutoImport = panel.querySelector("#adOptAutoImport");
    const optOnlyIfNotCached = panel.querySelector("#adOptOnlyIfNotCached");
    const btnResetDb = panel.querySelector("#btnResetDb");


    // -------------------- Sync (headless) --------------------
    const AD_LS_KEY_SYNC_LAST_RUN_AT = "ad_sync_lastRunAt";
    const AD_LS_KEY_SYNC_LAST_DAYS = "ad_sync_lastDays";
    const AD_LS_KEY_SYNC_AUTO_ENABLED = "ad_sync_auto_enabled";
    const AD_LS_KEY_SYNC_LAST_AUTO_ATTEMPT_AT = "ad_sync_lastAutoAttemptAt";

    function AD_uuidv7ToMs(uuid) {
        // uuid wie '019b664e-3662-78f9-9a0e-af7700f39165'
        // 1) remove dashes -> first 12 hex -> parseInt base16 -> ms
        const hex = String(uuid).replace(/-/g, "").slice(0, 12);
        const ms = parseInt(hex, 16);
        return Number.isFinite(ms) ? ms : NaN;
    }

    const syncMetaEl = panel.querySelector("#ad-ext-sync-meta");
    const syncRangeEl = panel.querySelector("#adExtSyncRange");
    const syncStartBtn = panel.querySelector("#adExtSyncStart");
    const syncOnlyMissingEl = panel.querySelector("#adExtSyncOnlyMissing");
    const syncAutoEl = panel.querySelector("#adExtSyncAuto");
    const syncStatusEl = panel.querySelector("#adExtSyncStatus");

    let _lastSyncStatus = null;
    const setSyncStatus = (txt) => {
        try {
            if (!syncStatusEl) return;
            const s = String(txt ?? "");
            if (!s.trim()) return;                 // NICHT löschen/blank setzen
            if (_lastSyncStatus === s) return;     // keine unnötigen Updates
            _lastSyncStatus = s;
            syncStatusEl.textContent = s;
        } catch {}
    };
    function AD_syncUpdateMeta() {
        const lastAt = (() => {
            try {
                const raw = localStorage.getItem(AD_LS_KEY_SYNC_LAST_RUN_AT);
                const n = Number(raw);
                return Number.isFinite(n) ? n : null;
            } catch { return null; }
        })();

        const lastDays = (() => {
            try {
                const raw = localStorage.getItem(AD_LS_KEY_SYNC_LAST_DAYS);
                const n = Number(raw);
                return Number.isFinite(n) ? n : null;
            } catch { return null; }
        })();

        if (!syncMetaEl) return;

        if (!lastAt) {
            syncMetaEl.textContent = "(noch nie synchronisiert)";
            return;
        }

        const d = new Date(lastAt);
        const pad = (n) => String(n).padStart(2, "0");
        const stamp = `${pad(d.getDate())}.${pad(d.getMonth() + 1)}.${String(d.getFullYear()).slice(-2)} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
        const days = Number.isFinite(lastDays) ? Math.max(0, Math.trunc(lastDays)) : null;
        const daysLabel = (days == null) ? null : (days === 1 ? "1 Tag" : `${days} Tage`);
        syncMetaEl.textContent = daysLabel
            ? `(letztes Mal: ${stamp} · Zeitraum: ${daysLabel})`
  : `(letztes Mal: ${stamp})`;
  }

    // Enable Sync UI (v0.14.19)
    try { if (syncStartBtn) syncStartBtn.disabled = false; } catch {}
    try { if (syncOnlyMissingEl) syncOnlyMissingEl.disabled = false; } catch {}
    try { if (syncAutoEl) syncAutoEl.disabled = false; } catch {}

    // Restore + wire Sync UI prefs (range + auto-sync)
    (function AD_syncInitUiPrefs() {
        // Range select: restore last value or default=7 days
        try {
            let n = Number(localStorage.getItem(AD_LS_KEY_SYNC_LAST_DAYS));
            const allowed = new Set(
                Array.from(syncRangeEl?.options || []).map((o) => String(o?.value || ""))
            );
            if (!Number.isFinite(n) || !allowed.has(String(n))) n = 7;
            if (syncRangeEl) syncRangeEl.value = String(n);
        } catch {
            try { if (syncRangeEl) syncRangeEl.value = "7"; } catch {}
        }

        // Auto-sync checkbox: default OFF
        try {
            const v = localStorage.getItem(AD_LS_KEY_SYNC_AUTO_ENABLED);
            if (syncAutoEl) syncAutoEl.checked = (v === "1");
        } catch {}

        // Persist changes
        try {
            syncAutoEl?.addEventListener?.("change", () => {
                try {
                    localStorage.setItem(AD_LS_KEY_SYNC_AUTO_ENABLED, syncAutoEl.checked ? "1" : "0");
                } catch {}
            });
        } catch {}

        try {
            syncRangeEl?.addEventListener?.("change", () => {
                try { localStorage.setItem(AD_LS_KEY_SYNC_LAST_DAYS, String(syncRangeEl.value || "7")); } catch {}
                AD_syncUpdateMeta();
            });
        } catch {}
    })();

    AD_syncUpdateMeta();
    setSyncStatus("Bereit.");


    const AD_SYNC_COLLECTOR_IFRAME_ID = "ad-sync-collector-iframe";

    function AD_syncGetOrCreateCollectorIframe() {
        let frame = document.getElementById(AD_SYNC_COLLECTOR_IFRAME_ID);
        if (frame) return frame;

        frame = document.createElement("iframe");
        frame.id = AD_SYNC_COLLECTOR_IFRAME_ID;
        frame.setAttribute("aria-hidden", "true");
        frame.setAttribute("tabindex", "-1");
        frame.style.cssText = [
            "position: fixed",
            "width: 1px",
            "height: 1px",
            "left: -9999px",
            "top: -9999px",
            "opacity: 0",
            "pointer-events: none",
            "border: 0"
        ].join(";");

        try { document.body.appendChild(frame); } catch {}
        return frame;
    }

    async function AD_syncCollectIdsInBackgroundTab({ startPage = 0, maxPages = 2000, stopSignal, statusCb }) {
        statusCb = statusCb || (() => {});

        // BroadcastChannel + session correlation (reuse bulk BG collector)
        const sessionId = `${Date.now()}-${Math.random().toString(16).slice(2)}`;

        let bc = null;
        try { if (typeof BroadcastChannel !== "undefined") bc = new BroadcastChannel("ad_bulk"); } catch { bc = null; }

        if (!bc) {
            const e = new Error("BroadcastChannel nicht verfügbar");
            e.code = "BC_UNAVAILABLE";
            throw e;
        }

        const openTabFn =
              (typeof GM_openInTab === "function") ? GM_openInTab :
        (typeof GM !== "undefined" && typeof GM.openInTab === "function") ? GM.openInTab :
        null;

        if (!openTabFn) {
            const e = new Error("GM_openInTab nicht verfügbar");
            e.code = "GM_openInTab_MISSING";
            throw e;
        }

        const u = new URL("/history/matches", location.origin);
        u.searchParams.set("page", String(startPage));
        u.searchParams.set("ad_bulk_bg", "1");
        u.searchParams.set("ad_bulk_session", sessionId);
        u.searchParams.set("ad_bulk_maxPages", String(maxPages));
        // Use same timings as Bulk (if available)
        try { if (typeof AD_BULK_SETTINGS !== "undefined") u.searchParams.set("ad_bulk_waitRenderMs", String(AD_BULK_SETTINGS.waitRenderMs)); } catch {}
        try { if (typeof AD_BULK_SETTINGS !== "undefined") u.searchParams.set("ad_bulk_settleMs", String(AD_BULK_SETTINGS.settleMs)); } catch {}

        statusCb("iFrame blockiert → Sammeln läuft im Hintergrund…");

        const tab = openTabFn(u.pathname + u.search + u.hash, { active: false, insert: true, setParent: true });

        return await new Promise((resolve, reject) => {
            let done = false;

            const cleanup = () => {
                if (done) return;
                done = true;
                try { bc.close(); } catch {}
                try { tab?.close?.(); } catch {}
            };

            const stopTimer = setInterval(() => {
                if (!stopSignal?.stopped) return;
                try { bc.postMessage({ type: "stop", sessionId }); } catch {}
                cleanup();
                const e = new Error("Stopped");
                e.code = "STOPPED";
                reject(e);
            }, 200);

            const onMsg = (ev) => {
                const m = ev?.data || {};
                if (!m || m.sessionId !== sessionId) return;

                if (m.type === "status") {
                    const t = String(m.text ?? "");
                    if (t.trim()) { try { statusCb(t); } catch {} }
                    return;
                }

                if (m.type === "done" || m.type === "stopped") {
                    clearInterval(stopTimer);
                    cleanup();
                    resolve((m.ids || []).map(String));
                    return;
                }

                if (m.type === "error") {
                    clearInterval(stopTimer);
                    cleanup();
                    const e = new Error(String(m.text || "BG collector error"));
                    e.code = "BG_ERROR";
                    reject(e);
                }
            };

            try { bc.addEventListener("message", onMsg); } catch { bc.onmessage = onMsg; }
        });
    }

    async function AD_syncCollectIdsWithinDays({ days, stopSignal, statusCb }) {
        statusCb = statusCb || (() => {});
        stopSignal = stopSignal || { stopped: false };

        const d = Number(days);
        const cutoffMs = Date.now() - d * 24 * 60 * 60 * 1000;

        const maxPages = Math.min(
            (typeof AD_BULK_SETTINGS !== "undefined" ? (AD_BULK_SETTINGS.maxPagesSafety || 5000) : 5000),
            2000
        );

        const isIframeCode = (c) => (c === "IFRAME_BLOCKED" || c === "IFRAME_TIMEOUT" || c === "IFRAME_LOAD_ERROR");

        const collectViaIframe = async () => {
            const frame = AD_syncGetOrCreateCollectorIframe();
            const seenIds = new Set();
            const inRangeIds = new Set();

            const startUrl = AD_bulkMakeHistoryListUrlForPage(0, { ad_bulk_iframe: "1" });
            statusCb("Sammle Matches… (Seite 0)");

            await AD_bulkLoadCollectorIframe(frame, startUrl, stopSignal);

            if (stopSignal.stopped) return [];

            // Wait initial render
            await AD_bulkWaitUntil(() => {
                const doc = frame.contentDocument;
                if (!doc) return false;
                const ids = AD_bulkCollectMatchIdsFromDoc(doc);
                if (ids.size > 0) return true;
                const root = doc.querySelector("main") || doc.querySelector('[role="main"]') || doc.querySelector("#root") || doc.body;
                return String(root?.textContent || "").trim().length > 0;
            }, Math.max((AD_BULK_SETTINGS?.waitRenderMs || 8000), 15000), stopSignal);

            if (stopSignal.stopped) return [];

            await AD_bulkSleep(AD_BULK_SETTINGS?.settleMs || 250);

            let page = 0;

            // Page 0 already loaded
            let currentIds = AD_bulkCollectMatchIdsFromDoc(frame.contentDocument);
            let currentSig = AD_bulkSigOfIds(currentIds);

            for (let i = 0; i < maxPages && !stopSignal.stopped; i++) {
                const idsOnPage = currentIds;

                if (idsOnPage.size === 0) {
                    statusCb(`Sammle Matches… Seite ${page} | leer`);
                    break;
                }

                let newCount = 0;
                let minTsOnPage = Infinity;
                let hasFiniteTs = false;

                for (const id of idsOnPage) {
                    const s = String(id);
                    if (seenIds.has(s)) continue;
                    seenIds.add(s);
                    newCount++;

                    const ts = AD_uuidv7ToMs(s);
                    if (Number.isFinite(ts)) {
                        hasFiniteTs = true;
                        if (ts >= cutoffMs) inRangeIds.add(s);
                        if (ts < minTsOnPage) minTsOnPage = ts;
                    } else {
                        // Unklarer Timestamp → lieber nicht verlieren
                        inRangeIds.add(s);
                    }
                }

                statusCb(`Sammle Matches… Seite ${page} | neu: ${newCount} | gefunden: ${inRangeIds.size}`);

                // Early-stop: wir sind am Rand/älter (nach Verarbeitung dieser Seite!)
                if (hasFiniteTs && Number.isFinite(minTsOnPage) && minTsOnPage < cutoffMs) break;

                if (page !== 0 && newCount === 0) break;

                // Next page
                const prevSig = currentSig;
                const nextPage = page + 1;
                const url = AD_bulkMakeHistoryListUrlForPage(nextPage, { ad_bulk_iframe: "1" });
                AD_bulkSpaNavigateInFrame(frame, url);
                const r = await AD_bulkWaitForNewPageContentInDoc(frame.contentDocument, prevSig, stopSignal);

                if (r?.ids?.size === 0) break;
                if (r?.sig && r.sig === prevSig) break;

                currentIds = r.ids;
                currentSig = r.sig;
                page = nextPage;
            }

            const arr = Array.from(inRangeIds);
            arr.sort((a, b) => {
                const ta = AD_uuidv7ToMs(a);
                const tb = AD_uuidv7ToMs(b);
                if (Number.isFinite(ta) && Number.isFinite(tb)) return tb - ta;
                return String(a).localeCompare(String(b));
            });
            return arr;
        };

        try {
            return await collectViaIframe();
        } catch (e) {
            if (stopSignal?.stopped) throw e;

            const code = String(e?.code || "");
            if (!isIframeCode(code)) throw e;

            // Optional fallback (vorhanden aus Bulk)
            const all = await AD_syncCollectIdsInBackgroundTab({ startPage: 0, maxPages, stopSignal, statusCb });
            if (stopSignal?.stopped) return [];

            const inRange = new Set();
            for (const id of all) {
                const ts = AD_uuidv7ToMs(id);
                if (Number.isFinite(ts)) {
                    if (ts >= cutoffMs) inRange.add(id);
                } else {
                    inRange.add(id);
                }
            }

            const arr = Array.from(inRange);
            arr.sort((a, b) => {
                const ta = AD_uuidv7ToMs(a);
                const tb = AD_uuidv7ToMs(b);
                if (Number.isFinite(ta) && Number.isFinite(tb)) return tb - ta;
                return String(a).localeCompare(String(b));
            });
            return arr;
        }
    }

    async function AD_syncImportStats(ids, { onlyMissing, stopSignal, statusCb, days }) {
        statusCb = statusCb || (() => {});
        stopSignal = stopSignal || { stopped: false };

        const db = await openDb();

        let cachedKeys = new Set();
        let todo = (ids || []).map(String);

        if (onlyMissing) {
            statusCb("Prüfe Cache…");
            cachedKeys = await AD_bulkIdbGetAllKeys(db);
            todo = todo.filter(id => !cachedKeys.has(id));
        }

        const cachedCount = (ids.length - todo.length);
        statusCb(`Synchronisiere… Gesamt: ${ids.length} | im Cache: ${cachedCount} | zu laden: ${todo.length}`);

        let done = 0, ok = 0, failed = 0;
        let lastOkMatchId = null;
        let lastOkFetchedAt = null;

        let idx = 0;

        async function worker() {
            while (!stopSignal.stopped) {
                const my = idx++;
                if (my >= todo.length) return;

                const matchId = todo[my];
                try {
                    const res = await AD_bulkFetchAndCacheStatsWithRetry(db, matchId, stopSignal);
                    ok++;
                    lastOkMatchId = matchId;
                    lastOkFetchedAt = res?.fetchedAt || Date.now();
                } catch (e) {
                    if (stopSignal.stopped) return;
                    failed++;
                } finally {
                    done++;
                    statusCb(`Import: ${done}/${todo.length} | OK: ${ok} | Fehler: ${failed}`);
                    await AD_bulkSleep(AD_BULK_SETTINGS?.delayMs || 200);
                }
            }
        }

        const conc = AD_BULK_SETTINGS?.concurrency || 3;
        await Promise.allSettled(Array.from({ length: conc }, () => worker()));

        if (lastOkMatchId) {
            try { AD_notifyCacheUpdated(lastOkMatchId, lastOkFetchedAt || Date.now()); } catch {}
        }

        if (stopSignal.stopped) {
            statusCb(`Abgebrochen. OK: ${ok} | Fehler: ${failed}`);
            return { ok, failed, done, total: todo.length, lastOkMatchId, lastOkFetchedAt };
        }

        statusCb(`Fertig. OK: ${ok} | Fehler: ${failed} | Neu geladen: ${ok} | Zeitraum: ${days} Tage`);
        return { ok, failed, done, total: todo.length, lastOkMatchId, lastOkFetchedAt };
    }

    let AD_syncRunning = false;

    const AD_SYNC_AUTO_OLD_MS = 20 * 60 * 60 * 1000; // 20h
    const AD_SYNC_AUTO_GUARD_MS = 10 * 60 * 1000;    // 10min anti-loop

    function AD_syncMaybeAutoStart(reason) {
        try {
            if (!location.pathname.startsWith("/statistics")) return;

            const autoEnabled = (() => {
                try { return localStorage.getItem(AD_LS_KEY_SYNC_AUTO_ENABLED) === "1"; } catch { return false; }
            })();
            if (!autoEnabled) return;

            if (AD_syncRunning) return;

            // UI ready?
            if (!syncStartBtn || !syncRangeEl) return;
            try { if (syncStartBtn.disabled) return; } catch {}

            // Prevent overlap with Bulk (shared collectors/importer settings)
            try {
                if (typeof bulkState !== "undefined" && bulkState?.running) return;
            } catch {}

            // Prefer: block while auto-import is in-flight (API load)
            try {
                if (typeof AD_autoImportInFlight !== "undefined" && AD_autoImportInFlight?.size > 0) return;
            } catch {}

            const now = Date.now();

            // Anti-loop: if we already attempted within last 10 minutes, don't try again
            try {
                const lastAttempt = Number(localStorage.getItem(AD_LS_KEY_SYNC_LAST_AUTO_ATTEMPT_AT));
                if (Number.isFinite(lastAttempt) && (now - lastAttempt) < AD_SYNC_AUTO_GUARD_MS) return;
            } catch {}

            // "Old" if never ran or older than 20 hours
            let lastRunAt = NaN;
            try { lastRunAt = Number(localStorage.getItem(AD_LS_KEY_SYNC_LAST_RUN_AT)); } catch {}
            const isOld = (!Number.isFinite(lastRunAt) || (now - lastRunAt) > AD_SYNC_AUTO_OLD_MS);
            if (!isOld) return;

            // Mark attempt immediately (guard against SPA/interval loops)
            try { localStorage.setItem(AD_LS_KEY_SYNC_LAST_AUTO_ATTEMPT_AT, String(now)); } catch {}

            setSyncStatus("Auto-Synchronisation wird gestartet…");

            // Start via the same code path as manual click
            try { syncStartBtn.click(); } catch {}
        } catch {}
    }


    try {
        syncStartBtn?.addEventListener?.("click", async () => {
            if (AD_syncRunning) return;

            // Prevent accidental overlap with Bulk (shared collectors/importer settings)
            try {
                if (typeof bulkState !== "undefined" && bulkState?.running) {
                    setSyncStatus("Bulk läuft bereits – bitte warten.");
                    return;
                }
            } catch {}

            AD_syncRunning = true;

            const days = Number(syncRangeEl?.value || 30);
            const onlyMissing = !!syncOnlyMissingEl?.checked;
            const stopSignal = { stopped: false };

            try {
                try { if (syncStartBtn) syncStartBtn.disabled = true; } catch {}
                try { if (syncRangeEl) syncRangeEl.disabled = true; } catch {}
                try { if (syncOnlyMissingEl) syncOnlyMissingEl.disabled = true; } catch {}
                try { if (syncAutoEl) syncAutoEl.disabled = true; } catch {}

                setSyncStatus("Initialisiere…");

                const ids = await AD_syncCollectIdsWithinDays({
                    days,
                    stopSignal,
                    statusCb: setSyncStatus
                });

                if (stopSignal.stopped) {
                    setSyncStatus("Abgebrochen.");
                    return;
                }

                if (!ids || ids.length === 0) {
                    setSyncStatus("Keine Matches im Zeitraum gefunden.");
                    return;
                }

                setSyncStatus(`Gefunden (Zeitraum): ${ids.length}. Importiere…`);

                await AD_syncImportStats(ids, {
                    onlyMissing,
                    stopSignal,
                    statusCb: setSyncStatus,
                    days
                });

                try {
                    localStorage.setItem(AD_LS_KEY_SYNC_LAST_RUN_AT, String(Date.now()));
                    localStorage.setItem(AD_LS_KEY_SYNC_LAST_DAYS, String(days));
                } catch {}
                AD_syncUpdateMeta();
            } catch (e) {
                const msg = String(e?.message || e);
                setSyncStatus(`Fehler: ${msg}`);
            } finally {
                AD_syncRunning = false;
                try { if (syncStartBtn) syncStartBtn.disabled = false; } catch {}
                try { if (syncRangeEl) syncRangeEl.disabled = false; } catch {}
                try { if (syncOnlyMissingEl) syncOnlyMissingEl.disabled = false; } catch {}
                try { if (syncAutoEl) syncAutoEl.disabled = false; } catch {}
            }
        });
    } catch {}


    // -------------------- Bulk Import (paged, robust, kein Overlay) --------------------

    const AD_BULK_SETTINGS = {
        // Import
        concurrency: 3,
        delayMs: 200,
        maxRetries: 3,
        retryBaseDelayMs: 800,

        // Collect
        startPageDefault: 0,
        waitRenderMs: 8000,
        settleMs: 250,
        stopOnEmptyPage: true,
        stopOnRepeatPage: true,
        maxPagesSafety: 5000
    };

    GM_addStyle(`
  /* Bulk Panel (embedded / inline) */
  #adBulkPanel{ font: 12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; display:flex; flex-direction:column; min-height:0; height:100%; }

  #adBulkPanel .ad-bulk-top{
    display:flex;
    gap:10px;
    align-items:center;
    justify-content:space-between;
  }
  #adBulkPanel .ad-bulk-runstate{
    display:flex;
    align-items:center;
    gap:8px;
    min-height:18px;
  }
  #adBulkPanel .ad-bulk-phase{
    font-size:12px;
    font-weight:800;
    opacity:.92;
  }
  #adBulkPanel .ad-bulk-meta{ font-size:12px; opacity:.72; white-space:nowrap; }

  /* Running indicator */
  #adBulkPanel .ad-bulk-running-dot{
    width:10px;
    height:10px;
    border-radius:999px;
    background: rgba(160,255,190,.95);
    box-shadow: 0 0 0 0 rgba(160,255,190,.55);
    opacity:0;
    flex:0 0 auto;
  }
  #adBulkPanel[data-running="collect"] .ad-bulk-running-dot,
  #adBulkPanel[data-running="import"] .ad-bulk-running-dot{
    opacity:1;
    animation: ad-bulk-pulse 1.2s ease-in-out infinite;
  }
  @keyframes ad-bulk-pulse{
    0%{ box-shadow: 0 0 0 0 rgba(160,255,190,.55); }
    70%{ box-shadow: 0 0 0 10px rgba(160,255,190,0); }
    100%{ box-shadow: 0 0 0 0 rgba(160,255,190,0); }
  }

  /* Primary actions */
  #adBulkPanel .ad-bulk-primary{
    display:flex;
    gap:8px;
    align-items:stretch;
    margin-top:8px;
  }

  /* Buttons */
  #adBulkPanel .ad-bulk-btn{
    padding:8px 12px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.15);
    background: rgba(0,0,0,.20);
    color: inherit;
    cursor:pointer;
    user-select:none;
    font-weight:700;
    transition: transform .06s ease, opacity .15s ease, background .15s ease;
  }
  #adBulkPanel .ad-bulk-btn:active{ transform: translateY(1px); }
  #adBulkPanel .ad-bulk-btn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }
  #adBulkPanel .ad-bulk-btn--danger{ background: rgba(255,100,100,.18); border-color: rgba(255,100,100,.35); }
  #adBulkPanel .ad-bulk-btn--ghost{ background: rgba(0,0,0,.10); opacity:.88; }
  #adBulkPanel .ad-bulk-btn--primary{
    flex:1 1 auto;
    padding:10px 14px;
    font-weight:900;
    background: rgba(140,190,255,.18);
    border-color: rgba(140,190,255,.35);
  }

  /* Progress */
  #adBulkPanel .ad-bulk-progress-wrap{
    margin-top:10px;
    height:8px;
    border-radius:999px;
    background: rgba(255,255,255,.12);
    overflow:hidden;
    position:relative;
  }
  #adBulkPanel .ad-bulk-progress-bar{
    height:100%;
    width:0%;
    border-radius:999px;
    background: rgba(140,190,255,.70);
    transform: translateX(0);
    transition: width .20s linear;
    will-change: transform, width;
    animation:none;
  }
  #adBulkPanel .ad-bulk-progress-wrap.is-indeterminate .ad-bulk-progress-bar{
    width:35%;
    animation: ad-bulk-indeterminate 1.1s ease-in-out infinite;
  }
  @keyframes ad-bulk-indeterminate{
    0%{ transform: translateX(-140%); }
    100%{ transform: translateX(320%); }
  }

  /* Log console */
  #adBulkPanel .ad-bulk-log{ margin-top:10px; display:flex; flex-direction:column; flex:1 1 auto; min-height:0; }
  #adBulkPanel .ad-bulk-log-head{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin-bottom:6px;
  }
  #adBulkPanel .ad-bulk-log-title{
    font-size:12px;
    font-weight:900;
    opacity:.92;
  }
  #adBulkPanel .ad-bulk-log-actions{ display:flex; gap:6px; }
  #adBulkPanel .ad-bulk-log-btn{
    padding:4px 8px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.12);
    color: inherit;
    cursor:pointer;
    font-size:11px;
    font-weight:800;
    opacity:.92;
  }
  #adBulkPanel .ad-bulk-log-btn:active{ transform: translateY(1px); }
  #adBulkPanel .ad-bulk-log-btn[disabled]{ opacity:.45; cursor:not-allowed; transform:none; }

  #adBulkPanel .ad-bulk-log-body{
    border-radius:12px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(0,0,0,.18);
    padding:6px 8px;
    box-sizing: border-box;
    min-height: calc(10 * 18px + 12px + 2px); /* mind. 10 Zeilen */
    height: auto;
    flex: 1 1 auto;
    overflow:auto;
    overscroll-behavior: contain;
  }
  #adBulkPanel .ad-bulk-log-line{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:11px;
    line-height:14px;
    white-space: pre-wrap;
    padding:2px 0;
    opacity:.92;
  }
`);

    const bulkState = {
        collectedIds: [],
        matchesFound: 0,
        pagesChecked: 0,
        running: null, // null | "collect" | "import"
        stopSignal: { stopped: false },
        // (v0.14.13) UI sofort neutralisieren, wenn Stop geklickt wird (ohne Run-State zu verändern)
        uiResetOnStop: false,
        importMeta: { total: 0, cached: 0, toFetch: 0, done: 0, ok: 0, failed: 0 }
    };

    const bulkPanel = document.createElement("div");
    bulkPanel.id = "adBulkPanel";
    bulkPanel.classList.add("adBulkPanel--embedded");
    bulkPanel.innerHTML = `
  <div class="ad-bulk-top">
    <div class="ad-bulk-runstate">
      <span class="ad-bulk-running-dot" aria-hidden="true"></span>
      <span id="adBulkPhase" class="ad-bulk-phase">Bereit.</span>
    </div>
    <div id="adBulkMeta" class="ad-bulk-meta">Matches gefunden: 0</div>
  </div>

  <div class="ad-bulk-primary">
    <button id="adBulkRunAll" type="button" class="ad-bulk-btn ad-bulk-btn--primary ad-ext-btn-primary">Import aus Historie starten</button>
    <button id="adBulkStop" type="button" class="ad-bulk-btn ad-bulk-btn--danger" disabled>Stop</button>
  </div>

  <div id="adBulkProgressWrap" class="ad-bulk-progress-wrap" role="progressbar" aria-valuemin="0" aria-valuemax="100">
    <div id="adBulkProgressBar" class="ad-bulk-progress-bar"></div>
  </div>

  <div class="ad-bulk-log">
    <div class="ad-bulk-log-head">
      <div class="ad-bulk-log-title">Protokoll</div>
      <div class="ad-bulk-log-actions">
        <button id="adBulkLogCopy" type="button" class="ad-bulk-log-btn">Kopieren</button>
        <button id="adBulkLogClear" type="button" class="ad-bulk-log-btn">Leeren</button>
      </div>
    </div>
    <div id="adBulkLogBody" class="ad-bulk-log-body" role="log" aria-live="polite" aria-relevant="additions text">
      <div id="adBulkLogList"></div>
    </div>
  </div>
`;

    try { bulkPanel.style.display = "none"; } catch {}
    document.body.appendChild(bulkPanel);

    const bulkStatusEl = bulkPanel.querySelector("#adBulkStatus");
    const bulkPhaseEl = bulkPanel.querySelector("#adBulkPhase");
    const bulkMetaEl = bulkPanel.querySelector("#adBulkMeta");
    const bulkProgressWrapEl = bulkPanel.querySelector("#adBulkProgressWrap");
    const bulkProgressBarEl = bulkPanel.querySelector("#adBulkProgressBar");

    const btnBulkRunAll = bulkPanel.querySelector("#adBulkRunAll");
    const btnBulkStop = bulkPanel.querySelector("#adBulkStop");

    const bulkLogBodyEl = bulkPanel.querySelector("#adBulkLogBody");
    const bulkLogListEl = bulkPanel.querySelector("#adBulkLogList");
    const btnBulkLogCopy = bulkPanel.querySelector("#adBulkLogCopy");
    const btnBulkLogClear = bulkPanel.querySelector("#adBulkLogClear");

    // -------------------- Protokoll (Ringpuffer) --------------------
    const bulkLog = [];
    const BULK_LOG_MAX = 200;
    const BULK_LOG_VISIBLE = BULK_LOG_MAX; // scrollable full buffer

    const bulkLogUi = {
        lastCollectPage: null,
        lastImportDone: null,
        lastImportLogAt: 0,
        lastQueueSig: null
    };

    function AD_bulkFmtHms(d) {
        const pad = (n) => String(n).padStart(2, "0");
        return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    }

    function AD_bulkLogIcon(type) {
        switch (String(type || "").toLowerCase()) {
            case "ok": return "✅";
            case "warn": return "⚠️";
            case "error": return "❌";
            default: return "ℹ️";
        }
    }

    function bulkLogPush(type, msg) {
        const entry = { ts: new Date(), type: String(type || "info"), msg: String(msg || "") };
        bulkLog.push(entry);
        while (bulkLog.length > BULK_LOG_MAX) bulkLog.shift();
        renderBulkLog();
    }

    function renderBulkLog() {
        if (!bulkLogListEl) return;

        const items = bulkLog.slice(-BULK_LOG_VISIBLE);

        // Auto-scroll to bottom only if user is already near the bottom (so manual scroll-up is respected)
        const shouldScroll = (() => {
            try {
                if (!bulkLogBodyEl) return true;
                return (bulkLogBodyEl.scrollTop + bulkLogBodyEl.clientHeight) >= (bulkLogBodyEl.scrollHeight - 24);
            } catch { return true; }
        })();

        try { bulkLogListEl.innerHTML = ""; } catch {}

        const frag = document.createDocumentFragment();
        for (const it of items) {
            const line = document.createElement("div");
            line.className = "ad-bulk-log-line";
            const ts = AD_bulkFmtHms(it.ts);
            const icon = AD_bulkLogIcon(it.type);
            line.textContent = `[${ts}] ${icon} ${it.msg}`;
            frag.appendChild(line);
        }
        bulkLogListEl.appendChild(frag);

        if (shouldScroll && bulkLogBodyEl) {
            try { bulkLogBodyEl.scrollTop = bulkLogBodyEl.scrollHeight; } catch {}
        }
    }

    function AD_bulkLogToText() {
        return bulkLog.map(it => {
            const ts = AD_bulkFmtHms(it.ts);
            const icon = AD_bulkLogIcon(it.type);
            return `[${ts}] ${icon} ${it.msg}`;
        }).join("\n");
    }

    async function AD_bulkCopyText(text) {
        const t = String(text || "");
        try {
            if (navigator?.clipboard?.writeText) {
                await navigator.clipboard.writeText(t);
                return true;
            }
        } catch {}

        // Fallback
        try {
            const ta = document.createElement("textarea");
            ta.value = t;
            ta.style.position = "fixed";
            ta.style.left = "-9999px";
            ta.style.top = "0";
            document.body.appendChild(ta);
            ta.focus();
            ta.select();
            const ok = document.execCommand("copy");
            ta.remove();
            return !!ok;
        } catch {
            return false;
        }
    }

    btnBulkLogCopy?.addEventListener("click", async () => {
        const ok = await AD_bulkCopyText(AD_bulkLogToText());
        bulkLogPush(ok ? "ok" : "warn", ok ? "Protokoll kopiert." : "Kopieren nicht möglich.");
    });

    btnBulkLogClear?.addEventListener("click", () => {
        bulkLog.length = 0;
        renderBulkLog();
    });
    function AD_bulkClamp(n, min, max) {
        const v = Number(n);
        if (!Number.isFinite(v)) return min;
        return Math.max(min, Math.min(max, v));
    }

    function AD_bulkSetPhase(t) {
        if (!bulkPhaseEl) return;
        const s = String(t ?? "").trim();
        bulkPhaseEl.textContent = s || "Bereit.";
    }

    function AD_bulkSetProgress(pct) {
        if (!bulkProgressBarEl) return;
        const p = AD_bulkClamp(pct, 0, 100);

        // In collect mode we use indeterminate CSS – do not override with determinate widths
        const isInd = !!bulkProgressWrapEl?.classList?.contains?.("is-indeterminate");
        if (isInd) {
            try { bulkProgressBarEl.style.opacity = "1"; } catch {}
            return;
        }

        bulkProgressBarEl.style.width = `${p}%`;

        // Avoid tiny "rest pixel" at 0%
        try { bulkProgressBarEl.style.opacity = (p <= 0 ? "0" : "1"); } catch {}

        // Ensure determinate mode is clean
        try { bulkProgressBarEl.style.animation = "none"; } catch {}
        try { bulkProgressBarEl.style.transform = "translateX(0)"; } catch {}

        try { bulkProgressWrapEl?.setAttribute?.("aria-valuenow", String(Math.round(p))); } catch {}
    }

    function AD_bulkUpdatePagesChecked(n) {
        const v = parseInt(String(n ?? ""), 10);
        if (!Number.isFinite(v) || v < 0) return;
        bulkState.pagesChecked = v;
    }

    function AD_bulkUpdateImportMeta(patch) {
        try { bulkState.importMeta = { ...bulkState.importMeta, ...(patch || {}) }; } catch {}
    }

    function AD_bulkMaybeLogFromStatus(s) {
        const txt = String(s || "");

        // (v0.14.13) Wenn Stop geklickt wurde und UI bereits zurückgesetzt ist,
        // keine alten Meta-Updates (Matches/Progress) mehr aus Status-Text ableiten.
        if (bulkState?.uiResetOnStop && bulkState?.stopSignal?.stopped) {
            if (/Stop angefordert/i.test(txt)) {
                bulkLogPush("warn", "Abbruch angefordert.");
            }
            return;
        }

        // Stop
        if (/Stop angefordert/i.test(txt)) {
            bulkLogPush("warn", "Abbruch angefordert.");
            return;
        }

        // Collect progress (iframe + bg-tab share the same payload, bg has "BG " prefix)
        let m = txt.match(/(?:BG\s*)?Collect page=(\d+)[\s\S]*?new=(\d+)[\s\S]*?total=(\d+)[\s\S]*?pagesVisited=(\d+)/i);
        if (m) {
            const page = parseInt(m[1], 10);
            const neu = parseInt(m[2], 10);
            const total = parseInt(m[3], 10);
            const pages = parseInt(m[4], 10);

            if (Number.isFinite(total)) AD_bulkUpdateFoundMatches(total);
            if (Number.isFinite(pages)) AD_bulkUpdatePagesChecked(pages);

            if (bulkLogUi.lastCollectPage !== page) {
                bulkLogUi.lastCollectPage = page;
                bulkLogPush("info", `Seite ${page}: +${Number.isFinite(neu) ? neu : 0} neu (gesamt ${Number.isFinite(total) ? total : "?"}) · Seiten geprüft: ${Number.isFinite(pages) ? pages : "?"}`);
            }
            return;
        }

        // Collect done / aborted
        m = txt.match(/(?:BG\s*)?Collect (fertig|abgebrochen)\.[\s\S]*?IDs(?:\sbisher)?\s*[:=]\s*(\d+)/i);
        if (m) {
            const kind = String(m[1] || "").toLowerCase();
            const n = parseInt(m[2], 10);
            if (Number.isFinite(n)) AD_bulkUpdateFoundMatches(n);

            bulkLogPush(kind === "fertig" ? "ok" : "warn", `${kind === "fertig" ? "Sammeln beendet" : "Sammeln abgebrochen"}. Matches gefunden: ${Number.isFinite(n) ? n : "?"}`);
            return;
        }

        // Collect stop reason (empty/repeat/no-new)
        m = txt.match(/(?:BG\s*)?Collect stop:[\s\S]*?Total IDs=(\d+)/i);
        if (m) {
            const n = parseInt(m[1], 10);
            if (Number.isFinite(n)) AD_bulkUpdateFoundMatches(n);
            bulkLogPush("ok", `Sammeln beendet. Matches gefunden: ${Number.isFinite(n) ? n : "?"}`);
            return;
        }

        // Collector fallback / errors
        m = txt.match(/iFrame Collector fehlgeschlagen\s*\(([^)]+)\)/i);
        if (m) {
            bulkLogPush("warn", `Collector-Fallback: ${String(m[1] || "").trim()}`);
            return;
        }

        m = txt.match(/(?:BG\s*)?Collect Fehler:\s*(.*)/i);
        if (m) {
            bulkLogPush("error", `Sammeln fehlgeschlagen: ${String(m[1] || "").trim()}`);
            return;
        }

        // Import queue meta
        m = txt.match(/Queue:\s*total=(\d+)\s*\|\s*cached=(\d+)\s*\|\s*toFetch=(\d+)/i);
        if (m) {
            const total = parseInt(m[1], 10);
            const cached = parseInt(m[2], 10);
            const toFetch = parseInt(m[3], 10);

            if (Number.isFinite(total)) AD_bulkUpdateFoundMatches(total);
            AD_bulkUpdateImportMeta({ total, cached, toFetch, done: 0, ok: 0, failed: 0 });

            const sig = `${total}|${cached}|${toFetch}`;
            if (bulkLogUi.lastQueueSig !== sig) {
                bulkLogUi.lastQueueSig = sig;
                bulkLogPush("info", `Warteschlange: Gesamt ${Number.isFinite(total) ? total : "?"} | Im Cache: ${Number.isFinite(cached) ? cached : "?"} | Noch zu laden: ${Number.isFinite(toFetch) ? toFetch : "?"}`);
            }

            if (Number.isFinite(toFetch) && toFetch === 0) {
                AD_bulkSetProgress(100);
                bulkLogPush("ok", "Alles bereits im Cache – kein Import nötig.");
            }
            return;
        }

        // Import progress
        m = txt.match(/Import:\s*done=(\d+)\s*\/\s*(\d+)\s*\|\s*ok=(\d+)\s*\|\s*failed=(\d+)\s*\|\s*cached=(\d+)/i);
        if (m) {
            const done = parseInt(m[1], 10);
            const total = parseInt(m[2], 10);
            const ok = parseInt(m[3], 10);
            const failed = parseInt(m[4], 10);
            const cached = parseInt(m[5], 10);

            AD_bulkUpdateImportMeta({ done, ok, failed, cached, toFetch: total });

            if (Number.isFinite(done) && Number.isFinite(total) && total > 0) {
                AD_bulkSetProgress((done / total) * 100);
            }

            const remaining = (Number.isFinite(total) && Number.isFinite(done)) ? Math.max(0, total - done) : null;

            const now = Date.now();
            const doneChanged = (bulkLogUi.lastImportDone !== done);
            const shouldLog =
                  doneChanged &&
                  (done === 0 || done === 1 || done === total || (Number.isFinite(done) && done % 10 === 0) || (now - bulkLogUi.lastImportLogAt) > 1000);

            if (shouldLog) {
                bulkLogUi.lastImportDone = done;
                bulkLogUi.lastImportLogAt = now;

                bulkLogPush(
                    "info",
                    `Import: ${Number.isFinite(done) ? done : "?"}/${Number.isFinite(total) ? total : "?"} | OK: ${Number.isFinite(ok) ? ok : "?"} | Fehler: ${Number.isFinite(failed) ? failed : "?"} | Im Cache: ${Number.isFinite(cached) ? cached : "?"} | Noch zu laden: ${remaining == null ? "?" : remaining}`
      );
    }
      return;
  }

    // Import summary (Status block after queue run)
    const first = (txt.split("\n")[0] || "").trim();
    if (/^(Fertig\.|Abgebrochen\.)/i.test(first) && /(toFetch=|cached=|ok=|failed=)/i.test(txt)) {
        const total = parseInt((txt.match(/total=(\d+)/i) || [])[1], 10);
        const toFetch = parseInt((txt.match(/toFetch=(\d+)/i) || [])[1], 10);
        const ok = parseInt((txt.match(/ok=(\d+)/i) || [])[1], 10);
        const failed = parseInt((txt.match(/failed=(\d+)/i) || [])[1], 10);
        const cached = parseInt((txt.match(/cached=(\d+)/i) || [])[1], 10);

        if (Number.isFinite(total)) AD_bulkUpdateFoundMatches(total);
        AD_bulkUpdateImportMeta({ total, cached, toFetch, ok, failed });

        const aborted = /^Abgebrochen\./i.test(first);
        if (!aborted) AD_bulkSetProgress(100);

        bulkLogPush(
            aborted ? "warn" : "ok",
            `${aborted ? "Abgebrochen" : "Fertig"}. Gesamt: ${Number.isFinite(total) ? total : "?"} | Neu geladen: ${Number.isFinite(toFetch) ? toFetch : "?"} | Im Cache: ${Number.isFinite(cached) ? cached : "?"} | OK: ${Number.isFinite(ok) ? ok : "?"} | Fehler: ${Number.isFinite(failed) ? failed : "?"}`
    );
        return;
    }

    // Import error
    m = txt.match(/Import Fehler:\s*(.*)/i);
    if (m) {
        bulkLogPush("error", `Import fehlgeschlagen: ${String(m[1] || "").trim()}`);
        return;
    }
}

    function AD_bulkSetStatus(t) {
        const s = String(t ?? "");
        if (bulkStatusEl) bulkStatusEl.textContent = s;

        // Keep progress mode in sync (safety net)
        try { AD_bulkSetProgressMode(bulkState.running); } catch {}

        // Derive log/meta/progress updates from existing status stream
        try { AD_bulkMaybeLogFromStatus(s); } catch {}

        // Phase label (stable German)
        if (!bulkState.running) {
            AD_bulkSetPhase("Bereit.");
        } else if (bulkState.running === "collect") {
            AD_bulkSetPhase("Sammle Match-IDs…");
        } else if (bulkState.running === "import") {
            AD_bulkSetPhase("Importiere Statistiken…");
        }

        // (v0.14.13) Nach Stop-Klick: Anzeige neutral halten (Progress/Matches/Phase)
        if (bulkState?.uiResetOnStop && bulkState?.stopSignal?.stopped) {
            AD_bulkSetPhase("Bereit.");
            AD_bulkSetMeta("Matches gefunden: 0");
            try { AD_bulkSetProgress(0); } catch {}
        }

        // Terminal lines may override briefly
        const first = (s.split("\n")[0] || "").trim();
        if (/^(Abgebrochen\.|Fertig\.|Import Fehler)/i.test(first)) {
            AD_bulkSetPhase(first);
        } else if (/^(?:BG\s*)?Collect Fehler/i.test(first)) {
            AD_bulkSetPhase("Sammeln fehlgeschlagen.");
        }
    }

    function AD_bulkSetMeta(t) {
        if (bulkMetaEl) bulkMetaEl.textContent = String(t ?? "");
    }

    function AD_bulkIsHistoryListPage() {
        const p = String(location.pathname || "");
        return /^\/history\/matches\/?$/i.test(p);
    }

    function AD_bulkSleep(ms) {
        return new Promise(r => setTimeout(r, ms));
    }

    function AD_bulkSetProgressMode(mode) {
        const m = String(mode || "");
        const isCollect = (m === "collect");
        const isImport = (m === "import");

        try { bulkProgressWrapEl?.classList?.toggle?.("is-indeterminate", isCollect); } catch {}

        if (!bulkProgressBarEl) return;

        if (isCollect) {
            // Let CSS indeterminate take over
            try { bulkProgressBarEl.style.opacity = "1"; } catch {}
            try { bulkProgressBarEl.style.width = ""; } catch {}
            try { bulkProgressBarEl.style.animation = ""; } catch {}
            try { bulkProgressBarEl.style.transform = ""; } catch {}
            try { bulkProgressWrapEl?.removeAttribute?.("aria-valuenow"); } catch {}
            return;
        }

        // Ensure no indeterminate artifacts remain
        try { bulkProgressBarEl.style.animation = "none"; } catch {}
        try { bulkProgressBarEl.style.transform = "translateX(0)"; } catch {}

        if (isImport) {
            try { bulkProgressBarEl.style.opacity = "1"; } catch {}
            try {
                const cur = String(bulkProgressBarEl.style.width || "").trim();
                if (!cur) bulkProgressBarEl.style.width = "0%";
            } catch {}
            return;
        }

        // Idle: hide bar completely (no "rest pixel")
        try { bulkProgressBarEl.style.width = "0%"; } catch {}
        try { bulkProgressBarEl.style.opacity = "0"; } catch {}
        try { bulkProgressWrapEl?.removeAttribute?.("aria-valuenow"); } catch {}
    }

    function AD_bulkUpdateMeta() {
        const n = Number(bulkState.matchesFound || 0);
        AD_bulkSetMeta(`Matches gefunden: ${Number.isFinite(n) ? n : 0}`);
    }

    function AD_bulkUpdateUi() {
        const running = bulkState.running;
        const uiReset = !!(bulkState?.uiResetOnStop && bulkState?.stopSignal?.stopped);

        try { bulkPanel.dataset.running = running || "none"; } catch {}

        // Primary
        if (btnBulkRunAll) btnBulkRunAll.disabled = !!running;
        if (btnBulkStop) btnBulkStop.disabled = !running;

        // Phase + Meta
        if (uiReset) {
            AD_bulkSetPhase("Bereit.");
            AD_bulkSetMeta("Matches gefunden: 0");
        } else {
            if (!running) AD_bulkSetPhase("Bereit.");
            if (running === "collect") AD_bulkSetPhase("Sammle Match-IDs…");
            if (running === "import") AD_bulkSetPhase("Importiere Statistiken…");
            AD_bulkUpdateMeta();
        }

        // Progress bar mode
        AD_bulkSetProgressMode(uiReset ? null : running);

        if (uiReset) {
            try { bulkProgressWrapEl?.classList?.remove?.("is-indeterminate"); } catch {}
            try { bulkProgressWrapEl?.removeAttribute?.("aria-valuenow"); } catch {}
            try { if (bulkProgressBarEl) bulkProgressBarEl.style.width = "0%"; } catch {}
        }

        if (running === "import") {
            // Determinate
            try { bulkProgressWrapEl?.classList?.remove?.("is-indeterminate"); } catch {}
            try {
                const cur = String(bulkProgressBarEl?.style?.width || "").trim();
                if (!cur) AD_bulkSetProgress(0);
            } catch {}
        }

        if (!running) {
            try { bulkProgressWrapEl?.classList?.remove?.("is-indeterminate"); } catch {}
            try { bulkProgressWrapEl?.removeAttribute?.("aria-valuenow"); } catch {}
            try { if (bulkProgressBarEl) bulkProgressBarEl.style.width = "0%"; } catch {}
        }
    }


    // -------------------- Panel Docking --------------------
    function AD_bulkEnsureHistorySlot() {
        // disabled (v0.14.10): History inline slot removed (no DOM injection on /history/matches)
        return null;
    }


    function AD_attachBulkPanelMaybe(reason) {
        try {
            // Settings Slot only (v0.14.10): Bulk UI is exclusively embedded in /statistics Settings.
            const slotSettings = document.getElementById("ad-ext-settings-slot-bulk");
            if (slotSettings) {
                if (bulkPanel.parentNode !== slotSettings) {
                    try { slotSettings.innerHTML = ""; } catch {}
                    slotSettings.appendChild(bulkPanel);
                }
                bulkPanel.style.display = "";
                return;
            }

            // Outside Settings: keep hidden (never dock to /history/matches or any other page)
            if (!bulkPanel.isConnected) {
                try { document.body.appendChild(bulkPanel); } catch {}
            }
            bulkPanel.style.display = "none";
        } catch (e) {
            console.warn(LOG_PREFIX, "Bulk docking failed:", reason, e);
            try { bulkPanel.style.display = "none"; } catch {}
        }
    }


    // -------------------- Collect IDs (paged) --------------------
    const AD_BULK_UUID_RE = /\/history\/matches\/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i;

    function AD_bulkCollectMatchIdsFromDoc(doc) {
        const ids = new Set();

        const sel = [
            'a[href*="/history/matches/"]',
            '[data-href*="/history/matches/"]',
            '[to*="/history/matches/"]'
        ].join(",");

        for (const el of (doc?.querySelectorAll?.(sel) || [])) {
            const candidates = [
                el.getAttribute?.("href"),
                el.getAttribute?.("data-href"),
                el.getAttribute?.("to"),
                el.href,
                el.dataset?.href
            ];

            for (const c of candidates) {
                const s = String(c || "");
                const m = s.match(AD_BULK_UUID_RE);
                if (m && m[1]) ids.add(String(m[1]));
            }
        }

        return ids;
    }

    function AD_bulkCollectMatchIdsFromDom() {
        return AD_bulkCollectMatchIdsFromDoc(document);
    }


    function AD_bulkGetPageParam() {
        try {
            const u = new URL(location.href);
            const raw = u.searchParams.get("page");
            const n = parseInt(String(raw ?? ""), 10);
            if (Number.isFinite(n) && n >= 0) return n;
            return AD_BULK_SETTINGS.startPageDefault;
        } catch {
            return AD_BULK_SETTINGS.startPageDefault;
        }
    }

    function AD_bulkMakeUrlForPage(page) {
        const u = new URL(location.href);
        u.searchParams.set("page", String(page));
        return u.pathname + u.search + u.hash;
    }

    function AD_bulkSigOfIds(ids) {
        const arr = Array.from(ids);
        arr.sort();
        return arr.slice(0, 10).join("|");
    }

    function AD_bulkSpaNavigateTo(url) {
        try { history.pushState({}, "", url); } catch {
            try { location.href = url; } catch {}
            return;
        }
        try { window.dispatchEvent(new PopStateEvent("popstate")); } catch {
            try { window.dispatchEvent(new Event("popstate")); } catch {}
        }
    }

    async function AD_bulkWaitForNewPageContentInDoc(doc, prevPageSig, stopSignal) {
        const t0 = Date.now();
        while (!stopSignal.stopped && (Date.now() - t0) < AD_BULK_SETTINGS.waitRenderMs) {
            const ids = AD_bulkCollectMatchIdsFromDoc(doc);
            const sig = AD_bulkSigOfIds(ids);

            if (ids.size > 0 && sig !== prevPageSig) {
                await AD_bulkSleep(AD_BULK_SETTINGS.settleMs);
                return { ids, sig, changed: true };
            }

            await AD_bulkSleep(200);
        }

        const ids = AD_bulkCollectMatchIdsFromDoc(doc);
        return { ids, sig: AD_bulkSigOfIds(ids), changed: false };
    }

    async function AD_bulkWaitForNewPageContent(prevPageSig, stopSignal) {
        return AD_bulkWaitForNewPageContentInDoc(document, prevPageSig, stopSignal);
    }


    // -------------------- Headless Collect (iFrame primary) --------------------
    const AD_BULK_BC_NAME = "ad_bulk";
    const AD_BULK_COLLECTOR_IFRAME_ID = "ad-bulk-collector-iframe";

    // Runtime handle (used for Stop in background-tab mode)
    const bulkRuntime = {
        mode: null, // null | "iframe" | "bg"
        sessionId: null,
        bc: null,
        tab: null
    };

    function AD_bulkRuntimeClear() {
        bulkRuntime.mode = null;
        bulkRuntime.sessionId = null;
        try { bulkRuntime.bc?.close?.(); } catch {}
        bulkRuntime.bc = null;
        try { bulkRuntime.tab?.close?.(); } catch {}
        bulkRuntime.tab = null;
    }

    async function AD_bulkWaitUntil(fn, timeoutMs, stopSignal, intervalMs = 200) {
        const t0 = Date.now();
        while (!stopSignal?.stopped && (Date.now() - t0) < timeoutMs) {
            let ok = false;
            try { ok = !!fn(); } catch { ok = false; }
            if (ok) return true;
            await AD_bulkSleep(intervalMs);
        }
        return false;
    }

    function AD_bulkMakeHistoryListUrlForPage(page, extraParams) {
        const u = new URL("/history/matches", location.origin);
        u.searchParams.set("page", String(page));
        for (const [k, v] of Object.entries(extraParams || {})) {
            if (v == null) continue;
            u.searchParams.set(String(k), String(v));
        }
        return u.pathname + u.search + u.hash;
    }

    function AD_bulkGetOrCreateCollectorIframe() {
        let frame = document.getElementById(AD_BULK_COLLECTOR_IFRAME_ID);
        if (frame) return frame;

        frame = document.createElement("iframe");
        frame.id = AD_BULK_COLLECTOR_IFRAME_ID;
        frame.setAttribute("aria-hidden", "true");
        frame.setAttribute("tabindex", "-1");
        frame.style.cssText = [
            "position: fixed",
            "width: 1px",
            "height: 1px",
            "left: -9999px",
            "top: -9999px",
            "opacity: 0",
            "pointer-events: none",
            "border: 0"
        ].join(";");

        try { document.body.appendChild(frame); } catch {}
        return frame;
    }

    async function AD_bulkLoadCollectorIframe(frame, url, stopSignal) {
        if (stopSignal?.stopped) return false;

        const timeoutMs = Math.max(15000, AD_BULK_SETTINGS.waitRenderMs);

        // Force reload if same src
        try {
            const cur = String(frame.getAttribute("src") || frame.src || "");
            if (cur && cur.endsWith(url)) {
                try { frame.src = "about:blank"; } catch {}
                await AD_bulkSleep(50);
            }
        } catch {}

        await new Promise((resolve, reject) => {
            let done = false;
            const t = setTimeout(() => {
                if (done) return;
                done = true;
                cleanup();
                const e = new Error("iFrame load timeout");
                e.code = "IFRAME_TIMEOUT";
                reject(e);
            }, timeoutMs);

            function cleanup() {
                try { clearTimeout(t); } catch {}
                try { frame.removeEventListener("load", onLoad); } catch {}
                try { frame.removeEventListener("error", onErr); } catch {}
            }

            function onLoad() {
                if (done) return;
                done = true;
                cleanup();
                resolve(true);
            }

            function onErr() {
                if (done) return;
                done = true;
                cleanup();
                const e = new Error("iFrame load error");
                e.code = "IFRAME_LOAD_ERROR";
                reject(e);
            }

            try {
                frame.addEventListener("load", onLoad);
                frame.addEventListener("error", onErr);
            } catch {}

            try { frame.setAttribute("src", url); frame.src = url; } catch (e) {
                done = true;
                cleanup();
                reject(e);
            }
        });

        if (stopSignal?.stopped) return false;

        // Check same-origin access
        try {
            const doc = frame.contentDocument;
            const win = frame.contentWindow;
            if (!doc || !win) {
                const e = new Error("iFrame doc/window unavailable");
                e.code = "IFRAME_BLOCKED";
                throw e;
            }
            // Accessing location.href can throw when blocked
            void win.location.href;
        } catch (e) {
            const err = new Error("iFrame blocked (X-Frame-Options/CSP?)");
            err.code = "IFRAME_BLOCKED";
            err.cause = e;
            throw err;
        }

        return true;
    }

    function AD_bulkSpaNavigateInFrame(frame, url) {
        const win = frame?.contentWindow;
        if (!win) {
            const e = new Error("Frame window unavailable");
            e.code = "IFRAME_BLOCKED";
            throw e;
        }

        try { win.history.pushState({}, "", url); } catch {
            try { win.location.href = url; } catch {}
            return;
        }

        try { win.dispatchEvent(new win.PopStateEvent("popstate")); } catch {
            try { win.dispatchEvent(new win.Event("popstate")); } catch {}
        }
    }

    async function AD_bulkCollectIdsHeadless({ startPage = 0, maxPages = AD_BULK_SETTINGS.maxPagesSafety, stopSignal, statusCb }) {
        bulkRuntime.mode = "iframe";
        statusCb = statusCb || (() => {});

        const collected = new Set();
        const frame = AD_bulkGetOrCreateCollectorIframe();

        const startUrl = AD_bulkMakeHistoryListUrlForPage(startPage, { ad_bulk_iframe: "1" });

        statusCb(`Collect (headless) lade iFrame…\n${startUrl}`);

        await AD_bulkLoadCollectorIframe(frame, startUrl, stopSignal);

        if (stopSignal?.stopped) return [];

        // Wait until the SPA rendered something useful (IDs or at least mounted content)
        await AD_bulkWaitUntil(() => {
            const d = frame.contentDocument;
            if (!d) return false;
            const ids = AD_bulkCollectMatchIdsFromDoc(d);
            if (ids.size > 0) return true;
            const root = d.querySelector("main") || d.querySelector('[role="main"]') || d.querySelector("#root") || d.body;
            const t = String(root?.textContent || "").trim();
            return (t.length > 0);
        }, Math.max(AD_BULK_SETTINGS.waitRenderMs, 15000), stopSignal);

        if (stopSignal?.stopped) return [];

        await AD_bulkSleep(AD_BULK_SETTINGS.settleMs);

        let page = startPage;
        let prevPageSig = null;
        let pagesVisited = 0;

        const firstIds = AD_bulkCollectMatchIdsFromDoc(frame.contentDocument);
        const firstSig = AD_bulkSigOfIds(firstIds);

        for (const id of firstIds) collected.add(id);
        prevPageSig = firstSig;
        pagesVisited++;

        statusCb(`Collect start page=${page}\nonPage=${firstIds.size} | total=${collected.size}`);

        if (AD_BULK_SETTINGS.stopOnEmptyPage && firstIds.size === 0) {
            const out = Array.from(collected);
            out.sort();
            return out;
        }

        for (let i = 0; i < maxPages && !stopSignal?.stopped; i++) {
            const nextPage = page + 1;
            const url = AD_bulkMakeHistoryListUrlForPage(nextPage, { ad_bulk_iframe: "1" });

            AD_bulkSpaNavigateInFrame(frame, url);

            const { ids, sig } = await AD_bulkWaitForNewPageContentInDoc(frame.contentDocument, prevPageSig, stopSignal);

            if (AD_BULK_SETTINGS.stopOnEmptyPage && ids.size === 0) {
                statusCb(`Collect stop: page=${nextPage} leer.\nTotal IDs=${collected.size}`);
                break;
            }

            if (AD_BULK_SETTINGS.stopOnRepeatPage && sig === prevPageSig) {
                statusCb(`Collect stop: page=${nextPage} wiederholt letzte Seite.\nTotal IDs=${collected.size}`);
                break;
            }

            const before = collected.size;
            for (const id of ids) collected.add(id);
            const newOnPage = collected.size - before;

            pagesVisited++;
            page = nextPage;
            prevPageSig = sig;

            statusCb(
                `Collect page=${page}\n` +
                `onPage=${ids.size} | new=${newOnPage} | total=${collected.size}\n` +
                `pagesVisited=${pagesVisited}`
      );

            if (newOnPage === 0) {
                statusCb(`Collect stop: page=${page} brachte keine neuen IDs.\nTotal IDs=${collected.size}`);
                break;
            }
        }

        const out = Array.from(collected);
        out.sort();
        return out;
    }

    async function AD_bulkCollectIdsInBackgroundTab({ startPage = 0, maxPages = AD_BULK_SETTINGS.maxPagesSafety, stopSignal, statusCb }) {
        statusCb = statusCb || (() => {});
        bulkRuntime.mode = "bg";

        // BroadcastChannel + session correlation
        const sessionId = `${Date.now()}-${Math.random().toString(16).slice(2)}`;
        bulkRuntime.sessionId = sessionId;

        let bc = null;
        try {
            if (typeof BroadcastChannel !== "undefined") bc = new BroadcastChannel(AD_BULK_BC_NAME);
        } catch { bc = null; }

        if (!bc) {
            const e = new Error("BroadcastChannel not available");
            e.code = "BC_UNAVAILABLE";
            throw e;
        }

        bulkRuntime.bc = bc;

        const openTabFn =
              (typeof GM_openInTab === "function") ? GM_openInTab :
        (typeof GM !== "undefined" && typeof GM.openInTab === "function") ? GM.openInTab :
        null;

        if (!openTabFn) {
            const e = new Error("GM_openInTab not available");
            e.code = "GM_openInTab_MISSING";
            throw e;
        }

        const u = new URL("/history/matches", location.origin);
        u.searchParams.set("page", String(startPage));
        u.searchParams.set("ad_bulk_bg", "1");
        u.searchParams.set("ad_bulk_session", sessionId);
        u.searchParams.set("ad_bulk_maxPages", String(maxPages));
        u.searchParams.set("ad_bulk_waitRenderMs", String(AD_BULK_SETTINGS.waitRenderMs));
        u.searchParams.set("ad_bulk_settleMs", String(AD_BULK_SETTINGS.settleMs));

        statusCb("iFrame blockiert → Collect läuft im Hintergrund (Tab bleibt unsichtbar)…");

        const tab = openTabFn(u.pathname + u.search + u.hash, { active: false, insert: true, setParent: true });
        bulkRuntime.tab = tab;

        return await new Promise((resolve, reject) => {
            let done = false;

            const cleanup = () => {
                if (done) return;
                done = true;
                try { bc.close(); } catch {}
                try { tab?.close?.(); } catch {}
                bulkRuntime.bc = null;
                bulkRuntime.tab = null;
                bulkRuntime.sessionId = null;
                bulkRuntime.mode = null;
            };

            const stopTimer = setInterval(() => {
                if (!stopSignal?.stopped) return;
                try { bc.postMessage({ type: "stop", sessionId }); } catch {}
                cleanup();
                const e = new Error("Stopped");
                e.code = "STOPPED";
                reject(e);
            }, 200);

            const onMsg = (ev) => {
                const m = ev?.data || {};
                if (!m || m.sessionId !== sessionId) return;

                if (m.type === "status") {
                    statusCb(String(m.text || ""));
                    return;
                }

                if (m.type === "done") {
                    try { statusCb(String(m.text || "")); } catch {}
                    clearInterval(stopTimer);
                    cleanup();
                    resolve((m.ids || []).map(String));
                    return;
                }

                if (m.type === "stopped") {
                    try { statusCb(String(m.text || "")); } catch {}
                    clearInterval(stopTimer);
                    cleanup();
                    const ids = (m.ids || []).map(String);
                    resolve(ids);
                    return;
                }

                if (m.type === "error") {
                    clearInterval(stopTimer);
                    cleanup();
                    const e = new Error(String(m.text || "BG collector error"));
                    e.code = "BG_ERROR";
                    reject(e);
                }
            };

            try { bc.addEventListener("message", onMsg); } catch {
                bc.onmessage = onMsg;
            }
        });
    }

    async function AD_bulkCollectIdsSmart({ startPage = AD_BULK_SETTINGS.startPageDefault, maxPages = AD_BULK_SETTINGS.maxPagesSafety, stopSignal, statusCb }) {
        statusCb = statusCb || (() => {});

        const isIframeCode = (c) => (c === "IFRAME_BLOCKED" || c === "IFRAME_TIMEOUT" || c === "IFRAME_LOAD_ERROR");

        try {
            return await AD_bulkCollectIdsHeadless({ startPage, maxPages, stopSignal, statusCb });
        } catch (e) {
            if (stopSignal?.stopped) throw e;

            let code = String(e?.code || "");
            if (code && !isIframeCode(code)) {
                // Not an iframe-related failure → surface it
                throw e;
            }

            // (v0.14.13) iFrame-Collect einmal kurz retryen, bevor BG-Tab Fallback startet.
            if (!stopSignal?.stopped && isIframeCode(code)) {
                try {
                    bulkLogPush("warn", "Collector Retry…");
                } catch {}
                try {
                    statusCb(`Collector Retry… (${code || "unknown"})`);
                } catch {}

                // Force a fresh iframe attempt
                try {
                    const f = document.getElementById(AD_BULK_COLLECTOR_IFRAME_ID);
                    if (f) f.src = "about:blank";
                } catch {}
                await AD_bulkSleep(100);

                const oldWait = AD_BULK_SETTINGS.waitRenderMs;
                const oldSettle = AD_BULK_SETTINGS.settleMs;
                // "kurz" – second attempt with tighter timings, then restore.
                try {
                    AD_BULK_SETTINGS.waitRenderMs = Math.min(oldWait, 3500);
                    AD_BULK_SETTINGS.settleMs = Math.min(oldSettle, 150);
                    return await AD_bulkCollectIdsHeadless({ startPage, maxPages, stopSignal, statusCb });
                } catch (e2) {
                    e = e2;
                    code = String(e?.code || code || "");
                } finally {
                    AD_BULK_SETTINGS.waitRenderMs = oldWait;
                    AD_BULK_SETTINGS.settleMs = oldSettle;
                }
            }

            // Fallback: background tab collector
            statusCb(`iFrame Collector fehlgeschlagen (${code || "unknown"}). Fallback…`);
            try {
                return await AD_bulkCollectIdsInBackgroundTab({ startPage, maxPages, stopSignal, statusCb });
            } catch (fbErr) {
                // Visible feedback + release UI early (safety)
                try { bulkLogPush("error", `Fallback fehlgeschlagen: ${fbErr?.message || fbErr}`); } catch {}
                try { bulkState.running = null; } catch {}
                try { AD_bulkRuntimeClear(); } catch {}
                try { AD_bulkUpdateUi(); } catch {}
                throw fbErr;
            }
        } finally {
            if (bulkRuntime.mode === "iframe") {
                // keep iframe for reuse, but clear mode
                bulkRuntime.mode = null;
            }
        }
    }

    async function AD_bulkCollectAllPages(statusCb, stopSignal) {
        const collected = new Set();

        let page = AD_bulkGetPageParam();
        let prevPageSig = null;
        let pagesVisited = 0;

        const firstIds = AD_bulkCollectMatchIdsFromDom();
        const firstSig = AD_bulkSigOfIds(firstIds);

        for (const id of firstIds) collected.add(id);
        prevPageSig = firstSig;
        pagesVisited++;

        statusCb(`Collect start page=${page}\nonPage=${firstIds.size} | total=${collected.size}`);

        if (AD_BULK_SETTINGS.stopOnEmptyPage && firstIds.size === 0) return collected;

        for (let i = 0; i < AD_BULK_SETTINGS.maxPagesSafety && !stopSignal.stopped; i++) {
            const nextPage = page + 1;
            const url = AD_bulkMakeUrlForPage(nextPage);

            AD_bulkSpaNavigateTo(url);

            const { ids, sig } = await AD_bulkWaitForNewPageContent(prevPageSig, stopSignal);

            if (AD_BULK_SETTINGS.stopOnEmptyPage && ids.size === 0) {
                statusCb(`Collect stop: page=${nextPage} leer.\nTotal IDs=${collected.size}`);
                break;
            }

            if (AD_BULK_SETTINGS.stopOnRepeatPage && sig === prevPageSig) {
                statusCb(`Collect stop: page=${nextPage} wiederholt letzte Seite.\nTotal IDs=${collected.size}`);
                break;
            }

            const before = collected.size;
            for (const id of ids) collected.add(id);
            const newOnPage = collected.size - before;

            pagesVisited++;
            page = nextPage;
            prevPageSig = sig;

            statusCb(
                `Collect page=${page}\n` +
                `onPage=${ids.size} | new=${newOnPage} | total=${collected.size}\n` +
                `pagesVisited=${pagesVisited}`
      );

        if (newOnPage === 0) {
            statusCb(`Collect stop: page=${page} brachte keine neuen IDs.\nTotal IDs=${collected.size}`);
            break;
        }
    }

    return collected;
}

    // -------------------- Import queue --------------------

    async function AD_bulkIdbGetAllKeys(db) {
        return new Promise((resolve, reject) => {
            try {
                const tx = db.transaction("match_stats", "readonly");
                const store = tx.objectStore("match_stats");
                const req = store.getAllKeys();
                req.onsuccess = () => resolve(new Set((req.result || []).map(String)));
                req.onerror = () => reject(req.error);
            } catch (e) {
                reject(e);
            }
        });
    }

    async function AD_bulkFetchAndCacheStatsOnceOnDb(db, matchId) {
        const url = `${API_HOST}/as/v0/matches/${encodeURIComponent(matchId)}/stats`;
        const stats = await gmRequestJson("GET", url);

        if (!stats || (typeof stats === "object" && !Array.isArray(stats) && Object.keys(stats).length === 0)) {
            const e = new Error("Empty stats payload");
            e.status = 0;
            throw e;
        }

        const fetchedAt = Date.now();
        await idbPut(db, "match_stats", { matchId, fetchedAt, stats });
        return { stats, fetchedAt };
    }

    function AD_bulkIsRetryableError(e) {
        const st = Number(e?.status || 0);
        if (st === 404) return false;
        if (st === 0) return true; // network / empty stats treated as retryable
        if (st === 408 || st === 425 || st === 429) return true;
        if (st >= 500 && st <= 599) return true;
        return true; // default retry for unknown
    }

    async function AD_bulkFetchAndCacheStatsWithRetry(db, matchId, stopSignal) {
        let lastErr = null;
        for (let attempt = 0; attempt <= AD_BULK_SETTINGS.maxRetries; attempt++) {
            if (stopSignal.stopped) {
                const e = new Error("Stopped");
                e.status = 0;
                throw e;
            }

            try {
                return await AD_bulkFetchAndCacheStatsOnceOnDb(db, matchId);
            } catch (e) {
                lastErr = e;
                const retryable = AD_bulkIsRetryableError(e);
                if (!retryable || attempt >= AD_BULK_SETTINGS.maxRetries) throw e;

                const wait = AD_BULK_SETTINGS.retryBaseDelayMs * Math.pow(2, attempt);
                await AD_bulkSleep(wait);
            }
        }
        throw lastErr || new Error("Retry failed");
    }

    async function AD_bulkRunQueue({ ids, cachedKeys, db, statusCb, stopSignal }) {
        const todo = ids.filter(id => !cachedKeys.has(id));

        let done = 0, ok = 0, failed = 0;
        let lastOkMatchId = null;
        let lastOkFetchedAt = null;

        const cached = ids.length - todo.length;
        statusCb(`Queue: total=${ids.length} | cached=${cached} | toFetch=${todo.length}`);

        let idx = 0;
        async function worker(n) {
            while (!stopSignal.stopped) {
                const my = idx++;
                if (my >= todo.length) return;

                const matchId = todo[my];
                try {
                    const res = await AD_bulkFetchAndCacheStatsWithRetry(db, matchId, stopSignal);
                    ok++;
                    lastOkMatchId = matchId;
                    lastOkFetchedAt = res?.fetchedAt || Date.now();
                } catch (e) {
                    if (stopSignal.stopped) return;
                    failed++;
                    try { warn(`Bulk worker ${n} failed for ${matchId}:`, e?.status || e); } catch {}
                } finally {
                    done++;
                    statusCb(`Import: done=${done}/${todo.length} | ok=${ok} | failed=${failed} | cached=${cached}`);
                    await AD_bulkSleep(AD_BULK_SETTINGS.delayMs);
                }
            }
        }

        await Promise.allSettled(Array.from({ length: AD_BULK_SETTINGS.concurrency }, (_, i) => worker(i + 1)));
        return { total: ids.length, toFetch: todo.length, ok, failed, cached, lastOkMatchId, lastOkFetchedAt };
    }

    // (v0.14.10) Collect läuft headless (kein sichtbares Navigieren zur History-Liste).

    // -------------------- Button Wiring --------------------

    btnBulkStop?.addEventListener("click", () => {
        if (!bulkState.running) return;

        bulkState.stopSignal.stopped = true;
        if (btnBulkStop) btnBulkStop.disabled = true;

        // (v0.14.13) Sofortiges UI-Reset beim Stop-Klick (ohne auf finally zu warten)
        bulkState.uiResetOnStop = true;
        bulkState.matchesFound = 0;
        bulkState.collectedIds = [];
        bulkState.pagesChecked = 0;
        bulkState.importMeta = { total: 0, cached: 0, toFetch: 0, done: 0, ok: 0, failed: 0 };
        AD_bulkSetProgress(0);
        AD_bulkSetPhase("Bereit.");
        AD_bulkSetMeta("Matches gefunden: 0");
        AD_bulkUpdateUi();
        try { bulkLogPush("warn", "Abbruch – Anzeige zurückgesetzt."); } catch {}

        // Stop background-tab collector if active
        try {
            if (bulkRuntime?.mode === "bg" && bulkRuntime.bc && bulkRuntime.sessionId) {
                bulkRuntime.bc.postMessage({ type: "stop", sessionId: bulkRuntime.sessionId });
            }
            try { bulkRuntime?.tab?.close?.(); } catch {}
        } catch {}

        // Best-effort: halt iframe activity
        try {
            if (bulkRuntime?.mode === "iframe") {
                const f = document.getElementById(AD_BULK_COLLECTOR_IFRAME_ID);
                if (f) f.src = "about:blank";
            }
        } catch {}

        AD_bulkSetStatus("Stop angefordert…");
    });
    btnBulkRunAll?.addEventListener("click", async () => {
        if (bulkState.running) return;

        // (v0.14.13) Sofortiges Feedback: klick greift auch wenn async init verzögert
        try { bulkLogPush("info", "Start: Sammeln & Import initialisiert…"); } catch {}
        try { if (btnBulkRunAll) btnBulkRunAll.disabled = true; } catch {}
        bulkState.uiResetOnStop = false;

        // One-click flow: Collect → Import
        bulkState.running = "collect";
        bulkState.stopSignal = { stopped: false };
        bulkState.collectedIds = [];
        bulkState.matchesFound = 0;
        bulkState.pagesChecked = 0;
        bulkState.importMeta = { total: 0, cached: 0, toFetch: 0, done: 0, ok: 0, failed: 0 };
        bulkLogUi.lastCollectPage = null;
        bulkLogUi.lastImportDone = null;
        bulkLogUi.lastImportLogAt = 0;
        bulkLogUi.lastQueueSig = null;

        AD_bulkUpdateUi();
        bulkLogPush("info", "Sammle Match-IDs…");

        try {
            // -------- Collect --------
            try {
                AD_bulkSetStatus("Sammle Match-IDs…");
                const ids = await AD_bulkCollectIdsSmart({
                    startPage: AD_BULK_SETTINGS.startPageDefault,
                    maxPages: AD_BULK_SETTINGS.maxPagesSafety,
                    stopSignal: bulkState.stopSignal,
                    statusCb: AD_bulkSetStatus
                });

                // Normalize
                const uniq = Array.from(new Set((ids || []).map(String)));
                uniq.sort();
                bulkState.collectedIds = uniq;
                bulkState.matchesFound = uniq.length;

                if (bulkState.stopSignal.stopped) {
                    AD_bulkSetStatus(`Abgebrochen.\nMatches gefunden: ${bulkState.collectedIds.length}`);
                    return;
                }

                if (!bulkState.collectedIds.length) {
                    AD_bulkSetStatus("Sammeln beendet.\nMatches gefunden: 0");
                    return;
                }

                AD_bulkSetStatus(`Matches gefunden: ${bulkState.collectedIds.length}. Starte Import…`);
            } catch (e) {
                const code = String(e?.code || "");
                if (bulkState.stopSignal.stopped || code === "STOPPED") {
                    AD_bulkSetStatus(`Abgebrochen.
Matches gefunden: ${bulkState.collectedIds.length}`);
                } else {
                    AD_bulkSetStatus(`Sammeln Fehler: ${e?.message || e}`);
                }
                return;
            } finally {
                // Ensure collector runtime is cleaned before import
                try { AD_bulkRuntimeClear(); } catch {}
            }

            // -------- Import --------
            bulkState.running = "import";
            bulkLogPush("info", "Importiere Statistiken…");
            AD_bulkSetProgress(0);
            AD_bulkUpdateUi();

            try {
                AD_bulkSetStatus("Öffne IndexedDB…");
                const db = await openDb();

                AD_bulkSetStatus("Lese Cache-Keys…");
                const cached = await AD_bulkIdbGetAllKeys(db);

                const res = await AD_bulkRunQueue({
                    ids: bulkState.collectedIds,
                    cachedKeys: cached,
                    db,
                    statusCb: AD_bulkSetStatus,
                    stopSignal: bulkState.stopSignal
                });

                const aborted = bulkState.stopSignal.stopped;

                AD_bulkSetStatus(
                    `${aborted ? "Abgebrochen." : "Fertig."}\n` +
                    `total=${res.total}\n` +
                    `toFetch=${res.toFetch}\n` +
                    `ok=${res.ok}\n` +
                    `failed=${res.failed}\n` +
                    `cached=${res.cached}`
        );

                // Optional: Cache update signal
                if (res?.lastOkMatchId) {
                    try { AD_notifyCacheUpdated(res.lastOkMatchId, res?.lastOkFetchedAt || Date.now()); } catch {}
                }
            } catch (e) {
                AD_bulkSetStatus(`Import Fehler: ${e?.message || e}`);
            }
        } finally {
            const wasStopped = !!bulkState.stopSignal?.stopped;
            bulkState.running = null;
            bulkState.stopSignal = { stopped: false };
            try { AD_bulkRuntimeClear(); } catch {}

            // (v0.14.13) Safety net: nach Stop keine alten Meta-Werte hängen lassen
            if (wasStopped) {
                bulkState.matchesFound = 0;
                bulkState.collectedIds = [];
                bulkState.pagesChecked = 0;
                bulkState.importMeta = { total: 0, cached: 0, toFetch: 0, done: 0, ok: 0, failed: 0 };
                try { AD_bulkSetProgress(0); } catch {}
                try { AD_bulkSetPhase("Bereit."); } catch {}
                try { AD_bulkSetMeta("Matches gefunden: 0"); } catch {}
            }

            bulkState.uiResetOnStop = false;
            AD_bulkUpdateUi();
        }
    });


    // Initial UI state
    AD_bulkUpdateUi();

    // -------------------- Settings (localStorage) --------------------
    function AD_readBool(key, defVal) {
        try {
            const raw = localStorage.getItem(key);
            if (raw == null) return !!defVal;
            if (raw === "1" || raw === "true" || raw === "yes" || raw === "on") return true;
            if (raw === "0" || raw === "false" || raw === "no" || raw === "off") return false;
            return !!defVal;
        } catch {
            return !!defVal;
        }
    }

    function AD_writeBool(key, val) {
        try { localStorage.setItem(key, val ? "1" : "0"); } catch {}
    }

    // Default: an (auto-import) + nur wenn nicht im Cache
    if (optAutoImport) optAutoImport.checked = AD_readBool(AD_LS_KEY_AUTOIMPORT_ENABLED, AD_AUTOIMPORT_DEFAULT_ENABLED);
    if (optOnlyIfNotCached) optOnlyIfNotCached.checked = AD_readBool(AD_LS_KEY_AUTOIMPORT_ONLY_IF_NOT_CACHED, AD_AUTOIMPORT_DEFAULT_ONLY_IF_NOT_CACHED);

    optAutoImport?.addEventListener("change", () => AD_writeBool(AD_LS_KEY_AUTOIMPORT_ENABLED, !!optAutoImport.checked));
    optOnlyIfNotCached?.addEventListener("change", () => AD_writeBool(AD_LS_KEY_AUTOIMPORT_ONLY_IF_NOT_CACHED, !!optOnlyIfNotCached.checked));


    // -------------------- UI attach/visibility (kein Floating Overlay) --------------------
    function AD_attachApiPanelMaybe(reason) {
        try {
            const slot = document.getElementById("ad-ext-settings-slot-importer");

            if (slot) {
                if (panel.parentNode !== slot) {
                    // Slot kann Placeholder enthalten → reinigen
                    try { slot.innerHTML = ""; } catch {}
                    slot.appendChild(panel);
                }
                panel.classList.add("adApiPanel--embedded");
                panel.style.display = "";
            } else {
                // außerhalb der Settings-Seite: Panel verstecken (Tracker läuft weiter)
                if (!panel.isConnected) {
                    try { document.body.appendChild(panel); } catch {}
                }
                panel.classList.add("adApiPanel--embedded");
                panel.style.display = "none";
            }
        } catch (e) {
            console.warn(LOG_PREFIX, "UI attach/visibility failed:", reason, e);
            try { panel.style.display = "none"; } catch {}
        }
    }

    // Legacy Hook: Viewer kann (historisch) Visibility togglen – UI bleibt aber ausschließlich im Settings-Panel sichtbar.
    function AD_applyPanelVisibility(reason) {
        AD_attachApiPanelMaybe(reason || "applyPanelVisibility");
    }

    // Initial anwenden
    AD_applyPanelVisibility("init");

    // Same-Tab: Viewer dispatcht ein CustomEvent, damit es sofort wirkt
    window.addEventListener(AD_IMPORTER_UI_VISIBILITY_EVENT, (ev) => {
        try {
            const visible = !!ev?.detail?.visible;
            AD_writeBool(AD_LS_KEY_IMPORTER_UI_VISIBLE, visible);
            AD_applyPanelVisibility();
            console.debug("[AD API] UI visibility set via event:", visible);
        } catch (e) {
            console.warn("[AD API] UI visibility event failed:", e);
        }
    });

    // Cross-Tab/Script-Grenzen: localStorage storage-event (kommt nur in ANDEREN Tabs)
    window.addEventListener("storage", (e) => {
        if (e && e.key === AD_LS_KEY_IMPORTER_UI_VISIBLE) {
            AD_applyPanelVisibility();
            console.debug("[AD API] UI visibility updated via storage.");
        }
    });


    function setStatus(text, ok = true) {
        statusEl.textContent = text;
        statusEl.classList.toggle("ok", ok);
        statusEl.classList.toggle("bad", !ok);
    }

    function renderContext(ctx) {
        ui.matchId = ctx.matchId;
        ui.route = ctx.route;

        // Im Settings-Panel (Statistics) gibt es keine Match-ID → neutraler Status.
        if (!ctx.matchId) {
            // Nur "Bereit." zurücksetzen, wenn noch kein sinnvoller Status da ist.
            const t = (statusEl.textContent || "").trim();
            if (!t || t.startsWith("Öffne ein Match")) setStatus("Bereit.", true);
            return;
        }

        // Kurzer Info-Status (Auto-Import/Cache läuft ggf. im Hintergrund)
        setStatus(`Match erkannt (${ctx.route}).`, true);
    }

    async function actionResetDb() {
        const msg = "⚠️ Achtung: Dadurch wird der komplette lokale Cache (IndexedDB) gelöscht. Statistiken müssen danach neu geladen werden. Fortfahren?";
        const ok = (() => { try { return window.confirm(msg); } catch { return false; } })();
        if (!ok) {
            setStatus("Abgebrochen.", true);
            return;
        }

        try {
            if (btnResetDb) btnResetDb.disabled = true;
            setStatus("Reset läuft…", true);
            await deleteDatabase();
            setStatus("DB zurückgesetzt.", true);
        } catch (e) {
            err("Reset DB failed:", e);
            setStatus("Fehler: Konnte DB nicht löschen (siehe Konsole).", false);
        } finally {
            try { if (btnResetDb) btnResetDb.disabled = false; } catch {}
        }
    }

    // Wire minimal UI
    btnResetDb?.addEventListener("click", actionResetDb);


    // -------------------- Auto-Import Logic --------------------
    // Ziel: Wenn Autodarts nach Match-Ende auf /history/matches/<MATCH_ID> navigiert,
    // automatisch /stats holen + cachen + Viewer informieren.
    //
    // Viewer-Sync:
    //  - CustomEvent "ad-cache-updated" (gleicher Tab / gleiches Fenster)
    //  - localStorage Marker "ad_cache_updated" (damit es auch über Tabs/Scripts geht)
    function AD_notifyCacheUpdated(matchId, fetchedAt) {
        try {
            window.dispatchEvent(new CustomEvent("ad-cache-updated", { detail: { matchId, fetchedAt } }));
        } catch {}
        // Marker für andere Tabs/Scripts: Viewer hört auf "storage" Event und liest diesen Key.
        try {
            localStorage.setItem(AD_LS_CACHE_UPDATED_KEY, JSON.stringify({ matchId, fetchedAt }));
        } catch {}
    }

    const AD_autoImportInFlight = new Set(); // matchId
    let AD_lastAutoImportedMatchId = null;
    let AD_autoImportDebounceT = null;

    function AD_sleep(ms) {
        return new Promise((r) => setTimeout(r, ms));
    }

    async function AD_hasStatsInCache(matchId) {
        try {
            const db = await openDb();
            const rec = await idbGet(db, "match_stats", matchId);
            return !!(rec && rec.stats);
        } catch (e) {
            // im Zweifel: "nicht im Cache" → lieber importieren
            warn("Cache-check failed:", e?.message || e);
            return false;
        }
    }

    async function AD_fetchAndCacheStatsOnce(matchId) {
        const db = await openDb();
        const url = `${API_HOST}/as/v0/matches/${encodeURIComponent(matchId)}/stats`;
        const stats = await gmRequestJson("GET", url);

        // Treat "empty object" as not ready (kommt manchmal kurz nach Match-Ende)
        if (!stats || (typeof stats === "object" && !Array.isArray(stats) && Object.keys(stats).length === 0)) {
            const e = new Error("Empty stats payload");
            e.status = 0;
            throw e;
        }

        const fetchedAt = Date.now();
        await idbPut(db, "match_stats", { matchId, fetchedAt, stats });
        return { stats, fetchedAt };
    }

    async function AD_importStatsWithRetry(matchId, { force = false } = {}) {
        if (!matchId) return { ok: false, skipped: true, reason: "no-matchId" };

        // Optional: nur auf History-Matches auto-importen
        if (ui.route !== "history") return { ok: false, skipped: true, reason: "not-history" };

        if (!force && optOnlyIfNotCached?.checked) {
            const has = await AD_hasStatsInCache(matchId);
            if (has) {
                console.debug(LOG_PREFIX, "Auto-import skipped (already cached):", matchId);
                return { ok: false, skipped: true, reason: "cached" };
            }
        }

        // Dedupe / In-flight Lock
        if (!force) {
            if (AD_autoImportInFlight.has(matchId)) return { ok: false, skipped: true, reason: "in-flight" };
            if (AD_lastAutoImportedMatchId === matchId) return { ok: false, skipped: true, reason: "already-imported" };
        }

        AD_autoImportInFlight.add(matchId);

        try {
            const isForceText = force ? " (force)" : "";
            console.debug(LOG_PREFIX, `Auto-import start${isForceText}:`, matchId);

            // Wenn option "Nur wenn nicht im Cache" AUS ist, skippen wir trotzdem nicht automatisch.
            // Das ist bewusst für Debug/Manuelles Reimporten pro neuem Match.
            const delays = Array.isArray(AD_STATS_RETRY_DELAYS_MS) ? AD_STATS_RETRY_DELAYS_MS : [1000, 2000, 4000];

            let lastErr = null;
            for (let attempt = 0; attempt <= delays.length; attempt++) {
                try {
                    if (attempt > 0) {
                        const waitMs = delays[Math.min(attempt - 1, delays.length - 1)] || 1000;
                        console.debug(LOG_PREFIX, `Retry ${attempt}/${delays.length} in ${waitMs}ms…`, matchId);
                        setStatus(`Auto-import: Retry ${attempt}/${delays.length} (${Math.round(waitMs/1000)}s)…`, false);
                        await AD_sleep(waitMs);

                        // Wenn user inzwischen weg navigiert ist und wir nicht "force" sind → sauber abbrechen.
                        if (!force && ui.matchId !== matchId) {
                            console.debug(LOG_PREFIX, "Auto-import aborted (navigated away):", matchId);
                            return { ok: false, skipped: true, reason: "navigated-away" };
                        }
                    }

                    setStatus(`Auto-import: Lade /stats${force ? " (force)" : ""}…`, true);
                    const { stats, fetchedAt } = await AD_fetchAndCacheStatsOnce(matchId);

                    AD_lastAutoImportedMatchId = matchId;

                    setStatus(`Auto-import OK: /stats gecached (${new Date(fetchedAt).toLocaleTimeString()})`, true);
                    AD_notifyCacheUpdated(matchId, fetchedAt);

                    return { ok: true, matchId, fetchedAt, stats };
                } catch (e) {
                    lastErr = e;
                    const status = e?.status;
                    const msg = e?.message || String(e);

                    // Live-Match: /stats nicht erlaubt
                    const apiMsg = (e?.body?.error?.message) ? e.body.error.message : "";
                    if (status === 400 && String(apiMsg).toLowerCase().includes("live stats not supported")) {
                        warn("Auto-import: Live stats not supported – skip.", matchId);
                        return { ok: false, skipped: true, reason: "live-not-supported" };
                    }

                    // letzte Runde? → raus
                    if (attempt >= delays.length) break;

                    // sonst: retry (404/500/timeout/empty)
                    console.warn(LOG_PREFIX, "Auto-import failed (will retry):", matchId, status || "", msg);
                }
            }

            // final error
            err("Auto-import endgültig fehlgeschlagen:", matchId, lastErr);
            setStatus(`Auto-import FEHLER: ${lastErr?.message || lastErr}`, false);
            return { ok: false, skipped: false, error: lastErr };
        } finally {
            AD_autoImportInFlight.delete(matchId);
        }
    }

    function AD_scheduleAutoImport(matchId, reason) {
        if (!optAutoImport?.checked) return;
        if (!matchId) return;
        if (ui.route !== "history") return;

        if (AD_autoImportDebounceT) clearTimeout(AD_autoImportDebounceT);
        AD_autoImportDebounceT = setTimeout(() => {
            AD_autoImportDebounceT = null;
            AD_importStatsWithRetry(matchId, { force: false }).catch((e) => {
                err("Auto-import uncaught error:", e);
            });
        }, AD_AUTOIMPORT_DEBOUNCE_MS);

        console.debug(LOG_PREFIX, "Auto-import scheduled:", matchId, "reason:", reason);
    }

    // -------------------- SPA Navigation Hook --------------------
    function handleUrlChange(reason) {
        // Panel nur im Settings-Panel sichtbar halten (nie als Overlay)
        try { AD_attachApiPanelMaybe(reason); } catch {}
        try { AD_attachBulkPanelMaybe(reason); } catch {}
        try { AD_syncMaybeAutoStart(reason); } catch {}


        const ctx = getMatchContextFromPath(location.pathname);
        const changed = (ctx.matchId !== ui.matchId) || (ctx.route !== ui.route);

        if (!changed) return;

        log("URL change:", reason, location.href);
        renderContext(ctx);

        // Auto-Import nur für History-Match-Seiten (nach Match-Ende)
        if (ctx?.isHistory && ctx?.matchId) {
            AD_scheduleAutoImport(ctx.matchId, reason);
        }
    }

    function hookHistoryMethods() {
        const _pushState = history.pushState;
        const _replaceState = history.replaceState;

        history.pushState = function (...args) {
            const ret = _pushState.apply(this, args);
            handleUrlChange("pushState");
            return ret;
        };

        history.replaceState = function (...args) {
            const ret = _replaceState.apply(this, args);
            handleUrlChange("replaceState");
            return ret;
        };

        window.addEventListener("popstate", () => handleUrlChange("popstate"));
    }

    hookHistoryMethods();
    handleUrlChange("init");

    // Fallback falls intern anders navigiert wird
    setInterval(() => handleUrlChange("interval"), 800);

})();