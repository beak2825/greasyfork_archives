// ==UserScript==
// @name         Symfony 翻译文档 doctrine.html
// @namespace    fireloong
// @version      0.1.3
// @description  翻译文档 doctrine.html
// @author       Itsky71
// @match        https://symfony.com/doc/5.x/doctrine.html
// @match        https://symfony.com/doc/6.4/doctrine.html
// @match        https://symfony.com/doc/7.1/doctrine.html
// @match        https://symfony.com/doc/7.2/doctrine.html
// @match        https://symfony.com/doc/current/doctrine.html
// @icon         https://www.google.com/s2/favicons?sz=64&domain=symfony.com
// @require      https://unpkg.com/jquery@3.7.1/dist/jquery.min.js
// @grant        none
// @license      MIT
// @downloadURL https://update.greasyfork.org/scripts/496324/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20doctrinehtml.user.js
// @updateURL https://update.greasyfork.org/scripts/496324/Symfony%20%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3%20doctrinehtml.meta.js
// ==/UserScript==

(function($) {
    'use strict';

    const translates = {
        '\n        \n                    Databases and the Doctrine ORM\n        \n            ': '数据库和 Doctrine ORM',
        'Do you prefer video tutorials? Check out the Doctrine screencast series.': '你喜欢视频教程吗？请查看 <a href="https://symfonycasts.com/screencast/symfony-doctrine" class="reference external" rel="external noopener noreferrer" target="_blank">Doctrine 的屏幕录像</a>系列。',
        'Symfony provides all the tools you need to use databases in your applications\nthanks to Doctrine, the best set of PHP libraries to work with databases.\nThese tools support relational databases like MySQL and PostgreSQL and also\nNoSQL databases like MongoDB.': 'Symfony 提供了所有你需要在应用程序中使用数据库的工具，这要归功于 <a href="https://www.doctrine-project.org/" class="reference external" rel="external noopener noreferrer" target="_blank">Doctrine</a>，这是一套最佳的 PHP 库，用于与数据库一起工作。这些工具支持关系型数据库（如 MySQL 和 PostgreSQL）以及 NoSQL 数据库（如 MongoDB）。',
        'Databases are a broad topic, so the documentation is divided in three articles:': '数据库是一个广泛的主题，因此文档被分为三篇文章：',
        'This article explains the recommended way to work with relational databases\nin Symfony applications;': '本文解释了在 Symfony 应用程序中推荐使用的<strong>关系型数据库</strong>的工作方式；',
        "Read this other article if you need low-level access\nto perform raw SQL queries to relational databases (similar to PHP's PDO);": '如果你需要低级访问来执行对关系型数据库的原始 SQL 查询（类似于 PHP 的 <a href="https://www.php.net/pdo" class="reference external" rel="external noopener noreferrer" target="_blank">PDO</a>），请阅读<a href="doctrine/dbal.html" class="reference internal">另一篇文章</a>；',
        'Read DoctrineMongoDBBundle docs if you are working with MongoDB databases.': '如果你正在使用 <strong>MongoDB 数据库</strong>，请阅读 <a href="https://symfony.com/doc/current/bundles/DoctrineMongoDBBundle/index.html" class="reference external">DoctrineMongoDBBundle 的文档</a>。',

        'Installing Doctrine': '安装 Doctrine',
        'First, install Doctrine support via the orm Symfony pack,\nas well as the MakerBundle, which will help generate some code:': '首先，通过 <code translate="no" class="notranslate">orm</code> <a href="setup.html#symfony-packs" class="reference internal">Symfony pack</a> 安装 Doctrine 支持，并安装 MakerBundle，它将帮助生成一些代码：',

        'Configuring the Database': '配置数据库',
        'The database connection information is stored as an environment variable called\nDATABASE_URL. For development, you can find and customize this inside .env:':'数据库连接信息被存储为一个名为 <code translate="no" class="notranslate">DATABASE_URL</code> 的环境变量。对于开发环境，你可以在 <code translate="no" class="notranslate">.env</code> 文件中找到并自定义它：',
        "If the username, password, host or database name contain any character considered\nspecial in a URI (such as : / ? # [ ] @ ! $ & ' ( ) * + , ; =),\nyou must encode them. See RFC 3986 for the full list of reserved characters or\nuse the urlencode function to encode them. In this case you need to\nremove the resolve: prefix in config/packages/doctrine.yaml to avoid errors:\nurl: '%env(DATABASE_URL)%'": '如果用户名、密码、主机或数据库名包含 URI 中被视为特殊的任何字符（如 <code translate="no" class="notranslate">: / ? # [ ] @ ! $ &amp; \' ( ) * + , ; =</code>），则必须对它们进行编码。请参阅 <a href="https://www.ietf.org/rfc/rfc3986.txt" class="reference external" rel="external noopener noreferrer" target="_blank">RFC 3986</a> 以获取保留字符的完整列表，或使用 <a href="https://secure.php.net/manual/zh/function.urlencode.php" class="reference external" title="urlencode" rel="external noopener noreferrer" target="_blank">urlencode</a> 函数对它们进行编码。在这种情况下，你需要从 <code translate="no" class="notranslate">config/packages/doctrine.yaml</code> 中移除 <code translate="no" class="notranslate">resolve:</code> 前缀以避免错误：<code translate="no" class="notranslate">url: \'%env(DATABASE_URL)%\'</code>',
        'Now that your connection parameters are setup, Doctrine can create the db_name\ndatabase for you:': '既然您的连接参数已经设置好了，Doctrine 可以为您创建名为 <code translate="no" class="notranslate">db_name</code> 的数据库：',
        "There are more options in config/packages/doctrine.yaml that you can configure,\nincluding your server_version (e.g. 8.0.37 if you're using MySQL 8.0.37), which may\naffect how Doctrine functions.": '在 <code translate="no" class="notranslate">config/packages/doctrine.yaml</code> 中有更多的选项可以配置，包括您的 <code translate="no" class="notranslate">server_version</code>（例如，如果您使用的是 MySQL 8.0.37，则为 8.0.37），这可能会影响 Doctrine 的功能。',
        'There are many other Doctrine commands. Run php bin/console list doctrine\nto see a full list.': 'Doctrine 还有很多其它命令。运行 <code translate="no" class="notranslate">php bin/console list doctrine</code> 可以查看完整列表。',

        'Creating an Entity Class': '创建一个实体类',
        "Suppose you're building an application where products need to be displayed.\nWithout even thinking about Doctrine or databases, you already know that\nyou need a Product object to represent those products.": '假设你正在构建一个需要展示产品的应用程序。即使不去考虑 Doctrine 或数据库，你也知道你需要一个 <code translate="no" class="notranslate">Product</code> 对象来代表这些产品。',
        'You can use the make:entity command to create this class and any fields you\nneed. The command will ask you some questions - answer them like done below:': '你可以使用 <code translate="no" class="notranslate">make:entity</code> 命令来创建这个类以及你需要的任何字段。该命令会询问你一些问题，按照下面的方式回答即可：',
        'Whoa! You now have a new src/Entity/Product.php file:': '哇！你现在有了一个新的 <code translate="no" class="notranslate">src/Entity/Product.php</code> 文件：',
        "Starting in MakerBundle: v1.57.0 - You can pass either --with-uuid or\n--with-ulid to make:entity. Leveraging Symfony's Uid Component,\nthis generates an entity with the id type as Uuid\nor Ulid instead of int.": '从 <a href="https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html" class="reference external">MakerBundle</a> 的 v1.57.0 版本开始，你可以在 <code translate="no" class="notranslate">make:entity</code> 命令中使用 <code translate="no" class="notranslate">--with-uuid</code> 或 <code translate="no" class="notranslate">--with-ulid</code> 选项。利用 Symfony 的 <a href="components/uid.html" class="reference internal">Uid Component</a> 组件，这将生成一个实体，其 <code translate="no" class="notranslate">id</code> 类型为 <a href="components/uid.html#uuid" class="reference internal">Uuid</a> 或 <a href="components/uid.html#ulid" class="reference internal">Ulid</a>，而不是 <code translate="no" class="notranslate">int</code>。',
        'Starting in v1.44.0 - MakerBundle: only supports entities using PHP attributes.': '从 v1.44.0 版本开始 - <a href="https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html" class="reference external">MakerBundle</a> 仅支持使用 PHP 特性的实体。',
        "Confused why the price is an integer? Don't worry: this is just an example.\nBut, storing prices as integers (e.g. 100 = $1 USD) can avoid rounding issues.":'困惑为什么价格是整数吗？不用担心：这只是一个例子。但是，将价格存储为整数（例如，100 = 1美元）可以避免四舍五入的问题。',
        "If you are using an SQLite database, you'll see the following error:\nPDOException: SQLSTATE[HY000]: General error: 1 Cannot add a NOT NULL\ncolumn with default value NULL. Add a nullable=true option to the\ndescription property to fix the problem.": '如果你正在使用 SQLite 数据库，你可能会看到以下错误：PDOException: SQLSTATE[HY000]: General error: 1 Cannot add a NOT NULL column with default value NULL。要解决这个问题，你需要在 <code translate="no" class="notranslate">description</code> 属性上添加一个 <code translate="no" class="notranslate">nullable=true</code> 选项。',
        'There is a limit of 767 bytes for the index key prefix when using\nInnoDB tables in MySQL 5.6 and earlier versions. String columns with 255\ncharacter length and utf8mb4 encoding surpass that limit. This means\nthat any column of type string and unique=true must set its\nmaximum length to 190. Otherwise, you\'ll see this error:\n"[PDOException] SQLSTATE[42000]: Syntax error or access violation:\n1071 Specified key was too long; max key length is 767 bytes".': '在 MySQL 5.6 及更早版本中，当使用 InnoDB 表时，<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-limits.html" class="reference external" rel="external noopener noreferrer" target="_blank">索引键前缀的长度限制为 767 字节</a>。具有 255 个字符长度和 <code translate="no" class="notranslate">utf8mb4</code> 编码的字符串列会超过这个限制。这意味着任何类型为 <code translate="no" class="notranslate">string</code> 且 <code translate="no" class="notranslate">unique=true</code> 的列都必须将其最大长度设置为 <code translate="no" class="notranslate">190</code>。否则，你将看到此错误：“[PDOException] SQLSTATE[42000]: 语法错误或访问违规：1071 指定的键过长；最大键长度为 767 字节”。',
        'This class is called an "entity". And soon, you\'ll be able to save and query Product\nobjects to a product table in your database. Each property in the Product\nentity can be mapped to a column in that table. This is usually done with attributes:\nthe #[ORM\\Column(...)] comments that you see above each property:': '这个类被称为“实体”。很快，你就可以将 <code translate="no" class="notranslate">product</code> 对象保存到数据库中的产品表，并对这些对象进行查询。<code translate="no" class="notranslate">product</code> 实体中的每个属性都可以映射到该表中的一个列。这通常是通过属性来完成的：你在每个属性上方看到的 <code translate="no" class="notranslate">#[ORM\Column(...)]</code> 注释：',
        'The make:entity command is a tool to make life easier. But this is your code:\nadd/remove fields, add/remove methods or update configuration.': '<code translate="no" class="notranslate">make:entity</code> 命令是一个让生活更轻松的工具。但这是你的代码：添加/删除字段，添加/删除方法或更新配置。',
        "Doctrine supports a wide variety of field types, each with their own options.\nCheck out the list of Doctrine mapping types in the Doctrine documentation.\nIf you want to use XML instead of attributes, add type: xml and\ndir: '%kernel.project_dir%/config/doctrine' to the entity mappings in your\nconfig/packages/doctrine.yaml file.": 'Doctrine 支持多种字段类型，每种类型都有自己的选项。请查阅 Doctrine 文档中的 <a href="https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/basic-mapping.html#reference-mapping-types" class="reference external" rel="external noopener noreferrer" target="_blank">Doctrine 映射类型列表</a>。如果你想使用 XML 而不是属性，可以在你的 <code translate="no" class="notranslate">config/packages/doctrine.yaml</code> 文件中的实体映射中添加 <code translate="no" class="notranslate">type: xml</code> 和 <code translate="no" class="notranslate">dir: \'%kernel.project_dir%/config/doctrine\'</code>。',
        "Be careful not to use reserved SQL keywords as your table or column names\n(e.g. GROUP or USER). See Doctrine's Reserved SQL keywords documentation\nfor details on how to escape these. Or, change the table name with\n#[ORM\\Table(name: 'groups')] above the class or configure the column name with\nthe name: 'group_name' option.": '请注意，不要将保留的 SQL 关键字用作表名或列名（例如 <code translate="no" class="notranslate">GROUP</code> 或 <code translate="no" class="notranslate">USER</code>）。请参阅 Doctrine 的<a href="https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/basic-mapping.html#quoting-reserved-words" class="reference external" rel="external noopener noreferrer" target="_blank">保留 SQL 关键字文档</a>，了解如何转义这些关键字。或者，在类上方使用 <code translate="no" class="notranslate">#[ORM\Table(name: \'groups\')]</code> 来更改表名，或使用 <code translate="no" class="notranslate">name: \'group_name\'</code> 选项来配置列名。',

        'Migrations: Creating the Database Tables/Schema': '迁移：创建数据库表/模式',
        "The Product class is fully-configured and ready to save to a product table.\nIf you just defined this class, your database doesn't actually have the product\ntable yet. To add it, you can leverage the DoctrineMigrationsBundle, which is\nalready installed:": '<code translate="no" class="notranslate">Product</code> 类已完全配置好，并准备保存到 <code translate="no" class="notranslate">product</code> 表中。如果你刚刚定义了这个类，你的数据库实际上还没有 <code translate="no" class="notranslate">product</code> 表。要添加它，你可以利用已经安装的 <a href="https://github.com/doctrine/DoctrineMigrationsBundle" class="reference external" rel="external noopener noreferrer" target="_blank">DoctrineMigrationsBundle</a>：',
        'Starting in MakerBundle: v1.56.0 - Passing --formatted to make:migration\ngenerates a nice and tidy migration file.': '从 <a href="https://symfony.com/doc/current/bundles/SymfonyMakerBundle/index.html" class="reference external">MakerBundle</a> 的 v1.56.0 版本开始，向 <code translate="no" class="notranslate">make:migration</code> 命令传递 <code translate="no" class="notranslate">--formatted</code> 选项会生成一个整洁的迁移文件。',
        'If everything worked, you should see something like this:': '如果一切顺利，你应该会看到类似这样的内容：',
        'If you open this file, it contains the SQL needed to update your database! To run\nthat SQL, execute your migrations:': '如果你打开这个文件，它会包含更新数据库所需的 SQL 语句！要运行这些 SQL 语句，请执行你的迁移：',
        'This command executes all migration files that have not already been run against\nyour database. You should run this command on production when you deploy to keep\nyour production database up-to-date.': '这个命令会执行所有尚未在数据库上运行的迁移文件。当你部署到生产环境时，你应该在生产环境上运行此命令，以保持生产数据库的更新。',

        'Migrations & Adding more Fields': '迁移和添加更多字段',
        'But what if you need to add a new field property to Product, like a\ndescription? You can edit the class to add the new property. But, you can\nalso use make:entity again:': '但是，如果你需要给 <code translate="no" class="notranslate">Product</code> 添加一个新的字段属性，比如描述（<code translate="no" class="notranslate">description</code>），你当然可以编辑这个类来添加新的属性。但是，你同样可以再次使用 <code translate="no" class="notranslate">make:entity</code> 命令：',
        'This adds the new description property and getDescription() and setDescription()\nmethods:': '这会增加新的 <code translate="no" class="notranslate">description</code> 属性以及 <code translate="no" class="notranslate">getDescription()</code> 和 <code translate="no" class="notranslate">setDescription()</code> 方法：',
        "The new property is mapped, but it doesn't exist yet in the product table. No\nproblem! Generate a new migration:": '新属性已经被映射，但它尚未存在于产品表中。没问题！生成一个新的迁移：',
        'This time, the SQL in the generated file will look like this:': '这次，生成文件中的 SQL 将如下所示：',
        'The migration system is smart. It compares all of your entities with the current\nstate of the database and generates the SQL needed to synchronize them! Like\nbefore, execute your migrations:': '迁移系统是智能的。它会将您的所有实体与数据库的当前状态进行比较，并生成所需的 SQL 以同步它们！像以前一样，执行您的迁移：',
        'This will only execute the one new migration file, because DoctrineMigrationsBundle\nknows that the first migration was already executed earlier. Behind the scenes, it\nmanages a migration_versions table to track this.': '这只会执行一个新的迁移文件，因为 DoctrineMigrationsBundle 知道第一个迁移已经在此前执行过了。在幕后，它管理一个 <code translate="no" class="notranslate">migration_versions</code> 表来跟踪这一点。',
        'Each time you make a change to your schema, run these two commands to generate the\nmigration and then execute it. Be sure to commit the migration files and execute\nthem when you deploy.': '每次您对架构做出更改时，请运行这两个命令以生成迁移并执行它。确保在部署时提交迁移文件并执行它们。',
        'If you prefer to add new properties manually, the make:entity command can\ngenerate the getter & setter methods for you:': '如果您更喜欢手动添加新属性，那么 <code translate="no" class="notranslate">make:entity</code> 命令可以为您生成 getter 和 setter 方法：',
        'If you make some changes and want to regenerate all getter/setter methods,\nalso pass --overwrite.': '如果您做了一些更改并希望重新生成所有 getter/setter 方法，也请传递 <code translate="no" class="notranslate">--overwrite</code> 参数。',

        'Persisting Objects to the Database': '将对象持久化到数据库',
        "It's time to save a Product object to the database! Let's create a new controller\nto experiment:": '是时候将 <code translate="no" class="notranslate">Product</code> 对象保存到数据库了！让我们创建一个新的控制器来试验：',
        'Inside the controller, you can create a new Product object, set data on it,\nand save it:': '在控制器内部，您可以创建一个新的 <code translate="no" class="notranslate">Product</code> 对象，为其设置数据，然后保存它：',
        'Try it out!': '试试看！',
        'Congratulations! You just created your first row in the product table. To prove it,\nyou can query the database directly:': '恭喜你！你刚刚在 <code translate="no" class="notranslate">product</code> 表中创建了第一行数据。为了证明这一点，你可以直接查询数据库：',
        'Take a look at the previous example in more detail:': '更详细地查看前面的示例：',
        'line 13 The EntityManagerInterface $entityManager argument tells Symfony\nto inject the Entity Manager service into\nthe controller method. This object is responsible for saving objects to, and\nfetching objects from, the database.': '<strong>第 13 行</strong>：<code translate="no" class="notranslate">EntityManagerInterface $entityManager</code> 参数告诉 Symfony 将 <a href="service_container.html#services-constructor-injection" class="reference internal">Entity Manager 服务注入</a>到控制器方法中。这个对象负责将对象保存到数据库以及从数据库中获取对象。',
        'lines 15-18 In this section, you instantiate and work with the $product\nobject like any other normal PHP object.': '<strong>第 15-18 行</strong>：在这一部分，你像处理其它正常的 PHP 对象一样，对 <code translate="no" class="notranslate">$product</code> 对象进行实例化并操作它。',
        'line 21 The persist($product) call tells Doctrine to "manage" the\n$product object. This does not cause a query to be made to the database.': '<strong>第 21 行</strong>：<code translate="no" class="notranslate">persist($product)</code> 调用告诉 Doctrine 去“管理”<code translate="no" class="notranslate">$product</code> 对象。这并不会导致对数据库执行查询。',
        "line 24 When the flush() method is called, Doctrine looks through\nall of the objects that it's managing to see if they need to be persisted\nto the database. In this example, the $product object's data doesn't\nexist in the database, so the entity manager executes an INSERT query,\ncreating a new row in the product table.": '当调用 <code translate="no" class="notranslate">flush()</code> 方法时，Doctrine 会检查其管理的所有对象，看它们是否需要被保存到数据库中。在这个例子中，<code translate="no" class="notranslate">$product</code> 对象的数据在数据库中还不存在，所以实体管理器会执行一个 <code translate="no" class="notranslate">INSERT</code> 查询，在 <code translate="no" class="notranslate">product</code> 表中创建一行新数据。',
        'If the flush() call fails, a Doctrine\\ORM\\ORMException exception\nis thrown. See Transactions and Concurrency.': '如果 <code translate="no" class="notranslate">flush()</code> 调用失败，会抛出一个 <code translate="no" class="notranslate">Doctrine\ORM\ORMException</code> 异常。请参见<a href="https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/transactions-and-concurrency.html" class="reference external" rel="external noopener noreferrer" target="_blank">事务和并发性</a>。',
        "Whether you're creating or updating objects, the workflow is always the same: Doctrine\nis smart enough to know if it should INSERT or UPDATE your entity.": '无论你是在创建还是更新对象，工作流程都是一样的：Doctrine 足够智能，知道它应该插入还是更新你的实体。',

        'Validating Objects': '验证对象',
        'The Symfony validator can reuse Doctrine metadata to perform\nsome basic validation tasks. First, add or configure the\nauto_mapping option to define which\nentities should be introspected by Symfony to add automatic validation constraints.': '<a href="validation.html" class="reference internal">Symfony 验证器</a>可以重用 Doctrine 的元数据来执行一些基本的验证任务。首先，添加或配置 <a href="reference/configuration/framework.html#reference-validation-auto-mapping" class="reference internal">auto_mapping 选项</a>，以定义哪些实体应该由 Symfony 检查以添加自动验证约束。',
        'Consider the following controller code:': '考虑以下控制器代码：',
        "Although the Product entity doesn't define any explicit\nvalidation configuration, if the auto_mapping option\nincludes it in the list of entities to introspect, Symfony will infer some\nvalidation rules for it and will apply them.": '尽管 <code translate="no" class="notranslate">Product</code> 实体没有定义任何明确的<a href="validation.html" class="reference internal">验证配置</a>，但如果 <code translate="no" class="notranslate">auto_mapping</code> 选项将其包含在要检查的实体列表中，Symfony 将为其推断一些验证规则并应用它们。',
        "For example, given that the name property can't be null in the database, a\nNotNull constraint is added automatically\nto the property (if it doesn't contain that constraint already).": '例如，由于数据库中的 <code translate="no" class="notranslate">name</code> 属性不能为 <code translate="no" class="notranslate">null</code>，如果 <code translate="no" class="notranslate">name</code> 属性尚未包含该约束，则会自动为该属性添加一个 <a href="reference/constraints/NotNull.html" class="reference internal">NotNull 约束</a>。',
        'The following table summarizes the mapping between Doctrine metadata and\nthe corresponding validation constraints added automatically by Symfony:': '下表总结了 Doctrine 元数据与 Symfony 自动添加的相应验证约束之间的映射关系：',
        'Because the Form component as well as API Platform internally\nuse the Validator component, all your forms and web APIs will also automatically\nbenefit from these automatic validation constraints.': '由于<a href="forms.html" class="reference internal">表单组件</a>以及 <a href="https://api-platform.com/docs/core/validation/" class="reference external" rel="external noopener noreferrer" target="_blank">API 平台</a>内部都使用了验证器组件，因此你所有的表单和 Web API 也将自动受益于这些自动验证约束。',
        "This automatic validation is a nice feature to improve your productivity, but it\ndoesn't replace the validation configuration entirely. You still need to add\nsome validation constraints to ensure that data\nprovided by the user is correct.": '这种自动验证是一个提高生产力的好特性，但它并没有完全取代验证配置。你仍然需要添加一些<a href="reference/constraints.html" class="reference internal">验证约束</a>来确保用户提供的数据是正确的。',

        'Fetching Objects from the Database': '从数据库检索对象',
        'Fetching an object back out of the database is even easier. Suppose you want to\nbe able to go to /product/1 to see your new product:': '从数据库中检索对象更加简单。假设你想访问 <code translate="no" class="notranslate">/product/1</code> 来查看你的新产品：',
        "Another possibility is to use the ProductRepository using Symfony's autowiring\nand injected by the dependency injection container:": '另一种可能性是使用 <code translate="no" class="notranslate">ProductRepository</code>，通过 Symfony 的自动装配和依赖注入容器进行注入：',
        'When you query for a particular type of object, you always use what\'s known\nas its "repository". You can think of a repository as a PHP class whose only\njob is to help you fetch entities of a certain class.': '当你查询特定类型的对象时，你总是使用它的“存储库”。你可以将存储库视为一个 PHP 类，其唯一职责就是帮助你获取特定类的实体。',
        'Once you have a repository object, you have many helper methods:': '一旦你有了存储库对象，你就有了许多辅助方法：',
        'You can also add custom methods for more complex queries! More on that later in\nthe Databases and the Doctrine ORM section.': '你也可以为更复杂的查询添加自定义方法！稍后将在<a href="doctrine.html#doctrine-queries" class="reference internal">数据库和 Doctrine ORM</a> 部分详细介绍。',
        'When rendering an HTML page, the web debug toolbar at the bottom of the page\nwill display the number of queries and the time it took to execute them:': '在渲染 HTML 页面时，页面底部的 Web 调试工具栏将显示查询的数量和执行它们所需的时间：',
        "If the number of database queries is too high, the icon will turn yellow to\nindicate that something may not be correct. Click on the icon to open the\nSymfony Profiler and see the exact queries that were executed. If you don't\nsee the web debug toolbar, install the profiler Symfony pack\nby running this command: composer require --dev symfony/profiler-pack.": '如果数据库查询的数量过高，图标将变为黄色，表示可能存在问题。点击图标以打开 Symfony Profiler 并查看执行的确切查询。如果你没有看到 Web 调试工具栏，请通过运行此命令安装 <a href="setup.html#symfony-packs" class="reference internal">Symfony <code translate="no" class="notranslate">profiler</code> 包</a>：<code translate="no" class="notranslate">composer require --dev symfony/profiler-pack</code>。',
        'For more information, read the Symfony profiler documentation.': '有关更多信息，请参阅 <a href="profiler.html" class="reference internal">Symfony Profiler 文档</a>。',

        'Automatically Fetching Objects (EntityValueResolver)': '自动检索对象（EntityValueResolver）',
        'Entity Value Resolver was introduced in Symfony 6.2.': 'Entity Value Resolver 是在 Symfony 6.2 中引入的。',
        'Autowiring of the EntityValueResolver was introduced in DoctrineBundle 2.7.1.': '<code translate="no" class="notranslate">EntityValueResolver</code> 的自动装配是在 DoctrineBundle 2.7.1 中引入的。',
        'In many cases, you can use the EntityValueResolver to do the query for you\nautomatically! You can simplify the controller to:': '在许多情况下，你可以使用 <code translate="no" class="notranslate">EntityValueResolver</code> 自动为你执行查询！你可以将控制器简化为：',
        "That's it! The bundle uses the {id} from the route to query for the Product\nby the id column. If it's not found, a 404 page is generated.": '就这样！该包使用路由中的 <code translate="no" class="notranslate">{id}</code> 来通过 <code translate="no" class="notranslate">id</code> 列查询 <code translate="no" class="notranslate">Product</code>。如果找不到，将生成一个 404 页面。',
        "When enabled globally, it's possible to disable the behavior on a specific\ncontroller, by using the MapEntity set to disabled:": '当全局启用时，可以通过将 <code translate="no" class="notranslate">MapEntity</code> 设置为 <code translate="no" class="notranslate">disabled</code> 状态来在特定控制器上禁用此行为：',

        'Fetch Automatically': '自动检索',
        'If your route wildcards match properties on your entity, then the resolver\nwill automatically fetch them:': '如果你的路由通配符与实体上的属性匹配，那么解析器将自动获取它们：',
        'Automatic fetching works in these situations:': '在这些情况下，自动获取有效：',
        'If {id} is in your route, then this is used to fetch by\nprimary key via the find() method.': '如果你的路由中包含 <code translate="no" class="notranslate">{id}</code>，那么这将被用于通过 <code translate="no" class="notranslate">find()</code> 方法按主键获取。',
        'The resolver will attempt to do a findOneBy() fetch by using\nall of the wildcards in your route that are actually properties\non your entity (non-properties are ignored).': '解析器将尝试使用路由中所有实际上是你实体属性的通配符（非属性将被忽略）通过 <code translate="no" class="notranslate">findOneBy()</code> 方法进行获取。',
        'This behavior is enabled by default on all controllers. If you prefer, you can\nrestrict this feature to only work on route wildcards called id to look for\nentities by primary key. To do so, set the option\ndoctrine.orm.controller_resolver.auto_mapping to false.': '在所有控制器上默认启用此行为。如果你愿意，可以限制此功能仅对名为 <code translate="no" class="notranslate">id</code> 的路由通配符起作用，以便通过主键查找实体。为此，请将选项 <code translate="no" class="notranslate">doctrine.orm.controller_resolver.auto_mapping</code> 设置为 <code translate="no" class="notranslate">false</code>。',
        'When auto_mapping is disabled, you can configure the mapping explicitly for\nany controller argument with the MapEntity attribute. You can even control\nthe EntityValueResolver behavior by using the MapEntity options :': '当 <code translate="no" class="notranslate">auto_mapping</code> 被禁用时，你可以使用 <code translate="no" class="notranslate">MapEntity</code> 属性为任何控制器参数显式配置映射。你甚至可以通过使用 <a href="doctrine.html#mapentity-options" class="reference internal">MapEntity 选项</a>来控制 <code translate="no" class="notranslate">EntityValueResolver</code> 的行为：',

        'Fetch via an Expression': '通过表达式检索',
        "If automatic fetching doesn't work for your use case, you can write an expression\nusing the ExpressionLanguage component:": '如果自动获取不适用于你的用例，你可以使用 <a href="components/expression_language.html" class="reference internal">ExpressionLanguage 组件</a>编写一个表达式：',
        "In the expression, the repository variable will be your entity's\nRepository class and any route wildcards - like {product_id} are\navailable as variables.": '在表达式中，<code translate="no" class="notranslate">repository</code> 变量将是你实体的 Repository 类，任何路由通配符（如 <code translate="no" class="notranslate">{product_id}</code>）都可用作变量。',
        'This can also be used to help resolve multiple arguments:': '这也可以用来帮助解析多个参数：',
        'In the example above, the $product argument is handled automatically,\nbut $comment is configured with the attribute since they cannot both follow\nthe default convention.': '在上面的示例中，<code translate="no" class="notranslate">$product</code> 参数是自动处理的，但 <code translate="no" class="notranslate">$comment</code> 是使用属性配置的，因为它们不能都遵循默认约定。',
        "If you need to get other information from the request to query the database, you\ncan also access the request in your expression thanks to the request\nvariable. Let's say you want the first or the last comment of a product depending on a query parameter named sort:": '如果你需要从请求中获取其它信息来查询数据库，由于 <code translate="no" class="notranslate">request</code> 变量的存在，你还可以在表达式中访问请求。假设你想根据名为 <code translate="no" class="notranslate">sort</code> 的查询参数来获取产品的第一条或最后一条评论：',
        'The support for the request variable in expressions was introduced\nin Symfony 6.4.': '表达式中对 <code translate="no" class="notranslate">request</code> 变量的支持是在 Symfony 6.4 中引入的。',

        'MapEntity Options': 'MapEntity 选项',
        'A number of options are available on the MapEntity attribute to\ncontrol behavior:': '<code translate="no" class="notranslate">MapEntity</code> 属性提供了许多选项来控制行为：',
        'If an id option is configured and matches a route parameter, then\nthe resolver will find by the primary key:': '如果配置了 <code translate="no" class="notranslate">id</code> 选项并且与路由参数匹配，则解析器将按主键查找：',
        'Configures the properties and values to use with the findOneBy()\nmethod: the key is the route placeholder name and the value is the Doctrine\nproperty name:': '配置要与 <code translate="no" class="notranslate">findOneBy()</code> 方法一起使用的属性和值：键是路由占位符名称，值是 Doctrine 属性名称：',
        'Configures the properties that should be used in the findOneBy()\nmethod by excluding one or more properties so that not all are used:': '通过排除一个或多个属性来配置应在 <code translate="no" class="notranslate">findOneBy()</code> 方法中使用的属性，以便不使用所有属性：',
        '\n                            If true, then when findOneBy() is used, any values that are\nnull will not be used for the query.\n                    ': '如果为 true，则在使用 <code translate="no" class="notranslate">findOneBy()</code> 时，任何值为 <code translate="no" class="notranslate">null</code> 的属性都不会用于查询。',
        'By default, the EntityValueResolver uses the default\nobject manager, but you can configure this:': '默认情况下，<code translate="no" class="notranslate">EntityValueResolver</code> 使用默认的对象管理器，但你可以进行配置：',
        '\n                            If true, forces Doctrine to always fetch the entity from the database\ninstead of cache.\n                    ': '如果为 true，则强制 Doctrine 始终从数据库中获取实体而不是从缓存中获取。',
        '\n                            If true, the EntityValueResolver will not try to replace the argument.\n                    ': '如果为 true，则 <code translate="no" class="notranslate">EntityValueResolver</code> 不会尝试替换参数。',

        'Updating an Object': '更新一个对象',
        "Once you've fetched an object from Doctrine, you interact with it the same as\nwith any PHP model:": '一旦你从 Doctrine 中检索到对象，你就可以像与任何 PHP 模型一样与它进行交互：',
        'Using Doctrine to edit an existing product consists of three steps:': '使用 Doctrine 编辑现有产品包括三个步骤：',
        'fetching the object from Doctrine;': '从 Doctrine 中检索对象；',
        'modifying the object;': '修改对象；',
        'calling flush() on the entity manager.': '在实体管理器上调用 <code translate="no" class="notranslate">flush()</code>。',
        'You can call $entityManager->persist($product), but it isn\'t necessary:\nDoctrine is already "watching" your object for changes.': '你可以调用 <code translate="no" class="notranslate">$entityManager-&gt;persist($product)</code>，但这并不是必需的：Doctrine 已经在“监视”你的对象以获取更改。',

        'Deleting an Object': '删除一个对象',
        'Deleting an object is very similar, but requires a call to the remove()\nmethod of the entity manager:': '删除对象非常相似，但需要调用实体管理器的 <code translate="no" class="notranslate">remove()</code> 方法：',
        "As you might expect, the remove() method notifies Doctrine that you'd\nlike to remove the given object from the database. The DELETE query isn't\nactually executed until the flush() method is called.": '正如你可能所预料的那样，<code translate="no" class="notranslate">remove()</code> 方法通知 Doctrine 你希望从数据库中删除给定对象。直到调用 <code translate="no" class="notranslate">flush()</code> 方法时，才会实际执行 <code translate="no" class="notranslate">DELETE</code> 查询。',

        'Querying for Objects: The Repository': '查询对象：仓库',
        "You've already seen how the repository object allows you to run basic queries\nwithout any work:": '你已经看到了存储库对象如何允许你无需任何工作即可运行基本查询：',
        'But what if you need a more complex query? When you generated your entity with\nmake:entity, the command also generated a ProductRepository class:': '但如果你需要一个更复杂的查询怎么办？当你使用 <code translate="no" class="notranslate">make:entity</code> 生成实体时，命令还会生成一个 <code translate="no" class="notranslate">ProductRepository</code> 类：',
        'When you fetch your repository (i.e. ->getRepository(Product::class)), it is\nactually an instance of this object! This is because of the repositoryClass\nconfig that was generated at the top of your Product entity class.': '当你检索你的存储库（即 <code translate="no" class="notranslate">-&gt;getRepository(Product::class)</code>）时，它实际上是此对象的一个实例！这是因为你的 <code translate="no" class="notranslate">Product</code> 实体类顶部生成的 <code translate="no" class="notranslate">repositoryClass</code> 配置。',
        'Suppose you want to query for all Product objects greater than a certain price. Add\na new method for this to your repository:': '假设你想要查询价格大于某个值的所有 Product 对象。在你的存储库中添加一个新方法来实现这一点：',
        'The string passed to createQuery() might look like SQL, but it is\nDoctrine Query Language. This allows you to type queries using commonly\nknown query language, but referencing PHP objects instead (i.e. in the FROM\nstatement).': '传递给 <code translate="no" class="notranslate">createQuery()</code> 的字符串可能看起来像 SQL，但它实际上是 <a href="https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/dql-doctrine-query-language.html" class="reference external" rel="external noopener noreferrer" target="_blank">Doctrine 查询语言</a>。这允许你使用众所周知的查询语言编写查询，但引用的是 PHP 对象（即在 <code translate="no" class="notranslate">FROM</code> 语句中）。',
        'Now, you can call this method on the repository:': '现在，你可以在存储库上调用这个方法：',
        'See Service Container for how to inject the repository into\nany service.': '请参阅<a href="service_container.html#services-constructor-injection" class="reference internal">服务容器</a>以了解如何将存储库注入到任何服务中。',

        'Querying with the Query Builder': '使用查询生成器查询',
        'Doctrine also provides a Query Builder, an object-oriented way to write\nqueries. It is recommended to use this when queries are built dynamically (i.e.\nbased on PHP conditions):': 'Doctrine 还提供了一个<a href="https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/query-builder.html" class="reference external" rel="external noopener noreferrer" target="_blank">查询构建器</a>，这是一种面向对象的编写查询的方式。建议在动态构建查询（即基于 PHP 条件）时使用它：',

        'Querying with SQL': '使用 SQL 查询',
        'In addition, you can query directly with SQL if you need to:': '此外，如果你需要，也可以直接使用 SQL 进行查询：',
        'With SQL, you will get back raw data, not objects (unless you use the NativeQuery\nfunctionality).': '使用 SQL，你将获得原始数据，而不是对象（除非你使用 <a href="https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/native-sql.html" class="reference external" rel="external noopener noreferrer" target="_blank">NativeQuery</a> 功能）。',

        'Configuration': '配置',
        'See the Doctrine config reference.': '请参阅 <a href="reference/configuration/doctrine.html" class="reference internal">Doctrine 配置参考</a>。',

        'Relationships and Associations': '关系和关联',
        'Doctrine provides all the functionality you need to manage database relationships\n(also known as associations), including ManyToOne, OneToMany, OneToOne and ManyToMany\nrelationships.': 'Doctrine 提供了管理数据库关系（也称为关联）所需的所有功能，包括 ManyToOne、OneToMany、OneToOne 和 ManyToMany 关系。',
        'For info, see How to Work with Doctrine Associations / Relations.': '有关信息，请参阅<a href="doctrine/associations.html" class="reference internal">如何与 Doctrine 关联/关系一起工作</a>。',

        'Database Testing': '数据库测试',
        'Read the article about testing code that interacts with the database.': '阅读有关<a href="testing/database.html" class="reference internal">测试与数据库交互的代码</a>的文章。',

        'Doctrine Extensions (Timestampable, Translatable, etc.)': 'Doctrine 扩展（Timestampable、Translatable 等）',
        'Doctrine community has created some extensions to implement common needs such as\n"set the value of the createdAt property automatically when creating an entity".\nRead more about the available Doctrine extensions and use the\nStofDoctrineExtensionsBundle to integrate them in your application.': 'Doctrine 社区创建了一些扩展来实现常见需求，例如“在创建实体时自动设置 createdAt 属性的值”。阅读有关<a href="https://github.com/doctrine-extensions/DoctrineExtensions" class="reference external" rel="external noopener noreferrer" target="_blank">可用 Doctrine 扩展</a>的更多信息，并使用 <a href="https://github.com/stof/StofDoctrineExtensionsBundle" class="reference external" rel="external noopener noreferrer" target="_blank">StofDoctrineExtensionsBundle</a> 在你的应用程序中集成它们。',

        'Learn more': '了解更多',
        'How to Work with Doctrine Associations / Relations': '<a href="doctrine/associations.html">如何使用 Doctrine 关联/关系工作</a>',
        'Doctrine Events': '<a href="doctrine/events.html">Doctrine 事件</a>',
        'How to Implement a Registration Form': '<a href="doctrine/registration_form.html">如何实现注册表单</a>',
        'How to Register custom DQL Functions': '<a href="doctrine/custom_dql_functions.html">如何注册自定义的 DQL 函数</a>',
        'How to Use Doctrine DBAL': '<a href="doctrine/dbal.html">如何使用 Doctrine DBAL</a>',
        'How to Work with Multiple Entity Managers and Connections': '<a href="doctrine/multiple_entity_managers.html">如何使用多个实体管理器和连接工作</a>',
        'How to Define Relationships with Abstract Classes and Interfaces': '<a href="doctrine/resolve_target_entity.html">如何使用抽象类和接口定义关系</a>',
        'How to Generate Entities from an Existing Database': '<a href="doctrine/reverse_engineering.html">如何从现有数据库生成实体</a>',
        'How to Test A Doctrine Repository': '<a href="testing/database.html">如何测试 Doctrine 存储库</a>',
    };

    fanyi(translates, 1, true);
})($);
